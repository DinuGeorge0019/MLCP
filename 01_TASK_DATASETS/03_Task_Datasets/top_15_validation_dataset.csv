problem_statement,problem_solution,tags,dificulty
During the research on properties of the greatest common divisor of a set of numbers Ildar a famous mathematician introduced a brand new concept of the weakened common divisor of a list of pairs of integers For a given list of pairs of integers a 1 b 1 a 2 b 2 a n b n their is arbitrary integer greater than 1 such that it divides at least one element in each pair WCD may not exist for some lists For example if the list looks like 12 15 25 18 10 24 then their WCD can be equal to 2 3 5 or 6 each of these numbers is strictly greater than 1 and divides at least one number in each pair You re currently pursuing your PhD degree under Ildar s mentorship and that s why this problem was delegated to you Your task is to calculate efficiently ,"['#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<""=""<<h<<""\\n""; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != \',\')cerr<<*sdbg++; cerr<<""=""<<h<<"",""; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<"" = ""; FORE(itt, (x)) cerr <<*itt <<"", ""; cerr <<""\\n""; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << ""("" << pair.first << "", "" << pair.second << "")"";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << ""("" << t.st << "", "" << t.nd << "", "" << t.rd << "")""; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\n\nconst int N = 1e6 + 5;\nint a[N], b[N];\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  int g = 0;\n  RE (i, n) {\n    cin>>a[i]>>b[i];\n    g = __gcd(g, a[i] * b[i]);\n  }\n  if (g == 1) {\n    cout<<""-1\\n"";\n    return 0;\n  }\n  RE (i, n) {\n    int cand = __gcd(g, a[i]);\n    if (cand > 1) {\n      g = cand;\n    }\n    cand = __gcd(g, b[i]);\n    if (cand > 1) {\n      g = cand;\n    }\n  }\n  cout<<g<<endl;\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]",1600
There are Imperial stormtroopers on the field The battle field is a plane with Cartesian coordinate system Each stormtrooper is associated with his coordinates on this plane Han Solo has the newest duplex lazer gun to fight these stormtroopers It is situated at the point In one shot it can can destroy all the stormtroopers situated on some line that crosses point Your task is to determine what minimum number of shots Han Solo needs to defeat all the stormtroopers The gun is the newest invention it shoots very quickly and even after a very large number of shots the stormtroopers don t have enough time to realize what s happening and change their location ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\n#define y0 asdfasdfsd\nconst int N=1010;\nint n,x0,y0,x[N],y[N],cnt;\nbool vis[N];\nint main() {\n\tscanf(""%d"",&n);\n\tscanf(""%d%d"",&x0,&y0);\n\trep(i,0,n) {\n\t\tscanf(""%d%d"",x+i,y+i);\n\t\tx[i]-=x0; y[i]-=y0;\n\t}\n\trep(i,0,n) if (!vis[i]) {\n\t\tcnt++;\n\t\trep(j,0,n) if (!vis[j]&&x[i]*y[j]==x[j]*y[i]) vis[j]=1;\n\t}\n\tprintf(""%d\\n"",cnt);\n}\n']","[0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1400
You have a string a and a string b Both of the strings have length n There are in the string a You also have a set Q Initially the set Q is empty You can apply the following operation on the string a any number of times Choose an index i 1 leq i leq n and a lowercase English letter c Add a i to the set Q and then replace a i with c For example Let the string a be tt abecca We can do the following operations In the first operation if you choose i 3 and c tt x the character a 3 tt e will be added to the set Q So the set Q will be tt e and the string a will be tt ab underline x cca In the second operation if you choose i 6 and c tt s the character a 6 tt a will be added to the set Q So the set Q will be tt e tt a and the string a will be tt abxcc underline s You can apply any number of operations on a but in the end the set Q should contain Under this constraint you have to maximize the number of integer pairs l r 1 leq l leq r leq n such that a l r b l r Here s l r means the substring of string s starting at index l inclusively and ending at index r inclusively ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n//inline int fastpow(int x, int y){\n//\tint z=1;\n//\tfor (; y; y>>=1,x=1ll*x*x%mod)\n//\t\tif (y&1) z=1ll*z*x%mod;\n//\treturn z;\n//}\nint T,n,k;\nchar a[200005],b[200005];\nint ch[100],seq[100],vis[100];\nint main(){\n\tfor (cin>>T; T; T--){\n\t\tscanf(""%d%d%s%s"",&n,&k,a+1,b+1);\n\t\tint len=0; ll ans=0;\n\t\tfor (int i=1; i<=n; i++) vis[a[i]-\'a\']=1;\n\t\tfor (int i=0; i<26; i++)\n\t\t\tif (vis[i]) seq[++len]=i;\n\t\tk=min(k,len);\n\t\tfor (int i=0; i<(1<<len); i++)\n\t\t\tif (__builtin_popcount(i)==k){\n\t\t\t\tfor (int j=0; j<len; j++)\n\t\t\t\t\tif (i&(1<<j)) ch[seq[j+1]]=1;\n\t\t\t\tint pre=1; ll sum=0;\n\t\t\t\tfor (int j=1; j<=n; j++){\n\t\t\t\t\tif (a[j]!=b[j] && !ch[a[j]-\'a\']) pre=j+1;\n\t\t\t\t\tsum+=j-pre+1;\n\t\t\t\t}\n\t\t\t\tans=max(ans,sum);\n\t\t\t\tfor (int j=0; j<len; j++)\n\t\t\t\t\tif (i&(1<<j)) ch[seq[j+1]]=0;\n\t\t\t}\n\t\tprintf(""%lld\\n"",ans);\n\t\tfor (int i=0; i<26; i++) vis[i]=0;\n\t}\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]",1600
Inna and Dima bought a table of size in the shop Each cell of the table contains a single letter Inna loves Dima so she wants to go through his name as many times as possible as she moves through the table For that Inna acts as follows initially Inna chooses some cell of the table where letter is written then Inna can move to some side adjacent table cell that contains letter then from this cell she can go to one of the side adjacent table cells that contains the written letter then she can go to a side adjacent cell that contains letter Then Inna assumes that she has gone through her sweetheart s name Inna s next move can be going to one of the side adjacent table cells that contains letter and then walk on through name DIMA in the similar manner Inna never skips a letter So from the letter she always goes to the letter from the letter she always goes the to letter from the letter she always goes to the letter and from the letter she always goes to the letter Depending on the choice of the initial table cell Inna can go through name DIMA either an infinite number of times or some positive finite number of times or she can t go through his name once Help Inna find out what maximum number of times she can go through name DIMA ,"['/** Micro Mezzo Macro Flation -- Overheated Economy ., Last Update: Feb. 12th 2013 **/ //{\n\n/** Header .. **/ //{\n#define LOCAL\n\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<int(n);++i)\n#define FOR(i, a, b) for (int i=int(a);i<int(b);++i)\n#define DWN(i, b, a) for (int i=int(b-1);i>=int(a);--i)\n#define REP_1(i, n) for (int i=1;i<=int(n);++i)\n#define FOR_1(i, a, b) for (int i=int(a);i<=int(b);++i)\n#define DWN_1(i, b, a) for (int i=int(b);i>=int(a);--i)\n#define REP_C(i, n) for (int n____=int(n),i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=int(b),i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=int(a),i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<int(n);++i)\n#define FOR_N(i, a, b) for (i=int(a);i<int(b);++i)\n#define DWN_N(i, b, a) for (i=int(b-1);i>=int(a);--i)\n#define REP_1_C(i, n) for (int n____=int(n),i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=int(b),i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=int(a),i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=int(n);++i)\n#define FOR_1_N(i, a, b) for (i=int(a);i<=int(b);++i)\n#define DWN_1_N(i, b, a) for (i=int(b);i>=int(a);--i)\n#define REP_C_N(i, n) for (int n____=(i=0,int(n));i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,int(b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,int(a));i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,int(n));i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=1,int(b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,int(a));i>=a____;--i)\n\n#define ECH(it, A) for (__typeof(A.begin()) it=A.begin(); it != A.end(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, nxt) for (int i=hd;i;i=nxt[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define DO(n) for ( int ____n ## __line__ = n; ____n ## __line__ -- ; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define BSC(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int(A.size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define fi first\n#define se second\n\n#define Rush for(int ____T=RD(); ____T--;)\n\n#define Display(A, n, m) {                      \\\n\tREP(i, n){\t\t                            \\\n        REP(j, m) cout << A[i][j] << "" "";       \\\n        cout << endl;\t\t\t\t            \\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#define Display_1(A, n, m) {\t\t\t\t    \\\n\tREP_1(i, n){\t\t                        \\\n        REP_1(j, m) cout << A[i][j] << "" "";     \\\n\t\tcout << endl;\t\t            \t\t\\\n\t}\t\t\t\t\t\t                    \\\n}\n\n#pragma comment(linker, ""/STACK:36777216"")\n//#pragma GCC optimize (""O2"")\n#define Ruby system(""ruby main.rb"")\n#define Haskell system(""runghc main.hs"")\n#define Python system(""python main.py"")\n#define Pascal system(""fpc main.pas"")\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned UINT;\ntypedef unsigned long long ULL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf("" %c"", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &x){\n    char c; for (c = getchar(); c < \'-\'; c = getchar());\n    if (c == \'-\'){x = \'0\' - getchar(); for (c = getchar(); \'0\' <= c && c <= \'9\'; c = getchar()) x = x * 10 + \'0\' - c;}\n    else {x = c - \'0\'; for (c = getchar(); \'0\' <= c && c <= \'9\'; c = getchar()) x = x * 10 + c - \'0\';}\n    return x;\n}\n\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline void RDD(const T0&a, const T1&b){RDD(a),RDD(b);}\ntemplate<class T0,class T1,class T2>inline void RDD(const T0&a, const T1&b, const T2&c){RDD(a),RDD(b),RDD(c);}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C B){sort(ALL(A), B); return A;}\ntemplate<class T> inline T& UNQ(T &A){A.resize(unique(ALL(SRT(A)))-A.begin());return A;}\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int dx4[] = {-1, 0, 1, 0};\nconst int dy4[] = {0, 1, 0, -1};\n\nconst int dx8[] = {-1, 0, 1, 0 , -1 , -1 , 1 , 1};\nconst int dy8[] = {0, 1, 0, -1 , -1 , 1 , -1 , 1};\n\nconst int dxhorse[] = {-2 , -2 , -1 , -1 , 1 , 1 , 2 , 2};\nconst int dyhorse[] = {1 ,  -1 , 2  , -2 , 2 ,-2 , 1 ,-1};\n\nconst int MOD = 1000000007;\n//int MOD = 99990001;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 1LL << 60;\nconst DB EPS = 1e-9;\nconst DB OO = 1e15;\nconst DB PI = acos(-1.0); //M_PI;\n\n//}\n\n/** Add On .. **/ //{\n// <<= \'0. Nichi Joo ., //{\ntemplate<class T> inline void checkMin(T &a,const T b){if (b<a) a=b;}\ntemplate<class T> inline void checkMax(T &a,const T b){if (a<b) a=b;}\ntemplate<class T> inline void checkMin(T &a, T &b, const T x){checkMin(a, x), checkMin(b, x);}\ntemplate<class T> inline void checkMax(T &a, T &b, const T x){checkMax(a, x), checkMax(b, x);}\ntemplate <class T, class C> inline void checkMin(T& a, const T b, C c){if (c(b,a)) a = b;}\ntemplate <class T, class C> inline void checkMax(T& a, const T b, C c){if (c(a,b)) a = b;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ninline int ceil(int x, int y){return (x - 1) / y + 1;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n//}\n// <<= \'1. Bitwise Operation ., //{\nnamespace BO{\n\ninline bool _1(int x, int i){return bool(x&1<<i);}\ninline bool _1(LL x, int i){return bool(x&1LL<<i);}\ninline LL _1(int i){return 1LL<<i;}\ninline LL _U(int i){return _1(i) - 1;};\n\ninline int reverse_bits(int x){\n    x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n    x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n    x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n    x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n    return x;\n}\n\ninline LL reverse_bits(LL x){\n    x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n    x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n    x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n    x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n    x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n    x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n    return x;\n}\n\ntemplate<class T> inline bool odd(T x){return x&1;}\ntemplate<class T> inline bool even(T x){return !odd(x);}\ntemplate<class T> inline T low_bit(T x) {return x & -x;}\ntemplate<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\ntemplate<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n\ninline int low_idx(int x){return __builtin_ffs(x);}\ninline int low_idx(LL x){return __builtin_ffsll(x);}\ninline int high_idx(int x){return low_idx(reverse_bits(x));}\ninline int high_idx(LL x){return low_idx(reverse_bits(x));}\ninline int clz(int x){return __builtin_clz(x);}\ninline int clz(LL x){return __builtin_clzll(x);}\ninline int ctz(int x){return __builtin_ctz(x);}\ninline int ctz(LL x){return __builtin_ctzll(x);}\ninline int parity(int x){return __builtin_parity(x);}\ninline int parity(LL x){return __builtin_parityll(x);}\ninline int lg2(int a){return 31 - clz(a);}\ninline int lg2(LL a){return 63 - clz(a);}\ninline int count_bits(int x){return __builtin_popcount(x);}\ninline int count_bits(LL x){return __builtin_popcountll(x);}\n\n} using namespace BO;//}\n// <<= \'2. Number Theory .,//{\nnamespace NT{\ninline LL __lcm(LL a, LL b){return a*b/__gcd(a,b);}\ninline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\ninline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\ninline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\ninline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\ninline void MUL(int &a, int b){a = (LL)a * b % MOD;}\ninline int pdt(int a, int b){return (LL)a * b % MOD;}\n\ninline int sum(int a, int b, int c){return sum(sum(a, b), c);}\ninline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\ninline int pdt(int a, int b, int c){return pdt(pdt(a, b), c);}\ninline int pdt(int a, int b, int c, int d){return pdt(pdt(pdt(a, b), c), d);}\n\ninline int pow(int a, int b){\n    int c(1); while (b){\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ninline int pow(int a, LL b){\n    int c(1); while (b){\n        if (b&1) MUL(c, a);\n        MUL(a, a), b >>= 1;\n    }\n    return c;\n}\n\ntemplate<class T> inline T pow(T a, LL b){\n    T c(1); while (b){\n        if (b&1) c *= a;\n        a *= a, b >>= 1;\n    }\n    return c;\n}\n\ninline int _I(int b){\n    int a = MOD, x1 = 0, x2 = 1, q;\n    while (true){\n        q = a / b, a %= b;\n        if (!a) return (x2 + MOD) % MOD;\n        DEC(x1, pdt(q, x2));\n\n        q = b / a, b %= a;\n        if (!b) return (x1 + MOD) % MOD;\n        DEC(x2, pdt(q, x1));\n    }\n}\n\ninline void DIV(int &a, int b){MUL(a, _I(b));}\ninline int qtt(int a, int b){return pdt(a, _I(b));}\n\ninline int phi(int n){\n    int res = n; for (int i=2;sqr(i)<=n;++i) if (!(n%i)){\n        DEC(res, qtt(res, i));\n        do{n /= i;} while(!(n%i));\n    }\n    if (n != 1)\n        DEC(res, qtt(res, n));\n    return res;\n}\n\n} using namespace NT;//}\n//}\n\n/** Miscellaneous .. **/ //{\n// <<= \'Random Event .. . //{\nnamespace RNG{\n//srand((unsigned)time(NULL));\ninline unsigned int rand16(){return ((rand()) << 15) ^ rand();}\ninline unsigned int rand32(){return (rand16() << 16) | rand16();}\ninline ULL rand64(){return ((LL)rand32() << 32) | rand32();}\ninline ULL random(LL l, LL r){return l == r ? l : rand64() % (r - l) + l;}\nint dice(){return rand() % 6;}\nbool coin(){return bool(rand() % 2);}\n} using namespace RNG;\n//}\n// <<= \'Clock .. . //{\nnamespace CLOCK{\nDB s0, s1, rd, k, T;\ninline DB getTime(){\n#ifdef LOCAL\n    return 1.0 * clock() / CLOCKS_PER_SEC;\n#else\n    timeval tv;\n    gettimeofday(&tv, 0);\n    return tv.tv_sec + tv.tv_usec * 1e-6;\n#endif\n}\n\ninline void st0(DB _T = 0.98){T = _T, s0 = getTime();}\ninline void st1(DB _k = 1.618){k = _k, s1 = getTime();}\ninline void ed1(){rd = getTime() - s1;}\ninline DB elapsed(){return getTime() - s0;}\ninline bool safe(){return elapsed() + rd * k < T;}\n} //using namespace CLOCK;\n//}\n// <<= \'Temp .. . //{\nnamespace TMP{\ntemplate<class T> PTT operator+(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi + p2.fi, p1.se + p2.se);\n}\n\ntemplate<class T> PTT operator-(const PTT &p1, const PTT &p2) {\n\treturn PTT(p1.fi - p2.fi, p1.se - p2.se);\n}\n\ntemplate<class T> PTT operator*(const PTT &lhs, T k){\n    return PTT(lhs.fi * k, lhs.se * k);\n}\n} using namespace TMP;\n//}\n//}\n\n/** Algorithm    .. */ //{\n// <<= \'-. Math .,//{\nnamespace Math{\n\ttypedef long long typec;\n\t///Lib functions\n\ttypec GCD(typec a, typec b)\n\t{\n\t\treturn b ? GCD(b, a % b) : a;\n\t}\n\ttypec extendGCD(typec a, typec b, typec& x, typec& y)\n\t{\n\t\tif(!b) return x = 1, y = 0, a;\n\t\ttypec res = extendGCD(b, a % b, x, y), tmp = x;\n\t\tx = y, y = tmp - (a / b) * y;\n\t\treturn res;\n\t}\n\t///for x^k\n\ttypec power(typec x, typec k)\n\t{\n\t\ttypec res = 1;\n\t\twhile(k)\n\t\t{\n\t\t\tif(k&1) res *= x;\n\t\t\tx *= x, k >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\t///for x^k mod m\n\ttypec powerMod(typec x, typec k, typec m)\n\t{\n\t\ttypec res = 1;\n\t\twhile(x %= m, k)\n\t\t{\n\t\t\tif(k&1) res *= x, res %= m;\n\t\t\tx *= x, k >>=1;\n\t\t}\n\t\treturn res;\n\t}\n\t/***************************************\n\tInverse in mod p^t system\n\t***************************************/\n\ttypec inverse(typec a, typec p, typec t = 1)\n\t{\n\t\ttypec pt = power(p, t);\n\t\ttypec x, y;\n\t    y = extendGCD(a, pt, x, y);\n\t\treturn x < 0 ? x += pt : x;\n\t}\n\t/***************************************\n\tLinear congruence theorem\n\tx = a (mod p)\n\tx = b (mod q)\n\tfor gcd(p, q) = 1, 0 <= x < pq\n\t***************************************/\n\ttypec linearCongruence(typec a, typec b, typec p, typec q)\n\t{\n\t\ttypec x, y;\n\t\ty = extendGCD(p, q, x, y);\n\t\twhile(b < a) b += q / y;\n\t\tx *= b - a, x = p * x + a, x %= p * q;\n\t\tif(x < 0) x += p * q;\n\t\treturn x;\n\t}\n\t/***************************************\n\tprime table\n\tO(n)\n\t***************************************/\n\tconst int PRIMERANGE = 1000000;\n\tint prime[PRIMERANGE + 1];\n\tint mobius[PRIMERANGE + 1];\n\tint getPrime()\n\t{\n\t\tmemset (prime, 0, sizeof (int) * (PRIMERANGE + 1));\n\t\tmemset(mobius , 0 , sizeof(mobius));\n\t\tmobius[1] = 1;\n\t\tfor (int i = 2; i <= PRIMERANGE; i++)\n\t\t{\n\t\t\tif (!prime[i]) prime[++prime[0]] = i , mobius[i] = -1;\n\t\t\tfor (int j = 1; j <= prime[0] && prime[j] <= PRIMERANGE / i; j++)\n\t\t\t{\n\t\t\t\tprime[prime[j]*i] = 1;\n\t\t\t\tif (i % prime[j] == 0) break;\n\t\t\t\telse mobius[i * prime[j]] = -mobius[i];\n\t\t\t}\n\t\t}\n\t\treturn prime[0];\n\t}\n\t/***************************************\n\tget factor of n\n\tO(sqrt(n))\n\tfactor[][0] is prime factor\n\tfactor[][1] is factor generated by this prime\n\tfactor[][2] is factor counter\n\n\tneed: Prime Table\n\t***************************************/\n\t///you should init the prime table before\n\tint factor[100][3], facCnt;\n\tint getFactors(int x)\n\t{\n\t\tfacCnt = 0;\n\t\tint tmp = x;\n\t\tfor(int i = 1; prime[i] <= tmp / prime[i]; i++)\n\t\t{\n\t\t\tfactor[facCnt][1] = 1, factor[facCnt][2] = 0;\n\t\t\tif(tmp % prime[i] == 0)\n\t\t\t\tfactor[facCnt][0] = prime[i];\n\t\t\twhile(tmp % prime[i] == 0)\n\t\t\t\tfactor[facCnt][2]++, factor[facCnt][1] *= prime[i], tmp /= prime[i];\n\t\t\tif(factor[facCnt][1] > 1) facCnt++;\n\t\t}\n\t\tif(tmp != 1)\n\t\t\tfactor[facCnt][0] = tmp, factor[facCnt][1] = tmp, factor[facCnt++][2] = 1;\n\t\treturn facCnt;\n\t}\n\ttypec combinationModP(typec n, typec k, typec p)\n\t{\n\t\tif(k > n) return 0;\n\t\tif(n - k < k) k = n - k;\n\t\ttypec a = 1, b = 1, x, y;\n\t\tint pcnt = 0;\n\t\tfor(int i = 1; i <= k; i++)\n\t\t{\n\t\t\tx = n - i + 1, y = i;\n\t\t\twhile(x % p == 0) x /= p, pcnt++;\n\t\t\twhile(y % p == 0) y /= p, pcnt--;\n\t\t\tx %= p, y %= p, a *= x, b *= y;\n\t\t\tb %= p, a %= p;\n\t\t}\n\t\tif(pcnt) return 0;\n\t\textendGCD(b, p, x, y);\n\t\tif(x < 0) x += p;\n\t\ta *= x, a %= p;\n\t\treturn a;\n\t}\n};//using namespace Math;\n//}\n// <<= \'-. Geo ,.//{\nnamespace Geo{\n\t#define typec double\n    const typec eps=1e-9;\n    int dblcmp(double d){\n        if (fabs(d)<eps)return 0;\n        return d>eps?1:-1;\n    }\n    int sgn(double a) {return a<-eps?-1:a>eps;}\n    inline double sqr(double x){return x*x;}\n    struct Point2D{\n\t\ttypec x,y;\n\t\tPoint2D(){}\n\t\tPoint2D(typec _x,typec _y):x(_x),y(_y){};\n\t\tvoid input(){\n\t\t\tscanf(""%lf%lf"",&x,&y);\n\t\t}\n\t\tvoid output(){\n\t\t\tprintf(""%.2f %.2f\\n"",x,y);\n\t\t}\n\t\tbool operator==(Point2D a)const{\n\t\t\treturn dblcmp(a.x-x)==0&&dblcmp(a.y-y)==0;\n\t\t}\n\t\tbool operator<(Point2D a)const{\n\t\t\treturn dblcmp(a.x-x)==0?dblcmp(y-a.y)<0:x<a.x;\n\t\t}\n\t\ttypec len(){\n\t\t\treturn hypot(x,y);\n\t\t}\n\t\ttypec len2(){\n\t\t\treturn x*x+y*y;\n\t\t}\n\t\tPoint2D operator + (const Point2D &A) const{\n\t\t\treturn Point2D(x + A.x , y + A.y);\n\t\t}\n\t\tPoint2D operator - (const Point2D &A) const{\n\t\t\treturn Point2D(x - A.x , y - A.y);\n\t\t}\n\t\tPoint2D operator * (const typec _x) const{\n\t\t\treturn Point2D(x * _x , y * _x);\n\t\t}\n\t\ttypec operator * (const Point2D &A) const{\n\t\t\treturn x * A.x + y * A.y;\n\t\t}\n\t\ttypec operator ^ (const Point2D &A) const{\n\t\t\treturn x * A.y - y * A.x;\n\t\t}\n\t\tPoint2D operator / (const typec _p) const{\n\t\t\treturn Point2D(x / _p , y / _p);\n\t\t}\n\t\ttypec distance(Point2D p){\n\t\t\treturn hypot(x-p.x,y-p.y);\n\t\t}\n\t\tPoint2D add(Point2D p){\n\t\t\treturn Point2D(x+p.x,y+p.y);\n\t\t}\n\t\tPoint2D sub(Point2D p){\n\t\t\treturn Point2D(x-p.x,y-p.y);\n\t\t}\n\t\tPoint2D mul(typec b){\n\t\t\treturn Point2D(x*b,y*b);\n\t\t}\n\t\tPoint2D div(typec b){\n\t\t\treturn Point2D(x/b,y/b);\n\t\t}\n\t\ttypec dot(Point2D p){\n\t\t\treturn x*p.x+y*p.y;\n\t\t}\n\t\ttypec det(Point2D p){\n\t\t\treturn x*p.y-y*p.x;\n\t\t}\n\t\ttypec rad(Point2D a,Point2D b){\n\t\t\tPoint2D p=*this;\n\t\t\treturn fabs(atan2(fabs(a.sub(p).det(b.sub(p))),a.sub(p).dot(b.sub(p))));\n\t\t}\n\t\tPoint2D trunc(typec r){\n\t\t\ttypec l=len();\n\t\t\tif (!dblcmp(l))return *this;\n\t\t\tr/=l;\n\t\t\treturn Point2D(x*r,y*r);\n\t\t}\n\t\tPoint2D rotleft(){\n\t\t\treturn Point2D(-y,x);\n\t\t}\n\t\tPoint2D rotright(){\n\t\t\treturn Point2D(y,-x);\n\t\t}\n\t\tPoint2D rotate(Point2D p,typec angle)//ÈÆµãpÄæÊ±ÕëÐý×ªangle½Ç¶È\n\t\t{\n\t\t\tPoint2D v=this->sub(p);\n\t\t\ttypec c=cos(angle),s=sin(angle);\n\t\t\treturn Point2D(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n\t\t}\n\t};\n\n\ttypec cross(Point2D a,Point2D b,Point2D c){\n\t\treturn (b.sub(a)).det(c.sub(a));\n\t}\n}using namespace Geo;\n//}\n//}\n\n/** I/O Accelerator Interface .. **/ //{\ntemplate<class T> inline T& RD(T &x){\n    //cin >> x;\n    //scanf(""%d"", &x);\n    char c; for (c = getchar(); c < \'0\'; c = getchar()); x = c - \'0\'; for (c = getchar(); \'0\' <= c && c <= \'9\'; c = getchar()) x = x * 10 + c - \'0\';\n    //char c; c = getchar(); x = c - \'0\'; for (c = getchar(); c >= \'0\'; c = getchar()) x = x * 10 + c - \'0\';\n    return x;\n}\n\ninline DB& RF(DB &x){\n    //cin >> x;\n    scanf(""%lf"", &x);\n    /*char t; while ((t=getchar())==\' \'||t==\'\\n\'); x = t - \'0\';\n    while ((t=getchar())!=\' \'&&t!=\'\\n\'&&t!=\'.\')x*=10,x+=t-\'0\';\n    if (t==\'.\'){DB l=1; while ((t=getchar())!=\' \'&&t!=\'\\n\')l*=0.1,x += (t-\'0\')*l;}*/\n    return x;\n}\n\ninline char* RS(char *s){\n    //gets(s);\n    scanf(""%s"", s);\n    return s;\n}\n\nint Case; template<class T> inline void OT(const T &x){\n    //printf(""Case %d: %d\\n"", ++Case, x);\n    //printf(""%.2lf\\n"", x);\n    //printf(""%d\\n"", x);\n    cout << x << endl;\n}\n//}\n/* .................................................................................................................................. */\nconst int N = 1111;\nint n , m;\nchar a[N][N];\nint dp[N][N];\nbool inmap(int p , int q){\n    return 0 <= p && p <= n - 1 && 0 <= q && q <= m - 1;\n}\nbool next(char c , char d){\n    if (c == \'D\') return d == \'I\';\n    if (c == \'I\') return d == \'M\';\n    if (c == \'M\') return d == \'A\';\n    if (c == \'A\') return d == \'D\';\n    return false;\n}\nint id(char c){\n    if (c == \'D\') return 0;\n    if (c == \'I\') return 1;//d == \'M\';\n    if (c == \'M\') return 2;//d == \'A\';\n    if (c == \'A\') return 3;//d == \'D\';\n    return -1;\n}\nint inst[N][N];\nbool circle;\nint __;\nint dfs(int x , int y){\n    if (inst[x][y] == __){\n//            cout << "">>> "" << x << \' \' << y << endl;\n        circle = 1;\n        return 0;\n    }\n    inst[x][y] = __;\n    if (dp[x][y] != 0) {\n            inst[x][y] = 0;\n            return dp[x][y];\n\n    }\n    for (int k = 0 ; k < 4 ; ++k) if (inmap(x + dx4[k] , y + dy4[k])){\n        int gx = x + dx4[k] , gy = y + dy4[k];\n        if (!next(a[x][y] , a[gx][gy])) continue;\n        checkMax(dp[x][y] , dfs(gx,gy));\n    }\n    inst[x][y] = 0;\n    ++dp[x][y];\n//    cout << x << \' \' << y << \' \' << dp[x][y] << endl;\n    return (dp[x][y]);\n}\n//bool fuck(int x , int y){\n//    int d = id(a[x][y]);\n//    if (dp[x][y][d] == 0) return 0;\n//    for (int k = 0 ; k < 4 ; ++k) if (inmap(x + dx4[k] , y + dy4[k])){\n//        int gx = x + dx4[k] , gy = y + dy4[k];\n//        int gd = id(a[gx][gy]);\n//        if (!next(a[x][y] , a[gx][gy])) continue;\n//        if (dp[x][y][d] <= dp[gx][gy][gd]) return true;\n//    }\n//    return false;\n//}\n\nvoid solve(){\n    RST(inst);\n    for (int i = 0 ; i < n ; ++i) scanf(""%s"" , a[i]);\n    RST(dp);\n    circle = 0;\n    __ = 0;\n    for (int i = 0 ; i < n && !circle; ++i)\n        for (int j = 0 ; j < m && !circle; ++j){\n            __=1;\n//            cout << i << \' \' << j <<endl;\n            dfs(i , j);\n        }\n    if (circle){\n        puts(""Poor Inna!"");\n        return;\n    }\n    int ans = 0;\n    for (int i = 0 ; i < n ; ++i)\n        for (int j = 0 ; j < m ; ++j) if (a[i][j] == \'D\' && dp[i][j]) //if (a[i][j] == \'D\' && dp[i][j][0])// && dp[i][j][0] % 4 ==0)\n            checkMax(ans , dp[i][j] / 4);\n    if (ans == 0) puts(""Poor Dima!"");\n    else OT(ans);\n}\nint main(){\n    while(cin >> n >> m) solve();\n}\n//\n//\n//\n//\n////\n//const int N = 1111;\n//const int dx[] = {0, 1, 0, -1};\n//const int dy[] = {1, 0, -1, 0};\n//int v[N][N], dp[N][N], s[N][N];\n//int n, m, found;\n//void Dfs(int x, int y){\n//    if (dp[x][y] != -1) return;\n//    v[x][y] = 1;\n//    dp[x][y] = 1;\n//    for (int i = 0; i < 4; i++){\n//        int xx = x + dx[i], yy = y + dy[i];\n//        if (xx <= 0 || xx > n || yy <= 0 || yy > m || (s[x][y] + 1) % 4 != s[xx][yy]) continue;\n//        if (v[xx][yy]){found = 1; return;}\n//        Dfs(xx, yy);\n//        if (found) return;\n//        dp[x][y] = max(dp[x][y], dp[xx][yy] + 1);\n//    }\n//    v[x][y] = 0;\n//}\n//char str[N];\n//int main(){\n//    //freopen(""in.txt"", ""r"", stdin);\n//    scanf(""%d%d"", &n, &m);\n//    for (int i = 1; i <= n; i++){\n//        scanf(""%s"", str + 1);\n//        for (int j = 1; j <= m; j++){\n//            if (str[j] == \'D\') s[i][j] = 0;\n//            if (str[j] == \'I\') s[i][j] = 1;\n//            if (str[j] == \'M\') s[i][j] = 2;\n//            if (str[j] == \'A\') s[i][j] = 3;\n//        }\n//    }\n//    found = 0;\n//    int ans = 0;\n//    memset(dp, -1, sizeof(dp));\n//\n//    for (int i = 1; i <= n; i++)\n//    for (int j = 1; j <= m; j++)\n//    if (dp[i][j] == -1) Dfs(i, j);\n//    if (found){\n//        puts(""Poor Inna!"");\n//        return 0;\n//    }\n//    for (int i = 1; i <= n; i++)\n//    for (int j = 1; j <= m; j++)\n//    if (!s[i][j]) ans = max(ans, dp[i][j] / 4);\n//    if (!ans) puts(""Poor Dima!"");\n//    else printf(""%d\\n"", ans);\n//\n\n//}\n']","[0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1900
Research rover finally reached the surface of Mars and is ready to complete its mission Unfortunately due to the mistake in the navigation system design the rover is located in the wrong place The rover will operate on the grid consisting of rows and columns We will define as the cell located in the row and column From each cell the rover is able to move to any cell that share a side with the current one The rover is currently located at cell and has to move to the cell It will randomly follow some between these two cells Each possible way is chosen equiprobably The cargo section of the rover contains the battery required to conduct the research Initially the battery charge is equal to units of energy Some of the cells contain anomaly Each time the rover gets to the cell with anomaly the battery looses half of its charge rounded down Formally if the charge was equal to before the rover gets to the cell with anomaly the charge will change to While the rover picks a random shortest path to proceed compute the expected value of the battery charge after it reaches cell If the cells and contain anomaly they also affect the charge of the battery ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD=1000000007;\nint N, M, K, S;\nint fact[200001];\nint ifact[200001];\n\nint powmod(int a, int b)\n{\n    int ret=1;\n    for(; b>0; b/=2)\n    {\n        if(b&1)\n            ret=1LL*ret*a%MOD;\n        a=1LL*a*a%MOD;\n    }\n    return ret;\n}\n\nint C(int n, int k)\n{\n    return 1LL*fact[n]*ifact[k]%MOD*ifact[n-k]%MOD;\n}\n\nint ways(int n, int m)\n{\n    return C(n+m, n);\n}\n\npair<int, int> A[2000];\nint X[2000];\nint Y[2000];\nint dp[2000][22];\nint ans[22];\n\nvoid addmod(int& x, int v)\n{\n    x+=v;\n    if(x>=MOD)\n        x-=MOD;\n}\n\nvoid submod(int& x, int v)\n{\n    addmod(x, MOD-v);\n}\n\nint main()\n{\n    fact[0]=1;\n    for(int i=1; i<=200000; i++)\n        fact[i]=1LL*fact[i-1]*i%MOD;\n    for(int i=0; i<=200000; i++)\n        ifact[i]=powmod(fact[i], MOD-2);\n    scanf(""%d%d%d%d"", &N, &M, &K, &S);\n    for(int i=0; i<K; i++)\n        scanf(""%d%d"", &A[i].first, &A[i].second), A[i].first--, A[i].second--;\n    sort(A, A+K);\n    for(int i=0; i<K; i++)\n        tie(X[i], Y[i])=A[i];\n    for(int i=0; i<K; i++) for(int x=1; x<=21; x++)\n    {\n        dp[i][x]=ways(X[i], Y[i]);\n        for(int j=0; j<i; j++) if(X[j]<=X[i] && Y[j]<=Y[i])\n            submod(dp[i][x], 1LL*dp[j][x]*ways(X[i]-X[j], Y[i]-Y[j])%MOD);\n        for(int j=0; j<x; j++)\n            submod(dp[i][x], dp[i][j]);\n    }\n    for(int x=0; x<=20; x++)\n    {\n        ans[x]=ways(N-1, M-1);\n        for(int i=0; i<K; i++)\n            submod(ans[x], 1LL*dp[i][x+1]*ways(N-1-X[i], M-1-Y[i])%MOD);\n        for(int i=0; i<x; i++)\n            submod(ans[x], ans[i]);\n    }\n    int tot=ways(N-1, M-1);\n    int rans=0;\n    for(int i=0; i<=20; i++)\n    {\n        submod(tot, ans[i]);\n        addmod(rans, 1LL*S*ans[i]%MOD);\n        S-=S/2;\n    }\n    addmod(rans, tot);\n    rans=1LL*rans*powmod(ways(N-1, M-1), MOD-2)%MOD;\n    printf(""%d\\n"", rans);\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2900
There have recently been elections in the zoo Overall there were main political parties one of them is the Little Elephant Political Party other parties have less catchy names Political parties find their number in the ballot highly important Overall there are possible numbers Each of these parties is going to be assigned in some way to exactly one number at that two distinct parties cannot receive the same number The Little Elephant Political Party members believe in the lucky digits and They want to evaluate their chances in the elections For that they need to find out how many correct assignments are there such that the number of lucky digits in the Little Elephant Political Party ballot number is strictly larger than the total number of lucky digits in the ballot numbers of 6 other parties Help the Little Elephant Political Party calculate this number As the answer can be rather large print the remainder from dividing it by ,"['#include <cstdio>\n#include <cstring>\n\n\nint m, length;\nint digit[11];\n\nint memory[2][11][11];\n\nint count(bool first, bool less, int length, int size) {\n    if (length == 0) {\n        return less && !size;\n    }\n    if (less && memory[first][length][size] != -1) {\n        return memory[first][length][size];\n    }\n    int ret = 0;\n    for (int i = 0; i < 10; ++ i) {\n        if (first && !i) {\n            continue;\n        }\n        if (!less && digit[length - 1] < i) {\n            continue;\n        }\n        ret += count(false, less || i < digit[length - 1], length - 1, size - (i == 4 || i == 7));\n    }\n    if (less) {\n        memory[first][length][size] = ret;\n    }\n    return ret;\n}\n\nint size[11];\n\nconst int MOD = 1000000000 + 7;\n\nint answer;\nint ways[7];\n\nvoid dfs(int i, int way) {\n    if (i < 7) {\n        for (int k = 0; k <= 10; ++ k) {\n            if (size[k] > 0) {\n                ways[i] = k;\n                dfs(i + 1, (long long)way * (size[k] --) % MOD);\n                size[k] ++;\n            }\n        }\n    } else {\n        int sum = 0;\n        for (int i = 0; i < 6; ++ i) {\n            sum += ways[i];\n        }\n        sum -= ways[6];\n        if (sum < 0) {\n            answer += way;\n            answer %= MOD;\n        }\n    }\n}\n\nint main() {\n    scanf(""%d"", &m);\n    m ++;\n    length = 0;\n    while (m) {\n        digit[length ++] = m % 10;\n        m /= 10;\n    }\n    memset(memory, -1, sizeof(memory));\n    for (int k = 0; k <= 10; ++ k) {\n        for (int i = 1; i <= length; ++ i) {\n            size[k] += count(true, i < length, i, k);\n        }\n    }\n    //for (int i = 0; i <= 10; ++ i) {\n    //    printf(""%d\\n"", size[i]);\n    //}\n    answer = 0;\n    dfs(0, 1);\n    printf(""%d\\n"", answer);\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1]",1900
Tokitsukaze is arranging a meeting There are n rows and m columns of seats in the meeting hall There are exactly n cdot m students attending the meeting including several naughty students and several serious students The students are numerated from 1 to n cdot m The students will enter the meeting hall in order When the i th student enters the meeting hall he will sit in the 1 st column of the 1 st row and the students who are already seated will move back one seat Specifically the student sitting in the j th 1 leq j leq m 1 column of the i th row will move to the j 1 th column of the i th row and the student sitting in m th column of the i th row will move to the 1 st column of the i 1 th row For example there is a meeting hall with 2 rows and 2 columns of seats shown as below There will be 4 students entering the meeting hall in order represented as a binary string of which represents naughty students and represents serious students The changes of seats in the meeting hall are as follows Denote a row or a column good if and only if there is at least one serious student in this row or column Please predict the number of good rows and columns just after the i th student enters the meeting hall for all i ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tstring s;cin>>s;\n\tvi base(n*m),sum(n*m);\n\tvi has(m);\n\tint pre=-inf;\n\trep(i,si(s))if(s[i]==\'1\'){\n\t\tif(!has[i%m]){\n\t\t\tbase[i]++;\n\t\t\thas[i%m]=1;\n\t\t}\n\t\tint dif=min(i-pre,m);\n\t\trng(j,i+m-dif,min(n*m,i+m))sum[j]++;\n\t\tpre=i;\n\t}\n\trep(i,n*m-1)base[i+1]+=base[i];\n\trep(i,n*m-m)sum[i+m]+=sum[i];\n\trep(i,n*m)base[i]+=sum[i];\n\tprint(base);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
You are given a permutation p 1 p 2 dots p n You should answer q queries Each query is a pair l i r i and you should calculate f l i r i Let s denote m l r as the position of the maximum in subsegment p l p l 1 dots p r Then f l r r l 1 f l m l r 1 f m l r 1 r if l le r or 0 otherwise ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,Q;\nint P[1010101];\nint L[1010101],R[1010101];\n\nint Lma[1010101],Rma[1010101];\nvector<int> delL[1010101],delR[1010101];\nvector<int> QL[1010101],QR[1010101];\ntemplate<class V,int NV> class SegTree_1 {\npublic:\n\tvector<V> val;\n\tstatic V const def=0;\n\tV comp(V l,V r){ return max(l,r);};\n\t\n\tSegTree_1(){val=vector<V>(NV*2,def);};\n\tV getval(int x,int y,int l=0,int r=NV,int k=1) { // x<=i<y\n\t\tif(r<=x || y<=l) return def;\n\t\tif(x<=l && r<=y) return val[k];\n\t\treturn comp(getval(x,y,l,(l+r)/2,k*2),getval(x,y,(l+r)/2,r,k*2+1));\n\t}\n\tvoid update(int entry, V v) {\n\t\tentry += NV;\n\t\tval[entry]=comp(v,val[entry]);\n\t\twhile(entry>1) entry>>=1, val[entry]=comp(val[entry*2],val[entry*2+1]);\n\t}\n};\nSegTree_1<int,1<<20> st;\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {if(e<0) return 0;V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tvoid add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<ll,20> sum;\nBIT<int,20> mu;\n\nll ret[1010101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tscanf(""%d%d"",&N,&Q);\n\tfor(i=1;i<=N;i++) {\n\t\tscanf(""%d"",&P[i]);\n\t\tLma[i]=st.getval(P[i],N+1);\n\t\tdelL[Lma[i]].push_back(i);\n\t\tst.update(P[i],i);\n\t\tsum.add(i,i-Lma[i]);\n\t}\n\tFOR(i,st.val.size()) st.val[i]=0;\n\tfor(i=N;i>=1;i--) {\n\t\tRma[i]=N+1-st.getval(P[i],N+1);\n\t\tdelR[Rma[i]].push_back(i);\n\t\tst.update(P[i],N+1-i);\n\t}\n\t\n\tFOR(i,Q) {\n\t\tscanf(""%d"",&L[i]);\n\t\tQL[L[i]].push_back(i);\n\t}\n\tFOR(i,Q) {\n\t\tscanf(""%d"",&R[i]);\n\t\tQR[R[i]].push_back(i);\n\t}\n\t\n\tFOR(i,N+1) {\n\t\tFORR(q,QL[i]) ret[q]+=(sum(R[q])-sum(L[q]-1))-1LL*i*(mu(R[q])-mu(L[q]-1));\n\t\tFORR(x,delL[i]) {\n\t\t\tsum.add(x,x+1-(sum(x)-sum(x-1)));\n\t\t\tmu.add(x,1);\n\t\t}\n\t}\n\tZERO(mu.bit);\n\tZERO(sum.bit);\n\tfor(i=1;i<=N;i++) {\n\t\tsum.add(i,Rma[i]-i-1);\n\t}\n\tfor(i=N+1;i>=1;i--) {\n\t\tFORR(q,QR[i]) ret[q]+=(sum(R[q])-sum(L[q]-1))+1LL*i*(mu(R[q])-mu(L[q]-1));\n\t\tFORR(x,delR[i]) {\n\t\t\tsum.add(x,-x-(sum(x)-sum(x-1)));\n\t\t\tmu.add(x,1);\n\t\t}\n\t}\n\t\n\tFOR(i,Q) cout<<ret[i]<<"" "";\n\tcout<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
You are given a sequence of positive integers Your task is to construct an undirected graph such that there are exactly vertices there are no self loops there are no multiple edges there are no more than edges its is equal to Vertices should be numbered through is an array with length equal to the number of vertices in a graph such that is the number of vertices adjacent to th vertex is a sorted in increasing order sequence of all distinct values from the It is guaranteed that there exists such a graph that all the conditions hold and it contains no more than edges Print the resulting graph ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint in[305];\n\nbool chk[1050][1050];\nint main() {\n\tint N, i, j, k;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in[i]);\n\n\tint X = in[N] + 1;\n\n\tint st = 1, en = in[N] + 1;\n\tint sti = 1, eni = N;\n\twhile (1) {\n\t\tif (sti == eni) {\n\t\t\tfor (i = st; i <= en; i++) for (j = i + 1; j <= en; j++) chk[i][j] = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (sti + 1 == eni) {\n\t\t\tfor (i = st; i < st + in[sti]; i++) for (j = st; j <= en; j++) chk[i][j] = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = sti + 1; i <= eni - 1; i++) in[i] -= in[sti];\n\n\t\tfor (i = st; i < st + in[sti]; i++) for (j = st; j <= en; j++) chk[i][j] = true;\n\t\tst = st + in[sti];\n\t\ten = st + in[eni - 1];\n\t\tsti++, eni--;\n\t}\n\t\n\tvector <pii> Va;\n\tfor (i = 1; i <= X; i++) for (j = i + 1; j <= X; j++) if (chk[i][j] || chk[j][i]) Va.emplace_back(i, j);\n\n\tprintf(""%d\\n"", (int)Va.size());\n\tfor (auto it : Va) printf(""%d %d\\n"", it.first, it.second);\n}']","[0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2500
JATC loves Banh mi a Vietnamese food His affection for Banh mi is so much that he always has it for breakfast This morning as usual he buys a Banh mi and decides to enjoy it in a special way First he splits the Banh mi into n parts places them on a row and numbers them from 1 through n For each part i he defines the of the part as x i in 0 1 JATC s going to eat those parts one by one At each step he chooses arbitrary remaining part and eats it Suppose that part is the i th part then his of the Banh mi will increase by x i and the deliciousness of all the remaining parts will also increase by x i The initial enjoyment of JATC is equal to 0 For example suppose the deliciousness of 3 parts are 0 1 0 If JATC eats the second part then his enjoyment will become 1 and the deliciousness of remaining parts will become 1 1 Next if he eats the first part then his enjoyment will become 2 and the remaining parts will become 2 After eating the last part JATC s enjoyment will become 4 However JATC doesn t want to eat all the parts but to save some for later He gives you q queries each of them consisting of two integers l i and r i For each query you have to let him know what is the maximum enjoyment he can get if he eats all the parts with indices in the range l i r i in some order All the queries are independent of each other Since the answer to the query could be very large print it modulo 10 9 7 ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1000000007;\n\nint a[100006];\nint pre[100006];\n\nll ppow(ll a,ll n) {\n\tll ret=1,now=a;\n\twhile (n) {\n\t\tif (n&1) {\n\t\t\tret = (ret*now)%mod;\n\t\t}\n\t\tnow = (now*now)%mod;\n\t\tn >>=1;\n\t}\n\treturn ret;\n}\n\nint main () {\n\tios::sync_with_stdio(0); cin.tie(0);\n\tint n,q;\n\tcin >> n >> q;\n\tstring s;\n\tcin >> s;\n\tfor (int i=1;i<=n;++i) {\n\t\tchar c = s[i-1];\n\t\tif (c == '0') a[i] = 0;\n\t\telse a[i] = 1;\n\t\tpre[i] = pre[i-1] + a[i];\n\t}\n\twhile (q--) {\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tlong long _1 = pre[r] - pre[l-1],len = r-l+1;\n\t\tcout << ( (ppow(2,_1)-1) + (ppow(2,_1)-1)*(ppow(2,len-_1)-1) )%mod << endl;\n\t}\n}\n""]","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Let s denote as the number of bits set 1 bits in the binary representation of the non negative integer You are given multiple queries consisting of pairs of integers and For each query find the such that and is maximum possible If there are multiple such numbers find the smallest of them ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    forn(i, N) {\n        i64 L, R;\n        cin >> L >> R;\n        i64 add = 0;\n        ford(k, 60) {\n            i64 M = (1LL << k) - 1;\n            if (L <= M && M <= R) {\n                add += M;\n                break;\n            }\n            if (L > M) {\n                add += 1LL << k;\n                L -= 1LL << k;\n                R -= 1LL << k;\n            }\n        }\n        cout << add << \'\\n\';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Cat Noku has obtained a map of the night sky On this map he found a constellation with stars numbered from to For each the th star is located at coordinates No two stars are located at the same position In the evening Noku is going to take a look at the night sky He would like to find three distinct stars and form a triangle The triangle must have positive area In addition all other stars must lie strictly outside of this triangle He is having trouble finding the answer and would like your help Your job is to find the indices of three stars that would form a triangle that satisfies all the conditions It is guaranteed that there is no line such that all stars lie on that line It can be proven that if the previous condition is satisfied there exists a solution to this problem ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point\n{\n\tll x, y;\n\n\tPoint() : x(), y() {}\n\tPoint (ll _x, ll _y) : x(_x), y(_y) {}\n\n\tPoint operator + (const Point &a) const\n\t{\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\tPoint operator - (const Point &a) const\n\t{\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n\tll operator % (const Point &a) const\n\t{\n\t\treturn x * a.x + y * a.y;\n\t}\n\tll operator * (const Point &a) const\n\t{\n\t\treturn x * a.y - y * a.x;\n\t}\n\tll sqrLen() const\n\t{\n\t\treturn *this % *this;\n\t}\n\n\tvoid scan()\n\t{\n\t\tscanf(""%lld%lld"", &x, &y);\n\t}\n};\n\nconst int N = 100100;\nPoint a[N];\nint n;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i].scan();\n\tll L = (a[1] - a[0]).sqrLen();\n\tint v = 1;\n\tfor (int i = 2; i < n; i++)\n\t{\n\t\tll d = (a[i] - a[0]).sqrLen();\n\t\tif (d < L)\n\t\t{\n\t\t\tL = d;\n\t\t\tv = i;\n\t\t}\n\t}\n\tll S = -1;\n\tint u = -1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tll s = (a[i] - a[0]) * (a[i] - a[v]);\n\t\ts = abs(s);\n\t\tif (s == 0) continue;\n\t\tif (S == -1 || s < S)\n\t\t{\n\t\t\tS = s;\n\t\t\tu = i;\n\t\t}\n\t}\n\tprintf(""%d %d %d\\n"", 1, min(v, u) + 1, max(v, u) + 1);\n\t\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Anna and Katie ended up in a secret laboratory There are a b c buttons in the laboratory It turned out that a buttons can only be pressed by Anna b buttons can only be pressed by Katie and c buttons can be pressed by either of them Anna and Katie decided to play a game taking turns pressing these buttons Anna makes the first turn Each button can be pressed at most once so at some point one of the girls will not be able to make her turn The girl who cannot press a button loses Determine who will win if both girls play optimally ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""debug.h""\n#else\n#define debug(...)\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.exceptions(cin.failbit);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    cout << (a + (c + 1) / 2 > b + c / 2 ? ""First"" : ""Second"") << \'\\n\';\n  }\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
YouKn0wWho has two integers x and y Help him to find an integer n such that 1 le n le 2 cdot 10 18 and n bmod x y bmod n Here a bmod b denotes the remainder of a after division by b If there are multiple such integers output any It can be shown that such an integer always exists under the given constraints ,"[""/**\n *    author:  tourist\n *    created: 30.10.2021 17:38:52       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long x, y;\n    cin >> x >> y;\n    if (y < x) {\n      cout << y + x << '\\n';\n      continue;\n    }\n    if (y == x) {\n      cout << x << '\\n';\n      continue;\n    }\n    cout << y - y % x / 2 << '\\n';\n  }\n  return 0;\n}\n""]","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1600
Mahmoud has an array consisting of integers He asked Ehab to find another array such that is lexicographically greater than or equal to is pairwise coprime for every and are coprime i e where is the greatest common divisor of and Ehab wants to choose a special array so he wants the lexicographically minimal array between all the variants Can you find it An array is lexicographically greater than an array if there exists an index such than and for all An array is equal to an array if for all ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 3e6 + 10;\n\nint p[MAXN];\nint n, a[MAXN];\nbool mark[MAXN];\n\nbool ok(int cur){\n\twhile (cur > 1) {\n\t\tif (mark[p[cur]]) return false;\n\t\tcur /= p[cur];\n\t}\n\treturn true;\n}\n\nvoid go(int cur){\n\twhile (cur > 1){\n\t\tmark[p[cur]] = true;\n\t\tcur /= p[cur];\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tmemset(p, -1, sizeof(p));\n\tfor (int i = 2; i < MAXN; i++)\n\t\tif (p[i] == -1)\n\t\t\tfor (int j = i; j < MAXN; j += i)\n\t\t\t\tp[j] = i;\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> a[i];\n\tint i;\n\tfor (i = 0; i < n; i++){\n\t\tif (!ok(a[i])){\n\t\t\tint cur = a[i]+1;\n\t\t\twhile (!ok(cur)) cur++;\n\t\t\tgo(cur);\n\t\t\tcout << cur << "" "";\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << a[i] << "" "";\n\t\tgo(a[i]);\n\t}\n\n\tint cur = 2;\n\twhile (i < n){\n\t\twhile (!ok(cur)) cur++;\n\t\tcout << cur << "" "";\n\t\tgo(cur);\n\t\ti++;\n\t}\n\tcout << ""\\n"";\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1900
Dmitry has an array of n non negative integers a 1 a 2 dots a n In one operation Dmitry can choose any index j 1 le j le n and increase the value of the element a j by 1 He can choose the same index j multiple times For each i from 0 to n determine whether Dmitry can make the mathrm MEX of the array equal to exactly i If it is possible then determine the minimum number of operations to do it The mathrm MEX of the array is equal to the minimum non negative integer that is not in the array For example the mathrm MEX of the array 3 1 0 is equal to 2 and the array 3 3 1 4 is equal to 0 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nifstream fin(""AAtest.in.txt"");\nll t,n,a[200005],l,palju,k,eel;\nvector<ll> v;\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cerr.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>n;\n        v.resize(0);\n        for(int i=0; i<n; i++) cin>>a[i];\n        sort(a,a+n);\n        l=0; k=0; palju=0;\n        eel=0;\n        for(int i=0; i<=n; i++){\n            if(eel!=-1) if(i!=0){\n                if(v.size()) eel+=i-1-v[v.size()-1],v.pop_back();\n                else eel=-1;\n            }\n            else eel=0;\n            while(k<n && a[k]==i) palju++,k++,v.push_back(i);\n            if(eel==-1) cout<<eel<<"" "";\n            else cout<<eel+palju<<"" "";\n            palju=0;\n        }\n        cout<<""\\n"";\n    }\n}\n']","[1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1700
There are two water tanks the first one fits a liters of water the second one fits b liters of water The first tank has c 0 le c le a liters of water initially the second tank has d 0 le d le b liters of water initially You want to perform n operations on them The i th operation is specified by a single non zero integer v i If v i 0 then you try to pour v i liters of water from the first tank into the second one If v i 0 you try to pour v i liters of water from the second tank to the first one When you try to pour x liters of water from the tank that has y liters currently available to the tank that can fit z more liters of water the operation only moves min x y z liters of water For all pairs of the initial volumes of water c d such that 0 le c le a and 0 le d le b calculate the volume of water in the first tank after all operations are performed ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, a, b;\n    std::cin >> n >> a >> b;\n    \n    std::vector<int> v(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> v[i];\n    }\n    \n    std::vector ans(a + 1, std::vector<int>(b + 1));\n    for (int s = 0; s <= a + b; s++) {\n        int X = std::max(0, s - b);\n        int Y = std::min(a, s);\n        int lo = X, hi = Y;\n        for (int i = n - 1; i >= 0; i--) {\n            lo += v[i];\n            hi += v[i];\n            lo = std::max(lo, X);\n            hi = std::min(hi, Y);\n        }\n        int flo = lo, fhi = hi;\n        for (int i = 0; i < n; i++) {\n            flo = std::max(std::min(flo - v[i], Y), X);\n            fhi = std::max(std::min(fhi - v[i], Y), X);\n        }\n        for (int c = X; c <= Y; c++) {\n            int d = s - c;\n            if (c <= lo) {\n                ans[c][d] = flo;\n            } else if (c >= hi) {\n                ans[c][d] = fhi;\n            } else {\n                ans[c][d] = flo + c - lo;\n            }\n        }\n    }\n    \n    for (int c = 0; c <= a; c++) {\n        for (int d = 0; d <= b; d++) {\n            std::cout << ans[c][d] << "" \\n""[d == b];\n        }\n    }\n    \n    return 0;\n}']","[0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2400
We play a game with n dots on a number line The initial coordinate of the i th dot is x i These coordinates are distinct Every dot starts moving simultaneously with the same constant speed Each dot moves in the direction of the closest dot different from itself until it meets another dot In the case of a tie it goes to the left Two dots meet if they are in the same coordinate after that they stop moving After enough time every dot stops moving The result of a game is the number of distinct coordinates where the dots stop Because this game is too easy calculate the sum of results when we play the game for every subset of the given n dots that has at least two dots As the result can be very large print the sum modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int in(){\n    int x;\n    scanf(""%d"",&x);\n    return x;\n}\nconst int N=3005,mod=1e9+7;\ninline int add(int a,int b){return a+b>=mod?a+b-mod:a+b;}\nint n,a[N];\nint pw[N];\nint main(){\n    n=in();\n    pw[0]=1;\n    for(int i=1;i<=n;i++)a[i]=in(),pw[i]=add(pw[i-1],pw[i-1]);\n    int ans=0;\n    for(int l=1;l<=n;l++){\n        for(int r=l+1;r<=n;r++){\n            int x=lower_bound(a+1,a+n+1,a[l]+a[l]-a[r])-a-1;\n            int y=lower_bound(a+1,a+n+1,a[r]+a[r]-a[l])-a;\n            ans=add(ans,pw[x+n-y+1]);\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1]",2000
Little Petya very much likes rectangular tables that consist of characters 0 and 1 Recently he has received one such table as a gift from his mother The table contained rows and columns The rows are numbered from top to bottom from to the columns are numbered from the left to the right from to Petya immediately decided to find the longest cool cycle whatever it takes A cycle is a sequence of pairwise distinct cells where each two consecutive cells have a common side besides the first cell has a common side with the last cell A cycle is called cool if it fulfills all the following conditions simultaneously The cycle entirely consists of the cells that contain 1 Each cell that belongs to the cycle has a common side with exactly two other cells that belong to the cycle Each cell of the table that contains 1 either belongs to the cycle or is positioned outside of it see definition below To define the notion of outside formally let s draw a cycle on a plane Let each cell of the cycle is the row number is the column number correspond to the point on the coordinate plane Let a straight line segment join each pair of points that correspond to the cells belonging to the cycle and sharing a side Thus we will get a closed polyline that has no self intersections and self touches The polyline divides the plane into two connected parts the part of an infinite area and the part of a finite area It is considered that cell lies outside of the cycle if it does not belong to the cycle and the corresponding point on the plane with coordinates lies in the part with the infinite area Help Petya to find the length of the longest cool cycle in the table The cycle length is defined as the number of cells that belong to the cycle ,"['#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <memory.h>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define forn( i,n ) for ( int i=0; i<(int)(n); i++ )\n#define foreach( it, a ) for ( __typeof((a).begin()) it = (a).begin(); it != (a).end(); it++ )\n#define pb push_back\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n\nconst int di[] = { -1, 0, 1, 0, -1, -1, 1, 1 };\nconst int dj[] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nint n, m;\nbool a[1010][1010];\nchar s[1010];\nbool u[1010][1010];\nint u1[1010][1010], it;\nint u2[1010][1010];\nvector<pii> v1;\npii q[1010*1010];\nint qb, qf;\n\nint go( int i, int j ) {\n  u2[i][j] = it;\n  int res = 1;\n  forn( q, 4 ) {\n    int ni = i + di[q];\n    int nj = j + dj[q];\n    if ( ni >= 0 && ni < n && nj >= 0 && nj < m )\n      if ( a[ni][nj] == 1 && u1[ni][nj] == it && u2[ni][nj] != it )\n        res += go( ni, nj );\n  }\n  return res;\n}\n\nint check( int si, int sj ) {\n  qb = qf = 0;\n  q[qf++] = pii( si, sj );\n  u[si][sj] = 1;\n  v1.clear();\n  bool side = false;\n\n  it++;\n  pii cur;\n  while ( qb < qf ) {\n    cur = q[qb++];\n    si = cur.first;\n    sj = cur.second;\n\n    forn( w, 8 ) {\n      int ni = si + di[w];\n      int nj = sj + dj[w];\n\n      if ( ni < 0 || ni >= n || nj < 0 || nj >= m ) {\n        side = true;\n        break;\n      }\n      else\n        if ( a[ni][nj] == 1 ) {\n          if ( u1[ni][nj] != it ) {\n            u1[ni][nj] = it;\n            v1.pb( pii( ni, nj ) );\n          }\n        }\n        else\n          if ( !u[ni][nj] ) {\n            u[ni][nj] = 1;\n            q[qf++] = pii( ni, nj );\n          }\n    }\n  }\n\n  if ( side ) return 0;\n\n  forn( i, v1.size() ) {\n    int cnt = 0;\n    forn( j, 4 ) {\n      int ti = v1[i].first + di[j];\n      int tj = v1[i].second + dj[j];\n      if ( ti >= 0 && ti < n && tj >= 0 && tj < m && a[ti][tj] == 1 && u1[ti][tj] == it )\n        cnt++;\n    }\n    if ( cnt != 2 ) return 0;\n  }\n\n  if ( v1.size() )\n    if ( go( v1[0].first, v1[0].second ) == (int)v1.size() ) return v1.size();\n\n  return 0;\n}\n\nint main()\n{\n  scanf( ""%d %d"", &n, &m );\n  forn( i, n ) {\n    scanf( ""%s"", s );\n    forn( j, m )\n      a[i][j] = s[j] == \'1\';\n  }\n\n  int ans = 0;\n  forn( i, n-1 )\n    forn( j, m-1 )\n      if ( a[i][j] && a[i+1][j] && a[i+1][j+1] && a[i][j+1] )\n        ans = 4;\n\n  forn( i, n )\n    forn( j, m )\n      if ( a[i][j] == 0 && !u[i][j] ) {\n        int z = check( i, j );\n        if ( z > ans ) ans = z;\n      }\n\n  printf( ""%d\\n"", ans );\n  return 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0]",2500
Little C loves number very much He loves all things about it Now he is playing a game on a chessboard of size n times m The cell in the x th row and in the y th column is called x y Initially The chessboard is empty Each time he places two chessmen on two different empty cells the Manhattan distance between which is exactly 3 The Manhattan distance between two cells x i y i and x j y j is defined as x i x j y i y j He want to place as many chessmen as possible on the chessboard Please help him find the maximum number of chessmen he can place ,"['#include<cstdio>\nlong long calc(int n,int m){\n\tif(n==1)return m/6*6+(m%6<3?0:m%6-3)*2;\n\tif(n==2){\n\t\tif(m==2)return 0;\n\t\tif(m==3||m==7)return 1ll*n*m-2;\n\t\treturn 1ll*n*m;\n\t}\n\tif(n%2==1&&m%2==1)return 1ll*n*m-1;\n\treturn 1ll*n*m;\n}\nint main(){\n\tint n,m;\n\tscanf(""%d%d"",&n,&m);\n\tif(n>m){int t=n;n=m;m=t;}\n\tprintf(""%lld\\n"",calc(n,m));\n}\n']","[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2200
You are given a tree an undirected connected graph without cycles and an integer s Vanya wants to put weights on all edges of the tree so that all weights are non negative real numbers and their sum is s At the same time he wants to make the diameter of the tree as small as possible Let s define the diameter of a weighed tree as the maximum sum of the weights of the edges lying on the path between two some vertices of the tree In other words the diameter of a weighed tree is the length of the longest simple path in the tree where length of a path is equal to the sum of weights over all edges in the path Find the minimum possible diameter that Vanya can get ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, S;\n  cin >> N >> S;\n\n  vector<int> degs(N + 1);\n  for (int i = 0; i < N - 1; ++i) {\n    int u, v;\n    cin >> u >> v;\n    ++degs[u];\n    ++degs[v];\n  }\n\n  const int leaves = count(ALL(degs), 1);\n\n  cout << (LD)2 * S / leaves << ""\\n"";\n}\n\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1700
The new ITone 6 has been released recently and George got really keen to buy it Unfortunately he didn t have enough money so George was going to work as a programmer Now he faced the following problem at the work Given a sequence of integers You are to choose pairs of integers in such a way that the value of sum is maximal possible Help George to cope with the task ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\n#define Rep(i, a, b) for (int i(a); i <= (b); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst LL INF = 1000000000000000000;\n\nint N, M, K, P[5033];\nLL dp[5033][5033], sum[5033];\n\nvoid solve() {\n\tscanf(""%d %d %d"", &N, &M, &K);\n\tRep(i, 1, N) scanf(""%d"", P + i);\n\n\tsum[0] = 0;\n\tRep(i, 1, N) sum[i] = sum[i - 1] + P[i];\n\n\tRep(i, 0, N) Rep(j, 0, K) dp[i][j] = -INF;\n\tdp[0][0] = 0;\n\tRep(i, 1, N) Rep(j, 0, K) {\n\t\tLL &res = dp[i][j] = dp[i - 1][j];\n\t\tif (i >= M && j >= 1)\n\t\t\tres = max(res, dp[i - M][j - 1] + sum[i] - sum[i - M]);\n\t\tif (res < 0) res = -INF;\n\t}\n\tcout << dp[N][K] << endl;\n}\n\nint main() {\n\tsolve();\n\treturn 0;\n}\n']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Given an table consisting of lowercase English letters We ll consider some string if the table contains a correct path corresponding to the given string In other words good strings are all strings we can obtain by moving from the left upper cell of the table only to the right and down Here s the formal definition of correct paths Consider rows of the table are numbered from 1 to from top to bottom and columns of the table are numbered from 1 to from left to the right Cell is a cell of table on the th row and in the th column This cell corresponds to letter A path of length is a sequence of table cells The following paths are correct There is only one correct path of length that is consisting of a single cell Let s assume that is a correct path of length then paths and are correct paths of length We should assume that a path corresponds to a string of length Two players play the following game initially they have an empty string Then the players take turns to add a letter to the end of the string After each move adding a new letter the resulting string must be good The game ends after turns A player wins by the following scenario If the resulting string has strictly more letters than letters then the first player wins If the resulting string has strictly more letters than letters then the second player wins If the resulting string has the same number of letters and then the players end the game with a draw Your task is to determine the result of the game provided that both players played optimally well ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define INF (1<<29)\n\nint N;\nstring board[30];\n\nint dp[42][(1<<20)];\nint mask[42][30];\n\nint func(int i, int j, int c, bool first){\n    if(dp[i][j] != 10000) return dp[i][j];\n    \n    int next;\n    int ans = -INF;\n    \n    if(i == 2*(N-1)){\n        ans = 0;\n    } else {\n        REP(next,26){\n            int i2 = i + 1;\n            int j2 = (mask[i+1][next] & (j | (j << 1)));\n            if(j2 != 0) ans = max(ans, -func(i2, j2, next, !first));\n        }\n    }\n    \n    if(first){\n        if(c == 0) ans++; else if(c == 1) ans--;\n    } else {\n        if(c == 0) ans--; else if(c == 1) ans++;\n    }\n    \n//  cout << i << \' \' << j << \' \' << ans << endl;\n    \n    return dp[i][j] = ans;\n}\n\nint main(void){\n    int i,j,k;\n    \n    cin >> N;\n    REP(i,N) cin >> board[i];\n    \n    REP(i,2*N) REP(j,26) REP(k,N){\n        int x = k;\n        int y = i-x;\n        if(y >= 0 && y < N && board[x][y] - \'a\' == j) mask[i][j] |= (1<<k);\n    }\n    \n    REP(i,2*N) REP(j,(1<<N)) dp[i][j] = 10000;\n    int ans = func(0, 1, board[0][0] - \'a\', false);\n    if(ans < 0) cout << ""FIRST"" << endl;\n    if(ans == 0) cout << ""DRAW"" << endl;\n    if(ans > 0) cout << ""SECOND"" << endl;\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
One of Timofey s birthday presents is a colourbook in a shape of an infinite plane On the plane rectangles with sides parallel to coordinate axes are situated All sides of the rectangles have length Rectangles cannot intersect but they can touch each other Help Timofey to color his rectangles in different colors in such a way that every two rectangles touching each other by side would have different color or determine that it is impossible Two rectangles intersect if their intersection has positive area Two rectangles touch by sides if there is a pair of sides such that their intersection has non zero length ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,x,y;\nint main() {\n\tscanf(""%d"",&n);\n\tputs(""YES"");\n\trep(i,0,n) {\n\t\tscanf(""%d%d%*d%*d"",&x,&y);\n\t\tprintf(""%d\\n"",2*(x&1)+(y&1)+1);\n\t}\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
 Ivan plays a computer game that contains some microtransactions to make characters look cooler Since Ivan wants his character to be really cool he wants to use some of these microtransactions and he won t start playing until he gets all of them Each day during the Ivan earns exactly one burle There are n types of microtransactions in the game Each microtransaction costs 2 burles usually and 1 burle if it is on sale Ivan has to order exactly k i microtransactions of the i th type he orders microtransactions during the Ivan can order possibly zero number of microtransactions of types during any day of course If the microtransaction he wants to order is on sale then he can buy it for 1 burle and otherwise he can buy it for 2 burles There are also m special offers in the game shop The j th offer d j t j means that microtransactions of the t j th type are on sale during the d j th day Ivan wants to order all microtransactions as soon as possible Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PII pair<int,int>\n#define PB push_back\n#define POP pop_back\n#define FI first\n#define SE second\n#define endl \'\\n\'\n#define ls x<<1\n#define rs x<<1|1\nconst LL N=4e5+7,mod=998244353,INF=1e9;\nint n,m;\nint a[N],b[N];\nvector<int>v[N];\nint check(int x,int y){\n    int re=x,cnt=0;\n    int flag=0;\n    for(int i=1;i<=n;i++)b[i]=a[i];\n    for(int i=x;i>=1;i--){\n            //cout<<i<<\' \'<<re<<endl;\n        for(int j=0;j<v[i].size();j++){\n            while(b[v[i][j]]&&re){\n                re--;\n                y--;\n                b[v[i][j]]--;\n            }\n        }\n        if(re>=i)re--,flag++;\n    }\n    return flag/2>=y;\n}\nint main()\n{\n    cin>>n>>m;\n    int cnt=0;\n    for(int i=1;i<=n;i++){\n        scanf(""%d"",&a[i]);\n        cnt+=a[i];\n    }\n    int x,y;\n    for(int i=1;i<=m;i++){\n        scanf(""%d%d"",&x,&y);\n        v[x].PB(y);\n    }\n    int ans=INF;\n    int l=cnt,r=2*cnt;\n    while(l<=r){\n        int mid=l+r>>1;\n        if(check(mid,cnt)){\n            ans=min(ans,mid);\n            r=mid-1;\n        }\n        else l=mid+1;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2000
The famous writer Velepin is very productive Recently he signed a contract with a well known publication and now he needs to write k i books for i th year This is not a problem for him at all he can write as much as he wants about samurai space emptiness insects and werewolves He has n regular readers each of whom in the i th year will read one of the k i books published by Velepin Readers are very fond of discussing books so the j th of them will be satisfied within a year if at least a j persons read the same book as him Velepin has obvious problems with marketing so he turned to you A well known book reading service can control what each of Velepin s regular readers will read but he does not want books to be wasted so And so they turned to you with a request to tell you what the maximum number of regular readers can be made satisfied during each of the years if you can choose each person the book he will read ,"[""#include<bits/stdc++.h>\nusing namespace std;\nint n,q,a[300003];\nint f[300003],ans[300003],pre[300003];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(a[i]<=i)\n\t\t\tf[i]=max(f[i],pre[i-a[i]]+1);\n\t\tpre[i]=max(pre[i-1],f[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(f[i])\n\t\t\tans[f[i]+n-i]=i;\n\t\telse\n\t\t\tans[n-a[i]+1]=i;\n\tfor(int i=n;i>0;i--)\n\t\tans[i]=max(ans[i],ans[i+1]);\n\tcin>>q;\n\twhile(q--){\n\t\tint x;\n\t\tcin>>x;\n\t\tcout<<ans[x]<<'\\n';\n\t}\n}\n""]","[1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2600
Little Chris is participating in a graph cutting contest He s a pro The time has come to test his skills to the fullest Chris is given a simple undirected connected graph with vertices numbered from 1 to and edges The problem is to cut it into edge distinct paths of length 2 Formally Chris has to partition all edges of the graph into pairs in such a way that the edges in a single pair are adjacent and each edge must be contained in exactly one pair For example the figure shows a way Chris can cut a graph The first sample test contains the description of this graph You are given a chance to compete with Chris Find a way to cut the given graph or determine that it is impossible ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA ""sequence""\n\nint n;\nvector<int> gr[110000];\nint D[110000];\nvector<pair<int,PII> > ans;\n\nbool dfs(int v,int d,int pr){\n\tD[v]=d;\n\tint x=-1;\n\tforv(i,gr[v]){\n\t\tint p=gr[v][i];\n\t\tbool t=false;\n\t\tif(D[p]){\n\t\t\tif(p != pr && D[p]<d)\n\t\t\t\tt=true;\n\t\t}else\n\t\t\tt=dfs(p,d+1,v);\n\t\tif(!t)\n\t\t\tcontinue;\n\t\tif(x==-1)\n\t\t\tx=p;\n\t\telse{\n\t\t\tans.pb(mp(p,mp(v,x)));\n\t\t\tx=-1;\n\t\t}\n\t}\n\tif(x!=-1){\n\t\tans.pb(mp(pr,mp(v,x)));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main(){\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#else\n\t//freopen(TASKA"".in"", ""r"", stdin); freopen(TASKA"".out"", ""w"", stdout);\n#endif\n\t\n\tint m;\n\tcin>>n>>m;\n\tforn(i,m){\n\t\tint a,b;\n\t\tscanf(""%d%d"",&a,&b);\n\t\t--a;--b;\n\t\tgr[a].pb(b);\n\t\tgr[b].pb(a);\n\t}\n\tif(!dfs(0,1,-1)){\n\t\tcout<<""No solution"";\n\t\treturn 0;\n\t}\n\tforv(i,ans){\n\t\tprintf(""%d %d %d\\n"",ans[i].X + 1, ans[i].Y.X+1, ans[i].Y.Y+1);\n\t}\n\t\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2300
Little Dormi has recently received a puzzle from his friend and needs your help to solve it The puzzle consists of an upright board with n rows and m columns of cells some empty and some filled with blocks of sand and m non negative integers a 1 a 2 ldots a m 0 leq a i leq n In this version of the problem a i will be the number of blocks of sand in column i When a cell filled with a block of sand is disturbed the block of sand will fall from its cell to the sand counter at the bottom of the column each column has a sand counter While a block of sand is falling other blocks of sand that are adjacent at any point to the falling block of sand will also be disturbed and start to fall Specifically a block of sand disturbed at a cell i j will pass through all cells below and including the cell i j within the column disturbing all adjacent cells along the way Here the cells adjacent to a cell i j are defined as i 1 j i j 1 i 1 j and i j 1 if they are within the grid Note that the newly falling blocks can disturb other blocks In one operation you are able to disturb any piece of sand The puzzle is solved when there are a i blocks of sand counted in the i th sand counter for each column from 1 to m You are now tasked with finding the minimum amount of operations in order to solve the puzzle Note that Little Dormi will never give you a puzzle that is impossible to solve ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n/**\n * Description: Tarjan\'s, DFS once to generate \n \t* strongly connected components in topological order. $a,b$\n \t* in same component if both $a\\to b$ and $b\\to a$ exist.\n \t* Uses less memory than Kosaraju b/c doesn\'t store reverse edges.\n * Time: O(N+M)\n * Source: KACTL\n \t* https://github.com/kth-competitive-programming/kactl/blob/master/content/graph/SCC.h\n * Verification: https://cses.fi/problemset/task/1686/\n */\n\nstruct SCC {\n\tint N, ti = 0; V<vi> adj;\n\tvi disc, comp, stk, comps;\n\tvoid init(int _N) { N = _N; adj.rsz(N), disc.rsz(N), comp = vi(N,-1); }\n\tvoid ae(int x, int y) { adj[x].pb(y); }\n\tint dfs(int x) {\n\t\tint low = disc[x] = ++ti; stk.pb(x);\n\t\teach(y,adj[x]) if (comp[y] == -1) // comp[y] == -1, disc[y] != 0 -> in stack\n\t\t\tckmin(low,disc[y]?:dfs(y)); \n\t\tif (low == disc[x]) { // make new SCC, pop off stack until you find x\n\t\t\tcomps.pb(x); for (int y = -1; y != x;) \n\t\t\t\tcomp[y = stk.bk] = x, stk.pop_back();\n\t\t}\n\t\treturn low;\n\t}\n\tint gen() {\n\t\tF0R(i,N) if (!disc[i]) dfs(i);\n\t\treverse(all(comps));\n\t\tvi in_deg(N);\n\t\tF0R(i,N) each(j,adj[i]) if (comp[i] != comp[j]) \n\t\t++in_deg[comp[j]];\n\t\tint ans = 0;\n\t\tF0R(i,N) if (comp[i] == i && in_deg[i] == 0) ++ans;\n\t\treturn ans;\n\t}\n};\n\nint N,M;\nvs B;\nvi A;\nV<vb> done;\n\n// void make_done(int x, int y) {\n// \tif (x < 0 || x >= N || y <)\n// \tif (!done[x][y]) return;\n// \tdone[x][y] = 1;\n\n// }\n\nint main() {\n\tsetIO();\n\tre(N,M);\n\tB.rsz(N); re(B);\n\tA.rsz(M); re(A);\n\t// done = V<vb>(N,vb(M));\n\t// int ans = 0;\n\tV<vi> imp(N,vi(M));\n\tF0R(i,N) F0R(j,M) {\n\t\timp[i][j] = B[i][j] == \'#\';\n\t\tif (i) imp[i][j] |= imp[i-1][j];\n\t}\n\tauto exists = [&](int x, int y) {\n\t\treturn 0 <= x && x < N && 0 <= y && y < M && B[x][y] == \'#\';\n\t};\n\tSCC S; S.init(N*M);\n\tauto hsh = [&](int x, int y) {\n\t\treturn M*x+y;\t\n\t};\n\tauto ae = [&](pi x, pi y) {\n\t\tS.ae(hsh(x.f,x.s),hsh(y.f,y.s));\n\t};\n\tF0R(i,N) F0R(j,M) if (imp[i][j]) {\n\t\tF0R(d,4) {\n\t\t\tint ii = i+dx[d], jj = j+dy[d];\n\t\t\tif (exists(ii,jj)) ae({i,j},{ii,jj});\n\t\t}\n\t\tif (i+1 < N) ae({i,j},{i+1,j});\n\t}\n\tint ans = S.gen();\n\tdbg(""OH"",ans);\n\tF0R(i,N) F0R(j,M) if (!imp[i][j]) --ans;\n\tps(ans);\n\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2500
Polycarp is reading a book consisting of n pages numbered from 1 to n Every time he finishes the page with the number divisible by m he writes down the last digit of this page number For example if n 15 and m 5 pages divisible by m are 5 10 15 Their last digits are 5 0 5 correspondingly their sum is 10 Your task is to calculate the sum of all digits Polycarp has written down You have to answer q independent queries ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nconst int N = 2e5 + 5;\nint a[N];\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int q;\n    cin >> q;\n    while(q--) {\n        ll x, m;\n        cin >> x >> m;\n        int k = x / m;\n        m %= 10;\n        int cyc = 1;\n        int val = m % 10;\n        int s = 0;\n        while(val != 0) {\n            s += val;\n            val = (val + m) % 10;\n            cyc++;\n        }\n        // cout << m << "" "" << cyc << "" "" << s << endl;\n        int ans = (k / cyc) * s;\n        k %= cyc;\n        for(int i = 1; i <= k; i++) {\n            ans += (i * m) % 10;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Vasya decided to pass a very large integer to Kate First he wrote that number as a string then he appended to the right integer the number of digits in Magically all the numbers were shuffled in arbitrary order while this note was passed to Kate The only thing that Vasya remembers is a non empty substring of a substring of is a sequence of consecutive digits of the number Vasya knows that there may be more than one way to restore the number Your task is to find the smallest possible initial integer Note that decimal representation of number contained no leading zeroes except the case the integer was equal to zero itself in this case a single digit was used ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n#include <numeric>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <vector>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate <typename T>\nT nextInt() {\n    T x = 0, p = 1;\n    char ch;\n    do { ch = getchar(); } while(ch <= \' \');\n    if (ch == \'-\') {\n        p = -1;\n        ch = getchar();\n    }\n    while(ch >= \'0\' && ch <= \'9\') {\n        x = x * 10 + (ch - \'0\');\n        ch = getchar();\n    }\n    return x * p;\n}\n\nconst int maxN = (int)1e6 + 10;\nconst int maxL = 17;\nconst int INF = (int)1e9;\nconst int mod = (int)1e9 + 7;\nconst ll LLINF = (ll)1e18;\n\nvector <int> a(10);\nvector <int> b(10);\nchar s[maxN];\nchar t[maxN];\n\nstring get(const vector<int>&cnt) {\n    string ret = """";\n    for (int i = 0; i < 10; ++i) {\n        ret += string(cnt[i], char(\'0\' + i));\n    }\n    return ret;\n}\n\nint main() {\n\n  //  freopen(""input.txt"", ""r"", stdin);\n   // freopen(""output.txt"", ""w"", stdout);\n    gets(s);\n    gets(t);\n\n    if (strcmp(s, ""01"") == 0 || strcmp(s, ""10"") == 0) {\n        puts(""0"");\n        return 0;\n    }\n\n    int n = strlen(s);\n    int m = strlen(t);\n\n    for (int i = 0; i < n; ++i) {\n        a[s[i] - \'0\']++;\n    }\n    for (int i =0 ; i < m; ++i) {\n        b[t[i] - \'0\']++;\n    }\n\n    string T = (const char *) t;\n\n    for (int len = 1; ; ++len) {\n        vector <int> cnt = a;\n        int tmp = len;\n        int c = 0;\n        while(tmp > 0) {\n            cnt[tmp % 10]--;\n            tmp /= 10;\n            c++;\n        }\n        bool ok = true;\n        for (int i = 0; i < 10; ++i) {\n            cnt[i] -= b[i];\n            if (cnt[i] < 0) ok = false;\n        }\n        if (ok && (t[0] != \'0\' || *max_element(cnt.begin() + 1, cnt.end())) > 0 && n - c == len) {\n\n        } else continue;\n        bool have = false;\n        string best = """";\n        {\n            string cur = T + get(cnt);\n            if (cur[0] != \'0\') {\n                if (!have || best > cur) {\n                    best = cur;\n                    have = true;\n                }\n            }\n        }\n        string cur = """";\n        for (int i = 1; i < 10; ++i) {\n            if (cnt[i] > 0) {\n                cur += char(i + \'0\');\n                cnt[i]--;\n                break;\n            }\n        }\n        for (int i = 0; i <= 10; ++i) {\n            string now = cur + T + get(cnt);\n\n            if (now[0] != \'0\') {\n                if (!have || best > now) {\n                    best = now;\n                    have = true;\n                }\n            }\n            if (i != 10) {\n                cur += string(cnt[i], char(i + \'0\'));\n                cnt[i] = 0;\n            }\n        }\n        assert(have);\n     //   cout << len << \'\\n\';\n        puts(best.c_str());\n        exit(0);\n    }\n\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0]",2300
Ray lost his array and needs to find it by asking Omkar Omkar is willing to disclose that the array has the following qualities The array has n 1 le n le 2 cdot 10 5 elements Every element in the array a i is an integer in the range 1 le a i le 10 9 The array is sorted in nondecreasing order Ray is allowed to send Omkar a series of queries A query consists of two integers l and r such that 1 le l le r le n Omkar will respond with two integers x and f x is the mode of the subarray from index l to index r inclusive The mode of an array is defined by the number that appears the most frequently If there are multiple numbers that appear the most number of times the smallest such number is considered to be the mode f is the amount of times that x appears in the queried subarray The array has k 1 le k le min 25000 n distinct elements However due to Ray s sins Omkar will not tell Ray what k is Ray is allowed to send at most 4k queries Help Ray find his lost array ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef pair<int ,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef double rl;\n\ntypedef pii int2;\ntypedef tuple<int, int, int>           int3;\ntypedef tuple<int, int, int, int>      int4;\ntypedef tuple<int, int, int, int, int> int5;\n\ntypedef pll ll2;\ntypedef tuple<ll, ll, ll>         ll3;\ntypedef tuple<ll, ll, ll, ll>     ll4;\ntypedef tuple<ll, ll, ll, ll, ll> ll5;\n\n#define g0(x) get<0>(x)\n#define g1(x) get<1>(x)\n#define g2(x) get<2>(x)\n#define g3(x) get<3>(x)\n#define g4(x) get<4>(x)\n\ntypedef vector<int> vi;\ntypedef vector<pii> vii;\ntypedef vector<ll> vll;\ntypedef vector<pll> vll_ll;\ntypedef vector<vi> vvi;\ntypedef vector<vii> vvii;\ntypedef vector<vll> vvll;\ntypedef vector<vll_ll> vvll_ll;\n\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define xx first\n#define yy second\n\n#define FOR(i,N) for(int i=0; i<N; i++)\n\n#define popc __builtin_popcountll\n// #define popc __builtin_popcount\n\ntemplate<typename A>\nstring to_string(A* ptr)\n{\n    stringstream ss; ss << ""0x"" << std::setw(16) << std::setfill (\'0\') << std::hex << (uint64_t)(uintptr_t)ptr;\n    return ss.str();\n}\n\nstring to_string(char c)\n{\n    return ((string)""\'""+c)+ ""\'"";\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#if !ONLINE_JUDGE && 1\n#define dbg(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define dbg(...) 42\n#endif\n\nint n;\npii query(int l, int r)\n{\n    cout << ""? "" << l << \' \' << r << \'\\n\';\n    cout.flush();\n\n    int x, f;\n    cin >> x >> f;\n    return {x, f};\n}\n\nconst int MX=2e5+99;\nint a[MX];\nconst int DUNNO=-1;\nconst int BOUND=1\'000\'000\'000;\n\nvoid guess()\n{\n    cout << ""! "";\n    for(int i=1; i<=n; i++)\n    {\n        assert(1<=a[i] && a[i]<=BOUND);\n        cout << a[i] << \' \';\n    }\n    cout << \'\\n\';\n    cout.flush();\n}\n\nvoid solve(int L, int R)\n{\n    //dbg(L, R);\n    int aL=a[L], aR=a[R];\n\n    if(aL==aR)\n    {\n        for(int i=L+1; i<R; i++) a[i]=aL;\n        return;\n    }\n\n    if(L+1 == R) return;\n\n    auto [x, f]=query(L, R);\n    if(x==aL)\n    {\n        for(int i=1; i<f; i++) a[L+i]=aL;\n        if(L+f<R)\n        {\n            a[L+f]=query(L+f, L+f).xx;\n            solve(L+f, R);\n        }\n    }\n    else if(x==aR)\n    {\n        for(int i=1; i<f; i++) a[R-i]=aR;\n        if(L<R-f)\n        {\n            a[R-f]=query(R-f, R-f).xx;\n            solve(L, R-f);\n        }\n    }\n    else\n    {\n        //TODO;\n        a[L+f-1]=query(L+f-1, L+f-1).xx;\n        solve(L, L+f-1);\n        solve(L+f-1, R);\n    }\n}\n\nvoid solve()\n{\n    for(int i=1; i<=n; i++) a[i]=DUNNO;\n    a[1]=query(1,1).xx;\n    a[n]=query(n,n).xx;\n\n    solve(1, n);\n\n    guess();\n}\n\nint main()\n{\n#if !ONLINE_JUDGE && 0\n    freopen(""F.txt"", ""r"", stdin);\n    //freopen(""output.txt"", ""w"", stdout);\n#endif\n#if 0\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n#endif\n\n    //int TT;\n#if 0\n    cin >> TT;\n#else\n    //TT=1;\n#endif\n    /*\n    for(int ttt=0; ttt<TT; ttt++)\n    {\n\n    }\n    */\n    cin >> n;\n    solve();\n\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2700
Shiro s just moved to the new house She wants to invite all friends of her to the house so they can play monopoly However her house is too small so she can only invite one friend at a time For each of the n days since the day Shiro moved to the new house there will be exactly one cat coming to the Shiro s house The cat coming in the i th day has a ribbon with color u i Shiro wants to know the largest number x such that if we consider the streak of the first x days it is possible to remove day from this streak so that every ribbon color among the remaining x 1 will have the same number of occurrences For example consider the following sequence of u i 2 2 1 1 5 4 4 5 Then x 7 makes a streak since if we remove the leftmost u i 5 each ribbon color will appear exactly twice in the prefix of x 1 days Note that x 8 doesn t form a streak since you must remove exactly one day Since Shiro is just a cat she is not very good at counting and needs your help finding the longest streak ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 6;\nint n, a[N], c[N], d[N], mx, cnt;\nset<int> s;\n\ninline bool pd(int o) {\n\tif (s.size() == 1u && *s.begin() == 1) return 1;\n\tif (s.size() == 1u && *s.begin() == o) return 1;\n\tif (s.size() != 2u) return 0;\n\tint k = *s.begin(), t = *(++s.begin());\n\tif (k == 1 && (cnt - 1) * t == o - 1) return 1;\n\tif (cnt * k == o - 1 && k + 1 == t) return 1;\n\treturn 0;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tc[a[i]]++;\n\t\tmx = max(mx, a[i]);\n\t}\n\tfor (int i = 1; i <= mx; i++)\n\t\tif (c[i] && ++cnt && !d[c[i]]++)\n\t\t\ts.insert(c[i]);\n\tfor (int i = n; i; i--) {\n\t\tif (pd(i)) {\n\t\t\tcout << i << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!--d[c[a[i]]]) s.erase(c[a[i]]);\n\t\tif (!--c[a[i]]) --cnt;\n\t\tif (c[a[i]] && !d[c[a[i]]]++) s.insert(c[a[i]]);\n\t}\n\treturn 0;\n} ']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Limak is a little bear who loves to play Today he is playing by destroying block towers He built towers in a row The th tower is made of identical blocks For clarification see picture for the first sample Limak will repeat the following operation till everything is destroyed Block is called internal if it has all four neighbors i e it has each side top left down and right adjacent to other block or to the floor Otherwise block is boundary In one operation Limak destroys all boundary blocks His paws are very fast and he destroys all those blocks at the same time Limak is ready to start You task is to count how many operations will it take him to destroy all towers ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100010\nint n;\nint t[MAX];\nint w1[MAX],w2[MAX];\nmain(){\n  make(n);\n  R(i,n)make(t[i]);\n  R(i,n)w1[i+1] = min(w1[i]+1,t[i]);\n  FD(i,n)w2[i] = min(w2[i+1]+1,t[i]);\n  int wyn = 0;\n  R(i,n)MA(wyn,min(w1[i+1],w2[i]));\n  printf(""%d\\n"",wyn);\n}\n']","[0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1600
As Sherlock Holmes was investigating a crime he identified suspects He knows for sure that exactly one of them committed the crime To find out which one did it the detective lines up the suspects and numbered them from to After that he asked each one Which one committed the crime Suspect number answered either The crime was committed by suspect number or Suspect number didn t commit the crime Also the suspect could say so about himself Sherlock Holmes understood for sure that exactly answers were the truth and all other answers were a lie Now help him understand this which suspect lied and which one told the truth ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <algorithm>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nint main() {\n  #ifdef DEBUG\n  freopen(""std.in"", ""r"", stdin);\n  freopen(""std.out"", ""w"", stdout);\n  #endif\n\n  int n, m;\n  while (scanf(""%d%d"", &n, &m) >= 1) {\n    vi t(n), f(n);\n    vi as(n);\n    for (int i = 0; i < n; i++) {\n      scanf(""%d"", &as[i]);\n      if (as[i] > 0) t[as[i] - 1]++;\n      else f[-as[i] - 1]++;\n    }\n\n    int sf = 0;\n    for (int i = 0; i < n; i++)\n      sf += f[i];\n\n    int kcnt = 0;\n    vb ckill(n, false);\n    for (int kill = 0; kill < n; kill++) {\n      int ccnt = t[kill] + sf - f[kill];\n      if (ccnt != m) continue;\n      kcnt++;\n      ckill[kill] = true;\n    }\n    assert(kcnt >= 1);\n\n    for (int i = 0; i < n; i++) {\n      int x = abs(as[i]) - 1;\n\n      if (as[i] > 0) {\n        if (!ckill[x]) printf(""Lie\\n"");\n        else if (kcnt == 1) printf(""Truth\\n"");\n        else printf(""Not defined\\n"");\n      } else {\n        if (!ckill[x]) printf(""Truth\\n"");\n        else if (kcnt == 1) printf(""Lie\\n"");\n        else printf(""Not defined\\n"");\n      }\n    }\n  }\n  return 0;\n}\n']","[0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Tenzing has n animal friends He numbers them from 1 to n One day Tenzing wants to play with his animal friends To do so Tenzing will host several games In one game he will choose a set S which is a subset of 1 2 3 n and choose an integer t Then he will play the game with the animals in S for t minutes But there are some restrictions Tenzing loves friend 1 very much so 1 must be an element of S Tenzing doesn t like friend n so n must not be an element of S There are m additional restrictions The i th special restriction is described by integers u i v i and y i suppose x is the time that one of u i and v i is playing with Tenzing Tenzing must ensure that x is less or equal to y i Otherwise there will be unhappiness Tenzing wants to know the maximum total time that he can play with his animal friends Please find out the maximum total time that Tenzing can play with his animal friends and a way to organize the games that achieves this maximum total time or report that he can play with his animal friends for an infinite amount of time Also Tenzing does not want to host so many games so he will host at most n 2 games ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:31:38       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  const long long inf = (long long) 1e18;\n  vector<vector<long long>> g(n, vector<long long>(n, inf));\n  for (int i = 0; i < n; i++) {\n    g[i][i] = 0;\n  }\n  dsu d(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, z;\n    cin >> x >> y >> z;\n    --x; --y;\n    d.unite(x, y);\n    g[x][y] = z;\n    g[y][x] = z;\n  }\n  if (d.get(0) != d.get(n - 1)) {\n    cout << ""inf"" << \'\\n\';\n    return 0;\n  }\n  vector<pair<string, long long>> res;\n  long long ans = 0;\n  while (true) {\n    string s(n, \'0\');\n    s[0] = \'1\';\n    vector<int> que(1, 0);\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int to = 0; to < n; to++) {\n        if (s[to] == \'0\' && g[que[b]][to] == 0) {\n          que.push_back(to);\n          s[to] = \'1\';\n        }\n      }\n    }\n    if (s[n - 1] == \'1\') {\n      break;\n    }\n    long long T = inf;\n    for (int i = 0; i < n; i++) {\n      if (s[i] == \'1\') {\n        for (int j = 0; j < n; j++) {\n          if (s[j] == \'0\') {\n            T = min(T, g[i][j]);\n          }\n        }\n      }\n    }\n    ans += T;\n    res.emplace_back(s, T);\n    for (int i = 0; i < n; i++) {\n      if (s[i] == \'1\') {\n        for (int j = 0; j < n; j++) {\n          if (s[j] == \'0\') {\n            g[i][j] -= T;\n            g[j][i] -= T;\n          }\n        }\n      }\n    }\n  }\n  cout << ans << "" "" << res.size() << \'\\n\';\n  for (auto& p : res) {\n    cout << p.first << "" "" << p.second << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1900
A boy named Gena really wants to get to the Russian Code Cup finals or at least get a t shirt But the offered problems are too complex so he made an arrangement with his friends that they will solve the problems for him The participants are offered problems on the contest For each friend Gena knows what problems he can solve But Gena s friends won t agree to help Gena for nothing the th friend asks Gena rubles for his help he can Also the friend agreed to write a code for Gena only if Gena s computer is connected to at least monitors each monitor costs rubles Gena is careful with money so he wants to spend as little money as possible to solve all the problems Help Gena tell him how to spend the smallest possible amount of money Initially there s no monitors connected to Gena s computer ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst long long inf = (long long)4e18;\n\nconst int N = 12345;\nconst int T = (1 << 21);\n\nint x[N], k[N], mask[N];\nlong long f[T];\n\nint main() {\n  int n, m, b;\n  scanf(""%d %d %d"", &n, &m, &b);\n  for (int i = 0; i < n; i++) {\n    int foo;\n    scanf(""%d %d %d"", x + i, k + i, &foo);\n    mask[i] = 0;\n    while (foo--) {\n      int bar;\n      scanf(""%d"", &bar);\n      mask[i] |= (1 << (bar - 1));\n    }\n  }\n  for (int i = 0; i < n; i++)\n    for (int j = i + 1; j < n; j++)\n      if (k[i] > k[j]) {\n        swap(x[i], x[j]);\n        swap(k[i], k[j]);\n        swap(mask[i], mask[j]);\n      }\n  for (int i = 0; i < (1 << m); i++) f[i] = inf;\n  f[0] = 0;\n  long long ans = inf;\n  for (int i = 0; i < n; i++) {\n    for (int t = 0; t < (1 << m); t++)\n      if (f[t] + x[i] < f[t | mask[i]]) {\n        f[t | mask[i]] = f[t] + x[i];\n      }\n    long long cur = f[(1 << m) - 1];\n    cur += 1LL * k[i] * b;\n    if (cur < ans) ans = cur;\n  }\n  cout << (ans == inf ? -1 : ans) << endl;\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1900
She is skilled in all kinds of magics and is keen on inventing new one Patchouli is making a magical talisman She initially has n magical tokens Their magical power can be represented with integers a 1 a 2 ldots a n Patchouli may perform the following two operations on the tokens Patchouli chooses two tokens removes them and creates a new token with magical power equal to the sum of the two chosen tokens Patchouli chooses a token with an value of magical power x removes it and creates a new token with magical power equal to frac x 2 Tokens are more effective when their magical powers are values Please help Patchouli to find the minimum number of operations she needs to make magical powers of all tokens values ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconstexpr int inf = 1e18;\nconstexpr int maxn = 2e5 + 5;\nconstexpr int mod = 998244353;\n\ninline void solve()\n{\n  int n; cin >> n;\n  vector<int> a(n);\n  for (int &x : a)\n    cin >> x;\n  int Min = 31, cnt = 0;\n  for (int x : a)\n  {\n    if (!(x & 1))\n    {\n      cnt ++;\n      int z = (int)__builtin_ctz(x);\n      if (z == 32)\n        z = 0;\n      Min = min(Min, z);\n    }\n  }\n  if (cnt == n)\n    cnt = Min - 1 + n;\n  cout << cnt << '\\n';\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T; cin >> T;\n  while (T --)\n  solve();\n  return 0;\n}""]","[1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",800
One day shooshuns found a sequence of integers written on a blackboard The shooshuns can perform one operation with it the operation consists of two steps Find the number that goes th in the current sequence and add the same number to the end of the sequence Delete the first number of the current sequence The shooshuns wonder after how many operations all numbers on the board will be the same and whether all numbers will ever be the same ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nint a[ 100001 ];\n\nint main( )\n{\n\tint n, k, i, j;\n\tscanf(""%d%d"", &n, &k);\n\tfor ( i = 0; i < n; i++ )\n\t\tscanf(""%d"", &a[ i ]);\n\tfor ( i = k; i < n; i++ )\n\t\tif ( a[ i ] != a[ k - 1 ] )\n\t\t\tbreak;\n\tif ( i < n )\n\t\tputs(""-1"");\n\telse\n\t{\n\t\tfor ( i = k - 2; i >= 0; i-- )\n\t\t\tif ( a[ i ] != a[ k - 1 ] )\n\t\t\t\tbreak;\n\t\tprintf(""%d\\n"", i + 1);\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You re given a multiset of non negative integers a 1 a 2 dots a n In one step you take two elements x and y of the multiset remove them and insert their mean value frac x y 2 back into the multiset You repeat the step described above until you are left with only two numbers A and B What is the maximum possible value of their absolute difference A B Since the answer is not an integer number output it modulo 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1e9+7;\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  int T;\n  cin >> T;\n  while (T--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& x: a) cin >> x;\n    sort(a.begin(), a.end());\n    vector<pair<int, int>> terms;\n    auto get_sign = [&] () {\n      sort(terms.begin(), terms.end(), greater<>());\n      int eps = 0;\n      int cur = 1e9;\n      long long sum = 0;\n      for (auto& [e, x]: terms) {\n        if (e < cur) {\n          while (sum && cur > e) {\n            if (sum&1) {\n              if (sum > 0) eps = 1;\n              else if (sum < 0) eps = -1;\n            }\n            sum /= 2;\n            cur--;\n          }\n          cur = e;\n        }\n        sum += x;\n        //cout << e << \' \' << x << \' \' << sum << \' \' << eps << endl;\n      }\n      if (sum > 0) return 1;\n      if (sum < 0) return -1;\n      if (eps > 0) return 1;\n      if (eps < 0) return -1;\n      return 0;\n    };\n\n    auto calc = [&] (auto&& self, int l, int r) {\n      if (l == r) return l;\n      int m = (l+r)/2;\n      int x1 = self(self, l, m);\n      int x2 = self(self, m+1, r);\n      terms.clear();\n      terms.emplace_back(x1, -a[x1]);\n      for (int i = x1+1; i <= x2+1; i++) {\n        terms.emplace_back(n-i-(i == x1+1), a[i]);\n      }\n      for (int i = x1; i <= x2; i++) {\n        terms.emplace_back(i+1-(i == x2), a[i]);\n      }\n      terms.emplace_back(n-2-x2, -a[x2+1]);\n      //cout << ""split "" << x1 << \' \' << x2 << endl;\n      //for (auto& [e, x]: terms) cout << e << \' \' << x << endl;\n      if (get_sign() > 0) return x1;\n      return x2;\n    };\n    int c = calc(calc, 0, n-2);\n    //cout << c << endl;\n\n    int ans = 0;\n    int pw = 1;\n    for (int i = 0; i <= c; i++) {\n      if (i != c) pw = 1LL*pw*(MOD+1)/2 % MOD;\n      ans = (ans-1LL*pw*a[i]) % MOD;\n    }\n    pw = 1;\n    for (int i = n-1; i >= c+1; i--) {\n      if (i != c+1) pw = 1LL*pw*(MOD+1)/2 % MOD;\n      ans = (ans+1LL*pw*a[i]) % MOD;\n    }\n    if (ans < 0) ans += MOD;\n    cout << ans << \'\\n\';\n  }\n}\n']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3400
The Little Elephant loves numbers He has a positive integer The Little Elephant wants to find the number of positive integers such that is the divisor of and and have at least one common the same digit in their decimal representations Help the Little Elephant to find the described number ,"['#include <vector>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define sz size\n#define re return\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define abs(x) ((x) < 0 ? -(x) : (x))\n#define INF 2000000000\n#define sqr(x) ((x) * (x))\n#define all(x) x.begin(), x.end()\n\nlong long int x, d, res;\nint a[1000], l;\n\nint main() {\n\n#ifndef ONLINE_JUDGE\t          \n\tfreopen(""a.in"", ""r"", stdin);\n\tfreopen(""a.out"", ""w"", stdout);\n#endif\n\tcin >> x;\n\td = x;\n\twhile(d) {\n\t\ta[++l] = d % 10;\n\t\td /= 10;\n\t}\n\n\tfor(int i = 1; i * i <= x; i++) {\n\t\tif(x % i == 0) {\n\t\t\t    d = i;\n\t\t\t    bool ok = 1;\n\t\t\t\twhile(d) {\n\t\t\t\t\tfor(int i = 1; i <= l; i++)\n\t\t\t\t\t\tif(a[i] == d % 10) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif(!ok) {\n\t\t\t\t\t\tres++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\td /= 10;\t\n\t\t\t\t}\n\t\t\tif(x / i != i) {\n\t\t\t\td = x / i;\n\t\t\t    bool ok = 1;\n\t\t\t\twhile(d) {\n\t\t\t\t\tfor(int i = 1; i <= l; i++)\n\t\t\t\t\t\tif(a[i] == d % 10) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tif(!ok) {\n\t\t\t\t\t\tres++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\td /= 10;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n\tcout << res;\n\treturn 0;\n}\n\t\t\n\n\t\t\t\t\t\t\n\t\n\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
JATC s math teacher always gives the class some interesting math problems so that they don t get bored Today the problem is as follows Given an integer n you can perform the following operations zero or more times x multiplies n by x where x is an arbitrary positive integer replaces n with sqrt n to apply this operation sqrt n must be an integer You can perform these operations as many times as you like What is the minimum value of n that can be achieved and what is the minimum number of operations to achieve that minimum value Apparently no one in the class knows the answer to this problem maybe you can help them ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint f(int x) {\n\tif (x == 1) return 0;\n\telse if (x%2 == 1) return f(x+1)+1;\n\telse return 1+f(x/2);\n}\n\nint main () {\n\tint n;\n\tcin >> n;\n\tint op=0;\n\tint ans = 1;\n\tset<int> st;\n\tfor (int i=2;i<=n;++i) {\n\t\tint cnt=0;\n\t\twhile (n%i == 0) {\n\t\t\t++cnt;\n\t\t\tn /= i;\n\t\t}\n\t\tif (!cnt) continue;\n\t\tans *= i;\n\t\tst.insert(cnt);\n\t\tcerr << ""i = "" << i << "" , cnt = "" << cnt << endl;\n\t\t//op = max(op,f(cnt));\n\t}\n\tif (st.size() == 0) {\n\t\tcout << ans << \' \' << 0 << endl;\n\t\treturn 0;\n\t}\n\tif (st.size() == 1) {\n\t\tint x = *st.begin();\n\t\tint p=1;\n\t\tint xx=x;\n\t\twhile (x) {\n\t\t\tx>>=1;\n\t\t\tp<<=1;\n\t\t}\n\t\tint pre=1;\n\t\tif (xx == p/2) p = xx,pre=0;\n\t\tcerr << ""p = "" << p << endl;\n\t\tcout << ans << \' \' << f(p)+pre << endl;\n\t\treturn 0;\n\t}\n\tint x = *(--st.end());\n\tint p=1;\n\tint xx=x;\n\twhile (x) {\n\t\tx>>=1;\n\t\tp<<=1;\n\t}\n\tif (xx == p/2) p = xx;\n\tcout << ans << \' \' << f(p)+1 << endl;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1500
Natasha is planning an expedition to Mars for n people One of the important tasks is to provide food for each participant The warehouse has m daily food packages Each package has some food type a i Each participant must eat exactly one food package each day Due to extreme loads each participant must eat the same food type throughout the expedition Different participants may eat different or the same types of food Formally for each participant j Natasha should select his food type b j and each day j th participant will eat one food package of type b j The values b j for different participants may be different What is the maximum possible number of days the expedition can last following the requirements above ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint cnt[105];\n\nint main() {\n  int n,m;\n  scanf(""%d%d"",&m,&n);\n  for(int i=1;i<=n;i++) {\n  \tint x;\n  \tscanf(""%d"",&x);\n  \tcnt[x]++;\n  }\n  int ans=0;\n  for(int i=n;i>0;i--) {\n  \tint s=0;\n  \tfor(int j=1;j<=100;j++) s+=cnt[j]/i;\n  \tif (s>=m) {\n  \t\tans=i;\n  \t\tbreak;\n\t  }\n  }\n  printf(""%d\\n"",ans);\n  return 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",1200
Programming teacher Dmitry Olegovich is going to propose the following task for one of his tests for students You are given a tree with vertices specified by its adjacency matrix What is the output of the following pseudocode used 1 n 0 0 procedure dfs v print v used v 1 for i 1 2 n if a v i 1 and used i 0 dfs i dfs 1 In order to simplify the test results checking procedure Dmitry Olegovich decided to create a tree such that the result is his favorite sequence On the other hand Dmitry Olegovich doesn t want to provide students with same trees as input otherwise they might cheat That s why Dmitry Olegovich is trying to find out the number of different trees such that the result of running the above pseudocode with as input is exactly the sequence Can you help him Two trees with vertices are called different if their adjacency matrices and are different i e there exists a pair such that and ,"['#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<set>\nusing namespace std;\n#define ll long long \n#define pp 1000000007\n#define N 510\nll dp[N][N];\nint a[N],n;\nll mo(ll a){\n   if(a>=0 && a<pp)return a;\n   a%=pp;\n   if(a<0)a+=pp;\n   return a;\n}\nint main(){\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++)scanf(""%d"",&a[i]);\n    for(int i=0;i<=n+1;i++)dp[i][i-1]=1;\n    for(int i=1;i<=n;i++)dp[i][i]=1;\n    for(int len=2;len<n;len++)\n      for(int i=1;i+len-1<=n;i++){\n        int j=i+len-1;\n        dp[i][j]=dp[i+1][j];\n        for(int k=i+1;k<=j;k++)\n          if(a[k]>a[i])dp[i][j]=mo(dp[i][j]+dp[i+1][k-1]*dp[k][j]);\n      }\n    cout<<dp[2][n]<<endl;\n    return 0;\n} \n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2300
Advertising has become part of our routine And now in the era of progressive technologies we need your ideas to make advertising better In this problem we ll look at a simplified version of context advertising You ve got a text consisting of exactly words A standard advertising banner has exactly lines each line can contain at most characters The potential customer always likes it when they can see lots of advertising so you should determine which maximum number of consecutive words from the text can be written on the banner Single words in one line of the banner should be separated by spaces You are allowed to insert more than one space at once Note that you are not allowed to break the words that is each word in the text must occupy exactly one line in the banner Besides you cannot change the word order that is if you read the banner text consecutively from top to bottom and from left to right you should get some consecutive part of the advertisement text More formally the statement can be written like that Let s say that all words are indexed from to in the order in which they occur in the advertisement text Then you have to choose all words starting from some th one and ending with some th one so that all of them could be written on the banner There must be as many words as possible See the samples for clarifications ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(""%d"", &x); return x; }\n\n#define MAXN 1000010\n\nchar buf[6000010];\n\nint N, R, C;\nstring S[MAXN];\n\nint A[MAXN];\nint ASum[MAXN];\nint to[MAXN];\n\nint crt[MAXN], nxt[MAXN];\n\nvoid solve(int e) {\n\tint i;\n\tif (e == 0) {\n\t\tfor (i = 0; i <= N; ++i) {\n\t\t\tcrt[i] = i;\n\t\t}\n\t\treturn;\n\t}\n\tsolve(e / 2);\n\tfor (i = 0; i <= N; ++i) {\n\t\tnxt[i] = crt[crt[i]];\n\t}\n\tif (e % 2 != 0) {\n\t\tfor (i = 0; i <= N; ++i) {\n\t\t\tcrt[i] = to[nxt[i]];\n\t\t}\n\t} else {\n\t\tfor (i = 0; i <= N; ++i) {\n\t\t\tcrt[i] = nxt[i];\n\t\t}\n\t}\n}\n\nint main() {\n\tint i, j, r;\n\t\n\tfor (; ~scanf(""%d%d%d"", &N, &R, &C); ) {\n\t\tfor (i = 0; i < N; ++i) {\n\t\t\tscanf(""%s"", buf);\n\t\t\tS[i] = buf;\n\t\t}\n\t\tfor (i = 0; i < N; ++i) {\n\t\t\tA[i] = S[i].size() + 1;\n\t\t}\n\t\tfor (i = 0; i < N; ++i) {\n\t\t\tASum[i + 1] = ASum[i] + A[i];\n\t\t}\n\t\tfor (j = 0, i = 0; i <= N; ++i) {\n\t\t\tfor (; j <= N && ASum[j] - ASum[i] <= C + 1; ++j);\n\t\t\t--j;\n\t\t\tto[i] = j;\n\t\t}\n// cout<<""to : "";pv(to,to+N+1);\n\t\tsolve(R);\n// cout<<""crt : "";pv(crt,crt+N+1);\n\t\tint opt = -1;\n\t\tint im = -1;\n\t\tfor (i = 0; i <= N; ++i) {\n\t\t\tif (opt < crt[i] - i) {\n\t\t\t\topt = crt[i] - i;\n\t\t\t\tim = i;\n\t\t\t}\n\t\t}\n\t\tfor (r = 0; r < R; ++r) {\n\t\t\tif (im == to[im]) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = im; i < to[im]; ++i) {\n\t\t\t\tif (i > im) printf("" "");\n\t\t\t\tprintf(""%s"", S[i].c_str());\n\t\t\t}\n\t\t\tputs("""");\n\t\t\tim = to[im];\n\t\t}\ncerr<<""====""<<endl;\n\t}\n\t\n\treturn 0;\n}\n\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
You are given an integer n Find the minimum integer x such that x ge n and the number x is k A number is called k if its decimal representation having no leading zeroes contains no more than k different digits E g if k 2 the numbers 3434443 55550 777 and 21 are k whereas the numbers 120 445435 and 998244353 are not ,"['/*#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\n#pragma GCC target(""avx,avx2,fma"")*/\n// only when really needed\n\n/* GNU G++17 7.3.0: No long long for faster code\n   GNU G++17 9.2.0 (64 bit, msys 2): Long long only for faster code */\n \n#include <bits/stdc++.h>\n  \n#define for1(i,a,b) for (int i = a; i <= b; i++)\n#define for2(i,a,b) for (int i = a; i >= b; i--)\n#define int long long\n\n#define sz(a) (int)a.size()\n#define pii pair<int,int>\n \n/*\n__builtin_popcountll(x) : Number of 1-bit\n__builtin_ctzll(x) : Number of trailing 0\n*/\n \n#define PI 3.1415926535897932384626433832795\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define MOD2 1000000009\n#define EPS 1e-6\n\nusing namespace std;\n\nint t, n, k, res;\nset<int> se;\n\nvoid solve(int cur, int i, int j) {\n    se.insert(cur);\n\n    if (cur >= 1000000000) return;\n\n    if (cur != 0 || i != 0) solve(cur * 10 + i, i, j);\n    if (cur != 0 || j != 0) solve(cur * 10 + j, i, j);\n}\n\nsigned main() {\n    \n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    // freopen(""cf.inp"", ""r"", stdin);\n    // freopen(""cf.out"", ""w"", stdout);\n\n    for1(i,0,9) {\n        for1(j,i,9) solve(0, i, j);\n    }\n\n    cin >> t;\n    while (t--) {\n        res = INF;\n        cin >> n >> k;\n        if (k == 1) {\n            for1(i,1,9) {\n                int p = 0;\n                for1(j,1,15) {\n                    p = p * 10 + i;\n                    if (p >= n) {\n                        res = min(res, p);\n                        break;\n                    }\n                } \n            }\n            cout << res << ""\\n"";\n        }\n        else cout << *se.lower_bound(n) << ""\\n"";\n    }\n    \n}']","[1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0]",1900
children are standing in a circle and playing a game Children s numbers in clockwise order form a permutation of length It is an integer sequence such that each integer from to appears exactly once in it The game consists of steps On each step the current leader with index counts out people in clockwise order starting from the next person The last one to be pointed at by the leader becomes the new leader You are given numbers indices of leaders in the beginning of each step Child with number is the first leader in the game Write a program which will restore a possible permutation If there are multiple solutions then print any of them If there is no solution then print ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define N 111\nint n , m , a[ N ] , l[ N ];\nbool used[ N ];\nint main(){\n  cin >> n >> m;\n  for( int i = 0 ; i < m ; i ++ )\n    cin >> l[ i ];\n  for( int i = 1 ; i < m ; i ++ ){\n    int x = ( l[ i ] - l[ i - 1 ] + n ) % n;\n    if( x == 0 ) x = n;\n    if( a[ l[ i - 1 ] ] == 0 ){\n      if( used[ x ] ){\n        puts( ""-1"" );\n        exit(0);\n      }\n      a[ l[ i - 1 ] ] = x;\n      used[ x ] = true;\n      continue;\n    }\n    if( x != a[ l[ i - 1 ] ] ){\n      puts( ""-1"" );\n      exit(0);\n    }\n  }\n  for( int i = 1 ; i <= n ; i ++ ) if( a[ i ] == 0 )\n    for( int j = 1 ; j <= n ; j ++ ) if( !used[ j ] ){\n      a[ i ] = j;\n      used[ j ] = true;\n      break;\n    }\n  for( int i = 1 ; i <= n ; i ++ )\n    printf( ""%d%c"" , a[ i ] , "" \\n""[ i == n ] );\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Arpa has found a list containing numbers He calls a list bad if and only if it is not empty and see notes section for more information of numbers in the list is Arpa can perform two types of operations Choose a number and delete it with cost Choose a number and increase it by with cost Arpa can apply these operations to as many numbers as he wishes and he is allowed to apply the second operation arbitrarily many times on the same number Help Arpa to find the minimum possible cost to make the list good ,"['#include<map>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 2000000 + 10;\n\nint n;\nlong long x, y;\nlong long cnt[N];\nlong long pre[N];\n\nvoid solve()\n{\n    cin >> n >> x >> y;\n    for(int i = 0; i < n; ++ i) {\n        int t;\n        scanf(""%d"", &t);\n        cnt[t] ++;\n        pre[t] += t;\n    }\n    long long ans = x * n;\n    long long c = x / y;\n\n    for(int i = 1; i < N; ++ i) {\n        cnt[i] += cnt[i - 1];\n        pre[i] += pre[i - 1];\n    }\n\n    for(int d = 2; d <= 1000000; ++ d) {\n        long long tmp_ans = 0;\n        for(int i = 0; i + d < N; i += d) {\n            if (i + d - c > i + 1) {\n                tmp_ans += (cnt[i + d - c - 1] - cnt[i]) * x;\n            }\n            int st = max(i + d - c, i + 1ll);\n            tmp_ans += ((cnt[i + d - 1] - cnt[st - 1]) * (i + d) - (pre[i + d - 1] - pre[st - 1])) * y;\n        }\n        ans = min(ans, tmp_ans);\n    }\n    cout << ans << endl;\n\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2100
You are on the island which can be represented as a n times m table The rows are numbered from 1 to n and the columns are numbered from 1 to m There are k treasures on the island the i th of them is located at the position r i c i Initially you stand at the lower left corner of the island at the position 1 1 If at any moment you are at the cell with a treasure you can pick it up without any extra time In one move you can move up from r c to r 1 c left from r c to r c 1 or right from position r c to r c 1 Because of the traps you can t move down However moving up is also risky You can move up only if you are in a safe column There are q safe columns b 1 b 2 ldots b q You want to collect all the treasures as fast as possible Count the minimum number of moves required to collect all the treasures ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\nvector<int> p[maxn];\nint b[maxn];\n\nint main() {\n    int n, m, k, q; scanf(""%d%d%d%d"", &n, &m, &k, &q);\n    int tp = 0;\n    for (int i = 0; i < k; ++i) {\n        int r, c; scanf(""%d%d"", &r, &c);\n        p[r].push_back(c);\n        tp = max(tp, r);\n    }\n    for (int i = 0; i < q; ++i) scanf(""%d"", &b[i]);\n    sort(b, b + q);\n    \n    int prv = 1, s = 1;\n    vector<pair<int, long long>> cand;\n\n    if (p[1].empty()) {\n        for (int i = 0; i < q; ++i) cand.emplace_back(b[i], b[i] - 1); \n        s = 2;\n    } else {\n        cand = {make_pair(1, 0)};\n    }\n\n    for (int i = s; i <= n; ++i) {\n        if (p[i].empty()) continue;\n        sort(p[i].begin(), p[i].end());\n        int dist = i - prv;\n        int lb = p[i].front(), rb = p[i].back();\n        long long ld = 1e18, rd = 1e18;\n\n        for (int j = 0; j < (int)cand.size(); ++j) {\n            long long ldp = cand[j].second + abs(cand[j].first - rb) + abs(rb - lb) + dist;\n            long long rdp = cand[j].second + abs(cand[j].first - lb) + abs(rb - lb) + dist;\n            ld = min(ld, ldp);\n            rd = min(rd, rdp);\n        }\n\n        if (i == tp) {\n            printf(""%lld\\n"", min(ld, rd));\n            return 0;\n        }\n\n        int pos = lower_bound(b, b + q, lb) - b;\n        vector<pair<int, long long>> ncand;\n        if (pos != q) ncand.emplace_back(b[pos], ld + abs(b[pos] - lb));\n        if (pos > 0) ncand.emplace_back(b[pos - 1], ld + abs(b[pos - 1] - lb));\n        pos = lower_bound(b, b + q, rb) - b;\n        if (pos != q) ncand.emplace_back(b[pos], rd + abs(b[pos] - rb));\n        if (pos > 0) ncand.emplace_back(b[pos - 1], rd + abs(b[pos - 1] - rb));\n\n        cand = ncand;\n        prv = i;\n    }\n    assert(false);\n}\n']","[1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2100
Several ages ago Berland was a kingdom The King of Berland adored math That s why when he first visited one of his many palaces he first of all paid attention to the floor in one hall The floor was tiled with hexagonal tiles The hall also turned out hexagonal in its shape The King walked along the perimeter of the hall and concluded that each of the six sides has and adjacent tiles correspondingly To better visualize the situation look at the picture showing a similar hexagon for and According to the legend as the King of Berland obtained the values and he almost immediately calculated the total number of tiles on the hall floor Can you do the same ,"['#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\nint main()\n{\n  int i,a,b,c,tmp,tot;\n  scanf(""%d%d%d"",&a,&b,&c);\n  tot=0;\n  tmp=a*2;\n  for (i=0;i<b+c-1;i++)\n  {\n    tot+=(tmp/2);\n    if (i+1<b) tmp++;\n    else tmp--;\n    if (i+1<c) tmp++;\n    else tmp--;\n  } \n  printf(""%d\\n"",tot);\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Let s define f S Let S be a multiset i e it can contain repeated elements of non negative integers In one operation you can choose any non empty subset of S which can also contain repeated elements remove this subset all elements in it from S and add the MEX of the removed subset to S You can perform any number of such operations After all the operations S should contain exactly 1 number f S is the largest number that could remain in S after any sequence of operations You are given an array of non negative integers a of length n For each of its n prefixes calculate f S if S is the corresponding prefix for the i th prefix S consists of the first i elements of array a The MEX minimum excluded of an array is the smallest non negative integer that does not belong to the array For instance The MEX of 2 2 1 is 0 because 0 does not belong to the array The MEX of 3 1 0 1 is 2 because 0 and 1 belong to the array but 2 does not The MEX of 0 3 1 2 is 4 because 0 1 2 and 3 belong to the array but 4 does not ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1 << 19;\nint n;\nint a[N];\nint ans[N];\nint cnt[N];\n\nstruct node {\n\tint r;\n\tll k0, b0; // time to go\n\tll k1, b1;\n};\n\nvector < node > con[N]; \n\nint up[N];\nvoid adjust(int x) {\n\twhile(true) {\n\t\tauto &tmp = con[x].back();\n\t\tif(tmp.r * tmp.k0 + tmp.b0 > up[x]) {\n\t\t\ttmp.r = (up[x] - tmp.b0) / tmp.k0;\n\t\t}\n\t\tif(sz(con[x]) > 1 && tmp.r <= con[x][sz(con[x]) - 2].r) {\n\t\t\tcon[x].pop_back();\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tR(i, sz(con[x]) - 1, 1) \n\t\tif(con[x][i].r == con[x][i - 1].r + 1) {\n\t\t\tauto &tmp = con[x][i];\n\t\t\tll v1 = tmp.r * tmp.k0 + tmp.b0;\n\t\t\tll v2 = tmp.r * tmp.k1 + tmp.b1;\n\t\t\ttmp.k0 = 1, tmp.b0 = v1 - tmp.r;\n\t\t\ttmp.k1 = 1, tmp.b1 = v2 - tmp.r;\n\t\t}\n\tassert(sz(con[x]) <= 36);\n}\nvoid upd(int x) {\n\tauto &v2 = con[x * 2];\n\tauto &v1 = con[x * 2 + 1];\n\tcon[x].clear();\n\tll cur = 0;\n\tint p1 = 0, p2 = 0;\n\twhile(true) {\n\t\twhile(p1 < sz(v1) && v1[p1].r < cur) ++p1;\n\t\tif(p1 == sz(v1)) break;\n\t\tll valc = cur * v1[p1].k0 + v1[p1].b0;\n\t\twhile(p2 < sz(v2) && v2[p2].r < valc) ++p2;\n\t\tif(p2 == sz(v2)) break;\n\t\tll r1 = v1[p1].r;\n\t\tll r2 = (v2[p2].r - v1[p1].b0) / v1[p1].k0; \n\t\tnode nw;\n\t\tnw.r = min(r1, r2);\n\t\tnw.k0 = v1[p1].k0 * v2[p2].k0, nw.b0 = v1[p1].b0 * v2[p2].k0 + v2[p2].b0;\n\t\tnw.k1 = v1[p1].k0 * v2[p2].k1 + v1[p1].k1;\n\t\tnw.b1 = v1[p1].b0 * v2[p2].k1 + v1[p1].b1 + v2[p2].b1;\n\t\tcur = nw.r + 1;\n\t\tcon[x].emplace_back(nw);\n\t}\n\tadjust(x);\n}\nvoid make(int x, int p) {\n\tnode z0, z1;\n\tz0.r = cnt[p], z0.k0 = 1, z0.b0 = 0, z0.k1 = -1, z0.b1 = cnt[p]; \n\tz1.r = n, z1.k0 = 2, z1.b0 = -cnt[p], z1.k1 = 0, z1.b1 = 0;\n\tcon[x] = vector < node > {z0, z1};\n\tadjust(x);\n}\nvoid build(int x, int L, int R) {\n\tup[x] = n / max(L - 1, 1);\n\tif(L == R) {\n\t\tmake(x, L);\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tbuild(x * 2, L, mid);\n\tbuild(x * 2 + 1, mid + 1, R);\n\tupd(x);\n}\nvoid modify(int x, int L, int R, int p) {\n\tif(L == R) {\n\t\tmake(x, L);\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tp <= mid ? modify(x * 2, L, mid, p) : modify(x * 2 + 1, mid + 1, R, p);\n\tupd(x);\n}\n\nint need, zero, curp;\nvoid slv(int x, int L, int R, int l, int r) {\n\tif(l <= L && R <= r) {\n\t\tif(need > curp / R) {\n\t\t\tneed = n * 2;\n\t\t\treturn ;\n\t\t}\n\t\tint pos = 0;\n\t\twhile(pos < sz(con[x]) && con[x][pos].r < need) ++pos;\n\t\tif(pos == sz(con[x])) {\n\t\t\tneed = n * 2;\t\n\t\t} else {\n\t\t\tzero += con[x][pos].k1 * need + con[x][pos].b1;\n\t\t\tneed = con[x][pos].k0 * need + con[x][pos].b0;\n\t\t}\n//\t\tcout << ""after "" << L << \' \' << R << "" : "" << need << \' \' << zero\n//\t\t\t<<"", "" << con[x][pos].k0 << \' \' << con[x][pos].b0 << \' \' << \n//\t\t\t\tcon[x][pos].k1 << \' \' << con[x][pos].b1 << endl;\n\t\treturn ;\n\t}\n\tint mid = (L + R) >> 1;\n\tif(r > mid) slv(x * 2 + 1, mid + 1, R, l, r);\n\tif(l <= mid) slv(x * 2, L, mid, l, r);\n}\n\nint a1;\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\ta1 = a[1];\n\tL(i, 1, n) {\n\t\tif(a[i] > n) {\n\t\t\ta[i] = 0;\n\t\t}\n\t}\n\tL(i, 0, n) {\n\t\tcnt[i] = 0;\n\t}\n\t\n\tbuild(1, 0, n);\n\tint ns = 1;\n\tint SUM = 0;\n\tL(i, 1, n) {\n\t\tif(a[i] >= ns) {\n\t\t\t++SUM;\n\t\t}\n\t\t++cnt[a[i]];\n\t\tmodify(1, 0, n, a[i]);\n\t\tcurp = i;\n\t\twhile(ns <= i) {\n//\t\t\tcout << ""checking "" << ns << endl;\n\t\t\tneed = 1, zero = SUM + cnt[0]; \n\t\t\tif(1 < ns) slv(1, 0, n, 1, ns - 1);\n\t\t\tif(zero < need) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSUM -= cnt[ns];\n\t\t\t++ns;\n\t\t}\n\t\tans[i] = ns - 1;\n\t}\n\t\n\tans[1] = max(ans[1], a1);\n\tL(i, 1, n) {\n\t\tcout << ans[i] << \' \';\n\t}\n\tcout << \'\\n\';\n}\n\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3300
During the winter holidays the demand for Christmas balls is exceptionally high Since it s already the advances in alchemy allow easy and efficient ball creation by utilizing magic crystals Grisha needs to obtain some yellow green and blue balls It s known that to produce a ball one needs two yellow crystals one yellow and one blue and for a ball three blue crystals are enough Right now there are yellow and blue crystals in Grisha s disposal Find out how many additional crystals he should acquire in order to produce the required number of balls ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\nlong long A, B, PA, PB;\nlong long x, y, z;\nint main() {\n\tscanf(""%lld%lld%lld%lld%lld"", &A, &B, &x, &y, &z);\n\tPA = x * 2 + y, PB = y + z * 3;\n\tprintf(""%lld\\n"", max(PA, A) - A+max(PB, B) - B);\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given a sequence of one dimensional segments numbered through Your task is to find two distinct indices and such that segment lies within segment Segment lies within segment iff and Print indices and If there are multiple answers print any of them If no answer exists print ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\npii in[300050];\nint u[300050];\n\nint main() {\n\tint N, i;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tu[i] = i;\n\t\tscanf(""%d %d"", &in[i].first, &in[i].second);\n\t}\n\tsort(u + 1, u + N + 1, [](int a, int b) {\n\t\tif (in[a].first != in[b].first) return in[a].first < in[b].first;\n\t\telse return in[a].second > in[b].second;\n\t});\n\n\tint mxp = u[1];\n\tfor (i = 2; i <= N; i++) {\n\t\tif (in[u[i]].second <= in[mxp].second) return !printf(""%d %d\\n"", u[i], mxp);\n\t\telse mxp = u[i];\n\t}\n\treturn !printf(""-1 -1\\n"");\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1500
Having read half of the book called Storm and Calm on the IT lesson Innocentius was absolutely determined to finish the book on the maths lessons All was fine until the math teacher Ms Watkins saw Innocentius reading fiction books instead of solving equations of the fifth degree As during the last maths class Innocentius suggested the algorithm of solving equations of the fifth degree in the general case Ms Watkins had no other choice but to give him a new task The teacher asked to write consecutively without spaces all words from the Storm and Calm in one long string She thought that a string is good if the number of vowels in the string is no more than twice more than the number of consonants That is the string with vowels and consonants is good if and only if The task Innocentius had to solve turned out to be rather simple he should find the number of the longest good substrings of the string ,"['#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nchar vow[128],s[200005];\nint a[200005];\n\nint main(){\n    vow[\'a\']=vow[\'e\']=vow[\'i\']=vow[\'o\']=vow[\'u\']=1;\n    vow[\'A\']=vow[\'E\']=vow[\'I\']=vow[\'O\']=vow[\'U\']=1;\n    int n=strlen(gets(s+1)),ans=0,cnt=0;\n    for(int i=1;i<=n;i++) s[i]=vow[s[i]];\n    for(int i=1;i<=n;i++) a[i]=a[i-1]+(s[i]?-1:2);\n    vector<int> u={0};\n    for(int i=1;i<=n;i++){\n        if(a[i]-a[u.back()]>=0){\n            int lo=0,hi=u.size()-1;\n            while(lo<hi){\n                int m=(lo+hi)/2;\n                if(a[i]-a[u[m]]>=0) hi=m; else lo=m+1;\n            }\n            ans=max(ans,i-u[lo]);\n        }\n        if(a[i]<a[u.back()]) u.push_back(i);\n    }\n    if(!ans) return printf(""No solution"")&0;\n    for(int i=ans;i<=n;i++) if(a[i]-a[i-ans]>=0) cnt++;\n    printf(""%d %d\\n"",ans,cnt);\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2000
The nation of Panel holds an annual show called The Number Games where each district in the nation will be represented by one contestant The nation has n districts numbered from 1 to n each district has exactly one path connecting it to every other district The number of fans of a contestant from district i is equal to 2 i This year the president decided to reduce the costs He wants to remove k contestants from the games However the districts of the removed contestants will be furious and will not allow anyone to cross through their districts The president wants to ensure that all remaining contestants are from districts that can be reached from one another He also wishes to maximize the total number of fans of the participating contestants Which contestants should the president remove ,"['#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 1007681537;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "" "";\n#define endln cerr << ""\\n"";\n\nconst int maxn = 1e6 + 5;\nconst int logn = 20;\nint n, k;\nvi adj[maxn];\nint lev[maxn];\nint par[logn][maxn];\n\nvoid dfs(int u, int dad) {\n    FOR(i, 1, logn) {\n        par[i][u] = par[i - 1][par[i - 1][u]];\n    }\n    for (int v : adj[u]) {\n        if (v != dad) {\n            lev[v] = lev[u] + 1;\n            par[0][v] = u;\n            dfs(v, u);\n        }\n    }\n}\n\nvoid phongthan() {\n    cin >> n >> k;\n    FOR(i, 0, n - 1) {\n        int u, v; cin >> u >> v; u--, v--;\n        adj[u].pb(v), adj[v].pb(u);\n    }\n    static int f[maxn];\n    FOR(i, 0, logn) par[i][n - 1] = n - 1;\n    dfs(n - 1, -1);\n    f[n - 1] = 1;\n    int st = n - 2, tot = 1;\n    FOR(it, 0, n - k - 1) {\n        while (1) {\n            if (f[st]) {\n                st--;\n                break;\n            }\n            int u = st;\n            FORd(i, logn, 0) {\n                int nu = par[i][u];\n                if (!f[nu]) {\n                    u = nu;\n                }\n            }\n            if (tot + lev[st] - lev[u] + 1 <= n - k) {\n                int u = st;\n                while (!f[u]) {\n                    f[u] = 1;\n                    tot++;\n                    u = par[0][u];\n                }\n                st--;\n                break;\n            }\n            else {\n                st--;\n            }\n        }\n    }\n    vi res;\n    FOR(i, 0, n) if (!f[i]) res.pb(i);\n    FOR(i, 0, sz(res)) cout << res[i] + 1 << "" \\n""[i == sz(res) - 1];\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], ""r"", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], ""wb"", stdout));\n    }\n    phongthan();\n    cerr << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    return 0;\n} \n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2200
While dad was at work a little girl Tanya decided to play with dad s password to his secret database Dad s password is a string consisting of characters She has written all the possible three letter continuous substrings of the password on pieces of paper one for each piece of paper and threw the password out Each three letter substring was written the number of times it occurred in the password Thus Tanya ended up with pieces of paper Then Tanya realized that dad will be upset to learn about her game and decided to restore the password or at least any string corresponding to the final set of three letter strings You have to help her in this difficult task We know that dad s password consisted of lowercase and uppercase letters of the Latin alphabet and digits Uppercase and lowercase letters of the Latin alphabet are considered distinct ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\nint get(char c) {\n    if (c >= \'a\' && c <= \'z\') {\n        return c - \'a\';\n    } else {\n        if (c >= \'A\' && c <= \'Z\') {\n            return 26 + c - \'A\';\n        } else {\n            return 52 + c - \'0\';\n        }\n    }\n}\n\nchar put(int v) {\n    //assert(v < 62);\n    if (v < 26) {\n        return v + \'a\';\n    } else {\n        v -= 26;\n        if (v < 26) {\n            return v + \'A\';\n        } else {\n            v -= 26;\n            return v + \'0\';\n        }\n    }\n}\n\nstring A(int v) {\n    int x = v / 62;\n    int y = v % 62;\n    string res(2, \'0\');\n    res[0] = put(x);\n    res[1] = put(y);\n    return res;\n}\n\nint main() {\n#ifdef HOME\n    freopen(""input.txt"", ""r"", stdin);\n    //freopen(""output.txt"", ""w"", stdout);\n#else\n\n#endif\n\n    int k;\n    cin >> k;\n\n    const int n = 62 * 62;\n\n    vector<int> g[n];\n\n    memset(g, 0, sizeof(g));\n\n    vector<int> inDegree(n);\n    vector<int> outDegree(n);\n\n    for (int i = 0; i < k; ++i) {\n        string s;\n        cin >> s;\n        int from = get(s[0]) * 62 + get(s[1]);\n        int to = get(s[1]) * 62 + get(s[2]);\n        g[from].push_back(to);\n        inDegree[to]++;\n        outDegree[from]++;\n    }\n\n    //cerr << ""OK"" << endl;\n\n    int start = -1;\n\n    int c1 = 0, c2 = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (inDegree[i] == outDegree[i]) {\n            continue;\n        }\n        if (inDegree[i] > outDegree[i] + 1) {\n            cout << ""NO\\n"";\n            return 0;\n        }\n        if (outDegree[i] > outDegree[i] + 1) {\n            cout << ""NO\\n"";\n            return 0;\n        }\n        if (inDegree[i] == outDegree[i] + 1) {\n            ++c2;\n        }\n        if (outDegree[i] == inDegree[i] + 1) {\n            ++c1;\n            start = i;\n        }\n    }\n\n    if (c1 > 1 || c2 > 1) {\n        cout << ""NO\\n"";\n        return 0;\n    }\n    if (c1 != c2) {\n        cout << ""NO\\n"";\n        return 0;\n    }\n\n    if (start == -1) {\n        for (int i = 0; i < n; ++i) {\n            if (outDegree[i] > 0) {\n                start = i;\n                break;\n            }\n        }\n    }\n    vector<int> res;\n\n    vector<int> st;\n    st.push_back(start);\n    while (!st.empty()) {\n        int v = st.back();\n\n        if (g[v].empty()) {\n            res.push_back(v);\n            st.pop_back();\n        } else {\n            st.push_back(g[v].back());\n            g[v].pop_back();\n        }\n    }\n\n    if (res.size() != k + 1) {\n        puts(""NO"");\n        return 0;\n    }\n\n    reverse(res.begin(), res.end());\n\n    puts(""YES"");\n    cout << A(res[0]);\n    for (size_t i = 1; i < res.size(); ++i) {\n        cout << put(res[i] % 62);\n    }\n    cout << ""\\n"";\n\n    return 0;\n}']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2500
A horizontal grid strip of n cells is given In the i th cell there is a paint charge of size a i This charge can be either used to the left then all cells to the left at a distance less than a i from max i a i 1 1 to i inclusive will be painted or used to the right then all cells to the right at a distance less than a i from i to min i a i 1 n inclusive will be painted or not used at all Note that a charge can be used no more than once that is it be used simultaneously to the left and to the right It is allowed for a cell to be painted more than once What is the minimum number of times a charge needs to be used to paint all the cells of the strip ,"['// LUOGU_RID: 146673924\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint tt;\nint n,a[101];\nint f[2][105][105];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tcin>>tt;\n\twhile(tt--){\n\t\tcin>>n;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i];\n\t\tfor(int i=0;i<=n+1;i++){\n\t\t\tfor(int j=0;j<=n+1;j++){\n\t\t\t\tf[0][i][j]=f[1][i][j]=n+1;\n\t\t\t}\n\t\t}\n\t\tf[0][0][1]=0;\n\t\tfor(int p=1;p<=n;p++){\n\t\t\tint S=p&1,S_=S^1;\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tif(f[S_][i][j]==n+1) continue;\n//\t\t\t\t\tcout<<i<<\' \'<<j<<\' \'<<p<<"" ""<<f[i][j]<<\':\'<<\'\\n\';\n\t\t\t\t\tint lim=max(p-a[p]+1,1ll);\n\t\t\t\t\tif(j>=lim) f[S][max(i,p)][max(i,p)+1]=min(f[S][max(i,p)][max(i,p)+1],f[S_][i][j]+1);\n//\t\t\t\t\tcout<<f[max(i,p)][p+1]<<\' \'<<max(i,p)<<\' \'<<p+1<<\'\\n\';\n\t\t\t\t\tlim=min(n,p+a[p]-1);\n\t\t\t\t\tint t=max(lim,i);\n\t\t\t\t\tif(j<p){\n\t\t\t\t\t\tf[S][t][j]=min(f[S][t][j],f[S_][i][j]+1);\n//\t\t\t\t\t\tcout<<\'*\'<<f[t][j]<<\' \'<<t<<\' \'<<j<<\'\\n\';\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tf[S][t][t+1]=min(f[S][t][t+1],f[S_][i][j]+1);\n//\t\t\t\t\t\tcout<<f[t][t+1]<<\' \'<<t<<\' \'<<t+1<<\'\\n\';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tf[S][i][j]=min(f[S][i][j],f[S_][i][j]);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tif(p==6) cout<<f[S][10][1]<<\'\\n\';\n\t\t}\n\t\tcout<<min(f[0][n][n+1],f[1][n][n+1])<<\'\\n\';\n\t}\n}']","[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
A patient has been infected with an unknown disease His body can be seen as an infinite grid of triangular cells which looks as follows Two cells are neighboring if they share a side Therefore each cell x y has exactly three neighbors x 1 y x 1 y x 1 y 1 if x is even and x 1 y 1 otherwise Initially some cells are infected all the others are healthy The process of recovery begins Each second for cell even though there might be multiple cells that could change its state one of the following happens A healthy cell with at least 2 infected neighbors also becomes infected An infected cell with at least 2 healthy neighbors also becomes healthy If no such cell exists the process of recovery stops Patient is considered recovered if the process of recovery has stopped and all the cells are healthy We re interested in a scenario is it possible that the patient never recovers or if it s not possible what is the maximum possible duration of the recovery process ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 510;\nconst int M = N * N;\nint id[N][N];\nbool isBlack[M];\nvector<int> g[M];\nvector<pii> neigh[N][N];\nbool used[M];\nint n;\nint sumDeg;\nint szComp;\nbool allEmpty;\n\nvoid check(int x, int y) {\n\tassert(x >= 2 && y >= 2 && x < N - 2 && y < N - 2);\n\tif (id[x][y] != -1) return;\n\tint cnt = 0;\n\tfor (auto t : neigh[x][y]) {\n\t\tint xx = t.first, yy = t.second;\n\t\tif (id[xx][yy] != -1) cnt++;\n\t}\n\tif (cnt < 2) return;\n\tid[x][y] = n++;\n\tfor (auto t : neigh[x][y])\n\t\tcheck(t.first, t.second);\n}\n\nvoid dfs(int v) {\n\tszComp++;\n\tsumDeg += (int)g[v].size();\n\tfor (int u : g[v])\n\t\tif (isBlack[v] && isBlack[u])\n\t\t\tallEmpty = false;\n\tif (!isBlack[v]) {\n\t\tint cnt = 0;\n\t\tfor (int u : g[v])\n\t\t\tif (isBlack[u])\n\t\t\t\tcnt++;\n\t\tif (cnt == 2) allEmpty = false;\n\t}\n\tused[v] = 1;\n\tfor (int u : g[v])\n\t\tif (!used[u])\n\t\t\tdfs(u);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tfor (int x = 0; x < N; x++)\n\t\tfor (int y = 0; y < N; y++)\n\t\t\tid[x][y] = -1;\n\tfor (int x = 2; x < N - 2; x++)\n\t\tfor (int y = 2; y < N - 2; y++) {\n\t\t\tneigh[x][y].push_back(mp(x - 1, y));\n\t\t\tneigh[x][y].push_back(mp(x + 1, y));\n\t\t\tif (x % 2 == 0) {\n\t\t\t\tneigh[x][y].push_back(mp(x + 1, y - 1));\n\t\t\t} else {\n\t\t\t\tneigh[x][y].push_back(mp(x - 1, y + 1));\n\t\t\t}\n\t\t}\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx += 4;\n\t\ty += 4;\n\t\tid[x][y] = i;\n\t\tisBlack[i] = 1;\n\t}\n\tfor (int x = 2; x < N - 2; x++)\n\t\tfor (int y = 2; y < N - 2; y++) {\n\t\t\tcheck(x, y);\n\t\t}\n\tfor (int x = 2; x < N - 2; x++)\n\t\tfor (int y = 2; y < N - 2; y++) {\n\t\t\tif (id[x][y] == -1) continue;\n\t\t\tint v = id[x][y];\n\t\t\tfor (pii t : neigh[x][y]) {\n\t\t\t\tint u = id[t.first][t.second];\n\t\t\t\tif (u == -1) continue;\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\tint ans = 0;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (!isBlack[v]) continue;\n\t\tans += 3;\n\t\tfor (int u : g[v])\n\t\t\tif (isBlack[u])\n\t\t\t\tans--;\n\t}\n\tfor (int v = 0; v < n; v++) {\n\t\tif (used[v]) continue;\n\t\tsumDeg = 0;\n\t\tszComp = 0;\n\t\tallEmpty = true;\n\t\tans -= 2;\n\t\tdfs(v);\n\t\tif (sumDeg != 2 * szComp - 2) {\n\t\t\tprintf(""SICK\\n"");\n\t\t\treturn 0;\n\t\t}\n\t\tif (allEmpty && szComp > 1) ans -= 2;\n\t}\n\tprintf(""RECOVERED\\n%d\\n"", ans);\n\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0]",3500
Unfortunately not all numbers are lucky Petya calls a number if the number of lucky digits in it is a lucky number He wonders whether number is a nearly lucky number ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n\nint main()\n{\n    char num[1111];\n    while(~scanf(""%s"", num)){\n        int cnt = 0;\n        for(int i = 0; num[i]; i++)\n            if(num[i]==\'4\' || num[i] == \'7\') cnt++;\n        if(cnt==4 || cnt ==7) puts(""YES"");\n        else puts(""NO"");\n    }\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Let s define the sum of two permutations and of numbers as permutation where is the th lexicographically permutation of numbers counting from zero and is the number of permutation in the lexicographical order For example Misha has two permutations and Your task is to find their sum Permutation is called to be lexicographically smaller than permutation if for some following conditions hold ,"['#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <set>\n#include <map>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\n#define N 210000\n\nint n, a[N], b[N], c[N], a1[N], b1[N], c1[N], d[N];\n\nvoid modify(int x, int y) {\n\tfor (; x <= n; x += x & -x)\n\t\td[x] += y;\n}\n\nint query(int x) {\n\tint ans = 0;\n\tfor (; x; x -= x & -x)\n\t\tans += d[x];\n\treturn ans;\n}\n\nint get(int x) {\n\tint q = 0, h = n, mid;\n\twhile (q < h - 1) {\n\t\tmid = (q + h) / 2;\n\t\tif (query(mid) >= x)\n\t\t\th = mid;\n\t\telse\n\t\t\tq = mid;\n\t}\n\treturn h;\n}\n\nint main() {\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &a[i]), a[i]++;\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &b[i]), b[i]++;\n\tfor (int i = n; i; i--) {\n\t\ta1[i] = query(a[i]);\n\t\tmodify(a[i], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\td[i] = 0;\n\tfor (int i = n; i; i--) {\n\t\tb1[i] = query(b[i]);\n\t\tmodify(b[i], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\td[i] = 0;\n\tfor (int i = n; i; i--) {\n\t\tc1[i] += a1[i] + b1[i];\n\t\tif (c1[i] >= n - i + 1)\n\t\t\tc1[i] -= n - i + 1, c1[i - 1]++;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tmodify(i, 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tc[i] = get(c1[i] + 1);\n\t\tmodify(c[i], -1);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(""%d "", c[i] - 1);\n\tprintf(""%d\\n"", c[n] - 1);\n}\n']","[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2000
Shohag has an integer sequence a 1 a 2 ldots a n He can perform the following operation any number of times possibly zero Select any positive integer k it can be different in different operations Choose any position in the sequence possibly the beginning or end of the sequence or in between any two elements and insert k into the sequence at this position This way the sequence a changes and the next operation is performed on this changed sequence For example if a 3 3 4 and he selects k 2 then after the operation he can obtain one of the sequences underline 2 3 3 4 3 underline 2 3 4 3 3 underline 2 4 or 3 3 4 underline 2 Shohag wants this sequence to satisfy the following condition for each 1 le i le a a i le i Here a denotes the size of a Help him to find the minimum number of operations that he has to perform to achieve this goal We can show that under the constraints of the problem it s always possible to achieve this goal in a finite number of operations ,"['#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f3f3f3f3f\nusing namespace std;\ntypedef long long ll;\ninline ll read() {\n    ll x=0,f=1;int c=getchar();\n    while(!isdigit(c)) {if(c==\'-\') f=-1;c=getchar();}\n    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    return x*f;\n}\nll t,n,pos,mx;\nint main(){\n    //freopen("".in"",""r"",stdin);\n    //freopen("".out"",""w"",stdout);\n    t=read();\n    while(t--){\n        n=read(),mx=0;\n        for(int i=1,x;i<=n;i++) mx=max(mx,read()-(ll)i);\n        printf(""%lld\\n"",mx);\n    }\n    return 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Positive integer x is called of positive integer y if y is divisible by x without remainder For example 1 is a divisor of 7 and 3 is not divisor of 8 We gave you an integer d and asked you to find positive integer a such that a has at least 4 divisors difference between any two divisors of a is at least d ,"['#include<bits/stdc++.h>\nusing namespace std;\nlong long d[30007]={0};\nvector<long long> p;\nvoid solve(){\n\tlong long d;\n\tcin>>d;\n\tlong long a=*lower_bound(p.begin(),p.end(),d+1);\n\tlong long b=*lower_bound(p.begin(),p.end(),d+a);\n\tcout<<1LL*a*b<<endl;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tlong long i,j;\n\tfor(i=2;i<30007;i++){\n\t\tif(!d[i]){ \n\t\t\tp.emplace_back(i);\n\t\t}\n\t\telse{\n\t\t\tcontinue;\n\t\t}\n\t\tfor(j=i+i;j<30007;j+=i){\n\t\t\td[j]=1;\n\t\t}\n\t}\n\tlong long t=1;\n\tcin>>t;\n\twhile(t--){\n\t\tsolve();\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0]",1000
According to Berland laws it is only allowed to sell alcohol to people 18 years Vasya s job is to monitor the law s enforcement Tonight he entered a bar and saw people sitting there For every one of them Vasya happened to determine either the age or the drink the person is having Vasya can check any person i e learn his age and the drink he is having at the same time What minimal number of people should Vasya check additionally to make sure that there are no clients under 18 having alcohol drinks The list of all alcohol drinks in Berland is ,"['//#pragma comment(linker,""/STACK:256000000"")\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <stdio.h>\n#include <string>\n#include <memory.h>\n\nusing namespace std;\n\n#define ldb long double\n#define LL long long\n#define nextline() {int c; while ((c = getchar()) != 10 && c != EOF);}\n\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-9\n\n#define sqr(x) ((x) * (x))\n#define ABS(a) ((a)<0?-(a):(a))\n#define EQ(a,b) (ABS((a)-(b))<EPS)\n\n#define all(a) a.begin(), a.end()\n#define two(i) (1 << (i))\n#define has(mask, i) ((((mask) & two(i)) == 0) ? false : true)\n\nconst int inf = 1000 * 1000 * 1000;\nconst LL inf64 = 1000LL * 1000LL * 1000LL * 1000LL * 1000LL * 1000LL;\n\n\n#define MAXN 1000\n\nstring str[11] = {""ABSINTH"", ""BEER"", ""BRANDY"", ""CHAMPAGNE"", ""GIN"", ""RUM"", ""SAKE"", ""TEQUILA"", ""VODKA"", ""WHISKEY"", ""WINE""};\nint n;\nbool check (const string &s)\n{\n\tbool fl = true;\n\tfor (int i = 0; i < (int)s.size(); i++)\n\t\tif (!(s[i] >= \'0\' && s[i] <= \'9\'))\n\t\t\tfl = false;\n\t\t\t\n\tif (s.size() > 4)\n\t\tfl = false;\n\treturn fl;\n}\nint get_int(const string &s)\n{\n\tint x = 0;\n\tfor (int i = 0; i < (int)s.size(); i++)\n\t\tx = x * 10 + s[i] - \'0\';\n\treturn x;\n}\n\n\nvoid Load()\n{\n\tcin >> n;\n}\n\nvoid Solve()\n{\n\tint sum = 0, y;\n\tstring s;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> s;\n\t\tif (check(s))\n\t\t{\n\t\t\ty = get_int (s);\n\t\t\tif (y < 18)\n\t\t\t\tsum++;\n\t\t}\n\t\tfor (int j = 0; j < 11; j++)\n\t\t\tif (s == str[j])\n\t\t\t\tsum++;\n\t}\n\tcout << sum;\n}\n                \nint main()\n{\n\t//ios_base::sync_with_stdio(0);\n\tLoad();\n\tSolve();\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Polycarp has a cat and his cat is a real gourmet Dependent on a day of the week he eats certain type of food on Mondays Thursdays and Sundays he eats on Tuesdays and Saturdays he eats on other days of week he eats Polycarp plans to go on a trip and already packed his backpack His backpack contains a daily rations of b daily rations of c daily rations of Polycarp has to choose such day of the week to start his trip that his cat can eat without additional food purchases as long as possible Print the maximum number of days the cat can eat in a trip without additional food purchases if Polycarp chooses the day of the week to start his trip optimally ,"[""// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nint main() {\n  vector<int> cnt(3);\n  generate_n(cnt.begin(), 3, read);\n  const vector<int> eat = {0, 1, 2, 0, 2, 1, 0};\n  int ans = 0;\n  for (int i = 0; i < 7; ++i) {\n    vector<int> cur = cnt;\n    int days = 0;\n    for (int j = i; j < 7; ++j) {\n      if (!cur[eat[j]]) break;\n      --cur[eat[j]]; ++days;\n    }\n    int week = min(cur[0] / 3, min(cur[1] / 2, cur[2] / 2));\n    cur[0] -= week * 3;\n    cur[1] -= week * 2;\n    cur[2] -= week * 2;\n    days += week * 7;\n    for (int j = 0; j < 7; ++j) {\n      if (!cur[eat[j]]) break;\n      --cur[eat[j]]; ++days;\n    }\n    ans = max(ans, days);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
In the game of Mastermind there are two players Alice and Bob Alice has a secret code which Bob tries to guess Here a code is defined as a sequence of n colors There are exactly n 1 colors in the entire universe numbered from 1 to n 1 inclusive When Bob guesses a code Alice tells him some information about how good of a guess it is in the form of two integers x and y The first integer x is the number of indices where Bob s guess correctly matches Alice s code The second integer y is the size of the intersection of the two codes as multisets That is if Bob were to change the order of the colors in his guess y is the maximum number of indices he could get correct For example suppose n 5 Alice s code is 3 1 6 1 2 and Bob s guess is 3 1 1 2 5 At indices 1 and 2 colors are equal while in the other indices they are not equal So x 2 And the two codes have the four colors 1 1 2 3 in common so y 4 Solid lines denote a matched color for the same index Dashed lines denote a matched color at a different index x is the number of solid lines and y is the total number of lines You are given Bob s guess and two values x and y Can you find one possibility of Alice s code so that the values of x and y are correct ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n\t#define dbg(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n#else\n\t#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nint n,x,y;\nvi b, ans;\nvi cnt[MX];\nvi oc[MX];\n\nvoid make(int a, int b) { // index, value\n\tassert(sz(cnt[a]));\n\tans[cnt[a].bk] = b;\n\tcnt[a].pop_back();\n}\n\nvoid solve() {\n\tre(n,x,y); b.rsz(n); re(b); ans = vi(n);\n\t//dbg(""OK"",n,x,y,b);\n\tF0R(i,n+2) cnt[i].clear();\n\tF0R(i,n+1) oc[i].clear();\n\tF0R(i,n) cnt[b[i]].pb(i);\n\tint bad = 1; while (sz(cnt[bad])) bad ++;\n\tFOR(i,1,n+2) oc[sz(cnt[i])].pb(i);\n\tint ind = n;\n\t//dbg(""STARTLOOP"");\n\t//dbg(""STARTLOOP"");\n\tF0R(i,x) {\n\t\twhile (!sz(oc[ind])) ind --;\n\t\tint z = oc[ind].bk; //dbg(""CHOOSING"",ind,z);\n\t\toc[ind].pop_back(); make(z,z);\n\t\toc[sz(cnt[z])].pb(z);\n\t}\n\t//dbg(""MIDLOOP"");\n\twhile (!sz(oc[ind])) ind --;\n\tint BIG = oc[ind].bk;\n\tint lef = n-x, des = y-x, mx = min(2*(lef-ind),lef);\n\t//dbg(lef,des,mx);\n\tif (mx < des) {\n\t\tps(""NO"");\n\t\treturn;\n\t}\n\tif (mx == 2*(lef-ind)) {\n\t\tdbg(""HUH"");\n\t\tvi big, small;\n\t\tFOR(i,1,n+2) trav(t,cnt[i]) {\n\t\t\tif (i == BIG) big.pb(i);\n\t\t\telse small.pb(i);\n\t\t}\n\t\tassert(sz(big) >= sz(small));\n\t\tF0R(i,sz(small)) {\n\t\t\tif (des) des --, make(big[i],small[i]);\n\t\t\tif (des) des --, make(small[i],big[i]);\n\t\t}\n\t\tassert(des == 0);\n\t} else {\n\t\tdbg(""NOPE"");\n\t\tvi LEF;\n\t\tFOR(i,1,n+2) trav(t,cnt[i]) LEF.pb(i); // value, index\n\t\tassert(sz(LEF) == lef);\n\t\tF0R(i,des) make(LEF[i],LEF[(i+ind)%sz(LEF)]);\n\t}\n\tps(""YES"");\n\ttrav(t,ans) if (t == 0) t = bad;\n\tps(ans);\n\t// fill up y-x\n}\n\n// choose x to match\n// exactly y-x common, can\'t match\n// can\'t get > max\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) solve();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']","[1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2500
You are given an array a consisting of n integers Indices of the array start from zero i e the first element is a 0 the second one is a 1 and so on You can reverse subarray continuous subsegment of this array Recall that the subarray of a with borders l and r is a l r a l a l 1 dots a r Your task is to reverse such a subarray that the sum of elements on positions of the resulting array is i e the sum of elements a 0 a 2 dots a 2k for integer k lfloor frac n 1 2 rfloor should be maximum possible You have to answer t independent test cases ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        int N; cin >> N;\n        vl A(N); F0R(i, N) cin >> A[i];\n        ll P = 0;\n        ll pre[N+1];\n        pre[0] = 0;\n        ll lo2 = 0;\n        ll lo1 = 1e15;\n        ll ans = 0;\n        F0R(i, N) {\n            if (i % 2 == 0) {\n                P += A[i];\n                pre[i+1] = pre[i] - A[i];\n            } else {\n                pre[i+1] = pre[i] + A[i];\n            }\n            if ((i+1) % 2) {\n                ckmin(lo1, pre[i+1]);\n                ckmax(ans, pre[i+1] - lo1);\n            } else {\n                ckmin(lo2, pre[i+1]);\n                ckmax(ans, pre[i+1] - lo2);\n            }\n\n        }\n//        cout << P << "" "" << pre[N] << nl;\n\n        cout << ans+P << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
There are cities in Berland Some pairs of them are connected with directed roads One can use only these roads to move from one city to another There are no roads that connect a city to itself For each pair of cities there is at most one road from to A path from city to city is a sequence of cities where and there is a road from city to city for each from to The path can pass multiple times through each city except It can t pass through more than once A path from to is if it is the lexicographically minimal such path In other words is path from to if for any other path from to where is the minimum integer such that There is a tourist agency in the country that offers unusual excursions the th excursion starts at city and ends in city For each pair help the agency to study the ideal path from to Note that it is possible that there is no ideal path from to This is possible due to two reasons there is no path from to there are paths from to but for every such path there is another path from to such that where is the minimum integer for which The agency would like to know for the ideal path from to the th city in that path on the way from to For each triple find if there is an ideal path from to and print the th city in that path if there is any ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<bitset>\n#include<list>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nlist<int> l[3010];\nint c[3010][3010];\nint ti;\nint b[3010];\nint d[3010][3010];\nint start;\nvoid dfs(int x)\n{\n\tb[x]=1;\n\tc[start][x]=1;\n\tfor(auto v:l[x])\n\t\tif(!b[v])\n\t\t\tdfs(v);\n}\nstruct p\n{\n\tint x,y,k,id;\n};\np a[400010];\nint ans[400010];\nint cmp(p a,p b)\n{\n\treturn a.y<b.y;\n}\nlist<int> l2[3010];\nlist<int> l3[3010];\nint e[3010];\nint st[3010];\nvoid dfs2(int x,int d)\n{\n\tst[d]=x;\n\tfor(auto v:l3[x])\n\t\tif(a[v].k<=d)\n\t\t\tans[a[v].id]=st[d-a[v].k+1];\n\tb[x]=1;\n\tfor(auto v:l2[x])\n\t\tif(!b[v])\n\t\t\tdfs2(v,d+1);\n}\nint main()\n{\n\tmemset(c,0,sizeof c);\n\tmemset(d,0,sizeof d);\n\tint n,m,q;\n\tscanf(""%d%d%d"",&n,&m,&q);\n\tint i;\n\tint x,y;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(""%d%d"",&x,&y);\n\t\tl[x].push_back(y);\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tstart=i;\n\t\tmemset(b,0,sizeof b);\n\t\tdfs(i);\n\t}\n\tint j;\n\tfor(i=1;i<=n;i++)\n\t\tfor(auto v:l[i])\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tif(c[v][j])\n\t\t\t\t\tif(!d[i][j]||v<d[i][j])\n\t\t\t\t\t\td[i][j]=v;\n\tfor(i=1;i<=q;i++)\n\t{\n\t\tscanf(""%d%d%d"",&a[i].x,&a[i].y,&a[i].k);\n\t\ta[i].id=i;\n\t}\n\tsort(a+1,a+q+1,cmp);\n\tint k;\n\tmemset(ans,-1,sizeof ans);\n\tfor(i=1;i<=q;i++)\n\t\tif(i==1||a[i].y!=a[i-1].y)\n\t\t{\n\t\t\tk=i;\n\t\t\twhile(k<q&&a[k].y==a[k+1].y)\n\t\t\t\tk++;\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tl2[j].clear();\n\t\t\t\tl3[j].clear();\n\t\t\t}\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tif(d[j][a[i].y])\n\t\t\t\t\tl2[d[j][a[i].y]].push_back(j);\n\t\t\tfor(j=i;j<=k;j++)\n\t\t\t\tl3[a[j].x].push_back(j);\n\t\t\tmemset(b,0,sizeof b);\n\t\t\tdfs2(a[i].y,1);\n\t\t}\n\tfor(i=1;i<=q;i++)\n\t\tprintf(""%d\\n"",ans[i]);\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0]",2700
You are given n chips on a number line The i th chip is placed at the integer coordinate x i Some chips You can perform each of the two following types of moves any possibly zero number of times on any chip Move the chip i by 2 to the left or 2 to the right i e replace the current coordinate x i with x i 2 or with x i 2 move the chip i by 1 to the left or 1 to the right and pay for this move i e replace the current coordinate x i with x i 1 or with x i 1 Note that it s allowed to move chips to any integer coordinate including negative and zero Your task is to find the minimum total number of coins required to move all n chips to the same coordinate i e all x i should be equal after some sequence of moves ,"['#include ""bits/stdc++.h""\nusing namespace std;\n// #define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n;\n    cin >> n;\n    int b0 = 0, b1 = 0;\n    fr(i, 1, n) {\n        int x;\n        cin >> x;\n        x %= 2;\n        if(x) b1++;\n        else b0++;\n    }\n    cout << min(b0, b1);\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
The Fair Nut found a string s The string consists of lowercase Latin letters The Nut is a curious guy so he wants to find the number of strictly increasing sequences p 1 p 2 ldots p k such that For each i 1 leq i leq k s p i For each i 1 leq i k there is such j that p i j p i 1 and s j The Nut is upset because he doesn t know how to find the number Help him This number should be calculated modulo 10 9 7 ,"[""#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    string str; cin >> str;\n\n    int N = str.length();\n    int dp[N+1]; F0R(i, N+1) dp[i] = 0;\n\n    int lastB = 0;\n    dp[0] = 1;\n    int sumDP[N+1];\n    F0R(i, N+1) sumDP[i] = 0;\n    sumDP[0] = 1;\n    F0R(i, N) {\n        if (str[i] == 'b') {\n            lastB = i+1;\n        }\n        if (str[i] == 'a') {\n            dp[i+1] = sumDP[lastB];\n        }\n        sumDP[i+1] = sumDP[i] + dp[i+1];\n        sumDP[i+1] = sumDP[i+1] % MOD;\n    }\n\n    cout << sumDP[N] - 1 << endl;\n\n    return 0;\n}\n\n// read the question correctly (ll vs int)\n// template by bqi343""]","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1500
A string is called if it does not contain any characters other than and A bracket sequence is called shortly RBS if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are RBS and and are not We can see that each opening bracket in RBS is paired with some closing bracket and using this fact we can define of the RBS as maximum number of bracket pairs such that the 2 nd pair lies inside the 1 st one the 3 rd one inside the 2 nd one and so on For example nesting depth of is 0 is 1 and is 3 Now you are given RBS s of even length n You should color each bracket of s into one of two colors red or blue Bracket sequence r consisting only of red brackets should be RBS and bracket sequence consisting only of blue brackets b should be RBS Any of them can be empty You are not allowed to reorder characters in s r or b No brackets can be left uncolored Among all possible variants you should choose one that of r s and b s nesting depth If there are multiple solutions you can print any of them ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nchar wcz[nax];\n\nint b;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (wcz[i]==\'(\')\n\t\t{\n\t\t\tb++;\n\t\t\tprintf(""%d"", (b&1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(""%d"", (b&1));\n\t\t\tb--;\n\t\t}\n\t}\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Gildong is now developing a puzzle game The puzzle consists of n platforms numbered from 1 to n The player plays the game as a character that can stand on each platform and the goal of the game is to move the character from the 1 st platform to the n th platform The i th platform is labeled with an integer a i 0 le a i le n i When the character is standing on the i th platform the player can move the character to any of the j th platforms where i 1 le j le i a i If the character is on the i th platform where a i 0 and i ne n the player loses the game Since Gildong thinks the current game is not hard enough he wants to make it even harder He wants to change some possibly zero labels to 0 so that there remains exactly one way to win He wants to modify the game as little as possible so he s asking you to find the number of platforms that should have their labels changed Two ways are different if and only if there exists a platform the character gets to in one way but not in the other way ,"['#include<bits/stdc++.h>\nusing namespace std;\nint _,n,dp[3005][3005],tot,a[3005],F[3005];\nint main(){\n    cin >> _;\n    while (_--){\n        cin >> n;\n        for (int i=1;i<=n;i++) cin >> a[i];\n        for (int i=1;i<=n+1;i++)\n        for (int j=1;j<=n+1;j++) dp[i][j]=n+1;\n        dp[1][1]=0;\n        F[1]=0;\n        for (int i=2;i<=n;i++) F[i]=n+1;\n        for (int i=2;i<=n;i++){\n            for (int j=1;j<=n;j++) F[j]=min(F[j],dp[j][i]);\n            tot=0;\n            for (int j=i-1;j;j--){\n                if (j+a[j]>=i){\n                    dp[i][j+a[j]+1]=min(dp[i][j+a[j]+1],F[j]+tot);\n                    ++tot;\n                }\n            }\n        }\n        for (int j=1;j<=n;j++) F[j]=min(F[j],dp[j][n+1]);\n        cout << F[n] << endl;\n    }\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
It s Petya s birthday party and his friends have presented him a brand new Electrician n construction set which they are sure he will enjoy as he always does with weird puzzles they give him Construction set Electrician n consists of 2n 1 wires and 2n light bulbs Each bulb has its own unique index that is an integer from 1 to 2n while all wires look the same and are indistinguishable In order to complete this construction set one has to use each of the wires to connect two distinct bulbs We define a in a completed construction set as a sequence of distinct bulbs of length at least two such that every two consecutive bulbs in this sequence are directly connected by a wire Completed construction set configuration is said to be correct if a resulting network of bulbs and wires has a tree structure i e any two distinct bulbs are the endpoints of some chain Petya was assembling different configurations for several days and he noticed that sometimes some of the bulbs turn on After a series of experiments he came up with a conclusion that bulbs indexed 2i and 2i 1 turn on if the chain connecting them consists of exactly d i wires Moreover the following condition holds the value of d i is never greater than n Petya did his best but was not able to find a configuration that makes all bulbs to turn on so he seeks your assistance Please find out a configuration that makes all bulbs shine It is guaranteed that such configuration always exists ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint n,pos[N];\nPII p[N];\nvector<PII> ans;\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",&p[i].fi),p[i].se=i;\n\tsort(p+1,p+n+1); reverse(p+1,p+n+1);\n\tauto add=[&](int u,int v) {\n\t\tans.pb(mp(u,v));\n\t};\n\trep(i,1,n+1) {\n\t\tpos[i]=2*p[i].se-1;\n\t\tif (i>1) add(pos[i-1],pos[i]);\n\t}\n\tint len=n;\n\trep(i,1,n+1) {\n\t\tint c=i+p[i].fi;\n\t\tif (c==len+1) {\n\t\t\tpos[c]=2*p[i].se;\n\t\t\tadd(pos[len],pos[c]);\n\t\t\tlen++;\n\t\t} else {\n\t\t\tadd(pos[c-1],2*p[i].se);\n\t\t}\n\t}\n\tfor (auto p:ans) printf(""%d %d\\n"",p.fi,p.se);\n}\n']","[0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0]",2000
You are given an array of length 2 n The elements of the array are numbered from 1 to 2 n You have to process q queries to this array In the i th query you will be given an integer k 0 le k le n 1 To process the query you should do the following for every i in 1 2 n 2 k do the following if the i th element was already swapped with some other element skip it otherwise swap a i and a i 2 k after that print the maximum sum over all contiguous subsegments of the array including the empty subsegment For example if the array a is 3 5 3 2 8 20 6 1 and k 1 the query is processed as follows the 1 st element wasn t swapped yet so we swap it with the 3 rd element the 2 nd element wasn t swapped yet so we swap it with the 4 th element the 3 rd element was swapped already the 4 th element was swapped already the 5 th element wasn t swapped yet so we swap it with the 7 th element the 6 th element wasn t swapped yet so we swap it with the 8 th element So the array becomes 3 2 3 5 6 1 8 20 The subsegment with the maximum sum is 5 6 1 8 and the answer to the query is 18 Note that the queries actually i e after a query is performed the array does not return to its original state and the next query will be applied to the modified array ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 18) + 7;\nll a[N];\nint n;\n\nstruct Item {\n\tint len;\n\tll sum;\n\tvector<ll> pref, suf, mx;\n\n\tItem() : len(), sum(), pref(), suf(), mx() {}\n\tItem(int _len) {\n\t\tlen = _len;\n\t\tsum = 0;\n\t\tpref = vector<ll>(len, 0);\n\t\tsuf = vector<ll>(len, 0);\n\t\tmx = vector<ll>(len, 0);\n\t}\n};\n\nItem solve(int l, int r) {\n\tint len = r - l;\n\tItem I = Item(len);\n\tif (len == 1) {\n\t\tI.sum = a[l];\n\t\tI.pref[0] = I.suf[0] = I.mx[0] = max(0LL, a[l]);\n\t\treturn I;\n\t}\n\tItem L = solve(l, l + len / 2), R = solve(l + len / 2, r);\n\tI.sum = L.sum + R.sum;\n\tfor (int i = 0; i < len / 2; i++) {\n\t\tI.pref[i] = max(L.pref[i], L.sum + R.pref[i]);\n\t\tI.suf[i] = max(R.suf[i], R.sum + L.suf[i]);\n\t\tI.mx[i] = max(max(L.mx[i], R.mx[i]), L.suf[i] + R.pref[i]);\n\t\tI.pref[i + len / 2] = max(R.pref[i], R.sum + L.pref[i]);\n\t\tI.suf[i + len / 2] = max(L.suf[i], L.sum + R.suf[i]);\n\t\tI.mx[i + len / 2] = max(max(L.mx[i], R.mx[i]), R.suf[i] + L.pref[i]);\n\t}\n\treturn I;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tn = 1 << n;\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\tItem I = solve(0, n);\n\tint q;\n\tint x = 0;\n\tscanf(""%d"", &q);\n\twhile(q--) {\n\t\tint k;\n\t\tscanf(""%d"", &k);\n\t\tx ^= 1 << k;\n\t\tprintf(""%lld\\n"", I.mx[x]);\n\t}\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2500
Baby Badawy s first words were AND 0 SUM BIG so he decided to solve the following problem Given two integers n and k count the number of arrays of length n such that all its elements are integers between 0 and 2 k 1 inclusive the bitwise AND of all its elements is 0 the sum of its elements is as large as possible Since the answer can be very large print its remainder when divided by 10 9 7 ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        int mod = 1e9 + 7;\n        int n, k;\n        cin >> n >> k;\n        int z = 1;\n        for (int i = 0; i < k; i++) {\n            z = (z * (long long)n) % mod;\n        }\n        cout << z << '\\n';\n    }\n}""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1200
You are given an array consisting of n integers Your task is to determine whether it is possible to color all its elements in two colors in such a way that the sums of the elements of both colors have the same parity and each color has at least one element colored For example if the array is 1 2 4 3 2 3 5 4 we can color it as follows color blue 1 color blue 2 color red 4 color blue 3 color red 2 color red 3 color red 5 color red 4 where the sum of the blue elements is 6 and the sum of the red elements is 18 ,"['#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<random>\n#include<set>\n#include<unordered_set>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<time.h>\n \nusing namespace std;\n \n#define all(a) a.begin(), a.end()\n#define Max(a) *max_element(all(a))\n#define Min(a) *min_element(all(a))\n \nusing ll = long long;\nusing ld = long double;\n \nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto& e : a) cin >> e;\n    int odd = 0, even = 0;\n    for (auto e : a) {\n        if (e % 2 == 0) even++;\n        else odd++;\n    }\n    if (odd % 2 == 0) {\n        cout << ""YES"" << endl;\n    } else {\n        cout << ""NO"" << endl;\n    }\n}\n \nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(40);\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n}\n\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
When Sasha was studying in the seventh grade he started listening to music a lot In order to evaluate which songs he likes more he introduced the notion of the song s The title of the song is a word consisting of uppercase Latin letters The of the song is the of its title Let s define the of a word as the ratio of the number of vowels in the word to the number of all letters in the word Let s define the of a word as the sum of of all the substrings of the word More formally let s define the function which is equal to if is a vowel and to otherwise Let be the th character of string and be the substring of word staring at the th character and ending at the th character Then the of is defined by the formula The of equals Find the of the given song title We assume that the vowels are ,"['#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<set>\nusing namespace std;\n#define N 510000\nchar str[N];\nlong long s1[N],s2[N],s3[N];\ndouble ans=0;\nint n;\nbool pd(char ch){\n     return ch==\'I\' || ch==\'E\' || ch==\'A\' || ch==\'O\' || ch==\'U\' || ch==\'Y\';\n     }\nint main(){\n    scanf(""%s"",str);\n    n=strlen(str);\n    for(int i=1;i<=n;i++)\n      if(pd(str[i-1])){\n        int t1=min(i,n-i+1),t2=max(i,n-i+1);\n        s1[1]++;\n        s1[t1]--;\n        s2[t1]+=t1;\n        s2[t2+1]-=t1;\n        s3[n]++;\n        s3[t2]--;          \n      }\n    for(int i=1;i<=n;i++)s1[i]+=s1[i-1],s2[i]+=s2[i-1];\n    for(int i=n;i;i--)s3[i]+=s3[i+1];\n    for(int i=1;i<=n;i++){\n      long long s=s1[i]*i+s2[i]+s3[i]*(n-i+1);\n      ans+=(double)s/i;\n    }\n    printf(""%.7lf\\n"",ans);\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2000
You are given a rooted tree Each vertex contains a i tons of gold which costs c i per one ton Initially the tree consists only a root numbered 0 with a 0 tons of gold and price c 0 per ton There are q queries Each query has one of two types Add vertex i where i is an index of query as a son to some vertex p i vertex i will have a i tons of gold with c i per ton It s guaranteed that c i c p i For a given vertex v i consider the simple path from v i to the root We need to purchase w i tons of gold from vertices on this path spending the minimum amount of money If there isn t enough gold on the path If we buy x tons of gold in some vertex v the remaining amount of gold in it decreases by x of course we can t buy more gold that vertex has at the moment For each query of the second type calculate the resulting amount of gold we bought and the amount of money we should spend Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query so don t forget to flush output after printing answers You can use functions like in and in or similar after each writing in your program In standard if you don t tweak I O flushes in and in or in makes automatic flush as well ,"[""#include <bits/stdc++.h>\nusing namespace std;\nconst int LOG = 19;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int q, a0, c0;\n  cin >> q >> a0 >> c0;\n  vector<int> A(1), C(1);\n  A[0] = a0;\n  C[0] = c0;\n  int N = 1;\n  vector<int> d(1, 0);\n  vector<int> P(1, -1);\n  vector<vector<int>> pp(LOG, vector<int>(1, -1));\n  vector<int> id(q + 1, -1);\n  id[0] = 0;\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 1){\n      id[i + 1] = N;\n      int p, a, c;\n      cin >> p >> a >> c;\n      p = id[p];\n      P.push_back(p);\n      A.push_back(a);\n      C.push_back(c);\n      int d2 = d[p] + 1;\n      d.push_back(d2);\n      pp[0].push_back(p);\n      for (int j = 0; j < LOG - 1; j++){\n        if (pp[j][N] == -1){\n          pp[j + 1].push_back(-1);\n        } else {\n          pp[j + 1].push_back(pp[j][pp[j][N]]);\n        }\n      }\n      N++;\n    }\n    if (t == 2){\n      int v, w;\n      cin >> v >> w;\n      v = id[v];\n      if (A[v] == 0){\n        cout << 0 << ' ' << 0 << endl;\n      } else {\n        int p = v;\n        for (int j = LOG - 1; j >= 0; j--){\n          int p2 = pp[j][p];\n          if (p2 != -1){\n            if (A[p2] > 0){\n              p = p2;\n            }\n          }\n        }\n        int D = d[v] - d[p];\n        int ans1 = 0;\n        long long ans2 = 0;\n        for (int j = D; j >= 0; j--){\n          int v2 = v;\n          for (int k = 0; k < LOG; k++){\n            if ((j >> k & 1) == 1){\n              v2 = pp[k][v2];\n            }\n          }\n          int a = min(A[v2], w);\n          ans1 += a;\n          ans2 += (long long) C[v2] * a;\n          w -= a;\n          A[v2] -= a;\n          if (w == 0){\n            break;\n          }\n        }\n        cout << ans1 << ' ' << ans2 << endl;\n      }\n    }\n  }\n}""]","[1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]",2200
Today Marin is at a cosplay exhibition and is preparing for a group photoshoot For the group picture the cosplayers form a horizontal line A group picture is considered if for every contiguous segment of at least 2 cosplayers the number of males does not exceed the number of females obviously Currently the line has n cosplayers which can be described by a binary string s The i th cosplayer is male if s i 0 and female if s i 1 To ensure that the line is you can invite some additional cosplayers possibly zero to join the line at any position You can t remove any cosplayer from the line Marin wants to know the minimum number of cosplayers you need to invite so that the group picture of all the cosplayers is She can t do this on her own so she s asking you for help Can you help her ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tstring a;\n\t\tint n;\n\t\tcin >> n >> a;\n\t\tint ans=0;\n\t\tfor(int i=1;i<a.size();i++)\n\t\t{\n\t\t\tif(a[i]==\'0\'&&a[i-1]==\'0\')\n\t\t\t\tans+=2;\n\t\t}\n\t\tfor(int i=2;i<a.size();i++)\n\t\t{\n\t\t\tif(a[i]==\'0\'&&a[i-2]==\'0\'&&a[i-1]!=\'0\')\n\t\t\t\tans++;\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']","[0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
This time the Berland Team Olympiad in Informatics is held in a remote city that can only be reached by one small bus Bus has passenger seats seat can be occupied only by a participant from the city Today the bus has completed trips each time bringing participants The participants were then aligned in one line in the order they arrived with people from the same bus standing in the order of their seats i e if we write down the cities where the participants came from we get the sequence repeated times After that some teams were formed each consisting of participants form the same city standing next to each other in the line Once formed teams left the line The teams were formed until there were no neighboring participants from the same city Help the organizers determine how many participants have left in the line after that process ended We can prove that answer doesn t depend on the order in which teams were selected ,"['#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, ""/STACK:336777216"")  \nusing namespace std;\n\n#define mp make_pair  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n\nvector <pll> Vu;\nint main() {\n\tint N, K, M, i, j;\n\tscanf(""%d %d %d"", &N, &K, &M);\n\tfor (i = 1; i <= N; i++) {\n\t\tint t;\n\t\tscanf(""%d"", &t);\n\t\tif (!Vu.empty() && Vu.back().first == t) {\n\t\t\tVu.back().second++;\n\t\t\tif (Vu.back().second == K) Vu.pop_back();\n\t\t}\n\t\telse Vu.emplace_back(t, 1);\n\t}\n\n\tll s = 0;\n\tfor (auto it : Vu) s += it.second;\n\tif (M == 1 || s == 0) return !printf(""%lld\\n"", s);\n\n\ts *= M;\n\tint st = 0, en = (int)Vu.size() - 1;\n\twhile (st < en) {\n\t\tif (Vu[st].first != Vu[en].first) return !printf(""%lld\\n"", s);\n\t\tif (Vu[st].second + Vu[en].second == K) {\n\t\t\ts -= (ll)(M - 1) * K;\n\t\t\tst++, en--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (Vu[st].second + Vu[en].second > K) s -= (ll)(M - 1)*K;\n\t\treturn !printf(""%lld\\n"", s);\n\t}\n\tif (st > en) return !printf(""0\\n"");\n\tif (st == en) {\n\t\tll x = Vu[st].second * M;\n\t\tif (x % K == 0) return !printf(""0\\n"");\n\t\telse return !printf(""%lld\\n"", s - (x / K)*K);\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
Amr lives in Lala Land Lala Land is a very beautiful country that is located on a coordinate line Lala Land is famous with its apple trees growing everywhere Lala Land has exactly apple trees Tree number is located in a position and has apples growing on it Amr wants to collect apples from the apple trees Amr currently stands in position At the beginning he can choose whether to go right or left He ll continue in his direction until he meets an apple tree he didn t visit before He ll take all of its apples and then reverse his direction continue walking in this direction until he meets another apple tree he didn t visit before and so on In the other words Amr reverses his direction when visiting each new apple tree Amr will stop collecting apples when there are no more trees he didn t visit in the direction he is facing What is the maximum number of apples he can collect ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n\ntypedef pair < int ,int > pii;\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 1e5+5;\n\nint i, j, k, n, m;\n\nint x, y;\n\nvector< pii > l, r;\n\nint main(){\n\n\tcin >> n;\n\n\tFOR(i,1,n) {\n\t\t\n\t\tcin >> x >> y;\n\t\t\n\t\tif(x < 0) l.pb(mp(x,y));\n\t\telse r.pb(mp(x,y));\n\n\t}\n\n\tsort(l.begin(),l.end(),greater< pii > ());\n\n\tsort(r.begin(),r.end());\n\n\tint mn = min(l.size(), r.size());\n\n\tmn--;\n\n\tint ans = 0;\n\n\tFOR(i,0,mn) ans += l[i].nd + r[i].nd;\n\n\tint t = 0;\n\n\tif(l.size() > mn + 1) t = max(t, l[mn + 1].nd);\n\tif(r.size() > mn + 1) t = max(t, r[mn + 1].nd);\n\n\tcout << ans + t << endl;\n\n   return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]",1100
You are given a matrix with rows and columns Each element of the matrix is either an asterisk or a dot You may perform the following operation arbitrary number of times choose a square submatrix of with size where and replace each element of the chosen submatrix with a dot Choosing a submatrix of size costs coins What is the minimum number of coins you have to pay to replace all asterisks with dots ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint A[5];\nint val[5];\nchar in[4][1050];\n\nint nxt[65536][120];\nint cost[120];\n\nint dp[1050][4096];\nint main() {\n\tint N, i, j, k, l, m;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= 4; i++) scanf(""%d"", &A[i]);\n\tfor (i = 0; i < 4; i++) scanf(""%s"", in[i]);\n\tfor (i = 1; i <= 4; i++) {\n\t\tfor (j = 0; j < i; j++) for (k = 0; k < i; k++) val[i] |= 1 << (4 * j + k);\n\t}\n\n\tint p = 0;\n\tfor (i = 0; i <= 1; i++) {\n\t\tfor (j = 0; j <= 2; j++) {\n\t\t\tfor (k = 0; k <= 3; k++) {\n\t\t\t\tfor (l = 0; l <= 4; l++) {\n\t\t\t\t\tint totc = A[i] + A[j] + A[k] + A[l];\n\t\t\t\t\tcost[p] = totc;\n\t\t\t\t\tint v = (val[i] << 3) | (val[j] << 2) | (val[k] << 1) | val[l];\n\t\t\t\t\tfor (m = 0; m < 65536; m++) nxt[m][p] = m & ~v;\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tmemset(dp, 0x3f, sizeof(dp));\n\tint st = 0;\n\tfor (i = 0; i < 1; i++) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tst = st * 2;\n\t\t\tif (in[j][i] == \'*\') st++;\n\t\t}\n\t}\n\tfor (i = 0; i < 120; i++) dp[0][nxt[st][i]] = min(dp[0][nxt[st][i]], cost[i]);\n\tfor (i = 1; i < N; i++) {\n\t\tint v = 0;\n\t\tfor (j = 0; j < 4; j++) v = v * 2 + (int)(in[j][i] == \'*\');\n\t\tfor (j = 0; j < 4096; j++) {\n\t\t\tif (dp[i-1][j] > 1000000) continue;\n\n\t\t\tl = j * 16 + v;\n\t\t\tfor (k = 0; k < 120; k++) {\n\t\t\t\tint x = nxt[l][k];\n\t\t\t\tif (x < 4096) dp[i][x] = min(dp[i][x], dp[i - 1][j] + cost[k]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn !printf(""%d\\n"", dp[N - 1][0]);\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Little C loves number very much He loves all things about it Now he has a positive integer n He wants to split n into 3 positive integers a b c such that a b c n and none of the 3 integers is a multiple of 3 Help him to find a solution ,"[""#include <bits/stdc++.h>\nusing namespace std;int n;\nint main()\n{\n\tcin>>n;if(n%3==0) cout<<1<<' '<<1<<' '<<n-2<<endl;else cout<<1<<' '<<2<<' '<<n-3<<endl;\n}""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Leha somehow found an array consisting of integers Looking at it he came up with a task Two players play the game on the array Players move one by one The first player can choose for his move a subsegment of non zero length with an odd sum of numbers and remove it from the array after that the remaining parts are glued together into one array and the game continues The second player can choose a subsegment of non zero length with an even sum and remove it Loses the one who can not make a move Who will win if both play optimally ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n;\nbool sig;\nint main(){\n\tscanf(""%d"",&n);\n\tint x;\n\twhile (n--){\n\t\tscanf(""%d"",&x);\n\t\tsig|=(x&1);\n\t}\n\tsig?printf(""First""):printf(""Second"");\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
One day as Petya and his friend Vasya were having one of their numerous trips they decided to visit a museum castle The museum has a specific shape it consists of rooms connected with corridors so that one can access any room from any other one After the two friends had a little walk around the museum they decided to split and watch the pieces of art each of them found interesting They agreed to meet in one of the rooms at six p m However they forgot one quite essential thing they didn t specify the place to meet and when the time came they started to rush about the museum looking for each other they couldn t call each other as roaming made a call s cost skyrocket Yet even despite the whole rush they couldn t get enough of the pieces of art that s why each of them has the following strategy each minute he make a decision where to go with probability he doesn t move to any other place during this minute i e he stays in the room With probability he equiprobably choose one of the adjacent rooms and went there along the corridor Here is the ordinal number of the current room Building was expensive in ancient times that s why each corridor connected two different rooms and any two rooms had no more than one corridor between them The boys act simultaneously As the corridors are dark it is impossible to meet there however one can walk along the corridors in both directions besides the two boys can be going through the same corridor simultaneously without meeting The boys act like that until they meet each other More formally the two friends meet when at some moment of time both of them decided to appear in the same room For each room find the probability that the boys will meet there considering that at 6 p m they are positioned in rooms and correspondingly ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#pragma comment(linker, ""/STACK:16777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\nint a,b,c,d,i,j,n,m,k,s1,s2;\nlong double beg[501][501],mas[501][501], inv[501][501], rg[501][501];\nint num[22][22], num2[22][22], st[22];\nbool sm[22][22];\ndouble p[22];\nbool used[22];\n\ninline double prob(int a, int b) {\n\tif (a == b) return p[a];\n\tif (!sm[a][b]) return 0.0;\n\treturn (1 - p[a]) / st[a];\n}\nint main()\n{\n\t/*freopen(""input.txt"",""w"",stdout);\n\tprintf(""22 %d 1 5\\n"", 22 * 21 / 2);\n\trept(i, 22) rept(j, i + 1) {\n\t\t\tprintf(""%d %d\\n"", i + 1, j + 1);\n\t}\n\trept(i,22) {\n\t\tprintf(""%.2lf\\n"", (double)(rand()%999 + 1)/1001);\n\t}\n\texit(0);*/\n\t//freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n\tscanf(""%d%d"",&n,&m);\n\trept(i,n) rept(j,n)  num[i][j] = k++;\n\tscanf(""%d%d"",&s1,&s2);\n\trept(i,m) {\n\t\tscanf(""%d%d"",&a,&b); --a; --b;\n\t\tsm[a][b] = sm[b][a] = 1;\n\t}\n\trept(i,n) rept(j,n) if (sm[i][j]) ++st[i];\n\trept(i,n) scanf(""%lf"",&p[i]);\n\t--s1; --s2;\n\tif (s1 == s2) {\n\t\trept(i,n) {\n\t\t\tif (i) printf("" "");\n\t\t\tif (i == s1) printf(""1.0""); else\n\t\t\tprintf(""0.0"");\n\t\t}\n\t\tprintf(""\\n"");\n\t\texit(0);\n\t}\n\trept(i,n) rept(j,n) {\n\t\tif (i == j) {\n\t\t\tmas[num[i][j]][num[i][j]] = 0.0;\n\t\t\tcontinue;\n\t\t}\n\t\trept(z1, n) {\n\t\t\trept(z2, n) {\n\t\t\t\tdouble p1 = prob(i, z1);\n\t\t\t\tdouble p2 = prob(j, z2);\n\t\t\t\tmas[num[i][j]][num[z1][z2]] = p1 * p2;\n\t\t\t}\n\t\t}\n\t}\n\n\trept(i,k) rept(j,k) {\n\t\trg[i][j] = mas[i][j];\n\t\tif (i == j) mas[i][j] = 1.0 - mas[i][j]; else\n\t\tmas[i][j] = -mas[i][j];\n\t}\n\trept(i,k) inv[i][i] = 1.0;\n\trept(i,k) {\n\t\ta = -1;\n\t\tlong double cur = -1.0;\n\t\tFOR(j, i, k - 1) {\n\t\t\tif (a == -1 || abs(mas[j][i]) > cur) {\n\t\t\t\ta = j;\n\t\t\t\tcur = abs(mas[j][i]);\n\t\t\t}\n\t\t}\n\t\trept(j, k) {\n\t\t\tswap(mas[i][j], mas[a][j]);\n\t\t\tswap(inv[i][j], inv[a][j]);\n\t\t}\n\t\tcur = mas[i][i];\n\t\trept(j,k) {\n\t\t\tmas[i][j] /= cur;\n\t\t\tinv[i][j] /= cur;\n\t\t}\n\t\trept(j,k) {\n\t\t\tif (j == i) continue;\n\t\t\tlong double o = mas[j][i];\n\t\t\trept(z, k) {\n\t\t\t\tmas[j][z] = mas[j][z] - mas[i][z] * o;\n\t\t\t\tinv[j][z] = inv[j][z] - inv[i][z] * o;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*rept(i,k) rept(j,k) {\n\t\tmas[i][j] = 0.0;\n\t\trept(z,k) mas[i][j] += rg[i][z] * inv[z][j];\n\t}\n\trept(i,k) rept(j,k) inv[i][j] = mas[i][j];*/\n\n\t/*rept(i,k) {\n\t\tlong double sum = 0.0;\n\t\trept(j,k) sum += inv[i][j];\n\t\trept(j,k) inv[i][j] /= sum;\n\t}*/\n\n\trept(i,n) {\n\t\tif (i) printf("" "");\n\t\tprintf(""%.9lf"", (double)inv[num[s1][s2]][num[i][i]]);\n\t}\n\tprintf(""\\n"");\n\n//\tcerr << clock() << endl;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
Sasha has an array a of n integers He got bored and for all i j i j he wrote down the minimum value of a i and a j He obtained a new array b of size frac n cdot n 1 2 For example if a 2 3 5 1 he would write min 2 3 min 2 5 min 2 1 min 3 5 min 3 1 min 5 1 2 2 1 3 1 1 Then he randomly all the elements of the array b Unfortunately he forgot the array a and your task is to restore any possible array a from which the array b could have been obtained ,"[""#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<numeric>\n#include<cmath>\n#include<fstream>\n#include<random>\n#include<set>\n#include<unordered_set>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<queue>\n#include<stack>\n#include<fstream>\n#include<time.h>\n\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\n#define Max(a) *max_element(all(a))\n#define Min(a) *min_element(all(a))\n\nusing ll = long long;\nusing ld = long double;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int s = n * (n - 1) / 2;\n    vector<int> a(s);\n    for (int i = 0; i < s; ++i) {\n        cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    vector<int> b(n);\n    int p = 0;\n    for (int i = n - 1; i > 0; --i) {\n        b[n - 1 - i] = a[p];\n        p += i;\n    }\n    b[n - 1] = 1000000000;\n    for (int i = 0; i < n; ++i) cout << b[i] << ' ';\n    cout << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(40);\n\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n}""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1200
There are n seats in the train s car and there is exactly one passenger occupying every seat The seats are numbered from 1 to n from left to right The trip is long so each passenger will become hungry at some moment of time and will go to take boiled water for his noodles The person at seat i 1 leq i leq n will decide to go for boiled water at minute t i Tank with a boiled water is located to the left of the 1 st seat In case too many passengers will go for boiled water simultaneously they will form a queue since there can be only one passenger using the tank at each particular moment of time Each passenger uses the tank for exactly p minutes We assume that the time it takes passengers to go from their seat to the tank is negligibly small Nobody likes to stand in a queue So when the passenger occupying the i th seat wants to go for a boiled water he will first take a look on all seats from 1 to i 1 In case at least one of those seats is empty he assumes that those people are standing in a queue right now so he would be better seating for the time being However at the very first moment he observes that all seats with numbers smaller than i are busy he will go to the tank There is an unspoken rule that in case at some moment several people can go to the tank than only the leftmost of them that is seating on the seat with smallest number will go to the tank while all others will wait for the next moment Your goal is to find for each passenger when he will receive the boiled water for his noodles ,"['#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <map>\n#include <set>\n#include <complex>\n\n#define sz(v) ((int)((v).size()))\n#define all(v) (v).begin(), (v).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int INF = 0x3c3c3c3c;\nconst ll LINF = 1ll*INF*INF*2;\n\nconst int N = 1000001;\nint n,m;\n\nvector<pii> v;\npriority_queue<int, vector<int>, greater<int>> Q;\nqueue<int> q;\nll ans[N];\nint main(void){\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i=0; i<n; i++) {\n\t\tint t;\n\t\tscanf(""%d"", &t);\n\t\tv.push_back({t,i});\n\t}\n\tsort(all(v));\n\n\tll cur=-1;\n\tint idx=0;\n\tint cnt=0;\n\twhile(cnt<n) {\n\t\tif(q.empty() && Q.empty()) cur=v[idx].first;\n\t\t\n\t\twhile(idx<n && v[idx].first<=cur+m) {\n\t\t\tif(q.empty() || q.back()>v[idx].second) q.push(v[idx++].second);\n\t\t\telse Q.push(v[idx++].second);\n\t\t}\n\t\t\n\t\tcur+=m;\n\t\tans[q.front()]=cur; q.pop();\n\t\tcnt++;\n\n\t\tif(q.empty() && !Q.empty()) {\n\t\t\tq.push(Q.top()); Q.pop();\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++) printf(""%lld "", ans[i]);\n}\n']","[1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
A new innovative ticketing systems for public transport is introduced in Bytesburg Now there is a single travel card for all transport To make a trip a passenger scan his card and then he is charged according to the fare The fare is constructed in the following manner There are three types of tickets a ticket for one trip costs byteland rubles a ticket for minutes costs byteland rubles a ticket for one day minutes costs byteland rubles Note that a ticket for minutes activated at time can be used for trips started in time range from to inclusive Assume that all trips take exactly one minute To simplify the choice for the passenger the system automatically chooses the optimal tickets After each trip starts the system analyses all the previous trips and the current trip and chooses a set of tickets for these trips with a minimum total cost Let the minimum total cost of tickets to cover all trips from the first to the current is and the total sum charged before is Then the system charges the passenger the sum You have to write a program that for given trips made by a passenger calculates the sum the passenger is charged after each trip ,"['#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint a[100001];\nint d[100001];\n\nint main() {\n\tint i, n;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\td[i] = min(min(d[i - 1] + 20, d[upper_bound(a, a + i, a[i] - 90) - a - 1] + 50), d[upper_bound(a, a + i, a[i] - 1440) - a - 1] + 120);\n\t\tprintf(""%d\\n"", d[i] - d[i - 1]);\n\t}\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1600
A club plans to hold a party and will invite some of its n members The n members are identified by the numbers 1 2 dots n If member i is not invited the party will gain an unhappiness value of a i There are m pairs of friends among the n members As per tradition if both people from a friend pair are invited they will share a cake at the party The total number of cakes eaten will be equal to the number of pairs of friends such that both members have been invited However the club s oven can only cook two cakes at a time So the club demands that the total number of cakes eaten is an even number What is the minimum possible total unhappiness value of the party respecting the constraint that the total number of cakes eaten is even ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint T,n,m;\nint arr[100000];\nint p1[100000];\nint p2[100000];\nint deg[100000];\n\nint main(void)\n{\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d%d"",&n,&m);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(""%d"",&arr[i]);\n\t\t\tdeg[i]=0;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(""%d%d"",&p1[i],&p2[i]);\n\t\t\tp1[i]--; p2[i]--;\n\t\t\tdeg[p1[i]]++; deg[p2[i]]++;\n\t\t}\n\t\tint ans=114514;\n\t\tif(m%2==0) ans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif((m-deg[i])%2==0)\n\t\t\t\tans=min(ans,arr[i]);\n\t\tfor(int i=0;i<m;i++)\n\t\t\tif((m-deg[p1[i]]-deg[p2[i]]+1)%2==0)\n\t\t\t\tans=min(ans,arr[p1[i]]+arr[p2[i]]);\n\t\tprintf(""%d\\n"",ans);\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1300
Some people leave the lights at their workplaces on when they leave that is a waste of resources As a hausmeister of DHBW Sagheer waits till all students and professors leave the university building then goes and turns all the lights off The building consists of floors with stairs at the left and the right sides Each floor has rooms on the same line with a corridor that connects the left and right stairs passing by all the rooms In other words the building can be represented as a rectangle with rows and columns where the first and the last columns represent the stairs and the columns in the middle represent rooms Sagheer is standing at the ground floor at the left stairs He wants to turn all the lights off in such a way that he will not go upstairs until all lights in the floor he is standing at are off Of course Sagheer must visit a room to turn the light there off It takes one minute for Sagheer to go to the next floor using stairs or to move from the current room stairs to a neighboring room stairs on the same floor It takes no time for him to switch the light off in the room he is currently standing in Help Sagheer find the minimum total time to turn off all the lights Note that Sagheer does not have to go back to his starting position and he does not have to visit rooms where the light is already switched off ,"['#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#if __cplusplus >= 201103L\n#include <unordered_map>\n#include <unordered_set>\n#endif\n#include <vector>\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define FOR(i,a,b) for(int i=a;i<(b);i++)\n#define FORN(i,b) for(int i=0;i<(b);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> > vii;\n\nint n,m,k;\nchar b[16][128];\nint x[16],y[16];\nint dp[16][2];\n\nint f(int i, int j){\n\tif(dp[i][j]>=0)return dp[i][j];\n\tint r;\n\tif(i==k){\n\t\tassert(y[i]>=0&&x[i]<m);\n\t\tif(j==0)r=y[i];\n\t\telse r=m-1-x[i];\n\t}\n\telse {\n\t\tif(y[i]<0)r=1+f(i-1,j);\n\t\telse {\n\t\t\tr=m+f(i-1,j^1);\n\t\t\tif(j==0)r=min(r,2*y[i]+1+f(i-1,j));\n\t\t\telse r=min(r,2*(m-1-x[i])+1+f(i-1,j));\n\t\t}\n\t}\n\treturn dp[i][j]=r;\n}\n\nint main(){\n\tscanf(""%d%d"",&n,&m);m+=2;\n\tFORN(i,n)scanf(""%s"",b[i]);\n\tFORN(i,n)FORN(j,m)b[i][j]-=\'0\';\n\tFORN(i,n){\n\t\tx[i]=m;\n\t\ty[i]=-1;\n\t\tFORN(j,m)if(b[i][j])x[i]=min(x[i],j),y[i]=max(y[i],j);\n\t}\n\tk=0;\n\twhile(k<n&&y[k]<0)k++;\n\tif(k==n){puts(""0"");return 0;}\n\t//puts(""holis"");\n\tmemset(dp,-1,sizeof(dp));\n\tprintf(""%d\\n"",f(n-1,0));\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Thor is getting used to the Earth As a gift Loki gave him a smartphone There are applications on this phone Thor is fascinated by this phone He has only one minor issue he can t count the number of unread notifications generated by those applications maybe Loki put a curse on it so he can t events are about to happen in chronological order They are of three types Application generates a notification this new notification is unread Thor reads all notifications generated so far by application he may re read some notifications Thor reads the first notifications generated by phone applications notifications generated in first events of the first type It s guaranteed that there were at least events of the first type before this event Please note that he doesn t read first unread notifications he just reads the very first notifications generated on his phone and he may re read some of them in this operation Please help Thor and tell him the number of unread notifications after each event You may assume that initially there are no notifications in the phone ,"['#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cstdint>\n#include <climits>\n#include <numeric>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n  int n, q;\n  scanf(""%d%d"", &n, &q);\n  vector<bool> read;\n  int total_read = 0;\n  map<int, vector<int>> app2no;\n  int lt = 0;\n  for (int i = 0; i < q; i++) {\n    int a, b;\n    scanf(""%d%d"", &a, &b);\n    if (a == 1) {\n      app2no[b].push_back(read.size());\n      read.push_back(false);\n    }\n    else if (a == 2) {\n      for (auto c : app2no[b]) {\n        if (!read[c])\n          total_read++;\n        read[c] = true;\n      }\n      app2no[b].clear();\n    }\n    else if (a == 3) {\n      for (int j = lt; j < b; j++) {\n        if (!read[j])\n          total_read++;\n        read[j] = true;\n      }\n      lt = max(lt, b);\n    }\n    int ans = read.size() - total_read;\n    printf(""%d\\n"", ans);\n  }\n  return 0;\n}']","[0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1600
You are given integers n and m Fill an n by m grid with the integers 1 through n cdot m in such a way that for any two adjacent cells in the grid the absolute difference of the values in those cells is not a prime number Two cells in the grid are considered adjacent if they share a side It can be shown that under the given constraints there is always a solution ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int t; cin>>t;\n    for (int ti = 0; ti < t; ++ti) {\n        int n,m; cin>>n>>m;\n        int s = n*m;\n        int r = m+1;\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                cout << r+y << (y == m-1 ? ""\\n"" : "" "");\n            }\n            r += 2*m;\n            if (r > s) {\n                r = 1;\n            }\n        }\n    }\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1400
You are given an array a of n integers You want to make all elements of a equal to zero by doing the following operation times Select a segment for each number in this segment we can add a multiple of len to it where len is the length of this segment added integers can be different It can be proven that it is always possible to make all elements of a equal to zero ,"['/**\n *    author:  tourist\n *    created: 30.08.2020 17:34:53       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  if (n == 1) {\n    cout << 1 << "" "" << 1 << \'\\n\';\n    cout << 0 << \'\\n\';\n    cout << 1 << "" "" << 1 << \'\\n\';\n    cout << 0 << \'\\n\';\n    cout << 1 << "" "" << 1 << \'\\n\';\n    cout << -a[0] << \'\\n\';\n    return 0;\n  }\n  cout << 1 << "" "" << 1 << \'\\n\';\n  cout << -a[0] << \'\\n\';\n  a[0] = 0;\n  cout << 2 << "" "" << n << \'\\n\';\n  for (int i = 2; i <= n; i++) {\n    if (i > 2) {\n      cout << "" "";\n    }\n    long long add = (long long) (a[i - 1] % n) * (n - 1);\n    cout << add;\n    a[i - 1] += add;\n  }\n  cout << \'\\n\';\n  cout << 1 << "" "" << n << \'\\n\';\n  for (int i = 1; i <= n; i++) {\n    if (i > 1) {\n      cout << "" "";\n    }\n    assert(a[i - 1] % n == 0);\n    cout << -a[i - 1];\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1600
Polycarp has recently created a new level in this cool new game Berlio Maker 85 and uploaded it online Now players from all over the world can try his level All levels in this game have two stats to them the number of plays and the number of clears So when a player attempts the level the number of plays increases by 1 If he manages to finish the level successfully then the number of clears increases by 1 as well so if the player finishes the level successfully then the number of plays will increase at the same time as the number of clears Polycarp is very excited about his level so he keeps peeking at the stats to know how hard his level turns out to be So he peeked at the stats n times and wrote down n pairs of integers p 1 c 1 p 2 c 2 dots p n c n where p i is the number of plays at the i th moment of time and c i is the number of clears at the same moment of time i e the order of given pairs is exactly the same as Polycarp has written down Between two consecutive moments of time Polycarp peeked at the stats many players but possibly zero could attempt the level Finally Polycarp wonders if he hasn t messed up any records and all the pairs are correct If there could exist such a sequence of plays and clears respectively that the stats were exactly as Polycarp has written down then he considers his records correct Help him to check the correctness of his records For your convenience you have to answer multiple independent test cases ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nint _,n,p[N],c[N];\nbool check() {\n\tint pp=0,cc=0;\n\trep(i,0,n) {\n\t\tif (p[i]<pp) return 0;\n\t\tint x=c[i]-cc;\n\t\tif (x<0||x>p[i]-pp) return 0;\n\t\tcc=c[i]; pp=p[i];\n\t}\n\treturn 1;\n}\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tscanf(""%d"",&n);\n\t\trep(i,0,n) {\n\t\t\tscanf(""%d%d"",p+i,c+i);\n\t\t}\n\t\tputs(check()?""YES"":""NO"");\n\t}\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Okabe needs bananas for one of his experiments for some strange reason So he decides to go to the forest and cut banana trees Consider the point in the 2D plane such that and are integers and There is a tree in such a point and it has bananas There are no trees nor bananas in other points Now Okabe draws a line with equation Okabe can select a single rectangle with axis aligned sides with all points on or under the line and cut all the trees in all points that are inside or on the border of this rectangle and take their bananas Okabe s rectangle can be degenerate that is it can be a line segment or even a point Help Okabe and find the maximum number of bananas he can get if he chooses the rectangle wisely Okabe is sure that the answer does not exceed You can trust him ,"['#include<bits/stdc++.h>\n#define oo 0x3f3f3f3f\n#define cl(x) memset(x, 0, sizeof(x))\n#define maxn \ntypedef long long ll;\nusing namespace std;\nvoid gn(int &x) {\n\tx = 0; char ch = getchar();\n\twhile (ch < \'0\' || ch > \'9\') ch = getchar();\n\twhile (ch >= \'0\' && ch <= \'9\')\n\t\tx = x * 10 + ch - \'0\', ch = getchar();\n}\nint m, b;\nll ans;\nint main() {\n\tgn(m); gn(b);\n\tfor (int y = 0; y <= b; ++y) {\n\t\tint x = m * (b - y);\n\t\tans = max(ans, 1ll * x * (x + 1) / 2ll * (y + 1) + 1ll * y * (y + 1) / 2ll * (x + 1));\n\t}\n\tprintf(""%I64d\\n"", ans);\n\treturn 0;\n}\n\n\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Paprika loves permutations She has an array a 1 a 2 dots a n She wants to make the array a of integers 1 to n In order to achieve this goal she can perform operations on the array In each operation she can choose two integers i 1 le i le n and x x 0 then perform a i a i bmod x that is replace a i by the remainder of a i divided by x In different operations the chosen i and x Determine the minimum number of operations needed to make the array a permutation of integers 1 to n If it is impossible output 1 A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tfor (cin >> t; t; t -= 1) {\n\t\t//b < a / 2\n\t\tint n;\n\t\tcin >> n;\n\t\tset<int> s;\n\t\tfor (int i = 1; i <= n; i += 1) s.insert(i);\n\t\tvector<int> v;\n\t\tfor (int i = 1, a; i <= n; i += 1) {\n\t\t\tcin >> a;\n\t\t\tif (s.contains(a)) s.erase(a);\n\t\t\telse v.push_back(a);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ok = 1;\n\t\tfor (int i = 0; int x : s)\n\t\t\tif (x * 2 >= v[i ++]) ok = 0;\n\t\tif (ok) cout << v.size() << ""\\n"";\n\t\telse cout << ""-1\\n"";\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",1300
You are given a permutation p of n elements A permutation of n elements is an array of length n containing each integer from 1 to n exactly once For example 1 2 3 and 4 3 5 1 2 are permutations but 1 2 4 and 4 3 2 1 2 are not permutations You should perform q queries There are two types of queries 1 x y swap p x and p y 2 i k print the number that i will become if we assign i p i k times ,"['#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <utility>\n#include <cmath>\n#include <numeric>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pb push_back\n#define endl ""\\n""\n#define all(x) x.begin(), x.end()\nconst int M = 200007;\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst double pi = acos(-1);\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nint n, q, p[M], go[M], pref[M];\n\nint main()\n{\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin >> n >> q;\n    int block = sqrt(n);\n    for(int i = 1; i <= n; ++i) cin >> p[i];\n    for(int i = 1; i <= n; ++i){\n         pref[p[i]] = i;\n         int x = i;\n         for(int j = 0; j < block; ++j) x = p[x];\n         go[i] = x;\n    }\n    while(q--){\n        int t, x, y;\n        cin >> t >> x >> y;\n        if(t == 1){\n            swap(pref[p[x]], pref[p[y]]);\n            swap(p[x], p[y]);\n            int cur = x;\n            for(int i = 0; i < block; ++i) cur = p[cur];\n            for(int i = 0; i < block; ++i){\n                go[x] = cur;\n                cur = pref[cur];\n                x = pref[x];\n            }\n            cur = y;\n            for(int i = 0; i < block; ++i) cur = p[cur];\n            for(int i = 0; i < block; ++i){\n                go[y] = cur;\n                cur = pref[cur];\n                y = pref[y];\n            }\n        }\n        else{\n            while(y >= block){\n                y -= block;\n                x = go[x];\n            }\n            while(y--) x = p[x];\n            cout << x << endl;\n        }\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2400
Let s call beauty of an array b 1 b 2 ldots b n n 1 min limits 1 leq i j leq n b i b j You re given an array a 1 a 2 ldots a n and a number k Calculate the sum of beauty over all subsequences of the array of length exactly k As this number can be very large output it modulo 998244353 A sequence a is a subsequence of an array b if a can be obtained from b by deletion of several possibly zero or all elements ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = 998244353;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\n\nconst int N = 1010;\nint n, k, m;\nint a[N];\nint dp[N][N];\nint ANS;\n\nint solve(int d) {\n\tfor (int i = 0; i <= k; i++)\n\t\tfor (int j = 0; j <= n; j++)\n\t\t\tdp[i][j] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tdp[1][i] = i;\n\tfor (int t = 1; t < k; t++) {\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile(a[i] - a[p] >= d) p++;\n\t\t\tdp[t + 1][i + 1] = add(dp[t + 1][i], dp[t][p]);\n\t\t}\n\t}\n\treturn dp[k][n];\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tsort(a, a + n);\n\tm = a[n - 1] - a[0];\n\tfor (int d = 1; d * (k - 1) <= m; d++)\n\t\tANS = add(ANS, solve(d));\n\tprintf(""%d\\n"", ANS);\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
This year Alex has finished school and now he is a first year student of Berland State University For him it was a total surprise that even though he studies programming he still has to attend physical education lessons The end of the term is very soon but unfortunately Alex still hasn t attended a single lesson Since Alex doesn t want to get expelled he wants to know the number of working days left until the end of the term so he can attend physical education lessons during these days But in BSU calculating the number of working days is a complicated matter There are days left before the end of the term numbered from to and initially all of them are working days Then the university staff sequentially publishes orders one after another Each order is characterised by three numbers and If then all days from to inclusive become non working days If some of these days are made working days by some previous order then these days still become non working days If then all days from to inclusive become working days If some of these days are made non working days by some previous order then these days still become working days Help Alex to determine the number of working days left after each order ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\n\nmap<int, int>working;\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tint n, q; cin >> n >> q;\n\tworking[-1] = -1;\n\tworking[2E9] = 2E9;\n\tworking[1] = n;\n\tint answer = n;\n\twhile (q--) {\n\t\tint l, r, k; cin >> l >> r >> k;\n\t\tint haveNow = 0;\n\t\tmap<int, int>::iterator it = working.lower_bound(l);\n\t\tit--;\n\t\tif (it->second >= l) {\n\t\t\tworking[l] = it->second;\n\t\t\tit->second = l-1;\n\t\t}\n\t\tit++;\n\t\twhile (it->first <= r) {\n\t\t\tif (it->second > r) {\n\t\t\t\thaveNow += r + 1 - it->first;\n\t\t\t\tworking[r + 1] = it->second;\n\n\t\t\t}\n\t\t\telse\n\t\t\t\thaveNow += it->second - it->first + 1;\n\t\t\tmap<int, int>::iterator it2 = it;\n\t\t\tit++;\n\t\t\tworking.erase(it2);\n\t\t}\n\t\tif (k == 1) {\n\t\t\tanswer -= haveNow;\n\t\t}\n\t\telse {\n\t\t\tanswer -= haveNow;\n\t\t\tworking[l] = r;\n\t\t\tanswer += r - l + 1;\n\t\t}\n\t\tcout << answer << ""\\n"";\n\t}\n\n\treturn 0;\n}']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2300
It is a holiday season and Koala is decorating his house with cool lights He owns n lights all of which flash periodically After taking a quick glance at them Koala realizes that each of his lights can be described with two parameters a i and b i Light with parameters a i and b i will toggle on to off or off to on every a i seconds starting from the b i th second In other words it will toggle at the moments b i b i a i b i 2 cdot a i and so on You know for each light whether it s initially on or off and its corresponding parameters a i and b i Koala is wondering what is the maximum number of lights that will ever be on at the same time So you need to find that out ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1010;\nint n,a[N],b[N],f[N];\nchar s[N];\n\nint main() {\n\tscanf(""%d"",&n);\n\tscanf(""%s"",s);\n\trep(i,0,n) f[i]=s[i]-\'0\';\n\trep(i,0,n) {\n\t\tscanf(""%d%d"",a+i,b+i);\n\t}\n\tint ans=accumulate(f,f+n,0);\n\trep(i,0,100000) {\n\t\trep(j,0,n) if (i>=b[j]&&(i-b[j])%a[j]==0) f[j]^=1;\n\t\tans=max(ans,accumulate(f,f+n,0));\n\t}\n\tprintf(""%d\\n"",ans);\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1300
On February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length k k ge 3 Nastya was very confused by this present so she decided to break the door throwing it on the mountains Mountains are described by a sequence of heights a 1 a 2 dots a n in order from left to right k le n It is guaranteed that neighboring heights are not equal to each other that is a i ne a i 1 for all i from 1 to n 1 Peaks of mountains on the segment l r from l to r are called indexes i such that l i r a i 1 a i and a i a i 1 It is worth noting that the boundary indexes l and r for the segment For example if n 8 and a 3 1 4 1 5 9 2 6 then the segment 1 8 has only two peaks with indexes 3 and 6 and there are no peaks on the segment 3 6 To break the door Nastya throws it to a segment l l k 1 of consecutive mountains of length k 1 le l le n k 1 When the door touches the peaks of the mountains it breaks into two parts after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains and so on Formally the number of parts that the door will break into will be equal to p 1 where p is the number of peaks on the segment l l k 1 Nastya wants to break it into as many pieces as possible Help her choose such a segment of mountains l l k 1 that the number of peaks on it is maximum If there are several optimal segments Nastya wants to find one for which the value l is minimal Formally you need to choose a segment of mountains l l k 1 that has the maximum number of peaks Among all such segments you need to find the segment that has the minimum possible value l ,"['#include <bits/stdc++.h>\n\nint A[210000];\nint P[210000];\nint pre[210000];\n\nint main() {\n    int T; scanf(""%d"", &T);\n    while (T--) {\n        int N, K;\n        scanf(""%d%d"", &N, &K);\n        for (int i = 0; i < N; ++i)\n            scanf(""%d"", &A[i]);\n        for (int i = 1; i < N - 1; ++i)\n            P[i] = (A[i] > A[i - 1] && A[i] > A[i + 1]);\n        for (int i = 1; i <= N; ++i) pre[i] = pre[i - 1] + P[i - 1];\n        int maxi = 0;\n        for (int i = 0; i + K - 1 < N; ++i)\n            if (pre[maxi + K - 1] - pre[maxi + 1] < pre[i + K - 1] - pre[i + 1])\n                maxi = i;\n        printf(""%d %d\\n"", pre[maxi + K - 1] - pre[maxi + 1] + 1, maxi + 1);\n    }\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
You are given a multiset S Initially S 1 2 3 ldots n You will perform the following operation n 1 times Choose the largest number S text max in S and the smallest number S text min in S Remove the two numbers from S and add S text max S text min into S It s easy to show that there will be exactly one number left after n 1 operations Output that number ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconst long double phi = (1 + std::sqrt(5.L)) / 2;\n\ni64 floor_sum(i64 n, i64 m, i64 a, i64 b) {\n    i64 ans = 0;\n    if (a >= m) {\n        ans += (n - 1) * n * (a / m) / 2;\n        a %= m;\n    }\n    if (b >= m) {\n        ans += n * (b / m);\n        b %= m;\n    }\n\n    long long y_max = (a * n + b) / m, x_max = (y_max * m - b);\n    if (y_max == 0) return ans;\n    ans += (n - (x_max + a - 1) / a) * y_max;\n    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);\n    return ans;\n}\n\nconstexpr i64 X = 701408733;\nconstexpr i64 Y = 1134903170;\n\nint g(int n) {\n    int ans = 0;\n    ans -= floor_sum(n / 2 + 1, Y, 2 * X, 0);\n    ans += floor_sum((n + 1) / 2, Y, 2 * X, X);\n    return ans;\n}\n\nint get(int n) {\n    int t = (n + 1) * Y / (2 * Y + X);\n    \n    int ans = 0;\n    ans += g(n - 1);\n    ans -= g(t);\n    if (n % 2 == 0) {\n        ans *= -1;\n    }\n    ans += int(n * X / Y) * ((n - t - 1) % 2 == 0 ? -1 : 1);\n    if ((n - t) % 2 == 1) {\n        ans += n;\n    }\n    \n    return ans;\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::cout << get(n) << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2900
A new bus route is opened in the city The route is a closed polygon line in the place with all segments parallel to one of the axes buses will operate on the route All buses move in a loop along the route in the same direction with equal constant velocities stopping times are negligible in this problem Buses start their movement in the first vertex of the route with equal interval Suppose that is the total time for a single bus to travel the whole loop of the route Then the bus 1 starts moving at time 0 the bus 2 starts at time the bus 3 starts at time and so on finally the bus starts moving at time Thus all intervals between pairs of consecutive buses including the interval between the last and the first bus are equal Buses can communicate with each other via wireless transmitters of equal power If the transmitters have power then only buses within distance of each other can communicate The buses are also equipped with a distributed system of schedule tracking For all buses to stick to the schedule the system has to synchronize the necessary data between all buses from time to time At the moment of synchronization the bus 1 communicates with the bus 2 the bus 2 with bus 3 and so on also the bus communicates with the bus 1 As a research employee you are tasked with finding the smallest value of such that it is possible to find a time moment to perform synchronization once all buses have started moving ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK ""text""\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nstruct point {\n  ld x, y;\n\n  void read() {\n    int x_, y_;\n    assert(scanf(""%d%d"", &x_, &y_) == 2);\n    x = x_, y = y_;\n  }\n\n  point(ld x_ = 0, ld y_ = 0) : x(x_), y(y_) {}\n\n  point operator - (const point &p) const {\n    return point(x - p.x, y - p.y);\n  }\n\n  point operator + (const point &p) const {\n    return point(x + p.x, y + p.y);\n  }\n\n  point operator * (const ld &k) const {\n    return point(x * k, y * k);\n  }\n\n  ld operator * (const point &p) const {\n    return x * p.x + y * p.y;\n  }\n\n  ld slen() const {\n    return *this * *this;\n  }\n\n  ld len() const {\n    return sqrt(slen());\n  }\n\n  bool operator == (const point &p) const {\n    return abs(x - p.x) <= eps && abs(y - p.y) <= eps;\n  }\n\n  point norm() const {\n    return *this * (1 / len());\n  }\n\n  point rot() const {\n    return point(-y, x);\n  }\n};\n\nconst int maxn = (int) 1e5 + 10;\nint n, m;\n\npoint ps[maxn];\n\nint read() {\n  if (scanf(""%d%d"", &n, &m) < 2) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    ps[i].read();\n  }\n  return 1;\n}\n\nbool mcmp(pair<ld, int> &x, pair<ld, int> &y) {\n  if (abs(x.first - y.first) > eps) {\n    return x.first < y.first;\n  }\n  return 0;\n}\n\nbool ok(vector<pair<ld, point> > &ss, ld y, ld len) {\n  //eprintf(""len = %.3f\\n"", (double) len);\n  static vector<pair<ld, int> > a;\n  a.clear();\n\n  int it = 0;\n  for (int i = 0; i < sz(ss) - 1; ++i) {\n    ld x1 = ss[i].first;\n    ld x2 = ss[i + 1].first;\n    point p1 = ss[i].second, p2 = ss[i + 1].second;\n\n    if (!(p1 == p2)) {\n      point dir = (p2 - p1).norm();\n      point norm = dir.rot();\n\n      point c = norm * (norm * p1);\n      if (c.len() > y) {\n        continue;\n      }\n      ld dx = y * y - c.slen();\n      dx = sqrt(max((ld) 0, dx));\n\n      ld dx1 = (p1 - c) * dir;\n      ld dx2 = (p2 - c) * dir;\n\n      ld ndx1 = dx1, ndx2 = dx2;\n      if (abs(dx1) > dx) {\n        ndx1 = (dx1 > 0 ? dx : -dx);\n      }\n      if (abs(dx2) > dx) {\n        ndx2 = (dx2 > 0 ? dx : -dx);\n      }\n      if (abs(ndx1 - ndx2) <= eps) {\n        continue;\n      }\n      point np1 = p1 + (p2 - p1) * ((ndx1 - dx1) / (dx2 - dx1));\n      point np2 = p1 + (p2 - p1) * ((ndx2 - dx1) / (dx2 - dx1));\n      ld nx1 = x1 + (x2 - x1) * (ndx1 - dx1) / (dx2 - dx1);\n      ld nx2 = x1 + (x2 - x1) * (ndx2 - dx1) / (dx2 - dx1);\n      p1 = np1, p2 = np2;\n      x1 = nx1, x2 = nx2;\n    } else {\n      if (p1.len() > y) {\n        continue;\n      }\n    }\n\n    //eprintf(""[%.3f, %.3f]\\n"", (double) x1, (double) x2);\n    assert(max(p1.len(), p2.len()) <= y + eps);\n\n    while (x1 < x2 - eps) {\n      ld xsmall = x1 - it * len;\n      if (xsmall >= len - eps) {\n        ++it;\n        continue;\n      }\n      a.pb(mp(xsmall, 1));\n\n      ld x2s = xsmall + (x2 - x1);\n      if (x2s >= len - eps) {\n        //eprintf(""adds  [%.3f..%.3f]\\n"", (double) xsmall, (double) len);\n        a.pb(mp(len, -1));\n        ++it;\n        x1 += len - xsmall;\n        continue;\n      }\n      //eprintf(""adds  [%.3f..%.3f]\\n"", (double) xsmall, (double) x2s);\n      a.pb(mp(x2s, -1));\n      break;\n    }\n  }\n\n  sort(a.begin(), a.end(), mcmp);\n\n  int bal = 0;\n  for (int i = 0; i < sz(a);) {\n    int i0 = i;\n    while (i < sz(a) && !mcmp(a[i0], a[i])) {\n      bal += a[i].second;\n      ++i;\n    }\n    //eprintf(""%d\\n"", bal);\n    if (bal >= m) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nvoid solve() {\n  ld len = 0;\n\n  ps[n] = ps[0];\n  for (int i = 0; i < n; ++i) {\n    len += (ps[i + 1] - ps[i]).len();\n  }\n\n  len /= m;\n\n  ld x = 0;\n\n  int i = 1 % n, j = 1 % n;\n  point p = ps[0], q = ps[0];\n  {\n    ld left = len;\n    while (1) {\n      ld clen = (ps[j] - q).len();\n      if (left >= clen - eps) {\n        left -= clen;\n        q = ps[j];\n        j = (j + 1) % n;\n        continue;\n      }\n      q = q + (ps[j] - q) * (left / clen);\n      break;\n    }\n  }\n\n  vector<pair<ld, point> > ss;\n  while (1) {\n    ss.pb(mp(x, (p - q)));\n    if (x >= len * m - eps) {\n      break;\n    }\n\n    ld len1 = (ps[i] - p).len();\n    ld len2 = (ps[j] - q).len();\n    //eprintf(""%.3f %.3f\\n"", (double) len1, (double) len2);\n\n    ld mn = min(len1, len2);\n    mn = min(mn, len * m - x);\n    assert(mn > eps);\n\n    p = p + (ps[i] - p) * (mn / len1);\n    q = q + (ps[j] - q) * (mn / len2);\n    len1 -= mn, len2 -= mn;\n    x += mn;\n    if (len1 <= eps) {\n      i = (i + 1) % n;\n    }\n    if (len2 <= eps) {\n      j = (j + 1) % n;\n    }\n  }\n\n  /*for (int i = 0; i < sz(ss); ++i) {\n    eprintf(""(%.3f, (%.3f,%.3f))\\n"", (double) ss[i].first, (double) ss[i].second.x, (double) ss[i].second.y);\n  }\n  assert(!ok(ss, 23.1, len));\n  */\n\n  ld left = 0, right = 1e4;\n\n  for (int iter = 0; iter < 50; ++iter) {\n    ld mid = (left + right) / 2;\n    if (ok(ss, mid, len)) {\n      right = mid;\n    } else {\n      left = mid;\n    }\n  }\n\n  printf(""%.18f\\n"", (double) right);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK "".out"", ""w"", stdout);\n  assert(freopen(TASK "".in"", ""r"", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""Time %.2f\\n"", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",3100
One winter morning Rudolf was looking thoughtfully out the window watching the falling snowflakes He quickly noticed a certain symmetry in the configuration of the snowflakes And like a true mathematician Rudolf came up with a mathematical model of a snowflake He defined a snowflake as an undirected graph constructed according to the following rules Initially the graph has only one vertex Then more vertices are added to the graph The initial vertex is connected by edges to k new vertices k 1 Each vertex that is connected to only one other vertex is connected by edges to k more new vertices This step should be done The smallest possible snowflake for k 4 is shown in the figure After some mathematical research Rudolf realized that such snowflakes may not have any number of vertices Help Rudolf check if a snowflake with n vertices can exist ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n\nlong long root_n(long long n, int k)\n{\n\tlong long m = pow(n, (long double)1.0 / k);\n\twhile (pow(m, k) <= n) \n    m++;\n\tm--;\n\treturn m;\n}\n\nvoid solve()\n{\n  long long n;\n\tcin >> n;\n\n\n\tfor (int m = 3; m<65;++m)\n    {\n\t\tlong long k = root_n(n, m-1);\n\t\tif (k < 2) continue;\n\t\t__int128 nn = n;\n\t\tnn *= (k - 1);\n\t\tnn += 1;\n\t\twhile (nn % k == 0) nn /= k;\n\t\tif (nn == 1) {\n\t\t\tcout << ""YES"" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << ""NO"" << endl;\n\treturn;\n}\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n}\n']","[0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Students love to celebrate their holidays Especially if the holiday is the day of the end of exams Despite the fact that Igor K unlike his groupmates failed to pass a programming test he decided to invite them to go to a cafe so that each of them could drink a bottle of fresh cow milk Having entered the cafe the friends found different kinds of milk on the menu that s why they ordered bottles one bottle of each kind We know that the volume of milk in each bottle equals When the bottles were brought in they decided to pour all the milk evenly among the cups so that each got a cup As a punishment for not passing the test Igor was appointed the person to pour the milk He protested that he was afraid to mix something up and suggested to distribute the drink so that the milk from each bottle was in no more than two different cups His friends agreed but they suddenly faced the following problem and what is actually the way to do it Help them and write the program that will help to distribute the milk among the cups and drink it as quickly as possible Note that due to Igor K s perfectly accurate eye and unswerving hands he can pour any fractional amount of milk from any bottle to any cup ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nvector <pair <int, int> > cup[60]; // id, amount\n\nint main(void){\n    int N,M,W,i,j;\n    \n    cin >> N >> W >> M;\n    if(M > N && N % (M - N) != 0){\n        cout << ""NO"" << endl;\n        return 0;\n    }\n    \n    REP(i,N){\n        int low = i*M, high = (i+1)*M, mid = low/N*N + N;\n        if(high <= mid){\n            cup[low/N].push_back(make_pair(i+1,M));\n        } else {\n            cup[low/N].push_back(make_pair(i+1,mid-low));\n            cup[low/N+1].push_back(make_pair(i+1,high-mid));\n        }\n    }\n    \n    cout << ""YES"" << endl;\n    REP(i,M) REP(j,cup[i].size()){\n        int id = cup[i][j].first;\n        double amount = (double)cup[i][j].second * W / M;\n        printf(""%d %.6f"",id,amount);\n        if(j == cup[i].size() - 1) printf(""\\n""); else printf("" "");\n    }\n    \n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Iahub has drawn a set of points in the cartesian plane which he calls special points A quadrilateral is a simple polygon without self intersections with four sides also called edges and four vertices also called corners Please note that a quadrilateral doesn t have to be convex A special quadrilateral is one which has all four vertices in the set of special points Given the set of special points please calculate the maximal area of a special quadrilateral ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define FR(i,a) for(int i = 0; i < (a); i++)\nusing namespace std;\n\nstruct Point {\n    double x,y;\n    Point() {}\n    Point(double x, double y):x(x),y(y){}\n    Point operator -(Point q) {return Point(x-q.x,y-q.y);}\n    double operator %(Point q){ return x*q.y-y*q.x;}\n};\nint n;\nPoint p[2000];\n\nvoid get(int i, int j, double &a, double &b, double &c) {\n    a = p[i].y - p[j].y;\n    b = p[j].x - p[i].x;\n    c = - a * p[i].x - b * p[i].y;\n}\ndouble f(Point X, double A, double B, double C) {\n    return X.x * A + X.y * B + C;\n}\ndouble get_area(Point A, Point B, Point C) {\n    return (0.5*abs(((B-A)%(C-A))));\n}\nint main() {\n    //freopen(""test.in"",""r"",stdin);\n    //freopen(""A.out"",""w"",stdout);\n    cin >> n;\n    FOR(i,1,n) cin >> p[i].x >> p[i].y;\n    double res = 0;\n    FOR(i,1,n)\n    FOR(j,i+1,n) {\n        bool ok1 = false, ok2 = false;\n        double a,b,c;\n        get(i,j,a,b,c);\n        FOR(k,1,n)\n        if (k != i && k != j) {\n            if (f(p[k],a,b,c) < 0) ok1 = true;\n            if (f(p[k],a,b,c) > 0) ok2 = true;\n        }\n        if (!ok1 || !ok2) continue;\n        double area1 = -1e9, area2 = -1e9;\n        FOR(k,1,n)\n        if (k != i && k != j) {\n            if (f(p[k],a,b,c) < 0)\n                area1 = max(area1,get_area(p[k],p[i],p[j]));\n            if (f(p[k],a,b,c) > 0)\n                area2 = max(area2,get_area(p[k],p[i],p[j]));\n        }\n        res = max(res,area1+area2);\n    }\n    printf(""%.9lf\\n"",res);\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2100
You might have remembered Theatre square from the problem 1A Now it s finally getting repaved The square still has a rectangular shape of n times m meters However the picture is about to get more complicated now Let a i j be the j th square in the i th row of the pavement You are given the picture of the squares if a i j then the j th square in the i th row should be if a i j then the j th square in the i th row should be The black squares are paved already You have to pave the white squares There are two options for pavement tiles 1 times 1 tiles each tile costs x burles and covers exactly 1 square 1 times 2 tiles each tile costs y burles and covers exactly 2 adjacent squares of the What is the smallest total price of the tiles needed to cover all the white squares ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 1005;\nchar c[maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    int tst;\n    cin >> tst;\n    while (tst--) {\n        int n, m;\n        cin >> n >> m;\n        int x, y;\n        cin >> x >> y;\n        y = min(y, 2 * x);\n        int ans = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                cin >> c[i][j];\n                if (c[i][j] == \'.\') {\n                    if (j != 1 && c[i][j - 1] == \'.\' && c[i][j] == \'.\') {\n                        c[i][j] = \'*\';\n                        c[i][j - 1] = \'*\';\n                        ans += y;\n                    }\n                }\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (c[i][j] == \'.\') ans += x;\n            }\n        }\n        cout << ans << \'\\n\';\n    }\n    return 0;\n}']","[1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1000
You are given an array a of n positive integers In one operation you must pick some i j such that 1 leq i j leq a and append a i a j to the end of the a i e increase n by 1 and set a n to a i a j Your task is to minimize and print the minimum value of a after performing k operations ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int N = 2007;\nint T, n, m, k;\nll a[N], b[N * N];\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tcin >> n >> k;\n\t\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\t\tif (k >= 3) {\n\t\t\tcout << ""0\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tif (k == 1) {\n\t\t\tll ans = 2e18;\n\t\t\tfor (int i = 1; i <= n; ++i) ans = min(ans, a[i]);\n\t\t\tfor (int i = 1; i <= n; ++i)\n\t\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\t\tans = min(ans, abs(a[i] - a[j]));\n\t\t\tcout << ans << \'\\n\';\n\t\t\tcontinue;\n\t\t}\n\t\tll ans = 2e18;\n\t\tfor (int i = 1; i <= n; ++i) ans = min(ans, a[i]);\n\t\tm = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\t\tb[++m] = abs(a[i] - a[j]);\n\t\tsort(b + 1, b + m + 1);\n\t\tans = min(ans, b[1]);\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tint p = lower_bound(b + 1, b + m + 1, a[i]) - b;\n\t\t\tif (p <= m) ans = min(ans, b[p] - a[i]);\n\t\t\tif (p > 1) ans = min(ans, a[i] - b[p - 1]);\n\t\t}\n\t\tcout << ans << \'\\n\';\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0]",1400
One day Qwerty the Ranger witnessed two transport ships collide with each other As a result all contents of their cargo holds scattered around the space And now Qwerty wants to pick as many lost items as possible to sell them later The thing is both ships had lots of new gravitational grippers transported to sale A gripper is a device that can be installed on a spaceship and than draw items in space to itself grip and transport them to the ship s cargo hold Overall the crashed ships lost gravitational grippers the th gripper is located at a point with coordinates Each gripper has two features the power and the action radius and can grip any items with mass of no more than at distance no more than A gripper itself is an item too and it has its mass of Qwerty s ship is located at point and has an old magnetic gripper installed its characteristics are and There are no other grippers in the ship s cargo holds Find the largest number of grippers Qwerty can get hold of As he picks the items he can arbitrarily install any gripper in the cargo hold of the ship including the gripper he has just picked At any moment of time the ship can have only one active gripper installed We consider all items and the Qwerty s ship immobile when the ranger picks the items except for when the gripper moves an item then the item moves to the cargo holds and the ship still remains immobile We can assume that the ship s cargo holds have enough room for all grippers Qwerty can use any gripper he finds or the initial gripper an arbitrary number of times ,"['#include <algorithm>\n#include <set>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n  vector<int> x(1);\n  vector<int> y(1);\n  vector<int> p(1);\n  vector<int> r(1);\n  int n;\n  scanf(""%d"", &(x[0]));\n  scanf(""%d"", &(y[0]));\n  scanf(""%d"", &(p[0]));\n  scanf(""%d"", &(r[0]));\n  scanf(""%d"", &n);\n  x.resize(n + 1);\n  y.resize(n + 1);\n  p.resize(n + 1);\n  r.resize(n + 1);\n  vector<int> m(n + 1);\n  for (int i = 1; i <= n; ++i) {\n    scanf(""%d"", &(x[i]));\n    scanf(""%d"", &(y[i]));\n    scanf(""%d"", &(m[i]));\n    scanf(""%d"", &(p[i]));\n    scanf(""%d"", &(r[i]));\n    x[i] -= x[0];\n    y[i] -= y[0];\n  } \n  x[0] = 0;\n  y[0] = 0;\n  ++n;\n  /*int n = 250001;\n  vector<int> x(n);\n  for (int i = 0; i < n; ++i) x[i] = rand() % 10000000;\n  vector<int> y(n);\n  for (int i = 0; i < n; ++i) y[i] = rand() % 10000000;\n  vector<int> p(n);\n  for (int i = 0; i < n; ++i) p[i] = 10000000;\n  vector<int> r(n);\n  for (int i = 0; i < n; ++i) r[i] = 20000000;\n  vector<int> m(n);\n  for (int i = 0; i < n; ++i) m[i] = rand() % 10000000;*/\n\n  vector<ll> alldist(2 * n);\n  for (int i = 0; i < n; ++i) {\n    alldist[2 * i] = x[i] * (ll) x[i] + y[i] * (ll) y[i];\n    alldist[2 * i + 1] = r[i] * (ll) r[i];\n  }\n  sort(alldist.begin(), alldist.end());\n  int dcnt = 0;\n  for (int i = 0; i < alldist.size(); ++i) {\n    if (i == 0 || alldist[i] > alldist[i - 1])\n      alldist[dcnt++] = alldist[i];\n  }\n  vector<int> dist(n);\n  for (int i = 0; i < n; ++i) {\n    int left = -1;\n    int right = dcnt;\n    ll need = x[i] * (ll) x[i] + y[i] * (ll) y[i];\n    while (right - left > 1) {\n      int mid = (left + right) / 2;\n      if (alldist[mid] == need) {\n        dist[i] = mid;\n\tbreak;\n      } else if (alldist[mid] < need) {\n        left = mid; \n      } else {\n        right = mid;\n      }\n    }\n    if (right - left <= 1) {\n      printf(""BUG!1\\n"");\n      return 1;\n    }\n    need = r[i] * (ll) r[i];\n    left = -1;\n    right = dcnt;\n    while (right - left > 1) {\n      int mid = (left + right) / 2;\n      if (alldist[mid] == need) {\n        r[i] = mid;\n\tbreak;\n      } else if (alldist[mid] < need) {\n        left = mid; \n      } else {\n        right = mid;\n      }\n    }\n    if (right - left <= 1) {\n      printf(""BUG!2\\n"");\n      return 1;\n    }\n  }\n\n  vector<int> allpow(2 * n);\n  for (int i = 0; i < n; ++i) {\n    allpow[2 * i] = p[i];\n    allpow[2 * i + 1] = m[i];\n  }\n  sort(allpow.begin(), allpow.end());\n  int pcnt = 0;\n  for (int i = 0; i < allpow.size(); ++i) {\n    if (i == 0 || allpow[i] > allpow[i - 1])\n      allpow[pcnt++] = allpow[i];\n  }\n  for (int i = 0; i < n; ++i) {\n    int left = -1;\n    int right = pcnt;\n    int need = p[i];\n    while (right - left > 1) {\n      int mid = (left + right) / 2;\n      if (allpow[mid] == need) {\n        p[i] = mid;\n\tbreak;\n      } else if (allpow[mid] < need) {\n        left = mid; \n      } else {\n        right = mid;\n      }\n    }\n    if (right - left <= 1) {\n      printf(""BUG!!\\n"");\n      return 1;\n    }\n    need = m[i];\n    left = -1;\n    right = pcnt;\n    while (right - left > 1) {\n      int mid = (left + right) / 2;\n      if (allpow[mid] == need) {\n        m[i] = mid;\n\tbreak;\n      } else if (allpow[mid] < need) {\n        left = mid; \n      } else {\n        right = mid;\n      }\n    }\n    if (right - left <= 1) {\n      printf(""BUG!!\\n"");\n      return 1;\n    }\n  }\n  \n\n  vector<set<pair<int, int> > > fenwick(dcnt);\n  for (int i = 1; i < n; ++i) {\n    int dcoord = dist[i];\n    int pcoord = m[i];\n    while (dcoord < dcnt) {\n      fenwick[dcoord].insert(make_pair(pcoord, i));\n      dcoord |= (dcoord + 1);\n    }\n  }\n  vector<int> queue(n);\n  int qt = 0;\n  int qh = 1;\n  int res = 0;\n  while (qt < qh) {\n    int cur = queue[qt++];\n    int dbound = r[cur];\n    int pbound = p[cur];\n    while (dbound >= 0) {\n      while (!fenwick[dbound].empty() && fenwick[dbound].begin()->first <= pbound) {\n        int kill = fenwick[dbound].begin()->second;\n\tint dcoord = dist[kill];\n\tint pcoord = m[kill];\n\twhile (dcoord < dcnt) {\n\t  fenwick[dcoord].erase(make_pair(pcoord, kill));\n\t  dcoord |= (dcoord + 1);\n\t}\n\tqueue[qh++] = kill;\n\t++res;\n      }\n      dbound = (dbound & (dbound + 1)) - 1;\n    }\n  }\n  printf(""%d\\n"", res);\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2400
Consider an infinite triangle made up of layers Let s number the layers starting from one from the top of the triangle from top to bottom The k th layer of the triangle contains k points numbered from left to right Each point of an infinite triangle is described by a pair of numbers r c 1 le c le r where r is the number of the layer and c is the number of the point in the layer From each point r c there are two edges to the points r 1 c and r 1 c 1 but only one of the edges is activated If r c is even then the edge to the point r 1 c is activated otherwise the edge to the point r 1 c 1 is activated Look at the picture for a better understanding From the point r 1 c 1 it is possible to reach the point r 2 c 2 if there is a path between them only from edges For example in the picture above there is a path from 1 1 to 3 2 but there is no path from 2 1 to 1 1 Initially you are at the point 1 1 For each turn you can Replace activated edge for point r c That is if the edge to the point r 1 c is activated then the edge to the point r 1 c 1 becomes activated otherwise if the edge to the point r 1 c 1 then the edge to the point r 1 c becomes activated This action increases the cost of the path by 1 Move from the current point to another by following the activated edge This action the cost of the path You are given a sequence of n points of an infinite triangle r 1 c 1 r 2 c 2 ldots r n c n Find the minimum cost path from 1 1 passing through all n points in order ,"['#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\npair <int,int> a[200005];\nint main(int argc, char** argv) {\n\tint T;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++) cin >> a[i].first;\n\t\tfor(int i=1;i<=n;i++) cin >> a[i].second;\n\t\tsort(a+1,a+n+1);\n\t\tint ans=0;\n\t\ta[0]={1,1};\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif((a[i+1].second-a[i].second)==(a[i+1].first-a[i].first))\n\t\t\t{\n\t\t\t\tif(a[i].first+a[i].second&1) ans+=0;\n\t\t\t\telse ans+=a[i+1].second-a[i].second;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lst=a[i].first-a[i].second,nxt=a[i+1].first-a[i+1].second;\n\t\t\t\tif(lst%2==0) ++lst;\n\t\t\t\tif(nxt%2==0) ++nxt;\n\t\t\t\tans+=(nxt-lst)/2;\n\t\t\t}\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]",2000
William has array of n numbers a 1 a 2 dots a n He can perform the following sequence of operations Pick any two items from array a i and a j where a i must be a multiple of 2 a i frac a i 2 a j a j cdot 2 Help William find the maximal sum of array elements which he can get by performing the sequence of operations described above ,"[""/**\n *    author:  tourist\n *    created: 28.11.2021 17:34:54       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<long long> a(n);\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      while (a[i] % 2 == 0) {\n        a[i] /= 2;\n        k += 1;\n      }\n    }\n    sort(a.begin(), a.end());\n    for (int i = 0; i < k; i++) {\n      a.back() *= 2;\n    }\n    cout << accumulate(a.begin(), a.end(), 0LL) << '\\n';\n  }\n  return 0;\n}\n""]","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",900
Recently Tema and Vika celebrated Family Day Their friend Arina gave them a carpet which can be represented as an n cdot m table of lowercase Latin letters Vika hasn t seen the gift yet but Tema knows what kind of carpets she likes Vika will like the carpet if she can read her name on She reads column by column from left to right and chooses one or zero letters from current column Formally the girl will like the carpet if it is possible to select four distinct columns in order from left to right such that the first column contains v the second one contains i the third one contains k and the fourth one contains a Help Tema understand in advance whether Vika will like Arina s gift ,"['/*  \n  hmz is cute!\n--------------------------------------------\n  You\'ve got to have faith\n  Don\'t let them cut you down cut you down once more\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define TY int\n#define IL inline\n#define pb push_back\n#define mod (TY)(1e9+7)\n#define MAXN 200005\n#define MAXM 200005\n#define MAXK 27\n#define INF (TY)(1e9)\n#define block 300\n#define For(i,a,b) for(TY i=(a);i<=(b);++i)\n#define FOR(i,a,b) for(TY i=(a);i<(b);++i)\n#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)\n#define ROF(i,a,b) for(TY i=(a);i>(b);--i)\nIL TY qr(){\n\tTY x=0,f=1;char op=getchar();\n\tfor(;op<\'0\'||op>\'9\';op=getchar())if(op==\'-\')f=-1;\n\tfor(;op>=\'0\'&&op<=\'9\';op=getchar())x=x*10+(op^48);\n\treturn x*f;\n}IL bool ischar(char op){\n\tif(op>=\'a\'&&op<=\'z\')return true;\n\tif(op>=\'A\'&&op<=\'Z\')return true;\n\treturn false;\n}IL char getc(){\n\tchar op=getchar();\n\twhile(!ischar(op))op=getchar();\n\treturn op;\n}IL string qs(){\n\tstring op="""";char u=getchar();\n\twhile(!ischar(u))u=getchar();\n\twhile(ischar(u))op+=u,u=getchar();\n\treturn op;\n}IL void qw(TY x){\n\tif(!x){putchar(\'0\');return;}\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)qw(x/10);putchar(x%10+\'0\');\n}IL void qw(TY x,char op){qw(x),putchar(op);}\nIL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}\nIL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}\nIL TY Mod(TY a){return (a>=mod?a-mod:a);}\nIL TY Abs(TY a,TY b){return a>b?a-b:b-a;}\nIL TY Pow(TY a,TY b){\n\tTY ans=1,base=a;\n\twhile(b){\n\t\tif(b&1)ans=ans*base%mod;\n\t\tbase=base*base%mod;b>>=1;\n\t}return ans;\n}TY T,n,m;char mp[21][21],num[]={\'v\',\'i\',\'k\',\'a\'};\nint main(){\n    //freopen("".in"",""r"",stdin);\n    //freopen("".out"",""w"",stdout);\n\n    /* init */\n\tT=qr();while(T--){\n\t\tn=qr();m=qr();\n\t\tTY id=0;\n\t\tFor(i,1,n)For(j,1,m)mp[i][j]=getc();\n\t\tFor(j,1,m){\n\t\t\tbool vis=0;\n\t\t\tFor(i,1,n)vis|=(mp[i][j]==num[id]);\n\t\t\tif(vis)++id;\n\t\t\tif(id==4)break;\n\t\t}ws(id==4?""Yes\\n"":""No\\n"");\n\t}\n    return 0;\n}']","[1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",800
You are given an array a consisting of n integers Each a i is one of the six following numbers 4 8 15 16 23 42 Your task is to remove the minimum number of elements to make this array An array of length k is called if k is divisible by 6 and it is possible to split it into frac k 6 4 8 15 16 23 42 Examples of good arrays 4 8 15 16 23 42 the whole array is a required sequence 4 8 4 15 16 8 23 15 16 42 23 42 the first sequence is formed from first second fourth fifth seventh and tenth elements and the second one is formed from remaining elements Examples of bad arrays 4 8 15 16 42 23 the order of elements should be exactly 4 8 15 16 23 42 4 8 15 16 23 42 4 the length of the array is not divisible by 6 4 8 15 16 23 42 4 8 15 16 23 23 the first sequence can be formed from first six elements but the remaining array cannot form the required sequence ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=500005;\nconst int a[]={0,4,8,15,16,23,42};\nint T,n,b[Maxn],cnt[8]; \nint main()\n{\n\tscanf(""%d"",&n);\n\tcnt[0]=0x3f3f3f3f;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(""%d"",&b[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=6;j++)\n\t\t\tif(b[i]==a[j]&&cnt[j-1])\n\t\t\t\tcnt[j]++,cnt[j-1]--;\n\tprintf(""%d\\n"",n-6*cnt[6]);\n\treturn 0;\n}']","[1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Magnus decided to play a classic chess game Though what he saw in his locker shocked him His favourite chessboard got broken into pieces each of size by is And what s even worse some squares were of wrong color th square of the th row of th piece of the board has color being black and being white Now Magnus wants to change color of some squares in such a way that he recolors minimum number of squares and obtained pieces form a valid chessboard Every square has its color different to each of the neightbouring by side squares in a valid board Its size should be by You are allowed to move pieces but ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nchar in[4][105][105];\nchar cur[205][205];\n\nint u[4];\nint main() {\n\tint N, i, j, k;\n\tscanf(""%d"", &N);\n\tfor (i = 0; i < 4; i++) for (j = 0; j < N; j++) scanf(""%s"", in[i][j]);\n\n\tfor (i = 0; i < 4; i++) u[i] = i;\n\n\tint ans = INF;\n\tdo {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tfor (j = 0; j < N; j++) for (k = 0; k < N; k++) cur[(i / 2)*N + j][(i % 2)*N + k] = in[u[i]][j][k];\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (i = 0; i < 2 * N; i++) {\n\t\t\tfor (j = 0; j < 2 * N; j++) {\n\t\t\t\tchar c = \'0\' + (i + j) % 2;\n\t\t\t\tif (c != cur[i][j]) cnt++;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, cnt);\n\t} while (next_permutation(u, u + 4));\n\treturn !printf(""%d\\n"", ans);\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Leha plays a computer game where is on each level is given a connected graph with vertices and edges Graph can contain multiple edges but can not contain self loops Each vertex has an integer which can be equal to or To pass the level he needs to find a good subset of edges of the graph or say that it doesn t exist Subset is called good if by by leaving only edges from this subset in the original graph we obtain the following for every vertex i 1 or it s degree modulo 2 is equal to Leha wants to pass the game as soon as possible and ask you to help him In case of multiple correct answers print any of them ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nstruct UnionFind {\n\tvector<int> data;\n\tvoid init(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n};\n\nvector<int> t_parent;\nvector<int> t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile (!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor (int j = (int)g[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = g[i][j];\n\t\t\tif (t_parent[c] == -1 && c != root) {\n\t\t\t\tt_parent[c] = i;\n\t\t\t\tstk.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n; int m;\n\twhile (~scanf(""%d%d"", &n, &m)) {\n\t\tvector<int> d(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(""%d"", &d[i]);\n\t\tvector<pair<int, int> > edges(m);\n\t\tmap<pii, int> eindex;\n\t\tfor (int i = 0; i < m; ++ i) {\n\t\t\tint u; int v;\n\t\t\tscanf(""%d%d"", &u, &v), -- u, -- v;\n\t\t\tedges[i] = { u,v };\n\t\t\teindex[minmax(u, v)] = i;\n\t\t}\n\t\tint arb = -1;\n\t\tvector<int> odd;\n\t\trep(i, n) {\n\t\t\tif (d[i] == -1 && arb == -1)\n\t\t\t\tarb = i;\n\t\t\tif (d[i] == 1)\n\t\t\t\todd.push_back(i);\n\t\t}\n\t\tif (odd.size() % 2 != 0) {\n\t\t\tif (arb == -1) {\n\t\t\t\tputs(""-1"");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[arb] = 1;\n\t\t\todd.push_back(arb);\n\t\t}\n\t\tvector<vi> g(n);\n\t\tUnionFind uf; uf.init(n);\n\t\tfor (auto e : edges) if (uf.unionSet(e.first, e.second)) {\n\t\t\tg[e.first].push_back(e.second);\n\t\t\tg[e.second].push_back(e.first);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tvector<int> add(n);\n\t\trep(k, odd.size() / 2) {\n\t\t\tint a = odd[k * 2], b = odd[k * 2 + 1];\n\t\t\tadd[a] ^= 1;\n\t\t\tadd[b] ^= 1;\n\t\t}\n\t\tvector<int> sum(add.begin(), add.end());\n\t\tfor (int ix = (int)t_ord.size() - 1; ix > 0; -- ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tsum[p] ^= sum[i];\n\t\t}\n\t\tvi ans;\n\t\treu(i, 1, n) if (sum[i] % 2 != 0) {\n\t\t\tans.push_back(eindex[minmax(t_parent[i], i)]);\n\t\t}\n\t\tprintf(""%d\\n"", (int)ans.size());\n\t\tfor (int i = 0; i < (int)ans.size(); ++ i) {\n\t\t\tif (i != 0) putchar(\' \');\n\t\t\tprintf(""%d"", ans[i] + 1);\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2100
Automatic Bakery of Cyberland ABC recently bought an rectangle table To serve the diners ABC placed seats around the table The size of each seat is equal to a unit square so there are seats in total ABC placed conveyor belts on each unit square on the table There are three types of conveyor belts and A belt can bring things upwards can bring leftwards and can bring rightwards Let s number the rows with to from top to bottom the columns with to from left to right We consider the seats above and below the top of the table are rows and respectively Also we define seats to the left of the table and to the right of the table to be column and Due to the conveyor belts direction restriction there are currently no way for a diner sitting in the row to be served Given the initial table there will be events in order There are two types of events A means a piece of bread will appear at row and column we will denote such position as The bread will follow the conveyor belt until arriving at a seat of a diner It is possible that the bread gets stuck in an infinite loop Your task is to simulate the process and output the final position of the bread or determine that there will be an infinite loop C means that the type of the conveyor belt at is changed to Queries are performed separately meaning that even if the bread got stuck in an infinite loop it won t affect further queries ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n\nconst int maxn=200000+5;\n\nint n,m,q;\nchar a[maxn][10];\nint tree[1<<20][10];\nint b[maxn][10];\n\nvoid solveb(int p)\n{\n\tfor (int i=0;i<m;i++) b[p][i]=-1;\n\tfor (int i=0;i<m && a[p][i]==\'<\';i++) b[p][i]=1;\n\tfor (int i=m-1;i>=0 && a[p][i]==\'>\';i--) b[p][i]=2;\n}\nvoid combine(int p)\n{\n\tfor (int i=0;i<m;i++) tree[p][i]=(tree[p*2+2][i]<0)?-1:tree[p*2+1][tree[p*2+2][i]];\n}\nvoid bruteforce(int p,int s)\n{\n\tfor (int i=0;i<m;i++) tree[p][i]=-1;\n\tfor (int i=0;i<m;i++) if (a[s][i]==\'^\') tree[p][i]=i;\n\tfor (int i=0;i+1<m;i++) if (tree[p][i]>=0 && a[s][i+1]==\'<\') tree[p][i+1]=tree[p][i];\n\tfor (int i=m-1;i>0;i--) if (tree[p][i]>=0 && a[s][i-1]==\'>\') tree[p][i-1]=tree[p][i];\n}\nvoid init(int p,int s,int t)\n{\n\tif (s==t)\n\t{\n\t\tbruteforce(p,s);\n\t\treturn;\n\t}\n\tint m=(s+t)/2;\n\tinit(p*2+1,s,m);\n\tinit(p*2+2,m+1,t);\n\tcombine(p);\n}\nvoid update(int p,int s,int t,int key)\n{\n\tif (s==t)\n\t{\n\t\tbruteforce(p,s);\n\t\treturn;\n\t}\n\tint m=(s+t)/2;\n\tif (key<=m)\n\t\tupdate(p*2+1,s,m,key);\n\telse\n\t\tupdate(p*2+2,m+1,t,key);\n\tcombine(p);\t\n}\n\nvoid solve(int p,int s,int t,int &x,int &y)\n{\n\tif (x==t && tree[p][y]>=0)\n\t{\n\t\tx=s-1;\n\t\ty=tree[p][y];\n\t\treturn;\n\t}\n\tif (s==t) return;\n\tint m=(s+t)/2;\n\tif (x>m) solve(p*2+2,m+1,t,x,y);\n\tif (x<=m) solve(p*2+1,s,m,x,y);\n}\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""input.txt"",""r"",stdin);\n#endif\n\tscanf(""%d%d%d"",&n,&m,&q);\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tchar s[32];\n\t\tscanf(""%s"",s);\n\t\tfor (int j=0;j<m;j++) a[i][j]=s[j];\n\t}\n\tinit(0,0,n-1);\n\tfor (int i=0;i<n;i++) solveb(i);\n\tfor (;q>0;q--)\n\t{\n\t\tchar s[32];\n\t\tscanf(""%s"",s);\n\t\tif (s[0]==\'A\')\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(""%d%d"",&x,&y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tsolve(0,0,n-1,x,y);\n\t\t\tif (x>=0)\n\t\t\t\tif (b[x][y]>0)\n\t\t\t\t\ty=((b[x][y]==1)?0:m+1),x++;\n\t\t\t\telse\n\t\t\t\t\tx=y=-1;\n\t\t\telse\n\t\t\t\tx++,y++;\n\t\t\tprintf(""%d %d\\n"",x,y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x,y;\n\t\t\tchar d[32];\n\t\t\tscanf(""%d%d%s"",&x,&y,d);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\ta[x][y]=d[0];\n\t\t\tsolveb(x);\n\t\t\tupdate(0,0,n-1,x);\n\t\t}\n\t}\n\treturn 0;\n}\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
The Road Accident band is planning an unprecedented tour around Treeland The RA fans are looking forward to the event and making bets on how many concerts their favorite group will have Treeland consists of cities some pairs of cities are connected by bidirectional roads Overall the country has roads We know that it is possible to get to any city from any other one The cities are numbered by integers from 1 to For every city we know its value the number of people in it We know that the band will travel along some path having concerts in cities along the path The band s path will not pass one city twice each time they move to the city that hasn t been previously visited Thus the musicians will travel along some path without visiting any city twice and in some not necessarily all cities along the way they will have concerts The band plans to gather all the big stadiums and concert halls during the tour so every time they will perform in a city which population is than the population of the previously visited city In other words the sequence of population in the cities where the concerts will be held is In a recent interview with the leader of the road accident band promised to the fans that the band will in the largest possible number of cities Thus the band will travel along some chain of cities of Treeland and have concerts in some of these cities so that the population number will increase and the number of concerts will be the largest possible The fans of Treeland are frantically trying to figure out how many concerts the group will have in Treeland Looks like they can t manage without some help from a real programmer Help the fans find the sought number of concerts ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct node{\n     node *next;\n     int where;\n} *first[10001], a[100001];\n\nint ans, l, v[10001], dist[10001], n, c[10001], f[10001], len;\nbool b[6001];\n\ninline void makelist(int x, int y){\n     a[++l].where = y;\n     a[l].next = first[x];\n     first[x] = &a[l];\n}\n\ninline void soso(int now){\n     b[now] = true;\n     if (!len || v[now] > f[len]) \n     {\n          f[++len] = v[now];\n          ans = max(ans, len); \n          for (node *x = first[now]; x; x = x->next) \n               if (!b[x->where]) soso(x->where);\n          --len;\n     }\n     else\n     {\n          int Left = 0, Right = len, Mid = (Left + Right) >> 1;\n          for (; Left + 1 < Right; Mid = (Left + Right) >> 1)\n               if (v[now] > f[Mid]) Left = Mid;\n               else Right = Mid;\n          if (v[now] < f[Right]) \n          {\n               int dhh = f[Right];\n               f[Right] = v[now];\n               for (node *x = first[now]; x; x = x->next) \n                    if (!b[x->where]) soso(x->where);\n               f[Right] = dhh;\n          }\n          else\n               for (node *x = first[now]; x; x = x->next) \n                    if (!b[x->where]) soso(x->where);\n     }\n}         \n          \nint main(){\n    // freopen(""f.in"", ""r"", stdin);\n    // freopen(""f.out"", ""w"", stdout);\n     scanf(""%d"", &n);\n     for (int i = 1; i <= n; i++) scanf(""%d"", &v[i]);\n     memset(first, 0, sizeof(first)); l = 0;\n     for (int i = 1; i < n; i++)\n     {\n          int x, y;\n          scanf(""%d%d"", &x, &y);\n          makelist(x, y); makelist(y, x);\n     }\n     ans = 0;\n     for (int i = 1; i <= n; i++)\n     {\n          memset(b, false, sizeof(b));\n          len = 0; \n          soso(i);\n     }\n     printf(""%d\\n"", ans);\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]",2200
After years of hard work scientists invented an absolutely new e reader display The new display has a larger resolution consumes less energy and its production is cheaper And besides one can bend it The only inconvenience is highly unusual management For that very reason the developers decided to leave the e readers software to programmers The display is represented by square of pixels each of which can be either black or white The display rows are numbered with integers from to upside down the columns are numbered with integers from to from the left to the right The display can perform commands like When a traditional display fulfills such command it simply inverts a color of where is the row number and is the column number But in our new display every pixel that belongs to at least one of the segments and both ends of both segments are included inverts a color For example if initially a display in size is absolutely white then the sequence of commands leads to the following changes You are an e reader software programmer and you should calculate minimal number of commands needed to display the picture You can regard all display pixels as initially white ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 2010\nchar s[N][N];int n,S=0;bool v1[N],v2[N],w1[N],w2[N];\nint main()\n{\n\tscanf(""%d"",&n);\n\tfor(int i=0;i<n;i++)scanf(""%s"",s[i]);\n\tfor(int i=n-1;i>0;i--)\n\t\tfor(int j=i;j<n;j++)\n\t\t\tif((s[j][j-i]-\'0\')^v1[j]^v2[j-i])S++,v1[j]^=1,v2[j-i]^=1;\n\tfor(int i=n-1;i>0;i--)\n\t\tfor(int j=i;j<n;j++)\n\t\t\tif((s[j-i][j]-\'0\')^w1[j-i]^w2[j])S++,w1[j-i]^=1,w2[j]^=1;\n\tfor(int i=0;i<n;i++)\n\t\tif((s[i][i]-\'0\')^v1[i]^v2[i]^w1[i]^w2[i])S++;\n\tprintf(""%d\\n"",S);\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Eleven wants to choose a new name for herself As a bunch of geeks her friends suggested an algorithm to choose a name for her Eleven wants her name to have exactly characters Her friend suggested that her name should only consist of uppercase and lowercase letters More precisely they suggested that the th letter of her name should be uppercase if is a member of Fibonacci sequence and lowercase otherwise The letters in the name are numbered from to Fibonacci sequence is the sequence where As her friends are too young to know what Fibonacci sequence is they asked you to help Eleven determine her new name ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nint f[200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n;\tcin >> n;\n\tf[1] = f[2] = 1;\n\tfor (int i = 3; i < 20; i++)\n\t\tf[i] = f[i-1] + f[i-2];\n\tfor (int i = 1; i <= n; i++){\n\t\tbool fl = 0;\n\t\tfor (int j = 1; j < 20; j++)\n\t\t\tif (i == f[j])\n\t\t\t\tfl = 1;\n\t\tif (fl)\n\t\t\tcout << ""O"";\n\t\telse\n\t\t\tcout << ""o"";\n\t}\n\tcout << ""\\n"";\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given two integers n and k An array a 1 a 2 ldots a n of length n consisting of zeroes and ones is if for integers i from 1 to n of the following conditions are satisfied at least lceil frac i k rceil of the first i elements of a are equal to 1 at least lceil frac i k rceil of the last i elements of a are equal to 1 Here lceil frac i k rceil denotes the result of division of i by k rounded up For example lceil frac 6 3 rceil 2 lceil frac 11 5 rceil lceil 2 2 rceil 3 and lceil frac 7 4 rceil lceil 1 75 rceil 2 Find the minimum possible number of ones in a good array ,"['#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define ff first\n#define ss second\n#define pb push_back\nusing namespace std;\nvoid init() {\n\t\n}\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\tint a[n + 1];\n\tfor (int i = 1; i <= n; i++) a[i] = 0;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\ta[i] = a[(n + 1) - i] = (i % k == 1);\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcnt += a[i];\n\t\tif (cnt < i / k + bool(i % k)) {\n\t\t\tif (!a[i]) {\n\t\t\t\ta[i] = 1;\n\t\t\t\tcnt++;\n\t\t\t} else throw runtime_error("""");\n\t\t}\n\t}\n\tcout << cnt << endl;\n}\nint32_t main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tinit();\n\tint t = 1;\n\tcin >> t;\n\twhile (t--) solve();\n}']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given an array a of n integers You need to find the maximum value of a i a j a k over all triplets i j k such that i j k Here denotes the bitwise AND operation and denotes the bitwise OR operation ,"[""/**\n *    author:  tourist\n *    created: 25.08.2019 18:01:53       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int BITS = 21;\nconst int MAX = (1 << BITS);\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<pair<int, int>> bests(MAX, make_pair(-1, -1));\n  auto Update = [&](pair<int, int>& p, int v) {\n    if (v > p.first) {\n      p.second = p.first;\n      p.first = v;\n    } else {\n      p.second = max(p.second, v);\n    }\n  };\n  for (int i = 0; i < n; i++) {\n    Update(bests[a[i]], i);\n  }\n  for (int j = 0; j < BITS; j++) {\n    for (int i = 0; i < MAX; i++) {\n      if (i & (1 << j)) {\n        Update(bests[i ^ (1 << j)], bests[i].first);\n        Update(bests[i ^ (1 << j)], bests[i].second);\n      }\n    }\n  }\n  auto Can = [&](int num, int high) {\n    for (int i = 0; i < n; i++) {\n      int x = (a[i] ^ num) & high;\n      if (bests[x].second > i) {\n        return true;\n      }\n    }\n    return false;\n  };\n  int ans = 0;\n  int high = 0;\n  for (int j = BITS - 1; j >= 0; j--) {\n    high += (1 << j);\n    if (Can(ans + (1 << j), high)) {\n      ans += (1 << j);\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2600
In the lattice points of the coordinate line there are radio stations the th of which is described by three integers the coordinate of the th station on the line the broadcasting range of the th station the broadcasting frequency of the th station We will say that two radio stations with numbers and reach each other if the broadcasting range of each of them is more or equal to the distance between them In other words Let s call a pair of radio stations bad if stations and reach each other and they are close in frequency that is Find the number of bad pairs of radio stations ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 101010\nstruct Nd{\n  int sum , tl , tr;\n  Nd(){\n    sum = tl = tr = 0;\n  }\n} nd[ N * 30 * 4 ];\nint nid;\nint new_node(){ return ++ nid; }\ninline int Sum( int x ){\n  return x ? nd[ x ].sum : 0;\n}\n#define mid ((l+r)>>1)\nvoid modify( int now , int l , int r , int p ){\n  if( l == r ){\n    nd[ now ].sum ++;\n    return;\n  }\n  if( p <= mid ){\n    if( !nd[ now ].tl )\n      nd[ now ].tl = new_node();\n    modify( nd[ now ].tl , l , mid , p );\n  }else{\n    if( !nd[ now ].tr )\n      nd[ now ].tr = new_node();\n    modify( nd[ now ].tr , mid + 1 , r , p );\n  }\n  nd[ now ].sum = Sum( nd[ now ].tl ) + Sum( nd[ now ].tr );\n}\nint query( int now , int l , int r , int ql , int qr ){\n  if( !now || r < ql || l > qr ) return 0;\n  if( ql <= l && r <= qr ) return nd[ now ].sum;\n  return query( nd[ now ].tl , l , mid , ql , qr ) +\n         query( nd[ now ].tr , mid + 1 , r , ql , qr );\n}\nint rt[ 10101 ];\nvoid build(){\n\n}\nint n , k , maxx , maxf;\nvector< pair<int,pair<int,int> > > v;\nvoid init(){\n  n = getint();\n  k = getint();\n  for( int i = 0 ; i < n ; i ++ ){\n    int xi = getint();\n    int ri = getint();\n    int fi = getint();\n    maxx = max( maxx , xi );\n    maxf = max( maxf , fi );\n    v.push_back( { ri , { xi , fi } } );\n  }\n}\nvoid solve(){\n  sort( v.begin() , v.end() );\n  reverse( v.begin() , v.end() );\n  LL ans = 0;\n  for( auto i : v ){\n    int nr = i.first;\n    int nx = i.second.first;\n    int nf = i.second.second;\n    int lx = max( 1 , nx - nr ) , rx = min( maxx , nx + nr );\n    int lf = max( 1 , nf - k ) , rf = min( maxf , nf + k );\n    for( int j = lf ; j <= rf ; j ++ )\n      ans += query( rt[ j ] , 1 , maxx , lx , rx );\n    if( !rt[ nf ] ) rt[ nf ] = new_node();\n    modify( rt[ nf ] , 1 , maxx , nx );\n    //printf( ""r=%d x=%d f=%d : ans=%lld\\n"" , nr , nx , nf , ans );\n  }\n  printf( ""%lld\\n"" , ans );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2200
Mark loves to move fast So he made a spaceship that works in 4 dimensional space He wants to use the spaceship to complete missions as fast as possible In each mission the spaceship starts at 0 0 0 0 and needs to end up at a b c d To do this he instructs the spaceship s computer to execute a series of moves where each move is a unit step in one of the eight cardinal directions pm 1 0 0 0 0 pm 1 0 0 0 0 pm 1 0 0 0 0 pm 1 Unfortunately he also moved fast when building the spaceship so there is a bug in the spaceship s code The first move will be executed once the second move will be executed twice the third move will be executed thrice and so on In general the i th move will be executed i times For any four integers a b c d let f a b c d be the minimum number of moves of a mission that ends up at a b c d Compute the sum of f a b c d over all points with integer coordinates such that A le a le A B le b le B C le c le C D le d le D ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=4007;\n\nint tab[10];\n\nll dp[5][4][4][nax];\n\nll wyn;\n\nvi normalize(vi wek)\n{\n\tfor (int &i : wek)\n\t\ti=abs(i);\n\tsort(wek.begin(), wek.end());\n\treturn wek;\n}\n\nvoid normalizuj(vi &wek)\n{\n\tfor (int &i : wek)\n\t\ti=abs(i);\n\tsort(wek.begin(), wek.end());\n}\n\nset<int> sumki;\n\nconst int k1=15;\nconst int k2=100;\n\nconst int dd=50;\nbitset<1217> moge[dd+1][k1][k1][k1];\n\nint spam[k1][k1][k1][1117];\n\nvoid brutuj()\n{\n\tfor (int i=0; i<=100; i++)\n\t\tsumki.insert(i*(i+1)/2);\n\t\n\tmoge[0][0][0][0][k2]=1;\n\tfor (int i=1; i<=dd; i++)\n\t{\n\t\tfor (int a=0; a<k1; a++)\n\t\t{\n\t\t\tfor (int b=0; b<k1; b++)\n\t\t\t{\n\t\t\t\tfor (int c=0; c<k1; c++)\n\t\t\t\t{\n\t\t\t\t\tfor (int p=0; p<3; p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int w=-1; w<=1; w+=2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint na=a;\n\t\t\t\t\t\t\tint nb=b;\n\t\t\t\t\t\t\tint nc=c;\n\t\t\t\t\t\t\tif (p==0)\n\t\t\t\t\t\t\t\tna+=i*w;\n\t\t\t\t\t\t\tif (p==1)\n\t\t\t\t\t\t\t\tnb+=i*w;\n\t\t\t\t\t\t\tif (p==2)\n\t\t\t\t\t\t\t\tnc+=i*w;\n\t\t\t\t\t\t\tna=abs(na);\n\t\t\t\t\t\t\tnb=abs(nb);\n\t\t\t\t\t\t\tnc=abs(nc);\n\t\t\t\t\t\t\tif (na>=k1 || nb>=k1 || nc>=k1)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tmoge[i][na][nb][nc]|=moge[i-1][a][b][c];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmoge[i][a][b][c]|=(moge[i-1][a][b][c]<<i);\n\t\t\t\t\tmoge[i][a][b][c]|=(moge[i-1][a][b][c]>>i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint glupiefast[nax][4][4];\n\nint glupie(int chce, int a, int b)\n{\n\tint ochce=chce;\n\tif (glupiefast[ochce][a][b])\n\t\treturn glupiefast[ochce][a][b]-1;\n\tif (a==1 && b==1)\n\t{\n\t\tchce+=4;\n\t}\n\tif (a==1 && b==2)\n\t{\n\t\tif (!sumki.count(chce))\n\t\t\tchce+=4;\n\t}\n\tif (a==2 && b==2)\n\t{\n\t\tchce+=2;\n\t\tif (!sumki.count(chce))\n\t\t\tchce+=4;\n\t}\n\tint ret=0;\n\tint sum=0;\n\twhile(sum<chce || (sum&1)!=(chce&1))\n\t{\n\t\tret++;\n\t\tsum+=ret;\n\t}\n\tglupiefast[ochce][a][b]=ret+1;\n\treturn ret;\n}\n\nint pyt(int a, int b, int c, int d)\n{\n\tif (spam[a][b][c][d])\n\t\treturn spam[a][b][c][d]-1;\n\tfor (int i=0; i<=dd; i++)\n\t{\n\t\tif (moge[i][a][b][c][d+k2])\n\t\t{\n\t\t\tspam[a][b][c][d]=i+1;\n\t\t\treturn i;\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main()\n{\n\tbrutuj();\n\tfor (int i=0; i<4; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tdp[0][3][3][0]=1;\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tfor (int j=0; j<nax; j++)\n\t\t{\n\t\t\tfor (int a=0; a<4; a++)\n\t\t\t{\n\t\t\t\tfor (int b=a; b<4; b++)\n\t\t\t\t{\n\t\t\t\t\tif (!dp[i][a][b][j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int l=-tab[i]; l<=tab[i]; l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint na=a;\n\t\t\t\t\t\tint nb=b;\n\t\t\t\t\t\tint nc=min(abs(l), 3);\n\t\t\t\t\t\tif (nc<nb)\n\t\t\t\t\t\t\tswap(nc, nb);\n\t\t\t\t\t\tif (nb<na)\n\t\t\t\t\t\t\tswap(nb, na);\n\t\t\t\t\t\tdp[i+1][na][nb][j+abs(l)]+=dp[i][a][b][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i=0; i<nax; i++)\n\t\tfor (int a=0; a<4; a++)\n\t\t\tfor (int b=a; b<4; b++)\n\t\t\t\tif (dp[4][a][b][i])\n\t\t\t\t\twyn+=dp[4][a][b][i]*glupie(i, a, b);\n\t\n\tint ii=tab[0];\n\tfor (int i=0; i<=ii; i++)\n\t{\n\t\tint jj=tab[1];\n\t\tif (abs(i)>=k1)\n\t\t\tjj=min(jj, k1-1);\n\t\tfor (int j=0; j<=jj; j++)\n\t\t{\n\t\t\tint lll=tab[2];\n\t\t\tif (abs(i)>=k1 || abs(j)>=k1)\n\t\t\t\tlll=min(lll, k1-1);\n\t\t\tfor (int l=0; l<=lll; l++)\n\t\t\t{\n\t\t\t\tint kk=tab[3];\n\t\t\t\tif (abs(i)>=k1 || abs(j)>=k1 || abs(l)>=k1)\n\t\t\t\t\tkk=min(kk, k1-1);\n\t\t\t\tfor (int k=0; k<=kk; k++)\n\t\t\t\t{\n\t\t\t\t\tint mno=(1+(i>0))*(1+(j>0))*(1+(l>0))*(1+(k>0));\n\t\t\t\t\tvi wek={i, j, l, k};\n\t\t\t\t\tnormalizuj(wek);\n\t\t\t\t\tint s=0;\n\t\t\t\t\tfor (int p : wek)\n\t\t\t\t\t\ts+=p;\n\t\t\t\t\twyn-=mno*glupie(s, min(wek[0], 3), min(wek[1], 3));\n\t\t\t\t\twyn+=mno*pyt(wek[0], wek[1], wek[2], wek[3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3500
Tom is waiting for his results of Zhongkao examination To ease the tense atmosphere his friend Daniel decided to play a game with him This game is called The game is about the array a consisting of n integers Denote l r as the subsegment consisting of integers a l a l 1 ldots a r Tom will divide the array into contiguous subsegments l 1 r 1 l 2 r 2 ldots l m r m such that each integer is in exactly one subsegment More formally For all 1 le i le m 1 le l i le r i le n l 1 1 r m n For all 1 i le m l i r i 1 1 Denote s i sum k l i r i a k that is s i is the sum of integers in the i th subsegment For all 1 le i le j le m the following condition must hold min i le k le j s k le sum k i j s k le max i le k le j s k Tom believes that the more subsegments the array a is divided into the better results he will get So he asks Daniel to find the number of subsegments among all possible ways to divide the array a You have to help him find it ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT ã\x81§æ\x95°å\x88\x97ã\x82\x92ç®¡ç\x90\x86ã\x81\x99ã\x82\x8bã\x81¨ã\x81\x8dã\x81«ä½¿ã\x81\x86 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify ã\x81\x97ã\x81¦ã\x81ªã\x81\x84ã\x82\x84\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ã\x82½ã\x83¼ã\x83\x88ã\x81\x97ã\x81¦ i ç\x95ªç\x9b®ã\x81\x8c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//ä¾\x8bã\x81\x88ã\x81° sortidx ã\x81§å¾\x97ã\x81\x9f idx ã\x82\x92ä½¿ã\x81\x88ã\x81°å\x8d\x98ã\x81«ã\x82½ã\x83¼ã\x83\x88å\x88\x97ã\x81«ã\x81ªã\x81£ã\x81¦è¿\x94ã\x81£ã\x81¦ã\x81\x8fã\x82\x8b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS revv(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t>\nvoid pb(vc<t>&a,const vc<t>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t>\nvc<t> cat(vc<t> a,const vc<t>&b){\n\tpb(a,b);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tvc<ll> s=presum(a);\n\tint m;\n\t{\n\t\tvc<ll> vs=s;mkuni(vs);\n\t\trep(i,n+1)s[i]=lwb(vs,s[i]);\n\t\tm=si(vs);\n\t}\n\tvvc<int> dp[2];\n\trep(k,2){\n\t\tdp[k].resize(n+1,vi(n+1,-inf));\n\t\trep(i,n+1)dp[k][i][i]=0;\n\t}\n\tvi left[2],right[2];\n\trep(k,2){\n\t\tleft[k].resize(n+1,-inf);\n\t\tleft[k][0]=0;\n\t}\n\trep(k,2){\n\t\tright[k].resize(n+1,-inf);\n\t\tright[k][n]=0;\n\t}\n\tvvc<int> pos(m);\n\tvi look(n+1,-1);\n\trep(v,m)rep(i,n+1)if(s[i]==v){\n\t\tlook[i]=si(pos[v]);\n\t\tpos[v].pb(i);\n\t}\n\tfor(auto idx:pos){\n\t\trep(i,si(idx))rng(j,i+1,si(idx))rep(k,2)chmax(dp[k][idx[i]][idx[j]],j-i);\n\t}\n\tvc<pi> ls[2];\n\tvc<tuple<int,int,int>> buf;\n\tint ans=dp[0][0][n];\n\tper(vlw,m)rng(vup,vlw+1,m){\n\t\trep(k,2)ls[k].clear();\n\t\tbuf.clear();\n\t\t{\n\t\t\tint pre=-1;\n\t\t\trep(i,n+1){\n\t\t\t\tif(s[i]==vlw){\n\t\t\t\t\tif(pre!=-1&&s[pre]==vup){\n\t\t\t\t\t\tbuf.eb(1,pre,i);\n\t\t\t\t\t}\n\t\t\t\t\tpre=i;\n\t\t\t\t}else if(s[i]==vup){\n\t\t\t\t\tif(pre!=-1&&s[pre]==vlw){\n\t\t\t\t\t\tbuf.eb(0,pre,i);\n\t\t\t\t\t}\n\t\t\t\t\tpre=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(auto [k,l,r]:buf){\n\t\t\tfor(auto [x,y]:ls[k^1]){\n\t\t\t\tint v=s[x];\n\t\t\t\tassert(v==s[r]);\n\t\t\t\tif(chmax(dp[k^1][x][r],dp[k][y][l]+2)){\n\t\t\t\t\t//dmp2(x,y,l,r,dp[k^1][x][r]);\n\t\t\t\t\trep(i,look[x]+1)rng(j,look[r],si(pos[v])){\n\t\t\t\t\t\tint p=pos[v][i],q=pos[v][j];\n\t\t\t\t\t\tassert(s[p]==v&&s[q]==v);\n\t\t\t\t\t\tchmax(dp[k^1][p][q],dp[k^1][p][x]+dp[k^1][x][r]+dp[k^1][r][q]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tls[k].eb(l,r);\n\t\t}\n\t\tfor(auto [k,l,r]:buf){\n\t\t\trep(i,l+1)chmax(left[k^1][r],left[k][i]+dp[k][i][l]+1);\n\t\t}\n\t\tfor(auto [k,l,r]:revv(buf)){\n\t\t\trng(i,r,n+1)chmax(right[k][l],dp[k^1][r][i]+right[k^1][i]+1);\n\t\t}\n\t\tfor(auto [k,l,r]:buf){\n\t\t\tint L=-inf,R=-inf;\n\t\t\trep(i,l+1)chmax(L,left[k][i]+dp[k][i][l]);\n\t\t\trng(i,r,n+1)chmax(R,dp[k^1][r][i]+right[k^1][i]);\n\t\t\tchmax(ans,L+R+1);\n\t\t}\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","[1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3500
You are the head of a large enterprise n people work at you and n is odd i e n is not divisible by 2 You have to distribute salaries to your employees Initially you have s dollars for it and the i th employee should get a salary from l i to r i dollars You have to distribute salaries in such a way that the median salary is To find the median of a sequence of odd length you have to sort it and take the element in the middle position after sorting For example the median of the sequence 5 1 10 17 6 is 6 the median of the sequence 1 2 1 is 1 It is guaranteed that you have enough money to pay the minimum salary i e l 1 l 2 dots l n le s You have to answer t test cases ,"[""// https://probablydance.com/2016/12/27/i-wrote-a-faster-sorting-algorithm/\n\n//          Copyright Malte Skarupke 2016.\n// Distributed under the Boost Software License, Version 1.0.\n//    (See http://www.boost.org/LICENSE_1_0.txt)\n\n#include <cstdint>\n#include <algorithm>\n\nnamespace detail\n{\ninline unsigned int to_unsigned_or_bool(int i)\n{\n    return static_cast<unsigned int>(i) + static_cast<unsigned int>(1 << (sizeof(int) * 8 - 1));\n}\ninline unsigned int to_unsigned_or_bool(unsigned int i)\n{\n    return i;\n}\ninline unsigned long to_unsigned_or_bool(long l)\n{\n    return static_cast<unsigned long>(l) + static_cast<unsigned long>(1l << (sizeof(long) * 8 - 1));\n}\ninline unsigned long to_unsigned_or_bool(unsigned long l)\n{\n    return l;\n}\ninline unsigned long long to_unsigned_or_bool(long long l)\n{\n    return static_cast<unsigned long long>(l) + static_cast<unsigned long long>(1ll << (sizeof(long long) * 8 - 1));\n}\ninline unsigned long long to_unsigned_or_bool(unsigned long long l)\n{\n    return l;\n}\ninline std::uint32_t to_unsigned_or_bool(float f)\n{\n    union\n    {\n        float f;\n        std::uint32_t u;\n    } as_union = { f };\n    std::uint32_t sign_bit = -std::int32_t(as_union.u >> 31);\n    return as_union.u ^ (sign_bit | 0x80000000);\n}\ninline std::uint64_t to_unsigned_or_bool(double f)\n{\n    union\n    {\n        double d;\n        std::uint64_t u;\n    } as_union = { f };\n    std::uint64_t sign_bit = -std::int64_t(as_union.u >> 63);\n    return as_union.u ^ (sign_bit | 0x8000000000000000);\n}\n\ntemplate<typename...>\nstruct nested_void\n{\n    using type = void;\n};\n\ntemplate<typename... Args>\nusing void_t = typename nested_void<Args...>::type;\n\n\ntemplate<typename It, typename Func>\ninline void unroll_loop_four_times(It begin, size_t iteration_count, Func && to_call)\n{\n    size_t loop_count = iteration_count / 4;\n    size_t remainder_count = iteration_count - loop_count * 4;\n    for (; loop_count > 0; --loop_count)\n    {\n        to_call(begin);\n        ++begin;\n        to_call(begin);\n        ++begin;\n        to_call(begin);\n        ++begin;\n        to_call(begin);\n        ++begin;\n    }\n    switch(remainder_count)\n    {\n    case 3:\n        to_call(begin);\n        ++begin;\n        [[fallthrough]];\n    case 2:\n        to_call(begin);\n        ++begin;\n        [[fallthrough]];\n    case 1:\n        to_call(begin);\n    }\n}\n\ntemplate<typename It, typename F>\ninline It custom_std_partition(It begin, It end, F && func)\n{\n    for (;; ++begin)\n    {\n        if (begin == end)\n            return end;\n        if (!func(*begin))\n            break;\n    }\n    It it = begin;\n    for(++it; it != end; ++it)\n    {\n        if (!func(*it))\n            continue;\n\n        std::iter_swap(begin, it);\n        ++begin;\n    }\n    return begin;\n}\n\nstruct PartitionInfo\n{\n    PartitionInfo()\n        : count(0)\n    {\n    }\n\n    union\n    {\n        size_t count;\n        size_t offset;\n    };\n    size_t next_offset;\n};\n\ntemplate<size_t>\nstruct UnsignedForSize;\ntemplate<>\nstruct UnsignedForSize<4>\n{\n    typedef uint32_t type;\n};\ntemplate<>\nstruct UnsignedForSize<8>\n{\n    typedef uint64_t type;\n};\ntemplate<typename T>\nstruct SubKey;\ntemplate<size_t Size>\nstruct SizedSubKey\n{\n    using sub_key_type = typename UnsignedForSize<Size>::type;\n\n    template<typename T>\n    static sub_key_type sub_key(T && value, void *)\n    {\n        return to_unsigned_or_bool(value);\n    }\n\n    typedef SubKey<void> next;\n};\ntemplate<typename T, typename Enable = void>\nstruct FallbackSubKey\n    : SubKey<decltype(to_radix_sort_key(std::declval<T>()))>\n{\n    using base = SubKey<decltype(to_radix_sort_key(std::declval<T>()))>;\n\n    template<typename U>\n    static base sub_key(U && value, void * data)\n    {\n        return base::sub_key(to_radix_sort_key(value), data);\n    }\n};\ntemplate<typename T>\nstruct FallbackSubKey<T, void_t<decltype(to_unsigned_or_bool(std::declval<T>()))>>\n    : SubKey<decltype(to_unsigned_or_bool(std::declval<T>()))>\n{\n};\ntemplate<typename T>\nstruct SubKey : FallbackSubKey<T>\n{\n};\ntemplate<>\nstruct SubKey<unsigned int> : SizedSubKey<sizeof(unsigned int)>\n{\n};\ntemplate<>\nstruct SubKey<unsigned long> : SizedSubKey<sizeof(unsigned long)>\n{\n};\ntemplate<>\nstruct SubKey<unsigned long long> : SizedSubKey<sizeof(unsigned long long)>\n{\n};\n\ntemplate<typename It, typename ExtractKey>\ninline void StdSortFallback(It begin, It end, ExtractKey & extract_key)\n{\n    std::sort(begin, end, [&](const typename std::remove_reference<decltype(*begin)>::type & l,\n                              const typename std::remove_reference<decltype(*begin)>::type & r) { return extract_key(l) < extract_key(r); });\n}\n\ntemplate<std::ptrdiff_t StdSortThreshold, typename It, typename ExtractKey>\ninline bool StdSortIfLessThanThreshold(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key)\n{\n    if (num_elements <= 1)\n        return true;\n    if (num_elements >= StdSortThreshold)\n        return false;\n    StdSortFallback(begin, end, extract_key);\n    return true;\n}\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, typename SubKeyType = typename CurrentSubKey::sub_key_type>\nstruct InplaceSorter;\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, size_t NumBytes, size_t Offset = 0>\nstruct UnsignedInplaceSorter\n{\n    static constexpr size_t ShiftAmount = (((NumBytes - 1) - Offset) * 8);\n    template<typename T>\n    inline static uint8_t current_byte(T && elem, void * sort_data)\n    {\n        return CurrentSubKey::sub_key(elem, sort_data) >> ShiftAmount;\n    }\n    template<typename It, typename ExtractKey>\n    static void sort(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key, void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data)\n    {\n        if (num_elements < AmericanFlagSortThreshold)\n            american_flag_sort(begin, end, extract_key, next_sort, sort_data);\n        else\n            ska_byte_sort(begin, end, extract_key, next_sort, sort_data);\n    }\n\n    template<typename It, typename ExtractKey>\n    static void american_flag_sort(It begin, It end, ExtractKey & extract_key, void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data)\n    {\n        PartitionInfo partitions[256];\n        for (It it = begin; it != end; ++it)\n        {\n            ++partitions[current_byte(extract_key(*it), sort_data)].count;\n        }\n        size_t total = 0;\n        uint8_t remaining_partitions[256];\n        int num_partitions = 0;\n        for (int i = 0; i < 256; ++i)\n        {\n            size_t count = partitions[i].count;\n            if (!count)\n                continue;\n            partitions[i].offset = total;\n            total += count;\n            partitions[i].next_offset = total;\n            remaining_partitions[num_partitions] = i;\n            ++num_partitions;\n        }\n        if (num_partitions > 1)\n        {\n            uint8_t * current_block_ptr = remaining_partitions;\n            PartitionInfo * current_block = partitions + *current_block_ptr;\n            uint8_t * last_block = remaining_partitions + num_partitions - 1;\n            It it = begin;\n            It block_end = begin + current_block->next_offset;\n            It last_element = end - 1;\n            for (;;)\n            {\n                PartitionInfo * block = partitions + current_byte(extract_key(*it), sort_data);\n                if (block == current_block)\n                {\n                    ++it;\n                    if (it == last_element)\n                        break;\n                    else if (it == block_end)\n                    {\n                        for (;;)\n                        {\n                            ++current_block_ptr;\n                            if (current_block_ptr == last_block)\n                                goto recurse;\n                            current_block = partitions + *current_block_ptr;\n                            if (current_block->offset != current_block->next_offset)\n                                break;\n                        }\n\n                        it = begin + current_block->offset;\n                        block_end = begin + current_block->next_offset;\n                    }\n                }\n                else\n                {\n                    size_t offset = block->offset++;\n                    std::iter_swap(it, begin + offset);\n                }\n            }\n        }\n        recurse:\n        if (Offset + 1 != NumBytes || next_sort)\n        {\n            size_t start_offset = 0;\n            It partition_begin = begin;\n            for (uint8_t * it = remaining_partitions, * part_end = remaining_partitions + num_partitions; it != part_end; ++it)\n            {\n                size_t end_offset = partitions[*it].next_offset;\n                It partition_end = begin + end_offset;\n                std::ptrdiff_t num_elements = end_offset - start_offset;\n                if (!StdSortIfLessThanThreshold<StdSortThreshold>(partition_begin, partition_end, num_elements, extract_key))\n                {\n                    UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, NumBytes, Offset + 1>::sort(partition_begin, partition_end, num_elements, extract_key, next_sort, sort_data);\n                }\n                start_offset = end_offset;\n                partition_begin = partition_end;\n            }\n        }\n    }\n\n    template<typename It, typename ExtractKey>\n    static void ska_byte_sort(It begin, It end, ExtractKey & extract_key, void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data)\n    {\n        PartitionInfo partitions[256];\n        for (It it = begin; it != end; ++it)\n        {\n            ++partitions[current_byte(extract_key(*it), sort_data)].count;\n        }\n        uint8_t remaining_partitions[256];\n        size_t total = 0;\n        int num_partitions = 0;\n        for (int i = 0; i < 256; ++i)\n        {\n            size_t count = partitions[i].count;\n            if (count)\n            {\n                partitions[i].offset = total;\n                total += count;\n                remaining_partitions[num_partitions] = i;\n                ++num_partitions;\n            }\n            partitions[i].next_offset = total;\n        }\n        for (uint8_t * last_remaining = remaining_partitions + num_partitions, * end_partition = remaining_partitions + 1; last_remaining > end_partition;)\n        {\n            last_remaining = custom_std_partition(remaining_partitions, last_remaining, [&](uint8_t partition)\n            {\n                size_t & begin_offset = partitions[partition].offset;\n                size_t & end_offset = partitions[partition].next_offset;\n                if (begin_offset == end_offset)\n                    return false;\n\n                unroll_loop_four_times(begin + begin_offset, end_offset - begin_offset, [&](It it)\n                {\n                    uint8_t this_partition = current_byte(extract_key(*it), sort_data);\n                    size_t offset = partitions[this_partition].offset++;\n                    std::iter_swap(it, begin + offset);\n                });\n                return begin_offset != end_offset;\n            });\n        }\n        if (Offset + 1 != NumBytes || next_sort)\n        {\n            for (uint8_t * it = remaining_partitions + num_partitions; it != remaining_partitions; --it)\n            {\n                uint8_t partition = it[-1];\n                size_t start_offset = (partition == 0 ? 0 : partitions[partition - 1].next_offset);\n                size_t end_offset = partitions[partition].next_offset;\n                It partition_begin = begin + start_offset;\n                It partition_end = begin + end_offset;\n                std::ptrdiff_t num_elements = end_offset - start_offset;\n                if (!StdSortIfLessThanThreshold<StdSortThreshold>(partition_begin, partition_end, num_elements, extract_key))\n                {\n                    UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, NumBytes, Offset + 1>::sort(partition_begin, partition_end, num_elements, extract_key, next_sort, sort_data);\n                }\n            }\n        }\n    }\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, size_t NumBytes>\nstruct UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, NumBytes, NumBytes>\n{\n    template<typename It, typename ExtractKey>\n    inline static void sort(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key, void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * next_sort_data)\n    {\n        next_sort(begin, end, num_elements, extract_key, next_sort_data);\n    }\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>\nstruct InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, uint32_t> : UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, 4>\n{\n};\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>\nstruct InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, uint64_t> : UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, 8>\n{\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>\nstruct SortStarter;\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold>\nstruct SortStarter<StdSortThreshold, AmericanFlagSortThreshold, SubKey<void>>\n{\n    template<typename It, typename ExtractKey>\n    static void sort(It, It, std::ptrdiff_t, ExtractKey &, void *)\n    {\n    }\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>\nstruct SortStarter\n{\n    template<typename It, typename ExtractKey>\n    static void sort(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key, void * next_sort_data = nullptr)\n    {\n        if (StdSortIfLessThanThreshold<StdSortThreshold>(begin, end, num_elements, extract_key))\n            return;\n\n        void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *) = static_cast<void (*)(It, It, std::ptrdiff_t, ExtractKey &, void *)>(&SortStarter<StdSortThreshold, AmericanFlagSortThreshold, typename CurrentSubKey::next>::sort);\n        if (next_sort == static_cast<void (*)(It, It, std::ptrdiff_t, ExtractKey &, void *)>(&SortStarter<StdSortThreshold, AmericanFlagSortThreshold, SubKey<void>>::sort))\n            next_sort = nullptr;\n        InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey>::sort(begin, end, num_elements, extract_key, next_sort, next_sort_data);\n    }\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename It, typename ExtractKey>\nvoid inplace_radix_sort(It begin, It end, ExtractKey & extract_key)\n{\n    using SubKey = SubKey<decltype(extract_key(*begin))>;\n    SortStarter<StdSortThreshold, AmericanFlagSortThreshold, SubKey>::sort(begin, end, end - begin, extract_key);\n}\n\nstruct IdentityFunctor\n{\n    template<typename T>\n    T&& operator()(T && i) const\n    {\n        return std::forward<T>(i);\n    }\n};\n}\n\ntemplate<typename It, typename ExtractKey>\nstatic void ska_sort(It begin, It end, ExtractKey && extract_key)\n{\n    detail::inplace_radix_sort<128, 1024>(begin, end, extract_key);\n}\n\ntemplate<typename It>\nstatic void ska_sort(It begin, It end)\n{\n    ska_sort(begin, end, detail::IdentityFunctor());\n}\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nnamespace IO {\n    const int BUFFER_SIZE = 1 << 15;\n\n    char input_buffer[BUFFER_SIZE];\n    int input_pos = 0, input_len = 0;\n\n    char output_buffer[BUFFER_SIZE];\n    int output_pos = 0;\n\n    char number_buffer[100];\n    uint8_t lookup[100];\n\n    void _update_input_buffer() {\n        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);\n        input_pos = 0;\n\n        if (input_len == 0)\n            input_buffer[0] = EOF;\n    }\n\n    inline char next_char(bool advance = true) {\n        if (input_pos >= input_len)\n            _update_input_buffer();\n\n        return input_buffer[advance ? input_pos++ : input_pos];\n    }\n\n    template<typename T>\n    inline void read_int(T &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == '-')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - '0');\n        } while (isdigit(next_char(false)));\n\n        if (negative)\n            number = -number;\n    }\n\n    template<typename T, typename... Args>\n    inline void read_int(T &number, Args &... args) {\n        read_int(number);\n        read_int(args...);\n    }\n\n    void _flush_output() {\n        fwrite(output_buffer, sizeof(char), output_pos, stdout);\n        output_pos = 0;\n    }\n\n    inline void write_char(char c) {\n        if (output_pos == BUFFER_SIZE)\n            _flush_output();\n\n        output_buffer[output_pos++] = c;\n    }\n\n    template<typename T>\n    inline void write_int(T number, char after = '\\0') {\n        if (number < 0) {\n            write_char('-');\n            number = -number;\n        }\n\n        int length = 0;\n\n        while (number >= 10) {\n            uint8_t lookup_value = lookup[number % 100];\n            number /= 100;\n            number_buffer[length++] = (lookup_value & 15) + '0';\n            number_buffer[length++] = (lookup_value >> 4) + '0';\n        }\n\n        if (number != 0 || length == 0)\n            write_char(number + '0');\n\n        for (int i = length - 1; i >= 0; i--)\n            write_char(number_buffer[i]);\n\n        if (after)\n            write_char(after);\n    }\n\n    void init() {\n        // Make sure _flush_output() is called at the end of the program.\n        bool exit_success = atexit(_flush_output) == 0;\n        assert(exit_success);\n\n        for (int i = 0; i < 100; i++)\n            lookup[i] = (i / 10 << 4) + i % 10;\n    }\n}\n\n\nconst int INF = 1e9 + 5;\n\nstruct salary {\n    int L, R;\n\n    bool operator<(const salary &other) const {\n        return L < other.L;\n    }\n};\n\nint N, H;\nlong long S;\nvector<salary> salaries;\n\nbool possible(int median) {\n    long long sum = 0;\n    int count = 0;\n\n    for (int i = N - 1; i >= 0; i--)\n        if (salaries[i].R >= median) {\n            sum += max(median - salaries[i].L, 0);\n            count++;\n\n            if (count == H || sum > S)\n                break;\n        }\n\n    return count == H && sum <= S;\n}\n\nvoid solve_case() {\n    IO::read_int(N, S);\n    H = (N + 1) / 2;\n    salaries.resize(N);\n\n    for (salary &s : salaries) {\n        IO::read_int(s.L, s.R);\n        S -= s.L;\n    }\n\n    ska_sort(salaries.begin(), salaries.end(), [](const salary &s) {\n        return s.L;\n    });\n\n    int low = 0, high = INF;\n\n    while (low < high) {\n        int mid = (low + high + 1) / 2;\n\n        if (possible(mid))\n            low = mid;\n        else\n            high = mid - 1;\n    }\n\n    IO::write_int(low, '\\n');\n}\n\nint main() {\n    IO::init();\n\n    int T;\n    IO::read_int(T);\n\n    while (T-- > 0)\n        solve_case();\n}\n   ""]","[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",1900
Let s define a of length n as an array p of length n which contains every number from 1 to n exactly once You are given a permutation p 1 p 2 dots p n and a number k You need to sort this permutation in the ascending order In order to do it you can repeat the following operation any number of times possibly zero pick two elements of the permutation p i and p j such that i j k and swap them Unfortunately some permutations can t be sorted with some fixed numbers k For example it s impossible to sort 2 4 3 1 with k 2 That s why before starting the sorting you can make at most one choose any pair p i and p j and swap them Your task is to check whether is it possible to sort the permutation any preliminary exchanges if it s not check whether is it possible to sort the permutation using exactly preliminary exchange For example if k 2 and permutation is 2 4 3 1 then you can make a preliminary exchange of p 1 and p 4 which will produce permutation 1 4 3 2 which is possible to sort with given k ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005;\n\nint n,k,a[N];\n\nvoid ldc(){\n    cin >> n >> k;\n    for(int i=0; i<n; ++i) cin >> a[i],a[i]--;\n    int de=0;\n    for(int i=0; i<n; ++i) if(a[i]%k!=i%k) de++;\n    assert(de!=1);\n    if(de==0) cout << ""0\\n"";\n    else if(de==2) cout << ""1\\n"";\n    else cout << ""-1\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]",900
John Doe started thinking about graphs After some thought he decided that he wants to paint an undirected graph containing exactly cycles of length A cycle of length is an unordered group of three distinct graph vertices and such that each pair of them is connected by a graph edge John has been painting for long but he has not been a success Help him find such graph Note that the number of vertices there shouldn t exceed or else John will have problems painting it ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint n, i, j, k;\nint a[111][111];\n\nint main() {\n  scanf(""%d"",&n);\n  memset(a,0,sizeof(a));\n  int m = 0;\n  while (n > 0)\n    for (i=100;i>=3;i--)\n      if (i*(i-1)*(i-2)/6 <= n) {\n        m += i;\n        for (j=m-i;j<m;j++)\n          for (k=m-i;k<m;k++) a[j][k] = (j != k);\n        n -= i*(i-1)*(i-2)/6;\n        for (int z=i;z>=2;z--)\n          if (z*(z-1)/2 <= n) {\n            m++;\n            for (j=m-z-1;j<m-1;j++) a[j][m-1] = a[m-1][j] = 1;\n            n -= z*(z-1)/2;\n            for (int y=z+1;y>=2;y--)\n              if (y*(y-1)/2 <= n) {\n                m++;\n                for (j=m-y-1;j<m-1;j++) a[j][m-1] = a[m-1][j] = 1;\n                n -= y*(y-1)/2;\n                break;\n              }\n            break;\n          }\n        break;\n      }\n  printf(""%d\\n"",m);\n  for (i=0;i<m;i++) {\n    for (j=0;j<m;j++) printf(""%d"",a[i][j]);\n    printf(""\\n"");\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0]",1600
Petya got interested in grammar on his third year in school He invented his own language called Petya s Petya wanted to create a maximally simple language that would be enough to chat with friends that s why all the language s grammar can be described with the following set of rules There are three parts of speech the adjective the noun the verb Each word in his language is an adjective noun or verb There are two genders masculine and feminine Each word in his language has gender either masculine or feminine Masculine adjectives end with and feminine adjectives end with Masculine nouns end with and feminime nouns end with Masculine verbs end with and feminime verbs end with Thus each word in the Petya s language has one of the six endings given above There are no other endings in Petya s language It is accepted that the whole word consists of an ending That is words and so on belong to the Petya s language There aren t any punctuation marks grammatical tenses singular plural forms or other language complications A sentence is either exactly one valid language word or exactly one is any sequence of the Petya s language that satisfy both conditions Words in statement follow in the following order from the left to the right zero or more adjectives followed by exactly one noun followed by zero or more verbs All words in the statement should have the same gender After Petya s friend Vasya wrote instant messenger an instant messaging program that supported the Petya s language Petya wanted to add spelling and grammar checking to the program As Vasya was in the country and Petya didn t feel like waiting he asked you to help him with this problem Your task is to define by a given sequence of words whether it is true that the given text represents exactly one sentence in Petya s language ,"['//  Codeforces Beta Round #86\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void pvp(T a, T b) { for (T i = a; i != b; ++i) cout << ""("" << i->first << "", "" << i->second << "") ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in_c() { int c; for (; (c = getchar()) <= \' \'; ) { if (!~c) throw ~0; } return c; }\nint in() { int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -in(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\nInt In() { Int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -In(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\n\nint L;\nchar S[100010];\n\nint N;\nint is[100010];\n\nbool solve() {\n    int i;\n    for (i = 0; i < N; ++i) {\n        if (is[i] == -1) {\n            return 0;\n        }\n    }\n    if (N == 1) return 1;\n    for (i = 0; i < N; ++i) {\n        if (is[0] % 2 != is[i] % 2) {\n            return 0;\n        }\n    }\n    int a = 0, b = 0, c = 0;\n    i = 0;\n    for (; i < N && is[i] / 2 == 0; ++i) ++a;\n    for (; i < N && is[i] / 2 == 1; ++i) ++b;\n    for (; i < N && is[i] / 2 == 2; ++i) ++c;\n    if (i != N) return 0;\n    if (b != 1) return 0;\n    return 1;\n}\n\nint main() {\n    int i;\n    \n    for (; ; ) {\n        N = 0;\n        for (; ~scanf(""%s"", S); ) {\n            if (!strcmp(S, ""#"")) break;\n            L = strlen(S);\n            is[N] = -1;\n            if (!strcmp(S + L - 4,   ""lios"")) is[N] = 0;\n            if (!strcmp(S + L - 5,  ""liala"")) is[N] = 1;\n            if (!strcmp(S + L - 3,    ""etr"")) is[N] = 2;\n            if (!strcmp(S + L - 4,   ""etra"")) is[N] = 3;\n            if (!strcmp(S + L - 6, ""initis"")) is[N] = 4;\n            if (!strcmp(S + L - 6, ""inites"")) is[N] = 5;\n            ++N;\n        }\n        if (N == 0) break;\n//cout<<""is : "";pv(is,is+N);\n        bool res = solve();\n        puts(res ? ""YES"" : ""NO"");\n    }\n    \n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1600
You are in charge of the BubbleReactor It consists of N BubbleCores connected with N lines of electrical wiring Each electrical wiring connects two distinct BubbleCores There are no BubbleCores connected with more than one line of electrical wiring Your task is to start the BubbleReactor by starting each BubbleCore In order for a BubbleCore to be started it needs to be receiving power from a directly connected BubbleCore which is already started However you can kick start one BubbleCore manually without needing power It is guaranteed that all BubbleCores can be started Before the BubbleCore boot up procedure its potential is calculated as the number of BubbleCores it can power on the number of inactive BubbleCores which are connected to it directly or with any number of inactive BubbleCores in between itself included Start the BubbleReactor so that the sum of all BubbleCores potentials is maximum ,"['#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<""=""<<h<<""\\n""; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != \',\') { cerr<<*sdbg++; } cerr<<""=""<<h<<"",""; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<"" = ""; FORE(itt, (x)) cerr <<*itt <<"", ""; cerr <<""\\n""; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << ""("" << pair.first << "", "" << pair.second << "")"";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << ""("" << t.st << "", "" << t.nd << "", "" << t.rd << "")""; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<""(""; for (auto& v: vec) out<<v<<"", ""; return out<<"")""; }\n\nconst int N = 3e4 + 5;\nVI slo[N];\nint vis[N];\nVI stos;\nint on_cyc[N];\nVI cyc;\nvoid Dfs1(int v, int par) {\n  vis[v] = 1;\n  stos.PB(v);\n  for (auto nei : slo[v]) {\n    if (nei == par) { continue; }\n    if (vis[nei]) {\n      FORD (ind, SZ(stos) - 1, 0) {\n        cyc.PB(stos[ind]);\n        on_cyc[stos[ind]] = 1;\n        if (stos[ind] == nei) {\n          throw 1;\n        }\n      }\n    }\n    Dfs1(nei, v);\n  }\n  stos.pop_back();\n}\nint sz[N];\nint sum_szs[N];\nvoid Dfs2(int v) {\n  sz[v] = 1;\n  for (auto nei : slo[v]) {\n    if (on_cyc[nei]) { continue; }\n    if (sz[nei]) { continue; }\n    Dfs2(nei);\n    sum_szs[v] += sum_szs[nei];\n    sz[v] += sz[nei];\n  }\n  sum_szs[v] += sz[v];\n}\nint res[N];\nint n;\nvoid Dfs3(int v) {\n  for (auto nei : slo[v]) {\n    if (on_cyc[nei]) { continue; }\n    if (res[nei]) { continue; }\n    res[nei] = res[v] + n - 2 * sz[nei];\n    Dfs3(nei);\n  }\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  cin>>n;\n  RE (i, n) {\n    int a, b;\n    cin>>a>>b;\n    a++;\n    b++;\n    slo[a].PB(b);\n    slo[b].PB(a);\n  }\n  try {\n    Dfs1(n, 0);\n  } catch (...) {\n  }\n  RE (i, n) {\n    debug(i, on_cyc[i]);\n  }\n  \n  VI szs;\n  int bonus = 0;\n  for (auto v : cyc) {\n    Dfs2(v);\n    bonus += sum_szs[v] - sz[v];\n    szs.PB(sz[v]);\n  }\n  for (auto v : cyc) {\n    szs.PB(sz[v]);\n  }\n  VI dp(SZ(szs));\n  for (auto v : cyc) {\n    szs.PB(sz[v]);\n  }\n  debug(cyc);\n  debug(szs);\n  dp.insert(dp.begin(), 0);\n  VI pref_sum = szs;\n  RE (i, SZ(pref_sum) - 1) {\n    pref_sum[i] += pref_sum[i - 1];\n  }\n  FOR (len, 1, SZ(cyc) - 1) {\n    debug(dp);\n    VI ndp(SZ(dp) - 1);\n    REP (i, SZ(dp) - 1) {\n      ndp[i] = pref_sum[i + len] - pref_sum[i] + max(dp[i], dp[i + 1]);\n    }\n    dp = ndp;\n  }\n  debug(dp);\n  REP (i, SZ(cyc)) {\n    int v = cyc[i];\n    res[v] = dp[i] + bonus + n;\n    Dfs3(v);\n    debug(v, res[v]);\n  }\n  int best = 0;\n  RE (i, n) {\n    maxi(best, res[i]);\n    debug(i, res[i]);\n  }\n  cout<<best<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2800
Once at a team training Vasya Petya and Sasha got a problem on implementing linear search in an array According to the boys linear search works as follows The array elements in a pre selected order are in turn compared with the number that you need to find Once you find the array element that is equal to the required one the search ends The efficiency of the algorithm is the number of performed comparisons The fewer comparisons the linear search has made the more effective it is Vasya believes that a linear search would work better if it sequentially iterates through the elements starting with the st one in this problem we consider the elements of the array indexed from to and ending with the th one And Petya says that Vasya is wrong the search will need less comparisons if it sequentially iterates the elements starting from the th and ending with the st one Sasha argues that the two approaches are equivalent To finally begin the task the teammates decided to settle the debate and compare the two approaches on an example For this they took an array that is a permutation of integers from to and generated queries of the form find element with value in the array They want to calculate for both approaches how many comparisons in total the linear search will need to respond to all queries If the first search needs fewer comparisons then the winner of the dispute is Vasya If the second one does then the winner is Petya If both approaches make the same number of comparisons then Sasha s got the upper hand But the problem is linear search is too slow That s why the boys aren t going to find out who is right before the end of the training unless you come in here Help them to determine who will win the dispute ,"['#include<iostream>\n\nusing namespace std;\n\nlong long n,m,s1,s2,i,a[100021],b[100021],pos[100021];\n\nint main()\n{\n    cin>>n;\n    for (i=0;i<n;i++)\n    {\n        cin>>a[i];\n        pos[a[i]]=i;\n    }\n    cin>>m;\n    for (i=0;i<m;i++) cin>>b[i];\n    s1=0;s2=0;\n    for (i=0;i<m;i++)\n    {\n        s1+=pos[b[i]]+1;\n        s2+=n-pos[b[i]];\n    }\n    cout<<s1<<"" ""<<s2<<endl;\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Sherlock has a new girlfriend so unlike him Valentine s day is coming and he wants to gift her some jewelry He bought pieces of jewelry The th piece has price equal to that is the prices of the jewelry are Watson gave Sherlock a challenge to color these jewelry pieces such that two pieces don t have the same color if the price of one piece is a prime divisor of the price of the other piece Also Watson asked him to minimize the number of different colors used Help Sherlock complete this trivial task ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[101000], n;\nint main(){\n    int i, j;\n    scanf(""%d"",&n);\n    for(i=2;i<=n+1;i++){\n        for(j=i+i;j<=n+1;j+=i){\n            w[j] = 1;\n        }\n    }\n    if(n<=2){\n        printf(""1\\n"");\n        for(i=1;i<=n;i++)printf(""%d "",1);\n        return 0;\n    }\n    printf(""2\\n"");\n    for(i=1;i<=n;i++){\n        if(!w[i+1])printf(""1 "");\n        else printf(""2 "");\n    }\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1200
You are given a rooted tree consisting of vertices Each vertex has a number written on it number is written on vertex Let s denote as the distance between vertices and in the tree that is the number of edges in the shortest path from to Also let s denote the of vertex as the set of vertices such that both these conditions are met is an ancestor of every vertex is an ancestor of itself You are given queries to the tree th query is represented by two numbers and and the answer to this query is the minimum value of among such vertices such that belongs to blocked subtree of Write a program that would process these queries quickly ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << ""\\n""; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nstruct Vertex {\n\tint level;\n\tint val;\n\n\tVertex() {}\n\tVertex(int l, int v): level(l), val(v) {}\n\n\tbool operator <(const Vertex& ot) const {\n\t\treturn level < ot.level;\n\t}\n};\n\nconst int INF = 1e9 + 10;\n\nstruct SegTree {\n\tint n;\n\tvector<vector<Vertex>> a;\n\tvector<vector<int>> res;\n\n\tSegTree(const vector<int>& level, const vector<int>& vals) {\n\t\tn = 1;\n\t\twhile (n < (int)level.size()) {\n\t\t\tn *= 2;\n\t\t}\n\t\ta.resize(n + n);\n\t\tres.resize(n + n);\n\t\tfor (int i = 0; i < (int)level.size(); ++i) {\n\t\t\ta[n + i] = {{level[i], vals[i]}};\n\t\t\tres[n + i] = {INF, vals[i]};\n\t\t}\n\t\tfor (int i = n - 1; i > 0; --i) {\n\t\t\ta[i].resize(a[i + i].size() + a[i + i + 1].size());\n\t\t\tmerge(all(a[i + i]), all(a[i + i + 1]), a[i].begin());\n\t\t\tres[i].resize(a[i].size() + 1, INF);\n\t\t\tfor (int j = 0; j < (int)a[i].size(); ++j) {\n\t\t\t\tres[i][j + 1] = min(res[i][j], a[i][j].val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint _get(int v, int l1, int r1, int l, int r, int maxk) {\n\t\tif (l >= r1 || l1 >= r) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (l <= l1 && r >= r1) {\n\t\t\tint idx = lower_bound(all(a[v]), Vertex(maxk + 1, 0)) - a[v].begin();\n\t\t\treturn res[v][idx];\n\t\t}\n\t\tint mid = (l1 + r1) / 2;\n\t\treturn min(_get(v + v, l1, mid, l, r, maxk),\n\t\t\t\t   _get(v + v + 1, mid, r1, l, r, maxk));\n\t}\n\n\tint get(int l, int r, int maxk) {\n\t\treturn _get(1, 0, n, l, r, maxk);\n\t}\n};\n\nconst int N = 111111;\nint tin[N], tout[N], level[N];\nint timer = 0;\nvector<int> a[N];\nint val[N];\nvector<int> levels, vals;\n\nvoid dfs(int v, int p = -1) {\n\ttin[v] = timer++;\n\tlevels.push_back(level[v]);\n\tvals.push_back(val[v]);\n\tfor (int x : a[v]) {\n\t\tif (x == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tlevel[x] = level[v] + 1;\n\t\tdfs(x, v);\n\t}\n\ttout[v] = timer;\n}\n\nint main() {\n\tint n = nxt(), root = nxt() - 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tval[i] = nxt();\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\n\tdfs(root);\n\n\tSegTree tree(levels, vals);\n\tint q = nxt();\n\tint last = 0;\n\twhile (q--) {\n\t\tint p1 = nxt(), p2 = nxt();\n\t\tint x = (p1 + last) % n;\n\t\tint k = (p2 + last) % n;\n\n\t\tlast = tree.get(tin[x], tout[x], level[x] + k);\n\t\tprintf(""%d\\n"", last);\n\t}\n\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2300
Little Petya loves presents His mum bought him two strings of the same size for his birthday The strings consist of uppercase and lowercase Latin letters Now Petya wants to compare those two strings The letters case does not matter that is an uppercase letter is considered equivalent to the corresponding lowercase letter Help Petya perform the comparison ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n\nusing namespace std;\n\nstring s1,s2;\n\nint main() {\n  //freopen(""a.in"",""r"",stdin);\n\n  getline(cin,s1);\n  getline(cin,s2);\n  \n  for (int i=0;i<s1.size();++i) {\n    if (s1[i]>=97) s1[i]-=32;\n    if (s2[i]>=97) s2[i]-=32;\n  }\n  \n  if (s1==s2) printf(""0\\n"");\n  else {\n    if (s1<s2) printf(""-1\\n"");\n    else printf(""1\\n"");\n  }\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",800
You are given a string a consisting of n characters n is even For each i from 1 to n a i is one of or A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not You want to find a string b that consists of n characters such that b is a regular bracket sequence if for some i and j 1 le i j le n a i a j then b i b j In other words you want to replace all occurrences of with the same type of bracket then all occurrences of with the same type of bracket and all occurrences of with the same type of bracket Your task is to determine if such a string b exists ,"['#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nbool check(string s)\n{\n    int n = s.size();\n    int balance = 0;\n    for (auto c: s)\n    {\n        if (c==\')\') balance--; else balance++;\n        if (balance<0) return false;\n    }\n    if (balance!=0) return false;\n    return true;\n}\n\nvoid solve()\n{\n    string s; cin>>s;\n    for (int mask = 0; mask<8; mask++)\n    {\n        string s1;\n        for (auto c: s)\n        {\n            if (mask&(1<<(c-\'A\'))) s1+=\'(\'; else s1+=\')\';\n        }\n        if (check(s1)) {cout<<""YES""<<endl; return;}\n    }\n    cout<<""NO""<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t; while (t--) solve();\n\n\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",900
Monocarp plays Rage of Empires II Definitive Edition a strategic computer game Right now he s planning to attack his opponent in the game but Monocarp s forces cannot enter the opponent s territory since the opponent has built a wall The wall consists of n sections aligned in a row The i th section initially has durability a i If durability of some section becomes 0 or less this section is considered broken To attack the opponent Monocarp needs to break at least two sections of the wall any two sections possibly adjacent possibly not To do this he plans to use an onager a special siege weapon The onager can be used to shoot any section of the wall the shot deals 2 damage to the target section and 1 damage to adjacent sections In other words if the onager shoots at the section x then the durability of the section x decreases by 2 and the durability of the sections x 1 and x 1 if they exist decreases by 1 each Monocarp can shoot at any sections any number of times Monocarp wants to calculate the minimum number of onager shots needed to break at least two sections Help him ,"['#include ""bits/stdc++.h""\n \nusing namespace std;\n \nusing ll = long long;\nconst ll inf = 1e9;\nconst int md1 = 1e9+7;\n \n#define all(v)                      v.begin(), v.end()\n#define rall(v)                     v.rbegin(), v.rend()\n#define sz(v)                       ((int)v.size())\n \n#define forn(i,n)                   for(int i = 0; i < n; ++i)\n#define forbe(i,b,e)                for(int i = b; i < e; ++i)\n \n#define pb                          push_back\n \n#define pry                         puts(""YES"")\n#define prn                         puts(""NO"")\n#define endl                        \'\\n\'\n \n#define fst                         first\n#define scn                         second\n \n#define int long long\nvoid solve(){\n    int n;\n    cin>>n;\n    vector<int>a(n);\n    forn(i,n)cin>>a[i];\n    vector<int>b=a;\n    sort(all(b));\n    int ans = (b[0]+1)/2+(b[1]+1)/2;\n\n    for(int i=0;i+1<n;i++){\n        int x=a[i],y=a[i+1];\n        if(x>y)swap(x,y);\n        if(y>=2*x){\n            ans=min(ans,(y+1)/2);\n            continue;\n        }\n        int pp = y-x;\n        y-=pp*2;\n        x-=pp;\n        int now = pp+x/3*2+x%3;\n        ans=min(ans,now);\n    }\n    for(int i=0;i+2<n;++i){\n        int x=a[i],y=a[i+2];\n        if(x>y)swap(x,y);\n        int now=x/2+y/2;\n        x%=2,y%=2;\n        if(x || y) ++now;\n        ans=min(ans,now);\n    }\n    cout<<ans<<endl;\n}\n \nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while(t--)\n        solve();\n}']","[1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0]",2000
Twilight Sparkle has received a new task from Princess Celestia This time she asked to decipher the ancient scroll containing important knowledge of pony origin To hide the crucial information from evil eyes pony elders cast a spell on the scroll That spell adds exactly one letter in any place to each word it is cast on To make the path to the knowledge more tangled elders chose of words in the scroll and cast a spell on them Twilight Sparkle knows that the elders admired the order in all things so the scroll original scroll contained words in She is asked to delete one letter from some of the words of the scroll to undo the spell to get some version of the original scroll Unfortunately there may be more than one way to recover the ancient scroll To not let the important knowledge slip by Twilight has to look through all variants of the original scroll and find the required one To estimate the maximum time Twilight may spend on the work she needs to know the number of variants she has to look through She asks you to find that number Since that number can be very big Twilight asks you to find it modulo 10 9 7 It may occur that princess Celestia has sent a wrong scroll so the answer may not exist A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring arr[2009];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    long long t=1;\n    //cin>>t;\n    while(t--) {\n        int n;\n        cin>>n;\n        int x=0,y=0;\n        for(int f=0;f<n;f++) {\n            cin>>arr[f];\n            x+=arr[f].size()+1;\n        }\n        long long ans=0,dp[22009]={0},mod=1e9+7;\n        for(int f=0;f<=arr[n-1].size();f++) {\n            dp[--x]=1;\n        }\n        y=x;\n        for(int f=n-2;f>=0;f--) {\n            x-=arr[f].size()+1;\n            int m=max(arr[f].size(),arr[f+1].size());\n            int m1=arr[f].size();\n            int m2=arr[f+1].size();\n            while(arr[f].size()<m)\n                arr[f]+=(\'a\'-1);\n            while(arr[f+1].size()<m)\n                arr[f+1]+=(\'a\'-1);\n            for(int f1=-1;f1<m1;f1++) {\n                bool ok[20009]={0};\n                int i=m-1;\n                if(f1==-1) {\n                    arr[f+1]+=(\'a\'-1);\n                    m++;\n                }\n                ok[m]=1;\n                for(int f2=m-1;f2>=1;f2--) {\n                    if(i==f1)\n                        i--;\n                    if(arr[f][i]<arr[f+1][f2]||arr[f][i]==arr[f+1][f2]&&(f2==m-1||ok[f2+1]))\n                        ok[f2]=1;\n                    i--;\n                }\n                bool b=0;\n                bool k=0;\n                i=0;\n                if(arr[f].substr(0,max(0,f1))+arr[f].substr(f1+1)<=arr[f+1]) {\n                    dp[x+f1+1]=(dp[x+f1+1]+dp[y])%mod;\n                    //cout<<x+f1+1<<"" ""<<y<<endl;\n                }\n                for(int f2=0;f2<m2;f2++){\n                    int x1=x+f1+1;\n                    int y1=y+f2+1;\n                    //cout<<""f2: ""<<f2<<"" x: ""<<x1<<"" y: ""<<y1<<endl;\n\n                    if(i==f1)\n                        i++;\n                    if(b) {\n                        //cout<<""1 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&f2+1==m) {\n                        //cout<<""2 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&arr[f][i]>arr[f+1][f2]&&ok[f2+1]) {\n                        //cout<<""3 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&arr[f][i]==arr[f+1][f2]&&ok[f2+1]) {\n                        //cout<<""4 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&arr[f][i]<arr[f+1][f2]&&ok[f2+1]) {\n                        //cout<<""5 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    if(b==0&&f2>=0&&arr[f][i]>arr[f+1][f2]) {\n                        k=1;\n                        //cout<<""k""<<endl;\n                    }\n                    if(k==0&&f2>=0&&arr[f][i]<arr[f+1][f2]) {\n                        b=1;\n                        //cout<<""b""<<endl;\n                    }\n                    i++;\n                }\n            }\n            arr[f]=arr[f].substr(0,m1);\n            arr[f+1]=arr[f+1].substr(0,m2);\n            y-=arr[f].size()+1;\n        }\n        //cout<<""x: ""<<x<<endl;\n        for(int f=0;f<=arr[0].size();f++) {\n            ans=(ans+dp[f])%mod;\n        }\n        //for(int f=0;f<x;f++)\n        //    cout<<dp[f]<<"" "";\n        //cout<<endl;\n        cout<<ans<<endl;\n    }\n}\n']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2800
Unfortunately Vasya can only sum pairs of integers such that for any decimal place at least one number has digit in this place For example Vasya can sum numbers and but he cannot sum and Vasya has a set of distinct non negative integers Vasya wants to choose some integers from this set so that he could sum any two chosen numbers What maximal number of integers can he choose in the required manner ,"['/*\n* Problem: \n* Author: Leo Yu\n* Time: \n* State: SOLVED\n* Memo: \n*/\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long LL;\ninline int\tread()\n{\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; ch < \'0\' || ch > \'9\'; ch = getchar())\tif (ch == \'-\')  positive = 0;\n\tfor (; ch >= \'0\' && ch <= \'9\'; ch = getchar())\tx = x * 10 + ch - \'0\';\n\treturn positive ? x : -x;\n}\n#define link Link\n\nvector<int>\tans;\nint a[100006];\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""a.in"", ""r"", stdin);\n\tfreopen(""a.out"", ""w"", stdout);\n#endif\n\n\tint N = read();\n\tans.clear();\n\tbool\tflag1 = 0, flag2 = 0, flag3 = 0;\n\tfor (int i = 1; i <= N; ++ i)\n\t{\n\t\tint x = a[i] = read();\n\t\tif (x == 0)\tans.push_back(x);\n\t\tif (x && x < 10 && !flag1)\tans.push_back(x), flag1 = 1;\n\t\tif (x && x < 100 && x % 10 == 0 && !flag2)\tans.push_back(x), flag2 = 1;\n\t\tif (x == 100 && !flag3)\tans.push_back(x), flag3 = 1;\n\t}\n\tfor (int i = 1; i <= N; ++ i)\n\t{\n\t\tint x = a[i];\n\t\tif (x && x < 100 && x % 10 && !flag1 && !flag2)\tans.push_back(x), flag1 = flag2 = 1;\n\t}\n\tprintf(""%d\\n"", ans.size());\n\tfor (int i = 0; i < ans.size(); ++ i)\n\t\tprintf(""%d%c"", ans[i], i < ans.size() - 1 ? \' \' : \'\\n\');\n\n\treturn 0;\n}\n\n']","[0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1600
You are given a tuple generator f k f 1 k f 2 k dots f n k where f i k a i cdot f i k 1 b i bmod p i and f 0 x 1 x 2 dots x n Here x bmod y denotes the remainder of x when divided by y All p i are primes One can see that with fixed sequences x i y i a i the tuples f k starting from some index will repeat tuples with smaller indices Calculate the maximum number of different tuples from all f k for k ge 0 that can be produced by this generator if x i a i b i are integers in the range 0 p i 1 and can be chosen arbitrary The answer can be large so print the remainder it gives when divided by 10 9 7 ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,p[SZ],mr[2000555];\nbool np[2000555];\n#define S 6000000\nint fy[2000555];\nint ny[S],yy[S],an,cm[2000555];\nconst int MOD=1e9+7;\nmap<int,int> sb;\nbool go(int g)\n{\n\tint su=0;\n\tfor(int t=fy[g];t;t=ny[t])\n\t{\n\t\tint y=0;\n\t\twhile(g%yy[t]==0)\n\t\t\t++y,g/=yy[t];\n\t\tif(mr[yy[t]]>=y)\n\t\t\tcontinue;\n\t\tsu=1; mr[yy[t]]=y;\n\t}\n\treturn su;\n}\nint mc[2000555];\nvoid AA(int g)\n{\n\tfor(int t=fy[g];t;t=ny[t])\n\t{\n\t\tint y=0;\n\t\twhile(g%yy[t]==0)\n\t\t\t++y,g/=yy[t];\n\t\tif(mr[yy[t]]==y) ++mc[yy[t]];\n\t}\n}\nbool BB(int g)\n{\n\tbool must=0;\n\tfor(int t=fy[g];t;t=ny[t])\n\t{\n\t\tint y=0;\n\t\twhile(g%yy[t]==0)\n\t\t\t++y,g/=yy[t];\n\t\tif(mr[yy[t]]==y) must|=mc[yy[t]]==1;\n\t}\n\treturn must;\n}\nll zy[SZ]; int zn=0;\nint main()\n{\n\tfor(int i=2;i<=2000000;++i) if(!np[i])\n\t\tfor(int j=i;j<=2000000;j+=i)\n\t\t\t++an,yy[an]=i,ny[an]=fy[j],\n\t\t\tfy[j]=an,np[j]=1;\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(""%d"",p+i),++sb[-p[i]];\n\tint aa=0;\n\tfor(auto g:sb)\n\t{\n\t\tif(g.se<2) continue;\n\t\tint w=-g.fi;\n\t\tif(!go(w)) aa=1;\n\t\telse zy[++zn]=w;\n\t\tfor(int j=1;j<g.se;++j)\n\t\t\tif(!go(w-1)) aa=1;\n\t\t\telse zy[++zn]=w-1;\n\t}\n\tfor(auto g:sb)\n\t{\n\t\tif(g.se!=1) continue;\n\t\tint w=-g.fi;\n\t\tif(go(w)) zy[++zn]=w;\n\t\telse if(go(w-1)) zy[++zn]=w-1;\n\t\telse aa=1;\n\t}\n\tfor(int i=1;i<=zn;++i)\n\t\tAA(zy[i]);\n\tfor(int i=1;i<=zn;++i)\n\t\tif(!BB(zy[i])) aa=1;\n\tll ans=1;\n\tfor(int i=1;i<=2000000;++i)\n\t\twhile(mr[i]--) ans=ans*i%MOD;\n\tans+=aa;\n\tans=(ans%MOD+MOD)%MOD;\n\tcout<<ans<<""\\n"";\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2900
Today is Mashtali s birthday He received a tree from Haj Davood as his birthday present A directed tree is called a tree iff The length of the longest directed path in it is exactly n Every vertex has attached to it independent of their orientation Let s call vertices u and v friends if one of them has a directed path to the other For every pair of vertices u and v that are not friends there should exist a vertex w that is friends with both u and v a mutual friend After opening his gift Mashtali found out that the labels on the vertices were gone Immediately he asked himself how many different unlabeled Hagh trees are there That is how many possible trees could he have received as his birthday present At the first glance the number of such trees seemed to be infinite since there was no limit on the number of vertices but then he solved the problem and proved that Amazed by this fact he shared the task with you so that you could enjoy solving it as well Since the answer can be rather large he asked you to find the number of different unlabeled Hagh trees modulo 998244353 Here two trees are considered different if they are not isomorphic if there is no way to map nodes of one tree to the second tree so that edges are mapped to edges preserving the orientation Some examples for n 2 Directed trees D and E are Hagh C is not Hagh because it has a vertex with 4 edges attached to it A and B are not Hagh because their longest directed paths are not equal to n Also in B the leftmost and rightmost vertices are not friends neither do they have a mutual friend ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, ""MOD must be positive"");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tint n;\n\tcin >> n;\n\tvector<num> trees(n+1);\n\tvector<num> psums(n+1);\n\ttrees[0] = 1;\n\tpsums[0] = trees[0];\n\tnum inv2 = num(1) / num(2);\n\tnum inv6 = num(1) / num(6);\n\tfor(int k = 1; k <= n; k++){\n\t\tnum good = psums[k-1] + 1;\n\t\tnum bad = psums[k-1] - trees[k-1] + 1;\n\t\tnum res = good * (good+1) * inv2 - bad * (bad+1) * inv2;\n\t\ttrees[k] = res;\n\t\tpsums[k] = psums[k-1] + trees[k];\n\t}\n\tnum ans = 0;\n\tans += trees[n];\n\t{\n\t\tnum good = psums[n-1];\n\t\tnum bad = psums[n-1] - trees[n-1];\n\t\tans += (good * (good + 1) * (good + 2) * inv6 - bad * (bad + 1) * (bad + 2) * inv6) * 2;\n\t}\n\tfor(int t = 1; t <= n; t++){\n\t\tnum good = psums[t-1];\n\t\tnum bad = psums[t-1] - trees[t-1];\n\t\tnum top = good * (good + 1) * inv2 - bad * (bad + 1) * inv2;\n\t\tans += top * (t == n ? 1 : trees[n-1-t]);\n\t}\n\tcout << ans << \'\\n\';\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1]",2900
You are playing the game Arranging The Sheep The goal of this game is to make the sheep line up The level in the game is described by a string of length n consisting of the characters empty space and sheep In one move you can move any sheep one square to the left or one square to the right if the corresponding square The game ends as soon as the sheep are lined up that is there should be no empty cells between any sheep For example if n 6 and the level is described by the string then the following game scenario is possible the sheep at the 4 position moves to the right the state of the level the sheep at the 2 position moves to the right the state of the level the sheep at the 1 position moves to the right the state of the level the sheep at the 3 position moves to the right the state of the level the sheep at the 2 position moves to the right the state of the level the sheep are lined up and the game ends For a given level determine the minimum number of moves you need to make to complete the level ,"['#include ""bits/extc++.h""\n\nusing namespace std;\n\ntemplate<class T, class U = less<T>>\nusing rt = __gnu_pbds::tree<T, __gnu_pbds::null_type, U, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n\ntemplate<class T, class U>\nvoid sep(T &out, const string &s, const U &u) {\n\tout << u;\n}\n\ntemplate<class T, class Head, class ...Tail>\nvoid sep(T &out, const string &s, const Head &h, const Tail &...t) {\n\tout << h << s;\n\tsep(out, s, t...);\n}\n\n#ifdef DEBUG\n#define dbg(...)                                                      \\\ncerr << ""L"" << __LINE__ << "" ["" << #__VA_ARGS__ << ""]"" << "": "";       \\\nsep(cerr, "" | "", __VA_ARGS__);                                        \\\ncerr << endl\n#else\n#define cerr if(false) cerr\n#define dbg(...) cerr\n#endif\n\n//imagine a language where int = long\n#define long int64_t\n\n//typing too hard\n#define endl ""\\n""\n\n#define sz(x) int((x).size())\n\nvoid solve() {\n\tint n;\n\tstring s;\n\tcin >> n >> s;\n\tif(s.find(\'*\') == string::npos) {\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tvector<int> arr;\n\tfor(int i = 0; i < n; i++) {\n\t\tif(s[i] == \'*\'){\n\t\t\tarr.push_back(i);\n\t\t}\n\t}\n\tint m = n;\n\tn = sz(arr);\n\tint change[m] {};\n\tfor(int i = 0; i < n; i++) {\n\t\tchange[arr[i] - i]++;\n\t}\n\tlong ans = 1e18, cur = 0, lo = 0, hi = n;\n\tfor(int i = 0; i < n; i++) {\n\t\tdbg(arr[i], i);\n\t\tcur += abs(arr[i] - i);\n\t}\n\tfor(int i = 0; i <= m - n; i++) {\n\t\tdbg(i, ans, cur);\n\t\tans = min(ans, cur);\n\t\tlo += change[i];\n\t\thi -= change[i];\n\t\tcur += lo;\n\t\tcur -= hi;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin.exceptions(ios::failbit);\n#ifdef LOCAL\n\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tint t = 1;\n\tcin >> t;\n\tfor(int _ = 1; _ <= t; _++) {\n\t\tdbg(_);\n//\t\tcout << ""Case #"" << _ << "": "";\n\t\tsolve();\n\t}\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
The Floral Clock has been standing by the side of Mirror Lake for years Though unable to keep time it reminds people of the passage of time and the good old days On the rim of the Floral Clock are flowers numbered from to clockwise each of which has a colour among all possible ones For each colour there are exactly two flowers with it the between which Additionally if flowers and are of the same colour then flowers opposite to and opposite to should be of the same colour as well symmetry is beautiful Formally the between two flowers is plus the number of flowers on the minor arc or semicircle between them Below is a possible arrangement with that cover all possibilities The of an arrangement is defined to be the product of the lengths of flower segments separated by all opposite flowers of the same colour In other words in order to compute the beauty we remove from the circle all flowers that have the same colour as flowers opposite to them Then the beauty is the product of lengths of all remaining segments Note that we include segments of length in this product If there are no flowers that have the same colour as flower opposite to them the beauty equals For instance the of the above arrangement equals the segments are and While keeping the constraints satisfied there may be lots of different arrangements Find out the sum of over all possible arrangements modulo Two arrangements are considered different if a pair exists such that flowers and are of the same colour in one of them but not in the other ,"['//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=998244353;\nconst int proot=3;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==\' \'||c==\'\\n\')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(\' \')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar(\'\\n\')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!=\'-\'&&(c<\'0\'||c>\'9\'))c=_buff.get();\n\tif(c==\'-\')ng=1,c=_buff.get();\n\twhile(c>=\'0\'&&c<=\'9\')r=r*10+c-\'0\',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar(\'-\'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar(\'0\');\n\tfor(int i=sz-1;i>=0;i--)putchar(\'0\'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==\' \'||c==\'\\n\')c=_buff.get();return c;}\n\nint n,g[50111],g0[50111],g1[50111],g2[50111];\nint f0[50111],f1[50111],f2[50111];\n\nconst int FFTmx=150111;\nconst int FFTpmx=131072;\nint bitrev_pre[FFTmx],bitrev[FFTmx],fsz;\nint w_pre[FFTmx],w[FFTmx];\nvoid FFTinit(int sz)\n{\n\tfsz=1;\n\twhile(fsz<sz)fsz<<=1;\n\tint tmp=__builtin_ctz(FFTpmx/fsz);\n\tfor(int i=0;i<fsz;i++)bitrev[i]=bitrev_pre[i]>>tmp;\n}\nll qpow(ll x,ll k){return k==0?1:qpow(x*x%mod,k>>1)*(k&1?x:1)%mod;}\nvoid FFT(int a[],int coef)\n{\n\tfor(int i=0;i<fsz;i++)if(i<bitrev[i])swap(a[i],a[bitrev[i]]);\n\tfor(int l=1;l<fsz;l<<=1)\n\t{\n\t\tint l2=l+l,u=FFTpmx/l2;\n\t\tif(coef==1)for(int j=0;j<l;j++)w[j]=w_pre[u*j];\n\t\telse for(int j=0;j<l;j++)w[j]=w_pre[FFTpmx-u*j];\n\t\tfor(int i=0;i<fsz;i+=l2)\n\t\t{\n\t\t\tfor(int j=0;j<l;j++)\n\t\t\t{\n\t\t\t\tint tmp=1ll*a[i+l+j]*w[j]%mod;\n\t\t\t\ta[i+l+j]=a[i+j]-tmp<0?a[i+j]-tmp+mod:a[i+j]-tmp;\n\t\t\t\ta[i+j]=a[i+j]+tmp>=mod?a[i+j]+tmp-mod:a[i+j]+tmp;\n\t\t\t}\n\t\t}\n\t}\n\tif(coef==-1)\n\t{\n\t\tll inv=qpow(fsz,mod-2);\n\t\tfor(int i=0;i<fsz;i++)a[i]=a[i]*inv%mod;\n\t}\n}\nvoid FFTprecalc()\n{\n\tfor(int i=1;i<FFTpmx;i++)bitrev_pre[i]=bitrev_pre[i>>1]>>1|(i&1?FFTpmx>>1:0);\n\tw_pre[0]=1;\n\tint ww=qpow(proot,(mod-1)/FFTpmx);\n\tfor(int i=1;i<=FFTpmx;i++)w_pre[i]=1ll*w_pre[i-1]*ww%mod;\n}\nint ta[FFTmx],tb[FFTmx],tc[FFTmx];\nvoid push(int a[],int asz,int b[],int bsz,int c[],int cl,int cr)\n{\n\tFFTinit(asz+bsz);\n\tfor(int i=0;i<fsz;i++)ta[i]=i<asz?a[i]:0;\n\tfor(int i=0;i<fsz;i++)tb[i]=i<bsz?b[i]:0;\n\tFFT(ta,1);\n\tFFT(tb,1);\n\tfor(int i=0;i<fsz;i++)tc[i]=1ll*ta[i]*tb[i]%mod;\n\tFFT(tc,-1);\n\tassert(cr<=fsz);\n\tfor(int i=cl;i<=cr;i++)c[i]=c[i]+tc[i]>=mod?c[i]+tc[i]-mod:c[i]+tc[i];\n}\nvoid solve(int l,int r)\n{\n//\tcerr<<""solve:""<<l<<"",""<<r<<endl;\n\tif(r-l<=500)\n\t{\n\t\tfor(int i=l;i<=r;i++)\n\t\t{\n\t\t\tfor(int j=l;j<i;j++)\n\t\t\t{\n\t\t\t\tf0[i]=(f0[i]+1ll*f0[j]*g0[i-j]+1ll*f1[j]*g1[i-j])%mod;\n\t\t\t\tf1[i]=(f1[i]+1ll*f0[j]*g1[i-j]+1ll*f1[j]*g2[i-j])%mod;\n\t\t\t\tf2[i]=(f2[i]+1ll*f2[j]*g2[i-j]+1ll*f1[j]*g1[i-j])%mod;\n\t\t\t}\n\t\t\tf0[i]=(f0[i]+g0[i])%mod;\n\t\t\tf1[i]=(f1[i]+g1[i])%mod;\n\t\t\tf2[i]=(f2[i]+g2[i])%mod;\n\t\t}\n\t\treturn;\n\t}\n\tint m=l+r>>1;\n\tsolve(l,m);\n\tpush(f0+l,m+1-l,g0,r+1-l,f0+l,m+1-l,r-l);\n\tpush(f1+l,m+1-l,g1,r+1-l,f0+l,m+1-l,r-l);\n\tpush(f0+l,m+1-l,g1,r+1-l,f1+l,m+1-l,r-l);\n\tpush(f1+l,m+1-l,g2,r+1-l,f1+l,m+1-l,r-l);\n\tpush(f2+l,m+1-l,g2,r+1-l,f2+l,m+1-l,r-l);\n\tpush(f1+l,m+1-l,g1,r+1-l,f2+l,m+1-l,r-l);\n\tsolve(m+1,r);\n}\nint main()\n{\n\tFFTprecalc();\n\tcin>>n;\n//\tn=50000;\n\tg[0]=g[2]=1;\n\tfor(int i=4;i<=n;i+=2)g[i]=(g[i-2]+g[i-4])%mod;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tg0[i+1]=1ll*g[i]*i*i%mod;\n\t\tg1[i+1]=1ll*g[i-1]*i*i%mod;\n\t\tif(i>=2)g2[i+1]=1ll*g[i-2]*i*i%mod;\n\t}\n\tsolve(0,n);\n\tll ans=0;\n\tans=1ll*(g[n-1]+g[n-3])*n%mod*(n-1)%mod*(n-1)%mod;\n\tfor(int i=2;i<n;i++)\n\t{\n\t\tint l=i,r=n-i;\n\t\tll curans=0;\n\t\tcurans+=1ll*g[l-1]*f0[r]%mod;\n\t\tcurans+=1ll*g[l-2]*f1[r]%mod;\n\t\tcurans+=1ll*g[l-2]*f1[r]%mod;\n\t\tif(l>=3)curans+=1ll*g[l-3]*f2[r]%mod;\n\t\tcurans=curans%mod*(i-1)%mod*(i-1)%mod;\n\t\tans+=1ll*curans*i%mod;\n\t}\n\tcout<<ans%mod<<endl;\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",3400
You have a tree of n vertices You are going to convert this tree into n rubber bands on infinitely large plane Conversion rule follows For every pair of vertices a and b rubber bands a and b should intersect if and only if there is an edge exists between a and b in the tree Shape of rubber bands must be a simple loop In other words rubber band is a loop which doesn t self intersect Now let s define following things Rubber band a rubber band b if and only if rubber band b is in rubber band a s area and they don t intersect each other Sequence of rubber bands a 1 a 2 ldots a k k ge 2 are if and only if for all i 2 le i le k a i 1 includes a i This is an example of conversion Note that rubber bands 5 and 6 are nested It can be proved that is it possible to make a conversion and sequence of nested rubber bands under given constraints What is the maximum length of sequence of nested rubber bands can be obtained from given tree Find and print it ,"[""/**\n *    author:  tourist\n *    created: 12.04.2020 18:15:51       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> take(n);\n  vector<int> nope(n);\n  int ans = 0;\n  function<void(int, int)> Dfs = [&](int v, int pr) {\n    vector<int> children;\n    for (int u : g[v]) {\n      if (u == pr) {\n        continue;\n      }\n      Dfs(u, v);\n      children.push_back(u);\n    }\n    {\n      take[v] = 0;\n      for (int u : children) {\n        take[v] = max(take[v], nope[u]);\n      }\n      take[v] += 1;\n    }\n    {\n      nope[v] = 0;\n      for (int u : children) {\n        nope[v] = max(nope[v], max(nope[u], take[u]));\n      }\n      nope[v] += (int) g[v].size() - 2;\n    }\n    {\n      int m1 = 0, m2 = 0;\n      for (int u : children) {\n        if (nope[u] > m1) {\n          m2 = m1;\n          m1 = nope[u];\n        } else {\n          m2 = max(m2, nope[u]);\n        }\n      }\n      ans = max(ans, m1 + m2 + 1);\n    }\n    {\n      int m1 = 0, m2 = 0;\n      for (int u : children) {\n        int cur = max(nope[u], take[u]);\n        if (cur > m1) {\n          m2 = m1;\n          m1 = cur;\n        } else {\n          m2 = max(m2, cur);\n        }\n      }\n      ans = max(ans, m1 + m2 + (int) g[v].size() - 2);\n    }\n  };\n  Dfs(0, -1);\n  cout << ans << '\\n';\n  return 0;\n}\n""]","[0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0]",2700
You are given a rectangle grid That grid s size is Let s denote the coordinate system on the grid So each point on the grid will have coordinates a pair of integers Your task is to find a maximum sub rectangle on the grid so that it contains the given point and its length width ratio is exactly In other words the following conditions must hold The sides of this sub rectangle should be parallel to the axes And values should be integers If there are multiple solutions find the rectangle which is closest to Here closest means the Euclid distance between and the center of the rectangle is as small as possible If there are still multiple solutions find the lexicographically minimum one Here lexicographically minimum means that we should consider the sub rectangle as sequence of integers so we can choose the lexicographically minimum one ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nint gcd(int a, int b) {\n    while (a && b) {\n        a > b ? a %= b : b %= a;\n    }\n    return a + b;\n}\n\nint n, m, x, y;\nint sx, sy;\n\nLL dist(int x1, int y1) {\n    LL dx = 2 * (LL) x1 + (LL) sx - 2 * (LL) x;\n    LL dy = 2 * (LL) y1 + (LL) sy - 2 * (LL) y;\n    return dx * dx + dy * dy;\n}\n\nbool check(int x1, int y1) {\n    return x1 <= x && x1 + sx >= x && y1 <= y && y1 + sy >= y && x1 + sx <= n && y1 + sy <= m && x1 >= 0 && y1 >= 0;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    int a, b;\n    cin >> n >> m >> x >> y >> a >> b;\n    int g = gcd(a, b);\n    a /= g;\n    b /= g;\n    int coef = min(n / a, m / b);\n    sx = coef * a;\n    sy = coef * b;\n    pair<LL, PII> res = MP((LL) ((1ULL << 63) - 1), MP(0, 0));\n    vector<PII> options;\n    vector<int> xs;\n    xs.PB(0);\n    xs.PB(n - sx);\n    xs.PB(x - sx / 2);\n    xs.PB(x - sx / 2 - 1);\n    vector<int> ys;\n    ys.PB(0);\n    ys.PB(m - sy);\n    ys.PB(y - sy / 2);\n    ys.PB(y - sy / 2 - 1);\n    FORE (it, xs) {\n        FORE (jt, ys) {\n            if (check(*it, *jt)) {\n                res = min(res, MP(dist(*it, *jt), MP(*it, *jt)));\n            }\n        }\n    }\n    cout << res.ND.ST << "" "" << res.ND.ND << "" "" << res.ND.ST + sx << "" "" << res.ND.ND + sy << endl;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Merge sort is a well known sorting algorithm The main function that sorts the elements of array with indices from can be implemented as follows If the segment is already sorted in non descending order that is for any such that then end the function call Let Call Call Merge segments and making the segment sorted in non descending order The merge algorithm doesn t call any other functions The array in this problem is indexed so to sort the whole array you need to call The number of calls of function is very important so Ivan has decided to calculate it while sorting the array For example if then there will be call of which will check that the array is sorted and then end If then the number of calls is first of all you call which then sets and calls and which do not perform any recursive calls because segments and are sorted Ivan has implemented the program that counts the number of calls but now he needs to test it To do this he needs to find an array such that is a permutation of size that is the number of elements in is and every integer number from can be found in this array and the number of calls when sorting the array is exactly Help Ivan to find an array he wants ,"['#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nconst int nmax = 100500;\n\nint dp[nmax];\n\nvector<int> ans;\nbool ok = true;\n\nvoid solve(int lf, int rg, int k, int a, int b) {\n\tif (k == 1) {\n\t\tfor (int i = lf; i <= rg; ++i) {\n\t\t\tans[i] = a + (i - lf);\n\t\t}\n\t\treturn;\n\t}\n\tif (k <= 2) {\n\t\tok = false;\n\t\treturn;\n\t}\n\tint l = lf, r = rg + 1;\n\tint m = (l + r) >> 1;\n\t--k;\n\tif (dp[m - l] + 1 >= k) {\n\t\tsolve(lf, m - 1, k - 1, a + rg - m + 1, b);\n\t\tfor (int i = m; i <= rg; ++i) {\n\t\t\tans[i] = a + (i - m);\n\t\t}\n\t} else {\n\t\tk -= dp[m - l];\n\t\tsolve(lf, m - 1, dp[m - l], a + rg - m + 1, b);\n\t\tsolve(m, rg, k, a, a + rg - m);\n\t}\n}\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(""input.txt"");\n\t//ofstream cout(""output.txt"");\n\n\tdp[1] = 1;\n\tfor (int n = 2; n < nmax; ++n) {\n\t\tint l = 0, r = n;\n\t\tint m = (l + r) >> 1;\n\t\tdp[n] = 1 + dp[m - l] + dp[r - m];\n\t}\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (dp[n] < k) {\n\t\tcout << ""-1\\n"";\n\t\treturn 0;\n\t}\n\n\tans.resize(n);\n\tsolve(0, n - 1, k, 1, n);\n\n\tif (!ok) {\n\t\tcout << ""-1\\n"";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << ans[i] << "" "";\n\t}\n\tcout << ""\\n"";\n\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
You are given strings S and T consisting of lowercase English letters It is guaranteed that T is a permutation of the string Find string S the permutation of S such that T is a subsequence of S String a is a of string b if the number of occurrences of each distinct character is the same in both strings A string a is a of a string b if a can be obtained from b by deletion of several possibly zero or all elements A string a is than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tfor (cin >> t; t; t -= 1) {\n\t\tstring S, T;\n\t\tcin >> S >> T;\n\t\tranges::sort(S);\n\t\tif (T != ""abc"" or S[0] != \'a\') cout << S << ""\\n"";\n\t\telse {\n\t\t\tfor (int i = 0; i < 26; i += 1)\n\t\t\t\tfor (char c : S) {\n\t\t\t\t\tif (i == 0 or i >= 3) {\n\t\t\t\t\t\tif (c == \'a\' + i) cout << c;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == \'a\' + 3 - i) cout << c;\n\t\t\t\t}\n\t\t\tcout << ""\\n"";\n\t\t}\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0]",800
You are given a rooted tree It contains n vertices which are numbered from 1 to n The root is the vertex 1 Each edge has two positive integer values Thus two positive integers a j and b j are given for each edge Output n 1 numbers r 2 r 3 dots r n where r i is defined as follows Consider the path from the root vertex 1 to i 2 le i le n Let the sum of the costs of a j along this path be A i Then r i is equal to the length of the maximum prefix of this path such that the sum of b j along this prefix does not exceed A i Consider an example In this case r 2 0 since the path to 2 has an amount of a j equal to 5 only the prefix of this path of length 0 has a smaller or equal amount of b j r 3 3 since the path to 3 has an amount of a j equal to 5 9 5 19 the prefix of length 3 of this path has a sum of b j equal to 6 10 1 17 the number is 17 le 19 r 4 1 since the path to 4 has an amount of a j equal to 5 9 14 the prefix of length 1 of this path has an amount of b j equal to 6 this is the longest suitable prefix since the prefix of length 2 already has an amount of b j equal to 6 10 16 which is more than 14 r 5 2 since the path to 5 has an amount of a j equal to 5 9 2 16 the prefix of length 2 of this path has a sum of b j equal to 6 10 16 this is the longest suitable prefix since the prefix of length 3 already has an amount of b j equal to 6 10 1 17 what is more than 16 r 6 1 since the path up to 6 has an amount of a j equal to 2 the prefix of length 1 of this path has an amount of b j equal to 1 r 7 1 since the path to 7 has an amount of a j equal to 5 3 8 the prefix of length 1 of this path has an amount of b j equal to 6 this is the longest suitable prefix since the prefix of length 2 already has an amount of b j equal to 6 3 9 which is more than 8 r 8 2 since the path up to 8 has an amount of a j equal to 2 4 6 the prefix of length 2 of this path has an amount of b j equal to 1 3 4 r 9 3 since the path to 9 has an amount of a j equal to 2 4 1 7 the prefix of length 3 of this path has a sum of b j equal to 1 3 3 7 ,"['/*\nDiv 3, I literally don\'t care edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=2e5+5,mod=1e9+7;\nll n,c,k,a[N],b[N],g[N][21],p[N],h[N];\nll s[N],t[N];\nvector<ll> ke[N];\nvoid dfs (ll u){\n    rv(v,ke[u]){\n        h[v]=h[u]+1;\n        s[v]=s[u]+a[v];\n        t[v]=t[u]+b[v];\n        dfs(v);\n    }\n}\nvoid prep(){\n    rep(i,1,19)\n    rep(j,1,n) g[j][i]=g[g[j][i-1]][i-1];\n}\nll par (ll u, ll h){\n    rep(i,0,19) if (h&(1<<i)) u=g[u][i];\n    return u;\n}\nvoid solo()\n{\n   cin>>n;\n   rep(i,2,n){\n       cin>>p[i]>>a[i]>>b[i];\n       ke[p[i]].pb(i);\n       g[i][0]=p[i];\n   }\n   prep();\n   dfs(1);\n   rep(i,2,n){\n       ll l=0,r=h[i],res=0;\n       while (l<=r){\n           ll mid=(l+r)/2;\n           if (t[par(i,mid)]<=s[i]) res=mid,r=mid-1;\n           else l=mid+1;\n       }\n       res=h[i]-res;\n       cout<<res<<"" "";\n   }\n   rep(i,0,n)\n   rep(j,0,20) g[i][j]=0;\n   rep(i,1,n) ke[i].clear(),h[i]=0;\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0]",1700
You are given a sequence a a 1 a 2 dots a n consisting of n integers Let s call a group of consecutive elements a Each is characterized by two indices the index of its left end and the index of its right end Denote by a l r a of the sequence a with the left end in l and the right end in r i e a l r a l a l 1 dots a r For example if a 31 4 15 92 6 5 then a 2 5 4 15 92 6 a 5 5 6 a 1 6 31 4 15 92 6 5 are We split the given sequence a into so that each element is in one the sums of elements for all are For example if a 55 45 30 30 40 100 then such a sequence can be split into three a 1 2 55 45 a 3 5 30 30 40 a 6 6 100 Each element belongs to exactly the sum of the elements of each is 100 Let s define of split as the length of the longest For example the thickness of the split from the example above is 3 Find the minimum thickness among all possible splits of the given sequence of a into in the required way ,"['#include <bits/stdc++.h>\n#define dprintf(...) printf(__VA_ARGS__)\nusing namespace std;\ntypedef long long LL;\n\nint N, A[2010];\n\nbool check(int max_len) {\n  int sum = 0;\n  for (int i = 0; i < N && i < max_len; i++) {\n    sum += A[i];\n\n    int j = i+1, js = 0, jn = 0;\n    bool good = true;\n    while (j < N) {\n      js += A[j++];\n      jn += 1;\n      if (js > sum || jn > max_len) { good = false; break; }\n      if (js == sum) {\n        js = 0;\n        jn = 0;\n      }\n    }\n    if (good && js == 0 && jn == 0) return true;\n  }\n\n  return false;\n}\n\nvoid solve() {\n  cin >> N;\n  for (int i = 0; i < N; i++) cin >> A[i];\n\n  // (l, r]\n  int l = 0, r = N;\n  while (r - l > 1) {\n    int m = (l + r) / 2;\n    if (check(m)) {\n      r = m;\n    } else {\n      l = m;\n    }\n  }\n\n  printf(""%d\\n"", r);\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n\n  int T; cin >> T;\n  for (int cs = 1; cs <= T; cs++) {\n    solve();\n  }\n}\n']","[1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Lord Tirek is a centaur and the main antagonist in the season four finale episodes in the series My Little Pony Friendship Is Magic In Twilight s Kingdom Part 1 Tirek escapes from Tartarus and drains magic from ponies to grow stronger The core skill of Tirek is called Absorb Mana It takes all mana from a magic creature and gives them to the caster Now to simplify the problem assume you have ponies numbered from 1 to Each pony has three attributes amount of mana that the pony has at time 0 maximum mana that the pony can have mana regeneration per unit time Lord Tirek will do instructions each of them can be described with three integers The instruction means that at time Tirek will use Absorb Mana on ponies with numbers from to both borders inclusive We ll give you all the instructions in order count how much mana Tirek absorbs for each instruction ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n;\n\nstruct inode {\n\tint lastUsed;\n};\n\nconst int BT = 131072;\n\ninode itree[BT*2];\n\nint s[100003],maxmana[100003],regen[100003];\n\nlong long ans[100003];\nint ansi;\n\nstruct adjust\n{\n\tint regen; // regen time\n\tint ansIndex;\n\tint l;\n\tint r;\n};\n\ninline bool sf(const adjust &a, const adjust &b) {\n\treturn a.regen < b.regen;\n}\n\nvector<adjust> events;\n\nvoid updateTree(int ind, int l, int r, int ql, int qr, int t, bool needUpdate = true) {\n\tif (r < ql || l > qr) return;\n\tint m = (l+r+1)>>1;\n\tif (ql <= l && r <= qr) {\n\t\tif (itree[ind].lastUsed < 0) {\n\t\t\tif (ind >= BT) {\n\t\t\t\tans[ansi] += min(s[ind-BT] + regen[ind-BT] * (long long)t, (long long)maxmana[ind-BT]);\n\t\t\t} else {\n\t\t\t\tupdateTree(ind<<1, l, m-1, ql, qr, t, false);\n\t\t\t\tupdateTree((ind<<1)+1, m, r, ql, qr, t, false);\n\t\t\t}\n\t\t} else {\n\t\t\tadjust adj;\n\t\t\tadj.regen = t - itree[ind].lastUsed;\n\t\t\tadj.ansIndex = ansi;\n\t\t\tadj.l = l;\n\t\t\tadj.r = r;\n\t\t\tevents.push_back(adj);\n\t\t}\n\t\tif (needUpdate) {\n\t\t\titree[ind].lastUsed = t;\n\t\t}\n\t\treturn;\n\t}\n\tif (itree[ind].lastUsed >= 0) {\n\t\titree[ind<<1].lastUsed = itree[ind].lastUsed;\n\t\titree[(ind<<1)+1].lastUsed = itree[ind].lastUsed;\n\t\titree[ind].lastUsed = -1;\n\t}\n\tupdateTree(ind<<1, l, m-1, ql, qr, t, needUpdate);\n\tupdateTree((ind<<1)+1, m, r, ql, qr, t, needUpdate);\n}\n\nstruct inode2 {\n\tlong long bcnt;\n\tlong long bsum;\n} itree2[BT*2];\n\nvoid update2(int p, long long regenrate, long long val) {\n\tp += BT;\n\twhile(p) {\n\t\titree2[p].bcnt -= regenrate;\n\t\titree2[p].bsum += val;\n\t\tp >>= 1;\n\t}\n}\n\npair<long long, long long> getBounded(int l, int r) {\n\tlong long cnt = 0;\n\tlong long sum = 0;\n\tl += BT;\n\tr += BT;\n\twhile(l <= r) {\n\t\tif (l&1){\n\t\t\tcnt += itree2[l].bcnt;\n\t\t\tsum += itree2[l].bsum;\n\t\t}\n\t\tif (!(r&1)){\n\t\t\tcnt += itree2[r].bcnt;\n\t\t\tsum += itree2[r].bsum;\n\t\t}\n\t\tl = (l+1)>>1;\n\t\tr = (r-1)>>1;\n\t}\n\treturn make_pair(cnt, sum);\n}\n\nint main(){\n\tscanf(""%d"",&n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(""%d%d%d"",&s[i],&maxmana[i],&regen[i]);\n\t}\n\tfor(int i = 0; i < BT*2; i++) {\n\t\titree[i].lastUsed = -2;\n\t}\n\tint m;\n\tscanf(""%d"",&m);\n\tfor(int i = 0; i < m; i++) {\n\t\tint t,l,r;\n\t\tscanf(""%d%d%d"",&t,&l,&r);\n\t\tl--,r--;\n\t\tansi = i;\n\t\tupdateTree(1,0,BT-1,l,r,t);\n\t}\n\tsort(events.begin(),events.end(),sf);\n\tvector<pair<int,int>> ponyMaxReach;\n\tfor(int i = 0; i < n; i++) {\n\t\tif (regen[i] != 0) {\n\t\t\tponyMaxReach.emplace_back((maxmana[i]+regen[i]-1) / regen[i], i);\n\t\t}\n\t\titree2[i+BT].bcnt = regen[i];\n\t}\n\tfor(int i = BT-1; i >= 1; i--) {\n\t\titree2[i].bcnt = itree2[i<<1].bcnt + itree2[(i<<1)+1].bcnt;\n\t}\n\tsort(ponyMaxReach.begin(),ponyMaxReach.end());\n\tfor(int i = 0, j = 0; i < events.size(); i++) {\n\t\tfor(;j < ponyMaxReach.size() && ponyMaxReach[j].first <= events[i].regen;j++) {\n\t\t\tint ponyInd = ponyMaxReach[j].second;\n\t\t\tupdate2(ponyInd, regen[ponyInd], maxmana[ponyInd]);\n\t\t}\n\t\tauto res = getBounded(events[i].l, events[i].r);\n\t\tans[events[i].ansIndex] += res.first * events[i].regen + res.second;\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tprintf(""%lld\\n"", ans[i]);\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3100
There are n pillars aligned in a row and numbered from 1 to n Initially each pillar contains exactly one disk The i th pillar contains a disk having radius a i You can move these disks from one pillar to another You can take a disk from pillar i and place it on top of pillar j if all these conditions are met there is no other pillar between pillars i and j Formally it means that i j 1 pillar i contains one disk either pillar j contains no disks or the topmost disk on pillar j has radius strictly greater than the radius of the disk you move When you place a disk on a pillar that already has some disks on it you put the new disk on top of previously placed disks so the new disk will be used to check the third condition if you try to place another disk on the same pillar You may take any disk and place it on other pillar any number of times provided that every time you do it all three aforementioned conditions are met Now you wonder is it possible to place all n disks on the same pillar simultaneously ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nint n;\nint a[N];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tint m = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (a[i] > a[m])\n\t\t\tm = i;\n\tfor (int i = m; i > 0; i--) {\n\t\tif (a[i] < a[i - 1]) {\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = m; i < n - 1; i++) {\n\t\tif (a[i] < a[i + 1]) {\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(""YES\\n"");\n\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
During Zhongkao examination Reycloer met an interesting problem but he cannot come up with a solution immediately Time is running out Please help him Initially you are given an array a consisting of n ge 2 integers and you want to change all elements in it to 0 In one operation you select two indices l and r 1 le l le r le n and do the following Let s a l oplus a l 1 oplus ldots oplus a r where oplus denotes the bitwise XOR operation Then for all l le i le r replace a i with s You can use the operation above in any order at most 8 times in total Find a sequence of operations such that after performing the operations in order all elements in a are equal to 0 It can be proven that the solution always exists ,"['// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2"")\n#include <bits/stdc++.h>\n// #define int long long\n#define i64 long long\n#define pii pair <int, int> \nusing namespace std;\ninline int read(void) {\n    int x=0,sgn=1; char ch=getchar();\n    while(ch<48||57<ch) {if(ch==45)sgn=0;ch=getchar();}\n    while(47<ch&&ch<58) {x=x*10+ch-48;   ch=getchar();}\n    return sgn? x:-x;\n}\nvoid write(int x) {\n    if(x<0) putchar(\'-\'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+\'0\');\n}\nint n;\nint a[100005];\ninline void work() {\n    n=read();\n    for(int i=1; i<=n; ++i) a[i]=read();\n    if(n%2==0) cout<<""2\\n1 ""<<n<<endl<<""1 ""<<n<<endl;\n    else cout<<""4\\n1 ""<<n-1<<endl<<""1 ""<<n-1<<endl<<""2 ""<<n<<endl<<""2 ""<<n<<endl;\n}\nsigned main() {\n    int T=read();\n    while(T--) work();\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
There are n models in the shop numbered from 1 to n with sizes s 1 s 2 ldots s n Orac will buy some of the models and will arrange them in the order of increasing numbers i e indices but not sizes Orac thinks that the obtained arrangement is if for any two adjacent models with indices i j and i j 1 note that i j i j 1 because Orac arranged them properly i j 1 is divisible by i j and s i j s i j 1 For example for 6 models with sizes 3 6 7 7 7 7 he can buy models with indices 1 2 and 6 and the obtained arrangement will be beautiful Also note that the arrangement with exactly one model is also considered beautiful Orac wants to know the maximum number of models that he can buy and he may ask you these queries many times ,"['#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\nusing namespace std;\nint t,n,a[N],dp[N],ansn;\nint main(){\n\tcin>>t;\n\twhile (t--){\n\t\tcin>>n;ansn=0;\n\t\tfor (int i=1;i<=n;i++)cin>>a[i],dp[i]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tfor (int j=i+i;j<=n;j+=i)if (a[j]>a[i])dp[j]=max(dp[j],dp[i]+1);\n\t\t\tansn=max(ansn,dp[i]);\n\t\t}\n\t\tcout<<ansn<<endl;\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1400
Gerald found a table consisting of rows and columns As a prominent expert on rectangular tables he immediately counted the table s properties that is the minimum of the numbers in the corners of the table minimum of four numbers However he did not like the final value it seemed to be too small And to make this value larger he decided to crop the table a little delete some columns on the left and some on the right as well as some rows from the top and some from the bottom Find what the maximum property of the table can be after such cropping Note that the table should have at least two rows and at least two columns left in the end The number of cropped rows or columns from each of the four sides can be zero ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\nint a,b,c,d,n,m,k;\nunsigned q[1001][32];\nint mas[1002][1002];\ninline bool check(int xx) {\n\trept(i, n) memset(q[i], 0, sizeof(q[i]));\n\trept(i, n) {\n\t\trept(j, m) {\n\t\t\tif (mas[i][j] >= xx) {\n\t\t\t\tq[i][j >> 5] |= 1u << (j & 31);\n\t\t\t}\n\t\t}\n\t}\n\n\tint lim = (m + 31) / 32;\n\trept(i, n) {\n\t\tFOR(j, i + 1, n - 1) {\n\t\t\tbool ok = 0;\n\t\t\trept(z, lim) {\n\t\t\t\tint t = q[i][z] & q[j][z];\n\t\t\t\tif (t) {\n\t\t\t\t\tif (t & (t - 1)) return 1;\n\t\t\t\t\tif (ok) return 1;\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar buf[65537], *ch = buf;\ninline char get_char()\n{\n       if (*ch==0)\n       {\n            ch=buf;\n            fread(buf,sizeof(char),65536,stdin);\n       }\n       return *(ch++);\n}\n\n\ninline void next_int(int &ans)\n{\n       char ch;\n       while ((ch=get_char())<\'0\' || ch>\'9\');\n       do\n       {\n               ans=ans*10+ch-\'0\';\n       }\n       while ((ch=get_char())>=\'0\' && ch<=\'9\');\n}\n\nint main() {\n\t//freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n\t\n\n\tnext_int(n); next_int(m);\n\trept(i, n) {\n\t\trept(j, m) {\n\t\t\tnext_int(mas[i][j]);\n\t\t}\n\t}\n\n\tint l = -1, r = INF + 1;\n\twhile (r - l > 1) {\n\t\tint xx = (r + l) / 2;\n\t\tif (!check(xx)) r = xx; else\n\t\tl = xx;\n\t}\n\tprintf(""%d\\n"", l);\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0]",2100
You are given three integers a b and x Your task is to construct a binary string s of length n a b such that there are exactly a zeroes exactly b ones and exactly x indices i where 1 le i n such that s i ne s i 1 It is guaranteed that the answer always exists For example for the string there are four indices i such that 1 le i n and s i ne s i 1 i 1 2 3 4 For the string there are two such indices i i 3 5 Recall that binary string is a non empty sequence of characters where each character is either or ,"['#include ""bits/stdc++.h""\n#define MAXN 100009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<""----------------""<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(__typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\n#define debug(x)  cerr<< #x <<"" = ""<< x<<endl;\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\n\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nint a,b,x;\n\nint main()\n{\n    //~ freopen(""file.in"", ""r"", stdin);\n    scanf(""%d%d%d"", &a,&b,&x);\n    string s=""0"";a --;\n    if(a < b)\n    \ts[0] ++, b --, a ++;\n    for(int i = 1; i <= x; i ++){\n    \ts.pb(\'1\' - s[i - 1] + \'0\');\n    \tif(s[i] == \'1\')\n    \t\tb --;\n    \telse\n    \t\ta --;\n    }\n    for(int i = 0; i <= x; i ++){\n    \tcout << s[i];\n        while(s[i] == \'0\' && a){\n            cout << 0;\n            a --;\n        }\n        while(s[i] == \'1\' && b){\n            cout << 1;\n            b --;\n        }\n    }\t\n\treturn 0;\n}\n\n\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Little Vova studies programming in an elite school Vova and his classmates are supposed to write progress tests for each test they will get a mark from 1 to Vova is very smart and he can write every test for any mark but he doesn t want to stand out from the crowd too much If the sum of his marks for all tests exceeds value then his classmates notice how smart he is and start distracting him asking to let them copy his homework And if the median of his marks will be lower than points then his mom will decide that he gets too many bad marks and forbid him to play computer games Vova has already wrote tests and got marks He doesn t want to get into the first or the second situation described above and now he needs to determine which marks he needs to get for the remaining tests Help him do that ,"['#include<bits/stdc++.h>\n#define sz(x) int((x).size())\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> PII;\ntypedef std::pair<ll,ll> PLL;\n\ntemplate<class T> inline T pr(T x) { return --x; }\ntemplate<class T> inline T nx(T x) { return ++x; }\n\nconst int maxn = 1010;\nint n,K,p,x,y,cnt,c1,cy,a[maxn],sum;\n\nint main() {\n    int i,j,k,t,tt,T,Test;\n    scanf(""%d%d%d%d%d"",&n,&K,&p,&x,&y);\n    for (i=1; i<=K; ++i) {\n        scanf(""%d"",a+i);\n        if (a[i]<y) ++cnt;\n        sum += a[i];\n    }\n    if (cnt<=n/2) {\n        c1 = min(n/2-cnt,n-K);\n        cy = n-c1-K;\n        sum += c1 + cy*y;\n        if (sum>x) { puts(""-1""); return 0; }\n        for (i=1; i<=c1; ++i) printf(""%d "",1);\n        for (i=1; i<=cy; ++i) printf(""%d "",y);\n        puts("""");\n    }\n    else puts(""-1"");\n\n    return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
William arrived at a conference dedicated to cryptocurrencies Networking meeting new people and using friends connections are essential to stay up to date with the latest news from the world of cryptocurrencies The conference has n participants who are initially unfamiliar with each other William can introduce any two people a and b who were not familiar before to each other William has d conditions i th of which requires person x i to have a connection to person y i Formally two people x and y have a connection if there is such a chain p 1 x p 2 p 3 dots p k y for which for all i from 1 to k 1 it s true that two people with numbers p i and p i 1 know each other For every i 1 le i le d William wants you to calculate the maximal number of acquaintances one person can have assuming that William satisfied all conditions from 1 and up to and including i and performed i introductions The conditions are being checked after William performed i introductions The answer for each i must be calculated independently It means that when you compute an answer for i you should assume that no two people have been introduced to each other yet ,"[""/**\n *    author:  tourist\n *    created: 28.11.2021 17:43:04       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n  vector<int> sz;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n    sz.assign(n, 1);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      sz[y] += sz[x];\n      sz[x] = 0;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, dd;\n  cin >> n >> dd;\n  dsu d(n);\n  int cc = 1;\n  for (int it = 1; it <= dd; it++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    if (!d.unite(x, y)) {\n      cc += 1;\n    }\n    vector<int> b;\n    for (int i = 0; i < n; i++) {\n      if (d.get(i) == i) {\n        b.push_back(d.sz[i]);\n      }\n    }\n    sort(b.rbegin(), b.rend());\n    assert(cc <= (int) b.size());\n    cout << accumulate(b.begin(), b.begin() + cc, 0) - 1 << '\\n';\n  }\n  return 0;\n}\n""]","[1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",1600
Alice and Bob are playing a game on a matrix consisting of 2 rows and m columns The cell in the i th row in the j th column contains a i j coins in it Initially both Alice and Bob are standing in a cell 1 1 They are going to perform a sequence of moves to reach a cell 2 m The possible moves are Move right from some cell x y to x y 1 Move down from some cell x y to x 1 y First Alice makes until she reaches 2 m She collects the coins in all cells she visit including the starting cell When Alice finishes Bob starts his journey He also performs the moves to reach 2 m and collects the coins in all cells that he visited The score of the game is the total number of coins Bob collects Alice wants to minimize the score Bob wants to maximize the score What will the score of the game be if both players play optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int m;\n    cin >> m;\n    vector<vector<int>> a(2, vector<int>(m));\n    for (int j = 0; j < 2; j++){\n      for (int k = 0; k < m; k++){\n        cin >> a[j][k];\n      }\n    }\n    vector<int> S1(m + 1);\n    S1[m] = 0;\n    for (int j = m - 1; j >= 0; j--){\n      S1[j] = S1[j + 1] + a[0][j];\n    }\n    vector<int> S2(m + 1);\n    S2[0] = 0;\n    for (int j = 0; j < m; j++){\n      S2[j + 1] = S2[j] + a[1][j];\n    }\n    int ans = INF;\n    for (int j = 0; j < m; j++){\n      ans = min(ans, max(S1[j + 1], S2[j]));\n    }\n    cout << ans << endl;\n  }\n}']","[0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Vova is again playing some computer game now an RPG In the game Vova s character received a quest to slay the fearsome monster called Modcrab After two hours of playing the game Vova has tracked the monster and analyzed its tactics The Modcrab has health points and an attack power of Knowing that Vova has decided to buy a lot of strong healing potions and to prepare for battle Vova s character has health points and an attack power of Also he has a large supply of healing potions each of which increases his current amount of health points by when Vova drinks a potion All potions are identical to each other It is guaranteed that The battle consists of multiple phases In the beginning of each phase Vova can either attack the monster thus reducing its health by or drink a healing potion it increases Vova s health by Then the Modcrab attacks Vova reducing his health by The battle ends when Vova s or Modcrab s health drops to or lower It is possible that the battle ends in a middle of a phase after Vova s attack Of course Vova wants to win the fight But also he wants to do it as fast as possible So he wants to make up a strategy that will allow him to win the fight after the minimum possible number of phases Help Vova to make up a strategy You may assume that Vova never runs out of healing potions and that he can always win ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 20;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-9;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint main() {\n\tint H1, A1, C1, H2, A2, i;\n\tscanf(""%d %d %d %d %d"", &H1, &A1, &C1, &H2, &A2);\n\n\tint ans = INF;\n\tfor (i = 0; i <= 10000; i++) {\n\t\tint h = H1 + i*(C1 - A2);\n\t\tll tur = (h + A2 - 1) / A2;\n\t\tif (tur * A1 >= H2) {\n\t\t\tans = min(ans, (H2 + A1 - 1) / A1 + i);\n\t\t\tprintf(""%d\\n"", ans);\n\t\t\tfor (int j = 1; j <= i; j++) printf(""HEAL\\n"");\n\t\t\tfor (int j = 1; j <= (H2 + A1 - 1) / A1; j++) printf(""STRIKE\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn !printf(""%d\\n"", ans);\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Vasya and Petya take part in a Codeforces round The round lasts for two hours and contains five problems For this round the dynamic problem scoring is used If you were lucky not to participate in any Codeforces round with dynamic problem scoring here is what it means The maximum point value of the problem depends on the ratio of the number of participants who solved the problem to the total number of round participants Everyone who made at least one submission is considered to be participating in the round Pay attention to the range bounds For example if 40 people are taking part in the round and 10 of them solve a particular problem then the solvers fraction is equal to and the problem s maximum point value is equal to 1500 If the problem s maximum point value is equal to then for each whole minute passed from the beginning of the contest to the moment of the participant s correct submission the participant loses points For example if the problem s maximum point value is 2000 and the participant submits a correct solution to it 40 minutes into the round this participant will be awarded with points for this problem There are participants in the round including Vasya and Petya For each participant and each problem the number of minutes which passed between the beginning of the contest and the submission of this participant to this problem is known It s also possible that this participant made no submissions to this problem With two seconds until the end of the round all participants submissions have passed pretests and not a single hack attempt has been made Vasya believes that no more submissions or hack attempts will be made in the remaining two seconds and every submission will pass the system testing Unfortunately Vasya is a cheater He has registered new accounts for the round Now Vasya can submit any of his solutions from these new accounts in order to change the maximum point values of the problems Vasya can also submit any wrong solutions to any problems Note that Vasya can not submit correct solutions to the problems he hasn t solved Vasya seeks to score strictly more points than Petya in the current round Vasya has already prepared the scripts which allow to obfuscate his solutions and submit them into the system from any of the new accounts in just fractions of seconds However Vasya doesn t want to make his cheating too obvious so he wants to achieve his goal while making submissions from the smallest possible number of new accounts Find the smallest number of new accounts Vasya needs in order to beat Petya provided that Vasya s assumptions are correct or report that Vasya can t achieve his goal ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\n#define tm f__k\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\nint n;\nint ac[5];\nint tm[2][5];\n\nint f(int p, int d, int m, int n) {\n    if (tm[p][d] == -1) return 0;\n    int fr = 250 - tm[p][d];\n    if (2*m > n) return fr*2;\n    if (4*m > n) return fr*4;\n    if (8*m > n) return fr*6;\n    if (16*m > n) return fr*8;\n    if (32*m > n) return fr*10;\n    return fr*12;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < 5; j++) {\n            int x;\n            cin >> x;\n            if (i <= 1) tm[i][j] = x;\n            if (x != -1) ac[j]++;\n        }\n    }\n\n    for (int m = 0; m < 120*40; m++) {\n        int sm = 0;\n        for (int j = 0; j < 5; j++) {\n            int ma = -TEN(9);\n            for (int a = 0; a <= m; a++) {\n                if (a && tm[0][j] == -1) break;\n                ma = max(ma, f(0, j, ac[j]+a, n+m) - f(1, j, ac[j]+a, n+m));\n            }\n            sm += ma;\n        }\n        if (sm > 0) {\n            cout << m << endl;\n            return 0;\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Vlad decided to go on a trip to the mountains He plans to move between n mountains some of which are connected by roads The i th mountain has a height of h i If there is a road between mountains i and j Vlad can move from mountain i to mountain j by spending h j h i units of energy If his energy drops below zero during the transition he will not be able to move from mountain i to mountain j Note that h j h i can be negative and then the energy will be restored Vlad wants to consider different route options so he asks you to answer the following queries is it possible to construct some route starting at mountain a and ending at mountain b given that he initially has e units of energy ,"['#include<bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(""Ofast"",""inline"",""-ffast-math"")\n#pragma GCC target(""avx,sse2,sse3,sse4,mmx"")\n\n#define int long long\n\nconst int MOD=998244353;\nvector<int> Q[200001];\nint n,m,q,a[200001],fa[200001],ans[200001];\nint getfa(int x){if(fa[x]==x) return x;return fa[x]=getfa(fa[x]);}\nvoid merge(int x,int y){fa[getfa(x)]=getfa(y);}\nvoid Delta() {\n   cin >> n >> m;\n   for(int i=1;i<=n;++i) {\n      cin >> a[i];\n      fa[i]=i;Q[i].clear();\n   }\n   for(int i=1,u,v;i<=m;++i) {\n      cin >> u >> v;\n      Q[u].push_back(v);\n      Q[v].push_back(u);\n   }\n   vector<array<int,4>> P;cin >> q;\n   for(int i=1,u,v,e;i<=q;++i) {\n      cin >> u >> v >> e;\n      P.push_back({a[u]+e,u,v,i});\n   }\n   for(int i=1;i<=n;++i)\n      P.push_back({a[i],-2147483648,i,-1});\n   sort(P.begin(),P.end());\n   for(array<int,4> i:P) {\n      if(i[3]==-1)\n         for(int j:Q[i[2]]) {\n            if(a[j]<=a[i[2]])\n               merge(i[2],j);\n         }\n      else\n         ans[i[3]]=getfa(i[1])==getfa(i[2]);\n   }\n   for(int i=1;i<=q;++i)\n      if(ans[i]) cout << ""YES\\n"";\n      else cout << ""NO\\n"";\n   cout << ""\\n"";\n}\nsigned main() {\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);cout.tie(0);\n   int T;cin >> T;\n   while(T--) Delta();\n}']","[0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0]",2000
Marina loves Sasha But she keeps wondering whether Sasha loves her Of course the best way to know it is fortune telling There are many ways of telling fortune but Marina has picked the easiest one She takes in her hand one or several camomiles and tears off the petals one by one After each petal she pronounces alternatively Loves and Doesn t love at that Marina always starts with Loves There are camomiles growing in the field possessing the numbers of petals equal to Marina wants to pick a bouquet with the maximal possible total number of petals so that the result would still be Loves Help her do that find the maximal number of petals possible in the bouquet ,"[""#include <iostream>\n#include <algorithm>\nusing namespace std;\nint arr[256];\nint n;\nint main()\n{\n\tcin>>n;\n\tfor(int i=0; i<n; ++i) cin>>arr[i];\n\tint cnt=0;\n\tfor(int i=0; i<n; ++i) cnt += arr[i]&1;\n\tif (!cnt) {\n\t\tcout<<0<<'\\n';\n\t\treturn 0;\n\t}\n\tint r=0;\n\tsort(arr,arr+n);\n\tfor(int i=0; i<n; ++i) r+=arr[i];\n\tint a=0;\n\twhile(!(arr[a]&1)) ++a;\n\tif (!(cnt&1)) r -= arr[a];\n\tcout<<r<<'\\n';\n}\n""]","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1200
Ashish and Vivek play a game on a matrix consisting of n rows and m columns where they take turns claiming cells Unclaimed cells are represented by 0 while claimed cells are represented by 1 The initial state of the matrix is given There can be some claimed cells in the initial state In each turn a player must claim a cell A cell may be claimed if it is unclaimed and does not share a row or column with any other already claimed cells When a player is unable to make a move he loses and the game ends If Ashish and Vivek take turns to move and Ashish goes first determine the winner of the game if both of them are playing optimally Optimal play between two players means that both players choose the best possible strategy to achieve the best possible outcome for themselves ,"['#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint t;\n\tscanf(""%d"" ,&t);\n\twhile(t--){\n\t\tint n, m;\n\t\tscanf(""%d%d"", &n, &m);\n\t\tvector <vector <bool> > b(n, vector <bool> (m));\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tint a;\n\t\t\t\tscanf(""%d"", &a);\n\t\t\t\tb[i][j]=(a==1);\n\t\t\t}\n\t\t}\n\t\tvector <int> freen(n, 1), freem(m, 1);\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tif(b[i][j]){\n\t\t\t\t\tfreen[i]=0;\n\t\t\t\t\tfreem[j]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf((min(count(freen.begin(), freen.end(), 1), count(freem.begin(), freem.end(), 1))&1)==0?""Vivek\\n"":""Ashish\\n"");\n\t}\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Arkady has got an infinite plane painted in color 0 Then he draws n rectangles filled with paint with sides parallel to the Cartesian coordinate axes one after another The color of the i th rectangle is i rectangles are enumerated from 1 to n in the order he draws them It is possible that new rectangles cover some of the previous ones completely or partially Count the number of different colors on the plane after Arkady draws all the rectangles ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005;\nconst int M=525000;\nint a[N],b[N],c[N],d[N];\nint n,ans,qx[N*2],qy[N*2];\nint vis[N*2],mx[M],mn[M];\nvector<pair<int,int> > v[N*2];\nset<int> s[M];\nvoid pushup(int k,int l,int r){\n\tif (l!=r){\n\t\tmx[k]=max(mx[k*2],mx[k*2+1]);\n\t\tmn[k]=min(mn[k*2],mn[k*2+1]);\n\t}\n\telse\n\t\tmx[k]=mn[k]=0;\n\tif (s[k].size()){\n\t\tif (vis[*s[k].rbegin()])\n\t\t\tmn[k]=max(mn[k],*s[k].rbegin());\n\t\telse mx[k]=max(mx[k],*s[k].rbegin());\n\t}\n\tif (mx[k]<mn[k])\n\t\tmx[k]=0;\n}\nvoid insert(int k,int l,int r,int x,int y,int v){\n\t//printf(""%d %d %d %d\\n"",l,r,x,y);\n\tif (l==x&&r==y){\n\t\tif (v){\n\t\t\tif (v>0) s[k].insert(v);\n\t\t\telse s[k].erase(-v); \n\t\t}\n\t\tpushup(k,l,r);\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tif (y<=mid) insert(k*2,l,mid,x,y,v);\n\telse if (x>mid) insert(k*2+1,mid+1,r,x,y,v);\n\telse insert(k*2,l,mid,x,mid,v),\n\t\t insert(k*2+1,mid+1,r,mid+1,y,v);\n\tpushup(k,l,r);\n}\nint main(){\n\tscanf(""%d"",&n);\n\tfor (int i=1;i<=n;i++){\n\t\tscanf(""%d%d%d%d"",&a[i],&b[i],&c[i],&d[i]);\n\t\tqx[++*qx]=a[i]; qx[++*qx]=c[i];\n\t\tqy[++*qy]=b[i]; qy[++*qy]=d[i];\n\t}\n\tsort(qx+1,qx+*qx+1);\n\tsort(qy+1,qy+*qy+1);\n\t*qx=unique(qx+1,qx+*qx+1)-qx-1;\n\t*qy=unique(qy+1,qy+*qy+1)-qy-1;\n\tfor (int i=1;i<=n;i++){\n\t\ta[i]=lower_bound(qx+1,qx+*qx+1,a[i])-qx;\n\t\tc[i]=lower_bound(qx+1,qx+*qx+1,c[i])-qx;\n\t\tb[i]=lower_bound(qy+1,qy+*qy+1,b[i])-qy;\n\t\td[i]=lower_bound(qy+1,qy+*qy+1,d[i])-qy-1;\n\t\tv[a[i]].push_back(make_pair(i,i));\n\t\tv[c[i]].push_back(make_pair(i,-i));\n\t}\n\tfor (int i=1;i<=*qx;i++){\n\t\tfor (int j=0;j<v[i].size();j++)\n\t\t\tinsert(1,1,*qy,b[v[i][j].first],d[v[i][j].first],v[i][j].second);\n\t\tfor (;mx[1];){\n\t\t\tvis[mx[1]]=1; ans++;\n\t\t\tinsert(1,1,*qy,b[mx[1]],d[mx[1]],0);\n\t\t}\n\t}\n\tprintf(""%d"",ans+1);\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3300
Wilbur the pig really wants to be a beaver so he decided today to pretend he is a beaver and bite at trees to cut them down There are trees located at various positions on a line Tree is located at position All the given positions of the trees are distinct The trees are equal i e each tree has height Due to the wind when a tree is cut down it either falls left with probability or falls right with probability If a tree hits another tree while falling that tree will fall in the same direction as the tree that hit it A tree can hit another tree only if the distance between them is strictly less than For example imagine there are trees located at positions and while and the tree at position falls right It hits the tree at position and it starts to fall too In it s turn it hits the tree at position and it also starts to fall The distance between and is exactly so the tree at position will not fall As long as there are still trees standing Wilbur will select either the leftmost standing tree with probability or the rightmost standing tree with probability Selected tree is then cut down If there is only one tree remaining Wilbur always selects it As the ground is covered with grass Wilbur wants to know the expected total length of the ground covered with fallen trees after he cuts them all down because he is concerned about his grass eating cow friends Please help Wilbur ,"[""//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define int long long\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 2049;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nld dp[maxN][maxN][2][2];\n\nll x[maxN], nx[maxN][2], val[maxN][2];\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tld p;\n\tint n, h; cin >> n >> h >> p;\n\tx[0] = -1e9;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tx[n + 1] = 1e9; \n\tsort(x, x + n + 2);\n\tn += 2;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos = i;\n\t\twhile (pos < n - 1 && x[pos + 1] - x[pos] < h)\n\t\t\tpos++;\n\t\tnx[i][1] = pos;\n\t\tval[i][1] = x[pos] - x[i] + h;\n\t\tpos = i;\n\t\twhile (pos && x[pos] - x[pos - 1] < h)\n\t\t\tpos--;\n\t\tnx[i][0] = pos;\n\t\tval[i][0] = x[i] - x[pos] + h;\n\t}\n\tfor (int l = n - 2; l; --l) {\n\t\tfor (int r = l; r < n - 1; r++) {\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tint prv = a? x[l - 1] + h: x[l - 1];\n\t\t\t\t\tint nxt = b? x[r + 1]: x[r + 1] - h;\n\t\t\t\t\tif (r == l) {\n\t\t\t\t\t\tdp[l][r][a][b] += p * min(x[l] - prv, h) + (1 - p) * min(nxt - x[r], h); \n\t\t\t\t\t} else {\n\t\t\t\t\t\t//l falls left\n\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * (min(x[l] - prv, h) + dp[l + 1][r][0][b]));\n\t\t\t\t\t\t//r falls right\n\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * (min(nxt - x[r], h) + dp[l][r - 1][a][1]));\n\t\t\t\t\t\t//l falls right\n\t\t\t\t\t\tint pos = nx[l][1];\n\t\t\t\t\t\tif (pos >= r)\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * (min(nxt - x[r], h) + x[r] - x[l]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * ((val[l][1]) + dp[pos + 1][r][1][b]));\n\t\t\t\t\t\t//r falls left\n\t\t\t\t\t\tpos = nx[r][0];\n\t\t\t\t\t\tif (pos <= l)\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * (min(x[l] - prv, h) + x[r] - x[l]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * ((val[r][0]) + dp[l][pos - 1][a][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << setprecision(7) << fixed << dp[1][n - 2][0][1] << '\\n';\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n""]","[0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2300
You are given a permutation p 1 p 2 ldots p n In one move you can swap two adjacent values You want to perform a minimum number of moves such that in the end there will exist a subsegment 1 2 ldots k in other words in the end there should be an integer i 1 leq i leq n k 1 such that p i 1 p i 1 2 ldots p i k 1 k Let f k be the minimum number of moves that you need to make a subsegment with values 1 2 ldots k appear in the permutation You need to find f 1 f 2 ldots f n ,"['/**\n *    author:  tourist\n *    created: 21.12.2019 14:12:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nclass segtree {\n public:\n  struct node {\n    // don\'t forget to set default value (used for leaves)\n    // not necessarily neutral element!\n    long long L = 0;\n    long long R = 0;\n    int alive = 1;\n    int addL = 0;\n    int addR = 0;\n\n    void apply(int l, int r) {\n      alive = 0;\n      L = R = 0;\n      addL = addR = 0;\n    }\n\n    void apply(int l, int r, int v, char c) {\n      if (c == \'L\') {\n        L += (long long) alive * v;\n        addL += v;\n      }\n      if (c == \'R\') {\n        R += (long long) alive * v;\n        addR += v;\n      }\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.L = a.L + b.L;\n    res.R = a.R + b.R;\n    res.alive = a.alive + b.alive;\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].addL != 0) {\n      tree[x + 1].apply(l, y, tree[x].addL, \'L\');\n      tree[z].apply(y + 1, r, tree[x].addL, \'L\');\n      tree[x].addL = 0;\n    }\n    if (tree[x].addR != 0) {\n      tree[x + 1].apply(l, y, tree[x].addR, \'R\');\n      tree[z].apply(y + 1, r, tree[x].addR, \'R\');\n      tree[x].addR = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i];\n    --p[i];\n  }\n  vector<int> pos(n);\n  for (int i = 0; i < n; i++) {\n    pos[p[i]] = i;\n  }\n  fenwick<int> fenw(n);\n  vector<long long> res(n);\n  long long inv = 0;\n  segtree st(n);\n  for (int it = 0; it < n; it++) {\n    int at = pos[it];\n    inv += fenw.get(n - 1) - fenw.get(at);\n    fenw.modify(at, +1);\n    if (at > 0) {\n      st.modify(0, at - 1, 1, \'R\');\n    }\n    if (at < n - 1) {\n      st.modify(at + 1, n - 1, 1, \'L\');\n    }\n    st.modify(at, at);\n    int med = -1;\n    {\n      int low = 0, high = n - 1;\n      while (low < high) {\n        int mid = (low + high) >> 1;\n        int s = fenw.get(mid);\n        if (s >= it / 2 + 1) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      med = low;\n    }\n    res[it] = inv;\n    if (med > 0) {\n      res[it] += st.get(0, med - 1).L;\n    }\n    if (med < n - 1) {\n      res[it] += st.get(med + 1, n - 1).R;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (i > 0) {\n      cout << "" "";\n    }\n    cout << res[i];\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2300
You are playing a computer game The current level of this game can be modeled as a straight line Your character is in point 0 of this line There are n monsters trying to kill your character the i th monster has health equal to a i and is initially in the point x i Every second the following happens first you fire up to k bullets at monsters Each bullet targets exactly one monster and decreases its health by 1 For each bullet you choose its target arbitrary for example you can fire all bullets at one monster fire all bullets at different monsters or choose any other combination Any monster can be targeted by a bullet regardless of its position and any other factors then all alive monsters with health 0 or less die then all alive monsters move 1 point closer to you monsters to the left of you increase their coordinates by 1 monsters to the right of you decrease their coordinates by 1 If any monster reaches your character moves to the point 0 you lose Can you survive and kill all n monsters without letting any of them reach your character ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<std::pair<int, int>> m(n);\n    for (int i = 0; i < n; i++) {\n        int a;\n        std::cin >> a;\n        m[i].second = a;\n    }\n    for (int i = 0; i < n; i++) {\n        int x;\n        std::cin >> x;\n        m[i].first = std::abs(x);\n    }\n    \n    std::sort(m.begin(), m.end());\n    i64 sum = 0;\n    for (auto [x, a] : m) {\n        sum += a;\n        if (sum > 1LL * x * k) {\n            std::cout << ""NO\\n"";\n            return;\n        }\n    }\n    std::cout << ""YES\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
A is a string that reads the same backwards as forwards For example the string is palindrome while the string is not Let p t be the number of of string t i e the number of substrings t l dots r that are palindromes themselves Even if some substring occurs in t several times it s counted exactly once The whole string t is also counted as a substring of t For example string t has p t 6 unique palindromic substrings and Now let s define p s m p t where t s 1 dots m In other words p s m is the number of palindromic substrings in the prefix of s of length m For example p 5 p 5 You are given an integer n and k conditions k le 20 Let s say that string s consisting of n lowercase Latin letters is if all k conditions are satisfied A condition is a pair x i c i and have the following meaning p s x i c i i e a prefix of s of length x i contains exactly c i unique palindromic substrings Find a good string s or report that such s doesn t exist Look in Notes if you need further clarifications ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005;\n\nint n,k,a[N],b[N];\n\nvoid ldc(){\n    cin >> n >> k;\n    a[0]=b[0]=0;\n    for(int i=1; i<=k; ++i) cin >> a[i];\n    for(int i=1; i<=k; ++i) cin >> b[i];\n    for(int i=0; i<k; ++i) if(b[i+1]-b[i]>a[i+1]-a[i]){\n        cout << ""NO\\n"";\n        return;\n    }\n    string res;\n    int cur=-1,cur2=-1;\n    for(int i=0; i<k; ++i){\n        int cnt=b[i+1]-b[i];\n        bool flag=0;\n        for(int j=a[i]; j<a[i+1]; ++j){\n            if(j<3){\n                cur++;\n                res+=\'a\'+cur,cnt--;\n            }\n            else if(!flag&&b[i+1]-b[i]>0){\n                cur++;\n                res+=\'a\'+cur,cnt--;\n            }\n            else if(cnt==0){\n                cur2++;\n                if(cur2==3) cur2=0;\n                res+=\'a\'+cur2;\n            }\n            else res+=\'a\'+cur,cnt--;\n            flag=1;\n        }\n    }\n    cout << ""YES\\n"" << res << ""\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1900
Maxim is a minibus driver on Venus To ride on Maxim s minibus you need a ticket Each ticket has a number consisting of n digits However as we know the residents of Venus use a numeral system with base k rather than the decimal system Therefore the ticket number can be considered as a sequence of n integers from 0 to k 1 inclusive The residents of Venus consider a ticket to be if there is a digit on it that is equal to the sum of the remaining digits modulo k For example if k 10 then the ticket 7135 is lucky because 7 1 5 equiv 3 pmod 10 On the other hand the ticket 7136 is not lucky because no digit is equal to the sum of the others modulo 10 Once while on a trip Maxim wondered how many lucky tickets exist At the same time Maxim understands that this number can be very large so he is interested only in the answer modulo some prime number m ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <forward_list>\n#include <fstream>\n#include <functional>\n#include <initializer_list>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ninline int read() {\n  char ch = getchar();\n  int x = 0, f = 1;\n  while (ch < \'0\' || ch > \'9\') {\n    if (ch == \'-\') f = -1;\n    ch = getchar();\n  }\n  while (ch >= \'0\' && ch <= \'9\') {\n    x = x * 10 + ch - \'0\';\n    ch = getchar();\n  }\n  return x * f;\n}\n\nll n;\nint k, mod;\n\ninline int addmod(int x) { return x >= mod ? x - mod : x; }\ninline int submod(int x) { return x < 0 ? x + mod : x; }\nint fpow(int x, ll y) {\n  int ans = 1;\n  while (y) {\n    if (y & 1) ans = 1ll * ans * x % mod;\n    x = 1ll * x * x % mod;\n    y /= 2;\n  }\n  return ans;\n}\n\nsigned main() {\n  scanf(""%lld%d%d"", &n, &k, &mod);\n  if (n == 1) {\n    printf(""%d\\n"", 1 % mod);\n    return 0;\n  }\n  if (k % 2) {\n    int fl = 1;\n    if (n % 2 == 1) fl = mod - 1;\n    int ans1 = 1ll * (1ll * fpow(k - 1, n) - fl + mod) % mod * fpow(k, mod - 2) % mod;\n    int ans2 = 0;\n    for (int i = 0; i < k; i++) {\n      if (1ll * n % k * i % k == 2 * i % k) {\n        ans2++;\n      }\n    }\n    ans1 = (1ll * ans1 * k + 1ll * fl * ans2) % mod;\n    ans1 = submod(fpow(k, n) - ans1);\n    printf(""%d\\n"", ans1);\n    return 0;\n  } else {\n    int fl = fpow(2, n);\n    if (n % 2 == 1) fl = submod(-fl);\n    int ans1 = 1ll * (1ll * fpow(k - 2, n) - fl + mod) % mod * fpow(k, mod - 2) % mod;\n    int ans2 = 0;\n    for (int i = 0; i * 2 < k; i++) {\n      int u = 1ll * n % k * i % k;\n      if (u == 2 * i % k) ans2++;\n      if ((u + k / 2) % k == 2 * i % k) ans2++;\n    }\n    //\tprintf(""ans1=%d,ans2=%d,fl=%d\\n"",ans1,ans2,fl);\n    ans2 = 1ll * ans2 * fpow(2, mod - 2) % mod;\n    ans1 = (1ll * ans1 * (k / 2) + 1ll * fl * ans2) % mod;\n    ans1 = submod(1ll * fpow(k, n) * fpow(2, mod - 2) % mod - ans1);\n    printf(""%d\\n"", ans1);\n    return 0;\n  }\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2200
Alice and Bob are playing yet another card game This time the rules are the following There are n cards lying in a row in front of them The i th card has value a i First Alice chooses a non empty consecutive segment of cards l r l le r After that Bob removes a single card j from that segment l le j le r The score of the game is the total value of the remaining cards on the segment a l a l 1 dots a j 1 a j 1 dots a r 1 a r In particular if Alice chooses a segment with just one element then the score after Bob removes the only card is 0 Alice wants to make the score as big as possible Bob takes such a card that the score is as small as possible What segment should Alice choose so that the score is maximum possible Output the maximum score ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 1e5 + 10;\nint a[maxN];\nint n;\nint pref[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(""input.txt"", ""r"", stdin);\n    cin >> n;\n    int best = 0;\n    vector < pair < int, int > > all;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        pref[i] = pref[i - 1] + a[i];\n        for (auto& it : all) {\n            it.first = max(it.first, a[i]);\n        }\n        all.emplace_back(a[i], pref[i - 1]);\n        sort(all.begin(), all.end());\n        map < int, int > mp;\n        for (auto& it : all) {\n            if (!mp.count(it.first)) mp[it.first] = it.second;\n            else mp[it.first] = min(mp[it.first], it.second);\n        }\n        all.clear();\n        for (auto& it : mp) {\n            all.emplace_back(it);\n            best = max(best, pref[i] - it.second - it.first);\n        }\n    }\n    cout << best;\n    return 0;\n}']","[0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
The classic programming language of Bitland is Bit This language is so peculiar and complicated The language is that peculiar as it has exactly one variable called Also there are two operations Operation increases the value of variable by 1 Operation decreases the value of variable by 1 A statement in language Bit is a sequence consisting of exactly one operation and one variable The statement is written without spaces that is it can only contain characters Executing a statement means applying the operation it contains A programme in Bit is a sequence of statements each of them needs to be executed Executing a programme means executing all the statements it contains You re given a programme in language Bit The initial value of is Execute the programme and find its final value the value of the variable when this programme is executed ,"['#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <string>\nusing namespace std;\n#define LL long long\n#define maxn 200100\n#define maxe 210000\n\nchar s[20];\nint main()\n{\n\tint n,ans=0;\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tscanf(""%s"",s);\n\t\tif(s[1]==\'+\')\n\t\t\tans++;\n\t\telse\n\t\t\tans--;\n\t}\n\tcout<<ans<<endl;\n}\t']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Limak is a little polar bear Polar bears hate long strings and thus they like to compress them You should also know that Limak is so young that he knows only first six letters of the English alphabet and You are given a set of possible operations Limak can perform them in any order any operation may be applied any number of times The th operation is described by a string of length two and a string of length one No two of possible operations have the same string When Limak has a string he can perform the th operation on if the first two letters of match a two letter string Performing the th operation removes first two letters of and inserts there a string See the notes section for further clarification You may note that performing an operation decreases the length of a string exactly by Also for some sets of operations there may be a string that cannot be compressed any further because the first two letters don t match any Limak wants to start with a string of length and perform operations to finally get a one letter string In how many ways can he choose the starting string to be able to get Remember that Limak can use only letters he knows ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,q,ans,tran[10][10],dp[10][10];\nchar s[20],t[20];\nint main() {\n\tscanf(""%d%d"",&n,&q);\n\trep(i,0,q) {\n\t\tscanf(""%s%s"",s,t);\n\t\ttran[t[0]-\'a\'][s[0]-\'a\']++;\n\t}\n\tdp[0][0]=1;\n\trep(i,0,n) {\n\t\trep(j,0,6) rep(k,0,6) dp[i+1][k]+=dp[i][j]*tran[j][k];\n\t}\n\trep(j,0,6) ans+=dp[n-1][j];\n\tprintf(""%d\\n"",ans);\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0]",1300
You are walking through a parkway near your house The parkway has n 1 benches in a row numbered from 1 to n 1 from left to right The distance between the bench i and i 1 is a i meters Initially you have m units of energy To walk 1 meter of distance you spend 1 unit of your energy You can t walk if you have no energy Also you can restore your energy by and this is the only way to restore the energy When you are sitting you can restore any integer amount of energy you want if you sit longer you restore more energy Note that the amount of your energy m Your task is to find the amount of energy you have to by sitting on benches to reach the bench n 1 from the bench 1 and end your walk You have to answer t independent test cases ,"['/**\n *    author:  tourist\n *    created: 12.06.2022 18:34:19       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    int s = 0;\n    for (int i = 0; i < n; i++) {\n      int a;\n      cin >> a;\n      s += a;\n    }\n    cout << max(0, s - m) << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given a grid with n rows and m columns Rows and columns are numbered from 1 to n and from 1 to m The intersection of the a th row and b th column is denoted by a b Initially you are standing in the top left corner 1 1 Your goal is to reach the bottom right corner n m You can move in four directions from a b up to a 1 b down to a 1 b left to a b 1 or right to a b 1 You cannot move in the same direction in two consecutive moves and you cannot leave the grid What is the minimum number of moves to reach n m ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nll i,j,k,n,m,t;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);cout.tie(0);\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>m;\n\t\tn--;m--;\n\t\tif(n>m)swap(n,m);\n\t\tif(n+m<=1){\n\t\t\tcout<<n+m<<\'\\n\';continue;\n\t\t}\n\t\tif(!n||!m){\n\t\t\tcout<<""-1\\n"";continue;\n\t\t}\n\t\tcout<<m+m-((m-n)&1)<<\'\\n\';\n\t}\n}']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Inna and Dima decided to surprise Sereja They brought a really huge candy matrix it s big even for Sereja Let s number the rows of the giant matrix from to from top to bottom and the columns from to from left to right We ll represent the cell on the intersection of the th row and th column as Just as is expected some cells of the giant candy matrix contain candies Overall the matrix has candies the th candy is at cell The time moved closer to dinner and Inna was already going to eat of her favourite sweets from the matrix when suddenly Sereja for the reason he didn t share with anyone rotated the matrix times clockwise by 90 degrees Then he performed the horizontal rotate of the matrix times And then he rotated the matrix times counterclockwise by 90 degrees The figure below shows how the rotates of the matrix looks like Inna got really upset but Duma suddenly understood two things the candies didn t get damaged and he remembered which cells contained Inna s favourite sweets before Sereja s strange actions Help guys to find the new coordinates in the candy matrix after the transformation Sereja made ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <limits>\n#include <tuple>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nint n, m, x, y, z, p;\nint main()\n{\n    scanf(""%d %d %d %d %d %d"", &n, &m, &x, &y, &z, &p);\n    x%=4; y%=2; z%=4;\n    for (int i=0;i<p;++i)\n    {\n        int a, b, n0=n, m0=m; scanf(""%d %d"", &a, &b);\n        for (int j=0;j<x;++j)\n        {\n            a=n0-a+1;\n            swap(a, b);\n            swap(n0, m0);\n        }\n        for (int j=0;j<y;++j)\n        {\n            b=m0-b+1;\n        }\n        for (int j=0;j<z;++j)\n        {\n            for (int k=0;k<3;++k)\n            {\n                a=n0-a+1;\n                swap(a, b);\n                swap(n0, m0);\n            }\n        }\n        printf(""%d %d\\n"", a, b);\n    }\n    return 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Find the minimum number with the given sum of digits s such that digits in it are distinct i e all digits are unique For example if s 20 then the answer is 389 This is the minimum number in which all digits are different and the sum of the digits is 20 3 8 9 20 For the given s print the required number ,"[""/*\nDiv 3, I literally don't care edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,a[N],d[N];\nvoid solo()\n{\n   cin>>n;\n   vector<ll> s;\n   ll k=9;\n   while (n!=0){\n       if (n<=k) k=n;\n       s.pb(k);\n       n-=k;\n       k--;\n   }\n   reb(i,s.size()-1,0) cout<<s[i];\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given an array a 1 a 2 ldots a n You need to find an array b 1 b 2 ldots b n consisting of numbers 1 2 3 such that out of the following three conditions are satisfied There exist indices 1 leq i j leq n such that a i a j b i 1 b j 2 There exist indices 1 leq i j leq n such that a i a j b i 1 b j 3 There exist indices 1 leq i j leq n such that a i a j b i 2 b j 3 If such an array does not exist you should report it ,"[""#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint n, a[110];\n\nvoid solve() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n\n    unordered_map<int, int> freq;\n    int can = 0;\n    for (int i = 1; i <= n; i++) {\n        if (++freq[a[i]] == 2) {\n            can++;\n        }\n    }\n\n    if (can < 2) {\n        cout << -1 << '\\n';\n        return;\n    }\n\n    int n12 = 0, n13 = 0;\n    for (auto [v, f] : freq) {\n        if (f >= 2) {\n            if (n12 == 0) { n12 = v; }\n            else { n13 = v; break; }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        if (a[i] == n12) {\n            cout << 2 << ' ';\n            n12 = 0;\n        } else if (a[i] == n13) {\n            cout << 3 << ' ';\n            n13 = 0;\n        } else {\n            cout << 1 << ' ';\n        }\n    }\n    cout << '\\n';\n}\n\nint main() {\n#ifdef ONLINE_JUDGE\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    int t;\n    cin >> t;\n    for (int i = 1; i <= t; i++) {\n        solve();\n    }\n}""]","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Let s call a string if it has length 11 and fits the pattern where each is replaced by a digit For example and are phone numbers while and are not You have n cards with digits and you want to use them to make as many phone numbers as possible Each card must be used in at most one phone number and you don t have to use all cards The phone numbers do not necessarily have to be distinct ,"['#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <set>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    int N; cin >> N;\n    string s;\n    cin >> s;\n    int M = 0;\n    for (int i = 0; i < s.length(); i++)\n        if (s[i] == \'8\')\n            M++;\n\n    cout << min (M, N / 11) << ""\\n"";\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given an array a 1 a 2 dots a n You can perform the following operation any number of times Choose a pair of two neighboring equal elements a i a i 1 if there is at least one such pair Replace them by one element with value a i 1 After each such operation the length of the array will decrease by one and elements are renumerated accordingly What is the minimum possible length of the array a you can get ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 505;\nint dp[maxN][maxN];\nint what[maxN][maxN];\nint n;\nint a[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = i; j <= n; j++) {\n            if (i == j) {\n                dp[i][j] = true;\n                what[i][j] = a[i];\n            }\n            else {\n                dp[i][j] = j - i + 1;\n            }\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i + len - 1 <= n; i++) {\n            int j = i + len - 1;\n            for (int k = i; k < j; k++) {\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                if (dp[i][k] == 1 && dp[k + 1][j] == 1 && what[i][k] == what[k + 1][j]) {\n                    dp[i][j] = 1;\n                    what[i][j] = what[i][k] + 1;\n                }\n            }\n        }\n    }\n    cout << dp[1][n];\n    return 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Given n find any array a 1 a 2 ldots a n of integers such that all of the following conditions hold 1 le a i le 10 9 for every i from 1 to n a 1 a 2 ldots a nFor every i from 2 to n a i isn t divisible by a i 1 It can be shown that such an array always exists under the constraints of the problem ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a(n);iota(all(a),100);\n\tprint(a);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given three integers n k and x Find the number modulo 998 244 353 of integer sequences a 1 a 2 ldots a n such that the following conditions are satisfied 0 le a i lt 2 k for each integer i from 1 to n There is no non empty subsequence in a such that the bitwise XOR of the elements of the subsequence is x A sequence b is a subsequence of a sequence c if b can be obtained from c by deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int MAXB = 10000000, INV2 = (MOD + 1) / 2;\n\nint ppw[10000005], prp[10000005], pinv[10000005];\nint power(int x, int t)\n{\n\tint ret = 1;\n\twhile(t > 0) {\n\t\tif(t & 1) ret = 1ULL * ret * x % MOD;\n\t\tx = 1ULL * x * x % MOD;\n\t\tt >>= 1;\n\t}\n\treturn ret;\n}\n\nint n, k, x;\nvoid solve()\n{\n\tscanf(""%d%d%d"", &n, &k, &x);\n\tif(x == 0) {\n\t\tif(n > k) {\n\t\t\tprintf(""0\\n""); return;\n\t\t}\n\t\tint ret = 1ULL * prp[k] * pinv[k - n] % MOD;\n\t\trep(i, n) ret = 1ULL * ret * ppw[i] % MOD;\n\t\tprintf(""%d\\n"", ret);\n\t} else {\n\t\tint ret = 0, ccf = 1, tmp = power(2, n);\n\t\tfor(int i = 0; i <= k; i ++) {\n\t\t\tint prob = i == 0 ? 1 : (1 + 1ULL * pinv[k] * prp[k - 1] % MOD * (MOD - ppw[i] + 1)) % MOD;\n\t\t\tret = (ret + 1ULL * ccf * pinv[i] % MOD * prob) % MOD;\n\t\t\tccf = 1ULL * ccf * (tmp - 1) % MOD * (ppw[k - i] - 1) % MOD;\n\t\t\ttmp = 1ULL * tmp * INV2 % MOD;\n\t\t\tccf = 1ULL * ccf * ppw[i] % MOD;\n\t\t}\n\t\tprintf(""%d\\n"", ret);\n\t}\n}\n\nint main()\n{\n\tppw[0] = 1;\n\trep1(i, MAXB) ppw[i] = 2 * ppw[i - 1] % MOD;\n\tprp[0] = 1;\n\trep1(i, MAXB) prp[i] = 1ULL * prp[i - 1] * (ppw[i] - 1) % MOD;\n\tpinv[MAXB] = power(prp[MAXB], MOD - 2);\n\tfor(int i = MAXB; i >= 1; i --) pinv[i - 1] = 1ULL * pinv[i] * (ppw[i] - 1) % MOD;\n\tint T;\n\tscanf(""%d"", &T);\n\twhile(T --) solve();\n\treturn 0;\n}']","[0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2700
There are n cards numbered 1 ldots n The card i has a red digit r i and a blue digit b i written on it We arrange all n cards in random order from left to right with all permutations of 1 ldots n having the same probability We then read all red digits on the cards from left to right and obtain an integer R In the same way we read all blue digits and obtain an integer B When reading a number leading zeros can be ignored If all digits in a number are zeros then the number is equal to 0 Below is an illustration of a possible rearrangement of three cards and how R and B can be found Two players Red and Blue are involved in a bet Red bets that after the shuffle R B and Blue bets that R B If in the end R B the bet results in a draw and neither player wins Determine which of the two players is more likely has higher probability to win the bet or that their chances are equal Refer to the Note section for a formal discussion of comparing probabilities ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define N 1000002\ntypedef long long ll;\nint n,T;\nchar a[N],b[N];\nint main()\n{\n\tscanf(""%d"",&T);\n\twhile(T--)\n\t{\n\t\tscanf(""%d"",&n);\n\t\tscanf(""%s%s"",a+1,b+1);\n\t\tint c1=0,c2=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(a[i]-\'0\'<b[i]-\'0\')c1++;\n\t\t\telse if(a[i]-\'0\'>b[i]-\'0\')c2++;\n\t\t}\n\t\tif(c1==c2)puts(""EQUAL"");\n\t\telse if(c1<c2)puts(""RED"");\n\t\telse puts(""BLUE"");\n\t}\n}\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given two arrays of integers a 1 a 2 ldots a n and b 1 b 2 ldots b n Let s define a transformation of the array a Choose any non negative integer k such that 0 le k le n Choose k distinct array indices 1 le i 1 i 2 ldots i k le n Add 1 to each of a i 1 a i 2 ldots a i k all other elements of array a remain unchanged Permute the elements of array a in any order Is it possible to perform some transformation of the array a so that the resulting array is equal to b ,"['#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 1600;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint t; cin >> t;\n\twhile(t--){\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> a(n), b(n);\n\t\tfor(auto &i : a) cin >> i;\n\t\tfor(auto &i : b) cin >> i;\t\n\t\tsort(all(a));\n\t\tsort(all(b));\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(b[i] >= a[i] && b[i] <= a[i] + 1) ret++;\n\t\t}\n\t\tcout << (ret == n ? ""YES\\n"" : ""NO\\n"");\n\t}\n\n}\n\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",900
Now Dmitry has a session and he has to pass n exams The session starts on day 1 and lasts d days The ith exam will take place on the day of a i 1 le a i le d all a i are different For the session schedule Dmitry considers a special value mu the smallest of the rest times before the exam for all exams For example for the image above mu 1 In other words for the schedule he counts exactly n numbers how many days he rests between the exam i 1 and i for i 0 between the start of the session and the exam i Then it finds mu the minimum among these n numbers Dmitry believes that he can improve the schedule of the session He may ask to change the date of one exam change one arbitrary value of a i Help him change the date so that all a i remain different and the value of mu is as large as possible For example for the schedule above it is most advantageous for Dmitry to move the second exam to the very end of the session The new schedule will take the form Dmitry can leave the proposed schedule unchanged if there is no way to move one exam so that it will lead to an improvement in the situation ,"[""#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef vector<ll> V;\nint n,d;\nint arr[200005];\nvoid solve(){\n\tcin>>n>>d;\n\tfor(int i=1; i<=n; i++) cin>>arr[i];\n\tsort(arr+1,arr+n+1);\n\tarr[n+1] = d+1;\n\tmultiset<int>st;\n\tfor(int i=1; i<=n; i++) st.insert(arr[i]-1-arr[i-1]);\n\tint ans = *st.begin();\n\tfor(int i=1; i<n; i++){\n\t\tint a = arr[i]-1-arr[i-1];\n\t\tint b = arr[i+1]-1-arr[i];\n\t\tst.erase(st.find(a));\n\t\tst.erase(st.find(b));\n\t\tst.insert(arr[i+1]-1-arr[i-1]);\n\t\t\n\t\tint mx = *st.rbegin();\n\t\tint half = mx/2; if(mx%2==0) half--;\n\t\tst.erase(st.find(mx)); st.insert(half);\n\t\tans = max(ans,*st.begin());\n\t\t\n\t\tst.erase(st.find(half)); st.insert(mx);\n\t\tif(d-arr[n]){\n\t\t\tst.insert(d-1-arr[n]);\n\t\t\tans = max(ans,*st.begin());\n\t\t\tst.erase(st.find(d-1-arr[n]));\n\t\t}\n\t\tst.erase(st.find(arr[i+1]-1-arr[i-1]));\n\t\tst.insert(a); st.insert(b);\n\t}\n\tint diff = arr[n]-1-arr[n-1];\n\tst.erase(st.find(diff));\n\tst.insert(d-1-arr[n-1]); \n\tans = max(ans,*st.begin()); st.erase(st.find(d-1-arr[n-1]));\n\t\n\tint mx = *st.rbegin();\n\tint half = mx/2; if(mx%2==0) half--;\n\tst.erase(st.find(mx)); st.insert(half);\n\tans = max(ans,*st.begin());\n\tcout<<ans<<'\\n';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\tint t = 1;\n\tcin >> t;\n\twhile(t--) solve();\n}""]","[1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",1900
AquaMoon knew through foresight that some ghosts wanted to curse tourists on a pedestrian street But unfortunately this time these ghosts were hiding in a barrier and she couldn t enter this barrier in a short time and destroy them Therefore all that can be done is to save any unfortunate person on the street from the ghosts The pedestrian street can be represented as a one dimensional coordinate system There is one person hanging out on the pedestrian street At the time 0 he is at coordinate x moving with a speed of 1 unit per second In particular at time i the person will be at coordinate x i The ghosts are going to cast n curses on the street The i th curse will last from time tl i 1 10 18 to time tr i 1 10 18 exclusively and will kill people with coordinates from l i 1 10 18 to r i 1 10 18 exclusively Formally that means that the person whose coordinate is between l i 1 10 18 r i 1 10 18 in the time range tl i 1 10 18 tr i 1 10 18 will die To save the person on the street AquaMoon can stop time at any moment t and then move the person from his current coordinate x to any coordinate y t x and y are not necessarily integers The movement costs AquaMoon x y energy The movement is continuous so if there exists some cursed area between points x and y at time t the person will AquaMoon wants to know what is the minimum amount of energy she needs to spend in order to save the person on the street from all n curses But she is not good at programming As her friend can you help her ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nusing dpl = deque<pl>; // OK\n\nint N,X; // OK\nmap<pl,dpl> ranges;\nint cur_time;\n\nvoid attempt_add_left(pair<pl,dpl>& p, ll best_left) {\n\tll L = p.f.f;\n\tif (!sz(p.s) || p.s.ft.s+(p.s.ft.f+cur_time)-L > best_left) \n\t\tp.s.push_front({L-cur_time,best_left});\n}\n\nvoid attempt_add_right(pair<pl,dpl>& p, ll best_right) {\n\tll R = p.f.s;\n\tif (!sz(p.s) || p.s.bk.s+R-(p.s.bk.f+cur_time) > best_right) \n\t\tp.s.pb({R-cur_time,best_right});\n}\n\nvoid cleanup(pair<pl,dpl>& p) {\n\tll best_right = INF;\n\tll R = p.f.s;\n\twhile (sz(p.s)) {\n\t\tll dif = (p.s.bk.f+cur_time)-R;\n\t\tif (dif <= 0) break;\n\t\tbest_right = p.s.bk.s+dif;\n\t\tp.s.pop_back();\n\t}\n\tattempt_add_right(p,best_right);\n}\n\nmap<int,int> start_cnt, end_cnt;\n\nvoid ban(int L, int R) {\n\tdbg(""BAN"",L,R);\n\t++start_cnt[L], ++end_cnt[R];\n\tauto it = ranges.ub({L,INF});\n\tif (it != begin(ranges) && prev(it)->f.s > L) --it;\n\twhile (it != end(ranges) && it->f.f < R) {\n\t\tpair<pl,dpl> t = *(it++); cleanup(t);\n\t\tranges.erase(prev(it));\n\t\tif (t.f.f <= L) {\n\t\t\tpair<pl,dpl> nt; nt.f = {t.f.f,L};\n\t\t\teach(u,t.s) {\n\t\t\t\tif (u.f+cur_time <= L) nt.s.pb(u);\n\t\t\t\telse {\n\t\t\t\t\tattempt_add_right(nt,u.s+(u.f+cur_time)-L);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tranges[nt.f] = nt.s;\n\t\t}\n\t\tif (R <= t.f.s) {\n\t\t\tpair<pl,dpl> nt; nt.f = {R,t.f.s};\n\t\t\tll min_lef = INF;\n\t\t\teach(u,t.s) {\n\t\t\t\tif (u.f+cur_time < R) {\n\t\t\t\t\tmin_lef = u.s+R-(u.f+cur_time);\n\t\t\t\t} else nt.s.pb(u);\n\t\t\t}\n\t\t\tattempt_add_left(nt,min_lef);\n\t\t\tranges[nt.f] = nt.s;\n\t\t}\n\t}\n}\n\nvoid subtract(map<int,int>& m, int x) {\n\t--m[x];\n\tassert(m[x] >= 0);\n\tif (m[x] == 0) m.erase(x);\n}\n\nint get_next_start(int L) {\n\tauto it = start_cnt.lb(L);\n\tif (it == end(start_cnt)) return MOD;\n\treturn it->f;\n}\n\nint get_prev_end(int R) {\n\tauto it = end_cnt.ub(R);\n\tif (it == begin(end_cnt)) return -MOD;\n\treturn prev(it)->f;\n}\n\ndpl merge_deques(dpl l, dpl r) {\n\twhile (sz(l) && sz(r)) {\n\t\tassert(l.bk.f < r.ft.f);\n\t\tll dif = r.ft.f-l.bk.f;\n\t\tif (l.bk.s >= r.ft.s+dif) {\n\t\t\tl.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tif (r.ft.s >= l.bk.s+dif) {\n\t\t\tr.pop_front();\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tl.ins(end(l),all(r));\n\treturn l;\n}\n\nvoid revert(int L, int R) {\n\t// dbg(""REVERT"",L,R);\n\tsubtract(start_cnt,L), subtract(end_cnt,R);\n\tint LL = get_next_start(L), RR = get_prev_end(R);\n\t// dbg(""GOT"",L,R,LL,RR);\n\tauto it = ranges.ub({L,INF});\n\tbool flag = 0;\n\tif (it != begin(ranges) && prev(it)->f.s == L) {\n\t\tpair<pl,dpl> t = *prev(it); ranges.erase(prev(it));\n\t\tcleanup(t);\n\t\tt.f.s = LL; ranges[t.f] = t.s;\n\t\tflag = (LL >= R);\n\t}\n\tif (it != end(ranges) && it->f.f == R) {\n\t\tpair<pl,dpl> t = *it; cleanup(t);\n\t\tif (flag) {\n\t\t\tassert(it != begin(ranges));\n\t\t\tranges.erase(it--);\n\t\t\tassert(RR <= L);\n\t\t\tassert(it->f.s == t.f.s);\n\t\t\tassert(RR == it->f.f);\n\t\t\tit->s = merge_deques(it->s,t.s);\n\t\t} else {\n\t\t\tranges.erase(it);\n\t\t\tt.f.f = RR;\n\t\t\tranges[t.f] = t.s;\n\t\t}\n\t}\n}\n\nint main() {\n\tsetIO();\n\tre(N,X);\n\tranges[{-MOD,MOD}] = {{X,0}}; // OK\n\tV<tuple<int,int,int,int>> mod;\n\trep(N) {\n\t\tints(TL,TR,L,R);\n\t\t--TL, ++TR, --L, ++R;\n\t\tmod.pb({TL,1,L,R});\n\t\tmod.pb({TR,-1,L,R});\n\t}\n\tsor(mod);\n\teach(t,mod) {\n\t\tauto [_time, ad, L, R] = t;\n\t\tcur_time = _time;\n\t\tif (ad == 1) ban(L,R);\n\t\telse revert(L,R);\n\t}\n\tassert(sz(start_cnt) == 0 && sz(end_cnt) == 0);\n\tassert(sz(ranges) == 1);\n\tV<pair<pl,dpl>> franges(all(ranges));\n\teach(t,franges) cleanup(t);\n\tll ans = INF;\n\teach(t,franges[0].s) ckmin(ans,t.s);\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3500
It is Borya s eleventh birthday and he has got a great present cards with numbers The th card has the number written on it Borya wants to put his cards in a row to get one greater number For example if Borya has cards with numbers and and he puts them in a row in this order he would get a number He is only 11 but he already knows that there are ways to put his cards in a row But today is a special day so he is only interested in such ways that the resulting big number is divisible by eleven So the way from the previous paragraph is good because but if he puts the cards in the following order he would get a number it is not divisible by so this way is not good for Borya Help Borya to find out how many good ways to put the cards are there Borya considers all cards different even if some of them contain the same number For example if Borya has two cards with 1 on it there are two good ways Help Borya find the number of good ways to put the cards This number can be large so output it modulo ,"['#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <utility>\n#include <cstdlib>\n#include <memory>\n#include <queue>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <complex>\n#include <bitset>\n#include <fstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n\nusing namespace std;\n\n#define ws ws_____________________\n#define y1 y1_____________________\n#define y0 y0_____________________\n#define left left_________________\n#define right right_______________\n#define next next_________________\n#define prev prev_________________\n#define hash hash_________________\n\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair \n#define sz(C) ((int) (C).size())\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; --i)\n#define all(C) begin(C), end(C)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int uint;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vii;\ntypedef long double ld;\ntypedef complex<double> cd;\n\n#ifdef LOCAL\n#define eprintf(args...) fprintf(stderr, args), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define FILE_NAME ""a""\n\nconst int MOD = 998244353;\n\nvoid add(int& x, int y) {\n\t((x += y) >= MOD) && (x -= MOD);\n}\n\nint mul(int x, int y) {\n\treturn x * 1ll * y % MOD;\n}\n\nconst int M = 11;\n\nvoid addM(int& x, int y) {\n\t((x += y) >= M) && (x -= M);\n}\n\nvoid subM(int& x, int y) {\n\taddM(x, -y + M);\n}\n\nvi repr(int a) {\n\tvi res;\n\twhile (a) {\n\t\tres.pb(a % 10);\n\t\ta /= 10;\n\t}\n\tassert(!res.empty());\n\treverse(all(res));\n\treturn res;\n}\n\npii convert(int a) {\n\tvi digs = repr(a);\n\n\tpii res;\n\tres.fst = sz(digs) & 1;\n\n\tforn(i, sz(digs)) {\n\t\tif  (i & 1) {\n\t\t\tsubM(res.snd, digs[i]);\n\t\t} else {\n\t\t\taddM(res.snd, digs[i]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint n;\nvi odd;\nvi even;\n\nbool read() {\n\tif  (scanf(""%d"", &n) < 1) {\n\t\treturn 0;\n\t}\n\todd.clear();\n\teven.clear();\n\tforn(i, n) {\n\t\tint a;\n\t\tscanf(""%d"", &a);\n\t\tauto conv = convert(a);\n\t\tif  (conv.fst) {\n\t\t\todd.pb(conv.snd);\n\t\t} else {\n\t\t\teven.pb(conv.snd);\n\t\t}\n\t}\n\treturn 1;\n}\n\nvi calc1() {\n\tconst int all_even_poses = sz(odd) / 2;\n\tconst int all_odd_poses = sz(odd) - all_even_poses;\n\n\tvvi dp(all_even_poses + 1, vi(M, 0));\n\tdp[0][0] = 1;\n\tforn(i, sz(odd) + 1) {\n\t\tvvi ndp(all_even_poses + 1, vi(M, 0));\n\n\t\tforn(used_even, all_even_poses + 1) {\n\t\t\tconst int used_odd = i - used_even;\n\t\t\tforn(rem, M) {\n\t\t\t\tconst int cur_dp = dp[used_even][rem];\n\t\t\t\tif  (!cur_dp) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tassert(used_odd >= 0);\n\t\t\t\tassert(used_odd <= all_odd_poses);\n\n\t\t\t\t// eprintf(""i = %d, used_even = %d, used_odd = %d, rem = %d, cur_dp = %d\\n"", i, used_even, used_odd, rem, cur_dp);\n\n\t\t\t\tif  (i == sz(odd)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// put to even\n\t\t\t\tif  (used_even < all_even_poses) {\n\t\t\t\t\tint nrem = rem;\n\t\t\t\t\taddM(nrem, odd[i]);\n\t\t\t\t\tassert(0 <= nrem && nrem < M);\n\t\t\t\t\tadd(ndp[used_even + 1][nrem], mul(cur_dp, all_even_poses - used_even));\n\t\t\t\t}\n\n\t\t\t\t// put to odd\n\t\t\t\tif  (used_odd < all_odd_poses) {\n\t\t\t\t\tint nrem = rem;\n\t\t\t\t\tsubM(nrem, odd[i]);\n\t\t\t\t\tassert(0 <= nrem && nrem < M);\n\t\t\t\t\tadd(ndp[used_even][nrem], mul(cur_dp, all_odd_poses - used_odd));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif  (i == sz(odd)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdp.swap(ndp);\n\t}\n\n\treturn dp[all_even_poses];\n}\n\nint calc2(const vi& dyn1) {\n\tconst int max_places = sz(odd) + sz(even) + 1;\n\n\tvvi dp(max_places + 1, vi(M, 0));\n\tforn(rem, M) {\n\t\tdp[sz(odd) / 2 + 1][rem] = dyn1[rem];\n\t}\n\n\tforn(i, sz(even)) {\n\t\tconst int cur_places = sz(odd) + i + 1;\n\t\tvvi ndp(max_places + 1, vi(M, 0));\n\n\t\tforn(even_places, max_places + 1) {\n\t\t\tconst int odd_places = cur_places - even_places;\n\n\t\t\tforn(rem, M) {\n\t\t\t\tconst int cur_dp = dp[even_places][rem];\n\t\t\t\tif  (!cur_dp) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// eprintf(""i = %d, even_places = %d, rem = %d, odd_places = %d\\n"", i, even_places, rem, odd_places);\n\n\t\t\t\tassert(even_places > 0);\n\t\t\t\tassert(odd_places >= 0);\n\n\t\t\t\t// to even place\n\t\t\t\tif  (even_places) {\n\t\t\t\t\tint nrem = rem;\n\t\t\t\t\taddM(nrem, even[i]);\n\t\t\t\t\tadd(ndp[even_places + 1][nrem], mul(cur_dp, even_places));\n\t\t\t\t}\n\n\t\t\t\t// to odd place\n\t\t\t\t{\n\t\t\t\t\tint nrem = rem;\n\t\t\t\t\tsubM(nrem, even[i]);\n\t\t\t\t\tadd(ndp[even_places][nrem], mul(cur_dp, odd_places));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tdp.swap(ndp);\n\t}\n\n\tint ans = 0;\n\tforn(i, sz(dp)) {\n\t\tadd(ans, dp[i][0]);\n\t}\n\n\treturn ans;\n}\n\nint solve() {\n\t// eprintf(""even:\\n"");\n\t// for (int e : even) {\n\t// \teprintf(""%d "", e);\n\t// }\n\t// eprintf(""\\n"");\n\n\t// eprintf(""odd:\\n"");\n\t// for (int o : odd) {\n\t// \teprintf(""%d "", o);\n\t// }\n\t// eprintf(""\\n"");\n\n\tvi dyn1 = calc1();\n\n\t// eprintf(""dyn1:\\n"");\n\t// forn(i, sz(dyn1)) {\n\t// \teprintf(""%d -> %d\\n"", i, dyn1[i]);\n\t// }\n\n\tint ans = calc2(dyn1);\n\n\treturn ans;\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(FILE_NAME "".in"", ""r"", stdin);\n\t// freopen(FILE_NAME "".out"", ""w"", stdout);\n#endif\n\n\tint T;\n\tscanf(""%d"", &T);\n\tforn(t, T) {\n\t\tassert(read());\n\t\tprintf(""%d\\n"", solve());\n\t}\n\n#ifdef LOCAL\n\tcerr.precision(5);\n\tcerr << ""Time: "" << fixed << (double) clock() / CLOCKS_PER_SEC << endl;\n#endif\n\treturn 0;\n}\n\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2400
Gildong recently learned how to find the longest increasing subsequence LIS in O n log n time for a sequence of length n He wants to test himself if he can implement it correctly but he couldn t find any online judges that would do it even though there are actually many of them So instead he s going to make a quiz for you about making permutations of n distinct integers between 1 and n inclusive to test his code with your output The quiz is as follows Gildong provides a string of length n 1 consisting of characters and only The i th 1 indexed character is the comparison result between the i th element and the i 1 st element of the sequence If the i th character of the string is then the i th element of the sequence is less than the i 1 st element If the i th character of the string is then the i th element of the sequence is greater than the i 1 st element He wants you to find two possible sequences not necessarily distinct consisting of n distinct integers between 1 and n inclusive each satisfying the comparison results where the length of the LIS of the first sequence is minimum possible and the length of the LIS of the second sequence is maximum possible ,"['#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\nusing namespace std;\n\nint T , x , L; char str[2000003];\n\nint main(){\n\tfor(scanf(""%d"" , &T); T ; --T){\n\t\tscanf(""%d %s"" , &L , str + 1); int p = 1 , now = L;\n\t\twhile(p <= L){\n\t\t\tint p1 = p; while(p1 < L && str[p1] == \'<\') ++p1;\n\t\t\tfor(int i = L - p1 + 1 ; i <= L - p + 1 ; ++i) printf(""%d "" , i);\n\t\t\tnow -= p1 - p + 1; p = p1 + 1;\n\t\t}\n\t\tputchar(\'\\n\'); p = 1;\n\t\twhile(p <= L){\n\t\t\tint p1 = p; while(p1 < L && str[p1] == \'>\') ++p1;\n\t\t\tfor(int i = p1 ; i >= p ; --i) printf(""%d "" , i);\n\t\t\tp = p1 + 1;\n\t\t}\n\t\tputchar(\'\\n\');\n\t}\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1800
n people gathered in a room with m tables n ge 2m They want to play the Hat k times Thus k games will be played at each table Each player will play in k games To do this they are distributed among the tables for each game During each game one player plays at exactly one table A player can play at different tables Players want to have the most fair schedule of games For this reason they are looking for a schedule table distribution for each game such that At any table in each game there are either lfloor frac n m rfloor people or lceil frac n m rceil people that is either n m rounded down or n m rounded up Different numbers of people can play different games at the same table Let s calculate for each player the value b i the number of times the i th player played at a table with lceil frac n m rceil persons n m rounded up Any two values of b imust differ by no more than 1 In other words for any two players i and j it must be true b i b j le 1 For example if n 5 m 2 and k 2 then at the request of the first item either two players or three players should play at each table Consider the following schedules First game 1 2 3 are played at the first table and 4 5 at the second one The second game at the first table they play 5 1 and at the second 2 3 4 This schedule is since b 2 2 the second player played twice at a big table and b 5 0 the fifth player did not play at a big table First game 1 2 3 are played at the first table and 4 5 at the second one The second game at the first table they play 4 5 2 and at the second one 1 3 This schedule is b 1 2 1 1 1 any two values of b i differ by no more than 1 Find any fair game schedule for n people if they play on the m tables of k games ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nifstream fin(""AAtest.in.txt"");\nll t,n,m,k,pik,arv,su,ms,va,mv,x,l;\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cerr.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>n>>m>>k;\n        va=n/m; su=(n+m-1)/m;\n        if(va==su) mv=m;\n        else ms=n-m*va,mv=m-ms;\n        arv=min(ms*su,mv*va);\n        x=0;\n        for(int i=0; i<k; i++){\n            l=x;\n            l%=n;\n            for(int j=0; j<m; j++) if(j<ms){\n                cout<<su<<"" "";\n                for(int u=0; u<su; u++){\n                    cout<<l+1<<"" "";\n                    l++;\n                    l%=n;\n                }\n                cout<<""\\n"";\n            }\n            else{\n                cout<<va<<"" "";\n                for(int u=0; u<va; u++){\n                    cout<<l+1<<"" "";\n                    l++;\n                    l%=n;\n                }\n                cout<<""\\n"";\n            }\n            x+=arv;\n        }\n    }\n}\n']","[1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2000
You are given a directed graph of n vertices and m edges Vertices are numbered from 1 to n There is a token in vertex 1 The following actions are allowed Token movement To move the token from vertex u to vertex v if there is an edge u to v in the graph This action takes 1 second Graph transposition To transpose all the edges in the graph replace each edge u to v by an edge v to u This action takes increasingly more time k th transposition takes 2 k 1 seconds i e the first transposition takes 1 second the second one takes 2 seconds the third one takes 4 seconds and so on The goal is to move the token from vertex 1 to vertex n in the shortest possible time Print this time modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn\'t exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr("" ""); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << "", "";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\nint N,M;\nint dp[MX][2][21];\npi mn[MX][2];\nvi adj[MX][2];\npi bes[MX];\n\nusing T = pair<pi,pi>; // {transpositions, dist} and {vertex, color} ??\n// priority_queue<T,V<T>,greater<T>> pq;\n\n// BFS minimizing dist for transpositions < 21\n// Dijkstra minimizing {transpositions,dist}\n\n// void ad(pi loc, pi dist) {\n// \tif (dist.f < 21) {\n\n// \t} else {\n// \t\tif ()\n// \t}\n// }\n\nvoid bfs() {\n\tFOR(i,1,N+1) F0R(j,2) F0R(k,21) dp[i][j][k] = MOD;\n\tdeque<T> todo;\n\tauto upd = [&](pi vertColor, pi info) { // OK\n\t\tif (dp[vertColor.f][vertColor.s][info.f] <= info.s) {\n\t\t\treturn 0;\n\t\t}\n\t\tdp[vertColor.f][vertColor.s][info.f] = info.s;\n\t\treturn 1;\n\t};\n\tauto ad_front = [&](pi vertColor, pi info) {\n\t\tif (!upd(vertColor,info)) return;\n\t\ttodo.push_front({info,vertColor});\n\t};\n\tauto ad_back = [&](pi vertColor, pi info) {\n\t\tif (!upd(vertColor,info)) return;\n\t\ttodo.pb({info,vertColor});\n\t};\n\tad_front({1,0},{0,0});\n\twhile (sz(todo)) { // {transpositions,dist}, {vert,color}\n\t\tT t = todo.ft; todo.pop_front();\n\t\tif (t.f.s > dp[t.s.f][t.s.s][t.f.f]) continue;\n\t\t// dbg(""TRANSPOSITIONS"",""DIST"",""VERT"",""COLOR"",t,adj[t.s.f][t.s.s]);\n\t\tif (t.f.f+1 < 21) ad_front({t.s.f,t.s.s^1},{t.f.f+1,t.f.s});\n\t\ttrav(e,adj[t.s.f][t.s.s]) ad_back({e,t.s.s},{t.f.f,t.f.s+1});\n\t}\n}\n\npi dist[MX][2];\n\nvoid dijk() {\n\tdbg(""DIJK"");\n\tFOR(i,1,N+1) F0R(j,2) dist[i][j] = {MOD,MOD}; // transpositions dist\n\tpriority_queue<T,V<T>,greater<T>> todo;\n\tauto ad = [&](pi vertColor, pi info) {\n\t\tif (ckmin(dist[vertColor.f][vertColor.s],info)) {\n\t\t\ttodo.push({info,vertColor});\n\t\t}\n\t};\n\tad({1,0},{0,0});\n\twhile (sz(todo)) {\n\t\tauto t = todo.top(); todo.pop();\n\t\tif (t.f > dist[t.s.f][t.s.s]) continue;\n\t\tad({t.s.f,t.s.s^1},{t.f.f+1,t.f.s});\n\t\ttrav(e,adj[t.s.f][t.s.s]) ad({e,t.s.s},{t.f.f,t.f.s+1});\n\t}\n\tpi ans = min(dist[N][0],dist[N][1]);\n\tdbg(""HA"",ans);\n\tps(pow(mi(2),ans.f)-1+ans.s);\n\texit(0);\n\t// pi p = {};\n}\n\nint main() {\n\tsetIO(); re(N,M);\n\tF0R(i,M) {\n\t\tint u,v; re(u,v);\n\t\t// dbg(""ED"",u,v);\n\t\tadj[u][0].pb(v);\n\t\tadj[v][1].pb(u);\n\t}\n\tbfs();\n\tint ans = MOD;\n\tF0R(j,2) F0R(k,21) if (dp[N][j][k] != MOD) {\n\t\t// dbg(""HA"",j,k,dp[N][j][k]);\n\t\tckmin(ans,(1<<k)-1+dp[N][j][k]);\n\t}\n\tif (ans != MOD) {\n\t\tps(ans);\n\t\texit(0);\n\t}\n\tdijk();\n\n\t// FOR(i,1,N+1) {\n\t// \tmn[i] = MOD;\n\t// \tbes[i] = {MOD,MOD};\n\t// \tF0R(j,2) F0R(k,21) dp[i][j][k] = MOD;\n\t// }\n\t// ad({1,0},{0,0});\n\t// F0R(i,21) {\n\n\t// }\n\t// while (1) {\n\t// \tT p = pq.top(); pq.pop();\n\t// \tif (mn[p.s] < p.f.f && p.f.f >= 21) continue;\n\t// \ttrav(t,adj[][]) {\n\n\t// \t}\n\t// }\n\t// FOR(i,1,N+1) F0R(j,21) dp[i][j] = MOD;\n\t// dp[1][0] = 1;\n\t// F0R(mov,21) {\n\n\t// }\n\t// first get min for each vert\n\t// if some are still not reached\n\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2400
Watchmen are in a danger and Doctor Manhattan together with his friend Daniel Dreiberg should warn them as soon as possible There are watchmen on a plane the th watchman is located at point They need to arrange a plan but there are some difficulties on their way As you know Doctor Manhattan considers the distance between watchmen and to be Daniel as an ordinary person calculates the distance using the formula The success of the operation relies on the number of pairs such that the distance between watchman and watchmen calculated by Doctor Manhattan is equal to the distance between them calculated by Daniel You were asked to compute the number of such pairs ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  map <int, int> xs;\n  map <int, int> ys;\n  map < pair <int, int>, int > zs;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    scanf(""%d %d"", &x, &y);\n    ans += (xs[x]++);\n    ans += (ys[y]++);\n    ans -= (zs[make_pair(x, y)]++);\n  }\n  cout << ans << endl;\n  return 0;\n}\n']","[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
n people gathered to hold a jury meeting of the upcoming competition the i th member of the jury came up with a i tasks which they want to share with each other First the jury decides on the order which they will follow while describing the tasks Let that be a permutation p of numbers from 1 to n an array of size n where each integer from 1 to n occurs exactly once Then the discussion goes as follows If a jury member p 1 has some tasks left to tell then they tell one task to others Otherwise they are skipped If a jury member p 2 has some tasks left to tell then they tell one task to others Otherwise they are skipped If a jury member p n has some tasks left to tell then they tell one task to others Otherwise they are skipped If there are still members with tasks left then the process repeats from the start Otherwise the discussion ends A permutation p is nice if none of the jury members tell two or more of their own tasks in a row Count the number of nice permutations The answer may be really large so print it modulo 998 244 353 ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 200001; \n\n\nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvoid __print(mi X) {\n    cout << X.v;\n}\nmi facs[MX];\nmi facInvs[MX];\n\nmi choose(mi _a, mi _b) {\n    ll a = (ll) _a, b = (ll) _b;\n\tif (b > a) return 0;\n\tif (a < 0) return 0;\n\tif (b < 0) return 0;\n    mi cur = facs[a];\n    cur = cur * facInvs[b];\n    cur = cur * facInvs[a-b];\n    return cur;\n}\n\nvoid initFacs() {\n\tfacs[0] = 1;\n\tFOR(i, 1, MX) {\n\t\tfacs[i] = (facs[i-1] * i);\n\t}\n    facInvs[MX - 1] = inv(facs[MX-1]);\n    F0Rd(i, MX-1) {\n        facInvs[i] = facInvs[i+1] * (i+1);\n    }\n}\nvoid solve() {\n    int N; cin >> N;\n    vi A(N); F0R(i, N) cin >> A[i];\n    sort(all(A));\n    if (A[N-1] == A[N-2]) {\n        cout << facs[N] << nl;\n    } else if (A[N-1] - 2 >= A[N-2]) {\n        cout << 0 << nl;\n    } else {\n        int cnt = 0;\n        F0R(i, N) if (A[i] == A[N-2]) cnt++;\n        cout << facs[N] * cnt * inv(mi(cnt+1)) << nl;\n    }\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n    initFacs();\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1500
In mathematics a is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements For example the sequence is a subsequence of A of a string is a continuous subsequence of the string For example is a substring of You are given two strings and another string called Your task is to find the longest common subsequence of and such that it doesn t contain as a substring ,"['#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\n//#pragma comment(linker,""/STACK:102400000,102400000"")\n\nint nA, nB, nVirus;\nstring A, B, virus;\nint trans[101][26];\n\nstring prefix(string A, int len)\n{\n\tstring ret;\n\tfor(int i = 0; i < len; i++)\n\t\tret += A[i];\n\treturn ret;\n}\n\nbool endWith(string A, string pat)\n{\n\tif(A.length() < pat.length()) return false;\n\tfor(int i = 0; i < pat.length(); i++)\n\t\tif(A[i - (int)pat.length() + (int)A.length()] != pat[i])\n\t\t\treturn false;\n\treturn true;\n}\n\nint getStateID(string s)\n{\n\tint ret = 0;\n\tfor(int i = 1; i <= nVirus; i++)\n\t\tif(endWith(s, prefix(virus, i)))\n\t\t\tret = i;\n\treturn ret;\n}\n\nint F[101][101][101];\nint nex1[101][101][101];\nint nex2[101][101][101];\nint nex3[101][101][101];\nstring nex0[101][101][101];\nint done[101][101][101];\n\nint f(int pA, int pB, int state)\n{\n\tif(state == nVirus) return -10000;\n\tif(pA == nA && pB == nB) return 0;\n\tif(done[pA][pB][state]) return F[pA][pB][state];\n\tint &ret = F[pA][pB][state];\n\tret = -10000;\n\tdone[pA][pB][state] = true;\n\tif(pA != nA)\n\t{\n\t\tint v = f(pA + 1, pB, state);\n\t\tif(v > ret)\n\t\t{\n\t\t\tret = v;\n\t\t\tnex1[pA][pB][state] = pA + 1;\n\t\t\tnex2[pA][pB][state] = pB;\n\t\t\tnex3[pA][pB][state] = state;\n\t\t\tnex0[pA][pB][state] = """";\n\t\t}\n\t}\n\tif(pB != nB)\n\t{\n\t\tint v = f(pA, pB + 1, state);\n\t\tif(v > ret)\n\t\t{\n\t\t\tret = v;\n\t\t\tnex1[pA][pB][state] = pA;\n\t\t\tnex2[pA][pB][state] = pB + 1;\n\t\t\tnex3[pA][pB][state] = state;\n\t\t\tnex0[pA][pB][state] = """";\n\t\t}\n\t}\n\tif(pA != nA && pB != nB && A[pA] == B[pB])\n\t{\n\t\tint v = 1 + f(pA + 1, pB + 1, trans[state][A[pA]-\'A\']);\n\t\tif(v > ret)\n\t\t{\n\t\t\tret = v;\n\t\t\tnex1[pA][pB][state] = pA + 1;\n\t\t\tnex2[pA][pB][state] = pB + 1;\n\t\t\tnex3[pA][pB][state] = trans[state][A[pA]-\'A\'];\n\t\t\tnex0[pA][pB][state] = A[pA];\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint MAIN()\n{\n\tcin >> A >> B >> virus;\n\tnA = A.length();\n\tnB = B.length();\n\tnVirus = virus.length();\n\tmemset(nex1, 0xff, sizeof(nex1));\n\tfor(int i = 0; i < nVirus; i++)\n\t\tfor(int j = 0; j < 26; j++)\n\t\t\ttrans[i][j] = getStateID(prefix(virus, i) + char(\'A\' + j));\n\tmemset(done, 0, sizeof(done));\n\tint ans = f(0, 0, 0);\n\tif(ans == 0)\n\t\tcout << ans << endl;\n\telse\n\t{\n\t\tint arg1 = 0;\n\t\tint arg2 = 0;\n\t\tint arg3 = 0;\n\t\tstring ansString;\n\t\twhile(nex1[arg1][arg2][arg3] != -1)\n\t\t{\n\t\t\tansString += nex0[arg1][arg2][arg3];\n\t\t\tint nextArg1 = nex1[arg1][arg2][arg3];\n\t\t\tint nextArg2 = nex2[arg1][arg2][arg3];\n\t\t\tint nextArg3 = nex3[arg1][arg2][arg3];\n\t\t\targ1 = nextArg1;\n\t\t\targ2 = nextArg2;\n\t\t\targ3 = nextArg3;\n\t\t}\n\t\tcout << ansString << endl;\n\t}\n\n\t\n\treturn 0;\n}\n\nint main()\n{\n\t#ifdef LOCAL_TEST\n\t\tfreopen(""in.txt"", ""r"", stdin);\n\t\tfreopen(""out.txt"", ""w"", stdout);\n\t#endif\n\tios :: sync_with_stdio(false);\n\tcout << fixed << setprecision(16);\n\treturn MAIN();\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2000
You are given an array consisting of positive integers You pick two integer numbers and from to inclusive numbers are picked randomly equiprobably and independently If then you swap values of and You have to calculate the expected value of the number of unique elements in segment of the array from index to index inclusive indexed ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define N 1048576\nint n , a[ N ] , p[ N ];\nint main(){\n  scanf( ""%d"" , &n );\n  for( int i = 1 ; i <= n ; i ++ )\n    scanf( ""%d"" , &a[ i ] );\n  LL s = 0 , ans = 0;\n  for( int i = 1 ; i <= n ; i ++ ){\n    s += i - p[ a[ i ] ];\n    p[ a[ i ] ] = i;\n    ans += s;\n  }\n  ans = ans + ans - n;\n  double fans = (double)ans / ( (LL)n * n );\n  printf( ""%.12f\\n"" , fans );\n}\n']","[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Each month Blake gets the report containing main economic indicators of the company Blake Technologies There are commodities produced by the company For each of them there is exactly one integer in the final report that denotes corresponding revenue Before the report gets to Blake it passes through the hands of managers Each of them may reorder the elements in some order Namely the th manager either sorts first numbers in non descending or non ascending order and then passes the report to the manager or directly to Blake if this manager has number Employees of the Blake Technologies are preparing the report right now You know the initial sequence of length and the description of each manager that is value and his favourite order You are asked to speed up the process and determine how the final report will look like ,"[""#include <iostream>\n#include <set>\nusing namespace std;\n\nconst int N = 200011;\n\nmultiset <int> ms;\n\npair <int, int> sta[N];\nint a[N];\n\nint main()\n{\n\tios :: sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tint x;\n\t\tcin >> x;\n\t\t//ms.insert(x);\n\t\ta[i] = x;\n\t}\n\tint top = 0;\n\tfor(int i = 0; i < m; i ++)\n\t{\n\t\tint t, r;\n\t\tcin >> t >> r;\n\t\twhile(top > 0 && r >= sta[top - 1].first)\n\t\t\ttop --;\n\t\tsta[top ++] = {r, t};\n\t}\n\tsta[top ++] = {0, 0};\n\tfor(int i = 1; i <= sta[0].first; i ++)\n\t\tms.insert(a[i]);\n\tfor(int i = 0; i < top - 1; i ++)\n\t\tif(sta[i].second == 1)\n\t\t\tfor(int j = sta[i].first; j > sta[i + 1].first; j --)\n\t\t\t{\n\t\t\t\tauto it = ms.rbegin();\n\t\t\t\ta[j] = *it;\n\t\t\t\tms.erase(ms.find(*it));\n\t\t\t}\n\t\telse\n\t\t\tfor(int j = sta[i].first; j > sta[i + 1].first; j --)\n\t\t\t{\n\t\t\t\tauto it = ms.begin();\n\t\t\t\ta[j] = *it;\n\t\t\t\tms.erase(it);\n\t\t\t}\n\tfor(int i = 1; i <= n; i ++)\n\t\tcout << a[i] << ' ';\n\tcout << '\\n';\n\treturn 0;\n}\n""]","[0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1700
After the contest in comparing numbers Shapur s teacher found out that he is a real genius and that no one could possibly do the calculations faster than him even using a super computer Some days before the contest the teacher took a very simple looking exam and all his students took part in the exam The teacher gave them strings and asked them to them Concatenating strings means to put them in some arbitrary order one after the other For example from concatenating and we can get to or depending on the order of concatenation Unfortunately enough the teacher forgot to ask students to concatenate their strings in a pre defined order so each student did it the way he she liked Now the teacher knows that Shapur is such a fast calculating genius boy and asks him to correct the students papers Shapur is not good at doing such a time taking task He rather likes to finish up with it as soon as possible and take his time to solve 3 SAT in polynomial time Moreover the teacher has given some advice that Shapur has to follow Here s what the teacher said As I expect you know the strings I gave to my students including you contained only lowercase and uppercase Persian Mikhi Script letters These letters are too much like Latin letters so to make your task much harder I converted all the initial strings and all of the students answers to Latin As latin alphabet has much less characters than Mikhi Script I added three odd looking characters to the answers these include and These characters are my own invention of course And I call them The length of all initial strings was less than or equal to and the lengths of my students answers are less than or equal to My son not all students are genius as you are It is quite possible that they make minor mistakes changing case of some characters For example they may write instead of Don t be picky and ignore these mistakes Those signs which I previously talked to you about are not important You can ignore them since many students are in the mood for adding extra signs or forgetting about a sign So something like is the same as You should indicate for any of my students if his answer was right or wrong Do this by writing for Wrong answer or for a correct answer I should remind you that none of the strings initial strings or answers are empty Finally do these as soon as possible You have less than hours to complete this ,"['# include <cstdio>\n# include <cctype>\n# include <cstring>\n\nchar inp1[101],inp2[101],inp3[101];\nchar check[6][301];\nchar student[601];\n\nvoid generate(char *i1,char *i2,char *i3,char* out)\n{\n\tstrcpy(out,i1);\n\tstrcat(out,i2);\n\tstrcat(out,i3);\n}\n\nvoid modify(char *inp)\n{\n\tint pos=0;\n\tfor(int i=0;inp[i];i++)\n\t\tif(isalpha(inp[i]))\n\t\t\tinp[pos++]=tolower(inp[i]);\n\tinp[pos]=0;\n}\n\nint main()\n{\n\tscanf(""%s%s%s"",inp1,inp2,inp3);\n\n\tmodify(inp1);\n\tmodify(inp2);\n\tmodify(inp3);\n\t\n\tgenerate(inp1,inp2,inp3,check[0]);\n\tgenerate(inp1,inp3,inp2,check[1]);\n\tgenerate(inp2,inp1,inp3,check[2]);\n\tgenerate(inp2,inp3,inp1,check[3]);\n\tgenerate(inp3,inp2,inp1,check[4]);\n\tgenerate(inp3,inp1,inp2,check[5]);\n\t\n\tint N;\n\tscanf(""%d"",&N);\n\t\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(""%s"",student);\n\t\tmodify(student);\n\t\tfor(int j=0;j<6;j++)\n\t\t\tif(strcmp(student,check[j])==0)\n\t\t\t{\n\t\t\t\tprintf(""ACC\\n"");\n\t\t\t\tgoto bpp;\n\t\t\t}\n\t\tprintf(""WA\\n"");\n\t\tbpp:;\n\t}\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1300
Let s consider a game in which two players A and B participate This game is characterized by two positive integers X and Y The game consists of and each consists of In each of the players either A or B wins A ends when one of the players reaches X wins in the of that This player is declared the winner of the The players play until one of them reaches Y wins in the After that the game ends and this player is declared the winner of the entire game You have just watched a game but didn t notice who was declared the winner You remember that during the game n were played and you know which player won each However you the values of X and Y Based on the available information determine who won the entire game A or B If there is not enough information to determine the winner you should also report it ,"[""#include <iostream>\nusing namespace std;\n\nint n;\nchar p[30];\n\nvoid solve() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> p[i];\n    }\n\n    cout << p[n] << '\\n';\n}\n\nint main() {\n#ifdef ONLINE_JUDGE\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    int t;\n    cin >> t;\n    for (int i = 1; i <= t; i++) {\n        solve();\n    }\n}""]","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",800
There was an epidemic in Monstropolis and all monsters became sick To recover all monsters lined up in queue for an appointment to the only doctor in the city Soon monsters became hungry and began to eat each other One monster can eat other monster if its weight is than the weight of the monster being eaten and they stand in the queue next to each other Monsters eat each other instantly There are no monsters which are being eaten at the same moment After the monster eats the monster the weight of the monster increases by the weight of the eaten monster In result of such eating the length of the queue decreases by one all monsters after the eaten one step forward so that there is no empty places in the queue again A monster can eat several monsters one after another Initially there were monsters in the queue the th of which had weight For example if weights are in order of queue monsters are numbered from to from left to right then some of the options are the first monster can t eat the second monster because is not greater than the second monster can t eat the third monster because is not greater than the second monster can t eat the fifth monster because they are not neighbors the second monster can eat the first monster the queue will be transformed to After some time someone said a good joke and all monsters recovered At that moment there were monsters in the queue the th of which had weight Both sequences and contain the weights of the monsters in the order from the first to the last You are required to provide one of the possible orders of eating monsters which led to the current queue or to determine that this could not happen Assume that the doctor didn t make any appointments while monsters were eating each other ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int MX=(1<<20) , inf = -(1<<29);\nint dp[509][509];\nint sum[509] , n , arr[509];\nvector < pair < int , char > > sol;\nint calc(int x , int y){\n    if(x > y || x == y) return 1;\n    int &ret = dp[x][y]; if(ret != -1) return ret;\n    ret = 0;\n    for(int k = x ; k < y ; k++){\n        if(sum[k] - sum[x-1] != sum[y] - sum[k])\n            ret |= ( calc(x , k) && calc(k+1 , y) );\n    }\n    return ret;\n}\nvoid find_sol(int x , int y , int add){\n    if(x > y || x == y) return;\n    for(int k = x ; k < y ; k++){\n        if(sum[k] - sum[x-1] != sum[y] - sum[k] && calc(x , k) && calc(k+1 , y) ){\n            find_sol(x , k , add);\n            find_sol(k+1 , y , add+1);\n            if(sum[k] - sum[x-1] > sum[y] - sum[k])\n                sol.push_back({add+1 , \'R\'});\n            else sol.push_back({add+2 , \'L\'});\n            break;\n        }\n    }\n}\nbool solve(vector < int > v){\n    n = v.size();\n    for(int j=1;j<=n;j++){\n        arr[j] = v[j-1];\n        sum[j] = arr[j] + sum[j-1];\n    }\n    memset(dp , -1 , sizeof(dp));\n    sol.clear();\n    if(!calc(1,n)) return 0;\n    find_sol(1 , n , 0);\n    return 1;\n}\nint aa , bb;\nint main(){\n    scanf(""%d"",&aa);\n    vector < int > src;\n    for(int j=1;j<=aa;j++){\n        int x;\n        scanf(""%d"",&x);\n        src.push_back(x);\n    }\n    bool nosol = 0;\n    reverse(src.begin() , src.end());\n    scanf(""%d"",&bb);\n    vector < pair < int , char > > wholy;\n    for(int iter = 1 ; iter <= bb ; iter++){\n        vector < int > v;\n        int x;\n        scanf(""%d"",&x);\n        while(!src.empty()){\n            if(src.back() > x) break;\n            v.push_back(src.back());\n            x-=src.back();\n            src.pop_back();\n        }\n        if(x){\n            nosol = 1;\n            break;\n        }\n        if(!solve(v)){\n            nosol = 1;\n            break;\n        }\n        for(auto pp : sol)\n            wholy.push_back({pp.first + iter -1 , pp.second});\n    }\n    if(src.size()) nosol = 1;\n    if(nosol){\n        puts(""NO"");\n        return 0;\n    }\n    puts(""YES"");\n    for(auto pp : wholy)\n        cout<<pp.first<<\' \'<<pp.second<<endl;\n}\n\n']","[1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
You are given a string S and an array of strings t 1 t 2 dots t k Each string t i consists of lowercase Latin letters from to S consists of lowercase Latin letters from to and question marks Each string t i has its cost c i an integer number The value of some string T is calculated as sum limits i 1 k F T t i cdot c i where F T t i is the number of occurences of string t i in T as a substring For example F text aaabaaa text aa 4 You have to replace all question marks in S with lowercase Latin letters from to so the value of S is maximum possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\n\nconst int AC_SIGMA=14,AC_V=22,AC_N=2010;\nstruct node {\n\tnode *go[AC_V],*fail,*f;\n\tll fg;\n}pool[AC_N],*cur,*root,*q[AC_N];\nnode* newnode() {\n\tnode *p=cur++;\n\tmemset(p->go,0,sizeof(p->go)); p->fail=p->f=NULL; p->fg=0;\n\treturn p;\n}\nvoid init() { cur=pool; root=newnode();}\nnode* append(node *p,int w) {\n\tif (!p->go[w]) p->go[w]=newnode(),p->go[w]->f=p;\n\treturn p=p->go[w];\n}\nvoid build() {\n\tint t=1;\n\tq[0]=root;\n\trep(i,0,t) rep(j,0,AC_SIGMA) if (q[i]->go[j]) {\n\t\tnode *v=q[i]->go[j],*p=v->f->fail;\n\t\twhile (p&&!p->go[j]) p=p->fail;\n\t\tif (p) v->fail=p->go[j]; else v->fail=root;\n\t\tq[t++]=q[i]->go[j];\n\t}\n\trep(i,0,t) if (q[i]->fail) q[i]->fg+=q[i]->fail->fg;\n\trep(i,0,t) rep(j,0,AC_SIGMA) if (!q[i]->go[j]) {\n\t\tnode *p=q[i]->fail;\n\t\tif (!p) q[i]->go[j]=root; else q[i]->go[j]=p->go[j];\n\t}\n}\n\nint k,go[20][1010];\nll val[20][1010];\nchar s[401000];\nll dp[(1<<14)+10][1010],tmp[1010];\n\nint main() {\n\tscanf(""%d"",&k);\n\tinit();\n\trep(i,0,k) {\n\t\tscanf(""%s"",s);\n\t\tnode *p=root;\n\t\tint m=strlen(s);\n\t\trep(j,0,m) p=append(p,s[j]-\'a\');\n\t\tint w;\n\t\tscanf(""%d"",&w);\n\t\tp->fg+=w;\n\t}\n\tbuild();\n\tscanf(""%s"",s);\n\tint n=strlen(s);\n\tVI qm;\n\trep(i,0,n) if (s[i]==\'?\') qm.pb(i);\n\tint m=SZ(qm),g=cur-pool;\n\trep(S,0,(1<<14)) rep(j,0,g) dp[S][j]=-(1ll<<60);\n\tdp[0][0]=0;\n\t/*rep(j,0,g) {\n\t\tprintf(""%d %lld\\n"",j,pool[j].fg);\n\t\trep(k,0,14) printf(""go %d %d %d\\n"",j,k,pool[j].go[k]-pool);\n\t}*/\n\tll ans=-(1ll<<60);\n\trep(pf,0,m+1) {\n\t\tint l=(pf==0)?0:qm[pf-1]+1;\n\t\tint r=(pf==m)?(n-1):(qm[pf]-1);\n\t\trep(j,0,g) {\n\t\t\tnode *p=pool+j;\n\t\t\tll ss=0;\n\t\t\trep(k,l,r+1) {\n\t\t\t\tassert(s[k]!=\'?\');\n\t\t\t\tp=p->go[s[k]-\'a\'];\n\t\t\t\tss+=p->fg;\n\t\t\t}\n\t\t\tgo[pf][j]=p-pool;\n\t\t\tval[pf][j]=ss;\n\t\t}\n\t}\n\trep(S,0,(1<<14)) {\n\t\tint pf=__builtin_popcount(S);\n\t\tif (pf>m) continue;\n\t\trep(j,0,g) tmp[j]=-(1ll<<60);\n\t\trep(j,0,g) tmp[go[pf][j]]=max(tmp[go[pf][j]],dp[S][j]+val[pf][j]);\n\t\tif (__builtin_popcount(S)==m) {\n\t\t\trep(i,0,g) ans=max(ans,tmp[i]);\n\t\t}\n\t\t//rep(k,0,g) printf(""Tmp %d %d %lld\\n"",S,k,tmp[k]);\n\t\t//rep(k,0,g) printf(""Dp %d %d %lld\\n"",S,k,dp[S][k]);\n\t\trep(j,0,14) if (!(S&(1<<j))) {\n\t\t\trep(k,0,g) {\n\t\t\t\tnode *p=pool[k].go[j];\n\t\t\t\tdp[S|(1<<j)][p-pool]=max(dp[S|(1<<j)][p-pool],tmp[k]+p->fg);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%lld\\n"",ans);\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2800
There are shovels in Polycarp s shop The th shovel costs burles that is the first shovel costs burle the second shovel costs burles the third shovel costs burles and so on Polycarps wants to sell shovels in pairs Visitors are more likely to buy a pair of shovels if their total cost ends with several s Because of this Polycarp wants to choose a pair of shovels to sell in such a way that the sum of their costs ends with maximum possible number of nines For example if he chooses shovels with costs and their total cost is it ends with two nines You are to compute the number of pairs of shovels such that their total cost ends with maximum possible number of nines Two pairs are considered different if there is a shovel presented in one pair but not in the other ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,dp[20][2][2][2][2],a[20];\nvoid DP(){\n\tint mx=0;\n\tlong long MX=0;\n\tfor(;;){\n\t\tMX=MX*10+9;\n\t\tif(MX>=n*2){\n\t\t\tMX/=10;\n\t\t\tbreak;\n\t\t}\n\t\tmx++;\n\t}\n\tint sz=0;\n\twhile(n)a[sz++]=n%10,n/=10;\n\tfor(int l=0,r=sz-1;l<r;l++,r--)swap(a[l],a[r]);\n\tif(sz==mx){\n\t\tfor(int i=0;i<=a[0];i++)\n\t\t\tif(9-i<=i)\n\t\t\t\tdp[0][(i==9-i)][(i==a[0])][(i==0)][(9-i==0)]++;\n\t}else {\n\t\tfor(int i=0;i<=a[0];i++)\n\t\t\tfor(int j=0;j<=i;j++)\n\t\t\t\tdp[0][(i==j)][(i==a[0])][(i==0)][(j==0)]++;\n\t}\n\tsz--;\n\tfor(int i=0,p=1,s1,s2,s3,s4;i<sz;i++,p++)\n\t\tfor(int j=0;j<2;j++)\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t\tfor(int l=0;l<2;l++)\n\t\t\t\t\tfor(int o=0;o<2;o++)\n\t\t\t\t\t\tfor(int A=0,B=9;A<=9;A++,B--){\n\t\t\t\t\t\t\tif(j&&A<B)continue;\n\t\t\t\t\t\t\tif(k&&A>a[p])continue;\n\t\t\t\t\t\t\ts1=j&(A==B);\n\t\t\t\t\t\t\ts2=k&(A==a[p]);\n\t\t\t\t\t\t\ts3=l&(A==0);\n\t\t\t\t\t\t\ts4=o&(B==0);\n\t\t\t\t\t\t\tdp[p][s1][s2][s3][s4]+=dp[i][j][k][l][o];\n\t\t\t\t\t\t}\n\tint ans=dp[sz][0][0][0][0]+dp[sz][0][1][0][0];\n\tprintf(""%d\\n"",ans);\n}\nint main(){\n\tscanf(""%d"",&n);\n\tDP();\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Vasya s got a birthday coming up and his mom decided to give him an array of positive integers of length Vasya thinks that an array s beauty is the greatest common divisor of all its elements His mom of course wants to give him as beautiful an array as possible with largest possible beauty Unfortunately the shop has only one array left On the plus side the seller said that he could decrease some numbers in the array no more than by for each number The seller can obtain array from array if the following conditions hold for all Help mom find the maximum possible beauty of the array she will give to Vasya that seller can obtain ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define M 1000000\n\nint K;\nint s[M+10];\n\nbool check(int p){\n    for(int x=0;x<=M;x+=p){\n        int ymax = min(x+p-1, M);\n        int ymin = ((x == 0) ? 1 : (x+K+1));\n        if(ymin <= ymax && s[ymin] < s[ymax+1]) return false;\n    }\n    return true;\n}\n\nint main(void){\n    int N,x,i;\n    \n    cin >> N >> K;\n    REP(i,N){\n        scanf(""%d"", &x);\n        s[x+1] = 1;\n    }\n    \n    REP(i,M+5) s[i+1] += s[i];\n    \n    for(i=M;i>=2;i--) if(check(i)) break;\n    cout << i << endl;\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]",2100
You are given two strings s t of length n m respectively Both strings consist of lowercase letters of the English alphabet Count the triples x y z of strings such that the following conditions are true s x y z the symbol represents the concatenation t x underbrace y dots y k text times z for some integer k ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\nbool dbg=false;\n\n//FOR を rng に置換したけど流石に平気やろ\n//Petrozavodsk 2019w Day9 G\nvi kmp(const string&s){\n\tint n=s.size();\n\tvi v(n+1);\n\tv[0]=-1;\n\trng(i,1,n+1){\n\t\tint j=v[i-1];\n\t\twhile(j>=0&&s[j]!=s[i-1])\n\t\t\tj=v[j];\n\t\tv[i]=j+1;\n\t}\n\treturn v;\n}\n\nvi periods(const string&s){\n\tint n=s.size();\n\tvi x=kmp(s),v;\n\tfor(int i=x[n];i!=-1;i=x[i])\n\t\tv.pb(n-i);\n\treturn v;\n}\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tstring s,t;cin>>s>>t;\n\tint pre=0;\n\twhile(pre<n&&s[pre]==t[pre])pre++;\n\tint suf=0;\n\twhile(suf<n&&s[n-1-suf]==t[m-1-suf])suf++;\n\t\n\tll ans=0;\n\tint l=n-suf,r=pre;\n\tif(l<r){\n\t\t//vi x=periods(s.substr(l,r-l));\n\t\tvi y=periods(t.substr(l,r-l+(m-n)));\n\t\t//vc<bool> a(r-l+1),b(r-l+1);\n\t\t//for(auto v:x)a[v]\n\t\tfor(auto len:y){\n\t\t\tif(len<=r-l&&(m-n)%len==0){\n\t\t\t\tans+=r-l-len+1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\t//int t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",3000
You are given a string s consisting only of characters and You perform some process with this string This process can be described by the following pseudocode res 0for init 0 to inf cur init ok true for i 1 to s res res 1 if s i cur cur 1 else cur cur 1 if cur 0 ok false break if ok breakNote that the inf denotes infinity and the characters of the string are numbered from 1 to s You have to calculate the value of the res after the process ends ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while (T--) {\n        string S; cin >> S;\n        int N = sz(S);\n        ll pre[N];\n        ll cur = 0;\n        F0R(i, N) {\n            pre[i] = cur;\n            if (i > 0) ckmax(pre[i], pre[i-1]);\n\n            if (S[i] == \'+\') {\n                cur--;\n            } else cur++;\n        }\n\n        ll res = max(pre[N-1], cur);\n        ll ans = 0;\n        F0R(i, N) {\n            ans += res - pre[i] + 1;\n        }\n        cout << ans << nl;\n    }\n\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
A family consisting of father bear mother bear and son bear owns three cars Father bear can climb into the largest car and he likes it Also mother bear can climb into the middle car and she likes it Moreover son bear can climb into the smallest car and he likes it It s known that the largest car is strictly larger than the middle car and the middle car is strictly larger than the smallest car Masha came to test these cars She could climb into all cars but she liked only the smallest car It s known that a character with size can climb into some car with size if and only if he or she likes it if and only if he can climb into this car and You are given sizes of bears and Masha Find out some possible integer non negative sizes of cars ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define _USE_MATH_DEFINES\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef complex<ld> pt;\ntypedef vector<pt> pol;\n#define nl '\\n'\n\n///* advent of code\ntypedef istringstream iss;\n#define pb push_back\n#define ins insert\n#define multiset mset\n#define getl(A) getline(cin, A)\n//*/\n\nconst ll INF = 0x3f3f3f3f;\nconst ll MOD = 1e9+7;\nconst ld EPS = 1e-9;\n\n\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\n\tint a, b, c, d;\n\tcin >> a >> b >> c >> d;\n\tfor (int i = 1; i <= 200; i++) {\n\t\tfor (int j = 1; j < i; j++) {\n\t\t\tfor (int k = 1; k < i; k++) {\n\t\t\t\tif (a <= i and i <= 2*a and b <= j and j <= 2*b and c <= k and k <= 2*c\n\t\t\t\t\t\tand d <= k and k <= 2*d and j > 2*d) {\n\t\t\t\t\tcout << i << nl;\n\t\t\t\t\tcout << j << nl;\n\t\t\t\t\tcout << k << nl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << -1 << nl;\n\n\treturn 0;\n}\n""]","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300
You are given a string s of length n consisting only of lowercase Latin letters A substring of a string is a contiguous subsequence of that string So string is substring of string but string is not Your task is to calculate the number of ways to remove one substring from this string in such a way that remaining characters are the number of distinct characters either zero or one It is guaranteed that there is different characters in s Note that you remove the whole string and it is correct Also note that you should Since the answer can be rather large not very large though print it modulo 998244353 ,"['#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 200005\n#define INF 1000000000\n#define MOD 998244353\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,k,a[MAXN];\nstring str;\nvoid inc(int &a) {a++; if(a>=MOD) a-=MOD;}\nint main()\n{\n    scanf(""%d"",&n);\n    cin>>str;\n    char ch=str[0];\n    int ans=1;\n    for(int i=1;i<n;i++) \n    {\n        if(str[i]!=ch) break;\n        inc(ans);\n    }\n    inc(ans);\n    ch=str[n-1];\n    for(int i=n-2;i>=0;i--)\n    {\n        if(str[i]!=ch) break;\n        inc(ans);\n    }\n    if(str[0]==str[n-1])\n    {\n        ch=str[0];\n        int l=1,r=n-2;\n        while(str[r]==ch) r--;\n        while(str[l]==ch) l++;\n        ans=1LL*(l+1)*(n-r)%MOD;\n    }\n    else inc(ans);\n    printf(""%d\\n"",ans);\n    return 0;\n}\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]",1300
Dima is a good person In fact he s great But all good things come to an end Seryozha is going to kick Dima just few times For this reason he divides the room into unit squares Now the room is a rectangle consisting of unit squares For the beginning Seryozha put Dima in a center of some square Then he started to kick Dima it is known that he kicks Dima at least once Each time when Dima is kicked he flyes up and moves into one of four directions up left right down On each move Dima passes unit of the length in the corresponding direction Seryozha is really kind so he kicks Dima in such way that Dima never meets the walls in other words Dima never leave the room s space Seryozha is also dynamic character so Dima never flies above the same segment connecting a pair of adjacent squares twice Seryozha kicks Dima for a long time but Dima is not vindictive Dima writes Dima marked all squares in which he was staying or above which he was flying Thanks to kicks Dima does not remember the value so he asks you to find all possible values which matches to the Dima s records ,"['#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<string>\n#include<vector>\n#include<set>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n#define Fill(a,b) memset(a,b,sizeof(a))\n#define FI first\n#define SE second\n#define MP make_pair\n#define PII pair<int,int>\n#define flt double\n#define INF (0x3f3f3f3f)\n#define MaxN 1020300\n#define MaxNode 1020304\n#define MD 1000000007\n#define UPD(a,b) { a = max(a,(b)); }\n\nconst int pi[] = {0,1,0,-1};\nconst int pj[] = {1,0,-1,0};\n\nint n,m,A[1111][1111],u[1111][1111],l[1111][1111],vis[1111][1111];\nint can[6];\nPII q[MaxN];\n\nint main() {\n\t//freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"",stdout);\n\tcin >> n >> m;\n\tFill(A,0);\n\tFor(i,1,n) For(j,1,m) scanf(""%d"",&A[i][j]);\n\tFill(vis,0); int cnt = 0; \n\tFor(i,1,n) For(j,1,m) if (!vis[i][j] && A[i][j] == 1) {\n\t\t++cnt;\n\t\tint hd = 0, tl = 1;\n\t\tvis[i][j] = true; q[1] = MP(i,j);\n\t\twhile (hd < tl) {\n\t\t\tPII vex = q[++hd];\n\t\t\tFor(p,0,3) {\n\t\t\t\tint ni = vex.FI + pi[p], nj = vex.SE + pj[p];\n\t\t\t\tif (!vis[ni][nj] && ni && nj && ni <= n && nj <= m && A[ni][nj] == 1) {\n\t\t\t\t\tvis[ni][nj] = true;\n\t\t\t\t\tq[++tl] = MP(ni,nj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt > 1) {\n\t\tputs(""-1""); return 0;\n\t}\n\tint odd = 0,GCD = 0;\n\tFor(i,1,n) For(j,1,m) {\n\t\tif (!A[i][j]) {\n\t\t\tl[i][j] = u[i][j] = 0; continue ;\n\t\t}\n\t\tl[i][j] = l[i][j - 1] + 1;\n\t\tu[i][j] = u[i - 1][j] + 1;\n\t\tFill(can,0);\n\t\tint sm = 0;\n\t\tFor(p,0,3) {\n\t\t\tint ni = i + pi[p], nj = j + pj[p];\n\t\t\tif (A[ni][nj]) can[p] = true;\n\t\t\tsm += can[p];\n\t\t}\n\t\tif (sm == 2 && ((can[0] && can[2]) || (can[1] && can[3]))) continue ;\n\t\todd += sm & 1;\n\t\tGCD = __gcd(GCD,l[i][j] - 1);\n\t\tGCD = __gcd(GCD,u[i][j] - 1);\n\t}\n\tif (GCD <= 1 || (odd != 0 && odd != 2)) {\n\t\tputs(""-1""); return 0;\n\t}\n\tFor(i,2,max(n,m)) if (GCD % i == 0) printf(""%d "",i); puts("""");\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",2300
You are given an integer array a of length n Does there exist an array b consisting of n 1 positive integers such that a i gcd b i b i 1 for all i 1 leq i leq n Note that gcd x y denotes the greatest common divisor GCD of integers x and y ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC> bool cmin(typC &x,const typC &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC> bool cmax(typC &x,const typC &y) { if (x<y) { x=y; return 1; } return 0; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// void inc(ui &x,const ui &y) { if ((x+=y)>=p) x-=p; }\n// void dec(ui &x,const ui &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<setiosflags(ios::fixed)<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n;\n\t\tvector<int> a(n);\n\t\tcin>>a;\n\t\tfor (i=2; i<n; i++) if (a[i-1]%gcd(a[i],a[i-2])) break;\n\t\tif (i<n) cout<<""NO\\n""; else cout<<""YES\\n"";\n\t}\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1200
Shapur was an extremely gifted student He was great at everything including Combinatorics Algebra Number Theory Geometry Calculus etc He was not only smart but extraordinarily fast He could manage to sum numbers in a single second One day in 230 AD Shapur was trying to find out if any one can possibly do calculations faster than him As a result he made a very great contest and asked every one to come and take part In his contest he gave the contestants many different pairs of numbers Each number is made from digits or The contestants should write a new number corresponding to the given pair of numbers The rule is simple The th digit of the answer is if and only if the th digit of the two given numbers differ In the other case the th digit of the answer is Shapur made many numbers and first tried his own speed He saw that he can perform these operations on numbers of length length of a number is number of digits in it in a glance He always gives correct answers so he expects the contestants to give correct answers too He is a good fellow so he won t give anyone very big numbers and he always gives one person numbers of same length Now you are going to take part in Shapur s contest See if you are faster and more accurate ,"['# include <cstdio>\n\nchar inp1[101],inp2[101];\n\nint main()\n{\n\tscanf(""%s%s"",inp1,inp2);\n\tfor(int i=0;inp1[i];i++)\n\t\tif(inp1[i]==inp2[i])\n\t\t\tprintf(""0"");\n\t\telse\n\t\t\tprintf(""1"");\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
The teachers of the Summer Informatics School decided to plant n trees in a row and it was decided to plant only oaks and firs To do this they made a plan which can be represented as a binary string s of length n If s i 0 then the i th tree in the row should be an oak and if s i 1 then the i th tree in the row should be a fir The day of tree planting is tomorrow and the day after tomorrow an inspector will come to the School The inspector loves nature very much and he will evaluate the beauty of the row as follows First he will calculate l 0 as the maximum number of consecutive oaks in the row the maximum substring consisting of zeros in the plan s If there are no oaks in the row then l 0 0 Then he will calculate l 1 as the maximum number of consecutive firs in the row the maximum substring consisting of ones in the plan s If there are no firs in the row then l 1 0 Finally he will calculate the of the row as a cdot l 0 l 1 for some a the inspector s favourite number The teachers know the value of the parameter a but for security reasons they cannot tell it to you They only told you that a is an integer from 1 to n Since the trees have not yet been planted the teachers decided to change the type of no more than k trees to the opposite i e change s i from 0 to 1 or from 1 to 0 in the plan in order to maximize the beauty of the row of trees according to the inspector For each integer j from 1 to n answer the following question What is the maximum beauty of the row of trees that the teachers can achieve by changing the type of no more than k trees if the inspector s favourite number a is equal to j ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""debug.h""\n#else\n#define debug(...)\n#endif\n\nconst int N = 3005;\n\nint n, k;\nstring s;\nint mx1[N + 1];\nint ps[N + 1];\nint f[N + 1][N];\nint g[N + 1][N];\n\nint sum(int l, int r) { return ps[r + 1] - ps[l]; }\n\nvoid solve() {\n  for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + (s[i] == \'1\');\n  for (int op = 0; op <= k; op++) {\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n      while (j <= i && sum(j, i) > op) j++;\n      if (j <= i) {\n        f[op][i] = i - j + 1;\n      } else {\n        f[op][i] = -1e9;\n      }\n      if (i > 0) f[op][i] = max(f[op][i], f[op][i - 1]);\n    }\n  }\n  for (int i = 0; i < n; i++) ps[i + 1] = ps[i] + (s[i] == \'0\');\n  for (int op = 0; op <= k; op++) {\n    int j = n - 1;\n    for (int i = n - 1; i >= 0; i--) {\n      while (j >= i && sum(i, j) > op) j--;\n      if (j >= i) {\n        g[op][i] = j - i + 1;\n      } else {\n        g[op][i] = -1e9;\n      }\n      if (i < n - 1) g[op][i] = max(g[op][i], g[op][i + 1]);\n    }\n  }\n  for (int u = 0; u <= k; u++) {\n    if (f[u][n - 1] >= 0) {\n      mx1[f[u][n - 1]] = max(mx1[f[u][n - 1]], 0);\n    }\n    if (g[u][0] >= 0) {\n      mx1[0] = max(mx1[0], g[u][0]);\n    }\n    for (int i = 0; i < n - 1; i++) {\n      if (f[u][i] >= 0) {\n        mx1[f[u][i]] = max(mx1[f[u][i]], g[k - u][i + 1]);\n      }\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.exceptions(cin.failbit);\n  cin.tie(NULL);\n  int t;\n  cin >> t;\n  while (t--) {\n    cin >> n >> k;\n    cin >> s;\n    for (int i = 0; i <= n; i++) {\n      mx1[i] = -1e9;\n    }\n    solve();\n    reverse(s.begin(), s.end());\n    solve();\n    for (int a = 1; a <= n; a++) {\n      int ans = 0;\n      for (int i = 0; i <= n; i++) ans = max(ans, i * a + mx1[i]);\n      cout << ans << "" \\n""[a == n];\n    }\n  }\n}']","[1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2200
You are given two integers a and b Moreover you are given a sequence s 0 s 1 dots s n All values in s are integers 1 or 1 It s known that sequence is k periodic and k divides n 1 In other words for each k leq i leq n it s satisfied that s i s i k Find out the remainder of division of sum limits i 0 n s i a n i b i by 10 9 9 ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\nusing ll = long long;\nusing ld = long double;\nusing ull = uint64_t;\nusing namespace std;\n\nconst ll MOD = 1e9 + 9;\n\nll pw(ll a, ll b = MOD - 2) {\n\tif (!b) {\n\t\treturn 1;\n\t}\n\n\tll v = pw(a, b / 2);\n\tv = (v * v) % MOD;\n\n\tif (b & 1) {\n\t\tv = (v * a) % MOD;\n\t}\n\t\n\treturn v;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(20);\n\tll n, a, b, k;\n\tcin >> n >> a >> b >> k;\n\tstring s;\n\tcin >> s;\n\tll c = pw(a, n) % MOD;\n\tll ml = 1;\n\n\tll x = 0;\n\tfor (int i = 0; i < k; ++i) {\n\t\tif (s[i] == \'+\') {\n\t\t\tx += c * ml;\n\t\t} else {\n\t\t\tx -= c * ml;\n\t\t}\n\n\t\tx %= MOD;\n\t\tml = ml * b % MOD * pw(a) % MOD;\n\t}\n\n\tif (x < 0) {\n\t\tx += MOD;\n\t}\n\n\tll d = (n + 1) / k;\n\n\tif (ml == 1) {\n\t\tcout << (x * d) % MOD << ""\\n"";\n\t} else if (ml == 0) {\n\t\tcout << x % MOD << ""\\n"";\n\t} else {\n\t\tll p = pw(ml, d) - 1;\n\t\tll q = ml - 1;\n\t\tll mm = p * pw(q) % MOD;\n\t\tcout << (x * mm) % MOD << ""\\n"";\n\t}\n}\n\n\n\n\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1800
Bob is an avid fan of the video game and today he celebrates as the League of Leesins World Championship comes to an end The tournament consisted of n n ge 5 teams around the world Before the tournament starts Bob has made a prediction of the rankings of each team from 1 st to n th After the final he compared the prediction with the actual result and found out that the i th team according to his prediction ended up at the p i th position 1 le p i le n all p i are unique In other words p is a permutation of 1 2 dots n As Bob s favorite League player is the famous he decided to write down every 3 consecutive elements of the permutation p Formally Bob created an array q of n 2 triples where q i p i p i 1 p i 2 for each 1 le i le n 2 Bob was very proud of his array so he showed it to his friend Alice After learning of Bob s array Alice declared that she could retrieve the permutation p even if Bob rearranges the elements of q and the elements within each triple Of course Bob did not believe in such magic so he did just the same as above to see Alice s respond For example if n 5 and p 1 4 2 3 5 then the original array q will be 1 4 2 4 2 3 2 3 5 Bob can then rearrange the numbers within each triple and the positions of the triples to get 4 3 2 2 3 5 4 1 2 Note that 1 4 2 4 2 2 3 3 5 is not a valid rearrangement of q as Bob is not allowed to swap numbers belong to different triples As Alice s friend you know for sure that Alice was just trying to show off so you decided to save her some face by giving her p that is consistent with the array q she was given ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ntypedef long long ll;\nusing namespace std;\nll n, a[101010][4],sudah[101010],ban[101010],jaw[101010],awal,kedua,ketiga;\nvector<ll> v[101010];\nll ada(ll aa, ll bb)\n{\n\treturn (a[aa][1] == bb || a[aa][2] == bb || a[aa][3] == bb);\n}\nll vld(ll aa)\n{\n\tll jum = sudah[a[aa][1]] + sudah[a[aa][2]] + sudah[a[aa][3]];\n\t// cout << jum << ""AB\\n"";\t\n\treturn (jum == 2);\n}\nll cari(ll aa)\n{\n\tif(!sudah[a[aa][1]])return a[aa][1];\n\tif(!sudah[a[aa][2]])return a[aa][2];\n\tif(!sudah[a[aa][3]])return a[aa][3];\n}\nvoid dfs(ll p1, ll p2, ll idx)\n{\n\t// cout << p1 << "" "" << p2 << "" "" << idx << ""\\n"" ;\n\tll nx = 0;\n\tfor(ll i = 0; i < v[p2].size(); i++)\n\t{\n\t\t// if(ada(v[p2][i],p1))\n\t\t\t// cout << v[p2][i] << "" "" << i << ""___\\n"";\n\t\t// if(vld(v[p2][i]))\n\t\t\t// cout << v[p2][i] << "" "" << i << ""_o_\\n"";\n\t\tif(ada(v[p2][i],p1) && vld(v[p2][i]))\n\t\t\tnx = cari(v[p2][i]);\n\t}\n\tsudah[nx] = 1;\n\tjaw[idx] = nx;\n\tif(nx != 0)\n\t\tdfs(p2, nx, idx + 1);\n}\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin >> n;\n\tfor(ll i = 1; i <= n - 2; i++)\n\t{\n\t\tcin >> a[i][1] >> a[i][2] >> a[i][3];\n\t\tfor(ll j = 1; j <= 3; j++)\n\t\t{\n\t\t\tv[a[i][j]].pb(i);\n\t\t\tban[a[i][j]]++;\n\t\t}\n\t}\t\n\tfor(ll i = 1; i <= n; i++)\n\t\tif(ban[i] == 1)\n\t\t\tawal = i;\n\tll posisi = v[awal][0];\n\t// cout << awal << ""_\\n"";\n\t// cout << posisi << ""_\\n"";\n\tfor(ll i = 1; i <= 3; i++)\n\t\tif(ban[a[posisi][i]] == 2)\n\t\t\tkedua = a[posisi][i];\n\t\telse\n\t\tif(ban[a[posisi][i]] == 3)\n\t\t\tketiga = a[posisi][i];\n\t// cout << kedua << "" "" << ketiga << ""\\n"";\n\tjaw[1] = awal;\n\tjaw[2] = kedua;\n\tjaw[3] = ketiga;\n\tsudah[awal] = 1;\n\tsudah[kedua] = 1;\n\tsudah[ketiga] = 1;\n\t// return 0;\n\tdfs(kedua, ketiga, 4);\n\tfor(ll i = 1; i <= n; i++)\n\t\tcout << jaw[i] << "" "";\n\tcout << ""\\n"";\n} ']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
A sequence of round and square brackets is given You can change the sequence by performing the following operations change the direction of a bracket from opening to closing and vice versa without changing the form of the bracket i e you can change to and to you can change to and to The operation costs 0 burles change any bracket to bracket having the same direction i e you can change to but from to similarly you can change to but from to The operation costs 1 burle The operations can be performed in any order any number of times You are given a string s of the length n and q queries of the type where 1 le l r le n For every substring s l dots r find the minimum cost to pay to make it a correct bracket sequence It is guaranteed that the substring s l dots r has an even length The queries must be processed independently i e the changes made in the string for the answer to a question i don t affect the queries j j i In other words for every query the substring s l dots r is given from the initially given string s A correct bracket sequence is a sequence that can be built according the following rules an empty sequence is a correct bracket sequence if is a correct bracket sequence the sequences and are correct bracket sequences if and are correct bracket sequences the sequence the concatenation of the sequences is a correct bracket sequence E g the sequences and are correct bracket sequences whereas and are not ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nconst int oo=1e9;\nconst int N=1000005;\nint t,sum[N],q,l,r;\nstring s;\nint main() {\n   \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);cout.tie(0);\n    cin>>t;\n    while (t--) {\n        cin>>s;\n        for (int i=0;i<s.length();i++) {\n            sum[i+1]=sum[i];\n            if (s[i]==\'[\'||s[i]==\']\') {\n                if (i%2) sum[i+1]++;\n                else sum[i+1]--;\n            }\n        }\n        cin>>q;\n        for (int i=1;i<=q;i++) {\n            cin>>l>>r;\n            cout<<abs(sum[r]-sum[l-1])<<""\\n"";\n        }\n    }\n}\n']","[1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
You are given an array a 1 a 2 dots a n which is sorted in non descending order You decided to perform the following steps to create array b 1 b 2 dots b n Create an array d consisting of n arbitrary integers Set b i a i d i for each b i Sort the array b in non descending order You are given the resulting array b For each index i calculate what is the minimum and maximum possible value of d i you can choose in order to get the given array b Note that the minimum maximum d i s are of each other i e they can be obtained from different possible arrays d ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    for (int i = 0, j = 0; i < n; i++) {\n        while (b[j] < a[i]) {\n            j++;\n        }\n        std::cout << b[j] - a[i] << "" \\n""[i == n - 1];\n    }\n    \n    for (int i = 0, j = 0; i < n; i++) {\n        j = std::max(j, i);\n        while (j + 1 < n && a[j + 1] <= b[j]) {\n            j++;\n        }\n        std::cout << b[j] - a[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1400
Fishing Prince loves trees and he especially loves trees with only one centroid The tree is a connected graph without cycles A vertex is a of a tree only when you cut this vertex remove it and remove all edges from this vertex the size of the largest connected component of the remaining graph is the smallest possible For example the centroid of the following tree is 2 because when you cut it the size of the largest connected component of the remaining graph is 2 and it can t be smaller However in some trees there might be more than one centroid for example Both vertex 1 and vertex 2 are centroids because the size of the largest connected component is 3 after cutting each of them Now Fishing Prince has a tree He should cut one edge of the tree it means to remove the edge After that he should add one edge The resulting graph after these two operations should be a tree He can add the edge that he cut He wants the centroid of the resulting tree to be unique Help him and find any possible way to make the operations It can be proved that at least one such way always exists ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl \'\\n\'\n//#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\nconst int N = 100100;\nvi g[N];\nint tam[N];\n\n\nvi centroid;\nint n;\nvoid dfs1(int v,int p = -1){\n  tam[v] = 1;\n  bool is= 1;\n\n  for(int to : g[v])if(to!=p){\n    dfs1(to,v);\n    tam[v]+=tam[to];\n    if(tam[to] > n/2)is = 0;\n  }\n  if(n - tam[v] > n/2)is = 0;\n  if(is)centroid.pb(v);\n}\n\n\n\nvoid solve(){\n  cin >> n;\n  for(int i=1;i<=n;i++)g[i].clear(),tam[i] = 1;\n\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    g[a].pb(b);\n    g[b].pb(a);\n  } \n  centroid.clear();\n  dfs1(1);\n  vector<pii> ans;\n  if(sz(centroid) == 1){\n    int to = g[1][0];\n    ans.pb(pii(1,to));\n    ans.pb(pii(1,to));\n  }else{\n    for(int to : g[centroid[0]]){\n      if(to!=centroid[1]){\n        ans.pb(pii(centroid[0],to));\n        ans.pb(pii(to,centroid[1]));\n        break;\n      }\n    }\n  }\n  assert(sz(ans) == 2);\n  for(auto it : ans){\n    cout << it.ff<<"" ""<<it.ss<<endl;\n  }\n}\n\nint32_t main(){\n  FASTIO;\n  int t;\n  cin >> t;\n  while(t--){\n    solve();\n  }\n}']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0]",1700
Vasya is sitting on an extremely boring math class To have fun he took a piece of paper and wrote out numbers on a single line After that Vasya began to write out different ways to put pluses in the line between certain digits in the line so that the result was a correct arithmetic expression formally no two pluses in such a partition can stand together between any two adjacent pluses there must be at least one digit and no plus can stand at the beginning or the end of a line For example in the string ways add no pluses or are correct and ways or are incorrect The lesson was long and Vasya has written all the correct ways to place exactly pluses in a string of digits At this point he got caught having fun by a teacher and he was given the task to calculate the sum of all the resulting arithmetic expressions by the end of the lesson when calculating the value of an expression the leading zeros should be ignored As the answer can be large Vasya is allowed to get only its remainder modulo Help him ,"['#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint mo=1e9+7,nI[110000],I[110000],n,m;\nchar ch[110000];\nint quick(int k1,int k2){\n    int k3=1;\n    while (k2){\n        if (k2&1) k3=1ll*k3*k1%mo; k1=1ll*k1*k1%mo; k2>>=1;\n    }\n    return k3;\n}\nint C(int k1,int k2){\n    if (k2>k1) return 0;\n    return 1ll*I[k1]*nI[k2]%mo*nI[k1-k2]%mo;\n}\nint main(){\n    scanf(""%d%d"",&n,&m); scanf(""%s"",ch+1);\n    if (m==0){\n        int ans=0;\n        for (int i=1;i<=n;i++) ans=(1ll*ans*10+ch[i]-\'0\')%mo;\n        cout<<ans<<endl; return 0;\n    }\n    for (int i=1;i<=n;i++) nI[i]=quick(i,mo-2); nI[0]=1;\n    for (int i=1;i<=n;i++) nI[i]=1ll*nI[i]*nI[i-1]%mo;\n    I[0]=1; for (int i=1;i<=n;i++) I[i]=1ll*I[i-1]*i%mo;\n    int ans=0,num=0,pre=1;\n    for (int i=n;i;i--){\n        int k1=(num+1ll*pre*C(i-1,m))%mo;\n        ans=(ans+1ll*k1*(ch[i]-\'0\'))%mo;\n        num=(num+1ll*pre*C(i-2,m-1))%mo; pre=1ll*pre*10%mo;\n    }\n    cout<<ans<<endl;\n    return 0;\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]",2200
As we all know Dart is some kind of creature from Upside Down world For simplicity we call their kind Dart and other pollywogs are playing a game There are stones in a row numbered from through from left to right At most pollywog may be sitting on each stone at a time Initially the pollywogs are sitting on the first stones one pollywog on each stone Dart and his friends want to end up on the last stones At each second the leftmost pollywog should jump to the right A pollywog can jump at most stones more specifically a pollywog can jump from stone number to stones A pollywog can t jump on an occupied stone Jumping a distance takes amounts of energy from the pollywog Also stones are Each time landing on a special stone takes amounts of energy in addition to the energy for jump from the pollywog could be negative in this case it means the pollywog absorbs amounts of energy Pollywogs want to spend as little energy as possible this value could be negative They re just pollywogs so they asked for your help Tell them the total change in their energy in case they move optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef long long ll;\ntypedef vector<ll> VI;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int M=100;\nconst ll inf=1ll<<60;\nint x,k,n,q,cur,m,p,w,ed;\nint st[400],ps[400],c[100];\nll cost[M][M],g[40][M][M];\nmap<int,VI> dp;\nmap<int,int> hs;\nint cc[10];\nvector<PII> e;\nvoid jumpto(int x) {\n\tx=min(x,ed);\n\tif (cur>=x) return;\n\tVI p=dp[cur];\n\tint d=x-cur;\n\tper(k,0,30) if (d&(1<<k)) {\n\t\tVI q(m,inf);\n\t\trep(i,0,m) rep(j,0,m) q[j]=min(q[j],p[i]+g[k][i][j]);\n\t\tp=q;\n\t}\n\tdp[x]=p;\n\tcur=x;\n}\nvoid moveto(int x) {\n\tx=min(x,ed);\n\tif (cur>=x) return;\n\tVI p=dp[cur];\n\trep(y,cur,x) {\n\t\tVI q(m,inf);\n\t\trep(j,1,k+1) if (hs.count(y+j)) cc[j]=hs[y+j]; else cc[j]=0;\n\t\trep(i,0,m) {\n\t\t\tint S=st[i];\n\t\t\tif (S%2==0) q[ps[S>>1]]=min(q[ps[S>>1]],p[i]);\n\t\t\telse {\n\t\t\t\trep(j,1,k+1) {\n\t\t\t\t\tS=st[i]^1; int cs=c[j]+cc[j];\n\t\t\t\t\tif ((S&(1<<j))==0) {\n\t\t\t\t\t\tS|=(1<<j); S>>=1;\n\t\t\t\t\t\tq[ps[S]]=min(q[ps[S]],p[i]+cs);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp=q;\n\t}\n\tdp[x]=p;\n\tcur=x;\n}\nint main() {\n\tscanf(""%d%d%d%d"",&x,&k,&n,&q);\n\trep(S,0,(1<<k)) if (__builtin_popcount(S)==x) st[ps[S]=m++]=S;\n\trep(i,1,k+1) scanf(""%d"",c+i);\n\trep(i,0,m) rep(j,0,m) cost[i][j]=inf;\n\trep(i,0,m) {\n\t\tif (st[i]%2==0) cost[i][ps[st[i]>>1]]=0;\n\t\telse rep(j,1,k+1) {\n\t\t\tint S=st[i]; S^=1;\n\t\t\tif ((S&(1<<j))==0) {\n\t\t\t\tS|=(1<<j); S>>=1;\n\t\t\t\tcost[i][ps[S]]=c[j];\n\t\t\t}\n\t\t}\n\t}\n\ted=n-x+1;\n\trep(it,0,30) {\n\t\tif (it==0) {\n\t\t\trep(i,0,m) rep(j,0,m) g[it][i][j]=cost[i][j];\n\t\t} else {\n\t\t\trep(i,0,m) rep(j,0,m) g[it][i][j]=inf;\n\t\t\trep(k,0,m) {\n\t\t\t\trep(i,0,m) rep(j,0,m) rep(k,0,m) g[it][i][j]=min(g[it][i][j],g[it-1][i][k]+g[it-1][k][j]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,q) {\n\t\tscanf(""%d%d"",&p,&w); e.pb(mp(p,w));\n\t\ths[p]=w;\n\t}\n\tsort(all(e));\n\tdp[1]=VI(m,inf); dp[1][0]=0;\n\tcur=1;\n\trep(i,0,q) {\n\t\tjumpto(e[i].fi-k);\n\t\tmoveto(e[i].fi+1);\n\t}\n\tjumpto(n-x+1);\n\tprintf(""%lld\\n"",dp[n-x+1][0]);\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2900
The biggest event of the year Cota 2 world championship The Innernational is right around the corner 2 n teams will compete in a double elimination format please carefully read problem statement even if you know what is it to identify the champion Teams are numbered from 1 to 2 n and will play games one on one All teams start in the upper bracket All upper bracket matches will be held played between teams that haven t lost any games yet Teams are split into games by team numbers Game winner advances in the next round of upper bracket losers drop into the lower bracket Lower bracket starts with 2 n 1 teams that lost the first upper bracket game Each lower bracket round consists of two games In the first game of a round 2 k teams play a game with each other teams are split into games by team numbers 2 k 1 loosing teams are eliminated from the championship 2 k 1 winning teams are playing 2 k 1 teams that got eliminated in this round of upper bracket again teams are split into games by team numbers As a result of each round both upper and lower bracket have 2 k 1 teams remaining See example notes for better understanding Single remaining team of upper bracket plays with single remaining team of lower bracket in grand finals to identify championship winner You are a fan of teams with numbers a 1 a 2 a k You want the championship to have as many games with your favourite teams as possible Luckily you can affect results of every championship game the way you want What s maximal possible number of championship games that include teams you re fan of ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<bool> a(1 << n);\n  while (m--) {\n    int x;\n    cin >> x;\n    a[--x] = true;\n  }\n  vector<vector<int>> dp(1 << (n + 1), vector<int>(4, -1));\n  auto merge = [&](int x, int l, int r) {\n    for (int i = 0; i < 4; ++i) {\n      if (dp[l][i] == -1) {\n        continue;\n      }\n      for (int j = 0; j < 4; ++j) {\n        if (dp[r][j] == -1) {\n          continue;\n        }\n        int w1 = i / 2, w2 = j / 2;\n        int l1 = i % 2, l2 = j % 2;\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n        swap(w1, w2);\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n      }\n    }\n  };\n  function<void(int, int, int)> solve = [&](int x, int l, int r) {\n    if (r - l == 2) {\n      if (!a[l] && !a[l + 1]) {\n        dp[x][0] = 0;\n      } else if (a[l] && a[l + 1]) {\n        dp[x][3] = 1;\n      } else {\n        dp[x][1] = dp[x][2] = 1;\n      }\n    } else {\n      int y = (l + r) >> 1, z = x + ((y - l) << 1);\n      solve(x + 1, l, y);\n      solve(z, y, r);\n      merge(x, x + 1, z);\n    }\n  };\n  solve(0, 0, 1 << n);\n  cout << max(dp[0][0], max(dp[0][1] + 1, max(dp[0][2] + 1, dp[0][3] + 1))) << ""\\n"";\n  return 0;\n}\n']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
Iahub does not like background stories so he ll tell you exactly what this problem asks you for You are given a matrix with rows and columns Initially all values of the matrix are zeros Both rows and columns are 1 based that is rows are numbered 1 2 and columns are numbered 1 2 Let s denote an element on the th row and th column as We will call a submatrix such elements for which two inequalities hold Write a program to perform two following operations Query print the xor sum of the elements of the submatrix Update each element from submatrix gets xor ed by value ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\n\nclass fenv_tree_2d {\n  inline static int f(int x) { return x & -x; }\n  vector<vector<ll> > tr;\n\n  public:\n  fenv_tree_2d(int n = 0) : tr(n + 1, vector<ll>(n + 1, 0)) {}\n  void update(int x0, int y0, ll v) {\n    for (int y = y0 + 1; y < sz(tr); y += f(y))\n    for (int x = x0 + 1; x < sz(tr[y]); x += f(x))\n      tr[y][x] ^= v;\n  }\n  ll get(int x0, int y0) {\n    ll res = 0;\n    for (int y = y0 + 1; y > 0; y -= f(y))\n    for (int x = x0 + 1; x > 0; x -= f(x))\n      res ^= tr[y][x];\n    return res;\n  }\n};\n\nclass Solver {\n  fenv_tree_2d trs[2][2];\n  int n, n2;\n\n  public:\n  Solver(int n) : n(n), n2((n + 1) / 2) {\n    for (int a = 0; a < 2; a++)\n    for (int b = 0; b < 2; b++)\n      trs[a][b] = fenv_tree_2d(n2);\n  }\n  void update(int x, int y, ll v) {\n    trs[x & 1][y & 1].update(x >> 1, y >> 1, v);\n  }\n  ll get(int x, int y) {\n    return trs[x & 1][y & 1].get(x >> 1, y >> 1);\n  }\n};\n\nint main() {\n  #ifdef DEBUG\n  freopen("".in"", ""r"", stdin);\n  freopen("".out"", ""w"", stdout);\n  #endif\n\n  int n, m;\n  while (scanf(""%d%d"", &n, &m) >= 1) {\n    Solver tr(n);\n    while (m --> 0) {\n      int ty;\n      int x1, y1, x2, y2;\n      scanf(""%d"", &ty);\n      scanf(""%d%d%d%d"", &x1, &y1, &x2, &y2);\n      x1--, y1--, x2--, y2--;\n\n      if (ty == 1) {\n        // query\n        ll ans = tr.get(x2, y2);\n        if (x1) ans ^= tr.get(x1 - 1, y2);\n        if (y1) ans ^= tr.get(x2, y1 - 1);\n        if (x1 && y1) ans ^= tr.get(x1 - 1, y1 - 1);\n        printf(""%I64d\\n"", ans);\n      } else {\n        // change\n        assert(ty == 2);\n        ll val;\n        scanf(""%I64d"", &val);\n        tr.update(x1, y1, val);\n        if (x2 < n) tr.update(x2 + 1, y1, val);\n        if (y2 < n) tr.update(x1, y2 + 1, val);\n        if (x2 < n && y2 < n) tr.update(x2 + 1, y2 + 1, val);\n      }\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
One evening Rainbow Dash and Fluttershy have come up with a game Since the ponies are friends they have decided not to compete in the game but to pursue a common goal The game starts on a square flat grid which initially has the outline borders built up Rainbow Dash and Fluttershy have flat square blocks with size 1 times1 Rainbow Dash has an infinite amount of light blue blocks Fluttershy has an infinite amount of yellow blocks The blocks are placed according to the following rule each newly placed block must touch the built on the previous turns figure by a side note that the outline borders of the grid are built initially At each turn one pony can place any number of blocks of her color according to the game rules Rainbow and Fluttershy have found out that they can build patterns on the grid of the game that way They have decided to start with something simple so they made up their mind to place the blocks to form a Rainbow Dash is well known for her speed so she is interested in the minimum number of turns she and Fluttershy need to do to get a chess coloring covering the whole grid with blocks Please help her find that number Since the ponies can play many times on different boards Rainbow Dash asks you to find the minimum numbers of turns for several grids of the games The chess coloring in two colors is the one in which each square is neighbor by side only with squares of different colors ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define pf push_front\n#define pob pop_back\n#define pof pop_front\n#define mp make_pair\n#define fi first\n#define se second\n\ntypedef long long lli;\ntypedef pair<int, int> ii;\ntypedef pair<lli, lli> ll;\n\nint main() {\n\tint tc, n;\n\tscanf(""%d"", &tc);\n\twhile (tc--) {\n\t\tscanf(""%d"", &n);\n\t\tprintf(""%d\\n"", (n + 2) / 2);\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are playing one famous sandbox game with the three dimensional world The map of the world can be represented as a matrix of size n times m where the height of the cell i j is a i j You are in the cell 1 1 right now and want to get in the cell n m You can move only down from the cell i j to the cell i 1 j or right from the cell i j to the cell i j 1 There is an additional if the height of the current cell is x then you can move only to the cell with height x 1 you can perform several operations During one operation you can decrease the height of cell by one I e you choose some cell i j and assign set a i j a i j 1 Note that you make heights Also note that you decrease the height of the cell 1 1 Your task is to find the number of operations you have to perform to obtain at least one suitable path from the cell 1 1 to the cell n m It is guaranteed that the answer exists You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n          int a,b;\n          cin>>a>>b;\n          int m[a][b];\n          for (int i=0;i<a;i++) {\n              for (int j=0;j<b;j++) cin>>m[i][j]; \n          }\n          int min1=1000000000000000000;\n          int inf=1000000000000000000;\n          for (int i=0;i<a;i++) {\n              for (int j=0;j<b;j++) {\n                  int qq=m[i][j]-i-j; \n                  if (qq<=m[0][0]) { \n                  vector <vector<int>> dp(a,vector <int>(b)); \n                  dp[0][0]=m[0][0]-qq; \n                  for (int x=0;x<a;x++) {\n                      for (int y=0;y<b;y++) if (x+y>0) {\n                          dp[x][y]=inf; \n                          if (x>0) { if (m[x][y]>=qq+x+y) dp[x][y]=min(dp[x][y],dp[x-1][y]+m[x][y]-qq-x-y); } \n                          if (y>0) { if (m[x][y]>=qq+x+y) dp[x][y]=min(dp[x][y],dp[x][y-1]+m[x][y]-qq-x-y); } \n                      }\n                  }\n                  min1=min(min1,dp[a-1][b-1]); \n                  }\n              }\n          }\n   cout<<min1<<""\\n""; \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Let s define S x to be the sum of digits of number x written in decimal system For example S 5 5 S 10 1 S 322 7 We will call an integer x if S x 1 S x In each test you will be given one integer n Your task is to calculate the number of integers x such that 1 le x le n and x is interesting ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\t// 9 -> 1\n\tints(n);\n\twhile ((n+1)%10 != 0) --n;\n\tps((n+1)/10);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",800
Malek has recently found a treasure map While he was looking for a treasure he found a locked door There was a string written on the door consisting of characters and Below there was a manual on how to open the door After spending a long time Malek managed to decode the manual and found out that the goal is to replace each with one or more characters so that the final string becomes Below there was also written that a string is called if for each there are no more characters than characters among the first characters of and also the total number of characters is equal to the total number of characters Help Malek open the door by telling him for each character how many characters he must replace it with ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nchar s[1234567];\n\nint main() {\n  scanf(""%s"", s);\n  int n = strlen(s);\n  int total = 0;\n  int pos = -1;\n  for (int i = 0; i < n; i++) {\n    total += (s[i] == \'(\' ? 1 : -1);\n    if (s[i] == \'#\') {\n      pos = i;\n    }\n  }\n  if (total < 0) {\n    printf(""%d\\n"", -1);\n    return 0;\n  }\n  int last = 1 + total;\n  total = 0;\n  for (int i = 0; i < n; i++) {\n    total += (i == pos ? -last : (s[i] == \'(\' ? 1 : -1));\n    if (total < 0) {\n      printf(""%d\\n"", -1);\n      return 0;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (s[i] == \'#\') {\n      if (i == pos) {\n        printf(""%d\\n"", last);\n      } else {\n        printf(""%d\\n"", 1);\n      }\n    }\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
The Metropolis computer network consists of n servers each has an encryption key in the range from 0 to 2 k 1 assigned to it Let c i be the encryption key assigned to the i th server Additionally m pairs of servers are directly connected via a data communication channel Because of the encryption algorithms specifics a data communication channel can only be considered safe if the two servers it connects have encryption keys The initial assignment of encryption keys is guaranteed to keep all data communication channels safe You have been informed that a new virus is actively spreading across the internet and it is capable to change the encryption key of any server it infects More specifically the virus body contains some unknown number x in the same aforementioned range and when server i is infected its encryption key changes from c i to c i oplus x where oplus denotes the bitwise XOR operation Sadly you know neither the number x nor which servers of Metropolis are going to be infected by the dangerous virus so you have decided to count the number of such situations in which all data communication channels remain safe Formally speaking you need to find the number of pairs A x where A is some possibly empty subset of the set of servers and x is some number in the range from 0 to 2 k 1 such that when all servers from the chosen subset A and none of the others are infected by a virus containing the number x all data communication channels remain safe Since this number can be quite big you are asked to find its remainder modulo 10 9 7 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 500500;\nint n, m, k;\nll a[N];\nll p2[N];\nmap<ll, vector<pii>> G;\nint par[N];\nint sz[N];\n\nmap<int, int> toId;\nint getId(int v) {\n\tif (toId.count(v) > 0) return toId[v];\n\ttoId[v] = m;\n\tpar[m] = -1;\n\tsz[m] = 1;\n\treturn m++;\n}\n\nint getPar(int v) {\n\treturn par[v] == -1 ? v : par[v] = getPar(par[v]);\n}\nbool unite(int v, int u) {\n\tv = getPar(v);\n\tu = getPar(u);\n\tif (v == u) return false;\n\tif (sz[v] < sz[u]) swap(v, u);\n\tsz[v] += sz[u];\n\tpar[u] = v;\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tp2[i] = add(p2[i - 1], p2[i - 1]);\n\t}\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tll ans = p2[n + k];\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tG[a[v] ^ a[u]].push_back(mp(v, u));\n\t}\n\tfor (auto t : G) {\n\t\tvector<pii> g = t.second;\n\t\tm = 0;\n\t\ttoId.clear();\n\t\tint C = n;\n\t\tfor (pii s : g) {\n\t\t\tint v = getId(s.first), u = getId(s.second);\n\t\t\tif (unite(v, u)) C--;\n\t\t}\n\t\tans = sub(ans, p2[n]);\n\t\tans = add(ans, p2[C]);\n\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0]",2200
Fox Ciel just designed a puzzle game called Polygon It is played using triangulations of a regular edge polygon The goal is to transform one to another by some tricky rules of an edge poylgon is a set of diagonals satisfying the condition that no two diagonals share a common internal point For example the initial state of the game may look like a in above figure And your goal may look like c In each step you can choose a diagonal inside the polygon but not the one of edges of the polygon and this diagonal Suppose you are going to a diagonal There always exist two triangles sharing as a side let s denote them as and As a result of this operation the diagonal is replaced by a diagonal It can be easily proven that after operation resulting set of diagonals is still a of the polygon So in order to solve above case you may first diagonal it will be replaced by diagonal Then you diagonal and get figure c as result Ciel just proved that for any starting and destination triangulations this game has a solution She wants you to solve it in no more than steps for any puzzle satisfying ,"['#include <iostream>\n#include <cassert>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T>\nbool uin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool uax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nint m[1000][1000];\n\nvoid invert(int a, int b, int c, int d, vector<pii> &res, bool inv) {\n    assert(m[a][b] && m[a][c] && m[b][c] && m[a][d] && m[b][d] && !m[c][d]);\n    m[a][b] = m[b][a] = 0;\n    m[c][d] = m[d][c] = 1;\n    res.pb(inv ? mp(c, d) : mp(a, b));\n}\n\nvoid dfs(int l, int r, vector<pii> &res, bool inv) {\n    if (r - l <= 1) return;\n    vi a;\n    for (int i = r; i > l; --i) {\n        if (m[l][i]) a.pb(i);\n    }\n    for (int i = 0; i + 1 < a.size(); ++i) {\n        invert(l, a[i], 0, a[i + 1], res, inv);\n        dfs(a[i + 1], a[i], res, inv);\n    }\n    dfs(a.back(), r, res, inv);\n}\n\nvector<pii> solve(vector<pii> tr, bool inv) {\n    int N = tr.size() + 3;\n    forn(i, N) forn(j, N) m[i][j] = 0;\n    forn(i, N) m[i][(i + 1) % N] = m[(i + 1) % N][i] = 1;\n    forn(i, tr.size()) {\n        --tr[i].fi, --tr[i].se;\n        m[tr[i].fi][tr[i].se] = m[tr[i].se][tr[i].fi] = 1;\n    }\n    vector<pii> res;\n    dfs(1, N - 1, res, inv);\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    vector<pii> tr1(N - 3), tr2(N - 3);\n    forn(i, N - 3) cin >> tr1[i].fi >> tr1[i].se;\n    forn(i, N - 3) cin >> tr2[i].fi >> tr2[i].se;\n    vector<pii> res1 = solve(tr1, false);\n    vector<pii> res2 = solve(tr2, true);\n    reverse(all(res2));\n    res1.insert(res1.end(), all(res2));\n    cout << res1.size() << \'\\n\';\n    for (pii p: res1) {\n        cout << p.fi + 1 << \' \' << p.se + 1 << \'\\n\';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2900
Consider a 2 times n grid where n is an integer You may place the integers 1 2 ldots 2n on the grid using each integer A is a sequence of cells achieved by starting at 1 1 then repeatedly walking either downwards or to the right and stopping when 2 n is reached The path should not extend beyond the grid The of a path is the alternating sum of the numbers written on the cells in a path That is let the numbers written on the cells be a 1 a 2 ldots a k in the order that it is visited the cost of the path is a 1 a 2 a 3 a 4 ldots sum i 1 k a i cdot 1 i 1 Construct a way to place the integers 1 2 ldots 2n on the grid such that the minimum cost over all paths from 1 1 to 2 n is maximized If there are multiple such grids that result in the maximum value output any of them ,"['//\n//  main.cpp\n//  B\n//\n//  Created by Thomas Guo on 2023-04-09.\n//\n\n#include <iostream>\n#define maxn 100002\nusing namespace std;\nint grid[maxn][2];\nint main(){\n    int t;cin>>t;\n    while(t--){\n        int n;cin>>n;\n        grid[0][0] = 2*n;\n        grid[n-1][1] = 2*n-1;\n        int lo = 1, hi = 2*n-2;\n        for(int i=0; i<n-1; i++){\n            if(i%2 == 0){\n                grid[i][1] = lo;\n                grid[i+1][0] = lo+1;\n                lo += 2;\n            }\n            else{\n                grid[i][1] = hi-1;\n                grid[i+1][0] = hi;\n                hi -= 2;\n            }\n        }\n        for(int i=0; i<2; i++){\n            for(int j=0; j<n; j++){\n                cout<<grid[j][i]<<"" "";\n            }\n            cout<<""\\n"";\n        }\n    }\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Today at the lesson Vitya learned a very interesting function of a sequence of numbers is the minimum non negative number that is not present in the sequence as element For example and Vitya quickly understood all tasks of the teacher but can you do the same You are given an array consisting of non negative integers and queries Each query is characterized by one number and consists of the following consecutive steps Perform the bitwise addition operation modulo of each array element with the number Find of the resulting array ,"['#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<map>\n#include<set>\n#define MN 600000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n    while(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n    return x*f;\n}\nint n,m,s[25];\nstruct Tree{int l,r,x;}T[MN*4+5];\n\nvoid Build(int x,int l,int r)\n{\n    if((T[x].l=l)==(T[x].r=r)) return;\n    int mid=T[x].l+T[x].r>>1;\n    Build(x<<1,l,mid);Build(x<<1|1,mid+1,r);\n}\n\nvoid insert(int x,int k)\n{\n    if(T[x].l==T[x].r) {T[x].x=1;return;}\n    int mid=T[x].l+T[x].r>>1;\n    insert(x<<1|(k>mid),k);\n    T[x].x=T[x<<1].x+T[x<<1|1].x;\n}\n\nint Query(int x,int k)\n{\n    if(T[x].l==T[x].r) return 0;\n    int y=x<<1|s[k];\n    if(T[y].x==T[y].r-T[y].l+1) return Query(y^1,k-1)+(1<<k);\n    else return Query(y,k-1);\n}\n\nint main()\n{\n    n=read();m=read();Build(1,0,524287);\n    for(int i=1;i<=n;++i) insert(1,read());\n    for(int i=1;i<=m;++i)\n    {\n        int x=read();\n        for(int j=0;j<19;++j) if(x&(1<<j)) s[j]^=1;\n        printf(""%d\\n"",Query(1,18));\n    }\n    \n    \n    \n}']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2000
Qingshan has a string s while Daniel has a string t Both strings only contain texttt 0 and texttt 1 A string a of length k is good if and only if a i ne a i 1 for all i 1 2 ldots k 1 For example texttt 1 texttt 101 texttt 0101 are good while texttt 11 texttt 1001 texttt 001100 are not good Qingshan wants to make s good To do this she can do the following operation any number of times possibly zero insert t to any position of s getting a new s Please tell Qingshan if it is possible to make s good ,"['#include<bits/stdc++.h>\n#define ll long long\n#define il inline\nusing namespace std;\nconst int maxn=505;\nil int read(){\n\tint x=0;\n\tchar c=getchar();\n\tfor(;!(c>=\'0\'&&c<=\'9\');c=getchar());\n\tfor(;c>=\'0\'&&c<=\'9\';c=getchar())\n\t\tx=(x<<1)+(x<<3)+c-\'0\';\n\treturn x;\n}\nint T,n,m;\nchar a[maxn],b[maxn];\nbool chka(){\n\tfor(int i=1;i<n;i++)\n\t\tif(a[i]==a[i+1]) return 0;\n\treturn 1;\n}\nbool chkb(){\n\tfor(int i=1;i<m;i++)\n\t\tif(b[i]==b[i+1]) return 0;\n\treturn 1;\n}\nint main(){\n\tT=read();\n\twhile(T--){\n\t\tn=read(),m=read();\n\t\tscanf(""%s%s"",a+1,b+1);\n\t\tif(chka()){\n\t\t\tprintf(""Yes\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tif(!chkb()){\n\t\t\tprintf(""No\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tif(b[1]!=b[m]){\n\t\t\tprintf(""No\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tbool f0=0,f1=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t\tif(a[i]==\'0\'&&a[i+1]==\'0\') f0=1;\n\t\t\telse if(a[i]==\'1\'&&a[i+1]==\'1\') f1=1;\n\t\tif(f0&&f1){\n\t\t\tprintf(""No\\n"");\n\t\t\tcontinue; \n\t\t}\n\t\tif(b[1]==\'1\'&&f1){\n\t\t\tprintf(""No\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tif(b[1]==\'0\'&&f0){\n\t\t\tprintf(""No\\n"");\n\t\t\tcontinue;\n\t\t}printf(""Yes\\n"");\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Berland Government decided to improve relations with neighboring countries First of all it was decided to build new roads so that from each city of Berland and neighboring countries it became possible to reach all the others There are cities in Berland and neighboring countries in total and exactly two way roads Because of the recent financial crisis the Berland Government is strongly pressed for money so to build a new road it has to close some of the existing ones Every day it is possible to close one existing road and immediately build a new one Your task is to determine how many days would be needed to rebuild roads so that from each city it became possible to reach all the others and to draw a plan of closure of old roads and building of new ones ,"['#include <assert.h>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <list>\n#include <stack>\n#include <string.h>\n#include <stdlib.h>\n#include <vector>\n#include <utility>\n#include <list>\n#define INF 0x3fffffff\n#define LINF 0x3fffffffffffffffll\n#define DINF 1e100;\n\ntypedef long long ll;\n#define PII pair<int, int>\n#define PLL pair<ll, ll>\n#define PDD pair<double, double>\n#define PIL pair<int, ll>\n#define PLI pair<ll, int>\n#define PID pair<int, double>\n#define PDI pair<double, int>\n#define PLD pair<ll, double>\n#define PDL pair<double, ll>\n\n#define NUL(x) memset(x, 0, sizeof(x))\n#define MINUS(x) memset(x, 0xff, sizeof(x))\n#define PQ(x) priority_queue< x >  //highest first\n#define PQR(x) priority_queue< x , vector< x > , greater < x > > //lowest first\n#define MP make_pair\n#define PB push_back\n#define IT(x) for (typeof((x).begin()) it = (x).begin() ; it != (x).end() ; it++)\n#define IT2(x) for (typeof((x).begin()) it2 = (x).begin() ; it2 != (x).end() ; it2++)\n#define FOR(i, a, b) for (int i = (a) ; i< (b) ; i++)\n#define DEB(x...) fprintf(stderr,x);\n//#define DEB\n\nusing namespace std;\n\n\n#define MAX 1005\nint par[MAX];\nint n;\nint find(int a)\n{\n  if (par[a]==a) return a;\n  par[a]=find(par[a]);\n  return par[a];\n}\nbool unio(int a, int b)\n{\n  if (find(a)==find(b)) return false;\n  if (rand()&1) par[find(a)]=par[find(b)];\n  else par[find(b)]=par[find(a)];\n  return true;\n}\n\n\nlist<PII> cl;\nint main()\n{\n  srand(123);\n  int a,b;\n  int t=0;\n  scanf(""%i "", &n);\n  FOR(i,0,n) par[i]=i;\n  FOR(i,0,n-1)\n    {\n      scanf(""%i %i "", &a, &b);\n      a--;b--;\n      if (!unio(a,b))\n\t{\n\t  cl.PB(MP(a,b));\n\t  t++;\n\t}\n    }\n  printf(""%i\\n"",t);\n  FOR(i,1,n)\n    {\n      if (unio(0,i))\n\t{\n\t  printf(""%i %i %i %i\\n"", cl.front().first+1, cl.front().second+1, 1, i+1);\n\t  t--;\n\t  cl.pop_front();\n\t}\n    }\n\n  /*\n    while(testc());\n  */\n  \n  return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",1900
Arkady wants to have a dinner He has just returned from a shop where he has bought a semifinished cutlet He only needs to fry it The cutlet should be fried for seconds in particular it should be fried for seconds on one side and seconds on the other side Arkady has already got a frying pan and turn on fire but understood that maybe he won t be able to flip the cutlet exactly after seconds after the beginning of cooking Arkady is too busy with sorting sticker packs in his favorite messenger and can flip the cutlet only in some periods of time Namely there are periods of time in which he can do it the th of them is an interval of time from seconds after he starts cooking till seconds inclusive Arkady decided that it s not required to flip the cutlet exactly in the middle of cooking instead he will flip it several times in such a way that the cutlet will be fried exactly seconds on one side and seconds on the other side in total Help Arkady and find out if it s possible for him to cook the cutlet if he is able to flip the cutlet only in given periods of time and if yes find the minimum number of flips he needs to cook the cutlet ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 2e5 + 10;\nconst int INF = 1e9;\n\nint n, k;\npii seg[MAXN];\nint d[2][MAXN];\nvector<int> vec[2][MAXN];\nmultiset<int> st;\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> k;\n\tfor (int i = 0; i < k; i++)\tcin >> seg[i].F >> seg[i].S;\n\tmemset(d, 63, sizeof(d));\n\td[1][0] = 0;\n\tint cur = 0;\n\tfor (int l = 0; l < 2*n;) {\n\t\tif (cur < k && l == seg[cur].F){\n\t\t\tint r = seg[cur++].S;\n\t\t\tfor (int w = 0; w < 2; w++)\n\t\t\t\tfor (int i = 0; i < MAXN; i++) vec[w][i].clear();\n\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tvec[0][i].push_back(d[1][i] + 1 + 1);\n\t\t\t\tvec[0][min(n + 1, i + (r-l)+1)].push_back(-(d[1][i] + 1 + 1));\n\n\t\t\t\tvec[1][i].push_back(d[1][i] + 2 + 1);\n\t\t\t\tvec[1][min(n+1, i+(r-l)+1)].push_back(- (d[1][i] + 2 + 1));\n\n\t\t\t\tif (i + (r-l) <= n) {\n\t\t\t\t\tvec[1][i+ (r-l)].push_back(d[1][i] + 1);\n\t\t\t\t\tvec[1][i+ (r-l) + 1].push_back(-(d[1][i] + 1));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tvec[1][i].push_back(d[0][i] + 1 + 1);\n\t\t\t\tvec[1][min(n+1, i+(r-l)+1)].push_back(- (d[0][i] + 1 + 1));\n\n\t\t\t\tvec[0][i].push_back(d[0][i] + 2 + 1);\n\t\t\t\tvec[0][min(n+1, i+1+(r-l))].push_back(- (d[0][i] + 2 + 1));\n\t\t\t\t\n\t\t\t\tvec[0][i].push_back(d[0][i] + 1);\n\t\t\t\tvec[0][i+1].push_back(-(d[0][i] + 1));\n\t\t\t}\n\n\t\t\tfor (int w = 0; w < 2; w++){\n\t\t\t\tst.clear();\n\t\t\t\tfor (int i = 0; i <= n; i++){\n\t\t\t\t\tfor (int x:vec[w][i])\n\t\t\t\t\t\tif (x > 0)\n\t\t\t\t\t\t\tst.insert(x - 1);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tst.erase(st.find(-x - 1));\n\t\t\t\t\td[w][i] = (st.size()? *st.begin(): INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tl = r;\n\t\t}\n\t\telse{\n\t\t\tint r = (cur < k? seg[cur].F: 2*n);\n\t\t\tfor (int i = n; ~i; i--){\n\t\t\t\tif (i >= r-l)\n\t\t\t\t\td[1][i] = d[1][i-(r-l)];\n\t\t\t\telse\n\t\t\t\t\td[1][i] = INF;\n\t\t\t}\n\t\t\tl = r;\n\t\t}\n\t}\n\tint ans = min(d[0][n], d[1][n]);\n\tif (ans > (int)1e6)\n\t\tcout << ""Hungry\\n"";\n\telse {\n\t\tcout << ""Full\\n"";\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
There is a polyline going through points We know that the polyline passes through the point Find minimum positive value such that it is true or determine that there is no such ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef long long ll;\n\nconst double INF = 1e18;\n\ndouble solve(ll x, ll y)\n{\n    ll k = x / (2 * y);\n    if (k == 0) return INF;\n    return (double)x / (double)(2 * k);\n}\n\nint main()\n{\n    ll x, y;\n    cin >> x >> y;\n    if (x < y)\n    {\n        printf(""-1\\n"");\n        return 0;\n    }\n    if (x == y)\n    {\n        printf(""%d\\n"", x);\n        return 0;\n    }\n    printf(""%.12lf\\n"", min(solve(x - y, y), solve(x + y, y)));\n\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
You are given n numbers a 1 a 2 dots a n In one operation we can add to any one of those numbers a nonnegative integer power of 2 What is the smallest number of operations we need to perform to make all n numbers equal It can be proved that under given constraints it doesn t exceed 10 18 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int INF = (int)1e9;\nconst int N = 100100;\nconst int K = 60;\nll a[N];\nint n;\nll b[K][N];\nint dp[K][N];\n\nint getCount(int k, ll x) {\n\tll W = 1LL << (k - 1);\n\tif (x < W) {\n\t\treturn upper_bound(b[k], b[k] + n, x + W) - upper_bound(b[k], b[k] + n, x);\n\t} else {\n\t\treturn (upper_bound(b[k], b[k] + n, x - W) - b[k]) + \n\t\t\t(b[k] + n - upper_bound(b[k], b[k] + n, x));\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &a[i]);\n\tfor (int k = 1; k < K; k++) {\n\t\tll U = (1LL << k) - 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tb[k][i] = a[i] & U;\n\t\tsort(b[k], b[k] + n);\n\t}\n\tfor (int k = 0; k < K; k++)\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tdp[k][i] = INF;\n\tdp[0][n] = 0;\n\tfor (int k = 1; k < K; k++) \n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tif (dp[k - 1][i] == INF) continue;\n\t\t\tif (i == 0 && b[k - 1][i] == 0) continue;\n\t\t\tfor (ll z = 0; z < 2; z++) {\n\t\t\t\tll x = (i == 0 ? 0 : b[k - 1][i - 1]) + (z << (k - 1));\n\t\t\t\tint p = upper_bound(b[k], b[k] + n, x) - b[k];\n\t\t\t\tdp[k][p] = min(dp[k][p], dp[k - 1][i] + getCount(k, x));\n\t\t\t}\n\t\t}\n\tprintf(""%d\\n"", dp[K - 1][n]);\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3100
You have two integers l and r Find an integer x which satisfies the conditions below l le x le r All digits of x are different If there are multiple answers print any of them ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n#ifdef LBT\n  freopen(""test.in"", ""r"", stdin);\n  int nol_cl = clock();\n#endif\n\n  int l, r;\n  scanf(""%d%d"", &l, &r);\n  for (int i = l; i <= r; ++i) {\n    static bool m[10];\n    memset(m, 0, sizeof(m));\n    int x = i;\n    bool flag = false;\n    while (x) {\n      if (m[x % 10]) {\n        flag = true;\n        break;\n      }\n      m[x % 10] = true;\n      x /= 10;\n    }\n    if (!flag) {\n      printf(""%d\\n"", i);\n      return 0;\n    }\n  }\n  puts(""-1"");\n\n#ifdef LBT\n  LOG(""Time: %dms\\n"", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given an array a consisting of n integers it is guaranteed that n is even i e divisible by 2 All a i does not exceed some integer k Your task is to replace the number of elements replacement is the following operation choose some index i from 1 to n and replace a i with some integer in range 1 k to satisfy the following conditions after all replacements all a i are positive integers not greater than k for all i from 1 to frac n 2 the following equation is true a i a n i 1 x where x should be for all frac n 2 pairs of elements You have to answer t independent test cases ,"['#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=1000000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<\'0\') || (ch>\'9\')) {if (ch==\'-\') f=-1;ch=getchar();}\n    while ((ch>=\'0\') && (ch<=\'9\')) {x=x*10+(ch-\'0\');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nint n,k,a[N],sum[N],mn[N];\nstruct node{int id,l,r;}seg[N];\nbool operator <(node p,node q) {return p.r<q.r;}\nbool cmp(node p,node q) {return p.l<q.l;}\nmultiset<node> s;\nmultiset<node>::iterator it;\nvi ask;\n\nint main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\tn=read();k=read();\n\t\trep(i,1,n) a[i]=read();\n\t\trep(i,1,n>>1)\n\t\t{\n\t\t\tsum[a[i]+a[n-i+1]]++;\n\t\t\tint mn=min(a[i],a[n-i+1]),mx=max(a[i],a[n-i+1]);\n\t\t\tseg[i]=(node){i,mn+1,mx+k};\n\t\t}\n\t\tsort(seg+1,seg+1+(n>>1),cmp);\n\t\t//rep(i,1,(n>>1)) cout << seg[i].l << "" "" << seg[i].r << endl;\n\t\tint ans=n;int pos=1;\n\t\trep(x,2,k*2)\n\t\t{\n\t\t\twhile (!s.empty())\n\t\t\t{\n\t\t\t\tit=s.begin();node tmp=*it;\n\t\t\t\tif (x>tmp.r) s.erase(it);else break;\n\t\t\t}\n\t\t\twhile ((pos<=(n>>1)) && (seg[pos].l==x))\n\t\t\t{\n\t\t\t\ts.insert(seg[pos]);pos++;\n\t\t\t}\n\t\t\tint siz=s.size();\n\t\t\t//cout << x << "" "" << siz << endl;\n\t\t\tint now=siz-sum[x]+(n/2-siz)*2;\n\t\t\tans=min(ans,now);\n\t\t}\n\t\ts.clear();\n\t\tprintf(""%d\\n"",ans);\n\t\trep(i,1,k*2) sum[i]=0;\n\t}\n\treturn 0;\n}\n\n\n']","[1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1700
After a probationary period in the game development company of IT City Petya was included in a group of the programmers that develops a new turn based strategy game resembling the well known Heroes of Might Magic A part of the game is turn based fights of big squadrons of enemies on infinite fields where every cell is in form of a hexagon Some of magic effects are able to affect several field cells at once cells that are situated not farther than cells away from the cell in which the effect was applied The distance between cells is the minimum number of cell border crosses on a path from one cell to another It is easy to see that the number of cells affected by a magic effect grows rapidly when increases so it can adversely affect the game performance That s why Petya decided to write a program that can given determine the number of cells that should be repainted after effect application so that game designers can balance scale of the effects and the game performance Help him to do it Find the number of hexagons situated not farther than cells away from a given cell ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 17:50:32       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\n\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    ll n, t;\n\n    cin >> n;\n    cout << n * (n + 1) * 3 + 1;\n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Writing light novels is the most important thing in Linova s life Last night Linova dreamed about a fantastic kingdom She began to write a light novel for the kingdom as soon as she woke up and of course she is the queen of it There are n cities and n 1 two way roads connecting pairs of cities in the kingdom From any city you can reach any other city by walking through some roads The cities are numbered from 1 to n and the city 1 is the capital of the kingdom So the kingdom has a tree structure As the queen Linova plans to choose k cities developing industry while the other cities will develop tourism The capital also can be either industrial or tourism city A meeting is held in the capital once a year To attend the meeting each sends an envoy All envoys will follow the shortest path from the departure city to the capital which is unique Traveling in tourism cities is pleasant For each envoy his is equal to the number of on his path In order to be a queen loved by people Linova wants to choose k cities which can maximize the sum of of all envoys Can you calculate the maximum sum for her ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n\nconst int maxN = 223456;\nint n, k, u, v;\nvector<int> e[maxN];\nint sz[maxN], dep[maxN], f[maxN];\ni64 ans;\nvoid dfs(int u, int f)\n{\n\tsz[u] = 1;\n\tdep[u] = dep[f] + 1;\n\tfor (auto v : e[u])\n\t{\n\t\tif (v == f)\n\t\t\tcontinue;\n\t\tdfs(v, u);\n\t\tsz[u] += sz[v];\n\t}\n}\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tscanf(""%d%d"", &u, &v);\n\t\te[u].push_back(v);\n\t\te[v].push_back(u);\n\t}\n\tdfs(1, 0);\n\tfor (int i = 1; i <= n; i++)\n\t\tf[i] = dep[i] - sz[i];\n\tsort(f + 1, f + n + 1);\n\tfor (int i = 0; i < k; i++)\n\t\tans += f[n - i];\n\tprintf(""%lld\\n"", ans);\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0]",1600
A remote island chain contains islands labeled through Bidirectional bridges connect the islands to form a simple cycle a bridge connects islands and islands and and so on and additionally a bridge connects islands and The center of each island contains an identical pedestal and all but one of the islands has a fragile uniquely colored statue currently held on the pedestal The remaining island holds only an empty pedestal The islanders want to rearrange the statues in a new order To do this they repeat the following process First they choose an island directly adjacent to the island containing an empty pedestal Then they painstakingly carry the statue on this island across the adjoining bridge and place it on the empty pedestal Determine if it is possible for the islanders to arrange the statues in the desired order ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define INF ((int) 1e9+10)\n#define LINF ((ll) 1e16)\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(""%lf"", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c==\'-\') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>=\'0\') && (c<=\'9\'))\n\t\t\tx=x*10+c-\'0\',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nint main()\n{\n\tint n;\n\trint(n);\n\tVI a(n), b(n);\n\tji(n) rint(a[i]);\t\n\tji(n) rint(b[i]);\n\ta.erase(find(a.begin(), a.end(), 0));\n\tb.erase(find(b.begin(), b.end(), 0));\n\tn--;\n\tint idx = 0;\n\twhile (b[idx] != a[0])\n\t\t++idx;\n\tji(n)\n\t{\n\t\tif (a[i] != b[(idx+i)%n])\n\t\t{\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(""YES\\n"");\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
As for the technology in the outside world it is really too advanced for Gensokyo to even look up to Yasaka Kanako Under the direct supervision of Kanako and the Moriya Shrine the railway system of Gensokyo is finally finished GSKR Gensokyo Railways consists of n stations with m bidirectional tracks connecting them The i th track has length l i 1 le l i le 10 6 Due to budget limits the railway system though there may be more than one track between two stations The of a railway system is defined as the total length of its all tracks The of a railway system is defined as the maximum or minimum value among all of the currently functional system s full spanning forest In brief full spanning forest of a graph is a spanning forest with the same connectivity as the given graph Kanako has a simulator only able to process no more than 2m queries The input of the simulator is a string s of length m consisting of characters and or The simulator will assume the i th track functional if s i The device will then tell Kanako the maximum capacity of the system in the simulated state Kanako wants to know the the minimum capacity of the system with all tracks functional with the help of the simulator The structure of the railway system is fixed in advance In other words the interactor is not adaptive ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 505;\nint n, m;\nchar s[N];\npii a[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < m; j++)\n\t\t\ts[j] = \'0\';\n\t\ts[i] = \'1\';\n\t\tprintf(""? %s\\n"", s);\n\t\tfflush(stdout);\n\t\tscanf(""%d"", &a[i].first);\n\t\ta[i].second = i;\n\t}\n\tsort(a, a + m);\n\tfor (int i = 0; i < m; i++)\n\t\ts[i] = \'0\';\n\tint w = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\ts[a[i].second] = \'1\';\n\t\tprintf(""? %s\\n"", s);\n\t\tfflush(stdout);\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tif (x == w + a[i].first) {\n\t\t\tw = x;\n\t\t} else {\n\t\t\ts[a[i].second] = \'0\';\n\t\t}\n\t}\n\tprintf(""! %d\\n"", w);\n\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]",1700
There are n detachments on the surface numbered from 1 to n the i th detachment is placed in a point with coordinates x i y i All detachments are placed in different points Brimstone should visit each detachment at least once You can choose the detachment where Brimstone starts To move from one detachment to another he should first choose one of four directions of movement up right left or down and then start moving with the constant speed of one unit interval in a second until he comes to a detachment After he reaches an arbitrary detachment he can repeat the same process Each t seconds an orbital strike covers the whole surface so at that moment Brimstone should be in a point where some detachment is located He can stay with any detachment as long as needed Brimstone is a good commander that s why he can create detachment and place it in any empty point with integer coordinates he wants before his trip Keep in mind that Brimstone will need to visit this detachment too Help Brimstone and find such minimal t that it is possible to check each detachment If there is no such t report about it ,"['#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#pragma GCC optimize(""Ofast"")\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s"".in"", ""r"", stdin); freopen(s"".out"", ""w"", stdout)\n//#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, ""%d "", a[i]); fprintf(stderr, ""\\n"");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = \'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e3 + 5;\nstruct Node {\n\tint x, y;\n}a[MAXN], b[MAXN];\nint n, dx[MAXN], dy[MAXN], tx, ty;\nvector < int > row[MAXN], clm[MAXN];\nbool cmp1(int i, int j) {return a[i].y < a[j].y;}\nbool cmp2(int i, int j) {return a[i].x < a[j].x;}\n\nint f[MAXN], siz[MAXN];\ninline int find(int x) {\n\twhile(x != f[x]) x = f[x];\n\treturn x;\n}\nstruct Tri {\n\tint x, y, r, w;\n};\nstack < Tri > s;\ninline int merge(int x, int y, int opt = 0) {\n\tx = find(x), y = find(y);\n\tif(x == y) return 0;\n\tif(siz[x] < siz[y]) swap(x, y);\n\tif(opt) s.push((Tri) {y, f[y], x, siz[x]});\n\tf[y] = x; siz[x] += siz[y]; return 1;\n}\ninline void back() {\n\twhile(s.size()) {\n\t\tf[s.top().x] = s.top().y; siz[s.top().r] = s.top().w;\n\t\ts.pop();\n\t}\n}\nbool check(int mid) {\n//\tcerr << mid << "":"" << endl;\n\tFor(i, 1, tx) row[i].clear(); tx = 0;\n\tFor(i, 1, ty) clm[i].clear(); ty = 0;\n\tFor(i, 1, n) a[i] = b[i];\n\tFor(i, 1, n) dx[++tx] = a[i].x, dx[++tx] = a[i].x - mid, dx[++tx] = a[i].x + mid; \n\tFor(i, 1, n) dy[++ty] = a[i].y, dy[++ty] = a[i].y - mid, dy[++ty] = a[i].y + mid; \n\tsort(dx + 1, dx + 1 + tx); sort(dy + 1, dy + 1 + ty); tx = unique(dx + 1, dx + 1 + tx) - dx - 1, ty = unique(dy + 1, dy + 1 + ty) - dy - 1;\n//\tcerr << tx << \' \' << ty << endl;\n    For(i, 1, n) row[a[i].x = lower_bound(dx + 1, dx + 1 + tx, a[i].x) - dx].pb(i), clm[a[i].y = lower_bound(dy + 1, dy + 1 + ty, a[i].y) - dy].pb(i);\n\tFor(i, 1, tx) sort(row[i].begin(), row[i].end(), cmp1);\n\tFor(i, 1, ty) sort(clm[i].begin(), clm[i].end(), cmp2);\n\t\n\tFor(i, 1, n + 1) f[i] = i, siz[i] = 1;\n\twhile(s.size()) s.pop();\n\tFor(i, 1, tx) {\n\t\tfor(rint j = 1; j < row[i].size(); j++) {\n\t\t\tif(dy[a[row[i][j]].y] - dy[a[row[i][j-1]].y] <= mid) {\n\t\t\t\tmerge(row[i][j], row[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\tFor(i, 1, ty) {\n\t\tfor(rint j = 1; j < clm[i].size(); j++) {\n\t\t\tif(dx[a[clm[i][j]].x] - dx[a[clm[i][j-1]].x] <= mid) {\n\t\t\t\tmerge(clm[i][j], clm[i][j-1]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(siz[find(1)] == n) return 1;\n\tFor(x, 1, tx) {\n\t\tFor(y, 1, ty) {\n//\t\t\tcerr << siz[find(1)] << endl;\n\t\t\tfor(int j = 0; j < row[x].size(); j++) {\n\t\t\t\tif(abs(dy[a[row[x][j]].y] - dy[y]) <= mid) {\n//\t\t\t\t\tcerr << x << \' \' << y << \' \' << row[x][j] << \' \' << dy[a[row[x][j]].y]  << \' \' << dy[y] << endl;\n\t\t\t\t\tmerge(row[x][j], n + 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < clm[y].size(); j++) {\n\t\t\t\tif(abs(dx[a[clm[y][j]].x] - dx[x]) <= mid) {\n//\t\t\t\t\tcerr << x << \' \' << y << \' \' << clm[y][j] << \' \' << dx[a[clm[y][j]].x] << \' \' << dx[x] << endl;\n\t\t\t\t\tmerge(clm[y][j], n + 1, 1);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcerr << siz[find(1)] << endl;\n\t\t\tif(siz[find(1)] == n + 1) return 1;\n\t\t\tback();\n\t\t}\n\t}\n\treturn 0;\n}\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(""pro"");\n    #endif\n    cin >> n;\n    For(i, 1, n) cin >> a[i].x >> a[i].y, b[i] = a[i];\n    \n\tll l = 1, r = 2e9, res = -1;\n\twhile(l <= r) {\n//\t\tcerr << l << \' \' << r << endl;\n\t\tint mid = (l + r) >> 1;\n\t\tif(check(mid)) {\n\t\t\tr = mid - 1, res = mid;\n\t\t} else l = mid + 1;\n\t}\n\tcout << res << endl;\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n']","[0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0]",2800
Hemose has an array of n integers He wants Samez to sort the array in the non decreasing order Since it would be a too easy problem for Samez Hemose allows Samez to use only the following operation Choose indices i and j such that 1 le i j le n and lvert i j rvert geq x Then swap elements a i and a j Can you tell Samez if there s a way to sort the array in the non decreasing order by using the operation written above some finite number of times possibly 0 ,"['#include<bits/stdc++.h>\n#define rep(i,n) for (int i=1;i<=(n);i++)\nusing namespace std;\nint n,l,a[100005],b[100005];\nvector<int> v;\nvoid solve()\n{\n\tcin>>n>>l;\n\trep(i,n) cin>>a[i];\n\tv.clear();\n\trep(i,n) if(i-l>=1||i+l<=n) v.push_back(a[i]);\n\tsort(v.begin(),v.end());\n\tint t=0;\n\trep(i,n) if(i-l>=1||i+l<=n) b[i]=v[t++]; else b[i]=a[i];\n\trep(i,n-1) if(b[i]>b[i+1]) {puts(""NO"");return;}\n\tputs(""YES"");\n}\nint main()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--) solve();\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1200
Sasha lives in a big happy family At the Man s Day all the men of the family gather to celebrate it following their own traditions There are men in Sasha s family so let s number them with integers from to Each man has at most one father but may have arbitrary number of sons Man number is considered to be the of the man number if at least one of the following conditions is satisfied the man number is the father of the man number there is a man number such that the man number is his ancestor and the man number is the father of the man number Of course if the man number is an ancestor of the man number and then the man number is not an ancestor of the man number The tradition of the Sasha s family is to give gifts at the Man s Day Because giving gifts in a normal way is boring each year the following happens A list of candidates is prepared containing some possibly all of the men in some order Each of the men decides to give a gift In order to choose a person to give a gift to man looks through the list and picks the first man in the list such that is an ancestor of and gives him a gift Note that according to definition it may happen that a person gives a gift to himself If there is no ancestor of a person in the list he becomes sad and leaves the celebration without giving a gift to anyone This year you have decided to help in organizing celebration and asked each of the men who do they want to give presents to this person is chosen only among ancestors Are you able to make a list of candidates such that all the wishes will be satisfied if they give gifts according to the process described above ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 120000;\n\n\nint n, m;\nint gfl;\nint p[MAXN];\nvector<int> eds[MAXN];\nint g[MAXN];\nint tin[MAXN];\nint tm2;\nint fl[MAXN];\n\nvoid dfs(int v) {\n\ttin[v] = tm2++;\n\tfor (int u: eds[v])\n\t\tdfs(u);\n}\n\n\nvoid dfs2(int v, int now) {\n\tif (fl[v])\n\t\tnow = v;\n\tif (now != g[v]) {\n\t\tgfl = 1;\n\t}\n\tfor (int i: eds[v])\n\t\tdfs2(i, now);\n}\n\n\n\nint main() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < n; ++i)\n\t\tp[i] = -1;\n\tfor (int i = 0; i < m; ++i) {\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\t--a;\n\t\t--b;\n\t\tp[b] = a;\n\t\teds[a].push_back(b);\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%d"", g + i), --g[i];\n\n\tfor (int i = 0; i < n; ++i)\n\t\tif (p[i] == -1)\n\t\t\tdfs(i);\n\n\tvector<pair<int, int> > vv;\n\tfor (int i = 0; i < n; ++i) {\n\t\tvv.push_back(make_pair(tin[g[i]], g[i]));\n\t}\n\tsort(vv.begin(), vv.end());\n\tvv.resize(unique(vv.begin(), vv.end()) - vv.begin());\n\n\treverse(vv.begin(), vv.end());\n\tfor (int i = 0; i < (int)vv.size(); ++i)\n\t\tfl[vv[i].second] = 1;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (p[i] == -1)\n\t\t\tdfs2(i, -1);\n\t}\n\tif (gfl) {\n\t\tprintf(""-1\\n"");\n\t}\n\telse {\n\t\tprintf(""%d\\n"", (int)vv.size());\n\t\tfor (auto i: vv)\n\t\t\tprintf(""%d\\n"", i.second + 1);\n\t}\n\t\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0]",2000
You are given a positive integer n Since n may be very large you are given its binary representation You should compute the number of triples a b c with 0 leq a b c leq n such that a oplus b b oplus c and a oplus c are the sides of a non degenerate triangle Here oplus denotes the bitwise XOR operation You should output the answer modulo 998 244 353 Three positive values x y and z are the sides of a non degenerate triangle if and only if x y z x z y and y z x ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int maxn=222222,mod=998244353;\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline ll read(){\n\tchar ch=getchar();ll x=0,f=0;\n\twhile(ch<\'0\' || ch>\'9\') f|=ch==\'-\',ch=getchar();\n\twhile(ch>=\'0\' && ch<=\'9\') x=x*10+ch-\'0\',ch=getchar();\n\treturn f?-x:x;\n}\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint n,f[maxn][8][8],a[maxn];\nchar s[maxn];\nint main(){\n\tscanf(""%s"",s+1);\n\tn=strlen(s+1);\n\tFOR(i,1,n) a[i]=s[i]-\'0\';\n\tf[0][7][7]=1;\n\tFOR(i,0,n-1) FOR(j,0,7) FOR(k,0,7) if(f[i][j][k]){\n\t\tint x=(j&1)?a[i+1]:1,y=(j&2)?a[i+1]:1,z=(j&4)?a[i+1]:1;\n\t\tFOR(p,0,x) FOR(q,0,y) FOR(r,0,z){\n\t\t\tint jj=j,kk=k;\n\t\t\tif(p!=x) jj&=~1;\n\t\t\tif(q!=y) jj&=~2;\n\t\t\tif(r!=z) jj&=~4;\n\t\t\tint pp=p^q,qq=q^r,rr=p^r;\n\t\t\tif(pp&qq) kk&=~1;\n\t\t\tif(qq&rr) kk&=~2;\n\t\t\tif(pp&rr) kk&=~4;\n\t\t\tf[i+1][jj][kk]=(f[i+1][jj][kk]+f[i][j][k])%mod;\n\t\t}\n\t}\n\tint ans=0;\n\tFOR(i,0,7) ans=(ans+f[n][i][0])%mod;\n\tprintf(""%d\\n"",ans);\n}']","[1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2500
You are both a shop keeper and a shop assistant at a small nearby shop You have n goods the i th good costs a i coins You got tired of remembering the price of each product when customers ask for it thus you decided to simplify your life More precisely you decided to set the same price for all n goods you have However you don t want to lose any money so you want to choose the price in such a way that the sum of new prices is not less than the sum of the initial prices It means that if you sell all n goods for the new price you will receive at least the same or greater amount of money as if you sell them for their initial prices On the other hand you don t want to lose customers because of big prices so among all prices you can choose you need to choose the minimum one So you need to find the minimum possible equal price of all n goods so if you sell them for this price you will receive at least the same or greater amount of money as if you sell them for their initial prices You have to answer q independent queries ,"['#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << ""="" << (X) << endl;\n#else\n\t#define DBG(X)\n#endif\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::pair;\nusing std::swap;\nusing std::sort;\nusing std::lower_bound;\nusing std::unique;\n\nusing int64 = long long int;\nusing pii   = pair<int, int>;\nusing pii64 = pair<int64, int64>;\n\nconst int NIL = -1;\n\nvoid init_IO() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n}\n\nvoid solve() {\n\tint64 sum = 0, cnt;\n\tcin >> cnt;\n\n\tfor(int i = 0; i < cnt; ++i) {\n\t\tint64 val;\n\t\tcin >> val;\n\n\t\tsum += val;\n\t}\n\n\tcout << (sum + cnt - 1) / cnt << \'\\n\';\n}\n\nint main() {\n\tinit_IO();\n\n\tint T;\n\tcin >> T;\n\n\twhile(T--)\n\t\tsolve();\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Everyone knows that computers become faster and faster Recently Berland scientists have built a machine that can move itself back in time More specifically it works as follows It has an infinite grid and a robot which stands on one of the cells Each cell of the grid can either be empty or contain or The machine also has a program which consists of instructions which are being handled one by one Each instruction is represented by exactly one symbol letter or digit and takes exactly one unit of time say second to be performed except the last type of operation it s described below Here they are or the robot places this number into the cell he is currently at If this cell wasn t empty before the operation its previous number is replaced anyway the robot rases the number into the cell he is at or the robot goes one cell to the eft ight p own the robot tays where he is for a unit of time let x be 0 if the cell with the robot is empty otherwise let x be one more than the digit in this cell that is x 1 if the digit in this cell is 0 and x 2 if the digit is 1 Then the machine ravels x seconds back in time Note that this doesn t change the instructions order but it changes the position of the robot and the numbers in the grid as they were x units of time ago You can consider this instruction to be equivalent to a pressed x times For example let the board be completely empty and the program be Let the robot initially be at 0 0 now is the moment 0 the command is we do nothing now is the moment 1 the command is we are now at 1 0 now is the moment 2 the command is we are at 1 0 and this cell contains 1 now is the moment 3 the command is we travel 1 1 2 moments back that is to the moment 1 now is the moment 1 the command is we are again at 0 0 and the board is clear again but after we follow this instruction this cell has 0 in it We ve just rewritten the history The consequences of the third instruction have never happened Now Berland scientists want to use their machine in practice For example they want to be able to add two integers Assume that the initial state of the machine is as follows One positive integer is written in binary on the grid in such a way that its right bit is at the cell 0 1 from left to right from the highest bit to the lowest bit The other positive integer is written in binary on the grid in such a way that its right bit is at the cell 0 0 from left to right from the highest bit to the lowest bit All the other cells are empty The robot is at 0 0 We consider this state to be always in the past that is if you manage to travel to any negative moment the board was always as described above and the robot was at 0 0 for eternity You are asked to write a program after which The robot stands on a non empty cell If we read the number starting from the cell with the robot and moving to the right until the first empty cell this will be a b in binary from the highest bit to the lowest bit Note that there are no restrictions on other cells In particular there may be a digit just to the left to the robot after all instructions In each test you are given up to 1000 pairs a b and your program must work for all these pairs Also since the machine s memory is not very big your program must consist of no more than 10 5 instructions ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\nstring pulld = ""s10utsusdteds"";\nstring pullr = ""s10ltslsrters"";\nstring pulll = ""s10rtsrsltels"";\nstring pull_all;\nvoid make_pull_all(){\n\tfor(int i = 0; i < 36; i++){\n\t\tpull_all += pulld;\n\t\tpull_all += ""ls"";\n\t}\n\tfor(int i = 0; i < 36; i++){\n\t\tpull_all += ""r"";\n\t}\n}\n\nint main(){\n\tmake_pull_all();\n\tstring ans;\n\tans += ""d"" + pull_all;\n\tans += ""d"" + pull_all;\n\tans += ""uu"" + pull_all;\n\tans += ""d"";\n\tans += ""l0r"";\n\tfor(int i = 0; i < 32; i++){\n\t\tans += ""1010utdtlt"";\n\t\tans += ""r"" + pullr + ""l"";\n\t\tans += ""1100utdtlt"";\n\t\tans += ""l"" + pulll + ""l"" + pulll + ""rr"";\n\t\tans += ""l"";\n\t}\n\tans += ""rr"";\n\tcout << ans << endl;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3400
There is an array with elements and the number In one operation you can select some and replace element with where denotes the bitwise and operation You want the array to have at least two equal elements after applying some operations possibly none In other words there should be at least two distinct indices such that Determine whether it is possible to achieve and if possible the minimal number of operations to apply ,"['/// In The Name Of God\n/// I wish, that I could leave it all behind me / Go to my own world where no one can find me\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n#define int long long\n#define ll long long\n#define pii pair <int , int>\n#define ld long double\n#define for2(a,b,c) for(int (a) = (b); (a) < (c); (a)++)\n#define for3(a,b,c) for(    (a) = (b); (a) < (c); (a)++)\n#define setp cout << fixed << setprecision(15)\n#define endl ""\\n""\n#define minit(a,b) a = min(a,b)\n#define maxit(a,b) a = max(a,b)\n#define PII pair<int,int>\n#define Vec vector<int>\n#define error(x) cerr << #x << "" = "" << (x) << endl;\n#define all(x) (x).begin() , (x).end()\n\nint x[1000000];\nint y[1000000];\n\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n,X; cin >> n >> X;\n    int ans = 4;\n    for2(i,0,n){\n        int a,b;\n        cin >> a;\n        b = a&X;\n        if(x[a]){\n            cout << 0 << endl;\n            return 0;\n        }\n        if(y[a] || x[b])ans = 1;\n        if(y[b]) ans = min(ans,2ll);\n        x[a] = y[b] = 1;\n    }\n    if(ans == 4) ans = -1;\n    cout << ans << endl;\n\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Being Santa Claus is very difficult Sometimes you have to deal with difficult situations Today Santa Claus came to the holiday and there were m children lined up in front of him Let s number them from 1 to m Grandfather Frost knows n spells The i th spell gives a candy to every child whose place is in the L i R i range Each spell can be used at most once It is also known that if all spells are used each child will receive at most k candies It is not good for children to eat a lot of sweets so each child can eat no more than one candy while the remaining candies will be equally divided between his or her Mom and Dad So it turns out that if a child would be given an even amount of candies possibly zero then he or she will be unable to eat any candies and will go sad However the rest of the children who received an odd number of candies will be happy Help Santa Claus to know the maximum number of children he can make happy by casting some of his spells ,"['#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch==\'-\',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-\'0\',ch=getchar();\n\treturn f?x:-x;\n}\nint L[100010],R[100010],U[200010],u;\nint f[200010][1<<8|1];\nstd::vector<int>v[200010];\nint MX[1<<8|1],par[1<<8|1],pos[200010];\nint main(){\n#ifdef LOCAL\n\tfreopen(""in.in"",""r"",stdin);\n\t//freopen(""out.out"",""w"",stdout);\n#endif\n\tint n=gi(),____=gi(),___=gi();\n\tfor(int i=1;i<=n;++i)L[i]=gi(),R[i]=gi()+1,U[++u]=L[i],U[++u]=R[i];\n\tstd::sort(U+1,U+u+1);u=std::unique(U+1,U+u+1)-U-1;\n\tfor(int i=1;i<=n;++i)L[i]=std::lower_bound(U+1,U+u+1,L[i])-U;\n\tfor(int i=1;i<=n;++i)R[i]=std::lower_bound(U+1,U+u+1,R[i])-U-1;\n\tfor(int i=1;i<=n;++i)for(int j=L[i];j<=R[i];++j)v[j].push_back(i);\n\tmemset(f,-63,sizeof f);\n\tfor(int i=0;i<1<<8;++i)par[i]=__builtin_parity(i);\n\tf[0][0]=0;\n\tmemset(pos,-1,sizeof pos);\n\tfor(int i=0;i<u;++i){\n\t\tint o=v[i].size();\n\t\tmemset(MX,-63,sizeof MX);\n\t\tfor(int j=0;j<1<<o;++j){\n\t\t\tint S=0;\n\t\t\tfor(int k=0;k<o;++k)if((j>>k&1)&&R[v[i][k]]>i)S|=1<<k;\n\t\t\tif(par[j]&&f[i][j]>=0)f[i][j]+=U[i+1]-U[i];\n\t\t\tMX[S]=std::max(MX[S],f[i][j]);\n\t\t}\n\t\tint old=0;\n\t\tfor(int j=0;j<v[i].size();++j)pos[v[i][j]]=-1;\n\t\tfor(int j=0;j<v[i+1].size();++j)pos[v[i+1][j]]=j;\n\t\tfor(int j=0;j<o;++j)if(~pos[v[i][j]])old|=1<<pos[v[i][j]];\n\t\tint O=v[i+1].size();\n\t\tfor(int j=0;j<1<<o;++j){\n\t\t\tif(MX[j]>=0){\n\t\t\t\tint nS=0;\n\t\t\t\tfor(int k=0;k<o;++k)\n\t\t\t\t\tif((j>>k&1)&&R[v[i][k]]>i)\n\t\t\t\t\t\tnS|=1<<pos[v[i][k]];\n\t\t\t\tint E=((1<<O)-1)^old;\n\t\t\t\tfor(int k=E;;k=(k-1)&E){\n\t\t\t\t\tf[i+1][k|nS]=std::max(f[i+1][k|nS],MX[j]);\n\t\t\t\t\tif(!k)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"",f[u][0]);\n\treturn 0;\n}\n']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
There are several days left before the fiftieth birthday of a famous Berland s writer Berlbury In this connection the local library decided to make an exposition of the works of this famous science fiction writer It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period It is obvious that if the books differ much in size the visitors will not like it That was why the organizers came to the opinion that the difference between the highest and the lowest books in the exposition should be not more than millimeters The library has volumes of books by Berlbury arranged in chronological order of their appearance The height of each book in millimeters is know it is As Berlbury is highly respected in the city the organizers want to include into the exposition as many books as possible and to find out what periods of his creative work they will manage to cover You are asked to help the organizers cope with this hard task ,"['#include <cstdio>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nconst int N = 100*1001;\nint n,k,h[N],e[N];\n\nmultiset<int> s;\n\nbool ok() {\n    if (s.empty()) return true;\n    return ( (*s.rbegin())-(*s.begin()) <= k );\n}\n\nint main() {\n    scanf(""%d%d"",&n,&k);\n    for(int i=0;i<n;i++)\n        scanf(""%d"",&h[i]);\n    for(int i=0;i<n;i++) {\n        if (i==0) e[i]=0; else e[i]=e[i-1];\n        while(e[i]<n && ok()) {\n            s.insert(h[e[i]]);\n            e[i]++;\n        }\n        if (!ok()) {\n            e[i]--;\n            s.erase(s.find(h[e[i]]));\n        }\n        s.erase(s.find(h[i]));\n    }\n   // for(int i=0;i<n;i++) printf(""%d\\n"",e[i]);\n    int best = 1;\n    for(int i=0;i<n;i++) best=max(best,e[i]-i);\n    int c=0;\n    for(int i=0;i<n;i++) if (e[i]-i==best) c++;\n    printf(""%d %d\\n"",best,c);\n    for(int i=0;i<n;i++)\n        if (e[i]-i==best) printf(""%d %d\\n"",i+1,e[i]);\n    return 0;\n}\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]",1900
One day Vasya was sitting on a not so interesting Maths lesson and making an origami from a rectangular mm mm sheet of paper Usually the first step in making an origami is making a square piece of paper from the rectangular sheet by folding the sheet along the bisector of the right angle and cutting the excess part After making a paper ship from the square piece Vasya looked on the remaining mm mm strip of paper He got the idea to use this strip of paper in the same way to make an origami and then use the remainder if it exists and so on At the moment when he is left with a square piece of paper he will make the last ship from it and stop Can you determine how many ships Vasya will make during the lesson ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\nll a, b, ans;\n\nint main() {\n\tcin >> a >> b;\n\twhile (a > 0 && b > 0) {\n\t\tll t = (a - b) / b + 1;\n\t\tans += t;\n\t\ta -= t * b;\n\t\tswap(a, b);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Three companies decided to order a billboard with pictures of their logos A billboard is a big board A logo of each company is a rectangle of a non zero area Advertisers will put up the ad only if it is possible to place all three logos on the billboard so that they do not overlap and the billboard has no empty space left When you put a logo on the billboard you should rotate it so that the sides were parallel to the sides of the billboard Your task is to determine if it is possible to put the logos of all the three companies on some square billboard without breaking any of the described rules ,"['#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint main()\n{\n    int a,b,c,d,e,f,ans=0,k=-1,n1,n2;\n    cin>>a>>b>>c>>d>>e>>f;\n    ans=a*b+c*d+e*f;\n    for(n1=1;n1<=1000;n1++)\n        if(n1*n1==ans)\n        {\n            k=n1;\n            break;\n        }\n    if(k==-1)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(b==k)\n        swap(a,b);\n    if(d==k)\n        swap(c,d);\n    if(f==k)\n        swap(e,f);\n    if(a==k&&c==k&&e==k)\n    {\n        cout<<k<<endl;\n        for(n1=1;n1<=b;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'A\');\n            printf(""\\n"");\n        }\n        for(n1=1;n1<=d;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'B\');\n            printf(""\\n"");\n        }\n        for(n1=1;n1<=f;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'C\');\n            printf(""\\n"");\n        }\n        return 0;\n    }\n    int sd=0;\n    if(c==k)\n    {\n        sd=1;\n        swap(a,c);\n        swap(b,d);\n    }\n    else\n    if(e==k)\n    {\n        sd=2;\n        swap(a,e);\n        swap(b,f);\n    }\n    if(a!=k)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    if(d==k-b)\n        swap(c,d);\n    if(f==k-b)\n        swap(e,f);\n    if(c!=k-b||e!=k-b)\n    {\n        cout<<-1<<endl;\n        return 0;\n    }\n    {\n        cout<<k<<endl;\n        for(n1=1;n1<=b;n1++)\n        {\n            for(n2=1;n2<=k;n2++)\n                putchar(\'A\'+sd);\n            printf(""\\n"");\n        }\n        for(n1=1;n1<=k-b;n1++)\n        {\n            if(sd!=1)\n            for(n2=1;n2<=d;n2++)\n                putchar(\'B\');\n            else\n            for(n2=1;n2<=d;n2++)\n                putchar(\'A\');   \n            if(sd!=2)                       \n            for(n2=1;n2<=f;n2++)\n                putchar(\'C\');\n            else\n            for(n2=1;n2<=f;n2++)\n                putchar(\'A\');\n            printf(""\\n"");\n        }\n        return 0;\n    }           \n}\n']","[0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Consider the insertion sort algorithm used to sort an integer sequence a 1 a 2 ldots a n of length n in non decreasing order For each i in order from 2 to n do the following If a i ge a i 1 do nothing and move on to the next value of i Otherwise find the smallest j such that a i a j shift the elements on positions from j to i 1 by one position to the right and write down the initial value of a i to position j In this case we ll say that we performed an of an element from position i to position j It can be noticed that after processing any i the prefix of the sequence a 1 a 2 ldots a i is sorted in non decreasing order therefore the algorithm indeed sorts any sequence For example sorting 4 5 3 1 3 proceeds as follows i 2 a 2 ge a 1 do nothing i 3 j 1 insert from position 3 to position 1 3 4 5 1 3 i 4 j 1 insert from position 4 to position 1 1 3 4 5 3 i 5 j 3 insert from position 5 to position 3 1 3 3 4 5 You are given an integer n and a list of m integer pairs x i y i We are interested in sequences such that if you sort them using the above algorithm exactly m insertions will be performed first from position x 1 to position y 1 then from position x 2 to position y 2 finally from position x m to position y m How many sequences of length n consisting of not necessarily distinct integers between 1 and n inclusive satisfy the above condition Print this number modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#include <bits/extc++.h> /** keep-include */\nusing namespace __gnu_pbds;\n \ntemplate<class T>\nusing ordered_set = tree<T, null_type, less<T>, rb_tree_tag,\n    tree_order_statistics_node_update>;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, ""MOD must be positive"");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nvector<num> fact, ifact;\n\nvoid init(){\n\tint N = 1100000;\n\tfact = {1};\n\tfor(int i = 1; i < N; i++) fact.push_back(i * fact[i-1]);\n\tifact.resize(N);\n\tifact.back() = 1 / fact.back();\n\tfor(int i = N - 1; i > 0; i--) ifact[i-1] = i * ifact[i];\n}\n\nnum ncr(int n, int k){\n\tif(k < 0 || k > n) return 0;\n\treturn fact[n] * ifact[k] * ifact[n-k];\n}\n\nordered_set<int> work;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> x(m), y(m);\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x[i] >> y[i];\n\t\tx[i]--; y[i]--;\n\t}\n\tvector<pair<int,int> > constraints;\n\tfor(int i = m-1; i >= 0; i--){\n\t\tauto it = work.find_by_order(y[i]);\n\t\tconstraints.push_back({*it, *next(it)});\n\t\twork.erase(it);\n\t}\n\tint ns = 0;\n\tfor(auto [a, b] : constraints){\n\t\tif(a+1 == b) ns++;\n\t}\n\tnum ans = ncr(n + n-1 - ns, n);\n\tcout << ans << \'\\n\';\n\tfor(auto [a, b] : constraints){\n\t\twork.insert(a);\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tinit();\n\tconst int MAXN = 200100;\n\tfor(int i = 0; i < MAXN; i++) work.insert(i);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2600
Kolya is developing an economy simulator game His most favourite part of the development process is in game testing Once he was entertained by the testing so much that he found out his game coin score become equal to Kolya remembers that at the beginning of the game his game coin score was equal to and that he have bought only some houses for game coins each cars for game coins each and computers for game coins each Kolya is now interested whether he could have spent all of his initial game coins buying only houses cars and computers or there is a bug in the game Formally is there a triple of non negative integers and such that Please help Kolya answer this question ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll n;\n\nll a = 1234567;\nll b = 123456;\nll c = 1234;\n\nint main() {\n\tcin >> n;\n\tfor (ll i = 0; i * a <= n; ++i) {\n\t\tfor (ll j = 0; i * a + j * b <= n; ++j) {\n\t\t\tif ((n - i * a - j * b) % 1234 == 0) {\n\t\t\t\tcout << ""YES\\n"";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ""NO\\n"";\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300
You are given the current time in hour format Find and print the time after minutes Note that you should find only the time after minutes see the examples to clarify the problem statement You can read more about hour format here https en wikipedia org wiki 24 hour clock ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\n\nint main(){\n    int h,m;\n    scanf(""%d : %d"",&h,&m);\n    DRI(x);\n    while(x--){\n        m++;\n        if(m==60){\n            m=0;\n            h++;\n            if(h==24){\n                h=0;\n            }\n        }\n    }\n    printf(""%02d:%02d"",h,m);\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
A plane contains a not necessarily convex polygon without self intersections consisting of vertexes numbered from 1 to There is a spider sitting on the border of the polygon the spider can move like that The spider moves from the point with coordinates lying on the polygon border to the point with coordinates also lying on the border The spider can t go beyond the polygon border as it transfers that is the spider s path from point to point goes along the polygon border It s up to the spider to choose the direction of walking round the polygon border clockwise or counterclockwise The spider moves from point with coordinates to point with coordinates at that points and must lie on one vertical straight line point must be not lower than point and segment mustn t have points located strictly outside the polygon specifically the segment can have common points with the border Initially the spider is located at the polygon vertex with number Find the length of the shortest path to the vertex number consisting of transfers and descends The distance is determined by the usual Euclidean metric ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\nstruct XD{\n    double x,y;\n    int id;\n    XD(double xx=0,double yy=0):x(xx),y(yy){}\n    void get(int ii){\n        id=ii;\n        scanf(""%lf%lf"",&x,&y);\n    }\n    XD operator-(const XD& b)const{\n        return XD(x-b.x,y-b.y);\n    }\n    XD operator-()const{\n        return XD(-x,-y);\n    }\n    double operator*(const XD& b)const{\n        return x*b.x+y*b.y;\n    }\n    double operator^(const XD& b)const{\n        return x*b.y-y*b.x;\n    }\n    int ss()const{\n        return x>0||(x>=-1e-9&&y>0);\n    }\n    bool operator<(const XD& b)const{\n        if(ss()!=b.ss())return ss()<b.ss();\n        return ((*this)^b)<0;\n    }\n    void print(const char* c){printf(""%s: %.3lf %.3lf\\n"",c,x,y);}\n    double len(){return sqrt(x*x+y*y);}\n};\nconst double eps=1e-7;\nbool cmpx(const XD& a,const XD& b){\n    return a.x==b.x?a.y<b.y:a.x<b.x;\n}\nbool cmpy(const XD& a,const XD& b){\n    return a.y==b.y?a.x<b.x:a.y<b.y;\n}\nXD in[101000];\ndouble nowx;\nstruct line{\n    int a,b,id;\n    line(){}\n    line(int aa,int bb,int ii):a(aa),b(bb),id(ii){\n        if(cmpx(in[b],in[a]))swap(a,b);\n    }\n    double get(double x)const{\n        if(in[a].x==in[b].x)return in[b].y;\n        return ((x-in[a].x)*in[b].y+(in[b].x-x)*in[a].y)/((double)in[b].x-in[a].x);\n    }\n    bool isv()const{\n        return fabs(in[a].x-in[b].x)<eps;\n    }\n    bool isin(double x)const{\n        return x>=in[a].x&&x<=in[b].x;\n    }\n    bool operator<(const line& x)const{\n        double x1=get(nowx),x2=x.get(nowx);\n        if(fabs(x1-x2)<eps){\n            if(x.isv())return 0;\n            if(isv())return 1;\n            double n1=nowx-1e-4,n2=nowx+1e-4;\n            if(isin(n1)&&x.isin(n1))return get(n1)<x.get(n1);\n            else if(isin(n2)&&x.isin(n2))return get(n2)<x.get(n2);\n            else return id<x.id;\n        }\n        return x1<x2;\n    }\n    void print()const{\n        in[a].print(""a"");\n        in[b].print(""b"");\n    }\n};\nline lns[101000];\nstruct ev{\n    int ln;\n    int isin;\n    ev(){}\n    ev(int ll,int ii):ln(ll),isin(ii){}\n    int pt()const{\n        if(isin)return lns[ln].a;\n        else return lns[ln].b;\n    }\n    bool operator<(const ev& b)const{\n        int p1=pt(),p2=b.pt();\n        if(in[p1].x==in[p2].x)return isin>b.isin;\n        return cmpx(in[p1],in[p2]);\n    }\n};\nev evs[201000];\nstruct ee{\n    int y;\n    double l;\n    ee(int yy=0,double ll=0):y(yy),l(ll){}\n};\nvector<ee> ed[101000];\nbool hasd[101000];\nbool hasu[101000];\nint que[101000],qs,qe;\ndouble dis[101000];\nbool inq[101000];\nint n;\ninline void push(int x){\n    if(inq[x])return;\n    inq[x]=1;\n    que[qe++]=x;\n    if(qe==101000)qe=0;\n}\ninline int pop(){\n    int a=que[qs++];\n    if(qs==101000)qs=0;\n    inq[a]=0;\n    return a;\n}\ninline double spfa(int st,int end){\n    int i;\n    for(i=0;i<n;i++)dis[i]=1e100;\n    dis[st]=0;\n    qs=qe=0;\n    push(st);\n    while(qs!=qe){\n        int np=pop();\n        for(i=0;i<ed[np].size();i++){\n            int y=ed[np][i].y;\n            double l=ed[np][i].l;\n            if(dis[y]>dis[np]+l){\n                dis[y]=dis[np]+l;\n                push(y);\n            }\n        }\n    }\n    return dis[end];\n}\nint main(){\n    scanf(""%d"",&n);\n    int i,j;\n    for(i=0;i<n;i++){\n        in[i].get(i);\n    }\n    for(i=0;i<n;i++){\n        int ii=(i+1==n?0:i+1);\n        double d=(in[i]-in[ii]).len();\n        ed[i].push_back(ee(ii,d));\n        ed[ii].push_back(ee(i,d));\n    }\n    for(i=0;i<n;i++){\n        int p1=(i==0?n-1:i-1);\n        int p2=(i==n-1?0:i+1);\n        XD l1=in[p1]-in[i];\n        XD l2=in[p2]-in[i];\n        XD b(0,-1);\n        if((l1.x==0&&l1.y<0)||(l2.x==0&&l2.y<0))hasd[i]=0;\n        else if(l2<l1)hasd[i]=1;\n        else hasd[i]=0;\n        if((l1.x==0&&l1.y>0)||(l2.x==0&&l2.y>0))hasu[i]=0;\n        else if(-l2<-l1)hasu[i]=1;\n        else hasu[i]=0;\n//        printf(""hasd[%d] = %d %d\\n"",i,hasd[i],hasu[i]);\n    }\n    int ec=0;\n    for(i=0;i<n;i++){\n        int ii=(i+1==n?0:i+1);\n        lns[i]=line(i,ii,i);\n        evs[ec++]=ev(i,0);\n        evs[ec++]=ev(i,1);\n    }\n    sort(evs,evs+ec);\n    multiset<line> ss;\n    for(i=0;i<ec;i++){\n        int id=evs[i].ln;\n        int isin=evs[i].isin;\n        int p=evs[i].pt();\n        nowx=in[p].x;\n        if(hasd[p]||hasu[p]){\n            multiset<line>::iterator i2;\n//            for(i2=ss.begin();i2!=ss.end();i2++)i2->print();\n//            puts(""-----------"");\n            multiset<line>::iterator it=ss.lower_bound(line(p,p,-1));\n            if(hasu[p]){\n                i2=it;\n                while(i2!=ss.end()&&i2->get(nowx)<in[p].y+eps)i2++;\n                if(i2!=ss.end()){\n                    double y=i2->get(nowx);\n//                    in[i2->a].print(""a"");\n//                    in[i2->b].print(""b"");\n//                    printf(""p=%d nowx=%d y=%.3lf\\n"",p,nowx,y);\n                    if(y>in[p].y+eps){\n                        double d=y-in[p].y;\n                        XD pp(nowx,y);\n                        ed[i2->a].push_back(ee(p,d+(in[i2->a]-pp).len()));\n                        ed[i2->b].push_back(ee(p,d+(in[i2->b]-pp).len()));\n                    }\n                }\n            }\n            if(hasd[p]&&it!=ss.begin()){\n                i2=it;\n                i2--;\n                while(i2!=ss.begin()&&i2->get(nowx)>in[p].y-eps)i2--;\n                double y=i2->get(nowx);\n//                in[i2->a].print(""a"");\n//                in[i2->b].print(""b"");\n                //printf(""p=%d nowx=%d y=%.3lf\\n"",p,nowx,y);\n                if(y<in[p].y-eps){\n                    double d=in[p].y-y;\n                    XD pp(nowx,y);\n                    ed[p].push_back(ee(i2->a,d+(in[i2->a]-pp).len()));\n                    ed[p].push_back(ee(i2->b,d+(in[i2->b]-pp).len()));\n                }\n            }\n        }\n//        printf(""i=%d p=%d %s %d\\n"",i,p,isin?""add"":""remove"",id);\n        if(isin){\n            ss.insert(lns[id]);\n        }else{\n            ss.erase(lns[id]);\n        }\n    }\n    /*\n    for(i=0;i<n;i++){\n        printf(""%d: "",i);\n        for(int j=0;j<ed[i].size();j++)printf(""(%d,%.3lf) "",ed[i][j].y,ed[i][j].l);\n        puts("""");\n    }*/\n    int start,end;\n    scanf(""%d%d"",&start,&end);start--;end--;\n    printf(""%.9lf\\n"",spfa(start,end));\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",3000
Galois is one of the strongest chess players of Byteforces He has even invented a new variant of chess which he named PawnChess This new game is played on a board consisting of 8 rows and 8 columns At the beginning of every game some black and white pawns are placed on the board The number of black pawns placed is not necessarily equal to the number of white pawns placed Lets enumerate rows and columns with integers from 1 to 8 Rows are numbered from top to bottom while columns are numbered from left to right Now we denote as the cell located at the row and at the column There are always two players A and B playing the game Player A plays with white pawns while player B plays with black ones The goal of player A is to put any of his pawns to the row while player B tries to put any of his pawns to the row As soon as any of the players completes his goal the game finishes immediately and the succeeded player is declared a winner Player A moves first and then they alternate turns On his move player A must choose exactly one white pawn and move it one step upward and player B at his turn must choose exactly one black pawn and move it one step down Any move is possible only if the targeted cell is empty It s guaranteed that for any scenario of the game there will always be at least one move available for any of the players Moving upward means that the pawn located in will go to the cell while moving down means the pawn located in will go to the cell Again the corresponding cell must be empty i e not occupied by any other pawn of any color Given the initial disposition of the board determine who wins the game if both players play optimally Note that there will always be a winner due to the restriction that for any game scenario both players will have some moves available ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define sz(x) ((int) (x).size())\n#define X first\n#define Y second\n\n#define MAX 11\nstring board[MAX];\n\nvoid smin(int &a, int b) {\n\tif (a > b) a = b;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef _LOCAL\n\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tfor (int i = 0; i < 8; ++i) cin >> board[i];\n\tint min_a = 1234;\n\tint min_b = 1234;\n\tfor (int j = 0; j < 8; ++j) {\n\t\tint i;\n\t\tfor (i = 0; i < 8 && board[i][j] == \'.\'; ++i);\n\t\tif (i < 8 && board[i][j] == \'W\') smin(min_a, i);\n\t\tfor (i = 7; i >= 0 && board[i][j] == \'.\'; --i);\n\t\tif (i >= 0 && board[i][j] == \'B\') smin(min_b, 8 - i - 1);\n\t}\n\tcerr << min_a << \' \' << min_b << endl;\n\tif (min_a <= min_b) cout << ""A"" << endl;\n\telse cout << ""B"" << endl;\n\treturn 0;\n}\n\n/**\n*\t built in Contest Parser [Version 1.02]\n**/\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
In a medieval kingdom the economic crisis is raging Milk drops fall Economic indicators are deteriorating every day money from the treasury disappear To remedy the situation King Charles Sunnyface decided make his sons princes marry the brides with as big dowry as possible In search of candidates the king asked neighboring kingdoms and after a while several delegations arrived with unmarried princesses Receiving guests Karl learned that the dowry of the th princess is of golden coins Although the action takes place in the Middle Ages progressive ideas are widespread in society according to which no one can force a princess to marry a prince whom she does not like Therefore each princess has an opportunity to choose two princes for each of which she is ready to become a wife The princes were less fortunate they will obey the will of their father in the matter of choosing a bride Knowing the value of the dowry and the preferences of each princess Charles wants to play weddings in such a way that the total dowry of the brides of all his sons would be as great as possible At the same time to marry all the princes or princesses is not necessary Each prince can marry no more than one princess and vice versa each princess can marry no more than one prince Help the king to organize the marriage of his sons in the most profitable way for the treasury ,"['#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint n,m,f[200010],g[200010],p;\nstruct orz\n{\n\tint u,v,w;\n}x[200010];\ninline bool cmp(orz a,orz b)\n{\n\treturn a.w>b.w;\n}\ninline int fa(int i)\n{\n\treturn f[i]==i?i:f[i]=fa(f[i]);\n}\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,j,k;\n\tscanf(""%d%d"",&n,&m);\n\tfor(i=1;i<=m;i++)\n\t  scanf(""%d%d%d"",&x[i].u,&x[i].v,&x[i].w);\n\tsort(x+1,x+m+1,cmp);\n\tfor(i=1;i<=n;i++)\n\t  f[i]=i;\n\tfor(i=1;i<=m;i++)\n\t  {\n\t   j=fa(x[i].u);\n\t   k=fa(x[i].v);\n\t   if(j==k)\n\t     {\n\t      if(g[j]==0)\n\t        {\n\t\t\t g[j]++;\n\t\t\t p+=x[i].w;\n\t\t\t}\n\t\t }\n\t   else\n\t     if(g[j]+g[k]<=1)\n\t       {\n\t\t\tf[k]=j;\n\t\t\tg[j]+=g[k];\n\t\t\tp+=x[i].w;\n\t\t   }\n\t  }\n\tprintf(""%d\\n"",p);\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2500
There is a conveyor with 120 rows and 120 columns Each row and column is numbered from 0 to 119 and the cell in i th row and j th column is denoted as i j The top leftmost cell is 0 0 Each cell has a belt and all belts are initially facing to the right Initially a slime ball is on the belt of 0 0 and other belts are empty Every second the state of the conveyor changes as follows All slime balls on the conveyor move one cell in the direction of the belt at the same time If there is no cell in the moved position the slime gets out of the conveyor and if two slime balls move to the same cell they merge into one All belts with slime ball in the previous second change direction at the same time belts facing to the right become facing to the down and vice versa A new slime ball is placed on cell 0 0 There are q queries each being three integers t x and y You have to find out if there is a slime at the cell x y after t seconds from the start Can you do it ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=5e3+1e2+7;\n\nint T;\n\nint n,m;\n\nlong long f[121][121][2];\n\nlong long solve(long long t,int x,int y)\n{\n\tif(t<(x+y))\n\t\treturn 0;\n\tt=(t-(x+y)+1);\n\tmemset(f,0,sizeof(f));\n\tf[0][0][0]=t;\n\tfor(int i=0;i<120;i++)\n\t\tfor(int j=0;j<120;j++)\n\t\t{\n\t\t\tlong long s=f[i][j][0];\n\t\t\tf[i][j][0]=(s+1)/2;\n\t\t\tf[i][j][1]=s/2;\n\t\t\tf[i][j+1][0]+=(f[i][j][0]);\n\t\t\tf[i+1][j][0]+=(f[i][j][1]);\n\t\t}\n\treturn f[x][y][0]+f[x][y][1];\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tlong long t,x,y;\n\t\tcin>>t>>x>>y;\n\t\tlong long a=solve(t,x,y);\n\t\tlong long b=solve(t-1,x,y);\n\t\tif(x+y>t)\n\t\t\tcout<<""NO\\n"";\n\t\telse if(a!=b)\n\t\t\tcout<<""YES\\n"";\n\t\telse\n\t\t\tcout<<""NO\\n"";\n\t}\n}']","[0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
You are given a 1 indexed array a of length n where each element is 1 or 2 Process q queries of the following two types check if there exists a subarray dagger of a whose sum equals to s change a i to v dagger An array b is a subarray of an array a if b can be obtained from a by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end In particular an array is a subarray of itself ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\n\nint tab[nax];\n\nint fen[nax];\n\nvoid pisz(int v, int x)\n{\n\tfor (int i=v; i<=n; i+=(i&(-i)))\n\t\tfen[i]+=x;\n}\n\nint czyt(int v)\n{\n\tint ret=0;\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tret+=fen[i];\n\treturn ret;\n}\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""YES\\n"");\n\telse\n\t\tprintf(""NO\\n"");\n}\n\nset<int> jed;\n\nint pier()\n{\n\tif (jed.empty())\n\t\treturn n+1;\n\treturn (*jed.begin());\n}\n\nint ost()\n{\n\tif (jed.empty())\n\t\treturn 0;\n\tauto it=jed.end();\n\tit--;\n\treturn (*it);\n}\n\nvoid test()\n{\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tfen[i]=0;\n\tfor (int i=1; i<=n; i++)\n\t\tpisz(i, tab[i]);\n\tjed.clear();\n\tfor (int i=1; i<=n; i++)\n\t\tif (tab[i]==1)\n\t\t\tjed.insert(i);\n\twhile(q--)\n\t{\n\t\tint typ;\n\t\tscanf(""%d"", &typ);\n\t\tif (typ==2)\n\t\t{\n\t\t\tint x, w;\n\t\t\tscanf(""%d%d"", &x, &w);\n\t\t\tpisz(x, -tab[x]);\n\t\t\tif (tab[x]==1)\n\t\t\t\tjed.erase(x);\n\t\t\ttab[x]=w;\n\t\t\tpisz(x, tab[x]);\n\t\t\tif (tab[x]==1)\n\t\t\t\tjed.insert(x);\n\t\t\tcontinue;\n\t\t}\n\t\tint s;\n\t\tscanf(""%d"", &s);\n\t\tif (czyt(n)<s)\n\t\t{\n\t\t\tans(0);\n\t\t\tcontinue;\n\t\t}\n\t\tint bsa=0;\n\t\tint bsb=n;\n\t\twhile(bsa<bsb)\n\t\t{\n\t\t\tint bss=(bsa+bsb+2)>>1;\n\t\t\tif (czyt(bss)<=s)\n\t\t\t\tbsa=bss;\n\t\t\telse\n\t\t\t\tbsb=bss-1;\n\t\t}\n\t\tif (czyt(bsa)==s)\n\t\t{\n\t\t\tans(1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ost()>bsa)\n\t\t{\n\t\t\tans(1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (pier()<=n-bsa)\n\t\t{\n\t\t\tans(1);\n\t\t\tcontinue;\n\t\t}\n\t\tans(0);\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1700
A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example the bracket sequences and are regular the resulting expressions are and the bracket sequences and are not A bracket sequence is called if one of the following conditions is satisfied it is a regular bracket sequence if the order of the characters in this sequence is reversed it becomes a regular bracket sequence For example the bracket sequences are beautiful You are given a bracket sequence s You have to color it in such a way that every bracket is colored into one color for every color there is at least one bracket colored into that color for every color if you write down the sequence of brackets having that color in the order they appear you will get a beautiful bracket sequence Color the given bracket sequence s into the number of colors according to these constraints or report that it is impossible ,"[""#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> S(n + 1, 0);\n    S[0] = 0;\n    for (int j = 0; j < n; j++){\n      if (s[j] == '('){\n        S[j + 1] = S[j] + 1;\n      }\n      if (s[j] == ')'){\n        S[j + 1] = S[j] - 1;\n      }\n    }\n    if (S[n] != 0){\n      cout << -1 << endl;\n    } else {\n      bool pos = false, neg = false;\n      for (int j = 0; j < n; j++){\n        if (S[j] > 0){\n          pos = true;\n        }\n        if (S[j] < 0){\n          neg = true;\n        }\n      }\n      if (!pos || !neg){\n        cout << 1 << endl;\n        for (int j = 0; j < n; j++){\n          cout << 1;\n          if (j < n - 1){\n            cout << ' ';\n          }\n        }\n        cout << endl;\n      } else {\n        vector<int> c(n);\n        for (int j = 0; j < n; j++){\n          if (S[j] + S[j + 1] > 0){\n            c[j] = 1;\n          } else {\n            c[j] = 2;\n          }\n        }\n        cout << 2 << endl;\n        for (int j = 0; j < n; j++){\n          cout << c[j];\n          if (j < n - 1){\n            cout << ' ';\n          }\n        }\n        cout << endl;\n      }\n    }\n  }\n}""]","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
A sequence of n numbers is called if it contains all numbers from 1 to n exactly once For example the sequences 3 1 4 2 1 and 2 1 are permutations but 1 2 1 0 1 and 1 3 4 are not For a given number n you need to make a permutation p such that two requirements are satisfied at the same time For each element p i at least one of its neighbors has a value that differs from the value of p i by one That is for each element p i 1 le i le n at least one of its neighboring elements standing to the left or right of p i must be p i 1 or p i 1 the permutation must have no fixed points That is for every i 1 le i le n p i neq i must be satisfied Let s call the permutation that satisfies these requirements For example let n 4 Then 4 3 1 2 is a permutation since to the right of p 1 4 is p 2 p 1 1 4 1 3 to the left of p 2 3 is p 1 p 2 1 3 1 4 to the right of p 3 1 is p 4 p 3 1 1 1 2 to the left of p 4 2 is p 3 p 4 1 2 1 1 for all i is p i ne i For a given positive integer n output permutation of length n or output if permutation of length n does not exist ,"['#include <bits/stdc++.h>\n#define dprintf(...) printf(__VA_ARGS__)\nusing namespace std;\ntypedef long long LL;\n\nvoid solve() {\n  int n;\n  cin >> n;\n  if (n == 3) { printf(""-1\\n""); return; }\n\n  vector<int> a;\n  if (n % 2 == 0) {\n    for (int i = 1; i <= n; i++) {\n      a.push_back(n - i + 1);\n    }\n  } else {\n    a.push_back(n);\n    a.push_back(n-1);\n    for (int i = 1; i <= n-2; i++)\n      a.push_back(i);\n  }\n\n  for (int i = 1; i <= n; i++) {\n    int x = a[i-1];\n    printf(i > 1 ? "" %d"" : ""%d"", x);\n    if (x == i) printf(""*"");\n  }\n\n  printf(""\\n"");\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n\n  int T; cin >> T;\n  for (int cs = 1; cs <= T; cs++) {\n    solve();\n  }\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Petya loves lucky numbers Everybody knows that positive integers are if their decimal representation doesn t contain digits other than and For example numbers are lucky and are not One night Petya was sleeping He was dreaming of being the president of some island country The country is represented by islands connected by two way roads Between some islands there is no road way even through other islands that s why the country is divided into several regions More formally each island belongs to exactly one region there is a path between any two islands located in the same region there is no path between any two islands from different regions A region is lucky if the amount of islands in it is a lucky number As a real president Petya first decided to build a presidential palace Being a lucky numbers fan Petya wants to position his palace in one of the lucky regions However it is possible that initially the country has no such regions In this case Petya can build additional roads between different regions thus joining them Find the minimum number of roads needed to build to create a lucky region ,"['#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=100000+10;\nconst int oo=100000000;\n\nvector<int> e[maxn];\nint que[maxn],qid[maxn];\nbool flag[maxn];\nint cnt[maxn];\nint A[maxn],B[maxn];\nint opt[maxn],tmp[maxn];\nint n,m,t;\n\nint main()\n{\n\tscanf(""%d%d"",&n,&m);\n\tfor (int i=0,a,b;i<m;i++)\n\t{\n\t\tscanf(""%d%d"",&a,&b);\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\tif (!flag[i])\n\t{\n\t\tint l=1,r=1;\n\t\tque[1]=i;flag[i]=1;\n\t\tfor (;l<=r;l++)\n\t\tfor (int j=0;j<e[que[l]].size();j++)\n\t\tif (!flag[e[que[l]][j]])\n\t\t{\n\t\t\tque[++r]=e[que[l]][j];\n\t\t\tflag[que[r]]=1;\n\t\t}\n\t\tcnt[r]++;\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\tif (cnt[i])\n\t{\n\t\tA[++t]=i;B[t]=cnt[i];\n\t}\n\n\tfor (int i=1;i<=77777;i++) opt[i]=oo;\n\tfor (int i=1;i<=t;i++)\n\t{\n\t\tfor (int j=0;j<=77777;j++) tmp[j]=oo;\n\t\tfor (int j=0;j<A[i];j++)\n\t\t{\n\t\t\tint l=1,r=0;\n\t\t\tfor (int k=j,id=0;k<=77777;k+=A[i],id++)\n\t\t\t{\n\t\t\t\twhile (l<=r && id-qid[l]>B[i]) l++;\n\t\t\t\tif (l<=r) tmp[k]=que[l]+id;\n\t\t\t\twhile (l<=r && opt[k]-id<=que[r]) r--;\n\t\t\t\tque[++r]=opt[k]-id;qid[r]=id;\n\t\t\t}\n\t\t}\n\t\tfor (int j=0;j<=77777;j++) opt[j]=min(opt[j],tmp[j]);\n\t}\n\n\tint res=n+1;\n\tfor (int i=1;i<=77777;i++)\n\tif (opt[i]<res)\n\t{\n\t\tbool ok=1;\n\t\tfor (int k=i;k;k/=10)\n\t\t\tok&=(k%10==4 || k%10==7);\n\t\tif (ok) res=opt[i];\n\t}\n\tif (res==n+1) printf(""-1\\n"");\n\telse printf(""%d\\n"",res-1);\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2500
Little Petya very much likes computers Recently he has received a new Ternatron IV as a gift from his mother Unlike other modern computers Ternatron IV operates with ternary and not binary logic Petya immediately wondered how the operation is performed on this computer and whether there is anything like it It turned out that the operation does exist however it is called and it works like this Suppose that we need to calculate the value of the expression Both numbers and are written in the ternary notation one under the other one under If they have a different number of digits then leading zeroes are added to the shorter number until the lengths are the same Then the numbers are summed together digit by digit The result of summing each two digits is calculated modulo 3 Note that there is no carry between digits i e during this operation the digits aren t transferred For example Petya wrote numbers and on a piece of paper Help him find such number that If there are several such numbers print the smallest one ,"['//Done by Grey Matter\n//Fet per Ferran Alet\n\n#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<map>\n#include<queue>\n#include<fstream>\n#include<algorithm>\n#include<string>\n#include<stack>\n#include<numeric>\n#include<set>\n#include<sstream>\n#include<list>\n\n#define INF 2147483647\n#define LINF 1000000000000000000LL\n#define EPS 1e-9\n#define debug(x) cerr << #x << "" = "" << x << endl\n#define FOR(x,y) for(int x=0;x<y;x++)\n#define FORU(x,y) for(int x=1;x<=y;x++)\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<string> VS;\ntypedef map<int,int> MII;\ntypedef MII::iterator iMII;\n\nint main(){\n//ios_base::sync_with_stdio(false);\n    long long a,b;\n    while(cin>>a>>b){\n        string s,st;\n        while(a){\n            s+=char(\'0\'+a%3);\n            a/=3;\n        }\n        while(b){\n            st+=char(\'0\'+b%3);\n            b/=3;\n        }\n        while(s.size()<st.size()) s+=""0"";\n        while(s.size()>st.size()) st+=""0"";\n        string ss;\n        FOR(i,s.size()){\n            ss+=char(\'0\'+(st[i]-\'0\'+12-s[i]+\'0\')%3);\n        }\n        long long cont=1;\n        long long  res=0;\n        FOR(i,ss.size()){\n            res+=(ss[i]-\'0\')*cont;\n            cont*=3;\n        }\n        cout<<res<<endl;\n    }\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Given the number find the smallest positive integer which has exactly divisors It is guaranteed that for the given the answer will not exceed ,"['#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<list>\n#include<set>\n#include<queue>\n#include<cassert>\n#include<sstream>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define LET(x,a) \t__typeof(a) x(a)\n#define IFOR(i,a,b) \tfor(LET(i,a);i!=(b);++i)\n#define EACH(it,v)  \tIFOR(it,v.begin(),v.end())\n#define FOR(i,a,b)  \tfor(int i=(int)(a) ; i < (int)(b);++i)\n#define REP(i,n) \tFOR(i,0,n)\n#define PB\t\tpush_back\n#define MP \t\tmake_pair\n#define EPS\t\t1e-9\n#define INF 2000000000\n\ntypedef vector<int>\tVI;\ntypedef long long\tLL;\ntypedef pair<int,int>\tPI;\n\nLL min1;\nLL primes[]={2,3,5,7,11,13,17,19,23,29,31,37};\nvector<LL> factors;\n\nvoid solve(int n,int lastIndex,LL cur,int index){\n\tif(cur>min1||cur<0)return;\n\tif(n==1){\n\t\tmin1 = cur;\n\t\treturn;\n\t}\n\tLL curPrime = primes[index];\n\tfor(int i = lastIndex;i>=0;i--){\n\t\tif(n%factors[i]==0){\n\t\t\tLL newCur = cur;\t\n\t\t\tREP(j,factors[i]-1){\n\t\t\t\tnewCur*=curPrime;\n\t\t\t\tif(newCur>min1)break;\n\t\t\t}\n\t\t\tsolve(n/factors[i],i,newCur,index+1);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tLL n;cin>>n;\n\tmin1 = 1;\n\tLL tmp = n;\n\tVI div;\n\tfor(int i=2;i<=tmp;i++){\n\t\twhile(tmp%i==0){\n\t\t\ttmp/=i;\n\t\t\tdiv.PB(i);\n\t\t}\n\t}\n\tfor(int i = div.size()-1;i>=0;i--){\n\t\tint  p = div[i];\n\t\tLL mul = primes[div.size()-1-i],cur=1;\n\t\tREP(j,p-1)cur*=mul;\n\t\tmin1*=cur;\n\t}\n\tfactors.clear();\n\tFOR(i,2,64)if(n%i==0){\n\t\tfactors.PB(i);\n\t}\n\tsolve(n,factors.size()-1,1,0);\n\tcout<<min1<<endl;\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]",2000
In recent years John has very successfully settled at his new job at the office But John doesn t like to idly sit around while his code is compiling so he immediately found himself an interesting distraction The point of his distraction was to maintain a water level in the water cooler used by other zebras Originally the cooler contained exactly k liters of water John decided that the amount of water must always be at least l liters of water but no more than r liters John will stay at the office for exactly t days He knows that each day exactly x liters of water will be used by his colleagues At the beginning of each day he can add exactly y liters of water to the cooler but at any point in time the amount of water in the cooler must be in the range l r Now John wants to find out whether he will be able to maintain the water level at the necessary level for t days Help him answer this question ,"['//clear adj and visited vector declared globally after each test case\n//check for long long overflow\n//while adding and subs check if mod becomes -ve\n//while using an integer directly in a builtin function add ll\n//Mod wale question mein last mein if dalo ie. Ans<0 then ans+=mod;\n//Dont keep array name as size or any other key word\n//Incase of close mle change language to c++17 or c++14 \n\n#include <bits/stdc++.h>  \n#include <ext/pb_ds/assoc_container.hpp>\n#define int long long\n#define IOS std::ios::sync_with_stdio(false); cin.tie(NULL);cout.tie(NULL);cout.precision(dbl::max_digits10);\n#define pb push_back\n#define mod 1000000007ll //998244353ll\n#define lld long double\n#define mii map<int, int>\n#define mci map<char, int>\n#define msi map<string, int>\n#define pii pair<int, int>\n#define ff first\n#define ss second \n#define all(x) (x).begin(), (x).end()\n#define rep(i,x,y) for(int i=x; i<y; i++)    \n#define fill(a,b) memset(a, b, sizeof(a))\n#define vi vector<int>\n#define setbits(x) __builtin_popcountll(x)\n#define print2d(dp,n,m) for(int i=0;i<=n;i++){for(int j=0;j<=m;j++)cout<<dp[i][j]<<"" "";cout<<""\\n"";}\ntypedef std::numeric_limits< double > dbl;\nusing namespace __gnu_pbds;\nusing namespace std;\ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> indexed_set;\nconst long long N=200005, INF=2000000000000000000;\nlld pi=3.1415926535897932;\nint lcm(int a, int b)\n{\n    int g=__gcd(a, b);\n    return a/g*b;\n}\nint power(int a, int b, int p)\n    {\n        if(a==0)\n        return 0;\n        int res=1;\n        a%=p;\n        while(b>0)\n        {\n            if(b&1)\n            res=(res*a)%p;\n            b>>=1;\n            a=(a*a)%p;\n        }\n        return res;\n    }\n\nint32_t main()\n{\n    IOS;\n    int k, l, r, t, x, y;\n    cin>>k>>l>>r>>t>>x>>y;\n    set <int> s;\n    int f=0;\n    while(1)\n    {\n        int d=(k-l)/x;\n        t-=d;\n        if(t<=0)\n        break;\n        k-=(d*x);\n        if(s.find(k%x)!=s.end())\n        break;\n        if((k+y)>r)\n        {\n            f=1;\n            break;\n        }\n        s.insert(k%x);\n        k+=y;\n        if((k-x)<l)\n        {\n            f=1;\n            break;\n        }\n    }\n    if(f)\n    cout<<""No"";\n    else\n    cout<<""Yes"";\n}']","[1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]",2200
Jamie has recently found undirected weighted graphs with the following properties very The graph is connected and contains exactly vertices and edges All edge weights are integers and are in range inclusive The length of shortest path from to is a prime number The sum of edges weights in the minimum spanning tree MST of the graph is a prime number The graph contains no loops or multi edges If you are not familiar with some terms from the statement you can find definitions of them in notes section Help Jamie construct any graph with given number of vertices and edges that is ,"[""#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nint q,i,j,k,n,m,y,z,c,mx2,t,s;\nint a,b,p,A,B,H[100005];\nint x = 384437;\nint main(){\n    cin >> n >> m;\n\n    cout << x << ' ' << x << endl;\n\n    for(i=1 ; i<n-1 ; i++)\n        cout << i << ' ' << i+1 << ' ' << 1 << endl;\n\n    cout << i << ' ' << i+1 << ' ' << x-(n-2) << endl;\n\n    m -= n-1;\n\n    for(i=1 ; i<=n ; i++){\n        for(j=i+2 ; j<=n and m; j++){\n            m--;\n            cout << i << ' ' << j << ' ' << 100000000 << endl;\n        }\n    }\n\n}\n""]","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1600
You are given an array of integers a of length n The elements of the array can be either different or the same Each element of the array is colored either blue or red There are no unpainted elements in the array One of the two operations described below can be applied to an array in a single step either you can select any blue element and decrease its value by 1 or you can select any red element and increase its value by 1 Situations in which there are no elements of some color at all are also possible For example if the whole array is colored blue or red one of the operations becomes unavailable Determine whether it is possible to make 0 or more steps such that the resulting array is a permutation of numbers from 1 to n In other words check whether there exists a sequence of steps possibly empty such that after applying it the array a contains in some order all numbers from 1 to n inclusive each exactly once ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvector <int> v;\nint a[1000005];\nsigned main(int argc, char** argv) {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tcin >> a[i];\n\t\tstring s;\n\t\tv.clear();\n\t\tcin >> s;\n\t\ts=\' \'+s;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]==\'B\') v.push_back(a[i]);\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint flag=1;\n\t\tfor(int i=0;i<v.size();i++)\n\t\t\tif(v[i]<=i) flag=0;\n\t\tv.clear();\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(s[i]==\'R\') v.push_back(a[i]);\n\t\t}\n\t\tsort(v.begin(),v.end());\n\t\tint now=n;\n\t\tfor(int i=(int)v.size()-1;i>=0;i--)\n\t\t{\n\t\t\tif(v[i]>now) flag=0;\n\t\t\t--now;\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tcout << ""YES\\n"";\n\t\t}\n\t\telse cout << ""NO\\n"";\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1300
Finally Vasya have come of age and that means he can finally get a passport To do it he needs to visit the passport office but it s not that simple There s only one receptionist at the passport office and people can queue up long before it actually opens Vasya wants to visit the passport office tomorrow He knows that the receptionist starts working after minutes have passed after midnight and closes after minutes have passed after midnight so that is the last minute when the receptionist is still working The receptionist spends exactly minutes on each person in the queue If the receptionist would stop working within minutes he stops serving visitors other than the one he already serves Vasya also knows that exactly visitors would come tomorrow For each visitor Vasya knows the point of time when he would come to the passport office Each visitor queues up and doesn t leave until he was served If the receptionist is free when a visitor comes in particular if the previous visitor was just served and the queue is empty the receptionist begins to serve the newcomer immediately For each visitor the point of time when he would come to the passport office is positive Vasya can come to the office at the time zero that is at midnight if he needs so but he can come to the office only at integer points of time If Vasya arrives at the passport office at the same time with several other visitors he yields to them and stand in the queue after the last of them Vasya wants to come at such point of time that he will be served by the receptionist and he would spend the minimum possible time in the queue Help him ,"['#include<bits/stdc++.h>\nusing namespace std;\nlong long int S,E,L,res,bes;\nint n;\nvoid upd(long long int wait, long long int tt){\n\tif(bes == -1 || bes > wait)\n\t\tbes = wait, res = tt;\n}\nint main(){\n\tscanf(""%I64d%I64d%I64d"",&S,&E,&L);\n\tscanf(""%d"",&n);\n\tbes = -1;\n\tres = -1;\n\tlong long int now = S;\n\tfor(int i=0; i<n; i++){\n\t\tlong long int tt;\n\t\tscanf(""%I64d"",&tt);\n\t\tif(now >= tt){\n\t\t\tif(now + L > E)break;\n\t\t\tlong long int wait = now - (tt-1);\n\t\t\tupd(wait, tt-1);\n\t\t\tnow += L;\n\t\t}else{\n\t\t\tupd(0, now);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(now + L <= E)\n\t\tupd(0, now);\n\tprintf(""%I64d\\n"",res);\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Mad scientist Mike has constructed a rooted tree which consists of vertices Each vertex is a reservoir which can be either empty or filled with water The vertices of the tree are numbered from 1 to with the root at vertex 1 For each vertex the reservoirs of its children are located below the reservoir of this vertex and the vertex is connected with each of the children by a pipe through which water can flow downwards Mike wants to do the following operations with the tree Fill vertex with water Then and all its children are filled with water Empty vertex Then and all its ancestors are emptied Determine whether vertex is filled with water at the moment Initially all vertices of the tree are empty Mike has already compiled a full list of operations that he wants to perform in order Before experimenting with the tree Mike decided to run the list through a simulation Help Mike determine what results will he get after performing all the operations ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 500010;\n\nint pz[N], pv[N], fin[N];\nint s[N], val[N];\nint kw, w[N];\nint ss[2 * N], ff[2 * N], pred[2 * N], last[N];\n\nvoid dfs(int v, int pr) {\n  w[++kw] = v;\n  pz[v] = kw;\n  int j = last[v];\n  while (j > 0) {\n    if (ff[j] != pr) {\n      pv[ff[j]] = v;\n      dfs(ff[j], v);\n    }\n    j = pred[j];\n  }\n  fin[v] = kw;\n}\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  int m = n - 1;\n  for (int i = 1; i <= m; i++) {\n    scanf(""%d %d"", ss + i, ff + i);\n    ss[i + m] = ff[i];\n    ff[i + m] = ss[i];\n  }\n  for (int i = 1; i <= n; i++) last[i] = 0;\n  for (int i = 1; i <= m + m; i++) {\n    pred[i] = last[ss[i]];\n    last[ss[i]] = i;\n  }\n  kw = 0;\n  dfs(1, 0);\n  for (int i = 1; i <= n; i++) s[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    s[i]++;\n    int j = (i | (i - 1)) + 1;\n    if (j <= n) s[j] += s[i];\n    val[i] = 1;\n  }\n  int tt;\n  scanf(""%d"", &tt);\n  while (tt--) {\n    int com, v;\n    scanf(""%d %d"", &com, &v);\n    if (com == 1) {\n      int sum = 0;\n      int x = pz[v] - 1;\n      while (x > 0) {\n        sum += s[x];\n        x &= x - 1;\n      }\n      int cur = 0;\n      x = fin[v];\n      while (x > 0) {\n        cur += s[x];\n        x &= x - 1;\n      }\n      if (cur == sum) continue;\n      int last = pz[v] - 1;\n      while (cur > sum) {\n        int ll = last + 1, rr = fin[v];\n        while (ll < rr) {\n          int mid = (ll + rr) >> 1;\n          x = mid;\n          int q = 0;\n          while (x > 0) {\n            q += s[x];\n            x &= x - 1;\n          }\n          if (q > sum) rr = mid;\n          else ll = mid + 1;\n        }\n        x = ll;\n        val[x] = 0;\n        while (x <= n) {\n          s[x]--;\n          x = (x | (x - 1)) + 1;\n        }\n        last = ll;\n        cur--;\n      }\n      if (v != 1) {\n        int x = pz[pv[v]];\n        if (val[x] == 0) {\n          val[x] = 1;\n          while (x <= n) {\n            s[x]++;\n            x = (x | (x - 1)) + 1;\n          }\n        }\n      }\n    } else\n    if (com == 2) {\n      if (val[pz[v]] == 0) {\n        int x = pz[v];\n        val[x] = 1;\n        while (x <= n) {\n          s[x]++;\n          x = (x | (x - 1)) + 1;\n        }\n      }\n    } else {\n      int sum = 0;\n      int x = fin[v];\n      while (x > 0) {\n        sum += s[x];\n        x &= x - 1;\n      }\n      x = pz[v] - 1;\n      while (x > 0) {\n        sum -= s[x];\n        x &= x - 1;\n      }\n      if (sum > 0) printf(""0\\n"");\n      else printf(""1\\n"");\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0]",2100
You are given a special connected undirected graph where each vertex belongs to at most one simple cycle Your task is to remove as many edges as needed to convert this graph into a tree connected graph with no cycles For each node independently output the maximum distance between it and a leaf in the resulting tree assuming you were to remove the edges in a way that minimizes this distance ,"['///////////////////////////////    _LeMur_\n#define _CRT_SECURE_NO_WARNINGS\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <stack>\n#include <tuple>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <list>\n#include <map>\n#include <set>\n \nusing namespace std;\n \nconst int N = 500005;\nconst int M = 2 * N;\nconst int inf = 1000 * 1000 * 1000;\nconst int mod = 998244353;\nmt19937 myrand(chrono::steady_clock::now().time_since_epoch().count());\n\nint n, m;\nvector < pair<int, int> > g[N];\n\nbool mark[M];\nbool used[N];\nint parent[N], ind[N];\n\nvector < vector<int> > G;\nvector <int> gcycle[N];\n\nvoid dfs(int v, int p) {\n  used[v] = true;\n\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i].first;\n    int id = g[v][i].second;\n\n    if (to == p || mark[id]) continue;\n\n    if (used[to]) {\n      vector <int> cycle;\n\n      int gag = v;\n      while (gag != to) {\n        cycle.push_back(gag);\n        mark[ind[gag]] = true;\n        gag = parent[gag];\n      }\n      mark[id] = true;\n      cycle.push_back(gag);\n\n      gcycle[gag].push_back((int)G.size());\n      G.push_back(cycle);\n      continue;\n    }\n\n    parent[to] = v;\n    ind[to] = id;\n    dfs(to, v);\n  }\n}\n\nint dp[N], dpup[N];\n\nint max_in_multiset(multiset <int> &Q) {\n  if ((int)Q.size() == 0) return 0;\n  auto it = Q.end();\n  --it;\n  return *it;\n}\n\nint cycle1(int id) {\n  vector <int> cycle = G[id];\n  cycle.pop_back();\n\n  multiset <int> Q;\n  for (int i = 0; i < (int)cycle.size(); i++) {\n    int v = cycle[i];\n    Q.insert(i + 1 + dp[v]);\n  }\n  int answ = max_in_multiset(Q);\n\n  for (int i = (int)cycle.size() - 1; i >= 0; i--) {\n    int v = cycle[i];\n    Q.erase(Q.find(i + 1 + dp[v]));\n    Q.insert(dp[v] + (int)cycle.size() - i);\n    answ = min(answ, max_in_multiset(Q));\n  }\n\n  return answ;\n}\n\nvector <int> val[N];\n\nvoid dfs1(int v, int p) {\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i].first;\n    int id = g[v][i].second;\n    if (to == p || mark[id]) continue;\n    dfs1(to, v);\n    dp[v] = max(dp[v], dp[to] + 1);\n  }\n  for (int i = 0; i < (int)gcycle[v].size(); i++) {\n    int id = gcycle[v][i];\n    for (int j = 0; j < (int)G[id].size() - 1; j++) {\n      int to = G[id][j];\n      dfs1(to, v);\n    }\n    val[v].push_back(cycle1(id));\n    dp[v] = max(dp[v], val[v].back());\n  }\n}\n\nvoid cycle2(int id, int up) {\n  vector <int> vals, cycle;\n  cycle = G[id];\n  cycle.insert(cycle.end(), G[id].begin(), G[id].end());\n  cycle.pop_back();\n\n  int sz = (int)G[id].size();\n  for (int i = 0; i < (int)cycle.size(); i++) {\n    int v = cycle[i];\n    if (i < sz - 1) {\n      vals.push_back(dp[v]);\n    } else if (i == sz - 1) {\n      vals.push_back(up);\n    } else {\n      vals.push_back(dp[v]);\n    }\n  }\n\n  multiset <int> Qleft, Qright;\n  int sz_left = sz / 2;\n  int sz_right = sz - 1 - sz_left;\n\n  for (int i = 0; i < sz; i++) {\n    if (i < sz_left) {\n      Qleft.insert(vals[i] - i);\n    } else if (i > sz_left) {\n      Qright.insert(vals[i] + i);\n    }\n  }\n\n  for (int i = sz_left; i < sz_left + sz; i++) {\n    int v = cycle[i];\n    if (v != G[id][sz - 1]) {\n      dpup[v] = max(max_in_multiset(Qleft) + i, max_in_multiset(Qright) - i);\n    }\n    ///\n    Qleft.erase(Qleft.find(vals[i - sz_left] - (i - sz_left)));\n    Qleft.insert(vals[i] - i);\n    ///\n    Qright.erase(Qright.find(vals[i + 1] + i + 1));\n    Qright.insert(vals[i + 1 + sz_right] + i + 1 + sz_right);\n  }\n}\n\nvoid dfs2(int v, int p) {\n  multiset <int> Q;\n\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i].first;\n    int id = g[v][i].second;\n    if (to == p || mark[id]) continue;\n    Q.insert(dp[to] + 1);\n  }\n  for (int x: val[v]) Q.insert(x);\n\n  for (int i = 0; i < (int)g[v].size(); i++) {\n    int to = g[v][i].first;\n    int id = g[v][i].second;\n    if (to == p || mark[id]) continue;\n    Q.erase(Q.find(dp[to] + 1));\n    dpup[to] = max(dpup[v], max_in_multiset(Q)) + 1;\n    Q.insert(dp[to] + 1);\n\n    dfs2(to, v);\n  }\n\n  for (int i = 0; i < (int)gcycle[v].size(); i++) {\n    int id = gcycle[v][i];\n\n    Q.erase(Q.find(val[v][i]));\n    int up = max(dpup[v], max_in_multiset(Q));\n    Q.insert(val[v][i]);\n\n    cycle2(id, up);\n\n    for (int j = 0; j < (int)G[id].size() - 1; j++) {\n      int to = G[id][j];\n      dfs2(to, v);\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    scanf(""%d%d"", &a, &b);\n    g[a].push_back(make_pair(b, i));\n    g[b].push_back(make_pair(a, i));\n  }\n\n  dfs(1, -1);\n  dfs1(1, -1);\n  dfs2(1, -1);\n  \n  for (int i = 1; i <= n; i++) {\n    printf(""%d "", max(dp[i], dpup[i]));\n  }\n  cout << endl;\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",2900
You are given two arrays of integers a 1 ldots a n of length n and b 1 ldots b m of length m You can choose any element b j from array b 1 leq j leq m and for 1 leq i leq n perform a i a i b j You can perform any number of such operations After all the operations the value of x a 1 oplus a 2 oplus ldots oplus a n will be calculated Find the minimum and maximum values of x that could be obtained after performing any set of operations Above is the bitwise OR operation and oplus is the bitwise XOR operation ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7;\nint a[N], b[N];\nint n, m;\nvoid Main() {\n\tcin >> m >> n;\n\tL(i, 1, m) {\n\t\tcin >> b[i];\n\t}\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tint op = 0;\n\tL(i, 1, m) {\n\t\top ^= b[i];\n\t}\n\tint ans1 = 0, ans2 = 0;\n\tif(m & 1) {\n\t\tans1 = op;\n\t\tL(i, 1, n) {\n\t\t\top |= a[i];\n\t\t}\n\t\tans2 = op;\n\t} else {\n\t\tans2 = op;\n\t\tL(i, 1, n) {\n\t\t\top &= ~a[i];\n\t\t}\n\t\tans1 = op;\n\t}\n\tcout << ans1 << ' ' << ans2 << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n""]","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You are given integers Denote this list of integers as Let be a function that takes in a non empty list of integers The function will output another integer as follows First all integers in are padded with leading zeros so they are all the same length as the maximum length number in We will construct a string where the th character is the minimum of the th character in padded input numbers The output is the number representing the string interpreted in base 10 For example Define the function Here denotes a subsequence In other words is the sum of squares of sum of elements of nonempty subsequences of that evaluate to when plugged into modulo then multiplied by The last multiplication is not modded You would like to compute To reduce the output size print the value where denotes the bitwise XOR operator ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 1000000;\nconst int M = 6;\n\nconst ll mod = 1000000007;\n\nstruct Input {\n\tint n;\n\tint a[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(""%d"", &a[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tll ans;\n\t\n\tvoid write () {\n\t\tcout << ans << endl;\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\tint pw[M + 1];\n\t\tll pw2[N + 1];\n\t\tll cnt[N], sum[N], sum2[N];\n\t\tll val[N];\n\t\t\n\t\tvoid solve () {\n\t\t\tpw[0] = 1;\n\t\t\tforn (i, M)  {\n\t\t\t\tpw[i + 1] = pw[i] * 10;\n\t\t\t}\n\t\t\tpw2[0] = 1;\n\t\t\tforn (i, N) {\n\t\t\t\tpw2[i + 1] = pw2[i] * 2 % mod;\n\t\t\t}\n\t\t\tforn (i, n) {\n\t\t\t\t(cnt[a[i]] += 1) %= mod;\n\t\t\t\t(sum[a[i]] += a[i]) %= mod;\n\t\t\t\t(sum2[a[i]] += a[i] * 1ll * a[i]) %= mod;\n\t\t\t}\n\t\t\tforn (i, M) {\n\t\t\t\tford (j, N) {\n\t\t\t\t\tif (j / pw[i] % 10 != 0) {\n\t\t\t\t\t\t(cnt[j - pw[i]] += cnt[j]) %= mod;\n\t\t\t\t\t\t(sum[j - pw[i]] += sum[j]) %= mod;\n\t\t\t\t\t\t(sum2[j - pw[i]] += sum2[j]) %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tforn (i, N) {\n\t\t\t\tif (cnt[i] == 0) {\n\t\t\t\t\tval[i] = 0;\n\t\t\t\t} else if (cnt[i] == 1) {\n\t\t\t\t\tval[i] = sum2[i];\n\t\t\t\t} else {\n\t\t\t\t\tval[i] = (sum[i] * sum[i] + sum2[i]) % mod * pw2[cnt[i] - 2] % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug(val[N - 1]);\n\t\t\tforn (i, M) {\n\t\t\t\tforn (j, N) {\n\t\t\t\t\tif (j / pw[i] % 10 != 0) {\n\t\t\t\t\t\t(val[j - pw[i]] += mod - val[j]) %= mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = 0;\n\t\t\tforn (i, N) {\n\t\t\t\tans ^= val[i] * i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + "".in"").c_str(), ""r"", stdin);\n//\t\tfreopen((problemname + "".out"").c_str(), ""w"", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2700
It s a walking tour day in SIS Winter so t groups of students are visiting Torzhok Streets of Torzhok are so narrow that students have to go in a row one after another Initially some students are angry Let s describe a group of students by a string of capital letters and corresponds to an angry student corresponds to a patient student Such string describes the row from the last to the first student Every minute every angry student throws a snowball at the next student Formally if an angry student corresponds to the character with index i in the string describing a group then they will throw a snowball at the student that corresponds to the character with index i 1 students are given from the last to the first student If the target student was not angry yet they become angry Even if the first the rightmost in the string student is angry they don t throw a snowball since there is no one in front of them Let s look at the first example test The row initially looks like this Then after a minute the only single angry student will throw a snowball at the student in front of them and they also become angry After that no more students will become angry Your task is to help SIS Winter teachers to determine the last moment a student becomes angry for every group ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nint work(string s) {\n  int step = 0;\n  while (1) {\n    bool changed = false;\n\n    for (int i = (int)s.length()-2 ; i >= 0 ; i--) {\n      // cout << s[i] << s[i+1] << endl;\n      if (s[i] == 'A' && s[i+1] == 'P') {\n        changed = true;\n        s[i+1] = 'A';\n      }\n    }\n\n    if (!changed) {\n      return step;\n    }\n\n    step++;\n  }\n}\n\nint main() {\n  int t; cin >> t;\n\n  for (int tc = 1 ; tc <= t ; tc++) {\n    int n; cin >> n;\n    string s; cin >> s;\n\n    cout << work(s) << endl;\n  }\n  return 0;\n}""]","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Limak is a little polar bear He has balls the th ball has size Limak wants to give one ball to each of his three friends Giving gifts isn t easy there are two rules Limak must obey to make friends happy No two friends can get balls of the same size No two friends can get balls of sizes that differ by more than For example Limak can choose balls with sizes and or balls with sizes and But he can t choose balls with sizes and two friends would get balls of the same size and he can t choose balls with sizes and because sizes and differ by more than Your task is to check whether Limak can choose three balls that satisfy conditions above ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,a[51];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%d"",a+i);\n\tsort(a,a+n);\n\trep(i,0,n) rep(j,i+1,n) rep(k,j+1,n) if (a[k]==a[i]+2&&a[j]==a[i]+1) {\n\t\tputs(""YES"");\n\t\treturn 0;\n\t}\n\tputs(""NO"");\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]",900
Initially there was an array a consisting of n integers Positions in it are numbered from 1 to n Exactly q queries were performed on the array During the i th query some segment l i r i 1 le l i le r i le n was selected and values of elements on positions from l i to r i inclusive got changed to i The order of the queries couldn t be changed and all q queries were applied It is also known that every position from 1 to n got covered by at least one segment We could have offered you the problem about checking if some given array consisting of n integers with values from 1 to q can be obtained by the aforementioned queries However we decided that it will come too easy for you So the enhancement we introduced to it is the following Some set of positions possibly empty in this array is selected and values of elements on these positions are set to 0 Your task is to check if this array can be obtained by the aforementioned queries Also if it can be obtained then restore this array If there are multiple possible arrays then print any of them ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 200005;\nconst int MAXT = 530000;\nconst int mod = 1e9 + 7;\n\nstruct seg{\n\tint tree[MAXT], lim;\n\tvoid init(int n){\n\t\tmemset(tree, 0x3f, sizeof(tree));\n\t\tfor(lim = 1; lim <= n; lim <<= 1);\n\t}\n\tvoid upd(int x, int v){\n\t\tx += lim;\n\t\ttree[x] = v;\n\t\twhile(x > 1){\n\t\t\tx >>= 1;\n\t\t\ttree[x] = min(tree[x], v);\n\t\t}\n\t}\n\tint query(int s, int e){\n\t\ts += lim;\n\t\te += lim;\n\t\tint ret = 1e9;\n\t\twhile(s < e){\n\t\t\tif(s%2 == 1) ret = min(ret, tree[s++]);\n\t\t\tif(e%2 == 0) ret = min(ret, tree[e--]);\n\t\t\ts >>= 1;\n\t\t\te >>= 1;\n\t\t}\n\t\tif(s == e) ret = min(ret, tree[s]);\n\t\treturn ret;\n\t}\n}seg;\n\nint n, q, arr[MAXN];\nint l[MAXN], r[MAXN];\n\nint main(){\n\tcin >> n >> q;\n\tseg.init(n);\n\tmemset(l, 0x3f, sizeof(l));\n\tint anny = -1;\n\tset<int> s;\n\tfor(int i=1; i<=n; i++){\n\t\tscanf(""%d"",&arr[i]);\n\t\tl[arr[i]] = min(l[arr[i]], i);\n\t\tr[arr[i]] = max(r[arr[i]], i);\n\t\tif(arr[i] == 0) s.insert(i);\n\t\telse seg.upd(i, arr[i]);\n\t}\n\tif(!s.empty()) anny = *s.begin();\n\tfor(int i=q; i; i--){\n\t\tif(l[i] > r[i]) continue;\n\t\tif(seg.query(l[i], r[i]) < i){\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t\tauto it = s.lower_bound(l[i]);\n\t\twhile(it != s.end()){\n\t\t\tif(*it <= r[i]){\n\t\t\t\tarr[*it] = i;\n\t\t\t\tit = s.erase(it);\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t}\n\tfor(auto &i : s) arr[i] = 1;\n\tif(l[q] > r[q]){\n\t\tif(anny == -1){\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t\tarr[anny] = q;\n\t}\n\tputs(""YES"");\n\tfor(int i=1; i<=n; i++) printf(""%d "", arr[i]);\n\t// TODO : make sure q appears\n}\n']","[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Vanya got cubes He decided to build a pyramid from them Vanya wants to build the pyramid as follows the top level of the pyramid must consist of cube the second level must consist of cubes the third level must have cubes and so on Thus the th level of the pyramid must have cubes Vanya wants to know what is the maximum height of the pyramid that he can make using the given cubes ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint f[200] = {}, p[200] = {};\n\tfor(int i = 1 ; i < 200 ; i++){\n\t\tf[i] = i + f[i-1];\n\t\tp[i] = f[i] + p[i-1];\n\n\t}\n\tint n;\n\tcin >> n;\n\tcout << upper_bound(p, p+200, n) - p - 1<< endl;\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
YunQian is standing on an infinite plane with the Cartesian coordinate system on it In one move she can move to the diagonally adjacent point on the top right or the adjacent point on the left That is if she is standing on point x y she can either move to point x 1 y 1 or point x 1 y YunQian initially stands at point a b and wants to move to point c d Find the minimum number of moves she needs to make or declare that it is impossible ,"['// Problem: A. Walking Master\n// Contest: Codeforces - Codeforces Round 858 (Div. 2)\n// URL: https://codeforces.com/contest/1806/problem/A\n// Memory Limit: 1024 MB\n// Time Limit: 1000 ms\n\n#include<bits/stdc++.h>\n#define poly vector<int>\n#define IOS ios::sync_with_stdio(false)\n#define ll long long\n#define mp make_pair\n#define mt make_tuple\n#define pa pair < int,int >\n#define fi first\n#define se second\n#define inf 1e18\n#define mod 998244353\n#define int ll\n// #define N \nusing namespace std;\nvoid BellaKira()\n{\n\tint a,b,c,d;\n\tcin>>a>>b>>c>>d;\n\tint ans=0;\n\tif (c>a)\n\t{\n\t\tans+=(c-a);\n\t\tb+=(c-a);\n\t\ta=c;\n\t}\n\tif (d>b)\n\t{\n\t\tans+=(d-b);\n\t\ta+=d-b;\n\t\tb=d;\n\t}\n\tif (c<a&&d==b)\n\t{\n\t\tans+=a-c;\n\t\ta=c;\n\t}\n\tif (a!=c||b!=d) cout<<""-1\\n"";\n\telse cout<<ans<<\'\\n\';\n}\nsigned main()\n{\n\tIOS;cin.tie(0); \n\tint T=1;\n\tcin>>T;\n\twhile (T--)\n\t{\n\t\tBellaKira();\n\t}\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You have array of n numbers a 1 a 2 ldots a n Rearrange these numbers to satisfy a 1 a 2 le a 2 a 3 le ldots le a n 1 a n where x denotes absolute value of x It s always possible to find such rearrangement Note that all numbers in a are not necessarily different In other words some numbers of a may be same You have to answer independent t test cases ,"['\ufeff#include<bits/stdc++.h>\n#include <array>\nusing namespace std;\nusing ULL = unsigned long long;\nusing UL = unsigned;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\ntemplate<class Ty>\nusing passive_queue = priority_queue<Ty, vector<Ty>, greater<Ty>>;\n\nstruct Problem {\n\n\tvoid Loop() {\n\t\tUL N; cin >> N;\n\t\tvector<int> A(N); rep(i, N) cin >> A[i];\n\t\tsort(A.begin(), A.end());\n\t\tint p = 0, q = N - 1;\n\t\tvector<int> ans;\n\t\twhile (p <= q) {\n\t\t\tans.push_back(A[p]);\n\t\t\tif (p < q) ans.push_back(A[q]);\n\t\t\tp++; q--;\n\t\t}\n\t\treverse(ans.begin(), ans.end());\n\t\trep(i, N) {\n\t\t\tif (i) cout << "" "";\n\t\t\tcout << ans[i];\n\t\t} cout << endl;\n\t}\n\n\tvoid Solve() {\n\t\tUL Q; cin >> Q;\n\t\trep(i, Q) {\n\t\t\tLoop();\n\t\t}\n\t}\n\n\tProblem();\n};\nint main() {\n\tunique_ptr<Problem> p(new Problem());\n\tp->Solve();\n\treturn 0;\n}\nProblem::Problem() {\n\tcout << fixed << setprecision(10);\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1200
There are walruses standing in a queue in an airport They are numbered starting from the queue s tail the st walrus stands at the end of the queue and the th walrus stands at the beginning of the queue The th walrus has the age equal to The th walrus becomes displeased if there s a younger walrus standing in front of him that is if exists such that The of the th walrus is equal to the number of walruses between him and the furthest walrus ahead of him which is younger than the th one That is the further that young walrus stands from him the stronger the displeasure is The airport manager asked you to count for each of walruses in the queue his displeasure ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nvector <pii> a;\nint ans[100000];\nint x;\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tscanf (""%d"", &n);\n\ta.resize (n);\n\tforn (i, n) {\n\t\ta[i].sc = i;\n\t\tscanf (""%d"", &a[i].fs);\n\t}\n\tsort (all (a));\n\tint l = 0;\n\tx = -1;\n\twhile (l < n) {\n\t\tint r = l;\n\t\twhile (r + 1 < l && a[r+1].fs == a[l].fs)\n\t\t\tr ++;\n\t\tfor (int i = l; i <= r; i ++) {\n\t\t\tif (x < a[i].sc)\n\t\t\t\tans[a[i].sc] = -1;\n\t\t\telse\n\t\t\t\tans[a[i].sc] = x - a[i].sc - 1;\n\t\t}\n\t\tfor (int i = l; i <= r; i ++)\n\t\t\tx = max (x, a[i].sc);\n\t\tl = r + 1;\n\t}\n\tforn (i, n)\n\t\tprintf (""%d "", ans[i]);\n\tcout << endl;\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1500
You are given three strings s t and p consisting of lowercase Latin letters You may perform any number possibly zero operations on these strings During each operation you choose any character from p erase it from p and insert it into string s you may insert this character anywhere you want in the beginning of s in the end or between any two consecutive characters For example if p is and s is then the following outcomes are possible the character we erase from p and insert into s is highlighted rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow rightarrow Your goal is to perform several maybe zero operations so that s becomes equal to t Please determine whether it is possible Note that you have to answer q independent queries ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(""{"");\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; // const needed for vector<bool>\n        pr(""}"");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(""\\n""); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,"" ""); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint q;\n\nvoid solve() {\n\tstring s,t,p; re(s,t,p);\n\tvi bal(26);\n\ttrav(z,s) bal[z-\'a\'] ++;\n\ttrav(z,p) bal[z-\'a\'] ++;\n\ttrav(z,t) bal[z-\'a\'] --;\n\tF0R(j,26) if (bal[j] < 0) {\n\t\tps(""NO"");\n\t\treturn;\n\t}\n\tint ind = 0;\n\tF0R(i,sz(t)) {\n\t\tif (s[ind] == t[i]) ind ++;\n\t\tif (ind == sz(s)) {\n\t\t\tps(""YES"");\n\t\t\treturn;\n\t\t}\n\t}\n\tps(""NO"");\n}\n\nint main() {\n    setIO(); re(q);\n    F0R(i,q) solve();\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1300
You are managing a mobile phone network and want to offer competitive prices to connect a network The network has n nodes Your competitor has already offered some connections between some nodes with some fixed prices These connections are bidirectional There are initially m connections the competitor is offering The i th connection your competitor is offering will connect nodes fa i and fb i and costs fw i You have a list of k connections that you want to offer It is guaranteed that this set of connection does not form any cycle The j th of these connections will connect nodes ga j and gb j These connections are also bidirectional The cost of these connections have not been decided yet You can set the prices of these connections to any arbitrary integer value These prices are set independently for each connection After setting the prices the customer will choose such n 1 connections that all nodes are connected in a single network and the total cost of chosen connections is minimum possible If there are multiple ways to choose such networks the customer will choose an arbitrary one that also maximizes the number of your connections in it You want to set prices in such a way such that your k connections are chosen by the customer and the sum of prices of your connections is maximized Print the maximum profit you can achieve or 1 if it is unbounded ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 500005;\n\nint n, m, k;\nstruct disj{\n\tint pa[MAXN];\n\tvoid init(int n){\n\t\tiota(pa, pa + n + 1, 0);\n\t}\n\tint find(int x){\n\t\treturn pa[x] = (pa[x] == x ? x : find(pa[x]));\n\t}\n\tbool uni(int p, int q){\n\t\tp = find(p);\n\t\tq = find(q);\n\t\tif(p == q) return 0;\n\t\tpa[q] = p; return 1;\n\t}\n}disj;\n\nstruct edg{\n\tint s, e, x;\n\tbool operator<(const edg &e)const{\n\t\treturn x < e.x;\n\t}\n};\n\nvector<edg> mst, repl;\nvector<pi> gph[MAXN];\n\nint dep[MAXN];\nint par[19][MAXN], isquery[MAXN];\n\nvoid dfs(int x, int p){\n\tfor(auto &i : gph[x]){\n\t\tif(i.second == p) continue;\n\t\tif(i.first == 0) isquery[i.second] = 1;\n\t\tdep[i.second] = dep[x] + 1;\n\t\tpar[0][i.second] = x;\n\t\tdfs(i.second, x);\n\t}\n}\n\nint lca(int s, int e){\n\tif(dep[s] > dep[e]) swap(s, e);\n\tint dx = dep[e] - dep[s];\n\tfor(int i=0; i<19; i++){\n\t\tif((dx >> i) & 1) e = par[i][e];\n\t}\n\tfor(int i=18; i>=0; i--){\n\t\tif(par[i][s] != par[i][e]){\n\t\t\ts = par[i][s];\n\t\t\te = par[i][e];\n\t\t}\n\t}\n\tif(s != e) return par[0][s];\n\treturn s;\n}\n\n\nint pa[MAXN], ans[MAXN];\n\nint paint(int s, int l, int v, int *ans){\n\tif(s != pa[s]) return pa[s] = paint(pa[s], l, v, ans);\n\tif(dep[s] <= dep[l]) return s;\n\telse{\n\t\tans[s] = v;\n\t\treturn pa[s] = paint(par[0][s], l, v, ans);\n\t}\n}\n\nint main(){\n\tscanf(""%d %d %d"",&n,&k,&m);\n\tfor(int i=0; i<k; i++){\n\t\tint s, e; scanf(""%d %d"",&s,&e);\n\t\tmst.push_back({s, e, 0});\n\t}\n\tfor(int i=0; i<m;i++){\n\t\tint s, e, x;\n\t\tscanf(""%d %d %d"",&s,&e,&x);\n\t\tmst.push_back({s, e, x});\n\t}\n\tdisj.init(n);\n\tsort(mst.begin(), mst.end());\n\tfor(auto &i : mst){\n\t\tif(disj.uni(i.s, i.e)){\n\t\t\tgph[i.s].push_back(pi(i.x, i.e));\n\t\t\tgph[i.e].push_back(pi(i.x, i.s));\n\t\t}\n\t\telse{\n\t\t\trepl.push_back(i);\n\t\t}\n\t}\n\tdfs(1, 0);\n\tfor(int i=1; i<19; i++){\n\t\tfor(int j=1; j<=n; j++){\n\t\t\tpar[i][j] = par[i-1][par[i-1][j]];\n\t\t\tpa[j] = j;\n\t\t}\n\t}\n\tfor(auto &i : repl){\n\t\tint l = lca(i.s, i.e);\n\t\tpaint(i.s, l, i.x, ans);\n\t\tpaint(i.e, l, i.x, ans);\n\t}\n\tlint dap = 0;\n\tfor(int i=2; i<=n; i++){\n\t\tif(isquery[i]){\n\t\t\tif(ans[i] == 0){\n\t\t\t\tputs(""-1"");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdap += ans[i];\n\t\t}\n\t}\n\tcout <<dap << endl;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0]",2600
He has a chessboard of rows and columns Some cells of the chessboard are bad others are good For every good cell DZY wants to put a chessman on it Each chessman is either white or black After putting all chessmen DZY wants that no two chessmen with the same color are on two adjacent cells Two cells are adjacent if and only if they share a common edge You task is to find any suitable placement of chessmen on the given chessboard ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst double pi=acos (-1.0);\nconst double eps=1e-8 ;\n//const ll INF=(_I64_MAX)/2;\n//#pragma comment(linker, ""/STACK:102400000,102400000"")\nconst int inf=0x3f3f3f3f ;\n#define maxx(a) memset(a, 0x3f, sizeof(a))\n#define zero(a) memset(a, 0, sizeof(a))\n#define FILL(a,b) memset(a, b, sizeof(a))\n#define REP(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n#define srep(i,n) for(i = 1;i <= n;i ++)\n#define snuke(c,itr) for( __typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define MP make_pair\n#define fi first\n#define se second\ntypedef pair <int, int> PII;\ntypedef pair <ll, ll> PX;\n\n\nvoid work() {\n\n\n}\nstring s[111];\nint main ()\n{\n#ifdef LOCAL\n     freopen(""in.txt"" ,""r"", stdin);\n     // freopen (""out.txt"",""w"",stdout);\n#endif\n     int n,m,i,j;\n     cin>>n>>m;\n     rep(i,n) cin>>s[i];\n\n     rep(i,n) {\n         rep(j,m) {\n             if (s[i][j] == \'.\') {\n                 if ((i+j)&1) cout<<""W"";\n                 else cout<<""B"";\n             }\n             else cout<<s[i][j];\n         }\n         cout<<endl;\n     }\n\n\n     return 0 ;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1200
Someone give a strange birthday present to Ivan It is hedgehog connected undirected graph in which one vertex has degree at least 3 we will call it center and all other vertices has degree 1 Ivan thought that hedgehog is too boring and decided to make himself k multihedgehog Let us define k multihedgehog as follows 1 multihedgehog is hedgehog it has one vertex of degree at least 3 and some vertices of degree 1 For all k ge 2 k multihedgehog is k 1 multihedgehog in which the following changes has been made for each vertex v with degree 1 let u be its only neighbor remove vertex v create a new hedgehog with center at vertex w and connect vertices u and w with an edge New hedgehogs can differ from each other and the initial gift Thereby k multihedgehog is a tree Ivan made k multihedgehog but he is not sure that he did not make any mistakes That is why he asked you to check if his tree is indeed k multihedgehog ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\n\nvi graf[nax];\n\nvoid nope()\n{\n\tprintf(""No\\n"");\n\texit(0);\n}\n\nvoid tak()\n{\n\tprintf(""Yes\\n"");\n\texit(0);\n}\n\nint korz=-1;\n\nvi stos;\n\nvoid dfs1(int v, int oj)\n{\n\tstos.push_back(v);\n\tif ((int)stos.size()==2*k+1)\n\t\tkorz=stos[k];\n\tfor (int i : graf[v])\n\t\tif (i!=oj)\n\t\t\tdfs1(i, v);\n\tstos.pop_back();\n}\n\nvoid dfs2(int v, int oj, int odl)\n{\n\tif ((int)graf[v].size()==1 && odl!=k)\n\t\tnope();\n\tfor (int i : graf[v])\n\t\tif (i!=oj)\n\t\t\tdfs2(i, v, odl+1);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tif (n<=3)\n\t\tnope();\n\tint lis=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif ((int)graf[i].size()==1)\n\t\t\tlis=i;\n\tdfs1(lis, 0);\n\tif (korz==-1)\n\t\tnope();\n\tif ((int)graf[korz].size()<3)\n\t\tnope();\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif ((int)graf[i].size()==1 || i==korz)\n\t\t\tcontinue;\n\t\tif ((int)graf[i].size()<4)\n\t\t\tnope();\n\t}\n\tdfs2(korz, 0, 0);\n\ttak();\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1800
Mike and Ann are sitting in the classroom The lesson is boring so they decided to play an interesting game Fortunately all they need to play this game is a string s and a number k 0 le k s At the beginning of the game players are given a substring of s with left border l and right border r both equal to k i e initially l r k Then players start to make moves one by one according to the following rules A player chooses l prime and r prime so that l prime le l r prime ge r and s l prime r prime is lexicographically less than s l r Then the player changes l and r in this way l l prime r r prime Ann moves first The player that can t make a move loses Recall that a substring s l r l le r of a string s is a continuous segment of letters from s that starts at position l and ends at position r For example is a substring s 3 5 of and is not Mike and Ann were playing so enthusiastically that they did not notice the teacher approached them Surprisingly the teacher didn t scold them instead of that he said that he can figure out the winner of the game before it starts even if he knows only s and k Unfortunately Mike and Ann are not so keen in the game theory so they ask you to write a program that takes s and determines the winner for all possible k ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#ifndef LOCAL\n#pragma GCC optimize(""O3"")\n#endif\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\t\n\tstring s;\n\tcin >> s;\n\t\n\tchar minch = \'z\' + 1;\n\tfor (char ch : s) {\n\t\tif (ch > minch) {\n\t\t\tcout << ""Ann\\n"";\n\t\t} else {\n\t\t\tcout << ""Mike\\n"";\n\t\t\tminch = ch;\n\t\t}\n\t}\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1300
The guys lined up in a queue of n people starting with person number i 1 to ask Serafim the Owl about the meaning of life Unfortunately Kirill was very busy writing the legend for this problem so he arrived a little later and stood at the end of the line after the n th person Kirill is completely dissatisfied with this situation so he decided to bribe some people ahead of him For the i th person in the queue Kirill knows two values a i and b i If at the moment Kirill is standing at position i then he can choose any position j such that j i and exchange places with the person at position j In this case Kirill will have to pay him a j coins And for each k such that j k i Kirill will have to pay b k coins to the person at position k Kirill can perform this action any number of times Kirill is thrifty so he wants to spend as few coins as possible but he doesn t want to wait too long so Kirill believes he should be among the first m people in line Help Kirill determine the minimum number of coins he will have to spend in order to not wait too long ,"['#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst ll INF = LLONG_MAX, MOD = 1e9 + 7, P = 239;\nconst ld PI = 3.1415926535897938462643383279502, EPS = 1e-7;\n\ntemplate <typename T>\ninline ll sz(const T &a) {\n    return a.size();\n}\n\ntemplate <typename T, typename C>\nistream &operator >> (istream &in, pair<T, C> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <typename T, typename C>\nostream &operator << (ostream &out, pair<T, C> a) {\n    return out << a.first << \' \' << a.second;\n}\n\ntemplate <typename T>\nistream & operator >> (istream &in, vector<T> &a) {\n    for (auto &i : a) {\n        in >> i;\n    }\n    return in;\n}\n\ntemplate <typename T>\nostream &operator << (ostream &out, vector<T> a) {\n    for (auto i : a) {\n        out << i << \' \';\n    }\n    return out;\n}\n\ntemplate <typename T>\nvoid print(vector<T> a, string c = ""\\n"") {\n    for (T i : a) {\n        cout << i << c;\n    }\n}\n\nvoid solve() {\n    ll n, m;\n    cin >> n >> m;\n    vector<ll> a(n), b(n);\n    cin >> a >> b;\n    ll ans = 0;\n    for (int i = m; i < n; ++i) {\n        ans += min(a[i], b[i]);\n    }\n    ll sum2 = 0, ans2 = INF;\n    for (int i = m - 1; i >= 0; --i) {\n        ans2 = min(sum2 + a[i], ans2);\n        sum2 += b[i];\n    }\n    cout << ans + ans2;\n}\n\nsigned main() {\n#ifdef LOCAL\n    freopen(""inp.txt"", ""r"", stdin);\n    freopen(""out.txt"", ""w"", stdout);\n    freopen(""err.txt"", ""w"", stderr);\n\n    auto start_time = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int times = 1;\n    cin >> times;\n    while (times--)\n        solve(), cout << \'\\n\';\n\n#ifdef LOCAL\n    auto end_time = clock();\n    cerr << setprecision(3) << fixed << ""Execution time: "" << (end_time - start_time) * (int) 1e3 / CLOCKS_PER_SEC << "" ms\\n"";\n#endif\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Sasha was given a tree dagger with n vertices as a prize for winning yet another competition However upon returning home after celebrating his victory he noticed that some parts of the tree were missing Sasha remembers that he colored some of the edges of this tree He is certain that for any of the k pairs of vertices a 1 b 1 ldots a k b k he colored at least one edge on the simple path ddagger between vertices a i and b i Sasha does not remember how many edges he exactly colored so he asks you to tell him the minimum number of edges he could have colored to satisfy the above condition dagger A tree is an undirected connected graph without cycles ddagger A simple path is a path that passes through each vertex at most once ,"['#include<bits/stdc++.h>\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nvector<int>v[300005];\nint sy[45],cnt;\nint bu[25],bv[25],blc[25];\nint bz[300005][20];\nint dep[300005];\nint dfn[300005],siz[300005],tmp;\nint dp[1049576];\nvoid dfs(int x,int f)\n{\n\tdfn[x]=++tmp;\n\tsiz[x]=1;\n\tdep[x]=dep[f]+1;\n\tbz[x][0]=f;\n\tfor(int i=1;i<=19;i++)\n\t{\n\t\tbz[x][i]=bz[bz[x][i-1]][i-1];\t\n\t}\n\tfor(int i=0;i<v[x].size();i++)\n\t{\n\t\tif(v[x][i]==f)continue;\n\t\tdfs(v[x][i],x);\n\t\tsiz[x]+=siz[v[x][i]];\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(dep[bz[x][i]]>=dep[y])x=bz[x][i];\n\t}\n\tif(x==y)return x;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(bz[x][i]!=bz[y][i])\n\t\t{\n\t\t\tx=bz[x][i];\n\t\t\ty=bz[y][i];\n\t\t}\n\t}\n\treturn bz[x][0];\n} \nint findzx(int x,int k)\n{\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(k>=(1<<i))\n\t\t{\n\t\t\tk-=(1<<i);\n\t\t\tx=bz[x][i];\n\t\t}\n\t}\n\treturn x;\n}\nint pd(int x,int y,int z)\n{\n\tint ans=0;\n\tif(dfn[x]>=dfn[z]&&dfn[x]<=dfn[z]+siz[z]-1)ans++;\n\tif(dfn[y]>=dfn[z]&&dfn[y]<=dfn[z]+siz[z]-1)ans++;\n\tif(ans==1)return true;\n\treturn false;\n}\nsigned main()\n{\n\tint t,n,k,x,y;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;i++)v[i].clear();\n\t\tfor(int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tx=read();\n\t\t\ty=read();\n\t\t\tv[x].push_back(y);\n\t\t\tv[y].push_back(x);\n\t\t}\n\t\tcnt=0;\n\t\ttmp=0;\n\t\tdfs(1,0);\n\t\tk=read();\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tbu[i]=read();\n\t\t\tbv[i]=read();\n\t\t\tblc[i]=lca(bu[i],bv[i]);\t\n\t\t}\n\t\tfor(int i=1;i<=k;i++)\n\t\t{\n\t\t\tif(bu[i]!=blc[i])\n\t\t\t{\n\t\t\t\tint now=findzx(bu[i],dep[bu[i]]-dep[blc[i]]-1);\n\t\t\t\t++cnt;\n\t\t\t\tsy[cnt]=0;\n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pd(bu[j],bv[j],now))sy[cnt]|=(1<<(j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bv[i]!=blc[i])\n\t\t\t{\n\t\t\t\tint now=findzx(bv[i],dep[bv[i]]-dep[blc[i]]-1);\n\t\t\t\t++cnt;\n\t\t\t\tsy[cnt]=0; \n\t\t\t\tfor(int j=1;j<=k;j++)\n\t\t\t\t{\n\t\t\t\t\tif(pd(bu[j],bv[j],now))sy[cnt]|=(1<<(j-1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//printf(""%d\\n"",cnt);\n\t\t//for(int i=1;i<=cnt;i++)printf(""%d "",sy[i]);\n\t//\tprintf(""\\n"");\n\t\tfor(int i=0;i<(1<<k);i++)dp[i]=1000000000;\n\t\tdp[0]=0;\n\t\tfor(int i=0;i<(1<<k);i++)\n\t\t{\n\t\t\tif(dp[i]==1000000000)continue;\n\t\t\tfor(int j=1;j<=cnt;j++)\n\t\t\t{\n\t\t\t\tdp[i|sy[j]]=min(dp[i|sy[j]],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",dp[(1<<k)-1]);\n\t}\n}\n']","[1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0]",2300
You are given an array of integers The cost of a subsegment is the number of unordered pairs of distinct indices within the subsegment that contain equal elements Split the given array into non intersecting non empty subsegments so that the sum of their costs is minimum possible Each element should be present in exactly one subsegment ,"['#include <cstdio>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\nint a[100001];\nlong long d[22][100001];\nlong long tt;\nint b[100001];\nint L, R;\n\ninline void add(int x) {\n\ttt += b[x];\n\tb[x]++;\n}\n\ninline void sub(int x) {\n\tb[x]--;\n\ttt -= b[x];\n}\n\ninline void moveL(int tL) {\n\twhile (L < tL) sub(a[++L]);\n\twhile (L > tL) add(a[L--]);\n}\n\ninline void moveR(int tR) {\n\twhile (R < tR) add(a[++R]);\n\twhile (R > tR) sub(a[R--]);\n}\n\nint main() {\n\tqueue<tuple<int, int, int, int> > q;\n\tint i, j, k, n, m;\n\tscanf(""%d%d"", &n, &m);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\td[0][i] = 1e18;\n\t}\n\tfor (i = 1; i <= m; i++) {\n\t\tq.emplace(1, n, 0, n - 1);\n\t\twhile (!q.empty()) {\n\t\t\tint S, E, L, R, M;\n\t\t\ttie(S, E, L, R) = q.front();\n\t\t\tq.pop();\n\t\t\tif (S > E) continue;\n\t\t\tM = S + E >> 1;\n\t\t\tmoveR(M);\n\t\t\td[i][M] = 1e18;\n\t\t\tfor (j = k = L; j <= R && j < M; j++) {\n\t\t\t\tmoveL(j);\n\t\t\t\tlong long t = d[i - 1][j] + tt;\n\t\t\t\tif (t < d[i][M]) {\n\t\t\t\t\td[i][M] = t;\n\t\t\t\t\tk = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq.emplace(S, M - 1, L, k);\n\t\t\tq.emplace(M + 1, E, k, R);\n\t\t}\n\t}\n\tprintf(""%lld\\n"", d[m][n]);\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
You are given three integers n d and k Your task is to construct an undirected tree on n vertices with diameter d and degree of each vertex at most k or say that it is impossible An undirected tree is a connected undirected graph with n 1 edges Diameter of a tree is the maximum length of a simple path a path in which each vertex appears at most once between all pairs of vertices of this tree Degree of a vertex is the number of edges incident to this vertex i e for a vertex u it is the number of edges u v that belong to the tree where v is any other vertex of a tree ,"['#include ""bits/stdc++.h""\n#define MAXN 400009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<""----------------""<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(__typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\n#define debug(x)  cerr<< #x <<"" = ""<< x<<endl;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nint deg[MAXN];\nvoid fail(){\n\tputs(""NO"");\n\texit(0);\n}\nint main(){\n    //~ freopen(""file.in"", ""r"", stdin);\n    int n,d,k;\n    scanf(""%d%d%d"",&n,&d,&k);\n    if(n-1<d)\n\t\tfail();\n\tvector<PII>ans;\n\tqueue<PII>q;\n\tfor(int i=1;i<=d;i++){\n\t\tans.pb(mp(i,i+1));\n\t\tdeg[i]++;\n\t\tdeg[i+1]++;\n\t}\n\tfor(int i=1;i<=d+1;i++){\n\t\tint depth=min(i,d+2-i)-1;\n\t\tif(depth)\n\t\t\tq.push(mp(depth,i));\n\t}\n\tint node=d+1;\n\twhile(!q.empty()){\n\t\tPII nd=q.front();q.pop();\n\t\t//~ cout<<nd.ff<<"" ""<<nd.ss<<"" ""<<deg[nd.ss]<<"" ""<<k<<"" ""<<ans.size()<<endl;\n\t\tif((int)ans.size()<n-1){\n\t\t\twhile((int)ans.size()<n-1 and deg[nd.ss]<k){\n\t\t\t\t++node;\n\t\t\t\tdeg[nd.ss]++;deg[node]++;\n\t\t\t\t//~ cout<<nd.ss<<"" ""<<node<<endl;\n\t\t\t\tans.pb(mp(nd.ss,node));\n\t\t\t\tif(nd.ff>1)\n\t\t\t\t\tq.push(mp(nd.ff-1,node));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tbreak;\n\t}\n\tif((int)ans.size()<n-1)\n\t\tfail();\n\tfor(int i=1;i<=n;i++)\n\t\tif(deg[i]>k)\n\t\t\tfail();\n\t\t\n\tputs(""YES"");\n\ttr(it,ans)\n\t\tprintf(""%d %d\\n"",it->ff,it->ss);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2100
Today at the lesson of mathematics Petya learns about the digital root The digital root of a non negative integer is the single digit value obtained by an iterative process of summing digits on each iteration using the result from the previous iteration to compute a digit sum The process continues until a single digit number is reached Let s denote the digital root of x as S x Then S 5 5 S 38 S 3 8 11 S 1 1 2 2 S 10 S 1 0 1 1 As a homework Petya got n tasks of the form find k th positive number whose digital root is x Petya has already solved all the problems but he doesn t know if it s right Your task is to solve all n tasks from Petya s homework ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        ll k, x;\n        cin >> k >> x;\n        cout << 9 * (k - 1) + x << ""\\n"";\n    }\n    return 0;\n}\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1000
Ntarsis has received two integers n and k for his birthday He wonders how many fibonacci like sequences of length k can be formed with of the sequence A sequence of integers is considered fibonacci like if f i f i 1 f i 2 for all i 2 where f i denotes the i th element in the sequence Note that f 1 and f 2 can be arbitrary For example sequences such as 4 5 9 14 and 0 1 1 are considered fibonacci like sequences while 0 0 0 1 1 1 2 1 3 and 1 1 2 are not the first two do not always satisfy f i f i 1 f i 2 the latter does not satisfy that the elements are non negative Impress Ntarsis by helping him with this task ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint T;\n\tfor (cin >> T; T; T--) {\n\t\tint n, k; cin >> n >> k;\n\t\tint x = 1, y = 1;\n\t\tbool ok = 1;\n\t\tfor (int i = 0; i < k - 3; i++) {\n\t\t\tint z = x + y;\n\t\t\tx = y, y = z;\n\t\t\tif (x > n && y > n) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!ok) cout << ""0\\n"";\n\t\telse {\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i * x <= n; i++)\n\t\t\t\tif ((n - i * x) % y == 0 && i <= (n - i * x) / y)\n\t\t\t\t\tans++;\n\t\t\tcout << ans << \'\\n\';\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",1200
A tree is a connected undirected graph consisting of vertices and edges Vertices are numbered through Limak is a little polar bear and Radewoosh is his evil enemy Limak once had a tree but Radewoosh stolen it Bear is very sad now because he doesn t remember much about the tree he can tell you only three values and The tree had exactly vertices The tree had diameter In other words was the biggest distance between two vertices Limak also remembers that he once rooted the tree in vertex and after that its height was In other words was the biggest distance between vertex and some other vertex The distance between two vertices of the tree is the number of edges on the simple path between them Help Limak to restore his tree Check whether there exists a tree satisfying the given conditions Find any such tree and print its edges in any order It s also possible that Limak made a mistake and there is no suitable tree in this case print ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <vector>\n#define all(x) x.begin() , x.end()\n#define fi first\n#define se second\n#define pb push_back\n#define umax( x , y ) x = max( x , (y) )\n#define umin( x , y ) x = min( x , (y) )\n#define For( i , a ) for(int i=1;i<=a;i++)\n#define ort (((b+s) < 0 )? (b+s)/2-1:(b+s)/2)\n#define y2 asrwjaelkf\n#define y1 asseopirwjaelkf\n\nusing namespace std;\n\ninline int read() {\n\tint res = 0 ;int neg ;\n\twhile(true){char ch = getchar();if(ch>=\'0\' && ch<=\'9\' || ch==\'-\'){if(ch==\'-\') neg = -1;else neg = 1 , res = ch-\'0\';break;} }\n\twhile(true){char ch = getchar();if(ch>=\'0\' && ch<=\'9\') res*=10 , res+=ch-\'0\';else break;}\n\treturn res*neg;\n}\n\ntypedef long long Lint;\ntypedef double db;\ntypedef pair<int,int> ii;\ntypedef pair<int,ii> iii;\n\nconst int maxn = 1000020;\nconst int MOd = 1e9+7;\n\nint a, d, h;\nint ar[maxn], t[maxn];\n\nint main() {\n\t\n\tscanf(""%d %d %d"",&a,&d,&h);\n\t\n\tif( a == 2 && d == 1 && h == 1 ) {\n\t\tprintf(""1 2\\n"");\n\t\treturn 0;\n\t}\n\t\n\tif( d > h + h ) {\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tif( d < h ) {\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tint bag = 1;\n\tif( d == h ) {\n\t\tif( d < 2 ) {\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn 0;\n\t\t}\n\t\tbag = 2;\n\t}\n\tint n = 1;\n\tint back = 1;\n\tfor(int i=1;i<=h;i++) {\n\t\tprintf(""%d %d\\n"",back,++n);\n\t\tback = n;\n\t}\n\tback = 1;\n\tfor(int i=1;i<=d-h;i++) {\n\t\tprintf(""%d %d\\n"",back,++n);\n\t\tback = n;\n\t}\n\t\n\twhile( n < a ) {\n\t\tprintf(""%d %d\\n"",bag,++n);\n\t}\n\t\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1600
As you know the girl Dora is always looking for something This time she was given a permutation and she wants to find such a subsegment of it that none of the elements at its ends is either the minimum or the maximum of the entire subsegment More formally you are asked to find the numbers l and r 1 leq l leq r leq n such that a l neq min a l a l 1 ldots a r a l neq max a l a l 1 ldots a r and a r neq min a l a l 1 ldots a r a r neq max a l a l 1 ldots a r A permutation of length n is an array consisting of n distinct integers from 1 to n in any order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 occurs twice in the array and 1 3 4 is also not a permutation n 3 but 4 is present in the array Help Dora find such a subsegment or tell her that such a subsegment does not exist ,"['#include<bits/stdC++.h>\nusing namespace std;\nint T,n,a[200003];\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>a[i];\n\t\tint l=0,r=n-1,L=1,R=n;\n\t\tfor(;l<=r;){\n\t\t\tif(a[l]==L){l++;L++;continue;}\n\t\t\tif(a[l]==R){l++;R--;continue;}\n\t\t\tif(a[r]==L){r--;L++;continue;}\n\t\t\tif(a[r]==R){r--;R--;continue;}\n\t\t\tcout<<l+1<<\' \'<<r+1<<\'\\n\';\n\t\t\tbreak;\n\t\t}if(l>r)cout<<""-1\\n"";\n\t}\n}\n']","[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You have array Segment is good if for all Let s define is the length of the segment Segment is longer than segment if Your task is to find a good segment of the maximum length in array Note that a segment of length or is always good ,"['#include <stdio.h>\n#include <string.h>\n\nint main(){\n\n    int test;\n    int ans=0,now=0;\n    long long prev1,prev2,temp;\n\n    for( scanf(""%d"",&test) ; test-- ; ){\n        if( now==0 ){\n            scanf(""%I64d"",&prev2);\n            now=1;\n        }\n        else if( now==1 ){\n            scanf(""%I64d"",&prev1);\n            now=2;\n        }\n        else{\n            scanf(""%I64d"",&temp);\n            if( prev1+prev2!=temp ){\n                now=2;  \n            }\n            else{\n                now++;\n            }\n            prev2=prev1;\n            prev1=temp; \n        }\n        \n        if( now>ans ) ans=now;\n    }\n    printf(""%d\\n"",ans);\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Even if it s a really easy question she won t be able to answer it Cirno s perfect bitmasks classroom has just started Cirno gave her students a positive integer x As an assignment her students need to find the integer y which satisfies the following two conditions x texttt and y 0 x texttt xor y 0Where texttt and is the bitwise AND operation and texttt xor is the bitwise XOR operation Among the students was Mystia who was truly baffled by all these new operators Please help her ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconstexpr int inf = 1e18;\nconstexpr int maxn = 2e5 + 5;\nconstexpr int mod = 998244353;\n\ninline void solve()\n{\n  int x; cin >> x;\n  if (__builtin_popcount(x) > 1)\n    cout << (x & -x) << \'\\n\';\n  else if (x == 1)\n    cout << ""3\\n"";\n  else\n    cout << (x ^ 1) << \'\\n\';\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T; cin >> T;\n  while (T --)\n  solve();\n  return 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800
Polycarp was given a row of tiles Each tile contains one lowercase letter of the Latin alphabet The entire sequence of tiles forms the string s In other words you are given a string s consisting of lowercase Latin letters Initially Polycarp is on the tile of the row and wants to get to the tile by jumping on the tiles Jumping from i th tile to j th tile has a cost equal to index s i index s j where index c is the index of the letter c in the alphabet for example index 1 index 2 index 26 Polycarp wants to get to the n th tile for the minimum total cost but at the same time make number of jumps In other words among all possible ways to get to the last tile for the total cost he will choose the one with the number of jumps Polycarp can visit each tile Polycarp asks you to help print the sequence of indices of string s on which he should jump ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate <typename T> using ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>; \n\n#define endl \'\\n\'\n#define pb push_back\n#define ub upper_bound\n#define lb lower_bound\n#define fi first\n#define se second\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\n#define pii pair<int,int>\n#define sz(x) ((ll)x.size())\n#define fr(a,b,c) for(int a=b; a<=c; a++)\n#define frev(a,b,c) for(int a=c; a>=b; a--)\n#define rep(a,b,c) for(int a=b; a<c; a++)\n#define trav(a,x) for(auto &a:x)\n#define all(con) con.begin(),con.end()\n#define done(x) {cout << x << endl;return;}\n#define mini(x,y) x = min(x,y)\n#define maxi(x,y) x = max(x,y)\nconst ll infl = 0x3f3f3f3f3f3f3f3fLL;\nconst int infi = 0x3f3f3f3f;\nmt19937_64 mt(chrono::steady_clock::now().time_since_epoch().count());\n//const int mod = 998244353;\nconst int mod = 1e9 + 7;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int>> vvi;\ntypedef vector<pair<int, int>> vpii;\ntypedef map<int, int> mii;\ntypedef set<int> si;\ntypedef set<pair<int,int>> spii;\ntypedef queue<int> qi;\nuniform_int_distribution<int> rng(0, 1e9);\n\n// DEBUG FUNCTIONS START\nvoid __print(int x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\ntemplate<typename T, typename V> void __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << \',\'; __print(x.second); cerr << \'}\';}\ntemplate<typename T> void __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "","" : """"), __print(i); cerr << ""}"";}\nvoid deb() {cerr << ""\\n"";}\ntemplate <typename T, typename... V> void deb(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; deb(v...);}\n// DEBUG FUNCTIONS END\n\n\nconst int N = 2e5 + 5;\n\n\nvoid solve()\n{\n    \n    string s;\n    cin >> s;\n\n    int n = sz(s);\n    vvi g(26);\n\n    rep(i,0,n)\n    {\n        g[s[i] - \'a\'].pb(i);\n    }\n\n\n    cout << abs(s[0] - s.back()) << \' \';\n\n    vi res;\n\n    if(s[0] < s.back())\n    {\n        fr(i, s[0] - \'a\', s.back() - \'a\')\n        {\n            trav(x, g[i])\n            {\n                res.pb(x);\n            }\n        }\n    }\n    else\n    {\n        frev(i, s.back() - \'a\', s[0] - \'a\')\n        {\n            trav(x, g[i])\n            {\n                res.pb(x);\n            }\n        }\n    }\n    \n    \n    cout << sz(res) << endl;\n\n    trav(x, res)\n    {\n        cout << x + 1 << \' \';\n    }\n\n    cout << endl;\n\n\n}\n\n\n\n\nsigned main(){\n    \n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cout << fixed << setprecision(15);\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n    return 0;\n}\n\nint powm(int a, int b){\n    int res = 1;\n    while (b) {\n        if (b & 1)\n            res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1100
Having watched the commercial virus Hexadecimal also wanted to get a Domino Carpet and wanted badly to be photographed in front of it But of course a virus will never consent to buying a licensed Carpet So she ordered a truck of dominoes and decided to make such a Carpet herself The original Domino Carpet is a field of squares in size Each square is half of a domino and can be rotated either vertically or horizontally independently from its neighbors Vertically rotated domino halves look like this And horizontally rotated halves look like this Notice that some halves looks the same in both rotations but other halves differ Dominoes bought by Hexadecimal are represented by uncuttable chips in size which can be laid either vertically or horizontally If the chip is laid vertically then both of it s halves should be laid vertically orientated if the chip is laid horizontally then both of it s halves should be laid horizontally The samples of valid and invalid dominoes laid vertically and horizontally are Virus Hexadecimal assembles her own Domino Carpet so that the following conditions are satisfied each carpet square is covered by a domino chip i e there are no empty squares all domino chips lie entirely within the carpet and don t overlap with each other if there is a horizontal domino chip with its left half in column then there are no horizontal domino chips with their left halves in columns or Before starting to assemble her own Domino Carpet the virus wants to know the number of ways to achieve the intended purpose modulo You can assume that the virus has an infinitely large number of dominoes of each type ,"['#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define y0 y3487465\n#define y1 y8687969\n\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) {\n    re x > 0 ? x : -x;\n}\n\nconst string dom[2][7] = {\n    {""........."",""....O...."",""O.......O"",""O...O...O"",""O.O...O.O"",""O.O.O.O.O"",""OOO...OOO""},\n    {""........."",""....O...."",""..O...O.."",""..O.O.O.."",""O.O...O.O"",""O.O.O.O.O"",""O.OO.OO.O""}};\n\nconst int mod = 1000000007;\n\nint n;\nint m;\nchar w[1002][1002];\nint g[250][250];\nint can[250], can2[250];\nint cnt[251], res[251];\n\nint get (int i, int j) {\n    string s = """";\n    for (int p = 0; p < 3; p++)\n        for (int q = 0; q < 3; q++)\n            s += w[i + p][j + q];\n    int res = 0;\n    for (int p = 0; p < 2; p++)\n        for (int q = 0; q < 7; q++)\n            if (s == dom[p][q])\n                res |= (p + 1);\n    re res;\n}\n\nint main() {\n    scanf (""%d%d"", &n, &m); \n    gets (w[0]);\n    for (int i = 0; i < 4 * n + 1; i++) gets (w[i]);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            g[i][j] = get (4 * i + 1, 4 * j + 1);\n        for (int j = 0; j < m; j++) {\n            can[j] = int (n % 2 == 0);\n            for (int i = 0; i < n; i++) can[j] &= int ((g[i][j] & 2) != 0);\n        }\n    for (int j = 0; j + 1 < m; j++) {\n        memset (cnt, 0, sizeof (cnt));\n        cnt[0] = 1;\n        for (int i = 0; i < n; i++) {\n            if (g[i][j] & g[i][j + 1] & 1)\n                cnt[i + 1] = (cnt[i + 1] + cnt[i]) % mod;\n            if (i + 1 < n && int (g[i][j] & g[i + 1][j] & g[i][j + 1] & g[i + 1][j + 1] & 2))   \n                cnt[i + 2] = (cnt[i + 2] + cnt[i]) % mod;\n        }\n        can2[j] = (cnt[n] - can[j] * can[j + 1] + mod) % mod;\n    }\n    memset (res, 0, sizeof (res));\n    res[0] = 1;\n    for (int j = 0; j < m; j++) {\n        if (can[j]) res[j + 1] = (res[j + 1] + res[j]) % mod;\n        if (j + 1 < m) res[j + 2] = (res[j + 2] + (ll)res[j] * can2[j]) % mod;\n    }\n    printf (""%d\\n"", res[m]);\n    return 0;\n}']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
For her birthday Alice received an interesting gift from her friends The Light Square The Light Square game is played on an N times N lightbulbs square board with a magical lightbulb bar of size N times 1 that has magical properties At the start of the game some lights on the square board and magical bar are turned on The goal of the game is to transform the starting light square board pattern into some other pattern using the magical bar without rotating the square board The magical bar works as follows It can be placed on any row or column The orientation of the magical lightbulb must be left to right or top to bottom for it to keep its magical properties The entire bar needs to be fully placed on a board The lights of the magical bar never change If the light on the magical bar is the same as the light of the square it is placed on it will switch the light on the square board off otherwise it will switch the light on The magical bar can be used an infinite number of times Alice has a hard time transforming her square board into the pattern Bob gave her Can you help her transform the board or let her know it is impossible If there are multiple solutions print any ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n#define x first\n#define y second\n\nconst int N = 2005;\n\nchar str[N];\nint n, a[N][N], b[N], p[4*N], c[4*N], cnt;\n\nint f(int x){\n    if(x == p[x]) return x;\n    return p[x] = f(p[x]);\n}\n\nint main(){ ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> (str+1);\n        for(int j = 1; j <= n; j++) a[i][j] = str[j]&1;\n    }\n    for(int i = 1; i <= n; i++){\n        cin >> (str+1);\n        for(int j = 1; j <= n; j++) a[i][j] ^= str[j]&1;\n    }\n    cin >> (str+1);\n    for(int i = 1; i <= n; i++) b[i] = str[i]&1;\n    iota(p, p + 4*n+3, 0);\n    int T = 4*n+1, F = 4*n+2;\n    for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++){\n        switch(2*b[i] + b[j]){\n        case 0:\n            if(a[i][j]){ cout << ""-1\\n""; return 0; }\n            break;\n        case 1:\n            p[f(i)] = f(a[i][j] ? T : F);\n            break;\n        case 2:\n            p[f(j + n)] = f(a[i][j] ? T : F);\n            break;\n        case 3:\n            if(a[i][j]){\n                p[f(i)] = f(j + 3*n);\n                p[f(i + 2*n)] = f(j + n);\n            }\n            else{\n                p[f(i)] = f(j + n);\n                p[f(i + 2*n)] = f(j + 3*n);\n            }\n            break;\n        }\n    }\n    c[f(T)] = 1;\n    c[f(F)] = -1;\n    for(int i = 1; i <= 2*n; i++){\n        if(f(i) == f(i + 2*n)){ cout << ""-1\\n""; return 0; }\n        if(c[f(i)] && c[f(i)] == c[f(i + 2*n)]){ cout << ""-1\\n""; return 0; }\n        if(!c[f(i)] && !c[f(i + 2*n)]) c[f(i)] = -1;\n        if(!c[f(i)] && c[f(i + 2*n)]) c[f(i)] = -c[f(i + 2*n)];\n        if(!c[f(i + 2*n)] && c[f(i)]) c[f(i + 2*n)] = -c[f(i)];\n        if(c[f(i)] > 0) cnt++;\n    }\n    cout << cnt << \'\\n\';\n    for(int i = 1; i <= n; i++) if(c[f(i)] > 0) cout << ""row "" << i-1 << \'\\n\';\n    for(int i = 1; i <= n; i++) if(c[f(i + n)] > 0) cout << ""col "" << i-1 << \'\\n\';\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2100
You are given a tree with n nodes You have to write non negative integers on its edges so that the following condition would be satisfied For every two nodes i j look at the path between them and count the sum of numbers on the edges of this path Write all obtained sums on the blackboard Then every integer from 1 to lfloor frac 2n 2 9 rfloor has to be written on the blackboard at least once It is guaranteed that such an arrangement exists ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,x[SZ],y[SZ],fa[SZ],fe[SZ]; Edgc\nint sz[SZ],mi=2e9,u;\nvoid dd(int w,int f=0)\n{\n\tsz[w]=1; fa[w]=f;\n\tint mx=0;\n\tfor esb(w,e,b) if(b!=f)\n\t{\n\t\tdd(b,w); sz[w]+=sz[b];\n\t\tmx=max(mx,sz[b]);\n\t}\n\tmx=max(mx,n-sz[w]);\n\tif(mx<mi) mi=mx,u=w;\n}\nvoid go(int x,int l,ll s)\n{\n\tfe[x]=l*(ll)s; l=1;\n\tfor esb(x,e,b) if(b!=fa[x])\n\t\tgo(b,l,s),l+=sz[b];\n}\nint main()\n{\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<n;++i)\n\t\tscanf(""%d%d"",x+i,y+i),\n\t\tadde(x[i],y[i],i);\n\tdd(1);\n\tint U=u; dd(u); u=U;\n\tvector<pii> s;\n\tfor esb(u,e,b)\n\t\ts.pb(pii(sz[b],b));\n\tsort(s.begin(),s.end());\n\tll mx=-1; int I,l,r;\n\t{\n\tint L=0,R=n-1;\n\tfor(int i=0;i<=s.size();++i)\n\t{\n\t\tif(i) L+=s[i-1].fi,R-=s[i-1].fi;\n\t\tll u=(L+1)*ll(R+1);\n\t\tif(u>mx) mx=u,I=i,l=L,r=R;\n\t}\n\t}\n\tint cl=1;\n\tfor(int i=0;i<I;++i)\n\t{\n\t\tint t=s[i].fi;\n\t\tgo(s[i].se,cl,1);\n\t\tcl+=t;\n\t}\n\tcl=1;\n\tfor(int i=I;i<s.size();++i)\n\t{\n\t\tint t=s[i].fi;\n\t\tgo(s[i].se,cl,l+1);\n\t\tcl+=t;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(i!=u)\n\t\t\tprintf(""%d %d %d\\n"",i,fa[i],fe[i]);\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2700
You are given an integer x represented as a product of n its divisors p 1 cdot p 2 cdot ldots cdot p n Let S be the set of positive integer divisors of x including 1 and x itself We call a set of integers D if and only if there is no pair a in D b in D such that a ne b and a divides b Find a subset of S with maximum possible size Since the answer can be large print the size of the subset modulo 998244353 ,"['#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <limits>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nnamespace IO {\n    const int BUFFER_SIZE = 1 << 15;\n\n    char input_buffer[BUFFER_SIZE];\n    int input_pos = 0, input_len = 0;\n\n    void _update_input_buffer() {\n        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);\n        input_pos = 0;\n\n        if (input_len == 0)\n            input_buffer[0] = EOF;\n    }\n\n    inline char next_char(bool advance = true) {\n        if (input_pos >= input_len)\n            _update_input_buffer();\n\n        return input_buffer[advance ? input_pos++ : input_pos];\n    }\n\n    template<typename T>\n    inline void read_int(T &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == \'-\')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - \'0\');\n        } while (isdigit(next_char(false)));\n\n        if (negative)\n            number = -number;\n    }\n\n    template<typename T, typename... Args>\n    inline void read_int(T &number, Args &... args) {\n        read_int(number);\n        read_int(args...);\n    }\n}\n\nconst int MOD = 998244353;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(""divl %4\\n""\n            : ""=a"" (quot), ""=d"" (rem)\n            : ""d"" (x_high), ""a"" (x_low), ""r"" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\nnamespace NTT {\n    vector<mod_int> roots = {0, 1};\n    vector<int> bit_reverse;\n    int max_size = -1;\n    mod_int root;\n\n    bool is_power_of_two(int n) {\n        return (n & (n - 1)) == 0;\n    }\n\n    int round_up_power_two(int n) {\n        while (n & (n - 1))\n            n = (n | (n - 1)) + 1;\n\n        return max(n, 1);\n    }\n\n    // Given n (a power of two), finds k such that n == 1 << k.\n    int get_length(int n) {\n        assert(is_power_of_two(n));\n        return __builtin_ctz(n);\n    }\n\n    // Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n    // This makes even-odd div-conquer much easier.\n    void bit_reorder(int n, vector<mod_int> &values) {\n        if ((int) bit_reverse.size() != n) {\n            bit_reverse.assign(n, 0);\n            int length = get_length(n);\n\n            for (int i = 0; i < n; i++)\n                bit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n        }\n\n        for (int i = 0; i < n; i++)\n            if (i < bit_reverse[i])\n                swap(values[i], values[bit_reverse[i]]);\n    }\n\n    void find_root() {\n        max_size = 1 << __builtin_ctz(MOD - 1);\n        root = 2;\n\n        // Find a max_size-th primitive root of MOD.\n        while (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n            root++;\n    }\n\n    void prepare_roots(int n) {\n        if (max_size < 0)\n            find_root();\n\n        assert(n <= max_size);\n\n        if ((int) roots.size() >= n)\n            return;\n\n        int length = get_length(roots.size());\n        roots.resize(n);\n\n        // The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n        // the first half of the n-th primitive roots of MOD.\n        while (1 << length < n) {\n            // z is a 2^(length + 1)-th primitive root of MOD.\n            mod_int z = root.pow(max_size >> (length + 1));\n\n            for (int i = 1 << (length - 1); i < 1 << length; i++) {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = roots[i] * z;\n            }\n\n            length++;\n        }\n    }\n\n    void fft_iterative(int N, vector<mod_int> &values) {\n        assert(is_power_of_two(N));\n        prepare_roots(N);\n        bit_reorder(N, values);\n\n        for (int n = 1; n < N; n *= 2)\n            for (int start = 0; start < N; start += 2 * n)\n                for (int i = 0; i < n; i++) {\n                    mod_int even = values[start + i];\n                    mod_int odd = values[start + n + i] * roots[n + i];\n                    values[start + n + i] = even - odd;\n                    values[start + i] = even + odd;\n                }\n    }\n\n    const int FFT_CUTOFF = 150;\n\n    vector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n        int n = left.size();\n        int m = right.size();\n\n        // Brute force when either n or m is small enough.\n        if (min(n, m) < FFT_CUTOFF) {\n            const uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n            vector<uint64_t> result(n + m - 1, 0);\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++) {\n                    result[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\n                    if (result[i + j] > ULL_BOUND)\n                        result[i + j] %= MOD;\n                }\n\n            for (uint64_t &x : result)\n                if (x >= MOD)\n                    x %= MOD;\n\n            return vector<mod_int>(result.begin(), result.end());\n        }\n\n        int N = round_up_power_two(n + m - 1);\n        left.resize(N);\n        right.resize(N);\n\n        bool equal = left == right;\n        fft_iterative(N, left);\n\n        if (equal)\n            right = left;\n        else\n            fft_iterative(N, right);\n\n        mod_int inv_N = mod_int(N).inv();\n\n        for (int i = 0; i < N; i++)\n            left[i] *= right[i] * inv_N;\n\n        reverse(left.begin() + 1, left.end());\n        fft_iterative(N, left);\n        left.resize(n + m - 1);\n        return left;\n    }\n\n    vector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n        assert(exponent >= 0);\n        vector<mod_int> result = {1};\n\n        if (exponent == 0)\n            return result;\n\n        for (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n            result = mod_multiply(result, result);\n\n            if (exponent >> k & 1)\n                result = mod_multiply(result, v);\n        }\n\n        return result;\n    }\n\n    vector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n        if (polynomials.empty())\n            return {1};\n\n        struct compare_size {\n            bool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n                return x.size() > y.size();\n            }\n        };\n\n        priority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\n        while (pq.size() > 1) {\n            vector<mod_int> a = pq.top(); pq.pop();\n            vector<mod_int> b = pq.top(); pq.pop();\n            pq.push(mod_multiply(a, b));\n        }\n\n        return pq.top();\n    }\n}\n\n\nint main() {\n    int N;\n    IO::read_int(N);\n    vector<int> P(N);\n\n    for (int &p : P)\n        IO::read_int(p);\n\n    sort(P.begin(), P.end());\n    vector<int> freq(N + 1, 0);\n\n    for (int i = 0, j = 0; i < N; i = j) {\n        while (j < N && P[i] == P[j])\n            j++;\n\n        freq[j - i]++;\n    }\n\n    vector<vector<mod_int>> polynomials;\n\n    for (int e = 1; e <= N; e++)\n        if (freq[e] > 0) {\n            vector<mod_int> poly(e + 1, 1);\n            polynomials.push_back(NTT::mod_power(poly, freq[e]));\n        }\n\n    vector<mod_int> product = NTT::mod_multiply_all(polynomials);\n    cout << product[N / 2] << \'\\n\';\n}\n   ']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2600
One day Vitaly was going home late at night and wondering how many people aren t sleeping at that moment To estimate Vitaly decided to look which windows are lit in the house he was passing by at that moment Vitaly sees a building of floors and windows on each floor On each floor there are flats numbered from to and two consecutive windows correspond to each flat If we number the windows from to from left to right then the th flat of the th floor has windows and in the corresponding row of windows as usual floors are enumerated from the bottom Vitaly thinks that people in the flat aren t sleeping at that moment if of the windows corresponding to this flat has lights on Given the information about the windows of the given house your task is to calculate the number of flats where according to Vitaly people aren t sleeping ,"['#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, const char * argv[]) {\n    std::ios::sync_with_stdio(false);\n\n    int n, m, a, b, res = 0;\n    cin >> n >> m;\n    for(int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> a >> b;\n            if (a + b > 0) {\n                ++res;\n            }\n        }\n    }\n    \n    cout << res;\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
children are standing in a circle and playing the counting out game Children are numbered clockwise from to In the beginning the first child is considered the leader The game is played in steps In the th step the leader counts out people in clockwise order starting from the next person The last one to be pointed at by the leader is eliminated and the next player after him becomes the new leader For example if there are children with numbers currently in the circle the leader is child and then counting out rhyme ends on child who is eliminated Child becomes the leader You have to write a program which prints the number of the child to be eliminated on every step ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << "" "";\n    }\n    cerr << ""\\n"";\n}\n\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tvector<int> vv;\n\tfor (int i = 0; i < n; ++i)\n\t\tvv.push_back(i + 1);\n\tfor (int i = 0; i < k; ++i) {\n\t\tint a;\n\t\tcin >> a;\n\t\ta %= vv.size();\n\t\tfor (int j = 0; j < a; ++j)\n\t\t\trotate(vv.begin(), vv.begin() + 1, vv.end());\n\t\tcout << vv[0] << "" "";\n\t\tvv.erase(vv.begin());\n\t}\n\tcout << ""\\n"";\n\treturn 0;\n}\n\n\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Monocarp and Bicarp live in Berland where every bus ticket consists of n digits n is an even number During the evening walk Monocarp and Bicarp found a ticket where some of the digits have been erased Monocarp and Bicarp have decided to play a game with this ticket Monocarp hates happy tickets while Bicarp collects them A ticket is considered happy if the sum of the first frac n 2 digits of this ticket is equal to the sum of the last frac n 2 digits Monocarp and Bicarp take turns and Monocarp performs the first of them During each turn the current player must replace any erased digit with any digit from 0 to 9 The game ends when there are no erased digits in the ticket If the ticket is happy after all erased digits are replaced with decimal digits then Bicarp wins Otherwise Monocarp wins You have to determine who will win if both players play optimally ,"['#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nint n,s1,c1,s2,c2;\nchar s[1000005];\nint main(){\n\tscanf(""%d%s"",&n,s+1);\n\tFor(i,1,n/2)\n\t\tif (s[i]==\'?\') c1++;\n\t\telse s1+=s[i]-\'0\';\n\tFor(i,n/2+1,n)\n\t\tif (s[i]==\'?\') c2++;\n\t\telse s2+=s[i]-\'0\';\n\ts1+=c1/2*9; c1%=2;\n\ts2+=c2/2*9; c2%=2;\n\tputs(s1==s2?""Bicarp"":""Monocarp"");\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
A boy called Smilo is playing a new game In the game there are n hordes of monsters and the i th horde contains a i monsters The goal of the game is to destroy all the monsters To do this you have two types of attacks and a combo counter x initially set to 0 The first type you choose a number i from 1 to n such that there is at least one monster left in the horde with the number i Then you kill one monster from horde number i and the combo counter x increases by 1 The second type you choose a number i from 1 to n such that there are at least x monsters left in the horde with number i Then you use an ultimate attack and kill x monsters from the horde with number i After that x is reset to zero Your task is to destroy all of the monsters meaning that there should be no monsters left in any of the hordes Smilo wants to win as quickly as possible so he wants to the minimum number of attacks required to win the game ,"['#include<bits/stdc++.h>\n#define int long long\n#define N 200005\nusing namespace std;\nint read(){\n\tint w=0,h=1;char ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\'){if(ch==\'-\')h=-h;ch=getchar();}\n\twhile(ch>=\'0\'&&ch<=\'9\'){w=w*10+ch-\'0\';ch=getchar();}\n\treturn w*h;\n}\nint n,sum,ans,a[N];\nvoid solve(){\n\tn=read();sum=ans=0;\n\tfor(int i=1;i<=n;i++)sum+=(a[i]=read());\n\tsort(a+1,a+n+1);sum>>=1;\n\tfor(int i=n;i>=1;i--)\n\t\tif(sum>=a[i])sum-=a[i],a[i]=0,ans++;\n\t\telse if(sum)a[i]-=sum,sum=0,ans++;\n\tfor(int i=1;i<=n;i++)ans+=a[i];\n\tprintf(""%lld\\n"",ans);\n}\nsigned main(){\n\tint T=read();while(T--)solve();\n\treturn 0;\n}\n\n']","[1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0]",1500
Given an array a of n integers and an integer k 2 le k le n where each element of the array is denoted by a i 0 le i n Perform the operation z given below on a and print the value of z a k modulo 10 9 7 function z array a integer k if length a k return 0 else b empty array ans 0 for i 0 length a k temp a i for j i i k 1 temp max temp a j append temp to the end of b ans ans temp return ans z b k ,"[""/**\n *    author:  tourist\n *    created: 02.09.2018 17:54:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (int) ((long long) a * b % md);\n}\n\ninline int power(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nconst int INV2 = inv(2);\n\ninline int sum_positive(int start, int finish, int step) {\n  if (start <= 0) {\n    return 0;\n  }\n  if (finish < 0) {\n    finish += abs(finish) / step * step;\n  }\n  while (finish < 0) {\n    finish += step;\n  }\n  int cnt = (start - finish) / step + 1;\n  int value = mul(mul(start + finish, cnt), INV2);\n  return value;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<pair<int,int>> e(n);\n  for (int i = 0; i < n; i++) {\n    cin >> e[i].first;\n    e[i].second = i;\n  }\n  sort(e.begin(), e.end());\n  vector<int> pr(n), ne(n);\n  for (int i = 0; i < n; i++) {\n    pr[i] = i - 1;\n    ne[i] = i + 1;\n  }\n  const int step = k - 1;\n  int ans = 0;\n  for (auto &pp : e) {\n    int i = pp.second;\n    int L = pr[i] + 1;\n    int R = ne[i] - 1;\n    int len = (R - L + 1);\n    if (len >= k) {\n      int pos = i - L;\n      int xstart = k;\n      int xfinish = k + (len - k) / step * step;\n      int xcnt = (xfinish - xstart) / step + 1;\n      {\n        int value = sum_positive(pos + 1 - xstart, pos + 1 - xfinish, step);\n        sub(ans, mul(value, pp.first));\n      }\n      {\n        add(ans, mul(mul(pos, xcnt), pp.first));\n        int value = sum_positive(xfinish + pos - len, xstart + pos - len, step);\n        sub(ans, mul(value, pp.first));\n      }\n      add(ans, mul(xcnt, pp.first));\n    }\n    if (pr[i] != -1) {\n      ne[pr[i]] = ne[i];\n    }\n    if (ne[i] != n) {\n      pr[ne[i]] = pr[i];\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n""]","[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2500
Vladimir would like to prepare a present for his wife they have an anniversary He decided to buy her n flowers Vladimir went to a flower shop and he was amazed to see that there are m types of flowers being sold there and there is unlimited supply of flowers of each type Vladimir wants to choose flowers to maximize the happiness of his wife He knows that after receiving the first flower of the i th type happiness of his wife increases by a i and after receiving each consecutive flower of this type her happiness increases by b i That is if among the chosen flowers there are x i 0 flowers of type i his wife gets a i x i 1 cdot b i additional happiness and if there are no flowers of type i she gets nothing for this particular type Please help Vladimir to choose exactly n flowers to maximize the total happiness of his wife ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n\tint t;\n\tcin >> t;\n\n\tfor(int x = 0; x < t; x++) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tvector< pair<int, int> > arr;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\tarr.emplace_back(a, b);\n\t\t}\n\t\tsort(arr.begin(), arr.end());\n\t\tvector<int> sufsum(m);\n\t\tsufsum[m - 1] = arr[m - 1].first;\n\t\tfor(int i = m - 2; i >= 0; i--) {\n\t\t\tsufsum[i] = sufsum[i + 1] + arr[i].first;\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint j = lower_bound(arr.begin(), arr.end(), make_pair(arr[i].second + 1, 0LL)) - arr.begin();\n\n\t\t\tint cnt = m - j;\n\t\t\tif(cnt > n - 1) {\n\t\t\t\tcnt = n - 1;\n\t\t\t\tj = m - cnt;\n\t\t\t}\n\n\t\t\tif(cnt == n - 1 && i >= j && j >= 1 && arr[j - 1].first > arr[i].second) {\n\t\t\t\tj--;\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tif(i < j) {\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tassert(cnt <= n);\n\t\t\tint c = (j == m ? 0 : sufsum[j]) + (i < j ? arr[i].first : 0) + (n - cnt) * arr[i].second;\n\t\t\tans = max(ans, c);\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\n\treturn 0;\n}']","[1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0]",2000
You are given segments on the Ox axis You can drive a nail in any integer point on the Ox axis line nail so that all segments containing this point are considered nailed down If the nail passes through endpoint of some segment this segment is considered to be nailed too What is the smallest number of nails needed to nail all the segments down ,"['#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nbool cmp(pair <int, int> a, pair <int, int> b){\n    if(a.first<b.first){\n        return true;\n    }else{\n        if(a.first==b.first){\n            return a.second<b.second;\n        }\n        return false;\n    }\n}\n\n\nint main(){\n\n    int n;\n    pair <int, int> a[1013];\n    cin>>n;\n    for(int i=0; i<n; i++){\n        cin>>a[i].first>>a[i].second;\n        if(a[i].first>a[i].second) swap(a[i].first,a[i].second);\n    }\n    sort(a,a+n,cmp);\n    int m=0;\n    queue <int> q;\n    int f=0;\n    pair<int ,int> t;\n    while(f<n){\n        t=a[f];\n        int p=f;\n        bool fl=false;\n        while(p<n && max(t.first,a[p].first)<=min(t.second,a[p].second)){\n            t.first=max(t.first,a[p].first);\n            t.second=min(t.second,a[p].second);\n            fl=true;\n            p++;\n        }\n        q.push(t.first);\n        if(!fl) p++;\n        f=p;\n    }\n    cout<<q.size()<<endl;\n    while(!q.empty()){\n        cout<<q.front()<<"" "";\n        q.pop();\n    }\n    return 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1900
Bizon the Champion isn t just friendly he also is a rigorous coder Let s define function where is a sequence of integers Function returns the following sequence first all divisors of go in the increasing order then all divisors of go in the increasing order and so on till the last element of sequence For example Let s determine the sequence for integer is a sequence consisting of a single number For example at we get Given the numbers and find the sequence As the answer can be rather large find only the first elements of this sequence ,"['#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define int64 long long\n#define N 8500\n#define inf 100000\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nint i,j,k,len;\nshort b[N][N];\nint64 n,m,a[N];\nvoid dfs(int x,int cen) {\n\tif (!len) return;\n\tif (x==1||cen==m) {\n\t\tprintf(""%I64d "",a[x]);\n\t\tlen--;\n\t\treturn;\n\t}\n\tint i;\n\tfor (i=1;i<=*b[x]&&len;i++) dfs(b[x][i],cen+1);\n}\nint main() {\n\tscanf(""%I64d%I64d"",&n,&m);\n\tfor (i=1;1ll*i*i<=n;i++) if (n%i==0) a[++k]=i;\n\tfor (;i;i--) if (n%i==0&&1ll*i*i<n) a[++k]=n/i;\n\tFor(i,1,k) {\n\t\tFor(j,1,i) if (a[i]%a[j]==0) b[i][++*b[i]]=j;\n\t}\n\tlen=inf;\n\tdfs(k,0);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0]",2200
The Little Elephant loves permutations of integers from to very much But most of all he loves sorting them To sort a permutation the Little Elephant repeatedly swaps some elements As a result he must receive a permutation This time the Little Elephant has permutation Its sorting program needs to make exactly moves during the th move it swaps elements that are at that moment located at the th and the th positions But the Little Elephant s sorting program happened to break down and now on every step it can equiprobably either do nothing or swap the required elements Now the Little Elephant doesn t even hope that the program will sort the permutation but he still wonders if he runs the program and gets some permutation how much will the result of sorting resemble the sorted one For that help the Little Elephant find the mathematical expectation of the number of permutation inversions after all moves of the program are completed We ll call a pair of integers an in permutatuon if the following inequality holds ,"['#include <cstdio>\n#include <cstring>\n\nconst int N = 1000;\n\nint n, m, p[N], a[N], b[N];\ndouble prob[N][N];\n\nint main() {\n    scanf(""%d%d"", &n, &m);\n    for (int i = 0; i < n; ++ i) {\n        scanf(""%d"", p + i);\n    }\n    for (int i = 0; i < m; ++ i) {\n        scanf(""%d%d"", a + i, b + i);\n        a[i] --;\n        b[i] --;\n    }\n    for (int i = 0; i < n; ++ i) {\n        for (int j = 0; j < n; ++ j) {\n            prob[i][j] = i < j ? 1.0 : 0.0;\n        }\n    }\n    for (int k = m - 1; k >= 0; -- k) {\n        int u = a[k];\n        int v = b[k];\n        for (int i = 0; i < n; ++ i) {\n            if (i != u && i != v) {\n                prob[i][u] = prob[i][v] = (prob[i][u] + prob[i][v]) / 2.0;\n                prob[u][i] = prob[v][i] = (prob[u][i] + prob[v][i]) / 2.0;\n            }\n        }\n        prob[u][v] = prob[v][u] = (prob[u][v] + prob[v][u]) / 2.0;\n    }\n    double answer = 0;\n    for (int i = 0; i < n; ++ i) {\n        for (int j = 0; j < n; ++ j) {\n            if (p[i] > p[j]) {\n                answer += prob[i][j];\n            }\n        }\n    }\n    printf(""%.10f\\n"", answer);\n    return 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2600
Bike loves looking for the second maximum element in the sequence The second maximum element in the sequence of distinct numbers is such maximum element that the following inequality holds The lucky number of the sequence of distinct positive integers is the number that is equal to the bitwise excluding OR of the maximum element of the sequence and the second maximum element of the sequence You ve got a sequence of distinct positive integers Let s denote sequence as Your task is to find the maximum number among all lucky numbers of sequences Note that as all numbers in sequence are distinct all the given definitions make sence ,"['/*\nAuthor: elfness@UESTC\n*/\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\ntypedef long long LL;\nconst int V=100100;\nint l[V],r[V],a[V],ret,n;\nint main()\n{\n    while(~scanf(""%d"",&n))\n    {\n        ret=0;\n        for(int i=1;i<=n;i++)\n        scanf(""%d"",&a[i]);\n        for(int i=1;i<=n;i++)l[i]=r[i]=i;\n        for(int i=1;i<=n;i++)\n        {\n            while(l[i]!=1&&a[l[i]-1]<a[i])l[i]=l[l[i]-1];\n            if(l[i]!=1)ret=max(ret,a[i]^a[l[i]-1]);\n        }\n        for(int i=n;i>=1;i--)\n        {\n            while(r[i]!=n&&a[r[i]+1]<a[i])r[i]=r[r[i]+1];\n            if(r[i]!=n)ret=max(ret,a[i]^a[r[i]+1]);\n        }\n        printf(""%d\\n"",ret);\n    }\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Given n integers a 1 a 2 dots a n You can perform the following operation on them select any element a i 1 le i le n and divide it by 2 round down In other words you can replace any selected element a i with the value left lfloor frac a i 2 right rfloor where left lfloor x right rfloor is round down the real number x Output the minimum number of operations that must be done for a sequence of integers to become strictly increasing that is for the condition a 1 lt a 2 lt dots lt a n to be satisfied Or determine that it is impossible to obtain such a sequence Note that elements be swapped The only possible operation is described above For example let n 3 and a sequence of numbers 3 6 5 be given Then it is enough to perform two operations on it Write the number left lfloor frac 6 2 right rfloor 3 instead of the number a 2 6 and get the sequence 3 3 5 Then replace a 1 3 with left lfloor frac 3 2 right rfloor 1 and get the sequence 1 3 5 The resulting sequence is strictly increasing because 1 lt 3 lt 5 ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\nconst int N = 50;\nint T,n,ans,inp[N + 1];\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\tans = 0;\n\t\tn = read();\n\t\tfor (int i = 1;i <= n;i++) inp[i] = read();\n\t\tfor (int i = n - 1;i >= 1;i--){\n\t\t\twhile (inp[i] >= inp[i + 1]){\n\t\t\t\tif (inp[i] == 0) break;\n\t\t\t\t++ans,inp[i] >>= 1;\n\t\t\t}\n\t\t\tif (inp[i] >= inp[i + 1]) {puts(""-1"");goto AGAIN;}\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t\tAGAIN:;\n\t}\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
You are given numbers You can perform at most operations For each operation you can multiply one of the numbers by We want to make as large as possible where denotes the bitwise OR Find the maximum possible value of after performing at most operations optimally ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 200100;\nll a[N];\nll b[N];\nll c[N];\nll x;\nint k;\nint n;\n\nint main()\n{\n    scanf(""%d%d%lld"", &n, &k, &x);\n    ll y = 1;\n    for (int i = 0; i < k; i++)\n        y *= x;\n    for (int i = 0; i < n; i++)\n        scanf(""%lld"", &a[i]);\n    b[0] = 0;\n    for (int i = 0; i < n; i++)\n        b[i + 1] = b[i] | a[i];\n    c[n] = 0;\n    for (int i = n - 1; i >= 0; i--)\n        c[i] = c[i + 1] | a[i];\n    ll ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        ans = max(ans, b[i] | c[i + 1] | (a[i] * y));\n    }\n    printf(""%lld\\n"", ans);\n\n    return 0;\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1700
You are given a string s consisting only of characters or Let s be the length of s You are asked to choose some integer k k 0 and find a sequence a of length k such that 1 le a 1 a 2 dots a k le s a i 1 1 a i for all i from 2 to k The characters at positions a 1 a 2 dots a k are removed the remaining characters are concatenated without changing the order So in other words the positions in the sequence a should not be adjacent Let the resulting string be s s is called sorted if for all i from 2 to s s i 1 le s i Does there exist such a sequence a that the resulting string s is sorted ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nchar A[105];\n\nint main() {\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tscanf(""%s"", A + 1);\n\t\tN = strlen(A + 1);\n\t\tint L, R;\n\t\tfor(L = 2; L <= N; L++) {\n\t\t\tif(A[L] == \'1\' && A[L - 1] == \'1\') {\n\t\t\t\tL--; break;\n\t\t\t}\n\t\t}\n\n\t\tfor(R = N - 1; R >= 1; R--) {\n\t\t\tif(A[R] == \'0\' && A[R + 1] == \'0\') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(L < R) puts(""NO"");\n\t\telse puts(""YES"");\n\t}\n\treturn 0;\n}']","[1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Given an array a consisting of n integers find max limits 1 le i j le n LCM a i a j where LCM x y is the smallest positive integer that is divisible by both x and y For example LCM 6 8 24 LCM 4 12 12 LCM 2 3 6 ,"['#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nint gcd(int a, int b){\n\twhile(b){\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\nlong long lcm(int a, int b){\n\treturn 1ll * a / gcd(a, b) * b;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n; \n\tcin >> n;\n\tvector<int> a(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a.begin(), a.end());\n\ta.erase(unique(a.begin(), a.end()), a.end());\n\tlong long ans = a.back();\n\tconst int magic = 150;\n\tauto lookup = create<int>(magic, n + 1);\n\tfor(int i = 1; i < magic; i++){\n\t\tfor(int j = 0; j < n; j++)\n\t\t\tlookup[i][j] = -1;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tint p = a[j] % i;\n\t\t\tif(p) lookup[i][j] = j;\n\t\t\telse if(j) lookup[i][j] = lookup[i][j - 1];\n\t\t}\n\t}\n\tint iter = 0;\n\tfor(int i = n - 1; i >= 0; i--){\n\t\tunordered_set<int> dont;\n\t\titer = 0;\n\t\tfor(int j = i - 1; j >= 0 && iter <= 250; ){\n\t\t\tlong long m = 1ll * a[i] * a[j];\n\t\t\tif(m < ans) break;\n\t\t\tint g = gcd(a[i], a[j]);\n\t\t\tans = max(ans, m / g);\n\t\t\titer++;\n\t\t\tif(g >= magic) j--;\n\t\t\telse {\n\t\t\t\tdont.insert(g);\n\t\t\t\tint nj = j - 1;\n\t\t\t\twhile(nj >= 0){\n\t\t\t\t\tbool ch = false;\n\t\t\t\t\tfor(int v : dont) if(nj != lookup[v][nj]){\n\t\t\t\t\t\tnj = lookup[v][nj];\n\t\t\t\t\t\tch = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(!ch) break;\n\t\t\t\t}\n\t\t\t\tj = nj;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1]",2900
AquaMoon has a string a consisting of only 0 and 1 She wants to add and between all pairs of consecutive positions to make the absolute value of the resulting expression as small as possible Can you help her ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 100100;\nchar s[N];\nint n;\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tscanf(""%s"", s);\n\tint bal = (int)(s[0] - \'0\');\n\tfor (int i = 1; i < n; i++) {\n\t\tif (s[i] == \'0\') {\n\t\t\tprintf(""+"");\n\t\t} else {\n\t\t\tif (bal > 0) {\n\t\t\t\tbal--;\n\t\t\t\tprintf(""-"");\n\t\t\t} else {\n\t\t\t\tbal++;\n\t\t\t\tprintf(""+"");\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Madoka finally found the administrator password for her computer Her father is a well known popularizer of mathematics so the password is the answer to the following problem Find the maximum decimal number without zeroes and with no equal digits in a row such that the sum of its digits is n Madoka is too tired of math to solve it herself so help her to solve this problem ,"['#include <bits/stdc++.h>\n\n#define f first\n#define s second\n//#define x first\n//#define y second\n//#define int li\n#define err if(debug_out)cout\n\nusing namespace std;\nusing li = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pld = pair<ld, ld>;\n\nconst int INF = 1e9 + 13;\nconst li INF64 = 1e18 + 13;\nconst int N = 3e5 + 13;\nconst int LOGN = 20;\nconst int K = 22;\nconst int M = 998244353;//1e9 + 7;\nconst int A = 26;\nconst ld eps = 1e-8;\n\nmt19937 rnd(45768);\n\n/*\n*/\n\nint sum(int a, int b) {\n    a += b;\n    return (a >= M ? a - M : a);\n}\n\nint mul(int a, int b) {\n    return a * 1ll * b % M;\n}\n\nint dif(int a, int b) {\n    return sum(a, M - b);\n}\n\nint pow2(int n, int k) {\n    if(k == 0)\n        return 1;\n\n    int pw = pow2(n, k / 2);\n    pw = mul(pw, pw);\n\n    return (k % 2 == 0 ? pw : mul(pw, n));\n}\n\n/*\n*/\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    if(n == 1) {\n        cout << 1 << endl;\n        return;\n    }\n\n    string s = """";\n    while(n > 0) {\n        if(s.empty()) {\n            s += \'2\';\n            n -= 2;\n        } else if(s.back() == \'1\') {\n            if(n == 1) {\n                cout << 1 << s << endl;\n                return;\n            } else {\n                s += \'2\';\n                n -= 2;\n            }\n        } else {\n            s += \'1\';\n            n--;\n        }\n    }\n\n    cout << s << endl;\n}\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n\n    while(t--)\n        solve();\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Roman planted a tree consisting of vertices Each vertex contains a lowercase English letter Vertex is the root of the tree each of the remaining vertices has a in the tree Vertex is connected with its parent by an edge The parent of vertex is vertex the parent index is always less than the index of the vertex i e The of the vertex is the number of nodes on the path from the root to along the edges In particular the depth of the root is equal to We say that vertex is in the of vertex if we can get from to moving from the vertex to the parent In particular vertex is in its subtree Roma gives you queries the th of which consists of two numbers Let s consider the vertices in the subtree located at depth Determine whether you can use the letters written at these vertices to make a string that is a The letters that are written in the vertexes can be rearranged in any order to make a palindrome but all letters should be used ,"['#include <cstdio>\n#include <vector>\n#include <cstring>\n\n#define MAXN 500005\n\nint n,m;\n\nint fa[MAXN];\nint h[MAXN];\nstd::vector<int> childs[MAXN];\n\nint h_cnt[MAXN];\n\nint dfn[MAXN];\nint d2[MAXN];\n\nstruct data {\n\tint cnt[26];\n\tint d;\n};\n\nstd::vector<data> sum[MAXN];\n\nchar a[MAXN];\n\ninline void dfs(int x) {\n\tstatic int dfstot=0;\n\tdfn[x]=++dfstot;\n\tstatic data t;\n\tt=sum[h[x]].back();\n\t++t.cnt[a[x]-\'a\'];\n\tt.d=dfstot;\n\tsum[h[x]].push_back(t);\n\tfor (auto t : childs[x]) {\n\t\tdfs(t);\n\t}\n\td2[x]=dfstot;\n}\n\ninline int find(const std::vector<data> &A,int l,int r,int d) {\n\twhile (l<r) {\n\t\tint mid=(l+r+1)>>1;\n\t\tif (A[mid].d>d) {\n\t\t\tr=mid-1;\n\t\t} else {\n\t\t\tl=mid;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\tint i;\n\th[1]=1;\n\t++h_cnt[1];\n\tfor (i=2;i<=n;i++) {\n\t\tscanf(""%d"",fa+i);\n\t\tchilds[fa[i]].push_back(i);\n\t\th[i]=h[fa[i]]+1;\n\t\t++h_cnt[h[i]];\n\t}\n\t\n\tscanf(""%s"",a+1);\n\t\n\tdata x;\n\tmemset(&x,0,sizeof(x));\n\tfor (i=1;i<=n;i++) {\n\t\tsum[i].push_back(x);\n\t}\n\tdfs(1);\n\t\n\tfor (i=1;i<=m;i++) {\n\t\tint x,d;\n\t\tscanf(""%d%d"",&x,&d);\n\t\tint L=dfn[x],R=d2[x];\n\t\tint id1=find(sum[d],0,sum[d].size()-1,L-1);\n\t\tint id2=find(sum[d],0,sum[d].size()-1,R);\n\t\tdata A=sum[d][id1];\n\t\tdata B=sum[d][id2];\n\t\tint i;\n\t\tint t=0;\n\t\tfor (i=0;i<26;i++) {\n\t\t\tint x=B.cnt[i]-A.cnt[i];\n\t\t\tif (x>0 && x%2==1) ++t;\n\t\t}\n\t\tputs(t>1 ? ""No"" : ""Yes"");\n\t}\n}']","[0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0]",2200
You are given n positive integers a 1 ldots a n and an integer k geq 2 Count the number of pairs i j such that 1 leq i j leq n and there exists an integer x such that a i cdot a j x k ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n \ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\ntypedef complex<ld> cd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ld> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define rsz resize\n#define ins insert\n\nconst int MOD = 1e9+7; // 998244353 = (119<<23)+1\nconst ll INF = 1e18;\nconst int MX = 2e5+5;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define ook order_of_key\n#define fbo find_by_order\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) { \n        re(t); re(ts...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    \n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T> void pr(const T& x);\n    \n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n        pr(t); pr(ts...); \n    }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void pr(const T& x) { \n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    \n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); \n    }\n    \n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); \n    }\n    #define dbg(x...) pr(""["",#x,""] = [""), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0); // fast I/O\n        cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n\ta %= b; if (a == 0) return b == 1 ? 0 : -1;\n\tT x = invGeneral(b,a); \n\treturn x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n\tT val; \n\texplicit operator T() const { return val; }\n\tmodular() { val = 0; }\n\tmodular(const ll& v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\t\n\t// friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n\tfriend void pr(const modular& a) { pr(a.val); }\n\tfriend void re(modular& a) { ll x; re(x); a = modular(x); }\n   \n\tfriend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n\tfriend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\tfriend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n\tmodular operator-() const { return modular(-val); }\n\tmodular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tmodular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tmodular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n\tfriend modular pow(modular a, ll p) {\n\t\tmodular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend modular inv(const modular& a) { \n\t\tauto i = invGeneral(a.val,MOD); assert(i != -1);\n\t\treturn i;\n\t} // equivalent to return exp(b,MOD-2) if MOD is prime\n\tmodular& operator/=(const modular& m) { return (*this) *= inv(m); }\n\t\n\tfriend modular operator+(modular a, const modular& b) { return a += b; }\n\tfriend modular operator-(modular a, const modular& b) { return a -= b; }\n\tfriend modular operator*(modular a, const modular& b) { return a *= b; }\n\t\n\tfriend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint n,k;\n\ntemplate<class T> vector<pair<T,int>> factor(T x) { // x <= 10^{14} is fine\n\tvector<pair<T,int>> pri;\n\n\tfor (T i = 2; i*i <= x; ++i) if (x % i == 0) {\n\t\tint t = 0;\n\t\twhile (x % i == 0) x /= i, t ++;\n\t\tpri.pb({i,t});\n\t}\n\n\tif (x > 1) pri.pb({x,1});\n\treturn pri;\n}\n\nmap<ll,ll> m;\n\npl cool(ll X) {\n\tauto z = factor(X);\n\tll x = 1, y = 1;\n\ttrav(t,z) {\n\t\tt.s %= k;\n\t\tif (t.s > 0) {\n\t\t\tF0R(i,t.s) x *= t.f;\n\t\t\tF0R(i,k-t.s) {\n\t\t\t\ty *= t.f;\n\t\t\t\tif (y > 1e5) return {-1,-1};\n\t\t\t}\n\t\t}\n\t}\n\treturn {x,y};\n}\n\nint main() {\n\tsetIO(); re(n,k);\n\tll ans = 0;\n\tF0R(i,n) {\n\t\tll x; re(x);\n\t\tpl t = cool(x);\n\t\t// ps(""HA"",x,t);\n\t\tif (t.s != -1) {\n\t\t\tif (m.count(t.s)) ans += m[t.s];\n\t\t\tm[t.f] ++;\n\t\t}\n\t}\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), set tle\n\t* do smth instead of nothing and stay organized\n*/\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
No Great Victory anniversary in Berland has ever passed without the war parade This year is not an exception That s why the preparations are on in full strength Tanks are building a line artillery mounts are ready to fire soldiers are marching on the main square And the air forces general Mr Generalov is in trouble again This year a lot of sky scrapers have been built which makes it difficult for the airplanes to fly above the city It was decided that the planes should fly strictly from south to north Moreover there must be no sky scraper on a plane s route otherwise the anniversary will become a tragedy The Ministry of Building gave the data on sky scrapers the rest of the buildings are rather small and will not be a problem to the planes When looking at the city from south to north as a geometrical plane the th building is a rectangle of height Its westernmost point has the x coordinate of and the easternmost of The terrain of the area is plain so that all the buildings stand on one level Your task as the Ministry of Defence s head programmer is to find an polyline using the data on the sky scrapers The polyline s properties are as follows If you look at the city from south to north as a plane then any part of any building will be inside or on the boarder of the area that the polyline encloses together with the land surface The polyline starts and ends on the land level i e at the height equal to 0 The segments of the polyline are parallel to the coordinate axes i e they can only be vertical or horizontal The polyline s vertices should have integer coordinates If you look at the city from south to north the polyline together with the land surface must enclose the minimum possible area The polyline must have the smallest length among all the polylines enclosing the minimum possible area with the land The consecutive segments of the polyline must be perpendicular Picture to the second sample test the enveloping polyline is marked on the right ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\nstruct Skyscrapper{\n    int h, l, r;\n} A[100000];\nint n;\n\nvoid solve(int b, int e, vector<int> &ans) {\n    if (b == e){\n        ans.push_back(A[b].l);\n        ans.push_back(A[b].h);\n        ans.push_back(A[b].r);\n        ans.push_back(0);\n    }\n    else {\n        vector<int> v1, v2;\n        solve(b, (b+e)/2, v1);\n        solve((b+e)/2 + 1, e, v2);\n        int cur1, cur2, h1, h2, len1, len2,curh;\n        len1 = v1.size(); len2 = v2.size();\n        cur1=cur2=0;\n        h1=h2=0;\n        curh=0;\n        while (cur1 < len1 || cur2 < len2) {\n            if (cur2 >= len2 || cur1 < len1 && v1[cur1] <= v2[cur2]){\n                h1 = v1[cur1+1];\n                if (cur2 >= len2 || cur1 < len1 && v1[cur1] != v2[cur2]){\n                    if (max(h1, h2) != curh) {\n                        ans.push_back(v1[cur1]);\n                        curh = max(h1, h2);\n                        ans.push_back(curh);\n                    }\n                }\n                cur1 += 2;\n            }\n            else{\n                h2 = v2[cur2+1];\n                if (cur1 >= len1 || cur2 < len2 && v1[cur1] != v2[cur2]){\n                    if (max(h1, h2) != curh) {\n                        ans.push_back(v2[cur2]);\n                        curh = max(h1, h2);\n                        ans.push_back(curh);\n                    }\n                }\n                cur2 += 2;\n            }\n        }\n    }\n}\n\nint main () {\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    scanf(""%d"", &n);\n    for(int i=0; i<n; i++){\n        scanf(""%d%d%d"", &A[i].h,\n                        &A[i].l,\n                        &A[i].r);\n    }\n    vector<int> poly;\n    solve(0, n-1, poly);\n    printf(""%d\\n"", (int)poly.size());\n\n    int curh=0;\n    for(int i=0; i<poly.size(); i+=2) {\n        printf(""%d %d\\n"", poly[i], curh);\n        printf(""%d %d\\n"", poly[i], poly[i+1]);\n        curh = poly[i+1];\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2100
Kostya is a genial sculptor he has an idea to carve a marble sculpture in the shape of a sphere Kostya has a friend Zahar who works at a career Zahar knows about Kostya s idea and wants to present him a rectangular parallelepiped of marble from which he can carve the sphere Zahar has stones which are rectangular parallelepipeds The edges sizes of the th of them are and He can take and present them to Kostya If Zahar takes two stones he should glue them together on one of the faces in order to get a new piece of rectangular parallelepiped of marble Thus it is possible to glue a pair of stones together if and only if two faces on which they are glued together match as rectangles In such gluing it is allowed to rotate and flip the stones in any way Help Zahar choose such a present so that Kostya can carve a sphere of the maximum possible volume and present it to Zahar ,"['#include <bits/stdc++.h>\n\n#define mp make_pair\n#define f first\n#define s second\n\nusing namespace std;\n\npair<pair<int, int>, pair<int, int> > arr[600005];\npair<int, int> tmp[2];\n\nvoid update(pair<int, int> x)\n{\n  if(x.f > tmp[0].f)\n  {\n    if(x.s != tmp[0].s) tmp[1] = tmp[0];\n    tmp[0] = x;\n  }\n  else if(x.s != tmp[0].s && x.f > tmp[1].f)\n    tmp[1] = x;\n}\n\nvoid clr()\n{\n  tmp[0] = tmp[1] = mp(-1, -1);\n}\n\nint main()\n{\n  int n, x, y, z;\n  cin >> n;\n  int ans = 0;\n  pair<int, int> ch = mp(-1, -1);\n  for(int i=0;i<n;i++)\n  {\n    scanf(""%d %d %d"", &x, &y, &z);\n    arr[i*6] = mp(mp(x, y), mp(z, i));\n    arr[i*6+1] = mp(mp(y, x), mp(z, i));\n    arr[i*6+2] = mp(mp(x, z), mp(y, i));\n    arr[i*6+3] = mp(mp(z, x), mp(y, i));\n    arr[i*6+4] = mp(mp(z, y), mp(x, i));\n    arr[i*6+5] = mp(mp(y, z), mp(x, i));\n    if(min(x, min(y, z)) > ans)\n    {\n      ans = min(x, min(y, z));\n      ch.f = i + 1;\n    }\n  }\n  n *= 6;\n  sort(arr, arr + n);\n  clr();\n  update(arr[0].s);\n  for(int i=1;i<n;i++)\n  {\n    if(arr[i].f != arr[i - 1].f)\n    {\n      if(tmp[1].s != -1)\n      {\n        if(min(min(arr[i-1].f.f, arr[i-1].f.s), tmp[0].f + tmp[1].f) > ans)\n        {\n          ans = min(min(arr[i-1].f.f, arr[i-1].f.s), tmp[0].f + tmp[1].f);\n          ch = mp(tmp[0].s+1, tmp[1].s+1);\n        }\n      }\n      clr();\n    }\n    update(arr[i].s);\n  }\n  if(tmp[1].s != -1)\n  {\n    if(min(min(arr[n-1].f.f, arr[n-1].f.s), tmp[0].f + tmp[1].f) > ans)\n    {\n      ans = min(min(arr[n-1].f.f, arr[n-1].f.s), tmp[0].f + tmp[1].f);\n      ch = mp(tmp[0].s+1, tmp[1].s+1);\n    }\n  }\n  if(ch.s == -1)\n    cout << ""1\\n"" << ch.f;\n  else cout << ""2\\n"" << ch.f << "" "" << ch.s;\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
The boy Smilo is learning algorithms with a teacher named Brukhovich Over the course of the year Brukhovich will administer n exams For each exam its difficulty a i is known which is a non negative integer Smilo doesn t like when the greatest common divisor of the difficulties of two consecutive exams is equal to 1 Therefore he considers the of the academic year to be the number of such pairs of exams More formally the is the number of indices i 1 leq i leq n 1 such that gcd a i a i 1 1 where gcd x y is the greatest common divisor of integers x and y Brukhovich wants to minimize the sadness of the year of Smilo To do this he can set the difficulty of any exam to 0 However Brukhovich doesn t want to make his students lives too easy Therefore he will perform this action no more than k times Help Smilo determine the minimum sadness that Brukhovich can achieve if he performs no more than k operations As a reminder the greatest common divisor GCD of two non negative integers x and y is the maximum integer that is a divisor of both x and y and is denoted as gcd x y In particular gcd x 0 gcd 0 x x for any non negative integer x ,"['#include<bits/stdc++.h>\n#define rg register\n#define file(x)freopen(x"".in"",""r"",stdin);freopen(x"".out"",""w"",stdout)\n\nusing namespace std;\n\nconst int maxn=1e5+10;\n\ninline int gcd(int x,int y)\n{\n    if(!y)return x;\n    return gcd(y,x%y);\n}\n\nint n,K;\nint A[maxn];\n\ninline void solve()\n{\n    scanf(""%d %d"",&n,&K);\n    for(rg int i=1;i<=n;i+=1)scanf(""%d"",A+i);\n    if(n==1)\n    {\n\tputs(""0"");\n\treturn;\n    }\n    bool ccf=true;\n    for(rg int i=1;i<=n;i+=1)ccf&=A[i]==1;\n    if(ccf)\n    {\n\tfor(rg int i=1;i<=K;i+=1)A[i]=0;\n\tint Ans=0;\n\tfor(rg int i=1;i<n;i+=1)Ans+=gcd(A[i],A[i+1]);\n\tcout<<Ans<<endl;\n\treturn;\n    }\n    vector<int>B,C;\n    for(rg int i=1;i<=n;i+=1)\n    {\n\tif(A[i]==1)continue;\n\trg int j=i;\n\twhile(j<n&&A[j+1]^1&&gcd(A[j],A[j+1])==1)j+=1;\n\tfor(rg int k=i+1;k<j;k+=2)B.emplace_back(k);\n\tif((j-i)&1)C.emplace_back(j);\n\ti=j;\n    }\n    while(K&&B.size())\n    {\n\tA[B.back()]=0;B.pop_back();\n\tK-=1;\n    }\n    vector<pair<int,int> >Seq;\n    for(rg int i=1;i<=n;i+=1)\n\tif(A[i]==1)\n\t{\n\t    rg int j=i;\n\t    while(j<n&&A[j+1]==1)j+=1;\n\t    if(i>1&&j<n)Seq.emplace_back(i,j);\n\t    i=j;\n\t}\n    sort(Seq.begin(),Seq.end(),[](auto x,auto y)\n\t\t\t       {\n\t\t\t\t   return x.second-x.first>y.second-y.first;\n\t\t\t       });\n    while(Seq.size()&&Seq.back().second-Seq.back().first+1<=K)\n    {\n\tauto [l,r]=Seq.back();Seq.pop_back();\n\tK-=r-l+1;\n\tfor(rg int i=l;i<=r;i+=1)A[i]=0;\n    }\n    while(K&&C.size())\n    {\n\tA[C.back()]=0,C.pop_back();\n\tK-=1;\n    }\n    int Ans=0;\n    for(rg int i=1;i<n;i+=1)Ans+=gcd(A[i],A[i+1])==1;\n    int cnt=0;\n    for(rg int i=1;i<=n;i+=1)cnt+=A[i]==1;\n    Ans-=min(K,cnt);\n    printf(""%d\\n"",Ans);\n}\n\nint main()\n{\n    int T;scanf(""%d"",&T);\n    while(T--)solve();\n    return 0;\n}\n']","[1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]",2500
With hands joined go everywhere at a speed faster than our thoughts This time the Fire Sisters Karen and Tsukihi is heading for somewhere they ve never reached water surrounded islands There are three clusters of islands conveniently coloured red blue and purple The clusters consist of and distinct islands respectively Bridges have been built between some possibly all or none of the islands A bridge bidirectionally connects two different islands and has length For any two islands of the same colour either they shouldn t be reached from each other through bridges or the shortest distance between them is apparently in order to prevent oddities from spreading quickly inside a cluster The Fire Sisters are ready for the unknown but they d also like to test your courage And you re here to figure out the number of different ways to build all bridges under the constraints and give the answer modulo Two ways are considered different if a pair of islands exist such that there s a bridge between them in one of them but not in the other ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nll f[5003][5003];\nconst int MOD=998244353;\nint main()\n{\n\tfor(int i=0;i<=5000;++i) f[0][i]=1;\n\tfor(int i=1;i<=5000;++i)\n\t{\n\t\tf[i][0]=1;\n\t\tfor(int j=1;j<=5000;++j)\n\t\t\tf[i][j]=(f[i-1][j]+j*f[i-1][j-1])%MOD;\n\t}\n\tint a,b,c;\n\tscanf(""%d%d%d"",&a,&b,&c);\n\tll ans=f[a][b]*f[a][c]%MOD*f[b][c]%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tprintf(""%d\\n"",ans);\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1800
A tennis tournament with participants is running The participants are playing by an olympic system so the winners move on and the losers drop out The tournament takes place in the following way below is the number of the participants of the current round let be the maximal power of the number such that participants compete in the current round and a half of them passes to the next round the other participants pass to the next round directly when only one participant remains the tournament finishes Each match requires bottles of water for each participant and one bottle for the judge Besides towels are given to each participant for the whole tournament Find the number of bottles and towels needed for the tournament Note that it s a tennis tournament so in each match two participants compete one of them will win and the other will lose ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n  int n, b, p;\n  in >> n >> b >> p;\n  out << (2 * b + 1) * (n - 1) << "" "" << n * p << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
A sequence of non negative integers a 1 a 2 dots a n is called if for all i from 1 to n 1 all ones of binary representation in a i are in the places of ones of binary representation in a i 1 in other words a i a i 1 a i where denotes bitwise AND If n 1 then the sequence is considered as well For example the following four sequences are growing 2 3 15 175 in binary it s 10 2 11 2 1111 2 10101111 2 5 in binary it s 101 2 1 3 7 15 in binary it s 1 2 11 2 111 2 1111 2 0 0 0 in binary it s 0 2 0 2 0 2 The following three sequences are non growing 3 4 5 in binary it s 11 2 100 2 101 2 5 4 3 in binary it s 101 2 100 2 011 2 1 2 4 8 in binary it s 0001 2 0010 2 0100 2 1000 2 Consider two sequences of non negative integers x 1 x 2 dots x n and y 1 y 2 dots y n Let s call this pair of sequences if the sequence x 1 oplus y 1 x 2 oplus y 2 dots x n oplus y n is where oplus denotes bitwise XOR You are given a sequence of integers x 1 x 2 dots x n Find the lexicographically minimal sequence y 1 y 2 dots y n such that sequences x i and y i are co growing The sequence a 1 a 2 dots a n is lexicographically smaller than the sequence b 1 b 2 dots b n if there exists 1 le k le n such that a i b i for any 1 le i k but a k b k ,"['#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        int prev = 0;\n        for (int i = 0; i < n; i++) {\n            int y = prev & (~a[i]);\n            cout << y << "" "";\n            prev = a[i] ^ y;\n        }\n        cout << ""\\n"";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], ""r"", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Consider a simplified penalty phase at the end of a football match A penalty phase consists of at most 10 kicks the first team takes the first kick the second team takes the second kick then the first team takes the third kick and so on The team that scores more goals wins if both teams score the same number of goals the game results in a tie The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks For example if after the 7 th kick the first team has scored 1 goal and the second team has scored 3 goals the penalty phase ends the first team cannot reach 3 goals You know which player will be taking each kick so you have your predictions for each of the 10 kicks These predictions are represented by a string s consisting of 10 characters Each character can either be or This string represents your predictions in the following way if s i is then the i th kick will definitely score a goal if s i is then the i th kick definitely won t score a goal if s i is then the i th kick could go either way Based on your predictions you have to calculate the minimum possible number of kicks there can be in the penalty phase that means the earliest moment when the penalty phase is stopped considering all possible ways it could go Note that you may know that some kick will won t be scored but the referee doesn t ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nint test(str S) {\n\tAR<int,2> score{};\n\tF0R(i,sz(S)) {\n\t\t{\n\t\t\tAR<int,2> tmp = score;\n\t\t\tFOR(j,i,sz(S)) {\n\t\t\t\tif (j&1) ++tmp[1];\n\t\t\t}\n\t\t\tif (tmp[1] < tmp[0]) return i;\n\t\t}\n\t\t{\n\t\t\tAR<int,2> tmp = score;\n\t\t\tFOR(j,i,sz(S)) {\n\t\t\t\tif (!(j&1)) ++tmp[0];\n\t\t\t}\n\t\t\tif (tmp[0] < tmp[1]) return i;\n\t\t}\n\t\tscore[i&1] += S[i]-\'0\';\n\t}\n\treturn sz(S);\n}\n\nvoid solve(int tc) {\n\tstr S; re(S);\n\tint ans = MOD;\n\t{\n\t\tstr A = S;\n\t\tF0R(i,sz(A)) if (A[i] == \'?\') {\n\t\t\tif (i&1) A[i] = \'1\';\n\t\t\telse A[i] = \'0\';\n\t\t}\n\t\tckmin(ans,test(A));\n\t}\n\t{\n\t\tstr A = S;\n\t\tF0R(i,sz(A)) if (A[i] == \'?\') {\n\t\t\tif (i&1) A[i] = \'0\';\n\t\t\telse A[i] = \'1\';\n\t\t}\n\t\tckmin(ans,test(A));\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200
After a lot of trying Mashmokh designed a problem and it s your job to solve it You have a tree with vertices Each vertex has a unique index from 1 to The root of has index For each vertex of this tree you are given a list of its children in a specific order You must perform three types of query on this tree find distance the number of edges in the shortest path between and given and disconnect from its father and connect it to its th ancestor more formally let s denote the path from to the root by so that and is root disconnect from its father and connect it to vertex must be added to the end of the child list of vertex in the vertex sequence produced by calling function dfs root find the latest vertex that has distance from the root The pseudo code of function dfs v ls v list of children of vertex v its i th element is ls v i its size is size ls v sequence result empty sequence void dfs vertex now add now to end of result for int i 1 i size ls v i i 1 loop from i 1 to i size ls v dfs ls v i ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <queue>\n#include <complex>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define sz(s) int((s).size())\n#define len(s) int((s).size())\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define eprintf(...) 42\n#endif\n#if _WIN32 || __WIN32__\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n#define next _next\n#define prev _prev\n#define rank _rank\n#define hash _hash\n#define y0 yy0\n#define y1 yy1\n#define link _link\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef unsigned long long ullong;\ntypedef unsigned long long lint;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nconst int inf = int(1e9);\nconst double eps = 1e-9;\nconst double pi = 4 * atan(double(1));\nconst int N = int(1e5) + 100;\n\nstruct node {\n\t\n\tint ver, val, minVal, maxVal, add;\n\tint h, sz, p, l, r;\n\t\n\tnode() {\n\t\tminVal = inf;\n\t\tmaxVal = -inf;\n\t\tsz = 0;\n\t}\n\t\n\tnode(int ver, int val) {\n\t\tthis->ver = ver;\n\t\tthis->val = minVal = maxVal = val;\n\t\tadd = 0;\n\t\th = (rand() << 16) | rand();\n\t\tsz = 1;\n\t\tp = l = r = 0;\n\t}\n\t\n};\n\nint sz, root;\nint first[N], last[N];\nvi sons[N];\nnode d[5 * N];\n\ninline void push(int v) {\n\tif (v == 0 || d[v].add == 0) {\n\t\treturn;\n\t}\n\td[v].val += d[v].add;\n\td[v].minVal += d[v].add;\n\td[v].maxVal += d[v].add;\n\tif (d[v].l > 0) {\n\t\td[d[v].l].add += d[v].add;\n\t}\n\tif (d[v].r > 0) {\n\t\td[d[v].r].add += d[v].add;\n\t}\n\td[v].add = 0;\n}\t\n\ninline void calc(int v) {\n\tpush(v);\n\tpush(d[v].l);\n\tpush(d[v].r);\n\td[v].sz = d[d[v].l].sz + d[d[v].r].sz + 1;\n\td[v].minVal = min(d[v].val, min(d[d[v].l].minVal, d[d[v].r].minVal));\n\td[v].maxVal = max(d[v].val, max(d[d[v].l].maxVal, d[d[v].r].maxVal));\n\td[v].p = 0;\n\tif (d[v].l > 0) {\n\t\td[d[v].l].p = v;\n\t}\n\tif (d[v].r > 0) {\n\t\td[d[v].r].p = v;\n\t}\n}\n\nint merge(int l, int r) {\n\tpush(l);\n\tpush(r);\n\tif (l == 0) {\n\t\treturn r;\n\t}\n\tif (r == 0) {\n\t\treturn l;\n\t}\n\tint res;\n\tif (d[l].h > d[r].h) {\n\t\td[l].r = merge(d[l].r, r);\n\t\tres = l;\n\t}\n\telse {\n\t\td[r].l = merge(l, d[r].l);\n\t\tres = r;\n\t}\n\tcalc(res);\n\treturn res;\n}\n\nvoid dfs(int v, int ch = 0) {\n\td[++sz] = node(v, ch);\n\troot = merge(root, sz);\n\tfirst[v] = sz;\n\tfor (int i = 0; i < sz(sons[v]); ++i) {\n\t\tdfs(sons[v][i], ch + 1);\n\t\td[++sz] = node(v, ch);\n\t\troot = merge(root, sz);\n\t}\n\td[++sz] = node(v, ch);\n\troot = merge(root, sz);\n\tlast[v] = sz;\n}\n\ninline int getNum(int v) {\n\tint res = d[d[v].l].sz + 1;\n\twhile (d[v].p > 0) {\n\t\tint pv = d[v].p;\n\t\tif (d[pv].r == v) {\n\t\t\tres += d[d[pv].l].sz + 1;\n\t\t}\n\t\tv = pv;\n\t}\n\treturn res;\n}\n\ninline int getPos(int v) {\n\treturn getNum(first[v]);\n}\n\ninline int getVal(int v, int num) {\n\tpush(v);\n\tif (d[d[v].l].sz + 1 == num) {\n\t\treturn d[v].val;\n\t}\n\tif (d[d[v].l].sz + 1 > num) {\n\t\treturn getVal(d[v].l, num);\n\t}\n\telse {\n\t\treturn getVal(d[v].r, num - d[d[v].l].sz - 1);\n\t}\n}\n\ninline int getVal(int v) {\n\treturn getVal(root, getNum(first[v]));\n}\n\nvoid splitSize(int v, int sz, int &l, int &r) {\n\tpush(v);\n\tif (v == 0) {\n\t\tl = r = 0;\n\t\treturn;\n\t}\n\tif (d[d[v].l].sz + 1 <= sz) {\n\t\tsplitSize(d[v].r, sz - d[d[v].l].sz - 1, d[v].r, r);\n\t\tl = v;\n\t}\n\telse {\n\t\tsplitSize(d[v].l, sz, l, d[v].l);\n\t\tr = v;\n\t}\n\tcalc(v);\n}\n\ninline int getDist(int v, int u) {\n\tint l = getPos(v), r = getPos(u);\n\tif (l > r) {\n\t\tswap(l, r);\n\t}\n\tint p1, p2, p3;\n\tsplitSize(root, r, p1, p3);\n\tsplitSize(p1, l - 1, p1, p2);\n\tint res = d[p2].minVal;\n\troot = merge(p1, merge(p2, p3));\n\treturn getVal(v) + getVal(u) - 2 * res;\n}\n\ninline int findKth(int v, int k) {\n\tpush(v);\n\tif (v == 0) {\n\t\treturn -1;\n\t}\n\tif (d[v].val == k) {\n\t\tint res = findKth(d[v].r, k);\n\t\tif (res == -1) {\n\t\t\tres = d[v].ver;\n\t\t}\n\t\treturn res;\n\t}\n\tpush(d[v].r);\n\tif (d[v].r > 0 && d[d[v].r].minVal <= k && d[d[v].r].maxVal >= k) {\n\t\treturn findKth(d[v].r, k);\n\t}\n\treturn findKth(d[v].l, k);\n}\n\nvoid write(int v) {\n\tpush(v);\n\tif (v == 0) {\n\t\treturn;\n\t}\n\twrite(d[v].l);\n\tcerr << ""("" << d[v].ver << "", "" << d[v].val << "") "";\n\twrite(d[v].r);\n}\n\ninline void move(int v, int k) {\n\tint h = getVal(v);\n\tint p1, p2, p3;\n\tsplitSize(root, getPos(v) - 1, p1, p2);\n\tint pv = findKth(p1, h - k);\n\tsplitSize(p2, getNum(last[v]), p2, p3);\n\td[p2].add -= (k - 1);\n\tpush(p2);\n\troot = merge(p1, p3);\n\tsplitSize(root, getNum(last[pv]) - 1, p1, p3);\n\td[++sz] = node(pv, h - k);\n\tp2 = merge(p2, sz);\n\troot = merge(p1, merge(p2, p3));\n}\n\nint main() {\n\tint n, m;\n\tscanf(""%d %d"", &n, &m);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint sz;\n\t\tscanf(""%d"", &sz);\n\t\tfor (int j = 0; j < sz; ++j) {\n\t\t\tint cur;\n\t\t\tscanf(""%d"", &cur);\n\t\t\t--cur;\n\t\t\tsons[i].pb(cur);\n\t\t}\n\t}\n\tsz = root = 0;\n\tdfs(0);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint t;\n\t\tscanf(""%d"", &t);\n\t\tif (t == 1) {\n\t\t\tint v, u;\n\t\t\tscanf(""%d %d"", &v, &u);\n\t\t\t--v;\n\t\t\t--u;\n\t\t\tprintf(""%d\\n"", getDist(v, u));\n\t\t\tcontinue;\n\t\t}\n\t\tif (t == 2) {\n\t\t\tint v, h;\n\t\t\tscanf(""%d %d"", &v, &h);\n\t\t\t--v;\n\t\t\tmove(v, h);\n\t\t\tcontinue;\n\t\t}\n\t\tint k;\n\t\tscanf(""%d"", &k);\n\t\tprintf(""%d\\n"", findKth(root, k) + 1);\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3200
A car number in Berland consists of exactly digits A number is called beautiful if it has at least equal digits Vasya wants to change the digits in his car s number so that the number became beautiful To replace one of digits Vasya has to pay the sum of money equal to the absolute difference between the old digit and the new one Help Vasya find the minimum sum of money he should pay to make the number of his car beautiful You should also find the resulting beautiful number If there are several such numbers then print the lexicographically minimum one ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\n#define NextLine() { char c = getchar(); while (c != 10 && c != EOF) { c = getchar(); } }\n\nint n, k;\nint cnt[10];\nstring old;\n\nvoid Load()\n{\n\tmemset(cnt, 0, sizeof(cnt));\n\tscanf(""%d%d"", &n, &k);\n\tint i;\n\told = """";\n\tfor (i = 0; i < n; i++)\n\t{\n\t\tchar c = getchar();\n\t\twhile (! ((c >= \'0\') && (c <= \'9\'))) c = getchar();\n\t\tcnt[c - \'0\']++;\n\t\told += c;\n\t}\n}\n\nvoid Solve()\n{\n\tint i;\n\tint best = 0x7F7F7F7F;\n\tstring bs = """";\n\tfor (i = 0; i <= 9; i++)\n\t{\n\t\t//cerr << ""i = "" << i << ""\\n"";\n\t\tint cur = 0;\n\t\tint j;\n\t\tint num[10];\n\t\tmemset(num, 0, sizeof(num));\n\t\tfor (j = 0; j <= 9; j++)\n\t\t{\n\t\t\tnum[abs(j - i)] += cnt[j];\n\t\t}\n\t\t/*for (j = 0; j <= 9; j++)\n\t\t{\n\t\t\tcerr << num[j] << "" "";\n\t\t}\n\t\tcerr << ""\\n"";*/\n\t\tint cr = k, pos = 0;\n\t\twhile (cr > 0)\n\t\t{\n\t\t\tif (num[pos] >= cr)\n\t\t\t{\n\t\t\t\tnum[pos] = cr;\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < 10) \n\t\t\t\t{\n\t\t\t\t\tnum[pos] = 0;\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcr -= num[pos];\n\t\t\tpos++;\n\t\t}\n\t\t/*cerr << ""num counted\\n"";\n\t\tfor (j = 0; j < 10; j++)\n\t\t{\n\t\t\tcerr << num[j] << "" "";\n\t\t}\n\t\tcerr << ""\\n"";*/\n\t\tstring neww = old;\n\t\tfor (j = 0; j < old.length(); j++)\n\t\t{\n\t\t\tif (num[abs((neww[j] - \'0\') - i)] > 0 &&\n\t\t\t\t(int)(neww[j] - \'0\') > i)\n\t\t\t{\n\t\t\t\tnum[abs((neww[j] - \'0\') - i)]--;\n\t\t\t\tcur += abs(neww[j] - \'0\' - i);\n\t\t\t\tneww[j] = (char)(i + \'0\');\n\t\t\t}\n\t\t}\n\t\tfor (j = old.length() - 1; j >= 0; j--)\n\t\t{\n\t\t\tif (num[abs((neww[j] - \'0\') - i)] > 0)\n\t\t\t{\n\t\t\t\tnum[abs((neww[j] - \'0\') - i)]--;\n\t\t\t\tcur += abs(neww[j] - \'0\' - i);\n\t\t\t\tneww[j] = (char)(i + \'0\');\n\t\t\t}\n\t\t}\n\t\tif (cur < best || (cur == best && neww < bs))\n\t\t{\n\t\t\tbest = cur;\n\t\t\tbs = neww;\n\t\t}\n\t}\n\tprintf(""%d\\n%s"", best, bs.c_str());\n}\n\nint main()\n{\n\tLoad();\n\tSolve();\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0]",1900
Iva gave Pav an array a of n elements Let s define f l r a l a l 1 dots a r here denotes the bitwise AND operation f l r l r Iva also gave Pav q queries Each query consists of 2 numbers k and l and she wants Pav to find the largest index r l le r le n such that f l r ge k Pav wants to solve this problem fast because he doesn t want to upset Iva He needs your help ,"['#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint a[200001], pre[200001][32];\ninline bool check(int l, int r, int k) {\n\tint ans = 0;\n\tfor (int i = 0; i ^ 32; ++i) {\n\t\tif (pre[r][i] - pre[l - 1][i] == r - l + 1)\n\t\t\tans |= 1 << i;\n\t}\n\treturn ans >= k;\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n, q;\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tcin >> a[i];\n\t\tcin >> q;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 0; j ^ 32; ++j)\n\t\t\t\tpre[i][j] = pre[i - 1][j] + (a[i] >> j & 1);\n\t\t}\n\t\tfor (; q--;) {\n\t\t\tint L, k;\n\t\t\tcin >> L >> k;\n\t\t\tif (a[L] < k) {\n\t\t\t\tcout << ""-1 "";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = L, r = n, mid;\n\t\t\tfor (; l < r;) {\n\t\t\t\tmid = l + r + 1 >> 1;\n\t\t\t\tif (check(L, mid, k))\n\t\t\t\t\tl = mid;\n\t\t\t\telse\n\t\t\t\t\tr = mid - 1;\n\t\t\t}\n\t\t\tcout << r << \' \';\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n}']","[1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1400
Once Petya read a problem about a bracket sequence He gave it much thought but didn t find a solution Today you will face it You are given string It represents a correct bracket sequence A correct bracket sequence is the sequence of opening and closing brackets such that it is possible to obtain a correct mathematical expression from it inserting numbers and operators between the brackets For example such sequences as and are correct bracket sequences and such sequences as and are not In a correct bracket sequence each bracket corresponds to the matching bracket an opening bracket corresponds to the matching closing bracket and vice versa For example in a bracket sequence shown of the figure below the third bracket corresponds to the matching sixth one and the fifth bracket corresponds to the fourth one You are allowed to color some brackets in the bracket sequence so as all three conditions are fulfilled Each bracket is either not colored any color or is colored red or is colored blue For any pair of matching brackets exactly one of them is colored In other words for any bracket the following is true either it or the matching bracket that corresponds to it is colored No two neighboring colored brackets have the same color Find the number of different ways to color the bracket sequence The ways should meet the above given conditions Two ways of coloring are considered different if they differ in the color of at least one bracket As the result can be quite large print it modulo ,"['#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <string>\n#include <queue>\n#include <map>\n#include <set>\n\n#define MAX 768\n#define MOD 1000000007\n\nusing namespace std;\nFILE *in; FILE *out;\n\nint n;\nchar a[MAX];\nlong long dyn[MAX][MAX][3][3];\n\nlong long recurse(int left, int right, int colL, int colR)\n{\n\tif (left > right)\n\t\treturn 1;\n\tif (dyn[left][right][colL][colR] != -1)\n\t\treturn dyn[left][right][colL][colR];\n\t\n\tlong long ans = 0;\n\tint cnt = 1;\n\tint idx = left + 1;\n\twhile (idx <= right)\n\t{\n\t\tif (a[idx] == \'(\') cnt++;\n\t\telse cnt--;\n\t\tif (cnt == 0) break;\n\t\tidx++;\n\t}\n\t// Color left\n\tif (colL != 1)\n\t\tans += (recurse(left + 1, idx - 1, 1, 0) * recurse(idx + 1, right, 0, colR)) % MOD;\n\tif (colL != 2)\n\t\tans += (recurse(left + 1, idx - 1, 2, 0) * recurse(idx + 1, right, 0, colR)) % MOD;\n\t\n\t// Color right\n\tif (idx == right)\n\t{\n\t\tif (colR != 1)\n\t\t\tans += recurse(left + 1, idx - 1, 0, 1);\n\t\tif (colR != 2)\n\t\t\tans += recurse(left + 1, idx - 1, 0, 2);\n\t}\n\telse\n\t{\n\t\tans += (recurse(left + 1, idx - 1, 0, 1) * recurse(idx + 1, right, 1, colR)) % MOD;\n\t\tans += (recurse(left + 1, idx - 1, 0, 2) * recurse(idx + 1, right, 2, colR)) % MOD;\n\t}\n\treturn dyn[left][right][colL][colR] = ans % MOD;\n}\n\nint main(void)\n{\n\tin = stdin; out = stdout;\n//\tin = fopen(""D.in"", ""rt""); out = fopen(""D.out"", ""wt"");\n\t\n\tfscanf(in, ""%s"", a);\n\tn = (int)strlen(a);\n\tmemset(dyn, -1, sizeof(dyn));\n\tfprintf(out, ""%d\\n"", (int)recurse(0, n - 1, 0, 0));\n\t\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
You are given an integer n and two sequences a 1 a 2 dots a n and b 1 b 2 dots b n Let s call a set of integers S such that S subseteq 1 2 3 dots n if for every element i of S the following condition is met for every j in 1 i 1 if a j divides a i then j is also included in S An empty set is always The of the set S is sum limits i in S b i You have to calculate the maximum possible of a set ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nstruct Flow {\n    static constexpr int INF = 1e9;\n    int n;\n    struct Edge {\n        int to, cap;\n        Edge(int to, int cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nconstexpr int inf = 1e9;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::mt19937 gen;\n    int n;\n    std::cin >> n;\n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    std::vector<int> last(101, -1);\n    Flow g(n + 2);\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (b[i] > 0) {\n            ans += b[i];\n            g.addEdge(n, i, b[i]);\n        } else {\n            g.addEdge(i, n + 1, -b[i]);\n        }\n        for (int j = 1; j <= a[i]; j++) {\n            if (a[i] % j == 0 && last[j] != -1) {\n                g.addEdge(i, last[j], inf);\n            }\n        }\n        last[a[i]] = i;\n    }\n    ans -= g.maxFlow(n, n + 1);\n    std::cout << ans << ""\\n"";\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
You are given a graph G with n vertices and m edges between them Initially graph H is the same as graph G Then you decided to perform the following actions If there exists a triple of vertices a b c of H such that there is an edge from a to b and an edge from b to c but there is no edge from a to c add an edge from a to c Repeat the previous step as long as there are such triples Note that the number of edges in H can be up to n 2 after performing the actions You also wrote some values on vertices of graph H More precisely vertex i has the value of a i written on it Consider a simple path consisting of k vertices with indexes v 1 v 2 ldots v k The length of such a path is k The value of that path is defined as sum i 1 k a v i A simple path is considered the longest if there is no other simple path in the graph with greater length Among all the longest simple paths in H find the one with the smallest value ,"['#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < \'0\' || c > \'9\') c = getchar();\n\twhile(c >= \'0\' && c <= \'9\') x = x * 10 + c - \'0\', c = getchar();\n\treturn x;\n}\nint n, m, a[200005], tot, cd[200005];\nstd::vector <int> ver[200005], nv[200005], vn[200005];\nint a1; long long a2;\nint dfn[200005], ds, low[200005], vis[200005], tp, st[200005], bel[200005];\nint c1[200005], c2[200005]; long long d1[200005], d2[200005];\nvoid tarjan(int x){\n\tdfn[x] = low[x] = ++ds;\n\tst[++tp] = x; vis[x] = 1;\n\tfor(auto v : ver[x]){\n\t\tif(!dfn[v]) tarjan(v), low[x] = std::min(low[x], low[v]);\n\t\telse if(vis[v]) low[x] = std::min(low[x], dfn[v]);\n\t}\n\tif(low[x] == dfn[x]){\n\t\ttot++;\n\t\twhile(st[tp] != x){\n\t\t\tvis[st[tp]] = 0;\n\t\t\tbel[st[tp]] = tot;\n\t\t\t--tp;\n\t\t}\n\t\tvis[x] = 0;\n\t\tbel[x] = tot;\n\t\t--tp;\n\t}\n\treturn ;\n}\nvoid solve(){\n\tscanf(""%d%d"", &n, &m); a1 = 0, a2 = 1e18;\n\tfor(int i = 1; i <= n; ++i){\n\t\ta[i] = read(); ver[i].clear();\n\t\tdfn[i] = low[i] = vis[i] = bel[i] = 0;\n\t}\n\tds = tp = tot = 0;\n\tfor(int i = 1; i <= m; ++i){\n\t\tint x = read(), y = read();\n\t\tver[x].push_back(y);\n\t}\n\tfor(int i = 1; i <= n; ++i) if(!dfn[i]) tarjan(i);\n\tfor(int i = 1; i <= tot; ++i) vn[i].clear(), nv[i].clear(), c1[i] = c2[i] = d1[i] = d2[i] = 0;\n\tfor(int i = 1; i <= n; ++i) c1[bel[i]]++, d1[bel[i]] += 1ll * a[i];\n\tfor(int i = 1; i <= tot; ++i) cd[i] = 0;\n\tfor(int i = 1; i <= n; ++i) for(auto v : ver[i]){\n\t\t if(bel[i] == bel[v]) continue;\n\t\t nv[bel[i]].push_back(bel[v]), ++cd[bel[i]];\n\t\t vn[bel[v]].push_back(bel[i]);\n\t}\n\tstd::queue <int> q;\n\tfor(int i = 1; i <= tot; ++i) if(!cd[i]) q.push(i);\n\twhile(q.size()){\n\t\tint u = q.front(); q.pop();\n\t\tif(!nv[u].size()){\n\t\t\tc2[u] = c1[u];\n\t\t\td2[u] = d1[u];\n\t\t\tfor(auto v : vn[u]){\n\t\t\t\t--cd[v];\n\t\t\t\tif(cd[v] == 0) q.push(v);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tfor(auto v : nv[u]){\n\t\t\tif(c1[u] + c2[v] > c2[u]){\n\t\t\t\tc2[u] = c1[u] + c2[v];\n\t\t\t\td2[u] = d1[u] + d2[v];\n\t\t\t}\n\t\t\telse if(c1[u] + c2[v] == c2[u]) d2[u] = std::min(d2[u], d1[u] + d2[v]);\n\t\t}\n\t\tfor(auto v :vn[u]){\n\t\t\t--cd[v];\n\t\t\tif(cd[v] == 0) q.push(v);\n\t\t}\n\t}\n\tfor(int i = 1; i <= tot; ++i)\n\t\tif(c2[i] > a1){\n\t\t\ta1 = c2[i];\n\t\t\ta2 = d2[i];\n\t\t}\n\t\telse if(c2[i] == a1) a2 = std::min(a2, d2[i]);\n\tprintf(""%d %lld\\n"", a1, a2);\n\treturn ;\n}\nint main(){\n\tint T = 1;\n\tscanf(""%d"", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n']","[0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2100
Amr bought a new video game Guess Your Way Out The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node Let s index all the leaf nodes from the left to the right from 1 to The exit is located at some node where the player doesn t know where the exit is so he has to guess his way out Amr follows simple algorithm to choose the path Let s consider infinite command string consisting of alternating characters and Amr sequentially executes the characters of the string using following rules Character means go to the left child of the current node Character means go to the right child of the current node If the destination node is already visited Amr skips current command otherwise he moves to the destination node If Amr skipped two consecutive commands he goes back to the parent of the current node before executing next command If he reached a leaf node that is not the exit he returns to the parent of the current node If he reaches an exit the game is finished Now Amr wonders if he follows this algorithm how many nodes he is going to visit before reaching the exit ,"['#include <cstdio>\nusing namespace std;\n\nint main() {\n    int h;\n    long long id;\n    scanf(""%d%I64d"", &h, &id);\n    long long s = 0;\n    long long ans = 0;\n    long long L = 1, R = 1LL << h;\n    int H = 0;\n    while (L != R) {\n        ans ++;\n        if (s == 0) {\n            long long len = (R - L + 1) / 2;\n            if (id <= L + len - 1) {\n                R = L + len - 1;\n            } else {\n                ans += (1LL << (h - H)) - 1;\n                L += len;\n                s = 1 - s;\n            }\n        } else {\n            long long len = (R - L + 1) / 2;\n            if (id >= L + len) {\n                L += len;\n            } else {\n                ans += (1LL << (h - H)) - 1;\n                R = L + len - 1;\n                s = 1 - s;\n            }\n        }\n        s = 1 - s;\n        H ++;\n    }\n    printf(""%I64d\\n"", ans);\n    return 0;\n}']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1700
Santa has to send presents to the kids He has a large stack of n presents numbered from 1 to n the topmost present has number a 1 the next present is a 2 and so on the bottom present has number a n All numbers are distinct Santa has a list of m presents he has to send b 1 b 2 b m He will send them To send a present Santa has to find it in the stack by removing all presents above it taking this present and returning all removed presents on top of the stack So if there are k presents above the present Santa wants to send it takes him 2k 1 seconds to do it Fortunately Santa can speed the whole process up when he returns the presents to the stack he may reorder them as he wishes only those which were above the present he wanted to take the presents below cannot be affected in any way What is the minimum time required to send all of the presents provided that Santa knows the whole list of presents he has to send and reorders the presents optimally Santa cannot change the order of presents or interact with the stack of presents in any other way Your program has to answer t different test cases ,"['#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main() {\n#ifdef iq\n  freopen(""a.in"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  auto solve = [&] () {\n    int n, m;\n    cin >> n >> m;\n    vector <int> a(n);\n    vector <int> ind(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      a[i]--;\n      ind[a[i]] = i;\n    }\n    vector <int> b(m);\n    int mx = -1;\n    ll ans = 0;\n    for (int i = 0; i < m; i++) {\n      cin >> b[i];\n      b[i]--;\n      int x = ind[b[i]];\n      if (x > mx) {\n        mx = x;\n        ans += 2 * (x - i) + 1;\n      } else {\n        ans++;\n      }\n    }\n    cout << ans << \'\\n\';\n  };\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Inna likes sweets and a game called the Candy Matrix Today she came up with the new game Candy Matrix 2 Reload The field for the new game is a rectangle table of size Each line of the table contains one cell with a dwarf figurine one cell with a candy the other cells of the line are empty The game lasts for several moves During each move the player should choose and shout Let s go After that all the dwarves from the chosen lines start to move to the right During each second each dwarf goes to the adjacent cell that is located to the right of its current cell The movement continues until one of the following events occurs some dwarf in one of the chosen lines is located in the rightmost cell of his row some dwarf in the chosen lines is located in the cell with the candy The point of the game is to transport all the dwarves to the candy cells Inna is fabulous as she came up with such an interesting game But what about you Your task is to play this game optimally well Specifically you should say by the given game field what minimum number of moves the player needs to reach the goal of the game ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <limits>\n#include <tuple>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nint n, m;\nchar s[1010][1010];\nint main()\n{\n    scanf(""%d %d\\n"", &n, &m);\n    set<int> z;\n    for (int i=0;i<n;++i)\n    {\n        gets(s[i]);\n        int G=-1, S=-1;\n        for (int j=0;j<m;++j) if (s[i][j]==\'G\') G=j; else if (s[i][j]==\'S\') S=j;\n        if (S<G) { puts(""-1""); return 0; }\n        z.insert(S-G);\n    }\n    printf(""%d\\n"", int(z.size()));\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You are given an array a of length n The array is called if for all distinct indices i j k the sum a i a j a k is an element of the array More formally a is 3SUM closed if for all integers 1 leq i j k leq n there exists some integer 1 leq l leq n such that a i a j a k a l Determine if a is 3SUM closed ,"['#include<bits/stdc++.h>\nusing namespace std;\nint T,n,k,tot,fl,j,l,i,a[1000005];\nint main(){\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n;tot=0;\n\t\tfor(i=1;i<=n;++i){\n\t\t\tcin>>a[i];\n\t\t\tif(a[i]==0){\n\t\t\t\t++tot;\n\t\t\t\tif(tot>1){\n\t\t\t\t\t--i;--n;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(n>10){\n\t\t\tcout<<""NO\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tfl=0;tot=0;\n\t\t\tfor(i=1;i<=n;++i){\n\t\t\t\tfor(j=i+1;j<=n;++j){\n\t\t\t\t\tfor(k=j+1;k<=n;++k){\n\t\t\t\t\t\tfl=0;\n\t\t\t\t\t\tfor(l=1;l<=n;++l){\n\t\t\t\t\t\t\tif(a[l]==a[i]+a[j]+a[k]){\n\t\t\t\t\t\t\t\tfl=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(fl==0)++tot;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tot)cout<<""NO\\n"";\n\t\t\telse cout<<""YES\\n"";\n\t\t}\n\t}\n} ']","[0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300
You are given an unrooted tree with n vertices There is some hidden vertex x in that tree that you are trying to find To do this you may ask k queries v 1 v 2 ldots v k where the v i are vertices in the tree After you are finished asking all of the queries you are given k numbers d 1 d 2 ldots d k where d i is the number of edges on the shortest path between v i and x Note that you know which distance corresponds to which query What is the minimum k such that there exists some queries v 1 v 2 ldots v k that let you always uniquely identify x no matter what x is Note that you don t actually need to output these queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 5, INF = 1e9;\n\nvector<int> adj[N];\nint ans;\n\nint dfs(int u, int fa) {\n    int cnt = 0, cnt2 = 0;\n    for (auto v : adj[u]) {\n        if (v == fa) continue;\n        cnt += dfs(v, u);\n        ++cnt2;\n    }\n    if (cnt != cnt2 && adj[u].size() >= 3) --ans;\n    return (cnt > 0) | (adj[u].size() >= 3);\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T, n;\n    cin >> T;\n    while (T--) {\n        cin >> n;\n        \n        if (n == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        for (int i = 0; i < n; i++) adj[i].clear();\n\n        for (int i = 1; i < n; i++) {\n            int u, v;\n            cin >> u >> v;\n            --u; --v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n\n        ans = 0;\n        for (int i = 0; i < n; i++) ans += (adj[i].size() == 1);\n\n        int id = -1;\n        for (int i = 0; i < n; i++) {\n            if (adj[i].size() >= 3) {\n                id = i;\n                break;\n            }\n        }\n        if (id == -1) {\n            cout << 1 << endl;\n            continue;\n        }\n        dfs(id, id);\n        cout << ans << endl;\n    }\n    return 0;\n}']","[1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0]",2200
You are given n intervals and m points on the number line The i th intervals covers coordinates l i r i and the i th point is on coordinate i and has coefficient p i Initially all points are not activated You should choose a subset of the m points to activate For each of n interval we define its as 0 if there are no activated points in the interval the coefficient of the activated point with the within it otherwise Your task is to maximize the sum of the costs of all intervals by choosing which points to activate ,"['#include ""bits/stdc++.h""\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define ar array\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing pi = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nconst int INFi = 2e9;\nconst ll INF = 2e18;\n\nstruct Line {\n    ll k, b;\n\n    ll get(ll x) { return k * x + b; }\n\n    // returns the x-intercept of intersection ""strictly"" larger than T\n    ll cross_after(Line &L, ll T) {\n        assert(L.get(T) >= get(T));\n        if (L.k >= k) return INF;\n        if (L.b >= b) return (L.b - b + (k - L.k)) / (k - L.k);\n        return (L.b - b + 1) / (k - L.k);\n    }\n\n    Line(ll k_ = 0, ll b_ = INF) : k(k_), b(b_) {}\n};\n\nstruct KineticSegTree { // min kinetic segment tree\n    struct Node {\n        Line best;\n        ll melt;\n        ar<ll, 2> upd; // upd[0] - heaten, upd[1] - add x\n\n        Node() : best(), melt(INF), upd({0, 0}) {}\n    };\n\n    ll T;\n    int n;\n    vector<Node> t;\n\n    void apply(int v, ar<ll, 2> x) {\n        t[v].upd[0] += x[0];\n        t[v].upd[1] += x[1];\n        t[v].best.b += x[0] * t[v].best.k + x[1];\n        t[v].melt -= x[0];\n    }\n\n    bool IsBetter(Line &a, Line &b) {\n        ll l = a.get(T), r = b.get(T);\n        if (l != r)\n            return l < r;\n        return a.k < b.k;\n    }\n\n    void pull(int v) {\n        Line A = t[v << 1].best;\n        Line B = t[v << 1 | 1].best;\n        t[v].melt = min(t[v << 1].melt, t[v << 1 | 1].melt);\n        if (IsBetter(B, A)) swap(A, B);\n        t[v].best = A;\n        t[v].melt = min(t[v].melt, A.cross_after(B, T));\n    }\n\n    void init(vector<Line> &l, ll TT = 0) {\n        n = l.size();\n        T = TT;\n        t.resize(n * 4);\n        init(1, 0, n, l);\n    }\n\n    void init(int v, int l, int r, vector<Line> &lines) {\n        if (l + 1 == r) {\n            t[v].best = lines[l];\n            return;\n        }\n        init(v << 1, l, (l + r) >> 1, lines);\n        init(v << 1 | 1, (l + r) >> 1, r, lines);\n        pull(v);\n    }\n\n    void push(int v) {\n        if (!t[v].upd[0] && !t[v].upd[1]) return;\n        apply(v << 1, t[v].upd);\n        apply(v << 1 | 1, t[v].upd);\n        t[v].upd[0] = t[v].upd[1] = 0;\n    }\n\n    void propagate(int v) {\n        if (t[v].melt > 0) return;\n        push(v);\n        propagate(v << 1);\n        propagate(v << 1 | 1);\n        pull(v);\n    }\n\n    ll get(int v, int l, int r, int lq, int rq) {\n        if (rq <= l || r <= lq) return INF;\n        if (lq <= l && r <= rq) {\n            return t[v].best.get(T);\n        }\n        push(v);\n        return min(get(v << 1, l, (l + r) >> 1, lq, rq), get(v << 1 | 1, (l + r) >> 1, r, lq, rq));\n    }\n\n    ll get(int lq, int rq) {\n        return get(1, 0, n, lq, rq);\n    }\n\n    void upd(int v, int l, int r, int lq, int rq, ar<ll, 2> &x) {\n        if (rq <= l || r <= lq) return;\n        if (lq <= l && r <= rq) {\n            apply(v, x);\n            propagate(v);\n            return;\n        }\n        push(v);\n        upd(v << 1, l, (l + r) >> 1, lq, rq, x);\n        upd(v << 1 | 1, (l + r) >> 1, r, lq, rq, x);\n        pull(v);\n    }\n\n    void upd(int lq, int rq, ar<ll, 2> x) {\n        upd(1, 0, n, lq, rq, x);\n    }\n\n    void heaten(int lq, int rq, ll x) {\n        upd(lq, rq, {x, 0});\n    }\n\n    void add(int lq, int rq, ll x) {\n        upd(lq, rq, {0, x});\n    }\n};\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int m;\n    cin >> m;\n    vi l(n), r(n);\n    rep(i, n) {\n        cin >> l[i] >> r[i];\n    }\n    vector<Line> a(m + 1, {0, 0});\n    for (int i = 1; i <= m; ++i) {\n        cin >> a[i].k;\n        a[i].k *= -1;\n    }\n    KineticSegTree kst;\n    kst.init(a, 0);\n    vi ord(n);\n    iota(all(ord), 0);\n    sort(all(ord), [&](const int &i, const int &j) { return r[i] < r[j]; });\n    int j = 0;\n    for (int i = 1; i <= m; ++i) {\n        ll ans = kst.get(0, i);\n        kst.add(i, i + 1, ans);\n        while (j < n && r[ord[j]] == i) {\n            kst.heaten(l[ord[j]], r[ord[j]] + 1, 1);\n            j++;\n        }\n    }\n    cout << -kst.get(0, m + 1) << \'\\n\';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n     cin >> t;\n    rep(_, t) {\n        solve();\n    }\n    return 0;\n}']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3200
You are given a string of length with each character being one of the first lowercase English letters Calculate how many different strings of length composed from the first lowercase English letters exist such that the length of LCS longest common subsequence between and is Recall that LCS of two strings and is the longest string such that both in and as a subsequence ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 100100;\nchar s[N];\nll a[N];\nll b[N];\nint n;\nll m;\nll ans = 0;\n\nint main()\n{\n//  freopen(""input.txt"", ""r"", stdin);\n//  freopen(""output.txt"", ""w"", stdout);\n\n    scanf(""%d%lld"", &n, &m);\n    scanf("" %s "", s);\n    m--;\n    for (int i = 1; i < n; i++)\n        if (s[i] != s[i - 1])\n            b[i] = 1;\n    b[n] = 0;\n    for (int i = n - 1; i >= 0; i--)\n        b[i] += b[i + 1];\n    ans = 0;\n    for (int i = 0; i < n; i++)\n        ans += m * (b[i + 1] + 1);\n    for (int i = 0; i < n; i++)\n        b[i] = 0;\n    for (int i = 0; i < n - 1; i++)\n        if (s[i] != s[i + 1])\n            b[i + 1] = 1;\n    for (int i = 1; i <= n; i++)\n        b[i] += b[i - 1];\n    for (int i = 1; i < n; i++)\n        ans += m * b[i];\n    \n    int r = 0;\n    for (int l = 0; l < n - 1; l++)\n    {\n        if (s[l] == s[l + 1]) continue;\n        r = max(r, l + 2);\n        while(r < n && s[r] == s[r - 2]) r++;\n        ans -= r - l - 1;\n    }\n    \n    printf(""%lld\\n"", ans);\n\n    return 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
Each year in the castle of Dwarven King there is a competition in growing mushrooms among the dwarves The competition is one of the most prestigious ones and the winner gets a wooden salad bowl This year s event brought together the best mushroom growers from around the world so we had to slightly change the rules so that the event gets more interesting to watch Each mushroom grower has a mushroom that he will grow on the competition Under the new rules the competition consists of two parts The first part lasts seconds and the second part lasts seconds The first and the second part are separated by a little break After the starting whistle the first part of the contest starts and all mushroom growers start growing mushrooms at once each at his individual speed of meters per second After seconds the mushroom growers stop growing mushrooms and go to have a break During the break for unexplained reasons the growth of all mushrooms is reduced by percent After the break the second part of the contest starts and all mushrooms growers at the same time continue to grow mushrooms each at his individual speed of meters per second After a seconds after the end of the break the competition ends Note that the speeds before and after the break may vary Before the match dwarf Pasha learned from all participants what two speeds they have chosen However the participants did not want to disclose to him all their strategy and therefore did not say in what order they will be using these speeds That is if a participant chose speeds and then there are two strategies he either uses speed before the break and speed after it or vice versa Dwarf Pasha really wants to win the totalizer He knows that each participant chooses the strategy that maximizes the height of the mushroom Help Dwarf Pasha make the final table of competition results The participants are sorted in the result table by the mushroom height the participants with higher mushrooms follow earlier in the table In case of equal mushroom heights the participants are sorted by their numbers the participants with a smaller number follow earlier ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <memory.h>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\nusing namespace std;\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,(int)(v).size())\n#define iinf 1000000000\n#define linf 1000000000000000000LL\n#define dinf 1e200\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define mp make_pair\n#define lng long long\n#define eps 1e-11\n#define EQ(a,b) (fabs((a)-(b))<eps)\n#define SQ(a) ((a)*(a))\n#define PI 3.14159265359\n#define index asdindex\n#define FI first\n#define SE second\n#define prev asdprev\n#define ends asdends\n#define PII pair<int,int> \n#define X first\n#define Y second\n#define mset(a,b) memset(a,b,sizeof(a))\n\n\n\n\nlng v1[1010], v2[1010];\n\npair<lng, int> heights[1010];\n\nlng grow(lng v1, lng v2,  lng t1, lng t2, lng k){\n    lng res = t1*v1;\n    res=res/100*(100-k);\n    res+=v2*t2;\n    return res;\n}\n\nint main(){\n#ifdef __ASD__\n    freopen(""input.txt"",""r"",stdin);freopen(""output.txt"",""w"",stdout);\n#endif\n    //ios::sync_with_stdio(false);\n    int n;\n    lng t1, t2, k;\n    cin >> n >> t1 >> t2 >> k;\n\n    forn(i,n){\n        cin >> v1[i] >> v2[i];\n        v1[i]*=100;\n        v2[i]*=100;\n        heights[i] = mp(-max(grow(v1[i], v2[i], t1, t2, k), grow(v2[i], v1[i], t1, t2, k)), i);\n    }\n    sort(heights, heights+n);\n    for(int i=0;i<n;++i){\n        heights[i].first*=-1;\n        cout << heights[i].second+1;\n        cout <<"" "";\n        cout << heights[i].first/100;\n        cout <<""."";\n        printf(""%02d\\n"", (int)(heights[i].first%100));\n    }\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1200
Alice and Bob like games And now they are ready to start a new game They have placed chocolate bars in a line Alice starts to eat chocolate bars one by one from left to right and Bob from right to left For each chocololate bar the time needed for the player to consume it is known Alice and Bob eat them with equal speed When the player consumes a chocolate bar he immediately starts with another It is not allowed to eat two chocolate bars at the same time to leave the bar unfinished and to make pauses If both players start to eat the same bar simultaneously Bob leaves it to Alice as a true gentleman How many bars each of the players will consume ,"['#include <cstdio>\nusing namespace std;\nint t[1000*128];\nint n;\n\nint main() {\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++)\n        scanf(""%d"",&t[i]);\n    int i=-1,j=n,ti=0,tj=0,ci=0,cj=0;\n    while(i<j-1) {\n        if (ti<=tj) {\n            i++;\n            ti+=t[i];\n            ci++;\n        } else {\n            j--;\n            tj+=t[j];\n            cj++;\n        }\n    }\n    printf(""%d %d\\n"",ci,cj);\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
A running competition is going to be held soon The stadium where the competition will be held can be represented by several segments on the coordinate plane two horizontal segments one connecting the points 0 0 and x 0 the other connecting the points 0 y and x y n 1 vertical segments numbered from 0 to n The i th segment connects the points a i 0 and a i y 0 a 0 a 1 a 2 dots a n 1 a n x For example here is a picture of the stadium with x 10 y 5 n 3 and a 0 3 5 10 A is a route that goes along the segments starts and finishes at the same point and never intersects itself the only two points of a lap that coincide are its starting point and ending point The length of a lap is a total distance travelled around it For example the red route in the picture representing the stadium is a lap of length 24 The competition will be held in q stages The i th stage has length l i and the organizers want to choose a lap for each stage such that the length of the lap is a The organizers don t want to choose short laps for the stages so for each stage they want to find the maximum possible length of a suitable lap Help the organizers to calculate the maximum possible lengths of the laps for the stages In other words for every l i find the maximum possible integer L such that l i bmod L 0 and there exists a lap of length L If it is impossible to choose such a lap then print 1 ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=(\'0\'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\ntemplate<unsigned mod=998244353>struct mint {\n   unsigned val;\n   static unsigned get_mod(){return mod;}\n   unsigned inv() const{\n      int tmp,a=val,b=mod,x=1,y=0;\n      while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n      if(x<0)x+=mod; return x;\n   }\n   mint():val(0){}\n   mint(ll x):val(x>=0?x%mod:mod+(x%mod)){}\n   mint pow(ll t){mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n   mint& operator+=(const mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n   mint& operator-=(const mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n   mint& operator*=(const mint& x){val=ll(val)*x.val%mod; return *this;}\n   mint& operator/=(const mint& x){val=ll(val)*x.inv()%mod; return *this;}\n   mint operator+(const mint& x)const{return mint(*this)+=x;}\n   mint operator-(const mint& x)const{return mint(*this)-=x;}\n   mint operator*(const mint& x)const{return mint(*this)*=x;}\n   mint operator/(const mint& x)const{return mint(*this)/=x;}\n   bool operator==(const mint& x)const{return val==x.val;}\n   bool operator!=(const mint& x)const{return val!=x.val;}\n};\ntemplate<unsigned mod=998244353>struct factorial {\n   using Mint=mint<mod>;\n   vector<Mint> Fact, Finv;\npublic:\n   factorial(int maxx){\n      Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*(i+1);\n      Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*i;\n   }\n   Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n   Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n   Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\nusing Mint=mint<>;\n\nvector<int> rt,irt;\ntemplate<unsigned mod=998244353>void init(int lg=21){\n   using Mint=mint<mod>; Mint prt=2;\n   while(prt.pow(mod>>1).val==1)prt+=1;\n   rt.resize(1<<lg,1); irt.resize(1<<lg,1);\n   rep(w,0,lg){\n      int mask=(1<<w)-1,t=Mint(-1).val>>w;\n      Mint g=prt.pow(t),ig=prt.pow(mod-1-t);\n      rep(i,0,mask){\n         rt[mask+i+1]=(g*rt[mask+i]).val;\n         irt[mask+i+1]=(ig*irt[mask+i]).val;\n      }\n   }\n}\n\ntemplate<unsigned mod=998244353>struct FPS{\n   using Mint=mint<mod>; vector<Mint> f;\n   FPS():f({1}){}\n   FPS(int _n):f(_n){}\n   FPS(vector<Mint> _f):f(_f){}\n   Mint& operator[](const int i){return f[i];}\n   Mint eval(Mint x){\n      Mint res,w=1;\n      for(Mint v:f)res+=w*v,w*=x; return res;\n   }\n   FPS inv()const{\n      assert(f[0]!=0); int n=f.size();\n      FPS res(n); res.f[0]=f[0].inv();\n      for(int k=1;k<n;k<<=1){\n         FPS g(k*2),h(k*2);\n         rep(i,0,min(k*2,n))g[i]=f[i]; rep(i,0,k)h[i]=res[i];\n         g.ntt(); h.ntt(); rep(i,0,k*2)g[i]*=h[i]; g.ntt(1);\n         rep(i,0,k)g[i]=0,g[i+k]*=-1;\n         g.ntt(); rep(i,0,k*2)g[i]*=h[i]; g.ntt(1);\n         rep(i,k,min(k*2,n))res[i]=g[i];\n      } return res;\n   }\n   void ntt(bool inv=0){\n        int n=f.size(); if(n==1)return;\n        if(inv){\n            for(int i=1;i<n;i<<=1){\n                for(int j=0;j<n;j+=i*2){\n                    rep(k,0,i){\n                        f[i+j+k]*=irt[i*2-1+k];\n                        const Mint tmp=f[j+k]-f[i+j+k];\n                        f[j+k]+=f[i+j+k]; f[i+j+k]=tmp;\n                    }\n                }\n            }\n            Mint mul=Mint(n).inv(); rep(i,0,n)f[i]*=mul;\n        }else{\n            for(int i=n>>1;i;i>>=1){\n                for(int j=0;j<n;j+=i*2){\n                    rep(k,0,i){\n                        const Mint tmp=f[j+k]-f[i+j+k];\n                        f[j+k]+=f[i+j+k]; f[i+j+k]=tmp*rt[i*2-1+k];\n                    }\n                }\n            }\n        }\n   }\n   FPS operator+(const FPS& g)const{return FPS(*this)+=g;}\n   FPS operator-(const FPS& g)const{return FPS(*this)-=g;}\n   FPS operator*(const FPS& g)const{return FPS(*this)*=g;}\n   template<class T>FPS operator*(T t)const{return FPS(*this)*=t;}\n   FPS operator/(const FPS& g)const{return FPS(*this)/=g;}\n   template<class T>FPS operator/(T t)const{return FPS(*this)/=t;}\n   FPS operator%(const FPS& g)const{return FPS(*this)%=g;}\n   FPS& operator+=(FPS g){\n      if(g.f.size()>f.size())f.resize(g.f.size());\n      rep(i,0,g.f.size())f[i]+=g[i]; return *this;\n   }\n   FPS& operator-=(FPS g){\n      if(g.f.size()>f.size())f.resize(g.f.size());\n      rep(i,0,g.f.size())f[i]-=g[i]; return *this;\n   }\n   FPS& operator*=(FPS g){\n      int m=f.size()+g.f.size()-1,n=1; while(n<m)n<<=1;\n      f.resize(n); g.f.resize(n);\n      ntt(); g.ntt(); rep(i,0,n)f[i]*=g[i]; \n      ntt(1); f.resize(m); return *this;\n   }\n   template<class T>FPS& operator*=(T t){for(Mint x:f)x*=t; return *this;}\n   FPS& operator/=(FPS g){\n      if(g.f.size()>f.size())return *this=FPS({0});\n      reverse(ALL(f)); reverse(ALL(g.f));\n      int n=f.size()-g.f.size()+1;\n      f.resize(n); g.f.resize(n); FPS mul=g.inv();\n      *this*=mul; f.resize(n); reverse(ALL(f)); return *this;\n   }\n   template<class T>FPS& operator/=(T t){for(Mint x:f)x/=t; return *this;}\n   FPS& operator%=(FPS g){\n      *this-=*this/g*g;\n      while(!f.empty()&&f.back()==0)f.pop_back();\n      return *this;\n   }\n   FPS sqrt(){\n      int n=f.size(); FPS res(1); res[0]=1;\n      for(int k=1;k<n;k<<=1){\n         FPS ff=*this; res.f.resize(k*2);\n         res+=ff/res; res/=2;\n      } res.f.resize(n); return res;\n   }\n   FPS diff(){\n      FPS res=*this; rep(i,0,res.f.size()-1)res[i]=res[i+1]*(i+1);\n      res.f.pop_back(); return res;\n   }\n   FPS inte(){\n      FPS res=*this; res.f.push_back(0);\n      rrep(i,res.f.size()-1,0)res[i]=res[i-1]/i;\n      res[0]=0; return res;\n   }\n   FPS log(){\n      assert(f[0]==1); FPS res=diff()*inv(); \n      res.f.resize(f.size()-1); res=res.inte(); return res;\n   }\n   FPS exp(){\n      assert(f[0]==0); int m=f.size(),n=1; while(n<m)n<<=1;\n      f.resize(n); FPS d=diff(),res(n); vector<FPS> pre;\n      for(int k=n;k;k>>=1){\n         FPS g=d; g.f.resize(k);\n         g.ntt(); pre.push_back(g);\n      }\n      auto dfs=[&](auto dfs,int l,int r,int dep)->void{\n         if(r-l==1){if(l>0)res[l]/=l; return;}\n         int m=(l+r)>>1; dfs(dfs,l,m,dep+1);\n         FPS g(r-l); rep(i,0,m-l)g[i]=res[l+i];\n         g.ntt(); rep(i,0,r-l)g[i]*=pre[dep][i]; g.ntt(1);\n         rep(i,m,r)res[i]+=g[i-l-1]; dfs(dfs,m,r,dep+1);\n      }; res[0]=1; dfs(dfs,0,n,0); res.f.resize(m); return res;\n   }\n};//need to initialize\n\nint n,t; int a[1010000];\nint cnt[501000]={};\nfactorial<> fact(501000);\nMint inv[501000];\n\nFPS<> substituteXplus(FPS<> A, Mint w) {\n   int n = (int)A.f.size();\n   for (int i = 0; i < n; i++)\n      A[i] *= fact.fact(i, 0);\n   vector<Mint> B(n);\n   Mint pw = 1;\n   for (int i = 0; i < n; i++) {\n      B[i] = pw * fact.fact(i, 1);\n      pw *= w;\n   }\n   reverse(all(B));\n   FPS<> C = A * FPS<>(B);\n   B = C.f;\n   rotate(B.begin(), B.begin() + n - 1, B.end());\n   B.resize(n);\n   for (int i = 0; i < n; i++)\n      B[i] *= fact.fact(i, 1);\n   return FPS<>(B);\n}\n/*\n   CALL INIT !!!\n*/\n\nconst int N = 500500;\nbool good[N];\nint ans[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tinit();\n\n\tint n, x, y;\n\tscanf(""%d%d%d"", &n, &x, &y);\n\tvector<Mint> a(x + 1);\n\tn++;\n\tfor (int i = 0; i <= x; i++)\n\t\ta[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint z;\n\t\tscanf(""%d"", &z);\n\t\ta[z] = 1;\n\t}\n\tvector<Mint> b = a;\n\treverse(all(b));\n\tFPS<> c = FPS<>(a) * FPS<>(b);\n\n\tfor (int i = 1; i <= x; i++)\n\t\tif (c[x + i].val != 0)\n\t\t\tgood[y + i] = 1;\n\n\tfor (int i = 0; i < N; i++)\n\t\tans[i] = -1;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (!good[i]) continue;\n\t\tfor (int j = i; j < N; j += i)\n\t\t\tans[j] = 2 * i;\n\t}\n\n\tint q;\n\tscanf(""%d"", &q);\n\twhile(q--) {\n\t\tint z;\n\t\tscanf(""%d"", &z);\n\t\tz /= 2;\n\t\tprintf(""%d "", ans[z]);\n\t}\n\tprintf(""\\n"");\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2600
Petya recently found a game Choose a Square In this game there are n points numbered from 1 to n on an infinite field The i th point has coordinates x i y i and cost c i You have to choose a square such that its sides are parallel to coordinate axes the lower left and upper right corners belong to the line y x and all corners have integer coordinates The score you get is the sum of costs of the points covered by the selected square minus the length of the side of the square Note that the length of the side can be zero Petya asks you to calculate the maximum possible score in the game that can be achieved by placing exactly one square ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = (int)1e6 + 100;\nint x[maxN], y[maxN], c[maxN];\nint bestX = 1.5e9;\nint bestY = bestX;\nll cost = 0;\nint idX[maxN], idY[maxN];\nint id[maxN];\nvector < int > events[maxN];\npair < ll, int > t[4 * maxN];\nll upd[4 * maxN];\nvoid build(int v, int tl, int tr) {\n    t[v] = make_pair(0, tl);\n    if (tl == tr) return;\n    int tm = (tl + tr) / 2;\n    build(2 * v, tl, tm);\n    build(2 * v + 1, tm + 1, tr);\n}\nvoid push(int v, int tl, int tr) {\n    if (upd[v] == 0) return;\n    t[v].first += upd[v];\n    if (tl != tr) {\n        upd[2 * v] += upd[v];\n        upd[2 * v + 1] += upd[v];\n    }\n    upd[v] = 0;\n}\nvoid add(int v, int tl, int tr, int l, int r, ll val) {\n    if (l <= tl && tr <= r) {\n        upd[v] += val;\n        push(v, tl, tr);\n        return;\n    }\n    push(v, tl, tr);\n    if (r < tl || l > tr) return;\n    int tm = (tl + tr) / 2;\n    add(2 * v, tl, tm, l, r, val);\n    add(2 * v + 1, tm + 1, tr, l, r, val);\n    t[v] = max(t[2 * v], t[2 * v + 1]);\n}\nconst ll INF = 2e18;\npair < ll, int > get_mx(int v, int tl, int tr, int l, int r) {\n    push(v, tl, tr);\n    if (l <= tl && tr <= r) return t[v];\n    if (l > r) return make_pair(-INF, -1);\n    int tm = (tl + tr) / 2;\n    return max(get_mx(2 * v, tl, tm, l, min(r, tm)), get_mx(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    cin >> n;\n    vector < int > cords;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> c[i];\n        if (x[i] < y[i]) swap(x[i], y[i]);\n        cords.push_back(x[i]);\n        cords.push_back(y[i]);\n    }\n    sort(cords.begin(), cords.end());\n    cords.erase(unique(cords.begin(), cords.end()), cords.end());\n    for (int i = 0; i < cords.size(); i++) {\n        id[i + 1] = cords[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        idX[i] = lower_bound(cords.begin(), cords.end(), x[i]) - cords.begin() + 1;\n        idY[i] = lower_bound(cords.begin(), cords.end(), y[i]) - cords.begin() + 1;\n        events[idX[i]].push_back(i);\n    }\n    int m = cords.size();\n    build(1, 1, m);\n    for (int i = 1; i <= cords.size(); i++) {\n        add(1, 1, m, i, i, id[i]);\n        for (int v : events[i]) {\n            add(1, 1, m, 1, idY[v], c[v]);\n        }\n        auto it = get_mx(1, 1, m, 1, i);\n        ll val = it.first - id[i];\n        if (val > cost) {\n            bestX = id[i];\n            bestY = id[it.second];\n            cost = val;\n        }\n    }\n    cout << cost << \'\\n\';\n    cout << bestY << "" "" << bestY << "" "" << bestX << "" "" << bestX;\n\n    return 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",2400
Petya has two strings and of the same length The strings consist only of lucky digits Petya can perform of two types replace any one digit from string by its opposite i e replace by and by swap any pair of digits in string Petya is interested in the minimum number of operations that are needed to make string equal to string Help him with the task ,"['#define _CRT_SECURE_NO_WARNINGS\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define REP(i,n) for (int i=0,_n=(n); i < _n; i++)\n#define REPD(i,n) for (int i=(n)-1; i >= 0; i--)\n#define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define ALL(c) (c).begin(), (c).end()\n#define SORT(c) sort(ALL(c))\n\n#define CLEAR(x) memset(x,0,sizeof x);\n#define CLEARA(x) memset(&x,0,sizeof x);\n#define FILL(x,v) memset(x,v,sizeof x);\n#define FILLA(x,v) memset(&x,v,sizeof x);\n\n#define VAR(a,b) __typeof(b) a=(b)\n#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)\n\n#define REVERSE(c) reverse(ALL(c))\n#define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())\n#define INF 0x7fffffff\n#define X first\n#define Y second\n#define pb push_back\n#define SZ(c) (int)(c).size()\n#define MP make_pair\n#define eps 1.0e-11\nconst double pi = acos(-1.0);\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef long long LL;\n\nint n;\nchar a[1024000];\nchar b[1024000];\n\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tgets(a);\n\tgets(b);\n\tn=strlen(a);\n\tint x=0,y=0;\n\tREP(i,n) if (a[i]!=b[i])\n\t\tif (a[i]==\'4\')\n\t\t\t++x;\n\t\telse\n\t\t\t++y;\n\tprintf(""%d\\n"",max(x,y));\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You are given a checkerboard of size 201 times 201 i e it has 201 rows and 201 columns The rows of this checkerboard are numbered from 100 to 100 from bottom to top The columns of this checkerboard are numbered from 100 to 100 from left to right The notation r c denotes the cell located in the r th row and the c th column There is a king piece at position 0 0 and it wants to get to position a b as soon as possible In this problem our king is lame Each second the king makes exactly one of the following five moves Skip move King s position remains unchanged Go up If the current position of the king is r c he goes to position r 1 c Go down Position changes from r c to r 1 c Go right Position changes from r c to r c 1 Go left Position changes from r c to r c 1 King is to make moves that put him outside of the board The important consequence of the king being lame is that he is to make the same move during two consecutive seconds For example if the king goes right the next second he can only skip go up down or left What is the minimum number of seconds the lame king needs to reach position a b ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int a, b;\n    std::cin >> a >> b;\n    \n    a = std::abs(a);\n    b = std::abs(b);\n    if (a < b) {\n        std::swap(a, b);\n    }\n    int ans = a + b + std::max(0, a - b - 1);\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
The sequence is called if it is non decreasing or non increasing For example sequnces 3 1 1 0 and 1 2 3 100 are ordered but the sequence 1 3 3 1 is not You are given a sequence of numbers You are to find it s shortest subsequence which is not ordered A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements ,"['#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<vector>\n#include<list>\n#include<set>\n#include<queue>\n#include<cassert>\n#include<sstream>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\n#define LET(x,a) \t__typeof(a) x(a)\n#define IFOR(i,a,b) \tfor(LET(i,a);i!=(b);++i)\n#define EACH(it,v)  \tIFOR(it,v.begin(),v.end())\n#define FOR(i,a,b)  \tfor(int i=(int)(a) ; i < (int)(b);++i)\n#define REP(i,n) \tFOR(i,0,n)\n#define PB\t\tpush_back\n#define MP \t\tmake_pair\n#define EPS\t\t1e-9\n#define INF 2000000000\n\ntypedef vector<int>\tVI;\ntypedef long long\tLL;\ntypedef pair<int,int>\tPI;\n\nint arr[100005],min1[100005],min2[100005],max1[100005],max2[100005];\nint minind1[100005],minind2[100005],maxind1[100005],maxind2[100005];\n\nint main(){\n\tint n;cin>>n;\n\tREP(i,n){\n\t\tcin>>arr[i];\n\t\tif(i){\n\t\t\tif(arr[i]<min1[i-1]){\n\t\t\t\tmin1[i] = arr[i];\n\t\t\t\tminind1[i] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin1[i] = min1[i-1];\n\t\t\t\tminind1[i] = minind1[i-1];\n\t\t\t}\n\t\t\tif(arr[i]>max1[i-1]){\n\t\t\t\tmax1[i] = arr[i];\n\t\t\t\tmaxind1[i] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax1[i] = max1[i-1];\n\t\t\t\tmaxind1[i] = maxind1[i-1];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tmin1[i] = arr[i];\n\t\t\tminind1[i] = i;\n\t\t\tmaxind1[i] = i;\n\t\t\tmax1[i] = arr[i];\n\t\t}\n\t}\n\tfor(int i = n-1;i>=0;i--){\n\t\tif(i==n-1){\n\t\t\tmax2[i]=min2[i] = arr[i];\n\t\t\tminind2[i] = i;\n\t\t\tmaxind2[i] = i;\n\t\t}\n\t\telse {\n\t\t\tif(arr[i]>max2[i+1]){\n\t\t\t\tmax2[i] = arr[i];\n\t\t\t\tmaxind2[i] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax2[i] = max2[i+1];\n\t\t\t\tmaxind2[i] = maxind2[i+1];\n\t\t\t}\n\t\t\tif(arr[i]<min2[i+1]){\n\t\t\t\tmin2[i] = arr[i];\n\t\t\t\tminind2[i] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin2[i] = min2[i+1];\n\t\t\t\tminind2[i] = minind2[i+1];\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tint i1,i2,i3;\n\tFOR(i,1,n-1){\n\t\tif(min1[i-1]<arr[i] && min2[i+1]<arr[i]){\n\t\t\tans = 3;\n\t\t\ti1 = minind1[i-1];\n\t\t\ti2 = i;\n\t\t\ti3 = minind2[i+1];\n\t\t}\n\t\tif(max1[i-1]>arr[i] && max2[i+1]>arr[i]){\n\t\t\tans = 3;\n\t\t\ti1 = maxind1[i-1];\n\t\t\ti2 = i;\n\t\t\ti3 = maxind2[i+1];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\tif(ans)cout<<i1+1<<"" ""<<i2+1<<"" ""<<i3+1<<endl;\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Oleg s favorite subjects are History and Math and his favorite branch of mathematics is division To improve his division skills Oleg came up with t pairs of integers p i and q i and for each pair decided to find the integer x i such that p i is divisible by x i x i is not divisible by q i Oleg is really good at division and managed to find all the answers quickly how about you ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn\'t exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr("" ""); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << "", "";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\n/**\n * Description: Factors integers.\n * Time: O(\\sqrt N)\n * Source: Own\n * Verification: https://csacademy.com/contest/ceoi-2018-day-2/task/toys-big/\n */\n\nnamespace factorBasic {\n\ttemplate<class T> vector<pair<T,int>> factor(T x) { \n\t\tvector<pair<T,int>> pri;\n\t\tfor (T i = 2; i*i <= x; ++i) if (x % i == 0) {\n\t\t\tint t = 0;\n\t\t\twhile (x % i == 0) x /= i, t ++;\n\t\t\tpri.pb({i,t});\n\t\t}\n\t\tif (x > 1) pri.pb({x,1});\n\t\treturn pri;\n\t}\n\t/* Note:\n\t * number of operations needed s.t.\n\t *\t\t\t\t  phi(phi(...phi(n)...))=1\n\t * is O(log n).\n\t * Euler\'s theorem: a^{\\phi(p)}\\equiv 1 (mod p), gcd(a,p)=1\n\t */\n\tll phi(ll x) {\n\t\ttrav(a,factor(x)) x -= x/a.f;\n\t\treturn x;\n\t}\n\ttemplate<class T> void tour(vector<pair<T,int>>& v, \n\t\tvector<T>& V, int ind, T cur) {\n\t\t\tif (ind == sz(v)) V.pb(cur);\n\t\t\telse {\n\t\t\t\tT mul = 1;\n\t\t\t\tF0R(i,v[ind].s+1) {\n\t\t\t\t\ttour(v,V,ind+1,cur*mul);\n\t\t\t\t\tmul *= v[ind].f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ttemplate<class T> vector<T> getDivi(T x) {\n\t\tauto v = factor(x);\n\t\tvector<T> V; tour(v,V,0,(T)1); sort(all(V));\n\t\treturn V;\n\t}\n}\n\nusing namespace factorBasic;\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) {\n\t\tll p,q; re(p,q);\n\t\tif (p%q == 0) {\n\t\t\tV<pair<ll,int>> v = factor(q);\n\t\t\tll ans = 0;\n\t\t\ttrav(t,v) {\n\t\t\t\tll P = p;\n\t\t\t\twhile (P%q == 0) P /= t.f;\n\t\t\t\tckmax(ans,P);\n\t\t\t}\n\t\t\tps(ans);\n\t\t} else {\n\t\t\tps(p);\n\t\t}\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]",1500
Andryusha goes through a park each day The squares and paths between them look boring to Andryusha so he decided to decorate them The park consists of squares connected with bidirectional paths in such a way that any square is reachable from any other using these paths Andryusha decided to hang a colored balloon at each of the squares The baloons colors are described by positive integers starting from In order to make the park varicolored Andryusha wants to choose the colors in a special way More precisely he wants to use such colors that if and are distinct squares that and have a direct path between them and and have a direct path between them then balloon colors on these three squares are distinct Andryusha wants to use as little different colors as possible Help him to choose the colors ,"['#pragma comment(linker, ""/STACK:1000000000"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <memory>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <ctime> \n#include <stack>\n\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n\n\nconst int MAXN = 200001;\nvector <int> e[MAXN];\nint ans[MAXN];\n\nvoid dfs(int v, int p)\n{\n\tint c = 0;\n\tfor (int i = 0; i < e[v].size(); i++)\n\t{\n\t\tint u = e[v][i];\n\t\tif (u == p) continue;\n\t\tc++;\n\t\twhile ((c == ans[v]) || (c == ans[p])) c++;\n\t\tans[u] = c;\n\t\tdfs(u, v);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n\tint n;\n\tcin >> n;\n\tint mv = 1;\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\t\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tif (e[i].size() > e[mv].size()) mv = i;\n\t}\n\tans[mv] = 1;\n\tfor (int i = 0; i < e[mv].size(); i++)\n\t{\n\t\tans[e[mv][i]] = i + 2;\n\t\tdfs(e[mv][i], mv);\n\t}\n\tcout << e[mv].size() + 1 << endl;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tcout << ans[i] << "" "";\n\t}\n\tcout << endl;\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0]",1600
Penguin Xoriy came up with a new game recently He has icicles numbered from to Each icicle has a temperature an integer from to of these icicles are special their temperature is while a temperature of all the others is You have to find those special icicles You can choose a subset of icicles and ask the penguin what is the bitwise exclusive OR of the temperatures of the icicles in this subset Note that you can t ask more than questions You are to find the special icicles ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint a[1010];\nint cnt;\nint n,x,y;\nint ask()\n{\n\tint i;\n\tprintf(""? %d "",cnt);\n\tfor(i=1;i<=cnt;i++)\n\t\tprintf(""%d "",a[i]);\n\tprintf(""\\n"");\n\tfflush(stdout);\n\tint s;\n\tscanf(""%d"",&s);\n\treturn s;\n}\nint main()\n{\n\tscanf(""%d%d%d"",&n,&x,&y);\n\tint m=0;\n\tint s,p;\n\tint i,j;\n\tint num;\n\tint ans1=0,ans2=0;\n\tfor(i=1;i<=15;i++)\n\t\tif(n&(1<<(i-1)))\n\t\t\tm=i;\n\tfor(i=m;i>=1;i--)\n\t{\n\t\tcnt=0;\n\t\tnum=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j&(1<<(i-1)))\n\t\t\t{\n\t\t\t\ta[++cnt]=j;\n\t\t\t\tnum^=x;\n\t\t\t}\n\t\tif(cnt)\n\t\t{\n\t\t\ts=ask();\n\t\t\tif(s!=num)\n\t\t\t{\n\t\t\t\tp=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tans2|=1<<(p-1);\n\tfor(i=p-1;i>=1;i--)\n\t{\n\t\tcnt=0;\n\t\tnum=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j&(1<<(i-1))&&j&(1<<(p-1)))\n\t\t\t{\n\t\t\t\ta[++cnt]=j;\n\t\t\t\tnum^=x;\n\t\t\t}\n\t\tif(cnt)\n\t\t{\n\t\t\ts=ask();\n\t\t\tif(s!=num)\n\t\t\t\tans2|=1<<(i-1);\n\t\t}\n\t}\n\tfor(i=p-1;i>=1;i--)\n\t{\n\t\tcnt=0;\n\t\tnum=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j&(1<<(i-1))&&!(j&(1<<(p-1))))\n\t\t\t{\n\t\t\t\ta[++cnt]=j;\n\t\t\t\tnum^=x;\n\t\t\t}\n\t\tif(cnt)\n\t\t{\n\t\t\ts=ask();\n\t\t\tif(s!=num)\n\t\t\t\tans1|=1<<(i-1);\n\t\t}\n\t}\n\tfor(i=p+1;i<=m;i++)\n\t{\n\t\tcnt=0;\n\t\tnum=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(j&(1<<(p-1))&&j&(1<<(i-1)))\n\t\t\t{\n\t\t\t\ta[++cnt]=j;\n\t\t\t\tnum^=x;\n\t\t\t}\n\t\tif(cnt)\n\t\t{\n\t\t\ts=ask();\n\t\t\tif(s!=num)\n\t\t\t{\n\t\t\t\tans1|=1<<(i-1);\n\t\t\t\tans2|=1<<(i-1);\n\t\t\t}\n\t\t}\n\t}\n\tif(ans1>ans2)\n\t\tswap(ans1,ans2);\n\tprintf(""! %d %d\\n"",ans1,ans2); \n\treturn 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2400
Dasha is fond of challenging puzzles Rubik s Cube and so on This time she has a cyclic table of size and each cell of the table contains a lowercase English letter Each cell has coordinates The table is cyclic means that to the right of cell there is the cell and to the down there is the cell Dasha has a pattern as well A pattern is a non cyclic table of size Each cell is either a lowercase English letter or a question mark Each cell has coordinates The goal of the puzzle is to find all the appearance positions of the pattern in the cyclic table We say that the cell of cyclic table is an appearance position if for every pair such that and one of the following conditions holds There is a question mark in the cell of the pattern or The cell of the cyclic table equals to the cell of the pattern Dasha solved this puzzle in no time as well as all the others she ever tried Can you solve it ,"['//看看会不会爆int!\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mkp make_pair\n#define fi first\n#define se second\n#define FOR(i, l, r) for(int i = l; i <= r; i++)\n#define ROF(i, r, l) for(int i = r; i >= l; i--)\n#define all(a) a.begin(), a.end()\ninline int ckmax(int &a, int b) { return a < b ? a = b, 1 : 0; }\ninline int ckmin(int &a, int b) { return a > b ? a = b, 1 : 0; }\n#define clean(a) memset(a, 0, sizeof(a))\ntypedef long long ll;\n\nconst double pi = acos(-1.0);\n//对时间要求不高可以直接typedef complex<double> Comp;\nstruct Comp{\n  double x, y;\n  Comp(): x(0), y(0) {}\n  Comp(double _x, double _y): x(_x), y(_y) {}\n  Comp operator + (const Comp &rhs) const {\n    return Comp(x + rhs.x, y + rhs.y);\n  }\n  Comp operator - (const Comp &rhs) const {\n    return Comp(x - rhs.x, y - rhs.y);\n  }\n  Comp operator * (const Comp &rhs) const {\n    return Comp(x * rhs.x - y * rhs.y, x * rhs.y + y * rhs.x);\n  }\n  Comp &operator += (const Comp &rhs) {\n    x += rhs.x; y += rhs.y;\n    return *this;\n  }\n  Comp &operator -= (const Comp &rhs) {\n    x -= rhs.x; y -= rhs.y;\n    return *this;\n  }\n  Comp conj() const {\n    return Comp(x, -y);\n  }\n};\nconst int MAXN = 1 << 21;\nComp X[MAXN], Y[MAXN], Z[MAXN];\nint bitrev[MAXN];\n\nvoid FFT(Comp A[], int n, int o){\n\tfor(int i = 0; i < n; i++) if(bitrev[i] < i) swap(A[bitrev[i]], A[i]);\n\tfor(int s = 0; 1 << s <= n; s++){\n\t\tint m = 1 << s;\n\t\tdouble ang = 2 * pi / m * o;\n\t\tComp od = Comp(cos(ang), sin(ang));\n\t\tfor(int k = 0; k < n; k += m){\n\t\t\tComp w = Comp(1.0, 0);\n\t\t\tfor(int j = 0; j < m / 2; j++){\n\t\t\t\tComp t = w * A[k + j + m / 2];\n\t\t\t\tA[k + j + m / 2] = A[k + j] - t;\n\t\t\t\tA[k + j] = A[k + j] + t;\n\t\t\t\tw = w * od;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid conv(int x[], int n, int y[], int m, ll z[]){\n  int l = 0;\n  while ((1 << l) < n + m - 1) ++l;\n  int s = 1 << l;\n  for (int i = 0; i < s; ++i)\n    bitrev[i] = bitrev[i >> 1] >> 1 | ((i & 1) << (l - 1));\n  for (int i = 0; i < s; ++i){\n\t\tX[i] = Comp(i < n ? x[i] : 0, 0);\n\t\tY[i] = Comp(i < m ? y[i] : 0, 0);\n  }\n  FFT(X, s, 1); FFT(Y, s, 1);\n\tfor(int i = 0; i < s; ++i) Z[i] = X[i] * Y[i];\n  FFT(Z, s, -1);\n  for (int i = 0; i < s; ++i)\n\t\tz[i] = ll(Z[i].x / s + 0.5);\n}\n\nint n, m, r, c;\nint a[1000][1000], b[1000][1000];\nchar s[1000];\nint f1[1000 * 1000], f2[1000 * 1000], g1[1000 * 1000], g2[1000 * 1000];\nll res1[MAXN], res2[MAXN];\n\nint main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(""x.in"", ""r"", stdin);\n\tfreopen(""x.out"", ""w"", stdout);\n#endif\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(""%s"", s);\n\t\tfor(int j = 0; j < m; ++j)\n\t\t\ta[i][j] = s[j] == \'?\' ? 0 : s[j] - \'a\' + 1;\n\t}\n\tscanf(""%d%d"", &r, &c);\n\tfor(int i = 0; i < r; ++i){\n\t\tscanf(""%s"", s);\n\t\tfor(int j = 0; j < c; ++j)\n\t\t\tb[r - i - 1][c - j - 1] = s[j] == \'?\' ? 0 : s[j] - \'a\' + 1;\n\t}\n\tll sum = 0;\n\tfor(int i = 0; i < 800; ++i)\n\t\tfor(int j = 0; j < 800; ++j){\n\t\t\tf1[i * 800 + j] = a[i % n][j % m] * a[i % n][j % m];\n\t\t\tf2[i * 800 + j] = a[i % n][j % m] * 2;\n\t\t\tif(i < r && j < c){\n\t\t\t\tg1[i * 800 + j] = b[i][j];\n\t\t\t\tg2[i * 800 + j] = b[i][j] * b[i][j];\n\t\t\t\tsum += b[i][j] * b[i][j] * b[i][j];\n\t\t\t}\n\t\t}\n\tconv(f1, 800 * 800, g1, 800 * 800, res1);\n\tconv(f2, 800 * 800, g2, 800 * 800, res2);\n\tfor(int i = 0; i < n; printf(""\\n""), ++i)\n\t\tfor(int j = 0; j < m; ++j){\n\t\t\tll res = res1[(i + r - 1) * 800 + j + c - 1] - res2[(i + r - 1) * 800 + j + c - 1] + sum;\n\t\t\tprintf(""%d"", res == 0 ? 1 : 0);\n\t\t}\n  return 0;\n}\n/*\n                   _ooOoo_\n                  o8888888o\n                  88"" . ""88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---\'\\____\n             .\'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  \'\'\\---/\'\'  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .\'  /--.--\\  `. . __\n      ."""" \'<  `.___\\_<|>_/___.\'  >\'"""".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-\'======\n                   `=---=\'\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n         佛祖保佑       永无BUG\n*/\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0]",2600
You are given array of length You may consecutively apply two operations to this array remove some subsegment continuous subsequence of length and pay for it coins change some elements of the array by at most and pay coins for each change Please note that each of operations may be applied at most once and may be not applied at all so you can remove only one segment and each number may be changed increased or decreased by at most Also note that you are not allowed to delete the whole array Your goal is to calculate the minimum number of coins that you need to spend in order to make the greatest common divisor of the elements of the resulting array be greater than ,"['#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1000100;\n\nint N, A, B;\nint arr[MAXN];\nint tval[MAXN];\nset <int> pfac;\n\nvoid run (int x)\n{\n    for (int i = 2; i * i <= x; i++)\n    {\n        if (x % i == 0)\n            pfac.insert(i);\n        while (x % i == 0)\n            x /= i;\n    }\n    if (x > 1)\n        pfac.insert(x);\n}\n\nll solve (int x)\n{\n    int mlo = N, mhi = -1;\n    for (int i = 0; i < N; i++)\n    {\n        int k = (arr[i] + 1) % x;\n        if (k == 1) tval[i] = 0;\n        else if (k == 0 || k == 2) tval[i] = 1;\n        else\n        {\n            mlo = min (mlo, i);\n            mhi = max (mhi, i);\n        }\n    }\n    \n    ll tot = 0;\n    for (int i = 0; i < N; i++)\n    {\n        if (i >= mlo && i <= mhi)\n            tot += A;\n        else tot += B * tval[i];\n    }\n    \n    if (mlo < N)\n    {\n        ll bhi = 0, btot = 0;\n        for (int i = mhi + 1; i < N; i++)\n        {\n            btot += A - tval[i] * B;\n            bhi = min (bhi, btot);\n        }\n        ll blo = 0;\n        btot = 0;\n        for (int i = mlo - 1; i >= 0; i--)\n        {\n            btot += A - tval[i] * B;\n            blo = min (blo, btot);\n        }\n        \n        return tot + blo + bhi;\n    }\n    else\n    {\n        ll bans = 0, bhi = 0, btot = 0;\n        for (int i = 0; i < N; i++)\n        {\n            btot += A - tval[i] * B;\n            bans = min (bans, btot - bhi);\n            bhi = max (bhi, btot);\n        }\n        return tot + bans;\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> N >> A >> B;\n    \n    for (int i = 0; i < N; i++)\n        cin >> arr[i];\n    \n    pfac.clear();\n    for (int i = -1; i <= 1; i++)\n    {\n        run (arr[0] + i);\n        run (arr[N-1] + i);\n    }\n    \n    ll ans = 1e17;\n    for (set<int>::iterator it = pfac.begin(); it != pfac.end(); it++)\n        ans = min (ans, solve (*it));\n    \n    cout << ans << ""\\n"";\n    //system (""Pause"");\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2300
Alex Bob and Carl will soon participate in a team chess tournament Since they are all in the same team they have decided to practise really hard before the tournament But it s a bit difficult for them because chess is a game for two players not three So they play with each other according to following rules Alex and Bob play the first game and Carl is spectating When the game ends the one who lost the game becomes the spectator in the next game and the one who was spectating plays against the winner Alex Bob and Carl play in such a way that there are no draws Today they have played games and for each of these games they remember who was the winner They decided to make up a log of games describing who won each game But now they doubt if the information in the log is correct and they want to know if the situation described in the log they made up was possible that is no game is won by someone who is spectating if Alex Bob and Carl play according to the rules Help them to check it ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << ""\\n""; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nint main() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = nxt();\n\t}\n\n\tint spec = 3;\n\tfor (int x : a) {\n\t\tif (x == spec) {\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t\tspec = 6 - x - spec;\n\t}\n\tputs(""YES"");\n\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
First rate specialists graduate from Berland State Institute of Peace and Friendship You are one of the most talented students in this university The education is not easy because you need to have fundamental knowledge in different areas which sometimes are not related to each other For example you should know linguistics very well You learn a structure of Reberland language as foreign language In this language words are constructed according to the following rules First you need to choose the root of the word some string which has more than letters Then several strings with the length or symbols are appended to this word The only restriction All these strings are considered to be suffixes of the word this time we use word suffix to describe a morpheme but not the few last characters of the string as you may used to Here is one exercise that you have found in your task list You are given the word Find all distinct strings with the length or which can be suffixes of this word according to the word constructing rules in Reberland language Two strings are considered distinct if they have different length or there is a position in which corresponding characters do not match Let s look at the example the word is given This word can be obtained in the following ways where the root of the word is overlined and suffixes are marked by corners Thus the set of possible suffixes for this word is ,"['#include <bits/stdc++.h>\n\n#define FO(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\nchar s[10005];\nint n;\nset<string> f;\n\nint bf[10005][5];\n\nstring gs(int a, int b) {\n    return string(s+a,s+b);\n}\n\nbool cf(int i, int l) {\n    if (i+l > n) return false;\n    if (i+l == n) return true;\n    if (bf[i][l] != -1) return bf[i][l];\n    FO(nl,2,4) {\n        if (cf(i+l,nl) && gs(i,i+l) != gs(i+l,i+l+nl)) {\n            return bf[i][l] = true;\n        }\n    }\n    return bf[i][l] = false;\n}\n\nint main() {\n    memset(bf,-1,sizeof bf);\n\n    scanf("" %s"", s);\n    n = strlen(s);\n    FO(i,5,n) {\n        FO(l,2,4) {\n            if (cf(i,l)) f.insert(gs(i,i+l));\n        }\n    }\n    printf(""%d\\n"", sz(f));\n    for (string r : f) printf(""%s\\n"", r.c_str());\n}\n\n']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1800
You are given segments on the coordinate axis and the number The point is if it belongs to at least segments Find the smallest by the number of segments set of segments on the coordinate axis which contains all points and no others ,"['/*\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 210000;\n\nusing namespace std;\n\nint n, k;\nvector<pair<int, int> > events;\nvector<pair<int, int> > ans;\nint cnt;\nint op;\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tint a, b;\n//\t\tcin >> a >> b;\n\t\tscanf(""%d"", &a);\n\t\tscanf(""%d"", &b);\n\t\tevents.push_back(make_pair(a, -1));\n\t\tevents.push_back(make_pair(b, 1));\n\t}\n\tsort(events.begin(), events.end());\n\n\tfor (int i = 0; i < events.size(); i++)\n\t{\n\t\tif (cnt == k - 1 && events[i].second == -1)//open\n\t\t{\n\t\t\top = events[i].first;\n\t\t}\n\t\tif (cnt == k&&events[i].second == 1)//close\n\t\t{\n\t\t\tans.push_back(make_pair(op, events[i].first));\n\t\t}\n\t\tcnt -= events[i].second;\n\t}\n\n\tcout << ans.size() << endl;\n\tfor (int i = 0; i < ans.size(); i++)\n\t{\n\t\tprintf(""%d %d\\n"", ans[i].first, ans[i].second);\n//\t\tcout << ans[i].first << "" "" << ans[i].second << ""\\n"";\n\t}\n\n\tcin.get(); cin.get();\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1800
Phone number in Berland is a sequence of digits Often to make it easier to memorize the number it is divided into groups of two or three digits For example the phone number is easier to remember as Your task is to find for a given phone number any of its divisions into groups of two or three digits ,"['#include <assert.h>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <list>\n#include <stack>\n#include <string.h>\n#include <stdlib.h>\n#include <vector>\n#include <utility>\n#include <list>\n#define INF 0x3fffffff\n#define LINF 0x3fffffffffffffffll\n#define DINF 1e100;\n\ntypedef long long ll;\n#define PII pair<int, int>\n#define PLL pair<ll, ll>\n#define PDD pair<double, double>\n#define PIL pair<int, ll>\n#define PLI pair<ll, int>\n#define PID pair<int, double>\n#define PDI pair<double, int>\n#define PLD pair<ll, double>\n#define PDL pair<double, ll>\n\n#define NUL(x) memset(x, 0, sizeof(x))\n#define MINUS(x) memset(x, 0xff, sizeof(x))\n#define PQ(x) priority_queue< x >  //highest first\n#define PQR(x) priority_queue< x , vector< x > , greater < x > > //lowest first\n#define MP make_pair\n#define PB push_back\n#define IT(x) for (typeof((x).begin()) it = (x).begin() ; it != (x).end() ; it++)\n#define IT2(x) for (typeof((x).begin()) it2 = (x).begin() ; it2 != (x).end() ; it2++)\n#define FOR(i, a, b) for (int i = (a) ; i< (b) ; i++)\n#define DEB(x...) fprintf(stderr,x);\n//#define DEB\n\nusing namespace std;\n\nbool testc(int tc=0)\n{\n\n}\n\nchar buf[150];\nint main()\n{\n  int n;\n  scanf(""%i "", &n);\n  gets(buf);\n  int i=0;\n  if (n%2)\n    {\n      printf(""%c"", buf[0]);\n      i++;\n    }\n  while(i<n)\n    {\n      printf(""%c%c"", buf[i], buf[i+1]);\n      i+=2;\n      if (i<n) printf(""-"");\n    }\n  printf(""\\n"");\n  return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Fox Ciel is playing a card game with her friend Fox Jiro There are piles of cards on the table And there is a positive integer on each card The players take turns and Ciel takes the first turn In Ciel s turn she takes a card from the top of any non empty pile and in Jiro s turn he takes a card from the bottom of any non empty pile Each player wants to maximize the total sum of the cards he took The game ends when all piles become empty Suppose Ciel and Jiro play optimally what is the score of the game ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nint b[123456];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  vector <int> a;\n  int x = 0, y = 0;\n  while (n--) {\n    int foo;\n    scanf(""%d"", &foo);\n    for (int i = 0; i < foo; i++) {\n      scanf(""%d"", b + i);\n    }\n    for (int i = 0; i < foo / 2; i++) {\n      x += b[i];\n      y += b[foo - (foo / 2) + i];\n    }\n    if (foo % 2 == 1) {\n      a.push_back(b[foo / 2]);\n    }\n  }\n  sort(a.begin(), a.end());\n  reverse(a.begin(), a.end());\n  for (int i = 0; i < (int)a.size(); i++)\n    if (i % 2 == 0) x += a[i];\n    else y += a[i];\n  printf(""%d %d\\n"", x, y);\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2000
Petya studies at university The current academic year finishes with n special days Petya needs to pass m exams in those special days The special days in this problem are numbered from 1 to n There are three values about each exam s i the day when questions for the i th exam will be published d i the day of the i th exam s i d i c i number of days Petya needs to prepare for the i th exam For the i th exam Petya should prepare in days between s i and d i 1 inclusive There are three types of activities for Petya in each day to spend a day doing nothing taking a rest to spend a day passing exactly one exam or to spend a day preparing for exactly one exam So he can t pass prepare for multiple exams in a day He can t mix his activities in a day If he is preparing for the i th exam in day j then s i le j d i It is allowed to have breaks in a preparation to an exam and to alternate preparations for different exams in consecutive days So preparation for an exam is not required to be done in consecutive days Find the schedule for Petya to prepare for all exams and pass them or report that it is impossible ,"['#include <bits/stdc++.h>\n#define DIM 107\nusing namespace std;\n\nlong long n,m,d[DIM],c[DIM],k[DIM],is[DIM];\n\nvector<long long> blt[DIM];\n\npriority_queue<pair<long long,long long>,vector<pair<long long,long long> >,greater<pair<long long,long long> > > q;\n\nint main()\n{\n    cin>>n>>m;\n\n    for(int i = 1;i <= m;++i)\n    {\n        long long s;\n        cin>>s>>d[i]>>c[i];\n        blt[s].push_back(i);\n        is[d[i]] = i;\n    }\n\n    vector<long long> ans;\n    for(int i = 1; i <= n; ++i)\n    {\n       // cout<<i<<\' \';\n        for(auto j:blt[i])\n            q.push({d[j],j});\n\n      //  cout<<q.size()<<\' \';\n        if(is[i]!=0)\n        {\n            if(k[is[i]]<c[is[i]]) return cout<<-1,0;\n           // cout<<m+1<<""     "";\n            ans.push_back(m+1);\n           // q.pop();\n            continue;\n        }\n\n        while(q.size() && k[q.top().second] == c[q.top().second])\n            q.pop();\n\n        if(q.size() == 0) {ans.push_back(0);\n        //cout<<0<<""         "";\n        }\n        else\n        {\n            k[q.top().second]++;\n            ans.push_back(q.top().second);\n           // cout<<q.top().second<<""     "";\n        }\n\n        while(q.size() && k[q.top().second] == c[q.top().second])\n            q.pop();\n    }\n\n    for(auto i:ans) cout<<i<<\' \';\n    return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1700
There are cows playing poker at a table For the current betting phase each player s status is either or and does not change throughout the phase To increase the suspense a player whose current status is not may show his her hand to the table However so as not to affect any betting decisions he she may only do so if all other players have a status of either or The player s own status may be either or Find the number of cows that can currently show their hands without affecting any betting decisions ,"['#include <cstdio>\nconst\tint\tmaxn = 220000;\nchar\ta[maxn];\nint\tn, f1, f2, f3;\nint\tmain()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", a);\n\tf1 = f2 = f3 = 0;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tswitch(a[i])\n\t\t{\n\t\t\tcase \'A\': f1 ++; break;\n\t\t\tcase \'F\': f2 ++; break;\n\t\t\tcase \'I\': f3 ++; break;\n\t\t}\n\t}\n\tif (f3 > 1) {printf(""0\\n""); return 0;}\n\tif (f3 == 1) {printf(""1\\n""); return 0;}\n\tprintf(""%d\\n"", f1);\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1000
An important meeting is to be held and there are exactly n people invited At any moment any two people can step back and talk in private The same two people can talk several as many as they want times per meeting Each person has limited The sociability of the i th person is a non negative integer a i This means that after exactly a i talks this person leaves the meeting and does not talk to anyone else anymore If a i 0 the i th person leaves the meeting immediately after it starts A meeting is considered most if the maximum possible number of talks took place during it You are given an array of sociability a determine which people should talk to each other so that the total number of talks is as large as possible ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"")\n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint a[200005],n;\npriority_queue <pi> q;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        while(!q.empty()) q.pop();\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n            if(a[i]) q.push({a[i],i});\n        }\n        vecpi ans;\n        while(q.size() > 1) {\n            int idx1 = q.top().y; q.pop();\n            int idx2 = q.top().y; q.pop();\n            ans.pb({idx1,idx2});\n            a[idx1]--, a[idx2]--;\n            if(a[idx1]) q.push({a[idx1],idx1});\n            if(a[idx2]) q.push({a[idx2],idx2});\n        }\n        cout << ans.size() << \'\\n\';\n        for(pi i : ans) cout << i.x << \' \' << i.y << \'\\n\';\n    }\n}\n']","[1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1400
You are given a string s consisting of lowercase Latin letters and q queries for this string Recall that the substring s l r of the string s is the string s l s l 1 dots s r For example the substrings of are but not and There are two types of queries 1 pos c 1 le pos le s c is lowercase Latin letter replace s pos with c set s pos c 2 l r 1 le l le r le s calculate the number of distinct characters in the substring s l r ,"['#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << ""="" << (X) << endl;\n#else\n\t#define DBG(X)\n#endif\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::pair;\nusing std::swap;\nusing std::sort;\nusing std::lower_bound;\nusing std::unique;\n\nusing int64 = long long int;\nusing pii   = pair<int, int>;\nusing pii64 = pair<int64, int64>;\n\nconst int NIL = -1;\n\nvoid init_IO() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n}\n\nconst int MAX_N = (int)1e5 + 777;\nconst int A     = 26;\n\nint tree[2 * MAX_N], n;\n\nvoid solve() {\n\tstring str;\n\tcin >> str;\n\n\tn = len(str);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint code = str[i] - \'a\';\n\t\ttree[i + n] = 1 << code;\n\t}\n\n\tfor(int i = n - 1; i > 0; --i) {\n\t\ttree[i] = tree[2 * i] | tree[2 * i + 1];\n\t}\n\n\tint q;\n\tcin >> q;\n\n\twhile(q--) {\n\t\tint type;\n\t\tcin >> type;\n\n\t\tif(type == 1) {\n\t\t\tint pos;\n\t\t\tchar chr;\n\t\t\tcin >> pos >> chr;\n\t\t\t--pos;\n\t\t\tpos += n;\n\n\t\t\tint code = chr - \'a\';\n\t\t\ttree[pos] = 1 << code;\n\n\t\t\tfor(; pos > 0; pos /= 2)\n\t\t\t\ttree[pos / 2] = tree[pos] | tree[pos ^ 1];\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tcin >> l >> r;\n\t\t\t--l, --r;\n\t\t\tl += n, r += n;\n\t\t\t++r;\n\n\t\t\tint msk = 0;\n\n\t\t\twhile(l < r) {\n\t\t\t\tif(l & 1)\n\t\t\t\t\tmsk |= tree[l++];\n\n\t\t\t\tif(r & 1)\n\t\t\t\t\tmsk |= tree[--r];\n\n\t\t\t\tl /= 2;\n\t\t\t\tr /= 2;\n\t\t\t}\n\n\t\t\tint answ = 0;\n\n\t\t\tfor(int j = 0; j < A; ++j) {\n\t\t\t\tansw += (msk >> j) & 1;\n\t\t\t}\n\n\t\t\tcout << answ << \'\\n\';\n\t\t}\n\t}\n}\n\nint main() {\n\tinit_IO();\n\tsolve();\n\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Have you ever played Hanabi If not then you ve got to try it out This problem deals with a simplified version of the game Overall the game has 25 types of cards 5 distinct colors and 5 distinct values Borya is holding cards The game is somewhat complicated by the fact that everybody sees Borya s cards except for Borya himself Borya knows which cards he has but he knows nothing about the order they lie in Note that Borya can have multiple identical cards and for each of the 25 types of cards he knows exactly how many cards of this type he has The aim of the other players is to achieve the state when Borya knows the color and number value of each of his cards For that other players can give him hints The hints can be of two types color hints and value hints A color hint goes like that a player names some color and points at all the cards of this color Similarly goes the value hint A player names some value and points at all the cards that contain the value Determine what minimum number of hints the other players should make for Borya to be certain about each card s color and value ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 12345;\n\nint c[N], num[N];\nchar card[N];\nint mask[N];\n\nvector < pair <int, int> > p;\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  p.resize(n);\n  for (int i = 0; i < n; i++) {\n    scanf(""%s"", card);\n    c[i] = -1;\n    num[i] = 0;\n    if (card[0] == \'R\') c[i] = 0;\n    if (card[0] == \'G\') c[i] = 1;\n    if (card[0] == \'B\') c[i] = 2;\n    if (card[0] == \'Y\') c[i] = 3;\n    if (card[0] == \'W\') c[i] = 4;\n    num[i] = card[1] - \'1\';\n    p[i] = make_pair(c[i], num[i]);\n  }\n  sort(p.begin(), p.end());\n  p.resize(unique(p.begin(), p.end()) - p.begin());\n  n = p.size();\n  for (int i = 0; i < n; i++) {\n    c[i] = p[i].first;\n    num[i] = p[i].second;\n  }\n  int ans = 42;\n  for (int tn = 0; tn < (1 << 5); tn++) {\n    for (int tc = 0; tc < (1 << 5); tc++) {\n      vector <int> hints;\n      for (int i = 0; i < 5; i++) {\n        if (tn & (1 << i)) {\n          hints.push_back(i);\n        }\n      }\n      for (int i = 0; i < 5; i++) {\n        if (tc & (1 << i)) {\n          hints.push_back(~i);\n        }\n      }\n      int cnt = hints.size();\n      for (int i = 0; i < n; i++) {\n        mask[i] = 0;\n        for (int j = 0; j < cnt; j++) {\n          if (hints[j] >= 0) {\n            if (num[i] == hints[j]) {\n              mask[i] |= (1 << j);\n            }\n          } else {\n            if (c[i] == ~hints[j]) {\n              mask[i] |= (1 << j);\n            }\n          }\n        }\n      }\n      sort(mask, mask + n);\n      bool ok = true;\n      for (int i = 0; i < n - 1; i++) {\n        if (mask[i] == mask[i + 1]) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        if (cnt < ans) {\n          ans = cnt;\n        }\n      }\n    }\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Little Petya has recently started attending a programming club Naturally he is facing the problem of choosing a programming language After long considerations he realized that Java is the best choice The main argument in favor of choosing Java was that it has a very large integer data type called BigInteger But having attended several classes of the club Petya realized that not all tasks require using the BigInteger type It turned out that in some tasks it is much easier to use small data types That s why a question arises Which integer type to use if one wants to store a positive integer Petya knows only 5 integer types 1 occupies 1 byte and allows you to store numbers from to 2 occupies 2 bytes and allows you to store numbers from to 3 occupies 4 bytes and allows you to store numbers from to 4 occupies 8 bytes and allows you to store numbers from to 5 can store any integer number but at that it is not a primitive type and operations with it are much slower For all the types given above the boundary values are included in the value range From this list Petya wants to choose the smallest type that can store a positive integer Since BigInteger works much slower Peter regards it last Help him ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""a""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nstring n;\n\nvoid Load ()\n{\n    cin >> n;\n}\n\nbool operator < (const string &a, const string &b)\n{\n    if (a.size() < b.size()) return true;\n    if (b.size() < a.size()) return false;\n\n    for (int i = 0;i < a.size();i++)\n    {\n        if (a[i] < b[i]) return true;\n        if (b[i] < a[i]) return false;\n    }\n    return true;\n}\n\nvoid Solve ()\n{\n    string b = ""127"";\n    string s = ""32767"";\n    string i = ""2147483647"";\n    string l = ""9223372036854775807"";\n\n    if (n < b) cout << ""byte"";\n    else if (n < s) cout << ""short"";\n    else if (n < i) cout << ""int"";\n    else if (n < l) cout << ""long"";\n    else cout << ""BigInteger"";\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1300
You are playing a board card game In this game the player has two characteristics and the white magic skill and the black magic skill respectively There are spell cards lying on the table each of them has four characteristics and In one move a player can pick one of the cards and cast the spell written on it but only if first two of it s characteristics meet the requirement and i e if the player has enough magic skill to cast this spell However after casting the spell the characteristics of a player change and become equal to and At the beginning of the game both characteristics of a player are equal to zero The goal of the game is to cast the th spell Your task is to make it in as few moves as possible You are allowed to use spell in any order and any number of times for example you may not use some spells at all ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=201000;\nint n,a[N],b[N],c[N],d[N],e[N],dis[N],vis[N],pre[N],q[N],m;\nVI vx,vy,dd;\nset<PII> cc[N];\nvoid modify(int x,PII s) {\n\tfor (;x<=m;x+=x&-x) cc[x].insert(s);\n}\nvoid query(int x,int v) {\n\tdd.clear();\n\tfor (;x;x-=x&-x) {\n\t\twhile (1) {\n\t\t\tauto it=cc[x].lower_bound(mp(v,-1));\n\t\t\tif (it==cc[x].end()) break;\n\t\t\tdd.pb(it->se);\n\t\t\tcc[x].erase(it);\n\t\t}\n\t}\n}\nvoid print(int u) {\n\tprintf(""%d\\n"",dis[u]+1);\n\tfor (;u!=-1;u=pre[u]) {\n\t\tprintf(""%d "",u+1);\n\t}\n\tputs("""");\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%d%d%d%d"",a+i,b+i,c+i,d+i),vx.pb(a[i]),vx.pb(c[i]),vy.pb(b[i]),vy.pb(d[i]);\n\tsort(all(vx)); sort(all(vy));\n\tif (vx[0]!=0||vy[0]!=0) {\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\trep(i,0,n) vis[i]=0;\n\tvis[n-1]=1; q[0]=n-1; pre[n-1]=-1;\n\tm=SZ(vx);\n\trep(i,0,n) {\n\t\te[i]=m-(lower_bound(vx.begin(),vx.end(),a[i])-vx.begin());\n\t\tc[i]=m-(lower_bound(vx.begin(),vx.end(),c[i])-vx.begin());\n\t\tmodify(c[i],mp(d[i],i));\n\t}\n\tint t=1;\n\trep(i,0,t) {\n\t\tint u=q[i];\n\t\tif (a[u]==0&&b[u]==0) {\n\t\t\tprint(u);\n\t\t\treturn 0;\n\t\t}\n\t\tquery(e[u],b[u]);\n\t\tfor (auto v:dd) {\n\t\t\tif (vis[v]) continue;\n\t\t\tdis[v]=dis[u]+1; vis[v]=1;\n\t\t\tpre[v]=u; q[t++]=v;\n\t\t}\n\t}\n\tputs(""-1"");\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2500
Lara has a safe that is locked with a circle shaped code lock that consists of a rotating arrow a static circumference around the arrow an input screen and an input button The circumference of the lock is split into k equal sections numbered from 1 to k in clockwise order Arrow always points to one of the sections Each section is marked with one of the first k letters of the English alphabet No two sections are marked with the same letter Due to the lock limitations the safe s password is a string of length n that consists of first k letters of the English alphabet only Lara enters the password by rotating the lock s arrow and pressing the input button Initially the lock s arrow points to section 1 and the input screen is empty In one second she can do one of the following actions Rotate the arrow one section clockwise If the arrow was pointing at section x k it will now point at section x 1 If the arrow was pointing at section k it will now point at section 1 Rotate the arrow one section counter clockwise If the arrow was pointing at section x 1 it will now point at section x 1 If the arrow was pointing at section 1 it will now point at section k Press the input button The letter marked on the section that the arrow points to will be added to the content of the input screen As soon as the content of the input screen matches the password the safe will open Lara always enters her password in the minimum possible time Lara has recently found out that the safe can be re programmed She can take the first k letters of the English alphabet and assign them to the sectors in any order she likes Now she wants to re arrange the letters in a way that will minimize the number of seconds it takes her to input the password Compute this minimum number of seconds and the number of ways to assign letters for which this minimum number of seconds is achieved Two ways to assign letters to sectors are considered to be distinct if there exists at least one sector i that is assigned different letters ,"['#pragma GCC optimize(""Ofast"")\n#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int inf = 1E9;\n\nstruct Info {\n    int min = inf;\n    i64 cnt = 0;\n};\n\nInfo operator+(Info a, Info b) {\n    if (a.min < b.min) {\n        return a;\n    } else if (b.min < a.min) {\n        return b;\n    } else {\n        return {a.min, a.cnt + b.cnt};\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int k, n;\n    std::cin >> k >> n;\n    \n    std::string S;\n    std::cin >> S;\n    \n    std::vector cnt(k, std::vector<int>(k));\n    for (int i = 1; i < n; i++) {\n        cnt[S[i - 1] - \'a\'][S[i] - \'a\'] += 1;\n        cnt[S[i] - \'a\'][S[i - 1] - \'a\'] += 1;\n    }\n    for (int i = 0; i < k; i++) {\n        cnt[i][i] = 0;\n    }\n    \n    int half = (k + 1) / 2;\n    \n    std::vector<int> p;\n    for (int i = 0; i < half; i++) {\n        p.push_back(i);\n        if (i + half < k) {\n            p.push_back(i + half);\n        }\n    }\n    \n    std::vector<int> pw(k + 1);\n    pw[0] = 1;\n    for (int i = 1; i <= k; i++) {\n        pw[i] = pw[i - 1] * 3;\n    }\n    \n    std::vector<Info> dp(1 << k);\n    std::vector<int> tm(1 << k, -1);\n    std::vector sum(k, std::vector<int>(1 << k));\n    for (int a = 0; a < k; a++) {\n        for (int s = 1; s < (1 << k); s++) {\n            int b = __builtin_ctz(s);\n            sum[a][s] = sum[a][s ^ (1 << b)] + cnt[a][b];\n        }\n    }\n    \n    // i64 tot = 0;\n    Info ans;\n    std::vector<int> q;\n    for (int s = 0; s < (1 << k); s++) {\n        if (~s >> (S[0] - \'a\') & 1) {\n            continue;\n        }\n        if (__builtin_popcount(s) == half) {\n            q.clear();\n            q.push_back(0);\n            tm[0] = s;\n            dp[0] = {0, 1};\n            \n            for (int _ = 0; _ < q.size(); _++) {\n                int t = q[_];\n                \n                int c = __builtin_popcount(t);\n                int pos = p[c];\n                if (c % 2 == 0) {\n                    for (int C = ~t & s; C > 0; C &= (C - 1)) {\n                        int i = __builtin_ctz(C);\n                        if (c == 0 && i != S[0] - \'a\') {\n                            continue;\n                        }\n                        auto val = dp[t];\n                        val.min += (sum[i][(1 << k) - 1 - (s ^ t)] - sum[i][s ^ t]) * pos;\n                        int nt = t | 1 << i;\n                        if (tm[nt] == s) {\n                            dp[nt] = dp[nt] + val;\n                        } else {\n                            dp[nt] = val;\n                            tm[nt] = s;\n                            q.push_back(nt);\n                        }\n                    }\n                } else {\n                    for (int C = ~t & ~s & ((1 << k) - 1); C > 0; C &= (C - 1)) {\n                        int i = __builtin_ctz(C);\n                        auto val = dp[t];\n                        val.min += (sum[i][s ^ t] - sum[i][(1 << k) - 1 - (s ^ t)]) * pos;\n                        val.min += sum[i][t & s] * k;\n                        int nt = t | 1 << i;\n                        if (tm[nt] == s) {\n                            dp[nt] = dp[nt] + val;\n                        } else {\n                            dp[nt] = val;\n                            tm[nt] = s;\n                            q.push_back(nt);\n                        }\n                    }\n                }\n            }\n            \n            ans = ans + dp[(1 << k) - 1];\n        }\n    }\n    \n    ans.min += n;\n    std::cout << ans.min << ""\\n"";\n    std::cout << ans.cnt << ""\\n"";\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3300
You are given two positive integers n and k Your task is to find a string s such that all possible strings of length n that can be formed using the first k lowercase English alphabets occur as a subsequence of s If there are multiple answers print the one with the smallest length If there are still multiple answers you may print any of them A string a is called a subsequence of another string b if a can be obtained by deleting some possibly zero characters from b without changing the order of the remaining characters ,"[""#include <bits/stdc++.h>\nusing namespace std;\nvoid solve() {\n  int n, k;\n  cin >> n >> k;\n  while (n--)\n    for (int i = 0; i < k; i++)\n      cout << (char) ('a' + i);\n  cout << endl;\n}\nint main() {\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n""]","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",800
A tree is a connected graph without cycles A rooted tree has a special vertex called the root The parent of a vertex v different from root is the previous to v vertex on the shortest path from the root to the vertex v Children of the vertex v are all vertices for which v is the parent You are given a rooted tree with n vertices The vertex 1 is the root Initially all vertices are healthy Each second you do operations the operation and after that the operation Spreading for vertex v if at least one child of v is infected you can spread the disease by infecting at most one other child of v of your choice Injection you can choose any healthy vertex and infect it This process repeats each second until the whole tree is infected You need to find the minimal number of seconds needed to infect the whole tree ,"['#include <bits/stdc++.h>\n#define mod 1000000007\n#define int long long\nusing namespace std;\nint a[200005],b[200005],n;\ninline bool check(int x)\n{\n\tfor(int i=1;i<=n;i++) b[i]=0;\n\tint now=0;\n\tfor(int i=1;i<=x;i++)\n\t\tif(a[i]) b[i]=x-now,++now;\n\tif(now>x) return 0;\n\tint s=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(a[i]&&a[i]>b[i]) s+=a[i]-b[i];\n\tif(s+now>x) return 0;\n\treturn 1;\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n+1;i++) a[i]=0;\n\t\t++a[1];\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\t++a[x+1];\n\t\t}\n\t\t++n;\n\t\tsort(a+1,a+n+1);\n\t\treverse(a+1,a+n+1);\n\t\tint l=0,r=n,ans=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(check(mid)) ans=mid,r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0]",1600
Mike wants to prepare for IMO but he doesn t know geometry so his teacher gave him an interesting geometry problem Let s define to be the number of integer points in the segment with say that You are given two integers and and closed intervals on axis and you have to find In other words you should find the sum of the number of integer points in the intersection of any of the segments As the answer may be very large output it modulo Mike can t solve this problem so he needs your help You will help him won t you ,"['#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <bitset>\n#include <ctime>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, n) for (int i = a; i <= n; ++i)\n#define ROF(i, n, a) for (int i = n; i >= a; i--)\n#define FIT(i, v) for (auto &i : v)\n#define pb push_back\n#define mp make_pair\n#define mt make_touple\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\n#define log log2\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod = 1000000007;\nll powmod(ll a, ll b) {ll res=1; a %= mod; assert(b >= 0); for(; b; b >>= 1) {if (b & 1) res = res * a % mod; a = a * a % mod;} return res;}\n\nconst int N = 400100;\n\nmap<int, int> nor;\nvector<int> vals, val;\nint sol, n, k, l[N], r[N], A[N];\nll P[N], I[N];\nll comb(int x, int y) {\n    return 1LL * P[x] * I[y] % mod * I[x - y] % mod;\n}\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(""a.in"", ""r"", stdin);\n    freopen(""a.out"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> n >> k;\n    FOR(i,1,n) {\n        cin >> l[i] >> r[i];\n        r[i]++;\n        vals.pb(l[i]);\n        vals.pb(r[i]);\n    }\n    P[0] = 1;\n    FOR(i,1,n) {\n        P[i] = 1LL * P[i - 1] * i % mod;\n    }\n    I[n] = powmod(P[n], mod - 2);\n    ROF(i,n-1,0) {\n        I[i] = I[i + 1] * (i + 1) % mod;\n    }\n    sort(vals.begin(), vals.end());\n    FIT(it,vals) {\n        if(!val.size()) {\n            val.pb(it);\n        } else if (val.back() != it) {\n            val.pb(it);\n        }\n    }\n    int t = 0;\n    FIT(it,val) {\n        nor[it] = ++t;\n    }\n    FOR(i,1,n) {\n        A[nor[l[i]]]++;\n        A[nor[r[i]]]--;\n    }\n    FOR(i,1,t) {\n        A[i] += A[i - 1];\n        if (A[i] >= k) {\n            sol += 1LL * comb(A[i],k) * (val[i] - val[i - 1]) % mod;\n            if (sol >= mod) {\n                sol -= mod;\n            }\n        }\n    }\n    cout << sol;\n    return 0;\n}']","[0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2000
You have a statistic of price changes for one product represented as an array of n positive integers p 0 p 1 dots p n 1 where p 0 is the initial price of the product and p i is how the price was increased during the i th month Using these price changes you are asked to calculate the inflation coefficients for each month as the ratio of current price increase p i to the price at the start of this month p 0 p 1 dots p i 1 Your boss said you clearly that the inflation coefficients must not exceed k ,"[""#include<bits/stdc++.h>\nusing namespace std;\n//dengyaotriangle!\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        int n,k;\n        cin>>n>>k;\n        vector<int> p(n);\n        for(int i=0;i<n;i++)cin>>p[i];\n        long long s=p[0];\n        long long ans=0;\n        for(int i=1;i<n;i++){\n            ans=max(ans,(100ll*p[i]+k-1)/k-s);\n            s+=p[i];\n        }\n        cout<<ans<<'\\n';\n    }\n    return 0;\n}""]","[1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",1300
There is a secret sequence p 0 p 1 ldots p n 1 which is a permutation of 0 1 ldots n 1 You need to find any two indices i and j such that p i oplus p j is maximized where oplus denotes the bitwise XOR operation To do this you can ask queries Each query has the following form you pick arbitrary indices a b c and d 0 le a b c d n Next the jury calculates x p a mid p b and y p c mid p d where denotes the bitwise OR operation Finally you receive the result of comparison between x and y In other words you are told if x y x y or x y Please find any two indices i and j 0 le i j n such that p i oplus p j is maximum among all such pairs using at most 3n queries If there are multiple pairs of indices satisfying the condition you may output any one of them ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nchar pyt(int a, int b, int c, int d)\n{\n\tprintf(""? %d %d %d %d\\n"", a, b, c, d);\n\tff();\n\tchar ret;\n\tscanf("" %c"", &ret);\n\treturn ret;\n}\n\nvoid ans(int a, int b)\n{\n\tprintf(""! %d %d\\n"", a, b);\n\tff();\n}\n\nint n;\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tint g=0;\n\tfor (int i=1; i<n; i++)\n\t\tif (pyt(i, i, g, g)==\'>\')\n\t\t\tg=i;\n\tvi wek;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tif (i==g)\n\t\t\tcontinue;\n\t\tif (wek.empty())\n\t\t{\n\t\t\twek.push_back(i);\n\t\t\tcontinue;\n\t\t}\n\t\tchar c=pyt(g, i, g, wek.back());\n\t\tif (c==\'>\')\n\t\t{\n\t\t\twek={i};\n\t\t\tcontinue;\n\t\t}\n\t\tif (c==\'=\')\n\t\t{\n\t\t\twek.push_back(i);\n\t\t\tcontinue;\n\t\t}\n\t}\n\tint x=wek[0];\n\tfor (int i : wek)\n\t\tif (pyt(x, x, i, i)==\'>\')\n\t\t\tx=i;\n\tans(g, x);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
In Ancient Berland there were cities and two way roads of equal length The cities are numbered with integers from to inclusively According to an ancient superstition if a traveller visits three cities in row without visiting other cities between them a great disaster awaits him Overall there are such city triplets Each triplet is ordered which means that for example you are allowed to visit the cities in the following order Vasya wants to get from the city to the city and not fulfil the superstition Find out which minimal number of roads he should take Also you are required to find one of his possible path routes ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <tr1/unordered_set>\n#include <queue>\nusing namespace std;\nint N,M,K;\ntypedef pair<int,int> P;\nconst int MN = 50*1000 + 50;\ntr1::unordered_set<int> fails[MN];\nmap<P,int> ens;\nint to[MN];\nint ES=0;\nvector<int> e[MN];\nbool used[MN];\nint from[MN];\n\nstruct E {\n\tint c;\n\tint e;\n\tint f;\n\tbool operator<(const E& e) const {\n\t\treturn c>e.c;\n\t}\n};\n\nint main()\n{\n\tcin>>N>>M>>K;\n\tfor(int i=0; i<M; ++i) {\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tto[ES] = b;\n\t\tens[P(a,b)] = ES;\n\t\te[a].push_back(ES++);\n\t\tto[ES] = a;\n\t\tens[P(b,a)] = ES;\n\t\te[b].push_back(ES++);\n\t}\n\tfor(int i=0; i<K; ++i) {\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tP p(a,b);\n\t\tif (!ens.count(p)) continue;\n\t\tint e = ens[p];\n\t\tfails[e].insert(c);\n//\t\tcout<<""setting fail @ ""<<e<<\' \'<<c<<\'\\n\';\n\t}\n\n\tpriority_queue<E> q;\n\tfor(size_t i=0; i<e[1].size(); ++i) {\n\t\tE z = {1, e[1][i], -1};\n\t\tq.push(z);\n\t}\n\twhile(!q.empty()) {\n\t\tE p = q.top();\n\t\tq.pop();\n\n\t\tint ee = p.e;\n\t\tif (used[ee]) continue;\n\t\tfrom[ee] = p.f;\n\t\tint n = to[ee];\n//\t\tcout<<""setting from ""<<ee<<\' \'<<n<<"" : ""<<p.f<<"" ; ""<<p.c<<\'\\n\';\n\t\tused[ee] = 1;\n\t\tif (n==N) {\n\t\t\tint c = ee;\n\t\t\tvector<int> res;\n\t\t\twhile(c >= 0) {\n\t\t\t\tres.push_back(to[c]);\n\t\t\t\tc = from[c];\n\t\t\t}\n\t\t\tres.push_back(1);\n\t\t\treverse(res.begin(),res.end());\n\t\t\tcout<<p.c<<\'\\n\';\n\t\t\tfor(size_t i=0; i<res.size(); ++i) {\n\t\t\t\tif (i>0) cout<<\' \';\n\t\t\t\tcout<<res[i];\n\t\t\t}\n\t\t\tcout<<\'\\n\';\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(size_t i=0; i<e[n].size(); ++i) {\n\t\t\tint f = e[n][i];\n\t\t\tif (used[f]) continue;\n\t\t\tint t = to[f];\n\t\t\tif (fails[ee].count(t)) continue;\n\t\t\tE z = {p.c+1, f, ee};\n//\t\t\tcout<<""going @ ""<<ee<<\' \'<<n<<\' \'<<t<<\'\\n\';\n\t\t\tq.push(z);\n\t\t}\n\t}\n\tcout<<-1<<\'\\n\';\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2000
Many of you must be familiar with the Google Code Jam round rules Let us remind you of some key moments that are crucial to solving this problem During the round the participants are suggested to solve several problems each divided into two subproblems an easy one with small limits Small input and a hard one with large limits Large input You can submit a solution for Large input only after you ve solved the Small input for this problem There are no other restrictions on the order of solving inputs In particular the participant can first solve the Small input then switch to another problem and then return to the Large input Solving each input gives the participant some number of points usually different for each problem This takes into account only complete solutions that work correctly on all tests of the input The participant gets the test result of a Small input right after he submits it but the test result of a Large input are out only after the round s over In the final results table the participants are sorted by non increasing of received points If the points are equal the participants are sorted by ascending of time penalty By the Google Code Jam rules the time penalty is the Vasya decided to check out a new tactics on another round As soon as the round begins the boy quickly read all the problems and accurately evaluated the time it takes to solve them Specifically for each one of the problems Vasya knows five values Solving the Small input of the th problem gives to the participant points and solving the Large input gives more points That is the maximum number of points you can get for the th problem equals Writing the solution for the Small input of the th problem takes exactly minutes for Vasya Improving this code and turning it into the solution of the Large input takes another minutes Vasya s had much practice so he solves all Small inputs from the first attempt But it s not so easy with the Large input there is the probability that the solution to the Large input will turn out to be wrong at the end of the round Please keep in mind that these solutions do not affect the participants points and the time penalty A round lasts for minutes The time for reading problems and submitting solutions can be considered to equal zero Vasya is allowed to submit a solution exactly at the moment when the round ends Vasya wants to choose a set of inputs and the order of their solution so as to make the expectation of the total received points maximum possible If there are multiple ways to do this he needs to minimize the expectation of the time penalty Help Vasya to cope with this problem ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\nstruct problem {int score1,score2; int time1,time2; double fail; ll expscore1,expscore2; double ratio;};\n\nint N,T;\nproblem P[1010];\n\nll dpscore[1010][1600];\ndouble dppenal[1010][1600];\n\nvoid update(int n, int t, ll score, double penal){\n    if(n <= N && t <= T && (score > dpscore[n][t] || (score == dpscore[n][t] && penal < dppenal[n][t]))){\n        dpscore[n][t] = score;\n        dppenal[n][t] = penal;\n    }\n}\n\nint main(void){\n    int i,j;\n    \n    cin >> N >> T;\n    REP(i,N){\n        cin >> P[i].score1 >> P[i].score2 >> P[i].time1 >> P[i].time2 >> P[i].fail;\n        P[i].expscore1 = (ll)P[i].score1 * (ll)1000000;\n        int tmp = (int)(P[i].fail * 1000000 + 0.5);\n        P[i].expscore2 = (ll)P[i].score2 * (ll)(1000000 - tmp);\n        P[i].ratio = ((tmp == 1000000) ? (1.0E+18) : (P[i].time2 * P[i].fail / (1.0 - P[i].fail)));\n    }\n    \n    REP(i,N+5) REP(j,N-1) if(P[j].ratio > P[j+1].ratio) swap(P[j], P[j+1]);\n    \n    REP(i,N+1) REP(j,T+1) dpscore[i][j] = -1;\n    dpscore[0][0] = 0;\n    \n    REP(i,N) REP(j,T+1) if(dpscore[i][j] != -1){\n        ll score = dpscore[i][j];\n        double penal = dppenal[i][j];\n        \n        // solve 0\n        update(i+1, j, score, penal);\n        \n        // solve 1\n        update(i+1, j + P[i].time1, score + P[i].expscore1, penal + P[i].time1);\n        \n        // solve 2\n        double fail_penalty = penal + P[i].time1;\n        double ac_penalty = j + P[i].time1 + P[i].time2;\n        update(i+1, j + P[i].time1 + P[i].time2, score + P[i].expscore1 + P[i].expscore2, fail_penalty * P[i].fail + ac_penalty * (1.0 - P[i].fail));\n    }\n    \n    ll score = 0;\n    double penal = 0.0;\n    REP(i,T+1){\n        ll score2 = dpscore[N][i];\n        double penal2 = dppenal[N][i];\n        if(score2 > score || (score2 == score && penal2 < penal)){\n            score = score2;\n            penal = penal2;\n        }\n    }\n    \n    printf(""%.12f %.12f\\n"", score / 1000000.0, penal);\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2800
Daenerys Targaryen has an army consisting of groups of soldiers the th group contains soldiers She wants to bring her army to the other side of the sea to get the Iron Throne She has recently bought an airplane to carry her army through the sea The airplane has rows each of them has seats We call two seats neighbor if they are in the same row and in seats or Daenerys Targaryen wants to place her army in the plane so that there are no two soldiers from different groups sitting on neighboring seats Your task is to determine if there is a possible arranging of her army in the airplane such that the condition above is satisfied ,"['#include<bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nint n, k;\n\nint jed, dwa, czt;\nvector <int> wek;\n\nvoid nope()\n{\n    printf(""NO\\n"");\n    exit(0);\n}\n\nint main()\n{\n    scanf(""%d%d"", &n, &k);\n    dwa=n*2;\n    czt=n;\n    for (int i=1; i<=k; i++)\n    {\n        int x;\n        scanf(""%d"", &x);\n        wek.push_back(x);\n    }\n    while(!wek.empty())\n    {\n        nth_element(wek.begin(), wek.end()-1, wek.end());\n        int x=wek.back();\n        wek.pop_back();\n        if (!x)\n            continue;\n        if (x>=4 && czt)\n        {\n            czt--;\n            x-=4;\n            wek.push_back(x);\n            continue;\n        }\n        if (x>=4 && dwa)\n        {\n            dwa--;\n            x-=2;\n            wek.push_back(x);\n            continue;\n        }\n        if (x>=4 && jed)\n        {\n            jed--;\n            x-=1;\n            wek.push_back(x);\n            continue;\n        }\n        if (x>=4)\n            nope();\n        if (x==3)\n        {\n            if (czt)\n            {\n                czt--;\n                continue;\n            }\n            if (dwa)\n            {\n                dwa--;\n                x-=2;\n                wek.push_back(x);\n                continue;\n            }\n            if (jed)\n            {\n                jed--;\n                x-=1;\n                wek.push_back(x);\n                continue;\n            }\n            nope();\n        }\n        if (x==2)\n        {\n            if (czt)\n            {\n                czt--;\n                jed++;\n                continue;\n            }\n            if (dwa)\n            {\n                dwa--;\n                x-=2;\n                wek.push_back(x);\n                continue;\n            }\n            if (jed)\n            {\n                jed--;\n                x-=1;\n                wek.push_back(x);\n                continue;\n            }\n            nope();\n        }\n        if (x==1)\n        {\n            \n            if (czt)\n            {\n                czt--;\n                jed++;\n                continue;\n            }\n            if (dwa)\n            {\n                dwa--;\n                continue;\n            }\n            if (jed)\n            {\n                jed--;\n                continue;\n            }\n            nope();\n        }\n    }\n    printf(""YES\\n"");\n    return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1900
You are given a number in binary representation consisting of exactly n bits possibly with leading zeroes For example for n 5 the number 6 will be given as 00110 and for n 4 the number 9 will be given as 1001 Let s fix some integer i such that 1 le i le n In one operation you can swap any two adjacent bits in the binary representation Your goal is to find the smallest number of operations you are required to perform to make the number divisible by 2 i or say that it is impossible Please note that for each 1 le i le n you are solving the problem independently ,"['#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint N;char s[200005];\nint pcnt[200005],pos[200005],tot;ll res[200005];\nvoid solve(){\n\tscanf(""%d"",&N);scanf(""%s"",s+1);tot=0;reverse(s+1,s+N+1);\n\tfor(int i=1;i<=N;++i)if(s[i]==\'0\')pos[++tot]=i;\n\tfor(int i=1;i<=tot;++i)res[i]=res[i-1]+(ll)(pos[i]-i);\n\tpcnt[N+1]=0;for(int i=N;i>=1;--i)pcnt[i]=pcnt[i+1]+(s[i]==\'0\');\n\tfor(int i=1;i<=N;++i){\n\t\tif(i-(pcnt[1]-pcnt[i+1])>pcnt[i+1]){printf(""-1 "");continue;}\n\t\tprintf(""%lld "",res[i]);\n\t} puts("""");\n}\nint main(){\n\tint t;cin>>t;\n\twhile(t--)solve(); \n    return 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1100
Pushok the dog has been chasing Imp for a few hours already Fortunately Imp knows that Pushok is afraid of a robot vacuum cleaner While moving the robot generates a string consisting of letters and that produces a lot of noise We define of string as the number of occurrences of string as a in it in other words the number of such pairs that and and The robot is off at the moment Imp knows that it has a sequence of strings in its memory and he can arbitrary change their order When the robot is started it generates the string as a concatenation of these strings in the given order The noise of the resulting string equals the noise of this concatenation Help Imp to find the maximum noise he can achieve by changing the order of the strings ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 1e5 + 10;\n\nint n, a[MAXN];\nstring s[MAXN];\n\nll get(string t){\n\tll res = 0;\n\tint c = 0;\n\tfor (int i = 0; i < t.size(); i++){\n\t\tif (t[i] == 's')\n\t\t\tc++;\n\t\telse\n\t\t\tres += c;\n\t}\n\treturn res;\n}\n\nbool cmp(int u, int v){\n\treturn get(s[u]+s[v]) > get(s[v]+s[u]);\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> s[i];\n\tiota(a, a + n, 0);\n\tsort(a, a + n, cmp);\n\tstring t;\n\tfor (int i = 0; i < n; i++)\n\t\tt += s[a[i]];\n\tcout << get(t) << endl;\n}\n""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1800
Wilbur the pig is tinkering with arrays again He has the array initially consisting of zeros At one step he can choose any index and either add to all elements or subtract from all elements His goal is to end up with the array Of course Wilbur wants to achieve this goal in the minimum number of steps and asks you to compute this value ,"['//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 2e5 + 49;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nll a[maxN], b[maxN];\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> b[i];\n\tll x = 0, y = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] += x - y;\n\t\tif (a[i] < b[i])\n\t\t\tx += b[i] - a[i];\n\t\telse\n\t\t\ty += a[i] - b[i];\t\n\t}\n\tcout << x + y << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Li Hua has a tree of n vertices and n 1 edges The root of the tree is vertex 1 Each vertex i has importance a i Denote the of a subtree as the number of vertices in it and the as the sum of the importance of vertices in it Denote the of a non leaf vertex as the son with the subtree If multiple of them exist the is the one with the index Li Hua wants to perform m operations 1 x 1 leq x leq n calculate the of the subtree whose root is x 2 x 2 leq x leq n rotate the of x up Formally denote son x as the of x fa x as the father of x He wants to remove the edge between x and fa x and connect an edge between son x and fa x It is guaranteed that x is not root but guaranteed that x is not a leaf If x is a leaf please ignore the operation Suppose you were Li Hua please solve this problem ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pa pair <int, int>\n#define fi first\n#define se second\nint n, m, a[100005];\nbasic_string <int> G[100005];\nstruct cmp {\n\tbool operator () (const pa x, const pa y) const {\n\t\treturn x.fi > y.fi or x.fi == y.fi && x.se < y.se;\n\t}\n};\nmultiset <pa, cmp> s[100005];\nll w[100005];\nint siz[100005], father[100005];\nvoid dfs(int u, int fa) {\n\tw[u] = a[u], siz[u] = 1, father[u] = fa, s[u].clear();\n\tfor (auto v : G[u]) if (v != fa) {\n\t\tdfs(v, u), w[u] += w[v], siz[u] += siz[v];\n\t\ts[u].insert({siz[v], v});\n\t}\n}\nint main() {\n\tios :: sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v; cin >> u >> v, G[u] += v, G[v] += u;\n\t}\n\tdfs(1, 0);\n\twhile (m--) {\n\t\tint opt, x; cin >> opt >> x;\n\t\tif (opt == 1) {\n\t\t\tcout << w[x] << '\\n';\n\t\t}\n\t\telse {\n\t\t\tif (s[x].size()) {\n\t\t\t\tint fa = father[x], son = s[x].begin() -> se;\n\t\t\t\ts[fa].erase(s[fa].find({siz[x], x}));\n\t\t\t\tsiz[x] -= siz[son], siz[son] += siz[x];\n\t\t\t\tw[x] -= w[son], w[son] += w[x], s[x].erase(s[x].begin());\n\t\t\t\ts[son].insert({siz[x], x}), s[fa].insert({siz[son], son});\n\t\t\t\tfather[son] = fa, father[x] = son;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}""]","[0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0]",1900
After learning a lot about space exploration a little girl named Ana wants to change the subject Ana is a girl who loves palindromes string that can be read the same backwards as forward She has learned how to check for a given string whether it s a palindrome or not but soon she grew tired of this problem so she came up with a more interesting one and she needs your help to solve it You are given an array of strings which consist of only small letters of the alphabet Your task is to find palindrome pairs are there in the array A palindrome pair is a pair of strings such that the following condition holds permutation of the concatenation of the two strings is a palindrome In other words if you have two strings let s say and and you concatenate them into we have to check if there exists a permutation of this new string such that it is a palindrome in this case there exists the permutation Two pairs are considered different if the strings are located on The pair of strings with indices i j is considered as the pair j i ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nint n;\nmap<int, int> mm;\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tll ans = 0;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint cur = 0;\n\t\tfor (char c: s)\n\t\t\tcur ^= (1 << (c - \'a\'));\n\t\tans += mm[cur];\n\t\tfor (int i = 0; i < 26; ++i)\n\t\t\tans += mm[cur ^ (1 << i)];\n\t\t++mm[cur];\n\t}\n\tcout << ans << ""\\n"";\n\treturn 0;\n}\n\n\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1600
Vasya has recently learned at school what a number s divisor is and decided to determine a string s divisor Here is what he came up with String is the divisor of string if and only if there exists a positive integer such that if we write out string consecutively times we get string For example string has two divisors and Now Vasya wants to write a program that calculates the number of common divisors of two strings Please help him ,"['#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <queue>\n#include <string.h>\n#include <sstream>\n#define _USE_MATH_DEFINES\n#define fo(i,n) for(i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define sz(x) x.size()\nusing namespace std;\n\ntypedef long long ll;\n\nint gcd(int x, int y)\n{\n    if (x < y) swap(x, y);\n    if (y == 0) return x;\n    return gcd(y, x%y);\n}\n\nint main(void)\n{\n    string s1, s2;\n    cin >> s1 >> s2;\n\n    if (sz(s1) < sz(s2))\n        swap(s1, s2);    \n    int n = sz(s1), m = sz(s2), g = gcd(n, m), i, ans = 0, j;\n\n    if (s1.substr(0, m) != s2)\n        {\n            cout << 0 << endl;\n            return 0;\n        }\n    \n    for(i = 1; i <= g; i++)\n        {\n            if (g % i == 0)\n                {\n                    bool ne = false;\n                    for(j = 0; j < n; j+=i)\n                        {\n                            if (s1.substr(j, i) != s1.substr(0, i))\n                                {\n                                    ne = true;\n                                    break;\n                                }\n                        }\n                    if (!ne) ans ++;\n                }\n        }\n    \n    cout << ans << endl;\n}\n']","[0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]",1400
You have a set S of n distinct integers between 1 and m Each second you do the following steps Pick an element x in S uniformly at random Remove x from S If x 1 leq m and x 1 is not in S add x 1 to S What is the expected number of seconds until S is empty Output the answer modulo 1 000 000 007 Formally let P 1 000 000 007 It can be shown that the answer can be expressed as an irreducible fraction frac a b where a and b are integers and b not equiv 0 pmod P Output the integer equal to a cdot b 1 bmod P In other words output an integer z such that 0 le z P and z cdot b equiv a pmod P ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nconst ll mod=1000*1000*1000+7;\nconst ll o2=(mod+1)/2;\n\nll inv(ll v)\n{\n\tif (v<=1)\n\t\treturn v;\n\treturn inv(mod%v)*(mod-mod/v)%mod;\n}\n\nint n, m;\n\nint tab[nax];\n\nll dp[nax][nax];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tfor (int j=0; j<i; j++)\n\t\t{\n\t\t\tif (!j)\n\t\t\t{\n\t\t\t\tdp[i][j]=i;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j]=(dp[i-1][j]+1+dp[i][j-1])*o2%mod;\n\t\t\t}\n\t\t}\n\t}\n\tll wyn=m+1-tab[n];\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a=m+1-tab[i];\n\t\tint b=m+1-tab[i+1];\n\t\twyn+=dp[a][b];\n\t}\n\twyn%=mod;\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2500
Three swimmers decided to organize a party in the swimming pool At noon they started to swim from the left side of the pool It takes the first swimmer exactly a minutes to swim across the entire pool and come back exactly b minutes for the second swimmer and c minutes for the third Hence the first swimmer will be on the left side of the pool after 0 a 2a 3a minutes after the start time the second one will be at 0 b 2b 3b minutes and the third one will be on the left side of the pool after 0 c 2c 3c minutes You came to the left side of the pool exactly p minutes after they started swimming Determine how long you have to wait before one of the swimmers arrives at the left side of the pool ,"[""#include <bits/stdc++.h>\ntypedef long long ll;\n\nusing namespace std;\n\nll MOD = (ll)1000000007;\nvector<ll> nums;\n\nll roundup(ll k, ll x) {\n    if(!(k%x)) return 0;\n    return x - (k%x);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t, m, n;\n    ll k, ans = 0, a, b, c;\n    string s1, s2;\n    bool sad = false;\n    cin >> t;\n    while(t--) {\n        cin >> k >> a >> b >> c;\n        cout << min(roundup(k, a), min(roundup(k, b), roundup(k, c))) << '\\n';\n    }\n}""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
John Doe has a list of all Fibonacci numbers modulo This list is infinite it starts with numbers and Each number in the list apart from the first two is a sum of previous two modulo That is John s list is made from the Fibonacci numbers list by replacing each number there by the remainder when divided by John got interested in number and now wants to find its first occurrence in the list given above Help John and find the number of the first occurence of number in the list or otherwise state that number does not occur in the list The numeration in John s list starts from zero There the th position is the number the st position is the number the nd position is the number the rd position is the number the th position is the number and so on Thus the beginning of the list looks like this ,"['#include <iostream>\n\nusing namespace std;\n\nconst long long M = 10000000000000LL;\nconst int md = 100000000;\nconst int per = md*3/2;\nconst int nd = 30000000;\n\nlong long f[nd+10];\nlong long xa[500010], xb[500010], xc[500010];\nlong long x, ans;\nint q, a, b, it, c, i, itt;\n\ninline long long mul(long long a, long long b) {\n  long long a1 = a/10000000, a2 = a-a1*10000000;\n  long long b1 = b/10000000, b2 = b-b1*10000000;\n  long long res = a2*b2;\n  res += (a1*b2+b1*a2) % 1000000 * 10000000;\n  return res % M;\n}\n\nvoid check(long long z) {\n  if (ans != -1 && z >= ans) return;\n  long long q = z/nd, w = z % nd, res;\n  if (w == 0) res = xb[q];\n  else res = (mul(xb[q],f[w-1])+mul(xc[q],f[w])) % M;\n  if (res == x) ans = z;\n}\n\nlong long aa, bb, cc;\n\nvoid check2(long long z) {\n//  if (ans != -1 && z >= ans) return;\n  long long a = 1, b = 0, c = 1, na, nb, u;\n  long long step = 1LL << 50;\n  while (step > z) step >>= 1;\n  while (step) {\n    u = mul(b,b);\n    na = mul(a,a)+u;\n    if (na >= M) na -= M;\n    b = mul(b,a+c);\n    c = u+mul(c,c);\n    if (c >= M) c -= M;\n    a = na;\n    if (step & z) {\n      na = b;\n      nb = a+b;\n      if (nb >= M) nb -= M;\n      c = b+c;\n      if (c >= M) c -= M;\n      a = na; b = nb;\n    }\n    step >>= 1;\n  }\n  aa = a; bb = b; cc = c;\n}\n\nint main() {\n  f[0] = 0; f[1] = 1;\n  for (i=2;i<nd;i++) {\n    f[i] = f[i-1]+f[i-2];\n    if (f[i] >= M) f[i] -= M;\n  }\n  check2(nd);\n  xa[0] = 1; xb[0] = 0; xc[0] = 1;\n  xa[1] = aa; xb[1] = bb; xc[1] = cc;\n  for (i=2;i<(M*3/2)/nd;i++) {\n    xa[i] = mul(xa[i-1],xa[1])+mul(xb[i-1],xb[1]);\n    if (xa[i] >= M) xa[i] -= M;\n    xb[i] = mul(xa[i-1],xb[1])+mul(xb[i-1],xc[1]);\n    if (xb[i] >= M) xb[i] -= M;\n    xc[i] = mul(xb[i-1],xb[1])+mul(xc[i-1],xc[1]);\n    if (xc[i] >= M) xc[i] -= M;\n  }\n  cin >> x;\n  q = x % md;\n  a = 0; b = 1; it = 0;\n  ans = -1;\n  do {\n    if (a == q)\n      for (i=0;i<100000;i++) check((long long)i*per+it);\n    c = a+b;\n    if (c >= md) c -= md;\n    a = b; b = c;\n    it++;\n  } while (a != 0 || b != 1);\n  cout << ans << endl;\n  return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2900
Vlad came home and found out that someone had reconfigured the old thermostat to the temperature of a The thermostat can only be set to a temperature from l to r inclusive the temperature cannot change by less than x Formally in one operation you can reconfigure the thermostat from temperature a to temperature b if a b ge x and l le b le r You are given l r x a and b Find the minimum number of operations required to get temperature b from temperature a or say that it is impossible ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\n\nusing namespace std;\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n\nconst int inf = int(1e9);\nconst ll INF = ll(1e17);\nconst ll mod = 998244353;\nconst double PI = acos(-1.0);\n\nll bp(ll a, ll n, ll md = mod){\n    ll r = 1;\n    while(n){\n        if(n & 1) r = r * a % md;\n        a = a * a % md;\n        n >>= 1;\n    }\n    return r;\n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nvoid solve(){\n    int l, r, x, a, b;\n    cin >> l >> r >> x >> a >> b;\n\n    if(a == b) {\n        cout << 0 << endl;\n        return;\n    }\n    if(a > b) swap(a, b);\n    if(b - a >= x) {\n        cout << 1 << endl;\n    } else if(a - l >= x and l + x <= b) {\n        cout << 2 << endl;\n    } else if(a + x <= r and r - x >= b) {\n        cout << 2 << endl;\n    } else if( (a + x <= r and r - l >= x and l + x <= b)) {\n        cout << 3 << endl;\n    } else if( (a - x >= l and l + x <= r and r - x >= b)) {\n        cout << 3 << endl;\n    } else cout << -1 << endl;\n}\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n        // cout << ""Case #"" << i << "": "";\n        solve();\n    }\n    return 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
You are given a tree with vertices and you are allowed to perform transformations on it Transformation is defined by three vertices and consists of deleting edge and adding edge Transformation could be performed if all the following conditions are satisfied There is an edge in the current tree After the transformation the graph remains a tree After the deletion of edge the tree would consist of two connected components Let s denote the set of nodes in the component containing vertex by and the set of nodes in the component containing vertex by Then condition should be satisfied i e the size of the component with should be strictly larger than the size of the component with You should the sum of squared distances between all pairs of vertices in a tree which you could get after no more than transformations and output any sequence of transformations leading initial tree to such state Note that you don t need to minimize the number of operations It is necessary to minimize only the sum of the squared distances ,"['#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\n// ========================================================================= //\n\nconst int N = 200179;\n\nint n;\nvector < int > e[N];\nstruct Tree {\n    int root;\n    int curRoot;\n    int par;\n    vector < ipair > vs;\n};\nvector < Tree > trees;\n\nstruct Triple {\n    int x, y, z;\n};\nvector < Triple > ans;\n\nint c1 = -1, c2 = -1;\n\nint dfs1(int v, int p = -1) {\n    int s = 1;\n    for (int nv : e[v])\n        if (nv != p)\n            s += dfs1(nv, v);\n    if (c1 == -1 && s*2 >= n) {\n        c1 = v;\n        if (s * 2 == n)\n            c2 = p;\n        else\n            c2 = -1;\n    }\n    return s;\n}\n\nvoid dfs2(int v, int p) {\n    for (int nv : e[v])\n        if (nv != p)\n            dfs2(nv, v);\n    trees.back().vs.push_back({v, p});\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    scanf(""%d"", &n);\n    for (int i = 0; i < n - 1; ++i) {\n        int x, y;\n        scanf(""%d%d"", &x, &y);\n        --x;\n        --y;\n        e[x].push_back(y);\n        e[y].push_back(x);\n    }\n    if (n <= 3) {\n        cout << ""0\\n"";\n        return 0;\n    }\n\n    dfs1(0);\n    for (int nv : e[c1]) {\n        if (nv == c2)\n            continue;\n        trees.emplace_back();\n        trees.back().root = nv;\n        trees.back().curRoot = nv;\n        trees.back().par = c1;\n        dfs2(nv, c1);\n    }\n    if (c2 != -1) {\n        for (int nv : e[c2]) {\n            if (nv == c1)\n                continue;\n            trees.emplace_back();\n            trees.back().root = nv;\n            trees.back().curRoot = nv;\n            trees.back().par = c2;\n            dfs2(nv, c2);\n        }\n    }\n\n    for (Tree &tree : trees) {\n        for (ipair pp : tree.vs) {\n            int v = pp.X, p = pp.Y;\n            if (v == tree.root)\n                break;\n            ans.push_back({tree.par, tree.curRoot, v});\n            tree.curRoot = v;\n            ans.push_back({v, p, tree.root});\n        }\n        ans.push_back({tree.par, tree.curRoot, tree.root});\n    }\n\n    cout << sz(ans) << ""\\n"";\n    for (Triple t : ans)\n        cout << t.x+1 << "" "" << t.y+1 << "" "" << t.z+1 << ""\\n"";\n\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0]",2600
Utkarsh is forced to play yet another one of Ashish s games The game progresses turn by turn and as usual Ashish moves Consider the 2D plane There is a token which is initially at In one move a player must increase either the x coordinate or the y coordinate of the token by k In doing so the player must ensure that the token stays within a Euclidean distance d from 0 0 In other words if after a move the coordinates of the token are p q then p 2 q 2 leq d 2 must hold The game ends when a player is unable to make a move It can be shown that the game will end in a finite number of moves If both players play optimally determine who will win ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define unrequited_love ios_base::sync_with_stdio(0);cin.tie(0);\n\nvoid solve(vi a)\n{\n\tint n=a.size();\n\tsort(a.rbegin(), a.rend());\n\tint k = 1;\n\twhile (k + 1 <= n && a[k] >= k + 1) {\n\t\tk += 1;\n\t}\n\tint up = a[k - 1] - k;\n\tint right = 0;\n\twhile (k + right < n && a[k + right] == k) {\n\t\t++right;\n\t}\n\tcout << (up % 2 == 0 && right % 2 == 0 ? ""Ashish"" : ""Utkarsh"") << \'\\n\';\n}\n\nint main()\n{\n\tunrequited_love\n\tint t; cin>>t;\n\twhile(t--)\n\t{\n\t\tll d,k; cin>>d>>k;\n\t\tll bestr = (d*d)/(k*k);\n\t\tvi ans;\n\t\tll cur=0;\n\t\twhile(cur*cur<=bestr)\n\t\t{\n\t\t\tll rem = bestr-cur*cur;\n\t\t\tll ps = max(ll(floor(sqrt(double(rem))))-1,0LL);\n\t\t\twhile((ps+1)*(ps+1)<=rem) ps++;\n\t\t\t//cerr<<""CUR, PS = ""<<cur<<\' \'<<ps<<\'\\n\';\n\t\t\tans.pb(ps);\n\t\t\tcur++;\n\t\t}\n\t\t/*\n\t\tfor(int x:ans)\n\t\t{\n\t\t\tcout<<x<<\' \';\n\t\t}\n\t\tcout<<\'\\n\';\n\t\t*/\n\t\tsolve(ans);\n\t}\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Roger Waters has a square grid of size n times n and he wants to traverse his grid from the upper left 1 1 corner to the lower right corner n n Waters can move from a square to any other square adjacent by a side as long as he is still in the grid Also except for the cells 1 1 and n n every cell has a value 0 or 1 in it Before starting his traversal he will pick either a 0 or a 1 and will be able to only go to cells values in which are equal to the digit he chose The starting and finishing cells 1 1 and n n are exempt from this rule he may go through them regardless of picked digit Because of this the cell 1 1 takes value the letter and the cell n n takes value the letter For example in the first example test case he can go from 1 1 to n n by using the zeroes on this path 1 1 2 1 2 2 2 3 3 3 3 4 4 4 The rest of the band Pink Floyd wants Waters to not be able to do his traversal so while he is not looking they will in the grid from 0 to 1 or vice versa They are afraid they will not be quick enough and asked for your help in choosing the cells We can show that there always exists a solution for the given constraints Also note that Waters will pick his digit of the traversal after the band has changed his grid so he must not be able to reach n n no matter what digit he picks ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nchar s[505][505];\nint main(){\n\tint t, n;\n\tfor(cin >> t; t--;) {\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n ; i ++) cin >> s[i];\n\t\tif(s[0][1] == s[1][0]) {\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tif(s[0][1] != s[n - 1][n - 2]) {\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << 2 << endl;\n\t\t\t\t\tcout << ""1 2"" << endl;\n\t\t\t\t\tcout << ""2 1"" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == s[0][1]) {\n\t\t\t\t\tcout << n << \' \' << n - 1 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << n - 1<< \' \' << n << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[0][1] == s[n - 1][n - 2]) {\n\t\t\t\t\tcout << ""1 2"" << endl;\n\t\t\t\t}\n\t\t\t\telse cout << ""2 1"" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 2 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == \'1\') cout << n << \' \' << n - 1 << endl;\n\t\t\t\telse cout << n - 1 << "" "" << n << endl;\n\t\t\t\tif(s[0][1] == \'0\') cout << ""1 2"" << endl;\n\t\t\t\telse cout << ""2 1"" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
It is known that fleas in Berland can jump only vertically and horizontally and the length of the jump is always equal to centimeters A flea has found herself at the center of some cell of the checked board of the size centimeters each cell is centimeters She can jump as she wishes for an arbitrary number of times she can even visit a cell more than once The only restriction is that she cannot jump out of the board The flea can count the amount of cells that she can reach from the starting position Let s denote this amount by Your task is to find the number of such starting positions which have the maximum possible value of ,"['#include <cstdio>\n\nunsigned __int64 n, m, s, d;\n\nvoid main() {\n\tscanf(""%I64u%I64u%I64u"", &n, &m, &s), --n, --m;\n\tprintf(""%I64u\\n"", ((n / s) + 1) * ((m / s) + 1) * ((n % s) + 1) * ((m % s) + 1));\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Vladimir wants to modernize partitions in his office To make the office more comfortable he decided to remove a partition and plant several bamboos in a row He thinks it would be nice if there are bamboos in a row and the th from the left is meters high Vladimir has just planted bamboos in a row each of which has height meters right now but they grow meter each day In order to make the partition nice Vladimir can cut each bamboo once at any height no greater that the height of the bamboo and then the bamboo will stop growing Vladimir wants to check the bamboos each days i e days after he planted then after days and so on and cut the bamboos that reached the required height Vladimir wants the total length of bamboo parts he will cut off to be no greater than meters What is the maximum value he can choose so that he can achieve what he wants without cutting off more than meters of bamboo ,"['#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nstruct atom{\n\tint l,r,w;\n};\nvector<atom>B; \nvector<long long>A;\nint x[110],n;\nlong long w[11000000];\nlong long K;\nint main(){\n\tscanf(""%d%I64d"",&n,&K); A.push_back(1);\n\tfor (int j=1;j<=n;j++){\n\t\tscanf(""%d"",&x[j]); int m=x[j]-1;\n\t\tfor (int ne,i=1;i<=m;i=ne+1){\n\t\t\tne=m/(m/i); A.push_back(ne+1);\n\t\t\tB.push_back((atom){i,ne+1,m/i});\n\t\t}\n\t}\n//\tfor (int i=0;i<B.size();i++) cout<<B[i].l<<"" ""<<B[i].r<<"" ""<<B[i].w<<endl;\n\tA.push_back(1e12);\n\tsort(A.begin(),A.end());\n\tint tot=unique(A.begin(),A.end())-A.begin();\n\tA.resize(tot);\n\tfor (int i=0;i<B.size();i++){\n\t\tint L=lower_bound(A.begin(),A.end(),B[i].l)-A.begin();\n\t\tint R=lower_bound(A.begin(),A.end(),B[i].r)-A.begin();\n\t\tw[L]+=B[i].w; w[R]-=B[i].w;\n\t}\n\tlong long b=0,ans=0;\n\tfor (int i=1;i<=n;i++) b+=x[i];\n\tb+=K;\n//\tfor (int i=0;i<A.size();i++) cout<<A[i]<<"" ""; cout<<endl;\n\tfor (int i=0;i<A.size();i++){\n\t\tif (i) w[i]+=w[i-1];\n\t\tlong long k=w[i]+n;\n\t\tlong long lim=b/k;\n//\t\tcout<<k<<"" ""<<b<<endl;\n\t\tif (lim<A[i]) continue;\n\t\tlim=min(lim,A[i+1]);\n\t\tans=max(ans,lim);\n\t}\n//\tfor (int i=0;i<A.size();i++) cout<<w[i]<<"" ""; cout<<endl;\n\tcout<<ans<<endl;\n\treturn 0;\n}']","[0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0]",2300
You are given a tree consisting of n vertices Each edge has an integer value written on it Let f v u be the number of values that appear on the edges of a simple path between vertices v and u Calculate the sum of f v u over all pairs of vertices v and u such that 1 le v u le n ,"['/**\n *    author:  tourist\n *    created: 23.05.2022 18:44:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<pair<int, int>>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a; --b; --c;\n    g[c].emplace_back(a, b);\n  }\n  vector<int> p(n);\n  iota(p.begin(), p.end(), 0);\n  vector<int> sz(n, 1);\n  vector<pair<int, int>> ops;\n  auto Get = [&](int i) {\n    while (i != p[i]) {\n      i = p[i];\n    }\n    return i;\n  };\n  auto Unite = [&](int i, int j) {\n    i = Get(i);\n    j = Get(j);\n    if (i != j) {\n      if (sz[i] > sz[j]) {\n        swap(i, j);\n      }\n      ops.emplace_back(i, p[i]);\n      p[i] = j;\n      ops.emplace_back(~j, sz[j]);\n      sz[j] += sz[i];\n    }\n  };\n  auto Rollback = [&](int T) {\n    while ((int) ops.size() > T) {\n      int i = ops.back().first;\n      int j = ops.back().second;\n      ops.pop_back();\n      if (i >= 0) {\n        p[i] = j;\n      } else {\n        sz[~i] = j;\n      }\n    }\n  };\n  long long ans = 0;\n  function<void(int, int)> Dfs = [&](int l, int r) {\n    if (l == r) {\n      for (auto& p : g[l]) {\n        int x = Get(p.first);\n        int y = Get(p.second);\n        ans += (long long) sz[x] * sz[y];\n      }\n      return;\n    }\n    int mid = (l + r) >> 1;\n    {\n      int save = (int) ops.size();\n      bool fail = false;\n      for (int i = mid + 1; i <= r; i++) {\n        for (auto& p : g[i]) {\n          Unite(p.first, p.second);\n        }\n      }\n      Dfs(l, mid);\n      Rollback(save);\n    }\n    {\n      int save = (int) ops.size();\n      bool fail = false;\n      for (int i = l; i <= mid; i++) {\n        for (auto& p : g[i]) {\n          Unite(p.first, p.second);\n        }\n      }\n      Dfs(mid + 1, r);\n      Rollback(save);\n    }\n  };\n  Dfs(0, n - 1);\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]",2300
This time the brothers are dealing with a strange piece of wood marked with their names This plank of wood can be represented as a string of n characters Each character is either a or a You want to make some number of cuts possibly 0 on this string partitioning it into several contiguous pieces each with length at least 1 Both brothers act with dignity so they want to split the wood as evenly as possible They want to know the maximum number of pieces you can split the wood into such that the ratios of the number of occurrences of to the number of occurrences of in each chunk are the same Kaeya the curious thinker is interested in the solution for multiple scenarios He wants to know the answer for every of the given string Help him to solve this problem For a string we define a ratio as a b where appears in it a times and appears b times Note that a or b can equal 0 but not both Ratios a b and c d are considered equal if and only if a cdot d b cdot c For example for the string the ratio will be 3 0 for 2 1 for 1 2 and for 2 4 Note that the ratios of the latter two strings are equal to each other but they are not equal to the ratios of the first two strings ,"['#include<bits/stdc++.h>\n#define P pair<int,int>\nusing namespace std;\nconst int N=5e5+5;\nint n,c1,c2,lp;\nchar s[N];\nmap<P,int> mp;\nint read()\n{\n\tint res=0,fl=0; char a=getchar();\n\twhile(a<\'0\'||a>\'9\') fl|=a==\'-\',a=getchar();\n\twhile(a>=\'0\'&&a<=\'9\') res=res*10+a-\'0\',a=getchar();\n\treturn fl? -res:res;\n}\nint gcd(int x,int y) {return y? gcd(y,x%y):x;}\nint main()\n{\n\tint i,j,li,tt=read();\n\twhile(tt--)\n\t{\n\t\tmp.clear(),scanf(""%d%s"",&n,s+1);\n\t\tfor(i=1,c1=c2=0;i<=n;i++)\n\t\t{\n\t\t\ts[i]==\'D\'? c1++:c2++;\n\t\t\tlp=gcd(c1,c2),j=c1/lp,li=c2/lp;\n\t\t\tcout<<(++mp[P(j,li)])<<\' \';\n\t\t}\n\t\tcout<<\'\\n\';\n\t}\n\treturn 0;\n}']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1500
A two dimensional array is called a array if each grid contains one of the two possible brackets or A path through the two dimensional array cells is called if any two consecutive cells in the path are side adjacent and each cell of the path is located below or to the right from the previous one A two dimensional array whose size equals is called a array if any string formed by writing out the brackets on some monotonous way from cell to cell forms a correct bracket sequence Let s define the operation of comparing two correct bracket arrays of equal size and like that Let s consider a given two dimensional array of priorities a two dimensional array of same size containing different integers from to Let s find such position in the two dimensional array that If there are several such positions let s choose the one where number is minimum If then otherwise If the position is not found then the arrays are considered equal Your task is to find a th two dimensional correct bracket array It is guaranteed that for the given sizes of and there will be no less than two dimensional correct bracket arrays ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef vector<string> vstr;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void pvp(T a, T b) { for (T i = a; i != b; ++i) cout << ""("" << i->first << "", "" << i->second << "") ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in_c() { int c; for (; (c = getchar()) <= \' \'; ) { if (!~c) throw ~0; } return c; }\nint in() { int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -in(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\nInt In() { Int x = 0, c; for (; (uint)((c = getchar()) - \'0\') >= 10; ) { if (c == \'-\') return -In(); if (!~c) throw ~0; } do { x = (x << 3) + (x << 1) + (c - \'0\'); } while ((uint)((c = getchar()) - \'0\') < 10); return x; }\n\nconst Int INF = 1001001001001001001LL;\nvoid pl(Int &t, Int f) { if ((t += f) >= INF) t = INF; }\n\nconst int LIM = 205;\nInt DP[210][210];\nvoid dping() {\n    int i, j;\n    DP[0][0] = 1;\n    for (i = 0; i < LIM; ++i) for (j = 0; j < LIM; ++j) {\n        if (i < j) pl(DP[i + 1][j], DP[i][j]);\n        pl(DP[i][j + 1], DP[i][j]);\n    }\n}\n\nint M, N;\nInt K;\nint C[210][210];\n\nint L;\nint D[210];\npint ps[210];\nchar seq[210];\nchar ans[210][210];\n\nInt dp[210][210];\nInt calc() {\n    int i, j;\n    memset(dp, 0, sizeof(dp));\n    dp[0][0] = 1;\n    for (i = 0; i < L; ++i) for (j = 0; j <= L / 2; ++j) if (dp[i][j]) {\n        if (seq[i] != \')\') pl(dp[i + 1][j + 1], dp[i][j]);\n        if (seq[i] != \'(\') if (j) pl(dp[i + 1][j - 1], dp[i][j]);\n    }\n    return dp[L][0];\n}\n\nint main() {\n    int x, y, z;\n    int l;\n    \n    //dping();\n    \n    for (; cin >> M >> N >> K; ) {\n        for (x = 0; x < M; ++x) for (y = 0; y < N; ++y) {\n            C[x][y] = in();\n        }\n        L = M + N - 1;\n        assert(L % 2 == 0);\n        memset(D, 0x3f, sizeof(D));\n        for (x = 0; x < M; ++x) for (y = 0; y < N; ++y) {\n            chmin(D[x + y], C[x][y]);\n        }\n        for (z = 0; z < L; ++z) {\n            ps[z] = mp(D[z], z);\n        }\n        sort(ps, ps + L);\n//cout<<""ps : "";for(z=0;z<L;++z)cout<<ps[z].second<<"" "";cout<<endl;\n        memset(seq, \'?\', L);\n        seq[L] = 0;\n        Int k = K;\n        for (l = 0; l < L; ++l) {\n            z = ps[l].second;\n            seq[z] = \'(\';\n            Int tmp = calc();\n            if (k > tmp) {\n                k -= tmp;\n                seq[z] = \')\';\n            }\n        }\n//cout<<""seq : ""<<seq<<endl;\n        for (x = 0; x < M; ++x) for (y = 0; y < N; ++y) {\n            ans[x][y] = seq[x + y];\n        }\n        for (x = 0; x < M; ++x) {\n            ans[x][N] = 0;\n            puts(ans[x]);\n        }\n    }\n    \n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2300
To destroy humanity The Monster Association sent n monsters to Earth s surface The i th monster has health h i and power p i With his last resort attack True Spiral Incineration Cannon Genos can deal k damage to all monsters alive In other words Genos can reduce the health of all monsters by k if k 0 with a single attack However after every attack Genos makes the monsters advance With their combined efforts they reduce Genos attack damage by the power of the daggerweakest monster ddaggeralive In other words the minimum p i among all currently living monsters is subtracted from the value of k after each attack daggerThe Weakest monster is the one with the least power ddaggerA monster is alive if its health is strictly greater than 0 Will Genos be successful in killing all the monsters ,"['#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<set>\nusing namespace std;\npair<int, int>a[100000];\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n, k;\n\t\tcin >> n >> k;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\tcin >> a[i].first;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\tcin >> a[i].second;\n\t\tmultiset<int>s;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\ts.emplace(a[i].second);\n\t\tsort(a, a + n);\n\t\tint pre = k;\n\t\tfor (int i = 0; i < n && k > 0;) {\n\t\t\tint j = i;\n\t\t\tfor (; j < n && a[j].first <= pre; ++j)\n\t\t\t\ts.erase(s.find(a[j].second));\n\t\t\tif (s.size())\n\t\t\t\tk -= *s.begin();\n\t\t\tpre += k;\n\t\t\ti = j;\n\t\t}\n\t\tcout << (k <= 0 ? ""NO\\n"" : ""YES\\n"");\n\t}\n}']","[0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0]",1200
On a weekend Qingshan suggests that she and her friend Daniel go hiking Unfortunately they are busy high school students so they can only go hiking on scratch paper A permutation p is written from left to right on the paper First Qingshan chooses an integer index x 1 le x le n and tells it to Daniel After that Daniel chooses another integer index y 1 le y le n y ne x The game progresses turn by turn and as usual Qingshan moves first The rules follow If it is Qingshan s turn Qingshan must change x to such an index x that 1 le x le n x x 1 x ne y and p x p x at the same time If it is Daniel s turn Daniel must change y to such an index y that 1 le y le n y y 1 y ne x and p y p y at the same time The person who can t make her or his move loses and the other wins You as Qingshan s fan are asked to calculate the number of possible x to make Qingshan win in the case both players play optimally ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nint lew[nax];\nint pra[nax];\n\nint lewo[nax];\nint prao[nax];\n\nint wyn;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%d"", &tab[i]);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (tab[i]>tab[i-1])\n\t\t\tlew[i]=lew[i-1];\n\t\tlew[i]++;\n\t\t\n\t\tif (tab[i]<tab[i-1])\n\t\t\tlewo[i]=lewo[i-1];\n\t\tlewo[i]++;\n\t}\n\tfor (int i=n; i; i--)\n\t{\n\t\tif (tab[i]>tab[i+1])\n\t\t\tpra[i]=pra[i+1];\n\t\tpra[i]++;\n\t\t\n\t\tif (tab[i]<tab[i+1])\n\t\t\tprao[i]=prao[i+1];\n\t\tprao[i]++;\n\t}\n\tint naj=0;\n\tvi wek;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tnaj=max(naj, max(lew[i], pra[i]));\n\t\twek.push_back(max(lew[i], pra[i]));\n\t}\n\tsort(wek.begin(), wek.end());\n\treverse(wek.begin(), wek.end());\n\tdebug() << wek;\n\tif (wek[0]==wek[1] || !(naj&1))\n\t{\n\t\tprintf(""0\\n"");\n\t\treturn 0;\n\t}\n\tdebug() << ""no"";\n\tfor (int i=1; i<=n; i++)\n\t\twyn+=(lew[i]==naj && pra[i]==naj);\n\tprintf(""%d\\n"", wyn);\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
To celebrate your birthday you have prepared a festive table Now you want to seat as many guests as possible The table can be represented as a rectangle with height h and width w divided into h times w cells Let i j denote the cell in the i th row and the j th column of the rectangle 1 le i le h 1 le j le w Into each cell of the table you can either put a plate or keep it empty As each guest has to be seated next to their plate you can only put plates on the edge of the table into the first or the last row of the rectangle or into the first or the last column Formally for each cell i j you put a plate into at least one of the following conditions must be satisfied i 1 i h j 1 j w To make the guests comfortable no two plates must be put into cells that have a common side or corner In other words if cell i j contains a plate you can t put plates into cells i 1 j i j 1 i 1 j i j 1 i 1 j 1 i 1 j 1 i 1 j 1 i 1 j 1 Put as many plates on the table as possible without violating the rules above ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, m;\n        std::cin >> n >> m;\n        \n        std::vector<std::string> s(n, std::string(m, \'0\'));\n        for (int i = 0; i < m; i += 2) {\n            s[0][i] = \'1\';\n        }\n        for (int i = 1; i < n; i++) {\n            if (s[i - 1][m - 1] != \'1\' && s[i - 1][m - 2] != \'1\') {\n                s[i][m - 1] = \'1\';\n            }\n        }\n        for (int i = m - 2; i >= 0; i--) {\n            if (s[n - 1][i + 1] != \'1\' && s[n - 2][i + 1] != \'1\') {\n                s[n - 1][i] = \'1\';\n            }\n        }\n        for (int i = n - 2; i > 1; i--) {\n            if (s[i + 1][0] != \'1\' && s[i + 1][1] != \'1\') {\n                s[i][0] = \'1\';\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            std::cout << s[i] << ""\\n"";\n        }\n    }\n    \n    return 0;\n}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
There is an undirected graph with n vertices and m edges Initially for each vertex i there is a monster with danger a i on that vertex For a monster with danger a i you can defeat it if and only if you have defeated at least a i other monsters before Now you want to defeat all the monsters First you choose some vertex s and defeat the monster on that vertex since you haven t defeated any monsters before a s has to be 0 Then you can move through the edges If you want to move from vertex u to vertex v then the following must hold either the monster on vertex v has been defeated before or you can defeat it now For the second case you defeat the monster on vertex v and reach vertex v You can pass the vertices and the edges any number of times Determine whether you can defeat all the monsters or not ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n    \n    int leader(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return leader(x) == leader(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return siz[leader(x)];\n    }\n};\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        \n        if (std::pair(a[u], u) < std::pair(a[v], v)) {\n            std::swap(u, v);\n        }\n        adj[u].push_back(v);\n    }\n    \n    std::vector<bool> ok(n);\n    \n    std::vector<int> order(n);\n    std::iota(order.begin(), order.end(), 0);\n    std::sort(order.begin(), order.end(), [&](int i, int j) {\n        return std::pair(a[i], i) < std::pair(a[j], j);\n    });\n    \n    DSU dsu(n);\n    \n    for (auto x : order) {\n        ok[x] = a[x] == 0;\n        for (auto y : adj[x]) {\n            y = dsu.leader(y);\n            if (ok[y] && dsu.size(y) >= a[x]) {\n                ok[x] = true;\n            }\n            dsu.merge(x, y);\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (!dsu.same(0, i)) {\n            std::cout << ""NO\\n"";\n            return;\n        }\n    }\n    \n    if (ok[dsu.leader(0)]) {\n        std::cout << ""YES\\n"";\n    } else {\n        std::cout << ""NO\\n"";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0]",2100
There are n fishermen who have just returned from a fishing trip The i th fisherman has caught a fish of size a i The fishermen will choose some order in which they are going to tell the size of the fish they caught the order is just a permutation of size n However they are not entirely honest and they may increase the size of the fish they have caught Formally suppose the chosen order of the fishermen is p 1 p 2 p 3 dots p n Let b i be the value which the i th fisherman in the order will tell to the other fishermen The values b i are chosen as follows the first fisherman in the order just honestly tells the actual size of the fish he has caught so b 1 a p 1 every other fisherman wants to tell a value that is than the value told by the previous fisherman and is divisible by the size of the fish that the fisherman has caught So for i 1 b i is the smallest integer that is both than b i 1 and a p i For example let n 7 a 1 8 2 3 2 2 3 If the chosen order is p 1 6 7 5 3 2 4 then b 1 a p 1 1 b 2 is the smallest integer divisible by 2 and greater than 1 which is 2 b 3 is the smallest integer divisible by 3 and greater than 2 which is 3 b 4 is the smallest integer divisible by 2 and greater than 3 which is 4 b 5 is the smallest integer divisible by 2 and greater than 4 which is 6 b 6 is the smallest integer divisible by 8 and greater than 6 which is 8 b 7 is the smallest integer divisible by 3 and greater than 8 which is 9 You have to choose the order of fishermen in a way that yields the minimum possible sum limits i 1 n b i ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nconst int N = 1005;\n\nunordered_map<int, int> match, tmp, pre, vis;\nint a[N];\nint n, len;\nlong long ans;\n\nint dfs(int u) {\n\tvis[u] = 1;\n\tint minn = 1e9;\n\tfor (int i = u;; i += u) {\n\t\tif (!match.count(i)) {\n\t\t\tpre[i] = u;\n\t\t\tminn = min(minn, i);\n\t\t\tbreak;\n\t\t}\n\t\tif (!vis.count(match[i])) {\n\t\t\tpre[i] = u;\n\t\t\ttmp[match[i]] = i;\n\t\t\tminn = min(minn, dfs(match[i]));\n\t\t}\n\t}\n\treturn minn;\n}\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tn = read();\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = read();\n\t\tlen = 0;\n\t\ttmp.clear();\n\t\tpre.clear();\n\t\tvis.clear();\n\t\tint ret = dfs(a[i]);\n\t\tans += ret;\n\t\twhile (ret) {\n\t\t\tmatch[ret] = pre[ret];\n\t\t\tret = tmp[pre[ret]];\n\t\t}\n\t}\n\tprintf(""%lld\\n"", ans);\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3100
Petya has got cards each card contains some integer The numbers on the cards can be the same Let s index all cards by consecutive integers from to We ll denote the number that is written on a card with number as In order to play one entertaining game with his friends Petya needs to split the cards into pairs so that each pair had equal numbers on the cards Help Petya do that ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct node\n{\n\tint i,x;\n}a[8000005];\nbool cmp( node c, node d )\n{\n\tif ( c.x != d.x )\n\t\treturn c.x < d.x;\n\telse return c.i < d.i;\n}\nint main()\n{\n\tint n;\n\tfreopen(""input.txt"",""r"",stdin);\n\tfreopen(""output.txt"",""w"",stdout);\n\tscanf( ""%d"", &n );\n\tfor ( int i = 0; i < 2 * n; i++ )\n\t{\n\t\tscanf( ""%d"", &a[i].x );\n\t\ta[i].i = i;\n\t}\n\tsort( a, a + 2 * n, cmp );\n\tbool u = true;\n\tfor ( int i = 0; i < 2 * n; i ++ )\n\tif ( i % 2 == 0 )\n\t{\n\t\tif ( a[i].x != a[i+1].x )\n\t\t{\n\t\t\tu = false;\n\t\t\tputs(""-1"");\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( u )\n\t{\n\t\tfor ( int i = 0; i < 2 * n; i++ )\n\t\tif ( i % 2 == 0 )\n\t\t\tprintf( ""%d %d\\n"", a[i].i+1, a[i+1].i+1 );\n\t\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1200
Leha is planning his journey from Moscow to Saratov He hates trains so he has decided to get from one city to another by car The path from Moscow to Saratov can be represented as a straight line well it s not that straight in reality but in this problem we will consider it to be straight and the distance between Moscow and Saratov is n km Let s say that Moscow is situated at the point with coordinate 0 km and Saratov at coordinate n km Driving for a long time may be really difficult Formally if Leha has already covered i kilometers since he stopped to have a rest he considers the i 1 th kilometer as a i 1 It is guaranteed that for every i in 1 n 1 a i le a i 1 The difficulty of the journey is denoted as the sum of difficulties of each kilometer in the journey Fortunately there may be some rest sites between Moscow and Saratov Every integer point from 1 to n 1 may contain a rest site When Leha enters a rest site he may have a rest and the next kilometer will have difficulty a 1 the kilometer after it difficulty a 2 and so on For example if n 5 and there is a rest site in coordinate 2 the difficulty of journey will be 2a 1 2a 2 a 3 the first kilometer will have difficulty a 1 the second one a 2 then Leha will have a rest and the third kilometer will have difficulty a 1 the fourth a 2 and the last one a 3 Another example if n 7 and there are rest sites in coordinates 1 and 5 the difficulty of Leha s journey is 3a 1 2a 2 a 3 a 4 Leha doesn t know which integer points contain rest sites So he has to consider every possible situation Obviously there are 2 n 1 different distributions of rest sites two distributions are different if there exists some point x such that it contains a rest site in exactly one of these distributions Leha considers all these distributions to be equiprobable He wants to calculate p the expected value of difficulty of his journey Obviously p cdot 2 n 1 is an integer number You have to calculate it modulo 998244353 ,"['//nie, 3 cze 2018, 13:38:19 CEST\n//Konrad Paluszek, University of Warsaw (former XIV LO Staszic)\n# include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 998244353;\nconst bool local = \n#ifdef LOCAL\ntrue;\n#else\nfalse;\n#endif\n#define f first\n#define s second\n#define FOR(i, b, e) for (int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for (int i = (b); i >= (int)(e); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define bvt(s, f) int s(int x){return f(x);}int s(UI x){return f(x);}int s(LL x){return f##ll(x);}int s(ULL x){return f##ll(x);}\n#define FORBITS(i,m)  for(decltype(m)lP6N4Slr=(m),i=lP6N4Slr?ctz(lP6N4Slr):0;lP6N4Slr;lP6N4Slr^=((decltype(m))1<<i),i=ctz(lP6N4Slr))\n#define FORDBITS(i,m) for(decltype(m)_6Im=(m),i=_6Im?8*sizeof(m)-clz(_6Im)-1:0;_6Im;_6Im^=((decltype(m))1<<i),i=8*sizeof(m)-clz(_6Im)-1)\n#define SUBS(i, mask) for(decltype(mask)i = (mask),NFR9xNQCJZTrYQ=1;NFR9xNQCJZTrYQ;NFR9xNQCJZTrYQ=i,i=(i-1)&(mask))\n#define PB push_back\n#define MP make_pair\n#define MT(a, b, c) MP(MP(a, b), c)\n#define MQ(a, b, c, d) MP(MP(a, b), MP(c, d))\n#define tri(a, b, c) pair <pair <a, b>, c>\n#define quadr(a, b, c, d) pair <pair <a, b>, pair <c, d> >\n#define EB emplace_back\n# define jvx(...)\n# define fkz(...) __VA_ARGS__ jvx()\n# define cxo(...) __VA_ARGS__\n#define uuu_id() uuu\nusing LL=long long;using PII=pair<int,int>;using VI=vector<int>;using SI=set<int>;\nusing MII=map<int,int>;using UMII=unordered_map<int, int>;using LD=long double;using TII=\npair<PII,int>;using QII=pair<PII,PII>;using UI=unsigned int;using ULL=unsigned long long;\n#define uuu(prev, t) using S##t=set<t>; using V##t=vector<t>; using M##t=map<t,t>;\\\n\tusing MI##t=map<int,t>;using US##t=unordered_set<t>; prev(S##t) prev(V##t)\n#define uuu_() uuu\n#define ymd(t) \n#define ymd2(t) fkz(uuu_)()(ymd, t)\n#define ymd3(t) cxo(cxo(cxo(fkz(uuu_)()(ymd2, t))))\n#define ymd4(t) using P##t = pair<t,t>; using T##t=tri(t,t,t); using Q##t=quadr(t,t,t,t); \\\n\tymd3(P##t) ymd3(T##t) ymd3(Q##t) ymd3(t)\nymd4(LL) ymd4(LD) ymd3(PII) ymd3(TII) ymd3(QII) ymd4(VI) ymd4(SI) ymd4(UI) ymd4(ULL)\nbvt(popc,__builtin_popcount)bvt(ctz,__builtin_ctz)bvt(clz,__builtin_clz)bvt(bit_parity,__builtin_parity)\n#define siz(r) ((int)r.size())\n#define ALL(r) r.begin(), r.end()\n#define sim template <class T\n#define ros return o\nsim,class N>bool mini(T&o,N h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(T&o,N h){if(o<h)ros=h,1;return 0;}\n#define oor >ostream &operator<<(ostream &o,\n#define urs(r) typename pta<typename remove_reference<decltype(r)>::type>::t\n#define bnt ;}sim> struct\nsim,class N oor pair<T,N>u){ros<<""<""<<u.f<<"", ""<<u.s<<"">"" bnt pta{using t=T;};sim,int N>struct pta<T[N]>{using t=T*;};\nsim,typename=typename enable_if<!is_same<T,string>::value,urs(T().end())>::type oor\nT u){int c=0;o<<""{"";for(auto e:u)o<<"", ""+2*!c++<<e;ros<<""}"";}\nint mpow(int b, int e) {int o = 1; while (e) {if (e & 1)o = o * 1ll * b % MOD;b = b * 1ll * b % MOD;e /= 2;}ros;}\nvoid dor(){cerr<<dec<<""\\033[0m""<<endl;}sim,class...N>void dor(T x,N...y){cerr<<boolalpha<<x<<""; "";dor(y...);} const bool deb =\n#define acv(N,O) sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(N o, T x) {ros O N(x);} \\\n  sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(T o, N x) {return N(o) O x;} \\\n  sim> typename enable_if<is_arithmetic<T>::value || is_same<T,N>::value, N&>::type operator O##=(N &o, T x) {ros = o O N(x);}\n#ifdef DEB\ntrue;\n#define debug(c...)cerr<<""\\033[1;""<<30+__LINE__%8<<""m[""<<__FUNCTION__<<""#""<<__LINE__<<""] \\033[""<<30+(__LINE__/8+__LINE__*3)%8<<""m"",::dor(c)\n#define rcu m);}g(+) g(-) g(*) g(/) g(%) g(<<) g(>>) g(^) g(|) g(&) g(>=) g(<=) g(>) g(<) g(!=) g(==)\n#define zub(h,t,n...) class N> auto operator h(n u)->nep<urs(t)> {return ngy(t,\nsim>string bte(T u){stringstream o;o<<u;ros.str()bnt nep;sim>T yyo(nep<T>);sim>nep<T>ngy(T v,string c,int m=0);sim>T yyo(T o){ros bnt\nnep{T v;string c;int m; nep<T>mask(){return ngy(v,c,1);}\n#define g(o) template<zub(o, v o u, N) ""("" + bte(*this) + "") "" #o "" ("" + bte(u) + "")"", m);}\ntemplate<zub([],v[yyo(u)],N)c+""[""+bte(u)+""]"",rcu};sim>nep<T>ngy(T v,string c,int m){return nep<T>{v,c,m};}\nsim>T yyo(nep<T> o){ros.v;}sim>int uhn(T){return 0;}sim>int uhn(nep<T>o){ros.m;}\n#define ccy(c, y) sim> class enable_if<c is_arithmetic<T>::value,string>::type ema(T u){return bte(y);}\nccy(,bitset<8*sizeof(T)>(u))ccy(!,u)sim,class N> string ema(pair<T,N> o) {return ""<"" + ema(o.f) + "", "" + ema(o.s) + "">"";}\n#define g(o) sim, zub(o, yyo(p) o u.v, T p, nep<N>) ""("" + bte(p) + "") "" #o "" ("" + bte(u) + "")"", uhn(p) + u.m);}\nsim>string bte(nep<T>o){ros.c+"" = ""+(o.m?ema(o.v):bte(o.v));}sim oor nep<T>m){ros<<bte(rcu sim>nep<T>ngy(nep<T>o,string c="""",int m=0){ros;}\n#undef g\n#define imie(a...) ngy(a, #a)\n#define imask(a...) ngy(a, #a, 1)\n#define range(u, g, c) ngy(list<urs(u[0])>(&u[yyo(g)], &u[yyo(c)] + 1), #u ""["" + bte(g) + ""..."" + bte(c) + ""]"")\n#define arr(a, i) imie(a)[imie(i)]\n#define arr2(a, i, j) imie(a)[imie(i)][imie(j)]\n#define arr3(a, i, j, k) imie(a)[imie(i)][imie(j)][imie(k)]\n#define arr4(a, i, j, k, q) imie(a)[imie(i)][imie(j)][imie(k)][imie(q)]\nvector <stringstream> lif;struct prux {prux() {lif.EB();}~prux() {lif.pop_back();}};\n#define mark_stack(c...) udz(__LINE__,c)\n#define udz(a,b...) erf(a, b)\n#define erf(l,c...) prux _4IJ1MYUxZy2p_Q##l;lif.back()<<""\\033[1;""<<30+l%8<<""m[""<<__FUNCTION__<<\\\n  ""#""<<l<<""] \\033[""<<30+(l/8+l*3)%8<<""m"";siw(c)\nvoid siw(){};sim, class...N> void siw(T x, N...y) {lif.back() << x << ""; "";siw(y...);}\n#define print_stack() cerr << ""STACK_TRACE_FROM:"" << __FUNCTION__ << ""#"" << __LINE__<<endl,nfl()\n#define ckx(o) template<zub(o, o yyo(u), nep<N>) #o ""("" + bte(u) + "")"", u.m);}\nsim> struct tqaz{T a;int u,d,l,r;};sim> tqaz<T> zaqt(T a,int u,int d,int l,int r){return tqaz<T>{a,u,d,l,r};}\n#define matr(a,u,d,l,r) ngy(zaqt(a,yyo(u),yyo(d),yyo(l),yyo(r)), #a""[""+bte(u)+""...""+bte(d)+""][""+bte(l)+""...""+bte(r)+""]"")\n#define avc(f) sim>string f(tqaz<T> x){vector<vector<string>> t;FOR(i,x.u,x.d){t.EB();FOR(j,x.l,x.r)t.back().PB(f(x.a[i][j]));}\\\nstringstream o;VI M;FOR(j,x.l,x.r){int m=0;FOR(i,x.u,x.d)maxi(m, siz(t[i-x.u][j-x.l]));M.PB(m);}FOR(i,x.u,x.d){o<<""\\n\\t[""<<i<<""] "";\\\nFOR(j,x.l,x.r){REP(_, M[j-x.l]-siz(t[i-x.u][j-x.l]))o<<"" "";o<<t[i-x.u][j-x.l]<<((j+1)%5?"", "":""; "");}}ros.str() + ""\\n"";}\nvoid nfl() {for (auto &s : lif)cerr << ""  "" << s.str() << ""\\033[m"" << endl;} ckx(+) ckx(-) ckx(!) ckx(~) avc(bte) avc(ema)\nstruct zet_p {int o;LD v;zet_p(LL x=0):o(x%MOD),v(x){} zet_p(LL x, LD y):o(x%MOD),v(y){} int get(){ros>=0?o:o+MOD;}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o,v+a.v);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o,v-a.v);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o,v*a.v);}\n  zet_p operator/(zet_p a) {assert(a.o != 0); return zet_p(o*1ll*mpow(a.o, MOD-2),v/a.v);}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nostream&operator<<(ostream &o, zet_p u) {ros<<""[""<<u.o<<"" @ ""<<u.v<<""]"";}using frac_mod = zet_p;\n#else\nfalse;\nstruct zet_p {int o;int get(){ros>=0?o:o+MOD;}zet_p(LL x=0):o(x%MOD){}zet_p(int x):o(x%MOD){}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o);}\n  zet_p operator/(zet_p a) {return zet_p(o*1ll*mpow(a.o, MOD - 2));}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nstruct frac_mod {int o,m;int get(){return (o*1ll*mpow(m,MOD-2)%MOD+MOD)%MOD;}frac_mod(int x=0):o(x%MOD),m(1){}frac_mod(LL x):o(x%MOD),m(1){}\n  frac_mod(LL a,LL b):o(a),m(b){}\n  frac_mod operator+(frac_mod a){return frac_mod(o*1ll*a.m+m*1ll*a.o,m*a.m);}\n  frac_mod operator-(frac_mod a){return frac_mod(o*1ll*a.m-m*1ll*a.o,m*a.m);}\n  frac_mod operator*(frac_mod a){return frac_mod(o*1ll*a.o,m*1ll*a.m);}\n  frac_mod operator/(frac_mod a){return frac_mod(o*1ll*a.m,m*1ll*a.o);}\n  bool operator==(frac_mod a) {return (o * 1ll * a.m - m * 1ll * a.o) % MOD == 0;}};\nacv(frac_mod, +) acv(frac_mod, -) acv(frac_mod, *) acv(frac_mod, /)\n#define debug(...)\n#define mark_stack(...)\n#define print_stack(...)\n#endif\nacv(zet_p, +) acv(zet_p, -) acv(zet_p, *) acv(zet_p, /)\n#define nok(o,c,r,l...) auto operator o(c p, r y)-> decltype(MP(l)) {return MP(l);}\n#define pcg(o) sim, class S, class N, class H> nok(o, pair<S u T>, pair<H u N>, p.f o y.f, p.s o y.s)\\\nsim,class S,class N,class=typename enable_if<!is_base_of<ios_base,typename remove_reference<T>::type>::value>::type>nok\\\n(o,T,pair<S u N>, p o y.f, p o y.s) sim, class S, class N> nok(o, pair<S u N>, T, p.f o y, p.s o y)\n#define clp(r) pcg(r) sim, class S, class N, class H> \\\n\tpair <T,S> & operator r##=(pair <T,S> &p, pair<N,H> y) {p.f r##= y.f; p.s r##= y.s; return p;}\\\n\tsim, class S, class N> pair <T,S> &operator r##=(pair<T,S> &p, N y) {p.f r##= y; p.s r##= y; return p;}\n#define u ,\n#define syd(o) sim, class N> auto operator o(pair<T,N> e) -> decltype(MP(o e.f, o e.s)) {return MP(o e.f, o e.s);}\nclp(+) clp(-) clp(*) clp(/) clp(%) clp(^) clp(|) clp(>>) clp(<<) clp(&) pcg(&&) pcg(||) syd(-) syd(+) syd(~) syd(!)\n#undef u\nsim> int dud(T &, T&);sim> char dud(T x, ...);\n#define muf(c...) {\\\n\tsim, class N> static T c get1(pair <T, N> c o){ros.f;}\\\n\tsim, class N> static N c get2(pair <T, N> c o){ros.s;}\\\n\tsim, class N, class S> static T c get1(tri(T, N, S) c o){ros.f.f;}\\\n\tsim, class N, class S> static N c get2(tri(T, N, S) c o){ros.f.s;}\\\n\tsim, class N, class S> static S c get3(tri(T, N, S) c o){ros.s;}\\\n\tsim, class N, class S, class H> static S c get3(quadr(T, N, S, H) c o){ros.s.f;}\\\n\tsim, class N, class S, class H> static H c get4(quadr(T, N, S, H) c o){ros.s.s;}\\\n};\ntemplate <class X> struct qul muf()\ntemplate <> struct qul <int> muf(&)\n#define get1(o) qul<decltype(dud(o, o))>::get1(o)\n#define get2(o) qul<decltype(dud(o, o))>::get2(o)\n#define get3(o) qul<decltype(dud(o, o))>::get3(o)\n#define get4(o) qul<decltype(dud(o, o))>::get4(o)\nsim, class N> using gyv = T;\nnamespace std {sim, class N> struct hash<pair<T,N>>{size_t operator()(const pair<T,N>&u)const {\n      return hash<T>()(u.f) * 440624741ULL ^ hash<N>()(u.s);}};\n  sim> struct hash<gyv<T, decltype(((T*)0)->end())>> {size_t operator()(const T& u) const {size_t o = 505347433;\nfor (auto e : u)o = hash<urs(e)>()(e) ^ o * 277953755ULL;ros;}};}\n\nconst int MN = 1e6 + 44;\nvoid PdAYB7V() {\n\tprint_stack();\n\tdebug(imie(MN) * 1ll * imie(MOD), ""make sure it is right!!!!"");\n\tdebug(""make sure m, n aren\'t misused"");\n\tdebug(""long longs!!!!!!!!!!!!!!!!!!!"");\n\tdebug(""run with m, n = 1"");\n\tdebug(""make sure bounds on values aren\'t misused"");\n\tdebug(""Check time/memory limit"");\n\twhile (getchar() != EOF);\n\texit(0);\n}\nint a[MN];\nint main() {\n\t#ifdef DEB\n\tatexit(PdAYB7V);\n\t#endif\n\tint n;\n\tscanf(""%d"", &n);\n\tREP(i, n)\n\t\tscanf(""%d"", a + i);\n\tzet_p ans = a[0];\n\tzet_p curr = a[0];\n\tzet_p powe = 1;\n\tFOR(i, 1, n - 1) {\n\t\tpowe /= 2;\n\t\tcurr += (a[i] - a[i - 1]) * powe;\n\t\tdebug(imie(curr));\n\t\tans += curr;\n\t}\n\tdebug(imie(ans));\n\tREP(i, n - 1)\n\t\tans *= 2;\n\tprintf(""%d\\n"", ans.get());\n}\n\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2000
There are cities in Berland Each city has its index an integer number from to The capital has index All the roads in Berland are two way The road system is such that there is exactly one path from the capital to each city i e the road map looks like a tree In Berland s chronicles the road map is kept in the following way for each city different from the capital there is kept number index of the last city on the way from the capital to Once the king of Berland Berl XXXIV decided to move the capital from city to city Naturally after this the old representation of the road map in Berland s chronicles became incorrect Please help the king find out a new representation of the road map in the way described above ,"['#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<list>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<ctime>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair <int,int> ii;\n#define sz(a) int((a).size())\n#define pb push_back\nconst int INF = 2147483647;\nconst double PI = 3.141592653589793;\nconst int N = 100000;\n\nbool vis[N];\nVI graf[N];\nint tab[N],i,j,k,k2,pop[N],n,r1,r2;\n\nvoid dfs (int w, int o) {\n     pop[w]=o;\n     vis[w]=true;\n     for (int i=0;i<graf[w].size();i++) if (!vis[graf[w][i]]) dfs(graf[w][i],w);\n}\n\nint main () {\nscanf (""%d %d %d"",&n,&r1,&r2);\nfor (i=1;i<=n;i++) {\n    graf[i].resize(0);\n    vis[i]=false;\n}\ni=1;\nfor (j=0;j<n-1;j++) {\n    if (i==r1) i++;\n    scanf (""%d"",&tab[i]);\n    graf[i].pb(tab[i]);\n    graf[tab[i]].pb(i);\n    i++;\n}\ndfs(r1,-1);\nk=pop[r2]; k2=r2;\nwhile (k!=-1) {\n      tab[k]=k2;\n      k=pop[k];\n      k2 = pop[k2];\n}\nfor (i=1;i<=n;i++) if (i!=r2) printf(""%d "",tab[i]);\nprintf(""\\n"");\n      \nreturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1600
One industrial factory is reforming working plan The director suggested to set a mythical detail production norm If at the beginning of the day there were details in the factory storage then by the end of the day the factory has to produce remainder after dividing by more details Unfortunately no customer has ever bought any mythical detail so all the details produced stay on the factory The board of directors are worried that the production by the given plan may eventually stop that means that there will be moment when the current number of details on the factory is divisible by Given the number of details on the first day and number check if the production stops at some moment ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdlib>\n\n#define rep(a,b,c) for(int a=b;a<=c;++a)\n#define per(a,b,c) for(int a=b;a>=c;--a)\n#define mp make_pair\n#define PII pair<int,int>\n#define PDD pair<double,double>\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n#define X first\n#define Y second\n#define PI 3.141592653589793\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int gcd(int x,int y){\n\tfor\t(int t;y;t=x%y,x=y,y=t);\n\treturn\tx;\n}\n\ninline ll gcd(ll x,ll y){\n\tfor\t(ll t;y;t=x%y,x=y,y=t);\n\treturn\tx;\n}\n\ninline void read(int &x){\n\tchar cc=getchar();\n\twhile\t(cc<\'0\' || cc>\'9\')\tcc=getchar();\n\tx=0;\n\twhile\t(cc>=\'0\' && cc<=\'9\'){\n\t\tx=x*10+cc-\'0\';\n\t\tcc=getchar();\n\t}\n}\n\nint vis[100010];\n\nint main(){\n\tmemset(vis,0,sizeof vis);\n\tint a,m;\n\tscanf(""%d %d"",&a,&m);\n\twhile\t(1){\n\t\tif\t(a==0){\n\t\t\tputs(""Yes"");\n\t\t\treturn\t0;\n\t\t}\n\t\tif\t(vis[a]){\n\t\t\tputs(""No"");\n\t\t\treturn\t0;\n\t\t}\n\t\tvis[a]=1;\n\t\ta=(a+a%m)%m;\n\t}\n\treturn\t0;\n}\n\n\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Vova promised himself that he would never play computer games But recently Firestorm a well known game developing company published their newest game World of Farcraft and it became really popular Of course Vova started playing it Now he tries to solve a quest The task is to come to a settlement named Overcity and spread a rumor in it Vova knows that there are characters in Overcity Some characters are friends to each other and they share information they got Also Vova knows that he can bribe each character so he or she starts spreading the rumor th character wants gold in exchange for spreading the rumor When a character hears the rumor he tells it to all his friends and they start spreading the rumor to their friends for free and so on The quest is finished when all characters know the rumor What is the minimum amount of gold Vova needs to spend in order to finish the quest Take a look at the notes if you think you haven t understood the problem completely ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << ""\\n""; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nint main() {\n\tint n = nxt(), m = nxt();\n\tvector<int> c(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tc[i] = nxt();\n\t}\n\tvector<vector<int>> a(n);\n\tfor (int i = 0; i < m; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\n\tint mn;\n\tlong long ans = 0;\n\tvector<char> used(n);\n\n\tfunction<void(int)> dfs = [&](int v) {\n\t\tif (used[v]) {\n\t\t\treturn;\n\t\t}\n\t\tused[v] = 1;\n\t\tmn = min(mn, c[v]);\n\t\tfor (int x : a[v]) {\n\t\t\tdfs(x);\n\t\t}\n\t};\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (!used[i]) {\n\t\t\tmn = 1e9 + 10;\n\t\t\tdfs(i);\n\t\t\tans += mn;\n\t\t}\n\t}\n\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1300
You were playing with permutation p of length n but you lost it in Blair Alabama Luckily you remember some information about the permutation More specifically you remember an array b of length n where b i is the number of indices j such that j i and p j p i You have the array b and you want to find the permutation p However your memory isn t perfect and you constantly change the values of b as you learn more For the next q seconds one of the following things happen 1 i x you realize that b i is equal to x 2 i you need to find the value of p i If there s more than one answer print any It can be proven that there s always at least one possible answer under the constraints of the problem Answer the queries so you can remember the array ,"['#ifndef LOCAL\n#pragma GCC optimize (""-Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nconst int nmax=ten(5)+10;\nint ans[nmax];\n\nvoid work(int l,int r,int v){\n\trng(i,l,r)ans[i]+=(ans[i]>=v);\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvvc<pi> bs(n);\n\trep(i,n)bs[i].eb(0,read());\n\tint q;cin>>q;\n\tint s=0;\n\tvvc<pi> qs(n);\n\trep(_,q){\n\t\tint t;cin>>t;\n\t\tif(t==1){\n\t\t\tint i,x;cin>>i>>x;\n\t\t\ti--;\n\t\t\tbs[i].eb(s,x);\n\t\t}else{\n\t\t\tint i;cin>>i;\n\t\t\ti--;\n\t\t\tqs[i].eb(s++,bs[i].back().b);\n\t\t}\n\t}\n\trep(i,n){\n\t\tbs[i].eb(s,-1);\n\t\trep(j,si(bs[i])-1){\n\t\t\twork(bs[i][j].a,bs[i][j+1].a,bs[i][j].b);\n\t\t}\n\t\tfor(auto [j,v]:qs[i])\n\t\t\tans[j]=v;\n\t}\n\trep(i,s)print(n-ans[i]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",3200
Vus the Cossack has two binary strings that is strings that consist only of and We call these strings a and b It is known that b leq a that is the length of b is at most the length of a The Cossack considers every substring of length b in string a Let s call this substring c He matches the corresponding characters in b and c after which he counts the number of positions where the two strings are different We call this function f b c For example let b 00110 and c 11000 In these strings the first second third and fourth positions are different Vus the Cossack counts the number of such substrings c such that f b c is For example let a 01100010 and b 00110 a has four substrings of the length b 01100 11000 10001 00010 f 00110 01100 2 f 00110 11000 4 f 00110 10001 4 f 00110 00010 1 Since in three substrings f b c is even the answer is 3 Vus can not find the answer for big strings That is why he is asking you to help him ,"['#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN=1000005;\n\nint n,m;\nchar a[MAXN],b[MAXN];\nint sa[MAXN],sb[MAXN];\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    //freopen(""code.in"",""r"",stdin);\n    //freopen(""code.out"",""w"",stdout);\n    #endif\n    scanf(""%s%s"",a+1,b+1);\n    n=strlen(a+1);m=strlen(b+1);\n    for(int i=1;i<=n;i++)sa[i]=(a[i]-\'0\')^sa[i-1];\n    for(int i=1;i<=m;i++)sb[i]=(b[i]-\'0\')^sb[i-1];\n    int ans=0;\n    for(int i=m;i<=n;i++)\n    \tif(!(sb[m]^sa[i]^sa[i-m]))++ans;\n    cout<<ans<<endl;\n    return 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
There is an infinite 2 dimensional grid Initially a robot stands in the point 0 0 The robot can execute four commands move from point x y to x y 1 move from point x y to x y 1 move from point x y to x 1 y move from point x y to x 1 y You are given a sequence of commands s of length n Your task is to answer q queries given four integers x y l and r determine whether the robot visits the point x y while executing a sequence s but the substring from l to r is reversed i e the robot performs commands in order s 1 s 2 s 3 dots s l 1 s r s r 1 s r 2 dots s l s r 1 s r 2 dots s n ,"['#include <algorithm>\n#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate <class T> int arglb(const std::vector<T> &v, const T &x) { return std::distance(v.begin(), std::lower_bound(v.begin(), v.end(), x)); }\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n\n    int N, Q;\n    string S;\n\n    cin >> N >> Q >> S;\n\n    vector<int> xs(N + 1), ys(N + 1);\n\n    map<pair<int, int>, vector<int>> mp;\n    mp[{0, 0}].push_back(0);\n\n    for (int i = 0; i < N; ++i) {\n        xs.at(i + 1) = xs.at(i) + (S.at(i) == \'R\') - (S.at(i) == \'L\');\n        ys.at(i + 1) = ys.at(i) + (S.at(i) == \'U\') - (S.at(i) == \'D\');\n        mp[{xs.at(i + 1), ys.at(i + 1)}].push_back(i + 1);\n    }\n\n    while (Q--) {\n        int x, y, l, r;\n        cin >> x >> y >> l >> r;\n        --l;\n\n        const int xrem = x - xs.at(l), yrem = y - ys.at(l);\n\n        const int xt = xs.at(r) - xrem, yt = ys.at(r) - yrem;\n\n        bool found = false;\n        if (auto itr = mp.find({xt, yt}); itr != mp.end()) {\n            const auto &vec = itr->second;\n            int i = arglb(vec, l);\n            if (i < (int)vec.size() and vec.at(i) <= r) found = true;\n        }\n\n        if (auto itr = mp.find({x, y}); itr != mp.end()) {\n            const auto &vec = itr->second;\n            if (vec.back() >= r) found = true;\n            if (vec.front() <= l) found = true;\n        }\n\n        cout << (found ? ""YES"" : ""NO"") << \'\\n\';\n    }\n}\n']","[0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1900
Monocarp is playing a video game In the game he controls a spaceship and has to destroy an enemy spaceship Monocarp has two lasers installed on his spaceship Both lasers 1 and 2 have two values p i the power of the laser t i the reload time of the laser When a laser is fully charged Monocarp can either shoot it or wait for the other laser to charge and shoot both of them at the same time An enemy spaceship has h durability and s shield capacity When Monocarp shoots an enemy spaceship it receives P s damage i e P s gets subtracted from its durability where P is the total power of the lasers that Monocarp shoots i e p i if he only shoots laser i and p 1 p 2 if he shoots both lasers at the same time An enemy spaceship is considered destroyed when its durability becomes 0 or lower Initially both lasers are zero charged What s the lowest amount of time it can take Monocarp to destroy an enemy spaceship ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int p1, p2, h, s;\n    i64 t1, t2;\n    \n    std::cin >> p1 >> t1 >> p2 >> t2 >> h >> s;\n    \n    std::vector<i64> dp(h + 1);\n    dp[0] = 0;\n    for (int i = 1; i <= h; i++) {\n        dp[i] = std::min(dp[std::max(0, i - (p1 - s))] + t1, dp[std::max(0, i - (p2 - s))] + t2);\n        for (int j = 1; j <= i; j++) {\n            if (j * t1 >= t2) {\n                i64 dmg = (j - 1) * (p1 - s) + (j * t1 - t2) / t2 * (p2 - s) + (p1 + p2 - s);\n                dp[i] = std::min(dp[i], dp[std::max(0LL, i - dmg)] + j * t1);\n            }\n            if (j * t2 >= t1) {\n                i64 dmg = (j - 1) * (p2 - s) + (j * t2 - t1) / t1 * (p1 - s) + (p1 + p2 - s);\n                dp[i] = std::min(dp[i], dp[std::max(0LL, i - dmg)] + j * t2);\n            }\n        }\n    }\n    std::cout << dp[h] << ""\\n"";\n    \n    return 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2400
Vasya often uses public transport The transport in the city is of two types trolleys and buses The city has buses and trolleys the buses are numbered by integers from to the trolleys are numbered by integers from to Public transport is not free There are 4 types of tickets A ticket for one ride on some bus or trolley It costs burles A ticket for an unlimited number of rides on some bus or on some trolley It costs burles A ticket for an unlimited number of rides on all buses or all trolleys It costs burles A ticket for an unlimited number of rides on all buses and trolleys It costs burles Vasya knows for sure the number of rides he is going to make and the transport he is going to use He asked you for help to find the minimum sum of burles he will have to spend on the tickets ,"['#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\nlong long a[1111],b[1111],cost[11],n,m;\n\nint main()\n{\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tcin >> cost[i];\n\t}\n\tcin >> n >> m;\n\tfor(int i=0; i<n; i++) cin >> a[i]; \n\tfor(int i=0; i<m; i++) cin >> b[i];\n\tlong long ans=min(cost[3],2*cost[2]);\n\tlong long mi=0;\n\tfor(int i=0; i<n; i++) \n\t{\n\t\tlong long cur =min(a[i]*cost[0],cost[1]);\n\t\tmi+=cur;\n\t} \n\tmi=min(mi,cost[2]);\n\tlong long mmi=0;\n\tfor(int i=0; i<m; i++) \n\t{\n\t\tlong long cur=min(b[i]*cost[0],cost[1]);\n\t\tmmi+=cur;\n\t} \t\n\tmmi=min(mmi,cost[2]);\n\tmi+=mmi;\n\tans=min(mi,ans);\n\tcout << ans << endl;\t\n\tcin >> n;\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
The Saratov State University Olympiad Programmers Training Center SSU OPTC has students For each student you know the number of times he she has participated in the ACM ICPC world programming championship According to the ACM ICPC rules each person can participate in the world championship at most 5 times The head of the SSU OPTC is recently gathering teams to participate in the world championship Each team must consist of exactly three people at that any person cannot be a member of two or more teams What maximum number of teams can the head make if he wants each team to participate in the world championship with the same members at least times ,"['#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint a, b, c, nom;\n\nint main(){\n    cin >> a >> b;\n    for(int i = 0; i < a; ++i){\n\tcin >> c;\n\tif(5 - b >= c) ++nom;\n    }\n    cout << nom / 3;\n  \n    return 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",800
Mainak has a convex polygon mathcal P with n vertices labelled as A 1 A 2 ldots A n in a counter clockwise fashion The coordinates of the i th point A i are given by x i y i where x i and y i are both integers Further it is known that the interior angle at A i is either a right angle or a proper obtuse angle Formally it is known that 90 circ le angle A i 1 A i A i 1 180 circ forall i in 1 2 ldots n where we conventionally consider A 0 A n and A n 1 A 1 Mainak s friend insisted that all points Q such that there exists a chord of the polygon mathcal P passing through Q with length 1 must be coloured color red text red Mainak wants you to find the area of the coloured region formed by the color red text red points Formally determine the area of the region mathcal S Q in mathcal P Q text is coloured color red text red Recall that a chord of a polygon is a line segment between two points lying on the boundary vertices or points on edges of the polygon ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n \nusing ll = long long;\nusing db = double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = (int)1e9+7; // 998244353;\nconst int MX = (int)2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n/**\n * Description: Use in place of \\texttt{complex<T>}.\n * Source: http://codeforces.com/blog/entry/22175, KACTL\n * Verification: various\n */\n\nusing T = db; // or ll\nconst T EPS = 1e-9; // adjust as needed\nusing P = pair<T,T>; using vP = V<P>; using Line = pair<P,P>;\nint sgn(T a) { return (a>EPS)-(a<-EPS); }\nT sq(T a) { return a*a; }\n\nbool close(const P& a, const P& b) { \n\treturn sgn(a.f-b.f) == 0 && sgn(a.s-b.s) == 0; } \nT norm(const P& p) { return sq(p.f)+sq(p.s); }\nT abs(const P& p) { return sqrt(norm(p)); }\nT arg(const P& p) { return atan2(p.s,p.f); }\nP conj(const P& p) { return P(p.f,-p.s); }\nP perp(const P& p) { return P(-p.s,p.f); }\nP dir(T ang) { return P(cos(ang),sin(ang)); }\n\nP operator-(const P& l) { return P(-l.f,-l.s); }\nP operator+(const P& l, const P& r) { \n\treturn P(l.f+r.f,l.s+r.s); }\nP operator-(const P& l, const P& r) { \n\treturn P(l.f-r.f,l.s-r.s); }\nP operator*(const P& l, const T& r) { \n\treturn P(l.f*r,l.s*r); }\nP operator*(const T& l, const P& r) { return r*l; }\nP operator/(const P& l, const T& r) { \n\treturn P(l.f/r,l.s/r); }\nP operator*(const P& l, const P& r) { \n\treturn P(l.f*r.f-l.s*r.s,l.s*r.f+l.f*r.s); }\nP operator/(const P& l, const P& r) { \n\treturn l*conj(r)/norm(r); }\nP& operator+=(P& l, const P& r) { return l = l+r; }\nP& operator-=(P& l, const P& r) { return l = l-r; }\nP& operator*=(P& l, const T& r) { return l = l*r; }\nP& operator/=(P& l, const T& r) { return l = l/r; }\nP& operator*=(P& l, const P& r) { return l = l*r; }\nP& operator/=(P& l, const P& r) { return l = l/r; }\n\nP unit(const P& p) { return p/abs(p); }\nT dot(const P& a, const P& b) { return a.f*b.f+a.s*b.s; }\nT dot(const P& p, const P& a, const P& b) { return dot(a-p,b-p); }\nT cross(const P& a, const P& b) { return a.f*b.s-a.s*b.f; }\nT cross(const P& p, const P& a, const P& b) {\n\treturn cross(a-p,b-p); }\nP reflect(const P& p, const Line& l) {\n\tP a = l.f, d = l.s-l.f;\n\treturn a+conj((p-a)/d)*d; }\nP foot(const P& p, const Line& l) {\n\treturn (p+reflect(p,l))/(T)2; }\nbool onSeg(const P& p, const Line& l) {\n\treturn sgn(cross(l.f,l.s,p)) == 0 && sgn(dot(p,l.f,l.s)) <= 0; }\n\n/** \n * Description: computes the intersection point(s) of line (segments) $a$ and $b$\n * Source: KACTL\n * Verification: https://open.kattis.com/problems/segmentintersection\n */\n\n// #include ""Point.h""\n\n// {unique intersection point} if it exists\n// {b.f,b.s} if input lines are the same\n// empty if lines do not intersect\nvP lineIsect(const Line& a, const Line& b) {\n\tT a0 = cross(a.f,a.s,b.f), a1 = cross(a.f,a.s,b.s); \n\tif (a0 == a1) return a0 == 0 ? vP{b.f,b.s} : vP{};\n\treturn {(b.s*a0-b.f*a1)/(a0-a1)};\n}\n\n// point in interior of both segments a and b, if it exists\nvP strictIsect(const Line& a, const Line& b) {\n\tT a0 = cross(a.f,a.s,b.f), a1 = cross(a.f,a.s,b.s); \n\tT b0 = cross(b.f,b.s,a.f), b1 = cross(b.f,b.s,a.s); \n\tif (sgn(a0)*sgn(a1) < 0 && sgn(b0)*sgn(b1) < 0)\n\t\treturn {(b.s*a0-b.f*a1)/(a0-a1)};\n\treturn {};\n}\n\n// intersection of segments, a and b may be degenerate\nvP segIsect(const Line& a, const Line& b) { \n\tvP v = strictIsect(a,b); if (sz(v)) return v;\n\tset<P> s;\n\t#define i(x,y) if (onSeg(x,y)) s.ins(x)\n\ti(a.f,b); i(a.s,b); i(b.f,a); i(b.s,a);\n\treturn {all(s)};\n}\n\nP strictIsectOne(const Line& a, const Line& b) {\n\tT a0 = cross(a.f,a.s,b.f), a1 = cross(a.f,a.s,b.s); \n\t// T b0 = cross(b.f,b.s,a.f), b1 = cross(b.f,b.s,a.s); \n\treturn (b.s*a0-b.f*a1)/(a0-a1);\n}\n\nconst int DIVISIONS = 1000;\n\nvP get_hull(T C) {\n\tif (C <= -1) return {};\n\t// assert(-1 < C && C <= 0);\n\tvP hull;\n\tP last_isect;\n\tLine last_pair;\n\tF0R(i,DIVISIONS+1) {\n\t\tP on_x{(T)i/DIVISIONS,0};\n\t\tP u{C,sqrt(1-sq(C))};\n\t\tP f = foot(on_x,{{0,0},u});\n\t\tP actual = f+u*sqrt(max(1-norm(f-on_x),0.0));\n\t\tLine cur_pair{on_x,actual};\n\t\tif (i == 0) {\n\t\t\tlast_isect = u;\n\t\t} else {\n\t\t\tP nex_isect = strictIsectOne(last_pair, cur_pair);\n\t\t\tlast_isect = nex_isect;\n\t\t}\n\t\tlast_pair = cur_pair;\n\t\thull.pb(last_isect);\n\t}\n\thull.pb({1,0});\n\treturn hull;\n}\n\nT solve1(T C) {\n\tassert(C <= 0);\n\tvP hull = get_hull(C); // left to right\n\tT ans = 0;\n\tF0R(i,sz(hull)-1) ans += cross(hull[i+1],hull[i]);\n\treturn ans/2;\n}\n\nvoid print_all(V<P> v) {\n\teach(t,v) ps(t.f,t.s);\n}\n\nT solve2(T d, T c0, T c1) {\n\tdbg(""START"", d, c0, c1);\n\tauto h0 = get_hull(c0);\n\tauto h1 = get_hull(c1);\n\teach(t,h1) t = {d-t.f,t.s};\n\th0.pop_back(), h1.pop_back();\n\t// dbg(""S0"");\n\t// print_all(h0);\n\t// dbg(""S1"");\n\t// print_all(h1);\n\t// dbg(h1.ft, h1.bk); exit(0);\n\twhile (sz(h0) >= 2 && sz(h1) >= 2) {\n\t\t// exit(0);\n\t\tif (cross(end(h1)[-2], end(h0)[-1], end(h0)[-2]) >= 0) {\n\t\t\th1.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tif (cross(end(h0)[-2], end(h1)[-2], end(h1)[-1]) >= 0) {\n\t\t\th0.pop_back();\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tassert(sz(h0) >= 2 && sz(h1) >= 2);\n\t// dbg(""AFTER REDUCE"", h0.bk, h1.bk);\n\tP p = strictIsectOne({end(h0)[-1], end(h0)[-2]}, {end(h1)[-1], end(h1)[-2]});\n\th0.pop_back(), h1.pop_back();\n\th0.pb(p);\n\treverse(all(h1));\n\th0.ins(end(h0), all(h1));\n\t// dbg(""E"");\n\t// print_all(h0);\n\t// exit(0);\n\n\t// each(t,h0) dbg(t);\n\t// exit(0);\n\tdbg(""FINAL"", h0.ft, h0.bk);\n\n\tT ans = cross({d,0},h0.bk);\n\tF0R(i,sz(h0)-1) {\n\t\tans += cross(h0[i+1],h0[i]);\n\t}\n\tdbg(""GOT"",ans);\n\tdbg(""UNION"",ans/2);\n\treturn ans/2;\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tints(N);\n\tvP A(N); re(A);\n\t// if rect\n\tif (N == 4 && (norm(A[0]-A[1]) <= 1 || norm(A[1]-A[2]) <= 1)) {\n\t\tps(max(abs(A[0]-A[1]), abs(A[1]-A[2])));\n\t\texit(0);\n\t}\n\tV<T> C, sing;\n\tF0R(i,N) {\n\t\tint a = (i+N-1)%N, b = i, c = (i+1)%N;\n\t\tP x = A[a]-A[b], y = A[c]-A[b];\n\t\tdb huh = dot(x,y)/abs(x)/abs(y);\n\t\tif (huh > 0) {\n\t\t\tps(""A"");\n\t\t\texit(0);\n\t\t}\n\t\tif (huh <= -1) {\n\t\t\tps(""B"");\n\t\t\texit(0);\n\t\t}\n\t\tC.pb(huh);\n\t\t// S.pb(sqrt(1-sq(C.bk)));\n\t}\n\tT ans = 0;\n\tF0R(i,N) sing.pb(solve1(C[i]));\n\teach(t,sing) ans += t;\n\tF0R(i,N) {\n\t\tint j = (i+1)%N;\n\t\tif (norm(A[i]-A[j]) <= 2) {\n\t\t\tif (min(sing[i],sing[j]) > -1) {\n\t\t\t\tT sol2 = solve2(abs(A[i]-A[j]), C[i], C[j]);\n\t\t\t\tassert(sol2 <= sing[i]+sing[j]);\n\t\t\t\tans += sol2-sing[i]-sing[j];\n\t\t\t}\n\t\t}\n\t}\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",3500
It is given a non negative integer x the decimal representation of which contains n digits You need to color its digit in red or black so that the number formed by the red digits is divisible by A and the number formed by the black digits is divisible by B digit must be colored in each of two colors Consider the count of digits colored in red is r and the count of digits colored in black is b Among all possible colorings of the given number x you need to output any such that the value of r b is Note that the number x and the numbers formed by digits of each color The figure above shows an example of painting the number x 02165 of n 5 digits for A 3 and B 13 The red digits form the number 015 which is divisible by 3 and the black ones 26 which is divisible by 13 Note that the absolute value of the difference between the counts of red and black digits is 1 it is impossible to achieve a smaller value ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,a,b;\nstring s;\nconst int N =  42;\nint vis[N][N][N][N];\nint stc[N], colors[N];\nint ans;\n\nvoid lui(int id, int mod_a, int mod_b, int num_a) {\n    if (id == n) {\n        if (mod_a == 0 && mod_b == 0 && num_a > 0 && num_a < n) {\n            if (abs(n-2*num_a) < ans) {\n                ans = abs(n-2*num_a);\n                for (int i = 0 ; i < n; ++ i) {\n                    colors[i] = stc[i];\n                }\n            }\n        }\n\n        return ;\n    }\n\n    if (vis[id][mod_a][mod_b][num_a] == 1) {\n        return ;\n    }\n\n    vis[id][mod_a][mod_b][num_a] = 1;\n\n    stc[id] = 0;\n    lui(id+1, (mod_a*10 + s[id]-\'0\') % a, mod_b, num_a+1);\n    stc[id] = 1;\n    lui(id+1, mod_a, (mod_b*10+s[id]-\'0\')%b, num_a);\n    return;\n}\n\nint main() {\n  \n    int t;\n    cin >> t;\n    while (t--) {\n        cin >> n >> a >> b;\n        cin >> s;\n        memset(vis, 0 , sizeof(vis));\n        ans = 1e9;\n        lui(0, 0, 0, 0);\n        if (ans != 1e9) {\n            for (int i = 0 ; i < n ; ++ i) {\n                if (colors[i] == 0) {\n                    cout << ""R"";\n                } else {\n                    cout << ""B"";\n                }\n            }\n            cout << endl;\n        }  else {\n            cout << -1 << endl;\n        }\n    }\n    return 0;\n}']","[0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2100
Ivan loves burgers and spending money There are n burger joints on the street where Ivan lives Ivan has q friends and the i th friend suggested to meet at the joint l i and walk to the joint r i l i leq r i While strolling with the i th friend Ivan can visit all joints x which satisfy l i leq x leq r i For each joint Ivan knows the cost of the most expensive burger in it it costs c i burles Ivan wants to visit some subset of joints on his way in each of them he will buy the most expensive burger and spend the most money But there is a small issue his card broke and instead of charging him for purchases the amount of money on it changes as follows If Ivan had d burles before the purchase and he spent c burles at the joint then after the purchase he would have d oplus c burles where oplus denotes the bitwise XOR operation Currently Ivan has 2 2 100 1 burles and he wants to go out for a walk Help him to determine the maximal amount of burles he can spend if he goes for a walk with the friend i The amount of burles he spends is defined as the difference between the initial amount on his account and the final account ,"['#include<bits/stdc++.h>\n#define MAXN 500005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,q,a[MAXN],ans[MAXN],bas[40],pos[40];\nvector<P> eve[MAXN];\nint main()\n{\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++) scanf(""%d"",&a[i]);\n    scanf(""%d"",&q);\n    for(int i=0;i<q;i++)\n    {\n        int l,r;scanf(""%d%d"",&l,&r);\n        eve[r].push_back(P(l,i));\n    }\n    for(int i=1;i<=n;i++)\n    {\n        int x=a[i],p=i;\n        for(int j=20;j>=0;j--)\n        {\n            if(x&(1<<j))\n            {\n                if(!bas[j])\n                {\n                    bas[j]=x;pos[j]=p;\n                    break;\n                }\n                if(pos[j]<p) swap(bas[j],x),swap(pos[j],p);\n                x^=bas[j];\n            }\n        }\n        for(auto p:eve[i])\n            for(int j=20;j>=0;j--)\n                if(pos[j]>=p.F) ans[p.S]=max(ans[p.S],ans[p.S]^bas[j]);\n    }\n    for(int i=0;i<q;i++) printf(""%d\\n"",ans[i]);\n    return 0;\n}\n']","[1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
A is a sequence of integers consisting of distinct positive integers each of them doesn t exceed Let s denote the th element of permutation as We ll call number the size of permutation Nickolas adores permutations He likes some permutations more than the others He calls such permutations perfect A permutation is such permutation that for any is the permutation size the following equations hold and Nickolas asks you to print any perfect permutation of size for the given ,"['#include<cstdio>\n\nint n;\n\nint main()\n{\nscanf(""%d"",&n);\nif (n&1) printf(""-1\\n"");\nelse\n  for (int i=1;i<=n/2;i++) printf(""%d %d "",i*2,i*2-1);\nreturn 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Some time ago Leonid have known about defined on a set is such function that for any the formula holds Let s denote as the function applied times to the value More formally for each You are given some function Your task is to find minimum positive integer such that function is ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 210;\n\nint N;\nint arr[MAXN];\nll mdist, mult;\nbool bad[MAXN];\n\nll gcd (ll a, ll b)\n{\n    if (b == 0) return a;\n    return gcd (b, a % b);\n}\n\nll lcd (ll a, ll b)\n{\n    ll g = gcd (a, b);\n    return a / g * b;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    \n    cin >> N;\n    for (int i = 0; i < N; i++)\n    {\n        cin >> arr[i];\n        arr[i]--;\n    }\n    \n    mdist = 0, mult = 1;\n    \n    for (int i = 0; i < N; i++)\n        bad[i] = false;\n    \n    for (int i = 0; i < N; i++)\n    {\n        int tot = 1, cloc = i;\n        for (int j = 0; j < N; j++)\n            cloc = arr[cloc];\n        \n        if (bad[cloc]) continue;\n        \n        int lval = cloc;\n        bad[cloc] = true;\n        cloc = arr[cloc];\n        while (lval != cloc)\n        {\n            //cout << cloc << "" 1\\n"";\n            bad[cloc] = true;\n            tot++;\n            cloc = arr[cloc];\n        }\n        \n        //cout << i << "" "" << tot << ""\\n"";\n        if (tot > 0)\n            mult = lcd (mult, (ll) tot);\n    }\n    \n    for (int i = 0; i < N; i++)\n    {\n        int tot = 0, cloc = i;\n        while (!bad[cloc])\n        {\n            //cout << cloc << "" 2\\n"";\n            tot++;\n            cloc = arr[cloc];\n        }\n        \n        mdist = max (mdist, (ll) tot);\n    }\n    \n    //cout << mdist << "" "" << mult << endl;\n    \n    ll res = (mdist / mult + 1) * mult;\n    while (res >= mdist + mult)\n        res -= mult;\n    while (res < mult)\n        res += mult;\n    \n    cout << res << ""\\n"";\n    return 0;\n}']","[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2000
You are given a sequence of integers of length n and integer number k You should print number x in the range of 1 10 9 i e 1 le x le 10 9 such that exactly k elements of given sequence are less than or equal to x Note that the sequence can contain equal elements If there is no such x print without quotes ,"['/*input\n7 2\n3 7 5 1 10 3 20\n\n\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define db(a) cerr<<#a<<"" = ""<<a<<\'\\n\'\nusing namespace std;\n\nint main(){\n\tint n, k;\n\tcin >> n >> k;\n\n\tint a[n];\n\t\n\tfor(int i=0; i<n; i++){\n\t\tcin >> a[i];\n\t}\n\n\tsort(a, a+n);\n\n\tif(k == 0){\n\t\tif(a[0] != 1){\n\t\t\tcout << 1 << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << -1 << endl;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(k == n){\n\t\tcout << a[n-1] << endl;\n\t} else {\n\t\tif(a[k-1] != a[k]){\n\t\t\tcout << a[k-1] << endl;\n\t\t} else {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n\n}\n\t']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1200
You are playing a game The circle is divided into n sectors sectors are numbered from 1 to n in some order You are in the adjacent room and do not know either the number of sectors or their numbers There is also an arrow that initially points to some sector Initially the host tells you the number of the sector to which the arrow points After that you can ask the host to move the arrow k sectors counterclockwise or clockwise at most 2023 times And each time you are told the number of the sector to which the arrow points Your task is to determine the integer n the number of sectors in at most 2023 queries It is guaranteed that 1 le n le 10 6 ,"['#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n    int a=0;int f=0;char p=getchar();\n    while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n    return f?-a:a;\n}\nvoid YES(bool flag=true)\n{\n    if(flag)    puts(""YES"");\n    else    puts(""NO"");\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nint T;\nint n;\nint tot=1;\nint rnd()\n{\n\ttot++;\n\tif(tot<=1000)\treturn 1;\n\treturn 1000;\n}\nint now=1;\nint query(int x)\n{\n\t//now=(now+x-1)%5+1;\n\t//return now;\n\tcout<<""+ ""<<x<<endl;\n\tint p=read();\n\treturn p;\n}\nmap<int ,ll >tag;\nint main()\n{\n\tn=read();\ttag[n]=1;\n\tint tot=1;\n\tint ans;\n\tint pp;\n\twhile(true)\n\t{\n\t\tint len=rnd();\ttot+=len;\tint x=query(len);\n\t\tif(tag[x])\n\t\t{\n\t\t\tans=tot-tag[x];\n\t\t\tpp=x;\n\t\t\tbreak;\n\t\t}\n\t\telse\ttag[x]=tot;\n\t}\n\tprintf(""! %d"",ans);\n    return 0;\n}']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Recently Pari and Arya did some research about NP Hard problems and they found the problem very interesting Suppose the graph is given Subset of its vertices is called a of this graph if for each edge there is at least one endpoint of it in this set i e or or both Pari and Arya have won a great undirected graph as an award in a team contest Now they have to split it in two parts but both of them want their parts of the graph to be a vertex cover They have agreed to give you their graph and you need to find two subsets of its vertices and such that both and are vertex cover or claim it s impossible Each vertex should be given to no more than one of the friends or you can even keep it for yourself ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\n\nint n,m,u,v,col[N];\nVI e[N],vec[10];\nvoid dfs(int u) {\n\tfor (auto v:e[u]) {\n\t\tif (col[v]==0) {\n\t\t\tcol[v]=3-col[u];\n\t\t\tdfs(v);\n\t\t} else if (col[u]+col[v]!=3) {\n\t\t\tputs(""-1"");\n\t\t\texit(0);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\trep(i,1,n+1) if (col[i]==0) {\n\t\tcol[i]=1;\n\t\tdfs(i);\n\t}\n\trep(i,1,n+1) vec[col[i]].pb(i);\n\tprintf(""%d\\n"",SZ(vec[1]));\n\tfor (auto p:vec[1]) printf(""%d "",p);\n\tputs("""");\n\tprintf(""%d\\n"",SZ(vec[2]));\n\tfor (auto p:vec[2]) printf(""%d "",p);\n\tputs("""");\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1500
Pussycat Sonya has an array consisting of positive integers There are possible subsequences of the array For each subsequence she counts the minimum number of operations to make all its elements equal Each operation must be one of two Choose some element of the subsequence and multiply it by some prime number Choose some element of the subsequence and divide it by some prime number The chosen element must be divisible by the chosen prime number What is the sum of minimum number of operations for all possible subsequences Find and print this sum modulo ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\n\ntypedef pair<ll,ll> PLL;\nnamespace Factor {\n\tconst int N=1010000;\n\tll C,fac[10010],n,mut,a[1001000];\n\tint T,cnt,i,l,prime[N],p[N],psize,_cnt;\n\tll _e[100],_pr[100];\n\tvector<ll> d;\n\tinline ll mul(ll a,ll b,ll p) {\n\t\tif (p<=1000000000) return a*b%p;\n\t\telse if (p<=1000000000000ll) return (((a*(b>>20)%p)<<20)+(a*(b&((1<<20)-1))))%p;\n\t\telse {\n\t\t\tll d=(ll)floor(a*(long double)b/p+0.5);\n\t\t\tll ret=(a*b-d*p)%p;\n\t\t\tif (ret<0) ret+=p;\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvoid prime_table(){\n\t\tint i,j,tot,t1;\n\t\tfor (i=1;i<=psize;i++) p[i]=i;\n\t\tfor (i=2,tot=0;i<=psize;i++){\n\t\t\tif (p[i]==i) prime[++tot]=i;\n\t\t\tfor (j=1;j<=tot && (t1=prime[j]*i)<=psize;j++){\n\t\t\t\tp[t1]=prime[j];\n\t\t\t\tif (i%prime[j]==0) break;\n\t\t\t}\n\t\t}\n\t}\n\tvoid init(int ps) {\n\t\tpsize=ps;\n\t\tprime_table();\n\t}\n\tll powl(ll a,ll n,ll p) {\n\t\tll ans=1;\n\t\tfor (;n;n>>=1) {\n\t\t\tif (n&1) ans=mul(ans,a,p);\n\t\t\ta=mul(a,a,p);\n\t\t}\n\t\treturn ans;\n\t}\n\tbool witness(ll a,ll n) {\n\t\tint t=0;\n\t\tll u=n-1;\n\t\tfor (;~u&1;u>>=1) t++;\n\t\tll x=powl(a,u,n),_x=0;\n\t\tfor (;t;t--) {\n\t\t\t_x=mul(x,x,n);\n\t\t\tif (_x==1 && x!=1 && x!=n-1) return 1;\n\t\t\tx=_x;\n\t\t}\n\t\treturn _x!=1;\n\t}\n\tbool miller(ll n) {\n\t\tif (n<2) return 0;\n\t\tif (n<=psize) return p[n]==n;\n\t\tif (~n&1) return 0;\n\t\tfor (int j=0;j<=7;j++) if (witness(rand()%(n-1)+1,n)) return 0;\n\t\treturn 1;\n\t}\n\tll gcd(ll a,ll b) {\n\t\tll ret=1;\n\t\twhile (a!=0) {\n\t\t\tif ((~a&1) && (~b&1)) ret<<=1,a>>=1,b>>=1;\n\t\t\telse if (~a&1) a>>=1; else if (~b&1) b>>=1;\n\t\t\telse {\n\t\t\t\tif (a<b) swap(a,b);\n\t\t\t\ta-=b;\n\t\t\t}\n\t\t}\n\t\treturn ret*b;\n\t}\n\tll rho(ll n) {\n\t\tfor (;;) {\n\t\t\tll X=rand()%n,Y,Z,T=1,*lY=a,*lX=lY;\n\t\t\tint tmp=20;\n\t\t\tC=rand()%10+3;\n\t\t\tX=mul(X,X,n)+C;*(lY++)=X;lX++;\n\t\t\tY=mul(X,X,n)+C;*(lY++)=Y;\n\t\t\tfor(;X!=Y;) {\n\t\t\t\tll t=X-Y+n;\n\t\t\t\tZ=mul(T,t,n);\n\t\t\t\tif(Z==0) return gcd(T,n);\n\t\t\t\ttmp--;\n\t\t\t\tif (tmp==0) {\n\t\t\t\t\ttmp=20;\n\t\t\t\t\tZ=gcd(Z,n);\n\t\t\t\t\tif (Z!=1 && Z!=n) return Z;\n\t\t\t\t}\n\t\t\t\tT=Z;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tX=*(lX++);\n\t\t\t}\n\t\t}\n\t}\n\tvoid _factor(ll n) {\n\t\tfor (int i=0;i<cnt;i++) {\n\t\t\tif (n%fac[i]==0) n/=fac[i],fac[cnt++]=fac[i];}\n\t\tif (n<=psize) {\n\t\t\tfor (;n!=1;n/=p[n]) fac[cnt++]=p[n];\n\t\t\treturn;\n\t\t}\n\t\tif (miller(n)) fac[cnt++]=n;\n\t\telse {\n\t\t\tll x=rho(n);\n\t\t\t_factor(x);_factor(n/x);\n\t\t}\n\t}\n\tvoid dfs(ll x,int dep) {\n\t\tif (dep==_cnt) d.pb(x);\n\t\telse {\n\t\t\tdfs(x,dep+1);\n\t\t\tfor (int i=1;i<=_e[dep];i++) dfs(x*=_pr[dep],dep+1);\n\t\t}\n\t}\n\tvoid norm() {\n\t\tsort(fac,fac+cnt);\n\t\t_cnt=0;\n\t\trep(i,0,cnt) if (i==0||fac[i]!=fac[i-1]) _pr[_cnt]=fac[i],_e[_cnt++]=1;\n\t\t\telse _e[_cnt-1]++;\n\t}\n\tvector<ll> getd() {\n\t\td.clear();\n\t\tdfs(1,0);\n\t\treturn d;\n\t}\n\tvector<ll> factor(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\treturn getd();\n\t}\n\tvector<PLL> factorG(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\tvector<PLL> d;\n\t\trep(i,0,_cnt) d.pb(mp(_pr[i],_e[i]));\n\t\treturn d;\n\t}\n\tbool is_primitive(ll a,ll p) {\n\t\tassert(miller(p));\n\t\tvector<PLL> D=factorG(p-1);\n\t\trep(i,0,SZ(D)) if (powl(a,(p-1)/D[i].fi,p)==1) return 0;\n\t\treturn 1;\n\t}\n}\n\nconst int N=301010;\nll fac[N],inv[N],sm[N],ms[N];\nint x,ans,n;\nmap<int,int> hs[N];\nll comb(int x,int y) {\n\tif (y<0||y>x) return 0;\n\treturn fac[x]*inv[y]%mod*inv[x-y]%mod;\n}\nll solve(VI &d) {\n\tint cnt=0;\n\tll ret=0;\n//\trep(i,0,SZ(d)) printf(""%d "",d[i]);\n//\tputs("""");\n\trep(i,0,SZ(d)) {\n\t\tret+=i*(ms[cnt+d[i]]-ms[cnt]);\n\t\tret%=mod;\n\t\tcnt+=d[i];\n\t}\n\tcnt=0;\n\tper(i,0,SZ(d)) {\n\t\tret-=i*(ms[cnt+d[i]]-ms[cnt]);\n\t\tret%=mod;\n\t\tcnt+=d[i];\n\t}\n\treturn ret;\n}\nint main() {\n\tFactor::init(1000000);\n\tscanf(""%d"",&n);\n\tfac[0]=inv[0]=1;\n\trep(i,1,n+1) fac[i]=fac[i-1]*i%mod,inv[i]=powmod(fac[i],mod-2);\n\tsm[0]=0;\n\trep(i,1,n) sm[i]=(sm[i-1]+comb(n-1,i-1))%mod;\n\trep(i,1,n+1) ms[i]=(ms[i-1]+sm[i-1])%mod;\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",&x);\n\t\tvector<PLL> d=Factor::factorG(x);\n\t\tfor (auto p:d) hs[p.fi][p.se]++;\n\t}\n\trep(i,1,300001) if (!hs[i].empty()) {\n\t\tint mx=(--hs[i].end())->fi;\n\t\tVI d=VI(mx+1,0);\n\t\td[0]=n;\n\t\tfor (auto p:hs[i]) d[p.fi]+=p.se,d[0]-=p.se;\n\t\tans=(ans+solve(d))%mod;\n\t}\n\tif (ans<0) ans+=mod;\n\tprintf(""%d\\n"",ans);\n}\n\n/*\nint comb[1010][1010];\nint main() {\n//\trep(i,)\n\tcomb[0][0]=1;\n\trep(i,1,1001) {\n\t\tcomb[i][0]=comb[i][i]=1;\n\t\trep(j,1,i) {\n\t\t\tcomb[i][j]+=comb[i-1][j-1]+comb[i-1][j];\n\t\t\tif (comb[i][j]>=mod) comb[i][j]%mod;\n\t\t}\n\t}\n\trep(i,1,11) rep(j,1,11) {\n\t\tll ret=0;\n\t\tfor (int x=1;x<=i+1&&x<=j;x++) ret=(ret+comb[i][x-1]*comb[j][x]);\n\t\tprintf(""%d %d %d %d\\n"",i,j,comb[i+j][j-1]-comb[j][j-i-1],ret);\n\t}\n}*/\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]",3100
Ksenia has a chessboard of size Each cell of the chessboard contains one of the characters The cells that contain character are blocked We know that all chessboard cells that touch the border are blocked Ksenia is playing with two pawns on this chessboard Initially she puts the pawns on the chessboard One cell of the chessboard can contain two pawns if and only if the cell is blocked In other cases two pawns can not stand in one cell The game begins when Ksenia put pawns on the board In one move Ksenia moves each pawn to a side adjacent cell in the direction of arrows painted on the cell on which the corresponding pawn sits if the pawn sits on it does not move Assume that Ksenia moves pawns simultaneously see the second test case Of course Ksenia plays for points How can one calculate the points per game Very simply Let s count how many movements the first pawn made and how many movements the second pawn made sum these two numbers it will be the resulting score of the game Ksenia wonders what is the maximum number of points she can earn for that she should place the pawns optimally well early in the game Help her and find that number ,"['#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar s[3001][3001];\nint d[3001][3001];\nconst int dx[]={0,1,0,-1};\nconst int dy[]={1,0,-1,0};\nconst char ds[]="">v<^"";\nbool vis[3001][3001];\nint dp[3001][3001][2];\nint n,m;\nint bfs[3001*3001][2];\nint T;\nint anss[2];\nvoid Update(int ans[],int x,int y){\n\tif(x>ans[1]){\n\t\tans[1]=x;\n\t\tif(ans[1]>ans[0]) swap(ans[1],ans[0]);\n\t\tif(y>ans[1]) ans[1]=y;\n\t}\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=0;i<n;++i) scanf(""%s"",s[i]);\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j){\n\t\tdp[i][j][0]=0,dp[i][j][1]=-1;\n\t\tif(s[i][j]!=\'#\'){\n\t\t\tfor(int k=0;k<4;++k) if(ds[k]==s[i][j]){\n\t\t\t\t++d[i+dx[k]][j+dy[k]];\n\t\t\t}\n\t\t}\n\t}\n\tT=-1;\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j){\n\t\tif(!d[i][j]) ++T,bfs[T][0]=i,bfs[T][1]=j;\n\t}\n\tfor(int i=0;i<=T;++i){\n\t\tint x=bfs[i][0],y=bfs[i][1];\n\t\tif(s[x][y]==\'#\'){\n\t\t\tUpdate(anss,dp[x][y][0],dp[x][y][1]);\n\t\t}\n\t\telse{\n\t\t\tif(dp[x][y][0]==dp[x][y][1]) --dp[x][y][1];\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tif(s[x][y]==ds[k]){\n\t\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\t\tUpdate(dp[nx][ny],dp[x][y][0]+1,dp[x][y][1]+1);\n\t\t\t\t\tif(--d[nx][ny]==0) ++T,bfs[T][0]=nx,bfs[T][1]=ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(T!=n*m-1) printf(""-1\\n"");\n\telse printf(""%d\\n"",anss[0]+anss[1]);\n\tscanf(""%d"",&n);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0]",2200
Alice and Bob received n candies from their parents Now they want to divide all candies among themselves fairly so that the total weight of Alice s candies is equal to the total weight of Bob s candies Check if they can do that Note that candies ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 102;\n\nint t;\n\nint n;\n\nint a[N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        for(int i = 1; i <= n; i++)\n            cin >> a[i];\n        int x = 0, y = 0;\n        for(int i = 1; i <= n; i++)\n        {\n            if(a[i] == 1)\n                x++;\n            else\n                y++;\n        }\n        if(x % 2 == 0 && y % 2 == 0)\n            cout << ""YES\\n"";\n        else if(x % 2 == 0 && y % 2 == 1 && x > 0)\n            cout << ""YES\\n"";\n        else\n            cout << ""NO\\n"";\n    }\n    return 0;\n}\n']","[1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Little X has distinct integers He wants to divide all of them into two sets and The following two conditions must be satisfied If number belongs to set then number must also belong to set If number belongs to set then number must also belong to set Help Little X divide the numbers into two sets or determine that it s impossible ,"['//#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n#define mp make_pair\n#define pb push_back\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""[""#x""] Time : %.3lf s.\\n"", clock()*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(""["" x ""] Time : %.3lf s.\\n"", __VA_ARGS__, clock()*1.0/CLOCKS_PER_SEC)\n\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\nusing namespace std;\n\n#define TASKNAME ""B""\n\n#ifdef LOCAL\nstatic struct __timestamper {\n    string what;\n    __timestamper(const char* what) : what(what){};\n    __timestamper(const string& what) : what(what){};\n    ~__timestamper(){\n        TIMESTAMPf(""%s"", what.data());\n    }\n} __TIMESTAMPER(""end"");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\n\n\nconst int MAXN = 110000;\nint p[MAXN];\nint can[2][MAXN];\n\nint get(int a) {\n    if (a == p[a]) return a;\n    return p[a] = get(p[a]);\n}\n\n\nvoid join(int a, int b) {\n    a = get(a);\n    b = get(b);\n    p[a] = b;\n    can[0][b] &= can[0][a];\n    can[1][b] &= can[1][a];\n}\n\n\nint main(){\n  #ifdef LOCAL\n    assert(freopen(TASKNAME"".in"",""r"",stdin));\n    assert(freopen(TASKNAME"".out"",""w"",stdout));\n  #endif\n    int n, a, b;\n    scanf(""%d%d%d"",&n,&a,&b);\n    vector<pair<int,int>> v(n);\n    for (int i = 0; i < (int)v.size(); i++) \n        scanf(""%d"",&v[i].first), v[i].second = i;\n\n    for (int i = 0; i < n; i++)\n        p[i] = i, can[0][i] = can[1][i] = 1;\n\n    sort(v.begin(), v.end());\n\n    for (int i = 0; i < (int)v.size(); i++) {\n        int x = v[i].first;\n        {\n        int id = lower_bound(v.begin(), v.end(), mp(a - x, -1)) - v.begin();\n        if (id < (int)v.size() && v[id].first == a - x)\n            join(v[i].second, v[id].second);\n        else\n            can[0][get(v[i].second)] = 0;\n        }\n        {\n        int id = lower_bound(v.begin(), v.end(), mp(b - x, -1))  - v.begin();\n        if (id < (int)v.size() && v[id].first == b - x)\n            join(v[i].second, v[id].second);\n        else\n            can[1][get(v[i].second)] = 0;\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n        if (!can[0][i] && !can[1][i] && p[i] == i) {\n            printf(""NO\\n"");\n            return 0;\n        }\n\n    printf(""YES\\n"");\n    for (int i = 0; i < n; i++)\n        printf(""%d%c"", can[1][get(i)], "" \\n""[i==n-1]);\n\n      \n    return 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2000
And again a misfortune fell on Poor Student He is being late for an exam Having rushed to a bus stop that is in point he got on a minibus and they drove along a straight line parallel to axis in the direction of increasing Poor Student knows the following during one run the minibus makes stops the th stop is in point coordinates of all the stops are different the minibus drives at a constant speed equal to it can be assumed the passengers get on and off the minibus at a bus stop momentarily Student can get off the minibus only at a bus stop Student will have to get off the minibus at a terminal stop if he does not get off earlier the University where the exam will be held is in point Student can run from a bus stop to the University at a constant speed as long as needed a distance between two points can be calculated according to the following formula Student is already on the minibus so he cannot get off at the first bus stop Poor Student wants to get to the University as soon as possible Help him to choose the bus stop where he should get off If such bus stops are multiple choose the bus stop closest to the University ,"['#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <vector>\n\nconst double EPS = 1e-7;\n\nusing namespace std;\n\nint n, v1, v2;\ndouble xu, yu;\n\ndouble dist(double x1, double y1, double x2, double y2)\n{\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\ndouble f(double x)\n{\n\treturn x/v1 + dist(x, 0, xu, yu)/v2;\n}\n\nint main()\n{\n//\tfreopen("""", ""rt"", stdin);\n//\tfreopen("""", ""wt"", stdout);\n\tcin >> n >> v1 >> v2;\n\tvector <double> x(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> x[i];\n\tcin >> xu >> yu;\n\tint m = 1;\n\tfor (int i = 2; i < n; ++i)\n\t\tif (f(x[i]) < f(x[m]) || (std::abs(f(x[i]) - f(x[m])) < EPS && dist(x[i], 0, xu, yu) < dist(x[m], 0, xu, yu))) m = i;\n\tcout << m+1 << \'\\n\';\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200
There is a grid consisting of 2 rows and n columns The rows are numbered from 1 to 2 from top to bottom The columns are numbered from 1 to n from left to right Each cell of the grid contains an arrow pointing either to the left or to the right No arrow points outside the grid There is a robot that starts in a cell 1 1 Every second the following two actions happen one after another Firstly the robot moves left right down or up then it moves along the arrow that is placed in the current cell the cell it ends up after its move Your task is to determine whether the robot can reach the cell 2 n ,"['/**\n *    author:  tourist\n *    created: 15.03.2024 10:35:58\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<string> s(2);\n    cin >> s[0] >> s[1];\n    vector<vector<int>> was(2, vector<int>(n, 0));\n    was[0][0] = 1;\n    vector<pair<int, int>> que;\n    que.emplace_back(0, 0);\n    for (int it = 0; it < int(que.size()); it++) {\n      auto [i, j] = que[it];\n      for (int di = -1; di <= 1; di++) {\n        for (int dj = -1; dj <= 1; dj++) {\n          if (di * di + dj * dj == 1) {\n            int ni = i + di;\n            int nj = j + dj;\n            if (ni >= 0 && nj >= 0 && ni < 2 && nj < n) {\n              nj += (s[ni][nj] == \'<\' ? -1 : 1);\n              if (!was[ni][nj]) {\n                que.emplace_back(ni, nj);\n                was[ni][nj] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << (was[1][n - 1] ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0]",1300
Another dull quarantine day was going by when decided to start researching matrices of size n times m The rows are numerated 1 through n from top to bottom and the columns are numerated 1 through m from left to right The cell in the i th row and j th column is denoted as i j For each cell i j had two values The cost of the cell which is a single integer The direction of the cell which is one of characters Those characters correspond to transitions to adjacent cells i j 1 i j 1 i 1 j or i 1 j respectively No transition pointed outside of the matrix Let us call a cell i 2 j 2 from i 1 j 1 if starting from i 1 j 1 and repeatedly moving to the adjacent cell according to our current direction we will sooner or later visit i 2 j 2 decided to create another matrix from the existing two For a cell i j let us denote S i j as a set of all reachable cells from it including i j itself Then the value at the cell i j in the new matrix will be equal to the sum of costs of all cells in S i j After quickly computing the new matrix immediately sent it to his friends However he did not save any of the initial matrices Help him to restore any two valid matrices which produce the current one ,"['/**\n *    author:  tourist\n *    created: 27.09.2020 19:10:12       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nclass matching {\n public:\n  vector<vector<int>> g;\n  vector<vector<int>> g_rev;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was_a;\n  vector<int> was_b;\n  vector<bool> imp_a;\n  vector<bool> imp_b;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was_a = vector<int>(n, 0);\n    was_b = vector<int>(m, 0);\n    imp_a = vector<bool>(n, false);\n    imp_b = vector<bool>(m, false);\n    g.resize(n);\n    g_rev.resize(m);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n    g_rev[to].push_back(from);\n  }\n\n  bool dfs(int v) {\n    was_a[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was_a[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool dfs_rev(int v) {\n    was_b[v] = iter;\n    for (int u : g_rev[v]) {\n      if (pa[u] == -1) {\n        pb[v] = u;\n        pa[u] = v;\n        return true;\n      }\n    }\n    for (int u : g_rev[v]) {\n      if (was_b[pa[u]] != iter && dfs_rev(pa[u])) {\n        pb[v] = u;\n        pa[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      int add = 0;\n      iter++;\n      for (int i = 0; i < n; i++) {\n        if (imp_a[i] && pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      for (int i = 0; i < m; i++) {\n        if (imp_b[i] && pb[i] == -1 && dfs_rev(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, -1, 0, 1};\nconst string let = ""ULDR"";\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int h, w;\n    cin >> h >> w;\n    vector<vector<int>> a(h, vector<int>(w));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> a[i][j];\n      }\n    }\n    vector<vector<int>> id(h, vector<int>(w, -1));\n    vector<int> cnt(2);\n    for (int rot = 0; rot < 2; rot++) {\n      cnt[rot] = 0;\n      for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n          if ((i + j) % 2 == rot) {\n            id[i][j] = cnt[rot];\n            cnt[rot] += 1;\n          }\n        }\n      }\n    }\n    matching mat(cnt[0], cnt[1]);\n    vector<vector<bool>> critical(h, vector<bool>(w, true));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        for (int dir = 0; dir < 4; dir++) {\n          int ni = i + di[dir];\n          int nj = j + dj[dir];\n          if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n            if (a[ni][nj] < a[i][j]) {\n              critical[i][j] = false;\n            }\n          }\n        }\n        if (critical[i][j]) {\n          if ((i + j) % 2 == 0) {\n            mat.imp_a[id[i][j]] = true;\n          } else {\n            mat.imp_b[id[i][j]] = true;\n          }\n        }\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (critical[i][j] && (i + j) % 2 == 0) {\n          for (int dir = 0; dir < 4; dir++) {\n            int ni = i + di[dir];\n            int nj = j + dj[dir];\n            if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n              if (a[i][j] == a[ni][nj] && critical[ni][nj]) {\n                mat.add(id[i][j], id[ni][nj]);\n              }\n            }\n          }\n        }\n      }\n    }\n    mat.solve();\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if ((i + j) % 2 == 0) {\n          for (int dir = 0; dir < 4; dir++) {\n            int ni = i + di[dir];\n            int nj = j + dj[dir];\n            if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n              if (a[i][j] == a[ni][nj]) {\n                if (critical[i][j] != critical[ni][nj]) {\n                  mat.add(id[i][j], id[ni][nj]);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    mat.solve();\n    bool ok = true;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if ((i + j) % 2 == 0) {\n          if (critical[i][j] && mat.pa[id[i][j]] == -1) {\n            ok = false;\n          }\n        } else {\n          if (critical[i][j] && mat.pb[id[i][j]] == -1) {\n            ok = false;\n          }\n        }\n      }\n    }\n    if (!ok) {\n      cout << ""NO"" << \'\\n\';\n      continue;\n    }\n    cout << ""YES"" << \'\\n\';\n    vector<vector<int>> cost(h, vector<int>(w, -1));\n    vector<vector<char>> go(h, vector<char>(w, \'?\'));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if ((i + j) % 2 == 0 && mat.pa[id[i][j]] != -1) {\n          for (int dir = 0; dir < 4; dir++) {\n            int ni = i + di[dir];\n            int nj = j + dj[dir];\n            if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n              if (mat.pa[id[i][j]] == id[ni][nj]) {\n                go[i][j] = let[dir];\n                go[ni][nj] = let[dir ^ 2];\n                cost[i][j] = 1;\n                cost[ni][nj] = a[i][j] - 1;\n              }\n            }\n          }\n        }\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (cost[i][j] == -1) {\n          for (int dir = 0; dir < 4; dir++) {\n            int ni = i + di[dir];\n            int nj = j + dj[dir];\n            if (ni >= 0 && nj >= 0 && ni < h && nj < w) {\n              if (a[ni][nj] < a[i][j]) {\n                go[i][j] = let[dir];\n                cost[i][j] = a[i][j] - a[ni][nj];\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        assert(go[i][j] != \'?\' && cost[i][j] != -1);\n      }\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (j > 0) {\n          cout << "" "";\n        }\n        cout << cost[i][j];\n      }\n      cout << \'\\n\';\n    }\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (j > 0) {\n          cout << "" "";\n        }\n        cout << go[i][j];\n      }\n      cout << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3300
The Main Martian Tree grows on Mars It is a binary tree a rooted tree with no more than two sons at each vertex with n vertices where the root vertex has the number 1 Its fruits are the Main Martian Fruits It s summer now so this tree does not have any fruit yet Autumn is coming soon and leaves and branches will begin to fall off the tree It is clear that if a vertex falls off the tree then its entire subtree will fall off too In addition the root will remain on the tree Formally the tree will have some connected subset of vertices containing the root After that the fruits will grow on the tree only at those vertices which remain Exactly x fruits will grow in the root The number of fruits in each remaining vertex will be not less than the sum of the numbers of fruits in the remaining sons of this vertex It is allowed that some vertices will not have any fruits Natasha wondered how many tree configurations can be after the described changes Since this number can be very large output it modulo 998244353 Two configurations of the resulting tree are considered different if one of these two conditions is true they have different subsets of remaining vertices they have the same subset of remaining vertices but there is a vertex in this subset where they have a different amount of fruits ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = (119 << 23) + 1; // = 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nll po(ll b, ll p) { return !p?1:po(b*b%MOD,p/2)*(p&1?b:1)%MOD; }\nll inv (ll b) { return po(b,MOD-2); }\n\nint mul(int a, int b) { return (ll)a*b%MOD; }\nint ad(int a, int b) { return (a+b)%MOD; }\nint sub(int a, int b) { return (a-b+MOD)%MOD; }\nint get(int s) { return s > 1 ? 32 - __builtin_clz(s - 1) : 0; }\n\nvi operator+(const vi& l, const vi& r) {\n    vi res(max(sz(l),sz(r)));\n    F0R(i,sz(l)) res[i] = l[i];\n    F0R(i,sz(r)) res[i] = ad(res[i],r[i]);\n    return res;\n}\n\nvi operator-(const vi& l, const vi& r) {\n    vi res(max(sz(l),sz(r)));\n    F0R(i,sz(l)) res[i] = l[i];\n    F0R(i,sz(r)) res[i] = sub(res[i],r[i]);\n    return res;\n}\n\nnamespace NTT {\n    const int root = 3; \n    // For p < 2^30 there is also e.g. (5 << 25, 3), (7 << 26, 3),\n    // (479 << 21, 3) and (483 << 21, 5). The last two are > 10^9.\n        \n    \n    vi ntt(vi& a) { \n        int n = a.size(), x = get(n); \n        vi res, RES(n), roots(n);\n        roots[0] = 1, roots[1] = po(root,(MOD-1)/n);\n        FOR(i,2,n) roots[i] = mul(roots[i-1],roots[1]);\n        \n        res = a;\n        FOR(i,1,x+1) {\n            int inc = n>>i;\n            F0R(j,inc) for (int k = 0; k < n; k += inc) {\n                int t = 2*k%n+j;\n                RES[k+j] = ad(res[t],mul(roots[k],res[t+inc]));\n            }\n            swap(res,RES);\n        }\n        \n        return res;\n    }\n    \n    vi ntt_rev(vi& a) {\n        vi res = ntt(a);\n        ll in = inv(sz(a));\n        F0R(i,sz(res)) res[i] = mul(res[i],in);\n        reverse(res.begin() + 1, res.end());\n        return res;\n    }\n    \n    vi brute(vi& a, vi& b) {\n        vi c(sz(a)+sz(b)-1);\n        F0R(i,sz(a)) F0R(j,sz(b)) c[i+j] = ad(c[i+j],mul(a[i],b[j]));\n        return c;\n    }\n    \n    vi conv(vi a, vi b) {\n        int s = sz(a)+sz(b)-1, L = get(s), n = 1<<L;\n        if (s <= 0) return {};\n        if (s <= 200) return brute(a,b);\n        \n        a.resize(n); a = ntt(a);\n        b.resize(n); b = ntt(b);\n        \n        F0R(i,n) a[i] = mul(a[i],b[i]);\n        a = ntt_rev(a);\n        \n        a.resize(s);\n        return a;\n    }\n    \n    pair<vi,vi> eval(vector<vi> a) { // a_1a_2a_3a_4+a_2a_3a_4+a_3a_4+a_4+1,a_1a_2a_3a_4\n        if (sz(a) == 1) {\n            auto A = a[0]; A[0] ++;\n            return {A,a[0]};\n        }\n        auto P = eval(vector<vi>(a.begin(),a.begin()+sz(a)/2));\n        auto Q = eval(vector<vi>(a.begin()+sz(a)/2,a.end()));\n        P.f[0] = sub(P.f[0],1);\n        return {NTT::conv(P.f,Q.s)+Q.f,NTT::conv(P.s,Q.s)};\n    }\n}\n\nint n, sz[MX];\nll x;\nvi adj[MX];\nvector<vi> dat[MX];\n\nvoid dfs(int a, int b) {\n    sz[a] ++;\n    \n    vi child;\n    for (int i: adj[a]) if (i != b) {\n        dfs(i,a);\n        sz[a] += sz[i];\n        child.pb(i);\n    }\n    \n    switch(sz(child)) {\n        case 0:\n            dat[a].pb({0,1});\n            break;\n        case 1:\n            swap(dat[a],dat[child[0]]);\n            dat[a].pb({0,1});\n            break;\n        default:\n            if (sz[child[0]] < sz[child[1]]) swap(child[0],child[1]);\n            swap(dat[child[0]],dat[a]);\n            auto x = NTT::eval(dat[child[1]]).f; x.insert(x.begin(),0);\n            dat[a].pb(x);\n            break;\n    }   \n    \n    /*cout << ""HI "" << a << "" "" << sz(child) << ""\\n"";\n    for (auto x: dat[a]) {\n        for (int y: x) cout << y << "" "";\n        cout << ""\\n"";\n    }\n    cout << ""----\\n"";*/\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> x; x %= MOD;\n    F0R(i,n-1) {\n        int a,b; cin >> a >> b;\n        adj[a].pb(b), adj[b].pb(a);\n    }\n    dfs(1,0);\n    vi v = NTT::eval(dat[1]).f;\n    \n    int ans = 0, ccomb = 1;\n    FOR(i,1,n+1) {\n        ans = ad(ans,mul(v[i],ccomb));\n        ccomb = mul(ccomb,ad(x,i));\n        ccomb = mul(ccomb,inv(i));\n    }\n    cout << ans;\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",3400
You are given two strings s and t both consisting of lowercase English letters You are going to type the string s character by character from the first character to the last one When typing a character instead of pressing the button corresponding to it you can press the Backspace button It deletes the last character you have typed among those that aren t deleted yet or does nothing if there are no characters in the current string For example if s is and you press Backspace instead of typing the first and the fourth characters you will get the string the first press of Backspace deletes no character and the second press deletes the character Another example if s is and you press Backspace instead of the last two letters then the resulting text is Your task is to determine whether you can obtain the string t if you type the string s and press Backspace instead of typing several maybe zero characters of s ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python! \n\n// pairs\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll BIG = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; } // set a = max(a,b)\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\t++hi; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\t--lo; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\tstr S, T; re(S, T);\n\tauto ok = [&]() {\n\t\tint i = 0;\n\t\tfor (char c: T) {\n\t\t\twhile (i < sz(S) && S.at(i) != c) i += 2;\n\t\t\tif (i >= sz(S)) return false;\n\t\t\t++i;\n\t\t}\n\t\treturn (sz(S)-i)%2 == 0;\n\t};\n\tif (ok()) {\n\t\tps(""YES"");\n\t\treturn;\n\t}\n\tS.erase(begin(S));\n\tif (ok()) {\n\t\tps(""YES"");\n\t\treturn;\n\t}\n\tps(""NO"");\n\t// ababa\n\t// xxxxxxt_0 xx t_1 xxxx t_n xx xx\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1500
You are given an array of integers a 1 a 2 ldots a n In one operation you do the following Choose a non negative integer m such that 2 m leq n Subtract 1 from a i for all integers i such that 1 leq i leq 2 m Can you sort the array in non decreasing order by performing some number possibly zero of operations An array is considered non decreasing if a i leq a i 1 for all integers i such that 1 leq i leq n 1 ,"['#include<bits/stdc++.h>\n#pragma GCC optimize(""Ofast,no-stack-protector,fast-math"",3)\nusing namespace std;\nconst int N=(1<<20)+10,M=998244353;\nusing ll=long long;\nusing ul=unsigned long long;\nvoid add(int &x,int y){(x+=y)>=M&&(x-=M);}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nint T,n,m,K,ans,sum,a[N],b[N],bt;\nstring s,t;\nint main(){\n    ios::sync_with_stdio(false);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        for(i=1,cin>>n;i<=n;++i)cin>>a[i];\n        for(k=r=0;n>>k;++k){\n            for(x=(1<<k)+1,z=0;x<=(1<<k+1)&&x<=n;++x){\n                if(z>a[x]){r=1;break;}\n                z=max(z,a[x]);\n            }\n        }puts(r?""No"":""Yes"");\n    }\n    return 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",800
Tonya was given an array of a of length n written on a postcard for his birthday For some reason the postcard turned out to be a so the index of the element located strictly to the right of the n th is 1 Tonya wanted to study it better so he bought a robot Burenka 179 A program for Burenka is a pair of numbers s k where 1 leq s leq n 1 leq k leq n 1 Note that k be equal to n Initially Tonya puts the robot in the position of the array s After that Burenka makes n steps through the array If at the beginning of a step Burenka stands in the position i then the following happens The number a i is added to the of the program Burenka moves k positions to the right i i k is executed if i becomes greater than n then i i n Help Tonya find the maximum possible of a program for Burenka if the initial usefulness of any program is 0 Also Tony s friend Ilyusha asks him to change the array q times Each time he wants to assign a p x for a given index p and a value x You need to find the maximum possible of the program after each of these changes ,"['/**\n *    author:  tourist\n *    created: 16.08.2022 17:54:45       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, q;\n    cin >> n >> q;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> ds;\n    int old = n;\n    for (int i = 2; i <= n; i++) {\n      if (n % i == 0) {\n        ds.push_back(old / i);\n        while (n % i == 0) {\n          n /= i;\n        }\n      }\n    }\n    n = old;\n    int sz = (int) ds.size();\n    vector<vector<long long>> b(sz);\n    for (int i = 0; i < sz; i++) {\n      b[i].resize(ds[i]);\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < sz; j++) {\n        b[j][i % ds[j]] += a[i];\n      }\n    }\n    multiset<long long> s;\n    for (int i = 0; i < sz; i++) {\n      for (int j = 0; j < ds[i]; j++) {\n        s.insert(b[i][j] * ds[i]);\n      }\n    }\n    cout << (*s.rbegin()) << \'\\n\';\n    while (q--) {\n      int pos, val;\n      cin >> pos >> val;\n      --pos;\n      int delta = val - a[pos];\n      a[pos] = val;\n      for (int i = 0; i < sz; i++) {\n        int j = pos % ds[i];\n        s.erase(s.find(b[i][j] * ds[i]));\n        b[i][j] += delta;\n        s.insert(b[i][j] * ds[i]);\n      }\n      cout << (*s.rbegin()) << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","[1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2400
Bob has a rectangular chocolate bar of the size He introduced a cartesian coordinate system so that the point corresponds to the lower left corner of the bar and the point corresponds to the upper right corner Bob decided to split the bar into pieces by breaking it Each break is a segment parallel to one of the coordinate axes which connects the edges of the bar More formally each break goes along the line or where and are integers It should divide one part of the bar into two non empty parts After Bob breaks some part into two parts he breaks the resulting parts Also he doesn t move the parts of the bar Bob made breaks and wrote them down in his notebook in arbitrary order At the end he got parts Now he wants to calculate their areas Bob is lazy so he asks you to do this task ,"['#include <cstdio>\n#include <set>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass Point {\npublic:\n\tint x, y;\n\n\tPoint() {}\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tinline void init() {\n\t\tscanf(""%d%d"", &x, &y);\n\t}\n\n\tinline bool operator < (const Point & other) const {\n\t\treturn x < other.x || (x == other.x && y <= other.y);\n\t}\n};\n\nconst int MAXN = 110 + 1;\n\nset < pair <Point, Point> > ch;\nPoint s[MAXN], t[MAXN];\nbool tag[MAXN];\nint W, H, n, area[MAXN];\n\nint main() {\n\tscanf(""%d%d%d"", &W, &H, &n);\n\tch.insert(make_pair(Point(0, 0), Point(W, H)));\n\tfor (int i = 0; i < n; i++) {\n\t\ts[i].init();\n\t\tt[i].init();\n\t}\n\tfor (int o = 0; o < n; o++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (tag[i]) continue;\n\t\t\tfor (set < pair <Point, Point> >::iterator iter = ch.begin(); iter != ch.end(); iter++) {\n\t\t\t\tPoint ss = iter->first, tt = iter->second;\n\t\t\t\tif (s[i].x == t[i].x && ss.x <= s[i].x && t[i].x <= tt.x && s[i].y == ss.y && t[i].y == tt.y) {\n\t\t\t\t\ttag[i] = true;\n\t\t\t\t\tch.erase(iter);\n\t\t\t\t\tch.insert(make_pair(ss, t[i]));\n\t\t\t\t\tch.insert(make_pair(s[i], tt));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (s[i].y == t[i].y && ss.y <= s[i].y && t[i].y <= tt.y && s[i].x == ss.x && t[i].x == tt.x) {\n\t\t\t\t\ttag[i] = true;\n\t\t\t\t\tch.erase(iter);\n\t\t\t\t\tch.insert(make_pair(ss, t[i]));\n\t\t\t\t\tch.insert(make_pair(s[i], tt));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tag[i]) break;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (set < pair <Point, Point> >::iterator iter = ch.begin(); iter != ch.end(); iter++) {\n\t\tarea[cnt++] = (iter->second.y - iter->first.y) * (iter->second.x - iter->first.x);\n\t}\n\tsort(area, area + n + 1);\n\tfor (int i = 0; i <= n; i++) printf(""%d "", area[i]);\n\tputchar(\'\\n\');\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2000
Jzzhu has invented a kind of sequences they meet the following property You are given and please calculate modulo ,"['#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<math.h>\n#include<time.h>\n#include<vector>\n#include<bitset>\n#include<memory>\n#include<utility>\n#include<fstream>\n#include<stdio.h>\n#include<iostream>\n#include<stdlib.h>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\nint modo=1000000007;\nint main()\n{\n    #ifdef absi2011\n    freopen(""input.txt"",""r"",stdin);\n    freopen(""output.txt"",""w"",stdout);\n    #endif\n    long long x,y;\n    cin>>x>>y;\n    int t;\n    scanf(""%d"",&t);\n    t=t%6;\n    if (t==1) cout<<(x+modo+modo)%modo<<endl;\n    if (t==2) cout<<(y+modo+modo)%modo<<endl;\n    if (t==3) cout<<(y-x+modo+modo)%modo<<endl;\n    if (t==4) cout<<(-x+modo+modo)%modo<<endl;\n    if (t==5) cout<<(-y+modo+modo)%modo<<endl;\n    if (t==0) cout<<(-y+x+modo+modo)%modo<<endl;\n    return 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Students of Winter Informatics School are going to live in a set of houses connected by underground passages Teachers are also going to live in some of these houses but they can not be accommodated randomly For safety reasons the following must hold All passages between two houses will be closed if there are no teachers in both of them All other passages will stay open It should be possible to travel between any two houses using the underground passages that are Teachers should not live in houses directly connected by a passage Please help the organizers to choose the houses where teachers will live to satisfy the safety requirements or determine that it is impossible ,"['/**\n *    author:  tourist\n *    created: 05.01.2021 18:05:09       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    vector<int> res(n, -1);\n    res[0] = 1;\n    vector<int> que;\n    for (int x : g[0]) {\n      que.push_back(x);\n      res[x] = 0;\n    }\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int v : g[que[b]]) {\n        if (res[v] == -1) {\n          res[v] = 1;\n          for (int x : g[v]) {\n            if (res[x] == -1) {\n              res[x] = 0;\n              que.push_back(x);\n            }\n          }\n        }\n      }\n    }\n    if (*min_element(res.begin(), res.end()) == -1) {\n      cout << ""NO"" << \'\\n\';\n      continue;\n    }\n    cout << ""YES"" << \'\\n\';\n    vector<int> ret;\n    for (int i = 0; i < n; i++) {\n      if (res[i] == 1) {\n        ret.push_back(i);\n      }\n    }\n    cout << ret.size() << \'\\n\';\n    for (int i = 0; i < (int) ret.size(); i++) {\n      if (i > 0) {\n        cout << "" "";\n      }\n      cout << ret[i] + 1;\n    }\n    cout << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2200
Elena has a grid formed by n horizontal lines and m vertical lines The horizontal lines are numbered by integers from 1 to n from top to bottom The vertical lines are numbered by integers from 1 to m from left to right For each x and y 1 leq x leq n 1 leq y leq m the notation x y denotes the point at the intersection of the x th horizontal line and y th vertical line Two points x 1 y 1 and x 2 y 2 are adjacent if and only if x 1 x 2 y 1 y 2 1 Elena calls a sequence of points p 1 p 2 ldots p g of length g a if and only if all the following conditions hold The first point p 1 in this sequence is 1 1 The last point p g in this sequence is n m For each 1 le i g the points p i and p i 1 are adjacent Note that the walk may contain the same point more than once In particular it may contain point 1 1 or n m multiple times There are n m 1 n 1 m segments connecting the adjacent points in Elena s grid Elena wants to color each of these segments in blue or red color so that there exists a walk p 1 p 2 ldots p k 1 of length k 1 such that out of k segments connecting two consecutive points in this walk no two consecutive segments have the same color in other words for each 1 le i k the color of the segment between points p i and p i 1 differs from the color of the segment between points p i 1 and p i 2 Please find any such coloring or report that there is no such coloring ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n, m, k;\n    cin >> n >> m >> k;\n    if (k < n - 1 + m - 1) {\n        cout << ""NO\\n"";\n        return;\n    }\n    if (k % 2 != (n + m) % 2) {\n        cout << ""NO\\n"";\n        return;\n    }\n    cout << ""YES\\n"";\n    for (int t = 0; t < n; ++t) {\n        for (int i = 0; i < m - 1; ++i) {\n            if (i % 2 == 0) {\n                cout << ""R "";\n            } else {\n                cout << ""B "";\n            }\n        }\n        cout << ""\\n"";\n    }\n    char ch = (m % 2 == 0 ? \'B\' : \'R\');\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (i % 2 == 1 && j == m - 1) {\n                char c = \'B\' + \'R\' - ch;\n                cout << c << "" "";\n            } else {\n                cout << ch << "" "";\n            }\n        }\n        cout << ""\\n"";\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Vasya has recently bought some land and decided to surround it with a wooden fence He went to a company called Wooden board that produces wooden boards for fences Vasya read in the catalog of products that the company has at its disposal different types of wood The company uses the th type of wood to produce a board of this type that is a rectangular by block Vasya decided to order boards in this company and build a fence from them It turned out that the storehouse of the company is so large that Vasya can order arbitrary number of boards of every type Note that Vasya is allowed to the boards as he builds the fence Vasya is required to construct a fence of length however an arbitrary fence won t do Vasya wants his fence to look beautiful We ll say that a fence is if and only if the following two conditions are fulfilled two successive boards of the same type the first board of the fence has an arbitrary length and the of each subsequent board equals the of the previous one In other words the fence is considered beautiful if the type of the th board in the fence is different from the th board s type besides the th board s length is equal to the th board s width for all starting from 2 Now Vasya wonders how many variants of arranging a fence for his land exist Your task is to count the number of different beautiful fences of length Since the sought number can be large enough you need to calculate the answer modulo ,"['#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <queue>\n#include <string.h>\n#include <sstream>\n#define _USE_MATH_DEFINES\n#define fo(i,n) for(i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define sz(x) x.size()\nusing namespace std;\n\ntypedef long long ll;\n\nint main(void)\n{\n    int md = 1000000007, n, l, len, i, j, a[200], b[200];\n    cin >> n >> len;\n    fo(i,n)\n        {\n            cin >> a[i] >> b[i];\n        }\n    \n    ll d[3010][110][2];\n    memset(d, 0, sizeof(d));\n    \n    for(l=1;l<=len;l++)\n        {\n            fo(i, n)\n                {\n                    //cout << l << "" "" << a[i] << "" "" << b[i] << endl;\n                    if (l == a[i])\n                        {\n                            d[l][i][0] = 1;\n                        }\n                    if (l == b[i] && a[i] != b[i])\n                        {\n                            d[l][i][1] = 1;\n                        }\n                    if (l - a[i] > 0)\n                        {\n                            fo(j,n) if (j != i)                        \n                                {\n                                    if (a[j] == a[i])\n                                        d[l][i][0] += d[l - a[i]][j][1];\n                                    if (b[j] == a[i])\n                                        d[l][i][0] += d[l - a[i]][j][0];                                    \n                                }\n                        }\n                    if (l - b[i] > 0 && a[i] != b[i])\n                        {\n                            fo(j,n) if (j != i)                        \n                                {\n                                    if (a[j] == b[i])\n                                        d[l][i][1] += d[l - b[i]][j][1];\n                                    if (b[j] == b[i])\n                                        d[l][i][1] += d[l - b[i]][j][0];\n                                }\n                        }\n                    d[l][i][0] %= md;\n                    d[l][i][1] %= md;\n                }\n        }\n\n    ll ans = 0;\n    fo(i,n)\n        {\n            ans += d[len][i][0];\n            ans += d[len][i][1];\n            ans %= md;\n        }\n    cout << ans << endl;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
There is a secret permutation p of 0 1 2 ldots n 1 Your task is to find 2 indices x and y 1 leq x y leq n possibly x y such that p x 0 or p y 0 In order to find it you are allowed to ask 2n queries In one query you give two integers i and j 1 leq i j leq n i neq j and receive the value of gcd p i p j dagger Note that the permutation p is fixed any queries are made and does not depend on the queries dagger gcd x y denotes the greatest common divisor GCD of integers x and y Note that gcd x 0 gcd 0 x x for all positive integers x ,"['#include<bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int> v , g , v2;\nbool ok[20005];\nint query(int i,int j)\n{\n    printf(""? %d %d\\n"",i,j);fflush(stdout);\n    int x;scanf(""%d"",&x);\n    return x;\n}\nmt19937 rnd(time(0));\nvoid shuf()\n{\n    for(int i = 1;i < v.size();i++) {\n        swap(v[i] , v[rnd()%(i + 1)]);\n    }\n    return;\n}\nvoid solve()\n{\n    scanf(""%d"",&n);v.clear();\n    for(int i = 1;i <= n;i++) v.push_back(i);\n    while(v.size() > 2) {\n        g.clear();\n        for(int i = 0;i < v.size();i++) ok[i] = 1;\n        for(int i = 0;i + 2 < v.size();i += 3) {\n            int a= query(v[i] , v[i + 1]) , b = query(v[i + 1] , v[i + 2]);\n            if(a > b) ok[i + 2] = 0;\n            else if(a < b) ok[i] = 0;\n            else ok[i + 1] = 0;\n        }\n        v2.clear();\n        for(int i = 0;i < v.size();i++) {\n            if(ok[i]) v2.push_back(v[i]);\n        }\n        swap(v , v2);\n    }\n    printf(""! %d %d\\n"",v[0],v[1]) ; fflush(stdout);int d;scanf(""%d"",&d);\n    return;\n}\nint main() {\n //   freopen(""in.txt"",""r"",stdin);\n    srand(time(NULL));\n    int t;scanf(""%d"",&t);\n    while(t--) solve();\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2100
Alice and Bob are playing a game Initially they are given a non empty string s consisting of lowercase Latin letters The length of the string is even Each player also has a string of their own initially empty Alice starts then they alternate moves In one move a player takes either the first or the last letter of the string s removes it from s and adds to the beginning it to their own string The game ends when the string s becomes empty The winner is the player with a lexicographically smaller string If the players strings are equal then it s a draw A string a is lexicographically smaller than a string b if there exists such position i that a j b j for all j i and a i b i What is the result of the game if both players play optimally e g both players try to win if they can t then try to draw ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < \'-\')\n\t\t;\n\tif (c == \'-\') {\n\t\tint x = gc - \'0\';\n\t\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\t\treturn -x;\n\t}\n\tint x = c - \'0\';\n\twhile (gc >= \'0\') x = x * 10 + c - \'0\';\n\treturn x;\n}\n#undef gc\n\nconst int N = 2005;\n\nchar c[N];\nint dp[N][N];\nint T, n;\n\nint main() {\n#ifdef local\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tT = read();\n\twhile (T--) {\n\t\tscanf(""%s"", c + 1);\n\t\tn = strlen(c + 1);\n\t\tfor (int i = 1; i <= n - 1; i++) {\n\t\t\tif (c[i] == c[i + 1])\n\t\t\t\tdp[i][i + 1] = 0;\n\t\t\telse\n\t\t\t\tdp[i][i + 1] = 1;\n\t\t}\n\t\tfor (int len = 4; len <= n; len += 2) {\n\t\t\tfor (int l = 1; l <= n - len + 1; l++) {\n\t\t\t\tint r = l + len - 1;\n\t\t\t\tdp[l][r] = -1;\n\t\t\t\t// choose l\n\t\t\t\tint ret = 1;\n\t\t\t\tif (dp[l + 1][r - 1] != 0)\n\t\t\t\t\tret = min(ret, dp[l + 1][r - 1]);\n\t\t\t\telse if (c[r] < c[l])\n\t\t\t\t\tret = -1;\n\t\t\t\telse if (c[r] == c[l])\n\t\t\t\t\tret = min(ret, 0);\n\t\t\t\tif (dp[l + 2][r] != 0)\n\t\t\t\t\tret = min(ret, dp[l + 2][r]);\n\t\t\t\telse if (c[l + 1] < c[l])\n\t\t\t\t\tret = -1;\n\t\t\t\telse if (c[l + 1] == c[l])\n\t\t\t\t\tret = min(ret, 0);\n\t\t\t\tdp[l][r] = max(dp[l][r], ret);\n\t\t\t\tret = 1;\n\t\t\t\tif (dp[l + 1][r - 1] != 0)\n\t\t\t\t\tret = min(ret, dp[l + 1][r - 1]);\n\t\t\t\telse if (c[l] < c[r])\n\t\t\t\t\tret = -1;\n\t\t\t\telse if (c[l] == c[r])\n\t\t\t\t\tret = min(ret, 0);\n\t\t\t\tif (dp[l][r - 2] != 0)\n\t\t\t\t\tret = min(ret, dp[l][r - 2]);\n\t\t\t\telse if (c[r - 1] < c[r])\n\t\t\t\t\tret = -1;\n\t\t\t\telse if (c[r - 1] == c[r])\n\t\t\t\t\tret = min(ret, 0);\n\t\t\t\tdp[l][r] = max(dp[l][r], ret);\n\t\t\t}\n\t\t}\n\t\tif (dp[1][n] == 1)\n\t\t\tprintf(""Alice\\n"");\n\t\telse if (dp[1][n] == 0)\n\t\t\tprintf(""Draw\\n"");\n\t\telse\n\t\t\tprintf(""Bob\\n"");\n\t}\n}']","[0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Tzuyu gave Sana two integers a and b and a really important quest In order to complete the quest Sana has to output the smallest possible value of a oplus x b oplus x for any given x where oplus denotes the bitwise XOR operation ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\n//\tfreopen(""in.txt"", ""r"", stdin);\n//\tfreopen(""out.txt"", ""w"", stdout);\n\t\n\tint Tc;\n\tfor (cin >> Tc; Tc--; ) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tint rlt = 0;\n\t\tfor (int i = 30; i >= 0; i--) {\n\t\t\tbool fa = 0, fb = 0;\n\t\t\tif (a & (1 << i)) fa = 1;\n\t\t\tif (b & (1 << i)) fb = 1;\n\t\t\tif (fa != fb) rlt += (1 << i);\n\t\t}\n\t\tcout << rlt << endl;\n\t}\n\t\n\treturn 0;\n\n}\n\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Kevin Sun has just finished competing in Codeforces Round 334 The round was 120 minutes long and featured five problems with maximum point values of 500 1000 1500 2000 and 2500 respectively Despite the challenging tasks Kevin was uncowed and bulldozed through all of them distinguishing himself from the herd as the best cowmputer scientist in all of Bovinia Kevin knows his submission time for each problem the number of wrong submissions that he made on each problem and his total numbers of successful and unsuccessful hacks Because Codeforces scoring is complicated Kevin wants you to write a program to compute his final score Codeforces scores are computed as follows If the maximum point value of a problem is and Kevin submitted correctly at minute but made wrong submissions then his score on that problem is His total score is equal to the sum of his scores for each problem In addition Kevin s total score gets increased by points for each successful hack but gets decreased by points for each unsuccessful hack All arithmetic operations are performed with absolute precision and no rounding It is guaranteed that Kevin s final score is an integer ,"['#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint N, t[10], w[10], a, b;\n\ndouble mod (double x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nint main()\n{\n//freopen (""input"", ""r"", stdin);\n//freopen (""output"", ""w"", stdout);\n\nfor (int i=1; i<=5; i++)\n    scanf (""%d"", &t[i]);\nfor (int i=1; i<=5; i++)\n    scanf (""%d"", &w[i]);\nscanf (""%d %d"", &a, &b);\ndouble val = 100.0 * a - 50.0 * b;\nfor (int i=1; i<=5; i++)\n{\n    double x = i * 500.0;\n    double curr = x - (double) x * t[i] / 250.0 - 50.0 * w[i];\n    if (0.3 * x > curr) curr = 0.3 * x;\n    val += curr;\n}\n/*int sol = (int) val, pos, mini = 10000.0;\nfor (int i=sol - 2; i<=sol + 2; i++)\n    if (mod ((double) i - val) < mini)\n        mini = mod ((double) i - val), pos = i;\nprintf (""%d\\n"", pos);*/\nprintf (""%.lf\\n"", val);\n\nreturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and and and are not You are given a regular bracket sequence s and an integer number k Your task is to find a regular bracket sequence of length exactly k such that it is also a subsequence of s It is guaranteed that such sequence always exists ,"[""#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, int>;\nconst int MAXN = 1000005;\nconst int mod = 1e9 + 7;\n\nint n, k;\nstring s;\nstack<int> stk;\nbool fu[MAXN];\n\nint main(){\n\tcin >> n >> k;\n\tcin >> s;\n\tint rem = (n - k) / 2;\n\tfor(int i=0; i<s.size(); i++){\n\t\tif(s[i] == '(') stk.push(i);\n\t\telse{\n\t\t\tif(rem > 0){\n\t\t\t\tfu[stk.top()] = 1;\n\t\t\t\tfu[i] = 1;\n\t\t\t\trem--;\n\t\t\t}\n\t\t\tstk.pop();\n\t\t}\n\t}\n\tfor(int i=0;i <s.size(); i++){\n\t\tif(!fu[i]) putchar(s[i]); \n\t}\n}\n""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Today on a lecture about strings Gerald learned a new definition of string equivalency Two strings and of equal length are called in one of the two cases They are equal If we split string into two halves of the same size and and string into two halves of the same size and then one of the following is correct is equivalent to and is equivalent to is equivalent to and is equivalent to As a home task the teacher gave two strings to his students and asked to determine if they are equivalent Gerald has already completed this home task Now it s your turn ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nstring s,t;\nstring gao(string a) {\n\tif (SZ(a)%2==1) return a;\n\telse {\n\t\tstring a1="""";\n\t\trep(i,0,SZ(a)/2) a1.pb(a[i]);\n\t\tstring s1=gao(a1);\n\t\ta1.clear();\n\t\trep(i,SZ(a)/2,SZ(a)) a1.pb(a[i]);\n\t\tstring s2=gao(a1);\n\t\tif (s1<s2) return s1+s2; else return s2+s1;\n\t}\n}\nint main() {\n\tcin>>s>>t;\n\tputs(gao(s)==gao(t)?""YES"":""NO"");\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]",1700
Lately a national version of a bingo game has become very popular in Berland There are players playing the game each player has a card with numbers The numbers on each card are distinct but distinct cards can have equal numbers The card of the th player contains numbers During the game the host takes numbered balls one by one from a bag He reads the number aloud in a high and clear voice and then puts the ball away All participants cross out the number if it occurs on their cards The person who crosses out all numbers from his card first wins If multiple people cross out all numbers from their cards at the same time there are no winners in the game At the beginning of the game the bag contains 100 balls numbered 1 through 100 the numbers of all balls are distinct You are given the cards for each player Write a program that determines whether a player can win the game at the most favorable for him scenario or not ,"['#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ld eps = 1e-12;\nconst int inf = 1e9;\n#define pb push_back\n#define pob pop_back\n#define i1 first\n#define i2 second\n#define mp make_pair\n\n#define file """"\n#define N 100500\n\nint use[120];\n\nint m[120][120];\nint ml[120];    \nbool ans[120];\n       \nint main()\n{\n\n    int n;\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(""%d"", &ml[i]);\n        for (int j = 0; j < ml[i]; j++)\n            scanf(""%d"", &m[i][j]);\n        sort(m[i], m[i] + ml[i]);\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j <= 100; j++) use[j] = 0;\n        for (int j = 0; j < ml[i]; j++) use[m[i][j]] = 1;\n        ans[i] = 1;\n        for (int j = 0; j < n; j++)\n            if (i != j)\n            {\n                bool f = 1;\n                for (int k = 0; k < ml[j] && f; k++)\n                    if (!use[m[j][k]])\n                    {\n                        f = 0;\n                        break;\n                    }\n                if (f)\n                {\n                    ans[i] = 0;\n                    break;\n                }\n            }\n    }\n    for (int i = 0; i < n; i++)\n        if (ans[i] == 1) printf(""YES\\n"");\n        else printf(""NO\\n"");\n\n    return 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
As a human she can erase history of its entirety As a she can create history out of nothingness Keine has the ability to manipulate history The history of Gensokyo is a string s To fix the chaos caused by Yukari she needs to do the following operations n times for the i th time She chooses a t 2i 1 of s She replaces t 2i 1 with a string t 2i Note that the lengths of strings t 2i 1 and t 2i can be different Note that if t 2i 1 occurs more than once in s of them will be replaced For example let s t 2i 1 and t 2i After the operation s becomes or After n operations Keine got the final string and an operation sequence t of length 2n Just as Keine thinks she has finished Yukari appears again and shuffles the order of t Worse still Keine forgets the initial history Help Keine find the initial history of Gensokyo Recall that a substring is a sequence of consecutive characters of the string For example for string its substrings are and some others But the following strings are not its substring You cannot make hacks in this problem ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconstexpr int inf = 1e18;\nconstexpr int maxn = 2e5 + 5;\nconstexpr int mod = 998244353;\n\ninline void solve()\n{\n  int n; cin >> n; // the number of operations\n  vector<int> cnt(26);\n  vector<string> s(n * 2 + 1);\n  for (int i = 0; i < n * 2 + 1; i ++)\n  {\n    cin >> s[i];\n    for (char ch : s[i])\n      cnt[ch - 'a'] ^= 1;\n  }\n  for (int i = 0; i < 26; i ++)\n    if (cnt[i])\n      cout << char(i + 'a') << '\\n';\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T; cin >> T;\n  while (T --)\n  solve();\n  return 0;\n}""]","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1700
Alice received a set of Toy Train from Bob It consists of one train and a connected railway network of n stations enumerated from 1 through n The train occupies one station at a time and travels around the network of stations in a circular manner More precisely the immediate station that the train will visit after station i is station i 1 if 1 leq i n or station 1 if i n It takes the train 1 second to travel to its next station as described Bob gave Alice a fun task before he left to deliver m candies that are initially at some stations to their independent destinations using the train The candies are enumerated from 1 through m Candy i 1 leq i leq m now at station a i should be delivered to station b i a i neq b i The train has infinite capacity and it is possible to load off any number of candies at a station However only candy can be loaded from a station onto the train before it leaves the station You can choose any candy at this station The time it takes to move the candies is negligible Now Alice wonders how much time is needed for the train to deliver all candies Your task is to find for each station the minimum time the train would need to deliver all the candies were it to start from there ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  cin >> N >> M;\n\n  vector<PII> candies(M);\n  for (auto &p : candies) { cin >> p.st >> p.nd; --p.st; --p.nd; }\n  vector<VI> ends(N);\n  for (auto &p : candies) {\n    ends[p.st].PB(p.nd);\n  }\n\n  for (int start = 0; start < N; ++start) {\n    int total = 0;\n    for (int i = 0; i < N; ++i) {\n      int tdist = i < start ? N + i - start : i - start;\n\n      int nc = SZ(ends[i]);\n      if (nc == 0) { continue; }\n      int mdist = 1e9;\n      for (int v : ends[i]) {\n        if (v < i) { mini(mdist, N - i + v); } else { mini(mdist, v - i); }\n      }\n\n      maxi(total, (nc - 1) * N + mdist + tdist);\n    }\n\n    cout << total << "" "";\n  }\n  cout << ""\\n"";\n}\n\n']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Little Gerald and his coach Mike play an interesting game At the beginning of the game there is a pile consisting of candies and a pile consisting of stones Gerald and Mike move in turns Mike goes first During his move Mike checks how many candies and stones Gerald has eaten Let Gerald eat candies and stones Then Mike awards Gerald prize points Gerald during his move either eats a candy from the pile of candies or a stone from the pile of stones As Mike sees that Gerald has eaten everything apart one candy and one stone he awards points for the last time and the game ends Gerald is not allowed to eat all the candies and he is not allowed to eat all the stones too Tell Gerald how to play to get the largest possible number of points it is required to find one of the possible optimal playing strategies for Gerald ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++) \n#define REP(i,n) FOR(i,0,n) \n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint n,m,p;\nint x[22222];\nint y[22222];\nint d[10007][650];\n\nint d1[20000];\nint d2[20000];\n\nstring res;\nbool first = true;\n\nvoid go(){\n\tif(n==0 && m==0) return;\n\tif(n==0){\n\t\tres.pb(\'S\');\n\t\tm--;\n\t\tgo();\n\t\treturn;\n\t}\n\tif(m==0){\n\t\tres.pb(\'C\');\n\t\tn--;\n\t\tgo();\n\t\treturn;\n\t}\n\t\n\tif(n==10000 && first){\n\t\tfirst = false;\n\t\treturn;\n\t}\n\n\tint row = n;\n\tif(row>10000) row-=10000;\n\n\tint md = m % 31;\n\tint dv = m / 31;\n\t\t\t\n\tif(d[row][dv] &(1<<md)){\n\t\tres.pb(\'S\');\n\t\tm--;\n\t\tgo();\n\t}else{\n\t\tres.pb(\'C\');\n\t\tn--;\n\t\tgo();\n\t}\n}\n\nint solve(){\n\tCL(d1,0);\n\tCL(d2,0);\n\tCL(d,0);\n\n\tint *f1 = d1;\n\tint *f2 = d2;\n\n\tREP(i,n){\n\t\tint md = -1;\n\t\tint dv = 0;\n\t\tREP(j,m){\n\t\t\tmd ++;\n\t\t\tif(md>=31) md-=31,dv++;\n\t\t\tint row = i;\n\t\t\tif(row>10000) row-=10000;\n\t\t\tif(d[row][dv] &(1<<md))\n\t\t\t\td[row][dv] ^= (1<<md);\n\n\t\t\tf1[j] = (x[i]+y[j]);\n\t\t\tif(f1[j]>=p) f1[j]-=p;\n\n\t\t\tint v1 = j?f1[j-1]:-1;\n\t\t\tint v2 = i?f2[j]:-1;\n\n\t\t\tif(v1==-1 && v2==-1) continue;\n\t\t\t\n\t\t\t\n\t\t\tif(v1>v2){\n\t\t\t\tf1[j] += v1;\n\t\t\t\td[row][dv] |= (1<<md);\n\t\t\t}else{\n\t\t\t\tf1[j] += v2;\n\t\t\t}\n\t\t}\n\t\tswap(f1,f2);\n\t}\n\treturn f2[m-1];\n}\n\nbool check(string s,int val){\n\tint t = (x[0] +y[0])%p;\n\tint a = 0, b = 0;\n\tREP(i,s.size()){\n\t\tif(s[i]==\'C\') a++;\n\t\telse b++;\n\t\tt += (x[a] + y[b])%p;\n\t}\n\tif(t!=val){\n\t\tputs(""FUCK"");\n\t\treturn 0;\n\t}\n\telse puts(""OK"");\n\treturn 1;\n}\n\nint main(){ \n#ifdef LocalHost\n\tfreopen(""input.txt"",""r"",stdin);\n//\tfreopen(""output.txt"",""w"",stdout);\n#endif\n\tcin>>n>>m>>p;\n\t\n\t/*int it = 0;\nhere:\n\tit++;\n\tsrand(it);\n\t\n\tn = 11111;//9999 + rand()%10 + 1;\n\tm = 5;// + rand() %100 + 1;\n\tp = rand() % 1000 + 1;\n\t*/\n\tREP(i,n){\n\t\tscanf(""%d"",x+i);\n\t\t//x[i] = rand();\n\t\tx[i]%=p;\n\t}\n\tREP(i,m){\n\t\tscanf(""%d"",y+i);\n\t\t//y[i] = rand();\n\t\ty[i]%=p;\n\t}\n\t\n\tres="""";\n\tint qq = solve();\n\tcout<<qq<<endl;\n\tn--,m--;\n\tgo();\n\tn++,m++;\n\tsolve();\n\tn--,m--;\n\tgo();\n\treverse(res.begin(),res.end());\n\t//if(check(res,qq))\n\t//\tgoto here;\n\tprintf(""%s\\n"",res.c_str());\n#ifdef LocalHost\n\tcout<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n\treturn 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
Alice and Bob play 5 in a row game They have a playing field of size In turns they put either crosses or noughts one at a time Alice puts crosses and Bob puts noughts In current match they have made some turns and now it s Alice s turn She wonders if she can put cross in such empty cell that she wins immediately Alice wins if some crosses in the field form line of length This line can be horizontal vertical and diagonal ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream& in, std::ostream& out) {\n    std::vector<std::string> field(10);\n    for (int i = 0; i < 10; i++) {\n        in >> field[i];\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j <= 5; j++) {\n            int stat = 0;\n            int empty = 0;\n            for (int k = 0; k < 5; k++) {\n                if (field[i][j + k] == \'X\') {\n                    stat++;\n                } else if (field[i][j + k] == \'.\') {\n                    empty++;\n                }\n            }\n            if (stat == 4 && empty == 1) {\n                out << ""YES\\n"";\n                return;\n            }\n        }\n    }\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j <= 5; j++) {\n            int stat = 0;\n            int empty = 0;\n            for (int k = 0; k < 5; k++) {\n                if (field[j + k][i] == \'X\') {\n                    stat++;\n                } else if (field[j + k][i] == \'.\') {\n                    empty++;\n                }\n            }\n            if (stat == 4 && empty == 1) {\n                out << ""YES\\n"";\n                return;\n            }\n        }\n    }\n\n    for (int i = 0; i <= 5; i++) {\n        for (int j = 0; j <= 5; j++) {\n            int stat = 0;\n            int empty = 0;\n            for (int k = 0; k < 5; k++) {\n                if (field[i + k][j + k] == \'X\') {\n                    stat++;\n                } else if (field[i + k][j + k] == \'.\') {\n                    empty++;\n                }\n            }\n            if (stat == 4 && empty == 1) {\n                out << ""YES\\n"";\n                return;\n            }\n        }\n    }\n\n    for (int i = 0; i <= 5; i++) {\n        for (int j = 4; j < 10; j++) {\n            int stat = 0;\n            int empty = 0;\n            for (int k = 0; k < 5; k++) {\n                if (field[i + k][j - k] == \'X\') {\n                    stat++;\n                } else if (field[i + k][j - k] == \'.\') {\n                    empty++;\n                }\n            }\n            if (stat == 4 && empty == 1) {\n                out << ""YES\\n"";\n                return;\n            }\n        }\n    }\n    out << ""NO\\n"";\n}\n\nint main() {\n    std::cin.sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    run(std::cin, std::cout);\n    return 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1600
You are given two positive integer numbers and Permute change order of the digits of to construct maximal number not exceeding No number in input and or output can start with the digit It is allowed to leave as it is ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\n\nmap<int, int>haveInt;\nvector<int>need;\nvector<int>answer;\n\nvoid prnt() {\n\tfor (auto x : answer)cout << x;\n\texit(0);\n}\n\nvoid formAll() {\n\twhile (!haveInt.empty()) {\n\t\tmap<int, int>::iterator it = haveInt.end();\n\t\tit--;\n\t\tanswer.push_back(it->first);\n\t\tit->second -= 1;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t}\n\tprnt();\n}\n\nvoid tryNum(int a) {\n\tif (haveInt.size()==0)\n\t\tprnt();\n\tmap<int, int>::iterator it = haveInt.lower_bound(need[a]);\n\tif (it != haveInt.end() && it->first == need[a]) {\n\t\tint x = it->first;\n\t\tit->second--;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t\tanswer.push_back(x);\n\t\ttryNum(a + 1);\n\t\thaveInt[x]++;\n\t\tanswer.pop_back();\n\t}\n\tit = haveInt.lower_bound(need[a]);\n\tif (it == haveInt.begin())return;\n\tit--;\n\tanswer.push_back(it->first);\n\tit->second--;\n\tif (it->second == 0)\n\t\thaveInt.erase(it);\n\tformAll();\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tswap(s1, s2);\n\tfor (auto x : s2)\n\t\thaveInt[x - \'0\']++;\n\tif (s2.length() < s1.length())\n\t\tformAll();\n\tfor (auto x : s1)\n\t\tneed.push_back(x - \'0\');\n\ttryNum(0);\n\n\t\n\treturn 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
You are given n 1 integers a 2 dots a n and a tree with n vertices rooted at vertex 1 The leaves are all at the same distance d from the root Recall that a tree is a connected undirected graph without cycles The distance between two vertices is the number of edges on the simple path between them All non root vertices with degree 1 are leaves If vertices s and f are connected by an edge and the distance of f from the root is greater than the distance of s from the root then f is called a child of s Initially there are a red coin and a blue coin on the vertex 1 Let r be the vertex where the red coin is and let b be the vertex where the blue coin is You should make d moves A move consists of three steps Move the red coin to any child of r Move the blue coin to any vertex b such that dist 1 b dist 1 b 1 Here dist x y indicates the length of the simple path between x and y Note that b and b are not necessarily connected by an edge You can optionally swap the two coins or skip this step Note that r and b can be equal at any time and there is no number written on the root After each move you gain a r a b points What s the maximum number of points you can gain after d moves ,"['#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint T,n,a[200005],d[200005],mxd,l[200005],r[200005];\nll f[200005];\nvector<int> v[200005],D[200005];\nvoid dfs(int x,int y){\n\tD[d[x]=d[y]+1].pb(x);\n\tif(d[x]>mxd)mxd=d[x];\n\tl[d[x]]=min(l[d[x]],a[x]);\n\tr[d[x]]=max(r[d[x]],a[x]);\n\tfor(int i=0;i<v[x].size();++i)if(v[x][i]!=y)dfs(v[x][i],x);\n}\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;++i)v[i].clear(),D[i].clear(),l[i]=orz,r[i]=-orz;\n\t\tmxd=0;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tint x;\n\t\t\tscanf(""%d"",&x);\n\t\t\tv[x].pb(i),v[i].pb(x);\n\t\t}\n\t\tfor(int i=2;i<=n;++i)scanf(""%d"",a+i);\n\t\tdfs(1,0);\n\t\tfor(int i=0;i<D[mxd].size();++i){\n\t\t\tint x=D[mxd][i];\n\t\t\tf[x]=max(r[mxd]-a[x],a[x]-l[mxd]);\n\t\t}\n\t\tfor(int k=mxd-1;k;--k){\n\t\t\tll L=-orz*1ll*orz,R=-orz*1ll*orz;\n\t\t\tfor(int i=0;i<D[k].size();++i){\n\t\t\t\tint x=D[k][i];\n\t\t\t\tf[x]=-orz*1ll*orz;\n\t\t\t\tfor(int j=0;j<v[x].size();++j){\n\t\t\t\t\tint y=v[x][j];\n\t\t\t\t\tif(d[y]<d[x]) continue;\n\t\t\t\t\tf[x]=max(f[x],f[y]);\n\t\t\t\t}\n\t\t\t\tL=max(L,f[x]-a[x]);\n\t\t\t\tR=max(R,f[x]+a[x]);\n\t\t\t\tf[x]+=max(r[k]-a[x],a[x]-l[k]);\n\t\t\t}\n\t\t\tfor(int i=0;i<D[k].size();++i){\n\t\t\t\tint x=D[k][i];\n\t\t\t\tf[x]=max(f[x],max(L+a[x],R-a[x]));\n\t\t\t}\n\t\t}\n\t\tprintf(""%I64d\\n"",f[1]);\n\t}\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]",2500
Nearly each project of the F company has a whole team of developers working on it They often are in different rooms of the office in different cities and even countries To keep in touch and track the results of the project the F company conducts shared online meetings in a Spyke chat One day the director of the F company got hold of the records of a part of an online meeting of one successful team The director watched the record and wanted to talk to the team leader But how can he tell who the leader is The director logically supposed that the leader is the person who is present at any conversation during a chat meeting In other words if at some moment of time at least one person is present on the meeting then the leader is present on the meeting You are the assistant director Given the user logged on user logged off messages of the meeting in the chronological order help the director determine who can be the leader Note that the director has the record of only a continuous part of the meeting probably it s not the whole meeting ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define FOR(i,s,e) for (int i=(s); i<(e); i++)\n#define FOE(i,s,e) for (int i=(s); i<=(e); i++)\n#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)\n#define CLR(a,x) memset(a, x, sizeof(a))\n#define EXP(i,l) for (int i=(l); i; i=qn[i])\n#define N 100005\nusing namespace std;\n\nint n, m, cnt;\nint v[N], nod[N], a[N], L[N];\nchar op[N][5];\n\nint main(){\n\tscanf(""%d%d"", &n, &m);\n\tCLR(v, -1);\n\tFOR(i,0,m){\n\t\tscanf(""%s%d"", &op[i], &a[i]), --a[i];\n\t\tif (v[a[i]] == -1) v[a[i]] = (op[i][0] == \'+\' ? 1 : 0);\n\t}\n\t\n\tint sz = 0;\n\tFOR(i,0,n){\n\t\tif (v[i] == 0) ++cnt;\n\t\tif (v[i] == 1) L[sz++] = i;\n\t}\n\t\n\tif (cnt > 0){\n\t\twhile (sz) nod[L[--sz]] = 1;\n\t}\n\t\n\tFOR(i,0,m){\n\t\tif (op[i][0] == \'+\'){\n\t\t\tif (cnt > 0) nod[a[i]] = 1;\n\t\t\t++cnt;\n\t\t\twhile (sz){\n\t\t\t\t--sz;\n\t\t\t\tif (L[sz] != a[i]) nod[L[sz]] = 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t--cnt;\n\t\t\tif (cnt > 0) nod[a[i]] = 1;\n\t\t\tif (!nod[a[i]]) L[sz++] = a[i];\n\t\t}\n\t}\n\t\n\tint ret = n;\n\tFOR(i,0,n) ret -= nod[i];\n\tprintf(""%d\\n"", ret);\n\tFOR(i,0,n) if (!nod[i]) printf(""%d "", i + 1);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Luba is surfing the Internet She currently has opened tabs in her browser indexed from to from left to right The mouse cursor is currently located at the th tab Luba needs to use the tabs with indices from to inclusive for her studies and she wants to close all the tabs that don t belong to this segment as fast as possible Each second Luba can either try moving the cursor to the left or to the right if the cursor is currently at the tab then she can move it to the tab or to the tab or try closing all the tabs to the left or to the right of the cursor if the cursor is currently at the tab she can close all the tabs with indices from segment or from segment In the aforementioned expressions and denote the minimum and maximum index of an unclosed tab respectively For example if there were tabs initially and tabs and are closed then What is the minimum number of seconds Luba has to spend in order to leave opened ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tint  n, pos, l, r;\n\tcin >> n >> pos >> l >> r;\n\tif (l == 1 && r == n) {\n\t\tcout << 0;\n\t\treturn 0;\n\t}\n\tif (l == 1 ) {\n\t\tcout << 1+abs(pos-r);\n\t\treturn 0;\n\t}\n\tif (r == n) {\n\t\tcout << 1 + abs(pos - l);\n\t\treturn 0;\n\t}\n\tcout << min(2 + abs(pos - l) + abs(r - l), 2 + abs(pos - r) + abs(r - l));\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Captain Bill the Hummingbird and his crew recieved an interesting challenge offer Some stranger gave them a map potion of teleportation and said that only this potion might help them to reach the treasure Bottle with potion has two values and written on it These values define four moves which can be performed using the potion Map shows that the position of Captain Bill the Hummingbird is and the position of the treasure is You task is to tell Captain Bill the Hummingbird whether he should accept this challenge or decline If it is possible for Captain to reach the treasure using the potion then output otherwise without quotes ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nvoid solve() {\n    int x[2], y[2], a, b;\n    FOR(i, 0, 2) cin >> x[i] >> y[i];\n    cin >> a >> b;\n    int u = abs(x[0] - x[1]);\n    int v = abs(y[0] - y[1]);\n    if (u % a || v % b) {\n        cout << ""NO\\n"";\n        return;\n    }\n    if (u / a + v / b & 1) {\n        cout << ""NO\\n"";\n    }\n    else {\n        cout << ""YES\\n"";\n    }\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1200
You ve got a string S consisting of n lowercase English letters from your friend It turned out that this is a number written in numerals The poman numeral system is long forgotten All that s left is the algorithm to transform number from poman numerals to the numeral system familiar to us Characters of S are numbered from 1 to n from left to right Let s denote the value of S as f S it is defined as follows If S 1 an arbitrary integer m 1 le m S is chosen and it is defined that f S f S 1 m f S m 1 S where S l r denotes the substring of S from the l th to the r th position inclusively Otherwise S c where c is some English letter Then f S 2 pos c where pos c is the position of letter c in the alphabet pos 0 pos 25 Note that m is chosen independently on each step Your friend thinks it is possible to get f S T by choosing the right m on every step Is he right ,"['#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nint n;\nint cnt[27];\n\nll T;\nll w[27];\n\nchar s[MAXN];\n\nint main()\n{\n\tscanf(""%d%lld%s"",&n,&T,s + 1);\n\tw[0] = 1;\n\tfor (int i = 1;i <= 26;i++)\n\t\tw[i] = w[i - 1] * 2;\n\tT -= w[s[n] - \'a\'];\n\tT += w[s[n - 1] - \'a\'];\n\tfor (int i = 1;i <= n - 2;i++)\n\t\tT -= w[s[i] - \'a\'];\n\tif (T > 0)\n\t{\n\t\tputs(""No"");\n\t\treturn 0;\n\t}\n\tT = -T;\n\tfor (int i = 1;i <= n - 2;i++)\n\t\tcnt[s[i] - \'a\' + 1]++;\n\tfor (int i = 26;i >= 0;i--)\n\t\twhile (cnt[i] && T >= w[i])\n\t\t{\n\t\t\tT -= w[i];\n\t\t\tcnt[i]--;\n\t\t}\n\tputs(!T ? ""Yes"" : ""No"");\n\treturn 0;\n}']","[1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
Misha hacked the Codeforces site Then he decided to let all the users change their handles A user can now change his handle any number of times But each new handle must not be equal to any handle that is already used or that was used at some point Misha has a list of handle change requests After completing the requests he wants to understand the relation between the original and the new handles of the users Help him to do that ,"['/*\n    Look at me!\n    Look at me!\n    Look at how large the monster inside me has become!\n*/\n\n#include<fstream>\n#include<iostream>\n#include<cstdio>\n#include<map>\n#include<set>\n#define FIT(a,b) for(vector<int >::iterator a=b.begin();a!=b.end();a++)\n#define FITP(a,b) for(vector<pair<int,int> >::iterator a=b.begin();a!=b.end();a++)\n#define RIT(a,b) for(vector<int>::reverse_iterator a=b.end();a!=b.begin();++a)\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#define REP(a,b) for(register int a=0;a<b;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<ctime>\n#define f cin\n#define g cout\n#include<queue>\n#define debug cerr<<""OK"";\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ll long long\n#define ull unsigned long long\n#define mod 666013\n#define inf 1<<30\n#define N 200100\n#define DIM 10000000\nusing namespace std;\n/*int dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};*/\n\nint T[N],K,q,sol;\nstring a[N],b[N],nou[N];\n\nint main ()\n{\n\n    #ifndef ONLINE_JUDGE\n    freopen(""a.in"",""r"",stdin);\n    freopen(""a.out"",""w"",stdout);\n    #endif\n\n    f>>q;\n    FOR(i,1,q)\n    {\n        f>>a[i]>>b[i];\n        K=1;\n        ROF(j,i-1,1)\n        if(a[i].compare(nou[j])==0)\n        {\n            K=0;\n            nou[j]=b[i];\n            break;\n        }\n        if(K)\n        nou[i]=b[i];\n    }\n    FOR(i,1,q)\n    if(nou[i][0])\n    sol++;\n    g<<sol<<""\\n"";\n    FOR(i,1,q)\n    if(nou[i][0])\n    {\n        g<<a[i]<<"" ""<<nou[i]<<""\\n"";\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1100
You are given a binary string s recall that a string is binary if each character is either 0 or 1 Let f t be the decimal representation of integer t written in binary form possibly with leading zeroes For example f 011 3 f 00101 5 f 00001 1 f 10 2 f 000 0 and f 000100 4 The substring s l s l 1 dots s r is good if r l 1 f s l dots s r For example string s 1011 has 5 good substrings s 1 dots s 1 1 s 3 dots s 3 1 s 4 dots s 4 1 s 1 dots s 2 10 and s 2 dots s 4 011 Your task is to calculate the number of good substrings of string s You have to answer t independent queries ,"['#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/05, 23:45:33\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nchar in[200002];\nint L[200001];\nllong solve() {\n    cin >> in + 1;\n    int n = strlen(in + 1);\n    L[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        if (in[i] == \'0\') L[i] = L[i - 1];\n        else L[i] = i + 1;\n    }\n    llong ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        int x = 0;\n        for (int j = i; j > 0 && i - j <= 20; --j) {\n            if (in[j] == \'1\') x |= 1 << i - j;\n            if (i - j + 1 == x) ++ans;\n        }\n        if (i - 20 > 1) {\n            int l = L[i - 20 - 1];\n            int mn = 22;\n            int mx = i - l + 1;\n            if (mn <= x && x <= mx) ++ans;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) printf(""%lld\\n"", solve());\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0]",1700
There is a strip with an infinite number of cells Cells are numbered starting with 0 Initially the cell i contains a ball with the number i There are n pockets located at cells a 1 ldots a n Each cell contains at most one pocket is the following sequence of operations All pockets at cells a 1 ldots a n open simultaneously which makes balls currently located at those cells disappear After the balls disappear the pockets close again For each cell i from 0 to infty if the cell i contains a ball we move that ball to the free cell j with the lowest number If there is no free cell j i the ball stays at the cell i Note that after each filtering operation each cell will still contain exactly one ball For example let the cells 1 3 and 4 contain pockets The initial configuration of balls is shown below underscores display the cells with pockets 0 2 5 6 7 8 9 After opening and closing the pockets balls 1 3 and 4 disappear 0 2 5 6 7 8 9 After moving all the balls to the left the configuration looks like this 0 5 8 9 10 11 12 Another filtering repetition results in the following 0 8 11 12 13 14 15 You have to answer m questions The i th of these questions is what is the number of the ball located at the cell x i after k i repetitions of the filtering operation ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100005;\nconst int M = 10000005;\n\nstruct node_t {\n  int l, r, value;\n} tree[M];\n\nint n, m, start, total, a[N], b[N], fenw[N], last[N], root[N], times[N];\nlong long sum[N];\n\nvoid modify(int x, int value) {\n  for (; x <= n; x += x & -x) {\n    fenw[x] += value;\n  }\n}\n\nint query(int x) {\n  int result = 0;\n  for (; x; x -= x & -x) {\n    result += fenw[x];\n  }\n  return result;\n}\n\nint erase(int x) {\n  int l = 1, r = n, p = n + 1;\n  while (l <= r) {\n    int mid = l + r >> 1;\n    if (query(mid) > x) {\n      p = mid;\n      r = mid - 1;\n    } else {\n      l = mid + 1;\n    }\n  }\n  modify(p, -1);\n  return p - 1;\n}\n\npair<long long, int> check(int p, int k, int x) {\n  x += times[p] - k;\n  int q = upper_bound(times, times + n, x) - times;\n  return make_pair((long long)x * q - sum[q], q);\n}\n\nint query_where(int x, int k) {\n  int l = 1, r = n - 1, result = 0;\n  while (l <= r) {\n    int mid = l + r >> 1;\n    if (check(mid, k, 0).first <= x) {\n      result = mid;\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  return result;\n}\n\nint query_exact(int x, int k, int p) {\n  int l = 1, r = times[p + 1] - times[p], result = 0;\n  if (p == n - 1) {\n    r = x / n + k + 1;\n  }\n  while (l <= r) {\n    int mid = l + (r - l >> 1);\n    if (check(p, k, mid).first <= x) {\n      result = mid;\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n    }\n  }\n  return result;\n}\n\nvoid modify(int &x, int y, int l, int r, int p) {\n  tree[x = ++total] = tree[y];\n  ++tree[x].value;\n  if (l != r) {\n    int mid = l + r >> 1;\n    if (p <= mid) {\n      modify(tree[x].l, tree[y].l, l, mid, p);\n    } else {\n      modify(tree[x].r, tree[y].r, mid + 1, r, p);\n    }\n  }\n}\n\nint query_kth(int x, int l, int r, int k) {\n  if (l == r) {\n    return l;\n  } else {\n    int mid = l + r >> 1;\n    if (k >= tree[tree[x].l].value) {\n      return query_kth(tree[x].r, mid + 1, r, k - tree[tree[x].l].value);\n    } else {\n      return query_kth(tree[x].l, l, mid, k);\n    }\n  }\n}\n\nint query_sum(int x, int l, int r, int p) {\n  if (r == p) {\n    return tree[x].value;\n  }\n  int mid = l + r >> 1;\n  if (p <= mid) {\n    return query_sum(tree[x].l, l, mid, p);\n  } else {\n    return tree[tree[x].l].value + query_sum(tree[x].r, mid + 1, r, p);\n  }\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  scanf(""%d %d"", &n, &m);\n  for (int i = 0; i < n; ++i) {\n    scanf(""%d"", &a[i]);\n  }\n  start = a[0];\n  for (int i = 0; i < n; ++i) {\n    a[i] -= start;\n  }\n  for (int i = 1; i < n; ++i) {\n    times[i] = times[i - 1] + (a[i] - last[i - 1]) / i;\n    last[i] = last[i - 1] + i * (times[i] - times[i - 1]);\n    sum[i + 1] = sum[i] + times[i];\n  }\n  for (int i = 1; i <= n; ++i) {\n    modify(i, 1);\n  }\n  for (int i = n - 1; ~i; --i) {\n    b[i] = erase(a[i] - last[i]);\n  }\n  for (int i = 0; i < n; ++i) {\n    modify(root[i + 1], root[i], 0, n - 1, b[i]);\n  }\n  while (m--) {\n    int x, k;\n    scanf(""%d %d"", &x, &k);\n    if (x < start) {\n      printf(""%d\\n"", x);\n    } else {\n      x -= start;\n      int p = query_where(x, k);\n      int q = query_exact(x, k, p);\n      pair<long long, int> result = check(p, k, q);\n      int remain = x - result.first, prefix = result.second;\n      int rank = query_kth(root[prefix], 0, n - 1, remain);\n      int numbers = 0;\n      if (rank) {\n        numbers = query_sum(root[p + 1], 0, n - 1, rank - 1);\n      }\n      printf(""%lld\\n"", start + last[p] + (long long)q * (p + 1) + numbers);\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3400
Let s call an array of non negative integers a 1 a 2 ldots a n a k extension for some non negative integer k if for all possible pairs of indices 1 leq i j leq n the inequality k cdot i j leq min a i a j is satisfied The expansion coefficient of the array a is the maximal integer k such that the array a is a k extension Any array is a 0 expansion so the expansion coefficient always exists You are given an array of non negative integers a 1 a 2 ldots a n Find its expansion coefficient ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 330000;\n\nint a[N];\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(""in.txt"", ""r"", stdin);\n\tfreopen(""out.txt"", ""w"", stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n; cin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tint ans = INT_MAX;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (i > 1) ans = min(ans, a[i] / (i - 1));\n\t\tif (i < n) ans = min(ans, a[i] / (n - i));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
One department of some software company has n servers of different specifications Servers are indexed with consecutive integers from 1 to n Suppose that the specifications of the j th server may be expressed with a single integer number c j of artificial resource units In order for production to work it is needed to deploy two services S 1 and S 2 to process incoming requests using the servers of the department Processing of incoming requests of service S i takes x i resource units The described situation happens in an advanced company that is why each service may be deployed using not only one server but several servers simultaneously If service S i is deployed using k i servers then the load is divided equally between these servers and each server requires only x i k i that may be a fractional number resource units Each server may be left unused at all or be used for deploying exactly one of the services but not for two of them simultaneously The service should not use more resources than the server provides Determine if it is possible to deploy both services using the given servers and if yes determine which servers should be used for deploying each of the services ,"['#include<bits/stdc++.h>\n#define L long long\n#define aa first\n#define bb second\n#define pb push_back\nusing namespace std;\nint n,m1,m2;\npair<int,int> a[300010];\nvector<int> x,y;\ninline void print()\n{\n    int i;\n    printf(""Yes\\n%d %d\\n"",(int)x.size(),(int)y.size());\n    for(i=0;i<x.size();i++)\n      printf(""%d "",x[i]);\n    printf(""\\n"");\n    for(i=0;i<y.size();i++)\n      printf(""%d "",y[i]);\n    printf(""\\n"");\n}\ninline bool chk()\n{\n    int i,j;\n    for(i=n;i>0;i--)\n      if((L)a[i].aa*(n-i+1)>=m1)\n        break;\n    if(i>0)\n      {\n       for(j=i-1;j>0;j--)\n         if((L)a[j].aa*(i-j)>=m2)\n           break;\n       if(j>0)\n         {\n          for(;j<i;j++)\n            y.pb(a[j].bb);\n          for(;i<=n;i++)\n            x.pb(a[i].bb);\n          return 1;\n         }\n       else\n         return 0;\n      }\n    else\n      return 0;\n}\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i,j,k1,k2;\n\tscanf(""%d%d%d"",&n,&m1,&m2);\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   scanf(""%d"",&a[i].aa);\n       a[i].bb=i;\n      }\n    sort(a+1,a+n+1);\n    if(chk())\n      print();\n    else\n      {\n       swap(m1,m2);\n       if(chk())\n         {\n          swap(x,y);\n          print();\n         }\n       else\n         printf(""No\\n"");\n      }\n\treturn 0;\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1700
The Little Elephant very much loves sums on intervals This time he has a pair of integers and The Little Elephant has to find the number of such integers that the first digit of integer equals the last one in decimal notation For example such numbers as or will be included in the answer and or will not Help him and count the number of described numbers for a given pair and ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nll p[22];\nll f(ll n){\n\tstringstream ss;\n\tss<<n;\n\tstring s = ss.str();\n\tll res =  0;\n\tFOR(i,1,s.size()){\n\t\tint len = i;\n\t\tlen -= 2;\n\t\tif(len<0) len = 0;\n\t\tres += p[len]*9;\n\t}\n\tstring t = s;\n\tFOR(i,1,10){\n\t\tif(s[0]-\'0\' < i) break;\n\t\tif(s[0]-\'0\' == i){\n\t\t\tll val = 0;\n\t\t\tFOR(j,1,s.size()-1) val = 10 * val + s[j]-\'0\';\n\t\t\tval ++;\n\t\t\tif(s[s.size()-1]-\'0\' < i) val--;\n\t\t\tres += val;\n\t\t}else res += p[max(0,(int)s.size()-2)];\n\t}\n\treturn res;\n}\n\nbool good(ll n){\n\tstringstream ss;\n\tss<<n;\n\tstring s = ss.str();\n\treturn s[0]==s[s.size()-1];\n}\nll stupid(ll l,ll r){\n\tll res = 0;\n\tfor(ll i = l;i<=r;i++)\n\t\tif(good(i)) res++;\n\treturn res;\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n#endif\n\n\tp[0]=1;\n\tFOR(i,1,20) p[i]=p[i-1]*10;\n\tll l,r;\n\tcin>>l>>r;\n\tif(l>r) swap(l,r);\n\tcout<<f(r)-f(l-1)<<endl;\n//\tcout<<f(r)<<\' \'<<f(l-1)<<endl;\n//\tcout<<stupid(l,r)<<endl;\n\t//if(f(r)-f(l-1)==stupid(l,r)) goto start;\n\n#ifdef LocalHost\n\tcerr<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]",1500
You are given a set of 2n 1 integer points on a Cartesian plane Points are numbered from 0 to 2n inclusive Let P i be the i th point The x coordinate of the point P i equals i The y coordinate of the point P i equals zero initially Thus initially P i i 0 The given points are vertices of a plot of a piecewise function The j th piece of the function is the segment P j P j 1 In one move you can increase the y coordinate of any point with odd x coordinate i e such points are P 1 P 3 dots P 2n 1 by 1 Note that the corresponding segments also change For example the following plot shows a function for n 3 i e number of points is 2 cdot3 1 7 in which we increased the y coordinate of the point P 1 three times and y coordinate of the point P 5 one time Let the area of the plot be the area below this plot and above the coordinate axis OX For example the area of the plot on the picture above is 4 the light blue area on the picture above is the area of the plot drawn on it Let the height of the plot be the maximum y coordinate among all initial points in the plot i e points P 0 P 1 dots P 2n The height of the plot on the picture above is 3 Your problem is to say which minimum possible height can have the plot consisting of 2n 1 vertices and having an area equal to k Note that it is unnecessary to minimize the number of moves It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding 10 18 ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\nLL n, k;\nvoid init(){\n  cin>>n>>k;\n}\nvoid solve(){\n  LL per=k/n;\n  if(n * per < k) per++;\n  cout<<per<<endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
There are piles of stones of sizes lying on the table in front of you During one move you can take one pile and add it to the other As you add pile to pile the size of pile increases by the current size of pile and pile stops existing The cost of the adding operation equals the size of the added pile Your task is to determine the minimum cost at which you can gather all stones in one pile To add some challenge the stone piles built up conspiracy and decided that each pile will let you add to it not more than times after that it can only be added to another pile Moreover the piles decided to puzzle you completely and told you variants not necessarily distinct of what might equal Your task is to find the minimum cost for each of variants ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<iostream>\nusing namespace std;\n// }}}\n// #defines {{{\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define SZ(x) ((int)(x).size())\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,n) for(int i=(n)-1;i>=0;i--)\n#define PER1(i,a,b) for(int i=(b);i>=(a);i--)\n#define RI(x) scanf(""%d"",&x)\n#define DRI(x) int x;RI(x)\n#define RII(x,y) scanf(""%d%d"",&x,&y)\n#define DRII(x,y) int x,y;RII(x,y);\n#define RIII(x,y,z) scanf(""%d%d"",&x,&y,&z)\n#define DRIII(x,y,z) int x,y,z;RIII(x,y,z);\n#define CASET int ___T,cas=1;scanf(""%d"",&___T);while(___T--)\n#define CASEN0(n) int cas=1;while(scanf(""%d"",&n)!=EOF&&n)\n#define CASEN(n) int cas=1;while(scanf(""%d"",&n)!=EOF)\n#define MP make_pair\n#define PB push_back\n#define MS0(x) memset(x,0,sizeof(x))\n#define MS1(x) memset(x,-1,sizeof(x))\n#define SEP(x) ((x)?\'\\n\':\' \')\n#define F first\n#define S second\ntypedef pair<int,int> PII;\ntypedef long long LL;\n// }}}\n\nint in[101000];\nlong long sum[101000];\nbool cmp(int a,int b){return a>b;}\nint main(){\n    DRI(n);\n    REP(i,n)RI(in[i]);\n    sort(in,in+n,cmp);\n    DRI(q);\n    sum[0]=0;\n    REP(i,n)sum[i+1]=sum[i]+in[i];\n    long long a1=0;\n    REP1(i,1,n-1)a1+=i*1LL*in[i];\n    while(q--){\n        DRI(k);\n        if(k==1)printf(""%I64d"",a1);\n        else{\n            int np=1;\n            long long s=k,ans=0;\n            int cnt=1;\n            while(np<n){\n                long long tnp=np+s;\n                if(tnp>n)tnp=n;\n                ans+=cnt*(sum[tnp]-sum[np]);\n                np=tnp;\n                s*=k;\n                cnt++;\n            }\n            printf(""%I64d"",ans);\n        }\n        printf(""%c"",SEP(!q));\n    }\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
You have distinct points on a plane none of them lie on axis Check that there is a point after removal of which the remaining points are located on one side of the axis ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n,a,b;\n\nint main()\n{\n    scanf(""%d"",&n);\n    a=0;b=0;\n    for (int i=1;i<=n;i++)\n    {\n        int x,y;scanf(""%d%d"",&x,&y);\n        if (x>0) a++; else b++;\n    }\n    if (a>1&&b>1) puts(""No\\n""); else puts(""Yes\\n"");\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
There is a ribbon divided into n cells numbered from 1 to n from left to right Initially an integer 0 is written in each cell Monocarp plays a game with a chip The game consists of several turns During the first turn Monocarp places the chip in the 1 st cell of the ribbon During each turn Monocarp does of the two following actions move the chip to the next cell i e if the chip is in the cell i it is moved to the cell i 1 This action is impossible if the chip is in the last cell choose any cell x and teleport the chip into that cell At the end of each turn the integer written in the cell with the chip is increased by 1 Monocarp s goal is to make some turns so that the 1 st cell contains the integer c 1 the 2 nd cell contains the integer c 2 the n th cell contains the integer c n He wants to teleport the chip as few times as possible Help Monocarp calculate the minimum number of times he has to teleport the chip ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int lst = 0;\n    long long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        int x;\n        cin >> x;\n        if (x > lst) {\n            ans += x - lst;\n        }\n        lst = x;\n    }\n    cout << ans - 1 << ""\\n"";\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
You are given a string consisting of lowercase Latin letters Character is called dominant iff each substring of with length at least contains this character You have to find minimum such that there exists at least one dominant character ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 101010\nvoid build(){\n\n}\nchar c[ N ];\nint len;\nvoid init(){\n  cin >> c;\n  len = strlen( c );\n}\nint check( char cc ){\n  vector<int> vv;\n  int pre = -1 , mx = 0;\n  for( int i = 0 ; i < len ; i ++ )\n    if( c[ i ] == cc ){\n      mx = max( mx , i - pre );\n      pre = i;\n    }\n  mx = max( mx , len - pre );\n  return mx;\n}\nvoid solve(){\n  int ans = N;\n  for( int i = 0 ; i < 26 ; i ++ )\n    ans = min( ans , check( i + \'a\' ) );\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1400
Xenia is an amateur programmer Today on the IT lesson she learned about the Hamming distance The Hamming distance between two strings and of equal length is value Record is the Iverson notation and represents the following if it is one otherwise zero Now Xenia wants to calculate the Hamming distance between two long strings and The first string is the concatenation of copies of string that is The second string is the concatenation of copies of string Help Xenia calculate the required Hamming distance given ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 1000010;\n\nint ca[N][26], cb[N][26];\nchar x[N], y[N];\n\nint gcd(int a, int b) {\n  while (a > 0 && b > 0)\n    if (a > b) a %= b;\n    else b %= a;\n  return a + b;\n}\n\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  scanf(""%s"", x);\n  scanf(""%s"", y);\n  int a = strlen(x);\n  int b = strlen(y);\n  int g = gcd(a, b);\n  for (int i = 0; i < g; i++)\n    for (int j = 0; j < 26; j++) ca[i][j] = cb[i][j] = 0;\n  for (int i = 0; i < a; i++) ca[i % g][x[i] - \'a\']++;\n  for (int i = 0; i < b; i++) cb[i % g][y[i] - \'a\']++;\n  long long matches = 0;\n  for (int i = 0; i < g; i++)\n    for (int j = 0; j < 26; j++) matches += (long long)ca[i][j] * cb[i][j];\n  long long total = n * a;\n  matches *= (n / (b / g));\n  cout << (total - matches) << endl;\n  return 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
You have a fence consisting of n vertical boards The width of each board is 1 The height of the i th board is a i You think that the fence is if there is no pair of adjacent boards having the same height More formally the fence is great if and only if for all indices from 2 to n the condition a i 1 neq a i holds Unfortunately it is possible that now your fence is not great But you can change it You can increase the length of the i th board by 1 but you have to pay b i rubles for it The length of each board can be increased any number of times possibly zero Calculate the minimum number of rubles you have to spend to make the fence great again You have to answer q independent queries ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 3 * (int)1e5 + 100;\nint n;\nll a[maxN], b[maxN];\nconst int BUBEN = 4;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    int q;\n    cin >> q;\n    while (q--) {\n        cin >> n;\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i] >> b[i];\n        }\n        vector < pair < ll, ll > > best;\n        for (int i = 0; i <= BUBEN; i++) {\n            best.emplace_back(b[1] * i, a[1] + i);\n        }\n        for (int i = 2; i <= n; i++) {\n            vector < pair < ll, ll > > nbest;\n            for (int j = 0; j <= BUBEN; j++) {\n                ll mn = 2e18;\n                for (auto it : best) {\n                    if (it.second != a[i] + j) mn = min(mn, it.first);\n                }\n                mn += j * b[i];\n                nbest.emplace_back(mn, a[i] + j);\n            }\n            best = nbest;\n        }\n        ll mn = 2e18;\n        for (auto it : best) mn = min(mn, it.first);\n        cout << mn << \'\\n\';\n    }\n    return 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Monocarp is playing a computer game He s going to kill n monsters the i th of them has h i health Monocarp s character has two spells either of which he can cast an arbitrary number of times possibly zero and in an arbitrary order choose exactly two alive monsters and decrease their health by 1 choose a single monster and kill it When a monster s health becomes 0 it dies What s the minimum number of spell casts Monocarp should perform in order to kill all monsters ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[500005];\nsigned main()\n{\n\tint t,n,sl;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tsl=0;\n\t\tfor(int i=1;i<=n;i++)a[i]=read(),sl+=(a[i]==1);\n\t\tprintf(""%d\\n"",n-sl/2);\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",800
You have a rectangular chocolate bar consisting of single squares You want to eat squares so you may need to break the chocolate bar In one move you can break any single rectangular piece of chocolate in two rectangular pieces You can break only by lines between squares horizontally or vertically The cost of breaking is equal to square of the break length For example if you have a chocolate bar consisting of unit squares then you can break it horizontally and get two pieces the cost of such breaking is or you can break it vertically in two ways and get two pieces and the cost of such breaking is For several given values and find the minimum total cost of breaking You can eat exactly squares of chocolate if after all operations of breaking there is a set of rectangular pieces of chocolate with the total size equal to squares The remaining squares are not necessarily form a single rectangular piece ,"[""//ITNOA\n#include<bits/stdc++.h> \n\nusing namespace std;\n \n\n#define scan(x) do{while((x=getchar())<'0'); for(x-='0'; '0'<=(_=getchar()); x=(x<<3)+(x<<1)+_-'0');}while(0)\nchar _;\n\n//#define int long long\n#define rep(i, s, e) for(int i = s; i < e; i ++)\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxN = 1000 + 5;\nconst int mod = 1000*1000*1000 + 7;\nconst int base = 701;\nconst int SQ = 600;\nconst int maxL = 302;\n\n\nint dp[32][32][52];\n\nint32_t main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    rep(i,0,32) rep(j,0,32) rep(k,0,52)\n\tdp[i][j][k] = mod;\n\n    rep(i,1,32) rep(j,1,32)\n    {\n\tif(i * j < 52) dp[i][j][i*j] = 0;\n\tdp[i][j][0] = 0;\n\n\tint x = min(52, i*j);\n\trep(k,1,x)\n\t{\n\t    rep(who,0,k+1)\n\t    {\n\t\trep(wh,1,j)\n\t\t    dp[i][j][k] = min(dp[i][j][k], dp[i][wh][who] + dp[i][j-wh][k-who] + i * i);\n\t\trep(wh,1,i)\n\t\t    dp[i][j][k] = min(dp[i][j][k], dp[wh][j][who] + dp[i-wh][j][k-who] + j * j);\n\t    }\n\t}\n    }\n\n    int q; cin >> q;\n    rep(i,0,q)\n    {\n\tint n, m, k; cin >> n >> m >> k;\n\tcout << dp[n][m][k] << endl;\n    }\n    return 0;    \n}\n""]","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2000
The start of the new academic year brought about the problem of accommodation students into dormitories One of such dormitories has a square meter wonder room The caretaker wants to accommodate exactly students there But the law says that there must be at least 6 square meters per student in a room that is the room for students must have the area of at least square meters The caretaker can enlarge any possibly both side of the room by an arbitrary positive integer of meters Help him change the room so as all students could live in it and the total area of the room was as small as possible ,"['#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define MAXN 100005\n#define INF 0x7fffffffffffffffLL\nusing namespace std ;\ntypedef long long LL ;\n\nLL A, B, N, sq ;\nLL ta, tb, ba, bb, ans = INF ;\n\nint main()\n{\n\tint i, j ;\n\tscanf(""%I64d %I64d %I64d"", &N, &A, &B) ;\n\tN *= 6,\tsq = sqrt(N)+3 ;\n\tfor(ta = A; ta <= max(A, sq); ta ++)\n\t{\n\t\ttb = max(B, N/ta+(N%ta!=0)) ;\n\t\tif(ta*tb < ans) ans = ta*tb, ba = ta, bb = tb ;\n\t}\n\tfor(tb = B; tb <= max(B, sq); tb ++)\n\t{\n\t\tta = max(A, N/tb+(N%tb!=0)) ;\n\t\tif(ta*tb < ans) ans = ta*tb, ba = ta, bb = tb ;\n\t}\n\tprintf(""%I64d\\n%I64d %I64d\\n"", ans, ba, bb) ;\n\t//system(""pause"") ;\n\treturn 0 ;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2000
You are a game designer and want to make an obstacle course The player will walk from left to right You have n heights of mountains already selected and want to arrange them so that the absolute difference of the heights of the first and last mountains is as small as possible In addition you want to make the game difficult and since walking uphill or flat is harder than walking downhill the difficulty of the level will be the number of mountains i 1 leq i n such that h i leq h i 1 where h i is the height of the i th mountain You don t want to waste any of the mountains you modelled so you have to use all of them From all the arrangements that minimize h 1 h n find one that is the most difficult If there are multiple orders that satisfy these requirements you may find any ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <random>\n#include ""map""\ntypedef double ld;\ntypedef long long ll;\n#define all(x) x.begin(), x.end()\nusing namespace std;\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (auto &i : a)\n        cin >> i;\n    int p = n - 1;\n    sort(all(a));\n    for (int i = 0; i < n - 1; ++i) {\n        if (abs(a[i + 1] - a[i]) < abs(a[(p + 1) % n] - a[p]))\n            p = i;\n    }\n    for (int i = p + 1; i < n; ++i) {\n        cout << a[i] << \' \';\n    }\n    for (int i = 0; i < p + 1; ++i) {\n        cout << a[i] << \' \';\n    }\n    cout << \'\\n\';\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int q;\n    cin >> q;\n    while (q--) solve();\n}\n']","[1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You are given an undirected unrooted tree i e a connected undirected graph without cycles You must assign a integer weight to each vertex so that the following is satisfied if any vertex of the tree is removed then each of the remaining connected components has the same sum of weights in its vertices ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    i64 n;\n    std::cin >> n;\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--;\n        v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    std::vector<int> ans(n);\n    auto dfs = [&](auto self, int u, int p, int x) -> void {\n        ans[u] = x;\n        for (auto v : adj[u]) {\n            if (v == p) {\n                continue;\n            }\n            self(self, v, u, x == 0 ? 1 : -x);\n            ans[u] -= x == 0 ? 1 : -x;\n        }\n    };\n    dfs(dfs, 0, -1, 0);\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0]",2200
Living in Byteland was good enough to begin with but the good king decided to please his subjects and to introduce a national language He gathered the best of wise men and sent an expedition to faraway countries so that they would find out all about how a language should be designed After some time the wise men returned from the trip even wiser They locked up for six months in the dining room after which they said to the king there are a lot of different languages but almost all of them have letters that are divided into vowels and consonants in a word vowels and consonants must be combined correctly There are very many rules all of them have exceptions but our language will be deprived of such defects We propose to introduce a set of formal rules of combining vowels and consonants and include in the language all the words that satisfy them The rules of composing words are The letters are divided into vowels and consonants in some certain way All words have a length of exactly There are rules of the form Each rule is if the position has a letter of type then the position has a letter of type You are given some string of length it is not necessarily a correct word of the new language Among all the words of the language that lexicographically not smaller than the string find the minimal one in lexicographic order ,"['#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#ifdef WIN32\n\t#define LLD ""%I64d""\n#else\n\t#define LLD ""%lld""\n#endif\n\n#define pb push_back\n#define all(x) begin(x), end(x)\n\nconst int maxn = 405;\n\nvector<int> gr[maxn], grr[maxn], gr2[maxn], grr2[maxn];\nbool vis[maxn];\nint c[maxn];\nbool was[maxn][2];\nchar s[maxn], answer[maxn];\nvector<int> order;\n\nchar types[maxn], type1[10], type2[10];\nint t[maxn];\nint L, n, m;\n\nvoid toorder(int cur)\n{\n    if (vis[cur]) return;\n    vis[cur] = true;\n    for (auto x : gr[cur]) toorder(x);\n    for (auto x : gr2[cur]) toorder(x);\n    order.pb(cur);\n}\n\nvoid mark(int cur, int curc)\n{\n    if (vis[cur]) return;\n    vis[cur] = true;\n    c[cur] = curc;\n    for (auto x : grr[cur]) mark(x, curc);\n    for (auto x : grr2[cur]) mark(x, curc);\n}\n\nbool poss()\n{\n//     cout << ""poss "" << endl;\n//     for (int i = 0; i < 2 * n; i++)\n//     {\n//         cout << i << "": "";\n//         for (auto x : gr[i]) cout << x << \' \';\n//         cout << "" and "";\n//         for (auto x : gr2[i]) cout << x << \' \';\n//         cout << endl;\n//     }\n    order.resize(0);\n    for (int i = 0; i < 2 * n; i++) vis[i] = false;\n    for (int i = 0; i < 2 * n; i++) if (!vis[i]) toorder(i);\n    for (int i = 0; i < 2 * n; i++) vis[i] = false;\n    int kcomp = 0;\n    for (int i = (int)order.size() - 1; i >= 0; i--) if (!vis[order[i]])\n    {\n        mark(order[i], kcomp++);\n    }\n    for (int i = 0; i < n; i++) if (c[i] == c[i + n]) return false;\n    return true;\n}\n\nvoid go(int cur, bool follow)\n{\n//     cout << ""go "" << cur << \' \' << follow << endl;\n    if (!poss()) return;\n    if (cur == n)\n    {\n        answer[n] = \'\\0\';\n        printf(""%s\\n"", answer);\n        exit(0);\n    }\n    gr2[cur].clear();\n    gr2[cur + n].clear();\n    int start = 0;\n    if (follow)\n    {\n        int curt = t[s[cur] - \'a\'];\n        gr2[cur + (1 - curt) * n].pb(cur + curt * n);\n        grr2[cur + curt * n].pb(cur + (1 - curt) * n);\n        answer[cur] = s[cur];\n        go(cur + 1, true);\n        gr2[cur + (1 - curt) * n].clear();\n        grr2[cur + curt * n].clear();\n        start = s[cur] - \'a\' + 1;\n    }\n    was[cur][0] = false;\n    was[cur][1] = false;\n    for (int i = start; i < L; i++) if (!was[cur][t[i]])\n    {\n//         cout << cur << "" choose "" << i << endl;\n        answer[cur] = \'a\' + i;\n        int curt = t[i];\n        gr2[cur + (1 - curt) * n].pb(cur + curt * n);\n        grr2[cur + curt * n].pb(cur + (1 - curt) * n);\n        go(cur + 1, false);\n        gr2[cur + (1 - curt) * n].clear();\n        grr2[cur + curt * n].clear();\n        was[cur][t[i]] = true;\n    }\n}\n\nint main()\n{\n    scanf(""%s"", types);\n    L = strlen(types);\n    for (int i = 0; i < L; i++)\n    {\n        if (types[i] == \'V\') t[i] = 0;\n        else t[i] = 1;\n    }\n    scanf(""%d%d"", &n, &m);\n    for (int i = 0; i < m; i++)\n    {\n        int pos1, pos2, t1, t2;\n        scanf(""%d%s%d%s"", &pos1, type1, &pos2, type2);\n        pos1--, pos2--;\n        t1 = (type1[0] == \'V\' ? 0 : 1);\n        t2 = (type2[0] == \'V\' ? 0 : 1);\n        gr[pos1 + n * t1].pb(pos2 + n * t2);\n        grr[pos2 + n * t2].pb(pos1 + n * t1);\n        gr[pos2 + n * (1 - t2)].pb(pos1 + n * (1 - t1));\n        grr[pos1 + n * (1 - t1)].pb(pos2 + n * (1 - t2));\n    }\n    scanf(""%s"", s);\n    go(0, true);\n    cout << -1 << endl;\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2600
Caisa is now at home and his son has a simple task for him Given a rooted tree with vertices numbered from to vertex is the root Each vertex of the tree has a value You should answer queries Each query is one of the following Format of the query is 1 Let s write out the sequence of vertices along the path from the root to vertex You need to output such a vertex that and If there are several possible vertices pick the one with maximum value of If there is no such vertex output Format of the query is 2 You must change the value of vertex to You are given all the queries help Caisa to solve the problem ,"['#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <stack>\n#include <functional>\n\n#define snuke(it,x) for (__typeof((x).begin()) it = (x).begin(); it != (x).end(); ++ it)\n\ntypedef long long lld;\nconst int INF = 0X3F3F3F3F;\nconst int M = 2000000 + 5;\nconst int N = 100000 + 5;\nstd::stack<int> stack[200000 + 5];\nint prime[M],ptot,min_div[M],Index[M];\nbool doge[M];\nint A[N],answer[N],depth[N];\nstd::stack<int> queries[N];\nstd::vector<int> edges[N];\n\nvoid getPrime(int n) {\n    for (int i = 2; i <= n; ++ i) {\n        if (!doge[i]) {\n            Index[i] = ptot;\n            prime[ptot++] = i;\n            min_div[i] = i;\n        }\n        for (int j = 0; j < ptot; ++ j) {\n            if (i*prime[j]>n) break;\n            doge[i*prime[j]] = true;\n            min_div[i*prime[j]] = prime[j];\n            if (i%prime[j]==0) break;\n        }\n    }\n}\n\nvoid dfs(int u,int fa) {\n    if (fa!=-1) depth[u] = depth[fa] + 1;\n    int value = A[u];\n    int max_depth = -1,p = -2;\n    while (value>1) {\n        int d = min_div[value];\n        while (value%d==0) value /= d;\n        if (!stack[Index[d]].empty()) {\n            int id = stack[Index[d]].top();\n            if (max_depth < depth[id]) {\n                max_depth = depth[id];\n                p = id;\n            }\n        }\n        stack[Index[d]].push(u);\n    }\n    while (!queries[u].empty()) {\n        int id = queries[u].top(); queries[u].pop();\n        answer[id] = p + 1;\n    }\n    snuke(it,edges[u]) {\n        int v = *it;\n        if (v==fa) continue;\n        dfs(v,u);\n    }\n    value = A[u];\n    while (value>1) {\n        int d = min_div[value];\n        while (value%d==0) value /= d;\n        stack[Index[d]].pop();\n    }\n}\n\nvoid solve() {\n    dfs(0,-1);\n}\n\nint main() {\n    getPrime(2000000);\n    int n,nq;\n    scanf(""%d%d"",&n,&nq);\n    for (int i = 0; i < n; ++ i) {\n        scanf(""%d"",A+i);\n    }\n    for (int i = 0; i < n-1; ++ i) {\n        int a,b;\n        scanf(""%d%d"",&a,&b); a --; b --;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n    for (int i = 0; i < nq; ++ i) {\n        int op,a,b;\n        scanf(""%d"",&op);\n        if (op==1) {\n            scanf(""%d"",&a); a --;\n            queries[a].push(i);\n        } else {\n            scanf(""%d%d"",&a,&b); a --;\n            solve();\n            A[a] = b;\n            answer[i] = INF;\n        }\n    }\n    solve();\n    for (int i = 0; i < nq; ++ i) {\n        if (answer[i] != INF) {\n            printf(""%d\\n"",answer[i]);\n        }\n    }\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0]",2100
Polycarp has a string s 1 dots n of length n consisting of decimal digits Polycarp performs the following operation with the string s i e he can perform operation 0 or 1 time Polycarp selects two numbers i and j 1 leq i leq j leq n and removes characters from the s string at the positions i i 1 i 2 ldots j i e removes substring s i dots j More formally Polycarp turns the string s into the string s 1 s 2 ldots s i 1 s j 1 s j 2 ldots s n For example the string s Polycarp can turn into strings in this case i j 3 6 or i j 1 4 in this case i j 6 6 in this case i j 1 5 other operations are also possible only a few of them are listed above Polycarp likes the string very much so he is wondering if it is possible to turn the string s into a string in no more than one operation Note that you can perform zero operations ,"['#include <bits/stdc++.h>\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define si short int\n#define speed ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define pill pair<ll,ll>\n#define f first\n#define s second\n#define pilc pair<ll,char>\n#define all(a) (a).begin(),(a).end()\n#define rep(s,e,step) for(int i = (s); i < (e) ; i += step)\n#define vrep(s,e,step) for(int j = (s); j < (e) ; j += step)\n#define ex exit(0) \n#define sz(a) (a).size()\n#define triple pair<pill, ll>\n#define pinode pair<node*, node*>\n#define quadra pair<pill, pill>\n#define ld long double\nusing namespace std;\n \nconst ll N = 2e5 + 10;\nconst ll M = 2e5 + 1;\nconst ll big = 1e18;\nconst ll hsh2 = 1964325029 ;\nconst long long mod = 1e9 + 7;\nconst long double EPS = 1e-14;\nconst ll block = 1e7;\nconst ll shift = 2e3;\nmt19937_64 rofl(chrono::steady_clock::now().time_since_epoch().count());\n\nll t;\n\nvoid solve() {\n\tll n;\n\tstring a;\n\tcin >> n >> a;\n\tll L = 0, R = 0;\n\tstring x, y, p = ""2020"";\n\tfor(int j = 0; j < 4; j++) {\n\t\tx += a[j];  \t        \n\t\tif(x == p.substr(0, j + 1))\n\t\t\tL = j + 1;\n\t}\n\tfor(int j = n - 1; j >= n - 4; j--) {\n\t\ty = a[j] + y;\n\t\tif(y == p.substr(4 - (n - j), (n - j)))\n\t\t\tR = n - j;\n\t}\n\tif(L + R >= 4)\n\t\tcout << ""yEs\\n"";\n\telse\n\t\tcout << ""nO\\n"";\n}\n\nint main() {\n\tspeed;\n\tcin >> t;\n\twhile(t--)solve(); \t\n}              \n/*\nqiwwqdesw\n1\nd\n \n*/']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",800
You are given 2n tuples of values a b c where a and b are positive integers and c is a bracket or Exactly n tuples have c and the other n tuples have c You are asked to choose two positive values x and y x 0 and y 0 and sort the tuples in the increasing value of a cdot x b cdot y If several tuples have the same value you can place them in any order among themselves Is it possible to choose such x and y that taking brackets c from the tuples in the resulting order produces a regular bracket sequence ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nstruct Point {\n    T x;\n    T y;\n    Point(T x_ = 0, T y_ = 0) : x(x_), y(y_) {}\n    \n    template<class U>\n    operator Point<U>() {\n        return Point<U>(U(x), U(y));\n    }\n    Point &operator+=(Point p) & {\n        x += p.x;\n        y += p.y;\n        return *this;\n    }\n    Point &operator-=(Point p) & {\n        x -= p.x;\n        y -= p.y;\n        return *this;\n    }\n    Point &operator*=(T v) & {\n        x *= v;\n        y *= v;\n        return *this;\n    }\n    Point &operator/=(T v) & {\n        x /= v;\n        y /= v;\n        return *this;\n    }\n    Point operator-() const {\n        return Point(-x, -y);\n    }\n    friend Point operator+(Point a, Point b) {\n        return a += b;\n    }\n    friend Point operator-(Point a, Point b) {\n        return a -= b;\n    }\n    friend Point operator*(Point a, T b) {\n        return a *= b;\n    }\n    friend Point operator/(Point a, T b) {\n        return a /= b;\n    }\n    friend Point operator*(T a, Point b) {\n        return b *= a;\n    }\n    friend bool operator==(Point a, Point b) {\n        return a.x == b.x && a.y == b.y;\n    }\n    friend std::istream &operator>>(std::istream &is, Point &p) {\n        return is >> p.x >> p.y;\n    }\n    friend std::ostream &operator<<(std::ostream &os, Point p) {\n        return os << ""("" << p.x << "", "" << p.y << "")"";\n    }\n};\n\ntemplate<class T>\nT dot(Point<T> a, Point<T> b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ntemplate<class T>\nT cross(Point<T> a, Point<T> b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ntemplate<class T>\nT square(Point<T> p) {\n    return dot(p, p);\n}\n\ntemplate<class T>\ndouble length(Point<T> p) {\n    return std::sqrt(double(square(p)));\n}\n\nlong double length(Point<long double> p) {\n    return std::sqrt(square(p));\n}\n\ntemplate<class T>\nPoint<T> normalize(Point<T> p) {\n    return p / length(p);\n}\n\ntemplate<class T>\nstruct Line {\n    Point<T> a;\n    Point<T> b;\n    Line(Point<T> a_ = Point<T>(), Point<T> b_ = Point<T>()) : a(a_), b(b_) {}\n};\n\ntemplate<class T>\nPoint<T> rotate(Point<T> a) {\n    return Point(-a.y, a.x);\n}\n\ntemplate<class T>\nint sgn(Point<T> a) {\n    return a.y > 0 || (a.y == 0 && a.x > 0) ? 1 : -1;\n}\n\ntemplate<class T>\nbool pointOnLineLeft(Point<T> p, Line<T> l) {\n    return cross(l.b - l.a, p - l.a) > 0;\n}\n\ntemplate<class T>\nPoint<T> lineIntersection(Line<T> l1, Line<T> l2) {\n    return l1.a + (l1.b - l1.a) * (cross(l2.b - l2.a, l1.a - l2.a) / cross(l2.b - l2.a, l1.a - l1.b));\n}\n\ntemplate<class T>\nbool pointOnSegment(Point<T> p, Line<T> l) {\n    return cross(p - l.a, l.b - l.a) == 0 && std::min(l.a.x, l.b.x) <= p.x && p.x <= std::max(l.a.x, l.b.x)\n        && std::min(l.a.y, l.b.y) <= p.y && p.y <= std::max(l.a.y, l.b.y);\n}\n\ntemplate<class T>\nbool pointInPolygon(Point<T> a, std::vector<Point<T>> p) {\n    int n = p.size();\n    for (int i = 0; i < n; i++) {\n        if (pointOnSegment(a, Line(p[i], p[(i + 1) % n]))) {\n            return true;\n        }\n    }\n    \n    int t = 0;\n    for (int i = 0; i < n; i++) {\n        auto u = p[i];\n        auto v = p[(i + 1) % n];\n        if (u.x < a.x && v.x >= a.x && pointOnLineLeft(a, Line(v, u))) {\n            t ^= 1;\n        }\n        if (u.x >= a.x && v.x < a.x && pointOnLineLeft(a, Line(u, v))) {\n            t ^= 1;\n        }\n    }\n    \n    return t == 1;\n}\n\n// 0 : not intersect\n// 1 : strictly intersect\n// 2 : overlap\n// 3 : intersect at endpoint\ntemplate<class T>\nstd::tuple<int, Point<T>, Point<T>> segmentIntersection(Line<T> l1, Line<T> l2) {\n    if (std::max(l1.a.x, l1.b.x) < std::min(l2.a.x, l2.b.x)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    if (std::min(l1.a.x, l1.b.x) > std::max(l2.a.x, l2.b.x)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    if (std::max(l1.a.y, l1.b.y) < std::min(l2.a.y, l2.b.y)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    if (std::min(l1.a.y, l1.b.y) > std::max(l2.a.y, l2.b.y)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    if (cross(l1.b - l1.a, l2.b - l2.a) == 0) {\n        if (cross(l1.b - l1.a, l2.a - l1.a) != 0) {\n            return {0, Point<T>(), Point<T>()};\n        } else {\n            auto maxx1 = std::max(l1.a.x, l1.b.x);\n            auto minx1 = std::min(l1.a.x, l1.b.x);\n            auto maxy1 = std::max(l1.a.y, l1.b.y);\n            auto miny1 = std::min(l1.a.y, l1.b.y);\n            auto maxx2 = std::max(l2.a.x, l2.b.x);\n            auto minx2 = std::min(l2.a.x, l2.b.x);\n            auto maxy2 = std::max(l2.a.y, l2.b.y);\n            auto miny2 = std::min(l2.a.y, l2.b.y);\n            Point<T> p1(std::max(minx1, minx2), std::max(miny1, miny2));\n            Point<T> p2(std::min(maxx1, maxx2), std::min(maxy1, maxy2));\n            if (!pointOnSegment(p1, l1)) {\n                std::swap(p1.y, p2.y);\n            }\n            if (p1 == p2) {\n                return {3, p1, p2};\n            } else {\n                return {2, p1, p2};\n            }\n        }\n    }\n    auto cp1 = cross(l2.a - l1.a, l2.b - l1.a);\n    auto cp2 = cross(l2.a - l1.b, l2.b - l1.b);\n    auto cp3 = cross(l1.a - l2.a, l1.b - l2.a);\n    auto cp4 = cross(l1.a - l2.b, l1.b - l2.b);\n    \n    if ((cp1 > 0 && cp2 > 0) || (cp1 < 0 && cp2 < 0) || (cp3 > 0 && cp4 > 0) || (cp3 < 0 && cp4 < 0)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    \n    Point p = lineIntersection(l1, l2);\n    if (cp1 != 0 && cp2 != 0 && cp3 != 0 && cp4 != 0) {\n        return {1, p, p};\n    } else {\n        return {3, p, p};\n    }\n}\n\ntemplate<class T>\nbool segmentInPolygon(Line<T> l, std::vector<Point<T>> p) {\n    int n = p.size();\n    if (!pointInPolygon(l.a, p)) {\n        return false;\n    }\n    if (!pointInPolygon(l.b, p)) {\n        return false;\n    }\n    for (int i = 0; i < n; i++) {\n        auto u = p[i];\n        auto v = p[(i + 1) % n];\n        auto w = p[(i + 2) % n];\n        auto [t, p1, p2] = segmentIntersection(l, Line(u, v));\n        \n        if (t == 1) {\n            return false;\n        }\n        if (t == 0) {\n            continue;\n        }\n        if (t == 2) {\n            if (pointOnSegment(v, l) && v != l.a && v != l.b) {\n                if (cross(v - u, w - v) > 0) {\n                    return false;\n                }\n            }\n        } else {\n            if (p1 != u && p1 != v) {\n                if (pointOnLineLeft(l.a, Line(v, u))\n                    || pointOnLineLeft(l.b, Line(v, u))) {\n                    return false;\n                }\n            } else if (p1 == v) {\n                if (l.a == v) {\n                    if (pointOnLineLeft(u, l)) {\n                        if (pointOnLineLeft(w, l)\n                            && pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    } else {\n                        if (pointOnLineLeft(w, l)\n                            || pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    }\n                } else if (l.b == v) {\n                    if (pointOnLineLeft(u, Line(l.b, l.a))) {\n                        if (pointOnLineLeft(w, Line(l.b, l.a))\n                            && pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    } else {\n                        if (pointOnLineLeft(w, Line(l.b, l.a))\n                            || pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    }\n                } else {\n                    if (pointOnLineLeft(u, l)) {\n                        if (pointOnLineLeft(w, Line(l.b, l.a))\n                            || pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    } else {\n                        if (pointOnLineLeft(w, l)\n                            || pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\ntemplate<class T>\nstd::vector<Point<T>> hp(std::vector<Line<T>> lines) {\n    std::sort(lines.begin(), lines.end(), [&](auto l1, auto l2) {\n        auto d1 = l1.b - l1.a;\n        auto d2 = l2.b - l2.a;\n        \n        if (sgn(d1) != sgn(d2)) {\n            return sgn(d1) == 1;\n        }\n        \n        return cross(d1, d2) > 0;\n    });\n    \n    std::deque<Line<T>> ls;\n    std::deque<Point<T>> ps;\n    for (auto l : lines) {\n        if (ls.empty()) {\n            ls.push_back(l);\n            continue;\n        }\n        \n        while (!ps.empty() && !pointOnLineLeft(ps.back(), l)) {\n            ps.pop_back();\n            ls.pop_back();\n        }\n        \n        while (!ps.empty() && !pointOnLineLeft(ps[0], l)) {\n            ps.pop_front();\n            ls.pop_front();\n        }\n        \n        if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {\n            if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {\n                \n                if (!pointOnLineLeft(ls.back().a, l)) {\n                    assert(ls.size() == 1);\n                    ls[0] = l;\n                }\n                continue;\n            }\n            return {};\n        }\n        \n        ps.push_back(lineIntersection(ls.back(), l));\n        ls.push_back(l);\n    }\n    \n    while (!ps.empty() && !pointOnLineLeft(ps.back(), ls[0])) {\n        ps.pop_back();\n        ls.pop_back();\n    }\n    if (ls.size() <= 2) {\n        return {};\n    }\n    ps.push_back(lineIntersection(ls[0], ls.back()));\n    \n    return std::vector(ps.begin(), ps.end());\n}\n\nusing P = Point<i64>;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    n *= 2;\n    \n    std::vector<P> a;\n    std::vector<int> b;\n    a.reserve(n);\n    b.reserve(n);\n    std::map<std::array<int, 2>, int> ind;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        char p;\n        std::cin >> p;\n        int val = p == \'(\' ? 1 : -1;\n        if (ind.count({x, y})) {\n            b[ind[{x, y}]] += val;\n        } else {\n            ind[{x, y}] = a.size();\n            a.push_back({x, y});\n            b.push_back(val);\n        }\n    }\n    n = a.size();\n    \n    std::vector<int> p(n), invp(n);\n    std::vector<int> s(n + 1);\n    std::iota(p.begin(), p.end(), 0);\n    std::sort(p.begin(), p.end(),\n        [&](int i, int j) {\n            return a[i].x < a[j].x || (a[i].x == a[j].x && a[i].y < a[j].y);\n        });\n    int bad = 0;\n    for (int i = 0; i < n; i++) {\n        invp[p[i]] = i;\n        s[i + 1] = s[i] + b[p[i]];\n        bad += (s[i + 1] < 0);\n    }\n    if (bad == 0) {\n        std::cout << ""YES\\n"";\n        return;\n    }\n    \n    std::vector<std::tuple<P, int, int>> e;\n    e.reserve(n * (n - 1) / 2);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i].x < a[j].x && a[i].y > a[j].y) {\n                P v = rotate(a[j] - a[i]);\n                e.push_back({v, i, j});\n            }\n        }\n    }\n    std::sort(e.begin(), e.end(),\n        [&](auto a, auto b) {\n            return cross(std::get<0>(a), std::get<0>(b)) > 0;\n        });\n    int E = e.size();\n    for (int l = 0, r = 0; l < E; l = r) {\n        while (r < E && cross(std::get<0>(e[l]), std::get<0>(e[r])) == 0) {\n            r++;\n        }\n        std::vector<std::array<int, 2>> seg;\n        seg.reserve(r - l);\n        for (int i = l; i < r; i++) {\n            auto [_, x, y] = e[i];\n            seg.push_back({invp[x], invp[y]});\n        }\n        std::sort(seg.begin(), seg.end());\n        auto tmp = std::move(seg);\n        for (auto [l, r] : tmp) {\n            if (!seg.empty() && l <= seg.back()[1]) {\n                seg.back()[1] = std::max(seg.back()[1], r);\n            } else {\n                seg.push_back({l, r});\n            }\n        }\n        for (auto [l, r] : seg) {\n            for (int i = l + 1; i <= r; i++) {\n                bad -= (s[i] < 0);\n            }\n        }\n        if (bad == 0) {\n            std::cout << ""YES\\n"";\n            return;\n        }\n        for (auto [l, r] : seg) {\n            std::reverse(p.begin() + l, p.begin() + r + 1);\n            for (int i = l; i <= r; i++) {\n                invp[p[i]] = i;\n                s[i + 1] = s[i] + b[p[i]];\n            }\n            for (int i = l + 1; i <= r; i++) {\n                bad += (s[i] < 0);\n            }\n        }\n    }\n    std::cout << ""NO\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2900
Once little Vasya read an article in a magazine on how to make beautiful handmade garland from colored paper Vasya immediately went to the store and bought colored sheets of paper the area of each sheet is 1 square meter The garland must consist of exactly pieces of colored paper of arbitrary area each piece should be of a certain color To make the garland Vasya can arbitrarily cut his existing colored sheets into pieces Vasya is not obliged to use all the sheets to make the garland Vasya wants the garland to be as attractive as possible so he wants to maximize the total area of pieces of paper in the garland Calculate what the maximum total area of the pieces of paper in the garland Vasya can get ,"[""#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <unordered_set>\n#include <stdio.h>\n#include <string.h>\n#include <unordered_map>\nusing namespace std;\n\n#define MOD 10e9+7\n\nint c1[256];\nint c2[256];\n\nint main(){\n    string s1;\n    cin>>s1;\n    for(int i=0; i<s1.size(); i++)\n        c1[s1[i]]++;\n    string s2;\n    cin>>s2;\n    for(int i=0; i<s2.size(); i++)\n        c2[s2[i]]++;\n    int s=0;\n    for(char i='a'; i<='z'; i++){\n        if(c2[i]!=0&&c1[i]==0){\n            cout<<-1<<endl;\n            return 0;\n        }\n        s+=min(c1[i],c2[i]);\n    }\n    cout<<s<<endl;\n    return 0;\n}\n""]","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Little Petya very much likes strings Recently he has received a voucher to purchase a string as a gift from his mother The string can be bought in the local shop One can consider that the shop has all sorts of strings over the alphabet of fixed size The size of the alphabet is equal to However the voucher has a string type limitation specifically the voucher can be used to purchase string if the length of string s longest substring that is also its weak subsequence see the definition given below equals String with the length of is considered the weak subsequence of the string with the length of if there exists such a set of indexes that has the following two properties for all from to there exists at least one such for which Petya got interested how many different strings are available for him to purchase in the shop As the number of strings can be very large please find it modulo If there are infinitely many such strings print 1 ,"['#include <cstdio>\n#include <numeric>\n#include <iostream>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <string>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <bitset>\n#include <queue>\n#include <sstream>\n#include <deque>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define re return\n#define fi first\n#define se second\n#define sz(x) ((int) (x).size())\n#define all(x) (x).begin(), (x).end()\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(abs(x))\n#define y0 y3487465\n#define y1 y8687969\n#define fill(x,y) memset(x,y,sizeof(x))\n                         \ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long double ld;\ntypedef double D;\ntypedef pair<int, int> ii;\ntypedef vector<ii> vii;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\n\ntemplate<class T> T abs(T x) { re x > 0 ? x : -x; }\n\nconst int mod = 1000000000 + 7;\n\nint n;\nint m, w;\n\nint power (int a, int b) {\n    int c = 1;\n    while (b) {\n        if (b & 1) c = ((ll)c * a) % mod;\n        b /= 2;\n        a = ((ll)a * a) % mod;\n    }\n    re c;\n}\n\nint f[1000001], rf[1000001];\n\nint main () {\n    scanf (""%d%d"", &n, &w);\n    f[0] = rf[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        f[i] = ((ll)f[i - 1] * i) % mod;\n        rf[i] = power (f[i], mod - 2);\n    }\n    int ans = 0, cur = 1;\n    for (int i = 1; i <= n; i++) {\n        cur = ((ll)cur * (n - i + 1)) % mod;\n        if (i + 2 <= w) {\n            int all = ((ll)cur * n) % mod;\n            all = ((ll)all * all) % mod;\n            int tmp = f[n];\n            if (n - i - 1 >= 0) tmp = ((ll)tmp * rf[n - i - 1]) % mod; else tmp = 0;\n            tmp = ((ll)tmp * tmp) % mod;\n            tmp = (all - tmp + mod) % mod;\n            tmp = ((ll)tmp * power (n, w - i - 2)) % mod;\n            ans = ((ll)ans + tmp) % mod;\n        } else\n        if (i + 1 == w) {\n            int all = ((ll)cur * cur) % mod;\n            all = ((ll)all * n) % mod;\n            int tmp = ((ll)f[n - 1]) % mod;\n            if (n - i - 1 >= 0) tmp = ((ll)tmp * rf[n - i - 1]) % mod; else tmp = 0;\n            tmp = ((ll)tmp * tmp) % mod;\n            tmp = ((ll)tmp * n) % mod;\n            ans = ((ll)ans + all - tmp + mod) % mod;\n        } else {\n            int k = i - w;\n            int all = ((ll)f[n] * rf[n - i]) % mod;\n            all = ((ll)all * f[n - k]) % mod;\n            all = ((ll)all * rf[n - i]) % mod;\n            int tmp = ((ll)f[n] * rf[n - i]) % mod;\n            tmp = ((ll)tmp * (n - i)) % mod;\n            tmp = ((ll)tmp * f[n - (k + 2)]) % mod;\n            if (n - i - 1 >= 0) tmp = ((ll)tmp * rf[n - i - 1]) % mod; else tmp = 0;\n            ans = ((ll)ans + all - tmp + mod) % mod;\n        }\n    }\n    printf (""%d\\n"", ans);\n    return 0;\n}']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",3000
You have a knapsack with the capacity of W There are also n items the i th one has weight w i You want to put some of these items into the knapsack in such a way that their total weight C is at least half of its size but obviously does not exceed it Formally C should satisfy lceil frac W 2 rceil le C le W Output the list of items you will put into the knapsack or determine that fulfilling the conditions is impossible If there are several possible lists of items satisfying the conditions you can output any Note that you have to maximize the sum of weights of items in the knapsack ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nll a[N];\nll W;\n\nvoid solve() {\n\tscanf(""%d%lld"", &n, &W);\n\tvector<int> ans;\n\tll S = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tll x;\n\t\tscanf(""%lld"", &x);\n\t\tif (x > W) continue;\n\t\tif (2 * x >= W) {\n\t\t\tans.clear();\n\t\t\tans = {i + 1};\n\t\t\tS = x;\n\t\t} else if (S + x <= W) {\n\t\t\tS += x;\n\t\t\tans.push_back(i + 1);\n\t\t}\n\t}\n\tif (2 * S < W)\n\t\tprintf(""-1\\n"");\n\telse {\n\t\tprintf(""%d\\n"", (int)ans.size());\n\t\tfor (int x : ans)\n\t\t\tprintf(""%d "", x);\n\t\tprintf(""\\n"");\n\t}\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1300
You are given n words each of which consists of lowercase alphabet letters Each word one vowel You are going to choose some of the given words and make as many beautiful lyrics as possible Each consists of two lines Each consists of two words separated by whitespace A lyric is if and only if it satisfies all conditions below The number of vowels in the first word of the first line is the same as the number of vowels in the first word of the second line The number of vowels in the second word of the first line is the same as the number of vowels in the second word of the second line The last vowel of the first line is the same as the last vowel of the second line Note that there may be consonants after the vowel Also letters and are vowels Note that is vowel For example of a beautiful lyric is a beautiful lyric because there are two vowels each in and four vowels each in and keep in mind that is not a vowel and the last vowel of each line is For example of a not beautiful lyric is not a beautiful lyric because and don t have same number of vowels and the last vowels of two lines are different in the first and in the second How many beautiful lyrics can you write from given words Note that you cannot use a word more times than it is given to you For example if a word is given three times you can use it at most three times ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntypedef map<int,int> mii;\n#define itr iterator\nchar _s[2222222],*s[1111111];\nint v[333];\nstruct P{int i,tl,cc,used;}op[111111];\nint cop;\ninline bool operator<(const P&a,const P&b)\n{\n\tif(a.used>b.used)return 1;\n\tif(a.used<b.used)return 0;\n\tif(a.cc<b.cc)return 1;\n\tif(a.cc>b.cc)return 0;\n\treturn a.tl<b.tl;\n}\nint main()\n{\n\tint n;\n\tscanf(""%d"",&n);\n\tv[\'a\']=1;\n\tv[\'e\']=2;\n\tv[\'i\']=3;\n\tv[\'o\']=4;\n\tv[\'u\']=5;\n\ts[1]=_s;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(""%s"",s[i]);\n\t\tint m=strlen(s[i]);\n\t\ts[i+1]=s[i]+m+3;\n\t\tint cc=0,tl=0;\n\t\tfor(int j=0;j<m;++j)\n\t\t{\n\t\t\tif(v[s[i][j]])\n\t\t\t{\n\t\t\t\t++cc;\n\t\t\t\ttl=v[s[i][j]];\n\t\t\t}\n\t\t}\n\t\top[cop++]=(P){i,tl,cc,0};\n\t}\n\tsort(op,op+cop);\n\tint cp=0;\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tif(op[i].cc==op[i+1].cc&&op[i].tl==op[i+1].tl&&!op[i].used)\n\t\t{\n\t\t\top[i].used=2;\n\t\t\top[i+1].used=2;\n\t\t\t++cp;\n\t\t}\n\t}\n\tint res=cp;\n\tsort(op,op+cop);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tif(op[i].cc==op[i+1].cc&&!op[i].used&&!op[i+1].used)\n\t\t{\n\t\t\top[i].used=1;\n\t\t\top[i+1].used=1;\n\t\t\t++cp;\n\t\t}\n\t}\n\tsort(op,op+cop);\n\tif(cp/2<res)res=cp/2;\n\tprintf(""%d\\n"",res);\n\tfor(int i=0,j=0;j<res;i+=2,++j)\n\t{\n\t\tprintf(""%s %s\\n%s %s\\n"",s[op[cp*2-i-1].i],s[op[i].i],s[op[cp*2-i-2].i],s[op[i+1].i]);\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1700
The mobile application store has a new game called Subway Roller The protagonist of the game Philip is located in one end of the tunnel and wants to get out of the other one The tunnel is a rectangular field consisting of three rows and columns At the beginning of the game the hero is in some cell of the leftmost column Some number of trains rides towards the hero Each train consists of two or more neighbouring cells in some row of the field All trains are moving from right to left at a speed of two cells per second and the hero runs from left to right at the speed of one cell per second For simplicity the game is implemented so that the hero and the trains move in turns First the hero moves one cell to the right then one square up or down or stays idle Then all the trains move twice simultaneously one cell to the left Thus in one move Philip definitely makes a move to the right and can move up or down If at any point Philip is in the same cell with a train he loses If the train reaches the left column it continues to move as before leaving the tunnel Your task is to answer the question whether there is a sequence of movements of Philip such that he would be able to get to the rightmost column ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int N = 111;\nint n;\nchar t[3][N];\nbool dp[N][3];\nbool g[N][3][N];\n\nvoid read()\n{\n    int z;\n    scanf(""%d%d"", &n, &z);\n    for (int i = 0; i < 3; i++)\n        scanf("" %s "", t[i]);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < n; j++)\n            dp[j][i] = false;\n    for (int i = 0; i < 3; i++)\n        if (t[i][0] == \'s\')\n        {\n            dp[0][i] = true;\n            t[i][0] = \'.\';\n        }\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < n; j++)\n            g[0][i][j] = (t[i][j] == \'.\');\n    for (int i = 1; i < n; i++)\n        for (int x = 0; x < 3; x++)\n            for (int y = 0; y < n; y++)\n            {\n                int ny = y + 2 * i;\n                g[i][x][y] = ny >= n || g[0][x][ny];\n            }\n    for (int i = 0; i < n - 1; i++)\n        for (int x = 0; x < 3; x++)\n        {\n            if (!dp[i][x]) continue;\n            if (!g[i][x][i + 1]) continue;\n            for (int nx = x - 1; nx <= x + 1; nx++)\n            {\n                if (nx < 0 || nx >= 3) continue;\n                if (!g[i][nx][i + 1]) continue;\n                if (!g[i + 1][nx][i + 1]) continue;\n                dp[i + 1][nx] = true;\n            }\n        }\n    bool ans = false;\n    for (int i = 0; i < 3; i++)\n        ans |= dp[n - 1][i];\n    if (ans)\n        printf(""YES\\n"");\n    else\n        printf(""NO\\n"");\n    return;\n}\n\nvoid solve()\n{\n    read();\n}\n\nint main()\n{\n    int t;\n    scanf(""%d"", &t);\n    while(t--)\n        solve();\n\n    return 0;\n}']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1700
Nauuo is a girl who loves traveling One day she went to a tree Old Driver Tree literally a tree with an old driver on it The tree is a connected graph consisting of n nodes and n 1 edges Each node has a color and Nauuo will visit the ODT through a simple path on the tree in the old driver s car Nauuo wants to visit see more different colors in her journey but she doesn t know which simple path she will be traveling on So she wants to calculate the sum of the numbers of different colors on all different paths Can you help her What s more the ODT is being redecorated so there will be m modifications each modification will change a single node s color Nauuo wants to know the answer after each modification too Note that in this problem we consider the simple path from u to v and the simple path from v to u as two different simple paths if and only if u ne v ,"['#ifndef LOCAL\n#pragma GCC optimize (""-Ofast"")\n#pragma GCC optimize (""-unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n//fast IO by yosupo\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = \'\\0\';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();            \n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == \'-\') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - \'0\');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(vector<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(\' \');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single(\'\\n\');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single(\'0\');\n            return;\n        }\n        if (val < 0) {\n            write_single(\'-\');\n            val = -val;  // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(\'0\' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const vector<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(\' \');\n            write_single(val[i]);\n        }\n    }\n};\n\nScanner sc(stdin);\nPrinter pr(stdout);\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//内部でグラフをいじるから in,out を使うときは注意\n//hei[v] -> heavy edge で潜っていった時，自分含めて何個あるか\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep,hei,ni;\n\tvc<E> pe;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tfor(auto itr=g[v].bg;itr!=g[v].ed;itr++)\n\t\t\tif(*itr==p){\n\t\t\t\tpe[v]=*itr;\n\t\t\t\tg[v].erase(itr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(auto&e:g[v]){\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t\tif(si(g[v]))hei[v]=hei[g[v][0]]+1;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n),hei(n,1),ni(n),\n\t\tpe(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t\trep(i,n)ni[in[i]]=i;\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\t//XX Opencup GP of Korea\n\t//CF625 F\n\t//2020 Multi-Uni Contest Day5 G\n\t//CF415E\n\tvi index;\n\t//vs を含む virtual tree を返す\n\t//返すのは virtual tree に使われた頂点と，辺の集合\n\t//辺の端点は，virtual tree における番号\n\t//元の木における番号を virtual tree の頂点番号に写すのが，index という変数\n\t//辺は ch->par の順\n\t//virtual tree は行き掛け順で番号がついている\n\t//特に，頂点 0 が根になるようにできている\n\tpair<vi,vc<pi>> tree_compress(vi vs){\n\t\tif(si(index)==0)index.resize(n);\n\t\tassert(index.size());\n\t\tauto comp = [&](int x,int y){\n\t\t\treturn in[x] < in[y];\n\t\t};\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tint k = vs.size();\n\t\trep(i,k-1){\n\t\t\tvs.pb(lca(vs[i],vs[i+1]));\n\t\t}\n\t\tsort(all(vs),comp);\n\t\tvs.erase(unique(all(vs)),vs.ed);\n\t\tk = vs.size();\n\t\trep(i,k) index[vs[i]] = i;\n\t\tvc<pi> es;\n\t\trng(i,1,k){\n\t\t\tint p = lca(vs[i-1],vs[i]);\n\t\t\tes.eb(i,index[p]);\n\t\t}\n\t\treturn mp(vs,es);\n\t}\n};\n\n//Ofast,unroll-loops でちょい速くなる\n\n//update toptree\n//spaceships\n//do_use_segment_tree\n//CF679D\n\n//splay tree の左側が根の方のノードに対応している\n//頂点と辺がそれぞれノードを持つ\n//light edge だけ特別扱いしている\n//それ以外のやつは，普通の頂点倍加 LCT のような感じ (c[0],c[1])\n//頂点由来のノードであれば，c[2] に light edges の情報が入る\n//light edge の部分のやつは，light edge 内の splay tree をつくる (c[0],c[2])\n//ただし c[1] にはぶら下がるパス部分の情報が入る\ntemplate<class N>\nstruct toptree{\n\tstruct node{\n\t\t//t==0 vertex\n\t\t//t==1 path edge\n\t\t//t==2 light edge\n\t\tN d;\n\t\tbool rev;\n\t\tint c[3],p;\n\t\tnode(char tt=-1):rev(false),c{-1,-1,-1},p(-1){d.t=tt;}\n\t\tvoid show(){\n\t\t\tcerr<<int(d.t)<<"" ""<<""(""<<c[0]<<"",""<<c[1]<<"",""<<c[2]<<"") ""<<p<<endl;\n\t\t}\n\t};\n\tusing np=node*;\n\tint n;\n\tvc<node> x;\n\t//unused に入ってるノードの情報は clean とは限らない\n\tvi unused;\n\ttoptree(int nn):n(nn),x(n*2-1){\n\t\tgnr(i,n,n*2-1)unused.pb(i);\n\t}\n\t//reverse が呼ばれるのは path node のみ\n\t//light edge なら rev は常に false\n\tinline void reverse(int v){\n\t\tassert(v!=-1);\n\t\tassert(x[v].d.t<2);\n\t\tx[v].rev^=1;\n\t\tx[v].d.reverse();\n\t\tswap(x[v].c[0],x[v].c[1]);\n\t}\n\t//v は valid\n\t//link は張り替えるが update はしない\n\tinline void set_child(int v,int k,int c){\n\t\tassert(v!=-1);\n\t\tassert(inc(0,k,2));\n\t\tx[v].c[k]=c;\n\t\tif(c!=-1)x[c].p=v;\n\t}\n\tinline void set_light_left(int v,int c){set_child(v,0,c);}\n\tinline void set_light_right(int v,int c){set_child(v,2,c);}\n\tinline void set_path_left(int v,int c){set_child(v,0,c);}\n\tinline void set_path_right(int v,int c){set_child(v,1,c);}\n\t//v,c は valid\n\t//link は張り替えるが update はしない\n\tinline void insert_light(int v,int c){\n\t\tassert(v!=-1);\n\t\tassert(x[v].d.t==0);\n\t\tassert(c!=-1);\n\t\tassert(x[c].d.t==2);\n\t\tset_light_right(c,x[v].c[2]);\n\t\tx[v].c[2]=c;\n\t\tx[c].p=v;\n\t}\n\tinline void make_path_vertex(int v){assert(inc(0,v,n-1));x[v].d.t=0;}\n\tinline void make_path_edge(int v){assert(inc(n,v,n*2-2));x[v].d.t=1;}\n\tinline void make_light(int v){assert(inc(n,v,n*2-2));assert(!x[v].rev);x[v].d.t=2;}\n\tvoid update(int v){\n\t\tassert(v!=-1);\n\t\tassert(!x[v].rev);\n\t\tx[v].d.single();\n\t\tif(x[v].d.t<2){\n\t\t\tif(x[v].c[2]!=-1)x[v].d.update_light(x[x[v].c[2]].d);\n\t\t\trep(k,2)if(x[v].c[k]!=-1)x[v].d.update_path(k,x[x[v].c[k]].d);\n\t\t}else if(x[v].d.t==2){\n\t\t\tassert(x[v].c[1]!=-1);\n\t\t\tx[v].d.update_path(1,x[x[v].c[1]].d);\n\t\t\tfor(int k=0;k<3;k+=2)if(x[v].c[k]!=-1)x[v].d.update_light(x[x[v].c[k]].d);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t}\n\tvoid downdate(int v){\n\t\tassert(v!=-1);\n\t\tif(x[v].d.t<2){\n\t\t\tif(x[v].rev){\n\t\t\t\tx[v].rev=false;\n\t\t\t\trep(k,2)if(x[v].c[k]!=-1)reverse(x[v].c[k]);\n\t\t\t}\n\t\t\tif(x[v].c[2]!=-1)x[v].d.push_light(x[x[v].c[2]].d);\n\t\t\trep(k,2)if(x[v].c[k]!=-1)x[v].d.push_path(k,x[x[v].c[k]].d);\n\t\t}else if(x[v].d.t==2){\n\t\t\tassert(!x[v].rev);\n\t\t\tassert(x[v].c[1]!=-1);\n\t\t\tx[v].d.push_path(1,x[x[v].c[1]].d);\n\t\t\tfor(int k=0;k<3;k+=2)if(x[v].c[k]!=-1)x[v].d.push_light(x[x[v].c[k]].d);\n\t\t}else{\n\t\t\tassert(false);\n\t\t}\n\t\tx[v].d.clear_lazy();\n\t}\n\t//0,z の辺を使って rotate\n\tvoid rotate(int v,int z){\n\t\tassert(v!=-1);\n\t\tint p=x[v].p,c;\n\t\tassert(p!=-1);\n\t\tif(x[p].c[0]==v){\n\t\t\tc=x[v].c[z];\n\t\t\tx[v].c[z]=p;\n\t\t\tx[p].c[0]=c;\n\t\t}else{\n\t\t\tc=x[v].c[0];\n\t\t\tx[v].c[0]=p;\n\t\t\tx[p].c[z]=c;\n\t\t}\n\t\tif(c!=-1)x[c].p=p;\n\t\tx[v].p=x[p].p;\n\t\tx[p].p=v;\n\t\tif(x[v].p!=-1){\n\t\t\trep(k,3)if(x[x[v].p].c[k]==p)\n\t\t\t\tx[x[v].p].c[k]=v;\n\t\t}\n\t\tupdate(p);\n\t\t//cerr<<""After Rotate ""<<v<<endl;\n\t\t//show();\n\t}\n\t//void rotate_path(int v){rotate(v,1);}\n\t//void rotate_light(int v){rotate(v,2);}\n\t//親を辿れるだけたどり，downdate する\n\t//このあと何らかの操作で頂点 v を上に持ってこないと，計算量が崩壊する\n\tvoid prepare(int v){\n\t\tassert(v!=-1);\n\t\tif(x[v].p!=-1)prepare(x[v].p);\n\t\tdowndate(v);\n\t}\n\t//prepare されていることが前提\n\t//path/light 内で回せるだけ回す\n\t//違う種類の親との間のリンクに注意しようね\n\tvoid splay(int v){\n\t\tassert(v!=-1);\n\t\tint z=x[v].d.t<2?1:2;\n\t\twhile(1){\n\t\t\tint p=x[v].p;\n\t\t\tif(p==-1||(x[p].d.t<2)^(x[v].d.t<2))break;\n\t\t\tint q=x[p].p;\n\t\t\tif(q==-1||(x[q].d.t<2)^(x[v].d.t<2)){\n\t\t\t\trotate(v,z);\n\t\t\t}else{\n\t\t\t\tif((x[p].c[0]==v&&x[q].c[0]==p)||(x[p].c[z]==v&&x[q].c[z]==p))\n\t\t\t\t\trotate(p,z);\n\t\t\t\telse\n\t\t\t\t\trotate(v,z);\n\t\t\t\trotate(v,z);\n\t\t\t}\n\t\t}\n\t\tupdate(v);\n\t}\n\tint go_deep(int v,int k){\n\t\tassert(v!=-1);\n\t\twhile(1){\n\t\t\tdowndate(v);\n\t\t\tif(x[v].c[k]!=-1)v=x[v].c[k];\n\t\t\telse return v;\n\t\t}\n\t\tassert(false);\n\t}\n\tvoid expose(int v){\n\t\tassert(v!=-1);\n\t\tprepare(v);\n\t\tfor(int a=v;a!=-1;a=x[a].p)\n\t\t\tsplay(a);\n\t\tfor(int a=v;a!=-1;a=x[a].p){\n\t\t\tif(x[a].d.t==2){\n\t\t\t\tint b=x[a].p;\n\t\t\t\tassert(b!=-1);\n\t\t\t\tif(x[b].c[1]==-1){\n\t\t\t\t\tint l=x[a].c[0],r=x[a].c[2];\n\t\t\t\t\tif(l!=-1){\n\t\t\t\t\t\tx[l].p=-1;\n\t\t\t\t\t\tl=go_deep(l,2);\n\t\t\t\t\t\tsplay(l);\n\t\t\t\t\t\tset_light_right(l,r);\n\t\t\t\t\t\tupdate(l);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tl=r;\n\t\t\t\t\t}\n\t\t\t\t\tset_light_right(b,l);\n\t\t\t\t}else{\n\t\t\t\t\tint c=x[b].c[1];\n\t\t\t\t\tx[c].p=-1;\n\t\t\t\t\tc=go_deep(c,0);\n\t\t\t\t\tsplay(c);\n\t\t\t\t\tassert(!x[c].rev);\n\t\t\t\t\tmake_light(c);\n\t\t\t\t\tset_light_left(c,x[a].c[0]);\n\t\t\t\t\tset_light_right(c,x[a].c[2]);\n\t\t\t\t\tset_light_right(b,c);\n\t\t\t\t\t//b,c は子ノードの情報を反映していない\n\t\t\t\t\tupdate(c);\n\t\t\t\t\t//c は子ノードの情報を反映した\n\t\t\t\t}\n\t\t\t\tx[a].c[0]=x[a].c[2]=-1;\n\t\t\t\tmake_path_edge(a);\n\t\t\t\tset_path_right(b,a);\n\t\t\t}\n\t\t}\n\t\t//cerr<<""Before Splay ""<<v<<endl;\n\t\t//show();\n\t\tsplay(v);\n\t\t//cerr<<""After Expose ""<<v<<endl;\n\t\t//show();\n\t}\n\ttemplate<class...Args>\n\tvoid init_vertex(int v,Args&&...args){\n\t\tassert(inc(0,v,n-1));\n\t\tx[v]=node(0);\n\t\tx[v].d.init_vertex(v,forward<Args>(args)...);\n\t}\n\ttemplate<class...Args>\n\tvoid init_edge(int v,char t,int a,int b,Args&&...args){\n\t\tx[v]=node(t);\n\t\tx[v].d.init_edge(a,b,forward<Args>(args)...);\n\t}\n\tvoid evert(int v){\n\t\tassert(inc(0,v,n-1));\n\t\texpose(v);\n\t\tif(x[v].c[0]!=-1){\n\t\t\tint c=x[v].c[0];\n\t\t\tx[v].c[0]=-1;\n\t\t\tx[c].p=-1;\n\t\t\tc=go_deep(c,1);\n\t\t\tsplay(c);\n\t\t\treverse(c);\n\t\t\tassert(x[c].rev);\n\t\t\tx[c].rev=false;\n\t\t\treverse(x[c].c[1]);\n\t\t\tmake_light(c);\n\t\t\tinsert_light(v,c);\n\t\t\t//v,c は子ノードの情報を反映していない\n\t\t\tupdate(c);\n\t\t\tupdate(v);\n\t\t\t//v,c は子ノードの情報を反映した\n\t\t}\n\t}\n\t//a と b を辺で結び (a が親側)，辺の index を返す\n\t//もしもともと連結であれば，-1 を返す\n\ttemplate<class...Args>\n\tint link(int a,int b,Args&&...args){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\texpose(a);\n\t\tevert(b);\n\t\tif(x[a].p==-1){\n\t\t\tassert(si(unused));\n\t\t\tint e=unused.back();unused.pop_back();\n\t\t\tinit_edge(e,2,a,b,forward<Args>(args)...);\n\t\t\tset_path_right(e,b);\n\t\t\tinsert_light(a,e);\n\t\t\t//a,e は子ノードの情報を反映していない\n\t\t\tupdate(e);\n\t\t\tupdate(a);\n\t\t\t//a,e は子ノードの情報を反映した\n\t\t\treturn e;\n\t\t}else{\n\t\t\treturn -1;\n\t\t}\n\t}\n\t//cut したあとの木のノードのペア(親，子)を返す\n\tpi cut(int e){\n\t\tassert(inc(n,e,n*2-2));\n\t\texpose(e);\n\t\tpi res(x[e].c[0],x[e].c[1]);\n\t\tif(res.a!=-1)x[res.a].p=-1;\n\t\tif(res.b!=-1)x[res.b].p=-1;\n\t\tx[e].d.t=-1;\n\t\tunused.pb(e);\n\t\treturn res;\n\t}\n\tint lca(int a,int b){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\texpose(a);\n\t\texpose(b);\n\t\tif(x[a].p==-1)return -1;\n\t\tint d=a;\n\t\twhile(a!=b){\n\t\t\tint p=x[a].p;\n\t\t\tif(x[a].d.t==2&&x[p].d.t<2)d=p;\n\t\t\telse if(p==b&&x[p].c[1]==a)d=b;\n\t\t\ta=p;\n\t\t}\n\t\tassert(inc(0,d,n-1));\n\t\treturn d;\n\t}\n\tvoid expose_path(int a,int b){\n\t\tassert(inc(0,a,n-1));\n\t\tassert(inc(0,b,n-1));\n\t\tevert(a);\n\t\texpose(b);\n\t\tint c=x[b].c[1];\n\t\tif(c!=-1){\n\t\t\tx[b].c[1]=-1;\n\t\t\tx[c].p=-1;\n\t\t\tc=go_deep(c,0);\n\t\t\tsplay(c);\n\t\t\tassert(!x[c].rev);\n\t\t\tmake_light(c);\n\t\t\tinsert_light(b,c);\n\t\t\tupdate(c);\n\t\t\tupdate(b);\n\t\t}\n\t}\n\tN&operator[](int i){return x[i].d;}\n\tvoid show(){\n\t\trep(i,n*2-1)if(x[i].d.t!=-1){\n\t\t\tcerr<<i<<"" "";\n\t\t\tx[i].show();\n\t\t}\n\t}\n\t//init_vertex は終了しているとする\n\t//E.idx が必要．これに従って辺に id を振る\n\ttemplate<class H> void init_from_hld(const H&hld){\n\t\tunused.clear();\n\t\tauto subtree=[&](auto subtree_self,int root)->int{\n\t\t\tauto path=[&](auto path_self,int l,int r)->int{\n\t\t\t\tif(r<l)return -1;\n\t\t\t\tconst int m=(l+r)/2;\n\t\t\t\tint v=hld.ni[(m+1)/2],z;\n\t\t\t\tif(m%2==0){\n\t\t\t\t\tz=v;\n\t\t\t\t\tauto light=[&](auto light_self,int a,int b)->int{\n\t\t\t\t\t\tif(b<a)return -1;\n\t\t\t\t\t\tconst int c=(a+b)/2;\n\t\t\t\t\t\tint u=hld.g[v][c],w=hld.pe[u].idx+n;\n\t\t\t\t\t\tinit_edge(w,2,v,u,hld.pe[u]);\n\t\t\t\t\t\tset_path_right(w,subtree_self(subtree_self,u));\n\t\t\t\t\t\tset_light_left(w,light_self(light_self,a,c-1));\n\t\t\t\t\t\tset_light_right(w,light_self(light_self,c+1,b));\n\t\t\t\t\t\tupdate(w);\n\t\t\t\t\t\treturn w;\n\t\t\t\t\t};\n\t\t\t\t\tset_light_right(z,light(light,1,si(hld.g[v])-1));\n\t\t\t\t}else{\n\t\t\t\t\tz=hld.pe[v].idx+n;\n\t\t\t\t\tinit_edge(z,1,hld.par[v],v,hld.pe[v]);\n\t\t\t\t}\n\t\t\t\tset_path_left(z,path_self(path_self,l,m-1));\n\t\t\t\tset_path_right(z,path_self(path_self,m+1,r));\n\t\t\t\tupdate(z);\n\t\t\t\treturn z;\n\t\t\t};\n\t\t\treturn path(path,hld.in[root]*2,(hld.in[root]+hld.hei[root]-1)*2);\n\t\t};\n\t\tsubtree(subtree,hld.rt);\n\t}\n};\n\n\nstruct E{\n\tint to,idx;\n\toperator int()const{return to;}\n};\n//init_from_hld(HLD<E>(t,0)) とかにつかう\n\n//まず rep(i,n)t.init_vertex(i) を最初にやる\n\n//init_vertex(v,...): 頂点に対応するノードを初期化する\n//init_edge(a,b,...): 辺に対応するノードを初期化する，a が親側\n//single(isv): isv=is this a vertex? そのノード単体だけの情報に更新する(部分木の情報を忘れる)\n//reverse(): 反転\n//update_path(k,N): path 上で，(k==0?左:右)に path ノードを追加する\n//=compress\n//update_light: light ツリー上でノードを追加する（原理的に左右の区別がない）\n//=rake\n//これは，頂点単体のノードにその部分木の情報を伝える際にも呼ばれる\n//これで実用上は困らないはずだけど，もしそうでなければ，ごめん\n//push_path(k,N), push_light(N): push する，update と同様\n//clear_lazy(): lazy 系のデータを clear する \n\n//木が固定されている場合\n//ノードのマージされ方が限定され，実装が楽になるケースがある\n//vertex は, light -> path の順でマージしてる\n//light edge は，path -> light の順でマージしてる\n\n//t がノードの状態を表す変数で，絶対必要\n//これをうっかり書き換えるなどのミスが予想される\n\nstruct N{\n\tchar t;\n\tbool own,ok;\n\tint up,lw;\n\tll sum,upsum;\n\t//t==0\n\t//own,ok,up,lw,sum\n\t//t==1\n\t//ok,up,lw,sum\n\t//t==2\n\t//up,sum,upsum\n\tvoid init_vertex(int,bool good){\n\t\town=good;\n\t\tok=good;\n\t\tup=good;\n\t\tlw=good;\n\t\tsum=good;\n\t}\n\tvoid init_edge(int,int){\n\t\tok=true;\n\t\tup=0;\n\t\tlw=0;\n\t\tsum=0;\n\t\tupsum=0;\n\t}\n\tvoid init_edge(int a,int b,const E&){\n\t\tinit_edge(a,b);\n\t}\n\tvoid single(){\n\t\tif(t==0)init_vertex(-1,own);\n\t\telse init_edge(-1,-1);\n\t}\n\tvoid reverse(){\n\t\tassert(false);\n\t}\n\tvoid update_path(int dir,N x){\n\t\tif(t==2){\n\t\t\tup=x.up;\n\t\t\tsum=x.sum;\n\t\t\tupsum=sq<ll>(x.up);\n\t\t\tsum-=upsum;\n\t\t}else{\n\t\t\tN y=*this;\n\t\t\tif(dir)swap(x,y);\n\t\t\tok=x.ok&&y.ok;\n\t\t\tup=x.up;\n\t\t\tif(x.ok)up+=y.up;\n\t\t\tlw=y.lw;\n\t\t\tif(y.ok)lw+=x.lw;\n\t\t\tsum=x.sum+y.sum+ll(x.lw)*y.up*2;\n\t\t}\n\t}\n\tvoid update_light(const N& x){\n\t\tif(t==2){\n\t\t\tup+=x.up;\n\t\t\tsum+=x.sum;\n\t\t\tupsum+=x.upsum;\n\t\t}else{\n\t\t\tassert(t==0);\n\t\t\tif(own){\n\t\t\t\tassert(up==1);\n\t\t\t\tassert(lw==1);\n\t\t\t\tassert(sum==1);\n\t\t\t\tup=lw=x.up+1;\n\t\t\t\tsum=x.sum+sq<ll>(up);\n\t\t\t}else{\n\t\t\t\tsum=x.sum+x.upsum;\n\t\t\t}\n\t\t}\n\t}\n\tvoid push_path(int,N&){}\n\tvoid push_light(N&){}\n\tvoid clear_lazy(){}\n};\n\nvoid slv(){\n\tint n,m;sc.read(n,m);\n\ttoptree<N> t(n);\n\trep(i,n)t.init_vertex(i,true);\n\tvi c(n);\n\trep(i,n){\n\t\tsc.read(c[i]);\n\t\tc[i]--;\n\t}\n\tvvc<pi> qs(n);\n\trep(i,n)qs[c[i]].eb(0,i);\n\tvvc<E> rw(n);\n\trep(i,n-1){\n\t\tint a,b;sc.read(a,b);\n\t\ta--;b--;\n\t\trw[a].pb({b,i});\n\t\trw[b].pb({a,i});\n\t}\n\tt.init_from_hld(HLD<E>(rw,0));\n\trng(i,1,m+1){\n\t\tint v;sc.read(v);\n\t\tv--;\n\t\tqs[c[v]].eb(i,v);\n\t\tsc.read(c[v]);\n\t\tc[v]--;\n\t\tqs[c[v]].eb(i,v);\n\t}\n\tvc<ll> ans(m+1);\n\trep(col,n){\n\t\tll pre=ll(n)*n;\n\t\tfor(auto z:qs[col]){\n\t\t\tint i,v;tie(i,v)=z;\n\t\t\tt.expose(v);\n\t\t\tt[v].own^=1;\n\t\t\tt.update(v);\n\t\t\tll cur=t[v].sum;\n\t\t\tans[i]+=pre-cur;\n\t\t\tpre=cur;\n\t\t}\n\t\tfor(auto z:qs[col]){\n\t\t\tint i,v;tie(i,v)=z;\n\t\t\tt.expose(v);\n\t\t\tt[v].own^=1;\n\t\t}\n\t}\n\trep(i,m)ans[i+1]+=ans[i];\n\trep(i,m+1)pr.writeln(ans[i]);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3300
Eighth grader Vova is on duty today in the class After classes he went into the office to wash the board and found on it the number He asked what is this number and the teacher of mathematics Inna Petrovna answered Vova that is the answer to the arithmetic task for first graders In the textbook a certain was given The task was to add to the sum of the digits of the number written in decimal numeral system Since the number on the board was small Vova quickly guessed which could be in the textbook Now he wants to get a program which will search for arbitrary values of the number for all suitable values of or determine that such does not exist Write such a program for Vova ,"['#include<iostream>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\nint n,x[1000],m;\ninline bool check(int p)\n{\n\tint k=p;\n\twhile(p)\n\t  {\n\t   k+=p%10;\n\t   p/=10;\n\t  }\n\treturn k==n;\n}\nint main()\n{\n\t//freopen("".in"",""r"",stdin);\n\t//freopen("".out"",""w"",stdout);\n\tint i;\n\tscanf(""%d"",&n);\n\tfor(i=n-100;i<=n;i++)\n\t  if(check(i))\n\t    x[++m]=i;\n\tprintf(""%d\\n"",m);\n\tfor(i=1;i<=m;i++)\n\t  printf(""%d\\n"",x[i]);\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Surely you have seen insane videos by South Korean rapper PSY such as Gangnam Style Gentleman and Daddy You might also hear that PSY has been recording video Oppa Funcan Style two years ago unfortunately we couldn t find it on the internet We will remind you what this hit looked like you can find original description here On the ground there are n platforms which are numbered with integers from 1 to n on i th platform there is a dancer with number i Further every second all the dancers standing on the platform with number i jump to the platform with the number f i The moving rule f is selected in advance and is not changed throughout the clip The duration of the clip was k seconds and the rule f was chosen in such a way that after k seconds all dancers were in their initial positions i e the i th dancer stood on the platform with the number i That allowed to loop the clip and collect even more likes PSY knows that enhanced versions of old artworks become more and more popular every day So he decided to release a remastered version of his video In his case enhanced version means even more insanity so the number of platforms can be up to 10 18 But the video director said that if some dancer stays on the same platform all the time then the viewer will get bored and will turn off the video immediately Therefore for all x from 1 to n f x neq x must hold Big part of classic video s success was in that looping so in the remastered version all dancers should return to their initial positions in the end of the clip as well PSY hasn t decided on the exact number of platforms and video duration yet so he asks you to check if there is a good rule f for different options ,"['/**\n *    author:  tourist\n *    created: 29.05.2018 19:27:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long mulmod(long long a, long long b, long long c) {\n  long long sign = 1;\n  if (a < 0) {\n    a = -a;\n    sign = -sign;\n  }\n  if (b < 0) {\n    b = -b;\n    sign = -sign;\n  }\n  a %= c;\n  b %= c;\n  long long res = 0;\n  while (b > 0) {\n    if (b & 1) {\n      res = (res + a) % c;\n    }\n    a = (a + a) % c;\n    b >>= 1;\n  }\n  if (sign == -1) {\n    res = (-res) % c;\n  }\n  return res;\n}\n\ntemplate<typename T>\nT extgcd(T a, T b, T &x, T &y) {\n  if (a == 0) {\n    x = 0;\n    y = 1;\n    return b;\n  }\n  T p = b / a;\n  T g = extgcd(b - p * a, a, y, x);\n  x -= p * y;\n  return g;\n}\n\ntemplate<typename T>\nbool diophantine(T a, T b, T c, T &x, T &y, T &g) {\n  if (a == 0 && b == 0) {\n    if (c == 0) {\n      x = y = g = 0;\n      return true;\n    }\n    return false;\n  }\n  if (a == 0) {\n    if (c % b == 0) {\n      x = 0;\n      y = c / b;\n      g = abs(b);\n      return true;\n    }\n    return false;\n  }\n  if (b == 0) {\n    if (c % a == 0) {\n      x = c / a;\n      y = 0;\n      g = abs(a);\n      return true;\n    }\n    return false;\n  }\n  g = extgcd(a, b, x, y);\n  if (c % g != 0) {\n    return false;\n  }\n  T dx = c / a;\n  c -= dx * a;\n  T dy = c / b;\n  c -= dy * b;\n  x = dx + mulmod(x, c / g, b);\n  y = dy + mulmod(y, c / g, a);\n  g = abs(g);\n  return true;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  const int MAX = (int) (sqrt(1e15) + 1e3);\n  vector<bool> is_prime(MAX, true);\n  for (int i = 2; i * i < MAX; i++) {\n    if (is_prime[i]) {\n      for (int j = i * i; j < MAX; j += i) {\n        is_prime[j] = false;\n      }\n    }\n  }\n  vector<int> primes;\n  for (int i = 2; i < MAX; i++) {\n    if (is_prime[i]) {\n      primes.push_back(i);\n    }\n  }\n  int sz = (int) primes.size();\n  int tt;\n  cin >> tt;\n  vector<long long> ns(tt), ks(tt);\n  map<long long,vector<int>> mapik;\n  vector<int> res(tt, 0);\n  for (int i = 0; i < tt; i++) {\n    cin >> ns[i] >> ks[i];\n    mapik[ks[i]].push_back(i);\n  }\n  for (auto &p : mapik) {\n    long long k = p.first;\n    vector<long long> d;\n    {\n      long long tmp = k;\n      for (int it = 0; it < sz && (long long) primes[it] * primes[it] <= tmp; it++) {\n        if (tmp % primes[it] == 0) {\n          d.push_back(primes[it]);\n          while (tmp % primes[it] == 0) {\n            tmp /= primes[it];\n          }\n        }\n      }\n      if (tmp > 1) {\n        d.push_back(tmp);\n      }\n    }\n    if (d.size() == 0) {\n      continue;\n    }\n    if (d.size() == 1) {\n      for (int i : p.second) {\n        res[i] = (ns[i] % d[0] == 0);\n      }\n      continue;\n    }\n    if (d.size() == 2) {\n      for (int i : p.second) {\n        long long x, y, g;\n        if (diophantine(d[0], d[1], ns[i], x, y, g)) {\n          if (x >= 0 && y < 0) {\n            long long can_subtr = x / d[1];\n            long long need_add = ((-y) + d[0] - 1) / d[0];\n            if (can_subtr >= need_add) {\n              y = 0;\n            }\n          }\n          if (x < 0 && y >= 0) {\n            long long can_subtr = y / d[0];\n            long long need_add = ((-x) + d[1] - 1) / d[1];\n            if (can_subtr >= need_add) {\n              x = 0;\n            }\n          }\n          res[i] = (x >= 0 && y >= 0);\n        }\n      }\n      continue;\n    }\n    const long long inf = (long long) 2e18;\n    vector<long long> dist(d[0], inf);\n    priority_queue<pair<long long, int>, vector<pair<long long, int> >, greater<pair<long long, int> > > s;\n    dist[0] = 0;\n    s.emplace(dist[0], 0);\n    while (!s.empty()) {\n      long long expected = s.top().first;\n      int i = s.top().second;\n      s.pop();\n      if (dist[i] != expected) {\n        continue;\n      }\n      for (int it = 1; it < (int) d.size(); it++) {\n        int to = (int) ((i + d[it]) % d[0]);\n        if (dist[i] + d[it] < dist[to]) {\n          dist[to] = dist[i] + d[it];\n          s.emplace(dist[to], to);\n        }\n      }\n    }\n    for (int i : p.second) {\n      res[i] = (ns[i] >= dist[ns[i] % d[0]]);\n    }\n  }\n  for (int i = 0; i < tt; i++) {\n    cout << (res[i] ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]",3300
You are given two strings x and y both consist only of lowercase Latin letters Let s be the length of string s Let s call a sequence a a merging sequence if it consists of exactly x zeros and exactly y ones in some order A merge z is produced from a sequence a by the following rules if a i 0 then remove a letter from the beginning of x and append it to the end of z if a i 1 then remove a letter from the beginning of y and append it to the end of z Two merging sequences a and b are different if there is some position i such that a i neq b i Let s call a string z if for all i from 2 to z z i 1 neq z i Let s l r for some 1 le l le r le s be a substring of consecutive letters of s starting from position l and ending at position r inclusive Let f l 1 r 1 l 2 r 2 be the number of different merging sequences of x l 1 r 1 and y l 2 r 2 that produce merges Note that only non empty substrings of x and y are considered Calculate sum limits 1 le l 1 le r 1 le x 1 le l 2 le r 2 le y f l 1 r 1 l 2 r 2 Output the answer modulo 998 244 353 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nint N, M;\nchar X[1010];\nchar Y[1010];\n\nll D[1010][1010];\nll E[1010][1010];\n\nint main() {\n\tscanf(""%s"", X + 1);\n\tscanf(""%s"", Y + 1);\n\tN = strlen(X + 1);\n\tM = strlen(Y + 1);\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tD[i][0] = (X[i] == X[i - 1] ? 0 : D[i - 1][0]) + 1;\n\t}\n\tfor(int i = 1; i <= M; i++) {\n\t\tE[0][i] = (Y[i] == Y[i - 1] ? 0 : E[0][i - 1]) + 1;\n\t}\n\n\tll ans = 0;\n\tfor(int i = 1; i <= N; i++) {\n\t\tfor(int j = 1; j <= M; j++) {\n\t\t\tif(X[i] != X[i - 1]) D[i][j] = D[i - 1][j];\n\t\t\tif(X[i] != Y[j]) {\n\t\t\t\tD[i][j] = (D[i][j] + E[i - 1][j]) % MOD;\n\t\t\t\tif(i > 1) D[i][j] = (D[i][j] + E[0][j]) % MOD;\n\t\t\t}\n\t\t\tif(Y[j] != Y[j - 1]) E[i][j] = E[i][j - 1];\n\t\t\tif(X[i] != Y[j]) {\n\t\t\t\tE[i][j] = (E[i][j] + D[i][j - 1]) % MOD;\n\t\t\t\tif(j > 1) E[i][j] = (E[i][j] + D[i][0]) % MOD;\n\t\t\t}\n\t\t\tans = (ans + D[i][j] + E[i][j]) % MOD;\n\t\t}\n\t}\n\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]",2400
The student council is preparing for the relay race at the sports festival The council consists of n members They will run one after the other in the race the speed of member i is s i The d i of the i th stage is the difference between the maximum and the minimum running speed among the first i members who ran Formally if a i denotes the speed of the i th member who participated in the race then d i max a 1 a 2 dots a i min a 1 a 2 dots a i You want to minimize the sum of the discrepancies d 1 d 2 dots d n To do this you are allowed to change the order in which the members run What is the minimum possible sum that can be achieved ,"['#include <ctime>\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx"")\n#pragma warning(disable : 4996)\n#include <algorithm>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <math.h>\n#include <cassert>\n#include <unordered_map>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define len(s) (int)(s).size()\n// #define endl \'\\n\'\n\n\ninline void accell() {\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n}\n\ntemplate<class T> ostream& operator<< (ostream& out, const pair<int, int>&X) {\n    out << X.first << \' \' << X.second << endl;\n    return out;\n}\n\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T> &X) {\n    for (const auto& it : X)\n        out << it << \' \';\n    return out;\n}\ntemplate<class T> ostream& operator<< (ostream& out, const set<T> &X) {\n    for (const auto& it : X)\n        out << it << \' \';\n    return out;\n}\ntemplate<class T> void dbg(const T &X) {\n    cerr << ""DEBUG: "" << "": "";\n    cerr << X << endl;\n}\nconst int mod = 1e9 + 7;\nconst int N = 1e5 + 5;\n\n\nsigned main() {\n    accell();\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) \n        cin >> a[i];\n    sort(a.begin(), a.end());\n    vector<vector<int>>dp(n, vector<int>(n, 1e18));\n    int ans = 1e18;\n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = 0;\n    }\n    for (int len = 0; len < n; ++len) {\n        for (int l = 0; l + len < n; ++l) {\n            int r = l + len;\n            if (r + 1 < n) {\n                dp[l][r + 1] = min(dp[l][r + 1], dp[l][r] + a[r + 1] - a[l]);\n            }\n            if (l) {\n                dp[l - 1][r] = min(dp[l - 1][r], dp[l][r] + a[r] - a[l - 1]);\n            }\n        }\n    }\n    cout << dp[0][n - 1] << endl;\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
You are given a weighted tree undirected connected graph with no cycles loops or multiple edges with n vertices The edge u j v j has weight w j Also each vertex i has its own value a i assigned to it Let s call a path starting in vertex u and ending in vertex v where each edge can appear no more than twice regardless of direction a Vertices can appear in the 2 path multiple times even start and end vertices For some 2 path p profit text Pr p sum limits v in text distinct vertices in p a v sum limits e in text distinct edges in p k e cdot w e where k e is the number of times edge e appears in p That is vertices are counted once but edges are counted the number of times they appear in p You are about to answer m queries Each query is a pair of vertices qu qv For each query find 2 path p from qu to qv with maximal profit text Pr p ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 300300;\nconst long long Q = 2e18;\nconst long long mod = 998244353;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint tim;\nint dip[N];\nint tin[N];\nint tout[N];\nlong long s[N];\nlong long A[N];\nlong long B[N];\nlong long a[N];\nlong long e[N];\nlong long d[N];\nlong long u[N];\nlong long f[N];\nlong long er[N];\nint up[N][20];\nvector < int > v[N];\n\nvoid dfs(int x, int p)\n{\n        tin[x] = ++tim;\n        up[x][0] = p;\n        for(int i = 1; i < 20; i++){\n                up[x][i] = up[up[x][i - 1]][i - 1];\n        }\n        d[x] = a[x];\n        for(int h: v[x]){\n                int y = A[h] ^ B[h] ^ x;\n                if(y == p){\n                        continue;\n                }\n                dip[y] = dip[x] + 1;\n                s[y] = s[x] - e[h];\n                dfs(y, x);\n                d[x] += max(0ll, d[y] - e[h] - e[h]);\n        }\n        for(int h: v[x]){\n                int y = A[h] ^ B[h] ^ x;\n                if(y == p){\n                        continue;\n                }\n                f[y] = d[x] - max(0ll, d[y] - e[h] - e[h]);\n                er[y] = max(0ll, d[y] - e[h] - e[h]);\n        }\n        tout[x] = ++tim;\n}\n\nvoid go(int x, int p)\n{\n        for(int h: v[x]){\n                int y = A[h] ^ B[h] ^ x;\n                if(y == p){\n                        continue;\n                }\n                u[y] = max(0ll, u[x] + f[y] - e[h] - e[h]);\n                f[y] += f[x];\n                go(y, x);\n        }\n}\n\nbool is(int x, int y)\n{\n        return tin[x] <= tin[y] && tout[x] >= tout[y];\n}\n\nint lca(int x, int y)\n{\n        if(is(x, y)){\n             return x;\n        }\n        if(is(y, x)){\n                return y;\n        }\n        for(int i = 19; i >= 0; i--){\n                if(!is(up[x][i], y)){\n                        x = up[x][i];\n                }\n        }\n        return up[x][0];\n}\n\nint go_up(int x, int g)\n{\n        for(int i = 19; i >= 0; i--){\n                if(g >= (1 << i)){\n                        g -= (1 << i);\n                        x = up[x][i];\n                }\n        }\n        return x;\n}\n\nlong long get(int x, int y)\n{\n        long long profit = 0;\n        int p = lca(x, y);\n        profit += d[p];\n        if(x != p){\n                int g = go_up(x, dip[x] - dip[p] - 1);\n                profit += f[x] - f[g];\n                profit += d[x] - er[g];\n        }\n        if(y != p){\n                int g = go_up(y, dip[y] - dip[p] - 1);\n                profit += f[y] - f[g];\n                profit += d[y] - er[g];\n        }\n        profit += s[x] + s[y] - s[p] - s[p];\n        profit += u[p];\n        return profit;\n}\n\nvoid solve()\n{\n        int q;\n        cin >> n >> q;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        for(int i = 1; i < n; i++){\n                cin >> A[i] >> B[i] >> e[i];\n                v[A[i]].push_back(i);\n                v[B[i]].push_back(i);\n        }\n        dfs(1, 1);\n        go(1, 1);\n        for(int i = 1; i <= q; i++){\n                int x, y;\n                cin >> x >> y;\n                cout << get(x, y) << ""\\n"";\n        }\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2700
Maksim has n objects and m boxes each box has size exactly k Objects are numbered from 1 to n in order from left to right the size of the i th object is a i Maksim wants to pack his objects into the boxes and he will pack objects by the following algorithm he takes one of the empty boxes he has goes from left to right through the objects and if the i th object fits in the current box the remaining size of the box is greater than or equal to a i he puts it in the box and the remaining size of the box decreases by a i Otherwise he takes the new empty box and continues the process above If he has no empty boxes and there is at least one object not in some box then Maksim cannot pack the chosen set of objects Maksim wants to know the maximum number of objects he can pack by the algorithm above To reach this target Your task is to say the maximum number of objects Maksim can pack in boxes he has Each time when Maksim tries to pack the objects into the boxes he will make empty all the boxes he has before do it and the relative order of the remaining set of objects will not change ,"['#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for (int i = (a); i >= (b); --i)\n#define REP(i, a) for (int i = 0; i < (a); ++i)\n#define DEBUG(x) { cerr << #x << \'=\' << x << endl; }\n#define Arr(a, l, r) { cerr << #a << "" = {""; FOR(_, l, r) cerr << \' \' << a[_]; cerr << ""}\\n""; }\n#define N 1010100\n#define pp pair<int, int>\n#define endl \'\\n\'\n#define IO ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define taskname """"\n#define bit(S, i) (((S) >> (i)) & 1)\n#define all(s) s.begin(), s.end()\nusing namespace std;\n\nint a[N];\nint main() {\n    #ifdef NERO\n    freopen(""test.inp"",""r"",stdin);\n    freopen(""test.out"",""w"",stdout);\n    double stime = clock();\n    #else \n        //freopen(taskname"".inp"",""r"",stdin);\n        //freopen(taskname"".out"",""w"",stdout);\n    #endif //NERO\n    IO;\n    int n, m, k;\n    cin >> n >> m >> k;\n    FOR(i, 1, n) cin >> a[i];\n    int cnt = 0;\n    int sum = 0;\n    FORD(i, n, 1) {\n        if (sum + a[i] > k) {\n            cnt++;\n            sum = 0;\n        }\n        if (cnt == m || a[i] > k) {\n            cout << n - i;\n            return 0;\n        }\n        sum += a[i];\n    }\n    cout << n;\n    #ifdef NERO\n    double etime = clock();\n    cerr << ""Execution time: "" << (etime - stime) / CLOCKS_PER_SEC * 1000 << "" ms.\\n"";\n    #endif // NERO\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1800
Almost everything has density even a graph We define the density of a non directed graph nodes and edges of the graph have some values as follows where is the sum of the values of the nodes is the sum of the values of the edges Once DZY got a graph now he wants to find a connected induced subgraph of the graph such that the density of is as large as possible An induced subgraph of a graph is a graph that satisfies edge if and only if and edge the value of an edge in is the same as the value of the corresponding edge in so as the value of a node Help DZY to find the induced subgraph with maximum density Note that the induced subgraph you choose must be connected ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define M 1000000007\n#define N 211111\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, m;\nint a[N];\n\nint main(){\n//\tfreopen(""1.in"",""r"",stdin);\t\n//\tfreopen(""1.out"",""w"",stdout);\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++)scanf(""%d"", &a[i]);\n\tdouble ans = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y, c;\n\t\tscanf(""%d%d%d"", &x, &y, &c);\n\t\tx--;\n\t\ty--;\n\t\tans = max(ans, (a[x] + a[y]) / 1. / c); \n\t}\n\tprintf(""%.10lf\\n"", ans);\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Kirill has two integer arrays a 1 a 2 ldots a n and b 1 b 2 ldots b n of length n He defines the of the array b as sum i 1 n a i b i Here x denotes the absolute value of x Kirill can perform the following operation select two indices i and j 1 leq i j leq n and swap the values of b i and b j Help him find the maximum possible absolute beauty of the array b after performing swap ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    int l = 0, r = 1e9 + 10;\n    long long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n        l = max(l, min(a[i], b[i]));\n        r = min(r, max(a[i], b[i]));\n        ans += abs(a[i] - b[i]);\n    }\n    if (l > r) {\n        ans += 2 * (l - r);\n    }\n    cout << ans << ""\\n"";\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
You are given a following process There is a platform with n columns 1 times 1 squares are appearing one after another in some columns on this platform If there are no squares in the column a square will occupy the bottom row Otherwise a square will appear at the top of the highest square of this column When all of the n columns have at least one square in them the bottom row is being removed You will receive 1 point for this and all the squares left will fall down one row You task is to calculate the amount of points you will receive ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint cnt[1050];\nint main() {\n\tint N, M, i, j;\n\tscanf(""%d %d"", &N, &M);\n\tfor (i = 1; i <= M; i++) {\n\t\tscanf(""%d"", &j);\n\t\tcnt[j]++;\n\t}\n\n\tint mn = INF;\n\tfor (i = 1; i <= N; i++) mn = min(mn, cnt[i]);\n\treturn !printf(""%d\\n"", mn);\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
You have given an array a of length n and an integer x to a brand new robot What the robot does is the following it iterates over the elements of the array let the current element be q If q is divisible by x the robot adds x copies of the integer frac q x to the end of the array and moves on to the next element Note that the newly added elements could be processed by the robot later Otherwise if q is not divisible by x the robot shuts down Please determine the sum of all values of the array at the end of the process ,"['// Author: wlzhouzhuan\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast"")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - \'0\', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar(\'-\'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + \'0\');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\nconst int N=100005;\nint a[N],b[N];\nint main() {\n  int T=read();\n  while(T--){\n    int n=read(),k=read();\n    ll ans=0,lst=1e9,id=0;\n    rep(i,1,n){\n      a[i]=read();\n      int x=a[i];\n      b[i]=0;\n      while(x%k==0)x/=k,b[i]++;\n      if(b[i]<lst)lst=b[i],id=i;\n    }\n    rep(i,1,n)ans+=1ll*(lst+1)*a[i];\n    rep(i,1,id-1)ans+=1ll*a[i];\n    printf(""%lld\\n"",ans);\n  }\n  return 0;\n}']","[1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1100
As you know Vova has recently become a new shaman in the city of Ultima Thule So he has received the shaman knowledge about the correct bracket sequences The shamans of Ultima Thule have been using lots of different types of brackets since prehistoric times A bracket type is a positive integer The shamans define a correct bracket sequence as follows An empty sequence is a correct bracket sequence If and are correct bracket sequences then sequence their concatenation also is a correct bracket sequence If is a correct bracket sequence then sequence also is a correct bracket sequence where is an integer For example sequences and are correct bracket sequences and is not Moreover after Vova became a shaman he learned the correct bracket sequence consisting of integers As sequence is the most important Vova decided to encrypt it just in case Encrypting consists of two sequences The first sequence contains types of brackets that is The second sequence contains integers possibly not all of them which had negative numbers in sequence Unfortunately Vova forgot the main sequence But he was lucky enough to keep the encryption sequences and Help Vova restore sequence by the encryption If there are multiple sequences that correspond to the encryption restore any of them If there are no such sequences you should tell so ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nint src[1100000];\nint res[1100000];\nint st[1100000];\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tint n;\n\twhile(cin>>n){\n\t\tforn(i,n){\n\t\t\tscanf(""%d"",src+i);\n\t\t}\n\t\tint m;\n\t\tcin>>m;\n\t\tforn(i,m){\n\t\t\tint a;\n\t\t\tscanf(""%d"",&a);\n\t\t\t--a;\n\t\t\tsrc[a]*=-1;\n\t\t}\n\t\treverse(src,src+n);\n\t\tint p=0;\n\t\tbool ok=true;\n\t\tforn(i,n){\n\t\t\tint v=src[i];\n\t\t\tif(v>0 && (!p || st[p-1]!=v))\n\t\t\t\tv=-v;\n\t\t\tres[i]=v;\n\t\t\tif(v>0)\n\t\t\t\t--p;\n\t\t\telse\n\t\t\t\tst[p++]=-v;\n\t\t}\n\t\tif(p)\n\t\t\tok=false;\n\t\tif(!ok){\n\t\t\tcout<<""NO""<<\'\\n\';\n\t\t\tcontinue;\n\t\t}\n\t\treverse(res,res+n);\n\t\tcout<<""YES\\n"";\n\t\tforn(i,n){\n\t\t\tprintf(""%d "",res[i]);\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Manao is solving a problem with the following statement He came up with a solution that produces the correct answers but is too slow You are given the pseudocode of his solution where the function getAnswer calculates the answer to the problem getAnswer a 1 n b 1 len h answer 0 for i 1 to n len 1 answer answer f a i i len 1 b h 1 return answerf s 1 len b 1 len h index if index len 1 then return 1 for i 1 to len if s index b i h mem b i b i 0 res f s b h index 1 b i mem if res 0 return 1 return 0Your task is to help Manao optimize his algorithm ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int N = 2000010;\n\nint mx[N], add[N], a[N], b[N];\n\nvoid modify(int x, int l, int r, int ll, int rr, int v) {\n  if (l > rr || ll > r) return;\n  if (l >= ll && r <= rr) {\n    add[x] += v;\n    return;\n  }\n  if (add[x] != 0) {\n    add[x + x] += add[x];\n    add[x + x + 1] += add[x];\n    add[x] = 0;\n  }\n  int y = (l + r) >> 1;\n  modify(x + x, l, y, ll, rr, v);\n  modify(x + x + 1, y + 1, r, ll, rr, v);\n  mx[x] = mx[x + x + 1] + add[x + x + 1];\n  if (mx[x + x] + add[x + x] > mx[x]) mx[x] = mx[x + x] + add[x + x];\n}\n\nint main() {\n  int n, len, h;\n  scanf(""%d %d %d"", &n, &len, &h);\n  for (int i=1;i<=len;i++) scanf(""%d"", b+i);\n  sort(b + 1, b + len + 1);\n  reverse(b + 1, b + len + 1);\n  for (int i=1;i<=n;i++) {\n    int foo;\n    scanf(""%d"", &foo);\n    int ll = 0, rr = len;\n    while (ll < rr) {\n      int mid = (ll + rr + 1) >> 1;\n      if (foo + b[mid] >= h) ll = mid;\n      else rr = mid - 1;\n    }\n    a[i] = ll;\n  }\n  memset(mx, 0, sizeof(mx));\n  memset(add, 0, sizeof(add));\n  for (int i=1;i<=len;i++) modify(1, 0, len, i, i, -i);\n  for (int i=1;i<=len-1;i++) modify(1, 0, len, a[i], len, 1);\n  int ans = 0;\n  for (int i=len;i<=n;i++) {\n    modify(1, 0, len, a[i], len, 1);\n    if (mx[1] + add[1] == 0) ans++;\n    modify(1, 0, len, a[i - len + 1], len, -1);\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2600
Alice has got addicted to a game called Sirtet recently In Sirtet player is given an n times m grid Initially a i j cubes are stacked up in the cell i j Two cells are called adjacent if they share a side Player can perform the following operations stack up one cube in two cells stack up two cubes in one cell Cubes mentioned above are identical in height Here is an illustration of the game States on the right are obtained by performing one of the above operations on the state on the left and grey cubes are added due to the operation Player s goal is to i e so that each cell has the same number of cubes in it using above operations Alice however has found out that on some starting grids she may never reach the goal no matter what strategy she uses Thus she is wondering the number of initial grids such that L le a i j le R for all 1 le i le n 1 le j le m player can reach the goal using above operations Please help Alice with it Notice that the answer might be large please output the desired value modulo 998 244 353 ,"['#include <bits/stdc++.h>\n\ntypedef long long ll;\n\nconst int djq = 998244353;\n\nint n, m, L, R, c0, c1;\n\nstruct matrix\n{\n\tint n, m, a[2][2];\n\t\n\tmatrix() {}\n\tmatrix(int _n, int _m) :\n\t\tn(_n), m(_m) {memset(a, 0, sizeof(a));}\n\t\n\tfriend inline matrix operator * (matrix a, matrix b)\n\t{\n\t\tmatrix res = matrix(a.n, b.m);\n\t\tfor (int i = 0; i < a.n; i++) for (int j = 0; j < b.m; j++)\n\t\t\tfor (int k = 0; k < a.m; k++)\n\t\t\t\tres.a[i][j] = (1ll * a.a[i][k] * b.a[k][j] + res.a[i][j]) % djq;\n\t\treturn res;\n\t}\n\t\n\tfriend inline matrix operator ^ (matrix a, ll b)\n\t{\n\t\tmatrix res = matrix(a.n, a.m);\n\t\tfor (int i = 0; i < res.n; i++) res.a[i][i] = 1;\n\t\twhile (b)\n\t\t{\n\t\t\tif (b & 1) res = res * a;\n\t\t\ta = a * a;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n} F, A;\n\nint main()\n{\n\tstd::cin >> n >> m >> L >> R;\n\tc0 = (R >> 1) - (L - 1 >> 1); c1 = (R + 1 >> 1) - (L >> 1);\n\tA = matrix(2, 2); F = matrix(2, 1);\n\tA.a[0][0] = A.a[1][1] = c0; A.a[1][0] = A.a[0][1] = c1;\n\tF.a[0][0] = 1;\n\tF = (A ^ 1ll * n * m) * F;\n\tif (n * m & 1) std::cout << (F.a[0][0] + F.a[1][0]) % djq << std::endl;\n\telse std::cout << F.a[0][0] << std::endl;\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2100
As you could know there are no male planes nor female planes However each plane on Earth likes some other plane There are planes on Earth numbered from to and the plane with number likes the plane with number where and We call a love triangle a situation in which plane likes plane plane likes plane and plane likes plane Find out if there is any love triangle on Earth ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\n\nconst int MAXN = 5e3 + 10;\n\nint n, p[MAXN];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i], p[i]--;\n\tfor (int i = 0; i < n; i++)\n\t\tif (p[p[p[i]]] == i){\n\t\t\tcout << ""YES\\n"";\n\t\t\treturn 0;\n\t\t}\n\tcout << ""NO\\n"";\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",800
Let s denote the function f s that takes a string s consisting of lowercase Latin letters and dots and returns a string consisting of lowercase Latin letters as follows let r be an empty string process the characters of s from left to right For each character c do the following if c is a lowercase Latin letter append c at the end of the string r otherwise delete the last character from r if r is empty before deleting the last character the function crashes return r as the result of the function You are given two strings s and t You have to delete the minimum possible number of characters from s so that f s t and the function does not crash Note that you aren t allowed to insert new characters into s or reorder the existing ones ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int> psum(21000, 0);\n\tpsum[0] = 10100;\n\ts = s + ""48"";\n\tt = t + ""48"";\n\tint n = (int)s.size();\n\tfor(int i = 0; i < n; i++){\n\t\tpsum[i+1] = psum[i] + (s[i] == \'.\' ? -1 : 1);\n\t}\n\tvector<int> dp(n+1, 1e8);\n\tdp[0] = 0;\n\tvector<int> dp_mid(n+1, 1e8);\n\tvector<int> new_dp(n+1, 1e8);\n\tvector<int> z1(21000);\n\tvector<int> z2(21000);\n\tfor(char c : t){\n\t\tz1.assign(21000, 1e8);\n\t\tz2.assign(21000, 1e8);\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tdp[i] += psum[i];\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tz1[psum[i]] = min(z1[psum[i]], dp[i]);\n\t\t\tz1[psum[i]] = min(z1[psum[i]], z1[psum[i] + 1]);\n\t\t\tif(i > 0 && psum[i-1] > psum[i]) z1[psum[i-1]] = 1e8;\n\t\t\tdp_mid[i] = z1[psum[i]];\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tdp_mid[i] -= 2 * psum[i];\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tz2[psum[i]] = min(z2[psum[i]], dp_mid[i]);\n\t\t\tz2[psum[i]] = min(z2[psum[i]], z2[psum[i] - 1]);\n\t\t\tz2[psum[i] + 1] = 1e8;\n\t\t\tnew_dp[i] = z2[psum[i]];\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tnew_dp[i] += psum[i];\n\t\t}\n\t\tdp.assign(n+1, 1e8);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(s[i-1] == c) dp[i] = new_dp[i-1];\n\t\t}\n\t}\n\tassert(dp.back() < (int)1e8);\n\tcout << dp.back() << \'\\n\';\n}']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2700
Note The XOR sum of set s 1 s 2 ldots s m is defined as s 1 oplus s 2 oplus ldots oplus s m where oplus denotes the bitwise XOR operation After almost winning IOI Victor bought himself an n times n grid containing integers in each cell The integer in the cell in the i th row and j th column is a i j Sadly Mihai stole the grid from Victor and told him he would return it with only one condition Victor has to tell Mihai the XOR sum of the integers in the whole grid Victor doesn t remember all the elements of the grid but he remembers some information about it For each cell Victor remembers the XOR sum of all its neighboring cells Two cells are considered neighbors if they share an edge in other words for some integers 1 le i j k l le n the cell in the i th row and j th column is a neighbor of the cell in the k th row and l th column if i k 1 and j l or if i k and j l 1 To get his grid back Victor is asking you for your help Can you use the information Victor remembers to find the XOR sum of the whole grid It can be proven that the answer is unique ,"['/**\n *    author:  tourist\n *    created: 22.01.2022 17:52:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> a(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        cin >> a[i][j];\n      }\n    }\n    int ans = 0;\n    for (int rot = 0; rot < 2; rot++) {\n      for (int i = 0; i < n; i += 4) {\n        int x = i;\n        int y = 0;\n        while (x >= 0 && x < n && y >= 0 && y < n) {\n          ans ^= a[x][y];\n          x -= 2;\n          y += 2;\n        }\n      }\n      for (int j = (n % 4 == 0 ? 1 : 3); j < n; j += 4) {\n        int x = n - 1;\n        int y = j;\n        while (x >= 0 && x < n && y >= 0 && y < n) {\n          ans ^= a[x][y];\n          x -= 2;\n          y += 2;\n        }\n      }\n      reverse(a.begin(), a.end());\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
Alice and Bob decided to eat some fruit In the kitchen they found a large bag of oranges and apples Alice immediately took an orange for herself Bob took an apple To make the process of sharing the remaining fruit more fun the friends decided to play a game They put multiple cards and on each one they wrote a letter either or the letter Then they began to remove the cards one by one from left to right every time they removed a card with the letter Alice gave Bob all the fruits she had at that moment and took out of the bag as many apples and as many oranges as she had before Thus the number of oranges and apples Alice had did not change If the card had written letter then Bob did the same that is he gave Alice all the fruit that he had and took from the bag the same set of fruit After the last card way removed all the fruit in the bag were over You know how many oranges and apples was in the bag at first Your task is to find any sequence of cards that Alice and Bob could have played with ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nvector<ll> ans;\n\nll gcd(ll x, ll y)\n{\n    while(true)\n    {\n        if (x == y)\n            return x;\n        if (x < y)\n        {\n            ll p = (y - 1) / x;\n            ans.push_back(-p);\n            y -= x * p;\n        }\n        else\n        {\n            ll p = (x - 1) / y;\n            ans.push_back(p);\n            x -= y * p;\n        }\n    }\n    throw;\n}\n\nint main()\n{\n    ll x, y;\n    cin >> x >> y;\n    if (gcd(x, y) != 1)\n    {\n        printf(""Impossible\\n"");\n        return 0;\n    }\n//  reverse(ans.begin(), ans.end());\n    for (int i = 0; i < (int)ans.size(); i++)\n        printf(""%lld%c"", abs(ans[i]), (ans[i] > 0 ? \'A\' : \'B\'));\n    printf(""\\n"");\n\n    return 0;\n}']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2400
Mahmoud and Ehab are on the third stage of their adventures now As you know Dr Evil likes sets This time he won t show them any set from his large collection but will ask them to create a new set to replenish his beautiful collection of sets Dr Evil has his favorite evil integer He asks Mahmoud and Ehab to find a set of distinct non negative integers such the bitwise xor sum of the integers in it is exactly Dr Evil doesn t like big numbers so any number in the set shouldn t be greater than ,"['#include <cstdio>\nint N, X;\nint main()\n{\n\tscanf(""%d%d"", &N, &X);\n\tif (N == 1)\n\t{\n\t\tprintf(""YES\\n%d\\n"", X);\n\t\treturn 0;\n\t}\n\tif (N == 2)\n\t{\n\t\tif (X == 0)\n\t\t\tputs(""NO"");\n\t\telse\n\t\t\tprintf(""YES\\n0 %d\\n"", X);\n\t\treturn 0;\n\t}\n\tif (N == 3)\n\t{\n\t\tif (X == 0)\n\t\t\tprintf(""YES\\n1 2 3\\n"");\n\t\telse if (X == 1)\n\t\t\tprintf(""YES\\n0 2 3\\n"");\n\t\telse\n\t\t\tprintf(""YES\\n0 1 %d\\n"", X ^ 1);\n\t\treturn 0;\n\t}\n\tputs(""YES"");\n\tfor (int i = 0; i < N - 4; i++)\n\t{\n\t\tX ^= i;\n\t\tprintf(""%d "", i);\n\t}\n\tif (1 <= X && X <= 3)\n\t{\n\t\tfor (int i = 0; i <= 10; i++)\n\t\t\tfor (int j = 0; j <= 10; j++)\n\t\t\t\tif (i != j)\n\t\t\t\t\tfor (int k = 0; k <= 10; k++)\n\t\t\t\t\t\tif (i != k && j != k)\n\t\t\t\t\t\t\tfor (int l = 0; l <= 10; l++)\n\t\t\t\t\t\t\t\tif (i != l && j != l && k != l)\n\t\t\t\t\t\t\t\t\tif ((i ^ j ^ k ^ l) == X)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tprintf(""%d %d %d %d\\n"", 262144 + i, 262144 + j, 262144 + k, 262144 + l);\n\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t}\n\t}\n\telse\n\t\tprintf(""262144 262145 262146 %d\\n"", X ^ 262144 ^ 262145 ^ 262146);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Lech got into a tree consisting of vertices with a root in vertex number At each vertex written integer He will not get out until he answers queries of the form Answer for the query is maximal value among all vertices on path from to including and where is number of edges on path from to Also guaranteed that vertex is ancestor of vertex Leha s tastes are very singular he believes that vertex is ancestor of itself Help Leha to get out The expression means the bitwise exclusive to the numbers and Note that vertex is ancestor of vertex if vertex lies on the path from root to the vertex ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nstruct HLD {\n\tvector<vi> paths;\n\tvector<pair<int, int> > pathParent;\n\tvector<pair<int, int> > nodePos;\n\tvector<int> nodeDepth;\n\n\tvoid build(const vector<vi> &g, int root) {\n\t\tint N = g.size();\n\t\tvector<int> t_ord, t_parent(N, -1);\n\t\tnodeDepth.assign(N, 0);\n\t\t{\n\t\t\tvector<int> stk;\n\t\t\tstk.push_back(root);\n\t\t\twhile (!stk.empty()) {\n\t\t\t\tint i = stk.back();\n\t\t\t\tstk.pop_back();\n\t\t\t\tt_ord.push_back(i);\n\t\t\t\tfor (int j : g[i]) if (j != root && t_parent[j] == -1) {\n\t\t\t\t\tt_parent[j] = i;\n\t\t\t\t\tnodeDepth[j] = nodeDepth[i] + 1;\n\t\t\t\t\tstk.push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> subtsize(N, 1);\n\t\tfor (int ix = N - 1; ix > 0; -- ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tsubtsize[p] += subtsize[i];\n\t\t}\n\t\tpaths.clear();\n\t\tpaths.push_back(vi());\n\t\tpathParent.emplace_back(-1, 0);\n\t\tdfs(root, -1, g, subtsize);\n\t\tassert(paths.back().empty());\n\t\tpaths.pop_back();\n\t\tassert(paths.size() == pathParent.size());\n\n\t\tnodePos.assign(N, { -1, -1 });\n\t\trep(c, paths.size()) rep(p, paths[c].size())\n\t\t\tnodePos[paths[c][p]] = { c, p };\n\t}\n\n\tvoid get(int u, int &c, int &p) const {\n\t\ttie(c, p) = nodePos[u];\n\t}\n\n\tbool go_up(int &c, int &p) const {\n\t\ttie(c, p) = pathParent[c];\n\t\treturn c != -1;\n\t}\n\n\ttypedef tuple<int, int, int> SubPath;\n\n\tvoid getPath1(int u, int v, vector<SubPath> &path) const {\n\t\tpath.clear();\n\t\tint uc, up, vc, vp;\n\t\tget(u, uc, up);\n\t\tget(v, vc, vp);\n\t\twhile (uc != vc) {\n\t\t\tpath.emplace_back(vc, 0, vp + 1);\n\t\t\tgo_up(vc, vp);\n\t\t}\n\t\tpath.emplace_back(vc, up, vp + 1);\n\t}\n\nprivate:\n\tvoid dfs(int i, int p, const vector<vi> &g, const vector<int> &subtsize) {\n\t\tint color = (int)paths.size() - 1;\n\t\tint pos = paths.back().size();\n\t\tpaths.back().push_back(i);\n\n\t\tint c = -1;\n\t\tfor (int j : g[i]) if (j != p) {\n\t\t\tif (c == -1 || subtsize[c] < subtsize[j])\n\t\t\t\tc = j;\n\t\t}\n\n\t\tif (c == -1) {\n\t\t\tpaths.push_back(vi());\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(c, i, g, subtsize);\n\n\t\tfor (int j : g[i]) if (j != p && j != c) {\n\t\t\tpathParent.emplace_back(color, pos);\n\t\t\tdfs(j, i, g, subtsize);\n\t\t}\n\t}\n};\n\nint main() {\n\tint n; int q;\n\twhile (~scanf(""%d%d"", &n, &q)) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(""%d"", &a[i]);\n\t\tvector<vector<int> > g(n);\n\t\tfor (int i = 0; i < n - 1; ++ i) {\n\t\t\tint u, v;\n\t\t\tscanf(""%d%d"", &u, &v), -- u, -- v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\tHLD hld;\n\t\thld.build(g, 0);\n\t\tmap<pii, int> memo;\n\t\tvector<tuple<int, int, int>> path;\n\t\tvector<int> offsets(hld.paths.size() + 1);\n\t\tconst int W = 8;\n\t\trep(i, hld.paths.size())\n\t\t\toffsets[i + 1] = offsets[i] + (hld.paths[i].size() / W + 1) * W;\n\t\tvector<uint16_t> values(offsets.back());\n\t\trep(i, hld.paths.size()) rep(j, hld.paths[i].size())\n\t\t\tvalues[offsets[i] + j] = a[hld.paths[i][hld.paths[i].size() - 1 - j]];\n\t\tll anssum = 0;\n\t\trep(ii, q) {\n\t\t\tint u; int v;\n\t\t\tscanf(""%d%d"", &u, &v), -- u, -- v;\n\t\t\tauto &ans = memo.emplace(make_pair(make_pair(u, v), -1)).first->second;\n\t\t\tif (ans != -1) {\n\t\t\t\tprintf(""%d\\n"", ans);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thld.getPath1(u, v, path);\n\t\t\tint add = 0;\n\t\t\tint maxi = 0;\n\t\t\tfor (auto t : path) {\n\t\t\t\tint c, L, R;\n\t\t\t\ttie(c, L, R) = t;\n\t\t\t\tauto x = values.data() + offsets[c] + (hld.paths[c].size() - R);\n\t\t\t\tint len = R - L;\n\t\t\t\tfor (int i = 0; i < len; ++ i)\n\t\t\t\t\tamax(maxi, x[i] ^ (add + i));\n\t\t\t\tadd += len;\n\t\t\t}\n\t\t\tans = maxi;\n\t\t\tprintf(""%d\\n"", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",3200
You are given an array a of n integers Also you are given m subsegments of that array The left and the right endpoints of the j th segment are l j and r j respectively You are allowed to make operation In that operation you choose any subsegment of the array a and replace each value on this segment with any integer you are also allowed to keep elements the same You have to apply this operation so that for the given m segments the elements on each segment are distinct More formally for each 1 le j le m all elements a l j a l j 1 ldots a r j 1 a r j should be distinct You don t want to use the operation on a big segment so you have to find the smallest length of a segment so that you can apply the operation to this segment and meet the above mentioned conditions If it is not needed to use this operation the answer is 0 ,"['/**\n *    author:  tourist\n *    created: 19.05.2022 19:05:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    int mx = -1;\n\n    void apply(int l, int r, int v) {\n      mx = max(mx, v);\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mx = max(a.mx, b.mx);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> xs = a;\n    sort(xs.begin(), xs.end());\n    xs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n    for (int i = 0; i < n; i++) {\n      a[i] = (int) (lower_bound(xs.begin(), xs.end(), a[i]) - xs.begin());\n    }\n    vector<int> l(m), r(m);\n    for (int i = 0; i < m; i++) {\n      cin >> l[i] >> r[i];\n      --l[i]; --r[i];\n    }\n    const int inf = (int) 1e9;\n    int L = -1, R = -1;\n    for (int rot = 0; rot < 2; rot++) {\n      vector<int> last(n, -1);\n      vector<int> pred(n, -1);\n      for (int i = 0; i < n; i++) {\n        pred[i] = last[a[i]];\n        last[a[i]] = i;\n      }\n      segtree st(pred);\n      int mn = inf;\n      for (int i = 0; i < m; i++) {\n        int id = st.find_first(l[i], r[i], [&](const segtree::node& nd) {\n          return nd.mx >= l[i];\n        });\n        if (id != -1) {\n          mn = min(mn, id);\n        }\n      }\n      if (mn == inf) {\n        break;\n      }\n      if (rot == 0) {\n        L = mn;\n      } else {\n        R = n - 1 - mn;\n      }\n      reverse(a.begin(), a.end());\n      for (int i = 0; i < m; i++) {\n        swap(l[i], r[i]);\n        l[i] = n - 1 - l[i];\n        r[i] = n - 1 - r[i];\n      }\n    }\n    if (L == -1) {\n      cout << 0 << \'\\n\';\n      continue;\n    }\n    vector<int> lft(n, -1);\n    vector<int> rgt(n, -1);\n    for (int i = 0; i < L; i++) {\n      lft[a[i]] = i;\n    }\n    for (int i = n - 1; i > R; i--) {\n      rgt[a[i]] = i;\n    }\n    segtree st(n);\n    for (int i = 0; i < m; i++) {\n      st.modify(l[i], l[i], r[i]);\n    }\n    segtree sf(n);\n    for (int i = 0; i < n; i++) {\n      if (lft[i] != -1 && rgt[i] != -1 && lft[i] != rgt[i]) {\n        if (st.get(0, lft[i]).mx >= rgt[i]) {\n          sf.modify(lft[i], lft[i], rgt[i]);\n        }\n      }\n    }\n    int ans = n;\n    for (int from = 0; from <= L; from++) {\n      int to = R;\n      if (from > 0) {\n        to = max(to, sf.get(0, from - 1).mx);\n      }\n      ans = min(ans, to - from + 1);\n    }\n    ans = max(ans, 1);\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2600
In the 2050 Conference some people from the competitive programming community meet together and are going to take a photo The n people form a line They are numbered from 1 to n from left to right Each of them either holds a cardboard with the letter or a cardboard with the letter Let C c 1 c 2 dots c m c 1 c 2 ldots c m be the set of people who hold cardboards of Let P p 1 p 2 dots p k p 1 p 2 ldots p k be the set of people who hold cardboards of The photo is good if and only if it satisfies the following constraints C cup P 1 2 dots n C cap P emptyset c i c i 1 leq c i 1 c i 1 i m p i p i 1 geq p i 1 p i 1 i k Given an array a 1 ldots a n please find the number of good photos satisfying the following condition sum limits x in C a x sum limits y in P a y The answer can be large so output it modulo 998 244 353 Two photos are different if and only if there exists at least one person who holds a cardboard of in one photo but holds a cardboard of in the other ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = int((ll)v*m.v%MOD); return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvl get_cum(vl v) {\n\tvl cum(sz(v)+1);\n\tF0R(i,sz(v)) cum[i+1] = cum[i]+v[i];\n\treturn cum;\n}\n\nint N;\nvl A;\nmi ans;\nll tot;\n\nbool ok(ll csum) {\n\treturn 2*csum < tot;\n}\n\nvoid cpcp(ll _csum, vl tmp) {\n\t// mi rec = ans;\n\tvl cum = get_cum(tmp);\n\tvl cum2(sz(tmp)+1);\n\tF0R(i,sz(tmp)) {\n\t\tcum2[i+1] = tmp[i];\n\t\tif (i) cum2[i+1] += cum2[i-1];\n\t}\n\tFOR(i,1,sz(tmp)) {\n\t\tll csum = cum[i]+_csum;\n\t\tif (ok(csum)) {\n\t\t\tint max_ok = (sz(tmp)-1-i)/2;\n\t\t\tint num = lstTrue(0,max_ok,[&](int x) {\n\t\t\t\treturn ok(csum+cum2[i+2*x]-cum2[i]);\n\t\t\t});\n\t\t\tans += num+1;\n\t\t}\n\n\t\t// dbg(""AH"",csum,tot);\n\t\t// for (int j = i; j < sz(tmp); j += 2) {\n\t\t// \tif (j > i) csum += tmp[j-1];\n\t\t// \tif (csum < tot-csum) {\n\t\t// \t\t// dbg(""OO"",i,j,csum,tot);\n\t\t// \t\tans += 1;\n\t\t// \t}\n\t\t// }\n\t}\n\t// dbg(""HUH"",_csum,tmp,ans-rec);\n}\n\nvoid solve(int tc) {\n\tre(N); A.rsz(N); re(A);\n\tvl cum = get_cum(A);\n\ttot = cum.bk;\n\tans = 0;\n\tif (N <= 2) {\n\t\tF0R(i,N) if (cum[i] != tot-cum[i]) ++ans;\n\t\tps(ans);\n\t\treturn;\n\t}\n\tans = 1;\n\t// PPPPPCCCCC\n\tFOR(i,1,N) if (cum[N]-cum[i] < cum[i]) ++ans;\n\tF0R(a,2) F0R(b,2) {\n\t\tvl tmp = A;\n\t\tll csum = 0;\n\t\tif (a) {\n\t\t\ttmp.erase(begin(tmp));\n\t\t}\n\t\tif (b) {\n\t\t\tcsum += tmp.bk;\n\t\t\ttmp.pop_back();\n\t\t}\n\t\tcpcp(csum,tmp);\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2500
Binary Spiders are species of spiders that live on Mars These spiders weave their webs to defend themselves from enemies To weave a web spiders join in pairs If the first spider in pair has x legs and the second spider has y legs then they weave a web with x oplus y Here oplus means bitwise XOR Binary Spiders live in large groups You observe a group of n spiders and the i th spider has a i legs When the group is threatened some of the spiders become Defenders are chosen in the following way First there must be at least two defenders Second any pair of defenders must be able to weave a web with durability at least k Third there must be as much defenders as possible Scientists have researched the behaviour of Binary Spiders for a long time and now they have a hypothesis that they can always choose the defenders in an optimal way satisfying the conditions above You need to verify this hypothesis on your group of spiders So you need to understand how many spiders must become defenders You are not a Binary Spider so you decided to use a computer to solve this problem ,"[""#include <bits/stdc++.h>\n#define rep(i,n) for (i=1;i<=(n);i++)\nusing namespace std;\nint n,t,i,k,a[300007];\nint tot,c[9900007][2],id[9900007];\nvector<int> w;\nvoid init(){\n\ttot=1;\n\tc[1][0]=c[1][1]=0;\n}\nvoid ins(int v){\n\tint u=1;\n\tfor(int i=30;i>=0;i--){\n\t\tint o=((a[v]>>i)&1);\n\t\tif(!c[u][o]){\n\t\t\tc[u][o]=++tot;\n\t\t\tc[tot][0]=c[tot][1]=0;\n\t\t}\n\t\tu=c[u][o];\n\t\tid[u]=v;\n\t}\n}\nbool check(int v){\n\tint u=1;\n\tfor(int i=30;i>=0;i--){\n\t\tint o=(((a[v]^k)>>i)&1);\n\t\tif((!((k>>i)&1))&&c[u][!o]){\n\t\t\tw.push_back(id[c[u][!o]]);\n\t\t\tw.push_back(v);\n\t\t\treturn 1;\n\t\t}\n\t\tif(!c[u][o]) return 0;\n\t\tu=c[u][o];\n\t}\n\tw.push_back(id[u]);\n\tw.push_back(v);\n\treturn 1;\n}\nint low(vector<int> v0,vector<int> v1,int d){\n\tinit();\n\tfor(int u:v0) ins(u);\n\tfor(int u:v1) if(check(u)) return 2;\n\tw.push_back(v0.empty()?v1[0]:v0[0]);\n\treturn 1;\n}\nint high(vector<int> v,int d){\n\tif(v.empty()) return 0;\n\tvector<int> v0,v1;\n\tfor(int u:v) if((a[u]>>d)&1) v1.push_back(u); else v0.push_back(u);\n\tif((1<<d)>=k){\n\t\treturn high(v0,d-1)+high(v1,d-1);\n\t}\n\treturn low(v0,v1,d-1);\n}\nint main(){\n\tcin>>n>>k;\n\tif(k==0){\n\t\tcout<<n<<endl;\n\t\trep(i,n) cout<<i<<' ';\n\t\treturn 0;\n\t}\n\tvector<int> v;\n\trep(i,n){\n\t\tcin>>t;\n\t\tv.push_back(i);\n\t\ta[i]=t;\n\t}\n\tint ans=high(v,30);\n\tif(ans>=2){\n\t\tcout<<ans<<endl;\n\t\tfor(int u:w) cout<<u<<' ';\n\t}\n\telse cout<<-1;\n\treturn 0;\n}""]","[0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0]",2300
Vus the Cossack has a simple graph with n vertices and m edges Let d i be a degree of the i th vertex Recall that a degree of the i th vertex is the number of conected edges to the i th vertex He needs to remain not more than lceil frac n m 2 rceil edges Let f i be the degree of the i th vertex after removing He needs to delete them in such way so that lceil frac d i 2 rceil leq f i for each i In other words the degree of each vertex should not be reduced more than twice Help Vus to remain the needed edges ,"['#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\ntypedef long long ll;\n#define pb push_back\ntypedef pair<int,int> pii;\n#define mp make_pair\nconst int MAXN=1000005,INF=1<<30;\n\nint n;\nvector<int> G[MAXN];\nint Min[MAXN<<2|1],Max[MAXN<<2|1],ind[MAXN],rem[MAXN]; \nvoid build(int id,int l,int r)\n{\n\tif(l==r){Min[id]=rem[l];return;}\n\tint mid=(l+r)>>1;\n\tbuild(id<<1,l,mid);\n\tbuild(id<<1|1,mid+1,r);\n\tMin[id]=min(Min[id<<1],Min[id<<1|1]);\n}\nint querymin(int id,int l,int r)\n{\n\tif(l==r)return l;\n\tint mid=(l+r)>>1;\n\tif(Min[id<<1]<Min[id<<1|1])return querymin(id<<1,l,mid);\n\treturn querymin(id<<1|1,mid+1,r);\n}\nvoid modify(int id,int l,int r,int x,int c)\n{\n\tif(l==r){Min[id]=c;return;}\n\tint mid=(l+r)>>1;\n\tif(x<=mid)modify(id<<1,l,mid,x,c);\n\telse modify(id<<1|1,mid+1,r,x,c);\n\tMin[id]=min(Min[id<<1],Min[id<<1|1]);\n}\nset<pii> del;\ninline bool cmp(int x,int y){return rem[x]>rem[y];}\n\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(""code.in"",""r"",stdin);\n    //freopen(""code.out"",""w"",stdout);\n    #endif\n    int E,u,v;\n    scanf(""%d%d"",&n,&E);\n    for(int i=1;i<=E;i++)\n    {\n    \tscanf(""%d%d"",&u,&v);\n    \tG[u].pb(v);G[v].pb(u);\n    \t++ind[u];++ind[v];\n    }\n    for(int i=1;i<=n;i++)rem[i]=ind[i]/2;\n    build(1,1,n);\n    for(int i=1;i<=n;i++)\n    {\n    \tu=querymin(1,1,n);\n    \tmodify(1,1,n,u,INF);\n    \tsort(G[u].begin(),G[u].end(),cmp);\n    \tfor(int j=0;j<rem[u];j++)\n    \t{\n    \t\tv=G[u][j];\n    \t\tif(!rem[v])break;\n    \t\t--rem[v];\n    \t\tmodify(1,1,n,v,rem[v]);\n    \t\tdel.insert(mp(u,v));\n    \t}\n    \trem[u]=0;\n    }\n    printf(""%d\\n"",E-del.size());\n    for(u=1;u<=n;u++)\n    \tfor(auto v:G[u])\n    \t\tif(v>u && !del.count(mp(u,v)) && !del.count(mp(v,u)))\n\t\t\t\tprintf(""%d %d\\n"",u,v);\n    return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2400
There are n blocks arranged in a row and numbered from left to right starting from one Each block is either black or white You may perform the following operation zero or more times choose two blocks and invert their colors white block becomes black and vice versa You want to find a sequence of operations such that they make all the blocks having the same color You to minimize the number of operations but it should not exceed 3 cdot n If it is impossible to find such a sequence of operations you need to report it ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 202;\n\nint n, a[N], cnt[2];\nstring s;\nvector<int> vec;\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> s;\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i] = (s[i] == 'W')]++;\n\tif (cnt[0] % 2 && cnt[1] % 2) {\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n - 1; i++)\n\t\tif (a[i] != a[i - 1]) {\n\t\t\tvec.push_back(i);\n\t\t\ta[i] ^= 1;\n\t\t\ta[i + 1] ^= 1;\n\t\t}\n\tfor (int i = n - 2; i; i--)\n\t\tif (a[i] != a[i + 1]) {\n\t\t\tvec.push_back(i - 1);\n\t\t\ta[i] ^= 1;\n\t\t\ta[i - 1] ^= 1;\n\t\t}\n\n\tcout << vec.size() << '\\n';\n\tfor (int x: vec)\n\t\tcout << ++x << ' ';\n}\n""]","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
A house at the sea has h floors all of the same height The side of the house facing the sea has w windows at equal distances from each other on every floor Thus the windows are positioned in cells of a rectangular grid of size h times w In every window the light can be turned either on or off except for the given k at most 2 windows In these k windows the light can not be turned on because it is broken In the dark we can send a signal to a ship at sea using a configuration of lights turned on and off However the ship can not see the position of the lights with respect to the house Thus if one configuration of windows with lights on can be transformed into another using parallel translation these configurations are considered equal Note that only parallel translation is allowed but neither rotations nor flips are Moreover a configuration without any light at all is not considered valid Find how many different signals the ship can receive and print this number modulo 998 244 353 ,"['#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long\n#define sz(a) ((int) (a).size())\n#define vi vector < int > \n#define me(a, x) memset(a, x, sizeof(a))\n#define ull unsigned long long\n#define ld __float128\nusing namespace std;\nconst int N = 1607, mod = 998244353;\nint n, m, xn, xm, k, r[N], c[N], pw[N];\nbool vis[N][N];\nint msk[N];\nint ok[N];\nvi e[N];\ninline int getid(pair < int, int > o) {\n\treturn (o.first - 1) * xm + o.second;\n}\nvi T;\nbool use[N];\nvoid getlen(int u) {\n\tif(use[u]) return ;\n\tuse[u] = true;\n\tT.emplace_back(u);\n\tfor(auto v : e[u]) \n\t\tgetlen(v);\n}\nint dp[1 << 4];\nint ndp[1 << 4];\nvoid clear() {\n\tme(dp, 0);\n\tdp[0] = 1;\n}\nvoid push(vi msk, vi cnt) {\n\t\n\tme(ndp, 0);\n\tL(t, 0, sz(msk) - 1) {\n\t\tint v = msk[t];\n\t\tint c = cnt[t];\n\t\tL(i, 0, 15)\n\t\t\t(ndp[i | v] += (ll) c * dp[i] % mod) %= mod; \n\t}\n\tswap(dp, ndp);\n}\nint F[2][16], G[2][16];\nvoid Main() {\n\tcin >> n >> m >> k;\n\tpw[0] = 1;\n\tL(i, 1, n * m) pw[i] = (ll) pw[i - 1] * 2 % mod; \n\tL(i, 1, k) {\n\t\tcin >> r[i] >> c[i]; \n\t}\n\t\n\tint ns = 0;\n\tfor(xn = 1; xn <= n; ++xn) {\n\t\tfor(xm = 1; xm <= m; ++xm) {\n\t\t\tme(use, 0);\n\t\t\tL(i, 1, xn) \n\t\t\t\tL(j, 1, xm) \n\t\t\t\t\tvis[i][j] = true;\n\t\t\tL(i, 1, xn) {\n\t\t\t\tL(j, 1, xm) {\n\t\t\t\t\tint Msk = 0;\n\t\t\t\t\tif(i == 1) {\n\t\t\t\t\t\tMsk += 1;\n\t\t\t\t\t} \n\t\t\t\t\tif(i == xn) {\n\t\t\t\t\t\tMsk += 2;\n\t\t\t\t\t}\n\t\t\t\t\tif(j == 1) {\n\t\t\t\t\t\tMsk += 4;\n\t\t\t\t\t}\n\t\t\t\t\tif(j == xm) {\n\t\t\t\t\t\tMsk += 8;\n\t\t\t\t\t}\n\t\t\t\t\tmsk[(i - 1) * xm + j] = Msk;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tclear();\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tpush(vi{0, msk[i]}, vi{1, 1});\n\t\t\t(ns += dp[15]) %= mod;\n\t\t\t\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tok[i] = true, e[i].clear();\n\t\t\tbool okay = false;\n\t\t\tL(lx, 1, n - xn + 1) if(!okay) {\n\t\t\t\tL(ly, 1, m - xm + 1) if(!okay) {\n\t\t\t\t\tint rx = lx + xn - 1;\n\t\t\t\t\tint ry = ly + xm - 1;\n\t\t\t\t\tvector < pair < int, int > > vc; \n\t\t\t\t\tL(i, 1, k) {\n\t\t\t\t\t\tif(lx <= r[i] && r[i] <= rx) {\n\t\t\t\t\t\t\tif(ly <= c[i] && c[i] <= ry) {\n\t\t\t\t\t\t\t\tvc.emplace_back(r[i] - lx + 1, c[i] - ly + 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!sz(vc)) {\n\t\t\t\t\t\tokay = true;\n\t\t\t\t\t} else if(sz(vc) == 1) {\n\t\t\t\t\t\tok[getid(vc[0])] = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint u = getid(vc[0]);\n\t\t\t\t\t\tint v = getid(vc[1]);\n\t\t\t\t\t\te[u].emplace_back(v);\n\t\t\t\t\t\te[v].emplace_back(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(okay) continue;\n\t\t\t\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tif(sz(e[i]) > 2) {\n\t\t\t\t\tfor(auto v : e[i]) cout << v << \' \';\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\n\t\t\tclear();\n\t\t\tL(i, 1, xn * xm) \n\t\t\t\tif(!use[i]) {\n//\t\t\t\t\tif(sz(e[i]) == 1) {\n//\t\t\t\t\t\tpush(vi{0, msk[i]}, vi{ok[i], 1});\n//\t\t\t\t\t\tcontinue; \n//\t\t\t\t\t}\n\t\t\t\t\tT.clear();\n\t\t\t\t\tgetlen(i);\n\t\t\t\t\t\t\n\t\t\t\t\tme(F, 0);\n\t\t\t\t\tF[1][0] = 1;\n\t\t\t\t\tfor(auto u : T) {\n\t\t\t\t\t\tme(G, 0);\n\t\t\t\t\t\tL(x, 0, 1) {\n\t\t\t\t\t\t\tL(y, 0, 1) if(x || y) {\n\t\t\t\t\t\t\t\tif(!ok[u] && !y) continue;\n\t\t\t\t\t\t\t\tint t = msk[u];\n\t\t\t\t\t\t\t\tif(!y) t = 0;\n\t\t\t\t\t\t\t\tL(i, 0, 15) (G[y][i | t] += F[x][i]) %= mod;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tswap(F, G);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tvi A, B;\n\t\t\t\t\tL(i, 0, 15) {\n\t\t\t\t\t\tint s = (F[0][i] + F[1][i]) % mod; \n\t\t\t\t\t\tif(s) A.emplace_back(i), B.emplace_back(s);\n\t\t\t\t\t}\n\t\t\t\t\tpush(A, B);\n//\t\t\t\t\tcout << ok[i] << \' \' << msk[i] << \'\\n\';\n//\t\t\t\t\tL(i, 0, sz(A) - 1) cout << A[i] << "" : "" << B[i] << \'\\n\';\n//\t\t\t\t\tcout << \'\\n\';\n\t\t\t\t}\n\t\t\t(ns += mod - dp[15]) %= mod;\n\t\t}\n\t}\n\tcout << ns << \'\\n\';\n} \nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t;\n\tcin >> t;\n\twhile(t--) Main();\n\treturn 0;\n} \n/*\n1\n40 40 2\n10 11\n20 23\n\n1\n40 40 2\n10 11\n11 12\n*/']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1]",3200
Vasya is a regular participant at programming contests and is already experienced in finding important sentences in long statements Of course numbers constraints are important factorization of a number less than is easier than of a number less than However sometimes it s hard to understand the number at the first glance Could it be shortened For example instead of you could write 10 6 instead of 10 9 instead of 10 9 7 Vasya decided that to be concise the notation should follow several rules the notation should only consist of numbers operations of addition multiplication and exponentiation in particular the use of braces is forbidden the use of several exponentiation operations in a row is forbidden for example writing is unacceptable the value of the resulting expression equals to the initial number the notation should consist of the minimal amount of symbols Given n find the equivalent concise notation for it ,"[""// who's it from?\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define f first\n#define s second\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n\nll n;\nvector<pair<ll,string> > po;\nmap<ll, string> mp;\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int base = 2; base <= 100000; base++) {\n\t\tll val = base;\n\t\tstring s = to_string(base) + '^';\n\t\tfor (int e = 2; val * base <= 10000000000ll; e++) {\n\t\t\tval *= base;\n\t\t\tpo.emplace_back(val, s + to_string(e));\n\t\t\tif(mp.count(val) && SZ(s + to_string(e)) < SZ(mp[val])) {\n\t\t\t\tmp[val] = s + to_string(e);\n\t\t\t} else if (!mp.count(val)) {\n\t\t\t\tmp[val] = s + to_string(e);\n\t\t\t}\n\t\t}\n\t}\n\t//for (ll n = 1; n <= 10000; n++) {\n\tstring res = to_string(n);\n\tfor (const pair<ll,string> &p : po) {\n\t\tif (n >= p.f) {\n\t\t\tif (mp.count(n - p.f)) {\n\t\t\t\tstring tmp = p.s + '+' + mp[n - p.f];\n\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\tres = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif ((n - i) % p.f == 0 && mp.count((n - i) / p.f)) {\n\t\t\t\t\tstring tmp = p.s + '*' + mp[(n - i) / p.f];\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\ttmp += '+';\n\t\t\t\t\t\ttmp += to_string(i);\n\t\t\t\t\t}\n\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (int i = 2; i < 10; i++) {\n\t\t\t\tif (p.f * i <= n) {\n\t\t\t\t\tif (mp.count(n - p.f * i)) {\n\t\t\t\t\t\tstring tmp = p.s + '*' + to_string(i) + '+' + mp[n - p.f * i];\n\t\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (n % (p.f * i) == 0) {\n\t\t\t\t\t\tif (mp.count(n / (p.f * i))) {\n\t\t\t\t\t\t\tstring tmp = p.s + '*' + to_string(i) + '*' + mp[n / (p.f * i)];\n\t\t\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring tmp = p.s;\n\t\t\tif (n - p.f != 0) {\n\t\t\t\ttmp += '+';\n\t\t\t\ttmp += to_string(n - p.f);\n\t\t\t}\n\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\tres = tmp;\n\t\t\t}\n\t\t\tll c = n / p.f;\n\t\t\tint d = 0;\n\t\t\tll asdf = c;\n\t\t\twhile (asdf) {\n\t\t\t\td++;\n\t\t\t\tasdf /= 10;\n\t\t\t}\n\t\t\tll num = 0;\n\t\t\tfor (int i = 1; i < d; i++) {\n\t\t\t\tnum = num * 10 + 9;\n\t\t\t\ttmp = to_string(num) + '*' + p.s;\n\t\t\t\tassert(n - num * p.f >= 0);\n\t\t\t\tif (n - num * p.f != 0) {\n\t\t\t\t\ttmp += '+';\n\t\t\t\t\ttmp += to_string(n - num * p.f);\n\t\t\t\t}\n\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\tres = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = to_string(c) + '*' + p.s;\n\t\t\tif (n - c * p.f != 0) {\n\t\t\t\ttmp += '+';\n\t\t\t\ttmp += to_string(n - c * p.f);\n\t\t\t}\n\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\tres = tmp;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << n << ' ';\n\tcout << res << endl;\n\t//}\n\treturn 0;\n}""]","[1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2700
Recently your friend discovered one special operation on an integer array a Choose two indices i and j i neq j Set a i a j a i a j After playing with this operation for a while he came to the next conclusion For every array a of n integers where 1 le a i le 10 9 you can find a pair of indices i j such that the total sum of a will after performing the operation This statement sounds fishy to you so you want to find a counterexample for a given integer n Can you find such counterexample and prove him wrong In other words find an array a consisting of n integers a 1 a 2 dots a n 1 le a i le 10 9 such that for all pairs of indices i j performing the operation won t decrease the total sum it will increase or not change the sum ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    ll ans[N];\n    ans[0] = 1;\n    FOR(i, 1, N) {\n        ans[i] = ans[i-1] * 3;\n        if (ans[i] > MOD-7) {\n            cout << ""NO"" << nl; return;\n        }\n    }\n    cout << ""YES"" << nl;\n    F0R(i, N) cout << ans[i] << "" "";\n    cout << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
A number is a positive integer that has exactly two different positive divisors 1 and the integer itself For example 2 3 13 and 101 are prime numbers 1 4 6 and 42 are not You are given a sequence of digits from 1 to 9 in which You are allowed to do the following operation choose any digit from the sequence and delete it Your goal is to obtain a sequence which represents a prime number Note that you cannot reorder the digits in the sequence Print the resulting sequence or report that it is impossible to perform the operations so that the resulting sequence is a prime number ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nchar wcz[nax];\n\nvoid test()\n{\n\tscanf(""%s"", wcz+1);\n\tfor (int i=1; 1; i++)\n\t{\n\t\tif (wcz[i]==\'1\')\n\t\t{\n\t\t\tprintf(""17\\n"");\n\t\t\tbreak;\n\t\t}\n\t\tif (wcz[i]==\'7\')\n\t\t{\n\t\t\tprintf(""71\\n"");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given n points with integer coordinates on a coordinate axis OX The coordinate of the i th point is x i All points coordinates are distinct and given in strictly increasing order For each point i you can do the following operation take this point and move it by 1 to the left or to the right i e you can change its coordinate x i to x i 1 or to x i 1 In other words for each point you choose separately its new coordinate For the i th point it can be either x i 1 x i or x i 1 Your task is to determine if you can move some points as described above in such a way that the new set of points forms a of integers i e for some integer l the coordinates of points should be equal to l l 1 ldots l n 1 Note that the resulting points should have coordinates You have to answer t independent test cases ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:36:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n      a[i] -= i;\n    }\n    int L = *min_element(a.begin(), a.end());\n    int R = *max_element(a.begin(), a.end());\n    cout << (R - L <= 2 ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]",1000
You are given two strings and You have to remove the minimum possible number of standing one after another characters from string in such a way that it becomes a subsequence of string It can happen that you will not need to remove any characters at all or maybe you will have to remove all of the characters from and make it empty Subsequence of string is any such string that can be obtained by erasing zero or more characters from string ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 202020\nvoid build(){\n\n}\nchar a[ N ] , b[ N ];\nint la , lb;\nvoid init(){\n  scanf( ""%s"" , a + 1 );\n  la = strlen( a + 1 );\n  scanf( ""%s"" , b + 1 );\n  lb = strlen( b + 1 );\n}\nint ndl[ N ] , ndr[ N ];\nvoid solve(){\n  int ptr = 1;\n  for( int i = 1 ; i <= lb ; i ++ ){\n    while( ptr <= la && a[ ptr ] != b[ i ] ) ptr ++;\n    ndl[ i ] = ptr;\n    if( ptr <= la ) ptr ++;\n  }\n  ptr = la;\n  for( int i = lb ; i >= 1 ; i -- ){\n    while( ptr > 0 && a[ ptr ] != b[ i ] ) ptr --;\n    ndr[ i ] = ptr;\n    if( ptr > 0 ) ptr --;\n  }\n  int ans = N , al = -1 , ar = -1;\n  for( int i = 1 ; i <= lb ; i ++ ){\n    if( ndl[ i ] <= la ){\n      if( lb - i < ans ){\n        ans = lb - i;\n        al = i; ar = lb + 1;\n      }\n    }\n    if( ndr[ i ] > 0 ){\n      if( i - 1 < ans ){\n        ans = i - 1;\n        al = 0; ar = i;\n      }\n    }\n  }\n  for( int pl = 0 , pr = 1 ; pr <= lb ; pr ++ ){\n    if( ndr[ pr ] == 0 ) continue;\n    while( pl + 1 < pr && ndl[ pl + 1 ] < ndr[ pr ] ) pl ++;\n    int bye = pr - pl - 1;\n    if( bye < ans ){\n      ans = bye;\n      al = pl; ar = pr;\n    }\n  }\n  if( ans == N )\n    puts( ""-"" );\n  else{\n    for( int i = 1 ; i <= al ; i ++ ) putchar( b[ i ] );\n    for( int i = ar ; i <= lb ; i ++ ) putchar( b[ i ] );\n    puts( """" );\n  }\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0]",2100
Today the Z city residents enjoy a shell game competition The residents are gathered on the main square to watch the breath taking performance The performer puts 3 non transparent cups upside down in a row Then he openly puts a small ball under one of the cups and starts to shuffle the cups around very quickly so that on the whole he makes exactly 3 shuffles After that the spectators have exactly one attempt to guess in which cup they think the ball is and if the answer is correct they get a prize Maybe you can try to find the ball too ,"['#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    int cup;\n    bool p[] = {false, false, false};\n    scanf(""%d"", &cup);\n    p[cup-1] = true;\n    for(int i=0; i<3; i++){\n        int a, b;\n        scanf(""%d%d"", &a, &b); a--; b--;\n        swap(p[a], p[b]);\n    }\n    for(int i=0; i<3; i++){\n        if (p[i]) {\n            printf(""%d\\n"", i+1);\n            break;\n        }\n    }\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Andrey is just starting to come up with problems and it s difficult for him That s why he came up with a strange problem about permutations dagger and asks you to solve it Can you do it Let s call the of a permutation p of length n the value of the expression Find the maximum cost among all permutations of length n dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#pragma GCC target(""sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt"")\n#if defined(LOCAL) or not defined(LUOGU)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast,unroll-loops"")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL\n#include""dbg.h""\n#define dbgu(...) dbg(__VA_ARGS__)\n#else\n#define dbg(...) (__VA_ARGS__)\n#define dbgu(...)\n#endif\nnamespace Fread{const int SIZE=1<<16;char buf[SIZE],*S,*T;inline char getchar(){if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return\'\\n\';}return *S++;}}namespace Fwrite{const int SIZE=1<<16;char buf[SIZE],*S=buf,*T=buf+SIZE;inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}inline void putchar(char c){*S++=c;if(S==T)flush();}struct NTR{~NTR(){flush();}}ztr;}\n#define getchar Fread::getchar\n#define putchar Fwrite::putchar\n#define Setprecision 15\n#define between \'\\n\'\ntemplate<typename T>struct is_char{static constexpr bool value=(std::is_same<T,char>::value||std::is_same<T,signed char>::value||std::is_same<T,unsigned char>::value);};template<typename T>struct is_integral_ex{static constexpr bool value=(std::is_integral<T>::value||std::is_same<T,__int128>::value)&&!is_char<T>::value;};template<typename T>struct is_floating_point_ex{static constexpr bool value=std::is_floating_point<T>::value||std::is_same<T,__float128>::value;};namespace Fastio{struct Reader{template<typename T>typename std::enable_if_t<std::is_class<T>::value,Reader&>operator>>(T&x){for(auto &y:x)*this>>y;return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1;while(c<\'0\'||c>\'9\'){if(c==\'-\')f*=-1;c=getchar();}x=0;while(c>=\'0\'&&c<=\'9\'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x*=f;return *this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1,s=0;x=0;T t=0;while((c<\'0\'||c>\'9\')&&c!=\'-\'&&c!=\'.\'){if(c==\'-\')f*=-1;c=getchar();}while(c>=\'0\'&&c<=\'9\'&&c!=\'.\')x=x*10+(c^48),c=getchar();if(c==\'.\')c=getchar();else return x*=f,*this;while(c>=\'0\'&&c<=\'9\')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Reader&>operator>>(T&c){c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();return *this;}Reader&operator>>(char*str){int len=0;char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str[len++]=c,c=getchar();str[len]=\'\\0\';return*this;}Reader&operator>>(std::string&str){char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str.push_back(c),c=getchar();return*this;}Reader(){}}cin;const char endl=\'\\n\';struct Writer{typedef __int128 mxdouble;template<typename T>typename std::enable_if_t<std::is_class<T>::value,Writer&>operator<<(T x){for(auto &y:x)*this<<y<<between;*this<<\'\\n\';return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Writer&>operator<<(T x){if(x==0)return putchar(\'0\'),*this;if(x<0)putchar(\'-\'),x=-x;static int sta[45];int top=0;while(x)sta[++top]=x%10,x/=10;while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Writer&>operator<<(T x){if(x<0)putchar(\'-\'),x=-x;mxdouble _=x;x-=(T)_;static int sta[45];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;putchar(\'.\');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Writer&>operator<<(T c){putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])putchar(str[cur++]);return *this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(std::string str){int st=0,ed=str.size();while(st<ed)putchar(str[st++]);return*this;}Writer(){}}cout;}\n#define cin Fastio::cin\n#define cout Fastio::cout\n#define endl Fastio::endl\n#define int long long\nmain()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>p(n);\n\t\tfor(int x=0;x<n;x++)\n\t\t\tp[x]=x;\n\t\tint ans=0;\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tint res=0,res2=0;\n\t\t\tfor(int x=0;x<n;x++)\n\t\t\t\tres+=(p[x]+1)*(x+1),res2=max(res2,(p[x]+1)*(x+1));\n\t\t\tans=max(ans,res-res2);\n\t\t\tif(i!=0)reverse(p.begin()+i,p.end()),reverse(p.begin()+i-1,p.end());\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}']","[1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You are playing a very popular game called Cubecraft Initially you have one stick and want to craft k torches One torch can be crafted using Hopefully you ve met a very handsome wandering trader who has two trade offers exchange 1 stick for x sticks you lose 1 stick and gain x sticks exchange y sticks for 1 coal you lose y sticks and gain 1 coal During one trade you can use of these two trade offers You can use each trade offer any number of times you want to in any order Your task is to find the minimum number of trades you need to craft at least k torches The answer always exists under the given constraints You have to answer t independent test cases ,"[""#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nint T;\nsigned main(){\n\trd(T);\n\twhile(T--){\n\t\tint x,y,k;rd(x),rd(y),rd(k);\n\t\t--x;\n\t\tpt(max(0LL,(k+y*k+x-1-1)/x+k),'\\n');\n\t}\n\treturn 0;\n}\n""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
You are given a directed graph consisting of vertices and edges The vertices and are marked as source and sink correspondingly Additionally there are no edges ending at and there are no edges beginning in The graph was constructed in a following way initially each edge had capacity A maximum flow with source at and sink at was constructed in this flow network Let s denote as the value of flow passing through edge with index Next all capacities and flow value were erased Instead indicators were written on edges if flow value passing through edge was positive i e if and otherwise Using the graph and values find out what is the possible number of edges in the initial flow network that could be saturated the passing flow is equal to capacity i e Also construct the corresponding flow network with maximum flow in it A flow in directed graph is described by flow values on each of the edges so that the following conditions are satisfied for each vertex except source and sink total incoming flow and total outcoming flow are equal for each edge A flow is maximum if the difference between the sum of flow values on edges from the source and the sum of flow values on edges to the source there are no such in this problem is maximum possible ,"['#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\n// ========================================================================= //\nnamespace dinic {\n    int const INF = 100 + (int) 1e9;\n    ll const INFL = 100 + (ll) 1e18;\n    int const N = 200200;\n\n    struct edge_t {\n        int to, cap, flow;\n        \n        edge_t(int to, int cap)\n            : to(to)\n            , cap(cap)\n            , flow(0)\n        {}\n    };\n\n    vector<edge_t> all;\n    vector<int> g[N];\n    int index[N], dist[N];\n\n    void add_edge(int from, int to, int cap1, int cap2) {\n        g[from].push_back(all.size());\n        all.emplace_back(to, cap1);\n        g[to].push_back(all.size());\n        all.emplace_back(from, cap2);\n    }\n\n    void init_graph(int n) {\n        all.clear();\n        for (int i = 0; i < n; ++i) {\n            g[i].clear();\n        }\n    }\n\n    void clear_flow() {\n        for (auto& edge : all) {\n            edge.flow = 0;\n        }\n    }\n\n    int dfs(int v, int sink, int flow) {\n        if (v == sink || flow == 0) {\n            return flow;\n        }\n        for (int& i = index[v]; i < (int)g[v].size(); ++i) {\n            int x = g[v][i];\n            auto& e = all[x];\n            int to = e.to;\n            int diff = e.cap - e.flow;\n            if (diff > 0 && dist[v] - 1 == dist[to]) {\n                int now = dfs(to, sink, min(flow, diff));\n                if (now > 0) {\n                    e.flow += now;\n                    all[x ^ 1].flow -= now;\n                    return now;\n                }\n            }\n        }\n        return 0;\n    }\n\n    ll max_flow(int source, int sink, int n) {\n        clear_flow();\n        ll ret = 0;\n        while (true) {\n            static int q[N];\n            memset(dist, 63, sizeof(int) * n);\n            int tail = 0;\n            dist[q[tail++] = sink] = 0;\n            for (int i = 0; i < tail; ++i) {\n                int v = q[i];\n                for (int x : g[v]) {\n                    int to = all[x].to;\n                    if (all[x ^ 1].flow < all[x ^ 1].cap && dist[to] > INF) {\n                        dist[q[tail++] = to] = dist[v] + 1;\n                    }\n                }\n            }\n            if (dist[source] > INF) {\n                break;\n            }\n            memset(index, 0, n * sizeof(int));\n            while (int flow = dfs(source, sink, INF)) {\n                ret += flow;\n            }\n        }\n        return ret;\n    }\n}\n\n//void add_edge(int from, int to, int cap1, int cap2) {\n//void init_graph(int n) {\n//ll max_flow(int source, int sink, int n) {\n\nconst int N = 111;\n\nstruct Edge {\n    bool g;\n    int x, y;\n    int cap = 0, flow = 0;\n};\n\nint n, m, s1, s2;\nvector < int > e[N], eb[N];\nvector < Edge > es;\n\nbool vis[N];\nbool vis11[N];\n\nvoid dfs1(int v) {\n    if (vis11[v])\n        return;\n    vis11[v] = true;\n    for (int i : dinic::g[v]) {\n        dinic::edge_t edge = dinic::all[i];\n        if (edge.cap != edge.flow)\n            dfs1(edge.to);\n    }\n}\n\nbool dfs2(int v, int fin) {\n    if (v == fin)\n        return true;\n    if (vis[v])\n        return false;\n    vis[v] = true;\n    for (int i : e[v]) {\n        Edge &ee = es[i];\n        if (!ee.g)\n            continue;\n        ++ee.cap;\n        ++ee.flow;\n        if (dfs2(ee.y, fin))\n            return true;\n        --ee.cap;\n        --ee.flow;\n    }\n    return false;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    scanf(""%d%d%d%d"", &n, &m, &s1, &s2);\n    --s1; --s2;\n    dinic::init_graph(n);\n    for (int i = 0; i < m; ++i) {\n        int x, y, g;\n        scanf(""%d%d%d"", &x, &y, &g);\n        --x;\n        --y;\n        e[x].push_back(sz(es));\n        Edge ce;\n        ce.x = x;\n        ce.y = y;\n        ce.g = g;\n        es.push_back(ce);\n        if (g) {\n            dinic::add_edge(x, y, 1, 0);\n            dinic::add_edge(y, x, dinic::INF, 0);\n        } else {\n            dinic::add_edge(x, y, dinic::INF, 0);\n        }\n    }\n\n    int flw = dinic::max_flow(s1, s2, n);\n\n    dfs1(s1);\n    for (Edge &ee : es) {\n        if (ee.g) {\n            ++ee.flow;\n            ++ee.cap;\n            memset(vis, 0, sizeof(vis));\n            dfs2(s1, ee.x);\n            memset(vis, 0, sizeof(vis));\n            dfs2(ee.y, s2);\n            if (!(vis11[ee.x] && !vis11[ee.y])) {\n                ++ee.cap;\n            }\n        } else\n            ee.cap = 1;\n    }\n\n    cout << flw << ""\\n"";\n    for (Edge const& ee : es)\n        cout << ee.flow << "" "" << ee.cap << ""\\n"";\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",3000
year in Berland is such a year that its number can be represented as where and are non negative integer numbers For example if and then the years and are and year isn t as there is no such representation for it Such interval of years that there are no years in it is called You should write a program which will find maximum length of which starts no earlier than the year and ends no later than the year If all years in the interval are then the answer is ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<long long> v;\nint main()\n{\n\tlong long x,y,l,r,i,j,ans=0;\n\tscanf(""%I64d%I64d%I64d%I64d"",&x,&y,&l,&r);\n\tv.push_back(l-1);v.push_back(r+1);\n\tfor(i=1;;i*=x)\n\t{\n\t\tfor(j=1;;j*=y)\n\t\t{\n\t\t\tif(i+j>=l&&i+j<=r)v.push_back(i+j);\n\t\t\tif(j>r/y)break;\n\t\t}\n\t\tif(i>r/x)break;\n\t}\n\tsort(v.begin(),v.end());\n\tfor(i=1;i<v.size();++i)ans=max(ans,v[i]-v[i-1]-1);\n\tprintf(""%I64d"",ans);\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1800
While Mike was walking in the subway all the stuff in his back bag dropped on the ground There were several fax messages among them He concatenated these strings in some order and now he has string He is not sure if this is his own back bag or someone else s He remembered that there were exactly messages in his own bag each was a string and all those strings had the same length He asked you to help him and tell him if he has worn his own back bag Check if the given string is a concatenation of of the same length ,"['#include <bits/stdc++.h>\n#include <ext/algorithm>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\n#define ALL(c) c.begin(), c.end()\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define DB(a) cerr << #a << "" = "" << (a) << endl;\n#define OUT( a , n ) for( int J = 0; J < (n); J++ )cout<< (a)[J] << "" \\n""[J == (n) - 1 ]\n#define WAIT cout << flush , system(""PAUSE"");\n#define lowbit(x) ((x) & (-x))\n#define CONTAINS(a, x) ((a).find(x) != (a).end())\n#define endl \'\\n\'\n\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 2000;\nchar s[ MAXN ];\nint rad[ 2 * MAXN ];\n\nvoid Manacher()\n{\n   int size = strlen( s );\n   /* Manacher\'s Algorithm */\n\n   int i , j , k;\n\n    for ( i = j = 0; i < 2 * size - 1; i += k ) {\n\n      while ( i - j >= 0 && i + j + 1 < 2 * size &&\n              s[ ( i - j ) / 2 ] == s[ ( i + j + 1 ) / 2 ] )\n                j++;\n\n      rad[i] = j;\n      for ( k = 1; k <= rad[i] && rad[ i - k ] != rad[i] - k; k++ )\n        rad[ i + k ] = min( rad[ i - k ], rad[i] - k );\n\n      j = max( j - k, 0 );\n    }\n}\n\nbool isPal(int i , int j ) \n{\n    return rad[i + j] >= j - i + 1;\n}\n\nint k;\n\nint main()\n{\n    ios::sync_with_stdio( 0 );\n    cin.tie( 0 );\n    \n    cin >> s;\n    int len = strlen(s);\n    \n    Manacher();\n    cin >> k;\n    \n    if(len % k != 0)\n    {\n        cout << ""NO\\n"";\n        return 0;\n    }\n    \n    \n    \n    int sz = len / k;\n    \n    int ini = 0;\n    for( int i = 0; i < k; i++ )\n    {\n        //cout << ini << "" "" << ini + sz - 1 << endl;;\n        if( !isPal(ini , ini + sz - 1))\n        {\n            cout << ""NO\\n"";\n            return 0;\n        }\n        ini += sz;  \n    }\n    \n    cout << ""YES\\n"";\n    return 0;\n        \n    \n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]",1100
You have a permutation an array a a 1 a 2 ldots a n of distinct integers from 1 to n The length of the permutation n is odd You need to sort the permutation in increasing order In one step you can choose any prefix of the permutation with an odd length and reverse it Formally if a a 1 a 2 ldots a n you can choose any odd integer p between 1 and n inclusive and set a to a p a p 1 ldots a 1 a p 1 a p 2 ldots a n Find a way to sort a using no more than frac 5n 2 reversals of the above kind or determine that such a way doesn t exist The number of reversals doesn t have to be minimized ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor(int& x : a){\n\t\tcin >> x;\n\t\tx--;\n\t}\n\tvector<int> res;\n\twhile(n > 1){\n\t\tint x = n-2;\n\t\tint y = n-1;\n\t\tint lx = 0;\n\t\tint ly = 0;\n\t\tauto set_val = [&](){\n\t\t\tlx = 0;\n\t\t\tly = 0;\n\t\t\twhile(a[lx] != x) lx++;\n\t\t\twhile(a[ly] != y) ly++;\n\t\t};\n\t\tset_val();\n\t\tif(((x - lx) & 1) || ((y - ly) & 1)){\n\t\t\tcout << -1 << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tres.push_back(ly + 1);\n\t\treverse(a.begin(), a.begin() + ly + 1);\n\t\tset_val();\n\t\tres.push_back(lx);\n\t\treverse(a.begin(), a.begin() + lx);\n\t\tset_val();\n\t\tres.push_back(lx + 2);\n\t\treverse(a.begin(), a.begin() + lx + 2);\n\t\tset_val();\n\t\tres.push_back(3);\n\t\treverse(a.begin(), a.begin() + 3);\n\t\tres.push_back(n);\n\t\treverse(a.begin(), a.begin() + n);\n\t\tn -= 2;\n\t}\n\tcout << res.size() << '\\n';\n\tfor(int r : res){\n\t\tcout << r << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Given 2 integers u and v find the shortest array such that bitwise xor of its elements is u and the sum of its elements is v ,"['///BE NAME KHODA\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define S second\n#define F first\n#define int long long\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxn = 3e5+10;\nconst int mod = 1e9+7;\nconst ll inf = 1e18+10;\n\nll n, m, x, s;\nll cnt[70];\n\nsigned main()\n{\n    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin>> x >> s;\n    if(x % 2 != s % 2) return cout<< -1, 0;\n    if(x > s) return cout<< -1, 0;\n\n    if(x == 0 && s == 0)\n        return cout<< 0, 0;\n\n    int X = x, S = s;\n    if(x == s)\n    {\n        cout<< 1 <<""\\n""<< x;\n        return 0;\n    }\n\n    /// 2\n    for(int i = 0; i < 60; i++)\n        if(x&(1ll<<i))\n            s -= (1ll<<i);\n        else\n          cnt[i+1] = 1;\n\n    bool T = 1;\n    for(int i = 0; i < 60; i++)\n        if((s & (1ll<<i)) && !cnt[i])\n            T = 0;\n\n    if(T)\n    {\n        cout<< 2 <<""\\n"";\n        int a = x, b = 0;\n        for(int i = 0; i < 60; i++)\n            if(s & (1ll<<i))\n            {\n                a += (1ll<<(i-1));\n                b += (1ll<<(i-1));\n            }\n        cout<< a <<"" ""<< b;\n        return 0;\n    }\n\n    x = X, s = S;\n    int a = x, b = 0, c = 0;\n    s -= x;\n    for(int i = 0; i < 60; i++)\n        if(s & (1ll<<i))\n        {\n            b += (1ll<<(i-1));\n            c += (1ll<<(i-1));\n        }\n    cout<< 3 <<""\\n""<< a <<"" ""<< b <<"" ""<< c;\n}\n\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1700
You are given a matrix a of size n times m consisting of integers You can choose left lfloor frac m 2 right rfloor elements in Your task is to choose these elements in such a way that their sum is k and this sum is the In other words you can choose no more than a half rounded down of elements in each row you have to find the maximum sum of these elements divisible by k Note that you can choose zero elements and the sum of such set is 0 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint hmt() {int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c==\'-\');for(;isdigit(c);c=getchar()) x=x*10+c-\'0\';if(n) x=-x;return x;}\n#define in hmt()\n#define ins ({string x;char c=getchar();for(;c==\' \'||c==\'\\n\';c=getchar());for(;c!=\' \'&&c!=\'\\n\';c=getchar()) x+=c;x;})\n#define forinc(i,a,b) for(int i=a,_b=b;i<=_b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forb(i,BS) for(int i=BS._Find_first();i< BS.size();i = BS._Find_next(i))\n#define timer 1.0*clock()/CLOCKS_PER_SEC\n#define forv(a,b) for(auto &a:b)\n#define pb push_back\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define all(a) a.begin(),a.end()\n#define reset(f,x) memset(f,x,sizeof(f))\n#define bit(x,i) ((x>>(i-1))&1)\n#define onbit(x,i) (x|(1<<(i-1)))\n#define offbit(x,i) (x&~(1<<(i-1)))\nconst int N=75;\nint m,n,k,a[N][N],f[N][N][N][N];\nvoid maxi(int &a,int b)\n{\n    a=max(a,b);\n}\nint main()\n{\n    //freopen(""1433F.inp"",""r"",stdin);\n    m=in,n=in,k=in;\n    forinc(i,1,m) forinc(j,1,n) a[i][j]=in;\n    reset(f,-1);\n    f[1][0][0][0]=0;\n    forinc(i,1,m)\n    {\n        forinc(j,1,n) forinc(t,0,min(j-1,n/2)) forinc(c,0,k-1) if(f[i][j-1][t][c]!=-1)\n        {\n            maxi(f[i][j][t][c],f[i][j-1][t][c]);\n            maxi(f[i][j][t+1][(c+a[i][j])%k],f[i][j-1][t][c]+a[i][j]);\n        }\n        forinc(t,0,n/2) forinc(c,0,k-1) maxi(f[i+1][0][0][c],f[i][n][t][c]);\n    }\n    cout<<f[m+1][0][0][0]<<""\\n"";\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Given an array a of length n and an integer k find the number of indices 1 leq i leq n k such that the subarray a i dots a i k with length k 1 with length k has the following property If you multiply the first element by 2 0 the second element by 2 1 and the k 1 st element by 2 k then this subarray is sorted in strictly increasing order More formally count the number of indices 1 leq i leq n k such that 2 0 cdot a i 2 1 cdot a i 1 2 2 cdot a i 2 dots 2 k cdot a i k ,"['//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << \' \' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << \'\\n\';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << \' \' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK ""G""\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK "".in"", ""r"", stdin);\n    freopen(TASK "".out"", ""w"", stdout);\n#endif\n\n    int t;\n    cin >> t;\n    while(t--) {\n        int n, k;\n        cin >> n >> k;\n        vector<int> a(n);\n        cin >> a;\n        vector<int> ok(n);\n        for(int i = 1; i < n; ++i)\n            ok[i] = (a[i] * 2 > a[i - 1]);\n        vector<int> pref(n + 1, 0);\n        for(int i = 0; i < n; ++i)\n            pref[i + 1] = pref[i] + ok[i];\n        int ans = 0;\n        for(int i = 0; i + k <= n; ++i)\n            ans += (pref[i + k] - pref[i] == k);\n        cout << ans << endl;\n    }\n}']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1400
You are given a rooted tree consisting of n vertices Vertices are numbered from 1 to n Any vertex can be the root of a tree A is a connected undirected graph without cycles A is a tree with a selected vertex which is called the The tree is specified by an array of parents p containing n numbers p i is a parent of the vertex with the index i The of a vertex u is a vertex that is the next vertex on the shortest path from u to the root For example on the simple path from 5 to 3 the root the next vertex would be 1 so the parent of 5 is 1 The root has no parent so for it the value of p i is i the root is the only vertex for which p i i Find such a set of paths that each vertex belongs to exactly one path each path can contain one or more vertices in each path each next vertex is a son of the current vertex that is paths always lead down from parent to son number of paths is For example if n 5 and p 3 1 3 3 1 then the tree can be divided into three paths 3 rightarrow 1 rightarrow 5 path of 3 vertices 4 path of 1 vertices 2 path of 1 vertices ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\ninline int reads(char* s){\n\tint t = 0;\n\tregister char c = getchar();\n\twhile (c != \'1\' && c != \'0\' && c != \'?\') c = getchar();\n\twhile (c == \'1\' || c == \'0\' || c == \'?\') s[++t] = c,c = getchar();\n\treturn t;\n}\n\nconst int N = 2e5;\nint T,rt,n,ans,etot,stop,fa[N + 1],indeg[N + 1],head[N + 1],stk[N + 1];\n\nstruct Edge{\n\tint u,v,next;\n}e[(N << 1) + 1];\n\nvoid adde(int u,int v) {e[++etot] = (Edge){u,v,head[u]},head[u] = etot;}\n\nvoid dfs(int now,int f){\n\tstk[++stop] = now;\n\tif (!indeg[now]){\n\t\tprintf(""%d\\n"",stop);\n\t\tfor (int i = 1;i <= stop;i++) printf(""%d "",stk[i]);\n\t\tputchar(\'\\n\');\n\t\tstop = 0;\n\t\treturn ;\n\t}\n\tfor (int i = head[now];i;i = e[i].next){\n\t\tif (e[i].v == f) continue;\n\t\tdfs(e[i].v,now);\n\t}\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\tn = read();\n\t\tans = stop = etot = 0;\n\t\tfor (int i = 1;i <= n;i++) indeg[i] = 0,fa[i] = 0,head[i] = 0;\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tfa[i] = read();\n\t\t\tif (fa[i] != i) ++indeg[fa[i]],adde(i,fa[i]),adde(fa[i],i);\n\t\t\telse rt = i;\n\t\t}\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tif (!indeg[i]) ++ans;\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t\tdfs(rt,0);\n\t\tputchar(\'\\n\');\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",1300
Devu is a renowned classical singer He is invited to many big functions festivals Recently he was invited to All World Classical Singing Festival Other than Devu comedian Churu was also invited Devu has provided organizers a list of the songs and required time for singing them He will sing songs song will take minutes exactly The Comedian Churu will crack jokes All his jokes are of 5 minutes exactly People have mainly come to listen Devu But you know that he needs rest of 10 minutes after each song On the other hand Churu being a very active person doesn t need any rest You as one of the organizers should make an optimal s hedule for the event For some reasons you must follow the conditions The duration of the event must be no more than minutes Devu must complete all his songs With satisfying the two previous conditions the number of jokes cracked by Churu should be as many as possible If it is not possible to find a way to conduct all the songs of the Devu output 1 Otherwise find out maximum number of jokes that Churu can crack in the grand event ,"['#include<iostream>\n#include<cstdio>\n#include<set>\n#include<stack>\n#define ROF(a,b,c) for(int a=b;a>=c;--a)\n#include<vector>\n#include<algorithm>\n#define FOR(a,b,c) for(int a=b;a<=c;++a)\n#include<cstring>\n#include<bitset>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#define debug cerr<<""OK"";\n#define f cin\n#define g cout\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define ll long long\n#define mod 1000000007\n#define inf (1LL<<60)\n#define N 300\n#define DIM 1000100\n#define pct pair<long double,long double>\nusing namespace std;\n/*ifstream f(""a.in"");\nofstream g(""a.out"");*/\n//int dx[]={0,0,0,1,-1};\n//int dy[]={0,1,-1,0,0};\nint n,t,nrj,ti,i;\nint main ()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(""a.in"",""r"",stdin);\n    freopen(""a.out"",""w"",stdout);\n    #endif\n    \n    f>>n>>t;\n    FOR(i,1,n)\n    {\n        f>>ti;\n        t-=ti;\n    }\n    nrj+=(n-1)*2;\n    t-=(n-1)*10;\n    if(t>=0)\n    {\n        nrj+=t/5;\n        g<<nrj;\n    }\n    else\n        g<<""-1"";\n    return 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
The forest where our characters entertain themselves may be represented as a set of integer cells in the plane where the Shadow and the Princess can move only up down left and right by Some cells as it happens in decent forests are occupied by trees The Shadow and the Princess are not allowed to enter a cell occupied by a tree Unfortunately these are the hard times for the forest so there are very few trees growing here At first the Princess was walking within the cell while the Shadow hid from the Princess in the cell The Princess The Shadow and the trees are located in the different cells The Shadow is playing with the Princess As soon as the Princess moves by in some direction the Shadow simultaneously flies by in the same direction if it is possible if the cell to fly to is not occupied by some tree otherwise the Shadow doesn t move The Shadow is very shadowy so our characters do not interfere with each other We say that the Shadow is caught by the Princess if after some move both of them are located in the same cell Vlada managed to catch her Shadow Can you ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<functional>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<sstream>\nusing namespace std;\n// }}}\n// #defines {{{\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,a,b) for(int i=(a);i<=(b);i++)\n#define REPL(i,x) for(int i=0;x[i];i++)\n#define PER(i,n) for(int i=(n)-1;i>=0;i--)\n#define PER1(i,a,b) for(int i=(a);i>=(b);i--)\n#define RI(x) scanf(""%d"",&x)\n#define DRI(x) int x;RI(x)\n#define RII(x,y) scanf(""%d%d"",&x,&y)\n#define DRII(x,y) int x,y;RII(x,y)\n#define RIII(x,y,z) scanf(""%d%d%d"",&x,&y,&z)\n#define DRIII(x,y,z) int x,y,z;RIII(x,y,z)\n#define RS(x) scanf(""%s"",x)\n#define PI(x) printf(""%d\\n"",x)\n#define PIS(x) printf(""%d "",x)\n#define CASET int ___T,cas=1;scanf(""%d "",&___T);while(___T--)\n#define CASEN0(n) int cas=1;while(scanf(""%d"",&n)!=EOF&&n)\n#define CASEN(n) int cas=1;while(scanf(""%d"",&n)!=EOF)\n#define MP make_pair\n#define PB push_back\n#define MS0(x) memset(x,0,sizeof(x))\n#define MS1(x) memset(x,-1,sizeof(x))\n#define SEP(x) ((x)?\'\\n\':\' \')\n#define F first\n#define S second\n#ifdef ONLINE_JUDGE\n#define FILEIO(x) freopen(#x "".in"",""r"",stdin);freopen(#x "".out"",""w"",stdout);\n#define FILEIOS freopen(""input.txt"",""r"",stdin);freopen(""output.txt"",""w"",stdout);\n#else\n#define FILEIO(x) ;\n#define FILEIOS ;\n#endif\ntypedef pair<int,int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n// }}}\n\nint vx,vy,sx,sy;\nint mid=110;\nint que[41000][2],qs,qe;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nset<PII> rock;\ninline bool ins(int x,int y){return x<=110&&x>=-110&&y<=110&&y>=-110;}\nset<PII> vis;\nvector<int> mv;\nvector<int> ans;\ninline bool dfs(int sx,int sy){\n    if(vis.count(MP(sx,sy)))return 0;\n    vis.insert(MP(sx,sy));\n    REP(i,4){\n        int xx=sx+dx[i],yy=sy+dy[i];\n        if(rock.count(MP(xx,yy)))continue;\n        if(!ins(xx,yy))return 1;\n        if(dfs(xx,yy))return 1;\n    }\n    return 0;\n}\ninline bool to(int sx,int sy,int tx,int ty){\n    if(sx==tx&&sy==ty)return 1;\n    if(vis.count(MP(sx,sy)))return 0;\n    vis.insert(MP(sx,sy));\n    REP(i,4){\n        int xx=sx+dx[i],yy=sy+dy[i];\n        if(rock.count(MP(xx,yy)))continue;\n        if(!ins(xx,yy))return 0;\n        mv.PB(i);\n        if(to(xx,yy,tx,ty))return 1;\n        mv.pop_back();\n    }\n    return 0;\n}\ninline void move(int d){\n    ans.PB(d);\n    vx+=dx[d];\n    vy+=dy[d];\n    if(!rock.count(MP(sx+dx[d],sy+dy[d]))){\n        sx+=dx[d];sy+=dy[d];\n    }\n}\ninline void move(int d,int c){\n    while(c--)move(d);\n}\ninline void move(const vector<int>& seq){\n    REP(i,SZ(seq))move(seq[i]);\n}\nint main(){\n    RII(vx,vy);\n    RII(sx,sy);\n    DRI(m);\n    if(m==0){\n        puts(""-1"");\n        return 0;\n    }\n    while(m--){\n        DRII(x,y);\n        rock.insert(MP(x,y));\n    }\n    vis.clear();\n    if(dfs(vx,vy)){//open\n        vis.clear();\n        if(!dfs(sx,sy)){\n            puts(""-1"");\n            return 0;\n        }\n        vis.clear();mv.clear();\n        to(vx,vy,110,110);\n        move(mv);\n        move(0,1000);\n        move(1,1000);\n        if(ins(sx,sy)){\n            vis.clear();mv.clear();\n            to(sx,sy,110,110);\n            move(mv);\n        }\n        move(0,1000);\n        move(1,1000);\n        PII maxx=*rock.begin(),\n            minx=*rock.begin(),\n            maxy=*rock.begin(),\n            miny=*rock.begin();\n        FOR(it,rock){\n            if(it->F>maxx.F)maxx=*it;\n            if(it->F<minx.F)minx=*it;\n            if(it->S>maxy.S)maxy=*it;\n            if(it->S<miny.S)miny=*it;\n        }\n        if(vx>sx){\n            while(sy>maxx.S)move(3);\n            while(vx>sx)move(2);\n            move(0,1000);\n            move(1,1000);\n        }else{\n            while(sx>-200)move(2);\n            while(sy>minx.S)move(3);\n            while(vx<sx)move(0);\n            move(1,2000);\n            move(0,2000);\n        }\n        if(vy>sy){\n            while(sx>maxy.F)move(2);\n            while(vy>sy)move(3);\n        }else{\n            while(sy>-200)move(3);\n            while(sx>miny.F)move(2);\n            while(vy<sy)move(1);\n        }\n    }else{\n        vis.clear();mv.clear();\n        if(!to(vx,vy,sx,sy)){\n            puts(""-1"");\n            return 0;\n        }\n        while(vx!=sx||vy!=sy){\n            vis.clear();mv.clear();\n            to(vx,vy,sx,sy);\n            move(mv);\n        }\n    }\n    REP(i,SZ(ans))printf(""%c"",""RULD""[ans[i]]);\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3100
You have an array a 1 a 2 dots a n consisting of n integers You are allowed to perform the following operation on it Choose two elements from the array a i and a j i ne j such that gcd a i a j is not present in the array and add gcd a i a j to the end of the array Here gcd x y denotes greatest common divisor GCD of integers x and y Note that the array changes after each operation and the subsequent operations are performed on the new array What is the number of times you can perform the operation on the array ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((int)(x).size())\n#define each(x,v) for(auto&x:v)\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nconst int N=1000005;\nint n,a[N],b[N];\nint main(){\n\tscanf(""%d"",&n);\n\trep(i,1,n)scanf(""%d"",&a[i]),++b[a[i]];\n\tint ans=0;\n\trep(i,1,1000000)if(!b[i]){\n\t\tint g=0;\n\t\tfor(int j=i,k=1;j<=1000000;j+=i,++k){\n\t\t\tif(b[j])g=__gcd(g,k);\n\t\t}\n\t\tif(g==1){\n\t\t\t++ans;\n\t\t}\n\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']","[0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]",1900
You are given four integers a b x and y Initially a ge x and b ge y You can do the following operation n times Choose either a or b and decrease it by one However as a result of this operation value of a cannot become less than x and value of b cannot become less than y Your task is to find the possible product of a and b a cdot b you can achieve by applying the given operation no more than n times You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\nconst ll NN = 2e5 + 5;\nll t;\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n    \tll a, b, x, y, n;\n    \tcin >> a >> b >> x >> y >> n;\n    \tll a2, b2, n2;\n    \tll awal = min(n, a - x);\n    \tll awal2 = min(n, b - y);\n    \ta -= awal;\n    \tn -= awal;\n    \tb2 = b - awal2;\n    \tn2 = n - awal2;\n\n    \tll akhir = min(n, b - y);\n    \tll akhir2 = min(n2, a - x);\n    \tb -= akhir;\n    \tn -= akhir;\n    \ta2 = a - akhir2;\n    \tn2 = n2 - akhir2;\n    \t// cout << a << "" "" << b << "" "" << n << ""\\n"";\n    \ta *= b;\n    \ta2 *= b2;\n    \tcout << min(a, a2) << ""\\n"";\n    }\n}   ']","[1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Slavic has an array of length n consisting only of zeroes and ones In one operation he removes either the first or the last element of the array What is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to s after performing all the operations In case the sum s can t be obtained after any amount of operations you should output ,"['//\n// Created by Vladimir Zvezdin on 14.06.2022.\n//\n\n#                                                                                                                       include                                                                                                                                                                   <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, pair<T1, T2> &p) {\n    out << p.first << \' \' << p.second;\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &in, pair<T1, T2> &p) {\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, vector<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &in, vector<T> &arr) {\n    for (auto &i: arr) in >> i;\n    return in;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, set<T> &arr) {\n    for (auto &i: arr) out << i << \' \';\n    return out;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, map<T1, T2> &arr) {\n    for (auto &i: arr) out << i << \'\\n\';\n    return out;\n}\n\nvoid dbg_out() { cerr << endl; }\n\ntemplate<typename Head, typename... Tail>\nvoid dbg_out(Head H, Tail... T) {\n    cerr << \' \' << H;\n    dbg_out(T...);\n}\n\ntypedef long long ll;\ntypedef long long ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define ff first\n#define ss second\n#define all(x) x.begin(), x.end()\n\nvoid solve();\n\n//#define TASK ""E""\n\nint32_t main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n#ifdef TASK\n    freopen(TASK "".in"", ""r"", stdin);\n    freopen(TASK "".out"", ""w"", stdout);\n#endif\n\n    int t;\n    cin >> t;\n    while (t--) {\n        int n, s;\n        cin >> n >> s;\n        vector<int> a(n);\n        cin >> a;\n        if (accumulate(all(a), 0) < s) {\n            cout << ""-1\\n"";\n            continue;\n        }\n        vector<int> pref(n + 1, 0);\n        for (int i = 0; i < n; ++i)\n            pref[i + 1] = pref[i] + a[i];\n        int ans = n;\n        for (int i = 0; i < n; ++i) {\n            if (pref[n] - pref[i] < s) break;\n            int j = upper_bound(all(pref), pref[i] + s) - pref.begin();\n            ans = min(ans, i + n - j + 1);\n        }\n        cout << ans << endl;\n    }\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1200
Drazil is playing a math game with Varda Let s define for positive integer as a product of factorials of its digits For example First they choose a decimal number consisting of digits that contains at least one digit larger than This number may possibly start with leading zeroes Then they should find maximum positive number satisfying following two conditions 1 doesn t contain neither digit nor digit 2 Help friends find such number ,"['#include <iostream>\nusing namespace std;\nint p[10];\nvoid go(int x, int sign)\n{\n\tfor (int i = 2; i < 10; i++)\n\t\twhile (x % i == 0)\n\t\t{\n\t\t\tx /= i;\n\t\t\tp[i] += sign;\n\t\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tint val = 1;\n\t\tint f = c - \'0\';\n\t\tfor (int j = 1; j <= f; j++)\n\t\t\tval *= j;\n\t\tgo(val, 1);\n\t}\n\tstring ans = """";\n\tfor (int i = 9; i >= 2; i--)\n\t\twhile (p[i] > 0)\n\t\t{\n\t\t\tans += char(i + \'0\');\n\t\t\tint val = 1;\n\t\t\tfor (int j = 1; j <= i; j++)\n\t\t\t\tval *= j;\n\t\t\tgo(val, -1);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']","[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Let n be a positive integer Let a b c be nonnegative integers such that a b c n Alice and Bob are gonna play rock paper scissors n times Alice knows the sequences of hands that Bob will play However Alice has to play rock a times paper b times and scissors c times Alice wins if she beats Bob in at least lceil frac n 2 rceil frac n 2 rounded up to the nearest integer hands otherwise Alice loses Note that in rock paper scissors rock beats scissors paper beats rock scissors beat paper The task is given the sequence of hands that Bob will play and the numbers a b c determine whether or not Alice can win And if so find any possible sequence of hands that Alice can use to win If there are multiple answers print any of them ,"['#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int T; scanf(""%d"", &T); while(T--)\n    {\n        int N, a, b, c;\n        char str[999];\n        char ans[999];\n        int cnt = 0;\n        scanf(""%d%d%d%d%s"", &N, &a, &b, &c, str);\n        for(int i=0; i<N; ++i)\n        {\n            ans[i] = \'?\';\n            if(str[i]==\'R\' && b) --b,ans[i] = \'P\',++cnt;\n            if(str[i]==\'P\' && c) --c,ans[i] = \'S\',++cnt;\n            if(str[i]==\'S\' && a) --a,ans[i] = \'R\',++cnt;\n        }\n        if(cnt <(N+1)/2)\n        {\n            puts(""NO"");\n            continue;\n        }\n        for(int i=0; i<N; ++i)\n        {\n            if(ans[i] != \'?\') continue;\n            if(a) ans[i] = \'R\',--a;\n            else if(b) ans[i] = \'P\',--b;\n            else if(c) ans[i] = \'S\',--c;\n            \n        }\n        ans[N] = 0;\n        puts(""YES"");\n        puts(ans);\n    }    \n}']","[1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
In this problem at each moment you have a set of intervals You can move from interval from our set to interval from our set if and only if Also there is a path from interval from our set to interval from our set if there is a sequence of successive moves starting from so that we can reach Your program should handle the queries of the following two types add the new interval to the set of intervals The length of the new interval is guaranteed to be strictly greater than all the previous intervals answer the question is there a path from th one based added interval to th one based added interval Answer all the queries Note that initially you have an empty set of intervals ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n\n\nusing namespace std;\n\n#ifdef WIN32\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nll rdtsc() {\n    ll tmp;\n    asm(""rdtsc"" : ""=A""(tmp));\n    return tmp;\n}\n\ninline int myrand() {\n\treturn abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n\treturn myrand() % x;\n}\n\n#define TASKNAME ""text""\n#define pb push_back\n#define mp make_pair\n#define EPS (1e-9)\n#define INF ((int)1e9)\n#define sqr(x) ((x) * (x))         \n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n\nconst int maxn = (int)1e5;\nint pr[maxn], w[maxn];\npair<int, int> segms[maxn + 1];\nint xVals[maxn + 1];\n\nstruct Node {\n\tint x;\n\tint y;\n\n\tNode *l, *r;\n\n\tint maxr;\n\n\tNode(int _x) : x(_x), y(myrand()), l(0), r(0) {update();}\n\n\tinline Node* update() {\n\t\tmaxr = segms[x].second;\n\t\tif (l && l->maxr > maxr)\n\t\t\tmaxr = l->maxr;\n\t\tif (r && r->maxr > maxr)\n\t\t\tmaxr = r->maxr;\n\t\treturn this;\n\t}\n} *root;\n\nstruct xComp {\n\tinline bool operator () (const int x1, const int x2) {\n\t\tif (segms[x1].first != segms[x2].first)\n\t\t\treturn segms[x1].first < segms[x2].first;\n\t\tif (segms[x1].second != segms[x2].second)\n\t\t\treturn segms[x1].second > segms[x2].second;\n\t\treturn xVals[x1] < xVals[x2];\n\t}\n};\n\nint get(int v) {\n\tif (pr[v] == v)\n\t\treturn v;\n\treturn pr[v] = get(pr[v]);\n}\n\ninline void myUnion(int v1, int v2) {\n\t//eprintf(""myUnion %d %d\\n"", v1, v2);\n\tv1 = get(v1), v2 = get(v2);\n\tif (v1 == v2)\n\t\treturn;\n\tif (w[v1] == w[v2])\n\t\t++w[v1];\n\tif (w[v1] < w[v2])\n\t\tswap(v1, v2);\n\tpr[v2] = v1;\n\tsegms[v1].first = min(segms[v1].first, segms[v2].first);\n\tsegms[v1].second = max(segms[v1].second, segms[v2].second);\n}\n\n\nNode* merge(Node *l, Node *r) {\n\tif (!l)\n\t\treturn r;\n\tif (!r)\n\t\treturn l;\n\tif (l->y > r->y) {\n\t\tl->r = merge(l->r, r);\n\t\treturn l->update();\n\t} else {\n\t\tr->l = merge(l, r->l);\n\t\treturn r->update();\n\t}\n}\n\nvoid split(Node *v, int x, Node *&l, Node *&r) {\n\tif (!v) {\n\t\tl = r = 0;\n\t\treturn;\n\t}\n\n\tif (xComp()(v->x, x)) {\n\t\tsplit(v->r, x, v->r, r);\n\t\tl = v->update();\n\t} else {\n\t\tsplit(v->l, x, l, v->l);\n\t\tr = v->update();\n\t}\n}\n\nNode *getNode(Node *root, int needr) {\n\tif (!root || root->maxr < needr)\n\t\treturn 0;\n\tNode *res = getNode(root->l, needr);\n\tif (res)\n\t\treturn res;\n\tif (segms[root->x].second >= needr)\n\t\treturn root;\n\tres = getNode(root->r, needr);\n\tassert(res);\n\treturn res;\n}\n\nvoid addSegm(int l, int r, int id) {\n\tpr[id] = id, w[id] = 0;\n\tsegms[id] = mp(l, r);\n\txVals[id] = id;\n\n\tfor (int side = 0; side < 2; ++side) {\n\t\tint needr = !side ? (l + 1) : (r + 1);\n\t\twhile (1) {\n\t\t\tNode *v = getNode(root, needr);\n\t\t\tif (!v)\n\t\t\t\tbreak;\n\t\t\tif (!side && segms[v->x].first >= l)\n\t\t\t\tbreak;\n\t\t\tif (side && segms[v->x].first >= r)\n\t\t\t\tbreak;\n\t\t\tNode *left, *mid, *right;\n\t\t\t{\n\t\t\t\tint tmp = id + 1;\n\t\t\t\tsegms[tmp] = segms[v->x];\n\t\t\t\txVals[tmp] = xVals[v->x];\n\n\t\t\t\tsplit(root, tmp, left, mid);\n\t\t\t\t++xVals[tmp];\n\t\t\t\tsplit(mid, tmp, mid, right);\n\t\t\t\tassert(mid == v);\n\t\t\t}\n\t\t\tmyUnion(id, mid->x);\n\t\t\troot = merge(left, right);\n\t\t}\n\t}\n\n\tint toadd = get(id);\n\tNode *newv = new Node(toadd);\n\tNode *left, *mid, *right;\n\t{\n\t\tint tmp = id + 1;\n\t\tsegms[tmp] = segms[newv->x];\n\t\txVals[tmp] = xVals[newv->x];\n\n\t\tsplit(root, tmp, left, mid);\n\t\t++xVals[tmp];\n\t\tsplit(mid, tmp, mid, right);\n\t\tassert(!mid);\n\t}\n\t//eprintf(""add (%d..%d)\\n"", segms[toadd].first, segms[toadd].second);\t\n\troot = merge(left, merge(newv, right));\n}\n\n\nbool solve() {\n\tint n;\n\tif (scanf(""%d"", &n) < 1)\n\t\treturn 0;\n\n\tint added = 0;\n\n\troot = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint type;\n\t\tscanf(""%d"", &type);\n\n\t\tif (type == 1) {\n\t\t\tint l, r;\n\t\t\tscanf(""%d%d"", &l, &r);\n\t\t\taddSegm(l, r, added);\n\t\t\t++added;\n\t\t\tcontinue;\n\t\t}\n\t\tassert(type == 2);\n\t\tint s, t;\n\t\tscanf(""%d%d"", &s, &t);\n\t\t--s, --t;\n\t\tswap(s, t);\n\n\t\ts = get(s), t = get(t);\n\t\tprintf((segms[s].first <= segms[t].first && segms[t].second <= segms[s].second) ? ""YES\\n"" : ""NO\\n"");\n\t}\n\treturn 1;\n}\n\nint main() {\n\tlong long tmp = rdtsc();\n\tsrand(tmp);\n\t//eprintf(""%I64d\\n"", tmp);\n#ifdef DEBUG\n\tfreopen(TASKNAME"".in"", ""r"", stdin);\n\tfreopen(TASKNAME"".out"", ""w"", stdout);\n#endif\n\t\n\twhile (1) {\n\t\tif (!solve())\n\t\t\tbreak;\n\t\t#ifdef DEBUG\n\t\t\teprintf(""%.18lf\\n"", (double)clock() / CLOCKS_PER_SEC);\n\t\t#endif\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3000
Let s denote that some array b is if it contains a subarray b l b l 1 dots b r of odd length more than 1 l r and r l 1 is odd such that forall i in 0 1 dots r l b l i b r i If an array is not bad it is Now you are given an array a 1 a 2 dots a n Some elements are replaced by 1 Calculate the number of good arrays you can obtain by replacing each 1 with some integer from 1 to k Since the answer can be large print it modulo 998244353 ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=500005,P=998244353;\nint n,k,a[N],b[N],m,f[N];\n\ninline void read(int &i){\n\ti=0;char c=getchar();bool j=0;\n\tfor(;!isdigit(c);c=getchar())if(c==\'-\')j=1;\n\tfor(;isdigit(c);c=getchar())i=(i<<1)+(i<<3)+c-\'0\';i=j?-i:i;\n}\ninline ll Pow(ll a,int b){ll c=1;for(;b;a=a*a%P,b>>=1)if(b&1)c=c*a%P;return c;}\n\ninline int F(int n,int c,int t){\n\tif(!c)return k*Pow(k-1,n-1)%P;\n\tif(c==1)return Pow(k-1,n);\n\tf[0]=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)f[i]=1ll*f[i-1]*(k-1)%P;\n\tfor(int i=n;i>=1;--i){\n\t\tif((n-i)&1)ans-=f[i];\n\t\telse ans+=f[i];\n\t\tans%=P;\n\t}\n\tif(ans<0)ans+=P;\n\tif(!t){\n\t\tans=Pow(k-1,n+1)-ans;\n\t\tif(ans<0)ans+=P;\n\t\tans=ans*Pow(k-1,P-2)%P;\n\t}\n\treturn ans;\n}\n\nint calc(){\n\tfor(int i=1;i<m;++i)if(b[i]>0&&b[i+1]>0&&b[i]==b[i+1])return 0;\n\tint as=1;\n\tfor(int i=1;i<=m;){\n\t\tint j=i;\n\t\tif(b[i]!=-1){i++;continue;}\n\t\twhile(j+1<=m&&b[j+1]==-1)j++;\n\t\tint c=0;\n\t\tif(i>1)c++;\n\t\tif(j<m)c++;\n\t\tas=1ll*as*F(j-i+1,c,b[i-1]==b[j+1])%P;\n\t\ti=j+1;\n\t}\n\treturn as;\n}\n\nint main(){\n\tread(n);read(k);\n\tfor(int i=1;i<=n;++i)read(a[i]);\n\tfor(int i=1;i<=n;i+=2)b[++m]=a[i];\n\tint ans=calc();\n\tm=0;\n\tfor(int i=2;i<=n;i+=2)b[++m]=a[i];\n\tans=1ll*ans*calc()%P;\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2200
One day three best friends Petya Vasya and Tonya decided to form a team and take part in programming contests Participants are usually offered several problems during programming contests Long before the start the friends decided that they will implement a problem if at least two of them are sure about the solution Otherwise the friends won t write the problem s solution This contest offers problems to the participants For each problem we know which friend is sure about the solution Help the friends find the number of problems for which they will write a solution ,"['#include<vector> \n#include<list> \n#include<map> \n#include<set> \n#include<deque> \n#include<queue> \n#include<stack> \n#include<bitset> \n#include<algorithm> \n#include<functional> \n#include<numeric> \n#include<utility> \n#include<iostream> \n#include<sstream> \n#include<iomanip> \n#include<cmath> \n#include<cstdlib> \n#include<cctype> \n#include<string> \n#include<cstring> \n#include<cstdio> \n#include<ctime> \n#include<climits> \n#include<complex> \n#define sz(x) (int)((x).size()) \n#define rep(i,n) for (int i=0;i<n;i++) \n#define mp make_pair \n#define pb push_back\n#define fi first\n#define se second \n#define all(x) x.begin(),x.end() \n#define clr(x) memset((x),0,sizeof(x)) \n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e) \nusing namespace std; \nconst double eps=1e-8; \nconst double pi=acos(-1.0); \nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;} \ntypedef long long ll; \ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<string> vs; \ntypedef pair<int,int> pii; \ntypedef vector<pii> vpi; \nint main()\n{\n    int i,j,k,n;\n    cin>>n;\n    int s=0;\n    while (n--)\n    {\n        j=0;\n        for (i=0;i<3;i++)\n        {\n            cin>>k;\n            j+=k;\n        }\n        s+=j>=2;\n    }\n    cout<<s<<endl;\n    return 0;\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",800
Vitya loves programming and problem solving but sometimes to distract himself a little he plays computer games Once he found a new interesting game about tanks and he liked it so much that he went through almost all levels in one day Remained only the last level which was too tricky Then Vitya remembered that he is a programmer and wrote a program that helped him to pass this difficult level Try do the same The game is organized as follows There is a long road two cells wide and cells long Some cells have obstacles You control a tank that occupies one cell Initially the tank is located before the start of the road in a cell with coordinates Your task is to move the tank to the end of the road to the cell or Every second the tank moves one cell to the right the coordinate is increased by one When you press the up or down arrow keys the tank instantly changes the lane that is the coordinate When you press the spacebar the tank shoots and the nearest obstacle along the lane in which the tank rides is instantly destroyed In order to load a gun the tank needs seconds Initially the gun is not loaded that means the first shot can be made only after seconds after the tank starts to move If at some point the tank is in the same cell with an obstacle not yet destroyed it burns out If you press the arrow exactly at the moment when the tank moves forward the tank will first move forward and then change the lane so it will not be possible to move diagonally Your task is to find out whether it is possible to pass the level and if possible to find the order of actions the player need to make ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxDp = 3e6 + 100;\n\nint N, M1, M2, T;\nvector<int> Important;\n\nint MaxTime[MaxDp][2];\nbool ChangeRow[MaxDp][2];\nbool Locked[MaxDp][2];\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> M1 >> M2 >> T;\n  vector<vector<int>> Obstacles(2);\n  Obstacles[0].resize(M1);\n  Obstacles[1].resize(M2);\n\n  for (auto &V : Obstacles)\n    for (int &x : V)\n      cin >> x;\n\n  Important.reserve(3 * (M1 + M2) + 1);\n  Important.push_back(0);\n\n  auto addImportant = [&](int x) {\n    for (int t : {x - 1, x, x + 1}) {\n      if (SZ(Important) > 0 && Important.back() >= t) { continue; }\n      Important.push_back(t);\n    }\n  };\n\n  int Lptr = 0, Rptr = 0;\n  while (Lptr < M1 || Rptr < M2) {\n    bool TakeLeft = Rptr == M2;\n    if (Lptr < M1 && Rptr < M2)\n      TakeLeft |= Obstacles[0][Lptr] < Obstacles[1][Rptr];\n\n    if (TakeLeft)\n      addImportant(Obstacles[0][Lptr++]);\n    else\n      addImportant(Obstacles[1][Rptr++]);\n  }\n\n  debug(Important);\n  int S = SZ(Important);\n\n  const int Infty = 2e9;\n\n  MaxTime[0][0] = -T;\n  MaxTime[0][1] = -T;\n  ChangeRow[0][1] = true;\n\n  Lptr = 0; Rptr = 0;\n  for (int i = 1; i < S; ++i) {\n    int x = Important[i];\n    int dx = x - Important[i - 1];\n    bool LockedL = (Lptr < M1 && Obstacles[0][Lptr] == x);\n    bool LockedR = (Rptr < M2 && Obstacles[1][Rptr] == x);\n    if (LockedL) { ++Lptr; }\n    if (LockedR) { ++Rptr; }\n    Locked[i][0] = LockedL;\n    Locked[i][1] = LockedR;\n    debug(LockedL, LockedR);\n\n    // Row unchanged?\n    for (int b : {0, 1}) {\n      MaxTime[i][b] = MaxTime[i - 1][b] + dx;\n      if (Locked[i][b]) {\n        if (MaxTime[i][b] <= 0)\n          MaxTime[i][b] = -Infty;\n        else\n          MaxTime[i][b] -= T;\n      }\n    }\n\n    // Change rows?\n    for (int b : {0, 1}) {\n      if (Locked[i][b]) { continue; }\n      int tt = MaxTime[i][b ^ 1];\n      int NewT = min<LL>(tt, 0);\n      if (NewT > MaxTime[i][b]) {\n        MaxTime[i][b] = NewT;\n        ChangeRow[i][b] = true;\n      }\n    }\n\n    debug(i, MaxTime[i][0], MaxTime[i][1]);\n  }\n\n  auto checkWin = [&](int i, int b) {\n    if (MaxTime[i][b] < -T) { return; }\n    cout << ""Yes\\n"";\n    vector<int> Changes;\n    vector<PII> Shots;\n    int NumToShoot = 0;\n\n    auto settleShots = [&]() {\n      int x = Important[i];\n      int AmountWait = -MaxTime[i][b];\n      assert(AmountWait >= 0);\n      int FirstShot = x + AmountWait;\n      while (NumToShoot > 0) {\n        --NumToShoot;\n        Shots.emplace_back(FirstShot + NumToShoot * T, b + 1);\n      }\n    };\n\n    while (!(i == 0 && b == 0)) {\n      if (ChangeRow[i][b]) {\n        settleShots();\n        Changes.push_back(Important[i]);\n        b ^= 1;\n        NumToShoot = Locked[i][b];\n      } else {\n        --i;\n        NumToShoot += Locked[i][b];\n      }\n    }\n\n    settleShots();\n\n    cout << SZ(Changes) << ""\\n"";\n    reverse(ALL(Changes));\n    for (int v : Changes) { cout << v << "" ""; }\n    cout << ""\\n"";\n    cout << SZ(Shots) << ""\\n"";\n    reverse(ALL(Shots));\n    for (auto &P : Shots)\n      cout << P.first << "" "" << P.second << ""\\n"";\n\n\n    exit(0);\n  };\n\n  checkWin(S - 1, 0);\n  checkWin(S - 1, 1);\n\n  cout << ""No\\n"";\n}\n\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3000
k Gildong loves observing animals so he bought two cameras to take videos of wild animals in a forest The color of one camera is red and the other one s color is blue Gildong is going to take videos for n days starting from day 1 to day n The forest can be divided into m areas numbered from 1 to m He ll use the cameras in the following way On every odd day 1 st 3 rd 5 th bring the red camera to the forest and record a video for 2 days On every even day 2 nd 4 th 6 th bring the blue camera to the forest and record a video for 2 days If he starts recording on the n th day with one of the cameras the camera records for only one day Each camera can observe k consecutive areas of the forest For example if m 5 and k 3 he can put a camera to observe one of these three ranges of areas for two days 1 3 2 4 and 3 5 Gildong got information about how many animals will be seen in each area each day Since he would like to observe as many animals as possible he wants you to find the best way to place the two cameras for n days ,"['#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<iomanip>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint N , M , K , dp[53][20003] , sum[503][20003];\n\nint main(){\n\tcin>>N>>M>>K;\n\tfor(int i = 1 ; i <= N ; ++i)\n\t\tfor(int j = 1; j <= M ; ++j){\n\t\t\tcin>>sum[i][j]; sum[i][j] += sum[i][j -1 ];\n\t\t}\n\tmemset(dp , -0x1f , sizeof(dp));\n\tfor(int i = 1 ; i <= M - K + 1 ; ++i) dp[1][i] = sum[1][i + K - 1] - sum[1][i - 1] + sum[2][i + K - 1] - sum[2][i - 1];\n\tfor(int i = 2 ; i <= N ; ++i){\n\t\tdeque < int > q;\n\t\tfor(int j = 1 ; j <= K && j <= M - K + 1 ; ++j){\n\t\t\twhile(!q.empty() && dp[i - 1][q.back()] + sum[i][q.back() - 1] < dp[i - 1][j] + sum[i][j - 1]) q.pop_back();\n\t\t\tq.push_back(j);\n\t\t}\n\t\tfor(int j = 1 ; j <= M - K + 1 ; ++j){\n\t\t\tdp[i][j] = max(dp[i][j] , dp[i - 1][q.front()] + sum[i][q.front() - 1] - sum[i][j - 1]);\n\t\t\tif(q.front() == j) q.pop_front();\n\t\t\tif(j + K <= M - K + 1){\n\t\t\t\tint t = j + K;\n\t\t\t\twhile(!q.empty() && dp[i - 1][q.back()] + sum[i][q.back() - 1] < dp[i - 1][t] + sum[i][t - 1]) q.pop_back();\n\t\t\t\tq.push_back(t);\n\t\t\t}\n\t\t}\n\t\tq.clear();\n\t\tfor(int j = 1 ; j <= M - K + 1 && j <= K ; ++j){\n\t\t\tint t = M - K + 2 - j;\n\t\t\twhile(!q.empty() && dp[i - 1][q.back()] - sum[i][q.back() + K - 1] < dp[i - 1][t] - sum[i][t + K - 1])\n\t\t\t\tq.pop_back();\n\t\t\tq.push_back(t);\n\t\t}\n\t\tfor(int j = M - K + 1 ; j ; --j){\n\t\t\tdp[i][j] = max(dp[i][j] , dp[i - 1][q.front()] - sum[i][q.front() + K - 1] + sum[i][j + K - 1]);\n\t\t\tif(q.front() == j) q.pop_front();\n\t\t\tif(j - K > 0){\n\t\t\t\tint t = j - K;\n\t\t\t\twhile(!q.empty() && dp[i - 1][q.back()] - sum[i][q.back() + K - 1] < dp[i - 1][t] - sum[i][t + K - 1])\n\t\t\t\t\tq.pop_back();\n\t\t\t\tq.push_back(t);\n\t\t\t}\n\t\t}\n\t\tint mx = 0;\n\t\tfor(int j = 1 ; j <= M - K + 1; ++j){\n\t\t\tmx = max(mx , dp[i - 1][j]);\n\t\t\tif(j + K <= M - K + 1) dp[i][j + K] = max(dp[i][j + K] , mx + sum[i][j + K + K - 1] - sum[i][j + K - 1]);\n\t\t}\n\t\tmx = 0;\n\t\tfor(int j = M - K + 1 ; j ; --j){\n\t\t\tmx = max(mx , dp[i - 1][j]);\n\t\t\tif(j - K > 0) dp[i][j - K] = max(dp[i][j - K] , mx + sum[i][j - 1] - sum[i][j - K - 1]);\n\t\t}\n\t\tfor(int j = 1 ; j <= M - K + 1 ; ++j)\n\t\t\tdp[i][j] += sum[i + 1][j + K - 1] - sum[i + 1][j - 1];\n\t}\n\tint mx = 0;\n\tfor(int i = 1 ; i <= M - K + 1 ; ++i) mx = max(mx , dp[N][i]);\n\tcout << mx;\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
You are given three positive greater than zero integers c d and x You have to find the number of pairs of positive integers a b such that equality c cdot lcm a b d cdot gcd a b x holds Where lcm a b is the least common multiple of a and b and gcd a b is the greatest common divisor of a and b ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MX = 20000000;\n\nvector<int> primes;\nint sieve[20202020];\nll ans;\nint c, d, x;\n\nvoid f(int g) {\n\tint y = (x / g + d);\n\tif(y % c) return;\n\ty /= c;\n\tint cnt = 0, last = 0;\n\twhile(y > 1) {\n\t\tint t = sieve[y];\n\t\tif(last != t) { cnt++; last = t; }\n\t\ty /= t;\n\t}\n\tans += (1 << cnt);\n}\n\nint main() {\n\tfor(int i = 2; i <= MX; i++) {\n\t\tif(!sieve[i]) { sieve[i] = i; primes.push_back(i); }\n\t\tfor(int j : primes) {\n\t\t\tif(i * j > MX) break;\n\t\t\tsieve[i * j] = j;\n\t\t\tif(i % j == 0) break;\n\t\t}\n\t}\n\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tscanf(""%d%d%d"", &c, &d, &x);\n\t\tans = 0;\n\t\tfor(int i = 1; i * i <= x; i++) {\n\t\t\tif(x % i) continue;\n\t\t\tf(i);\n\t\t\tif(i != x / i) f(x / i);\n\t\t}\n\t\tprintf(""%lld\\n"", ans);\n\t}\n\treturn 0;\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2100
Recently Kolya found out that a new movie theatre is going to be opened in his city soon which will show a new movie every day for n days So on the day with the number 1 le i le n the movie theatre will show the premiere of the i th movie Also Kolya found out the schedule of the movies and assigned the entertainment value to each movie denoted by a i However the longer Kolya stays without visiting a movie theatre the larger the decrease in entertainment value of the next movie That decrease is equivalent to d cdot cnt where d is a predetermined value and cnt is the number of days since the last visit to the movie theatre It is also known that Kolya managed to visit another movie theatre a day before the new one opened the day with the number 0 For example if d 2 and a 3 2 5 4 6 then by visiting movies with indices 1 and 3 cnt value for the day 1 will be equal to 1 0 1 and cnt value for the day 3 will be 3 1 2 so the total entertainment value of the movies will be a 1 d cdot 1 a 3 d cdot 2 3 2 cdot 1 5 2 cdot 2 2 Unfortunately Kolya only has time to visit Help him create a plan to visit the cinema in such a way that the total entertainment value of all the movies he visits is maximized ,"['/*  \n  hmz is cute!\n--------------------------------------------\n  You\'ve got to have faith\n  Don\'t let them cut you down cut you down once more\n*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define TY long long\n#define IL inline\n#define pb push_back\n#define mod (TY)(1e9+7)\n#define MAXN 200005\n#define MAXM 200005\n#define MAXK 27\n#define INF (TY)(1e18)\n#define block 300\n#define For(i,a,b) for(TY i=(a);i<=(b);++i)\n#define FOR(i,a,b) for(TY i=(a);i<(b);++i)\n#define Rof(i,a,b) for(TY i=(a);i>=(b);--i)\n#define ROF(i,a,b) for(TY i=(a);i>(b);--i)\nIL TY qr(){\n\tTY x=0,f=1;char op=getchar();\n\tfor(;op<\'0\'||op>\'9\';op=getchar())if(op==\'-\')f=-1;\n\tfor(;op>=\'0\'&&op<=\'9\';op=getchar())x=x*10+(op^48);\n\treturn x*f;\n}IL bool ischar(char op){\n\tif(op>=\'a\'&&op<=\'z\')return true;\n\tif(op>=\'A\'&&op<=\'Z\')return true;\n\treturn false;\n}IL char getc(){\n\tchar op=getchar();\n\twhile(!ischar(op))op=getchar();\n\treturn op;\n}IL string qs(){\n\tstring op="""";char u=getchar();\n\twhile(!ischar(u))u=getchar();\n\twhile(ischar(u))op+=u,u=getchar();\n\treturn op;\n}IL void qw(TY x){\n\tif(!x){putchar(\'0\');return;}\n\tif(x<0)putchar(\'-\'),x=-x;\n\tif(x>=10)qw(x/10);putchar(x%10+\'0\');\n}IL void qw(TY x,char op){qw(x),putchar(op);}\nIL void ws(string s){FOR(i,0,s.size())putchar(s[i]);}\nIL TY Ceil(TY a,TY b){return a/b+(a%b!=0);}\nIL TY Mod(TY a){return (a>=mod?a-mod:a);}\nIL TY Abs(TY a,TY b){return a>b?a-b:b-a;}\nIL TY Pow(TY a,TY b){\n\tTY ans=1,base=a;\n\twhile(b){\n\t\tif(b&1)ans=ans*base%mod;\n\t\tbase=base*base%mod;b>>=1;\n\t}return ans;\n}TY T,n,m,d,a[MAXN];\npriority_queue<TY> q;\nint main(){\n    //freopen("".in"",""r"",stdin);\n    //freopen("".out"",""w"",stdout);\n\n    /* init */\n\tT=qr();while(T--){\n\t\tTY ans=0,sum=0;\n\t\twhile(!q.empty())q.pop();\n\t\tn=qr();m=qr();d=qr();\n\t\tFor(i,1,n){\n\t\t\ta[i]=qr();\n\t\t\tif(a[i]>0){\n\t\t\t\tif(q.size()<m||-q.top()<a[i]){\n\t\t\t\t\tq.push(-a[i]);sum+=a[i];\n\t\t\t\t\tif(q.size()>m)sum-=-q.top(),q.pop();\n\t\t\t\t}\n\t\t\t}ans=max(ans,sum-i*d);\n\t\t}qw(ans,\'\\n\');\n\t}\n    return 0;\n}']","[1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
There is a grid consisting of n rows and m columns The rows are numbered from 1 to n from bottom to top The columns are numbered from 1 to m from left to right The i th column has the bottom a i cells blocked the cells in rows 1 2 dots a i the remaining n a i cells are unblocked A robot is travelling across this grid You can send it commands move up right down or left If a robot attempts to move into a blocked cell or outside the grid it explodes However the robot is broken it executes each received command k times So if you tell it to move up for example it will move up k times k cells You can t send it commands while the robot executes the current one You are asked q queries about the robot Each query has a start cell a finish cell and a value k Can you send the robot an arbitrary number of commands possibly zero so that it reaches the finish cell from the start cell given that it executes each command k times The robot must stop in the finish cell If it visits the finish cell while still executing commands it doesn t count ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int LOG = 18;\nint a[N];\nint n, m;\nint sparse[LOG][N];\nint p2[N];\n\nint getMax(int l, int r) {\n\tint k = p2[r - l];\n\treturn max(sparse[k][l], sparse[k][r - (1 << k)]);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &m, &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tsparse[0][i] = a[i];\n\t}\n\tfor (int k = 0; k < LOG - 1; k++) {\n\t\tfor (int i = 0; i + (1 << (k + 1)) <= n; i++)\n\t\t\tsparse[k + 1][i] = max(sparse[k][i], sparse[k][i + (1 << k)]);\n\t}\n\tfor (int i = 2; i < N; i++)\n\t\tp2[i] = p2[i / 2] + 1;\n\tint q;\n\tscanf(""%d"", &q);\n\twhile(q--) {\n\t\tint x1, y1, x2, y2, k;\n\t\tscanf(""%d%d%d%d%d"", &y1, &x1, &y2, &x2, &k);\n\t\tif (abs(x1 - x2) % k) {\n\t\t\tprintf(""NO\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tif (abs(y1 - y2) % k) {\n\t\t\tprintf(""NO\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tif (x1 > x2) swap(x1, x2);\n\t\tint mx = getMax(x1 - 1, x2);\n\t\tint y = m - (m % k);\n\t\ty += y1 % k;\n\t\twhile(y <= m) y += k;\n\t\ty -= k;\n\t\tif (y <= mx) {\n\t\t\tprintf(""NO\\n"");\n\t\t} else {\n\t\t\tprintf(""YES\\n"");\n\t\t}\n\t}\n\n\treturn 0;\n}\n']","[1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1700
A binary string dagger b of odd length m is if b i is the median ddagger of b 1 i S for all indices i 1 leq i leq m For a binary string a of length k a binary string b of length 2k 1 is an of a if b 2i 1 a i for all i such that 1 leq i leq k For example and are of the string String x is not an of string y because x 3 neq y 2 Note that there are 2 k 1 different of a You are given a binary string s of length n Find the sum of the number of over all prefixes of s In other words find sum i 1 n f s 1 i where f x gives number of of string x Since the answer can be quite large you only need to find it modulo 998 244 353 dagger A binary string is a string whose elements are either mathtt 0 or mathtt 1 ddagger For a binary string a of length 2m 1 the median of a is the unique element that occurs at least m times in a S a l r denotes the string of length r l 1 which is formed by the concatenation of a l a l 1 ldots a r in that order ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 998244353;\nint fpow(int a,int b)\n{\n    int ans=1;\n    while(b){\n        if(b & 1) ans =1LL*ans*a%mod;\n        a = 1LL*a*a%mod ; b >>= 1;\n    }\n    return ans;\n}\nint t[400005] , rt[400005];\nint C(int a,int b)\n{\n    return 1LL*t[a]*rt[a - b] % mod * rt[b] %mod;\n}\nint c[200005];\nchar s[200005];\nint n;\nvoid solve()\n{\n    scanf(""%d"",&n);t[0] = rt[0] = 1;\n   // for(int i = 1;i <= n*2;i++) t[i] = 1LL*t[i - 1]*i % mod , rt[i] = fpow(t[i],mod-2);\n  //  for(int i = 0;i <= n;i++) c[i] = 1LL*C(i*2 , i) * fpow(i  + 1 , mod - 2) % mod ;\n    scanf(""%s"",s+1);\n    int lst = 1 ,d = 1;\n    int ans = 0;\n    for(int i = 2;i <= n +1;i++) {\n        if(i == n + 1 || s[i] != s[i - 1]){\n            int L = i - lst;\n            ans = (ans + 1LL*(fpow(2 , L) - 1) * d) % mod;\n          //  d = 1LL*d*c[L] % mod;\n         //   printf(""After %d , %d\\n"",i - 1 , ans);\n            lst = i;\n        }\n    }\n    printf(""%d\\n"",ans);\n    return;\n}\nint main() {\n   // freopen(""in.txt"",""r"",stdin);\n    int t;scanf(""%d"",&t);\n    while(t--) solve();\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1400
Madoka decided to entrust the organization of a major computer game tournament In this tournament matches are held according to the Olympic system In other words there are 2 n participants in the tournament numbered with integers from 1 to 2 n There are n rounds in total in the tournament In the i th round there are 2 n i matches between two players one of whom is right the other is left after which the winners go further along the tournament grid and the losing participants are eliminated from the tournament Herewith the relative order in the next round does not change And the winner of the tournament is the last remaining participant But the smaller the participant s number the more he will pay Madoka if he wins so Madoka wants the participant with the lowest number to win To do this she can arrange the participants in the first round as she likes and also determine for each match who will win the participant on the left or right But Madoka knows that tournament sponsors can change the winner in matches no more than k times That is if the participant on the left won before the change then the participant on the right will win after the change and if the participant on the right won then the participant on the left will win after the change Print the minimum possible number of the winner in the tournament which Madoka can get regardless of changes in sponsors But since the answer can be very large output it modulo 10 9 7 Note that we need to minimize the answer and only then take it modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\nconst int P = 1e9 + 7;\ntemplate<class T>\ninline T power(T a, i64 b) {\n\tT res = 1;\n\tfor (; b; b >>= 1, a *= a)\n\t\tif (b & 1) res *= a;\n\treturn res;\n}\ninline int norm(int x) {\n\tif (x < 0) x += P;\n\tif (x >= P) x -= P;\n\treturn x;\n}\nstruct Z {\n\tint x;\n\tZ(int _x = 0) : x(norm(_x)) {}\n\tinline Z operator-() const {\n\t\tif (!x) return 0;\n\t\treturn Z(P - x);\n\t}\n\tinline Z &operator+=(const Z &rhs) {\n\t\tx += rhs.x;\n\t\tif (x >= P) x -= P;\n\t\treturn *this;\n\t}\n\tinline Z &operator-=(const Z &rhs) {\n\t\tx -= rhs.x;\n\t\tif (x < 0) x += P;\n\t\treturn *this;\n\t}\n\tinline Z &operator*=(const Z &rhs) {\n\t\tx = 1ull * x * rhs.x % P;\n\t\treturn *this;\n\t}\n\tinline Z inv() const {\n\t\treturn power(*this, P - 2);\n\t}\n\tinline Z &operator/=(const Z &rhs) {\n\t\t*this *= rhs.inv();\n\t\treturn *this;\n\t}\n\tinline friend Z operator+(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res += rhs, res;\n\t}\n\tinline friend Z operator-(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res -= rhs, res;\n\t}\n\tinline friend Z operator*(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res *= rhs, res;\n\t}\n\tinline friend Z operator/(const Z &lhs, const Z &rhs) {\n\t\tZ res = lhs;\n\t\treturn res /= rhs, res;\n\t}\n};\nconst int N = 100005;\nZ fac[N], ifac[N], pw[N];\nvoid init(int n) {\n\tfac[0] = pw[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfac[i] = fac[i - 1] * i;\n\t\tpw[i] = pw[i - 1] * 2;\n\t}\n\tifac[n] = fac[n].inv();\n\tfor (int i = n; i; --i) {\n\t\tifac[i - 1] = ifac[i] * i;\n\t}\n}\nint main() {\n\tint n, k;\n\tcin >> n >> k;\n\tinit(n);\n\tif (k >= n) {\n\t\tcout << pw[n].x << ""\\n"";\n\t\treturn 0;\n\t}\n\tZ ans = 0;\n\tfor (int i = 0; i <= k; ++i) {\n\t\tans += fac[n] * ifac[i] * ifac[n - i];\n\t}\n\tcout << ans.x << ""\\n"";\n    return 0;\n}']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1900
In many many years far far away there will be a launch of the first flight to Mars To celebrate the success n astrophysicists working on the project will be given bonuses of a total value of k gold coins You have to distribute the money among the astrophysicists and to make it easier you have to assign bonuses in silver coins Each gold coin is worth g silver coins so you have to distribute all k cdot g silver coins among n people Unfortunately the company has some financial troubles right now Therefore instead of paying the number of silver coins written on the bonus they decided to round this amount to the nearest integer number of gold coins The rounding procedure is as follows If an astrophysicist has bonus equal to x silver coins and we denote r x bmod g then If r geq lceil frac g 2 rceil the astrophysicist receives x g r silver coins Otherwise an astrophysicists receives x r silver coins Note that due to rounding the total sum of actually paid money is not in general equal to k cdot g silver coins The operation a bmod b denotes the remainder of the division of a by b Sum of values before rounding but some workers can be assigned 0 silver coins You aim to distribute the bonuses so that the company saves as many silver coins due to rounding as possible Please note that there is always a distribution in which the company spends no more than k cdot g silver coins ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tint n, k, g;\n\t\tcin >> n >> k >> g;\n\t\tlong long total = k * 1LL * g;\n\t\tlong long at_first = min(total, (g - 1) / 2 * 1LL * n);\n\t\tlong long used = total - at_first;\n\t\tif (used % g > 0) used += g - (used % g);\n\t\t\n\t\tcout << total - used << endl;\n\t}\n\t\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
You have 5 different types of coins each with a value equal to one of the first 5 triangular numbers 1 3 6 10 and 15 These coin types are available in abundance Your goal is to find the minimum number of these coins required such that their total value sums up to exactly n We can show that the answer always exists ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define int long long //instead of int main, use signed main\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\ntypedef vector<int> vi;\n\nsigned main(){\n    IOS;\n\n    vi dp(100000 + 10, 1e18); dp[0] = 0;\n    for(int i = 1; i <= 100000; i++){\n        for(int j : {1, 3, 6, 10, 15}){\n            if(i < j) continue;\n            dp[i] = min(dp[i], dp[i - j] + 1);\n        }\n    }\n\n    int T; cin >> T;\n    while(T--){\n        int N; cin >> N;\n        int ans = 0;\n        if(N >= 1e5){\n            int chk = (N - (int)1e5) / 15 + 10;\n            ans = dp[N - chk * 15] + chk;\n        }\n        else ans = dp[N];\n        cout << ans << endl;\n    }\n\n}""]","[1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Let s call an array a of m integers a 1 a 2 ldots a m if a can be made increasing by removing a decreasing subsequence possibly empty from it For example if a 3 2 4 1 5 we can remove the decreasing subsequence a 1 a 4 from a and obtain a 2 4 5 which is increasing You are given a permutation p of numbers from 1 to n Find the number of pairs of integers l r with 1 le l le r le n such that p l ldots r the subarray of p from l to r is a array ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nint tab[nax];\n\nint nastwie[nax];\nint nastmie[nax];\n\nll wyn;\n\nint dolny[nax];\nint nd[nax];\nint ng[nax];\n\nint pd[nax];\nint pg[nax];\n\nint spokdal[nax];\n\nint lecimy[nax];\n\nmap<pii,int> mapa;\n\nint dive(int d, int g)\n{\n\tif (mapa.count({d, g}))\n\t\treturn mapa[{d, g}];\n\tint x=max(d, g);\n\tif (x==n)\n\t\treturn mapa[{d, g}]=n;\n\tx++;\n\tif (tab[x]>tab[d])\n\t\treturn mapa[{d, g}]=dive(x, g);\n\tif (tab[x]<tab[g])\n\t\treturn mapa[{d, g}]=dive(d, x);\n\treturn mapa[{d, g}]=x-1;\n}\n\nint check(int a, int b)\n{\n\tif (spokdal[a]>=b)\n\t\treturn 1;\n\tint x=spokdal[a];\n\tint g=pg[x];\n\tint d=pd[x];\n\tassert(g && d);\n\treturn dive(d, g)>=b;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\t\t//~ tab[i]=i;\n\t//~ {\n\t\t//~ if (i&1)\n\t\t\t//~ tab[i]=(i+1)/2;\n\t\t//~ else\n\t\t\t//~ tab[i]=n-(i-1)/2;\n\t//~ }\n\t//~ shandom_ruffle(tab+1, tab+1+n);\n\tfor (int i=n; i; i--)\n\t{\n\t\tnastwie[i]=nastmie[i]=i+1;\n\t\twhile(nastwie[i]<=n && tab[nastwie[i]]<tab[i])\n\t\t\tnastwie[i]=nastwie[nastwie[i]];\n\t\twhile(nastmie[i]<=n && tab[nastmie[i]]>tab[i])\n\t\t\tnastmie[i]=nastmie[nastmie[i]];\n\t}\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tif (tab[i+1]>tab[i])\n\t\t\tdolny[i]=1;\n\t}\n\tnd[n+1]=ng[n+1]=n+1;\n\tfor (int i=n; i; i--)\n\t{\n\t\tnd[i]=nd[i+1];\n\t\tng[i]=ng[i+1];\n\t\tif (dolny[i])\n\t\t\tnd[i]=i;\n\t\telse\n\t\t\tng[i]=i;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tpd[i]=pd[i-1];\n\t\tpg[i]=pg[i-1];\n\t\tif (dolny[i])\n\t\t\tpd[i]=i;\n\t\telse\n\t\t\tpg[i]=i;\n\t}\n\tspokdal[n+1]=n;\n\tfor (int i=n; i; i--)\n\t{\n\t\tspokdal[i]=spokdal[i+1];\n\t\tif (dolny[i])\n\t\t{\n\t\t\tint x=nd[i+1];\n\t\t\tif (x<=n && tab[x]<tab[i])\n\t\t\t\tspokdal[i]=min(spokdal[i], x-1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x=ng[i+1];\n\t\t\tif (x<=n && tab[x]>tab[i])\n\t\t\t\tspokdal[i]=min(spokdal[i], x-1);\n\t\t}\n\t}\n\tint w=n;\n\tll wyn=0;\n\tfor (int i=n; i; i--)\n\t{\n\t\twhile(!check(i, w))\n\t\t\tw--;\n\t\twyn+=w-i+1;\n\t}\n\tprintf(""%lld\\n"", wyn);\n\t//~ lecimy[n]=n;\n\t//~ for (int i=n-1; i; i--)\n\t//~ {\n\t\t//~ if (!pd[i] || !pg[i])\n\t\t//~ {\n\t\t\t//~ lecimy[i]=lecimy[i+1];\n\t\t\t//~ continue;\n\t\t//~ }\n\t\t//~ int d=pd[i];\n\t\t//~ int g=pg[i];\n\t\t//~ assert(d==i || g==i);\n\t\t//~ if (tab[i+1]>=tab[g])\n\t\t//~ {\n\t\t\t\n\t\t//~ }\n\t//~ }\n\t//~ debug() << range(spokdal+1, spokdal+1+n);\n\t//~ debug() << range(dolny+1, dolny+1+n);\n\treturn 0;\n}\n']","[1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2800
In the wilds far beyond lies the Land of Sacredness which can be viewed as a tree connected undirected graph consisting of n nodes and n 1 edges The nodes are numbered from 1 to n There are m travelers attracted by its prosperity and beauty Thereupon they set off their journey on this land The i th traveler will travel along the shortest path from s i to t i In doing so they will all edges in the shortest path from s i to t i which is unique in the tree During their journey the travelers will acquaint themselves with the others Some may even become friends To be specific the i th traveler and the j th traveler will become friends if and only if there are k edges that both the i th traveler and the j th traveler will Your task is to find out the number of pairs of travelers i j satisfying the following conditions 1 leq i j leq m the i th traveler and the j th traveler will become friends ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\n//Lyft Level 5 Challenge 2018 - Final F\ntemplate<class E>\nstruct doubling{\n\tconst vvc<E>&g;\n\tconst int n,h;\n\tint cnt;\n\tvvc<int> par;\n\tvi dep,in,out;\n\tvoid dfs(int v,int p,int d){\n\t\tpar[0][v]=p;\n\t\tdep[v]=d;\n\t\tin[v]=cnt++;\n\t\tfor(auto e:g[v])if(e!=p)\n\t\t\tdfs(e,v,d+1);\n\t\tout[v]=cnt;\n\t}\n\tdoubling(const vvc<E>&gg,int r):g(gg),n(g.size()),h(__lg(n)+1),\n\t\tcnt(0),par(h,vi(n,-1)),dep(n),in(n),out(n){\n\t\tdfs(r,-1,0);\n\t\trng(i,1,h){\n\t\t\trep(j,n)\n\t\t\t\tif(par[i-1][j]!=-1)\n\t\t\t\t\tpar[i][j]=par[i-1][par[i-1][j]];\n\t\t}\n\t}\n\tint lca(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tint w=dep[b]-dep[a];\n\t\trep(i,h)if(w&1<<i)\n\t\t\tb=par[i][b];\n\t\tif(a==b)return a;\n\t\tper(i,h){\n\t\t\tint x=par[i][a],y=par[i][b];\n\t\t\tif(x!=y)tie(a,b)=pi(x,y);\n\t\t}\n\t\treturn par[0][a];\n\t}\n\tint len(int a,int b){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tint jump(int a,int b,int d){\n\t\tassert(0<=a&&a<(int)g.size());\n\t\tassert(0<=b&&b<(int)g.size());\n\t\tint c=lca(a,b);\n\t\tint w=dep[a]+dep[b]-dep[c]*2;\n\t\tassert(0<=d&&d<=w);\n\t\tif(d<=dep[a]-dep[c]){\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\ta=par[i][a];\n\t\t\treturn a;\n\t\t}else{\n\t\t\td=w-d;\n\t\t\trep(i,h)if(d&1<<i)\n\t\t\t\tb=par[i][b];\n\t\t\treturn b;\n\t\t}\n\t}\n\tint getpar(int v,int len)const{\n\t\trep(i,h)if(len&1<<i)v=par[i][v];\n\t\treturn v;\n\t}\n};\n\ntemplate<class t>\nstruct BIT{\n\tvc<t> buf;\n\tint s;\n\tBIT(int n=0){init(n);}\n\tvoid init(int n){buf.assign(s=n,0);}\n\tvoid add(int i,t v){\n\t\tfor(;i<s;i+=(i+1)&(-i-1))\n\t\t\tbuf[i]+=v;\n\t}\n\tt get(int i){\n\t\tt res=0;\n\t\tfor(;i>=0;i-=(i+1)&(-i-1))\n\t\t\tres+=buf[i];\n\t\treturn res;\n\t}\n\tt sum(int b,int e){\n\t\treturn get(e-1)-get(b-1);\n\t}\n\tint kth(int k){\n\t\tint res=0;\n\t\tfor(int i=topbit(s);i>=0;i--){\n\t\t\tint w=res+(1<<i);\n\t\t\tif(w<=s&&buf[w-1]<=k){\n\t\t\t\tk-=buf[w-1];\n\t\t\t\tres=w;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t//yukicoder No.1024\n\tint kth_helper(int k,int i){\n\t\treturn kth(k+get(i-1));\n\t}\n};\n\n//offline\n//ROI2018 day2 D\nstruct point2d{\n\tstruct query{\n\t\tint x,i,l,r;\n\t\tbool operator<(const query&rhs)const{\n\t\t\treturn pi(x,-i)<pi(rhs.x,-rhs.i);\n\t\t}\n\t};\n\tvi ys,ans;\n\tvc<query> qs;\n\tpoint2d(const vc<pi>&ps){\n\t\tfor(auto p:ps)\n\t\t\tys.pb(p.b);\n\t\tmkuni(ys);\n\t\tfor(auto p:ps)\n\t\t\tqs.pb({p.a,-1,lwb(ys,p.b),-1});\n\t}\n\tvoid aq(int x1,int x2,int y1,int y2){\n\t\tint i=si(ans);\n\t\tans.pb(0);\n\t\ty1=lwb(ys,y1);\n\t\ty2=lwb(ys,y2);\n\t\tqs.pb({x1,i*2,y1,y2});\n\t\tqs.pb({x2,i*2+1,y1,y2});\n\t}\n\tvi calc(){\n\t\tsort(all(qs));\n\t\tBIT<int> bit(si(ys));\n\t\tfor(auto q:qs){\n\t\t\tif(q.i==-1){\n\t\t\t\tbit.add(q.l,1);\n\t\t\t}else{\n\t\t\t\tint w=bit.sum(q.l,q.r);\n\t\t\t\tif(q.i%2==0)ans[q.i/2]-=w;\n\t\t\t\telse ans[q.i/2]+=w;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n//内部でグラフをいじるから in,out を使うときは注意\n//VERIFY: yosupo\n//CF530F\n//CodeChef Persistent Oak\n//AOJ GRL5C\ntemplate<class E>\nstruct HLD{\n\tvvc<E> g;\n\tint n,rt,cnt;\n\tvi sub,in,out,par,head,dep;\n\tint dfs1(int v,int p,int d){\n\t\tpar[v]=p;\n\t\tdep[v]=d;\n\t\tg[v].erase(remove(all(g[v]),p),g[v].ed);\n\t\tfor(auto&e:g[v]){\n\t\t\tsub[v]+=dfs1(e,v,d+1);\n\t\t\tif(sub[g[v][0]]<sub[e])\n\t\t\t\tswap(g[v][0],e);\n\t\t}\n\t\treturn sub[v];\n\t}\n\tvoid dfs2(int v,int h){\n\t\tin[v]=cnt++;\n\t\thead[v]=h;\n\t\tfor(int to:g[v])\n\t\t\tdfs2(to,to==g[v][0]?h:to);\n\t\tout[v]=cnt;\n\t}\n\tHLD(){}\n\tHLD(const vvc<E>&gg,int rr):g(gg),n(g.size()),rt(rr),cnt(0),\n\t\tsub(n,1),in(n),out(n),par(n,-1),head(n),dep(n){\n\t\tdfs1(rt,-1,0);\n\t\tdfs2(rt,rt);\n\t}\n\tint lca(int a,int b){\n\t\twhile(head[a]!=head[b]){\n\t\t\tif(dep[head[a]]>dep[head[b]])\n\t\t\t\tswap(a,b);\n\t\t\tb=par[head[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])\n\t\t\tswap(a,b);\n\t\treturn a;\n\t}\n\tint len(int a,int b){\n\t\treturn dep[a]+dep[b]-dep[lca(a,b)]*2;\n\t}\n\tbool asde(int a,int b){\n\t\treturn in[a]<=in[b]&&out[b]<=out[a];\n\t}\n\tint k;\n\tvvc<pi> pt;\n\tstruct Query{\n\t\tint i,x1,x2,y1,y2,w;\n\t\tbool has(int x,int y){\n\t\t\treturn x1<=x&&x<x2&&y1<=y&&y<y2;\n\t\t}\n\t};\n\tvc<Query> qs;\n\tmap<int,int> dfs(int v,const doubling<int>&d){\n\t\tmap<int,int> res;\n\t\tint l=0,r=0;\n\t\tif(si(g[v])){\n\t\t\tres=dfs(g[v][0],d);\n\t\t\tl=in[g[v][0]];\n\t\t\tr=out[g[v][0]];\n\t\t}\n\t\tauto add=[&](int i,int to){\n\t\t\tauto itr=res.find(i);\n\t\t\tif(itr==res.ed)res[i]=to;\n\t\t\telse res.erase(itr);\n\t\t};\n\t\tbool curvert=false;\n\t\tauto waf=[&](int i,int to){\n\t\t\tif(!asde(v,to)){\n\t\t\t\tint c=lca(v,to);\n\t\t\t\tint uplen=dep[v]-dep[c];\n\t\t\t\tint downlen=dep[to]-dep[c];\n\t\t\t\tif(uplen+downlen>=k){\n\t\t\t\t\tif(uplen>=k){\n\t\t\t\t\t\tint z=d.getpar(v,k-1);\n\t\t\t\t\t\tif(l<r){\n\t\t\t\t\t\t\tqs.pb({i,0,in[z],l,r,2});\n\t\t\t\t\t\t\tqs.pb({i,l,r,out[z],n,2});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(curvert){\n\t\t\t\t\t\t\tqs.pb({i,0,in[z],in[v],in[v]+1,1});\n\t\t\t\t\t\t\tqs.pb({i,in[v],in[v]+1,out[z],n,1});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(in[to]>in[v]&&downlen){\n\t\t\t\t\t\t\tint w=d.getpar(to,downlen-1);\n\t\t\t\t\t\t\tif(l<r)qs.pb({i,l,r,in[w],out[w],-2});\n\t\t\t\t\t\t\tif(curvert)qs.pb({i,in[v],in[v]+1,in[w],out[w],-1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(in[to]<in[v]){\n\t\t\t\t\t\t\tint z=d.getpar(to,(uplen+downlen-k));\n\t\t\t\t\t\t\tif(l<r)qs.pb({i,in[z],out[z],l,r,2});\n\t\t\t\t\t\t\tif(curvert)qs.pb({i,in[z],out[z],in[v],in[v]+1,1});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd(i,to);\n\t\t};\n\t\trng(tmpi,1,si(g[v])){\n\t\t\tmap<int,int> z=dfs(g[v][tmpi],d);\n\t\t\tfor(auto kv:z){\n\t\t\t\twaf(kv.a,kv.b);\n\t\t\t}\n\t\t\tr=out[g[v][tmpi]];\n\t\t}\n\t\tcurvert=1;\n\t\tfor(auto kv:pt[v]){\n\t\t\twaf(kv.a,kv.b);\n\t\t}\n\t\treturn move(res);\n\t}\n\tvoid slv(int kk,int m){\n\t\tk=kk;\n\t\tpt.resize(n);\n\t\tvc<pi> xy;\n\t\tll res=0;\n\t\trep(i,m){\n\t\t\tint a,b;cin>>a>>b;\n\t\t\ta--;b--;\n\t\t\tpt[a].eb(i,b);\n\t\t\tpt[b].eb(i,a);\n\t\t\txy.pb(minmax(in[a],in[b]));\n\t\t\tif(len(a,b)<k)res++;\n\t\t}\n\t\tdoubling<int> d(g,0);\n\t\tdfs(0,d);\n\t\t\n\t\tvi ans(m);\n\t\t\n\t\tpoint2d ysp(xy);\n\t\tfor(auto z:qs)ysp.aq(z.x1,z.x2,z.y1,z.y2);\n\t\tauto mrt=ysp.calc();\n\t\trep(i,si(qs)){\n\t\t\tres+=qs[i].w*mrt[i];\n\t\t}\n\t\t\n\t\tdmp(ans);\n\t\tres-=m;\n\t\tprint(res/2);\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,m;cin>>n>>m;\n\tint k;cin>>k;\n\t\n\tvvc<int> t(n);\n\trep(_,n-1){\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tt[a].pb(b);\n\t\tt[b].pb(a);\n\t}\n\t\n\tHLD<int> h(t,0);\n\th.slv(k,m);\n}\n']","[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",3500
Let number be such number that adding some leading zeros possible none to it produces a palindromic string String is called a palindrome if it reads the same from left to right and from right to left For example numbers and are they can be transformed to strings and respectively which are palindromes You are given some integer number Check if it s a number ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tstring S;\n\twhile (cin >> S) {\n\t\tbool ans = false;\n\t\trep(i, 10) {\n\t\t\tans |= S == string(S.rbegin(), S.rend());\n\t\t\tS = \'0\' + S;\n\t\t}\n\t\tputs(ans ? ""Yes"" : ""No"");\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",900
Polycarp has two favorite integers x and y they can be equal and he has found an array a of length n Polycarp considers a pair of indices langle i j rangle 1 le i j le n if a i a j is divisible by x a i a j is divisible by y For example if x 5 y 2 n 6 a 1 2 7 4 9 6 then the only pairs are langle 1 5 rangle a 1 a 5 1 9 10 10 is divisible by 5 and a 1 a 5 1 9 8 8 is divisible by 2 langle 4 6 rangle a 4 a 6 4 6 10 10 is divisible by 5 and a 4 a 6 4 6 2 2 is divisible by 2 Find the number of pairs in the array a ,"[""// Problem: D. Divisible Pairs\n// Contest: Codeforces - Codeforces Round 925 (Div. 3)\n// URL: https://codeforces.com/contest/1931/problem/D\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\n\nint T;\n\nvoid solve() {\n\tint n, x, y; cin >> n >> x >> y;\n\tvector<int> a(n + 1);\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tmap<pair<int, int>, int> mp;\n\tll ans = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tans += mp[{(x - a[i] % x) % x, a[i] % y}];\n\t\tmp[{a[i] % x, a[i] % y}]++;\n\t}\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n}""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]",1300
Today Osama gave Fadi an integer X and Fadi was wondering about the minimum possible value of max a b such that LCM a b equals X Both a and b should be positive integers LCM a b is the smallest positive integer that is divisible by both a and b For example LCM 6 8 24 LCM 4 12 12 LCM 2 3 6 Of course Fadi immediately knew the answer Can you be just like Fadi and find any such pair ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tlong long x; cin >> x;\n\tvector<long long> all;\n\tfor(long long i = 2; i * i <= x; i++){\n\t\tif(x % i == 0){\n\t\t\tlong long cup = 1;\n\t\t\twhile(x % i == 0) x /= i, cup *= i;\n\t\t\tall.push_back(cup);\n\t\t}\n\t}\n\tif(x != 1) all.push_back(x);\n\tint len = all.size();\n\tlong long ans = 1ll<<60, A, B;\n\tfor(int i = 0; i < 1<<len; i++){\n\t\tlong long a = 1, b = 1;\n\t\tfor(int j = 0; j < len; j++){\n\t\t\tif((i>>j)&1) a *= all[j];\n\t\t\telse b *= all[j];\n\t\t}\n\t\tif(ans > max(a, b)) A = a, B = b;\n\t\tans = min(ans, max(a, b));\n\t}\n\tcout << A << ' ' << B << endl;\n\treturn 0;\n}\n""]","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]",1400
You are given n segments on a Cartesian plane Each segment s endpoints have integer coordinates Segments can intersect with each other No two segments lie on the same line Count the number of distinct points with which are covered by at least one segment ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\ntypedef LL type;\ntypedef pair<type,type> Pt;\ntypedef pair<Pt,Pt> Seg;\ntypedef pair<Pt,type> Circle;\n#define X first\n#define Y second\n#define A first\n#define B second\n#define O first\n#define R second\nPt operator+( const Pt& p1 , const Pt& p2 ){\n  return { p1.X + p2.X , p1.Y + p2.Y };\n}\nPt operator-( const Pt& p1 , const Pt& p2 ){\n  return { p1.X - p2.X , p1.Y - p2.Y };\n}\nPt operator*( const Pt& tp , const type& tk ){\n  return { tp.X * tk , tp.Y * tk };\n}\nPt operator/( const Pt& tp , const type& tk ){\n  return { tp.X / tk , tp.Y / tk };\n}\ntype operator*( const Pt& p1 , const Pt& p2 ){\n  return p1.X * p2.X + p1.Y * p2.Y;\n}\ntype operator^( const Pt& p1 , const Pt& p2 ){\n  return p1.X * p2.Y - p1.Y * p2.X;\n}\ntype norm2( const Pt& tp ){\n  return tp * tp;\n}\ndouble norm( const Pt& tp ){\n  return sqrt( norm2( tp ) );\n}\nPt perp( const Pt& tp ){\n  return { tp.Y , -tp.X };\n}\nvoid scan(Pt& p){\n  p.X=getint();\n  p.Y=getint();\n}\nLL ori( const Pt& o , const Pt& a , const Pt& b ){\n  LL ret = ( a - o ) ^ ( b - o );\n  return (ret > 0) - (ret < 0);\n}\n// p1 == p2 || q1 == q2 need to be handled\nbool banana( const Pt& p1 , const Pt& p2 ,\n             const Pt& q1 , const Pt& q2 ){\n  if( ( ( p2 - p1 ) ^ ( q2 - q1 ) ) == 0 ){ // parallel\n    return false;\n  }\n  return (ori( p1, p2, q1 ) * ori( p1, p2, q2 )<=0) &&\n         (ori( q1, q2, p1 ) * ori( q1, q2, p2 )<=0);\n}\nPt interPnt( Pt p1, Pt p2, Pt q1, Pt q2, bool& res){\n  if(not banana(p1, p2, q1, q2)){\n    res=false;\n    return {0, 0};\n  }\n\tLL f1 = ( p2 - p1 ) ^ ( q1 - p1 );\n\tLL f2 = ( p2 - p1 ) ^ ( p1 - q2 );\n\tLL f = ( f1 + f2 );\n\tif(f == 0){\n    res=false;\n    return {0, 0};\n  }\n  LL rx=q1.X*f2+q2.X*f1;\n  LL ry=q1.Y*f2+q2.Y*f1;\n  if(rx % f or ry % f){\n    res=false;\n    return {0, 0};\n  }\n  res=true;\n  rx/=f;\n  ry/=f;\n  return {rx, ry};\n}\nvoid build(){\n\n}\nconst int N=1021;\nint n;\nSeg s[N];\nLL ans;\nLL gcd(LL a, LL b){\n  if(a and b) return __gcd(a, b);\n  return a+b;\n}\nset<pair<LL,LL>> tot;\nset<pair<LL,LL>> on[N];\nvoid init(){\n  n=getint();\n  for(int i=0; i<n; i++){\n    scan(s[i].A);\n    scan(s[i].B);\n    LL dx=abs(s[i].B.X-s[i].A.X);\n    LL dy=abs(s[i].B.Y-s[i].A.Y);\n    LL gg=gcd(dx, dy);\n    ans+=gg+1;\n  }\n}\nvoid solve(){\n  for(int i=0; i<n; i++)\n    for(int j=0; j<n; j++){\n      if(i == j) continue;\n      bool r=false;\n      Pt ret=interPnt(s[i].A, s[i].B, s[j].A, s[j].B, r);\n      if(not r) continue;\n      tot.insert(ret);\n      on[i].insert(ret);\n    }\n  for(int i=0; i<n; i++)\n    ans-=on[i].size();\n  ans+=tot.size();\n  printf(""%lld\\n"", ans);\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2400
Alice got a new doll these days It can even walk Alice has built a maze for the doll and wants to test it The maze is a grid with n rows and m columns There are k obstacles the i th of them is on the cell x i y i which means the cell in the intersection of the x i th row and the y i th column However the doll is clumsy in some ways It can only walk straight or turn right at most once in the same cell including the start cell It cannot get into a cell with an obstacle or get out of the maze More formally there exist 4 directions in which the doll can look The doll looks in the direction along the row from the first cell to the last While moving looking in this direction the doll will move from the cell x y into the cell x y 1 The doll looks in the direction along the column from the first cell to the last While moving looking in this direction the doll will move from the cell x y into the cell x 1 y The doll looks in the direction along the row from the last cell to first While moving looking in this direction the doll will move from the cell x y into the cell x y 1 The doll looks in the direction along the column from the last cell to the first While moving looking in this direction the doll will move from the cell x y into the cell x 1 y Standing in some cell the doll can move into the cell in the direction it looks or it can turn right once Turning right once the doll switches it s direction by the following rules 1 to 2 2 to 3 3 to 4 4 to 1 Standing in one cell the doll can make at most one turn right Now Alice is controlling the doll s moves She puts the doll in of the cell 1 1 the upper left cell of the maze Initially the doll looks to the direction 1 so along the row from the first cell to the last She wants to let the doll walk across all the cells without obstacles exactly once and end in any place Can it be achieved ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl \'\\n\'\ntypedef long long ll;\n\nconst int N = 1e5+5;\nset<int> iToj[N];\nset<int> jToi[N];\n\nsigned main() {\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.tie(0);\n    int n,m,k;\n    cin>>n>>m>>k;\n\n    for(int i=0;i<k;++i){\n        int I,J;\n        cin>>I>>J;\n        iToj[I].insert(J);\n        jToi[J].insert(I);\n    }\n    int mni = 0, mxi = n+1, mnj = 0, mxj = m+1;\n    pair<int, int> pos = {1,1};\n    int dir = 0;\n    int cnt = 1;\n    bool First = true;\n    while(true) {\n        assert(!iToj[pos.first].count(pos.second));//remove\n        //cout << ""here, cnt: "" << cnt << endl;\n        //cout << ""here, pos: "" << pos.first << \' \'<< pos.second << endl;\n        //cout << ""bounds: ""<< mni << \' \' << mnj << \' \' << mxi << \' \' << mxj << endl;\n            //cout << ""\\n\\n"";\n        if(dir == 0) {\n            pair<int,int> next = pos;\n            next.second = mxj-1;\n            auto it = iToj[pos.first].upper_bound(pos.second);\n            if(it != iToj[pos.first].end()) {\n                next.second = min(next.second, *it-1);\n            }\n            if(next.second <= pos.second) {\n                if(First) {\n                    dir = (dir+1)%4;\n                    First = false;\n                    continue;\n                }\n                break;\n            }\n            cnt += next.second - pos.second;\n            mxj = next.second;\n            mni = next.first;\n            pos = next;\n        } else if(dir == 1) {\n\n\n            pair<int,int> next = pos;\n            next.first = mxi-1;\n            auto it = jToi[pos.second].upper_bound(pos.first);\n            if(it != jToi[pos.second].end()) {\n                next.first = min(next.first, *it-1);\n            }\n            if(next.first <= pos.first) {\n                //cout << ""deuaslfj\\n"";\n                break;\n            }\n\n            cnt += next.first - pos.first;\n            mxi = next.first;\n            mxj = next.second;\n            pos = next;\n\n\n\n        } else if(dir == 2) {\n            pair<int,int> next = pos;\n            next.second = mnj+1;\n            auto it = iToj[pos.first].lower_bound(pos.second);\n            if(it != iToj[pos.first].begin()) {\n                --it;\n                next.second = max(next.second, *it+1);\n            }\n            if(next.second >= pos.second) {\n\n                break;\n            }\n            cnt += pos.second - next.second;\n            mnj = next.second;\n            mxi = next.first;\n            pos = next;\n\n        } else {\n            pair<int,int> next = pos;\n            next.first = mni+1;\n            auto it = jToi[pos.second].lower_bound(pos.first);\n            if(it != jToi[pos.second].begin()) {\n                --it;\n                next.first = max(next.first, *it+1);\n            }\n            if(next.first >= pos.first) {\n\n                break;\n            }\n            cnt += pos.first - next.first;\n            mni = next.first;\n            mnj = next.second;\n            pos = next;\n\n        }\n        dir = (dir+1)%4;\n        First = false;\n    }\n    //cout << ""cnt: "" << cnt << endl;\n    cout << (cnt + k == n*m ? ""Yes"":""No"");\n}\n']","[1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2300
There s a famous museum in the city where Kleof lives In the museum exhibits numbered through had been displayed for a long time the th of those exhibits has value and mass Then the museum was bought by a large financial group and started to vary the exhibits At about the same time Kleof gained interest in the museum so to say You should process events of three types type the museum displays an exhibit with value and mass the exhibit displayed in the th event of this type is numbered see sample explanation for more details type the museum removes the exhibit with number and stores it safely in its vault type Kleof visits the museum and wonders for no important reason at all of course if there was a robbery and exhibits with total mass at most were stolen what would their maximum possible total value be For each event of type 3 let be the maximum possible total value of stolen exhibits with total mass Formally let be the set of numbers of all exhibits that are currently displayed so initially 1 n Let be the set of all subsets of and let Then is defined as Compute for each Note that the output follows a special format ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007,P=10000000+19;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=30100;\nint dp[30][N];\nint n,k,st[N],ed[N],ty,it,qur[N],q;\nPII p[N];\nVI ps;\nvoid query(int d,int l,int r,VI item) {\n\trep(i,0,k+1) dp[d][i]=dp[d-1][i];\n//\tprintf(""L R %d %d\\n"",l,r);\n//\trep(j,0,SZ(item)) printf(""%d "",item[j]); puts("""");\n\trep(j,0,SZ(item)) if (st[item[j]]<=l&&ed[item[j]]>=r) {\n//\t\tprintf(""Add %d\\n"",item[j]);\n\t\tint v=p[item[j]].fi,w=p[item[j]].se;\n\t\tper(i,0,k+1) {\n\t\t\tif (i>=w) dp[d][i]=max(dp[d][i],dp[d][i-w]+v);\n\t\t}\n\t}\n\tif (l==r) {\n\t\tll ret=0;\n\t//\trep(i,1,k+1) printf(""%d "",dp[d][i]); puts("""");\n\t\tper(i,1,k+1) ret=(ret*P+dp[d][i])%mod;\n\t\trep(j,0,qur[l]) printf(""%d\\n"",(int)ret);\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tVI lt,rt;\n\t\trep(j,0,SZ(item)) {\n\t\t\tif (st[item[j]]<=l&&ed[item[j]]>=r) continue;\n\t\t\tif (ed[item[j]]<=md) lt.pb(item[j]);//,printf(""LL %d\\n"",item[j]);\n\t\t\telse if (st[item[j]]>md) rt.pb(item[j]);//,printf(""RR %d\\n"",item[j]);\n\t\t\telse lt.pb(item[j]),rt.pb(item[j]);//,printf(""LR %d\\n"",item[j]);\n\t\t}\n\t\tquery(d+1,l,md,lt);\n\t\tquery(d+1,md+1,r,rt);\n\t}\n}\nint main() {\n//\tfreopen(""in"",""r"",stdin);\n\tscanf(""%d%d"",&n,&k);\n\trep(i,1,n+1) scanf(""%d%d"",&p[i].fi,&p[i].se),st[i]=1;\n\tscanf(""%d"",&q);\n\tint cur=1,im=n;\n\trep(i,0,q) {\n\t\tscanf(""%d"",&ty);\n\t\tif (ty==3) {\n\t\t\tqur[cur]++;\n\t\t} else if (ty==2) {\n\t\t\tscanf(""%d"",&it);\n\t\t\ted[it]=cur++;\n\t\t} else {\n\t\t\tim++;\n\t\t\tscanf(""%d%d"",&p[im].fi,&p[im].se);\n\t\t\tst[im]=++cur;\n\t\t}\n\t}\n\trep(i,1,im+1) ps.pb(i);\n\trep(i,1,im+1) if (ed[i]==0) ed[i]=cur;\n//\trep(i,1,im+1) printf(""%d %d %d\\n"",i,st[i],ed[i]);\n\tquery(1,1,cur,ps);\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2800
Each day in Berland consists of n hours Polycarp likes time management That s why he has a fixed schedule for each day it is a sequence a 1 a 2 dots a n each a i is either 0 or 1 where a i 0 if Polycarp works during the i th hour of the day and a i 1 if Polycarp rests during the i th hour of the day Days go one after another endlessly and Polycarp uses the same schedule for each day What is the maximal number of continuous hours during which Polycarp rests It is guaranteed that there is at least one working hour in a day ,"['#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    ll n, x;\n    cin >> n;\n    vector<ll> a;\n    for(int i = 0; i < n; ++i){\n        cin >> x;\n        a.pb(x);\n    }\n\n    for(int i = 0; i < n; ++i){\n        a.pb(a[i]);\n    }\n\n    ll mx = 0, cur = 0;\n\n    for(int i = 0; i < 2*n; ++i){\n        if(a[i] == 1){\n            cur++;\n        }\n        else{\n            mx = max(mx, cur);\n            cur = 0;\n        }\n    }\n\n    cout << mx;\n\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
It s now AD Shapur being extremely smart became the King of Persia He is now called Shapur His majesty King of kings of Iran and Aniran Recently the Romans declared war on Persia They dreamed to occupy Armenia In the recent war the Romans were badly defeated Now their senior army general Philip is captured by Shapur and Shapur is now going to capture Valerian the Roman emperor Being defeated the cowardly Valerian hid in a room at the top of one of his castles To capture him Shapur has to open many doors Fortunately Valerian was too scared to make impenetrable locks for the doors Each door has parts The first part is an integer number The second part is either an integer number or some really odd sign which looks like The third one is an integer and the fourth part is empty As if it was laid for writing something Being extremely gifted after opening the first few doors Shapur found out the secret behind the locks is an integer written in base to open the door we should write it in base The only bad news is that this is some sort of special numbering system that is used only in Roman empire so opening the doors is not just a piece of cake Here s an explanation of this really weird number system that even doesn t have zero Roman numerals are based on seven symbols a stroke identified with the letter for a unit a chevron identified with the letter for a five a cross stroke identified with the letter for a ten a identified as an abbreviation of Centum for a hundred etc Symbols are iterated to produce multiples of the decimal values with substituted for a multiple of five and the iteration continuing etc and the same for other bases etc At the fourth and ninth iteration a subtractive principle must be employed with the base placed before the higher base Also in bases greater than we use for for etc Help Shapur capture Valerian and bring peace back to Persia especially Armenia ,"['# include <cstdio>\n\nchar conv[]=""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"";\n\nvoid printroman(long long N)\n{\n    while(N>=1000)\n    {\n        printf(""M"");\n        N-=1000;\n    }\n    while(N>=900)\n    {\n        printf(""CM"");\n        N-=900;\n    }\n    while(N>=500)\n    {\n        printf(""D"");\n        N-=500;\n    }\n    while(N>=400)\n    {\n        printf(""CD"");\n        N-=400;\n    }\n    while(N>=100)\n    {\n        printf(""C"");\n        N-=100;\n    }\n    while(N>=90)\n    {\n        printf(""XC"");\n        N-=90;\n    }\n    while(N>=50)\n    {\n        printf(""L"");\n        N-=50;\n    }\n    while(N>=40)\n    {\n        printf(""XL"");\n        N-=40;\n    }\n    while(N>=10)\n    {\n        printf(""X"");\n        N-=10;\n    }\n    while(N>=9)\n    {\n        printf(""IX"");\n        N-=9;\n    }\n    while(N>=5)\n    {\n        printf(""V"");\n        N-=5;\n    }\n    while(N>=4)\n    {\n        printf(""IV"");\n        N-=4;\n    }\n    while(N>=1)\n    {\n        printf(""I"");\n        N-=1;\n    }\n}\n\nlong long toint(char *inp,int base)\n{\n    long long ret=0ll;\n    for(int i=0;inp[i];i++)\n        ret=ret*base+(inp[i]<\'A\'?inp[i]-\'0\':inp[i]-\'A\'+10);\n    return ret;\n}\n\nvoid printbase(long long N,int base)\n{\n    if(N>=base)printbase(N/base,base);\n    printf(""%c"",conv[N%base]);\n}\n\nint main()\n{\n    int A;\n    scanf(""%d"",&A);\n    \n    char B[3];\n    scanf(""%s"",B);\n    \n    int b;\n    if(B[0]!=\'R\')sscanf(B,""%d"",&b);\n    \n    char C[1001];\n    scanf(""%s"",C);\n    \n    long long I=toint(C,A);\n\n    if(B[0]==\'R\')\n        printroman(I);\n    else\n        printbase(I,b);\n    printf(""\\n"");\n    \n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
ICPC Assiut Community decided to hold a unique chess contest and you were chosen to control a queen and hunt down the hidden king while a member of ICPC Assiut Community controls this king You compete on an 8 times8 chessboard the rows are numerated from top to bottom and the columns are numerated left to right and the cell in row x and column y is denoted as x y In one turn you can move the queen to any of the squares on the same horizontal line vertical line or any of the diagonals For example if the queen was on square 4 5 you can move to q 1 5 4 q 1 q 1 9 q 1 or q 2 q 2 1 where 1 le q 1 le 8 q 1 ne 4 1 le q 2 le 7 q 2 ne 4 Note that the queen stay on its current cell In one turn the king can move Right Left Up Down Down Right Down Left Up Left or Up Right such that he doesn t get out of the board The king move into a cell that is on the same row column or diagonal with the queen including the position of the queen itself For example if the king was on square 4 5 he can move to 4 k 1 5 k 2 where 1 le k 1 k 2 le 1 k 1 k 2 ne 0 0 At the start of the game you should place the queen at any location on the board and this is done once per game After that the king is secretly placed at any cell different from the queen s location You do not know the position of the king Then the king and the queen take turns with the king moving first The king moves to one of the possible directions Right Down Up Left etc and you are only given the direction it moves to After that you should move your queen by declaring the square to which your queen will move The game follows like this until you win the game or run out of moves You win if the king has no valid moves You lose if after 130 moves of the queen the king still has valid moves ,"['#include<bits/stdc++.h>\nusing namespace std;\nint cx,cy,is[10][10],cnt,F=0;\nstring res;\nvoid Move(int dx,int dy){\n\tint tmp[10][10]={0};\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)tmp[i+dx][j+dy]=is[i][j];\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)is[i][j]=tmp[i][j];\n}\nvoid Make(int x,int y){\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)if(i==x||j==y||i+j==x+y||i-j==x-y)is[i][j]=0;\n}\nvoid MoveKing(){\n\tcin>>res;\n\tif(res==""Left"")Move(0,-1);\n\tif(res==""Right"")Move(0,1);\n\tif(res==""Up"")Move(-1,0);\n\tif(res==""Down"")Move(1,0);\n\tif(res==""Down-Right"")Move(1,1);\n\tif(res==""Down-Left"")Move(1,-1);\n\tif(res==""Up-Right"")Move(-1,1);\n\tif(res==""Up-Left"")Move(-1,-1);\n\tif(res==""Done"")F=1;\n}\nvoid Min(int &x,int &y,int tox,int toy){\n\tint mn=1e9;\n\tfor(int i=1;i<=8;i++)\n\t\tfor(int j=1;j<=8;j++){\n\t\t\tif(i==cx||j==cy||i+j==cx+cy||i-j==cx-cy){\n\t\t\t\tif(!(i==cx&&j==cy)){\n\t\t\t\t\tif(abs(i-tox)+abs(j-toy)<mn)mn=abs(i-tox)+abs(j-toy),x=i,y=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\nvoid Solve(){\n\tfor(int i=1;i<=8;i++)for(int j=1;j<=8;j++)is[i][j]=(i-1)*8+j;\n\tcx=1,cy=1,cnt=0,F=0;\n\tcout<<cx<<\' \'<<cy<<endl,cnt++,MoveKing();\n\tif(F)return ;\n\tMake(cx,cy);\n//\t\t\tfor(int i=1;i<=8;i++){\n//\t\t\t\tfor(int j=1;j<=8;j++){\n//\t\t\t\t\tcout<<is[i][j]<<\' \';\n//\t\t\t\t}\n//\t\t\t\tputs("""");\n//\t\t\t}\n\twhile(1){\n\t\tint w=0;\n\t\tfor(int i=1;i<=8;i++){\n\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\tif(is[i][j])w=is[i][j];\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tint p=0,q=0;\n\t\t\tfor(int i=1;i<=8;i++){\n\t\t\t\tfor(int j=1;j<=8;j++){\n\t\t\t\t\tif(is[i][j]==w)p=i,q=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!p)break;\n\t\t\tint tx,ty;\n\t\t\tMin(tx,ty,p,q);\n\t\t\tcx=tx,cy=ty;\n\t\t\t//cout<<""w:""<<w<<endl;\n\t\t\tcout<<cx<<\' \'<<cy<<endl,cnt++,assert(cnt<=130),MoveKing();\n\t\t\tif(F)return ;\n\t\t\tMake(cx,cy);\n//\t\t\tfor(int i=1;i<=8;i++){\n//\t\t\t\tfor(int j=1;j<=8;j++){\n//\t\t\t\t\tcout<<is[i][j]<<\' \';\n//\t\t\t\t}\n//\t\t\t\tputs("""");\n//\t\t\t}\n\t\t}\n\t\t\n\t}\n}\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--)Solve();\n}']","[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2800
Andrey thinks he is truly a successful developer but in reality he didn t know about the binary search algorithm until recently After reading some literature Andrey understood that this algorithm allows to quickly find a certain number x in an array For an array a indexed from zero and an integer x the pseudocode of the algorithm is as follows Note that the elements of the array are indexed from zero and the division is done in integers rounding down Andrey read that the algorithm only works if the array is sorted However he found this statement untrue because there certainly exist unsorted arrays for which the algorithm find x Andrey wants to write a letter to the book authors but before doing that he must consider the permutations of size n such that the algorithm finds x in them A permutation of size n is an array consisting of n distinct integers between 1 and n in arbitrary order Help Andrey and find the number of permutations of size n which contain x at position pos and for which the given implementation of the binary search algorithm finds x returns true As the result may be extremely large print the remainder of its division by 10 9 7 ,"['//#pragma GCC optimize(""Ofast"",""unroll-loops"",""omit-frame-pointer"",""inline"") //Optimization flags\n//#pragma GCC option(""arch=native"",""tune=native"",""no-zero-upper"") //Enable AVX\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n\n#include <bits/stdc++.h>\n\n#ifdef LOCAL\n#include ""debug-template.hpp""\n#endif\n\nusing namespace std;\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint n, x, pos; cin >> n >> x >> pos;\n\tvector<int> a(n, -1);\n\tint l = 0, r = n;\n\twhile (l < r) {\n\t\tint mid = l + r >> 1;\n\t\tif (mid <= pos) {\n\t\t\tl = mid + 1;\n\t\t\ta[mid] = 0;\n\t\t} else {\n\t\t\tr = mid;\n\t\t\ta[mid] = 1;\n\t\t}\n\t}\n\tint c0 = 0, c1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == pos) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (a[i] == 1) {\n\t\t\tc1++;\n\t\t}\n\t\tif (a[i] == 0) {\n\t\t\tc0++;\n\t\t}\n\t}\n\tconst int P = 1e9 + 7;\n\tint ans = 1;\n\tfor (int i = x - 1; i >= x - c0; i--) {\n\t\tans = ans * 1LL * i % P;\n\t}\n\tfor (int i = n - x; i >= n - x - c1 + 1; i--) {\n\t\tans = ans * 1LL * i % P;\n\t}\n\tfor (int i = 1; i <= n - c0 - c1 - 1; i++) {\n\t\tans = ans * 1LL * i % P;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]",1500
Vasilisa the Wise from the Kingdom of Far Far Away got a magic box with a secret as a present from her friend Hellawisa the Wise from the Kingdom of A Little Closer However Vasilisa the Wise does not know what the box s secret is since she cannot open it again She hopes that you will help her one more time with that The box s lock looks as follows it contains identical deepenings for gems as a square and some integer numbers are written at the lock s edge near the deepenings The example of a lock is given on the picture below The box is accompanied with gems Their shapes match the deepenings shapes and each gem contains one number from to each number is written on exactly one gem The box will only open after it is decorated with gems correctly that is each deepening in the lock should be filled with exactly one gem Also the sums of numbers in the square s rows columns and two diagonals of the square should match the numbers written at the lock s edge For example the above lock will open if we fill the deepenings with gems with numbers as is shown on the picture below Now Vasilisa the Wise wants to define given the numbers on the box s lock which gems she should put in the deepenings to open the box Help Vasilisa to solve this challenging task ,"[""#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <numeric>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\n#define two(X) (1<<(X))\n#define SIZE(A) ((int)(A.size()))\n#define LENGTH(A) ((int)A.length())\n#define random(x) (rand()%x)\n#define randomize() (srand((int)time(0)))\n\ntypedef long long int64;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\nconst int INF=0x7FFFFFFF;\nconst double eps=1e-10;\nconst double pi=acos(-1.0);\n\n\nint r1,r2,c1,c2,d1,d2;\n\nint main()\n{\n\tcin>>r1>>r2>>c1>>c2>>d1>>d2;\n\tfor (int i=1; i<=9; i++)\n\t\tfor (int j=1; j<=9; j++)\n\t\t\tfor (int x=1; x<=9; x++)\n\t\t\t\tfor (int y=1; y<=9; y++)\n\t\t\t\t\tif (i+j==r1 && x+y==r2 && i+x==c1 && j+y==c2 && i+y==d1 && j+x==d2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (i==j || i==x || i==y || j==x || j==y || x==y) continue;\n\t\t\t\t\t\tcout<<i<<' '<<j<<endl;\n\t\t\t\t\t\tcout<<x<<' '<<y<<endl;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\tcout<<-1<<endl;\n\treturn 0;\n}\n\n""]","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1000
You are given an array a of length n Let s define the operation Let x a n Then array a is partitioned into two parts left and right The left part contains the elements of a that are not greater than x le x The right part contains the elements of a that are strictly greater than x x The order of elements in each part is kept the same as before the operation i e the partition is stable Then the array is replaced with the concatenation of the left and the right parts For example if the array a is 2 4 1 5 3 the eversion goes like this 2 4 1 5 3 to 2 1 3 4 5 to 2 1 3 4 5 We start with the array a and perform eversions on this array We can prove that after several eversions the array a stops changing Output the minimum number k such that the array stops changing after k eversions ,"[""#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define pb push_back\n#define fir first\n#define sec second\n#define SZ(x) (int(x.size()))\ninline int read(){\n    int x=0;char ch=getchar();\n    int f=0;\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char let){\n    print(x),putchar(let);\n}\ntemplate<typename T1,typename T2>void ckmin(T1&x,T2 y){\n    if(x>y)x=y;\n}\ntemplate<typename T1,typename T2>void ckmax(T1&x,T2 y){\n    if(x<y)x=y;\n}\n\nint n;\nint a[200005];\n\nvoid solve(){\n    n=read();\n    rep(i,1,n)a[i]=read();\n    int las=n,cnt=0;\n    per(i,n-1,1)if(a[i]>a[las])las=i,cnt++;\n    print(cnt,'\\n');\n}\nint main(){\n    int T=read();\n    while(T--){\n        solve();\n    }\n    return 0;\n}""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
Ani and Borna are playing a short game on a two variable polynomial It s a special kind of a polynomial the monomials are fixed but all of its coefficients are fill in the blanks dashes e g xy x 4 y 7 x 8 y 3 ldots Borna will fill in the blanks with positive integers He wants the polynomial to be i e his goal is to make sure there exists a real number M such that the value of the polynomial at any point is greater than M Ani is mischievous and wants the polynomial to be unbounded Along with stealing Borna s heart she can also steal parts of polynomials Ani is only a petty kind of thief though she can only steal monomial from the polynomial before Borna fills in the blanks If Ani and Borna play their only moves optimally who wins ,"['#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200000;\n\nstruct P { int x,y,id; P() {} P(int x,int y):x(x),y(y),id(-1) {} };\nbool operator<(const P &a,const P &b) { if(a.x!=b.x) return a.x<b.x; return a.y<b.y; }\nP operator-(const P &a,const P &b) { return P(a.x-b.x,a.y-b.y); }\nll operator^(const P &a,const P &b) { return (ll)a.x*b.y-(ll)a.y*b.x; }\nll side(const P &a,const P &b,const P &c) { return (b-a)^(c-a); }\n\nint no;\nP o[MAXN];\n\nint np;\nP p[MAXN+1];\nbool killed[MAXN+1];\n\nint nh;\nP h[MAXN+2];\n\nint lst[MAXN+1],nlst;\n\nvoid makehull() { // assumes sorted\n\tnh=0; assert(!killed[0]); h[nh++]=p[0]; int tmp,last=-1;\n\ttmp=nh; FOR(i,1,np) if(!killed[i]) { while(nh>tmp&&side(h[nh-2],h[nh-1],p[i])<=0) --nh; h[nh++]=p[i]; last=i; }\n\ttmp=nh; for(int i=last-1;i>=0;--i) if(!killed[i]) { while(nh>tmp&&side(h[nh-2],h[nh-1],p[i])<=0) --nh; h[nh++]=p[i]; }\n\t--nh;\n}\n\nbool solve() {\n\tno=np; REP(i,np) o[i]=p[i];\n\t\n\tp[np++]=P(0,0);\n\tsort(p,p+np);\n\tREP(i,np) p[i].id=i;\n\tREP(i,np) killed[i]=false;\n\tmakehull();\n\tREP(i,nh) if(h[i].x%2==1||h[i].y%2==1) return true;\n\n\tnlst=nh; REP(i,nh) lst[i]=h[i].id;\n\tFORE(off,1,2) {\n\t\tREP(i,np) killed[i]=false; for(int i=off;i<nlst;i+=2) killed[lst[i]]=true;\n\t\tmakehull();\n\t\tREP(i,nh) if(h[i].x%2==1||h[i].y%2==1) return true;\n\t}\n\treturn false;\n}\n\nvoid run() {\n\tscanf(""%d"",&np);\n\tREP(i,np) scanf(""%d%d"",&p[i].x,&p[i].y);\n\tprintf(""%s\\n"",solve()?""Ani"":""Borna"");\n}\n\nint main() {\n\trun();\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3400
There are n students at your university The programming skill of the i th student is a i As a coach you want to divide them into teams to prepare them for the upcoming ICPC finals Just imagine how good this university is if it has 2 cdot 10 5 students ready for the finals Each team should consist of Each student should belong to The of a team is the difference between the programming skill of some student that belongs to this team and the programming skill of some student that belongs to this team in other words if the team consists of k students with programming skills a i 1 a i 2 dots a i k then the of this team is max limits j 1 k a i j min limits j 1 k a i j The total is the sum of of all teams formed Your task is to minimize the total of the division of students and find the optimal way to divide the students ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXA=3e5;\nint n,N,b[MAXA],c[MAXA];\nlong long f[MAXA],a[MAXA];\nint mysort(int x,int y){\n    return a[x]<a[y];\n}\nint main(){\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++) scanf(""%lld"",&a[i]),c[i]=i;\n    sort(c+1,c+n+1,mysort);\n    for(int i=1;i<=n;i++){\n\tf[i]=1e18;\n\tfor(int j=3;j<=min(6,i);j++){\n\t    f[i]=min(f[i],f[i-j]+a[c[i]]-a[c[i-j+1]]);\n\t}\n    }\n    for(int i=n;i;){\n\tfor(int j=3;j<=min(6,i);j++)\n\t    if(f[i]==f[i-j]+a[c[i]]-a[c[i-j+1]]){\n\t\t++N;\n\t\tfor(int k=1;k<=j;k++) b[c[i-k+1]]=N;\n\t\ti=i-j;\n\t\tbreak;\n\t    }\n    }\n    printf(""%lld %d\\n"",f[n],N);\n    for(int i=1;i<=n;i++) printf(""%d "",b[i]);\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2000
In the evening after the contest Ilya was bored and he really felt like maximizing He remembered that he had a set of sticks and an instrument Each stick is characterized by its length Ilya decided to make a rectangle from the sticks And due to his whim he decided to make rectangles in such a way that maximizes their total area Each stick is used in making at most one rectangle it is possible that some of sticks remain unused Bending sticks is not allowed Sticks with lengths and can make a rectangle if the following properties are observed A rectangle can be made of sticks with lengths of for example or A rectangle cannot be made of for example sticks Ilya also has an instrument which can reduce the length of the sticks The sticks are made of a special material so the length of each stick can be reduced by at most one For example a stick with length can either stay at this length or be transformed into a stick of length You have to answer the question what maximum total area of the rectangles can Ilya get with a file if makes rectangles from the available sticks ,"['#include <bits/stdc++.h>\n\n#define\tst first\n#define\tnd second\n#define\tmp make_pair\n#define\tpb push_back\n#define\tlli long long int\n#define\tall( gg )\tgg.begin(),gg.end()\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tFP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )\n#define\tFM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )\n#define\tdebug(ccc)\tcout << #ccc << "" = "" << ccc << endl;\n\n#define\tmod\t1000000007LL\n\nusing namespace std;\n\nint\tn;\nlli\tarr[200000];\nvector<lli>\tv;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tscanf(""%d"",&n);\n\tFP( i,1,n )\n\t\tscanf(""%lld"",arr+i);\n\tsort( arr+1,arr+n+1 );\n\treverse( arr+1,arr+n+1 );\n\tFP( i,1,n-1 ){\n\t\tif( arr[i]==arr[i+1] or arr[i]-1==arr[i+1] ){\n\t\t\tv.pb( min( arr[i],arr[i+1] ) );\n\t\t\ti++;\n\t\t}\n\t}\n\tsort( all(v) );\n\tlli\tres=0;\n\twhile( v.size()>=2 ){\n\t\tres += v.back()*v[v.size()-2];\n\t\tv.pop_back();\n\t\tv.pop_back();\n\t}\n\tcout << res << endl;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1600
There are n points and a line x y k on a two dimensional plane The i th point is at x i y i All points have non negative coordinates and are strictly below the line Alternatively 0 leq x i y i x i y i k Tenzing wants to erase all the points He can perform the following two operations Draw triangle Tenzing will choose two non negative integers a b that satisfy a b k then all points inside the triangle formed by lines x a y b and x y k will be erased It can be shown that this triangle is an isosceles right triangle Let the side lengths of the triangle be l l and sqrt 2 l respectively Then the cost of this operation is l cdot A The blue area of the following picture describes the triangle with a 1 b 1 with cost 1 cdot A Erase a specific point Tenzing will choose an integer i that satisfies 1 leq i leq n and erase the point i The cost of this operation is c i Help Tenzing find the minimum cost to erase all of the points ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:36:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    long long mx = 0;\n    long long add = 0;\n\n    void apply(int l, int r, long long v) {\n      mx += v;\n      add += v;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.mx = max(a.mx, b.mx);\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    if (tree[x].add != 0) {\n      tree[x + 1].apply(l, y, tree[x].add);\n      tree[z].apply(y + 1, r, tree[x].add);\n      tree[x].add = 0;\n    }\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  long long A;\n  cin >> n >> k >> A;\n  vector<int> l(n), r(n);\n  vector<long long> cost(n);\n  long long total = 0;\n  for (int i = 0; i < n; i++) {\n    int x, y;\n    cin >> x >> y >> cost[i];\n    l[i] = x;\n    r[i] = k - y;\n    total += cost[i];\n  }\n  vector<vector<int>> at(k + 1);\n  for (int i = 0; i < n; i++) {\n    at[r[i]].push_back(i);\n  }\n  segtree st(k + 1);\n  long long dp = 0;\n  for (int i = 1; i <= k; i++) {\n    for (int id : at[i]) {\n      st.modify(0, l[id], +cost[id]);\n    }\n    dp = max(dp, -A * i + st.get(0, i - 1).mx);\n    st.modify(i, i, dp + A * i);\n  }\n  cout << total - dp << \'\\n\';\n  return 0;\n}\n']","[1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
Welcome to Codeforces Stock Exchange We re pretty limited now as we currently allow trading on one stock Codeforces Ltd We hope you ll still be able to make profit from the market In the morning there are n opportunities to buy shares The i th of them allows to buy as many shares as you want each at the price of s i bourles In the evening there are m opportunities to sell shares The i th of them allows to sell as many shares as you want each at the price of b i bourles You can t sell more shares than you have It s morning now and you possess r bourles and no shares What is the maximum number of bourles you can hold after the evening ,"['#include<bits/stdc++.h>\nconst int MAXN=30+5;\nint n,m,r;\nint s[MAXN+5],b[MAXN+5];\nint mins=1000,maxb=1;\nint main(){\n\tscanf(""%d%d%d"",&n,&m,&r);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(""%d"",&s[i]);\n\t\tmins=std::min(mins,s[i]);\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tscanf(""%d"",&b[i]);\n\t\tmaxb=std::max(maxb,b[i]);\n\t}\n\tif(mins>=maxb){\n\t\tprintf(""%d\\n"",r);\n\t}else{\n\t\tprintf(""%d\\n"",r%mins+r/mins*maxb);\n\t}\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Timur likes his name As a spelling of his name he allows any permutation of the letters of the name For example the following strings are valid spellings of his name Note that the correct spelling must have uppercased and lowercased other letters Today he wrote string s of length n consisting only of uppercase or lowercase Latin letters He asks you to check if s is the correct spelling of his name ,"['#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define md(a) a=(a%mod+mod)%mod\n#define file(a) freopen(#a"".in"",""r"",stdin);freopen(#a"".out"",""w"",stdout)\nint T;\nint n;\nstring s;\nint g(char c)\n{\n\tint ans=0;\n\tfor(int i=0;i<=4;i++)if(c==s[i])ans++;\n\treturn ans;\n}\nvoid solve()\n{\n\tcin>>n>>s;\n\tif(n!=5)\n\t{\n\t\tcout<<""NO""<<endl;\n\t\treturn ;\n\t}\n\tif(g(\'T\')!=1){cout<<""NO""<<endl;return ;}\n\tif(g(\'i\')!=1){cout<<""NO""<<endl;return ;}\n\tif(g(\'m\')!=1){cout<<""NO""<<endl;return ;}\n\tif(g(\'u\')!=1){cout<<""NO""<<endl;return ;}\n\tif(g(\'r\')!=1){cout<<""NO""<<endl;return ;}\n\tcout<<""YES""<<endl;return ;\n}\nsigned main()\n{\n\tscanf(""%d"",&T);\n\twhile(T--)solve();\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
A binary string is a string where every character is texttt 0 or texttt 1 Call a binary string if it has an equal number of texttt 0 s and texttt 1 s Initially you have an infinite binary string t whose characters are all texttt 0 s You are given a sequence a of n updates where a i indicates that the character at index a i will be flipped texttt 0 leftrightarrow texttt 1 You need to keep and modify after each update a set S of ranges such that for each range l r the substring t l dots t r is a decent binary string and for all indices i such that t i texttt 1 there exists l r in S such that l leq i leq r You only need to output the ranges that are added to or removed from S after each update You can only add or remove ranges from S at most mathbf 10 6 times More formally let S i be the set of ranges after the i th update where S 0 varnothing the empty set Define X i to be the set of ranges removed after update i and Y i to be the set of ranges added after update i Then for 1 leq i leq n S i S i 1 setminus X i cup Y i The following should hold for all 1 leq i leq n forall a b in S i a neq b rightarrow a cap b varnothing X i subseteq S i 1 S i 1 setminus X i cap Y i varnothing displaystyle sum i 1 n X i Y i leq 10 6 ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc getchar()\n// #define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=1e6+1,mod=1e9+7;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint n,m=N-1;\n#define P pair<int,int>\nset<P>mp;\nV input(){\n\tn = getint();\n}\nset<int>one,zero,alen;\nV init(){\n\tFOR(i,1,m)zero.insert(i);\n\tFOR(i,1,m)alen.insert(i);\n}\nstruct node{ // 维护历史最小值\n\tint minn, sum;\n\tnode operator+(const node&o)const{\n\t\tnode out;\n\t\tout.minn = min(minn,sum+o.minn);\n\t\tout.sum = sum+o.sum;\n\t\treturn out;\n\t}\n}t1[N<<2],t2[N<<2];\n#define lc p<<1\n#define rc lc|1\n#define root 1,1,m\n#define lson lc,L,mid\n#define rson rc,mid+1,R\nV build(int p,int L,int R){\n\tt1[p].minn = t2[p].minn = -(R-L+1);\n\tt1[p].sum = t2[p].sum = -(R-L+1);\n\tif(L==R)return;\n\tint mid=L+R>>1;\n\tbuild(lson),build(rson);\n}\nV upd(int p){\n\tt1[p]=t1[lc]+t1[rc];\n\tt2[p]=t2[rc]+t2[lc];\n}\nV change(int p,int L,int R,int x,int w){\n\tif(L==R){\n\t\tif(w){\n\t\t\tt1[p].minn = t2[p].minn = 1;\n\t\t\tt1[p].sum = t2[p].sum = 1;\n\t\t}\n\t\telse{\n\t\t\tt1[p].minn = t2[p].minn = -1;\n\t\t\tt1[p].sum = t2[p].sum = -1;\n\t\t}\n\t\treturn;\n\t}\n\tint mid=L+R>>1;\n\tif(x<=mid)change(lson,x,w);\n\telse change(rson,x,w);\n\tupd(p);\n}\nnode ask1(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t1[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask1(rson,l,r);\n\tif(r<=mid)return ask1(lson,l,r);\n\treturn ask1(lson,l,mid)+ask1(rson,mid+1,r);\n}\nnode ask2(int p,int L,int R,int l,int r){\n\tif(L==l&&R==r)return t2[p];\n\tint mid=L+R>>1;\n\tif(l>mid)return ask2(rson,l,r);\n\tif(r<=mid)return ask2(lson,l,r);\n\treturn ask2(rson,mid+1,r)+ask2(lson,l,mid);\n}\nV work(){\n\tint x, l, r;\n\tbuild(1,1,m);\n\twhile(n--){\n\t\tx = getint();\n\t\tif(zero.find(x)!=zero.end()){\n\t\t\tl = x, r = *alen.upper_bound(x); // 找一个不被管辖的 0\n\t\t\t// alen.erase(x);\n\t\t\tif(alen.find(x)!=alen.end())\n\t\t\t\talen.erase(x);\n\t\t\telse{\n\t\t\t\talen.erase(r);\n\t\t\t\tr = *alen.upper_bound(x);\n\t\t\t}\n\t\t\talen.erase(r);\n\t\t\tauto it = mp.upper_bound(P(x+1,0));\n\t\t\tif(it != mp.begin()){\n\t\t\t\tauto tmp = it;\n\t\t\t\ttmp --;\n\t\t\t\tif(tmp->first<=x && tmp->second >=x)\n\t\t\t\t\tit --;\n\t\t\t}\n\t\t\tif(it != mp.end()) cmin(l,it->first);\n\t\t\tauto itl = it;\n\t\t\tint cnt = 0;\n\t\t\twhile(it != mp.end() && it->second<=r){\n\t\t\t\tcmax(r, it->second);\n\t\t\t\tit ++, cnt ++;\n\t\t\t}\n\t\t\tauto itr = it;\n\t\t\tcout<<cnt<<\'\\n\';\n\t\t\tfor(it = itl;it!=itr;it++){\n\t\t\t\tcout<<it->first<<\' \'<<it->second<<\'\\n\';\n\t\t\t}\n\t\t\tmp.erase(itl, itr);\n\t\t\tmp.insert(P(l,r));\n\t\t\tcout<<1<<\'\\n\';\n\t\t\tcout<<l<<\' \'<<r<<\'\\n\';\n\t\t\t// auto v = *--mp.lower_bound()\n\t\t\tzero.erase(x);\n\t\t\tone.insert(x);\n\t\t\tchange(root,x,1);\n\t\t}\n\t\telse{\n\t\t\tauto it = --mp.upper_bound(P(x+1,0));\n\t\t\tchange(root,x,0);\n\t\t\tcout<<1<<\'\\n\';\n\t\t\tint l = it->first,r = it->second;\n\t\t\tcout<<l<<\' \'<<r<<\'\\n\';\n\t\t\tmp.erase(it);\n\t\t\tint L, R, mid1, mid2;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid1=L+R>>1,L^R)\n\t\t\t\tif(ask1(root,l,mid1).minn <= -1) R=mid1;\n\t\t\t\telse L=mid1+1;\n\t\t\tL = l, R = r;\n\t\t\twhile(mid2=L+R>>1, L^R)\n\t\t\t\tif(ask2(root,mid2+1,r).minn<=-1)\n\t\t\t\t\tL=mid2+1;\n\t\t\t\telse R= mid2;\n\t\t\t// if(l == x || ask1(root,l,x-1).sum == 0){\n\t\t\t// \tL = x+1, R=r;\n\t\t\t// \twhile(mid=L+R>>1, L^R)\n\t\t\t// \t\tif(ask2(root,mid+1,r).minn<=-1)\n\t\t\t// \t\t\tL=mid+1;\n\t\t\t// \t\telse R= mid;\n\t\t\t// }\n\t\t\t// else{\n\t\t\t// \tL = l, R = x-1;\n\t\t\t// \twhile(mid=L+R>>1,L^R)\n\t\t\t// \t\tif(ask1(root,l,mid).minn <= -1) R=mid;\n\t\t\t// \t\telse L=mid+1;\n\t\t\t// }\n\t\t\tint cnt = (l<=mid1-1) + (mid1+1<=mid2-1)+(mid2+1<=r);\n\t\t\tcout<<cnt<<\'\\n\';\n\t\t\tif(l<=mid1-1){\n\t\t\t\tmp.insert(P(l,mid1-1));\n\t\t\t\tcout<<l<<\' \'<<mid1-1<<\'\\n\';\n\t\t\t}\n\t\t\tif(mid1+1<=mid2-1){\n\t\t\t\tmp.insert(P(mid1+1,mid2-1));\n\t\t\t\tcout<<mid1+1<<\' \'<<mid2-1<<\'\\n\';\n\t\t\t}\n\t\t\tif(mid2+1<=r){\n\t\t\t\tmp.insert(P(mid2+1,r));\n\t\t\t\tcout<<mid2+1<<\' \'<<r<<\'\\n\';\n\t\t\t}\n\t\t\tone.erase(x);\n\t\t\tzero.insert(x);\n\t\t\talen.insert(mid1);\n\t\t\talen.insert(mid2);\n\t\t}\n\t\t// cerr<<""===========================\\n"";\n\t}\n}\nint main(){\n\t// freopen(""test.in"",""r"",stdin);\n//\tfreopen("".out"",""w"",stdout);\n\t// for(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t// }\n\treturn 0;\n}\n\n']","[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3000
When the river brought Gerda to the house of the Old Lady who Knew Magic this lady decided to make Gerda her daughter She wants Gerda to forget about Kay so she puts all the roses from the garden underground Mole who lives in this garden now can watch the roses without going up to the surface Typical mole is blind but this mole was granted as special vision by the Old Lady He can watch any underground objects on any distance even through the obstacles and other objects However the quality of the picture depends on the Manhattan distance to object being observed Mole wants to find an point to watch roses that is such point with that the maximum Manhattan distance to the rose is minimum possible As usual he asks you to help between points and is defined as ,"['#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(""%d\\n"",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(""%d\\n"",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n    #define lld ""%I64d""\n#else\n    #define lld ""%lld""\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<\'0\'||c>\'9\')&&c!=\'-\');c==\'-\'?(sg=-1,x=0):(x=c-\'0\');\n\twhile((c=getchar())>=\'0\'&&c<=\'9\')x=x*10+c-\'0\';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gn(long double&x){double t;scanf(""%lf"",&t);x=t;}\ninline void gs(char *s){scanf(""%s"",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...) \n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\nint n;\nll x[111111],y[111111],z[111111];\n\nint out=0;\nbool check(ll d,int par){\n\tll lz,rz;\n\tlz=-7e18,rz=7e18;\n\n\tll l10,r10,l20,r20;\n\tll l1,r1,l2,r2;\n\n\tl1=l2=-7e18;\n\tr1=r2=7e18;\n\trep(i,1,n+1){\n\t\tupmax(l1,x[i]+y[i]+z[i]-d);\n\t\tupmin(r1,x[i]+y[i]+z[i]+d);\n\t\tupmax(l2,x[i]+y[i]-z[i]-d);\n\t\tupmin(r2,x[i]+y[i]-z[i]+d);\n\t}\n\tif((l1&1)!=par)l1++;\n\tif((l2&1)!=par)l2++;\n\tif((r1&1)!=par)r1--;\n\tif((r2&1)!=par)r2--;\n\t\n\tif(l1>r1 || l2>r2)return 0;\n\n\tupmin(rz,(r1-l2)/2ll);\n\tupmax(lz,(l1-r2)/2ll);\n\n\tl10=l1;\n\tr10=r1;\n\tl20=l2;\n\tr20=r2;\n\n\tl1=l2=-7e18;\n\tr1=r2=7e18;\n\trep(i,1,n+1){\n\t\tupmax(l1,x[i]-y[i]+z[i]-d);\n\t\tupmin(r1,x[i]-y[i]+z[i]+d);\n\t\tupmax(l2,x[i]-y[i]-z[i]-d);\n\t\tupmin(r2,x[i]-y[i]-z[i]+d);\n\t}\n\tif((l1&1)!=par)l1++;\n\tif((l2&1)!=par)l2++;\n\tif((r1&1)!=par)r1--;\n\tif((r2&1)!=par)r2--;\n\t\n\tif(l1>r1 || l2>r2)return 0;\n\n\tupmin(rz,(r1-l2)/2ll);\n\tupmax(lz,(l1-r2)/2ll);\n\n\tif(lz>rz)return 0;\n\n\tll z=lz;\n\n\tll lplu=max(l10-z,l20+z);\n\tll rplu=min(r10-z,r20+z);\n\tll lmin=max(l1-z,l2+z);\n\tll rmin=min(r1-z,r2+z);\n\n\tll x=(lplu+lmin)/2,y=(lplu-lmin)/2;\n\n\tif(out){\n\t\tout=0;\n\t\tprintf(""%I64d %I64d %I64d\\n"",x,y,z);\n\t}\n\treturn 1;\n}\nint main()\n{\n#ifdef JCVB\n\t//freopen(""1.in"",""r"",stdin);\n\t//freopen(""1.out"",""w"",stdout);\n\tint _time_jc=clock();\n#endif\n\tint te;gn(te);\n\twhile(te--){\n\t\tgn(n);\n\t\trep(i,1,n+1){\n\t\t\tgn(x[i]);\n\t\t\tgn(y[i]);\n\t\t\tgn(z[i]);\n\t\t}\n\t\tll l=0,r=3.1e18;\n\t\twhile(l<=r){\n\t\t\tll mid=l+r>>1;\n\t\t\tif(check(mid,0) || check(mid,1))r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tout=1;\n\t\tcheck(l,0);\n\t\tcheck(l,1);\n\t}\n\t\n#ifdef JCVB\n\tdebug(""time: %d\\n"",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2900
You came to the exhibition and one exhibit has drawn your attention It consists of n stacks of blocks where the i th stack consists of a i blocks resting on the surface The height of the exhibit is equal to m Consequently the number of blocks in each stack is less than or equal to m There is a camera on the ceiling that sees the top view of the blocks and a camera on the right wall that sees the side view of the blocks Find the maximum number of blocks you can remove such that the views for both the cameras would not change Note that while originally all blocks are stacked on the floor it is not required for them to stay connected to the floor after some blocks are removed There is in the whole exhibition so no block would fall down even if the block underneath is removed It is not allowed to move blocks by hand either ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll A[100005];\n\nint main() {\n   int N, M; scanf(""%d%d"", &N, &M);\n   for(int i = 1; i <= N; i++) scanf(""%lld"", &A[i]);\n   sort(A + 1, A + N + 1);\n   ll s = 0; for(int i = 1; i <= N; i++) s += A[i];\n\n   int h = 0;\n   ll ans = 0;\n   for(int i = 1; i <= N; i++) {\n      ans++;\n      if(h < A[i]) h++;\n   }\n   for(; h <= A[N] - 1; h++) {\n      ans++;\n   }\n   printf(""%lld\\n"", s - ans);\n\n   return 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1400
Olya has an array of integers a 1 a 2 ldots a n She wants to split it into tandem repeats Since it s rarely possible before that she wants to perform the following operation several possibly zero number of times insert a pair of equal numbers into an arbitrary position Help her More formally A tandem repeat is a sequence x of even length 2k such that for each 1 le i le k the condition x i x i k is satisfied An array a could be split into tandem repeats if you can split it into several parts each being a subsegment of the array such that each part is a tandem repeat In one operation you can choose an arbitrary letter c and insert c c to any position in the array at the beginning between any two integers or at the end You are to perform several operations and split the array into tandem repeats or determine that it is impossible Please note that you do have to minimize the number of operations ,"['/**\n *    author:  tourist\n *    created: 23.02.2022 13:49:47       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<pair<int, int>> ops;\n    vector<int> lens;\n    bool fail = false;\n    while (!a.empty()) {\n      int n = (int) a.size();\n      int i = n - 1;\n      int j = i - 1;\n      while (j >= 0 && a[j] != a[i]) {\n        j -= 1;\n      }\n      if (j == -1) {\n        fail = true;\n        break;\n      }\n      int ptr = j;\n      for (int k = i - 1; k >= j + 1; k--) {\n        ops.emplace_back(ptr, a[k]);\n        ptr += 1;\n      }\n      lens.push_back(2 * (i - j));\n      a.erase(a.begin() + i);\n      a.erase(a.begin() + j);\n      reverse(a.begin() + j, a.end());\n    }\n    if (fail) {\n      cout << -1 << \'\\n\';\n      continue;\n    }\n    cout << ops.size() << \'\\n\';\n    for (auto& op : ops) {\n      cout << op.first << "" "" << op.second << \'\\n\';\n    }\n    reverse(lens.begin(), lens.end());\n    cout << lens.size() << \'\\n\';\n    for (int i = 0; i < (int) lens.size(); i++) {\n      cout << lens[i] << "" \\n""[i == (int) lens.size() - 1];\n    }\n  }\n  return 0;\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2000
On the well known testing system MathForces a draw of n rating units is arranged The rating will be distributed according to the following algorithm if k participants take part in this event then the n rating is evenly distributed between them and rounded to the nearest lower integer At the end of the drawing an unused rating may remain it is not given to any of the participants For example if n 5 and k 3 then each participant will recieve an 1 rating unit and also 2 rating units will remain unused If n 5 and k 6 then none of the participants will increase their rating Vasya participates in this rating draw but does not have information on the total number of participants in this event Therefore he wants to know what different values of the rating increment are possible to get as a result of this draw and asks you for help For example if n 5 then the answer is equal to the sequence 0 1 2 5 Each of the sequence values and only them can be obtained as lfloor n k rfloor for some positive integer k where lfloor x rfloor is the value of x rounded down 0 lfloor 5 7 rfloor 1 lfloor 5 5 rfloor 2 lfloor 5 2 rfloor 5 lfloor 5 1 rfloor Write a program that for a given n finds a sequence of all possible rating increments ,"['#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nint main() {\n  int T;\n  scanf(""%d"", &T);\n  while (T-- > 0) {\n    int n;\n    scanf(""%d"", &n);\n    set<int> result;\n    result.insert(0);\n    for (int d = 1; d * d <= n; d++) {\n      int v = n / d;\n      result.insert(n / v);\n      result.insert(n / d);\n    }\n    int ans = result.size();\n    printf(""%d\\n"", ans);\n    int cnt = 0;\n    for (auto v : result) {\n      cnt++;\n      if (cnt == ans) {\n        printf(""%d\\n"", v);\n      } else {\n        printf(""%d "", v);\n      }\n    }\n  }\n  return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]",1400
You are given an array a of length n You are also given a set of positions p 1 p 2 dots p m where 1 le p i n The position p i means that you can swap elements a p i and a p i 1 You can apply this operation any number of times for each of the given Your task is to determine if it is possible to sort the initial array in non decreasing order a 1 le a 2 le dots le a n using only allowed swaps For example if a 3 2 1 and p 1 2 then we can first swap elements a 2 and a 3 because position 2 is contained in the given set p We get the array a 3 1 2 Then we swap a 1 and a 2 position 1 is also contained in p We get the array a 1 3 2 Finally we swap a 2 and a 3 again and get the array a 1 2 3 sorted in non decreasing order You can see that if a 4 1 2 3 and p 3 2 then you cannot sort the array You have to answer t independent test cases ,"['#include <cstdio>\n#include <algorithm>\nusing namespace std;\nint a[105],p[105];\nint main()\n{\n    int t,n,m,pp;\n    bool f;\n    scanf(""%d"",&t);\n    while(t--)\n    {\n        scanf(""%d%d"",&n,&m);\n        for(int i=1;i<=n;i++)\n            scanf(""%d"",&a[i]);\n        for(int i=1;i<=m;i++)\n            scanf(""%d"",&p[i]);\n        sort(p+1,p+m+1);\n        pp=1;\n        for(int i=2;i<=m;i++)\n            if(p[i]!=p[i-1]+1)\n            {\n                sort(a+p[pp],a+p[i-1]+2);\n                pp=i;\n            }\n        sort(a+p[pp],a+p[m]+2);\n        f=false;\n        for(int i=1;i<=n;i++)\n            if(a[i]<a[i-1])\n            {\n                f=true;\n                break;\n            }\n        if(f)\n            printf(""NO\\n"");\n        else printf(""YES\\n"");\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]",1200
You are given n strings s 1 s 2 dots s n consisting of lowercase Latin letters Let x be the length of string x Let a C a b of two strings a and b be the following operation if a is empty C a b b if b is empty C a b a if the last letter of a is equal to the first letter of b then C a b C a 1 a 1 b 2 b where s l r is the substring of s from the l th letter to the r th one otherwise C a b a b i e the concatenation of two strings Calculate sum limits i 1 n sum limits j 1 n C s i s j ,"[""#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nstruct Trie {\n    char a_init;\n    int D;\n    int INVALID = -1;\n    std::vector<std::vector<int>> child;\n    std::vector<int> par;\n\n    using T_NODE = int;\n    std::vector<T_NODE> v_info;\n\n    Trie(char a_init = 'a', int D = 26)\n        : a_init(a_init), D(D), child(1, std::vector<int>(D, INVALID)), par(1, -1), v_info(1) {}\n\n    int step(int now, char c) const {\n        if (now == INVALID) return INVALID;\n        return child.at(now).at(c - a_init);\n    }\n\n    int add_word(const std::string &str, T_NODE info) {\n        int now = 0;\n        for (auto &c : str) {\n            if (child[now][c - a_init] == INVALID) {\n                par.push_back(now);\n                child[now][c - a_init] = child.size();\n                child.emplace_back(D, INVALID);\n                v_info.resize(child.size());\n            }\n            now = child[now][c - a_init];\n        }\n        v_info[now] += info;\n        return now;\n    }\n};\n\n\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    vector<string> S(N);\n    for (auto &s : S) cin >> s;\n\n    Trie trie;\n    for (auto s : S) trie.add_word(s, 1);\n\n    for (int i = (int)trie.par.size() - 1; i; --i) trie.v_info.at(trie.par.at(i)) += trie.v_info.at(i);\n\n    long long ret = 0;\n    for (const auto &s : S) ret += (long long)s.size() * N * 2;\n\n    for (auto t : S) {\n        reverse(t.begin(), t.end());\n        int now = 0;\n        for (char c : t) {\n            now = trie.step(now, c);\n            if (now < 0) break;\n            ret -= trie.v_info.at(now) * 2;\n        }\n    }\n\n    cout << ret << '\\n';\n}\n""]","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0]",1900
Furik loves painting stars A star is a shape that results if we take a regular pentagon and paint all diagonals in it Recently he decided to teach Rubik to paint stars After many years of training Rubik could paint stars easily But now Furik decided to test Rubik and complicated the task Rubik must paint stars observing the following rules all stars must be painted in a single move i e it is forbidden to take the pen away from the paper it is forbidden to paint the same segment of non zero length more than once the stars can intersect only in their vertexes the length of a side of the regular pentagon in which Rubik paints each star must equal 10 Help Rubik to cope with this hard task ,"['#define _CRT_SECURE_NO_DEPRECATE\n#define _SECURE_SCL 0\n\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <map>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iostream>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <cctype>\n#include <sstream>\n#include <cassert>\n#include <bitset>\n#include <memory.h>\n\nusing namespace std;\n\n#pragma comment(linker, ""/STACK:200000000"")\n\ntypedef long long int64;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define fore(i, a, n) for(int i = (int)(a); i < (int)(n); i++)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) (int(a.size()) - 1)\n#define all(a) a.begin(), a.end()\n\nconst double EPS = 1E-9;\nconst int INF = 1000000000;\nconst int64 INF64 = (int64) 1E18;\nconst double PI = 3.1415926535897932384626433832795;\n\nconst double P[5][2] = {\n  {3.830127018922193, 3.366025403784439},\n  {-3.601321235851749, 10.057331467373021},\n  {0.466045194906253, 19.192786043799030},\n  {10.411264148588986, 18.147501411122495},\n  {12.490381056766580, 8.366025403784439}\n};\n\nstruct pt {\n  double x, y;\n\n  pt() {}\n  pt(double x, double y): x(x), y(y) {}\n};\n\nint m, e;\npt p[110000];\nvector<pair<int, int> > g[110000];\nvector<int> ans;\nbool used[110000];\n\nvoid add(int v1, int v2) {\n  g[v1].pb(mp(v2, e));\n  g[v2].pb(mp(v1, e));\n  e++;\n}\n\nvoid rec(int v) {\n  while (!g[v].empty()) {\n    if (used[g[v].back().sc]) {\n      g[v].pop_back();\n      continue;\n    }\n\n    used[g[v].back().sc] = true;\n    rec(g[v].back().fs);\n  }\n  ans.pb(v);\n}\n\nint sym(pt p, pt q, pt h) {\n  double a = p.y - q.y;\n  double b = q.x - p.x;\n  double c = -a * p.x - b * p.y;\n  pt res;\n  res.x = h.x - 2 * a * (a * h.x + b * h.y + c) / (a * a + b * b);\n  res.y = h.y - 2 * b * (a * h.x + b * h.y + c) / (a * a + b * b);\n  ::p[m] = res;\n  return m++;\n}\n\nint main() {\n#ifdef RADs_project\n  freopen(""input.txt"", ""rt"", stdin);\n  freopen(""output.txt"", ""wt"", stdout);\n#endif\n\t\n\tint n;\n  cin >> n;\n\n  vector<vector<int> > a(1, vector<int> (5));\n  forn(i, 5) {\n    p[i] = pt(P[i][0], P[i][1]);\n    a[0][i] = i;\n  }\n  m = 5;\n\n  forn(i, n - 1) {\n    int cur = 2;\n    if (i & 1)\n      cur = 1;\n\n    vector<int> b;\n    b.pb(a[i][cur]);\n\n    for (int j = 4; j >= 2; j--)\n      b.pb(sym(p[a[i][cur]], p[a[i][cur + 1]], p[a[i][(cur + j) % 5]]));\n\n    b.pb(a[i][cur + 1]);\n\n    a.pb(b);\n  }\n\n  forn(i, n)\n    forn(j, 5) {\n      if (j + 2 < 5)\n        add(a[i][j], a[i][j + 2]);\n      if (j + 3 < 5)\n        add(a[i][j], a[i][j + 3]);\n    }\n\n  cout << m << endl;\n  forn(i, m)\n    printf(""%.20lf %.20lf\\n"", p[i].x, p[i].y);\n\n  forn(i, n) {\n    forn(j, 5)\n      printf(j ? "" %d"" : ""%d"", a[i][j] + 1);\n    puts("""");\n  }\n\n  rec(0);\n  forn(i, ans.size())\n    printf(i ? "" %d"" : ""%d"", ans[i] + 1);\n  puts("""");\n\t\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
There are n players numbered from 1 to n sitting around a round table The i 1 th player sits to the right of the i th player for 1 le i n and the 1 st player sits to the right of the n th player There are n 2 cards each of which has an integer between 1 and n written on it For each integer from 1 to n there are exactly n cards having this number Initially all these cards are distributed among all the players in such a way that each of them has exactly n cards In one operation each player chooses one of his cards and passes it to the player to his right All these actions are performed Player i is called if all his cards have the integer i written on them Their objective is to reach a configuration in which everyone is solid Find a way to do it using at most n 2 n operations You do need to minimize the number of operations ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int n;\n    cin >> n;\n    vector c(n, vector<int>(n));\n    vector<vector<int>> ans;\n    for (int i = 0; i < n; i += 1)\n        for (int j = 0; j < n; j += 1) {\n            cin >> c[i][j];\n            c[i][j] -= 1;\n        }\n    while (true) {\n        int ready = 1;\n        for (int i = 0; i < n; i += 1) {\n            vector<int> p(n);\n            for (int j : c[i]) {\n                if (p[j]) ready = 0;\n                p[j] = 1;\n            }\n        }\n        if (ready) break;\n        vector<int> d(n);\n        for (int i = 0; i < n; i += 1) {\n            vector<int> p(n);\n            for (int j : c[i]) p[j] += 1;\n            while (d[i] < n and p[d[i]] <= 1) d[i] += 1;\n        }\n        for (int k = 0; k < 2; k += 1)\n            for (int i = 0; i < n; i += 1)\n                if (d[(i + 1) % n] == n)\n                    d[(i + 1) % n] = d[i];\n        ans.push_back(d);\n        for (int i = 0; i < n; i += 1) {\n            for (int& j : c[i])\n                if (j == d[i]) {\n                    j = d[(i + n - 1) % n];\n                    break;\n                }\n        }\n    }\n    for (int i = 1; i < n; i += 1)\n        for (int j = 0; j < i; j += 1) {\n            vector<int> d(n);\n            for (int k = 0; k < n; k += 1) d[k] = (k + i + n - j) % n;\n            ans.push_back(d);\n            for (int i = 0; i < n; i += 1) {\n                for (int& j : c[i])\n                    if (j == d[i]) {\n                        j = d[(i + n - 1) % n];\n                        break;\n                    }\n            }\n        }\n    for (int i = 0; i < n; i += 1)\n        for (int j : c[i])\n            assert(i == j);\n    cout << ans.size() << ""\\n"";\n    for (auto ansi : ans) {\n        for (int ansij : ansi) cout << ansij + 1 << "" "";\n        cout << ""\\n"";\n    }\n    return 0;\n}']","[1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2900
Limak is a little polar bear He likes strings strings of length consisting of lowercase English letters only The distance between two letters is defined as the difference between their positions in the alphabet For example and Also the distance between two nice strings is defined as the sum of distances of corresponding letters For example and Limak gives you a nice string and an integer He challenges you to find any nice string that Find any satisfying the given conditions or print if it s impossible to do so As input output can reach huge size it is recommended to use fast input output methods for example prefer to use instead of in C prefer to use instead of in ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n  int n, k;\n  in >> n >> k;\n  std::string s;\n  in >> s;\n  int maxValue = 0;\n  for (int i = 0; i < s.length(); i++) {\n    maxValue += std::max(s[i] - \'a\', \'z\' - s[i]);\n  }\n  if (maxValue < k) {\n    out << ""-1"" << std::endl;\n    return;\n  }\n  std::string t;\n  for (int i = 0; i < s.length(); i++) {\n    if (s[i] - \'a\' > \'z\' - s[i]) {\n      int d = std::min(s[i] - \'a\', k);\n      k -= d;\n      t.push_back(s[i] - d);\n    } else {\n      int d = std::min(\'z\' - s[i], k);\n      k -= d;\n      t.push_back(s[i] + d);\n    }\n  }\n  out << t << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1300
B loves to debug his code But before he runs the solution and starts debugging he has to first compile the code Initially the compiler displayed compilation errors each of them is represented as a positive integer After some effort B managed to fix some mistake and then another one mistake However despite the fact that B is sure that he corrected the two errors he can not understand exactly what compilation errors disappeared the compiler of the language which B uses shows errors in the new order every time B is sure that unlike many other programming languages compilation errors for his programming language do not depend on each other that is if you correct one error the set of other error does not change Can you help B find out exactly what two errors he corrected ,"['#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<iomanip>\n#include<bitset>\nusing namespace std;\n\nconst int N = 100100;\n\nint n, a[3][N];\nset<int> s;\n\nint main() {\n    int i, j;\n    //freopen(""ttt"", ""r"", stdin);\n\n    cin >> n;\n\n    for(i = 0; i < 3; ++i) {\n        for(j = 1; j <= n - i; ++j)\n            scanf(""%d"", &a[i][j]);\n        sort(a[i] + 1, a[i] + n - i + 1);\n    }\n\n    for(i = 1; i <= n; ++i)\n    if(a[0][i] != a[1][i]) {\n        cout << a[0][i] << ""\\n"";\n        break;\n    }\n\n    for(i = 1; i < n; ++i)\n    if(a[1][i] != a[2][i]) {\n        cout << a[1][i] << ""\\n"";\n        break;\n    }\n\n    return 0;\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1100
You are given a positive integer m and two integer sequence a a 1 a 2 ldots a n and b b 1 b 2 ldots b n Both of these sequence have a length n Permutation is a sequence of n different positive integers from 1 to n For example these sequences are permutations 1 1 2 2 1 6 7 3 4 1 2 5 These are not 0 1 1 2 3 You need to find the non negative integer x and increase all elements of a i by x modulo m i e you want to change a i to a i x bmod m so it would be possible to rearrange elements of a to make it equal b among them you need to find the smallest possible x In other words you need to find the smallest non negative integer x for which it is possible to find some permutation p p 1 p 2 ldots p n such that for all 1 leq i leq n a i x bmod m b p i where y bmod m remainder of division of y by m For example if m 3 a 0 0 2 1 b 2 0 1 1 you can choose x 1 and a will be equal to 1 1 0 2 and you can rearrange it to make it equal 2 0 1 1 which is equal to b ,"['//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")\n\n#include<bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define ll long long\n#define ld long double\n#define null nullptr\n#define _ <<\' \'<<\n#define endl \'\\n\'\n\nusing namespace std;\n\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int N = 2e5 + 7;\nconst int M = 1e9 + 7;\n//const int M = 998244353;\nconst int FFTM = 998244353;\n\n\nconst int maxn = 2002;\nconst int inf = 1e9 + 66555;\nint a[maxn];\nint b[maxn];\nint c[maxn];\n\n\nint main()\n{\n#ifdef LOCAL\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif // LOCAL\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for(int i = 0; i < n; ++i)\n        cin >> a[i];\n    for(int i = 0; i < n; ++i)\n        cin >> b[i];\n    sort(b, b + n);\n    int ans = inf;\n    for(int i = 0; i < n; ++i)\n    {\n        int kek;\n        if (b[i] > a[0]) kek = b[i] - a[0];\n            else         kek = m - a[0] + b[i];\n        for(int j = 0; j < n; ++j)\n            c[j] = (a[j] + kek) % m;\n        sort(c, c + n);\n        bool f = true;\n        for(int j = 0; j < n && f; ++j)\n            if (b[j] != c[j]) f = false;\n        if (f) ans = min(ans, kek);\n    }\n    cout << ans % m;\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]",1500
Mr Kitayuta s garden is planted with bamboos Bamboos are tall fast growing tropical plants with hollow stems At the moment the height of the th bamboo is meters and it grows meters at the end of each day Actually Mr Kitayuta hates these bamboos He once attempted to cut them down but failed because their stems are too hard Mr Kitayuta have not given up however He has crafted Magical Hammer with his intelligence to drive them into the ground He can use Magical Hammer at most times during each day due to his limited Magic Power Each time he beat a bamboo with Magical Hammer its height decreases by meters If the height would become negative by this change it will become meters instead it does not disappear In other words if a bamboo whose height is meters is beaten with Magical Hammer its new height will be meters It is possible to beat the same bamboo more than once in a day Mr Kitayuta will fight the bamboos for days starting today His purpose is to minimize the height of the tallest bamboo after days that is iterations of Mr Kitayuta beats the bamboos and then they grow Find the lowest possible height of the tallest bamboo after days ,"['#include <cstdio>\n#include <functional>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nlong long finalheights[100003];\nlong long grows[100003];\n\nint n,m,K,P;\n\nstruct node\n{\n\tlong long limit;\n\tlong long grow;\n\tint deadline;\n\tint lefthits;\n\tbool operator < (const node & other) const {\n\t\treturn deadline > other.deadline;\n\t}\n};\n\nbool check(long long ans)\n{\n\tvector<node> proc;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (finalheights[i] > ans) {\n\t\t\tnode cur;\n\t\t\tcur.limit = ans;\n\t\t\tcur.grow = grows[i];\n\t\t\tcur.deadline = cur.limit / cur.grow;\n\t\t\tcur.lefthits = (finalheights[i] - ans + P - 1) / P;\n\t\t\tproc.emplace_back(cur);\n\t\t}\n\t}\n\tif ((long long)proc.size() > K * m) return false;\n\tmake_heap(proc.begin(),proc.end());\n\tint d = 1;\n\tint hits = 0;\n\twhile (d <= m && !proc.empty()) {\n\t\tpop_heap(proc.begin(),proc.end());\n\t\tauto &work = proc.back();\n\t\tif (work.deadline < d) return false;\n\n\t\twork.lefthits--;\n\t\twork.limit += P;\n\t\twork.deadline = work.limit / work.grow;\n\t\tif (work.lefthits == 0) {\n\t\t\tproc.pop_back();\n\t\t} else {\n\t\t\tpush_heap(proc.begin(),proc.end());\n\t\t}\n\n\t\tif (++hits == K) {\n\t\t\thits = 0;\n\t\t\td++;\n\t\t}\n\t}\n\treturn proc.empty();\n}\n\nint main(){\n\tscanf(""%d%d%d%d"",&n,&m,&K,&P);\n\tfor (int i = 0; i < n; i++) {\n\t\tlong long h;\n\t\tscanf(""%lld%lld"",&h, &grows[i]);\n\t\tfinalheights[i] = h + grows[i] * m;\n\t}\n\tlong long low = 0, high = *max_element(finalheights, finalheights+n);\n\tlong long ans = -1;\n\twhile (low <= high) {\n\t\tlong long mid = (low+high)/2;\n\t\tif (check(mid)) {\n\t\t\tans = mid;\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\tprintf(""%lld\\n"", ans);\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2900
You are given n 1 integers a 1 a 2 dots a n 1 Your task is to construct an array b 1 b 2 dots b n such that every integer from 0 to n 1 appears in b exactly once for every i from 1 to n 1 b i oplus b i 1 a i where oplus denotes the bitwise XOR operator ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?""YES\\n"":""Yes\\n""); else cout<<(upp?""NO\\n"":""No\\n"");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<\'{\';for(int i=0;i<(int)p.size();i++){if(i){cout<<"","";}cout<<\'""\'<<p[i]<<\'""\';}cout<<""}\\n"";}\nelse{if(ty==1){cout<<p.size()<<""\\n"";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<"" "";cout<<p[i];}cout<<""\\n"";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    //cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    int N;\n\tcin>>N;\n\tvector<int> A(N);\n\trep(i,0,N-1){\n\t\tcin>>A[i+1];\n\t\tA[i+1]^=A[i];\n\t}\n\tfor(int d=0;d<30;d++){\n\t\tint X=0;\n\t\trep(i,0,N){\n\t\t\tif(A[i]&(1<<d)) X++;\n\t\t\telse X--;\n\t\t}\n\t\tif(X>0) rep(i,0,N) A[i]^=(1<<d);\n\t}\n\tvec_out(A);\n}']","[0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1900
A flowerbed has many flowers and two fountains You can adjust the water pressure and set any values and giving the distances at which the water is spread from the first and second fountain respectively You have to set such and that all the flowers are watered that is for each flower the distance between the flower and the first fountain doesn t exceed or the distance to the second fountain doesn t exceed It s OK if some flowers are watered by both fountains You need to decrease the amount of water you need that is set such and that all the flowers are watered and the is minimum possible Find this minimum value ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define scanf(...) scanf(__VA_ARGS__)?:0\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> PII;\ntypedef pair <ll, ll> PLL;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef pair <int, PII> PIP;\ntypedef pair <ll, int> PLI;\ntypedef pair <PII, ll> PIIL;\ntypedef pair <int, ll> PIL;\ntypedef unsigned int ui;\nconst int mod = 1e9+7;\nconst int inf = 1e9+9;\nconst ll MOD = 1e9+696969;\nconst ll INF = 1e18;\n#define maxn 2010\ninline ll sqr(ll a) {\n\treturn a*a;\n}\nint n;\nPII t[maxn];\nll d[maxn][2];\nll odl(int a, int b)\n{\n\treturn sqr(t[a].e1 - t[b].e1) + sqr(t[a].e2 - t[b].e2);\n}\n\nint main()\n{\n\tscanf(""%d%d%d"", &n, &t[0].e1, &t[0].e2);\n\tscanf(""%d%d"", &t[n+1].e1, &t[n+1].e2);\n\tfor (int i=1; i<=n; ++i) scanf(""%d%d"", &t[i].e1, &t[i].e2);\n\tfor (int i=1; i<=n; ++i)\n\t  d[i][0] = odl(0, i), d[i][1] = odl(n+1, i);\n\n\tll res = INF;\n\tfor (int j=0; j<2; ++j) {\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\tll wart = d[i][0]; //kwadrat\n\t\tll MIN = 0;\n\t\tfor (int j=1; j<=n; ++j)\n\t\t  if (d[j][0] > wart) MIN = max(MIN, d[j][1]);\n\t\tres = min(res, wart + MIN);\n\t}\n\tfor (int j=1; j<=n; ++j) swap(d[j][0], d[j][1]);\n\t}\n\n\tcout << res;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
