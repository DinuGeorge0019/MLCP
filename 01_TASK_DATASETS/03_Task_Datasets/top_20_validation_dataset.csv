problem_statement,problem_solution,tags,dificulty
There is a tree consisting of vertices The vertices are numbered from to Let s define the length of an interval as the value The score of a subtree of this tree is the maximum length of such an interval that the vertices with numbers belong to the subtree Considering all subtrees of the tree whose size is at most return the maximum score of the subtree Note that in this problem tree is not rooted so a subtree is an arbitrary connected subgraph of the tree ,"['#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n//#include <iostream>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <fstream>\n#include <numeric>\n#include <iomanip>\n#include <bitset>\n#include <list>\n#include <stdexcept>\n#include <functional>\n#include <utility>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<(int)n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#define ACCU accumulate\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef vector<double> VD;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<ll> VL;\nconst ll mod=1000000007;\nconst double eps=1e-9;\nconst double pi=acos(0)*2;\nll powmod(ll a,ll b) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll powmod(ll a,ll b,ll mod) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nconst int N=201000;\nset<int> mp;\nint dep[N],f[N],F[N][20],id[N],cnt[N];\nint y[N],nxt[N],fst[N],tot,ans,n,k,u,v;\n\nvoid add(int u,int v) {tot++;y[tot]=v;nxt[tot]=fst[u];fst[u]=tot;}\nvoid dfs(int u,int p) { f[u]=p;id[cnt[u]=++tot]=u;\n\tfor (int j=fst[u];j;j=nxt[j]) if (y[j]!=p) dep[y[j]]=dep[u]+1,dfs(y[j],u);}\nint LCA(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tfor (int k=dep[v]-dep[u],j=17;j>=0;j--) if ((k>>j)&1) v=F[v][j],k^=(1<<j);\n\tif (u==v) return u;\n\tfor (int k=17;f[u]!=f[v];u=F[u][k],v=F[v][k]) for (;k && F[u][k]==F[v][k];k--);\n\treturn f[u];\n}\nvoid modify(char ch,int u) {\n\ttypeof(mp.begin()) it=mp.lower_bound(cnt[u]);\n\tif (*it==cnt[u]) mp.erase(cnt[u]),it=mp.lower_bound(cnt[u]);\n\tif (!mp.size()) {if (ch==\'+\') mp.insert(cnt[u]);return;}\n\tint q=id[(it==mp.end())?*mp.begin():*it],p=id[(it--==mp.begin())?*(--mp.end()):*it];\n\tint dt=dep[u]-dep[LCA(p,u)]-dep[LCA(q,u)]+dep[LCA(p,q)];\n\tif (ch==\'+\') ans+=dt,mp.insert(cnt[u]); else ans-=dt;\t\n}\nbool check(int v) {\n\tans=0;\n\tmp.clear();\n\trep(i,1,v) modify(\'+\',i);\n\trep(i,v,n+1) {\n\t\tmodify(\'+\',i);\n\t\tif (ans+1<=k) return 1;\n\t\tmodify(\'-\',i+1-v);\n\t}\n\treturn 0;\n} \nint main() {\n\tscanf(""%d%d"",&n,&k);\n\trep(i,1,n) scanf(""%d%d"",&u,&v),add(u,v),add(v,u);\n\ttot=0;dfs(1,0);id[n+1]=n+1;\n\trep(i,1,n+1) F[i][0]=f[i];\n\trep(j,1,18) rep(i,1,n+1) F[i+1][j]=F[F[i+1][j-1]][j-1];\n\tint l=1,r=n+1;\n\twhile (l+1<r) {\n\t\tint md=(l+r)>>1;\n\t\tif (check(md)) l=md; else r=md;\n\t}\n\tprintf(""%d\\n"",l);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0]",2600
In the country there are exactly cities numbered with positive integers from to In each city there is an airport is located Also there is the only one airline which makes flights Unfortunately to use them you need to be a regular customer of this company namely you have the opportunity to enjoy flight from city to city only if you have already made at least flights before that Please note that flight flies exactly from city to city It can not be used to fly from city to city An interesting fact is that there may possibly be recreational flights with a beautiful view of the sky which begin and end in the same city You need to get from city to city Unfortunately you ve never traveled by plane before What minimum number of flights you have to perform in order to get to city Note that the same flight can be used multiple times ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 151\nint n,m;\nstruct mac{\n  bitset<MAX> t[MAX];\n  void dod(int a,int b){\n    t[a][b] = 1;\n  }\n  mac(){};\n  mac(mac& a,mac& b){\n    R(i,n){\n      R(j,n){\n      if(a.t[i][j])\n        t[i] |= b.t[j];\n      }\n    }\n  }\n}ak,dm;\nvector<mac> lo;\nint t = 0;\nint odp(int i){\n  while(i){\n    i--;\n    mac kan(dm,lo[i]);\n    if(kan.t[0][n-1] == 0){\n      dm = kan;\n      t+=1<<i;\n    }\n  }\n  printf(""%d\\n"",t+1);\n  exit(0);\n}\nvector<pair<int,PI> > w;\nvoid pot(int wyk){\n  lo.clear();\n  lo.PB(ak);\n  int i = 0;\n  while(wyk){\n    if(wyk&1){\n      mac kan(dm,lo[i]);\n      if(kan.t[0][n-1]){\n        odp(i);\n      }\n      dm = kan;\n      t+=1<<i;\n    }\n    wyk/=2;\n    lo.PB(mac(lo[i],lo[i]));\n    i++;\n  }\n}\nmain(){\n  make(n);\n  make(m);\n  ak.dod(n-1,n-1);\n  R(i,n){\n    dm.dod(i,i);\n  }\n  R(i,m){\n    int a,b,d;\n    make2(a,b);\n    a--;b--;\n    make(d);\n    w.PB({d,MP(a,b)});\n  }\n  sort(ALL(w));\n  int i = 0;\n  w.PB({(int)1e9+200,{0,0}});\n  while(i<m){\n    while(i < m && w[i].FI == t){\n      ak.dod(w[i].SE.FI,w[i].SE.SE);\n      i++;\n    }\n    pot(w[i].FI-t);\n  }\n  puts(""Impossible"");\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
Nicholas a painter is going to paint several new canvases Nicholas is sure that the canvases will turn out so great that each one will need framing and being hung on the wall Frames are what Nicholas decided to begin with Nicholas has sticks whose lengths equal Nicholas does not want to break the sticks or glue them together To make a sized frame he needs two sticks whose lengths equal and two sticks whose lengths equal Specifically to make a square frame when he needs four sticks of the same length Now Nicholas wants to make from the sticks that he has as many frames as possible to be able to paint as many canvases as possible to fill the frames Help him in this uneasy task Note that it is not necessary to use all the sticks Nicholas has ,"['// Friendship is Magic\n#pragma comment(linker, ""/STACK:32000000"")\n\n#include <memory.h>\n#include <string.h>\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\n\ntypedef long long LL;\n\nint n;\nint cnt[101];\n\nvoid do_solve() {\n    scanf(""%d"", &n);    \n    for (int i = 0; i < n; i++) {\n        int t;\n        scanf(""%d"", &t);\n        cnt[t]++;\n    }\n    int s = 0;\n    for (int i = 1; i <= 100; i++) s += cnt[i] / 2;\n    cout << s / 2;\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n    do_solve();\n    return 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
You are given a set of integer numbers initially it is empty You should perform queries There are three different types of queries Add all missing numbers from the interval Remove all present numbers from the interval Invert the interval add all missing and remove all present numbers from the interval After each query you should output of the set the smallest positive integer number which is not presented in the set ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nconst int maxn = 1e6 + 5;\nint n;\nint op[maxn];\nlong long l[maxn];\nlong long r[maxn];\n\nint st[maxn << 2];\nint lz1[maxn << 2];\nint lz2[maxn << 2];\n\nvoid pushdown(int p, int L, int R) {\n    if (lz1[p]) {\n        st[p] = (R - L + 1) - st[p];\n        if (L < R) {\n            if (~lz2[p << 1]) {\n                lz1[p << 1] = 0;\n                lz2[p << 1] ^= 1;\n            }\n            else {\n                lz1[p << 1] ^= 1;\n            }\n            if (~lz2[p << 1 | 1]) {\n                lz1[p << 1 | 1] = 0;\n                lz2[p << 1 | 1] ^= 1;\n            }\n            else {\n                lz1[p << 1 | 1] ^= 1;\n            }\n        }\n        lz1[p] = 0;\n    }\n    if (~lz2[p]) {\n        st[p] = lz2[p] * (R - L + 1);\n        if (L < R) {\n            lz2[p << 1] = lz2[p];\n            lz1[p << 1] = 0;\n            lz2[p << 1 | 1] = lz2[p];\n            lz1[p << 1 | 1] = 0;\n        }\n        lz2[p] = -1;\n    }\n}\n\nvoid upd1(int p, int l, int r, int L, int R) {\n    pushdown(p, L, R);\n    if (l > R || r < L) return;\n    if (l <= L && r >= R) {\n        lz1[p] = 1;\n        pushdown(p, L, R);\n        return;\n    }\n    upd1(p << 1, l, r, L, L + R >> 1);\n    upd1(p << 1 | 1, l, r, (L + R >> 1) + 1, R);\n    st[p] = st[p << 1] + st[p << 1 | 1];\n}\n\nvoid upd2(int p, int l, int r, int L, int R, int val) {\n    pushdown(p, L, R);\n    if (l > R || r < L) return;\n    if (l <= L && r >= R) {\n        lz2[p] = val;\n        pushdown(p, L, R);\n        return;\n    }\n    upd2(p << 1, l, r, L, L + R >> 1, val);\n    upd2(p << 1 | 1, l, r, (L + R >> 1) + 1, R, val);\n    st[p] = st[p << 1] + st[p << 1 | 1];\n}\n\nint query(int p, int L, int R) {\n    pushdown(p, L, R);\n    if (L == R) return L;\n    pushdown(p << 1, L, L + R >> 1);\n    pushdown(p << 1 | 1, (L + R >> 1) + 1, R);\n    if (st[p << 1] < (L + R >> 1) - L + 1) return query(p << 1, L, L + R >> 1);\n    return query(p << 1 | 1, (L + R >> 1) + 1, R);\n}\n\nvoid solve() {\n    cin >> n;\n    vector<long long> dc;\n    FOR(i, 0, n) {\n        cin >> op[i] >> l[i] >> r[i];\n        FOR(k, -1, 1 + 1) {\n            if (l[i] + k > 0) {\n                dc.pb(l[i] + k);\n            }\n            if (r[i] + k > 0) {\n                dc.pb(r[i] + k);\n            }\n        }\n    }\n    dc.pb(1);\n    sort(all(dc)), uni(dc);\n    FOR(i, 0, n) {\n        int x = lower_bound(all(dc), l[i]) - dc.begin();\n        int y = lower_bound(all(dc), r[i]) - dc.begin();\n        if (op[i] == 1) {\n            upd2(1, x, y, 0, sz(dc) - 1, 1);\n        }\n        else if (op[i] == 2) {\n            upd2(1, x, y, 0, sz(dc) - 1, 0);\n        }\n        else if (op[i] == 3) {\n            upd1(1, x, y, 0, sz(dc) - 1);\n        }\n        cout << dc[query(1, 0, sz(dc) - 1)] << ""\\n"";\n    }\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2300
The string s is given the string length is number The string consists of lowercase letters of the Latin alphabet As long as the string length is greater than 1 the following operation can be performed on it select any two adjacent letters in the string s and delete them from the string For example from the string in one operation you can get any of the four strings or In particular in one operation the length of the string reduces by 2 Formally let the string s have the form s s 1s 2 dots s n n 1 During one operation you choose an arbitrary index i 1 le i n and replace s s 1s 2 dots s i 1 s i 2 dots s n For the given string s and the letter c determine whether it is possible to make such a sequence of operations that in the end the equality s c will be true In other words is there such a sequence of operations that the process will end with a string of length 1 which consists of the letter c ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\nvoid solve(){\n\tstring s; cin>>s;\n\tchar ch; cin>>ch;\n\tint sz = s.length();\n\tfor(int i=0; i<sz; i+=2){\n\t\tif(s[i]==ch){\n\t\t\tcout<<""YES""<<\'\\n\';\n\t\t\treturn;\n\t\t}\n\t}\n\tcout<<""NO""<<\'\\n\';\n}\nint main(){\n\tios_base::sync_with_stdio(false); cin.tie(NULL);\n\tint t = 1;\n\tcin >> t;\n\twhile(t--) solve();\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
You are given a permutation dagger a of size n You can do the following operation Select an index i from 2 to n 1 such that a i 1 a i and a i a i 1 Swap a i and a i 1 Determine whether it is possible to sort the permutation after a finite number of operations dagger A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nint tab[nax];\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""YES\\n"");\n\telse\n\t\tprintf(""NO\\n"");\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tans(tab[1]==1);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Peter wrote on the board a strictly increasing sequence of positive integers Then Vasil replaced some digits in the numbers of this sequence by question marks Thus each question mark corresponds to exactly one lost digit Restore the the original sequence knowing digits remaining on the board ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, f[100001][11], pos[100001], len[100001];\nchar str[100001][11], ans[100001][11];\nbool b[100001][11];\n\nint main(){\n     //freopen(""e.in"", ""r"", stdin);\n     //freopen(""e.out"", ""w"", stdout);\n     scanf(""%d"", &n);\n     for (int i = 1; i <= n; i++) \n     {\n          scanf(""%s"", str[i] + 1);\n          pos[i] = 0; len[i] = strlen(str[i] + 1);\n     }\n     for (int j = 1; j <= len[1]; j++)\n          if (str[1][j] == \'?\')\n               if (j == 1) ans[1][j] = \'1\';\n               else ans[1][j] = \'0\';\n          else ans[1][j] = str[1][j];\n     bool ok = true;\n     for (int i = 2; i <= n; i++)\n     {\n          if (len[i] < len[i - 1])\n          {\n               ok = false;\n               break;\n          }\n          else\n          if (len[i] > len[i - 1])\n          {\n               for (int j = 1; j <= len[i]; j++)\n                    if (str[i][j] == \'?\')\n                         if (j == 1) ans[i][j] = \'1\';\n                         else ans[i][j] = \'0\';\n                    else ans[i][j] = str[i][j];\n          }\n          else\n          {\n               bool status = true, big = false;\n               for (int j = 1; j <= len[i] && status; j++)\n                    if (str[i][j] != \'?\')\n                    {\n                         if (!big && str[i][j] < ans[i - 1][j])\n                              status = false;\n                         else \n                         {\n                              ans[i][j] = str[i][j];\n                              if (str[i][j] > ans[i - 1][j]) big = true;\n                         }\n                    }\n                    else\n                    {\n                         char now[11];\n                         for (int k = 1; k < j; k++) now[k] = ans[i][k];\n                         int up = 0; if (j == 1) up = 1;\n                         bool find = false;\n                         for (int k = up; k < 10 && !find; ++k)\n                         {\n                              now[j] = k + \'0\';\n                              for (int l = j + 1; l <= len[i]; l++)\n                                   if (str[i][l] == \'?\') now[l] = \'9\';\n                                   else now[l] = str[i][l];\n                              bool r = false;\n                              for (int e = 1; e <= len[i]; e++)\n                                   if (now[e] > ans[i - 1][e]) \n                                   {\n                                        r = true;\n                                        break;\n                                   }\n                                   else\n                                   if (now[e] < ans[i - 1][e]) \n                                   {\n                                        r = false;\n                                        break;\n                                   }\n                              if (r) \n                              {\n                                   find = true, ans[i][j] = now[j];\n                                   if (ans[i][j] > ans[i - 1][j]) big = true;\n                              }\n                         }\n                         if (!find) status = false;\n                    }\n               if (!status || !big) \n               {\n                    ok = false;\n                    break;\n               }\n          }\n     }\n     if (!ok) printf(""NO\\n"");\n     else\n     {\n          printf(""YES\\n"");\n          for (int i = 1; i <= n; i++)\n          {\n               for (int j = 1; j <= len[i]; j++) printf(""%c"", ans[i][j]);\n               printf(""\\n"");\n          }\n     }\n}\n']","[1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
At a geometry lesson Gerald was given a task to get vector out of vector Besides the teacher permitted him to perform the following operations with vector Turn the vector by degrees clockwise Add to the vector a certain vector Operations could be performed in any order any number of times Can Gerald cope with the task ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++) \n#define REP(i,n) FOR(i,0,n) \n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nint x[3],y[3];\n\nll det(ll a,ll b, ll c,ll d){return a*d-b*c;}\n\nint main(){ \n#ifdef LocalHost\n\tfreopen(""input.txt"",""r"",stdin);\n//\tfreopen(""output.txt"",""w"",stdout);\n#endif\n\n\tREP(i,3) cin>>x[i]>>y[i];\n\t\n\tREP(i,4){\n\t\tswap(x[0],y[0]);\n\t\ty[0] = -y[0];\n\n\t\tint a = x[1] - x[0];\n\t\tint b = y[1] - y[0];\n\t\tll d = det(x[2], y[2], y[2], -x[2]);\n\t\tll d1 = det(a, y[2], b, -x[2]);\n\t\tll d2 = det(x[2], a, y[2], b);\n\t\tif(d==0){\n\t\t\tif(a==0 && b==0){\n\t\t\t\tputs(""YES"");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}else{\n\t\t\tif(d<0) d=-d;\n\t\t\tif(d1%d==0 && d2%d==0){\n\t\t\t\tputs(""YES"");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tputs(""NO"");\n\n\n#ifdef LocalHost\n\tcout<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n\treturn 0;\n}']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Alice and Bob are playing a game on a line with n cells There are n cells labeled from 1 through n For each i from 1 to n 1 cells i and i 1 are adjacent Alice initially has a token on some cell on the line and Bob tries to guess where it is Bob guesses a sequence of line cell numbers x 1 x 2 ldots x k in order In the i th question Bob asks Alice if her token is currently on cell x i That is Alice can answer either or to each Bob s question in this process before or after answering a question Alice is allowed to move her token from her current cell to some cell Alice acted in such a way that she was able to answer to of Bob s questions Note that Alice can even move her token before answering the first question or after answering the last question Alice can also choose to not move at all You are given n and Bob s questions x 1 ldots x k You would like to count the number of scenarios that let Alice answer to all of Bob s questions Let a b denote a scenario where Alice starts at cell a and ends at cell b Two scenarios a i b i and a j b j are different if a i neq a j or b i neq b j ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(""{"",x.f,"", "",x.s,""}""); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(""{"");\n        bool fst = 1; trav(a,x) pr(!fst?"", "":"""",a), fst = 0; \n        pr(""}"");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(""\\n""); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,"" ""); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),""r"",stdin); }\n    void setOut(string s) { freopen(s.c_str(),""w"",stdout); }\n    void setIO(string s = """") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint n,k, fst[MX], ans;\nvi v[MX];\nvi x;\n\nint main() {\n    setIO(); re(n,k); x.resz(k); re(x);\n    FOR(i,1,n+1) fst[i] = MOD;\n    F0R(i,sz(x)) if (fst[x[i]] == MOD) fst[x[i]] = i;\n    FOR(i,1,n+1) {\n        if (fst[i] == MOD) {\n            ans ++;\n            if (i > 1) ans ++;\n            if (i+1 <= n) ans ++;\n        } else {\n            if (i > 1) v[fst[i]+1].pb(i-1);\n            if (i+1 <= n) v[fst[i]+1].pb(i+1);\n        }\n    }\n    set<int> bad;\n    for (int i = k; i >= 0; --i) {\n        trav(t,v[i]) if (!bad.count(t)) ans ++;\n        if (i) bad.insert(x[i-1]);\n    }\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n']","[0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Furik and Rubik love playing computer games Furik has recently found a new game that greatly interested Rubik The game consists of parts and to complete each part a player may probably need to complete some other ones We know that the game can be fully completed that is its parts do not form cyclic dependencies Rubik has computers on which he can play this game All computers are located in different houses Besides it has turned out that each part of the game can be completed only on one of these computers Let s number the computers with integers from to Rubik can perform the following actions Complete some part of the game on some computer Rubik spends exactly hour on completing any part on any computer Move from the 1 st computer to the 2 nd one Rubik spends exactly hour on that Move from the 1 st computer to the 3 rd one Rubik spends exactly hours on that Move from the 2 nd computer to the 1 st one Rubik spends exactly hours on that Move from the 2 nd computer to the 3 rd one Rubik spends exactly hour on that Move from the 3 rd computer to the 1 st one Rubik spends exactly hour on that Move from the 3 rd computer to the 2 nd one Rubik spends exactly hours on that Help Rubik to find the minimum number of hours he will need to complete all parts of the game Initially Rubik can be located at the computer he considers necessary ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\nconst int maxn = 200;\n\nint n;\nint c[maxn];\nvector<int> nexts[maxn];\nint indeg[maxn];\n\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(""%d"", c + i);\n        c[i] --;\n    }\n    for (int i = 0; i < n; i++) {\n        scanf(""%d"", indeg + i);\n        for (int j = 0; j < indeg[i]; j++) {\n            int ai;\n            scanf(""%d"", &ai);\n            ai --;\n            nexts[ai].push_back(i);\n        }\n    }\n    int ret = 1 << 30;\n    for (int s = 0; s < 3; s++) {\n        int hours = 0;\n        queue<int> Q[3];\n        vector<int> deg(indeg, indeg + n);\n        for (int i = 0; i < n; i++) {\n            if (deg[i] == 0) {\n                Q[c[i]].push(i);\n            }\n        }\n        int house = s;\n        while (!Q[0].empty() || !Q[1].empty() || !Q[2].empty()) {\n            if (Q[house].empty()) {\n                hours ++;\n                house = (house + 1) % 3;\n                continue;\n            }\n            int p = Q[house].front();\n            Q[house].pop();\n            hours ++;\n            for (int i = 0; i < nexts[p].size(); i++) {\n                int q = nexts[p][i];\n                if (--deg[q] == 0) {\n                    Q[c[q]].push(q);\n                }\n            }\n        }\n        ret = min(ret, hours);\n    }\n    printf(""%d\\n"", ret);\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
A cake assembly line in a bakery was once again optimized and now n cakes are made at a time In the last step each of the n cakes should be covered with chocolate Consider a side view on the conveyor belt let it be a number line The i th cake occupies the segment a i w a i w on this line each pair of these segments does not have common points Above the conveyor there are n dispensers and when a common button is pressed chocolate from the i th dispenser will cover the conveyor segment b i h b i h Each pair of these segments also does not have common points The calibration of this conveyor belt part has not yet been performed so you are to make it Determine if it s possible to shift the conveyor so that each cake has some chocolate on it and there is no chocolate outside the cakes You can assume that the conveyour is long enough so the cakes never fall Also note that the button can only be pressed once ,"['// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == \'-\') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, 1e5 + 5)\n\nint n, w, h;\nint a[N], b[N];\nint da[N], db[N];\n\nvoid solve() {\n\tqread(n, w, h);\n\tint gp = 2 * (w - h);\n\trep(i, 1, n) qread(a[i]), da[i] = a[i] - a[i - 1];\n\trep(i, 1, n) qread(b[i]), db[i] = b[i] - b[i - 1];\n\tint nw = 0, nmax = 0, nmin = 0;\n\trep(i, 2, n) {\n\t\tnw += da[i] - db[i];\n\t\tTo_max(nmax, nw);\n\t\tTo_min(nmin, nw);\n\t}\n\tif(nmax - nmin <= gp) cout << ""YES\\n"";\n\telse cout << ""NO\\n"";\n}\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\twhile(T--) solve();\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Once the mischievous and wayward shooter named Shel found himself on a rectangular field of size n times m divided into unit squares Each cell either contains a target or not Shel only had a lucky shotgun with him with which he can shoot in one of the four directions right down left down left up or right up When fired the shotgun hits all targets in the chosen direction the Manhattan distance to which does not exceed a fixed constant k The Manhattan distance between two points x 1 y 1 and x 2 y 2 is equal to x 1 x 2 y 1 y 2 Shel s goal is to hit as many targets as possible Please help him find this value ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll n,m,k,ans=0;\n    cin>>n>>m>>k;\n    char c[n+1][m+1];\n    ll s[n+1][m+1];\n    for(ll i=0;i<=n;i++) s[i][0]=0;\n    for(ll i=1;i<=m;i++) s[0][i]=0;\n    for(ll i=1;i<=n;i++){\n        for(ll j=1;j<=m;j++){\n            cin>>c[i][j];\n            s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1];\n            if(c[i][j]==\'#\') s[i][j]++;\n        }\n    }\n    for(ll i=1;i<=n;i++){\n        for(ll j=1;j<=m;j++){\n            ll x=0;\n            if(n-i<=m-j){\n                for(ll kk=0;kk<=k&&i+kk<=n;kk++){\n                    ll i1=i+kk-1, j1=j-1, i2=i+kk, j2=min(j+k-kk,m);\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }else{\n                for(ll kk=0;kk<=k&&j+kk<=m;kk++){\n                    ll j1=j+kk-1, i1=i-1, j2=j+kk, i2=min(i+k-kk,n);\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }\n            ans=max(ans,x);\n            x=0;\n            if(n-i+1<=j){\n                for(ll kk=0;kk<=k&&i+kk<=n;kk++){\n                    ll i1=i+kk-1, j1=max(j-k+kk-1,0ll), i2=i+kk, j2=j;\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }else{\n                for(ll kk=0;kk<=k&&j-kk>=1;kk++){\n                    ll j1=j-kk-1, i1=i-1, j2=j-kk, i2=min(i+k-kk,n);\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }\n            ans=max(ans,x);\n            x=0;\n            if(i<=m-j+1){\n                for(ll kk=0;kk<=k&&i-kk>=1;kk++){\n                    ll i1=i-kk-1, j1=j-1, i2=i-kk, j2=min(j+k-kk,m);\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }else{\n                for(ll kk=0;kk<=k&&j+kk<=m;kk++){\n                    ll j1=j+kk-1, i1=max(i-k+kk-1,0ll), j2=j+kk, i2=i;\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }\n            ans=max(ans,x);\n            x=0;\n            if(i<=j){\n                for(ll kk=0;kk<=k&&i-kk>=1;kk++){\n                    ll i1=i-kk-1, j1=max(j-k+kk-1,0ll), i2=i-kk, j2=j;\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }else{\n                for(ll kk=0;kk<=k&&j-kk>=1;kk++){\n                    ll j1=j-kk-1, i1=max(i-k+kk-1,0ll), j2=j-kk, i2=i;\n                    x+=s[i2][j2]-s[i1][j2]-s[i2][j1]+s[i1][j1];\n                }\n            }\n            ans=max(ans,x);\n        }\n    }\n    cout<<ans;\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']","[0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Ari the monster is not an ordinary monster She is the hidden identity of Super M the Byteforces superhero Byteforces is a country that consists of cities connected by bidirectional roads Every road connects exactly two distinct cities and the whole road system is designed in a way that one is able to go from any city to any other city using only the given roads There are cities being attacked by humans So Ari we meant Super M have to immediately go to each of the cities being attacked to scare those bad humans Super M can pass from one city to another only using the given roads Moreover passing through one road takes her exactly one kron the time unit used in Byteforces However Super M is not on Byteforces now she is attending a training camp located in a nearby country Codeforces Fortunately there is a special device in Codeforces that allows her to instantly teleport from Codeforces to any city of Byteforces The way back is too long so for the purpose of this problem teleportation is used exactly once You are to help Super M by calculating the city in which she should teleport at the beginning in order to end her job in the minimum time measured in krons Also provide her with this time so she can plan her way back to Codeforces ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define sz(x) ((int) (x).size())\n#define X first\n#define Y second\n#define TRACE(x) cerr << #x << "" : "" << x << endl\n#define _ << "" "" <<\n\n#define MAX (123456 + 100)\nvector <int> adj[MAX];\nint N, M;\nbool mark[MAX];\nvector <int> goals;\n\nint DFS(int u, int par) {\n\tint ret = -1;\n\tif (mark[u]) ret = 0;\n\tfor (int v : adj[u]) if (v != par) {\n\t\tint child = DFS(v, u);\n\t\tif (child != -1) {\n\t\t\tif (ret == -1) ret = child + 2;\n\t\t\telse ret += child + 2;\n\t\t}\n\t}\n\treturn ret;\n}\n\npii getFar(int u, int par, int level) {\n\tpii ret = {-1, 0};\n\tif (mark[u]) ret = {u, level};\n\tfor (int v : adj[u]) if (v != par) {\n\t\tpii child = getFar(v, u, level + 1);\n\t\tif ((ret.X == -1) || (ret.Y < child.Y) || (ret.Y == child.Y && ret.X > child.X)) ret = child;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef _LOCAL\n\tfreopen(""input.txt"", ""r"", stdin);\n#endif\n\tcin >> N >> M;\n\tfor (int i = 0; i < N - 1; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint u; cin >> u;\n\t\tu--;\n\t\tmark[u] = true;\n\t\tgoals.push_back(u);\n\t}\n\n\tif (M == 1) cout << goals[0] + 1 << endl << 0 << endl;\n\telse {\n\t\tint s = DFS(goals[0], -1);\n\t\t// TRACE(s);\n\t\tpii far_away = getFar(goals[0], -1, 0);\n\t\t// TRACE(far_away.X _ far_away.Y);\n\t\tpii far_far_away = getFar(far_away.X, -1, 0);\n\t\t// TRACE(far_far_away.X _ far_far_away.Y);\n\t\tcout << min(far_away.X, far_far_away.X) + 1 << endl;\n\t\tcout << s - far_far_away.Y << endl;\n\t}\n\n\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Let a b and c be integers We define function f a b c as follows Order the numbers a b c in such a way that a le b le c Then return gcd a b where gcd a b denotes the greatest common divisor GCD of integers a and b So basically we take the gcd of the 2 smaller values and ignore the biggest one You are given an array a of n elements Compute the sum of f a i a j a k for each i j k such that 1 le i j k le n More formally compute sum i 1 n sum j i 1 n sum k j 1 n f a i a j a k ,"['#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < \'0\' || c > \'9\') c = getchar();\n\twhile(c >= \'0\' && c <= \'9\') x = x * 10 + c - \'0\', c = getchar();\n\treturn x;\n}\nint n, a[80005], f[100005], g[100005];\nlong long ans;\nstd::vector <int> fac[100005];\nvoid solve(){\n\tscanf(""%d"", &n); ans = 0ll;\n\tfor(int i = 1; i <= 100000; ++i) f[i] = g[i] = 0;\n\tfor(int i = 1; i <= n; ++i) a[i] = read();\n\tstd::sort(a + 1, a + n + 1);\n\tlong long tmp = 0ll;\n\tfor(int i = 1; i <= n; ++i){\n\t\tans += tmp;\n\t\tfor(auto v : fac[a[i]]){\n\t\t\tf[v] = g[v];\n\t\t\tfor(auto u : fac[a[i] / v]) if(u != 1) f[v] -= f[v * u];\n\t\t\ttmp += 1ll * v * f[v];\n\t\t}\n\t\tfor(auto v : fac[a[i]]) ++g[v];\n\t}\n\tprintf(""%lld\\n"", ans);\n\treturn ;\n}\nint main(){\n\tfor(int i = 1; i <= 100000; ++i) for(int j = i; j <= 100000; j += i) fac[j].push_back(i);\n\tfor(int i = 1; i <= 100000; ++i) std::reverse(fac[i].begin(), fac[i].end()); \n\tint T = 1;\n\tscanf(""%d"", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n']","[0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",2000
Find the minimum area of a land on which you can place two identical rectangular a times b houses The sides of the houses should be parallel to the sides of the desired square land Formally You are given two identical rectangles with side lengths a and b 1 le a b le 100 positive integers you are given just the sizes but their positions Find the square of the minimum area that contains both given rectangles Rectangles can be rotated both or just one moved but the sides of the rectangles should be parallel to the sides of the desired square Two rectangles can touch each other side or corner but cannot intersect Rectangles can also touch the sides of the square but must be completely inside it You can rotate the rectangles Take a look at the examples for a better understanding ,"[""#include<bits/stdc++.h>\nusing namespace std ;\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define re register\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;\n\treturn cn * flus ;\n}\n#define maxn 205\nint n, m ; \nsigned main() {\n\tint T = gi() ;\n\twhile( T -- ) {\n\t\tn = gi(), m = gi() ;\n\t\tcout << max(min(n * 2, m * 2), max(n, m)) * max(min(n * 2, m * 2), max(n, m)) << endl ; \n\t}\n\treturn 0 ;\n} ""]","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Vasya has a pack of cards standard cards and distinct jokers That is all he has at the moment Not to die from boredom Vasya plays Solitaire with them Vasya lays out cards as a rectangle If there are jokers among them then Vasya should change them with some of the rest of cards which are not layed out so that there were no jokers left Vasya can pick the cards to replace the jokers arbitrarily Remember that each card presents in pack exactly once i e Vasya tries to perform the replacements so that the solitaire was Vasya thinks that the solitaire is solved if after the jokers are replaced there exist two non overlapping squares inside each of which all the cards either have the same suit or pairwise different ranks Determine by the initial position whether the solitaire can be solved or not If it can be solved show the way in which it is possible ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\nint a[20][20];\nint Color[257];\nint value[257];\nint Num[257];\nint all[100];\n\nmain(){\n\tvalue[\'A\'] = 0;\n\tvalue[\'2\'] = 1;\n\tvalue[\'3\'] = 2;\n\tvalue[\'4\'] = 3;\n\tvalue[\'5\'] = 4;\n\tvalue[\'6\'] = 5;\n\tvalue[\'7\'] = 6;\n\tvalue[\'8\'] = 7;\n\tvalue[\'9\'] = 8;\n\tvalue[\'T\'] = 9;\n\tvalue[\'J\'] = 10;\n\tvalue[\'Q\'] = 11;\n\tvalue[\'K\'] = 12;\n\tvalue[\'H\'] = 0;\n\tvalue[\'D\'] = 1;\n\tvalue[\'C\'] = 2;\n\tvalue[\'S\'] = 3;\n\tNum[0] = \'A\';\n\tNum[1] = \'2\';\n\tNum[2] = \'3\';\n\tNum[3] = \'4\';\n\tNum[4] = \'5\';\n\tNum[5] = \'6\';\n\tNum[6] = \'7\';\n\tNum[7] = \'8\';\n\tNum[8] = \'9\';\n\tNum[9] = \'T\';\n\tNum[10] = \'J\';\n\tNum[11] = \'Q\';\n\tNum[12] = \'K\';\n\tColor[0] = \'H\';\n\tColor[1] = \'D\';\n\tColor[2] = \'C\';\n\tColor[3] = \'S\';\n\t\n\tint n, m, i, j, J1, J2, R1, R2, C1, C2;\n\tint mark, color;\n\tchar readin[9];\n\t\n\tmemset ( all, 0, sizeof ( all ) );\n\tscanf ( ""%d %d"", &n, &m );\n\tfor ( i = 0; i < n; i ++ )\n\t\tfor ( j = 0; j < m; j ++ ){\n\t\t\tscanf ( ""%s"", readin );\n\t\t\tif ( readin[1] == \'1\' )\n\t\t\t\ta[i][j] = 52;\n\t\t\telse if ( readin[1] == \'2\' )\n\t\t\t\ta[i][j] = 53;\n\t\t\telse\n\t\t\t\ta[i][j] = value[readin[0]] + value[readin[1]] * 13;\n\t\t\tall[ a[i][j] ] = 1;\n\t\t}\n\tfor ( J1 = 0; J1 < 53; J1 ++ )\n\t\tif ( ( all[52] == 1 && J1 == 52 ) || ( all[52] == 0 && J1 != 52 ) || ( all[52] == 1 && all[J1] == 1 ) )\n\t\t\tcontinue;\n\t\telse\n\tfor ( J2 = 0; J2 < 54; J2 ++ )\n\t\tif ( ( all[53] == 1 && J2 >= 52 ) || ( all[53] == 0 && J2 != 53 ) || ( all[53] == 1 && all[J2] == 1 ) || J1 == J2 )\n\t\t\tcontinue;\n\t\telse{\n\t\t\tfor ( i = 0; i < n; i ++ )\n\t\t\t\tfor ( j = 0; j < m; j ++ ){\n\t\t\t\t\tif ( a[i][j] == 52 )\ta[i][j] = J1;\n\t\t\t\t\tif ( a[i][j] == 53 )\ta[i][j] = J2;\n\t\t\t\t}\n\t\t\tfor ( R1 = 0; R1 + 3 <= n; R1 ++ )\n\t\t\tfor ( C1 = 0; C1 + 3 <= m; C1 ++ )\n\t\t\tfor ( R2 = 0; R2 + 3 <= n; R2 ++ )\n\t\t\tfor ( C2 = 0; C2 + 3 <= m; C2 ++ ){\n\t\t\t\tif ( abs( R1 - R2 ) < 3 && abs( C1 - C2 ) < 3 )\n\t\t\t\t\tcontinue;\n\t\t\t\tmark = 0;\n\t\t\t\tcolor = a[R1][C1] / 13;\n\t\t\t\tfor ( i = 0; i < 3; i ++ )\n\t\t\t\t\tfor ( j = 0; j < 3; j ++ ){\n\t\t\t\t\t\tif ( color != a[R1+i][C1+j] / 13 )\n\t\t\t\t\t\t\tcolor = -1;\n\t\t\t\t\t\tif ( mark & ( 1 << ( a[R1+i][C1+j] % 13 ) ) )\n\t\t\t\t\t\t\tmark = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmark |= ( 1 << ( a[R1+i][C1+j] % 13 ) );\n\t\t\t\t\t}\n\t\t\t\tif ( mark == -1 && color == -1 )\n\t\t\t\t\tcontinue;\n\t\t\t\tmark = 0;\n\t\t\t\tcolor = a[R2][C2] / 13;\n\t\t\t\tfor ( i = 0; i < 3; i ++ )\n\t\t\t\t\tfor ( j = 0; j < 3; j ++ ){\n\t\t\t\t\t\tif ( color != a[R2+i][C2+j] / 13 )\n\t\t\t\t\t\t\tcolor = -1;\n\t\t\t\t\t\tif ( mark & ( 1 << ( a[R2+i][C2+j] % 13 ) ) )\n\t\t\t\t\t\t\tmark = -1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tmark |= ( 1 << ( a[R2+i][C2+j] % 13 ) );\n\t\t\t\t\t}\n\t\t\t\tif ( mark == -1 && color == -1 )\n\t\t\t\t\tcontinue;\n\t\t\t\tprintf( ""Solution exists.\\n"" );\n\t\t\t\tif ( J1 == 52 && J2 == 53 )\n\t\t\t\t\tprintf( ""There are no jokers.\\n"" );\n\t\t\t\telse\n\t\t\t\t\tif ( J1 == 52 )\n\t\t\t\t\t\tprintf( ""Replace J2 with %c%c.\\n"", Num[J2%13], Color[J2/13] );\n\t\t\t\t\telse\n\t\t\t\t\t\tif ( J2 == 53 )\n\t\t\t\t\t\t\tprintf( ""Replace J1 with %c%c.\\n"", Num[J1%13], Color[J1/13] );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tprintf( ""Replace J1 with %c%c and J2 with %c%c.\\n"", Num[J1%13], Color[J1/13], Num[J2%13], Color[J2/13] );\n\t\t\t\tprintf( ""Put the first square to (%d, %d).\\n"", R1 + 1, C1 + 1 );\n\t\t\t\tprintf( ""Put the second square to (%d, %d).\\n"", R2 + 1, C2 + 1 );\n//\t\t\t\tcin >> i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor ( i = 0; i < n; i ++ )\n\t\t\t\tfor ( j = 0; j < m; j ++ ){\n\t\t\t\t\tif ( a[i][j] == J1 )\ta[i][j] = 52;\n\t\t\t\t\tif ( a[i][j] == J2 )\ta[i][j] = 53;\n\t\t\t\t}\n\t\t}\n\tprintf( ""No solution.\\n"" );\n//\tcin >> i;\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
m chairs are arranged in a circle sequentially The chairs are numbered from 0 to m 1 n people want to sit in these chairs The i th of them wants at least a i empty chairs both on his right and left side More formally if the i th person sits in the j th chair then no one else should sit in the following chairs j a i bmod m j a i 1 bmod m j a i 1 bmod m j a i bmod m Decide if it is possible to sit down for all of them under the given limitations ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \nll i,j,k,n,m,t,a[1005000];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);cout.tie(0);\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>m;\n\t\tm-=n;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tcin>>a[i];\n\t\t\tm-=a[i];\n\t\t}\n\t\tsort(a+1,a+n+1);\n\t\tm-=a[n];\n\t\tm+=a[1];\n\t\tcout<<((m<0)?""No"":""Yes"")<<\'\\n\';\n\t}\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
Bogocubic is playing a game with amenotiomoi First Bogocubic fixed an integer n and then he gave amenotiomoi an integer x which is initially equal to 1 In one move amenotiomoi performs of the following operations with the same probability increase x by 1 multiply x by 2 Bogocubic wants to find the expected number of moves amenotiomoi has to do to make x greater than or equal to n Help him find this number modulo 998 244 353 Formally let M 998 244 353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer y that 0 le y M and y cdot q equiv p pmod M ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=998244353;\nconst ll o2=(mod+1)/2;\nconst int d=64;\n//~ const int d=5;\n\n//~ map<ll,ll> mapa;\n\n//~ ll solve(ll n)\n//~ {\n\t//~ if (n==1)\n\t\t//~ return 0;\n\t//~ if (mapa.count(n))\n\t\t//~ return mapa[n];\n\t//~ ll ret=solve(n-1)+solve((n+1)/2);\n\t//~ ret*=o2;\n\t//~ ret++;\n\t//~ ret%=mod;\n\t//~ return mapa[n]=ret;\n//~ }\n\nstruct mac\n{\n\tll w[d][d];\n\tmac()\n\t{\n\t\tfor (int i=0; i<d; i++)\n\t\t\tfor (int j=0; j<d; j++)\n\t\t\t\tw[i][j]=0;\n\t}\n\tmac(ll v)\n\t{\n\t\tfor (int i=0; i<d; i++)\n\t\t\tfor (int j=0; j<d; j++)\n\t\t\t\tw[i][j]=(i==j)*v;\n\t}\n\tvoid wypisz()\n\t{\n\t\tfor (int i=0; i<d; i++)\n\t\t\tdebug() << range(w[i], w[i]+d);\n\t\tdebug();\n\t}\n};\n\nmac operator *(mac a, mac b)\n{\n\tmac ret=mac();\n\tfor (int i=0; i<d; i++)\n\t\tfor (int j=0; j<d; j++)\n\t\t\tfor (int l=0; l<d; l++)\n\t\t\t\tret.w[i][l]=(ret.w[i][l]+a.w[i][j]*b.w[j][l])%mod;\n\treturn ret;\n}\n\nvector<mac> kolejne;\nvector<mac> pref;\n\nll dpn[nax];\nll dps[nax];\n\nvoid przyloz(mac &v)\n{\n\tfor (int i=0; i<d; i++)\n\t{\n\t\tdps[i]=dpn[i];\n\t\tdpn[i]=0;\n\t}\n\tfor (int i=0; i<d; i++)\n\t\tfor (int j=0; j<d; j++)\n\t\t\tdpn[j]=(dpn[j]+dps[i]*v.w[i][j])%mod;\n}\n\nvoid zrob(ll n)\n{\n\tif (!n)\n\t\treturn;\n\tint kt=0;\n\tll x=1;\n\twhile(2*x<=n)\n\t{\n\t\tkt++;\n\t\tx*=2;\n\t}\n\tif (kt)\n\t\tprzyloz(pref[kt-1]);\n\tprzyloz(kolejne[kt]);\n\tzrob(n-x);\n}\n\nvoid test()\n{\n\tll n;\n\tscanf(""%lld"", &n);\n\tfor (int i=0; i<d; i++)\n\t\tdpn[i]=0;\n\tdpn[d-1]=1;\n\tzrob(n-1);\n\tprintf(""%lld\\n"", dpn[0]);\n\t//~ mac pus=mac(1);\n\t//~ for (ll i=1; i<n; i++)\n\t//~ {\n\t\t//~ int x=__builtin_ctz(i);\n\t\t//~ pus=pus*kolejne[x];\n\t//~ }\n\t//~ printf(""%lld\\n"", pus.w[d-1][0]);\n}\n\nint main()\n{\n\tfor (int i=0; i+1<d; i++)\n\t{\n\t\tmac tu=mac(1);\n\t\ttu.w[i][i]=o2;\n\t\ttu.w[i+1][i]=o2;\n\t\ttu.w[d-1][i]=1;\n\t\tif (i)\n\t\t\ttu=tu*kolejne.back();\n\t\tkolejne.push_back(tu);\n\t\t//~ debug() << imie(i);\n\t\t//~ kolejne[i].wypisz();\n\t}\n\tfor (int i=0; i+1<d; i++)\n\t{\n\t\tif (!i)\n\t\t{\n\t\t\tpref.push_back(kolejne[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmac tu=(pref.back()*kolejne[i])*pref.back();\n\t\t\tpref.push_back(tu);\n\t\t}\n\t}\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3200
The New Year has arrived in the Master s Assistance Center which means it s time to introduce a new feature Now students are given distance learning courses with a total of n courses available For the i th distance learning course a student can receive a grade ranging from x i to y i However not all courses may be available to each student Specifically the j th student is only given courses with numbers from l j to r j meaning the distance learning courses with numbers l j l j 1 ldots r j The creators of the distance learning courses have decided to determine the final grade in a special way Let the j th student receive grades c l j c l j 1 ldots c r j for their distance learning courses Then their final grade will be equal to c l j c l j 1 ldots c r j where denotes the bitwise OR operation Since the chatbot for solving distance learning courses is broken the students have asked for your help For each of the q students tell them the maximum final grade they can achieve ,"['#include<bits/stdc++.h>\n#pragma GCC optimize(""Ofast,no-stack-protector,fast-math"",3)\n#define cln cerr<<""Line:   ""<<__LINE__<<""    ""\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]=\'\\n\';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,T2,n,m,a[N],b[N],p[N],q[N],bt,ans;\nbitset<N>vs;\nstruct dat{\n    int v,t;\n    dat operator+(const dat &z)\n    const{\n        int p=t&z.t;\n        if(p){\n            p=__lg(p);\n            return{v|z.v|((1<<p+1)-1),((t|z.t)>>p)<<p};\n        }else return{v|z.v,t|z.t};\n    }\n    int val(){\n        int res=v,l=v,k=t,x;\n        // cerr<<v<<"" ""<<t<<endl;\n        while(k){\n            x=__lg(k),k^=1<<x;\n            res=max(res,l|((1<<x)-1));\n            l|=1<<x;\n        }res=max(res,l);\n        return res;\n    }\n}d[N],sm[N],sum;\n#define ls x<<1\n#define rs x<<1|1\nvoid build(int x,int l,int r){\n    if(l==r)sm[x]=d[l];\n    else{\n        int md=l+r>>1;\n        build(ls,l,md);\n        build(rs,md+1,r);\n        sm[x]=sm[ls]+sm[rs];\n    }\n}\nvoid qsm(int x,int l,int r,int L,int R){\n    if(l>=L&&r<=R)sum=sum+sm[x];\n    else{\n        int md=l+r>>1;\n        if(L<=md)qsm(ls,l,md,L,R);\n        if(md<R)qsm(rs,md+1,r,L,R);\n    }\n}\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n;\n        for(i=1;i<=n;++i){\n            cin>>l>>r,d[i]={};\n            while(r){\n                x=__lg(r);\n                if(l&&x==__lg(l)){\n                    l^=1<<x,r^=1<<x;\n                    d[i].v|=1<<x;\n                }else{\n                    d[i].t=r;break;\n                }\n            }\n        }\n        build(1,1,n);\n        for(cin>>T2;T2--;){\n            cin>>l>>r,sum={};\n            qsm(1,1,n,l,r);\n            printf(""%d "",sum.val());\n        }puts("""");\n    }\n    return 0;\n}']","[1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2400
You are given array with integers and queries The th query is given with three integers For the th query find any position so that ,"['#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(""%d"", &(X))\n#define RII(X, Y) scanf(""%d%d"", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(""%d%d%d"", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(""%d"", &X)\n#define DRII(X, Y) int X, Y; scanf(""%d%d"", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(""%d%d%d"", &X, &Y, &Z)\n#define RS(X) scanf(""%s"", (X))\n#define CASET int ___T, case_n = 1; scanf(""%d "", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nVI d[SIZE];\nint a[SIZE],nxt[SIZE];\nint main(){\n    map<PII,int>H;\n    DRII(n,m);\n    REP(i,n){\n        DRI(x);\n        a[i+1]=x;\n        d[x].PB(i+1);\n    }\n    for(int i=n-1;i>0;i--){\n        if(a[i+1]!=a[i])nxt[i]=i+1;\n        else nxt[i]=nxt[i+1];\n    }\n    while(m--){\n        DRIII(l,r,x);\n        int it1=lower_bound(ALL(d[x]),l)-d[x].begin();\n        int it2=lower_bound(ALL(d[x]),r+1)-d[x].begin();\n        if(it2-it1==r-l+1)puts(""-1"");\n        else printf(""%d\\n"",a[l]==x?nxt[l]:l);\n    }\n    return 0;\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Bob has a rectangular chocolate bar of the size He introduced a cartesian coordinate system so that the point corresponds to the lower left corner of the bar and the point corresponds to the upper right corner Bob decided to split the bar into pieces by breaking it Each break is a segment parallel to one of the coordinate axes which connects the edges of the bar More formally each break goes along the line or where and are integers It should divide one part of the bar into two non empty parts After Bob breaks some part into two parts he breaks the resulting parts Also he doesn t move the parts of the bar Bob made breaks and wrote them down in his notebook in arbitrary order At the end he got parts Now he wants to calculate their areas Bob is lazy so he asks you to do this task ,"['#include <cstdio>\n#include <set>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass Point {\npublic:\n\tint x, y;\n\n\tPoint() {}\n\n\tPoint(int x, int y) : x(x), y(y) {}\n\n\tinline void init() {\n\t\tscanf(""%d%d"", &x, &y);\n\t}\n\n\tinline bool operator < (const Point & other) const {\n\t\treturn x < other.x || (x == other.x && y <= other.y);\n\t}\n};\n\nconst int MAXN = 110 + 1;\n\nset < pair <Point, Point> > ch;\nPoint s[MAXN], t[MAXN];\nbool tag[MAXN];\nint W, H, n, area[MAXN];\n\nint main() {\n\tscanf(""%d%d%d"", &W, &H, &n);\n\tch.insert(make_pair(Point(0, 0), Point(W, H)));\n\tfor (int i = 0; i < n; i++) {\n\t\ts[i].init();\n\t\tt[i].init();\n\t}\n\tfor (int o = 0; o < n; o++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (tag[i]) continue;\n\t\t\tfor (set < pair <Point, Point> >::iterator iter = ch.begin(); iter != ch.end(); iter++) {\n\t\t\t\tPoint ss = iter->first, tt = iter->second;\n\t\t\t\tif (s[i].x == t[i].x && ss.x <= s[i].x && t[i].x <= tt.x && s[i].y == ss.y && t[i].y == tt.y) {\n\t\t\t\t\ttag[i] = true;\n\t\t\t\t\tch.erase(iter);\n\t\t\t\t\tch.insert(make_pair(ss, t[i]));\n\t\t\t\t\tch.insert(make_pair(s[i], tt));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (s[i].y == t[i].y && ss.y <= s[i].y && t[i].y <= tt.y && s[i].x == ss.x && t[i].x == tt.x) {\n\t\t\t\t\ttag[i] = true;\n\t\t\t\t\tch.erase(iter);\n\t\t\t\t\tch.insert(make_pair(ss, t[i]));\n\t\t\t\t\tch.insert(make_pair(s[i], tt));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tag[i]) break;\n\t\t}\n\t}\n\tint cnt = 0;\n\tfor (set < pair <Point, Point> >::iterator iter = ch.begin(); iter != ch.end(); iter++) {\n\t\tarea[cnt++] = (iter->second.y - iter->first.y) * (iter->second.x - iter->first.x);\n\t}\n\tsort(area, area + n + 1);\n\tfor (int i = 0; i <= n; i++) printf(""%d "", area[i]);\n\tputchar(\'\\n\');\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Polycarp found under the Christmas tree an array a of n elements and instructions for playing with it At first choose index i 1 leq i leq n starting position in the array Put the chip at the index i on the value a i While i leq n add a i to your score and move the chip a i positions to the right i e replace i with i a i If i n then Polycarp ends the game For example if n 5 and a 7 3 1 2 3 then the following game options are possible Polycarp chooses i 1 Game process i 1 overset 7 longrightarrow 8 The score of the game is a 1 7 Polycarp chooses i 2 Game process i 2 overset 3 longrightarrow 5 overset 3 longrightarrow 8 The score of the game is a 2 a 5 6 Polycarp chooses i 3 Game process i 3 overset 1 longrightarrow 4 overset 2 longrightarrow 6 The score of the game is a 3 a 4 3 Polycarp chooses i 4 Game process i 4 overset 2 longrightarrow 6 The score of the game is a 4 2 Polycarp chooses i 5 Game process i 5 overset 3 longrightarrow 8 The score of the game is a 5 3 Help Polycarp to find out the maximum score he can get if he chooses the starting index in an optimal way ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 200002;\n\nint t;\n\nint n;\n\nll a[N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        for(int i = 1; i <= n; i++)\n            cin >> a[i];\n        for(int i = n; i >= 1; i--)\n            if(i + a[i] <= n)\n                a[i] += a[i + a[i]];\n        ll ans = 0;\n        for(int i = 1; i <= n; i++)\n            ans = max(ans, a[i]);\n        cout << ans << ""\\n"";\n    }\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Two players are playing a game First each of them writes an integer from 1 to 6 and then a dice is thrown The player whose written number got closer to the number on the dice wins If both payers have the same difference it s a draw The first player wrote number the second player wrote number How many ways to throw a dice are there at which the first player wins or there is a draw or the second player wins ,"['#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  int a, b;\n  scanf (""%d %d"", &a, &b);\n  int x = 0, y = 0, z = 0;\n  for (int i = 1; i <= 6; ++i) {\n    if (abs(a - i) == abs(b - i)) ++y;\n    if (abs(a - i) < abs(b - i)) ++x;\n    if (abs(a - i) > abs(b - i)) ++z;\n  }\n  printf (""%d %d %d\\n"", x, y, z);\n  return 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Find the number of ways to divide an array a of n integers into any number of disjoint non empty segments so that in each segment there exist at most k distinct integers that appear exactly once Since the answer can be large find it modulo 998 244 353 ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int Mod = 998\'244\'353;\nconst int BlockLen = 170;\nconst int MaxN = 1e5 + 100;\nconst int NumBlocks = MaxN / BlockLen + 50;\n\nint values[MaxN];\nint dp[MaxN];\nint N, K;\n\nstruct Block {\n  int L, R;\n  vector<PII> pref_sums;\n  int ptr;\n  int increase;\n  VI num_incrs;\n\n  Block() : L(0), R(0), ptr(0), increase(0) {}\n  Block(int l, int r) : L(l), R(r), ptr(0), increase(0), num_incrs(r - l) {}\n\n  void IncrAll(int delta) { increase += delta; }\n\n  void Rebuild() {\n    VI order(SZ(num_incrs));\n    iota(ALL(order), 0);\n    sort(ALL(order), [&](int lhs, int rhs) {\n          return num_incrs[lhs] < num_incrs[rhs];\n        });\n\n    pref_sums.clear();\n    pref_sums.emplace_back((int)-1e9, 0);\n    pref_sums.emplace_back(num_incrs[order[0]], dp[order[0] + L]);\n\n    for (int i = 1; i < SZ(order); ++i) {\n      const int v = order[i];\n      LL val = (pref_sums.back().nd + dp[v + L]) % Mod;\n      if (num_incrs[v] == pref_sums.back().st) {\n        pref_sums.back().nd = val;\n      } else {\n        pref_sums.emplace_back(num_incrs[v], val);\n      }\n    }\n    ptr = 0;\n    debug(""Rebuild"", pref_sums);\n  }\n\n  void IncrSeg(int lft, int rgt, int delta) {\n    for (int i = 0; i < SZ(num_incrs); ++i) {\n      num_incrs[i] += increase;\n    }\n    increase = 0;\n    for (int i = lft - L; i < rgt - L; ++i) {\n      num_incrs[i] += delta;\n    }\n    debug(num_incrs);\n    Rebuild();\n  }\n\n  int GetAtMaxK() {\n    while (ptr > 0 && pref_sums[ptr].st + increase > K) { --ptr; }\n    while (ptr < SZ(pref_sums) - 1 && pref_sums[ptr + 1].st + increase <= K) { ++ptr; }\n    debug(""GetIn"", L, R, ptr, pref_sums, increase, K);\n    return pref_sums[ptr].nd;\n  }\n};\n\nBlock blocks[NumBlocks];\n\n\nvoid Increase(int L, int R, int delta) {\n  debug(""Increase"", L, R, delta);\n  for (int i = 0; i < NumBlocks; ++i) {\n    const int l_block = i * BlockLen;\n    const int r_block = min((i + 1) * BlockLen, N + 1);\n    if (l_block > N) { break; }\n    if (r_block <= L || l_block >= R) { continue; }\n    if (L <= l_block && r_block <= R) {\n      blocks[i].IncrAll(delta);\n    } else {\n      blocks[i].IncrSeg(max<int>(L, l_block), min<int>(R, r_block), delta);\n    }\n  }\n}\n\nint GetAtMaxK() {\n  int ans = 0;\n  for (int i = 0; i < NumBlocks; ++i) {\n    const int l_block = i * BlockLen;\n    if (l_block > N) { break; }\n    ans = (ans + blocks[i].GetAtMaxK()) % Mod;\n  }\n  debug(""Get"", ans);\n  return ans;\n}\n\nvoid BuildBlocks() {\n  for (int i = 0; i < NumBlocks; ++i) {\n    const int l_block = i * BlockLen;\n    const int r_block = min(N + 1, (i + 1) * BlockLen);\n    if (l_block > N) { break; }\n    debug(i, l_block, r_block);\n    blocks[i] = Block(l_block, r_block);\n    blocks[i].Rebuild();\n  }\n}\n\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N >> K;\n\n#ifdef TEST\n  for (int i = 0; i < N; ++i) { values[i] = i / 2 + 1; }\n  srand(69);\n  random_shuffle(values, values + N);\n#else\n  for (int i = 0; i < N; ++i) { cin >> values[i]; }\n#endif\n\n  dp[0] = 1;\n  BuildBlocks();\n\n  VI prev_occur(N + 1, 0), last_occur(N + 1, 0);\n\n  for (int i = 1; i <= N; ++i) {\n    const int v = values[i - 1];\n    if (last_occur[v]) {\n      Increase(prev_occur[v], last_occur[v], -1);\n    }\n    prev_occur[v] = last_occur[v];\n    last_occur[v] = i;\n    Increase(prev_occur[v], last_occur[v], 1);\n    dp[i] = GetAtMaxK();\n    blocks[i / BlockLen].Rebuild();\n  }\n\n  cout << dp[N] << ""\\n"";\n}\n\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2900
Jury has hidden a permutation of integers from to You know only the length Remind that in permutation all integers are distinct Let be the inverse permutation for i e for all The only thing you can do is to ask of elements and printing two indices and not necessarily distinct As a result of the query with indices and you ll get the value where denotes the operation You can find the description of operation in notes Note that some permutations can remain indistinguishable from the hidden one even if you make all possible queries You have to compute the number of permutations indistinguishable from the hidden one and print one of such permutations making no more than queries The hidden permutation does not depend on your queries ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n\n#define forn(i, a, n) for (int i = (int)(a); i < (int)(n); ++i)\n#define ford(i, a, n) for (int i = (int)(n - 1); i >= (int)(a); --i)\n#define fore(i, a, n) for (int i = (int)(a); i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define fs first\n#define sn second\n#define trace(a)\\\n    for (auto i : a) cerr << i << \' \';\\\n    cerr << \'\\n\'\n#define eb emplace_back\n\n#ifndef M_PI\nconst ld M_PI = acos(-1.0);\n#endif\n\ntemplate<typename T>\ninline void setmax(T& a, T b) {\n    if (a < b) a = b;\n}\n\ntemplate<typename T>\ninline void setmin(T& a, T b) {\n    if (a > b) a = b;\n}\n\nconst ld eps = 1e-9;\nconst int INF = 2000000000;\nconst ll LINF = 1ll * INF * INF;\nconst ll MOD = 1000000007;\n\nint get(int i, int j) {\n    cout << ""? "" << i << \' \' << j << endl;\n    int x;\n    cin >> x;\n    return x;\n}\n\nbool is_perm(vector<int> a) {\n    int n = a.size();\n    vector<int> cnt(n);\n    for (int x : a) {\n        if (x < 0 || x >= n)\n            return false;\n        if (cnt[x]) return false;\n        ++cnt[x];\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    forn(i, 0, n) a[i] = get(0, i);\n    b[0] = a[0];\n    forn(i, 1, n) b[i] = get(i, 0);\n    vector<int> ans;\n    int cnt = 0;\n    forn(x, 0, n) {\n        vector<int> p1(n), p2(n);\n        forn(i, 0, n)\n            p2[i] = x ^ a[i];\n        forn(i, 0, n)\n            p1[i] = p2[0] ^ b[i];\n        bool ok = is_perm(p1) && is_perm(p2);\n        for (int i = 0; i < n && ok; ++i)\n            if (p1[p2[i]] != i) ok = false;\n        if (ok) {\n            ++cnt;\n            ans = p1;\n        }\n    }\n    cout << ""!\\n"";\n    cout << cnt << \'\\n\';\n    forn(i, 0, n) cout << ans[i] << \' \';\n    cout << endl;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
ZS the Coder has recently found an interesting concept called the Birthday Paradox It states that given a random set of people there is around chance that some two of them share the same birthday ZS the Coder finds this very interesting and decides to test this with the inhabitants of Udayland In Udayland there are days in a year ZS the Coder wants to interview people from Udayland each of them has birthday in one of days each day with equal probability He is interested in the probability of at least two of them have the birthday at the same day ZS the Coder knows that the answer can be written as an irreducible fraction He wants to find the values of and he does not like to deal with floating point numbers Can you help him ,"['#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int maxn = (int)1e6;\nconst int inf = (int)1e9;\nconst int mod = (int)1e6 + 3;\nconst ll INF = (ll)1e18;\nconst double eps = 1e-9;\n\nll n, k;\n\nll binpow(ll a, ll k) {\n\tif (k == 0) return 1;\n\tll ans = binpow(a, k / 2);\n\tans = 1ll * ans * ans % mod;\n\tif (k % 2) ans = 1ll * ans * a % mod;\n\treturn ans;\n}\n\nll g(ll n, ll k) {\n\tif (k < mod) {\n\t\tll t = binpow(2, n);\n\t\tll ans = 1;\n\t\tfor (int i = 0; i <= k; i++) {\n\t\t\tans *= (t - (2ll * i + 1));\n\t\t\tans %= mod;\n\t\t\tif (ans < 0) ans += mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tll t = binpow(2, n);\n\tll cur = 1;\n\tfor (int i = 0; i < mod; i++) {\n\t\tcur *= (t - (2ll * i + 1));\n\t\tcur %= mod;\n\t\tif (cur < 0) cur += mod;\n\t}\n\tll s = k / mod;\n\tll ans = binpow(cur, s) * g(n, k % mod) % mod;\n\treturn ans;\n}\n\nll f(ll n, ll k) {\n\tif (k == 0) return 1;\n\tll t = (k - 1) / 2;\n\tll ans = g(n, t);\n\treturn ans * 1ll * f(n - 1, k / 2) % mod;\n}\n\nll get(ll n, ll k) {\n\tif (k == 0) return 0;\n\tll t = k / 2;\n\treturn t + get(n, t);\n}\n\nint main()\n{\n\n\tcin >> n >> k;\n\t\n\tif (n <= 60) {\n\t\tll mx = 1;\n\t\tfor (int i = 0; i < n; i++) mx *= 2;\n\t\tif (mx < k) {\n\t\t\tcout << 1 << "" "" << 1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tll alpha = get(n, k - 1);\n\tll P = f(n, k - 1);\n\tll t = n % (mod - 1) * 1ll * ((k - 1) % (mod - 1)) % (mod - 1);\n\tt -= alpha;\n\tt %= mod - 1;\n\tt += mod - 1;\n\tt %= mod - 1;\n\tll Q = binpow(2, t);\n\t\n\tP = Q - P;\n\tP %= mod; P += mod; P %= mod;\n\t\n\tcout << P << "" "" << Q << endl;\n\t\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2300
Suppose you are living with two cats A and B There are n napping spots where both cats usually sleep Your cats like to sleep and also like all these spots so they change napping spot each hour cyclically Cat A changes its napping place in order n n 1 n 2 dots 3 2 1 n n 1 dots In other words at the first hour it s on the spot n and then goes in decreasing order cyclically Cat B changes its napping place in order 1 2 3 dots n 1 n 1 2 dots In other words at the first hour it s on the spot 1 and then goes in increasing order cyclically The cat B is much younger so they have a strict hierarchy A and B don t lie together In other words if both cats d like to go in spot x then the A takes this place and B moves to the next place in its order if x n then to x 1 but if x n then to 1 Cat B follows his order so Calculate where cat B will be at hour k ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nvoid solve() {\n\n    ll N, K; cin >> N >> K;\n    if (N % 2 == 0) {\n        ll ans = K%N; if (ans == 0) ans = N;\n        cout << ans << nl;\n        return;\n    }\n    ll skip = (K - 1) / (N/2);\n    ll ans = (K+skip)%N; if (ans == 0) ans = N;\n    cout << ans << nl;\n\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1200
There is an infinite 2 dimensional grid The robot stands in cell 0 0 and wants to reach cell x y Here is a list of possible commands the robot can execute move north from cell i j to i j 1 move east from cell i j to i 1 j move south from cell i j to i j 1 move west from cell i j to i 1 j stay in cell i j The robot wants to reach cell x y in as few commands as possible However he can t execute the same command two or more times in a row What is the minimum number of commands required to reach x y from 0 0 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tint x, y; scanf(""%d%d"", &x, &y);\n\t\tif(x < y) swap(x, y);\n\t\tif(x == y) printf(""%d\\n"", x + y);\n\t\telse printf(""%d\\n"", 2 * y + 1 + (x - y - 1) * 2);\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Kevin Sun has just finished competing in Codeforces Round 334 The round was 120 minutes long and featured five problems with maximum point values of 500 1000 1500 2000 and 2500 respectively Despite the challenging tasks Kevin was uncowed and bulldozed through all of them distinguishing himself from the herd as the best cowmputer scientist in all of Bovinia Kevin knows his submission time for each problem the number of wrong submissions that he made on each problem and his total numbers of successful and unsuccessful hacks Because Codeforces scoring is complicated Kevin wants you to write a program to compute his final score Codeforces scores are computed as follows If the maximum point value of a problem is and Kevin submitted correctly at minute but made wrong submissions then his score on that problem is His total score is equal to the sum of his scores for each problem In addition Kevin s total score gets increased by points for each successful hack but gets decreased by points for each unsuccessful hack All arithmetic operations are performed with absolute precision and no rounding It is guaranteed that Kevin s final score is an integer ,"['#include<cstdio>\n#include<bitset>\n#include<vector>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint N, t[10], w[10], a, b;\n\ndouble mod (double x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nint main()\n{\n//freopen (""input"", ""r"", stdin);\n//freopen (""output"", ""w"", stdout);\n\nfor (int i=1; i<=5; i++)\n    scanf (""%d"", &t[i]);\nfor (int i=1; i<=5; i++)\n    scanf (""%d"", &w[i]);\nscanf (""%d %d"", &a, &b);\ndouble val = 100.0 * a - 50.0 * b;\nfor (int i=1; i<=5; i++)\n{\n    double x = i * 500.0;\n    double curr = x - (double) x * t[i] / 250.0 - 50.0 * w[i];\n    if (0.3 * x > curr) curr = 0.3 * x;\n    val += curr;\n}\n/*int sol = (int) val, pos, mini = 10000.0;\nfor (int i=sol - 2; i<=sol + 2; i++)\n    if (mod ((double) i - val) < mini)\n        mini = mod ((double) i - val), pos = i;\nprintf (""%d\\n"", pos);*/\nprintf (""%.lf\\n"", val);\n\nreturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
ZS the Coder loves mazes Your job is to create one so that he can play with it A maze consists of rooms and the rooms are arranged in rows numbered from the top to the bottom starting from and columns numbered from the left to the right starting from The room in the th row and th column is denoted by A player starts in the room and wants to reach the room Each room has four doors except for ones at the maze border one on each of its walls and two adjacent by the wall rooms shares the same door Some of the doors are locked which means it is impossible to pass through the door For example if the door connecting and is locked then we can t go from to Also one can only travel between the rooms downwards from the room to the room or rightwards from the room to the room provided the corresponding door is not locked ZS the Coder considers a maze to have if there is exactly ways of travelling from the room to the room Two ways are considered different if they differ by the sequence of rooms visited while travelling Your task is to create a maze such that its difficulty is exactly equal to In addition ZS the Coder doesn t like large mazes so the size of the maze and the number of locked doors are limited Sounds simple enough right ,"[""// Coding on my mac\n// My mac doesn't have bits/stdc++.h\n// http://codeforces.com/blog/entry/47152 looks helpful\n// If only I could be bothered setting things up\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nvector<pair<pair<int, int>, pair<int, int> > > ans;\nbool open[52][52][2];\n\nint main()\n{\n\tcout << 42 << ' ' << 50 << '\\n';\n\tcin.sync_with_stdio(false); cin.tie(0);\n\tll n; cin >> n;\n\tfor (int i = 0;i < 52;i++) for (int j = 0;j < 52;j++) open[i][j][0] = open[i][j][1] = true;\n\tfor (int i = 0;i < 13;i++)\n\t{\n\t\tint r = 3*i+3, c = 3*i+11;\n\t\topen[r][c+3][0] = false;\n\t\topen[r+1][c+3][0] = false;\n\t\topen[r+2][c+3][0] = false;\n\t\topen[r+3][c][1] = false;\n\t\topen[r+3][c+1][1] = false;\n\t\topen[r+3][c+2][1] = false;\n\t}\n\tint from = 1;\n\tfor (int i = 1;i <= 42;i++)\n\t{\n\t\topen[i][from][0] = false;\n\t\tif (i >= 7 && i%3 == 1)\n\t\t{\n\t\t\topen[i][from][0] = true;\n\t\t\topen[i][from][1] = false;\n\t\t\topen[i][from+1][1] = false;\n\t\t\topen[i][from+2][1] = false;\n\t\t\topen[i][from+3][0] = false;\n\t\t\tfrom += 3;\n\t\t}\n\t}\n\tfor (int i = 12;i >= -1;i--)\n\t{\n\t\tint r = 3*i+3, c = 3*i+11;\n\t\tint va = n%20; n /= 20;\n\t\tif (va == 0) continue;\n\t\tint bone = c - 10;\n\t\tif (bone <= 0) bone = 1;\n\t\tfor (int j = bone+1;j < c+3;j++) open[r+3][j][1] = false;\n\t\topen[r+3][bone][0] = true;\n\t\tif (va == 1) continue;\n\t\topen[r+2][bone][0] = true;\n\t\tif (va <= 10) open[r+2][bone+va-1][0] = false;\n\t\telse\n\t\t{\n\t\t\topen[r+2][bone+9][0] = false;\n\t\t\tint wh = bone + 20 - va;\n\t\t\topen[r+1][bone][0] = true;\n\t\t\tfor (int j = bone+1;j < wh;j++) open[r+1][j][1] = false;\n\t\t\topen[r+1][wh][0] = false;\n\t\t}\n\t}\n\tfor (int i = 1;i <= 42;i++) for (int j = 1;j <= 50;j++)\n\t{\n\t\tif (!open[i][j][0] && j != 50)\n\t\t\tans.push_back({{i, j}, {i, j+1}});\n\t\tif (!open[i][j][1] && i != 42)\n\t\t\tans.push_back({{i, j}, {i+1, j}});\n\t}\n\tcout << ans.size() << '\\n';\n\tfor (auto u: ans) cout << u.first.first << ' ' << u.first.second << ' ' << u.second.first << ' ' << u.second.second << '\\n';\n\treturn 0;\n}\n""]","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3100
Everyone knows that agents in Valorant decide who will play as attackers and who will play as defenders To do that Raze and Breach decided to play t matches of a digit game In each of t matches of the digit game a positive integer is generated It consists of n digits The digits of this integer are numerated from 1 to n from the highest order digit to the lowest order digit After this integer is announced the match starts Agents play in turns Raze starts In one turn an agent can choose any unmarked digit and mark it Raze can choose digits on odd positions but can not choose digits on even positions Breach can choose digits on even positions but can not choose digits on odd positions The match ends when there is only one unmarked digit left If the single last digit is odd then Raze wins else Breach wins It can be proved that before the end of the match for every initial integer with n digits each agent has an ability to make a turn i e there is at least one unmarked digit that stands on a position of required parity For each of t matches find out which agent wins if both of them want to win and play optimally ,"['#pragma GCC optimize(3)\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define rint register int\n#define INF ((1 << 30) - 1)\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define Pair pair < int, int >\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i, k, j) for(rint i = (k); i >= (j); i--)\n#define For(i, k, j) for(rint i = (k); i <= (j); i++)\n#define Foe(i, u) for(rint i = lst[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\n#define file(s) freopen(s"".in"", ""r"", stdin); freopen(s"".out"", ""w"", stdout)\n#define int long long\nconst int P = 1000000007; //\nusing namespace std;\ninline void ckmax(int &a, int b) {a = max(a, b);}\ninline void ckmin(int &a, int b) {a = min(a, b);}\ninline void mulmod(int &a, int b) {a = 1ll * a * b % P;}\ninline void addmod(int &a, int b) {int t = a + b; a = (t >= P ? t - P : t); }\ninline int ksm(int a, int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a, P-2);}\n\ninline void printarray(int *a, int n) {For(i, 1, n) fprintf(stderr, ""%d "", a[i]); fprintf(stderr, ""\\n"");}\nnamespace FastIO {\n    const int SIZE=1<<16; char buf[SIZE], obuf[SIZE], str[64]; int bi=SIZE, bn=SIZE, opt;\n    int read(char *s) {\n        while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n        int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n    }\n    bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n    void write(int x) {\n        if(!x) obuf[opt++] = \'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n        if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}\n    }\n    void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf, 1, opt, stdout); opt=0;}}\n    void Fflush() { if (opt) fwrite(obuf, 1, opt, stdout); opt=0;}\n};\nconst int MAXN = 3e5 + 5;\nint a[MAXN], n;\nsigned main()\n{\n    #ifndef ONLINE_JUDGE\n        file(""pro"");\n    #endif\n    int T; cin >> T;\n    while(T--) {\n    \tcin >> n; string s; cin >> s; s = \' \' + s;\n    \tif(n & 1) {\n    \t\tint res = 0;\n    \t\tfor(int i = 1; i <= n; i += 2) \n    \t\t\tif((s[i] - \'0\') & 1) res = 1;\n    \t\tprintf(res ? ""1\\n"" : ""2\\n"");\n\t\t} else {\n\t\t\tint res = 0;\n    \t\tfor(int i = 2; i <= n; i += 2) \n    \t\t\tif(!((s[i] - \'0\') & 1)) res = 1;\n    \t\tprintf(res ? ""2\\n"" : ""1\\n"");\n\t\t}\n\t}\n    return FastIO::Fflush(), 0;\n}\n/*\nThink twice :\nmod ?\nINF ?\nn = 1 ?\nlong long ?\nFastio::Fflush() ?\n\n*/\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
You are given an array of integers a 1 a 2 ldots a n Calculate the number of of this array 1 leq l leq r leq n such that The array b a l a l 1 ldots a r occurs in the array a as a exactly once In other words there is exactly one way to select a set of indices 1 leq i 1 i 2 ldots i r l 1 leq n such that b j a i j for all 1 leq j leq r l 1 ,"['#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<map>\ntypedef long long ll;\nconst int maxn=2e5+5;\nint t;\nint n;\nint a[maxn],fir[maxn],las[maxn];\nstd::map<int,bool>apr;\nsigned main(){\n\tscanf(""%d"",&t);\n\tfor(int wc=1;wc<=t;wc++){\n\t\tapr.clear();\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=n;i++)scanf(""%d"",a+i),fir[i]=(!apr[a[i]]),apr[a[i]]=true;\n\t\tapr.clear(),las[n+1]=0;\n\t\tfor(int i=n;i;i--)las[i]=las[i+1]+(!apr[a[i]]),apr[a[i]]=true;\n\t\tll ans=0;\n\t\tfor(int i=1;i<=n;i++)ans+=fir[i]*las[i];\n\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}\n//namespace burningContract\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
During the lesson small girl Alyona works with one famous spreadsheet computer program and learns how to edit tables Now she has a table filled with integers The table consists of rows and columns By we will denote the integer located at the th row and the th column We say that the table is sorted in non decreasing order in the column if for all from to Teacher gave Alyona tasks For each of the tasks two integers and are given and Alyona has to answer the following question if one keeps the rows from to inclusive and deletes all others will the table be sorted in non decreasing order in at least one column Formally does there exist such that for all from to inclusive Alyona is too small to deal with this task and asks you to help ,"['#include <set>\n#include <map>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <bitset>\n#include <cstring>\n#include <cstdlib>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#define REP(i,a,b) for(int i=(a);i<=(b);i++)\n#define PER(i,a,b) for(int i=(a);i>=(b);i--)\n#define RVC(i,S) for(int i=0;i<(S).size();i++)\n#define RAL(i,u) for(int i=fr[u];i!=-1;i=e[i].next)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\n     \ntemplate<class T> inline\nvoid read(T& num) {\n    bool start=false,neg=false;\n    char c;\n    num=0;\n    while((c=getchar())!=EOF) {\n        if(c==\'-\') start=neg=true;\n        else if(c>=\'0\' && c<=\'9\') {\n            start=true;\n            num=num*10+c-\'0\';\n        } else if(start) break;\n    }\n    if(neg) num=-num;\n}\n/*============ Header Template ============*/\n\nconst int maxn=(int)(1e5)+5;\nvector<int> a[maxn];\nint mi[maxn];\nint tmp[maxn];\n\nint main() {\n    int n,m;\n    read(n);read(m);\n    REP(i,1,n) {\n        a[i].push_back(0);\n        REP(j,1,m) {\n            int x;\n            read(x);\n            a[i].push_back(x);\n        }\n    }\n    int q;\n    read(q);\n    memset(mi,0x3f,sizeof(mi));\n    REP(j,1,m) {\n        int lst=1;\n        tmp[1]=1;\n        REP(i,2,n) {\n            if(a[i][j]<a[i-1][j]) lst=i;\n            tmp[i]=lst;\n        }\n        REP(i,1,n) mi[i]=min(mi[i],tmp[i]);\n    }\n    REP(i,1,q) {\n        int l,r;\n        read(l);read(r);\n        if(mi[r]<=l) {\n            printf(""Yes\\n"");\n        } else {\n            printf(""No\\n"");\n        }\n    }\n    return 0;\n}']","[1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1600
Sometimes Mister B has free evenings when he doesn t know what to do Fortunately Mister B found a new game where the player can play against aliens All characters in this game are lowercase English letters There are two players Mister B and his competitor Initially the players have a string consisting of the first English letters in alphabetical order for example if then equals to The players take turns appending letters to string Mister B moves first Mister B must append exactly letters on each his move He can arbitrary choose these letters His opponent adds exactly letters on each move Mister B quickly understood that his opponent was just a computer that used a simple algorithm The computer on each turn considers the suffix of string of length and generates a string of length such that all letters in the string are distinct and don t appear in the considered suffix From multiple variants of lexicographically minimal is chosen if and the suffix is the computer chooses string equal to After that the chosen string is appended to the end of Mister B soon found the game boring and came up with the following question what can be the minimum possible number of different letters in string on the segment between positions and inclusive Letters of string are numerated starting from ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint a, b, l, r, i, c, j, ans = 0;\n\tscanf(""%d %d %d %d"", &a, &b, &l, &r);\n\tint lq = (l - 1) / (a + b), lr = (l - 1) % (a + b) + 1, rq = (r - 1) / (a + b), rr = (r - 1) % (a + b) + 1;\n\tif (rq == lq) {\n\t\tif (rr <= a) ans = rr - lr + 1;\n\t\telse if(lr <= a) ans = a - lr + 1;\n\t\telse ans = 1;\n\t}\n\telse{\n\t\trr = min(a, rr);\n\t\tif (b < a) {\n\t\t\tif (rq - lq >= 3) ans = 2 * a - b;\n\t\t\telse if (rq - lq == 1) {\n\t\t\t\tif (lr > a) ans = 1 + rr;\n\t\t\t\telse ans = min(a - b, a - lr + 1) + rr;\n\t\t\t}\n\t\t\telse if (rq - lq == 2) {\n\t\t\t\tif (lr > a) ans = max(b + 1, rr) + a - b;\n\t\t\t\telse ans = max(b + a - lr + 1, rr) + a - b;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (rq - lq >= 2) ans = a + 1;\n\t\t\telse {\n\t\t\t\tif(rr >= a) ans = a + 1;\n\t\t\t\telse if(lr > a) ans = 1 + rr;\n\t\t\t\telse ans = min(rr + a - lr + 1, a);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Innovation technologies are on a victorious march around the planet They integrate into all spheres of human activity A restaurant called Dijkstra s Place has started thinking about optimizing the booking system There are booking requests received by now Each request is characterized by two numbers and the size of the group of visitors who will come via this request and the total sum of money they will spend in the restaurant correspondingly We know that for each request all people want to sit at the same table and are going to spend the whole evening in the restaurant from the opening moment at 18 00 to the closing moment Unfortunately there only are tables in the restaurant For each table we know the maximum number of people who can sit at it A table can have only people from the same group sitting at it If you cannot find a large enough table for the whole group then all visitors leave and naturally pay nothing Your task is given the tables and the requests decide which requests to accept and which requests to decline so that the money paid by the happy and full visitors was maximum ,"[""#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin(); e!=x.end(); ++e)\n\nconst int N = 1000 + 10;\n\nint n, k;\nint c[N], p[N], r[N];\nint vis[N];\npair<int, int> b[N];\npair< pair<int, int>, int> a[N];\n\nvoid solve()\n{\n\tcin >> n;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tcin >> c[i] >> p[i];\n\t\ta[i] = make_pair(make_pair(p[i], - c[i]), i);\n\t}\n\tsort(a, a + n);\n\tcin >> k;\n\tfor(int i = 0; i < k; ++ i) {\n\t\tcin >> r[i];\n\t\tb[i] = make_pair(r[i], i);\n\t}\n\tsort(b, b + k);\n\n\tint ret = 0;\n\tvector< pair<int, int> > vec;\n\n\tfor(int i = n - 1; i >= 0; -- i) {\n\t\tint tmp = -a[i].first.second;\n\n\t\tfor(int j = 0; j < k; ++ j) {\n\t\t\tif (b[j].first >= tmp && ! vis[j]) {\n\t\t\t\tvis[j] = true;\n\t\t\t\tret += a[i].first.first;\n\t\t\t\tvec.push_back(make_pair(a[i].second + 1, b[j].second + 1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcout << vec.size() << ' ' << ret << endl;\n\tfor(int i = 0; i < vec.size(); ++ i) {\n\t\tcout << vec[i].first << ' ' << vec[i].second << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n""]","[1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
You are locked in a room with a door that has a keypad with 10 keys corresponding to digits from 0 to 9 To escape from the room you need to enter a correct code You also have a sequence of digits Some keys on the keypad have fingerprints You believe the correct code is the longest not necessarily contiguous subsequence of the sequence you have that only contains digits with fingerprints on the corresponding keys Find such code ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX = 100005;\nint a[1000005];\nbool xd[1000005];\nint main() {\n\t// freopen(""a.in"", ""r"", stdin);\n\tint n, m; cin >> n >> m;\n\tfor (int i=0; i<n; i++) { scanf(""%d"", &a[i]); }\n\tfor (int i=0; i<m; i++) {\n\t\tint x; scanf(""%d"", &x); xd[x] = true;\n\n\t}\n\tfor (int i=0; i<n; i++) { if (xd[a[i]]) { cout << a[i] << "" ""; }}\n\n\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given a number n and an array b 1 b 2 ldots b n 2 obtained according to the following algorithm some array a 1 a 2 ldots a n was guessed array a was written to array b i e b i a i 1 le i le n The n 1 th element of the array b is the sum of the numbers in the array a i e b n 1 a 1 a 2 ldots a n The n 2 th element of the array b was written some number x 1 le x le 10 9 i e b n 2 x The array b was shuffled For example the array b 2 3 7 12 2 it could be obtained in the following ways a 2 2 3 and x 12 a 3 2 7 and x 2 For the given array b find any array a that could have been guessed initially ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=200010;\nconst int mod=1000000007;\nusing namespace std;\n\nint a[def];\n\nint main()\n{\tint _=1,__=1,n;\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d"",&n);n+=2;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tscanf(""%d"",&a[i]);\n\t\tsort(a+1,a+n+1);\n\t\tll sum=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t\tsum+=a[i];\n\t\tsum-=a[n];\n\t\tif(*lower_bound(a+1,a+n-1,sum)==sum){\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tif(a[i]!=sum){\n\t\t\t\t\tprintf(""%d "",a[i]);\n\t\t\t\t}else sum=-1;\n\t\t\t}\n\t\t\tputs("""");\n\t\t\tcontinue;\n\t\t}\n\n\t\tsum=0;\n\t\tfor(int i=1;i<n-1;i++)\n\t\t\tsum+=a[i];\n\t\tif(sum==a[n-1]){\n\t\t\tfor(int i=1;i<n-1;i++)\n\t\t\t\tprintf(""%d "",a[i]);\n\t\t\tputs("""");\n\t\t\tcontinue;\n\t\t}\n\t\tputs(""-1"");\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
When Serezha was three years old he was given a set of cards with letters for his birthday They were arranged into words in the way which formed the boy s mother favorite number in binary notation Serezha started playing with them immediately and shuffled them because he wasn t yet able to read His father decided to rearrange them Help him restore the original number on condition that it was the maximum possible one ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#ifndef LOCAL\n#pragma GCC optimize(""O3"")\n#endif\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define st first\n#define nd second\n\nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(11);\n\tcerr << fixed << setprecision(6);\n\t\n\tint n; string s;\n\tcin >> n >> s;\n\t\n\tint c0 = count(ALL(s), \'z\');\n\tint c1 = count(ALL(s), \'n\');\n\tfor (int i = 0; i < c1; ++i) { cout << ""1 ""; }\n\tfor (int i = 0; i < c0; ++i) { cout << ""0 ""; }\n\tcout << ""\\n"";\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
You are given a program you want to execute as a set of tasks organized in a dependency graph The dependency graph is a directed acyclic graph each task can depend on results of one or several other tasks and there are no directed circular dependencies between tasks A task can only be executed if all tasks it depends on have already completed Some of the tasks in the graph can only be executed on a coprocessor and the rest can only be executed on the main processor In one coprocessor call you can send it a set of tasks which can only be executed on it For each task of the set all tasks on which it depends must be either already completed or be included in the set The main processor starts the program execution and gets the results of tasks executed on the coprocessor automatically Find the minimal number of coprocessor calls which are necessary to execute the given program ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace program\n{\n\tconst int MAXN = 100000;\n\tint n, m, tot, Deg[MAXN + 10], E[MAXN + 10];\n\tvector<int> R[MAXN + 10];\n\tqueue<int> Q0, Q1;\n\n\tvoid work()\n\t{\n\t\ttot = 0;\n\t\tscanf(""%d%d"", &n, &m);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tscanf(""%d"", &E[i]);\n\t\tmemset(Deg, 0, sizeof(int) * n);\n\t\twhile(m--)\n\t\t{\n\t\t\tint u, v;\n\t\t\tscanf(""%d%d"", &u, &v);\n\t\t\tR[v].push_back(u);\n\t\t\tDeg[u]++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(!Deg[i])\n\t\t\t{\n\t\t\t\tif(!E[i])\n\t\t\t\t\tQ0.push(i);\n\t\t\t\telse\n\t\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\twhile(!Q0.empty() || !Q1.empty())\n\t\t{\n\t\t\tint f = 0;\n\t\t\twhile(!Q0.empty())\n\t\t\t{\n\t\t\t\tint u = Q0.front();\n\t\t\t\tQ0.pop();\n\t\t\t\tfor(vector<int>::iterator p = R[u].begin(); p != R[u].end(); p++)\n\t\t\t\t{\n\t\t\t\t\tint v = *p;\n\t\t\t\t\tif(!--Deg[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!E[v])\n\t\t\t\t\t\t\tQ0.push(v);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tQ1.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q1.empty())\n\t\t\t{\n\t\t\t\tf = 1;\n\t\t\t\tint u = Q1.front();\n\t\t\t\tQ1.pop();\n\t\t\t\tfor(vector<int>::iterator p = R[u].begin(); p != R[u].end(); p++)\n\t\t\t\t{\n\t\t\t\t\tint v = *p;\n\t\t\t\t\tif(!--Deg[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!E[v])\n\t\t\t\t\t\t\tQ0.push(v);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tQ1.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot += f;\n\t\t}\n\t\tprintf(""%d\\n"", tot);\n\t}\n}\n\nint main()\n{\n\tprogram::work();\n\treturn 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Nauuo is a girl who loves coding One day she was solving a problem which requires to calculate a sum of some numbers modulo p She wrote the following code and got the verdict Wrong answer She soon discovered the bug the function only worked for numbers in the range 0 p but the numbers in the problem may be out of the range She was curious about the wrong function so she wanted to know the result of it However the original code worked too slow so she asked you to help her You are given an array a 1 a 2 ldots a n and a number p Nauuo will make m queries in each query you are given l and r and you have to calculate the results of You can see the definition of the function in the pseudocode above Note that the integers won t overflow in the code above ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll read(){ll i;cin>>i;return i;}\n\nconst int inf=LLONG_MAX/3;\n\nint p;\n\nstruct N{\n\tvi x;\n\tint s;\n\tvoid init(int a){\n\t\tx={-inf,p-a,inf};\n\t\ts=a;\n\t}\n\tvoid mrg(const N&a,const N&b){\n\t\tint len=a.x.size()+b.x.size()-4;\n\t\tx.pb(-inf);\n\t\tint c=0,d=0;\n\t\trng(num,1,len+1){\n\t\t\tint cur=x.back();\n\t\t\twhile(c+d<num){\n\t\t\t\tint nx=min(a.x[c+1]-cur,b.x[d+1]-(cur+a.s-c*p));\n\t\t\t\tcur+=nx;\n\t\t\t\tif(a.x[c+1]<=cur)c++;\n\t\t\t\tif(d)d--;\n\t\t\t\twhile(b.x[d+1]<=cur+a.s-c*p)d++;\n\t\t\t}\n\t\t\tx.pb(cur);\n\t\t}\n\t\tx.pb(inf);\n\t\ts=a.s+b.s;\n\t}\n\tint get(int v){\n\t\treturn v+s-(upper_bound(all(x),v)-x.bg-1)*p;\n\t}\n};\n\nstruct S{\n\tvc<N> buf;\n\tint s;\n\tS(vi d){\n\t\ts=1;\n\t\twhile(s<int(d.size()))s*=2;\n\t\td.resize(s);\n\t\tbuf.resize(s*2);\n\t\trep(i,s)\n\t\t\tbuf[i+s].init(d[i]);\n\t\tgnr(i,1,s)\n\t\t\tbuf[i].mrg(buf[i*2],buf[i*2+1]);\n\t}\n\tvoid get(int b,int e,int&v,int l,int r,int i){\n\t\tif(e<=l||r<=b)return;\n\t\tif(b<=l&&r<=e){\n\t\t\tv=buf[i].get(v);\n\t\t\treturn;\n\t\t}\n\t\tint m=(l+r)/2;\n\t\tget(b,e,v,l,m,i*2);\n\t\tget(b,e,v,m,r,i*2+1);\n\t}\n\tint get(int b,int e){\n\t\tint v=0;\n\t\tget(b,e,v,0,s,1);\n\t\treturn v;\n\t}\n};\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n=read(),m=read();\n\tp=read();\n\tvi a(n);\n\trep(i,n)a[i]=read();\n\tS slv(a);\n\t\n\trep(_,m){\n\t\tint l=read()-1,r=read();\n\t\tcout<<slv.get(l,r)<<""\\n"";\n\t}\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3300
The country has cities and bidirectional roads it is possible to get from every city to any other one if you move only along the roads The cities are numbered with integers from to inclusive All the roads are initially bad but the government wants to improve the state of some roads We will assume that the citizens are happy about road improvement if the path from the capital located in city to any other city contains at most one bad road Your task is for every possible determine the number of ways of improving the quality of some roads in order to meet the citizens condition As those values can be rather large you need to print each value modulo ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <cassert>\n#include <ctime>\n#include <string>\n\nusing namespace std;\n\n#ifdef _WIN32\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n\ntypedef long double ld;\n\nlong long rdtsc() {\n  long long tmp;\n  asm(""rdtsc"" : ""=A""(tmp));\n  return tmp;\n}\n\ninline int myrand() {\n  return abs((rand() << 15) ^ rand());\n}\n\ninline int rnd(int x) {\n  return myrand() % x;\n}\n\n#define pb push_back\n#define mp make_pair\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define sz(x) ((int)(x).size())\n#define TASKNAME ""text""\n\nconst int INF = (int)1e9 + 1;\nconst ld EPS = 1e-9;\n\nvoid precalc() {\n}\n\nint n;\n\nconst int maxn = (int) 2e5 + 10;\nint pr[maxn];\n\nbool read() {\n  if (scanf(""%d"", &n) < 1) {\n    return 0;\n  }\n  pr[0] = -1;\n  for (int i = 1; i < n; ++i) {\n    scanf(""%d"", &pr[i]);\n    --pr[i];\n  }\n  return 1;\n}\n\nconst int MOD = (int) 1e9 + 7;\n\nint mult(int x, int y) {\n  return (long long) x * y % MOD;\n}\n\nvector<vector<int> > es;\n\nint f[maxn];\n\nvoid dfs(int v) {\n  int &res = f[v];\n  res = 1;\n  for (int it = 0; it < sz(es[v]); ++it) {\n    int u = es[v][it];\n    dfs(u);\n    res = mult(res, f[u] + 1);\n  }\n}\n\nint ans[maxn];\n\nvoid dfsLast(int v, int coef = 0) {\n  ++coef;\n  if (coef == MOD) {\n    coef = 0;\n  }\n  int &res = f[v];\n  res = 1;\n  int k  = sz(es[v]);\n  vector<int> pref(k + 1);\n  vector<int> suf(k + 1);\n  pref[0] = 1;\n  for (int i = 0; i < k; ++i) {\n    pref[i + 1] = mult(pref[i], f[es[v][i]] + 1);\n  }\n  suf[k] = 1;\n  for (int i = k - 1; i >= 0; --i) {\n    suf[i] = mult(suf[i + 1], f[es[v][i]] + 1);\n  }\n\n  ans[v] = mult(pref[k], coef);\n  for (int it = 0; it < k; ++it) {\n    int u = es[v][it];\n    dfsLast(u, mult(coef, mult(pref[it], suf[it + 1])));\n  }\n}\n\nvoid solve() {\n  es = vector<vector<int> >(n);\n  for (int i = 1; i < n; ++i) {\n    es[pr[i]].pb(i);\n  }\n\n  dfs(0);\n\n  dfsLast(0);\n  for (int i = 0; i < n; ++i) {\n    printf(""%d%c"", ans[i], "" \\n""[i == n - 1]);\n  }\n}\n\nint main() {\n  srand(rdtsc());\n#ifdef DEBUG\n  freopen(TASKNAME"".out"", ""w"", stdout);\n  assert(freopen(TASKNAME"".in"", ""r"", stdin));\n#endif\n\n  precalc();\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(""%.18lf\\n"", (double)clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2300
Ilya has recently taken up archaeology He s recently found two numbers written in the based notation Each of the found numbers consisted of exactly digits Ilya immediately started looking for information about those numbers He learned that the numbers are part of a cyphered code and the one who can decypher it can get the greatest treasure After considerable research Ilya understood that to decypher the code he should do the following Rearrange digits in the first number in some manner Similarly rearrange digits in the second number in some manner As a result of this operation the numbers can get leading zeroes Add numbers digit by digit modulo In other words we need to get the third number of length each digit of the number is the sum of the respective numbers of the found numbers For example suppose there are two numbers recorded in the ternary notation 001210 and 012111 then if you add them to each other digit by digit modulo 3 you will get number 010021 The key to the code is the maximum possible number that can be obtained in the previous step Help Ilya find the key to the code ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint n, m;\nint a[111111], b[111111];\nint la[111111], ra[111111];\nint Next[111111], Prev[111111];\nbool ma[111111], mb[111111];\n\nstruct data {\n    int i, j;\n    data (int _i, int _j) {\n        i = _i; j = _j;\n    }\n    inline friend bool operator < (data x, data y) {\n        return (a[x.i] + b[x.j]) % m < (a[y.i] + b[y.j]) % m;\n    }\n};\n\npriority_queue<data> f;\nset<int> idx;\n\nint main() {\n    // freopen(""E.in"", ""r"", stdin);\n\n    scanf(""%d%d"", &n, &m);\n    for(int i = 1; i <= n; i++) scanf(""%d"", a+i);\n    for(int i = 1; i <= n; i++) scanf(""%d"", b+i);\n\n    sort(a+1, a+1+n);\n    sort(b+1, b+1+n);\n    b[n+1] = m;\n    for(int i = 1; i <= n; i++)\n        idx.insert(-i);\n\n    memset(ma, 0, sizeof ma);\n    memset(mb, 0, sizeof mb);\n\n    for(int i = 1; i <= n; i++) {\n        int need = m-a[i]-1;\n        int l = 1, r = n+1;\n        while (l < r) {\n            int mid = (l+r)/2;\n            if (b[mid] <= need) l = mid+1;\n            else r = mid;\n        }\n        l--;\n        if (l) f.push(data(i, l));\n        if (l < n) f.push(data(i, n));\n    }\n\n    while (!f.empty()) {\n        data t = f.top(); f.pop();\n        if (!ma[t.i]) {\n            if (!mb[t.j]) {\n                printf(""%d "", (a[t.i] + b[t.j]) % m);\n                ma[t.i] = 1;\n                mb[t.j] = 1;\n                idx.erase(-t.j);\n            }\n            else {\n                set<int>::iterator it = idx.lower_bound(-t.j);\n                if (it != idx.end()) {\n                    t.j = -(*it);\n                    f.push(t);  \n                }\n                \n            }\n        }\n    }\n    return 0;\n}\n']","[1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2300
You have discovered n mysterious particles on a line with integer charges of c 1 dots c n You have a device that allows you to perform the following operation Choose a particle and remove it from the line The remaining particles will shift to fill in the gap that is created If there were particles with charges x and y directly to the left and right of the removed particle they combine into a single particle of charge x y For example if the line of particles had charges of 3 1 4 1 5 9 performing the operation on the 4th particle will transform the line into 3 1 9 9 If we then use the device on the 1st particle in this new line the line will turn into 1 9 9 You will perform operations until there is only one particle left What is the maximum charge of this remaining particle that you can obtain ,"['#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf("" %s"",ss);(st)=ss;}\n#define spln(i,n) (i==n?\'\\n\':\' \')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(""1.in"",""r"",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j,a[200005];\ni64 ans;\nvoid solve()\n{\n\tread(n);fz1(i,n)read(a[i]);\n\tans=-0x3f3f3f3f3f3f3f3fll;fz1(i,n)ans=max(ans,1ll*a[i]);\n\ti64 sum=0;bool flg=0;\n\tfor(i=1;i<=n;i+=2)if(a[i]>=0){\n\t\tflg=1;sum+=a[i];\n\t}\n\tif(flg) ans=max(ans,sum);\n\tsum=flg=0;\n\tfor(i=2;i<=n;i+=2)if(a[i]>=0){\n\t\tflg=1;sum+=a[i];\n\t}\n\tif(flg) ans=max(ans,sum);\n\tprintf(""%lld\\n"",ans);\n}\nint main()\n{\n\tint t;read(t);\n\twhile(t--)solve();\n\treturn 0;\n}']","[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
On Children s Day the child got a toy from Delayyy as a present However the child is so naughty that he can t wait to destroy the toy The toy consists of parts and ropes Each rope links two parts but every pair of parts is linked by at most one rope To split the toy the child must remove all its parts The child can remove a single part at a time and each remove consume an energy Let s define an energy value of part as The child spend energy for removing part where are the parts that are directly connected to the th and haven t been removed Help the child to find out what is the minimum total energy he should spend to remove all parts ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME """"\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""["" #x ""] Time = %.3lfs\\n"",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef linux\n#define LLD ""%lld""\n#else\n#define LLD ""%I64d""\n#endif\n\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst double INF = inf;\nconst double EPS = eps;\n                         \nint V[2100];\n\nint main()\n{\n  int i, n, m, v1, v2, res=0;\n  #ifdef LOCAL\n  freopen(TASKNAME"".in"",""r"",stdin);\n  freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n  scanf(""%d%d"", &n, &m);\n  for (i=0; i<n; i++)\n    scanf(""%d"", &V[i]);\n  for (i=0; i<m; i++)\n    scanf(""%d%d"", &v1, &v2), v1--, v2--, res+=min(V[v1],V[v2]);  \n  printf(""%d\\n"", res);\n  TIMESTAMP(end);\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Vasya is a regular participant at programming contests and is already experienced in finding important sentences in long statements Of course numbers constraints are important factorization of a number less than is easier than of a number less than However sometimes it s hard to understand the number at the first glance Could it be shortened For example instead of you could write 10 6 instead of 10 9 instead of 10 9 7 Vasya decided that to be concise the notation should follow several rules the notation should only consist of numbers operations of addition multiplication and exponentiation in particular the use of braces is forbidden the use of several exponentiation operations in a row is forbidden for example writing is unacceptable the value of the resulting expression equals to the initial number the notation should consist of the minimal amount of symbols Given n find the equivalent concise notation for it ,"[""// who's it from?\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define f first\n#define s second\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n\nll n;\nvector<pair<ll,string> > po;\nmap<ll, string> mp;\n\nint32_t main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n;\n\tfor (int base = 2; base <= 100000; base++) {\n\t\tll val = base;\n\t\tstring s = to_string(base) + '^';\n\t\tfor (int e = 2; val * base <= 10000000000ll; e++) {\n\t\t\tval *= base;\n\t\t\tpo.emplace_back(val, s + to_string(e));\n\t\t\tif(mp.count(val) && SZ(s + to_string(e)) < SZ(mp[val])) {\n\t\t\t\tmp[val] = s + to_string(e);\n\t\t\t} else if (!mp.count(val)) {\n\t\t\t\tmp[val] = s + to_string(e);\n\t\t\t}\n\t\t}\n\t}\n\t//for (ll n = 1; n <= 10000; n++) {\n\tstring res = to_string(n);\n\tfor (const pair<ll,string> &p : po) {\n\t\tif (n >= p.f) {\n\t\t\tif (mp.count(n - p.f)) {\n\t\t\t\tstring tmp = p.s + '+' + mp[n - p.f];\n\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\tres = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif ((n - i) % p.f == 0 && mp.count((n - i) / p.f)) {\n\t\t\t\t\tstring tmp = p.s + '*' + mp[(n - i) / p.f];\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\ttmp += '+';\n\t\t\t\t\t\ttmp += to_string(i);\n\t\t\t\t\t}\n\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tfor (int i = 2; i < 10; i++) {\n\t\t\t\tif (p.f * i <= n) {\n\t\t\t\t\tif (mp.count(n - p.f * i)) {\n\t\t\t\t\t\tstring tmp = p.s + '*' + to_string(i) + '+' + mp[n - p.f * i];\n\t\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (n % (p.f * i) == 0) {\n\t\t\t\t\t\tif (mp.count(n / (p.f * i))) {\n\t\t\t\t\t\t\tstring tmp = p.s + '*' + to_string(i) + '*' + mp[n / (p.f * i)];\n\t\t\t\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\t\t\t\tres = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring tmp = p.s;\n\t\t\tif (n - p.f != 0) {\n\t\t\t\ttmp += '+';\n\t\t\t\ttmp += to_string(n - p.f);\n\t\t\t}\n\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\tres = tmp;\n\t\t\t}\n\t\t\tll c = n / p.f;\n\t\t\tint d = 0;\n\t\t\tll asdf = c;\n\t\t\twhile (asdf) {\n\t\t\t\td++;\n\t\t\t\tasdf /= 10;\n\t\t\t}\n\t\t\tll num = 0;\n\t\t\tfor (int i = 1; i < d; i++) {\n\t\t\t\tnum = num * 10 + 9;\n\t\t\t\ttmp = to_string(num) + '*' + p.s;\n\t\t\t\tassert(n - num * p.f >= 0);\n\t\t\t\tif (n - num * p.f != 0) {\n\t\t\t\t\ttmp += '+';\n\t\t\t\t\ttmp += to_string(n - num * p.f);\n\t\t\t\t}\n\t\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\t\tres = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = to_string(c) + '*' + p.s;\n\t\t\tif (n - c * p.f != 0) {\n\t\t\t\ttmp += '+';\n\t\t\t\ttmp += to_string(n - c * p.f);\n\t\t\t}\n\t\t\tif (SZ(tmp) < SZ(res)) {\n\t\t\t\tres = tmp;\n\t\t\t}\n\t\t}\n\t}\n\t//cout << n << ' ';\n\tcout << res << endl;\n\t//}\n\treturn 0;\n}""]","[1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
Vasya has got an undirected graph consisting of n vertices and m edges This graph doesn t contain any self loops or multiple edges Self loop is an edge connecting a vertex to itself Multiple edges are a pair of edges such that they connect the same pair of vertices Since the graph is undirected the pair of edges 1 2 and 2 1 is considered to be multiple edges Isolated vertex of the graph is a vertex such that there is no edge connecting this vertex to any other vertex Vasya wants to know the minimum and maximum possible number of isolated vertices in an undirected graph consisting of n vertices and m edges ,"['/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fastIO ios_base::sync_with_stdio(0)\n#define nul point(0, 0)\n#define what_is(x) cerr << #x << "" is "" << x << endl\n#define solve_system int number; cin >> number; for (int i = 0; i < number; i++) solve()\n#define solve_system_scanf int number; scanf(""%d"", &number); for (int i = 0; i < number; i++) solve()\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst ll prost = 239;\nconst int two = 2;\nconst int th = 3;\nconst ll MOD = 998244353;\nconst ll MOD2 = MOD * MOD;\nconst int BIG = 1e9 + 239;\nconst int alf = 26;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dig = 10;\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n//easy functions\ntemplate< typename T >\ninline T gcd(T a, T b)\n{\n    while (a)\n    {\n        b %= a;\n        swap(a, b);\n    }\n    return b;\n}\ntemplate< typename T >\ninline T lcm(T a, T b) { return (a / gcd(a, b)) * b; }\ninline bool is_down(char x) { return (\'a\' <= x && x <= \'z\'); }\ninline bool is_upper(char x) { return (\'A\' <= x && x <= \'Z\'); }\ninline bool is_digit(char x) { return (\'0\' <= x && x <= \'9\'); }\n\n//random\nmt19937 rnd(239);\n\n//constants\nconst int M = 2 * 1e5 + 239;\nconst int N = 2 * 1e3 + 239;\nconst int L = 20;\nconst int T = (1 << 18);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 1e4 + 239;\n\nint main()\n{\n    #ifdef ONPC\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    ll n, m;\n    cin >> n >> m;\n    ll l = n;\n    ll r = 0;\n    for (ll x = 0; x <= n; x++)\n    {\n        ll v = (n - x);\n        ll e = m;\n        if (e < (v + 1) / 2LL) continue;\n        if (e > ((v * (v - 1)) / 2LL)) continue;\n        l = min(l, x);\n        r = max(r, x);\n    }\n    cout << l << "" "" << r;\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Sereja is interested in intervals of numbers so he has prepared a problem about intervals for you An interval of numbers is a pair of integers Interval belongs to interval if the following condition is met Sereja wants to write out a sequence of intervals on a piece of paper At that no interval in the sequence can belong to some other interval of the sequence Also Sereja loves number very much and he wants some at least one interval in the sequence to have Sereja wonders how many distinct ways to write such intervals are there Help Sereja and find the required number of ways modulo Two ways are considered distinct if there is such that the th intervals in two corresponding sequences are not equal ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007\n\nint N,M,X;\nint dp[2][320][320];\n\nint main(void){\n    int i,j,x;\n    \n    cin >> N >> M >> X;\n    X--;\n    \n    if(N > M){\n        cout << 0 << endl;\n        return 0;\n    }\n    \n    dp[0][0][0] = 1;\n    \n    REP(x,M){\n        int cur = x%2, next = (x+1)%2;\n        \n        REP(i,N+1) REP(j,N+1) dp[next][i][j] = 0;\n        \n        REP(i,N+1) REP(j,N+1) if(dp[cur][i][j] != 0){\n            if(x != X) dp[next][i][j] = (dp[next][i][j] + dp[cur][i][j]) % MOD;\n            if(x != X && i >= j+1) dp[next][i][j+1] = (dp[next][i][j+1] + dp[cur][i][j]) % MOD;\n            dp[next][i+1][j] = (dp[next][i+1][j] + dp[cur][i][j]) % MOD;\n            dp[next][i+1][j+1] = (dp[next][i+1][j+1] + dp[cur][i][j]) % MOD;\n        }\n    }\n    \n    ll ans = dp[M%2][N][N];\n    REP(i,N) ans = ans * (i+1) % MOD;\n    cout << ans << endl;\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2700
An array a of length m is considered good if there exists an integer array b of length m such that the following conditions hold sum limits i 1 m a i sum limits i 1 m b i a i neq b i for every index i from 1 to m b i 0 for every index i from 1 to m You are given an array c of length n Each element of this array is greater than 0 You have to answer q queries During the i th query you have to determine whether the subarray c l i c l i 1 dots c r i is good ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, q;\n    std::cin >> n >> q;\n    \n    std::vector<int> c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> c[i];\n    }\n    \n    std::vector<i64> s1(n + 1), s2(n + 1);\n    for (int i = 0; i < n; i++) {\n        s1[i + 1] = s1[i] + c[i];\n        s2[i + 1] = s2[i] + (c[i] == 1 ? 2 : 1);\n    }\n    \n    while (q--) {\n        int l, r;\n        std::cin >> l >> r;\n        l--;\n        \n        i64 a = s1[r] - s1[l];\n        i64 b = s2[r] - s2[l];\n        if (a >= b && r - l >= 2) {\n            std::cout << ""YES\\n"";\n        } else {\n            std::cout << ""NO\\n"";\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Jon Snow now has to fight with White Walkers He has rangers each of which has his own strength Also Jon Snow has his favourite number Each ranger can fight with a white walker only if the strength of the white walker equals his strength He however thinks that his rangers are weak and need to improve Jon now thinks that if he takes the bitwise XOR of strengths of some of rangers with his favourite number he might get soldiers of high strength So he decided to do the following operation times Arrange all the rangers in a straight line in the order of increasing strengths Take the bitwise XOR is written as of the strength of each alternate ranger with and update it s strength Suppose Jon has rangers with strengths and he performs the operation time with He first arranges them in the order of their strengths Then he does the following The strength of first ranger is updated to i e The strength of second ranger remains the same i e The strength of third ranger is updated to i e The strength of fourth ranger remains the same i e The strength of fifth ranger is updated to i e The new strengths of the rangers are Now Jon wants to know the maximum and minimum strength of the rangers after performing the above operations times He wants your help for this task Can you help him ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> pt;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nconst ld TAU=2*acos(-1);\nconst ld eps=1e-7;\nconst int inf=1e9+99;\nconst ll linf=1e18+88;\n\n\n\nint32_t main() {\n\tconst int N=1024;\n\tint n,k,x; scanf(""%d%d%d"",&n,&k,&x);\n\tstatic int c1[N],c2[N];\n\tfor(;n--;) {\n\t\tint a; scanf(""%d"",&a); ++c1[a];\n\t}\n\tfor(;k--;) {\n\t\tbool flip_next=1;\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tc2[i] += c1[i]>>1;\n\t\t\tc2[i^x] += c1[i]>>1;\n\t\t\tif(c1[i]&1) {\n\t\t\t\tif(flip_next) c2[i^x]++;\n\t\t\t\telse c2[i]++;\n\t\t\t\tflip_next = !flip_next;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++) c1[i]=c2[i], c2[i]=0;\n\t}\n\tint mn=N+7,mx=-1;\n\tfor(int i=0;i<N;i++) if(c1[i]) mx=i;\n\tfor(int i=N;--i>=0;) if(c1[i]) mn=i;\n\tprintf(""%d %d\\n"",mx,mn);\n}\n\n\n']","[0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
You are given a permutation dagger p of length n We call index x if for all y x it holds that p y p x and for all y x it holds that p y p x We call f p the number of good indices in p You can perform the following operation pick 2 indices i and j and swap elements p i and p j Find the maximum value of f p after applying the aforementioned operation dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['// Problem: F. Field Should Not Be Empty\n// Contest: Codeforces Round 915 (Div. 2)\n// URL: https://codeforces.com/contest/1905/problem/F\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#pragma GCC optimize(""Ofast,inline,unroll-loops"")\n// #define _GLIBCXX_DEBUG //交题前记得注释掉不然容易T。\n#include<bits/stdc++.h>\n#define File(s) freopen(#s"".in"",""r"",stdin),freopen(#s"".out"",""w"",stdout)\n#ifdef GTRAKIOI\n#define defrog(...) fprintf(stderr,__VA_ARGS__)\n#define deb(x) (std::cerr<<#x<<""@""<<__LINE__<<""=""<<(x)<<\'\\n\')\n#else\n#define defrog(...) 1\n#define deb(x) 1\n#endif\n#define defrogf(...) defrog(__VA_ARGS__)\n#if __cplusplus>=201703L\n#define rg\n#else\n#define rg register\n#endif\n#define ri rg int\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int>pii;\ntypedef std::vector<int>vi;\ntypedef std::vector<ll>vll;\ntypedef std::vector<pii>vpii;\ntypedef std::vector<vi >vvi;\ntypedef long double ld;\ntypedef __int128 i128;\ntypedef __uint128_t u128;\n#define Tp template<typename T>\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define all(cont) cont.begin(),cont.end()\n\nchar ibuf[1<<15],*p1,*p2;\n#define getchar() (p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,1<<15,stdin),p1==p2)?EOF:*p1++)\nstruct FastIO{\n\t/*inline void ou128(u128 x){\n\t\tu128 y=1;\n\t\twhile(y<=x/10)y*=10;\n\t\tdo putchar(x/y|48),x%=y,y/=10;while(y);\n\t}*/\n\tinline int rint(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c==\'-\';ri unsigned a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n\tinline ll rll(){rg char c,f=0;while((c=getchar())<48||c>57)f|=c==\'-\';rg ull a=c&15;while((c=getchar())>=48&&c<=57)a=a*10+(c&15);return f?~a+1:a;}\n//\tinline operator int(){return rint();}\n\tinline operator ll(){return rll();}\n\tinline char rchar(){rg char c;while(!isgraph(c=getchar()));return c;}\n\tinline int rstr(char*s){rg char c;while(!isgraph(c=getchar()));int cnt=-1;do s[++cnt]=c;while(isgraph(c=getchar()));s[++cnt]=0;return cnt;}\n}g90;\n\ntemplate<typename T=int>std::vector<T>rvec(std::size_t n,std::size_t start=0) {\n\tstd::vector<T>res(start+n);\n\tfor(std::size_t i=start;i<start+n;++i)res[i]=g90;\n\treturn res;\n}\n\nstd::mt19937 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int rnd(const int&a,const int&b){\n\treturn std::uniform_int_distribution<int>(a,b)(rng);\n}\ninline ld rnd(const ld&a,const ld&b){\n\treturn std::uniform_real_distribution<ld>(a,b)(rng);\n}\nnamespace MY_STD{\n\tTp inline T abs(const T&a){return a<0?-a:a;}\n}\n\nstruct DSU{//unweighted\n\tusing key_type=int;\n\n\tstd::vector<key_type>fa,size;\n\tinline DSU(key_type n):fa(n),size(n,1){std::iota(fa.begin(),fa.end(),0);}\n\tinline key_type& getFa(key_type x){\n\t\twhile(x^fa[x])x=fa[x]=fa[fa[x]];\n\t\treturn fa[x];\n\t}\n\tinline key_type& operator[](const key_type&x){return getFa(x);}\n\tinline auto canMerge(const key_type&u,const key_type&v){return getFa(u)!=getFa(v);}\n\tinline bool merge(key_type u,key_type v){\n\t\tu=getFa(u),v=getFa(v);\n\t\treturn (u)!=(v)&&(size[u]<size[v]&&(std::swap(u,v),1),fa[v]=u,size[u]+=size[v],size[v]=0,true);\n\t}\n\n};\n\nconstexpr int N=233333,M=1000000007;\ninline int qpow(ll a,ll b){ri res=1;for(;b;a=a*a%M,b>>=1)if(b&1)res=res*a%M;return res;}\n// #define pow qpow\nnamespace SegTree{\n\tstruct Node;\n\tusing Tree=Node*;\n\tusing CTree=const Node*;\n\tstruct Info{\n\t\tint res,max;\n\t};\n\tstruct Node{\n\t\tInfo info;\n\t\tTree ls,rs;\n\t}pool[N<<1];\n\tTree pptr=pool;\n\tvoid clear(){\n\t\tpptr=pool;\n\t}\n\tint search(const CTree&a,const CTree&b){\n\t\tif(b->ls==nullptr)return a->info.max<b->info.max?b->info.res:0;\n\t\tif(a->info.max<b->ls->info.max)return search(a,b->ls)+b->info.res-b->ls->info.res;\n\t\treturn search(a,b->rs);\n\t}\n\tInfo operator+(const Node&a,const Node&b){\n\t\treturn {a.info.res+search(&a,&b),std::max(a.info.max,b.info.max)};\n\t}\n\t#define lchild id->ls,l,mid\n\t#define rchild id->rs,mid+1,r\n\tvoid build(Tree&id,int l,int r){\n\t\tid=new(pptr++)Node{0,-M,nullptr,nullptr};\n\t\tif(l==r){\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tbuild(lchild);\n\t\tbuild(rchild);\n\t\t// std::cerr<<id<<\' \'<<l<<\' \'<<r<<\' \'<<id->ls<<\' \'<<id->rs<<\'\\n\';\n\t\tid->info=*(id->ls)+*(id->rs);\n\t}\n\tvoid modify(int pos,const int&x,int flag,Tree id,int l,int r){\n\t\t// std::cerr<<pos<<\' \'<<id<<\' \'<<l<<\' \'<<r<<\'\\n\';\n\t\tif(l==r){\n\t\t\tid->info.res=flag;\n\t\t\tid->info.max=x;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)/2;\n\t\tif(pos<=mid)modify(pos,x,flag,lchild);\n\t\telse modify(pos,x,flag,rchild);\n\t\t\n\t\tid->info=*(id->ls)+*(id->rs);\n\t}\n}\n\nsigned main(){\n\tusing namespace SegTree;\n\t// int n=g90,m=g90;\n\t// Tree rt;\n\t// build(rt,0,n);\n\t// // std::cerr<<rt<<\' \'<<rt->ls<<\' \'<<rt->rs<<\'\\n\';\n\t// for(;m--;){\n\t\t// int x=g90,y=g90;\n\t\t// modify(x,Frac(y,x),rt,0,n);\n\t\t// printf(""%d\\n"",rt->info.res-1);\n\t// }\n\tTree rt;\n\tint T=1;\n\tT=g90;\n\tfor(;T--;)[&]{\n\t\tint n=g90;\n\t\tclear();\n\t\tbuild(rt,0,n);\n\t\tvi p=rvec(n,1);\n\t\tfor(int x=1;x<=n;++x){\n\t\t\tmodify(x,p[x],p[x]==x,rt,0,n);\n\t\t}\n\t\tint ans=0;\n\t\t// deb(rt->info.res);\n\t\tauto op=[&](int x,int y){\n\t\t\tassert(x!=y);\n\t\t\tmodify(x,p[y],p[y]==x,rt,0,n);\n\t\t\tmodify(y,p[x],p[x]==y,rt,0,n);\n\t\t\t// std::cerr<<x<<\' \'<<y<<\' \'<<rt->info.res<<\'\\n\';\n\t\t\tans=std::max(ans,rt->info.res);\n\t\t\tmodify(x,p[x],p[x]==x,rt,0,n);\n\t\t\tmodify(y,p[y],p[y]==y,rt,0,n);\n\t\t};\n\t\t\n\t\tvi pmx(n+2),smn(n+2);\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tpmx[i]=(!pmx[i-1]||p[pmx[i-1]]<p[i]?i:pmx[i-1]);\n\t\t}\n\t\tfor(int i=n;i;--i){\n\t\t\tsmn[i]=(!smn[i+1]||p[smn[i+1]]>p[i]?i:smn[i+1]);\n\t\t}\n\t\tfor(int i=1;i<n;++i){\n\t\t\top(pmx[i],smn[i+1]);\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}();\n}']","[0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2600
While creating high loaded systems one should pay a special attention to caching This problem will be about one of the most popular caching algorithms called LRU Least Recently Used Suppose the cache may store no more than objects At the beginning of the workflow the cache is empty When some object is queried we check if it is present in the cache and move it here if it s not If there are more than objects in the cache after this the least recently used one should be removed In other words we remove the object that has the smallest time of the last query Consider there are videos being stored on the server all of the same size Cache can store no more than videos and caching algorithm described above is applied We know that any time a user enters the server he pick the video with probability The choice of the video is independent to any events before The goal of this problem is to count for each of the videos the probability it will be present in the cache after queries ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,k;\ndouble p[100],ff[100];\ndouble dp[(1<<20)+10];\nvoid gao(double pr,int i) {\n\tif (fabs(pr)<=1e-9) {\n\t\tputs(""0"");\n\t\treturn;\n\t}\n\tdp[0]=pr;\n\trep(i,0,n) ff[i]=0; ff[0]=pr;\n\trep(S,1,(1<<n)) if ((S&(1<<i))==0){\n\t\tdp[S]=0;\n\t\tdouble prob=1;\n\t\trep(j,0,n) if ((S&(1<<j))!=0){\n\t\t\tprob-=p[j];\n\t\t\tdp[S]+=dp[S^(1<<j)]*p[j];\n\t\t}\n\t\tdp[S]/=prob;\n\t\tff[__builtin_popcount(S)]+=dp[S];\n\t}\n\tdouble v=0;\n\trep(i,0,k) v+=ff[i];\n\tprintf(""%.10f\\n"",v);\n}\nint main() {\n\tscanf(""%d%d"",&n,&k);\n\trep(i,0,n) scanf(""%lf"",p+i);\n\trep(i,0,n) {\n\t\tgao(p[i],i);\n\t}\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2400
Summer is coming It s time for Iahub and Iahubina to work out as they both want to look hot at the beach The gym where they go is a matrix with lines and columns Let number represents the calories burned by performing workout at the cell of gym in the th line and the th column Iahub starts with workout located at line and column He needs to finish with workout After finishing workout he can go to workout or Similarly Iahubina starts with workout and she needs to finish with workout After finishing workout from cell she goes to either or There is one additional condition for their training They have to meet in exactly one cell of gym At that cell none of them will work out They will talk about fast exponentiation pretty odd small talk and then both of them will move to the next workout If a workout was done by either Iahub or Iahubina it counts as total gain Please plan a workout for Iahub and Iahubina such as total gain to be as big as possible Note that Iahub and Iahubina can perform workouts with different speed so the number of cells that they use to reach meet cell may differs ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n#define next NEXTHUI\n#define prev PREVHUI\n#define y1 Y1HUI\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint t[4][1050][1050];\nint n, m;\nint a[1050][1050];\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tscanf(""%d%d"", &n, &m);\n\tforn(i, n)\n\t\tforn(j, m)\n\t\t\tscanf(""%d"", &a[i + 1][j + 1]);\n\tseta(t, 0);\t\t\t\t\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tt[0][i][j] = max(t[0][i-1][j], t[0][i][j-1]) + a[i][j];\n\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = m; j >= 1; j--)\n\t\t\tt[1][i][j] = max(t[1][i-1][j], t[1][i][j+1]) + a[i][j];\n\n\tfor (int i = n; i >= 1; i--)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tt[2][i][j] = max(t[2][i+1][j], t[2][i][j-1]) + a[i][j];\n\n\tfor (int i = n; i >= 1; i--)\n\t\tfor (int j = m; j >= 1; j--)\n\t\t\tt[3][i][j] = max(t[3][i+1][j], t[3][i][j+1]) + a[i][j];\n\t\n\n\tint ans = 0;\n\tfor (int i = 2; i <= n-1; i++)\n\t\tfor (int j = 2; j <= m-1; j++) {\n\t\t\tans = max(ans, t[0][i-1][j] + t[3][i+1][j] + t[2][i][j-1] + t[1][i][j+1]);\n\n\t\t\tans = max(ans, t[0][i][j-1] + t[3][i][j+1] + t[2][i+1][j] + t[1][i-1][j]);\n\t\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
A superhero fights with a monster The battle consists of rounds each of which lasts exactly n minutes After a round ends the next round starts immediately This is repeated over and over again Each round has the same scenario It is described by a sequence of n numbers d 1 d 2 dots d n 10 6 le d i le 10 6 The i th element means that monster s hp hit points changes by the value d i during the i th minute of each round Formally if before the i th minute of a round the monster s hp is h then after the i th minute it changes to h h d i The monster s initial hp is H It means that before the battle the monster has H hit points Print the first minute after which the monster dies The monster dies if its hp is less than or equal to 0 Print if the battle continues infinitely ,"[""#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n\nusing namespace std;\n\nll d[200100], pr[200100];\n\nconst ll INF = 1e18;\n\nint main()\n{\n    ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n    ll H, n;\n    cin >> H >> n;\n    ll H1 = H, mx = INF;\n    vector<ll> v;\n    for(int i = 1; i <= n; ++i){\n        cin >> d[i];\n        pr[i] = pr[i-1] + d[i];\n        v.pb(pr[i]);\n        H += d[i];\n        if(H <= 0){\n            cout << i;\n            return 0;\n        }\n        mx = min(mx, pr[i]);\n    }\n\n    if(pr[n] < 0){\n        H = H1 + mx;\n        ll ans = ceil((1.0*H / abs(pr[n])));\n        H = H1;\n        H += ans * pr[n];\n        ans *= n;\n        for(int i = 1; i <= n; ++i){\n            ans++;\n            H += d[i];\n            if(H <= 0){\n                break;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    else{\n        cout << -1;\n    }\n\n    return 0;\n}\n""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
The leader of some very secretive organization has decided to invite all other members to a meeting All members of the organization live in the same town which can be represented as n crossroads connected by m two directional streets The meeting will be held in the leader s house near the crossroad 1 There are k members of the organization invited to the meeting i th of them lives near the crossroad a i All members of the organization receive the message about the meeting at the same moment and start moving to the location where the meeting is held In the beginning of each minute each person is located at some crossroad He or she can either wait a minute at this crossroad or spend a minute to walk from the current crossroad along some street to another crossroad obviously it is possible to start walking along the street only if it begins or ends at the current crossroad In the beginning of the first minute each person is at the crossroad where he or she lives As soon as a person reaches the crossroad number 1 he or she immediately comes to the leader s house and attends the meeting Obviously the leader wants all other members of the organization to come up as early as possible But since the organization is very secretive the leader does not want to attract much attention Let s denote the of the leader as follows initially the discontent is 0 whenever a person reaches the crossroad number 1 the discontent of the leader increases by c cdot x where c is some fixed constant and x is the number of minutes it took the person to reach the crossroad number 1 whenever x members of the organization walk dx 2 is added to the discontent where d is some fixed constant This is not cumulative for example if two persons are walking along the same street in the same direction at the same moment then 4d is added to the discontent not 5d Before sending a message about the meeting the leader can tell each member of the organization which path they should choose and where they should wait Help the leader to establish a plan for every member of the organization so they all reach the crossroad 1 and the discontent is minimized ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int mag=150;\n\nstruct MinCost {\n\tstruct kra {\n\t\tint cel, *prze1, *prze2;\n\t\tll koszt;\n\t};\n\tint n=0, zr, uj;\n\tconst ll inf=1e9;\n\tvector <vector <kra>> graf;\n\tvector <int> bylo, aktu;\n\tvector <ll> odl, pamodl;\n\tvoid vert(int v) {\n\t\tif (v>n) {\n\t\t\tn=v;\n\t\t\tgraf.resize(n);\n\t\t\tbylo.resize(n);\n\t\t\taktu.resize(n);\n\t\t\todl.resize(n);\n\t\t\tpamodl.resize(n);\n\t\t}\n\t}\n\tvoid add_edge(int v, int u, int prze, ll koszt) {\n\t\tvert(v+1); vert(u+1);\n\t\tkra ret1{u, new int(prze), new int(0), koszt};\n\t\tkra ret2{v, ret1.prze2, ret1.prze1, -koszt};\n\t\tgraf[v].push_back(ret1);\n\t\tgraf[u].push_back(ret2);\n\t}\n\tvoid spfa() {\n\t\tfor (int i=0; i<n; i++) {\n\t\t\taktu[i]=1;\n\t\t\tpamodl[i]=inf;\n\t\t}\n\t\taktu[zr]=pamodl[zr]=0;\n\t\tqueue <int> kol;\n\t\tkol.push(zr);\n\t\twhile(!kol.empty()) {\n\t\t\tint v=kol.front();\n\t\t\tkol.pop();\n\t\t\tif (aktu[v])\n\t\t\t\tcontinue;\n\t\t\taktu[v]=1;\n\t\t\tfor (kra i : graf[v]) {\n\t\t\t\tif (*i.prze1 && pamodl[v]+i.koszt<pamodl[i.cel]) {\n\t\t\t\t\tpamodl[i.cel]=pamodl[v]+i.koszt;\n\t\t\t\t\taktu[i.cel]=0;\n\t\t\t\t\tkol.push(i.cel);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid dij() {\n\t\tfor (int i=0; i<n; i++)\n\t\t\todl[i]=inf;\n\t\tpriority_queue < pair <ll,int> > dijks;\n\t\tdijks.push({0, zr});\n\t\twhile(!dijks.empty()) {\n\t\t\tll dis=-dijks.top().first;\n\t\t\tint v=dijks.top().second;\n\t\t\tdijks.pop();\n\t\t\tif (odl[v]!=inf)\n\t\t\t\tcontinue;\n\t\t\todl[v]=pamodl[v]+dis;\n\t\t\tfor (auto j : graf[v])\n\t\t\t\tif ((*j.prze1) && odl[j.cel]==inf)\n\t\t\t\t\tdijks.push({-(dis+pamodl[v]-pamodl[j.cel]+j.koszt), j.cel});\n\t\t}\n\t}\n\tint dfs(int v) {\n\t\tif (v==uj)\n\t\t\treturn 1;\n\t\tbylo[v]=1;\n\t\tfor (int i=0; i<(int)graf[v].size(); i++) {\n\t\t\tif (!bylo[graf[v][i].cel] && (*graf[v][i].prze1) &&\n\t\t\todl[v]+graf[v][i].koszt==odl[graf[v][i].cel] && dfs(graf[v][i].cel)) {\n\t\t\t\t(*graf[v][i].prze1)--;\n\t\t\t\t(*graf[v][i].prze2)++;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpair <int,ll> flow(int zrzr, int ujuj) {\n\t\tzr=zrzr; uj=ujuj;\n\t\tvert(zr+1); vert(uj+1);\n\t\t//~ spfa();\n\t\tpair <int,ll> ret{0, 0};\n\t\twhile(1) {\n\t\t\t//~ dij();\n\t\t\tspfa();\n\t\t\todl=pamodl;\n\t\t\tfor (int i=0; i<n; i++)\n\t\t\t\tbylo[i]=0;\n\t\t\tif (!dfs(zr))\n\t\t\t\tbreak;\n\t\t\tret.first++;\n\t\t\tret.second+=odl[uj];\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n\nint n, m, k, c, d;\n\nint main()\n{\n\tscanf(""%d%d%d%d%d"", &n, &m, &k, &c, &d);\n\tMinCost janusz;\n\tint zr=mag*n+1;\n\tfor (int i=0; i<mag; i++)\n\t\tjanusz.add_edge(i*n+1, 0, k, 0);\n\tfor (int i=0; i+1<mag; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tjanusz.add_edge(i*n+j, (i+1)*n+j, k, c);\n\tfor (int i=1; i<=k; i++)\n\t{\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tjanusz.add_edge(zr, x, 1, 0);\n\t}\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tfor (int h=0; h<2; h++)\n\t\t{\n\t\t\tfor (int j=0; j+1<mag; j++)\n\t\t\t\tfor (int l=1; l<=k; l++)\n\t\t\t\t\tjanusz.add_edge(j*n+a, (j+1)*n+b, 1, (2*l-1)*d+c);\n\t\t\tswap(a, b);\n\t\t}\n\t}\n\tauto wez=janusz.flow(zr, 0);\n\tassert(wez.first==k);\n\tprintf(""%lld\\n"", wez.second);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
You are given a permutation p of n integers 1 2 n a permutation is an array where each element from 1 to n occurs exactly once Let s call some subsegment p l r of this permutation special if p l p r max limits i l r p i Please calculate the number of special subsegments ,"['//#pragma comment(linker, ""/stack:200000000"")\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC optimize(""unroll-loops"")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    int a[n], pos[n + 1];\n    rep(i, 0, n) {\n        cin >> a[i];\n        pos[a[i]] = i;\n    }\n    int pr[n], ne[n];\n    vector<pair<int, int> > st;\n    st.push_back({inf, -1});\n    rep(i, 0, n) {\n        while (a[i] >= st.back().fi) {\n            st.pop_back();\n        }\n        pr[i] = st.back().se + 1;\n        st.push_back({a[i], i});\n    }\n    st.clear();\n    st.push_back({inf, n});\n    repb(i, n - 1, -1) {\n        while (a[i] >= st.back().fi) {\n            st.pop_back();\n        }\n        ne[i] = st.back().se - 1;\n        st.push_back({a[i], i});\n    }\n    int ans = 0;\n    rep(i, 0, n) {\n        if (i - pr[i] < ne[i] - i) {\n            rep(j, pr[i], i + 1) {\n                int need = a[i] - a[j];\n                if (need >= 1 && need <= n && pos[need] >= i && pos[need] <= ne[i]) {\n                    ans++;\n                }\n            }\n        } else {\n            rep(j, i, ne[i] + 1) {\n                int need = a[i] - a[j];\n                if (need >= 1 && need <= n && pos[need] >= pr[i] && pos[need] <= i) {\n                    ans++;\n                }\n            }\n        }\n    }\n    cout << ans << ""\\n"";\n    return 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]",2200
You are given an integer that consists of digits You are also given a sequence of digits of length The digit in position of sequence means that you can choose an arbitrary position in and replace the digit in the chosen position with Each element in the sequence can participate in no more than one replacing operation Your task is to perform such sequence of replacements that the given number gets maximum value You are allowed to use not all elements from ,"['#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define For(i,l,r) for(int i=l;i<=r;++i)\n#define Cor(i,l,r) for(int i=l;i>=r;--i)\n#define MaxN 200030\n#define Fill(a,b) memset(a,b,sizeof(a))\n#define PII pair<long long,long long>\n#define MP(x,y) make_pair(x,y)\n#define FI first\n#define SE second\nchar a[100020],b[100020];\nint main(){\n    scanf(""%s"",a);scanf(""%s"",b);\n    int n(strlen(a)),m(strlen(b));\n    sort(b,b+m);int j=m-1;;\n    For(i,0,n-1)if(b[j]>a[i]){a[i]=b[j];--j;if(j<0)break;}\n    For(i,0,n-1)printf(""%d"",a[i]-48);cout<<endl;\n    //system(""pause"");\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
To monitor cryptocurrency exchange rates trader William invented a wonderful device consisting of n lights arranged in a row The device functions in the following way Initially all lights on William s device are turned off At the beginning of a new iteration the device randomly with a uniform distribution picks a light that is turned off and turns it on telling William which cryptocurrency he should invest in After this iteration if any k consecutive lights contain more than one turned on light then the device finishes working William doesn t like uncertainty so he wants you to calculate the expected value of the number of lights that are turned on in the device after it finishes working ,"['/**\n *    author:  tourist\n *    created: 30.05.2021 17:47:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    Mint ans = 1;\n    for (int x = 1; n - (k - 1) * (x - 1) >= x; x++) {\n      ans += C(n - (k - 1) * (x - 1), x) / C(n, x);\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2600
Today as a friendship gift Bakry gave Badawy n integers a 1 a 2 dots a n and challenged him to choose an integer X such that the value underset 1 leq i leq n max a i oplus X is minimum possible where oplus denotes the bitwise XOR operation As always Badawy is too lazy so you decided to help him and find the minimum possible value of underset 1 leq i leq n max a i oplus X ,"['#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nconst int maxn = 100100, lg = 30;\nint to[maxn * lg][2], nds = 1;\nvoid insert(int x){\n\tint cur = 0;\n\tfor(int i = lg - 1; i >= 0; i--){\n\t\tint & v = to[cur][(x>>i)&1];\n\t\tif(v == 0) v = nds++;\n\t\tcur = v;\n\t}\n}\nint get(int r, int b){\n\tif(to[r][0] == 0 && to[r][1] == 0) return 0;\n\tif(to[r][0] == 0) return get(to[r][1], b - 1);\n\tif(to[r][1] == 0) return get(to[r][0], b - 1);\n\treturn min(get(to[r][0], b - 1), get(to[r][1], b - 1)) + (1<<b);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint x; cin >> x;\n\t\tinsert(x);\n\t}\n\tcout << get(0, 29) << endl;\n\treturn 0;\n}\n']","[1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0]",1900
In this task you need to process a set of stock exchange orders and use them to create An is an instruction of some participant to buy or sell stocks on stock exchange The order number has price direction buy or sell and integer This means that the participant is ready to buy or sell stocks at price for one stock A value is also known as a of an order All orders with the same price and direction are merged into one order with price and direction The volume of such order is a sum of volumes of the initial orders An order book is a list of aggregated orders the first part of which contains sell orders sorted by price in descending order the second contains buy orders also sorted by price in descending order An order book of depth contains best aggregated orders for each direction A buy order is better if it has higher price and a sell order is better if it has lower price If there are less than aggregated orders for some direction then all of them will be in the final order book You are given stock exhange orders Your task is to print order book of depth for these orders ,"['#include <iostream>\nusing namespace std;\ntypedef pair<int, int> pii;\n#include <queue>\npriority_queue<pii, vector<pii>, greater<pii> > sell;\npriority_queue<pii> buy;\nint n, s;\nchar bors;\npii sellbook[50];\npii buybook[50];\nint sellcount=-1;\nint buycount=-1;\nint main()\n{\n    cin >> n >> s;\n    int p, q;\n    for (int i=0; i<n; i++)\n        {\n            cin >> bors;\n            cin >> p >> q;\n            if (bors==\'B\') buy.push(pii (p, q));\n            else\n                sell.push(pii (p, q));\n        }\n    if (!sell.empty())\n    {\n        sellcount++;\n        sellbook[sellcount]=sell.top();\n        sell.pop();\n        while(!sell.empty())\n        {\n            if (sellbook[sellcount].first==sell.top().first)\n            {\n                sellbook[sellcount].second+=sell.top().second;\n                sell.pop();\n            }\n            else if (sellcount+1<s)\n            {\n                sellcount++;\n                sellbook[sellcount]=sell.top();\n                sell.pop();\n\n            }\n            else\n                break;\n        }\n    }\n    if (!buy.empty())\n    {\n        buycount++;\n        buybook[buycount]=buy.top();\n        buy.pop();\n        while(!buy.empty())\n        {\n            if (buybook[buycount].first==buy.top().first)\n            {\n                buybook[buycount].second+=buy.top().second;\n                buy.pop();\n            }\n            else if (buycount+1<s)\n            {\n                buycount++;\n                buybook[buycount]=buy.top();\n                buy.pop();\n\n            }\n            else\n                break;\n        }\n    }\n    for (int i=sellcount; i>=0; i--)\n    {\n        cout << ""S"" << "" "" << sellbook[i].first << "" "" << sellbook[i].second << endl;\n    }\n    for (int i=0; i<=buycount; i++)\n    {\n        cout << ""B"" << "" "" << buybook[i].first << "" "" << buybook[i].second << endl;\n    }\n}\n']","[1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
After seeing the ALL YOUR BASE ARE BELONG TO US meme for the first time numbers and realised that they have different bases which complicated their relations You re given a number represented in base and a number represented in base Compare those two numbers ,"[""#include <iostream>\n\nusing namespace std;\n\nint n, k;\nint a[100];\n\nlong long calc() {\n    long long x = 0;\n    for (int i = 0; i < n; i++) {\n        x = x * k + a[i];\n    }\n    return x;\n}\nint main() {\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    long long x = calc();\n    cin >> n >> k;\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    long long y = calc();\n    if (x == y) {\n        cout << '=' << endl;\n    } else if (x < y) {\n        cout << '<' << endl;\n    } else {\n        cout << '>' << endl;\n    }\n    return 0;\n}\n""]","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Once analyzed a sequence a 1 a 2 ldots a n consisting of n non negative integers as follows He considered each non empty of the sequence a computed the bitwise XOR of its elements and added up all the XORs obtaining the of the sequence a A sequence c is a of a sequence d if c can be obtained from d by deletion of several possibly zero or all elements For example 1 2 3 4 2 4 and 2 are subsequences of 1 2 3 4 but 4 3 and 0 are not was very proud of his analysis but now he lost the sequence a and also the coziness value However remembers the value of bitwise OR on m contiguous subsegments of the sequence a It turns out that each element of the original sequence is contained in of these m segments asks you to help find the coziness of the sequence a using the information he remembers If several coziness values are possible print any As the result can be very large print the value modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1e9 + 7; int T , N , M;\n\nint main(){\n    ios::sync_with_stdio(0);\n\tfor(cin >> T ; T ; --T){\n\t\tcin >> N >> M; int v = 0; for(int j = 1 ; j <= M ; ++j){int x; cin >> x >> x >> x; v |= x;}\n\t\tint pw2 = 1; for(int j = 1 ; j < N ; ++j) pw2 = 2ll * pw2 % P;\n\t\tint sum = 0; for(int j = 0 ; j < 30 ; ++j) if(v >> j & 1) sum = (sum + (1ll << j) * pw2) % P;\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0]",1500
You are given a 1 by n pixel image The i th pixel of the image has color a i For each color the number of pixels of that color is 20 You can perform the following operation which works like the bucket tool in paint programs on this image pick a color an integer from 1 to n choose a pixel in the image for all pixels connected to the selected pixel change their colors to the selected color two pixels of the same color are considered connected if all the pixels between them have the same color as those two pixels Compute the minimum number of operations needed to make all the pixels in the image have the same color ,"[""/**\n *    author:  tourist\n *    created: 18.09.2021 18:35:24       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      --a[i];\n    }\n    vector<vector<int>> at(n);\n    for (int i = 0; i < n; i++) {\n      at[a[i]].push_back(i);\n    }\n    vector<vector<int>> dp(n, vector<int>(n));\n    for (int i = n - 1; i >= 0; i--) {\n      for (int j = i; j < n; j++) {\n        dp[i][j] = (i == j ? 1 : dp[i + 1][j] + 1);\n        for (int k : at[a[i]]) {\n          if (k > i && k <= j) {\n            int cur = (i + 1 <= k - 1 ? dp[i + 1][k - 1] : 0);\n            cur += dp[k][j];\n            dp[i][j] = min(dp[i][j], cur);\n          }\n        }\n      }\n    }\n    cout << dp[0][n - 1] - 1 << '\\n';\n  }\n  return 0;\n}\n""]","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
You have an array containing distinct integers from to Your task is to sort this array in increasing order with the following operation you may need to apply it multiple times choose two indexes and is a prime number swap the elements on positions and in other words you are allowed to apply the following sequence of assignments is a temporary variable You do not need to minimize the number of used operations However you need to make sure that there are at most operations ,"['#include <iostream>\n#include <fstream>\n#include <vector>\n\nusing namespace std;\n\nint a, b, c;\nint m[100001];\nint n[100001];\nint nom[100001];\nbool f[1000000];\nint pos[100001];\nvector<int> v;\nvector<pair<int, int> > ans;\n\nvoid swap_(int a, int b){\n    //cout << pos[a] << ""\\n"";\n    //cout << a << \' \' << b << ""\\n"";\n    if(a == b) return;\n    int l = 0; \n    int r = v.size();\n    while(l < r - 1){\n\tint cen = (l + r) / 2;\n\tif(v[cen] > (b - a + 1)) r = cen;\n\telse l = cen;\n    }\n    ans.push_back(make_pair(b - v[l] + 1, b));\n    //cout << "" << "" << b - v[l] + 1 << \' \' << b << ""\\n"";\n    swap(pos[m[b - v[l] + 1]], pos[a]);\n    swap(m[b - v[l] + 1], m[b]);\n    b -= v[l] - 1;\n    int tmp;\n   //cin >> tmp;\n    swap_(a, b);\n}\n\nint main(){\n    cin >> a;\n    f[0] = 1;\n    f[1] = 1;\n    for(int i = 2; i <= a; ++i){\n      if(f[i] == 0){\n\tv.push_back(i);\n\tfor(int q = i; q <= 100000; q += i)\n\t  f[q] = 1;\n      }\n    }\n    //for(int i = 0; i < v.size(); ++i)\n   //   cout << i << \' \' << v[i] << ""\\n"";\n    for(int i = 1; i <= a; ++i){\n      cin >> m[i];\n      pos[m[i]] = i;\n    }\n    for(int i = 1; i <= a; ++i)\n      swap_(i, pos[i]);\n    cout << ans.size() << ""\\n"";\n    for(int i = 0; i < ans.size(); ++i)\n      cout << ans[i].first << \' \' << ans[i].second << ""\\n"";\n  \n    return 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
You are given k sequences of integers The length of the i th sequence equals to n i You have to choose exactly two sequences i and j i ne j such that you can remove exactly one element in each of them in such a way that the sum of the changed sequence i its length will be equal to n i 1 equals to the sum of the changed sequence j its length will be equal to n j 1 Note that it s to remove exactly one element in each of the two chosen sequences Assume that the sum of the empty of the length equals 0 sequence is 0 ,"['/// In The Name Of God\n\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = (l); i <= (r); i++)\n#define per(i, l, r) for (int i = (l); i >= (r); i--)\n\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl \'\\n\'\n#define ioi exit(0);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nconst int N = (int)2e5 + 7;\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nusing namespace std;\n\nint k;\nint sum[N];\nvector <int> a[N];\nmap <int, pair <int, int> > var;\n\nvoid bye(int x, int y) {\n\tint need = sum[x] - a[x][y];\n\tcout << ""YES\\n"";\n\tcout << var[need].f + 1 << \' \' << var[need].s + 1 << nl;\n\tcout << x + 1 << \' \' << y + 1;\n\tioi\n}\nint main() {\n\t#ifdef IOI2018\n\t\tfreopen (""in.txt"", ""r"", stdin);\n\t#endif\n\tKazakhstan\n\tcin >> k;\n\t--k;\n\trep(i, 0, k) {\n\t\tint n;\n\t\tcin >> n;\n\t\ta[i].resize(n);\n\t\t--n;\n\t\trep(j, 0, n) {\n\t\t\tcin >> a[i][j];\n\t\t\tsum[i] += a[i][j];\n\t\t}\n\t\trep(j, 0, n) {\n\t\t\tif (var.count(sum[i] - a[i][j])) bye(i, j);\n\t\t}\n\t\trep(j, 0, n) {\n\t\t\tvar[sum[i] - a[i][j]] = {i, j};\n\t\t}\n\t}\n\tcout << ""NO"";\n\tioi\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
You are given two binary strings a and b both of length n You can do the following operation any number of times possibly zero Select two indices l and r l r Change a l to 1 a l and a r to 1 a r If l 1 r the cost of the operation is x Otherwise the cost is y You have to find the minimum cost needed to make a equal to b or say there is no way to do so ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint T;\n\nint n,m;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>T;\n\twhile(T--)\n\t{\n\t\tint n,x,y;\n\t\tcin>>n>>x>>y;\n\t\tstring s,t;\n\t\tvector<int>v;\n\t\tcin>>s>>t;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(s[i]!=t[i])\n\t\t\t\tv.push_back(i);\n\t\tif(v.size()&1)\n\t\t{\n\t\t\tcout<<""-1\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tlong long ans=0;\n\t\tif(v.size()>2||v.size()==0||(v[0]+1!=v[1]))\n\t\t{\n\t\t\tans=v.size()/2*y;\n\t\t\tcout<<ans<<""\\n"";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans=min(2*y,x);\n\t\t\tcout<<ans<<""\\n"";\n\t\t}\n\t}\n}']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
You are given a matrix consisting of digits zero and one its size is You are allowed to rearrange its rows What is the maximum area of the submatrix that only consists of ones and can be obtained in the given problem by the described operations Let s assume that the rows of matrix are numbered from 1 to from top to bottom and the columns are numbered from 1 to from left to right A matrix cell on the intersection of the th row and the th column can be represented as Formally a submatrix of matrix is a group of four integers We will assume that the submatrix contains cells The area of the submatrix is the number of cells it contains ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int MAX_N = 5000 + 10;\nchar map[MAX_N][MAX_N];\nint rt[MAX_N][MAX_N];\nint n, m;\n\nint main() {\n\tscanf(""%d%d"", &n, &m);\n\tfor (int r = 0; r < n; ++r) {\n\t\tscanf(""%s"", map[r]);\n\t}\n\n\tfor (int r = 0; r < n; ++r) {\n\t\trt[r][m] = 0;\n\t\tfor (int c = m - 1; c >= 0; --c) {\n\t\t\trt[r][c] = map[r][c] == \'1\' ? rt[r][c + 1] + 1 : 0;\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\tfor (int c = 0; c < m; ++c) {\n\t\tstatic int a[MAX_N];\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\ta[r] = rt[r][c];\n\t\t}\n\t\tsort(a, a + n);\n\n\t\tfor (int r = 0; r < n; ++r) {\n\t\t\tans = max(ans, a[r] * (n - r));\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n']","[0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
A lot of frogs want to cross a river A river is w units width but frogs can only jump l units long where l w Frogs can also jump on lengths shorter than l but can t jump longer Hopefully there are some stones in the river to help them The stones are located at integer distances from the banks There are a i stones at the distance of i units from the bank the frogs are currently at Each stone can only be used once by one frog after that it drowns in the water What is the maximum number of frogs that can cross the river given that then can only jump on the stones ,"['#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define f first\n#define s second\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nll w, l;\n\nll a[N];\nll b[N];\n\nset <int> st;\n\nint main() {\n scanf(""%d%d"", &w, &l);\n st.insert(w);\n for (int i = 1; i < w; i++) {\n  scanf(""%d"", &a[i]);\n  if (a[i] > 0) st.insert(i);\n }\n b[0] = int(1e9);\n a[w] = int(1e9);\n for (int i = 0; i < w; i++) {\n  while (b[i] > 0) {\n   set <int>::iterator it = st.upper_bound(i + l);\n   if (it != st.begin()) {\n    it--;\n    int x = min(a[*it], b[i]);\n    b[i] -= x;\n    a[*it] -= x;\n    b[*it] += x;\n    if (!a[*it]) st.erase(it);\n   } else break;\n  }\n }\n cout << b[w];\n return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1900
Vasya has an array consisting of positive integer numbers Vasya wants to divide this array into two non empty consecutive parts the prefix and the suffix so that the sum of all elements in the first part equals to the sum of elements in the second part It is not always possible so Vasya will move some element before dividing the array Vasya will erase some element and insert it into an arbitrary position Can Vasya divide the array after choosing the right element to move and its new position ,"['#include<cstdio>\n#include<set>\ntypedef long long i64;\ni64 s[100007];\nint n,a[100007];\nstd::multiset<int>s1,s2;\nint main(){\n\tscanf(""%d"",&n);\n\tif(n==1)return puts(""NO""),0;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(""%d"",a+i);\n\t\ts[i]=a[i]+s[i-1];\n\t\ts2.insert(a[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ti64 v=s[i]*2-s[n];\n\t\tif(!v)return puts(""YES""),0;\n\t\ts1.insert(a[i]);\n\t\ts2.erase(s2.find(a[i]));\n\t\tif(v>0&&v%2==0&&v<=2000000000&&s1.find(v/2)!=s1.end())return puts(""YES""),0;\n\t\tif(v<0&&v%2==0&&v>=-2000000000&&s2.find(-v/2)!=s2.end())return puts(""YES""),0;\n\t}\n\treturn puts(""NO""),0;\n}']","[0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Igor is in the museum and he wants to see as many pictures as possible Museum can be represented as a rectangular field of cells Each cell is either empty or impassable Empty cells are marked with impassable cells are marked with Every two adjacent cells of different types one empty and one impassable are divided by a wall containing one picture At the beginning Igor is in some empty cell At every moment he can move to any empty cell that share a side with the current one For several starting positions you should calculate the maximum number of pictures that Igor can see Igor is able to see the picture only if he is in the cell adjacent to the wall with this picture Igor have a lot of time so he will examine every picture he can see ,"[""//ITNOA\n#include<bits/stdc++.h> \n\nusing namespace std;\n \n\n#define scan(x) do{while((x=getchar())<'0'); for(x-='0'; '0'<=(_=getchar()); x=(x<<3)+(x<<1)+_-'0');}while(0)\nchar _;\n\n#define int long long\n#define rep(i, s, e) for(int i = s; i < e; i ++)\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxN = 1000 + 5;\nconst int mod = 1000*1000*1000 + 7;\nconst int base = 701;\nconst int SQ = 600;\nconst int maxL = 302;\n\nchar a[maxN][maxN];\nbool mark[maxN][maxN];\nint col[maxN][maxN];\nint dx[] = {-1,1,0,0};\nint dy[] = {0,0,-1,1};\nint n,m;\n\nint ted[maxN*maxN];\n\nbool is_ok(int x, int y)\n{\n    if(x < 0 || y < 0 || n <= x || m <= y) return false;\n    return true;\n}\n\nvoid dfs(int x, int y, int c)\n{\n    mark[x][y] = 1; col[x][y] = c;\n    rep(i,0,4)\n    {\n\tint v = x + dx[i], u = y + dy[i];\n\tif(is_ok(v,u) && mark[v][u] == 0 && a[v][u] == '.')\n\t    dfs(v,u,c);\n    }    \n}\n\n\nint32_t main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    int q; cin >> n >> m >> q;\n    rep(i,0,n) rep(j,0,m)\n\tcin >> a[i][j];\n\n    int cnt = 0;\n    rep(i,1,n-1) rep(j,1,m-1)\n    {\n\tif(mark[i][j] == 0 && a[i][j] == '.')\n\t    dfs(i,j,cnt++);\n    }\n\n    rep(i,1,n-1) rep(j,1,m-1)\n\tif(a[i][j] == '.')\n\t{\n\t    rep(k,0,4)\n\t    {\n\t\tint v = i + dx[k], u = j + dy[k];\n\t\tif(is_ok(v,u) && a[v][u] == '*')\n\t\t    ted[col[i][j]] ++;\n\t    }\n\t\t\n\t}\n\n    rep(i,0,q)\n    {\n\tint x, y; cin >> x >> y; x --; y --;\n\tcout << ted[col[x][y]] << endl;\n    }\n    return 0;    \n}\n""]","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1700
You have a string s a sequence of commands for your toy robot The robot is placed in some cell of a grid He can perform four commands W move one cell up S move one cell down A move one cell left D move one cell right Let Grid s be the grid of minimum possible area such that there is a position in the grid where you can place the robot in such a way that it will not fall from the grid while running the sequence of commands s For example if s text DSAWWAW then Grid s is the 4 times 3 grid you can place the robot in the cell 3 2 the robot performs the command D and moves to 3 3 the robot performs the command S and moves to 4 3 the robot performs the command A and moves to 4 2 the robot performs the command W and moves to 3 2 the robot performs the command W and moves to 2 2 the robot performs the command A and moves to 2 1 the robot performs the command W and moves to 1 1 You have 4 extra letters one W one A one S one D You d like to insert in any position of sequence s to minimize the area of Grid s What is the minimum area of Grid s you can achieve ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\nset<pii> A,B;\nchar b[201010];\nint main(){\n\tint T;scanf(""%d"",&T);\n\twhile(T--){\n\t\tA.clear();B.clear();\n\t\tint x=0,y=0;\n\t\tscanf(""%s"",b);\n\t\tint n=strlen(b);\n\t\tA.insert({x,0});\n\t\tB.insert({y,0});\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(b[i]==\'W\')y++;\n\t\t\telse if(b[i]==\'S\')y--;\n\t\t\telse if(b[i]==\'A\')x++;\n\t\t\telse x--;\n\t\t\tA.insert({x,i+1});\n\t\t\tB.insert({y,i+1});\n\t\t}\t\t\n\t\tlong long ans=1LL*(prev(A.end())->first-A.begin()->first+1)*(prev(B.end())->first-B.begin()->first+1);\n\t\tx=0,y=0;\n\t\tint mx=0,Mx=0,my=0,My=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint a=A.begin()->first,b=prev(A.end())->first,c=B.begin()->first,d=prev(B.end())->first;\n\t\t\tans=min(ans,1LL*(max(Mx,b+1)-min(mx,a+1)+1)*(max(My,d)-min(my,c)+1));\n\t\t\tans=min(ans,1LL*(max(Mx,b-1)-min(mx,a-1)+1)*(max(My,d)-min(my,c)+1));\n\t\t\tans=min(ans,1LL*(max(Mx,b)-min(mx,a)+1)*(max(My,d+1)-min(my,c+1)+1));\n\t\t\tans=min(ans,1LL*(max(Mx,b)-min(mx,a)+1)*(max(My,d-1)-min(my,c-1)+1));\n\t\t\tA.erase({x,i});\n\t\t\tB.erase({y,i});\n\t\t\tif(::b[i]==\'W\')y++;\n\t\t\telse if(::b[i]==\'S\')y--;\n\t\t\telse if(::b[i]==\'A\')x++;\n\t\t\telse x--;\n\t\t\tMx=max(Mx,x);\n\t\t\tmx=min(mx,x);\n\t\t\tMy=max(My,y);\n\t\t\tmy=min(my,y);\n\t\t}\n\t\tprintf(""%lld\\n"",ans);\n\t}\n}\n']","[1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2100
The FB string is formed as follows Initially it is empty We go through all positive integers starting from 1 in ascending order and do the following for each integer if the current integer is divisible by 3 append to the end of the FB string if the current integer is divisible by 5 append to the end of the FB string Note that if an integer is divisible by both 3 and 5 we append and then not in the opposite order The first 10 characters of the FB string are the first comes from the integer 3 the next character comes from 5 the next comes from the integer 6 and so on It s easy to see that this string is infinitely long Let f i be the i th character of FB string so f 1 is f 2 is f 3 is f 4 is and so on You are given a string s consisting of characters and or You have to determine whether it is a substring contiguous subsequence of the FB string In other words determine if it is possible to choose two integers l and r 1 le l le r so that the string f l f l 1 f l 2 dots f r is exactly s For example is a substring of the FB string if we pick l 3 and r 5 the string f 3 f 4 f 5 is exactly is a substring of the FB string if we pick l 2 and r 9 the string f 2 f 3 f 4 dots f 9 is exactly is not a substring of the FB string ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nint n,a[2000005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\t\t\tstring t;\n\t\t\tfor(int j=1;j<=3000;j++)\n\t\t\t{\n\t\t\t\tif(j%3==0) t+=\'F\';\n\t\t\t\tif(j%5==0) t+=\'B\';\n\t\t\t}\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tstring s;\n\t\tcin >> s;\n\t\tint flag=0;\n\t\tfor(int i=0;i<=100;i++)\n\t\t{\n\t\t\tif(t.substr(i,s.size())==s)\n\t\t\t{\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag) cout << ""YES\\n"";\n\t\telse cout << ""NO\\n"";\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
There is a string consisting of capital Latin letters Let s denote its current length as During one move it is allowed to apply one of the following operations to it insert a letter in the string in the position The letter becomes the th symbol of the string at that the letters shift aside and the length of the string increases by 1 delete a character number from the string At that the letters shift together and the length of the string decreases by 1 the letter in the position of the line is replaced by At that the length of the string does not change Your task is to find in which minimal number of moves one can get a string from an string You should also find the sequence of actions leading to the required results ,"['//#pragma comment(linker,""/STACK:256000000"")\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <stdio.h>\n#include <string>\n#include <memory.h>\n\nusing namespace std;\n\n#define ldb long double\n#define LL long long\n#define nextline() {int c; while ((c = getchar()) != 10 && c != EOF);}\n\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-9\n\n#define sqr(x) ((x) * (x))\n#define ABS(a) ((a)<0?-(a):(a))\n#define EQ(a,b) (ABS((a)-(b))<EPS)\n\n#define all(a) a.begin(), a.end()\n#define two(i) (1 << (i))\n#define has(mask, i) ((((mask) & two(i)) == 0) ? false : true)\n\nconst int inf = 1000 * 1000 * 1000;\nconst LL inf64 = 1000LL * 1000LL * 1000LL * 1000LL * 1000LL * 1000LL;\n\n\n#define MAXN 1000\n\nstring a, b;\nint n, m;\nint dp[2000][2000];\nint wh[2000][2000];\n\nvoid Load()\n{\t\n\tcin >> a >> b;\n}\n\nint rec (int pos, int s)\n{\n\n\tif (s == n && pos == m)\n\t\treturn 0;\n\tif (s > n)\n\t\treturn inf;\n\n\tif (pos == m)\n\t{\n\t\tassert (n > s);\n\t\treturn n - s;\n\t}\n\tif (dp[pos][s] != -1)\n\t\treturn dp[pos][s];\n\n\tint cur = inf;\n\tint mn = inf;\n\tint w = -1;\n\n\tif (b[pos] == a[s])\n\t\tcur =  rec (pos + 1, s + 1);\n\tif (cur < mn)\n\t{\n\t\tmn = cur;\n\t\tw = 0;\n\t}\n\n\tcur = 1 + rec (pos, s + 1);\n\tif (cur < mn)\n\t{\n\t\tmn = cur;\n\t\tw = 1;\n\t}\n\n\tcur = 1 + rec (pos + 1, s + 1);\n\tif (cur < mn)\n\t{\n\t\tmn = cur;\n\t\tw = 2;\n\t}\n\tcur = 1 + rec (pos + 1, s);\n\tif (cur < mn)\n\t{\n\t\tmn = cur;\n\t\tw = 3;\n\t}\n\tdp[pos][s] = mn;\n\twh[pos][s] = w;\n\treturn mn;\n}\n\nvoid out (int pos, int s)\n{\n\tcerr << pos << "" "" << s << "" -> "" << wh[pos][s] << ""\\n"" ;\n\tif (s == n && m == pos)\n\t\treturn;\n\n\tif (pos == m)\n\t{\n\t\tfor (int i = 0; i < n - s; i++)\n\t\t\tprintf (""DELETE %d\\n"", m + 1);\n\t\treturn;\n\t}\n\tif (wh[pos][s] == 0)\n\t\tout (pos + 1, s + 1);\n\tif (wh[pos][s] == 1)\n\t{\n\t\tprintf (""DELETE %d\\n"", pos + 1);\n\t\tout (pos, s + 1);\n\t}\n\tif (wh[pos][s] == 2)\n\t{\n\t\tprintf (""REPLACE %d %c\\n"", pos + 1, b[pos]);\n\t\tout (pos + 1, s + 1);\n\t}\n\tif (wh[pos][s] == 3)\n\t{\n\t\tprintf (""INSERT %d %c\\n"" , pos + 1, b[pos]);\n\t\tout (pos + 1, s);\n\t}\n\n}\n\nvoid Solve()\n{\n\tn = a.size();\n\tm = b.size();\n\tmemset (dp, 0xFF, sizeof (dp));\n\tcout << rec (0, 0) << ""\\n"";\n\tout (0, 0);\n}\n                \nint main()\n{\n\t//ios_base::sync_with_stdio(0);\n#ifndef ONLINE_JUDGE\n\tfreopen(""in"", ""rt"", stdin);\n\tfreopen(""out"", ""wt"", stdout);\n#endif\n\n\tLoad();\n\tSolve();\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Someday Drazil wanted to go on date with Varda Drazil and Varda live on Cartesian plane Drazil s home is located in point and Varda s home is located in point In each step he can move in a unit distance in horizontal or vertical direction In other words from position he can go to positions or Unfortunately Drazil doesn t have sense of direction So he randomly chooses the direction he will go to in each step He may accidentally return back to his house during his travel Drazil may even not notice that he has arrived to and continue travelling Luckily Drazil arrived to the position successfully Drazil said to Varda It took me exactly steps to travel from my house to yours But Varda is confused about his words she is not sure that it is possible to get from to in exactly steps Can you find out if it is possible for Varda ,"['#include <stdio.h>\nint main(){\n    int x, y, n;\n    scanf(""%d%d%d"", &x, &y, &n);\n    if (x < 0) x = -x;\n    if (y < 0) y = -y;\n    if (x + y > n) {\n        printf(""No\\n"");\n    } else if ((x + y - n) % 2) {\n        printf(""No\\n"");\n    } else {\n        printf(""Yes\\n"");\n    }\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Vlad found a string s consisting of n lowercase Latin letters and he wants to make it as short as possible To do this he can remove pair of adjacent characters from s any number of times provided they are For example if s then by removing one pair of characters he can obtain the strings and but he cannot obtain because the removed letters were the same or because the removed letters were not adjacent What is the minimum length Vlad can achieve by applying any number of deletions ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<array>\n#include<set>\n#include<map>\n#include<queue>\n#include<iomanip>\n#include<numeric>\nusing namespace std;\nint cnt[26];\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n;\n\t\tstring s;\n\t\tcin >> n >> s;\n\t\tfor (int i = 0; i ^ 26; ++i)\n\t\t\tcnt[i] = 0;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\t++cnt[s[i] - 'a'];\n\t\tpriority_queue<int>q;\n\t\tfor (int i = 0; i ^ 26; ++i) {\n\t\t\tif (cnt[i])\n\t\t\t\tq.emplace(cnt[i]);\n\t\t}\n\t\tfor (; q.size() > 1;) {\n\t\t\tint u = q.top();\n\t\t\tq.pop();\n\t\t\tint v = q.top();\n\t\t\tq.pop();\n\t\t\tif (--u)\n\t\t\t\tq.emplace(u);\n\t\t\tif (--v)\n\t\t\t\tq.emplace(v);\n\t\t}\n\t\tcout << (q.size() ? q.top() : 0) << '\\n';\n\t}\n}""]","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1200
Pak Chanek has n blank heart shaped cards Card 1 is attached directly to the wall while each of the other cards is hanging onto exactly one other card by a piece of string Specifically card i i 1 is hanging onto card p i p i i In the very beginning Pak Chanek must write one integer number on each card He does this by choosing any permutation a of 1 2 dots n Then the number written on card i is a i After that Pak Chanek must do the following operation n times while maintaining a sequence s which is initially empty Choose a card x such that no other cards are hanging onto it Append the number written on card x to the end of s If x neq 1 and the number on card p x is larger than the number on card x replace the number on card p x with the number on card x Remove card x After that Pak Chanek will have a sequence s with n elements What is the maximum length of the longest non decreasing subsequence dagger of s at the end if Pak Chanek does all the steps optimally dagger A sequence b is a subsequence of a sequence c if b can be obtained from c by deletion of several possibly zero or all elements For example 3 1 is a subsequence of 3 2 1 4 3 1 and 3 1 but not 1 3 3 7 and 3 10 4 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> p(n);\n    for (int i = 1; i < n; i++) {\n        std::cin >> p[i];\n        p[i]--;\n    }\n    p[0] = -1;\n    \n    std::vector<int> h(n, 1), dp(n);\n    for (int i = n - 1; i >= 0; i--) {\n        dp[i] = std::max(dp[i], h[i]);\n        if (i) {\n            dp[p[i]] += dp[i];\n            h[p[i]] = std::max(h[p[i]], h[i] + 1);\n        }\n    }\n    \n    std::cout << dp[0] << ""\\n"";\n    \n    return 0;\n}\n']","[1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1800
The prime factorization of a positive integer m is the unique way to write it as displaystyle m p 1 e 1 cdot p 2 e 2 cdot ldots cdot p k e k where p 1 p 2 ldots p k are prime numbers p 1 p 2 ldots p k and e 1 e 2 ldots e k are positive integers For each positive integer m f m is defined as the multiset of all numbers in its prime factorization that is f m p 1 e 1 p 2 e 2 ldots p k e k For example f 24 2 3 3 1 f 5 1 5 and f 1 You are given a list consisting of 2n integers a 1 a 2 ldots a 2n Count how many positive integers m satisfy that f m a 1 a 2 ldots a 2n Since this value may be large print it modulo 998 244 353 ,"[""#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 998244353; \n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_P = 1e6 + 5;\n\nModint fact [MAX_P];\nModint ifact [MAX_P];\nint sieve [MAX_P];\n\nconst int MAX_N = 2022 * 2 + 5;\n\nModint dp [MAX_N][MAX_N];\n\nint main () {\n  fact[0] = 1;\n  ifact[0] = 1;\n  for (int i = 1; i < MAX_P; i++) {\n    fact[i] = fact[i - 1] * i;\n    ifact[i] = inv(fact[i]);\n  }\n\n  sieve[0] = 1;\n  sieve[1] = 1;\n  for (int i = 2; i < MAX_P; i++) {\n    if (!sieve[i]) {\n      for (int j = 2 * i; j < MAX_P; j += i) {\n        sieve[j] = 1;\n      }\n    }\n  }\n  \n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n;\n  cin >> n;\n\n  vector<int> arr (2 * n);\n  for (int i = 0; i < 2 * n; i++) {\n    cin >> arr[i];\n  }\n\n  sort(arr.begin(), arr.end());\n\n  vector<pair<int, int>> grp;\n  for (int u : arr) {\n    if (grp.empty() || grp.back().first != u) {\n      grp.emplace_back(u, 0);\n    }\n    grp.back().second++;\n  }\n\n  int m = grp.size();\n\n  dp[0][0] = 1;\n  for (int i = 0; i < m; i++) {\n    for (int j = 0; j <= n; j++) {\n      if (!sieve[grp[i].first]) {\n        dp[i + 1][j + 1] += dp[i][j] * ifact[grp[i].second - 1];\n      }\n      \n      dp[i + 1][j] += dp[i][j] * ifact[grp[i].second];\n    }\n  }\n\n  cout << dp[m][n] * fact[n] << '\\n';\n}""]","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0]",1900
 Polycarp has to write a coursework The coursework consists of m pages Polycarp also has n cups of coffee The coffee in the i th cup Polycarp has a i caffeine in it Polycarp can drink some cups of coffee each one no more than once He can drink cups in Polycarp drinks each cup and i e he cannot split any cup into several days Surely courseworks are not being written in a single day in a perfect world of Berland at least Let s consider some day of Polycarp s work Consider Polycarp drinks k cups of coffee during this day and caffeine dosages of cups Polycarp drink during this day are a i 1 a i 2 dots a i k Then the first cup he drinks gives him energy to write a i 1 pages of coursework the second cup gives him energy to write max 0 a i 2 1 pages the third cup gives him energy to write max 0 a i 3 2 pages the k th cup gives him energy to write max 0 a i k k 1 pages If Polycarp doesn t drink coffee during some day he cannot write coursework at all that day Polycarp has to finish his coursework as soon as possible spend the minimum number of days to do it Your task is to find out this number of days or say that it is impossible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds;   \n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update> \n#define ll long long int\n#define ld double\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define all(a) a.begin(),a.end()\n#define sz(a) (ll)(a.size())\nconst ll M=2e5+5;\nll a[M];\nint main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tll n,m;\n\tcin>>n>>m;\n\tll s=0;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t\ts=s+a[i];\n\t}\n\tsort(a+1,a+1+n);\n\tif(s<m)\n\t{\n\t\tcout<<""-1\\n"";\n\t\treturn 0;\n\t}\n\tll l=1,r=n,p=-1;\n\twhile(l<r)\n\t{\n\t\tll mid=(l+r)/2;\n\t\tif(mid==p)\n\t\t\tmid++;\n\t\tp=mid;\n\t\tll s=0;\n\t\tll curr=0;\n\t\tll x=0;\n\t\tfor(ll i=n;i>=1;i--)\n\t\t{\n\t\t\tif(curr==mid)\n\t\t\t{\n\t\t\t\tcurr=0;\n\t\t\t\tx++;\n\t\t\t}\n\t\t\ts=s+max(a[i]-x,(ll)0);\n\t\t\tcurr++;\n\t\t}\n\t\tif(s>=m)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tcout<<r<<""\\n"";\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
You have a string s consisting of n characters Each character is either or You can perform operations on the string Each operation consists of two steps select an integer i from 1 to the length of the string s then delete the character s i the string length gets reduced by 1 the indices of characters to the right of the deleted one also get reduced by 1 if the string s is not empty delete the maximum length prefix consisting of the same characters the indices of the remaining characters and the string length get reduced by the length of the deleted prefix Note that both steps are mandatory in each operation and their order cannot be changed For example if you have a string s the first operation can be one of the following select i 1 we ll get rightarrow rightarrow select i 2 we ll get rightarrow rightarrow select i 3 we ll get rightarrow rightarrow select i 4 we ll get rightarrow rightarrow select i 5 we ll get rightarrow rightarrow select i 6 we ll get rightarrow rightarrow You finish performing operations when the string s becomes empty What is the maximum number of operations you can perform ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nchar s[200005];\nint q[200005],n;\nint rem[200005];\nbool check(int v){\n\tint p=1;\n\tFor(i,1,*q) rem[i]=q[i]-(i<=v);\n\tFor(i,1,v-1){\n\t\tp=max(p,i);\n\t\tfor (;p<=*q&&!rem[p];++p);\n\t\tif (p>*q) return 0;\n\t\t--rem[p];\n\t}\n\treturn 1;\n}\nvoid solve(){\n\tscanf(""%d\\n%s"",&n,s+1);\n\t//n=strlen(s+1);\n\tq[0]=1; q[1]=1;\n\tFor(i,2,n)\n\t\tif (s[i]==s[i-1])\n\t\t\t++q[*q];\n\t\telse q[++*q]=1;\n\t//For(i,1,*q) cout<<q[i]<<endl;\n\tint l=1,r=*q,ans=-1;\n\twhile (l<=r){\n\t\tint mid=(l+r)/2;\n\t\tif (check(mid))\n\t\t\tans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tcout<<ans<<endl;\n}\nint main(){\n\tint T;\n\tscanf(""%d"",&T);\n\twhile (T--) solve();\n}']","[1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1700
It is a holiday season and Koala is decorating his house with cool lights He owns n lights all of which flash periodically After taking a quick glance at them Koala realizes that each of his lights can be described with two parameters a i and b i Light with parameters a i and b i will toggle on to off or off to on every a i seconds starting from the b i th second In other words it will toggle at the moments b i b i a i b i 2 cdot a i and so on You know for each light whether it s initially on or off and its corresponding parameters a i and b i Koala is wondering what is the maximum number of lights that will ever be on at the same time So you need to find that out ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1010;\nint n,a[N],b[N],f[N];\nchar s[N];\n\nint main() {\n\tscanf(""%d"",&n);\n\tscanf(""%s"",s);\n\trep(i,0,n) f[i]=s[i]-\'0\';\n\trep(i,0,n) {\n\t\tscanf(""%d%d"",a+i,b+i);\n\t}\n\tint ans=accumulate(f,f+n,0);\n\trep(i,0,100000) {\n\t\trep(j,0,n) if (i>=b[j]&&(i-b[j])%a[j]==0) f[j]^=1;\n\t\tans=max(ans,accumulate(f,f+n,0));\n\t}\n\tprintf(""%d\\n"",ans);\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300
You are given an integer n and three strings a b c each consisting of n lowercase Latin letters Let a template be a string t consisting of n lowercase and or uppercase Latin letters The string s matches the template t if the following conditions hold for all i from 1 to n if the i th letter of the template is then s i must be as t i if the i th letter of the template is then s i must be from the of t i For example if there is a letter A in the template you cannot use the letter a in the corresponding position of the string Accordingly the string doesn t match the template if the condition doesn t hold for at least one i Determine whether there exists a template t such that the strings a and b match it while the string c does not ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#include ""debug.h""  // https://github.com/Heltion/debug.h/blob/main/debug.h\n#else\n#define debug(...) (void)417\n#endif\nusing i64 = int64_t;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ti += 1) {\n    int n;\n    string a, b, c;\n    cin >> n >> a >> b >> c;\n    bool ans = false;\n    for (int i = 0; i < n; i += 1) {\n      if (a[i] == b[i] and a[i] != c[i]) { ans = true; }\n      if (a[i] != c[i] and b[i] != c[i]) { ans = true; }\n    }\n    cout << (ans ? ""YES"" : ""NO"") << ""\\n"";\n  }\n}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
Luca is in front of a row of n trees The i th tree has a i fruit and height h i He wants to choose a contiguous subarray of the array h l h l 1 dots h r such that for each i l leq i r He will collect all the fruit from each of the trees in the subarray that is he will collect a l a l 1 dots a r fruits However if he collects more than k fruits in total he will get caught What is the maximum length of a subarray Luca can choose so he doesn t get caught dagger x is by y if the ratio frac x y is an integer ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define vec vector\n#define read(x) for (auto &zu: (x)) cin >> zu;\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define print(x, sep) {for(auto &zu: (x))cout << zu << (sep);cout << ""\\n"";}\n#define len(x) (long long)((x).size())\n#define magic ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n#define sep << "" "" <<\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing str = string;\nusing pii = pair<int, int>;\nusing ld = long double;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nostream &operator <<(ostream &os, pii a){\n    return os << a.F sep a.S;\n}\n\nll inf = 1e18;\n\nvoid fa(bool ok){ cout << (ok ? ""YES"": ""NO"") << ""\\n""; }\n\nint tp(vi &a, int k, vi &weg){\n    int s = weg[a[0]];\n    int l = 0, r = 0;\n    int ans = 0;\n    while (r < len(a)){\n        if(s <= k)\n            ans = max(ans, r - l + 1);\n        if(s <= k){\n            r++;\n            if(r >= len(a))continue;\n            s += weg[a[r]];\n        }else{\n            s -= weg[a[l]];\n            l++;\n        }\n    }\n    return ans;\n}\n\nvoid solve(){\n    int n, k; cin >> n >> k;\n    vi a(n); read(a);\n    vi h(n); read(h);\n    vec <vi> seg;\n    vi cur;\n    cur.pb(0);\n    for(int i = 1; i < n; ++i){\n        if(h[i - 1] % h[i] == 0){\n            cur.pb(i);\n        }else{\n            seg.pb(cur);\n            cur.clear();\n            cur.pb(i);\n        }\n    }\n    seg.pb(cur);\n    int ans = 0;\n    for(auto &i: seg)\n        ans = max(ans, tp(i, k, a));\n    cout << ans << ""\\n"";\n}\n\nsigned main(){\n    magic;\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n    return 0;\n\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1300
You are given an integer array a 1 ldots n a 1 a 2 ldots a n Let us consider an empty deque double ended queue A deque is a data structure that supports adding elements to both the beginning and the end So if there are elements 3 4 4 currently in the deque adding an element 1 to the beginning will produce the sequence color red 1 3 4 4 and adding the same element to the end will produce 3 4 4 color red 1 The elements of the array are sequentially added to the initially empty deque starting with a 1 and finishing with a n Before adding each element to the deque you may choose whether to add it to the beginning or to the end For example if we consider an array a 3 7 5 5 one of the possible sequences of actions looks like this quad 1 add 3 to the beginning of the deque deque has a sequence color red 3 in it quad 2 add 7 to the end of the deque deque has a sequence 3 color red 7 in it quad 3 add 5 to the end of the deque deque has a sequence 3 7 color red 5 in it quad 4 add 5 to the beginning of the deque deque has a sequence color red 5 3 7 5 in it Find the minimal possible number of inversions in the deque after the whole array is processed An in sequence d is a pair of indices i j such that i j and d i d j For example the array d 5 3 7 5 has exactly two inversions 1 2 and 3 4 since d 1 5 3 d 2 and d 3 7 5 d 4 ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"")\n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 2e18+5;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nint a[200005];\nint t[800005];\nint n,m;\n\nvoid update(int x) {\n    for(;x <= m;x += x&-x) t[x]++;\n}\n\nint query(int l,int r) {\n    int ret = 0;\n    for(;r;r -= r&-r) ret += t[r];\n    for(--l;l;l -= l&-l) ret -= t[l];\n    return ret;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        vec rev;\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n            rev.pb(a[i]);\n        }\n        sort(all(rev)), rev.erase(unique(all(rev)),rev.end());\n        for(int i = 1;i <= n;i++) {\n            a[i] = lower_bound(all(rev),a[i])-rev.begin()+1;\n        }\n        m = rev.size();\n        ll ans = 0;\n        for(int i = 1;i <= n;i++) {\n            int L = query(1,a[i]-1), R = query(a[i]+1,m);\n            ans += min(L,R);\n            update(a[i]);\n        }\n        cout << ans << \'\\n\';\n        for(int i = 1;i <= m;i++) t[i] = 0;\n    }\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
You will be given a weighted directed graph of n nodes and m directed edges where the i th edge has a weight of w i 1 le i le m You need to reverse some edges of this graph so that there is at least one node in the graph from which every other node is reachable The cost of these reversals is equal to the maximum weight of all reversed edges If no edge reversal is required assume the cost to be 0 It is guaranteed that no self loop or duplicate edge exists Find the minimum cost required for completing the task If there is no solution print a single integer 1 ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=2e5+5;\nstruct union_set\n{\n\tvector<int> f;\n\tint n;\n\tunion_set() {}\n\tunion_set(int nn) :n(nn),f(nn+1)\n\t{\n\t\tiota(all(f),0);\n\t}\n\tint getf(int u) { return f[u]==u?u:f[u]=getf(f[u]); }\n\tvoid merge(int u,int v)\n\t{\n\t\tu=getf(u); v=getf(v);\n\t\tf[u]=v;\n\t}\n\tbool connected(int u,int v) { return getf(u)==getf(v); }\n};\nconst int inf=2e9;\nvector<int> e[N];\nint dfn[N],low[N],st[N],f[N],fs,tp,id;\nbool ed[N],rd[N];\nvoid tarjan(int u)\n{\n\tdfn[u]=low[u]=++id;\n\ted[u]=1; st[++tp]=u;\n\tfor (int v:e[u]) if (dfn[v])\n\t{\n\t\tif (ed[v]) low[u]=min(low[u],dfn[v]);\n\t}\n\telse tarjan(v),low[u]=min(low[u],low[v]);\n\tif (dfn[u]==low[u])\n\t{\n\t\t++fs;\n\t\tdo\n\t\t{\n\t\t\tf[st[tp]]=fs;\n\t\t\ted[st[tp]]=0;\n\t\t} while (st[tp--]!=u);\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n>>m;\n\t\tvector<tuple<int,int,int>> edges(m);\n\t\tvector<int> val={0,inf};\n\t\tfor (auto &[u,v,w]:edges) cin>>u>>v>>w,val.push_back(w);\n\t\tsort(all(val));\n\t\tint l=0,r=val.size()-1;\n\t\twhile (l<r)\n\t\t{\n\t\t\tint mid=l+r>>1;\n\t\t\tauto ck=[&](int W)\n\t\t\t{\n\t\t\t\tunion_set s(n);\n\t\t\t\tfor (auto [u,v,w]:edges) if (w<=W) s.merge(u,v);\n\t\t\t\tfor (i=1; i<=n; i++) e[i].clear();\n\t\t\t\tfor (auto [u,v,w]:edges) if (w>W) e[s.getf(u)].push_back(s.getf(v));\n\t\t\t\tfor (i=1; i<=n; i++) dfn[i]=low[i]=st[i]=f[i]=rd[i]=ed[i]=0; fs=tp=id=0;\n\t\t\t\tfor (i=1; i<=n; i++) if (!dfn[i]&&s.f[i]==i) tarjan(i);\n\t\t\t\tfor (i=1; i<=n; i++) if (s.f[i]==i) for (int v:e[i]) if (f[i]!=f[v]) rd[f[v]]=1;\n\t\t\t\treturn count(rd+1,rd+fs+1,0)==1;\n\t\t\t};\n\t\t\tif (ck(val[mid])) r=mid; else l=mid+1;\n\t\t}\n\t\tif (val[l]==inf) val[l]=-1;\n\t\tcout<<val[l]<<\'\\n\';\n\t}\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Kevin Sun is ruminating on the origin of cows while standing at the origin of the Cartesian plane He notices lines on the plane each representable by an equation of the form He also observes that no two lines are parallel and that no three lines pass through the same point For each triple such that Kevin considers the triangle formed by the three lines He calls a triangle if the circumcircle of that triangle passes through the origin Since Kevin believes that the circles of bovine life are tied directly to such triangles he wants to know the number of original triangles formed by unordered triples of distinct lines Recall that the of a triangle is the circle which passes through all the vertices of that triangle ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n\n#define _abs(x) ((x)>0?(x):-(x))\n\nll gcd(ll x, ll y){\n    return x ? gcd(y%x, x) : y;\n}\n\nint N;\nint a[2010],b[2010],c[2010];\nvector <pair <ll, ll> > v;\n\nll func(void){\n    int i,j;\n    int ans = 0;\n    \n    i = 0;\n    while(i < v.size()){\n        for(j=i;j<v.size();j++) if(v[j] != v[i]) break;\n        int d = j - i;\n        ans += d * (d - 1) / 2;\n        i = j;\n    }\n    \n    return ans;\n}\n\nint main(void){\n    int i,j;\n    \n    cin >> N;\n    REP(i,N) scanf(""%d%d%d"", &a[i], &b[i], &c[i]);\n    \n    ll ans = 0;\n    \n    int zero = 0;\n    REP(i,N) if(c[i] == 0) zero++;\n    if(zero == 2) ans += N - 2;\n    \n    REP(i,N) if(c[i] != 0){\n        v.clear();\n        ll px = a[i] * a[i] + b[i] * b[i];\n        ll qx = a[i] * c[i];\n        ll py = a[i] * a[i] + b[i] * b[i];\n        ll qy = b[i] * c[i];\n        \n        // cout << qx << ""/"" << px << \' \' << qy << ""/"" << py << endl;\n        \n        REP(j,i) if(c[j] != 0){\n            ll px2 = a[j] * a[j] + b[j] * b[j];\n            ll qx2 = a[j] * c[j];\n            ll py2 = a[j] * a[j] + b[j] * b[j];\n            ll qy2 = b[j] * c[j];\n            \n            ll rx = px * px2;\n            ll sx = qx * px2 - px * qx2;\n            \n            ll ry = py * py2;\n            ll sy = qy * py2 - py * qy2;\n            \n            ll g = gcd(_abs(sx), _abs(sy));\n            sx /= g; sy /= g;\n            if(sx < 0 || (sx == 0 && sy < 0)){\n                sx = -sx;\n                sy = -sy;\n            }\n            \n            // cout << i << \' \' << j << \' \' << sx << ""/"" << rx << \' \' << sy << ""/"" << ry << endl;\n            \n            v.push_back(make_pair(sx, sy));\n        }\n        \n        sort(v.begin(),v.end());\n        \n        ll tmp = func();\n        ans += tmp;\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2900
You are given a square matrix consisting of rows and columns We assume that the rows are numbered from to from top to bottom and the columns are numbered from to from left to right Some cells cells in total of the the matrix are filled with ones the remaining cells are filled with zeros We can apply the following operations to the matrix Swap th and th rows of the matrix Swap th and th columns of the matrix You are asked to transform the matrix into a special form using these operations In that special form all the ones must be in the cells that lie below the main diagonal Cell of the matrix which is located on the intersection of the th row and of the th column lies below the main diagonal if ,"[""#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <list>\nusing namespace std;\n\ntypedef long long ll;\nconst int BIGINT = 0x0FFFFFFF;\nconst ll BIGLL = 0x0FFFFFFFFFFFFFFFll;\nconst int MAXN = 1005;\n\n\nint n,m,x,y;\nint p[MAXN][2];\nbool ct[MAXN];\nvector< pair< int , pair<int,int> > > ans;\n\nvoid swap_and_commit(int t,int a,int b)\n{\n    if(t==1)\n    {\n        for(int i=0;i<m;i++)\n        {\n            if(p[i][0]==a) p[i][0]=b;\n            else if(p[i][0]==b) p[i][0]=a;\n        }\n        ans.push_back(make_pair(1,make_pair(a,b)));\n    }\n    else\n    {\n        for(int i=0;i<m;i++)\n        {\n            if(p[i][1]==a) p[i][1]=b;\n            else if(p[i][1]==b) p[i][1]=a;\n        }\n        ans.push_back(make_pair(2,make_pair(a,b)));\n    }\n}\n\nvoid solve(int l)\n{\n    if(l==n) return;\n    for(int i=1;i<=n;i++) ct[i]=false;\n    for(int i=0;i<m;i++)\n        if( p[i][1]>=l)\n            ct[p[i][0]]=true; \n    int freect=-1;\n    for(int i=1;i<=n;i++) if(!ct[i]) freect=i;\n    if(freect!=-1&&freect!=l)\n        swap_and_commit(1,l,freect);\n    for(int i=0;i<m;i++) \n        if(p[i][1]>l)\n        {\n            swap_and_commit(2,l,p[i][1]);\n            break;\n        }\n    solve(l+1);\n}\n\nint main()\n{\n    cin>>n; m=n-1;\n    for(int i=0;i<m;i++)\n        cin>>p[i][0]>>p[i][1];\n\n    solve(1);\n\n    cout << ans.size() << '\\n';\n    for(size_t i=0;i<ans.size();i++)\n        cout << ans[i].first << ' ' << ans[i].second.first << ' ' << ans[i].second.second << '\\n';\n    \n    return 0;\n}""]","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
You are given a binary table of size n times m This table consists of symbols 0 and 1 You can make such operation select 3 different cells that belong to one 2 times 2 square and change the symbols in these cells change 0 to 1 and 1 to 0 Your task is to make all symbols in the table equal to 0 You are allowed to make at most 3nm operations It can be proved that it is always possible ,"['#include <bits/stdc++.h>\n\ntemplate <typename T, int NDIMS> struct tensor_view {\n\tstatic_assert(NDIMS >= 0, ""NDIMS must be nonnegative"");\n\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tT* data;\n\n\ttensor_view(std::array<int, NDIMS> shape_, std::array<int, NDIMS> strides_, T* data_) : shape(shape_), strides(strides_), data(data_) {}\n\npublic:\n\ttensor_view() : shape{0}, strides{0}, data(nullptr) {}\n\nprotected:\n\tint flatten_index(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) { res += idx[i] * strides[i]; }\n\t\treturn res;\n\t}\n\tint flatten_index_checked(std::array<int, NDIMS> idx) const {\n\t\tint res = 0;\n\t\tfor (int i = 0; i < NDIMS; i++) {\n\t\t\tassert(0 <= idx[i] && idx[i] < shape[i]);\n\t\t\tres += idx[i] * strides[i];\n\t\t}\n\t\treturn res;\n\t}\n\npublic:\n\tT& operator[] (std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index(idx)];\n\t}\n\tT& at(std::array<int, NDIMS> idx) const {\n\t\treturn data[flatten_index_checked(idx)];\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> operator[] (int idx) const {\n\t\tstd::array<int, NDIMS-1> nshape; std::copy(shape.begin()+1, shape.end(), nshape.begin());\n\t\tstd::array<int, NDIMS-1> nstrides; std::copy(strides.begin()+1, strides.end(), nstrides.begin());\n\t\tT* ndata = data + (strides[0] * idx);\n\t\treturn tensor_view<T, NDIMS-1>(nshape, nstrides, ndata);\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> at(int idx) const {\n\t\tassert(0 <= idx && idx < shape[0]);\n\t\treturn operator[](idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 == D), T&> operator * () const {\n\t\treturn *data;\n\t}\n\n\ttemplate <typename U, int D> friend struct tensor_view;\n\ttemplate <typename U, int D> friend struct tensor;\n};\n\ntemplate <typename T, int NDIMS> struct tensor {\n\tstatic_assert(NDIMS >= 0, ""NDIMS must be nonnegative"");\n\nprotected:\n\tstd::array<int, NDIMS> shape;\n\tstd::array<int, NDIMS> strides;\n\tint len;\n\tT* data;\n\npublic:\n\ttensor() : shape{0}, strides{0}, len(0), data(nullptr) {}\n\n\texplicit tensor(std::array<int, NDIMS> shape_, const T& t = T()) {\n\t\tshape = shape_;\n\t\tstrides[NDIMS-1] = 1;\n\t\tfor (int i = NDIMS-1; i > 0; i--) {\n\t\t\tstrides[i-1] = strides[i] * shape[i];\n\t\t}\n\t\tlen = strides[0] * shape[0];\n\t\tdata = new T[len];\n\t\tstd::fill(data, data + len, t);\n\t}\n\n\ttensor(const tensor& o) : shape(o.shape), strides(o.strides), len(o.len), data(new T[len]) {\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tdata[i] = o.data[i];\n\t\t}\n\t}\n\n\ttensor& operator=(tensor&& o) noexcept {\n\t\tusing std::swap;\n\t\tswap(shape, o.shape);\n\t\tswap(strides, o.strides);\n\t\tswap(len, o.len);\n\t\tswap(data, o.data);\n\t\treturn *this;\n\t}\n\ttensor(tensor&& o) : tensor() {\n\t\t*this = std::move(o);\n\t}\n\ttensor& operator=(const tensor& o) {\n\t\treturn *this = tensor(o);\n\t}\n\t~tensor() { delete[] data; }\n\n\tusing view_t = tensor_view<T, NDIMS>;\n\tview_t view() {\n\t\treturn tensor_view<T, NDIMS>(shape, strides, data);\n\t}\n\toperator view_t() {\n\t\treturn view();\n\t}\n\n\tusing const_view_t = tensor_view<const T, NDIMS>;\n\tconst_view_t view() const {\n\t\treturn tensor_view<const T, NDIMS>(shape, strides, data);\n\t}\n\toperator const_view_t() const {\n\t\treturn view();\n\t}\n\n\tT& operator[] (std::array<int, NDIMS> idx) { return view()[idx]; }\n\tT& at(std::array<int, NDIMS> idx) { return view().at(idx); }\n\tconst T& operator[] (std::array<int, NDIMS> idx) const { return view()[idx]; }\n\tconst T& at(std::array<int, NDIMS> idx) const { return view().at(idx); }\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> operator[] (int idx) {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<T, NDIMS-1>> at(int idx) {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<const T, NDIMS-1>> operator[] (int idx) const {\n\t\treturn view()[idx];\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 < D), tensor_view<const T, NDIMS-1>> at(int idx) const {\n\t\treturn view().at(idx);\n\t}\n\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 == D), T&> operator * () {\n\t\treturn *view();\n\t}\n\ttemplate <int D = NDIMS>\n\tstd::enable_if_t<(0 == D), const T&> operator * () const {\n\t\treturn *view();\n\t}\n};\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N, M; cin >> N >> M;\n\t\ttensor<bool, 2> G({N, M});\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring s; cin >> s;\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tG[{i,j}] = s[j] - \'0\';\n\t\t\t}\n\t\t}\n\n\t\tvector<array<int, 6>> ops; ops.reserve(3*N*M);\n\n\t\tfor (int i = N-1; i >= 2; i--) {\n\t\t\tfor (int j = M-1; j >= 0; j--) {\n\t\t\t\tif (G[{i,j}]) {\n\t\t\t\t\tops.push_back({i,j,i-1,j,i-1,j?j-1:j+1});\n\t\t\t\t\tG[{i,j}] ^= 1;\n\t\t\t\t\tG[{i-1,j}] ^= 1;\n\t\t\t\t\tG[{i-1,j?j-1:j+1}] ^= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = M-1; j >= 2; j--) {\n\t\t\tif (G[{0,j}] && G[{1,j}]) {\n\t\t\t\tops.push_back({0,j,1,j,0,j-1});\n\t\t\t\tG[{0,j}] ^= 1;\n\t\t\t\tG[{1,j}] ^= 1;\n\t\t\t\tG[{0,j-1}] ^= 1;\n\t\t\t} else if (G[{0,j}]) {\n\t\t\t\tops.push_back({0,j,0,j-1,1,j-1});\n\t\t\t\tG[{0,j}] ^= 1;\n\t\t\t\tG[{0,j-1}] ^= 1;\n\t\t\t\tG[{1,j-1}] ^= 1;\n\t\t\t} else if (G[{1,j}]) {\n\t\t\t\tops.push_back({1,j,0,j-1,1,j-1});\n\t\t\t\tG[{1,j}] ^= 1;\n\t\t\t\tG[{0,j-1}] ^= 1;\n\t\t\t\tG[{1,j-1}] ^= 1;\n\t\t\t} else {\n\t\t\t\t// no op\n\t\t\t}\n\t\t}\n\n\t\tif (G[{0,0}] ^ G[{0,1}] ^ G[{1,0}]) {\n\t\t\tops.push_back({0,0,0,1,1,0});\n\t\t}\n\t\tif (G[{0,0}] ^ G[{0,1}] ^ G[{1,1}]) {\n\t\t\tops.push_back({0,0,0,1,1,1});\n\t\t}\n\t\tif (G[{0,0}] ^ G[{1,0}] ^ G[{1,1}]) {\n\t\t\tops.push_back({0,0,1,0,1,1});\n\t\t}\n\t\tif (G[{0,1}] ^ G[{1,0}] ^ G[{1,1}]) {\n\t\t\tops.push_back({0,1,1,0,1,1});\n\t\t}\n\n\t\tcout << ops.size() << \'\\n\';\n\t\tfor (auto o : ops) {\n\t\t\tfor (int z = 0; z < 6; z++) {\n\t\t\t\tcout << o[z]+1 << "" \\n""[z+1==6];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Igor the analyst has adopted little bunnies As we all know bunnies love carrots Thus Igor has bought a carrot to be shared between his bunnies Igor wants to treat all the bunnies equally and thus he wants to cut the carrot into pieces of equal area Formally the carrot can be viewed as an isosceles triangle with base length equal to and height equal to Igor wants to make cuts to cut the carrot into pieces He wants to make sure that all pieces have the same area Can you help Igor determine where to cut the carrot so that each piece have equal area ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\t\n\tint n;\n\tld h;\n\tcin >> n >> h;\n\tfor (int i = 1; i < n; i++) {\n\t\tld lg = 0, rg = 1.0;\n\t\tld need = ((ld)i) / ld(n);\n\t\tcout << sqrt(need) * (ld)h << endl;\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1200
Alice and Bob have a rectangular board consisting of n rows and m columns Alice and Bob play the following game They choose two integers l and r such that 1 le l le r le m and cut the board in such a way that only the part of it between column l and column r inclusive remains So all columns to the left of column l and all columns to the right of column r no longer belong to the board After cutting the board they move chips on the remaining part of the board the part from column l to column r They make alternating moves and the player which cannot make a move loses the game The first move is made by Alice the second by Bob the third by Alice and so on During their move the player must choose one of the chips from the board and move it any positive number of cells to the left so if the chip was in column i it can move to any column j i and the chips in the leftmost column cannot be chosen Alice and Bob have q pairs of numbers L i and R i For each such pair they want to determine who will be the winner of the game if l L i and r R i Note that these games should be considered independently they don t affect the state of the board for the next games and both Alice and Bob play optimally ,"['#ifdef ONLINE_JUDGE\n#pragma GCC optimize(""O3"")\n#pragma GCC target(""avx2"")\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n = scan();\n  int m = scan();\n  vector<int> a(n);\n  for (auto&& e : a) e = scan() - 1;\n  sort(ALL(a));\n  for (int q = scan(); q--;) {\n    int lo = scan() - 1;\n    int hi = scan() - 1;\n    int l = lower_bound(ALL(a), lo) - begin(a);\n    int r = upper_bound(ALL(a), hi) - begin(a);\n    int x = 0;\n    for (int i : Rep(l, r)) x ^= a[i] - lo;\n    cout << ""AB""[x == 0];\n  }\n  cout << \'\\n\';\n}\n']","[0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]",2700
Daniel is watching a football team playing a game during their training session They want to improve their passing skills during that session The game involves n players making multiple passes towards each other Unfortunately since the balls were moving too fast after the session Daniel is unable to know how many balls were involved during the game The only thing he knows is the number of passes delivered by each player during all the session Find the minimum possible amount of balls that were involved in the game ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#ifndef ONLINE_JUDGE\n#include ""debug.h""\n#else\n#define deb(...) 4\n#endif\n\nsigned main()\n{\n\tios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>v(n);\n\t\tfor(int i=0;i<n;i++) cin>>v[i];\n\t\tint sm=0;\n\t\tfor(auto x:v) sm+=x;\n\t\tif(sm==0){\n\t\t\tcout<<""0\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tint mx=*max_element(v.begin(),v.end());\n\t\tcout<<1+max(0LL,mx-sm+mx-1)<<\'\\n\';\n\t}\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
There are n students standing in a row Two coaches are forming two teams the first coach chooses the first team and the second coach chooses the second team The i th student has integer programming skill a i All programming skills are and between 1 and n inclusive Firstly the first coach will choose the student with maximum programming skill among all students not taken into any team k closest students to the left of him and k closest students to the right of him if there are less than k students to the left or to the right all of them will be chosen All students that are chosen leave the row and join the first team Secondly the second coach will make the same move but all students chosen by him join the second team Then again the first coach will make such move and so on This repeats until the row becomes empty i e the process ends when each student becomes to some team Your problem is to determine which students will be taken into the first team and which students will be taken into the second team ,"['// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar buff[BUFF], *begin = buff, *end = buff;\nchar getc() {\n  if (begin == end) {\n    begin = buff;\n    end = buff + fread(buff, 1, BUFF, stdin);\n  }\n  return begin == end ? -1 : *begin++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < \'0\' || c > \'9\') && c != \'-\'; c = getc()) {\n    assert(~c);\n  }\n  if (c == \'-\') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= \'0\' && c <= \'9\'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nint main() {\n  set<pair<int, int> > s;\n  set<int> pos;\n  int n = read(), k = read();\n  vector<int> arr(n), ans(n);\n  for (int i = 0; i < n; ++i) {\n    s.emplace(arr[i] = read(), i);\n    pos.emplace(i);\n  }\n  while (!s.empty()) {\n    static int cur = 2;\n    if (cur & 1) ++cur; else --cur;\n    int id = s.rbegin()->second;\n    auto it = pos.find(id);\n    /* get left */ {\n      if (it != pos.begin()) {\n        auto jt = it; --jt;\n        for (int i = 0; i < k; ++i) {\n          ans[*jt] = cur;\n          s.erase({arr[*jt], *jt});\n          if (jt == pos.begin()) {\n            pos.erase(jt); break;\n          }\n          auto kt = jt; --jt;\n          pos.erase(kt);\n        }\n      }\n    } /* get right */ {\n      auto jt = it; ++jt;\n      if (jt != pos.end()) {\n        for (int i = 0; i < k; ++i) {\n          ans[*jt] = cur;\n          s.erase({arr[*jt], *jt});\n          auto kt = jt; ++jt; pos.erase(kt);\n          if (jt == pos.end()) break;\n        }\n      }\n    }\n    ans[*it] = cur;\n    s.erase({arr[*it], *it});\n    pos.erase(it);\n  }\n  for (int i = 0; i < n; ++i) {\n    printf(""%d"", ans[i]);\n  }\n  return 0;\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Rudolf has an array a of n integers the elements are numbered from 1 to n In one operation he can choose an index i 2 le i le n 1 and assign a i 1 a i 1 1 a i a i 2 a i 1 a i 1 1 Rudolf can apply this operation any number of times Any index i can be used zero or more times Can he make all the elements of the array equal to zero using this operation ,"['#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n#define int long long\n#define pb push_back\n#define s second\n#define f first\n#define pf push_front\n#define inf 100000000000000000\n#define bitebi __builtin_popcountll\n#define FOR( i , n ) for( int i = 0 ; i < n ; i ++ )\n#define YES cout <<""YES\\n""\n#define NO cout << ""NO\\n""\n#define debug cout << ""Here Fine"" << endl ;\n#define pr pair < int , int >\n#define fbo find_by_order // returns iterator\n#define ook order_of_key // returns strictly less numbers than key\nusing namespace std ;\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""avx,avx2,fma"")\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst double Pi=acos(-1.0);\nconst double EPS=1E-8;\nconst int mod =  1000000007 ;\nconst int mod1 = 998244353 ;\nconst int N = 2e5 + 10 ;\nmt19937 R(time(0));\nmap < int , int > ma , ma1 ;\n\n\n\nvoid solve(){\n    int n ; cin >> n ;\n    int a[ n ] ;\n    FOR( i , n ) cin >> a[ i ] ;\n    for( int i = 0 ; i < n - 2 ; i ++ ){\n    \tif( a[ i ] >= 0 ){\n    \t\ta[ i + 1 ] = ( a[ i + 1 ] - 2 * a[ i ] ) ;\n    \t\ta[ i + 2 ] = a[ i + 2 ] - a[ i ] ;\n    \t\ta[ i ] = 0 ;\n\t\t}\n\t\telse{\n\t\t\tNO ; return ;\n\t\t}\n\t}\n\tif( a[ n - 1 ] == a[ n - 2 ] && a[ n - 1 ] == 0 ){\n\t\tYES ; \n\t} else NO ; \n}\nsigned main() {\n   ios_base::sync_with_stdio(0),cin.tie(NULL),cout.tie(NULL);\n   int t = 1 ; cin >> t ;\n   while( t -- ){\n   \t solve() ;\n   }\n\n}\n\n\n\n\n']","[1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
One day students come to the stadium They want to play football and for that they need to split into teams the teams must have an equal number of people We know that this group of people has archenemies Each student has at most two archenemies Besides if student is an archenemy to student then student is an archenemy to student The students want to split so as no two archenemies were in one team If splitting in the required manner is impossible some students will have to sit on the bench Determine the minimum number of students you will have to send to the bench in order to form the two teams in the described manner and begin the game at last ,"['#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\nint a[200][200];\nint used[200];\n\nint main()\n{\n  int i,j,k,m,n,x,y,t,tt,ans;\n  vector<int> q;\n  scanf(""%d%d"",&n,&m);\n  memset(a,0,sizeof(a));\n  for (i=0;i<m;i++)\n  {\n    scanf(""%d%d"",&x,&y);\n    x--;y--;\n    a[x][y]=1;\n    a[y][x]=1;\n  }\n  memset(used,0,sizeof(used));\n  ans=0;\n  for (i=0;i<n;i++)\n    if (used[i]==0)\n    {\n      t=1;\n      tt=0;\n      used[i]=1;\n      q.clear();\n      q.push_back(i);\n      for (j=0;j<q.size();j++)\n        for (k=0;k<n;k++)\n          if (a[q[j]][k]==1)\n          {\n            tt++;\n            if (used[k]==0)\n            {\n              used[k]=1;\n              t++;\n              q.push_back(k);\n            }\n          }\n      tt/=2;\n      if ((t==tt)&&(t%2!=0)) ans++;\n    }\n  if ((n-ans)%2!=0) ans++;\n  printf(""%d\\n"",ans);\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
A robot is placed in a cell 0 0 of an infinite grid This robot has adjustable length legs Initially its legs have length 1 Let the robot currently be in the cell x y and have legs of length m In one move it can perform one of the following three actions jump into the cell x m y jump into the cell x y m increase the length of the legs by 1 i e set it to m 1 What s the smallest number of moves robot has to make to reach a cell a b ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n\ta = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n\ta = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n\tvector<T> res;\n\tint ida = 0, idb = 0;\n\twhile (ida < a.size() || idb < b.size()) {\n\t\tif (idb == b.size()) {\n\t\t\tres.push_back(a[ida]); ida++;\n\t\t}\n\t\telse if (ida == a.size()) {\n\t\t\tres.push_back(b[idb]); idb++;\n\t\t}\n\t\telse {\n\t\t\tif (a[ida] < b[idb]) {\n\t\t\t\tres.push_back(a[ida]); ida++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.push_back(b[idb]); idb++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n\trep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << "" ""; cout << v[i];\n\t}\n\tcout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n\tif (n < 0) {\n\t\tll res = mod_pow(x, -n, m);\n\t\treturn mod_pow(res, m - 2, m);\n\t}\n\tif (abs(x) >= m)x %= m;\n\tif (x < 0)x += m;\n\t//if (x == 0)return 0;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\n//mod should be <2^31\nstruct modint {\n\tint n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) {\n\t\tif (m < 0 || mod <= m) {\n\t\t\tm %= mod; if (m < 0)m += mod;\n\t\t}\n\t\tn = m;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\ta = abs(a); b = abs(b);\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n\tif (loc >= v.size())v.resize(loc + 1, 0);\n\tv[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n\tfill(isp + 2, isp + mn, true);\n\tfor (int i = 2; i < mn; i++) {\n\t\tif (!isp[i])continue;\n\t\tps.push_back(i);\n\t\tfor (int j = 2 * i; j < mn; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\tif (res == st.begin())return st.end();\n\tres--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\treturn res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n\ta = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n\ta = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n\ta = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n\ta = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\nvoid solve() {\n\tint a, b; cin >> a >> b;\n\tint ans = mod;\n\tfor (int c = 1; c <= 200000; c++) {\n\t\tint cost = c - 1;\n\t\tcost += (a + c - 1) / c;\n\t\tcost += (b + c - 1) / c;\n\t\tchmin(ans, cost);\n\t}\n\tcout << ans << ""\\n"";\n}\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//init();\n\t//while(true)\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\t\tsolve();\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Shrimpy Duc is a fat and greedy boy who is always hungry After a while of searching for food to satisfy his never ending hunger Shrimpy Duc finds M M candies lying unguarded on a L times L grid There are n M M candies on the grid the i th M M is currently located at x i 0 5 y i 0 5 and has color c i out of a total of k colors the size of M Ms are insignificant Shrimpy Duc wants to steal a of M Ms specifically he wants to select a rectangle with coordinates within the grid and steal all candies within the rectangle Shrimpy Duc doesn t need to steal every single candy however he would like to steal In other words he wants to select a rectangle whose sides are parallel to the coordinate axes and whose left bottom vertex X 1 Y 1 and right top vertex X 2 Y 2 are points with integer coordinates satisfying 0 le X 1 X 2 le L and 0 le Y 1 Y 2 le L so that for every color 1 le c le k there is at least one M M with color c that lies within that rectangle How many such rectangles are there This number may be large so you only need to find it modulo 10 9 7 ,"['/**\n *    author:  tourist\n *    created: 30.08.2020 18:09:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nstruct Point {\n  int x;\n  int y;\n  int c;\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k, L;\n  cin >> n >> k >> L;\n  vector<Point> p(n);\n  for (int i = 0; i < n; i++) {\n    cin >> p[i].x >> p[i].y >> p[i].c;\n    --p[i].c;\n  }\n  sort(p.begin(), p.end(), [&](const Point& a, const Point& b) {\n    return a.y < b.y;\n  });\n  long long c2 = (long long) L * (L + 1) / 2;\n  auto C2 = [&](int x, int y) -> long long {\n    if (x >= y) {\n      return 0;\n    }\n    return ((long long) (y - x) * (y - x + 1)) >> 1;\n  };\n  Mint ans = 0;\n  for (int start = 0; start <= n - k; start++) {\n    int coeff = p[start].y - (start == 0 ? -1 : p[start - 1].y);\n    if (coeff == 0) {\n      continue;\n    }\n    vector<multiset<int>> s(k);\n    for (int i = 0; i < k; i++) {\n      s[i].insert(-1);\n      s[i].insert(L);\n    }\n    for (int i = start; i < n; i++) {\n      s[p[i].c].insert(p[i].x);\n    }\n    set<pair<int, int>> segs;\n    long long value = 0;\n    auto Modify = [&](set<pair<int, int>>::iterator it, int q) {\n      if (it != segs.begin()) {\n        value -= q * C2(it->first, abs(prev(it)->second));\n      }\n      if (next(it) != segs.end()) {\n        value -= q * C2(next(it)->first, abs(it->second));\n      }\n      if (it != segs.begin() && next(it) != segs.end()) {\n        value += q * C2(next(it)->first, abs(prev(it)->second));\n      }\n      value += q * C2(it->first, abs(it->second));\n    };\n    auto Erase = [&](set<pair<int, int>>::iterator it) {\n      Modify(it, -1);\n      segs.erase(it);\n    };\n    auto Add = [&](int from, int to) {\n      if (from >= to) {\n        return;\n      }\n      pair<int, int> seg = make_pair(from, -to);\n      auto it = segs.lower_bound(seg);\n      while (it != segs.end() && abs(it->second) <= to) {\n        Erase(it);\n        it = segs.lower_bound(seg);\n      }\n      if (it != segs.begin()) {\n        it = prev(it);\n        if (abs(it->second) >= to) {\n          return;\n        }\n      }\n      auto ret = segs.insert(seg);\n      assert(ret.second);\n      it = ret.first;\n      Modify(it, 1);\n    };\n    bool have_all = true;\n    for (int i = 0; i < k; i++) {\n      if (s[i].size() == 2) {\n        have_all = false;\n        break;\n      }\n      auto it = s[i].begin();\n      while (*it < L) {\n        int me = *it;\n        ++it;\n        int nxt = *it;\n        Add(me + 1, nxt);\n      }\n    }\n    if (!have_all) {\n      break;\n    }\n    for (int finish = n - 1; finish >= start; finish--) {\n      int coeff2 = (finish == n - 1 ? L : p[finish + 1].y) - p[finish].y;\n      ans += Mint(coeff) * coeff2 * (c2 - value);\n      int col = p[finish].c;\n      auto it = s[col].find(p[finish].x);\n      assert(it != s[col].end());\n      auto pr = prev(it);\n      auto nx = next(it);\n      Add((*pr) + 1, *nx);\n      s[col].erase(it);\n      if (value == c2) {\n        break;\n      }\n    }\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",3300
 Ivan plays a computer game that contains some microtransactions to make characters look cooler Since Ivan wants his character to be really cool he wants to use some of these microtransactions and he won t start playing until he gets all of them Each day during the Ivan earns exactly one burle There are n types of microtransactions in the game Each microtransaction costs 2 burles usually and 1 burle if it is on sale Ivan has to order exactly k i microtransactions of the i th type he orders microtransactions during the Ivan can order possibly zero number of microtransactions of types during any day of course If the microtransaction he wants to order is on sale then he can buy it for 1 burle and otherwise he can buy it for 2 burles There are also m special offers in the game shop The j th offer d j t j means that microtransactions of the t j th type are on sale during the d j th day Ivan wants to order all microtransactions as soon as possible Your task is to calculate the minimum day when he can buy all microtransactions he want and actually start playing ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PII pair<int,int>\n#define PB push_back\n#define POP pop_back\n#define FI first\n#define SE second\n#define endl \'\\n\'\n#define ls x<<1\n#define rs x<<1|1\nconst LL N=4e5+7,mod=998244353,INF=1e9;\nint n,m;\nint a[N],b[N];\nvector<int>v[N];\nint check(int x,int y){\n    int re=x,cnt=0;\n    int flag=0;\n    for(int i=1;i<=n;i++)b[i]=a[i];\n    for(int i=x;i>=1;i--){\n            //cout<<i<<\' \'<<re<<endl;\n        for(int j=0;j<v[i].size();j++){\n            while(b[v[i][j]]&&re){\n                re--;\n                y--;\n                b[v[i][j]]--;\n            }\n        }\n        if(re>=i)re--,flag++;\n    }\n    return flag/2>=y;\n}\nint main()\n{\n    cin>>n>>m;\n    int cnt=0;\n    for(int i=1;i<=n;i++){\n        scanf(""%d"",&a[i]);\n        cnt+=a[i];\n    }\n    int x,y;\n    for(int i=1;i<=m;i++){\n        scanf(""%d%d"",&x,&y);\n        v[x].PB(y);\n    }\n    int ans=INF;\n    int l=cnt,r=2*cnt;\n    while(l<=r){\n        int mid=l+r>>1;\n        if(check(mid,cnt)){\n            ans=min(ans,mid);\n            r=mid-1;\n        }\n        else l=mid+1;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
There are several days left before the fiftieth birthday of a famous Berland s writer Berlbury In this connection the local library decided to make an exposition of the works of this famous science fiction writer It was decided as well that it is necessary to include into the exposition only those books that were published during a particular time period It is obvious that if the books differ much in size the visitors will not like it That was why the organizers came to the opinion that the difference between the highest and the lowest books in the exposition should be not more than millimeters The library has volumes of books by Berlbury arranged in chronological order of their appearance The height of each book in millimeters is know it is As Berlbury is highly respected in the city the organizers want to include into the exposition as many books as possible and to find out what periods of his creative work they will manage to cover You are asked to help the organizers cope with this hard task ,"['#include <cstdio>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\nconst int N = 100*1001;\nint n,k,h[N],e[N];\n\nmultiset<int> s;\n\nbool ok() {\n    if (s.empty()) return true;\n    return ( (*s.rbegin())-(*s.begin()) <= k );\n}\n\nint main() {\n    scanf(""%d%d"",&n,&k);\n    for(int i=0;i<n;i++)\n        scanf(""%d"",&h[i]);\n    for(int i=0;i<n;i++) {\n        if (i==0) e[i]=0; else e[i]=e[i-1];\n        while(e[i]<n && ok()) {\n            s.insert(h[e[i]]);\n            e[i]++;\n        }\n        if (!ok()) {\n            e[i]--;\n            s.erase(s.find(h[e[i]]));\n        }\n        s.erase(s.find(h[i]));\n    }\n   // for(int i=0;i<n;i++) printf(""%d\\n"",e[i]);\n    int best = 1;\n    for(int i=0;i<n;i++) best=max(best,e[i]-i);\n    int c=0;\n    for(int i=0;i<n;i++) if (e[i]-i==best) c++;\n    printf(""%d %d\\n"",best,c);\n    for(int i=0;i<n;i++)\n        if (e[i]-i==best) printf(""%d %d\\n"",i+1,e[i]);\n    return 0;\n}\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0]",1900
There are n uniform random real variables between 0 and 1 inclusive which are denoted as x 1 x 2 ldots x n Tenzing has m conditions Each condition has the form of x i x j le 1 or x i x j ge 1 Tenzing wants to know the probability that all the conditions are satisfied modulo 998 244 353 Formally let M 998 244 353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output the integer x that 0 le x M and x cdot q equiv p pmod M ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:56:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> m0(n);\n  vector<int> m1(n);\n  for (int i = 0; i < m; i++) {\n    int x, y, w;\n    cin >> w >> x >> y;\n    --x; --y;\n    if (w == 0) {\n      m0[x] |= (1 << y);\n      m0[y] |= (1 << x);\n    } else {\n      m1[x] |= (1 << y);\n      m1[y] |= (1 << x);\n    }\n  }\n  vector<Mint> dp(1 << n);\n  dp[0] = 1;\n  for (int t = 0; t < (1 << n); t++) {\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        continue;\n      }\n      int nt = t | (1 << i);\n      int v0 = m0[i] & nt;\n      int v1 = m1[i] & nt;\n      int ways = (int) (v0 == 0) + (int) (v1 == 0);\n      dp[nt] += dp[t] * ways;\n    }\n  }\n  Mint ans = dp.back();\n  for (int i = 1; i <= n; i++) {\n    ans /= 2 * i;\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",3000
Natasha was already going to fly back to Earth when she remembered that she needs to go to the Martian store to buy Martian souvenirs for her friends It is known that the Martian year lasts x max months month lasts y max days day lasts z max seconds Natasha also knows that this store works according to the following schedule 2 months in a year were selected x l and x r 1 le x l le x r le x max 2 days in a month y l and y r 1 le y l le y r le y max and 2 seconds in a day z l and z r 1 le z l le z r le z max The store works at all such moments month x day y second z when simultaneously x l le x le x r y l le y le y r and z l le z le z r Unfortunately Natasha does not know the numbers x l x r y l y r z l z r One Martian told Natasha I went to this store n m times n times of them it was opened and m times closed He also described his every trip to the store the month day second of the trip and whether the store was open or closed at that moment Natasha can go to the store k times For each of them determine whether the store at the time of the trip is open closed or this information is unknown ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_WARNINGS\n//#include ""testlib.h""\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(""/home/alexandero/CLionProjects/ACM/input.txt"", ""r"", stdin);\n//freopen(""/home/alexandero/CLionProjects/ACM/output.txt"", ""w"", stdout);\n//freopen(""out.txt"", ""w"", stdout);\n#else\n  //freopen(""input.txt"", ""r"", stdin);\n//freopen(""output.txt"", ""w"", stdout);\n#endif\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n//cin » t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\nsolve(false);\n}\n#endif\n\n#ifdef AIM\n  cerr << ""\\n\\n time: "" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << ""\\n\\n"";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nvoid precalc() {\n\n}\n\n//#define int li\n//const li mod = 1000000007;\n\n//using ull = unsigned long long;\n\nstruct SegTree {\n  int shift;\n  vector<int> tree;\n  vector<int> xs;\n  void build() {\n    make_unique(xs);\n    shift = 1;\n    while (shift < xs.size()) {\n      shift *= 2;\n    }\n    tree.assign(2 * shift, 0);\n  }\n  int get_lower_bound(int coord) {\n    return lower_bound(all(xs), coord) - xs.begin();\n  }\n  int get_sum(int l, int r) {\n    l = get_lower_bound(l);\n    r = get_lower_bound(r);\n    l += shift;\n    r += shift;\n    int res = 0;\n    while (l < r) {\n      if (l & 1) {\n        res += tree[l++];\n        continue;\n      }\n      if (r & 1) {\n        res += tree[--r];\n        continue;\n      }\n      l /= 2;\n      r /= 2;\n    }\n    return res;\n  }\n  void update(int x, int val) {\n    int v = get_lower_bound(x);\n    assert(xs[v] == x);\n    v += shift;\n    while (v) {\n      tree[v] += val;\n      v /= 2;\n    }\n  }\n};\n\nstruct LargeTree {\n  int shift;\n  vector<SegTree> trees;\n  LargeTree(int n) {\n    shift = 1;\n    while (shift < n) {\n      shift *= 2;\n    }\n    trees.resize(2 * shift);\n  }\n  void build() {\n    for (int i = 0; i < trees.size(); ++i) {\n      trees[i].build();\n    }\n  }\n  void raw_insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].xs.push_back(y);\n      x /= 2;\n    }\n  }\n  void insert(int x, int y) {\n    x += shift;\n    while (x) {\n      trees[x].update(y, 1);\n      x /= 2;\n    }\n  }\n  int count(int lx, int rx, int ly, int ry) {\n    lx += shift;\n    rx += shift;\n    int res = 0;\n    while (lx < rx) {\n      if (lx & 1) {\n        res += trees[lx++].get_sum(ly, ry);\n        continue;\n      }\n      if (rx & 1) {\n        res += trees[--rx].get_sum(ly, ry);\n        continue;\n      }\n      lx /= 2;\n      rx /= 2;\n    }\n    return res;\n  }\n};\n\nconst int C = 100500;\n\nstruct Query {\n  int z;\n  int lx, rx;\n  int ly, ry;\n  int sign;\n  int id;\n};\n\nint pidorand() {\n  return (rand() << 16) | rand();\n}\n\n#ifndef AIM\n#define rand pidorand\n#endif\n\nvoid solve(bool read) {\n  //read = false;\n  LargeTree tree(C);\n  vector<int> borders(3);\n  for (int i = 0; i < 3; ++i) {\n    if (read) {\n      cin >> borders[i];\n    } else {\n      borders[i] = 100000;\n    }\n  }\n  int n, m, k;\n  if (read) {\n    cin >> n >> m >> k;\n  } else {\n    n = 1;\n    m = 100000;\n    k = 100000;\n  }\n  vector<int> mins(3, C), maxes(3, 0);\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < 3; ++j) {\n      int cur;\n      if (read) {\n        cin >> cur;\n      } else {\n        cur = rand() % borders[j] + 1;\n      }\n      relax_min(mins[j], cur);\n      relax_max(maxes[j], cur);\n    }\n  }\n  auto is_into = [&] (const vector<int>& cur) {\n    for (int i = 0; i < 3; ++i) {\n      if (cur[i] < mins[i] || cur[i] > maxes[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  vector<vector<vector<int>>> not_visited(C);\n  for (int i = 0; i < m; ++i) {\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n    }\n    if (is_into(cur)) {\n      cout << ""INCORRECT\\n"";\n      return;\n    }\n    not_visited[cur[2]].push_back({cur[0], cur[1]});\n    tree.raw_insert(cur[0], cur[1]);\n  }\n  tree.build();\n\n  cout << ""CORRECT\\n"";\n\n  vector<int> res(k, 0);\n  vector<bool> is_inside(k, false);\n  vector<vector<Query>> queries(C);\n  for (int i = 0; i < k; ++i) {\n    auto cur_mins = mins;\n    auto cur_maxes = maxes;\n    vector<int> cur(3);\n    for (int j = 0; j < 3; ++j) {\n      if (read) {\n        cin >> cur[j];\n      } else {\n        cur[j] = rand() % borders[j] + 1;\n      }\n      relax_min(cur_mins[j], cur[j]);\n      relax_max(cur_maxes[j], cur[j]);\n    }\n    if (is_into(cur)) {\n      is_inside[i] = true;\n      continue;\n    }\n    Query cur_q = {cur_maxes[2], cur_mins[0], cur_maxes[0] + 1, cur_mins[1], cur_maxes[1] + 1, 1, i};\n    queries[cur_q.z].push_back(cur_q);\n    cur_q.z = cur_mins[2] - 1;\n    cur_q.sign = -1;\n    if (cur_q.z >= 0) {\n      queries[cur_q.z].push_back(cur_q);\n    }\n  }\n\n  for (int z = 0; z < C; ++z) {\n    for (auto& vec : not_visited[z]) {\n      tree.insert(vec[0], vec[1]);\n    }\n    for (auto& q : queries[z]) {\n      res[q.id] += q.sign * tree.count(q.lx, q.rx, q.ly, q.ry);\n    }\n  }\n\n  for (int i = 0; i < k; ++i) {\n    if (is_inside[i]) {\n      cout << ""OPEN\\n"";\n      continue;\n    }\n    if (res[i] > 0) {\n      cout << ""CLOSED\\n"";\n      continue;\n    }\n    cout << ""UNKNOWN\\n"";\n  }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
Xenia the coder went to The Olympiad of Informatics and got a string problem Unfortunately Xenia isn t fabulous in string algorithms Help her solve the problem is a sequence of characters where record shows the length of the string of string is string String is a string if it meets the conditions the length of string is odd character occurs exactly once in the string either or substrings and are the same and are Gray strings For example strings are Gray strings and strings are not The of string is the sum of the squares of the lengths of all substrings of string that are Gray strings In other words consider all pairs of values If substring is a Gray string you should add to the beauty Xenia has got string consisting of lowercase English letters She is allowed to replace at most one letter of the string by any other English letter The task is to get a string of maximum beauty ,"['// WRONG ANSWER\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n#include <tuple>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\ntypedef pair<int, char> change;\n\nstatic char get(\n    const vector<vector<char> > &gray,\n    const vector<vector<map<change, char> > > &changes,\n    int level, int pos, change ch)\n{\n    int side = (1 << level) - 1;\n    int left = pos - side;\n    int right = pos + side;\n    if (ch.first < left || ch.first > right)\n        return gray[level][pos];\n    else\n    {\n        auto p = changes[level][pos].find(ch);\n        if (p == changes[level][pos].end())\n            return 0;\n        else\n            return p->second;\n    }\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    string str;\n    int L;\n    cin >> str;\n    L = str.size();\n    int N = 0;\n    while ((1 << (N + 1)) - 1 <= L)\n        N++;\n\n    vector<ll> value(N);\n    for (int i = 0; i < N; i++)\n    {\n        ll len = (1 << (i + 1)) - 1;\n        value[i] = len * len;\n    }\n\n    vector<vector<char> > gray(N, vector<char>(L, \'\\0\'));\n    vector<vector<map<change, char> > > changes(N, vector<map<change, char> >(L));\n    for (int i = 0; i < L; i++)\n    {\n        gray[0][i] = str[i];\n        for (int j = 0; j < 26; j++)\n            if (\'a\' + j != str[i])\n                changes[0][i].insert(make_pair(change(i, \'a\' + j), \'a\' + j));\n    }\n\n    ll score = L;\n    vector<ll> lose(L);\n    vector<vector<ll> > gain(26, vector<ll>(L));\n    for (int i = 1; i < N; i++)\n    {\n        const int side = (1 << i) - 1;\n        const int step = 1 << (i - 1);\n        for (int j = side; j < L - side; j++)\n        {\n            char left = gray[i - 1][j - step];\n            char right = gray[i - 1][j + step];\n            char mid = gray[i - 1][j];\n            gray[i][j] = (left && mid && right\n                && left == right && left != mid) ? str[j] : 0;\n            for (int jump = -step; jump <= step; jump += step)\n            {\n                for (auto cx : changes[i - 1][j + jump])\n                {\n                    const change c = cx.first;\n                    char l2 = get(gray, changes, i - 1, j - step, c);\n                    char m2 = get(gray, changes, i - 1, j, c);\n                    char r2 = get(gray, changes, i - 1, j + step, c);\n                    if (l2 && m2 && r2 && l2 == r2 && l2 != m2)\n                        changes[i][j].insert(make_pair(c, m2));\n                }\n            }\n            if (gray[i][j])\n            {\n                score += value[i];\n                for (int k = j - side; k <= j + side; k++)\n                    lose[k] += value[i];\n            }\n            for (auto cx : changes[i][j])\n                gain[cx.first.second - \'a\'][cx.first.first] += value[i];\n        }\n    }\n\n    ll ans = score;\n    for (int i = 0; i < 26; i++)\n        for (int j = 0; j < L; j++)\n        {\n            ll cur = score - lose[j] + gain[i][j];\n            ans = max(ans, cur);\n        }\n\n    cout << ans << \'\\n\';\n\n    return 0;\n}\n']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",3000
Nauuo is a girl who loves random picture websites One day she made a random picture website by herself which includes n pictures When Nauuo visits the website she sees exactly one picture The website does not display each picture with equal probability The i th picture has a non negative weight w i and the probability of the i th picture being displayed is frac w i sum j 1 nw j That is to say the probability of a picture to be displayed is proportional to its weight However Nauuo discovered that some pictures she does not like were displayed too often To solve this problem she came up with a great idea when she saw a picture she likes she would add 1 to its weight otherwise she would subtract 1 from its weight Nauuo will visit the website m times She wants to know the expected weight of each picture after all the m visits modulo 998244353 Can you help her The expected weight of the i th picture can be denoted by frac q i p i where gcd p i q i 1 you need to print an integer r i satisfying 0 le r i 998244353 and r i cdot p i equiv q i pmod 998244353 It can be proved that such r i exists and is unique ,"['#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#define maxn 300005\n#define ll long long\n#define ld double\n#define mod 998244353\n#define maxm 3005\nusing namespace std;\nint n, m; \nint a[maxn], w[maxn];\nll ksm(ll a, ll b)\n{\n\tif(!b) return 1;\n\tll ns = ksm(a, b >> 1);\n\tns = ns * ns % mod;\n\tif(b & 1) ns = ns * a % mod;\n\treturn ns;\n}\nll dp[maxm][maxm];\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tll S[2] = {0, 0};\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &w[i]), \n\t\tS[a[i]] += w[i], \n\t\tS[a[i]] %= mod;\n\tll f[2] = {S[0], S[1]};\n\tdp[1][0] = 1;\n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tll n1 = S[1] + j, n2 = S[0] - (i - 1 - j);\n\t\t\tif(!dp[i][j]) continue;\n\t\t\tll bk = ksm((n1 + n2) % mod, mod - 2);\n\t\t\tn1 = n1 * bk % mod, \n\t\t\tn2 = n2 * bk % mod;\n\t\t\tdp[i + 1][j] += n2 * dp[i][j], dp[i + 1][j] %= mod;\n\t\t\tdp[i + 1][j + 1] += n1 * dp[i][j], dp[i + 1][j + 1] %= mod;\n\t\t}\n\tfor(int j = 0; j <= m + 1; j++)\n\t\tf[1] += dp[m + 1][j] * j, f[1] %= mod, \n\t\tf[0] -= dp[m + 1][j] * (m - j), f[0] %= mod;\n\tS[0] = ksm(S[0], mod - 2);\n\tS[1] = ksm(S[1], mod - 2);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tll ns = f[a[i]] * S[a[i]] % mod * w[i] % mod;\n\t\tif(ns < 0) ns += mod;\n\t\tprintf(""%lld\\n"", ns);\n\t}\n\treturn 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
Ayoub had an array a of integers of size n and this array had two interesting properties All the integers in the array were between l and r inclusive The sum of all the elements was divisible by 3 Unfortunately Ayoub has lost his array but he remembers the size of the array n and the numbers l and r so he asked you to find the number of ways to restore the array Since the answer could be very large print it modulo 10 9 7 i e the remainder when dividing by 10 9 7 In case there are no satisfying arrays Ayoub has a wrong memory print 0 ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch=\'*\'; (ch<\'0\'||ch>\'9\')&&ch!=\'-\'; ch=getchar());\n    if(ch==\'-\') fu=1, ch=getchar();\n    for(v=0; ch>=\'0\'&&ch<=\'9\'; ch=getchar()) v=v*10+ch-\'0\';\n    if(fu) v=-v;\n}\nconst int MO=1e9+7;\nint n,l,r;\nLL ans,f[200010][3],s[3];\nint main(){\n//\tfreopen(""t.in"",""r"",stdin);\n//\tfreopen(""t.out"",""w"",stdout);\n\tcin>>n>>l>>r;\n\t--l;\n\ts[0]=r/3-l/3;\n\ts[1]=(r+2)/3-(l+2)/3;\n\ts[2]=(r+1)/3-(l+1)/3;\n\tf[0][0]=1;\n\tFOR(i,0,n-1)\n\t\tFOR(j,0,2)\n\t\t\tif (f[i][j]){\n\t\t\t\tFOR(k,0,2)\n\t\t\t\t\t(f[i+1][(j+k)%3]+=f[i][j]*s[k])%=MO;\n\t\t\t}\n\tans=(f[n][0]%MO+MO)%MO;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1500
You are given a positive integer m and two integer sequence a a 1 a 2 ldots a n and b b 1 b 2 ldots b n Both of these sequence have a length n Permutation is a sequence of n different positive integers from 1 to n For example these sequences are permutations 1 1 2 2 1 6 7 3 4 1 2 5 These are not 0 1 1 2 3 You need to find the non negative integer x and increase all elements of a i by x modulo m i e you want to change a i to a i x bmod m so it would be possible to rearrange elements of a to make it equal b among them you need to find the smallest possible x In other words you need to find the smallest non negative integer x for which it is possible to find some permutation p p 1 p 2 ldots p n such that for all 1 leq i leq n a i x bmod m b p i where y bmod m remainder of division of y by m For example if m 3 a 0 0 2 1 b 2 0 1 1 you can choose x 1 and a will be equal to 1 1 0 2 and you can rearrange it to make it equal 2 0 1 1 which is equal to b ,"['//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx"")\n\n#include<bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define ll long long\n#define ld long double\n#define null nullptr\n#define _ <<\' \'<<\n#define endl \'\\n\'\n\nusing namespace std;\n\nmt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nconst int N = 2e5 + 7;\nconst int M = 1e9 + 7;\n//const int M = 998244353;\nconst int FFTM = 998244353;\n\n\nconst int maxn = 2002;\nconst int inf = 1e9 + 66555;\nint a[maxn];\nint b[maxn];\nint c[maxn];\n\n\nint main()\n{\n#ifdef LOCAL\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif // LOCAL\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for(int i = 0; i < n; ++i)\n        cin >> a[i];\n    for(int i = 0; i < n; ++i)\n        cin >> b[i];\n    sort(b, b + n);\n    int ans = inf;\n    for(int i = 0; i < n; ++i)\n    {\n        int kek;\n        if (b[i] > a[0]) kek = b[i] - a[0];\n            else         kek = m - a[0] + b[i];\n        for(int j = 0; j < n; ++j)\n            c[j] = (a[j] + kek) % m;\n        sort(c, c + n);\n        bool f = true;\n        for(int j = 0; j < n && f; ++j)\n            if (b[j] != c[j]) f = false;\n        if (f) ans = min(ans, kek);\n    }\n    cout << ans % m;\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
You are given a binary string S of length n indexed from 1 to n You can perform the following operation any number of times possibly zero Choose two integers l and r 1 le l le r le n Let cnt 0 be the number of times occurs in S l ldots r and cnt 1 be the number of times occurs in S l ldots r You can pay cnt 0 cnt 1 1 coins and sort the S l ldots r by S l ldots r we mean the substring of S starting at position l and ending at position r For example if S we can perform the operation on S 2 ldots 4 paying 2 1 1 2 coins and obtain S as a new string Find the minimum total number of coins required to sort S in increasing order ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\nint tab[nax];\n\nchar wcz[nax];\n\nint kt[nax];\nint dp[nax];\n\nvoid ans(int v)\n{\n\tprintf(""%d\\n"", v);\n}\n\nint fen[10*nax];\n\nvoid reset()\n{\n\tfor (int i=1; i<=20*(n+17); i++)\n\t\tfen[i]=nax;\n}\n\nvoid pisz(int v, int w)\n{\n\tv+=(n+17)*10;\n\tfor (int i=v; i<=20*(n+17); i+=(i&(-i)))\n\t\tfen[i]=min(fen[i], w);\n}\n\nint czyt(int v)\n{\n\tint ret=nax;\n\tv+=(n+17)*10;\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tret=min(fen[i], ret);\n\treturn ret;\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t\ttab[i]=wcz[i]-\'0\';\n\tvi ile{0, 1};\n\tfor (int i=1; i<=n; i++)\n\t\tile[tab[i]]++;\n\tif (ile[1]>ile[0])\n\t{\n\t\treverse(tab+1, tab+1+n);\n\t\tfor (int i=1; i<=n; i++)\n\t\t\ttab[i]^=1;\n\t}\n\t//~ debug() << range(tab+1, tab+1+n);\n\t{\n\t\tint zero=1;\n\t\tfor (int i=2; i<=n; i++)\n\t\t\tif (tab[i]<tab[i-1])\n\t\t\t\tzero=0;\n\t\tif (zero)\n\t\t{\n\t\t\tans(0);\n\t\t\treturn;\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tkt[i]=kt[i-1]+tab[i];\n\t\tdp[i]=nax;\n\t}\n\tint p=1;\n\twhile(!tab[p])\n\t\tp++;\n\tdp[p]=0;\n\treset();\n\tfor (int i=p+1; i<=n; i++)\n\t{\n\t\tpisz((i-1)-kt[i-1], dp[i-1]-((i-1)-kt[i-1]));\n\t\tdp[i]=czyt(i-2*kt[i])+i-2*kt[i]+1;\n\t}\n\t//~ for (int i=p+1; i<=n; i++)\n\t//~ {\n\t\t//~ for (int j=p; j<i; j++)\n\t\t//~ {\n\t\t\t//~ if (i-2*kt[i]>=(j-kt[j]))\n\t\t\t\t//~ dp[i]=min(dp[i], dp[j]+abs(i-j-2*kt[i]+kt[j])+1);\n\t\t//~ }\n\t//~ }\n\t//~ debug() << range(kt+1, kt+1+n);\n\t//~ debug() << range(dp+1, dp+1+n);\n\tint wyn=dp[n];\n\tfor (int i=p; i<=n; i++)\n\t{\n\t\t//~ if (kt[i]!=kt[n])\n\t\t\t//~ continue;\n\t\t//~ debug() << i << "" "" << \n\t\twyn=min(wyn, dp[i]+max(n-i-2*kt[n]+kt[i], 0)+1);\n\t}\n\tprintf(""%d\\n"", wyn);\n\t//~ exit(0);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",3400
You ve got a positive integer sequence All numbers in the sequence are distinct Let s fix the set of variables Initially each variable contains the value of zero Consider the following sequence consisting of operations The first operation is assigning the value of to some variable Each of the following operations is assigning to some variable the value that is equal to the sum of values that are stored in the variables and At that the value that is assigned on the th operation must equal For each operation numbers are chosen anew Your task is to find the minimum number of variables such that those variables can help you perform the described sequence of operations ,"['#pragma comment(linker, ""/STACK:256000000"")\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <stdio.h>\n#include <set>\n#include <map>\n#include <stack>\n#include <fstream>\n#include <deque>\n#include <list>\n#include <ctime>\n\n#define SZ(a) (int(a.size()))\n#define MEM(a, val) memset(a, val, sizeof(a))\n#define MP(a, b) make_pair(a, b)\n#define PB(a) push_back(a)\n#define ALL(a) a.begin(), a.end()\n#define REP(i, n) for(int (i) = 0; (i) < (n); ++(i))\n#define FOR(i, a, b) for(int (i) = (a); (i) <= (b); ++(i))\n#define SQR(a) ((a) * (a))\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\ntypedef long long LL;\ntypedef long double dbl;\ntypedef pair<int, int> pii ;\ntypedef vector<int> vint;\ntypedef vector<LL> vLL;\n\nvector<bool> f[25];\nconst int inf = 1000000001;\nint n;\nint a[25];\ninline int bit(int i, int mask) {\n    return (mask >> i) & 1;\n}\n\nint main()\n{\n#ifdef _DEBUG\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#else\n    //freopen(""input.txt"", ""r"", stdin);freopen(""output.txt"", ""w"", stdout);\n#endif\n    cin >> n;\n    FOR(i, 1, n)\n        cin >> a[i];\n    f[1].resize(2);\n    f[1][0] = false;\n    f[1][1] = true;\n    for (int i = 1; i < n; ++i) {\n        f[i + 1].assign(1 << (i + 1), 0);\n        for (int mask = 0; mask < (1 << i); ++mask) {\n            if (f[i][mask]) {\n                bool end = false;\n                for (int j = 0; j < i && !end; ++j) {\n                    if (bit(j, mask) == 0)\n                        continue;\n                    for (int k = j; k < i && !end; ++k) {\n                        if (bit(k, mask) == 0)\n                            continue;\n                        if (a[j + 1] + a[k + 1] == a[i + 1]) {\n                            mask += (1 << i);\n                            f[i + 1][mask] = true;\n                            for (int u = 0; u < i; ++u) {\n                                if (bit(u, mask)) {\n                                    f[i + 1][mask ^ (1 << u)] = true;\n                                }\n                            }\n                            end = true;\n                            mask -= (1 << i);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int ans = inf;\n    for (int mask = 0; mask < (1 << n); ++mask) {\n        if (f[n][mask]) {\n            int pans = 0;\n            int t = mask;\n            while (t > 0) {\n                pans += t & 1;\n                t >>= 1;\n            }\n            ans = min(ans, pans);\n        }\n    }\n    if (ans == inf)\n        cout << -1 << endl;\n    else\n        cout << ans << endl;\n    return 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2200
While Vasya finished eating his piece of pizza the lesson has already started For being late for the lesson the teacher suggested Vasya to solve one interesting problem Vasya has an array and integer He should find the number of different ordered pairs of indexes such that and there are exactly integers such that and is divisible by In this problem it is meant that pair is equal to only if is equal to For example pair is not the same as ,"['#include""bits/stdc++.h""\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch==\'-\')f=-1;}while(ch<\'0\'||ch>\'9\');do x=x*10+ch-\'0\',ch=getchar();while(ch<=\'9\'&&ch>=\'0\');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,x,k;\n\nll A[maxn];\n\nmap<int,int> has;\n\nint main(){\n\tread(n,x,k);\n\tREP(i,1,n)read(A[i]);\n\tsort(A+1,A+n+1);\n\tll ans=0;\n\tREP(i,1,n){\n\t\tint t=(A[i]-1)/x;\n\t\tt+=k;\n\t\tll l=1ll*t*x,r=1ll*t*x+x-1;\n\t\tl=max(l,(ll)A[i]);\n\t\tans+=upper_bound(A+1,A+n+1,r)-lower_bound(A+1,A+n+1,l);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n']","[0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1700
You are given two integers x and y A sequence a of length n is called if a 1 x and for all 1 i le n the value of a i is either a i 1 y or a i 1 bmod y Here x bmod y denotes the remainder from dividing x by y Determine if there exists a modular sequence of length n with the sum of its elements equal to S and if it exists find any such sequence ,"['#include<bits/stdc++.h>\n\nint main() {\n        std::cin.tie(nullptr)->sync_with_stdio(false);\n\n        int t;\n        std::cin >> t;\n        while (t--) {\n                int n, x, y, s;\n                std::cin >> n >> x >> y >> s;\n                long long st = x / y;\n                if (s < 1ll * (x % y) * n) {\n                        std::cout << ""NO\\n"";\n                        continue;\n                }\n                s -= (x % y) * n;\n                std::vector<int> dp(s + 1, 1e9);\n                std::vector<int> par(s + 1, -1);\n                dp[0] = 0;\n                for (int i = 0; i <= s; ++i) {\n                        for (int j = 1; i + j * (j - 1) / 2 * y <= s; ++j) {\n                                int k = i + j * (j - 1) / 2 * y;\n                                if (dp[k] > dp[i] + j) {\n                                        dp[k] = dp[i] + j;\n                                        par[k] = j;\n                                }\n                        }\n                }\n                bool ok = false;\n                for (int d = 1; (2 * st + d - 1) * d / 2 * y <= s; ++d) {\n                        if (d + dp[s - (2 * st + d - 1) * d / 2 * y] <= n) {\n                                std::cout << ""YES\\n"";\n                                std::vector<int> ans(n, x % y);\n                                int ptr = 0;\n                                for (int i = 0; i < d; ++i, ++ptr) ans[ptr] += (st + i) * y;\n                                int u = s - (2 * st + d - 1) * d / 2 * y;\n                                while (u != 0) {\n                                        int k = par[u];\n                                        u -= k * (k - 1) / 2 * y;\n                                        for (int i = 0; i < k; ++i, ++ptr) ans[ptr] += i * y;\n                                }\n                                for (auto i : ans) std::cout << i << \' \';\n                                std::cout << \'\\n\';\n                                ok = true;\n                                break;\n                        }\n                }\n                if (!ok) std::cout << ""NO\\n"";\n        }\n}']","[1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2300
soldiers stand in a circle For each soldier his height is known A reconnaissance unit can be made of such two soldiers whose heights difference is minimal i e is minimal So each of them will be less noticeable with the other Output any pair of soldiers that can form a reconnaissance unit ,"['#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<list>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<ctime>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair <int,int> ii;\n#define sz(a) int((a).size())\n#define pb push_back\nconst int INF = 2147483647;\nconst double PI = 3.141592653589793;\n\nint n,m,i,tab[105];\n\nint main () {\nscanf (""%d"",&n);\nfor (i=0;i<n;i++) scanf (""%d"",&tab[i]);\nm=INF;\nfor (i=0;i<n;i++) m = min(m,abs(tab[(i+1)%n]-tab[i]));\nfor (i=0;i<n;i++) if (abs(tab[(i+1)%n]-tab[i]) == m) {\n    printf(""%d %d\\n"",i+1,(i+1)%n+1);\n    i=n+1;\n}\nreturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Chloe the same as Vladik is a competitive programmer She didn t have any problems to get to the olympiad like Vladik but she was confused by the task proposed on the olympiad Let s consider the following algorithm of generating a sequence of integers Initially we have a sequence consisting of a single element equal to Then we perform steps On each step we take the sequence we ve got on the previous step append it to the end of itself and insert in the middle the minimum positive integer we haven t used before For example we get the sequence after the first step the sequence after the second step The task is to find the value of the element with index the elements are numbered from in the obtained sequence i e after steps Please help Chloe to solve the problem ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long n,k;\n\nlong long get(long long n, long long k) {\n    long long length=(1ll<<n)-1;\n    if(length/2+1==k) return n;\n    else if(k<=length/2) return get(n-1,k);\n    else return get(n-1,k-length/2-1);\n}\n\nint main() {\n    scanf(""%lld %lld"", &n, &k);\n    printf(""%lld\\n"", get(n,k));\n\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1200
You are given a matrix of size Each element of the matrix is either 1 or 0 You have to determine the number of connected components consisting of 1 s Two cells belong to the same component if they have a common border and both elements in these cells are 1 s ,"['#include <vector>\n#include <cstdio>\n#include <iterator>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <functional>\n#include <array>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,""%s"")DEF(int,""%d"")DEF(double,""%lf"")DEF(float,""%f"")DEF(char,""%c"")DEF(const char*,""%s"")DEF(unsigned long,""%lu"")DEF(unsigned int, ""%u"")DEF(long double, ""%Lf"")\n#ifdef _MSC_VER\nDEF(long long int,""%I64d"")\n#else\nDEF(long long int,""%lld"")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(""%s"", arg);}\nint RD(char* arg){return std::scanf(""%s"", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf("" %c"", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(""(""); WT(arg.first); std::printf("", ""); WT(arg.second); std::printf("")"");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf("" ""): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(""\\n""); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf("" ""): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(""\\n""); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == \'""\' || #_1[0] == \'\\\'\'? WT("""", _1, """"): WT(\'[\', #_1, \'=\', _1, \']\'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(""(%03d) "", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(""""))\n\n\n\nnamespace XX\n{\n    template<typename... Datas>\n    struct UnionFind\n    {\n            struct Node:public Datas...\n            {\n                int _parent = -1;\n                void operator+=(Node& other) { int dummy[] = {(Datas::operator+=(other), 0)...}; }\n            };\n            UnionFind(int size = 0) :_data(size, Node()) {}\n\n            void resize(int size)\n            {\n                _data.resize(size, Node());\n            }\n\n            int size()\n            {\n                return _data.size();\n            }\n\n            Node& operator[](int idx) { return _data[(*this)(idx)]; }\n\n            int operator()(int n)\n            {\n                if(_data[n]._parent < 0)\n                    return n;\n                else\n                    return _data[n]._parent = (*this)(_data[n]._parent);\n            }\n\n            bool operator()(int a, int b)\n            {\n                int pa = (*this)(a), pb = (*this)(b);\n                if(pa == pb)\n                    return false;\n                else\n                {\n                    if(_data[pa]._parent == _data[pb]._parent)\n                        _data[pa]._parent--;\n                    else if(_data[pa]._parent > _data[pb]._parent)\n                        std::swap(pa, pb);\n\n                    _data[pa] += _data[pb];\n                    _data[pb]._parent = pa;\n                    return true;\n                }\n            }\n\n            std::vector<Node> _data;\n    };\n}\n\n\n\n\n\n\n\n\n//alias\n//for union/find\ntemplate<typename... Datas>\nusing UF = XX::UnionFind<Datas...>; \n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int R = 1 << 15;\nint last[R];\n\nstruct Data\n{\n    int num = 0;\n    void operator+=(Data&){}\n};\n\nint main()\n{\n    int ans = 0;\n    int N, M;\n    RD(N, M);\n    int now = 0;\n\n    for(int i: RG(N))\n    {\n        int buf[R] = {};\n        int pass[R] = {};\n\n        UF<Data> uf(M + 1);\n        int ex = 0;\n\n        for(int j: RG(M / 4))\n        {\n            char c;\n            RD(c);\n\n            if(c >= \'A\')\n                c = c - \'A\' + 10;\n            else\n                c -= \'0\';\n\n //           for(int k: RG(4))\n   //             WT(c >> (3 - k) & 1);\n            for(int k: RG(4))\n                if(c >> (3 - k) & 1)\n                {\n                    int pos = j * 4 + k;\n                    int id;\n                    if(last[pos])\n                        id = last[pos];\n                    else\n                        id = now + ++ex;\n\n                    buf[pos] = id;\n                    pass[id] = true;\n                    if(pos && buf[pos - 1])\n                        uf(buf[pos - 1], buf[pos]);\n                }\n        }\n\n//        WTL();\n\n        int alc = 0;\n        for(int j: RG(1, now + ex + 1))\n            if(!pass[j])\n                ans++;\n            else if(!uf[j].num)\n                uf[j].num = ++alc;\n\n        for(int j: RG(M))\n            if(buf[j])\n                last[j] = uf[buf[j]].num;\n            else\n                last[j] = 0;\n        now = alc;\n\n        //WTVL(last, last + M);\n    }\n\n    ans += now;\n\n    WTL(ans);\n\n\n}\n\n\n\n\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2500
The World Programming Olympics Medal is a metal disk consisting of two parts the first part is a ring with outer radius of cm inner radius of cm made of metal with density g cm The second part is an inner disk with radius cm it is made of metal with density g cm The disk is nested inside the ring The Olympic jury decided that will take one of possible values of It is up to jury to decide which particular value will take Similarly the Olympic jury decided that will take one of possible value of and will take a value from list According to most ancient traditions the ratio between the outer ring mass and the inner disk mass must equal where are constants taken from ancient books Now to start making medals the jury needs to take values for and calculate the suitable value of The jury wants to choose the value that would maximize radius Help the jury find the sought value of Value doesn t have to be an integer Medal has a uniform thickness throughout the area the thickness of the inner disk is the same as the thickness of the outer ring ,"['#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint n,m,k;\nint r1[10000],p1[10000],p2[10000];\nint main()\n{\n    while(~scanf(""%d"",&n))\n    {\n        for(int i=1;i<=n;i++)scanf(""%d"",&r1[i]);\n        scanf(""%d"",&m);\n        for(int i=1;i<=m;i++)scanf(""%d"",&p1[i]);\n        scanf(""%d"",&k);\n        for(int i=1;i<=k;i++)scanf(""%d"",&p2[i]);\n        int A,B;\n        scanf(""%d %d"",&A,&B);\n        sort(r1+1,r1+1+n);\n        sort(p1+1,p1+1+m);\n        sort(p2+1,p2+1+k);\n        double ans=(double)p2[1]/p1[m];\n        ans*=A;\n        ans/=B;\n        ans+=1;\n        ans=1.0/ans;\n        ans=sqrt(ans);\n        ans*=r1[n];\n        printf(""%.10f\\n"",ans);\n    }\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
You are given a weighted directed graph consisting of vertices and edges You should answer queries of two types find the length of shortest path from vertex to vertex add to weights of edges with indices ,"['#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <numeric>\n#include <random>\n#include <vector>\n#include <array>\n#include <bitset>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nstruct rng {\n    struct A {\n        int n;\n        const bool operator!=(A r) { return n != r.n; }\n        A& operator++() { n++; return *this; }\n        int operator*() { return n; }\n    };\n    int l, r;\n    rng(int r) : l(0), r(r) {}\n    rng(int l, int r) : l(l), r(r) {}\n    A begin() { return A{l}; }\n    A end() { return A{r}; }\n};\n\ntemplate<class D, D INF>\nstruct Dijkstra {\n    V<D> res; //res[i] = sからiまでの最短距離\n    \n    template<class E>\n    Dijkstra(const VV<E> &g, int s) {\n        int n = (int)g.size();\n        res = V<D>(n, INF);\n        \n        using P = pair<D, int>;\n        priority_queue<P, vector<P>, greater<P>> q;\n        q.push(P(0, s));\n        res[s] = 0;\n        while (!q.empty()) {\n            P p = q.top(); q.pop();\n            if (res[p.second] < p.first) continue;\n            for (E e: g[p.second]) {\n                if (p.first+e.dist < res[e.to]) {\n                    res[e.to] = p.first+e.dist;\n                    q.push(P(res[e.to], e.to));\n                }\n            }\n        }\n    }\n};\n\nstruct E {\n    int to;\n    int dist;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n, m, q;\n    cin >> n >> m >> q;\n    VV<E> g(n);\n    using P = pair<int, int>;\n    V<P> ed(m);\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c; a--; b--;\n        ed[i] = P(a, int(g[a].size()));\n        g[a].push_back(E{b, c});\n    }\n    \n    V<ll> sm = Dijkstra<ll, TEN(18)>(g, 0).res;\n    V<int> pos(n);\n    V<bool> cant(n);\n    for (int i = 0; i < n; i++) cant[i] = (sm[i] == TEN(18));\n\n    for (int i = 0; i < n; i++) {\n        if (cant[i]) continue;\n        for (auto &e: g[i]) {\n            int j = e.to;\n            e.dist -= sm[j] - sm[i];\n        }\n    }\n\n    auto ref = [&]() {\n        for (int i = 0; i < n; i++) {\n            if (cant[i]) continue;\n            for (auto &e: g[i]) {\n                int j = e.to;\n                e.dist -= pos[j] - pos[i];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (cant[i]) continue;\n            sm[i] += pos[i];\n            pos[i] = 0;\n        }\n    };\n\n    int c = 0;\n    V<bool> vis(n);\n    for (int ph = 0; ph < q; ph++) {\n        int ty;\n        cin >> ty;\n        if (ty == 1) {\n            if (c) {\n                fill(begin(pos), end(pos), TEN(9));\n                fill(begin(vis), end(vis), false);\n    \n                VV<int> que(c+1);\n                que[0].push_back(0);\n                pos[0] = 0;\n                for (int di = 0; di <= c; di++) {\n                    while (que[di].size()) {\n                        int p = que[di].back(); que[di].pop_back();\n                        if (vis[p]) continue;\n                        vis[p] = true;\n                        for (auto e: g[p]) {\n                            if (c < di + e.dist) continue;\n                            if (pos[e.to] <= di + e.dist) continue;\n                            pos[e.to] = di + e.dist;\n                            que[di + e.dist].push_back(e.to);\n                        }\n                    }\n                }\n                ref();\n                c = 0;                    \n            }\n            int v;\n            cin >> v; v--;\n            cout << (cant[v] ? -1 : sm[v]) << endl;\n        } else {\n            int x;\n            cin >> x;\n            for (int i = 0; i < x; i++) {\n                int l;\n                cin >> l; l--;\n                g[ed[l].first][ed[l].second].dist++;\n            }\n            c += x;            \n        }\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",3400
There is a chess board of size n times m The rows are numbered from 1 to n the columns are numbered from 1 to m Let s call a cell if a knight placed in that cell can t move to any other cell on the board Recall that a chess knight moves two cells in one direction and one cell in a perpendicular direction Find any cell on the board If there are no such cells print any cell on the board ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include ""library/debug.cpp""\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while (tt--) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 1 || m == 1) {\n            cout << 1 << "" "" << 1 << \'\\n\';\n        } else {\n            cout << 2 << "" "" << 2 << \'\\n\';\n        }\n    }\n    return 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
There are three cards with letters texttt a texttt b texttt c placed in a row in some order You can do the following operation Pick two cards and swap them Is it possible that the row becomes texttt abc after the operation Output if it is possible and otherwise ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define vec vector\n#define read(x) for (auto &zu: (x)) cin >> zu;\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define print(x, sep) {for(auto &zu: (x))cout << zu << (sep);cout << ""\\n"";}\n#define len(x) (long long)((x).size())\n#define magic ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n#define sep << "" "" <<\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing str = string;\nusing pii = pair<int, int>;\nusing ld = long double;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nostream &operator <<(ostream &os, pii a){\n    return os << a.F sep a.S;\n}\n\nll inf = 1e18;\n\nvoid fa(bool ok){ cout << (ok ? ""YES"": ""NO"") << ""\\n""; }\n\n\nvoid solve(){\n    str s; cin >> s;\n    int ne = 0;\n    for(int i = 0; i < len(s); ++i)\n        ne += (s[i] - \'a\') != i;\n    fa(ne == 2 or ne == 0);\n}\n\nsigned main(){\n    magic;\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n    return 0;\n\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
There are n models in the shop numbered from 1 to n with sizes s 1 s 2 ldots s n Orac will buy some of the models and will arrange them in the order of increasing numbers i e indices but not sizes Orac thinks that the obtained arrangement is if for any two adjacent models with indices i j and i j 1 note that i j i j 1 because Orac arranged them properly i j 1 is divisible by i j and s i j s i j 1 For example for 6 models with sizes 3 6 7 7 7 7 he can buy models with indices 1 2 and 6 and the obtained arrangement will be beautiful Also note that the arrangement with exactly one model is also considered beautiful Orac wants to know the maximum number of models that he can buy and he may ask you these queries many times ,"['#include<bits/stdc++.h>\n#define ll long long\n#define N 100010\nusing namespace std;\nint t,n,a[N],dp[N],ansn;\nint main(){\n\tcin>>t;\n\twhile (t--){\n\t\tcin>>n;ansn=0;\n\t\tfor (int i=1;i<=n;i++)cin>>a[i],dp[i]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tfor (int j=i+i;j<=n;j+=i)if (a[j]>a[i])dp[j]=max(dp[j],dp[i]+1);\n\t\t\tansn=max(ansn,dp[i]);\n\t\t}\n\t\tcout<<ansn<<endl;\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1400
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that every positive integer was one of his personal friends It turns out that positive integers can also be friends with each other You are given an array a of distinct positive integers Define a a i a i 1 ldots a j to be a if and only if there exists an integer m ge 2 such that a i bmod m a i 1 bmod m ldots a j bmod m where x bmod y denotes the remainder when x is divided by y Your friend Gregor wants to know the size of the largest friend group in a ,"['//别丢包了！\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 200005;\nll a[maxn];\nll gcd(ll a, ll b) {\n    if (!b) return a;\n    return gcd(b, a % b);\n}\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        for (int i = 1; i <= n; i++) scanf(""%lld"", &a[i]);\n        if (n == 1) printf(""1\\n"");\n        else {\n            vector<pair<ll, int> > cur;\n            int ans = 1;\n            for (int i = n; i >= 2; i--) {\n                ll h = abs(a[i] - a[i - 1]);\n                for (int i = 0; i < cur.size(); i++) {\n                    cur[i].fi = gcd(cur[i].fi, h);\n                    cur[i].se += 1;\n                }\n                cur.pb(mp(h, 2));\n                vector<pair<ll, int> > nx;\n                for (int i = 0; i < cur.size(); i++) {\n                    if (cur[i].fi == 1) continue;\n                    chkmax(ans, cur[i].se);\n                    if (i == 0 || cur[i].fi != cur[i - 1].fi)\n                        nx.pb(cur[i]);\n                }\n                cur = nx;\n            }\n            printf(""%d\\n"", ans);\n        }\n    }\n    return (0-0); //<3\n}']","[0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",1800
One day Sasha visited the farmer 2D and his famous magnetic farm On this farm the crop grows due to the influence of a special magnetic field Maintaining of the magnetic field is provided by n machines and the power of the i th machine is a i This year 2D decided to cultivate a new culture but what exactly he didn t say For the successful growth of the new culture it is necessary to slightly change the powers of the machines 2D can choose an arbitrary integer x then choose one machine and reduce the power of its machine by x times and at the same time increase the power of one another machine by x times powers of all the machines must stay Note that he may not do that if he wants More formally 2D can choose two such indices i and j and one integer x such that x is a divisor of a i and change powers as following a i frac a i x a j a j cdot xSasha is very curious that s why he wants to calculate the total power the farmer can reach There are too many machines and Sasha can t cope with computations help him ,"['#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n, a[50000];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a+n);\n\n    int sum = 0;\n    for (int i = 0; i < n; i++) sum += a[i];\n\n    int sol = sum;\n    for (int i = 1; i < n; i++) {\n        for (int d = 2; d <= a[i]; d++) {\n            if(a[i] % d != 0) continue;\n            sol = min(sol, sum-a[0]-a[i] + d*a[0] + a[i]/d);\n        }\n    }\n    cout << sol << endl;\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300
You are given a positive integer n Let s call some positive integer a without leading zeroes palindromic if it remains the same after reversing the order of its digits Find the number of distinct ways to express n as a sum of positive palindromic integers Two ways are considered different if the frequency of at least one palindromic integer is different in them For example 5 4 1 and 5 3 1 1 are considered different but 5 3 1 1 and 5 1 3 1 are considered the same Formally you need to find the number of distinct multisets of positive palindromic integers the sum of which is equal to n Since the answer can be quite large print it modulo 10 9 7 ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nconst int N=40005;\nconst int mod=1e9+7;\n\nint dp[N],n=40000;\n\nbool check(int x){\n    static int a[10],len;\n    len=0;while(x)a[++len]=x%10,x/=10;\n    for(int i=1,j=len;i<j;i++,j--)if(a[i]!=a[j])return false;\n    return true;\n}\n\nint main(){\n    dp[0]=1;\n    for(int i=1;i<=n;i++){\n        if(check(i)){\n            for(int j=i;j<=n;j++)\n                dp[j]=(dp[j]+dp[j-i])%mod;\n        }\n    }\n    int T=read();\n    while(T--)print(dp[read()],'\\n');\n    return 0;\n}""]","[0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1500
Several years ago Tolya had computer games and at some point of time he decided to burn them to CD After that he wrote down the names of the games one after another in a circle on the CD The names were distinct the length of each name was equal to The names didn t overlap Thus there is a cyclic string of length written on the CD Several years have passed and now Tolya can t remember which games he burned to his CD He knows that there were popular games that days All of the games he burned were among these games and You have to restore any valid list of games Tolya could burn to the CD several years ago ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld EPS = 1e-7;\n\nconst int N = 3e6 + 123;\nconst int M = 2e5 + 123;\nconst int A = \'z\' - \'a\' + 2;\n\nstruct Node {\n    int term;\n    int nxt[A];\n    int link;\n    int p, ps;\n    \n    Node() {\n        ps = -1;\n        p = -1;\n        term = -1;\n        fill(nxt, nxt + A, -1);\n        link = -1;\n    }\n};\n\nint ptr = 1;\nNode trie[N];\n\nint get_id(const string &s) {\n    int cur_v = 0;\n    for (char cc : s) {\n        int c = cc - \'a\';\n        if (trie[cur_v].nxt[c] == -1) {\n            assert(false);\n        }\n        cur_v = trie[cur_v].nxt[c];\n    }\n    \n    return trie[cur_v].term;\n}\n\nvoid add(const string &s, int id) {\n    int cur_v = 0;\n    for (char cc : s) {\n        int c = cc - \'a\';\n        if (trie[cur_v].nxt[c] == -1) {\n            trie[cur_v].nxt[c] = ptr++;\n            trie[ptr - 1].p = cur_v;\n            trie[ptr - 1].ps = c;\n        }\n        cur_v = trie[cur_v].nxt[c];\n    }\n    \n    trie[cur_v].term = id;\n}\n\nint link(int v);\n\nint go(int v, int c) {\n    if (trie[v].nxt[c] != -1) {\n        return trie[v].nxt[c];\n    }\n    if (v == 0) {\n        return 0;\n    }\n    \n    return trie[v].nxt[c] = go(link(v), c);\n}\n\nint link(int v) {\n    if (trie[v].link != -1) {\n        return trie[v].link;\n    }\n    \n    if (v == 0 || trie[v].p == 0) {\n        return 0;\n    }\n    \n    return trie[v].link = go(link(trie[v].p), trie[v].ps);\n}\n\nint n, k;\nset<int> q[M];\n\nint run() {\n    cin >> n >> k;\n    string s;\n    cin >> s;\n    int l = (int) s.size();\n    s = s + s;\n    \n    int g;\n    cin >> g;\n    for (int i = 0; i < g; i++) {\n        string t;\n        cin >> t;\n        add(t, i + 1);\n    }\n    \n    int cur_v = 0;\n    \n    for (int i = 0; i < 2 * l; i++) {\n        cur_v = go(cur_v, s[i] - \'a\');\n        \n        if (trie[cur_v].term != -1) {\n            int beg = i - k + 1;\n            if (beg < l) {\n                q[beg % k].insert(cur_v);\n            }\n        }\n    }\n    \n    for (int i = 0; i < k; i++) {\n        if ((int) q[i].size() == n) {\n            cout << ""YES\\n"";\n            for (int j = 0; j < n; j++) {\n                cout << get_id(s.substr(i + j * k, k)) << "" "";\n            }\n            cout << ""\\n"";\n            return 0;\n        }\n    }\n    \n    cout << ""NO\\n"";\n    \n    return 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    return run();\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2300
loves simple strings A string is called simple if every pair of adjacent characters are distinct For example are simple whereas are not simple is given a string He wants to change a minimum number of characters so that the string becomes simple Help him with this task ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nchar wcz[1000007];\n\nint tak[1000007];\n\nint main()\n{\n    scanf(""%s"", wcz);\n    for (int i=0; 1; i++)\n    {\n        if (!wcz[i])\n        break;\n        if (wcz[i]==wcz[i+1])\n        {\n            wcz[i+1]=1;\n            tak[i+1]=1;\n        }\n    }\n    for (int i=0; 1; i++)\n    {\n        if (!wcz[i])\n        break;\n        if (tak[i])\n        {\n            if (wcz[i-1]!=\'a\' && wcz[i+1]!=\'a\')\n            {\n                wcz[i]=\'a\';\n            }\n            else\n            {\n                if (wcz[i-1]!=\'b\' && wcz[i+1]!=\'b\')\n                {\n                    wcz[i]=\'b\';\n                }\n                else\n                {\n                    wcz[i]=\'c\';\n                }\n            }\n        }\n        printf(""%c"", wcz[i]);\n    }\n    printf(""\\n"");\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1300
After your debut mobile game Nim blew up you decided to make a sequel called Nim 2 This game will expand on the trusted Nim game formula adding the much awaited second heap In the game there are two heaps each containing a non negative number of stones Two players make moves in turn On their turn a player can take any positive number of stones from either one of the heaps A player who is unable to move loses the game To make the game easier to playtest you ve introduced developer shortcuts There are n shortcut positions x 1 y 1 ldots x n y n These change the game as follows suppose that before a player s turn the first and second heap contain x and y stones respectively If the pair x y is equal to one of the pairs x i y i then the player about to move loses instantly otherwise they are able to make moves as normal Note that in the above explanation the two heaps and all pairs are that is x must refer to the size of the first heap and y must refer to the size of the second heap The game release was followed by too much celebration and next thing you know is developer shortcuts made their way to the next official update of the game Players now complain that the AI opponent has become unbeatable at certain stages of the game You now have to write a program to figure out which of the given initial positions can be won by the starting player assuming both players act optimally ,"['/**\n *    author:  tourist\n *    created: 19.12.2020 13:02:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  const int M = (int) 1e9;\n  map<int, vector<int>> mp;\n  for (int i = 0; i < n; i++) {\n    mp[x[i]].push_back(y[i]);\n  }\n  mp[M + 1].push_back(-1);\n  set<pair<int, int>> s;\n  s.emplace(0, 2 * M);\n  vector<tuple<int, int, int>> res;\n  int last = -1;\n  for (auto& p : mp) {\n    sort(p.second.begin(), p.second.end());\n    int row = p.first;\n    int from = last + 1;\n    int to = row - 1;\n    while (from <= to) {\n      auto it = s.begin();\n      int it1 = it->first;\n      int it2 = it->second;\n      int len = it->second - it->first + 1;\n      if (len <= to - from + 1) {\n        res.emplace_back(from, from + len - 1, it->first);\n        from += len;\n        s.erase(it);\n        continue;\n      }\n      res.emplace_back(from, to, it->first);\n      s.erase(it);\n      s.emplace(it1 + (to - from + 1), it2);\n      break;\n    }\n    if (p.first > M) {\n      break;\n    }\n    for (int j : p.second) {\n      auto it = s.lower_bound(make_pair(j + 1, -1));\n      if (it != s.begin()) {\n        it = prev(it);\n        int L = it->first;\n        int R = it->second;\n        if (L <= j && j <= R) {\n          s.erase(it);\n          if (L < j) {\n            s.emplace(L, j - 1);\n          }\n          if (j < R) {\n            s.emplace(j + 1, R);\n          }\n        }\n      }\n    }\n    auto it = s.begin();\n    if (it->first < p.second[0]) {\n      int L = it->first;\n      int R = it->second;\n      p.second.insert(p.second.begin(), L);\n      s.erase(it);\n      if (L < R) {\n        s.emplace(L + 1, R);\n      }\n    }\n    last = row;\n  }\n  while (m--) {\n    int x, y;\n    cin >> x >> y;\n    auto it = mp.find(x);\n    if (it != mp.end()) {\n      auto ti = lower_bound(it->second.begin(), it->second.end(), y);\n      if (ti != it->second.end() && (*ti) == y) {\n        cout << ""LOSE"" << \'\\n\';\n      } else {\n        cout << ""WIN"" << \'\\n\';\n      }\n    } else {\n      auto ti = lower_bound(res.begin(), res.end(), make_tuple(x + 1, -1, -1));\n      assert(ti != res.begin());\n      ti = prev(ti);\n      assert(get<0>(*ti) <= x && x <= get<1>(*ti));\n      int val = get<2>(*ti) + (x - get<0>(*ti));\n      if (val == y) {\n        cout << ""LOSE"" << \'\\n\';\n      } else {\n        cout << ""WIN"" << \'\\n\';\n      }\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3100
Squirrel Liss loves nuts There are trees numbered to from west to east along a street and there is a delicious nut on the top of each tree The height of the tree is Liss wants to eat all nuts Now Liss is on the root of the tree with the number In one second Liss can perform one of the following actions Walk up or down one unit on a tree Eat a nut on the top of the current tree Jump to the next tree In this action the height of Liss doesn t change More formally when Liss is at height of the tree she jumps to height of the tree This action can t be performed if Compute the minimal time in seconds required to eat all nuts ,['#include <iostream>\n#include <iomanip>\n#include <string>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n\nusing namespace std;\n\nint n;\n\nint H;\n\nint NH = 0;\n\nint ans = 0;\n\nint main()\n{\n\tcin >> n;\n\tcin >> H;\n\tans += (NH = H) + 1;\n\tfor (int i = 2; i <= n; i++)\n\t{\n\t\tans++;\n\t\tcin >> H;\n\t\tif (H >= NH)\n\t\t{\n\t\t\tans += H - NH + 1;\n\t\t\tNH = H;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans += NH - H + 1;\n\t\t\tNH = H;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}'],"[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
 You are given a rectangular n times m matrix a In one move you can choose any column and cyclically shift elements in this column You can perform this operation as many times as you want possibly zero You can perform this operation to a column multiple times After you are done with cyclical shifts you compute for every row the maximal value in it Suppose that for i th row it is equal r i What is the maximal possible value of r 1 r 2 ldots r n ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=5010;\nint n,m,_,p[N];\nPII v[N];\nint a[20][N],dp[N],pd[N],ff[N],gg[N];\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tscanf(""%d%d"",&n,&m);\n\t\trep(i,0,n) {\n\t\t\trep(j,0,m) scanf(""%d"",&a[i][j]);\n\t\t}\n\t\trep(j,0,m) {\n\t\t\tp[j]=0;\n\t\t\trep(i,0,n) p[j]=max(p[j],a[i][j]);\n\t\t\tv[j]=mp(p[j],j);\n\t\t}\n\t\tsort(v,v+m); reverse(v,v+m);\n\t\tm=min(m,n);\n\t\tmemset(dp,0,sizeof(dp));\n\t\trep(i,0,m) {\n\t\t\trep(j,0,(1<<n)) pd[j]=dp[j],dp[j]=0;\n\t\t\tint x=v[i].se;\n\t\t\trep(rot,0,n) {\n\t\t\t\trep(j,0,(1<<n)) ff[j]=pd[j];\n\t\t\t\trep(k,0,n) {\n\t\t\t\t\trep(j,0,(1<<n)) gg[j]=ff[j];\n\t\t\t\t\trep(j,0,(1<<n)) if (j&(1<<k)) ff[j]=max(ff[j],gg[j-(1<<k)]+a[(k+rot)%n][x]);\n\t\t\t\t}\n\t\t\t\trep(j,0,(1<<n)) dp[j]=max(dp[j],ff[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",dp[(1<<n)-1]);\n\t}\n}\n']","[1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2000
The flag of Berland is such rectangular field that satisfies following conditions Flag consists of three colors which correspond to letters and Flag consists of three equal in width and height stripes parralel to each other and to sides of the flag Each stripe has Each color should be used in You are given a field consisting of characters and Output without quotes if this field corresponds to correct flag of Berland Otherwise print without quotes ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:1048576"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nchar in[105][105];\nchar u[105][105];\nbool isValid(int N, int M) {\n\tif (N % 3) return false;\n\n\tchar x[4] = ""BGR"";\n\tdo {\n\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < M; j++) u[i][j] = x[i / (N / 3)];\n\t\t\n\t\tint i, j;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tfor (j = 0; j < M; j++) if (in[i][j] != u[i][j]) break;\n\t\t\tif (j < M) break;\n\t\t}\n\t\tif (i >= N) return true;\n\t} while (next_permutation(x, x + 3));\n\treturn false;\n}\nint main() {\n\tint N, M, i, j;\n\tscanf(""%d %d"", &N, &M);\n\tfor (i = 0; i < N; i++) scanf(""%s"", in[i]);\n\n\tif (isValid(N, M)) return !printf(""YES\\n"");\n\tfor (i = 0; i < N; i++) for (j = 0; j < M; j++) u[j][i] = in[i][j];\n\tfor (i = 0; i < N; i++) for (j = 0; j < M; j++) in[j][i] = u[j][i];\n\tif (isValid(M, N)) return !printf(""YES\\n"");\n\treturn !printf(""NO\\n"");\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Sereja and Dima play a game The rules of the game are very simple The players have cards in a row Each card contains a number all numbers on the cards are distinct The players take turns Sereja moves first During his turn a player can take one card either the leftmost card in a row or the rightmost one The game ends when there is no more cards The player who has the maximum sum of numbers on his cards by the end of the game wins Sereja and Dima are being greedy Each of them chooses the card with the larger number during his move Inna is a friend of Sereja and Dima She knows which strategy the guys are using so she wants to determine the final score given the initial state of the game Help her ,"['#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector> \n#include<cstring>\n#include<string>\n#define mp make_pair\n#define scn second\n#define frs first\n#define pb push_back\n#define NAME ""a""\n#define fop freopen(NAME "".in"", ""r"", stdin); freopen(NAME "".out"", ""w"", stdout); \nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nvoid dout() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid dout(Head H, Tail... T) {\n  cerr << H << \' \';\n  dout(T...);\n}\n\nint n, a[100000], ans[10];\n\nint main(){\n\t#ifdef LocalHost\n\t\tfop;\n\t#endif\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%d"", &a[i]);\n   \tint l = 0, r = n - 1, turn = 0;   \t\n   \twhile (l <= r) {\n   \t\tans[(turn++)%2] += max(a[l], a[r]);\n   \t\tif (a[l] > a[r])\n   \t\t\t++l;\n   \t\telse \n   \t\t\t--r;\n   \t}\n   \tprintf(""%d %d"", ans[0], ans[1]);\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",800
Ivan likes to learn different things about numbers but he is especially interested in numbers Ivan thinks that a positive integer number is if the difference between and the sum of its digits in decimal representation is not less than To prove that these numbers may have different special properties he wants to know how rare or not rare they are in fact he needs to calculate the quantity of numbers that are not greater than Ivan tried to do the calculations himself but soon realized that it s too difficult for him So he asked you to help him in calculations ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int MOD2 = (int) 1e8 + 7;\nconst int INF = (int) 1e9;\nconst ll LINF = (ll) 1e18;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ll isqrt(ll k) {ll r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\n#define db(x) cerr << #x << "" = "" << (x) << "", "";\n#define endln cerr << ""\\n"";\n\nint sum(long long n) {\n    int res = 0;\n    while (n) {\n        res += n % 10;\n        n /= 10;\n    }\n    return res;\n}\n\nvoid solve() {\n    long long n, s; cin >> n >> s;\n    long long l = 1, r = n + 1;\n    while (l < r) {\n        long long m = l + r >> 1;\n        if (m - sum(m) < s) {\n            l = m + 1;\n        }\n        else {\n            r = m;\n        }\n    }\n    cout << n + 1 - (l + r) / 2 << ""\\n"";\n}\n\nint main() {\n    int JUDGE_ONLINE = 1;\n    if (fopen(""in.txt"", ""r"")) {\n        JUDGE_ONLINE = 0;\n        assert(freopen(""in.txt"", ""r"", stdin));\n        //assert(freopen(""out.txt"", ""w"", stdout));\n    }\n    else {\n        ios_base::sync_with_stdio(0), cin.tie(0);\n    }\n    solve();\n    if (!JUDGE_ONLINE) {\n        //cout << ""\\nTime elapsed: "" << 1000 * clock() / CLOCKS_PER_SEC << ""ms\\n"";\n    }\n    return 0;\n}\n']","[0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Nikita has a stack A stack in this problem is a data structure that supports two operations Operation puts an integer on the top of the stack and operation deletes the top integer from the stack i e the last added If the stack is empty then the operation does nothing Nikita made operations with the stack but forgot them Now Nikita wants to remember them He remembers them one by one on the th step he remembers an operation he made th In other words he remembers the operations in order of some permutation After each step Nikita wants to know what is the integer on the top of the stack after performing the operations he have already remembered in the corresponding order Help him ,"['#include <cstdio>\n#include <algorithm>\n\nconst int o = 1 << 17;\n\nusing namespace std;\n\nstruct node {\n\tint sum, min;\n} IT[1 << 18];\nint a[100001];\n\nint main() {\n\tint i, j, k, l, n, t;\n\tscanf(""%d"", &n);\n\twhile (n--) {\n\t\tscanf(""%d%d"", &i, &j);\n\t\tif (j) {\n\t\t\tscanf(""%d"", &k);\n\t\t\ta[i] = k;\n\t\t\tl = i + o;\n\t\t\tIT[l].sum = 1;\n\t\t\twhile (l >>= 1) {\n\t\t\t\tIT[l].sum = IT[l << 1].sum + IT[l << 1 | 1].sum;\n\t\t\t\tIT[l].min = min(IT[l << 1].min, IT[l << 1].sum + IT[l << 1 | 1].min);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tl = i + o;\n\t\t\tIT[l].sum = -1;\n\t\t\twhile (l >>= 1) {\n\t\t\t\tIT[l].sum = IT[l << 1].sum + IT[l << 1 | 1].sum;\n\t\t\t\tIT[l].min = min(IT[l << 1].min, IT[l << 1].sum + IT[l << 1 | 1].min);\n\t\t\t}\n\t\t}\n\t\tl = 1;\n\t\tt = IT[1].sum - 1;\n\t\tif (IT[1].min > t) {\n\t\t\tputs(""-1"");\n\t\t\tcontinue;\n\t\t}\n\t\twhile (l < o) {\n\t\t\tif (IT[l << 1].sum + IT[l << 1 | 1].min > t) l = l << 1;\n\t\t\telse {\n\t\t\t\tt -= IT[l << 1].sum;\n\t\t\t\tl = l << 1 | 1;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", a[l - o]);\n\t}\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Little Chris is participating in a graph cutting contest He s a pro The time has come to test his skills to the fullest Chris is given a simple undirected connected graph with vertices numbered from 1 to and edges The problem is to cut it into edge distinct paths of length 2 Formally Chris has to partition all edges of the graph into pairs in such a way that the edges in a single pair are adjacent and each edge must be contained in exactly one pair For example the figure shows a way Chris can cut a graph The first sample test contains the description of this graph You are given a chance to compete with Chris Find a way to cut the given graph or determine that it is impossible ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<string, string> PSS;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<int, lng> PIL;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\n#define hash asdhash\n#define move asdmove\nconst ld EPS = 1e-12;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld DINF = 1e200;\nconst ld PI = 3.1415926535897932384626433832795l;\nint gcd(int a,int b){return a?gcd(b%a,a):b;}\nlng gcd(lng a,lng b){return a?gcd(b%a,a):b;}\nlng powmod(lng a,lng p,lng m){lng r=1;while(p){if(p&1)r=r*a%m;p>>=1;a=a*a%m;}return r;}\n#define TASKA ""sequence""\n\nint n;\nvector<int> gr[110000];\nint D[110000];\nvector<pair<int,PII> > ans;\n\nbool dfs(int v,int d,int pr){\n\tD[v]=d;\n\tint x=-1;\n\tforv(i,gr[v]){\n\t\tint p=gr[v][i];\n\t\tbool t=false;\n\t\tif(D[p]){\n\t\t\tif(p != pr && D[p]<d)\n\t\t\t\tt=true;\n\t\t}else\n\t\t\tt=dfs(p,d+1,v);\n\t\tif(!t)\n\t\t\tcontinue;\n\t\tif(x==-1)\n\t\t\tx=p;\n\t\telse{\n\t\t\tans.pb(mp(p,mp(v,x)));\n\t\t\tx=-1;\n\t\t}\n\t}\n\tif(x!=-1){\n\t\tans.pb(mp(pr,mp(v,x)));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main(){\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#else\n\t//freopen(TASKA"".in"", ""r"", stdin); freopen(TASKA"".out"", ""w"", stdout);\n#endif\n\t\n\tint m;\n\tcin>>n>>m;\n\tforn(i,m){\n\t\tint a,b;\n\t\tscanf(""%d%d"",&a,&b);\n\t\t--a;--b;\n\t\tgr[a].pb(b);\n\t\tgr[b].pb(a);\n\t}\n\tif(!dfs(0,1,-1)){\n\t\tcout<<""No solution"";\n\t\treturn 0;\n\t}\n\tforv(i,ans){\n\t\tprintf(""%d %d %d\\n"",ans[i].X + 1, ans[i].Y.X+1, ans[i].Y.Y+1);\n\t}\n\t\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
Kijin Seija Shinmyoumaru has a mallet that can turn objects bigger or smaller She is testing it out on a sequence a and a number v whose initial value is 1 She wants to make v gcd limits i ne j a i cdot a j by 10 5 operations gcd limits i ne j a i cdot a j denotes the gcd of all products of two distinct elements of the sequence a In each operation she picks a subsequence b of a and does one of the followings v v cdot mathrm lcm b v frac v mathrm lcm b Note that she does need to guarantee that v is an integer that is v does need to be a multiple of mathrm lcm b when performing Reduce Moreover she wants to guarantee that the total length of b chosen over the operations does not exceed 10 6 Fine a possible operation sequence for her ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (int)1e6 + 7;\nint n;\nint a[N];\nint d[N];\nint cntDif[N];\nint c[N][3];\nbool u[N];\n\nvector<pair<vector<int>, int>> getGcd(int ban) {\n\tint g = 0;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tg = gcd(g, a[i]);\n\t}\n\tint gg = 0;\n\tvector<int> w;\n\tfor (int i = 0; i < n; i++) if (i != ban) {\n\t\tint ng = gcd(gg, a[i]);\n\t\tif (ng == gg) continue;\n\t\tif (gg == 0 || cntDif[gg / g] != cntDif[ng / g]) {\n\t\t\tw.push_back(i);\n\t\t}\n\t\tgg = ng;\n\t}\n\tvector<pair<vector<int>, int>> ans;\n\tint sz = (int)w.size();\n\tassert(sz > 0);\n\tfor (int mask = 1; mask < (1 << sz); mask++) {\n\t\tint t = 1;\n\t\tvector<int> cur;\n\t\tfor (int i = 0; i < sz; i++) if ((mask >> i) & 1) {\n\t\t\tt ^= 1;\n\t\t\tcur.push_back(w[i]);\n\t\t}\n\t\tans.push_back(mp(cur, t));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tfor (int x = 2; x < N; x++) {\n\t\tif (d[x] != 0) continue;\n\t\tc[x][0] = 0;\n\t\tc[x][1] = 30;\n\t\tc[x][2] = -1;\n\t\tfor (int y = x; y < N; y += x)\n\t\t\tif (d[y] == 0)\n\t\t\t\td[y] = x;\n\t}\n\tcntDif[1] = 0;\n\tfor (int x = 2; x < N; x++) {\n\t\tint y = x;\n\t\twhile(d[y] == d[x]) y /= d[x];\n\t\tcntDif[x] = cntDif[y] + 1;\n\t}\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", &a[i]);\n\t\tint x = a[i];\n\t\twhile(x > 1) {\n\t\t\tint p = d[x];\n\t\t\tint k = 0;\n\t\t\twhile(x % p == 0) {\n\t\t\t\tx /= p;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\tc[p][0]++;\n\t\t\tif (k < c[p][1]) {\n\t\t\t\tc[p][1] = k;\n\t\t\t\tc[p][2] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int p = 2; p < N; p++) if (d[p] == p) {\n\t\tif (c[p][0] <= n - 2) continue;\n\t\tif (c[p][0] == n - 1) {\n\t\t\tint v = 0;\n\t\t\twhile(a[v] % p == 0) v++;\n\t\t\tu[v] = 1;\n\t\t} else {\n\t\t\tu[c[p][2]] = 1;\n\t\t}\n\t}\n\tvector<int> zz;\n\tfor (int i = 0; i < n; i++)\n\t\tif (u[i])\n\t\t\tzz.push_back(i);\n\tvector<pair<vector<int>, int>> ans;\n\tvector<pair<vector<int>, int>> ans0 = getGcd(-1);\n\tint w = 2 - (int)zz.size();\n\tif (w > 0) {\n\t\tfor (int it = 0; it < w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(z);\n\t} else {\n\t\tfor (int it = 0; it < -w; it++)\n\t\t\tfor (auto z : ans0)\n\t\t\t\tans.push_back(mp(z.first, z.second ^ 1));\n\t}\n\tfor (int x : zz) {\n\t\tans0 = getGcd(x);\n\t\tfor (auto z : ans0)\n\t\t\tans.push_back(z);\n\t}\n\tprintf(""%d\\n"", (int)ans.size());\n\tfor (auto z : ans) {\n\t\tprintf(""%d %d"", z.second, (int)z.first.size());\n\t\tsort(all(z.first));\n\t\tfor (int id : z.first)\n\t\t\tprintf("" %d"", id + 1);\n\t\tprintf(""\\n"");\n\t}\n\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0]",3500
Iahub helps his grandfather at the farm Today he must milk the cows There are cows sitting in a row numbered from to from left to right Each cow is either facing to the left or facing to the right When Iahub milks a cow all the cows that see the current cow get scared and lose one unit of the quantity of milk that they can give A cow facing left sees all the cows with lower indices than her index and a cow facing right sees all the cows with higher indices than her index A cow that got scared once can get scared again and lose one more unit of milk A cow that has been milked once cannot get scared and lose any more milk You can assume that a cow never loses all the milk she can give a cow gives an infinitely amount of milk Iahub can decide the order in which he milks the cows But he must milk each cow exactly once Iahub wants to lose as little milk as possible Print the minimum amount of milk that is lost ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int)(x).size())\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\n\nint main() {\n  #ifdef DEBUG\n  freopen("".in"", ""r"", stdin);\n  freopen("".out"", ""w"", stdout);\n  #endif\n\n  int n;\n  while (scanf(""%d"", &n) >= 1) {\n    vi as(n);\n    for (int i = 0; i < n; i++)\n      scanf(""%d"", &as[i]);\n\n    ll res = 0;\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n      if (as[i] == 1) cnt++;\n      else res += cnt;\n    }\n    printf(""%I64d\\n"", res);\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
You are given n integer numbers a 1 a 2 dots a n Consider graph on n nodes in which nodes i j i neq j are connected if and only if a i AND a j neq 0 where AND denotes the bitwise AND operation Find the length of the shortest cycle in this graph or determine that it doesn t have cycles at all ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\n#include <assert.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n; ll a[SZ];\nint dis[555][555],aa[555][555];\nint main()\n{\n\tmemset(dis,127/4,sizeof dis);\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(""%lld"",a+i);\n\t\tif(!a[i])\n\t\t{\n\t\t\t--n; --i;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif(n>3*64)\n\t{\n\t\tputs(""3"");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif((a[i]&a[j])) dis[i][j]=dis[j][i]=1;\n\tmemcpy(aa,dis,sizeof aa);\n\tint ans=2e9;\n\tfor(int k=1;k<=n;++k)\n\t{\n\t\tfor(int i=1;i<k;++i)\n\t\t\tfor(int j=i+1;j<k;++j)\n\t\t\t\tans=min(ans,aa[i][k]+aa[k][j]+dis[i][j]);\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tfor(int j=1;j<=n;++j)\n\t\t\t\tdis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);\n\t}\n\tif(ans>1e3) ans=-1;\n\tprintf(""%d\\n"",ans);\n}\n']","[0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1]",1900
There are n boxes with different quantities of candies in each of them The i th box has a i candies inside You also have n friends that you want to give the candies to so you decided to give each friend a box of candies But you don t want any friends to get upset so you decided to eat some possibly none candies from each box so that all boxes have the same quantity of candies in them Note that you may eat a different number of candies from different boxes and you cannot add candies to any of the boxes What s the minimum total number of candies you have to eat to satisfy the requirements ,"['#include <iostream>\n\nusing namespace std;\n\nconst int N = 100;\n\nlong long a[N];\n\nint main()\n{\n\tint t;\n\tint n;\n\tint i;\n\tlong long mn;\n\tlong long ans;\n\t\n\tcin >> t;\n\twhile(t --)\n\t{\n\t\tcin >> n;\n\t\tfor(i = 1; i <= n; i ++)\n\t\t\tcin >> a[i];\n\t\t\n\t\tfor(i = 1, mn = 1e7; i <= n; i ++)\n\t\t\tmn = min(mn, a[i]);\n\t\tfor(i = 1, ans = 0; i <= n; i ++)\n\t\t\tans += a[i] - mn;\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given an unweighted tree of n vertices numbered from 1 to n and a list of n 1 integers a 1 a 2 ldots a n 1 A tree is a connected undirected graph without cycles You will use each element of the list to label one vertex No vertex should be labeled twice You can label the only remaining unlabeled vertex with any integer A vertex x is called if it is possible to do this labeling so that for each vertex i its label is the distance between x and i The distance between two vertices s and t on a tree is the minimum number of edges on a path that starts at vertex s and ends at vertex t Find all good vertices ,"['#include <algorithm>\n#include <array>\n#include <iostream>\n#include <random>\n#include <set>\n#include <vector>\n#include <chrono>\nusing namespace std;\n\ntemplate <typename Int = int>\nInt read() {\n  Int s = 1, x = 0;\n  char c = getchar();\n  while (!isdigit(c)) {\n    if (c == \'-\')\n      s = -1;\n    c = getchar();\n  }\n  while (isdigit(c))\n    x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n  return s * x;\n}\n\nconst int P = 1e9 + 7;\n\ntypedef array<int, 10> Hash;\n \nHash operator*(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = 1LL * u[i] * v[i] % P;\n  return t;\n}\n\nHash operator+(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] + v[i]) % P;\n  return t;\n}\n\nHash operator-(const Hash& u, const Hash& v) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] - v[i] + P) % P;\n  return t;\n}\n \nHash Base;\n \nHash mult_base(const Hash& u) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (1LL * u[i] * Base[i]) % P;\n  return t;\n}\n\nHash add_one(const Hash& u) {\n  Hash t;\n  for (int i = 0; i < 10; i++)\n    t[i] = (u[i] + 1) % P;\n  return t;\n}\n\nmt19937 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\n \nint gen_base() {\n  static uniform_int_distribution<int> d(258, P - 1);\n  int b = d(rng);\n  return b % 2 == 0 ? b - 1 : b;\n}\n\nconst int N = 2e5;\n\nHash sub[N];\nvector<int> g[N];\n\nvoid dfs1(int p, int i) {\n  for (int j : g[i])\n    if (p != j) {\n      dfs1(i, j);\n      sub[i] = sub[i] + sub[j];\n    }\n  sub[i] = add_one(mult_base(sub[i]));\n}\n\nHash root[N];\n\nvoid dfs2(int p, int i, Hash up) {\n  root[i] = sub[i] + mult_base(up);\n  Hash all = up;\n  for (int j : g[i])\n    if (p != j)\n      all = all + sub[j];\n  for (int j : g[i])\n    if (p != j) {\n      Hash tmp = add_one(mult_base(all - sub[j]));\n      dfs2(i, j, tmp);\n    }\n}\n\nint main() {\n  for (int i = 0; i < 10; i++)\n    Base[i] = gen_base();\n  static int c[N];\n  int n = read();\n  for (int i = 0; i < n - 1; i++)\n    c[read()]++;\n  for (int h = 0; h < n - 1; h++) {\n    int i = read() - 1, j = read() - 1;\n    g[i].push_back(j), g[j].push_back(i);\n  }\n  dfs1(-1, 0);\n  Hash h;\n  fill(h.begin(), h.end(), 0);\n  dfs2(-1, 0, h);\n  Hash rn, pw;\n  for (int i = 0; i < 10; i++)\n    rn[i] = 0, pw[i] = 1;\n  for (int i = 0; i < n; i++) {\n    while (c[i]--)\n      rn = rn + pw;\n    pw = mult_base(pw);\n  }\n  set<Hash> ok;\n  for (int i = 0; i < 10; i++)\n    pw[i] = 1;\n  for (int i = 0; i < n; i++) {\n    ok.insert(pw + rn);\n    pw = mult_base(pw);\n  }\n  vector<int> ans;\n  for (int i = 0; i < n; i++)\n    if (ok.count(root[i]))\n      ans.push_back(i);\n  printf(""%d\\n"", (int) ans.size());\n  sort(ans.begin(), ans.end());\n  for (int i : ans)\n    printf(""%d "", i + 1);\n  printf(""\\n"");\n  return 0;\n}']","[1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2400
One day Petya was solving a very interesting problem But although he used many optimization techniques his solution still got Time limit exceeded verdict Petya conducted a thorough analysis of his program and found out that his function for finding maximum element in an array of positive integers was too slow Desperate Petya decided to use a somewhat unexpected optimization using parameter so now his function contains the following code int fast max int n int a int ans 0 int offset 0 for int i 0 i n i if ans a i ans a i offset 0 else offset offset 1 if offset k return ans return ans That way the function iteratively checks array elements storing the intermediate maximum and if after consecutive iterations that maximum has not changed it is returned as the answer Now Petya is interested in fault rate of his function He asked you to find the number of permutations of integers from to such that the return value of his function on those permutations is not equal to Since this number could be very big output the answer modulo ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 2000228;\n\n\nconst ll MOD = 1000 * 1000 * 1000 + 7;\n\nll rev(ll a, int b = MOD - 2) {\n    if (b == 0) {\n        return 1;\n    }\n\n    ll v = rev(a, b / 2);\n    v = (v * v) % MOD;\n    if (b & 1) {\n        v = (v * a) % MOD;\n    }\n\n    return v;\n}\n\nll f[MAXN];\nll fct[MAXN];\nll rfct[MAXN];\n\nll cnk(int x, int y) {\n    return fct[x + y] * rfct[x] % MOD * rfct[y] % MOD;\n}\n\nint main() {\n#ifdef PAUNSVOKNO\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    int n, k;\n    cin >> n >> k;\n    fct[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        fct[i] = (fct[i - 1] * i) % MOD;\n    }\n\n    rfct[n] = rev(fct[n]);\n    for (int i = n; i > 0; --i) {\n        rfct[i - 1] = (rfct[i] * i) % MOD;\n    }\n    \n    ll mulall = 1;\n    ll ans = fct[n - 1];\n\n\n    ll sum = 0;\n    f[0] = 1;\n    sum = 0;\n\n    for (int i = 1; i < n; ++i) {\n        sum = (sum + f[i - 1]) % MOD;\n        ll cf = sum * mulall % MOD;\n        ans += cf * fct[n - 1] % MOD * rfct[i] % MOD;\n        ans %= MOD;\n        mulall = (mulall * i) % MOD;\n        f[i] = (rev(mulall) * cf) % MOD;\n        if (i >= k) {\n            sum = (sum - f[i - k] + MOD) % MOD;\n        }\n    }\n\n    cout << (fct[n] - ans + MOD) % MOD;\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
You are given a sequence a 1 a 2 dots a n consisting of n pairwise distinct positive integers Find left lfloor frac n 2 right rfloor different pairs of integers x and y such that x neq y x and y appear in a x mod y doesn t appear in a Note that some x or y can belong to multiple pairs lfloor x rfloor denotes the floor function the largest integer less than or equal to x x mod y denotes the remainder from dividing x by y If there are multiple solutions print any of them It can be shown that at least one solution always exists ,"['#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tgenerate(all(a), nxt);\n\tsort(all(a));\n\tfor (int i = 0; i < n / 2; ++i) {\n\t\tcout << a[i + 1] << "" "" << a[0] << ""\\n"";\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Polycarpus has a finite sequence of opening and closing brackets In order not to fall asleep in a lecture Polycarpus is having fun with his sequence He is able to perform two operations adding any bracket in any position in the beginning the end or between any two existing brackets cyclic shift moving the last bracket from the end of the sequence to the beginning Polycarpus can apply any number of operations to his sequence and adding a cyclic shift in any order As a result he wants to get the correct bracket sequence of the minimum possible length If there are several such sequences Polycarpus is interested in the lexicographically smallest one Help him find such a sequence A is a sequence of opening and closing brackets from which you can get a correct arithmetic expression by adding characters 1 and Each opening bracket must correspond to a closed one For example the sequences are correct and and are not The sequence is lexicographically smaller than sequence if there is such number from to that for and Consider that ,"['#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define TRACE(x) cout << #x << "" = "" << x << endl\n#define _ << "" _ "" <<\n\ntypedef long long llint;\n\nconst int MAXN = 2000200;\nconst int off = 1<<21;\nconst int mod = 1e9 + 9;\nconst int H = 9973;\n\ninline int add(int a, int b) {\n  return a+b >= mod ? a+b-mod : a+b;\n}\n\ninline int sub(int a, int b) {\n  return a >= b ? a-b : a-b+mod;\n}\n\ninline int mul(int a, int b) {\n  return llint(a)*b % mod;\n}\n\nint h[MAXN], pw[MAXN];\n\nstruct data {\n  int op, cl;\n} T[2*off];\n\ndata operator + (const data &a, const data &b) {\n  int m = min(a.op, b.cl);\n  return {a.op + b.op - m, a.cl + b.cl - m};\n}\ndata dummy = {0, 0};\n\ndata query(int i, int lo, int hi, int a, int b) {\n  if (lo >= b || hi <= a) return dummy;\n  if (lo >= a && hi <= b) return T[i];\n  return query(i*2, lo, (lo+hi)/2, a, b) + query(i*2+1, (lo+hi)/2, hi, a, b);\n}\n\nchar s[MAXN];\n\ninline int get_hash(int i, int len) {\n  return sub(h[i + len], mul(h[i], pw[len]));\n}\n\nbool cmp(int i, int j, int len) {\n  int lo = 0, hi = len;\n  while (lo < hi) {\n    int mid = (lo + hi + 1) / 2;\n    if (get_hash(i, mid) == get_hash(j, mid)) lo = mid; else\n      hi = mid - 1;\n  }\n\n  return s[i + lo] == \'(\';\n}\n\nint main(void) {\n  scanf(""%s"", s);\n  int n = strlen(s);\n  REP(i, n) s[n+i] = s[i];\n  \n  pw[0] = 1;\n  h[0] = 0;\n  REP(i, 2*n) {\n    h[i+1] = add(mul(h[i], H), s[i]);\n    pw[i+1] = mul(pw[i], H);\n  }\n\n  FOR(i, off, 2*off)\n    if (i-off < 2*n) {\n      if (s[i-off] == \'(\') T[i] = {1, 0}; else\n        T[i] = {0, 1};\n    } else \n      T[i] = dummy;\n  \n  for (int i = off-1; i > 0; --i)\n    T[i] = T[i*2] + T[i*2+1];\n  \n  int best = 4*n;\n  int bestop = -1;\n  int bestcl = -1;\n  int ind = -1;\n  \n  REP(i, n) {\n    data a = query(1, 0, off, i, i + n);\n    int len = n + a.op + a.cl;\n    if (len < best || (len == best && cmp(i, ind, n))) {\n      best = len;\n      bestop = a.op;\n      bestcl = a.cl;\n      ind = i;\n    }\n  }\n  \n  REP(i, bestcl) putchar(\'(\');\n  REP(i, n) putchar(s[ind + i]);\n  REP(i, bestop) putchar(\')\');\n  putchar(\'\\n\');\n  return 0;\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2700
Two large companies Cecsi and Poca Pola are fighting against each other for a long time In order to overcome their competitor Poca Pola started a super secret project for which it has total n vacancies in all of their offices After many tests and interviews n candidates were selected and the only thing left was their employment Because all candidates have the same skills it doesn t matter where each of them will work That is why the company decided to distribute candidates between workplaces so that the total distance between home and workplace over all candidates is minimal It is well known that Earth is round so it can be described as a circle and all m cities on Earth can be described as points on this circle All cities are enumerated from 1 to m so that for each i 1 le i le m 1 cities with indexes i and i 1 are neighbors and cities with indexes 1 and m are neighbors as well People can move only along the circle The distance between any two cities equals to minimal number of transitions between neighboring cities you have to perform to get from one city to another In particular the distance between the city and itself equals 0 The Poca Pola vacancies are located at offices in cities a 1 a 2 ldots a n The candidates live in cities b 1 b 2 ldots b n It is possible that some vacancies are located in the same cities and some candidates live in the same cities The Poca Pola managers are too busy with super secret project so you were asked to help Poca Pola to distribute candidates between workplaces so that the sum of the distance between home and workplace over all candidates is minimum possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nint m,n,mat[N];\nPII p[N],q[N];\nll cc[N];\n\nvoid add(PII *q,int i,int l,int r,int v,int ty=0) {\n\tint pl=lower_bound(q,q+n,mp(l,-1))-q;\n\tint pr=lower_bound(q,q+n,mp(r+1,-1))-q-1;\n//\tprintf(""gg %d %d\\n"",pl,pr);\n\tif (pl>pr) return;\n\tif (ty==0) {\n\t\tpl-=i; pr-=i; \n\t} else {\n\t\tswap(pl,pr); pl=i-pl; pr=i-pr;\n\t}\n//\tprintf(""add %d %d %d\\n"",pl,pr,v);\n\tif (pl>=0&&pr>=0) cc[pl]+=v,cc[pr+1]-=v;\n\telse if (pl<0&&pr<0) cc[pl+n]+=v,cc[pr+1+n]-=v;\n\telse {\n\t\tcc[pl+n]+=v; cc[n]-=v;\n\t\tcc[0]+=v; cc[pr+1]-=v;\n\t}\n}\n\nint main() {\n\tscanf(""%d%d"",&m,&n);\n\trep(i,0,n) scanf(""%d"",&p[i].fi),p[i].se=i;\n\trep(i,0,n) scanf(""%d"",&q[i].fi),q[i].se=i;\n\tsort(p,p+n); sort(q,q+n);\n\trep(i,0,n) {\n\t\tadd(q,i,p[i].fi-m,p[i].fi-m/2-1,m-p[i].fi);\n\t\tadd(q,i,p[i].fi-m/2,p[i].fi-1,p[i].fi);\n\t\tadd(q,i,p[i].fi,p[i].fi+m/2,-p[i].fi);\n\t\tadd(q,i,p[i].fi+m/2+1,p[i].fi+m,p[i].fi+m);\n\t}\n\trep(i,0,n) {\n\t\tadd(p,i,q[i].fi-m,q[i].fi-m/2-1,-q[i].fi,1);\n\t\tadd(p,i,q[i].fi-m/2,q[i].fi,q[i].fi,1);\n\t\tadd(p,i,q[i].fi+1,q[i].fi+m/2,-q[i].fi,1);\n\t\tadd(p,i,q[i].fi+m/2+1,q[i].fi+m,q[i].fi,1);\n\t}\n\trep(i,1,n+1) cc[i]+=cc[i-1];\n\tint md=min_element(cc,cc+n)-cc;\n\trep(i,0,n) mat[p[i].se]=q[(i+md)%n].se;\n\tprintf(""%lld\\n"",cc[md]);\n\trep(i,0,n) printf(""%d%c"",mat[i]+1,"" \\n""[i==n-1]);\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
You are playing a computer game To pass the current level you have to kill a big horde of monsters In this horde there are n monsters standing in the row numbered from 1 to n The i th monster has a i health and a special Death s Blessing spell of strength b i attached to it You are going to kill all of them It takes exactly h seconds to kill a monster with health h When the i th monster dies it casts its spell that increases the health of its by b i the neighbors of the j th monster in the row are the monsters on places j 1 and j 1 The first and the last monsters have only one neighbor each After each monster is killed the row shrinks so its former neighbors become adjacent to each other so if one of them dies the other one is affected by its spell For example imagine a situation with 4 monsters with health a 2 6 7 3 and spells b 3 6 0 5 One of the ways to get rid of the monsters is shown below 2673 xrightarrow 6 s 8133 xrightarrow 13 s 83 xrightarrow 8 s 6 xrightarrow 6 s 3605305355 As a result we can kill all monsters in 6 13 8 6 33 seconds Note that it s only an example and may not be the fastest way to get rid of the monsters What is the minimum time required to kill all monsters in the row ,"['//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << "" "" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<""Yes""<<endl;else cout<<""No""<<endl;}\nvoid ans2(bool x){if(x) cout<<""YES""<<endl;else cout<<""NO""<<endl;}\nvoid ans3(bool x){if(x) cout<<""Yay!""<<endl;else cout<<"":(""<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv="" ""){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv="" ""){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<""[""<<z.first<<""]=""<<z.second<<"","";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << "" "" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << "" "";cout<<""|""; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll t;cin>>t;\n  while(t--){\n    ll n;cin>>n;\n    vector<ll>a(n),b(n);\n    rep(i,0,n)cin>>a[i];\n    rep(i,0,n)cin>>b[i];\n    cout<<acc(b)+acc(a)-max(b)<<endl;\n\n  }\n  return 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
While walking down the street Vanya saw a label Hide Seek Because he is a programmer he used as a bitwise AND for these two words represented as a integers in base and got new word Now Vanya thinks of some string and wants to know the number of pairs of words of length length of such that their bitwise AND is equal to As this number can be large output it modulo To represent the string as a number in numeral system with base Vanya uses the following rules digits from to correspond to integers from to letters from to correspond to integers from to letters from to correspond to integers from to letter correspond to integer letter correspond to integer ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint n,h,k;\nint a[1000000];\nlong long ans;\nlong long cnt[1000];\nstring s;\n\nint make(char q)\n{\n    if(q==\'-\')\n        return 62;\n    if(q==\'_\')\n        return 63;\n    if(q>=\'0\' && q<=\'9\')\n        return q-\'0\';\n    else\n    if(q>=\'A\' && q<=\'Z\')\n        return 10+q-\'A\';\n    else\n    if(q>=\'a\' && q<=\'z\')\n    {\n        return 10+\'z\'-\'a\'+1+q-\'a\';\n    }\n}\n\nint main()\n{\n    for(int i=0;i<64;i++)\n        for(int j=0;j<64;j++)\n            cnt[i&j]++;\n    cin>>s;\n    long long ans=1;\n    const int md=1e9+7;\n    for(int i=0;i<s.size();i++)\n    {\n        int cur=make(s[i]);\n        ans=(ans*cnt[cur])%md;\n    }\n    cout<<ans<<""\\n"";\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0]",1500
Comrade Dujikov is busy choosing artists for Timofey s birthday and is recieving calls from Taymyr from Ilia alpinist Ilia alpinist calls every minutes i e in minutes and so on Artists come to the comrade every minutes i e in minutes and so on The day is minutes long i e the day consists of minutes How many artists should be killed so that there are no artists in the room when Ilia calls Consider that a call and a talk with an artist take exactly one minute ,"['//It is made by ljh2000\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <ctime>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <complex>\nusing namespace std;\n\nint vis[1000010];\n\ninline int getint(){\n    int w=0,q=0; char c=getchar(); while((c<\'0\'||c>\'9\') && c!=\'-\') c=getchar();\n    if(c==\'-\') q=1,c=getchar(); while (c>=\'0\'&&c<=\'9\') w=w*10+c-\'0\',c=getchar(); return q?-w:w;\n}\n\nint main() {\n\tint n,m,z;\n\tscanf(""%d%d%d"",&n,&m,&z);\n\tfor (int i=n;i<=z;i+=n) \n\t    vis[i]=1;\n\tint ans=0;\n\tfor (int i=m;i<=z;i+=m) \n\t    if (vis[i]) ans++;\n\tprintf(""%d"",ans);\n\treturn 0;\n}\n']","[0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array There are n n cdot n 1 cdot n 2 cdot ldots cdot 1 different permutations of length n Given a permutation p of n numbers we create an array a consisting of 2n numbers which is equal to p concatenated with its reverse We then define the beauty of p as the number of inversions in a The number of inversions in the array a is the number of pairs of indices i j such that i j and a i a j For example for permutation p 1 2 a would be 1 2 2 1 The inversions in a are 2 4 and 3 4 assuming 1 based indexing Hence the beauty of p is 2 Your task is to find the sum of beauties of all n permutations of size n Print the remainder we get when dividing this value by 1 000 000 007 10 9 7 ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nnamespace _fac\n{\n\ttypedef unsigned int ui;\n\ttypedef unsigned long long ll;\n\tconst int N=1e6+2;\n\tconst ll p=1e9+7;\n\tll fac[N];\n\tll ifac[N];\n\tll inv[N];\n\tll ksm(ll x,int y)\n\t{\n\t\tll r=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) r=(ll)r*x%p;\n\t\t\tx=(ll)x*x%p;\n\t\t\ty>>=1;\n\t\t}\n\t\treturn r;\n\t}\n\tll C(int n,int m)\n\t{\n\t\tif (n<m||m<0) return 0;\n\t\treturn (ll)fac[n]*ifac[m]%p*ifac[n-m]%p;\n\t}\n\tvoid init_fac()\n\t{\n\t\tint i;\n\t\tfac[0]=1;\n\t\tfor (i=1; i<N; i++) fac[i]=(ll)fac[i-1]*i%p;\n\n\t\tifac[N-1]=ksm(fac[N-1],p-2);\n\t\tfor (i=N-1; i; i--) ifac[i-1]=(ll)ifac[i]*i%p;\n\n\t\tll x; inv[1]=1;\n\t\tfor (i=2; i<N; i++)\n\t\t{\n\t\t\tx=p/i;\n\t\t\tinv[i]=(ll)x*(p-inv[p-x*i])%p;\n\t\t}\n\t}\n}\nusing _fac::init_fac; using _fac::fac; using _fac::ifac; using _fac::inv;\nusing _fac::ksm; using _fac::C; using _fac::p;\n\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tinit_fac();\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n;\n\t\tcout<<fac[n]*C(n,2)*2%p<<\'\\n\';\n\t}\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",900
Hanh is a famous biologist He loves growing trees and doing experiments on his own garden One day he got a tree consisting of n vertices Vertices are numbered from 1 to n A tree with n vertices is an undirected connected graph with n 1 edges Initially Hanh sets the value of every vertex to 0 Now Hanh performs q operations each is either of the following types Type 1 Hanh selects a vertex v and an integer d Then he chooses some vertex r lists all vertices u such that the path from r to u passes through v Hanh then increases the value of all such vertices u by d Type 2 Hanh selects a vertex v and calculates the expected value of v Since Hanh is good at biology but not math he needs your help on these operations ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace __gnu_pbds;\nusing namespace std;\n \ntemplate <typename T>\nusing ordered_set =\n\ttree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n \n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n\t*this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n \n#define shandom_ruffle random_shuffle\n \nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e18;\nconst ll mod=998244353;\n\nint n, q;\n\nvi graf[nax];\nint pre[nax];\nint post[nax];\nint czas;\n\nint roz[nax];\n\nvector <pair<int,pii> > waz[nax];\n\nll dziel(ll a, ll b)\n{\n\ta%=mod;\n\tb%=mod;\n\tll wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\ta=(a*b)%mod;\n\t\tb=(b*b)%mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nll drz[nax];\n\nvoid dod(int a, int b, ll w)\n{\n\tw%=mod;\n\tfor (int i=a; i<=n; i+=(i&(-i)))\n\t\tdrz[i]+=w;\n\tfor (int i=b+1; i<=n; i+=(i&(-i)))\n\t\tdrz[i]-=w;\n}\n\nll czyt(int v)\n{\n\tll ret=0;\n\tfor (int i=v; i; i-=(i&(-i)))\n\t\tret+=drz[i];\n\tret%=mod;\n\tif (ret<0)\n\t\tret+=mod;\n\treturn ret;\n}\n\nvoid dfs1(int v, int oj)\n{\n\troz[v]=1;\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t\tcontinue;\n\t\tdfs1(i, v);\n\t\troz[v]+=roz[i];\n\t}\n}\n\nbool mniej(int a, int b)\n{\n\treturn roz[a]<roz[b];\n}\n\nvoid dfs2(int v, int oj)\n{\n\tsort(graf[v].begin(), graf[v].end(), mniej);\n\tif (!graf[v].empty() && graf[v].back()==oj)\n\t\tgraf[v].pop_back();\n\tczas++;\n\tpre[v]=czas;\n\tfor (int i : graf[v])\n\t\tdfs2(i, v);\n\tpost[v]=czas;\n\t\n\tif (v!=1)\n\t{\n\t\twaz[v].push_back({n-roz[v], {1, pre[v]-1}});\n\t\twaz[v].push_back({n-roz[v], {post[v]+1, n}});\n\t}\n\tint g;\n\tfor (int i=0; i<(int)graf[v].size(); i=g)\n\t{\n\t\tg=i;\n\t\twhile(g<(int)graf[v].size() && roz[graf[v][i]]==roz[graf[v][g]])\n\t\t\tg++;\n\t\twaz[v].push_back({roz[graf[v][i]], {pre[graf[v][i]], post[graf[v][g-1]]}});\n\t}\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tdfs1(1, 0);\n\tdfs2(1, 0);\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ debug() << pre[i] << "" "" << waz[i];\n\tll dzn=dziel(1, n);\n\twhile(q--)\n\t{\n\t\tint typ;\n\t\tscanf(""%d"", &typ);\n\t\tif (typ==1)\n\t\t{\n\t\t\tint v;\n\t\t\tll d;\n\t\t\tscanf(""%d%lld"", &v, &d);\n\t\t\tdod(1, n, n*d);\n\t\t\tfor (const auto i : waz[v])\n\t\t\t\tdod(i.second.first, i.second.second, -i.first*d);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(""%d"", &v);\n\t\t\tll x=czyt(pre[v]);\n\t\t\tx%=mod;\n\t\t\tx+=mod;\n\t\t\tx%=mod;\n\t\t\tprintf(""%lld\\n"", (x*dzn)%mod);\n\t\t}\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2700
Dreamoon likes to play with sets integers and is defined as the largest positive integer that divides both and Let be a set of exactly four distinct integers greater than Define to be of rank if and only if for all pairs of distinct elements from Given and Dreamoon wants to make up sets of rank using integers from to such that no integer is used in two different sets of course you can leave some integers without use Calculate the minimum that makes it possible and print one possible solution ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nint n,k;\nint main() {\n\tscanf(""%d%d"",&n,&k);\n\tprintf(""%d\\n"",(6*n-1)*k);\n\trep(i,0,n) {\n\t\tprintf(""%d %d %d %d\\n"",(6*i+1)*k,(6*i+2)*k,(6*i+3)*k,(6*i+5)*k);\n\t}\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Every December VK traditionally holds an event for its employees named Secret Santa Here s how it happens n employees numbered from 1 to n take part in the event Each employee i is assigned a different employee b i to which employee i has to make a new year gift Each employee is assigned to exactly one other employee and nobody is assigned to themselves but two employees may be assigned to each other Formally all b i must be distinct integers between 1 and n and for any i b i ne i must hold The assignment is usually generated randomly This year as an experiment all event participants have been asked who they wish to make a gift to Each employee i has said that they wish to make a gift to employee a i Find a valid assignment b that maximizes the number of fulfilled wishes of the employees ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        \n        int ans = 0;\n        std::vector<int> a(n), b(n, -1), c(n, -1);\n        for (int i = 0; i < n; i++) {\n            std::cin >> a[i];\n            a[i]--;\n            if (c[a[i]] < 0) {\n                b[i] = a[i];\n                c[a[i]] = i;\n                ans++;\n            }\n        }\n        \n        std::vector<int> u, v;\n        for (int i = 0; i < n; i++) {\n            if (c[i] >= 0) {\n                continue;\n            }\n            int j = i;\n            while (b[j] >= 0) {\n                j = b[j];\n            }\n            u.push_back(i);\n            v.push_back(j);\n        }\n        \n        if (!u.empty()) {\n            if (u.size() > 1 || u[0] != v[0]) {\n                for (int i = 0; i < int(u.size()); i++) {\n                    b[v[i]] = u[(i + 1) % u.size()];\n                }\n            } else {\n                int x = u[0];\n                int y = a[x];\n                b[x] = y;\n                b[c[y]] = x;\n            }\n        }\n        \n        std::cout << ans << ""\\n"";\n        for (int i = 0; i < n; i++) {\n            std::cout << b[i] + 1 << "" \\n""[i == n - 1];\n        }\n    }\n    \n    return 0;\n}']","[1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
You ve got an array consisting of integers Your task is to find a minimal by inclusion segment such that among numbers there are exactly distinct numbers Segment are integers of length satisfying the given property is called if there is no segment satisfying the property and less then in length such that Note that the segment doesn t have to be minimal in length among all segments satisfying the given property ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\n#define Eo(x) {cerr << #x << "" = "" << (x) << endl;}\n#define E(x) {cerr << #x << "" = "" << (x) << \' \';}\n\nusing namespace std;\nmap<int,int> cnt;\nconst int N = 100005;\nint ar[N];\n\nint main(){\n\tint n, k;\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=0; i<n; ++i) scanf(""%d"", ar+i);\n\n\tint l, r;\n\tfor (r = 0; r<n; ++r){\n\t\t++cnt[ar[r]];\n\t\tif (cnt.size() >= k) break;\n\t}\n\tif (cnt.size() < k){\n\t\tprintf(""%d %d\\n"", -1, -1);\n\t\treturn 0;\n\t}\n\tfor (l = 0; l<r; ++l){\n\t\tif (cnt[ar[l]] == 1) break;\n\t\t--cnt[ar[l]];\n\t}\n\tprintf(""%d %d\\n"", l+1, r+1);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0]",1500
A has a string consisting of some number of lowercase English letters He gives it to his friend B who appends some number of letters to the end of this string Since both A and B like the characters and they have made sure that at this point exist in the string B now gives this string to C and he appends some number of letters to the end of the string However since C is a good friend of A and B the number of letters he appends is equal to the number of or to the number of in the string It is also possible that the number of letters equals both to the number of letters and to the number of letters at the same time You have a string in your hands and you want to check if it is possible to obtain the string in this way or not If it is possible to obtain the string print otherwise print without the quotes ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nchar s[50100];\nint n,cnt[10];\nint main() {\n\tscanf(""%s"",s);\n\tn=strlen(s);\n\trep(i,0,n-1) {\n\t\tif (s[i]>s[i+1]) {\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\trep(i,0,n) cnt[s[i]-\'a\']++;\n\tif (cnt[0]>=1&&cnt[1]>=1&&(cnt[2]==cnt[0]||cnt[2]==cnt[1])) {\n\t\tputs(""YES"");\n\t} else puts(""NO"");\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You have n chains the i th chain consists of c i vertices Vertices in each chain are numbered independently from 1 to c i along the chain In other words the i th chain is the undirected graph with c i vertices and c i 1 edges connecting the j th and the j 1 th vertices for each 1 le j c i Now you decided to unite chains in one graph in the following way the first chain is skipped the 1 st vertex of the i th chain is connected by an edge with the a i th vertex of the i 1 th chain the last c i th vertex of the i th chain is connected by an edge with the b i th vertex of the i 1 th chain Calculate the length of the longest simple cycle in the resulting graph A is a chain where the first and last vertices are connected as well If you travel along the simple cycle each vertex of this cycle will be visited exactly once ,"[""#include<bits/stdc++.h>\nusing namespace std;\n//dengyaotriangle!\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        vector<int> a(n),b(n),c(n);\n        for(int i=0;i<n;i++)cin>>c[i];\n        for(int i=0;i<n;i++)cin>>a[i];\n        for(int i=0;i<n;i++)cin>>b[i];\n        long long cl=0;\n        long long ans=0;\n        for(int i=1;i<n;i++){\n            if(a[i]==b[i]){\n                cl=2;\n            }else{\n                if(cl==0)cl=abs(a[i]-b[i])+2;\n                else cl=max(cl+2+c[i-1]-1-abs(a[i]-b[i]),abs(a[i]-b[i])+2ll);\n            }\n            ans=max(ans,cl+c[i]-1);\n        }\n        cout<<ans<<'\\n';\n    }\n    return 0;\n}""]","[1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
You still have partial information about the score during the historic football match You are given a set of pairs a i b i indicating that at some point during the match the score was a i b i It is known that if the current score is x y then after the goal it will change to x 1 y or x y 1 What is the largest number of times a draw could appear on the scoreboard The pairs a i b i are given in chronological order time increases but you are given score only for some moments of time The last pair corresponds to the end of the match ,"['/**************************************************************\n    Problem: ????\n    User: Big_Red_Dates\n    Language: GNU_C++11\n    Result: Accepted\n    Time:0 ms\n    Memory:0 kb\n    length:0 kb\n    score: inf\n****************************************************************/\n//CLOCKS_PER_SEC\nusing namespace std;\n#include<bitset>\n#include<deque>\n#include<stdint.h>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<ctime>\n#include<map>\n#define sqr(x) (x)*(x)\n#define sort stable_sort\n#define ll long long\n#define mk make_pair\n#define pb push_back\n#define in insert\n#define mtr(x,y,z) mk(mk(x,y),z)\n#define fi first\n#define se second\n#define lch(x) ((x)<<1)\n#define rch(x) (((x)<<1)|1)\n#define all(x) (x).begin(),(x).end()\n#define titose CLOCKS_PER_SEC\n#define fpi(x) freopen(x,""r"",stdin);\n#define fpo(x) freopen(x,""w"",stdout);\n#define fprio fpi(""in.txt"");fpo(""out.txt"");\n#define fast ios_base::sync_with_stdio(false);\ninline void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!=\'-\') c=getchar();if (c==\'-\') f=-1; else v=v*10+c-\'0\';while (isdigit(c=getchar())) v=v*10+c-\'0\';x=v*f;}\ninline void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!=\'-\') c=getchar();if (c==\'-\') f=-1; else v=v*10+c-\'0\';while (isdigit(c=getchar())) v=v*10+c-\'0\';x=v*f;}\ninline void readc(char &x){char c;while ((c=getchar())==\' \');x=c;}\ninline void writes(string s){puts(s.c_str());}\ninline void writeln(){writes("""");}\ninline void writei(int x){if (x<0){putchar(\'-\');x=abs(x);}if (!x) putchar(\'0\');char a[25];int top=0;while (x){a[++top]=(x%10)+\'0\';x/=10;}while (top){putchar(a[top]);top--;}}\ninline void writell(ll x){if (x<0){putchar(\'-\');x=abs(x);}if (!x) putchar(\'0\');char a[25];int top=0;while (x){a[++top]=(x%10)+\'0\';x/=10;}while (top){putchar(a[top]);top--;}}\n/*\n#pragma GCC optimize(""-funsafe-loop-optimizations"")\n#pragma GCC optimize(""-funroll-loops"")\n#pragma GCC optimize(""-fwhole-program"")\n#pragma GCC optimize(""Ofast,no-stack-protector"")\n#pragma GCC optimize(""-fthread-jumps"")\n#pragma GCC optimize(""-falign-functions"")\n#pragma GCC optimize(""-falign-jumps"")\n#pragma GCC optimize(""-falign-loops"")\n#pragma GCC optimize(""-falign-labels"")\n#pragma GCC optimize(""-fcaller-saves"")\n#pragma GCC optimize(""-fcrossjumping"")\n#pragma GCC optimize(""-fcse-follow-jumps"")\n#pragma GCC optimize(""-fcse-skip-blocks"")\n#pragma GCC optimize(""-fdelete-null-pointer-checks"")\n#pragma GCC optimize(""-fdevirtualize"")\n#pragma GCC optimize(""-fexpensive-optimizations"")\n#pragma GCC optimize(""-fgcse"")\n#pragma GCC optimize(""-fgcse-lm"")\n#pragma GCC optimize(""-fhoist-adjacent-loads"")\n#pragma GCC optimize(""-finline-small-functions"")\n#pragma GCC optimize(""-findirect-inlining"")\n#pragma GCC optimize(""-fipa-sra"")\n#pragma GCC optimize(""-foptimize-sibling-calls"")\n#pragma GCC optimize(""-fpartial-inlining"")\n#pragma GCC optimize(""-fpeephole2"")\n#pragma GCC optimize(""-freorder-blocks"")\n#pragma GCC optimize(""-freorder-functions"")\n#pragma GCC optimize(""-frerun-cse-after-loop"")\n#pragma GCC optimize(""-fsched-interblock"")\n#pragma GCC optimize(""-fsched-spec"")\n#pragma GCC optimize(""-fschedule-insns"")\n#pragma GCC optimize(""-fschedule-insns2"")\n#pragma GCC optimize(""-fstrict-aliasing"")\n#pragma GCC optimize(""-fstrict-overflow"")\n#pragma GCC optimize(""-ftree-switch-conversion"")\n#pragma GCC optimize(""-ftree-tail-merge"")\n#pragma GCC optimize(""-ftree-pre"")\n#pragma GCC optimize(""-ftree-vrp"")\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(4)\n#pragma GCC optimize(5)\n#pragma GCC optimize(6)\n#pragma GCC optimize(7)\n#pragma GCC optimize(8)\n#pragma GCC optimize(9)\n*/\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define vi vector<int>\n#define vl vector<ll>\n#define si set<int>\n#define sl set<ll>\n#define mii map<int,int>\n#define mll map<ll,ll>\n#define msi map<string,int>\n#define msl map<string,ll>\n#define piii pair<int,pii >\n#define piipi pair<pii,int>\n#define plll pair<ll,pll >\n#define pllpl pair<pll,ll>\n#define pqi priority_queue<int>\n#define pql priority_queue<ll>\n#define npqi priority_queue<int,vector<int>,greater<int> >\n#define npql priority_queue<ll,vector<ll>,greater<ll> >\n#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)\n#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)\n#define rep(i,x) forup ((i),1,(x))\n#define repd(i,x) fordo ((i),(x),1)\n#define itr iterator\n#define forcsc(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define NO {cout<<""NO"";return 0;}\n#define YES {cout<<""YES"";return 0;}\n#define y0 y000000000000000000000000000\n#define y1 y111111111111111111111111111\n#define j0 j000000000000000000000000000\n#define j1 j111111111111111111111111111\n#define cl0(a) memset((a),(0),(sizeof((a))))\n#define clz(a) memset((a),(0x16),(sizeof((a))))\n#define clf(a) memset((a),(-(0x16)),(sizeof((a))))\n#define inf 0x3bbbbbbb\n#define lnf 0x1bbbbbbbbbbbbbbbll\n#define sqrt divi\n#define p2(i) (1ll<<(i))\n#define readi read\n#define readll read\n/*************************************************/\nll n,m,i,j,a,b,c,d,ans;\nstring st;\nint main()\n{\n\ta=b=0;\n\tread(n);\n\twhile (n--)\n\t{\n\t\tread(c);read(d);\n\t\tans+=max(0ll,min(c,d)-max(a,b)+1);\n\t\ta=c;b=d;\n\t\tif (a==b){a++;b++;}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Dima s got a staircase that consists of stairs The first stair is at height the second one is at the last one is at Dima decided to play with the staircase so he is throwing rectangular boxes at the staircase from above The th box has width and height Dima throws each box vertically down on the first stairs of the staircase that is the box covers stairs with numbers Each thrown box flies vertically down until at least one of the two following events happen the bottom of the box touches the top of a stair the bottom of the box touches the top of a box thrown earlier We only consider touching of the horizontal sides of stairs and boxes at that touching with the corners isn t taken into consideration Specifically that implies that a box with width cannot touch the stair number You are given the description of the staircase and the sequence in which Dima threw the boxes at it For each box determine how high the bottom of the box after landing will be Consider a box to fall after the previous one lands ,"['#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cassert>\n#include<ctime>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,n,m) for(int i = (int)n; i <= (int)m; i++)\n#define FOD(i,n,m) for(int i = (int)n; i >= (int)m; i--)\n\ntypedef long long i64;\ntypedef pair<int, int> PI;\n\n#define sz(v) ((i64)(v).size())\n#define all(v) (v).begin(),(v).end()\n#define bit(n) (1LL<<(i64)(n))\n#define each(i,v) for(__typeof((v).begin()) i = (v).begin(); i != (v).end(); i++)\n\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n\ntemplate<class T> void fmax(T &a, T b) { if (a < b) a = b; }\ntemplate<class T> void fmin(T &a, T b) { if (a > b) a = b; }\n\nint n, m;\nlong long a[100010];\n\nint main() {\n\tcin >> n;\n\tFOR(i,1,n) cin >> a[i];\n\tlong long now = 0, h;\n\tint w;\n\tcin >> m;\n\trep(i,m) {\n\t\tcin >> w >> h;\n\t\tnow = max(now, a[w]);\n\t\tcout << now << endl;\n\t\tnow += h;\n\t}\n}\n\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Mars is home to an unusual species of spiders Binary spiders Right now Martian scientists are observing a colony of n spiders the i th of which has a i legs Some of the spiders are friends with each other Namely the i th and j th spiders are friends if gcd a i a j ne 1 i e there is some integer k ge 2 such that a i and a j are simultaneously divided by k without a remainder Here gcd x y denotes the greatest common divisor GCD of integers x and y Scientists have discovered that spiders can send messages If two spiders are friends then they can transmit a message directly in one second Otherwise the spider must pass the message to his friend who in turn must pass the message to his friend and so on until the message reaches the recipient Let s look at an example Suppose a spider with eight legs wants to send a message to a spider with 15 legs He can t do it directly because gcd 8 15 1 But he can send a message through the spider with six legs because gcd 8 6 2 and gcd 6 15 3 Thus the message will arrive in two seconds Right now scientists are observing how the s th spider wants to send a message to the t th spider The researchers have a hypothesis that spiders always transmit messages optimally For this reason scientists would need a program that could calculate the minimum time to send a message and also deduce one of the optimal routes ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nint n;\nint arr[300005];\nbool has[300005];\n\nconst int BUF=300005;\nvector<int> al[600010];\n\nint w[600010];\nint pp[600010];\nqueue<int> q;\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\tcin>>n;\n\trep(x,1,n+1) cin>>arr[x];\n\tint s,t; cin>>s>>t;\n\t\n\tif (s!=t && arr[s]==arr[t]){\n\t\tif (arr[s]==1) cout<<""-1""<<endl;\n\t\telse{\n\t\t\tcout<<2<<endl;\n\t\t\tcout<<s<<"" ""<<t<<endl;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\trep(x,1,n+1) has[arr[x]]=true;\n\t\n\trep(x,2,300005){\n\t\tfor (int y=x;y<300005;y+=x) if (has[y]){\n\t\t\tal[y].pub(BUF+x);\n\t\t\tal[BUF+x].pub(y);\n\t\t}\n\t}\n\t\n\tmemset(w,-1,sizeof(w));\n\tw[arr[s]]=0;\n\tq.push(arr[s]);\n\t\n\twhile (!q.empty()){\n\t\tint u=q.front(); q.pop();\n\t\tfor (auto it:al[u]){\n\t\t\tif (w[it]==-1){\n\t\t\t\tw[it]=w[u]+1;\n\t\t\t\tpp[it]=u;\n\t\t\t\tq.push(it);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (w[arr[t]]==-1){\n\t\tcout<<""-1""<<endl;\n\t\treturn 0;\n\t}\n\t\n\tvector<int> stk={arr[t]};\n\twhile (stk.back()!=arr[s]) stk.pub(pp[stk.back()]);\n\t\n\tmap<int,int> occ;\n\trep(x,1,n+1) occ[arr[x]]=x;\n\tocc[arr[s]]=s,occ[arr[t]]=t;\n\t\n\tcout<<w[arr[t]]/2+1<<endl;\n\tfor (int x=sz(stk)-1;x>=0;x-=2) cout<<occ[stk[x]]<<"" ""; cout<<endl;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1]",1800
Vasya decided to learn to play chess Classic chess doesn t seem interesting to him so he plays his own sort of chess The queen is the piece that captures all squares on its vertical horizontal and diagonal lines If the cell is located on the same vertical horizontal or diagonal line with queen and the cell contains a piece of the enemy color the queen is able to move to this square After that the enemy s piece is removed from the board The queen cannot move to a cell containing an enemy piece if there is some other piece between it and the queen There is an chessboard We ll denote a cell on the intersection of the th row and th column as The square contains the white queen and the square contains the black queen All other squares contain green pawns that don t belong to anyone The players move in turns The player that moves first plays for the white queen his opponent plays for the black queen On each move the player has to capture some piece with his queen that is move to a square that contains either a green pawn or the enemy queen The player loses if either he cannot capture any piece during his move or the opponent took his queen during the previous move Help Vasya determine who wins if both players play with an optimal strategy on the board ,"['#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<map>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin>>n;\n    if(n % 2 == 0)\n    {\n        cout<<""white""<<endl;\n        cout<<""1 2""<<endl;\n    }\n    else\n    {\n        cout<<""black""<<endl;\n    }\n    return 0;\n}']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
You are given a connected weighted graph with vertices and edges The graph doesn t contain loops nor multiple edges Consider some edge with id Let s determine for this edge the maximum integer weight we can give to it so that it is contained in all minimum spanning trees of the graph if we don t change the other weights You are to determine this maximum weight described above for each edge You should calculate the answer for each edge independently it means there can t be two edges with changed weights at the same time ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int inf=(1<<30);\nconst int N=201000;\nint n,m,f[N],u,v,w,dep[N],ret[N];\nvector<VI> E,Ew;\nvector<PII> e[N];\nint mark[N],p[N][20],pe[N][20],pid[N];\nvoid dfs(int u,int f) {\n\tdep[u]=dep[f]+1;\n\tfor (auto w:e[u]) {\n\t\tint v=w.fi;\n\t\tif (v==f) continue;\n\t\tp[v][0]=u;\n\t\tpid[v]=w.se;\n\t\tpe[v][0]=Ew[pid[v]][0];\n\t\tdfs(v,u);\n\t}\n}\nint find(int x) {\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\n#define LOGN 18\n\nint lca(int u,int v) {\n\tif (dep[u]>dep[v]) swap(u,v);\n\tint mv=0;\n\tper(i,0,LOGN) if (dep[p[v][i]]>=dep[u]) mv=max(mv,pe[v][i]),v=p[v][i];\n\tif (u==v) return mv;\n\tper(i,0,LOGN) if (p[v][i]!=p[u][i]) mv=max(mv,max(pe[u][i],pe[v][i])),u=p[u][i],v=p[v][i];\n\treturn max(mv,max(pe[u][0],pe[v][0]));\n}\n\n\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,1,n+1) f[i]=i;\n\trep(i,0,m) {\n\t\tscanf(""%d%d%d"",&u,&v,&w);\n\t\tE.pb(VI{w,u,v,i});\n\t\tEw.pb(VI{w,u,v,i});\n\t}\n\tsort(all(E));\n\trep(i,0,m) {\n\t\tint id=E[i][3],u=E[i][2],v=E[i][1];\n\t\tif (find(u)!=find(v)) {\n\t\t\tmark[id]=1;\n\t\t\te[u].pb(mp(v,id)); e[v].pb(mp(u,id));\n\t\t\tf[find(u)]=find(v);\n\t\t}\n\t}\n\tdfs(1,0);\n\trep(j,1,LOGN) {\n\t\trep(i,1,n+1) {\n\t\t\tp[i][j]=p[p[i][j-1]][j-1];\n\t\t\tpe[i][j]=max(pe[i][j-1],pe[p[i][j-1]][j-1]);\n\t\t}\n\t}\n\trep(i,1,n+1) f[i]=i;\n\trep(i,0,m) ret[i]=inf;\n\trep(i,0,m) {\n\t\tint id=E[i][3],u=E[i][2],v=E[i][1];\n\t\tif (!mark[id]) {\n\t\t\tret[id]=lca(u,v);\n\t\t\twhile (1) {\n\t\t\t\tu=find(u);\n\t\t\t\tv=find(v);\n\t\t\t\tif (u==v) break;\n\t\t\t\tif (dep[v]>dep[u]) swap(u,v);\n\t\t\t\tret[pid[u]]=E[i][0];\n\t\t\t\tf[u]=find(p[u][0]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,m) {\n\t\tif (ret[i]==inf) ret[i]=0;\n\t\tprintf(""%d\\n"",ret[i]-1);\n\t}\n}\n']","[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2700
One day Vitaly was going home late at night and wondering how many people aren t sleeping at that moment To estimate Vitaly decided to look which windows are lit in the house he was passing by at that moment Vitaly sees a building of floors and windows on each floor On each floor there are flats numbered from to and two consecutive windows correspond to each flat If we number the windows from to from left to right then the th flat of the th floor has windows and in the corresponding row of windows as usual floors are enumerated from the bottom Vitaly thinks that people in the flat aren t sleeping at that moment if of the windows corresponding to this flat has lights on Given the information about the windows of the given house your task is to calculate the number of flats where according to Vitaly people aren t sleeping ,"['#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, const char * argv[]) {\n    std::ios::sync_with_stdio(false);\n\n    int n, m, a, b, res = 0;\n    cin >> n >> m;\n    for(int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> a >> b;\n            if (a + b > 0) {\n                ++res;\n            }\n        }\n    }\n    \n    cout << res;\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You have a grid with rows and columns Each cell is either empty denoted by or blocked denoted by Two empty cells are if they share a side Two cells located in the row and column and are if there exists a sequence of empty cells that starts with finishes with and any two consecutive cells in this sequence are directly connected A is a set of empty cells such that any two cells in the component are connected and there is no cell in this set that is connected to some cell not in this set Your friend Limak is a big grizzly bear He is able to destroy any obstacles in some range More precisely you can choose a square of size in the grid and Limak will transform all blocked cells there to empty ones However you can ask Limak to help only once The chosen square must be completely inside the grid It s possible that Limak won t change anything because all cells are empty anyway You like big connected components After Limak helps you what is the maximum possible size of the biggest connected component in the grid ,"['#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint S[510][510], Num[510][510], C[250100], SS, CC[250100], Res;\nchar p[510][510];\nint n, K, cnt;\nvoid DFS(int x, int y){\n    Num[x][y]=cnt;\n    CC[cnt]++;\n    if(!Num[x+1][y] && p[x+1][y] == \'.\')DFS(x+1,y);\n    if(!Num[x-1][y] && p[x-1][y] == \'.\')DFS(x-1,y);\n    if(!Num[x][y+1] && p[x][y+1] == \'.\')DFS(x,y+1);\n    if(!Num[x][y-1] && p[x][y-1] == \'.\')DFS(x,y-1);\n}\nvoid Ins(int x, int y){\n    int t = Num[x][y];\n    if(!t)return;\n    if(!C[t])SS += CC[t];\n    C[t]++;\n}\nvoid Del(int x, int y){\n    int t = Num[x][y];\n    if(!t)return;\n    C[t]--;\n    if(!C[t])SS -= CC[t];\n}\nint Calc(int x, int y){\n    return S[x+K-1][y+K-1] - S[x-1][y+K-1] - S[x+K-1][y-1] + S[x-1][y-1];\n}\nint main(){\n    int i,j,k;\n    scanf(""%d%d"",&n,&K);\n    for(i=1;i<=n;i++){\n        scanf(""%s"",p[i]+1);\n        for(j=1;j<=n;j++){\n            S[i][j]=S[i-1][j]+S[i][j-1]-S[i-1][j-1];\n            if(p[i][j]==\'.\')S[i][j]++;\n        }\n    }\n    for(i=1;i<=n;i++){\n        for(j=1;j<=n;j++){\n            if(!Num[i][j] && p[i][j]==\'.\'){\n                cnt++;\n                DFS(i,j);\n            }\n        }\n    }\n    for(i=1;i<=n-K+1;i++){\n        SS = 0;\n        for(j=1;j<=cnt;j++)C[j]=0;\n        for(j=i-1;j<=i+K;j++){\n            for(k=1;k<=K;k++){\n                Ins(j,k);\n            }\n        }\n        for(j=i;j<i+K;j++){\n            Ins(j,K+1);\n        }\n        Res = max(Res,SS + K*K - Calc(i,1));\n        for(j=2;j<=n-K+1;j++){\n            for(k=i;k<i+K;k++){\n                Del(k,j-2);\n                Ins(k,j+K);\n            }\n            Del(i-1,j-1);\n            Del(i+K,j-1);\n            Ins(i-1,j+K-1);\n            Ins(i+K,j+K-1);\n            Res = max(Res,SS + K*K - Calc(i,j));\n        }\n    }\n    printf(""%d\\n"",Res);\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2400
Imagine that there is a group of three friends A B and A owes B 20 rubles and B owes C 20 rubles The total sum of the debts is 40 rubles You can see that the debts are not organized in a very optimal manner Let s rearrange them like that assume that A owes C 20 rubles and B doesn t owe anything to anybody The debts still mean the same but the total sum of the debts now equals 20 rubles This task is a generalisation of a described example Imagine that your group of friends has people and you know the debts between the people Optimize the given debts without changing their meaning In other words finally for each friend the difference between the total money he should give and the total money he should take must be the same Print the minimum sum of all debts in the optimal rearrangement of the debts See the notes to the test samples to better understand the problem ,"['#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint a[1000];\n\nint main() {\n    int n, m, x, y, c;\n    cin >> n >> m;\n    for (int i = 0; i < m; ++i) {\n        cin >> x >> y >> c;\n        a[x] += c;\n        a[y] -= c;\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        ans += abs(a[i]);\n    }\n    cout << ans / 2 << endl;\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
You are given an array a 1 a 2 ldots a n In one operation you can choose two elements a i and a j i ne j and decrease each of them by one You need to check whether it is possible to make all the elements equal to zero or not ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5 + 5;\nint a[maxn];\n\nint main() {\n    int n; scanf(""%d"", &n);\n    for (int i = 0; i < n; ++i) scanf(""%d"", &a[i]);\n    sort(a, a + n);\n\n    if (accumulate(a, a + n, 0ll) & 1) {\n        puts(""NO"");\n        return 0;\n    }\n\n    long long sum = 0;\n    for (int i = 0; i < n - 1; ++i) sum += a[i];\n    if (sum >= a[n - 1]) puts(""YES"");\n    else puts(""NO"");\n}\n\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
The Fair Nut likes kvass very much On his birthday parents presented him n kegs of kvass There are v i liters of kvass in the i th keg Each keg has a lever You can pour your glass by 1 liter pulling this lever The Fair Nut likes this drink very much so he wants to pour his glass by s liters of kvass But he wants to do it so kvass level in the least keg is as much as possible Help him find out how much kvass can be in the least keg or define it s not possible to pour his glass by s liters of kvass ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int n; cin >> n; ll vol; cin >> vol;\n    vl data; F0R(i, n) {\n        ll cur; cin >> cur;\n        data.pb(cur);\n    }\n    sort(all(data));\n    ll sum = 0;\n    F0R(i, n) {\n        sum += data[i];\n    }\n    if (sum < vol) {\n        cout << -1 << endl; return 0;\n    }\n    if (sum - data[0] * n >= vol) {\n        cout << data[0] << endl; return 0;\n    }\n    ll remaining = vol - sum + data[0] * n;\n    ll perN = remaining / n;\n    if (remaining % n != 0) perN++;\n    cout << data[0] - perN << endl;\n\n    return 0;\n}\n\n// read the question correctly (ll vs int)\n// template by bqi343']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
As we all know Max is the best video game player among her friends Her friends were so jealous of hers that they created an actual game just to prove that she s not the best at games The game is played on a directed acyclic graph a DAG with vertices and edges There s a character written on each edge a lowercase English letter Max and Lucas are playing the game Max goes first then Lucas then Max again and so on Each player has a marble initially located at some vertex Each player in his her turn should move his her marble along some edge a player can move the marble from vertex to vertex if there s an outgoing edge from to If the player moves his her marble from vertex to vertex the character of that round is the character written on the edge from to There s one additional rule the ASCII code of character of round should be to the ASCII code of character of round for The rounds are numbered for both players together i e Max goes in odd numbers Lucas goes in even numbers The player that can t make a move loses the game The marbles may be at the same vertex at the same time Since the game could take a while and Lucas and Max have to focus on finding Dart they don t have time to play So they asked you if they both play optimally who wins the game You have to determine the winner of the game for all initial positions of the marbles ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=110;\nchar dp[N][N][28][2];\nint n,m,u,v;\nchar s[10];\nvector<PII> e[N];\nbool dfs(int u,int v,int k,int op) {\n\tif (dp[u][v][k][op]!=0x11) return dp[u][v][k][op];\n\tif (op==0) {\n\t\tbool win=0;\n\t\tfor (auto p:e[u]) if (p.se>=k) {\n\t\t\twin|=dfs(p.fi,v,p.se,op^1);\n\t\t\tif (win==1) break;\n\t\t}\n\t\treturn dp[u][v][k][op]=win;\n\t} else {\n\t\tbool win=1;\n\t\tfor (auto p:e[v]) if (p.se>=k) {\n\t\t\twin&=dfs(u,p.fi,p.se,op^1);\n\t\t\tif (win==0) break;\n\t\t}\n\t\treturn dp[u][v][k][op]=win;\n\t}\n}\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,m) {\n\t\tscanf(""%d%d%s"",&u,&v,s); --u; --v;\n\t\te[u].pb(mp(v,s[0]-\'a\'+1));\n\t}\n\tmemset(dp,0x11,sizeof(dp));\n\trep(i,0,n) {\n\t\trep(j,0,n) if (dfs(i,j,0,0)) putchar(\'A\'); else putchar(\'B\');\n\t\tputs("""");\n\t}\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Venya joined a tour to the madhouse in which orderlies play with patients the following game Orderlies pick a string s of length n consisting only of lowercase English letters The player can ask two types of queries ask to list all substrings of s l r Substrings will be returned in random order and in every substring all characters will be randomly shuffled guess the string picked by the orderlies This query can be asked exactly once after that the game will finish If the string is guessed correctly the player wins otherwise he loses The player can ask of the first type To make it easier for the orderlies there is an additional limitation the total number of returned substrings in all queries of the first type must not exceed n 1 2 Venya asked you to write a program which will guess the string by interacting with the orderlies program and acting by the game s rules Your program should immediately terminate after guessing the string using a query of the second type In case your program guessed the string incorrectly or it violated the game rules it will receive verdict Note that in every test case the string is fixed beforehand and will not change during the game which means that the interactor is not adaptive ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n;\nchar p[120], A[10100][120], B[10100][120], res[120];\nint SA[110], SB[110], Z[110];\nint main() {\n\tint i, j;\n\tscanf(""%d"", &n);\n\n\tprintf(""? %d %d\\n"", 1, n);\n\tfflush(stdout);\n\tif (n == 1) {\n\t\tscanf(""%s"", p);\n\t\tprintf(""! %s\\n"", p);\n\t\tfflush(stdout);\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < n*(n + 1) / 2; i++) {\n\t\tscanf(""%s"", A[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; A[i][j]; j++)c += A[i][j] - \'a\';\n\t\tint L = j;\n\t\tSA[L] += c;\n\t}\n\tprintf(""? %d %d\\n"", 1, n - 1);\n\tfflush(stdout);\n\n\tfor (i = 0; i < n*(n - 1) / 2; i++) {\n\t\tscanf(""%s"", B[i]);\n\t\tint c = 0;\n\t\tfor (j = 0; B[i][j]; j++)c += B[i][j] - \'a\';\n\t\tint L = j;\n\t\tSB[L] += c;\n\t}\n\n\tfor (i = 1; i <= n; i++) {\n\t\tZ[i] = SA[i] - SB[i];\n\t\tres[n - i] = Z[i] - Z[i - 1] + \'a\';\n\t}\n\tprintf(""! %s\\n"", res);\n\n}']","[0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
You are given an array a consisting of n integers You can perform the following operations arbitrary number of times possibly zero Choose a pair of indices i j such that i j 1 indices i and j are adjacent and set a i a i a i a j Choose a pair of indices i j such that i j 1 indices i and j are adjacent and set a i a i a i a j The value x means the absolute value of x For example 4 4 3 3 Your task is to find the minimum number of operations required to obtain the array of equal elements and print the order of operations to do it ,"[""#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 200000 + 10;\ntypedef long long ll;\nint a[N],cnt[N];\nint main(){\n    ios::sync_with_stdio(0);\n    int n; cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i], cnt[a[i]]++;\n    int ans = n, t;\n    for(int i=0;i<N;i++){\n        if(n-cnt[i]<ans) ans = n-cnt[i], t = i;\n    }\n    cout<<ans<<endl;\n    queue<int> q;\n    for(int i=1;i<=n;i++){\n        if(a[i]==t) q.push(i);\n    }\n    while(!q.empty()){\n        t = q.front(), q.pop();\n        if(t>1&&a[t-1]!=a[t]){\n            if(a[t-1]>a[t]) cout<<2<<' '<<t-1<<' '<<t<<endl;\n            else cout<<1<<' '<<t-1<<' '<<t<<endl;\n            a[t-1] = a[t];\n            q.push(t-1);\n        }\n        if(t<n&&a[t+1]!=a[t]){\n            if(a[t+1]>a[t]) cout<<2<<' '<<t+1<<' '<<t<<endl;\n            else cout<<1<<' '<<t+1<<' '<<t<<endl;\n            a[t+1] = a[t];\n            q.push(t+1);\n        }\n    }\n}\n""]","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Vanya wants to minimize a tree He can perform the following operation multiple times choose a vertex and two disjoint except for paths of equal length and Additionally vertices must not have any neighbours in the tree other than adjacent vertices of corresponding paths After that one of the paths may be merged into the other that is the vertices can be effectively erased Help Vanya determine if it possible to make the tree into a path via a sequence of described operations and if the answer is positive also determine the shortest length of such path ,"['#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\nconst int N = (int) 2e5 + 100;\nvector <int> g[N];\n\n\nvoid dfs(int v, int par, int cd, int d[] )\n{\n\td[v] = cd;\n\tfor (int to : g[v] )\n\t{\n\t\tif (to == par) continue;\n\t\tdfs(to, v, cd + 1, d);\n\t}\n}\n\nint dfsCheck(int v, int par)\n{\n\tvector <int> ds;\n\tfor (int to : g[v] )\n\t{\n\t\tif (to == par) continue;\n\t\tds.push_back(dfsCheck(to, v) );\t\n\t}\n\tsort(ds.begin(), ds.end() );\n\tds.resize(unique(ds.begin(), ds.end() ) - ds.begin() );\n\tif (v != par)\n\t{\n//\t\teprintf(""v = %d, par = %d, ds.size() = %d\\n"", v, par, (int) ds.size() );\n\t\tif ( (int) ds.size() > 1)\n\t\t{\n\t\t\tprintf(""-1\\n"");\n\t\t\texit(0);\n\t\t}\n\t\tif (ds.empty() ) return 1;\n\t\treturn ds[0] + 1;\n\t}\n\tif (ds.empty() ) return 0;\n\tif ( (int) ds.size() > 2) return -1;\n\treturn ds[0] + ds.back();\n}\n\nint d0[N];\nint da[N];\nint db[N];\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\ta--;\n\t\tb--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tdfs(0, 0, 0, d0);\n\tint a = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (d0[i] > d0[a] )\n\t\t\ta = i;\n\tdfs(a, a, 0, da);\n\tint b = a;\n\tfor (int i = 0; i < n; i++)\n\t\tif (da[i] > da[b] )\n\t\t\tb = i;\n\tdfs(b, b, 0, db);\n\tint c = b;\n\tfor (int i = 0; i < n; i++)\n\t\tif (db[i] + da[i] == db[a] && min(db[i], da[i] ) > min(db[c], da[c] ) )\n\t\t\tc = i;\n//\teprintf(""a = %d, b = %d, c = %d\\n"", a, b, c);\n\t\n\tint ans = dfsCheck(c, c);\n\twhile (ans % 2 == 0 && ans > 0)\n\t\tans /= 2;\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n\n\n']","[1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Dima took up the biology of bacteria as a result of his experiments he invented types of bacteria Overall there are bacteria at his laboratory right now and the number of bacteria of type equals For convenience we will assume that all the bacteria are numbered from to The bacteria of type are numbered from to With the help of special equipment Dima can move energy from some bacteria into some other one Of course the use of such equipment is not free Dima knows ways to move energy from some bacteria to another one The way with number can be described with integers and mean that this way allows moving energy from bacteria with number to bacteria with number or vice versa for dollars Dima s Chef Inna calls the type distribution if there is a way may be non direct to move energy from any bacteria of the particular type to any other bacteria of the same type between any two bacteria of the same type for zero cost As for correct type distribution the cost of moving the energy depends only on the types of bacteria help Inna to determine is the type distribution correct If it is print the matrix with size Cell of this matrix must be equal to the minimal possible cost of energy moving from bacteria with type to bacteria with type ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <limits>\n#include <tuple>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nconst int C=1e6;\nint n, m, k, ty[C], c[555], d[555][555], u[C], uc[555], lo[555], ls;\nvector<int> t[C];\nvoid go(int v)\n{\n    if (!uc[ty[v]]) lo[ls++]=ty[v];\n    ++uc[ty[v]];\n    u[v]=1;\n    for (int i=0;i<t[v].size();++i) if (!u[t[v][i]]) go(t[v][i]);\n}\nvoid sm(int &a, int x)\n{\n    if (a==-1||a>x) a=x;\n}\nint main()\n{\n    scanf(""%d %d %d"", &n, &m, &k);\n    for (int i=0;i<k;++i) scanf(""%d"", &c[i]);\n    for (int i=0, s=0;i<k;s+=c[i], ++i) for (int j=s;j<s+c[i];++j) ty[j]=i;\n    for (int i=0;i<k;++i) for (int j=0;j<k;++j) if (i!=j) d[i][j]=-1;\n    for (int i=0;i<m;++i)\n    {\n        int a, b, x;\n        scanf(""%d %d %d"", &a, &b, &x);\n        --a; --b;\n        if (x==0)\n        {\n            t[a].push_back(b);\n            t[b].push_back(a);\n        }\n        a=ty[a];\n        b=ty[b];\n        sm(d[a][b], x);\n        sm(d[b][a], x);\n    }\n    for (int i=0;i<n;++i)\n    {\n        if (uc[ty[i]]) continue;\n        int pp=ls;\n        go(i);\n        for (int j=pp;j<ls;++j) if (uc[lo[j]]!=c[lo[j]]) { puts(""No""); return 0; }\n    }\n    for (int l=0;l<k;++l) for (int i=0;i<k;++i) for (int j=0;j<k;++j)\n    {\n        if (d[i][l]!=-1&&d[l][j]!=-1) sm(d[i][j], d[i][l]+d[l][j]);\n    }\n    puts(""Yes"");\n    for (int i=0;i<k;++i) for (int j=0;j<k;++j) printf(""%d%c"", d[i][j], j+1==k?\'\\n\':\' \');\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]",2000
There are n cells numbered 1 2 dots n from left to right You have to place a robot at any cell initially The robot must make k moves In one move the robot must move one cell to the left or right provided that it doesn t move out of bounds In other words if the robot was in the cell i it must move to either the cell i 1 or the cell i 1 as long as it lies between 1 and n endpoints inclusive The cells in the order they are visited including the cell the robot is placed together make a Each cell i has a value a i associated with it Let c 0 c 1 dots c k be the sequence of cells in a in the order they are visited c 0 is the cell robot is initially placed c 1 is the cell where the robot is after its first move and so on more formally c i is the cell that the robot is at after i moves Then the value of the path is calculated as a c 0 a c 1 dots a c k Your task is to calculate the sum of values over all possible Since this number can be very large output it modulo 10 9 7 Two are considered different if the starting cell differs or there exists an integer i in 1 k such that the current cell of the robot after exactly i moves is different in those paths You must process q updates to a and print the updated sum each time Each update changes the value of exactly one cell See the input format and the sample input output for more details ,"['// author: xay5421\n// created: Fri Jan  8 23:00:15 2021\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=5005,P=1e9+7;\nint n,K,Q,f[N][N],g[N],a[N];\nint main(){\n#ifdef xay5421\n\tfreopen(""a.in"",""r"",stdin);\n#endif\n\tscanf(""%d%d%d"",&n,&K,&Q);\n\trep(i,1,n)scanf(""%d"",&a[i]);\n\trep(i,1,n)f[i][0]=1;\n\trep(j,1,K){\n\t\trep(i,1,n){\n\t\t\tf[i][j]=(f[i-1][j-1]+f[i+1][j-1])%P;\n\t\t}\n\t}\n\trep(i,1,n){\n\t\trep(j,0,K){\n\t\t\t(g[i]+=1LL*f[i][j]*f[i][K-j]%P)%=P;\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,1,n)(ans+=1LL*g[i]*a[i]%P)%=P;\n\trep(i,1,Q){\n\t\tint k1,k2;\n\t\tscanf(""%d%d"",&k1,&k2);\n\t\t(ans+=P-1LL*g[k1]*a[k1]%P)%=P;\n\t\ta[k1]=k2;\n\t\t(ans+=1LL*g[k1]*a[k1]%P)%=P;\n\t\tprintf(""%d\\n"",ans);\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2200
You are playing a computer game where you lead a party of m soldiers Each soldier is characterised by his agility a i The level you are trying to get through can be represented as a straight line segment from point 0 where you and your squad is initially located to point n 1 where the boss is located The level is filled with k traps Each trap is represented by three numbers l i r i and d i l i is the location of the trap and d i is the danger level of the trap whenever a soldier with agility lower than d i steps on a trap that is moves to the point l i he gets instantly killed Fortunately you can disarm traps if you move to the point r i you disarm this trap and it no longer poses any danger to your soldiers Traps don t affect you only your soldiers You have t seconds to complete the level that is to bring some soldiers from your squad to the boss Before the level starts you choose which soldiers will be coming with you and which soldiers won t be After that you have to bring to the boss To do so you may perform the following actions if your location is x you may move to x 1 or x 1 This action consumes one second if your location is x and the location of your squad is x you may move to x 1 or to x 1 with your squad in one second You may not perform this action if it puts some soldier in danger i e the point your squad is moving into contains a non disarmed trap with d i greater than agility of some soldier from the squad This action consumes one second if your location is x and there is a trap i with r i x you may disarm this trap This action is done instantly it consumes no time Note that after each action both your coordinate and the coordinate of your squad should be integers You have to choose the maximum number of soldiers such that they all can be brought from the point 0 to the point n 1 where the boss waits in no more than t seconds ,"['#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint m, n, k, t;\nint A[200005];\nint L[200005];\nint R[200005];\nint D[200005];\n\nint ok(int x) {\n    int a = A[m - x];\n    vector<pii> P;\n    for (int i = 1; i <= k; i++) {\n        if (D[i] <= a) continue;\n        P.emplace_back(L[i], R[i]);\n    }\n    sort(P.begin(), P.end());\n    int sum = 0, ed = 0;\n    for (auto i : P) {\n        if (i.second <= ed) continue;\n        if (ed < i.first) ed = i.first - 1;\n        sum += i.second - ed;\n        ed = i.second;\n    }\n    ll need = (n + 1) + sum * 2ll;\n    return need <= t;\n}\n\nint main() {\n    scanf(""%d %d %d %d"", &m, &n, &k, &t);\n    for (int i = 0; i < m; i++) scanf(""%d"", &A[i]);\n    for (int i = 1; i <= k; i++) {\n        scanf(""%d %d %d"", &L[i], &R[i], &D[i]);\n    }\n    sort(A, A + m);\n    int st = 0, ed = m;\n    while (st < ed) {\n        int md = st + ed + 1 >> 1;\n        if (ok(md)) st = md;\n        else ed = md - 1;\n    }\n    printf(""%d\\n"", st);\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Consider a conveyor belt represented using a grid consisting of n rows and m columns The cell in the i th row from the top and the j th column from the left is labelled i j Every cell except n m has a direction Right or Down assigned to it If the cell i j is assigned direction any luggage kept on that will move to the cell i j 1 Similarly if the cell i j is assigned direction any luggage kept on that will move to the cell i 1 j If at any moment the luggage moves out of the grid it is considered to be lost There is a counter at the cell n m from where all luggage is picked A conveyor belt is called if and only if any luggage reaches the counter regardless of which cell it is placed in initially More formally for every cell i j any luggage placed in this cell should eventually end up in the cell n m This may not hold initially you are however allowed to the directions of some cells to make the conveyor belt functional Please determine the minimum amount of cells you have to change Please note that it is always possible to make any conveyor belt functional by changing the directions of some set of cells ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int k_N = 100 + 3;\n\nstring s[k_N];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n\n        for(int i = 0; i < n; ++i)\n            cin >> s[i];\n    \n        int ans = 0;\n        for(int i = 0; i < n - 1; ++i)\n            ans += s[i][m - 1] != \'D\';\n\n        for(int i = 0; i < m - 1; ++i)\n            ans += s[n - 1][i] != \'R\';\n\n        cout << ans << ""\\n"";\n    }\n}']","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Berland is a country with ancient history where roads were built and destroyed for centuries It is known that there always were n cities in Berland You also have records of t key moments in the history of the country numbered from 1 to t Each record contains a list of roads between some pairs of cities which could be used for travel in Berland at a specific moment in time You have discovered a time machine that transports you between key moments Unfortunately you cannot choose what point in time to end up at but you know the order consisting of k moments in time a i in which the machine will transport you Since there is little time between the travels when you find yourself in the next key moment in time you can travel on at most one existing road at that moment coming out from the city you were in before time travel Currently you are in city 1 and the time machine has already transported you to moment a 1 You want to reach city n as quickly as possible Determine the minimum number of time travels that you need to make in order to reach city n ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, t;\n    std::cin >> n >> t;\n    \n    std::vector<std::vector<std::pair<int, int>>> adj(n);\n    for (int i = 0; i < t; i++) {\n        int m;\n        std::cin >> m;\n        \n        for (int j = 0; j < m; j++) {\n            int x, y;\n            std::cin >> x >> y;\n            x--, y--;\n            adj[x].emplace_back(y, i);\n            adj[y].emplace_back(x, i);\n        }\n    }\n    \n    int k;\n    std::cin >> k;\n    std::vector<int> a(k);\n    std::vector<std::vector<int>> pos(t);\n    for (int i = 0; i < k; i++) {\n        std::cin >> a[i];\n        a[i]--;\n        pos[a[i]].push_back(i);\n    }\n    \n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> q;\n    q.emplace(0, 0);\n    std::vector dis(n, -1);\n    \n    while (!q.empty()) {\n        auto [d, x] = q.top();\n        q.pop();\n        \n        if (dis[x] != -1) {\n            continue;\n        }\n        dis[x] = d;\n        \n        for (auto [y, i] : adj[x]) {\n            auto it = std::lower_bound(pos[i].begin(), pos[i].end(), d);\n            if (it != pos[i].end()) {\n                q.emplace(*it + 1, y);\n            }\n        }\n    }\n    \n    std::cout << dis[n - 1] << ""\\n"";\n    \n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1900
Andrey is just starting to come up with problems and it s difficult for him That s why he came up with a strange problem about permutations dagger and asks you to solve it Can you do it Let s call the of a permutation p of length n the value of the expression Find the maximum cost among all permutations of length n dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#pragma GCC target(""sse,sse2,sse3,ssse3,sse4.1,sse4.2,avx,avx2,popcnt"")\n#if defined(LOCAL) or not defined(LUOGU)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast,unroll-loops"")\n#endif\n#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL\n#include""dbg.h""\n#define dbgu(...) dbg(__VA_ARGS__)\n#else\n#define dbg(...) (__VA_ARGS__)\n#define dbgu(...)\n#endif\nnamespace Fread{const int SIZE=1<<16;char buf[SIZE],*S,*T;inline char getchar(){if(S==T){T=(S=buf)+fread(buf,1,SIZE,stdin);if(S==T)return\'\\n\';}return *S++;}}namespace Fwrite{const int SIZE=1<<16;char buf[SIZE],*S=buf,*T=buf+SIZE;inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}inline void putchar(char c){*S++=c;if(S==T)flush();}struct NTR{~NTR(){flush();}}ztr;}\n#define getchar Fread::getchar\n#define putchar Fwrite::putchar\n#define Setprecision 15\n#define between \'\\n\'\ntemplate<typename T>struct is_char{static constexpr bool value=(std::is_same<T,char>::value||std::is_same<T,signed char>::value||std::is_same<T,unsigned char>::value);};template<typename T>struct is_integral_ex{static constexpr bool value=(std::is_integral<T>::value||std::is_same<T,__int128>::value)&&!is_char<T>::value;};template<typename T>struct is_floating_point_ex{static constexpr bool value=std::is_floating_point<T>::value||std::is_same<T,__float128>::value;};namespace Fastio{struct Reader{template<typename T>typename std::enable_if_t<std::is_class<T>::value,Reader&>operator>>(T&x){for(auto &y:x)*this>>y;return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1;while(c<\'0\'||c>\'9\'){if(c==\'-\')f*=-1;c=getchar();}x=0;while(c>=\'0\'&&c<=\'9\'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x*=f;return *this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Reader&>operator>>(T&x){char c=getchar();short f=1,s=0;x=0;T t=0;while((c<\'0\'||c>\'9\')&&c!=\'-\'&&c!=\'.\'){if(c==\'-\')f*=-1;c=getchar();}while(c>=\'0\'&&c<=\'9\'&&c!=\'.\')x=x*10+(c^48),c=getchar();if(c==\'.\')c=getchar();else return x*=f,*this;while(c>=\'0\'&&c<=\'9\')t=t*10+(c^48),s++,c=getchar();while(s--)t/=10.0;x=(x+t)*f;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Reader&>operator>>(T&c){c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();return *this;}Reader&operator>>(char*str){int len=0;char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str[len++]=c,c=getchar();str[len]=\'\\0\';return*this;}Reader&operator>>(std::string&str){char c=getchar();while(c==\'\\n\'||c==\' \'||c==\'\\r\')c=getchar();while(c!=\'\\n\'&&c!=\' \'&&c!=\'\\r\')str.push_back(c),c=getchar();return*this;}Reader(){}}cin;const char endl=\'\\n\';struct Writer{typedef __int128 mxdouble;template<typename T>typename std::enable_if_t<std::is_class<T>::value,Writer&>operator<<(T x){for(auto &y:x)*this<<y<<between;*this<<\'\\n\';return *this;}template<typename T>typename std::enable_if_t<is_integral_ex<T>::value,Writer&>operator<<(T x){if(x==0)return putchar(\'0\'),*this;if(x<0)putchar(\'-\'),x=-x;static int sta[45];int top=0;while(x)sta[++top]=x%10,x/=10;while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_floating_point_ex<T>::value,Writer&>operator<<(T x){if(x<0)putchar(\'-\'),x=-x;mxdouble _=x;x-=(T)_;static int sta[45];int top=0;while(_)sta[++top]=_%10,_/=10;if(!top)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;putchar(\'.\');for(int i=0;i<Setprecision;i++)x*=10;_=x;while(_)sta[++top]=_%10,_/=10;for(int i=0;i<Setprecision-top;i++)putchar(\'0\');while(top)putchar(sta[top]+\'0\'),--top;return*this;}template<typename T>typename std::enable_if_t<is_char<T>::value,Writer&>operator<<(T c){putchar(c);return*this;}Writer&operator<<(char*str){int cur=0;while(str[cur])putchar(str[cur++]);return *this;}Writer&operator<<(const char*str){int cur=0;while(str[cur])putchar(str[cur++]);return*this;}Writer&operator<<(std::string str){int st=0,ed=str.size();while(st<ed)putchar(str[st++]);return*this;}Writer(){}}cout;}\n#define cin Fastio::cin\n#define cout Fastio::cout\n#define endl Fastio::endl\n#define int long long\nmain()\n{\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<int>p(n);\n\t\tfor(int x=0;x<n;x++)\n\t\t\tp[x]=x;\n\t\tint ans=0;\n\t\tfor(int i=n-1;i>=0;i--)\n\t\t{\n\t\t\tint res=0,res2=0;\n\t\t\tfor(int x=0;x<n;x++)\n\t\t\t\tres+=(p[x]+1)*(x+1),res2=max(res2,(p[x]+1)*(x+1));\n\t\t\tans=max(ans,res-res2);\n\t\t\tif(i!=0)reverse(p.begin()+i,p.end()),reverse(p.begin()+i-1,p.end());\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}']","[1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
With hands joined go everywhere at a speed faster than our thoughts This time the Fire Sisters Karen and Tsukihi is heading for somewhere they ve never reached water surrounded islands There are three clusters of islands conveniently coloured red blue and purple The clusters consist of and distinct islands respectively Bridges have been built between some possibly all or none of the islands A bridge bidirectionally connects two different islands and has length For any two islands of the same colour either they shouldn t be reached from each other through bridges or the shortest distance between them is apparently in order to prevent oddities from spreading quickly inside a cluster The Fire Sisters are ready for the unknown but they d also like to test your courage And you re here to figure out the number of different ways to build all bridges under the constraints and give the answer modulo Two ways are considered different if a pair of islands exist such that there s a bridge between them in one of them but not in the other ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nll f[5003][5003];\nconst int MOD=998244353;\nint main()\n{\n\tfor(int i=0;i<=5000;++i) f[0][i]=1;\n\tfor(int i=1;i<=5000;++i)\n\t{\n\t\tf[i][0]=1;\n\t\tfor(int j=1;j<=5000;++j)\n\t\t\tf[i][j]=(f[i-1][j]+j*f[i-1][j-1])%MOD;\n\t}\n\tint a,b,c;\n\tscanf(""%d%d%d"",&a,&b,&c);\n\tll ans=f[a][b]*f[a][c]%MOD*f[b][c]%MOD;\n\tans=(ans%MOD+MOD)%MOD;\n\tprintf(""%d\\n"",ans);\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1800
Each evening Roma plays online poker on his favourite website The rules of poker on this website are a bit strange there are always two players in a hand there are no bets and the winner takes virtual bourle from the loser Last evening Roma started to play poker He decided to spend no more than virtual bourles he will stop immediately if the number of his loses exceeds the number of his wins by Also Roma will leave the game if he wins enough money for the evening i e if the number of wins exceeds the number of loses by Next morning Roma found a piece of paper with a sequence on it representing his results Roma doesn t remember the results exactly and some characters in the sequence are written in a way such that it s impossible to recognize this character so Roma can t recall whether he won bourles or he lost The sequence written by Roma is a string consisting of characters Roma won the corresponding hand Roma lost draw and unknown result Roma wants to restore any sequence by changing all characters to or The sequence is called if all these conditions are met In the end the absolute difference between the number of wins and loses is equal to There is no hand such that the absolute difference before this hand was equal to Help Roma to restore any such sequence ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 2007;\nconst int Z = 1002;\nint n, k;\nchar s[N];\nbool dp[N][N];\nint par[N][N];\n\nint main()\n{\n//    freopen(""input.txt"", ""r"", stdin);\n//    freopen(""output.txt"", ""w"", stdout);\n\n    scanf(""%d%d %s"", &n, &k, s);\n    dp[0][Z] = 1;\n    for (int i = 0; i < n; i++)\n        for (int bal = -k + 1; bal < k; bal++)\n        {\n            if (!dp[i][Z + bal]) continue;\n            if (s[i] == \'W\' || s[i] == \'?\')\n            {\n                dp[i + 1][Z + bal + 1] = 1;\n                par[i + 1][Z + bal + 1] = 1;\n            }\n            if (s[i] == \'D\' || s[i] == \'?\')\n            {\n                dp[i + 1][Z + bal] = 1;\n                par[i + 1][Z + bal] = 0;\n            }\n            if (s[i] == \'L\' || s[i] == \'?\')\n            {\n                dp[i + 1][Z + bal - 1] = 1;\n                par[i + 1][Z + bal - 1] = -1;\n            }\n        }\n    if (dp[n][Z + k])\n    {\n        int p = n, w = Z + k;\n        while(p > 0)\n        {\n            int d = par[p][w];\n            p--;\n            w -= d;\n            if (d == 1)\n                s[p] = \'W\';\n            if (d == 0)\n                s[p] = \'D\';\n            if (d == -1)\n                s[p] = \'L\';\n        }\n        printf(""%s\\n"", s);\n    }\n    else if (dp[n][Z - k])\n    {\n        int p = n, w = Z - k;\n        while(p > 0)\n        {\n            int d = par[p][w];\n            p--;\n            w -= d;\n            if (d == 1)\n                s[p] = \'W\';\n            if (d == 0)\n                s[p] = \'D\';\n            if (d == -1)\n                s[p] = \'L\';\n        }\n        printf(""%s\\n"", s);\n    }\n    else\n        printf(""NO\\n"");\n\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
You are given two arrays a and b both of length n All elements of both arrays are from 0 to n 1 You can reorder elements of the array b if you want you may leave the order of elements as it is After that let array c be the array of length n the i th element of this array is c i a i b i ,"['#include <unordered_map>\n#include <unordered_set>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <iomanip>\n#include <bitset>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\nusing namespace std;\n#define il inline\n#define elif else if\n\n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n\n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define All(x) x.begin(),x.end()\n\n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n\n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n\n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n\n// Read\nstruct InputReader{\n\t#define bs 1000001\n\tchar buf[bs]; int p;\n\til InputReader(){ p = bs; }\n\til void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n\til char C(){ if(p >= bs) Flush(); return buf[p++]; }\n\til char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != \'-\' ) ch = C(); return ch; }\n\til void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n\tint operator() (){\n\t\tint ans = 0, fu = 1; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10 + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\tll Readll(){\n\t\tll ans = 0LL, fu = 1LL; char ch = Readnum();\n\t\tif( ch == \'-\' ) fu = -1LL, ch = C();\n\t\twhile( ch >= \'0\' && ch <= \'9\' ){\n\t\t\tans = ans*10LL + ch-\'0\';\n\t\t\tch = C();\n\t\t}\n\t\treturn ans * fu;\n\t}\n\til void Readstring( string &x ){\n\t\tx.clear(); char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != \'#\'  &&  ch != \'.\' ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  ||  ch == \'#\'  ||  ch == \'.\' ){\n\t\t\tx += ch;\n\t\t\tch = C();\n\t\t}\n\t}\n\til void Readchstring( char s[] ){\n\t\tint len = 0; char ch = C();\n\t\twhile( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != \'*\'  &&  ch != \'?\'*/ ) ch = C();\n\t\twhile( isdigit(ch)  ||  isalpha(ch)  /*||  ch == \'*\'  ||  ch == \'?\'*/ ){\n\t\t\ts[len++] = ch;\n\t\t\tch = C();\n\t\t}\n\t\ts[len] = \'\\0\';\n\t}\n\til void Specialread( char &c ){\n\t\tc = C();\n\t\twhile( !isdigit(c) && !isalpha(c) && c != \'#\'  &&  c != \'.\'  &&  c != \'=\'  &&  c != \'B\' ) c = C();\n\t}\n\t#undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n\n// File\n#define Fin(a) freopen(a,""r"",stdin)\n#define Fout(a) freopen(a,""w"",stdout)\nil void FILEIO(){\n\t#ifdef intLSY\n\t\tFin(""in.in"");\n\t#endif\n}\nil void FILEIO( string pname ){\n\tFin((pname+"".in"").c_str());\n\t#ifndef intLSY\n\t\tFout((pname+"".out"").c_str());\n\t#endif\n}\nvoid Printtime(){\n\t#ifdef intLSY\n\t\tdouble _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n\t\tprintf(""\\n\\nTime usage:\\n%.0lf ms\\n"",_timeuse);\n\t#endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n\n\n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n\n\n// Debug\n#define B cerr << ""BreakPoint"" << endl;\n#define O(x) cerr << #x << "" "" << x << endl;\n#define O_(x) cerr << #x << "" "" << x << ""  "";\n#define ERR(x) cerr << ""ERR! #"" << x << endl;\n#define Msz(x) cerr << ""Sizeof "" << #x << "" "" << sizeof(x)/1024/1024 << "" MB"" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = \' \' , char ed = \'\\n\' ){\n\tif( s > t ) return;\n\tfor( int i = s ; i < t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << a[t] << ed;\n\tcout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = \' \' , char ed = \'\\n\' ){\n\tif( t == -1 ) t = a.size()-1;\n\tfor( int i = s ; i <= t ; i++ )\n\t\tcout << a[i] << sp;\n\tcout << ed;\n\tcout.flush();\n}\n\n\n// Optimize\n#define abs(a) ((a)<0?(~(a)+1):(a))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n//#define swap(a,b) {a=a^b;b=a^b;a=a^b;}\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define MOD 998244353\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 262144\n\nint n;\nint cnt[MAXN];\nint a[MAXN];\nint nxtnum[MAXN];\n\nint Nxt( int x ){\n\treturn nxtnum[x] == x ? x : nxtnum[x] = Nxt(nxtnum[x]);\n}\n\nint main(){\n\tFILEIO();\n\n\tRead(n);\n\tFor(i,n) Read(a[i]);\n\tFor(i,n){\n\t\tiRead(x);\n\t\t++cnt[x];\n\t}\n\n\tFor0(i,n) nxtnum[i] = cnt[i] ? i : (i+1)%n;\n\n\tFor(i,n){\n\t\tint u = a[i];\n\t\tint v = Nxt((n-u)%n);\n\t\tprintf(""%d "",(u+v)%n);\n\t\t--cnt[v];\n\t\tif(!cnt[v]) nxtnum[v] = (v+1)%n;\n\t}\n\tputchar(10);\n\n\tEND();\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Maria is the most active old lady in her house She was tired of sitting at home She decided to organize a ceremony against the coronavirus She has n friends who are also grannies Maria is not included in this number The i th granny is ready to attend the ceremony provided that at the time of her appearance in the courtyard there will be at least a i other grannies there Note that grannies can come into the courtyard at the same time Formally the granny i agrees to come if the number of other grannies who came earlier or at the same time with her is greater than or equal to a i Grannies gather in the courtyard like that Initially only Maria is in the courtyard that is the initial number of grannies in the courtyard is 1 All the remaining n grannies are still sitting at home On each step Maria selects a subset of grannies none of whom have yet to enter the courtyard She promises each of them that at the time of her appearance there will be at least a i other grannies including Maria in the courtyard Maria can call several grannies at once In this case the selected grannies will go out into the courtyard She cannot deceive grannies that is the situation when the i th granny in the moment of appearing in the courtyard finds that now there are strictly less than a i other grannies except herself but including Maria is prohibited Please note that if several grannies appeared in the yard at the same time then each of them sees others at the time of appearance Your task is to find what maximum number of grannies including herself Maria can collect in the courtyard for the ceremony After all the more people in one place during quarantine the more effective the ceremony Consider an example if n 6 and a 1 5 4 5 1 9 then at the first step Maria can call grannies with numbers 1 and 5 each of them will see two grannies at the moment of going out into the yard note that a 1 1 le 2 and a 5 1 le 2 at the second step Maria can call grannies with numbers 2 3 and 4 each of them will see five grannies at the moment of going out into the yard note that a 2 5 le 5 a 3 4 le 5 and a 4 5 le 5 the 6 th granny cannot be called into the yard therefore the answer is 6 Maria herself and another 5 grannies ,"['// Author : PinkRabbit\n#include<bits/stdc++.h>\nusing namespace std;\n#define F(i,a,b) for(int i=a;i<=(b);++i)\n#define F2(i,a,b) for(int i=a;i<(b);++i)\n#define dF(i,a,b) for(int i=a;i>=(b);--i)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define Debug debug(""Passing [%s] in LINE %d\\n"",__FUNCTION__,__LINE__)\n#define MN 300005\n#define MM 600005\n#define ll long long\n#define mod 998244353\n#define inf 0x3f3f3f3f\n#define infll 0x3f3f3f3f3f3f3f3f\ntypedef pair<int,int> pii;\n#define pb push_back\n#define mkp make_pair\n#define fi first\n#define se second\ninline int qpow(int b,ll e,int m=mod){int a=1;for(;e;e>>=1,b=(ll)b*b%m)if(e&1)a=(ll)a*b%m;return a;}\nint n,m,q,k;\nint a[MN],b[MN],f[MN],g[MN];\nvector<int>G[MN];\nint h[MN],nxt[MM],to[MM],tot;\ninline void ins(int x,int y){nxt[++tot]=h[x];to[tot]=y;h[x]=tot;}\nint main(){int tests=1;scanf(""%d"",&tests);\nwhile(tests--){\n\tscanf(""%d"",&n);\n\tF(i,1,n)scanf(""%d"",a+i);\n\tsort(a+1,a+n+1);\n\tint p=0;\n\tF(i,1,n)if(a[i]<=i)p=i;\n\tprintf(""%d\\n"",p+1);\n}\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Consider the infinite sequence s of positive integers created by repeating the following steps Find the lexicographically smallest triple of positive integers a b c such that a oplus b oplus c 0 where oplus denotes the bitwise XOR operation a b c are not in s Here triple of integers a 1 b 1 c 1 is considered to be lexicographically smaller than triple a 2 b 2 c 2 if sequence a 1 b 1 c 1 is lexicographically smaller than sequence a 2 b 2 c 2 Append a b c to s in this order Go back to the first step You have integer n Find the n th element of s You have to answer t independent test cases A sequence a is lexicographically smaller than a sequence b if in the first position where a and b differ the sequence a has a smaller element than the corresponding element in b ,"[""/**\n *    author:  tourist\n *    created: 12.04.2020 17:26:50       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\npair<long long, long long> Get(int bit, long long idx) {\n  if (bit == 0) {\n    return make_pair(1, 2);\n  }\n  long long some = 1LL << (bit - 2);\n  auto q = Get(bit - 2, idx % some);\n  q.first ^= (1LL << (bit - 2));\n  q.second ^= (1LL << (bit - 1));\n  long long cs = idx / some;\n  if (cs == 1) {\n    q.first ^= (1LL << (bit - 2));\n    q.second ^= (1LL << (bit - 1));\n  }\n  if (cs == 2) {\n    q.first ^= (1LL << (bit - 1));\n    q.second ^= (1LL << (bit - 1)) ^ (1LL << (bit - 2));\n  }\n  if (cs == 3) {\n    q.first ^= (1LL << (bit - 1)) ^ (1LL << (bit - 2));\n    q.second ^= (1LL << (bit - 2));\n  }\n  q.first ^= 1LL << bit;\n  q.second ^= 1LL << (bit + 1);\n  return q;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    long long n;\n    cin >> n;\n    long long idx = (n - 1) / 3;\n    long long pos = (n - 1) % 3;\n    for (int bit = 0; ; bit += 2) {\n      long long here = 1LL << bit;\n      if (idx < here) {\n        auto p = Get(bit, idx);\n        cout << (pos == 0 ? p.first : (pos == 1 ? p.second : (p.first ^ p.second))) << '\\n';\n        break;\n      }\n      idx -= here;\n    }\n  }\n  return 0;\n}\n""]","[0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2200
You are given a string s of length n Let s define two operations you can apply on the string remove the first character of the string remove the second character of the string Your task is to find the number of distinct strings that can be generated by applying the given operations on the initial string any number of times possibly zero in any order ,"[""#include<iostream>\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<cstring>\n#include<random>\n#include<ctime>\nusing namespace std;\nconst int maxn=100005;\nint T,n,tg[30];\nchar str[maxn];\nsigned main(){\n\tios::sync_with_stdio(false);cin.tie(0);\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>n>>str+1;\n\t\tfor(int i=0;i<26;++i)tg[i]=0;\n\t\tint ans=0,num=0;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tif((++tg[str[i]-'a'])==1)++num;\n\t\t\tans+=num;\n\t\t}\n\t\tcout<<ans<<'\\n';\n\t}\n\treturn 0;\n}""]","[0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0]",1100
Lately a national version of a bingo game has become very popular in Berland There are players playing the game each player has a card with numbers The numbers on each card are distinct but distinct cards can have equal numbers The card of the th player contains numbers During the game the host takes numbered balls one by one from a bag He reads the number aloud in a high and clear voice and then puts the ball away All participants cross out the number if it occurs on their cards The person who crosses out all numbers from his card first wins If multiple people cross out all numbers from their cards at the same time there are no winners in the game At the beginning of the game the bag contains 100 balls numbered 1 through 100 the numbers of all balls are distinct You are given the cards for each player Write a program that determines whether a player can win the game at the most favorable for him scenario or not ,"['#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ld eps = 1e-12;\nconst int inf = 1e9;\n#define pb push_back\n#define pob pop_back\n#define i1 first\n#define i2 second\n#define mp make_pair\n\n#define file """"\n#define N 100500\n\nint use[120];\n\nint m[120][120];\nint ml[120];    \nbool ans[120];\n       \nint main()\n{\n\n    int n;\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(""%d"", &ml[i]);\n        for (int j = 0; j < ml[i]; j++)\n            scanf(""%d"", &m[i][j]);\n        sort(m[i], m[i] + ml[i]);\n    }\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j <= 100; j++) use[j] = 0;\n        for (int j = 0; j < ml[i]; j++) use[m[i][j]] = 1;\n        ans[i] = 1;\n        for (int j = 0; j < n; j++)\n            if (i != j)\n            {\n                bool f = 1;\n                for (int k = 0; k < ml[j] && f; k++)\n                    if (!use[m[j][k]])\n                    {\n                        f = 0;\n                        break;\n                    }\n                if (f)\n                {\n                    ans[i] = 0;\n                    break;\n                }\n            }\n    }\n    for (int i = 0; i < n; i++)\n        if (ans[i] == 1) printf(""YES\\n"");\n        else printf(""NO\\n"");\n\n    return 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Paul palindromes He assumes that string is if each its character is one of the first letters of the English alphabet and doesn t contain any palindrome contiguous substring of length 2 or more Paul has found a tolerable string of length Help him find the lexicographically next tolerable string of the same length or else state that such string does not exist ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nchar s[1234567];\n\nint main() {\n  int n, p;\n  scanf(""%d %d"", &n, &p);\n  scanf(""%s"", s);\n  for (int i = n - 1; i >= 0; i--) {\n    for (char c = s[i] + 1; c < \'a\' + p; c++) {\n      if (i - 1 >= 0 && s[i - 1] == c) {\n        continue;\n      }\n      if (i - 2 >= 0 && s[i - 2] == c) {\n        continue;\n      }\n      if (p == 2 && n > 2) {\n        continue;\n      }\n      if (p == 1 && n > 1) {\n        continue;\n      }\n      for (int j = 0; j < n; j++) {\n        if (j < i) {\n          putchar(s[j]);\n          continue;\n        }\n        if (j == i) {\n          s[i] = c;\n          putchar(s[i]);\n          continue;\n        }\n        for (char c = \'a\'; c < \'a\' + p; c++) {\n          if (j - 1 >= 0 && s[j - 1] == c) {\n            continue;\n          }\n          if (j - 2 >= 0 && s[j - 2] == c) {\n            continue;\n          }\n          s[j] = c;\n          break;\n        }\n        putchar(s[j]);\n      }\n      printf(""\\n"");\n      return 0;\n    }\n  }\n  puts(""NO"");\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1700
You are given a permutation dagger p of length n and a positive integer k le n In one operation you Choose k elements p i 1 p i 2 ldots p i k Remove them and then add them sorted in increasing order to the end of the permutation For example if p 2 5 1 3 4 and k 2 and you choose 5 and 3 as the elements for the operation then 2 color red 5 1 color red 3 4 rightarrow 2 1 4 color red 3 color red 5 Find the minimum number of operations needed to sort the permutation in increasing order It can be proven that it is always possible to do so dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ri int\n#define DEBUG(k...) fprintf(stderr,k)\ntypedef long long ll;\ntemplate<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,true:false;}\ntemplate<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,true:false;}\ntemplate<class T>inline void clear(T *arr,int siz,int val=0){memset(arr,val,sizeof(T)*(siz+1));}\nconst int maxn=2e5+10;\nint a[maxn],b[maxn],len,m,n,t_case;\nint main(){\n\tscanf(""%d"",&t_case);\n\twhile(t_case--){\n\t\tscanf(""%d%d"",&n,&m);\n\t\tlen=0;\n\t\tfor(ri i=1;i<=n;++i){\n\t\t\tscanf(""%d"",a+i);\n\t\t\tif(a[i]==len+1)++len;\n\t\t}\n\t\tprintf(""%d\\n"",(n-len+m-1)/m);\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
You are given a tree of n vertices numbered from 1 to n with edges numbered from 1 to n 1 A tree is a connected undirected graph without cycles You have to assign integer weights to each edge of the tree such that the resultant graph is a prime tree A is a tree where the weight of every path consisting of is prime A path should not visit any vertex twice The weight of a path is the sum of edge weights on that path Consider the graph below It is a prime tree as the weight of every path of two or less edges is prime For example the following path of two edges 2 to 1 to 3 has a weight of 11 2 13 which is prime Similarly the path of one edge 4 to 3 has a weight of 5 which is also prime Print valid assignment of weights such that the resultant tree is a prime tree If there is no such assignment then print 1 It can be proven that if a valid assignment exists one exists with weights between 1 and 10 5 as well ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define SZ(x) ((int)(x).size())\n#define each(x,v) for(auto&x:v)\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nconst int N=100005;\nint T,n,dep[N],ans[N];\nvector<pair<int,int> >e[N];\nvoid dfs1(int k1,int k2){\n\tdep[k1]=dep[k2]+1;\n\teach(x,e[k1])if(get<0>(x)!=k2){\n\t\tans[get<1>(x)]=dep[k1]&1?2:3;\n\t\tdfs1(get<0>(x),k1);\n\t}\n}\nint main(){\n#ifdef xay5421\n\tfreopen(""a.in"",""r"",stdin);\n#endif\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d"",&n);\n\t\trep(i,1,n)e[i].clear();\n\t\trep(i,2,n){\n\t\t\tint u,v;\n\t\t\tscanf(""%d%d"",&u,&v);\n\t\t\te[u].eb(v,i),e[v].eb(u,i);\n\t\t}\n\t\tbool err=0;\n\t\trep(i,1,n)if(SZ(e[i])>2){\n\t\t\terr=1;\n\t\t}\n\t\tif(err){\n\t\t\tputs(""-1"");\n\t\t\tcontinue;\n\t\t}\n\t\tint root=1;\n\t\trep(i,1,n)if(SZ(e[i])<=1){root=i;break;}\n\t\tdfs1(root,0);\n\t\trep(i,2,n)printf(""%d "",ans[i]);\n\t\tputs("""");\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]",1400
Evlampiy was gifted a rooted tree The vertices of the tree are numbered from 1 to n Each of its vertices also has an integer a i written on it For each vertex i Evlampiy calculated c i the number of vertices j in the subtree of vertex i such that a j a i Illustration for the second example the first integer is a i and the integer in parentheses is c iAfter the new year Evlampiy could not remember what his gift was He remembers the tree and the values of c i but he completely forgot which integers a i were written on the vertices Help him to restore initial integers ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>E[2010];\nint w[2010], root, n, Num[2010], ord[2010], cnt, vis[2010], Res[2010], Rank[2010], Ed[2010], inp[2010];\nvoid DFS(int a, int pp) {\n\tNum[a] = ++cnt;\n\tord[cnt] = a;\n\tfor (auto &x : E[a]) {\n\t\tDFS(x, a);\n\t}\n\tEd[a] = cnt;\n}\nint main() {\n\tint i, a, j;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &a);\n\t\tif (a) {\n\t\t\tE[a].push_back(i);\n\t\t}\n\t\telse {\n\t\t\troot = i;\n\t\t}\n\t\tscanf(""%d"", &w[i]);\n\t\tinp[i] = w[i];\n\t}\n\tDFS(root, 0);\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (!vis[ord[j]] && !w[ord[j]])break;\n\t\t}\n\t\tif (j == n + 1) {\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t\tint x = ord[j];\n\t\tvis[x] = 1;\n\t\tRes[i] = x;\n\t\tRank[x] = i;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (Num[j] < Num[x] && Num[x] <= Ed[j] && !vis[j]) {\n\t\t\t\tw[j]--;\n\t\t\t\tif (w[j] < 0) {\n\t\t\t\t\tputs(""NO"");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tint c = 0;\n\t\tfor (j = 1; j <= n; j++) {\n\t\t\tif (Num[i] < Num[j] && Num[j] <= Ed[i]) {\n\t\t\t\tif (Rank[i] > Rank[j])c++;\n\t\t\t}\n\t\t}\n\t\tif (c != inp[i]) {\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(""YES"");\n\tfor (i = 1; i <= n; i++)printf(""%d "", Rank[i]);\n}']","[1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Monocarp and Polycarp are learning new programming techniques Now they decided to try pair programming It s known that they have worked together on the same file for n m minutes Every minute exactly one of them made one change to the file Before they started there were already k lines written in the file Every minute exactly one of them does one of two actions adds a new line to the end of the file or changes one of its lines Monocarp worked in total for n minutes and performed the sequence of actions a 1 a 2 dots a n If a i 0 then he adds a new line to the end of the file If a i 0 then he changes the line with the number a i Monocarp performed actions strictly in this order a 1 then a 2 a n Polycarp worked in total for m minutes and performed the sequence of actions b 1 b 2 dots b m If b j 0 then he adds a new line to the end of the file If b j 0 then he changes the line with the number b j Polycarp performed actions strictly in this order b 1 then b 2 b m Restore their common sequence of actions of length n m such that all actions would be correct there should be no changes to lines that do not yet exist Keep in mind that in the common sequence Monocarp s actions should form the subsequence a 1 a 2 dots a n and Polycarp s subsequence b 1 b 2 dots b m They can replace each other at the computer any number of times Let s look at an example Suppose k 3 Monocarp first changed the line with the number 2 and then added a new line thus n 2 a 2 0 Polycarp first added a new line and then changed the line with the number 5 thus m 2 b 0 5 Since the initial length of the file was 3 in order for Polycarp to change line number 5 two new lines must be added beforehand Examples of correct sequences of changes in this case would be 0 2 0 5 and 2 0 0 5 Changes 0 0 5 2 wrong order of actions and 0 5 2 0 line 5 cannot be edited yet are not correct ,"['#ifndef CONTESTSMTH_HEADER_H\n#define CONTESTSMTH_HEADER_H\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\n\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing tree = __gnu_pbds::tree<K, V, less<K>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\ntemplate <typename K, typename V = __gnu_pbds::null_type>\nusing htable = __gnu_pbds::gp_hash_table<K, V>;\nusing llong = long long;\nauto isz = [](const auto& c) { return int(c.size()); };\n#ifdef VSE\nmt19937 rng(0);\n#else\nmt19937 rng((size_t) make_shared<char>().get());\n#endif\n\n#endif //CONTESTSMTH_HEADER_H\n\n#ifndef CONTESTSMTH_UTILS_H\n#define CONTESTSMTH_UTILS_H\n\n\n\ntemplate <typename T, T val = T()>\nauto make_vector(size_t d) {\n    return vector<T>(d, val);\n}\n\ntemplate <typename T, T val = T(), typename ...Ds>\nauto make_vector(size_t d, Ds... ds) {\n    return vector<decltype(make_vector<T, val>(ds...))>(d, make_vector<T, val>(ds...));\n}\n\nllong min(int a, llong b) {\n    return min<llong>(a, b);\n}\n\nllong min(llong a, int b) {\n    return min<llong>(a, b);\n}\n\nllong max(int a, llong b) {\n    return max<llong>(a, b);\n}\n\nllong max(llong a, int b) {\n    return max<llong>(a, b);\n}\n\ntemplate <typename T>\nvoid relmax(T& a, const T& b) {\n    a = max(a, b);\n}\n\ntemplate <typename T>\nvoid relmin(T& a, const T& b) {\n    a = min(a, b);\n}\n\n#endif //CONTESTSMTH_UTILS_H\n\n\nstruct Solver {\n    void solve() {\n        int k, n, m;\n        cin >> k >> n >> m;\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        vector<int> b(m);\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n        int x = 0, y = 0;\n        vector<int> ans;\n        for (int z = 0; z < n + m; z++) {\n            if (x < n && a[x] == 0) {\n                ans.push_back(0);\n                x++;\n                k++;\n            } else if (y < m && b[y] == 0) {\n                ans.push_back(0);\n                y++;\n                k++;\n            } else if (y == m || (x < n && a[x] < b[y])) {\n                if (a[x] > k) {\n                    cout << ""-1\\n"";\n                    return;\n                }\n                ans.push_back(a[x++]);\n            } else {\n                if (b[y] > k) {\n                    cout << ""-1\\n"";\n                    return;\n                }\n                ans.push_back(b[y++]);\n            }\n        }\n        for (int i : ans) {\n            cout << i << "" "";\n        }\n        cout << ""\\n"";\n    }\n};\n\nint main(int argc, char** argv) {\n#ifdef VSE\n    if (argc > 1) assert(freopen(argv[1], ""r"", stdin));\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n    cin >> t;\n    for (int it = 1; it <= t; it++) {\n        Solver().solve();\n    }\n    return 0;\n}\n\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1100
On a normal day at the hidden office in A R C Markland N Rin received an artifact given to her by the exploration captain Sagar After much analysis she now realizes that this artifact contains data about a strange flower which has existed way before the New Age However the information about its chemical structure has been encrypted heavily The chemical structure of this flower can be represented as a string p From the unencrypted papers included Rin already knows the length n of that string and she can also conclude that the string contains at most three distinct letters as in Carbon as in Hydrogen and as in Oxygen At each moment Rin can input a string s of an arbitrary length into the artifact s terminal and it will return every starting position of s as a of p However the artifact has limited energy and cannot be recharged in any way since the technology is way too ancient and is incompatible with any current A R C s devices To be specific The artifact only contains frac 7 5 units of energy For each time Rin inputs a string s of length t the artifact consumes frac 1 t 2 units of energy If the amount of energy reaches below zero the task will be considered failed immediately as the artifact will go black forever Since the artifact is so precious yet fragile Rin is very nervous to attempt to crack the final data Can you give her a helping hand ,"['/**\n *    author:  tourist\n *    created: 19.01.2020 17:31:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    string s(n, \'?\');\n    auto Ask = [&](string t) {\n      cout << ""? "" << t << endl;\n      int foo;\n      cin >> foo;\n      for (int i = 0; i < foo; i++) {\n        int bar;\n        cin >> bar;\n        --bar;\n        for (int j = 0; j < (int) t.size(); j++) {\n          s[bar + j] = t[j];\n        }\n      }\n    };\n    if (n <= 7) {\n      Ask(""CH"");\n      Ask(""CO"");\n      if (s == string(n, \'?\')) {\n        if (n == 4) {\n          Ask(""HO"");\n          if (s == string(n, \'?\')) {\n            Ask(""OH"");\n            if (s == string(n, \'?\')) {\n              Ask(""CCC"");\n              if (s == string(n, \'?\')) {\n                Ask(""OOO"");\n                if (s[0] == \'O\') {\n                  if (s[n - 1] == \'?\') s[n - 1] = \'C\';\n                } else {\n                  Ask(""HHH"");\n                  if (s[0] == \'H\') {\n                    if (s[n - 1] == \'?\') s[n - 1] = \'C\';\n                  } else {\n                    Ask(""OOCC"");\n                    if (s == string(n, \'?\')) s = ""HHCC"";\n                  }\n                }\n              } else {\n                Ask(""HCCC"");\n                Ask(""OCCC"");\n              }\n            } else {\n              for (int i = 0; i < n; i++) {\n                if (s[i] == \'?\') {\n                  s[i] = \'O\';\n                } else {\n                  break;\n                }\n              }\n              goto haha;\n            }\n          } else {\n            goto haha;\n          }\n        } else {\n          Ask(""CC"");\n          if (s[1] != \'?\' && s[0] == \'?\') {\n            string q = s;\n            q[0] = \'H\';\n            Ask(q);\n            if (s[0] == \'?\') {\n              s[0] = \'O\';\n            }\n          } else {\n            Ask(""OH"");\n            Ask(""HO"");\n            if (s == string(n, \'?\')) {\n              Ask(string(n, \'H\'));\n              Ask(string(n, \'O\'));\n              if (s == string(n, \'?\')) {\n                string q(n, \'H\');\n                q[n - 1] = \'C\';\n                Ask(q);\n                if (s == string(n, \'?\')) {\n                  s = string(n, \'O\');\n                  s[n - 1] = \'C\';\n                }\n              }\n            } else {\n              if (s[n - 1] == \'C\' && s.find(""H"") == string::npos && s.find(""O"") == string::npos) {\n                string q = s;\n                for (int i = 0; i < n; i++) {\n                  if (q[i] == \'?\') {\n                    q[i] = \'H\';\n                  }\n                }\n                Ask(q);\n                if (s[0] == \'?\') {\n                  for (int i = 0; i < n; i++) {\n                    if (s[i] == \'?\') {\n                      s[i] = \'O\';\n                    }\n                  }\n                }\n              } else {\n                int beg = 0;\n                while (beg < n) {\n                  if (s[beg] != \'?\') {\n                    ++beg;\n                    continue;\n                  }\n                  int end = beg;\n                  while (end + 1 < n && s[end + 1] == \'?\') {\n                    ++end;\n                  }\n                  if (beg == 0) {\n                    for (int i = beg; i <= end; i++) {\n                      s[i] = s[end + 1];\n                    }\n                  } else {\n                    for (int i = beg; i <= end; i++) {\n                      s[i] = s[beg - 1];\n                    }\n                  }\n                  beg = end + 1;\n                }\n                string q = s;\n                q[n - 1] = \'C\';\n                Ask(q);\n              }\n            }\n          }\n        }\n      } else {\n        haha:\n        while (true) {\n          bool any = false;\n          for (int i = 0; i < n; i++) {\n            if (s[i] == \'?\') {\n              any = true;\n              break;\n            }\n          }\n          if (!any) {\n            break;\n          }\n          bool found = false;\n          for (int i = 0; i + 4 < n; i++) {\n            if (s[i] == \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\' && s[i + 3] != \'?\' && s[i + 4] != \'?\') {\n              string q = ""C"";\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              q += s[i + 4];\n              Ask(q);\n              if (s[i] == \'?\') {\n                q[0] = \'O\';\n                Ask(q);\n                if (s[i] == \'?\') {\n                  s[i] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 4 < n; i++) {\n            if (s[i] != \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\' && s[i + 3] != \'?\' && s[i + 4] == \'?\') {\n              string q = """";\n              q += s[i];\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              q += ""C"";\n              Ask(q);\n              if (s[i + 4] == \'?\') {\n                q[4] = \'O\';\n                Ask(q);\n                if (s[i + 4] == \'?\') {\n                  s[i + 4] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 3 < n; i++) {\n            if (s[i] == \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\' && s[i + 3] != \'?\') {\n              string q = ""C"";\n              q += s[i + 1];\n              q += s[i + 2];\n              q += s[i + 3];\n              Ask(q);\n              if (s[i] == \'?\') {\n                q[0] = \'O\';\n                Ask(q);\n                if (s[i] == \'?\') {\n                  s[i] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 3 < n; i++) {\n            if (s[i] != \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\' && s[i + 3] == \'?\') {\n              string q = """";\n              q += s[i];\n              q += s[i + 1];\n              q += s[i + 2];\n              q += ""C"";\n              Ask(q);\n              if (s[i + 3] == \'?\') {\n                q[3] = \'O\';\n                Ask(q);\n                if (s[i + 3] == \'?\') {\n                  s[i + 3] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 2 < n; i++) {\n            if (s[i] == \'?\' && s[i + 1] != \'?\' && s[i + 2] != \'?\') {\n              string q = ""C"";\n              q += s[i + 1];\n              q += s[i + 2];\n              Ask(q);\n              if (s[i] == \'?\') {\n                q[0] = \'O\';\n                Ask(q);\n                if (s[i] == \'?\') {\n                  s[i] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          if (found) continue;\n          for (int i = 0; i + 2 < n; i++) {\n            if (s[i] != \'?\' && s[i + 1] != \'?\' && s[i + 2] == \'?\') {\n              string q = """";\n              q += s[i];\n              q += s[i + 1];\n              q += ""C"";\n              Ask(q);\n              if (s[i + 2] == \'?\') {\n                q[2] = \'O\';\n                Ask(q);\n                if (s[i + 2] == \'?\') {\n                  s[i + 2] = \'H\';\n                }\n              }\n              found = true;\n              break;\n            }\n          }\n          assert(found);\n        }\n      }\n    } else {\n      Ask(""CH"");\n      Ask(""CO"");\n      Ask(""HC"");\n      Ask(""HO"");\n      Ask(""OC"");\n      if (s == string(n, \'?\')) {\n        Ask(string(n, \'C\'));\n        if (s == string(n, \'?\')) {\n          Ask(""OHH"");\n          if (s == string(n, \'?\')) {\n            Ask(string(n - 1, \'O\'));\n            if (s == string(n, \'?\')) {\n              s = string(n, \'H\');\n            } else {\n              if (s[n - 1] == \'?\') {\n                s[n - 1] = \'H\';\n              }\n            }\n          } else {\n            for (int i = 0; i < n; i++) {\n              if (s[i] == \'?\') {\n                s[i] = \'O\';\n              } else {\n                break;\n              }\n            }\n            for (int i = n - 1; i >= 0; i--) {\n              if (s[i] == \'?\') {\n                s[i] = \'H\';\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else {\n        Ask(""OHH"");\n        int pref = 0, suf = 0;\n        int beg = 0;\n        while (beg < n) {\n          if (s[beg] != \'?\') {\n            ++beg;\n            continue;\n          }\n          int end = beg;\n          while (end + 1 < n && s[end + 1] == \'?\') {\n            ++end;\n          }\n          if (beg == 0) {\n            if (s[end + 1] != \'H\') {\n              for (int i = beg; i <= end; i++) {\n                s[i] = s[end + 1];\n              }\n            } else {\n              pref = end + 1;\n            }\n          } else {\n            if (end == n - 1) {\n              if (s[beg - 1] != \'O\') {\n                for (int i = beg; i <= end; i++) {\n                  s[i] = s[beg - 1];\n                }\n              } else {\n                for (int i = beg; i <= end - 1; i++) {\n                  s[i] = \'O\';\n                }\n                suf = 1;\n              }\n            } else {\n              if (s[beg - 1] == \'O\' && s[end + 1] == \'H\') {\n                for (int i = beg; i <= end; i++) {\n                  s[i] = \'O\';\n                }\n              } else {\n                assert(s[beg - 1] == s[end + 1]);\n                for (int i = beg; i <= end; i++) {\n                  s[i] = s[beg - 1];\n                }\n              }\n            }\n          }\n          beg = end + 1;\n        }\n        if (pref > 0) {\n          string q = s;\n          if (suf > 0) {\n            q.pop_back();\n          }\n          for (int i = 0; i < pref; i++) {\n            q[i] = \'O\';\n          }\n          Ask(q);\n          if (s[0] == \'?\') {\n            for (int i = 0; i < pref; i++) {\n              s[i] = \'H\';\n            }\n          }\n        }\n        if (suf > 0) {\n          string q = s;\n          q[n - 1] = \'O\';\n          Ask(q);\n          if (s[n - 1] == \'?\') {\n            s[n - 1] = \'H\';\n          }\n        }\n      }\n    }\n    cout << ""! "" << s << endl;\n    int foo;\n    cin >> foo;\n    if (foo == 0) break;\n  }\n  return 0;\n}\n']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3500
You are given a weighted tree with n vertices Recall that a tree is a connected graph without any cycles A weighted tree is a tree in which each edge has a certain weight The tree is undirected it doesn t have a root Since trees bore you you decided to challenge yourself and play a game on the given tree In a move you can travel from a node to one of its neighbors another node it has a direct edge with You start with a variable x which is initially equal to 0 When you pass through edge i x changes its value to x mathsf XOR w i where w i is the weight of the i th edge Your task is to go from vertex a to vertex b but you are allowed to enter node b if and only if after traveling to it the value of x will become 0 In other words you can travel to node b only by using an edge i such that x mathsf XOR w i 0 Once you enter node b the game ends and you win Additionally you can teleport at any point in time to any vertex except vertex b You can teleport from any vertex even from a Answer with if you can reach vertex b from a and otherwise Note that mathsf XOR represents the bitwise XOR operation ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,a,b;\nvector<pair<int,int>> edge[100005];\nset<int> st;\nvoid dfs1(int x, int p, int v){\n  for(auto it: edge[x]){\n    if(it.first!=p){\n      int y=(v^it.second);\n      st.insert(y);\n      dfs1(it.first,x,y);\n    }\n  }\n}\nbool dfs2(int x, int p, int v){\n  for(auto it: edge[x]){\n    if(it.first==p || it.first==b) continue;\n    int y=(v^it.second);\n    if(dfs2(it.first,x,y) || st.find(y)!=st.end())\n      return true;\n  }\n  return false;\n}\nmain(){\n  int t;\n  cin>>t;\n  while(t--){\n    st.clear();\n    cin>>n>>a>>b;\n    for(int i=0;i<=n;i++)\n      edge[i].clear();\n    for(int i=1;i<n;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      edge[a].push_back({b,c});\n      edge[b].push_back({a,c});\n    }\n    dfs1(b,-1,0);\n    if(dfs2(a,-1,0))\n      cout<<""YES\\n"";\n    else if(st.find(0)!=st.end())\n      cout<<""YES\\n"";\n    else\n      cout<<""NO\\n"";\n  }\n}']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1700
You are given two positive integer sequences a 1 ldots a n and b 1 ldots b m For each j 1 ldots m find the greatest common divisor of a 1 b j ldots a n b j ,"['/**\n *    author:  tourist\n *    created: 19.12.2020 12:31:44       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  long long g = 0;\n  for (int i = 1; i < n; i++) {\n    g = __gcd(g, abs(a[i] - a[0]));\n  }\n  for (int i = 0; i < m; i++) {\n    if (i > 0) {\n      cout << "" "";\n    }\n    cout << __gcd(g, a[0] + b[i]);\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1600
You are given a rooted tree of 2 n 1 vertices Every vertex of this tree has either 0 children or 2 children All leaves of this tree have the same distance from the root and for every non leaf vertex one of its children is the left one and the other child is the right one Formally you are given a The vertices of the tree are numbered in the following order the root has index 1 if a vertex has index x then its left child has index 2x and its right child has index 2x 1 Every vertex of the tree has a letter written on it either or Let s define the character on the vertex x as s x Let the of some vertex x be defined in the following way if the vertex x is a leaf then the of x be consisting of only one character s x otherwise the of x is s x f l x f r x where operator defines concatenation of strings f l x is the of the left child of x and f r x is the of the right child of x The of the tree is the of its root You have to calculate the number of different strings that can be obtained as the of the given tree if you are allowed to perform the following operation any number of times before constructing the of the tree choose any non leaf vertex x and swap its children so the left child becomes the right one and vice versa ,"['/**\n *    author:  tourist\n *    created: 22.04.2022 18:45:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  Mint ans = 1;\n  function<string(int)> Dfs = [&](int v) {\n    if (2 * v + 1 >= (int) s.size()) {\n      return (string) """" + s[v];\n    }\n    auto x = Dfs(2 * v + 1);\n    auto y = Dfs(2 * v + 2);\n    if (x != y) {\n      ans *= 2;\n    }\n    if (x > y) {\n      swap(x, y);\n    }\n    return (string) """" + s[v] + x + y;\n  };\n  Dfs(0);\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0]",2100
In Homer s school there are n students who love clubs Initially there are m clubs and each of the n students is in exactly one club In other words there are a i students in the i th club for 1 leq i leq m and a 1 a 2 dots a m n The n students are so unfriendly that every day one of them chosen from all of the n students gets angry The student who gets angry will do one of the following things With probability frac 1 2 he leaves his current club then creates a new club himself and joins it There is only one student himself in the new club he creates With probability frac 1 2 he does not create new clubs In this case he changes his club to a new one possibly the same club he is in currently with probability proportional to the number of students in it Formally suppose there are k clubs and there are b i students in the i th club for 1 leq i leq k before the student gets angry He leaves his current club and then joins the i th club with probability frac b i n We note that when a club becomes empty students will never join it because any student who gets angry will join an empty club with probability 0 according to the above statement Homer wonders the expected number of days until every student is in the same club for the first time We can prove that the answer can be represented as a rational number frac p q with gcd p q 1 Therefore you are asked to find the value of pq 1 bmod 998 244 353 It can be shown that q bmod 998 244 353 neq 0 under the given constraints of the problem ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(V<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(double& d) { str t; re(t); d = stod(t); }\nvoid re(long double& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(V<T>& x) { each(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { each(a,x) re(a); }\ntcT> void rv(int n, V<T>& x) { x.rsz(n); re(x); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t// #ifdef LOCAL\n\t// \treturn b ? ""true"" : ""false""; \n\t// #else \n\treturn ts((int)b);\n\t// #endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(V<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr("" ""); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << "", "";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\nvoid setPrec() { cout << fixed << setprecision(15); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid setIO(str s = """") {\n\tunsyncIO(); setPrec();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for USACO\n}\n\nvoid decrement() {}\ntcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n#define rvi(x,y) vi x(y); re(x);\n\n// https://codeforces.com/blog/entry/87598\n// P(x)=2N-x, Q(x)=N-x\n// evaluate Q(1...N-1) in blocks of B\n// evaluate P(1...N-1) in blocks of B\n// evaluate R(1...N-1) in blocks of B\n// \n\n// you want Q(1...N-1) + ... + P(1...a-1)*Q(a..N-1)\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = int((ll)v*m.v%MOD); return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: Basic poly ops including division. Can replace \\texttt{T} with double, complex.\n * Source: Own. Also see\n\t* https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/PolyInterpolate.h\n\t* https://github.com/ecnerwala/icpc-book/blob/master/content/numerical/fft.cpp\n * Verification: see FFT\n */\n\n// #include ""../../number-theory (11.1)/Modular Arithmetic/ModInt.h""\n\nusing T = mi; using poly = vector<T>;\nvoid remz(poly& p) { while (sz(p)&&p.bk==T(0)) p.pop_back(); }\npoly REMZ(poly p) { remz(p); return p; }\npoly rev(poly p) { reverse(all(p)); return p; }\npoly shift(poly p, int x) { \n\tif (x >= 0) p.insert(begin(p),x,0); \n\telse assert(sz(p)+x >= 0), p.erase(begin(p),begin(p)-x);\n\treturn p; \n}\npoly RSZ(const poly& p, int x) { \n\tif (x <= sz(p)) return poly(begin(p),begin(p)+x);\n\tpoly q = p; q.rsz(x); return q;  }\nT eval(const poly& p, T x) { // evaluate at point x\n\tT res = 0; R0F(i,sz(p)) res = x*res+p[i]; \n\treturn res; }\npoly dif(const poly& p) { // differentiate\n\tpoly res; FOR(i,1,sz(p)) res.pb(T(i)*p[i]); \n\treturn res; }\npoly integ(const poly& p) { // integrate\n\tpoly res(sz(p)+1); F0R(i,sz(p)) res[i+1] = p[i]/T(i+1);\n\treturn res; }\n\npoly& operator+=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] += r[i]; \n\treturn l; }\npoly& operator-=(poly& l, const poly& r) {\n\tl.rsz(max(sz(l),sz(r))); F0R(i,sz(r)) l[i] -= r[i]; \n\treturn l; }\npoly& operator*=(poly& l, const T& r) { each(t,l) t *= r; \n\treturn l;\t }\npoly& operator/=(poly& l, const T& r) { each(t,l) t /= r; \n\treturn l; }\npoly operator+(poly l, const poly& r) { return l += r; }\npoly operator-(poly l, const poly& r) { return l -= r; }\npoly operator-(poly l) { each(t,l) t *= -1; return l; }\npoly operator*(poly l, const T& r) { return l *= r; }\npoly operator*(const T& r, const poly& l) { return l*r; }\npoly operator/(poly l, const T& r) { return l /= r;\t }\npoly operator*(const poly& l, const poly& r) {\n\tif (!min(sz(l),sz(r))) return {};\n\tpoly x(sz(l)+sz(r)-1); \n\tF0R(i,sz(l)) F0R(j,sz(r)) x[i+j] += l[i]*r[j];\n\treturn x;\n}\npoly& operator*=(poly& l, const poly& r) { return l = l*r; }\n\npair<poly,poly> quoRem(poly a, poly b) { \n\tremz(a); remz(b); assert(sz(b));\n\tT lst = b.bk, B = T(1)/lst; each(t,a) t *= B; \n\teach(t,b) t *= B;\n\tpoly q(max(sz(a)-sz(b)+1,0));\n\tfor (int dif; (dif=sz(a)-sz(b)) >= 0; remz(a)) {\n\t\tq[dif] = a.bk; F0R(i,sz(b)) a[i+dif] -= q[dif]*b[i]; }\n\teach(t,a) t *= lst;\n\treturn {q,a}; // quotient, remainder\n}\npoly operator/(const poly& a, const poly& b) { return quoRem(a,b).f; }\npoly operator%(const poly& a, const poly& b) { return quoRem(a,b).s; }\n/**poly a = {1,3,5,8,6,0,0,0,0}, b = {1,5,1};\nps(quoRem(a,b)); a = 2*a, b = 2*b; ps(quoRem(a,b));*/\npoly gcd(poly a, poly b) { return b == poly{} ? a : gcd(b,a%b); }\nT resultant(poly a, poly b) { // R(A,B)\n\t// =b_m^n*prod_{j=1}^mA(mu_j)\n\t// =b_m^na_m^n*prod_{i=1}^nprod_{j=1}^m(mu_j-lambda_i)\n\t// =(-1)^{mn}a_n^m*prod_{i=1}^nB(lambda_i)\n\t// =(-1)^{nm}R(B,A)\n\t// Also, R(A,B)=b_m^{deg(A)-deg(A-CB)}R(A-CB,B)\n\tint ad = sz(a)-1, bd = sz(b)-1; \n\tif (bd <= 0) return bd < 0 ? 0 : pow(b.bk,ad);\n\tint pw = ad; a = a%b; pw -= (ad = sz(a)-1);\n\treturn resultant(b,a)*pow(b.bk,pw)*T((bd&ad&1)?-1:1);\n}\n\n/**\n * Description: Multiply polynomials of ints for any modulus $<2^{31}$. \n \t* For XOR convolution ignore \\texttt{m} within \\texttt{fft}. \n * Time: O(N\\log N)\n * Source: \n \t* KACTL (https://github.com/kth-competitive-programming/kactl/blob/master/content/numerical/NumberTheoreticTransform.h)\n \t* https://cp-algorithms.com/algebra/fft.html\n \t* https://csacademy.com/blog/fast-fourier-transform-and-variations-of-it\n \t* maroonrk\n * Verification: \n\t* https://judge.yosupo.jp/problem/convolution_mod\n\t* SPOJ polymul, CSA manhattan, CF Perfect Encoding\n\t* http://codeforces.com/contest/632/problem/E\n */\n\n// #include ""ModInt.h""\n// const int MOD = 998244353;\n\ntemplate<class T> void fft(V<T>& A, bool inv = 0) { // NTT\n\tint n = sz(A); assert((T::mod-1)%n == 0); V<T> B(n);\n\tfor(int b = n/2; b; b /= 2, swap(A,B)) {\n\t\tT w = pow(T::rt(),(T::mod-1)/n*b), m = 1;\n\t\tfor(int i = 0; i < n; i += b*2, m *= w) F0R(j,b) {\n\t\t\tT u = A[i+j], v = A[i+j+b]*m;\n\t\t\tB[i/2+j] = u+v; B[i/2+j+n/2] = u-v;\n\t\t}\n\t}\n\tif (inv) { reverse(1+all(A)); \n\t\tT z = T(1)/T(n); each(t,A) t *= z; }\n}\ntemplate<class T> V<T> mul(V<T> A, V<T> B) { // only special moduli for NTT\n\tif (!min(sz(A),sz(B))) return {};\n\tint s = sz(A)+sz(B)-1, n = 1; for (; n < s; n *= 2);\n\tbool eq = A == B; A.rsz(n), fft(A);\n\tif (eq) B = A; // squaring A, reuse result\n\telse B.rsz(n), fft(B);\n\tF0R(i,n) A[i] *= B[i];\n\tfft(A,1); A.rsz(s); return A;\n}\ntemplate<class M, class T> V<M> mulMod(V<T> x, V<T> y) {\n\tauto con = [](const V<T>& v) {\n\t\tV<M> w(sz(v)); F0R(i,sz(v)) w[i] = (int)v[i];\n\t\treturn w; };\n\treturn mul(con(x),con(y));\n}\ntemplate<class T> V<T> MUL(const V<T>& A, const V<T>& B) { // arbitrary moduli\n\tusing m0 = mint<(119<<23)+1,62>; auto c0 = mulMod<m0>(A,B);\n\tusing m1 = mint<(5<<25)+1,  62>; auto c1 = mulMod<m1>(A,B);\n\tusing m2 = mint<(7<<26)+1,  62>; auto c2 = mulMod<m2>(A,B);\n\tint n = sz(c0); V<T> res(n);\n\tm1 r01 = 1/m1(m0::mod); m2 r02 = 1/m2(m0::mod), r12 = 1/m2(m1::mod);\n\tF0R(i,n) { // a is remainder mod m0::mod, b fixes it mod m1::mod\n\t\tint a = c0[i].v, b = ((c1[i]-a)*r01).v, c = (((c2[i]-a)*r02-b)*r12).v;\n\t\tres[i] = (T(c)*m1::mod+b)*m0::mod+a; // c fixes it mod m2::mod\n\t}\n\treturn res;\n}\n\n\n/**\n * Description: Multiply small polys directly, otherwise use FFT.\n * Source: KACTL, https://cp-algorithms.com/algebra/fft.html\n */\n\n// #include ""Poly.h""\n// #include ""FFT.h""\n\nbool small(const poly& a, const poly& b) { // multiply directly\n\treturn (ll)sz(a)*sz(b) <= 10000; } \n// vmi smart(const vmi& a, const vmi& b) { return mul(a,b); }\n// vl smart(const vl& a, const vl& b) {\n// \tauto X = mul(vcd(all(a)),vcd(all(b)));\n// \tvl x(sz(X)); F0R(i,sz(X)) x[i] = round(X[i].real());\n// \treturn x; }\npoly conv(const poly& a, const poly& b) {\n\treturn small(a,b) ? a*b : mul(a,b); } \n\n/**\n * Description: computes $A^{-1}$ such that $AA^{-1}\\equiv 1\\pmod{x^n}$.\n \t* Newton\'s method: If you want $F(x)=0$ and $F(Q_k)\\equiv 0\\pmod{x^a}$\n \t* then $Q_{k+1}=Q_k-\\frac{F(Q_k)}{F\'(Q_k)}\\pmod{x^{2a}}$ satisfies\n \t* $F(Q_{k+1})\\equiv 0 \\pmod{x^{2a}}$. Application: if $f(n),g(n)$ are the\n \t* \\#s of forests and trees on $n$ nodes then \n \t* $\\sum_{n=0}^{\\infty}f(n)x^n=\\exp\\left(\\sum_{n=1}^{\\infty}\\frac{g(n)}{n!}\\right)$.\n * Time: O(N\\log N)\n * Source: CF, http://people.csail.mit.edu/madhu/ST12/scribe/lect06.pdf\n \t* https://cp-algorithms.com/algebra/polynomial.html\n * Usage: vmi v={1,5,2,3,4}; ps(exp(2*log(v,9),9)); // squares v\n * Verification: https://codeforces.com/contest/438/problem/E\n \t* https://codeforces.com/gym/102028/submission/77687049\n \t* https://loj.ac/problem/6703 (MultipointEval)\n */\n\n// #include ""PolyConv.h""\n\npoly inv(poly A, int n) { // Q-(1/Q-A)/(-Q^{-2})\n\tpoly B{1/A[0]};\n\tfor (int x = 2; x/2 < n; x *= 2)\n\t\tB = 2*B-RSZ(conv(RSZ(A,x),conv(B,B)),x);\n\treturn RSZ(B,n);\n}\npoly sqrt(const poly& A, int n) {  // Q-(Q^2-A)/(2Q)\n\tassert(A[0] == 1); poly B{1};\n\tfor (int x = 2; x/2 < n; x *= 2)\n\t\tB = T(1)/T(2)*RSZ(B+conv(RSZ(A,x),inv(B,x)),x);\n\treturn RSZ(B,n);\n}\npair<poly,poly> divi(const poly& f, const poly& g) { // return quotient and remainder\n\tif (sz(f) < sz(g)) return {{},f};\n\tpoly q = conv(inv(rev(g),sz(f)-sz(g)+1),rev(f));\n\tq = rev(RSZ(q,sz(f)-sz(g)+1));\n\tpoly r = RSZ(f-conv(q,g),sz(g)-1); return {q,r};\n}\npoly log(poly A, int n) { assert(A[0] == 1); // (ln A)\' = A\'/A\n\tA.rsz(n); return integ(RSZ(conv(dif(A),inv(A,n-1)),n-1)); }\npoly exp(poly A, int n) { assert(A[0] == 0);\n\tpoly B{1}, IB{1};\n\tfor (int x = 1; x < n; x *= 2) {\n\t\tIB = 2*IB-RSZ(conv(B,conv(IB,IB)),x); // inverse of B to x places\n\t\tpoly Q = dif(RSZ(A,x)); Q += RSZ(conv(IB,dif(B)-conv(B,Q)),2*x-1); \n\t\t// first x-1 terms of dif(B)-conv(B,Q) are zero\n\t\tB = B+RSZ(conv(B,RSZ(A,2*x)-integ(Q)),2*x); \n\t} // We know that Q=A\' is B\'/B to x-1 places, we want to find B\'/B to 2x-1 places\n\treturn RSZ(B,n);\n}\n// poly expOld(poly A, int n) { // Q-(lnQ-A)/(1/Q)\n// \tassert(A[0] == 0); poly B = {1};\n// \twhile (sz(B) < n) { int x = 2*sz(B);\n// \t\tB = RSZ(B+conv(B,RSZ(A,x)-log(B,x)),x); }\n// \treturn RSZ(B,n);\n// }\n\nvoid segProd(vector<poly>& stor, poly& v, int ind, int l, int r) { // v -> places to evaluate at\n\tif (l == r) { stor[ind] = {-v[l],1}; return; }\n\tint m = (l+r)/2; segProd(stor,v,2*ind,l,m); segProd(stor,v,2*ind+1,m+1,r);\n\tstor[ind] = conv(stor[2*ind],stor[2*ind+1]);\n}\nvoid evalAll(vector<poly>& stor, poly& res, poly v, int ind = 1) {\n\tv = divi(v,stor[ind]).s;\n\tif (sz(stor[ind]) == 2) { res.pb(sz(v)?v[0]:0); return; }\n\tevalAll(stor,res,v,2*ind); evalAll(stor,res,v,2*ind+1);\n}\npoly multiEval(poly v, poly p) {\n\tvector<poly> stor(4*sz(p)); segProd(stor,p,1,0,sz(p)-1);\n\tpoly res; evalAll(stor,res,v); return res; }\n\npoly combAll(vector<poly>& stor, poly& dems, int ind, int l, int r) {\n\tif (l == r) return {dems[l]};\n\tint m = (l+r)/2;\n\tpoly a = combAll(stor,dems,2*ind,l,m), b = combAll(stor,dems,2*ind+1,m+1,r);\n\treturn conv(a,stor[2*ind+1])+conv(b,stor[2*ind]);\n}\npoly interpolate(vector<pair<T,T>> v) {\n\tint n = sz(v); poly x; each(t,v) x.pb(t.f);\n\tvector<poly> stor(4*n); segProd(stor,x,1,0,n-1);\n\tpoly dems; evalAll(stor,dems,dif(stor[1]));\n\tF0R(i,n) dems[i] = v[i].s/dems[i];\n\treturn combAll(stor,dems,1,0,n-1);\n}\n\nconst int B = 1<<15;\n\nint M, N = 0;\n\nmi get_p(int i) { return 2*N-i; }\n\nmi get_q(int i) { return N-i; }\n\n// poly divideAndMultiply(V<poly> v) {\n// \tif (sz(v) == 1) return v[0];\n// \tpoly a = divideAndMultiply(V<poly>(begin(v),begin(v)+sz(v)/2));\n// \tpoly b = divideAndMultiply(V<poly>(begin(v)+sz(v)/2,end(v)));\n// \trtn mul(a,b);\n// }\n\n// poly Bconsecutive(mi a, mi b) { // a*(x+i)+b\n// \tV<poly> v; FOR(i,1,B+1) v.pb({a*i+b,a});\n// \treturn divideAndMultiply(v);\n// }\n\nAR<poly,3> getR(int l, int r) { \n\t// product of p, product of q, desired\n\tif (l == r) {\n\t\tpoly tmp_p{2*N-l,-1};\n\t\tpoly tmp_q{N-l,-1};\n\t\treturn {tmp_p,tmp_q,tmp_q};\n\t}\n\tint m = (l+r)/2;\n\tauto ans_l = getR(l,m), ans_r = getR(m+1,r);\n\treturn {mul(ans_l[0],ans_r[0]),mul(ans_l[1],ans_r[1]),\n\t\tmul(ans_l[2],ans_r[1])+mul(ans_l[0],ans_r[2])};\n\t// p(x+l), q(x+l), q(x+l)\n\t// q(x+1) ...          q(x+B)\n\t// p(x+1) ... p(x+B-1) q(x+B)\n}\n\n// p(x+1)*...*p(x+B)\n// q(x+1)*...*q(x+B)\n\n\nmi tot_q_prod = 1;\n\nmi eval_dumb(int t) {\n\tmi sum = 0;\n\tFOR(i,1,t+1) {\n\t\tmi prod = 1;\n\t\tFOR(j,1,i) prod *= get_p(j);\n\t\tFOR(j,i,N) prod *= get_q(j);\n\t\tsum += prod;\n\t}\n\tsum /= tot_q_prod;\n\t// FOR(j,1,N) sum /= get_q(j);\n\treturn sum;\n}\n\npoly PP,QQ,RR;\npoly suf_prod;\n\nmi eval_smart(int a) { // 0 to a-1\n\tmi ans = 0;\n\tmi pref_prod = 1;\n\t// last term is P[1..a-1]\n\tfor (int i = 0; ; ++i) {\n\t\t// P[1..B*i] Q[B*i+1] onwards\n\t\t// over to\n\t\t// P[1..B*(i+1)-1] Q[B*i+B] onwards\n\t\tif (B*i+B-1 < a) {\n\t\t\tans += pref_prod*RR[i]*suf_prod[i+1]; // suf_prod[i] has B*i+1 onwards\n\t\t} else {\n\t\t\t// start with P[1..B*i] .. Q[B*i+1 onwards]\n\t\t\tmi cur_prod = pref_prod*suf_prod[i];\n\t\t\tFOR(j,B*i,a) {\n\t\t\t\tif (j > B*i) {\n\t\t\t\t\tcur_prod /= get_q(j);\n\t\t\t\t\tcur_prod *= get_p(j);\n\t\t\t\t}\n\t\t\t\tans += cur_prod;\n\t\t\t}\n\t\t\t// B*i to a-1\n\t\t\tbreak;\n\t\t}\n\t\tpref_prod *= PP[i];\n\t\t// PP[0]..PP[i-1]*RR[i]*QQ[i+1]*QQ[i+2]+...\n\t\t// B*i to B*i+B-1\n\t}\n\tdbg(""DIVIDING"",tot_q_prod);\n\tans /= tot_q_prod;\n\treturn ans;\n}\n\nmi eval(int t) {\n\t// mi x = eval_dumb(t);\n\tmi y = eval_smart(t);\n\t// assert(x == y);\n\treturn y;\n}\n\nint main() {\n\tsetIO(); \n\tre(M); rvi(A,M);\n\teach(t,A) N += t;\n\n\tauto PQR = getR(1,B);\n\tpoly P = PQR[0];\n\tpoly Q = PQR[1];\n\tpoly R = PQR[2];\n\n\tpoly places; F0R(i,B) places.pb(B*i);\n\n\tPP = multiEval(P,places);\n\t// F0R(i,B) {\n\t// \tmi mul = 1;\n\t// \tFOR(j,1,B+1) mul *= get_p(B*i+j);\n\t// \tdbg(""HUH"",i,PP[i],mul);\n\t// }\n\tQQ = multiEval(Q,places);\n\tRR = multiEval(R,places);\n\tfor (int i = 0; ; ++i) {\n\t\tif (B*i+B < N) {\n\t\t\ttot_q_prod *= QQ[i];\n\t\t} else {\n\t\t\tFOR(cur,B*i+1,N) tot_q_prod *= get_q(cur);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint ind = 0; while (B*ind < N) ++ind;\n\tsuf_prod = poly(ind+1);\n\tsuf_prod[ind] = suf_prod[ind-1] = 1;\n\tFOR(j,B*(ind-1)+1,N) suf_prod[ind-1] *= get_q(j);\n\tR0F(i,ind-1) {\n\t\tassert(i < sz(QQ));\n\t\tsuf_prod[i] = QQ[i]*suf_prod[i+1];\n\t\t// dbg(""HA"",i,QQ[i],suf_prod[i]);\n\t}\n\tdbg(""CALCED"",tot_q_prod);\n\t// dbg(""HA"",suf_prod[0],suf_prod,tot_q_prod); exit(0);\n\t// mi test_prod = 1; FOR(i,1,N) test_prod *= i;\n\t// dbg(tot_prod,test_prod);\n\n\n\n\tmi ans = 0;\n\teach(t,A) ans += eval(t);\n\tans -= eval(N);\n\tps(-2*ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",3500
Erelong Leha was bored by calculating of the greatest common divisor of two factorials Therefore he decided to solve some crosswords It s well known that it is a very interesting occupation though it can be very difficult from time to time In the course of solving one of the crosswords Leha had to solve a simple task You are able to do it too aren t you Leha has two strings and The hacker wants to change the string at such way that it can be found in as a substring All the changes should be the following Leha chooses one position in the string and replaces the symbol in this position with the question mark The hacker is sure that the question mark in comparison can play the role of an arbitrary symbol For example if he gets string as a result it will appear in as a substring Guaranteed that the length of the string doesn t exceed the length of the string Help the hacker to replace in as few symbols as possible so that the result of the replacements can be found in as a substring The symbol should be considered equal to any other symbol ,"['#include <bits/stdc++.h>\n\nint N, M;\nstd::string S, T;\nint ans = -1, best = 1E9;\n\nint main () {\n\tstd::ios::sync_with_stdio (0);\n\tstd::cin.tie (0);\n\tstd::cout.tie (0);\n\tstd::cin >> N >> M >> S >> T;\n\tfor (int i = 0; i < T.size () - S.size () + 1; ++i) {\n\t\tint cur = 0;\n\t\tfor (int j = 0; j < S.size (); ++j)\n\t\t\tif (S[j] != T[i + j]) ++cur;\n\t\tif (best > cur) {\n\t\t\tbest = cur;\n\t\t\tans = i;\n\t\t}\n\t}\n\tstd::cout << best << std::endl;\n\tfor (int i = 0; i < S.size (); ++i)\n\t\tif (S[i] != T[ans + i]) std::cout << i + 1 << "" "";\n}\n\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1000
Let s denote a free matrix as a binary that is consisting of only s and s matrix such that every square submatrix of size of this matrix contains at least one zero Consider the following problem You don t have to solve this problem Instead you have to construct a few tests for it You will be given numbers For every find two integers and such that the answer for the aforementioned problem is exactly if we set and ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint main() {\n\tint T;\n\tscanf(""%d"", &T);\n\twhile (T--) {\n\t\tll x, i;\n\t\tscanf(""%lld"", &x);\n\t\tif (x == 0) {\n\t\t\tprintf(""1 1\\n"");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (i = 1; i * i < x; i++) {\n\t\t\tif (x%i) continue;\n\n\t\t\tll t1 = i, t2 = x / i;\n\t\t\tif ((t1 + t2) % 2) continue;\n\t\t\tll N = (t1 + t2) / 2, NM = (t2 - t1) / 2;\n\t\t\tll M = N / NM;\n\t\t\tif (N*N - (N/M)*(N/M) == x) {\n\t\t\t\tprintf(""%lld %lld\\n"", N, M);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i*i >= x) printf(""-1\\n"");\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Yura is tasked to build a closed fence in shape of an arbitrary non degenerate simple quadrilateral He s already got three straight fence segments with known lengths a b and c Now he needs to find out some possible integer length d of the fourth straight fence segment so that he can build the fence using these four segments In other words the fence should have a quadrilateral shape with side lengths equal to a b c and d Help Yura find any possible length of the fourth side A non degenerate simple quadrilateral is such a quadrilateral that no three of its corners lie on the same line and it does not cross itself ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define ll long long int\n#define isnum(ch) (\'0\'<=ch&&ch<=\'9\')\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\n#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)\n#define gc (_op==_ed&&(_ed=(_op=_buf)+fread(_buf,1,100000,stdin),_op==_ed)?EOF:*_op++)\nchar _buf[100000],*_op(_buf),*_ed(_buf);\nI getint(){\n\tint _s=0,_f=1;char _ch=gc;\n\twhile(!isnum(_ch))(_ch==\'-\')&&(_f=-1),_ch=gc;\n\twhile(isnum(_ch))_s=_s*10+_ch-48,_ch=gc;\n\treturn _s*_f;\n}\nconst int N=2e5+1,mod=998244353;\nV check(int&x){x-=mod,x+=x>>31&mod;}\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nint T,n;\nll a[N];\nV input(){\n\tn=3;\n\tFOR(i,1,n)a[i]=getint();\n\tcout<<a[3]+a[2]+a[1]-1<<\'\\n\';\n}\nV init(){\n\t\n}\nV work(){\n\t\n}\nint main(){\n//\tfreopen(""test.in"",""r"",stdin);\n//\tfreopen("".out"",""w"",stdout);\n\tfor(scanf(""%d"",&T);T--;){\n\t\tinput();\n\t\tinit();\n\t\twork();\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",800
You are given two integers n and k There is a graph on n vertices numbered from 1 to n which initially has no edges You have to assign each vertex an integer let a i be the integer on the vertex i All a i should be distinct integers from 1 to n After assigning integers for every pair of vertices i j you add an edge between them if i j a i a j le k Your goal is to create a graph which can be partitioned into the minimum possible for the given values of n and k number of cliques Each vertex of the graph should belong to exactly one clique Recall that a clique is a set of vertices such that every pair of vertices in it are connected with an edge So we also ask you to print the partition itself ,"['/**\n *    author:  tourist\n *    created: 15.03.2024 10:55:44\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n, -1);\n    vector<int> c(n, -1);\n    int cnt = 0;\n    int beg = 0;\n    while (beg < n) {\n      k = min(k, n - beg);\n      int half = (k - 1) / 2;\n      for (int i = 0; i < k; i++) {\n        a[beg + i] = beg + (half - 1 - i);\n        if (a[beg + i] < beg) {\n          a[beg + i] += k;\n        }\n        c[beg + i] = cnt;\n      }\n      cnt += 1;\n      beg += k;\n    }\n    for (int i = 0; i < n; i++) {\n      cout << a[i] + 1 << "" \\n""[i == n - 1];\n    }\n    cout << cnt << \'\\n\';\n    for (int i = 0; i < n; i++) {\n      cout << c[i] + 1 << "" \\n""[i == n - 1];\n    }\n  }\n  return 0;\n}\n']","[1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
 Once upon a time a man came to the sea The sea was stormy and dark The man started to call for the little mermaid to appear but alas he only woke up Cthulhu Whereas on the other end of the world Pentagon is actively collecting information trying to predict the monster s behavior and preparing the secret super weapon Due to high seismic activity and poor weather conditions the satellites haven t yet been able to make clear shots of the monster The analysis of the first shot resulted in an undirected graph with vertices and edges Now the world s best minds are about to determine whether this graph can be regarded as Cthulhu or not To add simplicity let s suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it Formally we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees whose roots are connected by a simple cycle It is guaranteed that the graph contains no multiple edges and self loops ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint l[100];\nint n, m;\n\nint leader (int v) {\n\tif (l[v] != v)\n\t\tl[v] = leader (l[v]);\n\treturn l[v];\n}\n\nvoid unite (int v1, int v2) {\n\tv1 = leader (v1);\n\tv2 = leader (v2);\n\tl[v1] = v2;\n}\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tscanf (""%d%d"", &n, &m);\n\tif (m != n) {\n\t\tcout << ""NO"" << endl;\n\t\treturn 0;\n\t}\n\tforn (i, n)\n\t\tl[i] = i;\n\tforn (i, n) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tx --;\n\t\ty --;\n\t\tunite (x, y);\n\t}\n\tforn (i, n-1)\n\t\tif (leader (i) != leader (i+1)) {\n\t\t\tcout << ""NO"" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tcout << ""FHTAGN!"" << endl;\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1500
You are given a directed unweighted graph without loops with n vertexes and a path in it that path is not necessary simple given by a sequence p 1 p 2 ldots p m of m vertexes for each 1 leq i m there is an arc from p i to p i 1 Define the sequence v 1 v 2 ldots v k of k vertexes as if v is a subsequence of p v 1 p 1 v k p m and p is one of the shortest paths passing through the vertexes v 1 ldots v k in that order A sequence a is a subsequence of a sequence b if a can be obtained from b by deletion of several possibly zero or all elements It is obvious that the sequence p is good but your task is to find the good subsequence If there are multiple shortest good subsequences output any of them ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nbool board[102][102];\nint dist[102][102];\nint k;\nint arr[1000002];\nint DP[1000002];\nint mark[102];\nint recent[1000002];\n\nvoid track(int x){\n    if(!x) return;\n    track(recent[x]);\n    printf(""%d "", arr[x]);\n}\n\nint main(){\n    scanf(""%d"", &n);\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=n; j++){\n            scanf(""%1d"", &board[i][j]);\n            dist[i][j] = board[i][j];\n            if(!board[i][j]) dist[i][j] = 1000;\n        }\n    }\n\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=n; j++){\n            for(int k=1; k<=n; k++){\n                if(dist[k][j] > dist[k][i] + dist[i][j] && dist[k][i] != 1000 && dist[i][j] != 1000){\n                    dist[k][j] = dist[k][i] + dist[i][j];\n                }\n            }\n        }\n    }\n\n    scanf(""%d"", &k);\n    for(int i=1; i<=k; i++) scanf(""%d"", &arr[i]), DP[i] = 1e6+2;\n\n    DP[1] = 1;\n    for(int i=1; i<=k; i++){\n        for(int j=1; j<=n; j++){\n            if(arr[i] == j) continue;\n            if(!mark[j]) continue;\n            if(dist[j][arr[i]] == 1000 || dist[j][arr[i]] < i-mark[j]) continue;\n            if(DP[i] > DP[mark[j]]+1){\n                DP[i] = DP[mark[j]]+1;\n                recent[i] = mark[j];\n            }\n        }\n//        printf(""%d: %d\\n"", i, DP[i]);\n        mark[arr[i]] = i;\n    }\n\n    printf(""%d\\n"", DP[k]);\n    track(k);\n}\n']","[1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1700
Innocentius has a problem his computer monitor has broken Now some of the pixels are dead that is they are always black As consequence Innocentius can t play the usual computer games He is recently playing the following game with his younger brother Polycarpus Innocentius is touch typing a program that paints a white square one pixel wide frame on the black screen As the monitor is broken some pixels that should be white remain black Polycarpus should look at what the program displayed on the screen and guess the position and size of the frame Innocentius has painted Polycarpus doesn t like the game but Innocentius persuaded brother to play as the game is good for the imagination and attention Help Polycarpus automatize his part in the gaming process Write the code that finds such possible frame that the frame s width is 1 pixel the frame doesn t go beyond the borders of the screen all white pixels of the monitor are located on the frame of all frames that satisfy the previous three conditions the required frame must have the smallest size Formally a square frame is represented by such pixels of the solid square that are on the square s border that is are not fully surrounded by the other pixels of the square For example if the frame s size is then it consists of 8 pixels if its size is then it contains 4 pixels and if then the frame is reduced to a single pixel ,"['#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\nconst ld eps = 1e-12;\nconst int inf = 1e9;\n#define pb push_back\n#define pob pop_back\n#define i1 first\n#define i2 second\n#define mp make_pair\n\n#define file """"\n#define N 100500\n\nchar a[2300][2300];\n       \nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++)\n        scanf(""%s"", a[i]);\n    int l = inf, r = -inf, u = inf, d = -inf;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            if (a[i][j] == \'w\')\n            {\n                l = min(l, j);\n                r = max(r, j);\n                u = min(u, i);\n                d = max(d, i);\n            }\n    if (l == inf)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    bool L = 0, R = 0, U = 0, D = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if (i == u && j > l && j < r && a[i][j] == \'w\') U = 1;\n            if (i == d && j > l && j < r && a[i][j] == \'w\') D = 1;\n            if (j == l && i > u && i < d && a[i][j] == \'w\') L = 1;\n            if (j == r && i > u && i < d && a[i][j] == \'w\') R = 1;\n        }\n    int s = max(r - l, d - u);\n    if (l == r || u == d)\n    {\n        if (l == r)\n        {\n            if (r - s >= 0) l = r - s;\n            else if (l + s < m) r = l + s;\n            else if (L || R)\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n            else\n            {\n                l = max(0, r - s);\n                r = min(m - 1, l + s);\n                if (r - l != s)\n                {\n                    cout << -1 << endl;\n                    return 0;\n                }\n            }\n        }\n        else\n        {\n            if (d - s >= 0) u = d - s;\n            else if (u + s < n) d = u + s;  \n            else if (U || D)\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n            else\n            {\n                u = max(0, d - s);\n                d = min(n - 1, u + s);\n                if (d - u != s)\n                {\n                    cout << -1 << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    else\n    {                         \n    if (U && D && d - u != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (L && R && r - l != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (U && d - u != s) d = s + u;\n    if (D && d - u != s) u = d - s;\n    if (L && r - l != s) r = l + s;\n    if (R && r - l != s) l = r - s;\n    if (!U && !D && d - u != s)\n    {\n        u = max(0, d - s);\n        d = min(n - 1, u + s);\n    }\n    if (!L && !R && r - l != s)\n    {\n        l = max(0, r - s);\n        r = min(m - 1, l + s);\n    }\n    if (u < 0 || l < 0 || d >= n || r >= m)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    if (d - u != s || r - l != s)\n    {\n        cout << -1 << endl;\n        return 0;\n    }\n    }\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n        {\n            if ((i == u || i == d) && j >= l && j <= r)\n            {\n                if (a[i][j] != \'w\') a[i][j] = \'+\';\n            }\n            else if (i >= u && i <= d && (j == l || j == r))\n            {\n                if (a[i][j] != \'w\') a[i][j] = \'+\';\n            }\n            else if (a[i][j] == \'w\')\n            {\n                cout << -1 << endl;\n                return 0;\n            }\n        }\n    for (int i = 0; i < n; i++)\n        printf(""%s\\n"", a[i]);\n\n\n\n    return 0;\n}']","[1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Master Andrey loves trees dagger very much so he has a tree consisting of n vertices But it s not that simple Master Timofey decided to steal one vertex from the tree If Timofey stole vertex v from the tree then vertex v and all edges with one end at vertex v are removed from the tree while the numbers of other vertices remain unchanged To prevent Andrey from getting upset Timofey decided to make the resulting graph a tree again To do this he can add edges between any vertices a and b but when adding such an edge he must pay a b coins to the Master s Assistance Center Note that the resulting tree vertex v Timofey has not yet decided which vertex v he will remove from the tree so he wants to know for each vertex 1 leq v leq n the minimum number of coins needed to be spent to make the graph a tree again after removing vertex v as well as which edges need to be added dagger A tree is an undirected connected graph without cycles ,"['#include<bits/stdc++.h>\n#pragma GCC optimize(""Ofast,no-stack-protector,fast-math"",3)\n#define cln cerr<<""Line:   ""<<__LINE__<<""    ""\n#define pct __builtin_popcountll\n#define ctz __builtin_ctzll\n#define mkp make_pair\n#define MST(x) memset(x,0,sizeof(x))\n#define all(x) x.begin(),x.end()\nusing namespace std;\nconstexpr int N=(1<<20)+100,_g=3,M=998244353,M1=1e9+7,M2=1e9+9;\nnamespace fast_io{\n\tchar buf[N+10],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2))?EOF:*p1++\n\tstatic inline void read(int &x){\n\t\tfor(c=gc;c<48;c=gc);\n\t\tfor(x=0;c>47;x=(x<<1)+(x<<3)+(48^c),c=gc);\n\t}\n\tchar ob[N+100],stk[505];int tp,ot;\n\tvoid fls(){fwrite(ob,1,ot,stdout),ot=0;}\n    int cntt;\n\tstatic inline void write(int x){\n        if(!cntt)atexit(fls),cntt=1;\n\t\twhile(x>9)stk[++tp]=48^(x%10),x/=10;\n\t\tfor(ob[ot++]=48^x;tp;ob[ot++]=stk[tp--]);\n\t\tob[ot++]=\'\\n\';if(ot>N)fls();\n\t}\n}using fast_io::read;\nusing fast_io::write;\nusing ll=long long;\n#define pli pair<ll,int>\n#define pii pair<int,int>\nusing ul=unsigned long long;\nusing ld=double;\nmt19937_64 rg(random_device{}());\nconst ll INF=3e18;\ntemplate<typename tp1,typename tp2>\n    void ckmx(tp1 &x,const tp2 &y){x<y?x=y:0;}\ntemplate<typename tp1,typename tp2>\n    void ckmn(tp1 &x,const tp2 &y){x>y?x=y:0;}\nvoid add(int &x,int y){(x+=y)>=M?x-=M:0;}\nvoid del(int &x,int y){(x-=y)<0?x+=M:0;}\nvoid add(int &x,ul y,int z){x=(y*z+x)%M;}\nvoid del(int &x,ul y,int z){(x-=y*z%M)<0&&(x+=M);}\nconstexpr int qp(ll a,ll x=M-2){\n    int res=1;for(;x;x>>=1,a=a*a%M)\n        (x&1)&&(res=a*res%M);return res;\n}\nstruct NTP{};\ntemplate<typename tp1,typename tp2,int N>\nstruct Htb{\n    static constexpr int M=1e7+19;\n    int hd[M+3],to[N],ct;\n    tp1 ed[N];tp2 w[N];\n    static int hc(ul v){\n        v^=v<<13,v^=v>>7;\n        return (v^(v<<17))%M;\n    }\n    void ins(tp1 x,tp2 y){\n        int &p=hd[hc(x)];\n        ed[++ct]=x,to[ct]=p;\n        w[p=ct]=y;\n    }\n    int count(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return 1;\n        return 0;\n    }\n    pair<tp2,bool>find(tp1 x){\n        for(int i=hd[hc(x)];i;i=to[i])\n            if(ed[i]==x)return mkp(w[i],true);\n        return mkp(0,false);\n    }\n    int operator[](tp1 x){\n        int &p=hd[hc(x)];\n        for(int i=p;i;i=to[i])\n            if(ed[i]==x)return i;\n        ed[++ct]=x,to[ct]=p;\n        return p=ct;\n    }\n    void clear(){while(ct)hd[hc(ed[ct--])]=0;}\n};\nnamespace MATH{\n    vector<int>jc,nv;\n    int dv2(int x){return x&1?x+M>>1:x>>1;}\n    int C(int n,int m){\n        assert(m<=n);\n        return 1ll*jc[n]*nv[m]%M*nv[n-m]%M;\n    }\n    int P(int n,int m){\n        return 1ll*jc[n]*nv[n-m]%M;\n    }\n    int D(int n,int m){\n        if(n<0||m<0)return 0;\n        if(!n)return 1;\n        if(!m)return 0;\n        return C(n+m-1,m-1);\n    }\n    void init(int n){\n        int x;\n        jc.resize(n+2),nv.resize(n+2);\n        jc[0]=nv[0]=jc[1]=nv[1]=1;\n        for(x=2;x<=n;++x){\n            jc[x]=1ll*x*jc[x-1]%M;\n            nv[x]=ll(M-M/x)*nv[M%x]%M;\n        }\n        for(x=1;x<=n;++x)nv[x]=1ll*nv[x-1]*nv[x]%M;\n    }\n}\nstruct DET{\n    int a[3005][3005],n;\n    int run(){\n        if(!n)return 1;\n        int x,y,z,k,res=1;\n        for(x=1;x<=n;++x){\n            for(y=x;y<=n&&!a[y][x];++y);\n            if(y>n)return 0;\n            if(y>x){\n                for(k=1;k<=n;++k)swap(a[x][k],a[y][k]);\n                res&&(res=M-res); \n            }\n            k=qp(a[x][x]);\n            res=1ll*res*a[x][x]%M;\n            for(z=1;z<=n;++z)\n                a[x][z]=1ll*a[x][z]*k%M;\n            for(y=1;y<=n;++y)\n                if(x!=y){\n                    k=a[y][x];\n                    for(z=1;z<=n;++z)\n                        del(a[y][z],a[x][z],k);\n                }\n        }\n        for(x=1;x<=n;++x)\n            res=1ll*res*a[x][x]%M;\n        return res;\n    }\n}det;\nll Gcd(ll x,ll y){\n    if(!x||!y)return x|y;\n    int k=min(ctz(x),ctz(y));\n    ll d;y>>=ctz(y);\n    while(x){\n        x>>=ctz(x),d=x-y;\n        if(x<y)y=x;\n        if(d<0)x=-d;\n        else x=d;\n    }return y<<k;\n}\nusing ll=long long;\nusing ul=unsigned long long;\nconstexpr int bceil(int n){return 1<<(std::__lg(n-1)+1);}\ntemplate<int mod>struct NTT{\n    constexpr int dil(int x){return x>>31?x+mod:x;}\n    constexpr int mul(ul x,int y){return x*y%mod;}\n    constexpr int qpow(int a,int b,int r=1){for(;b;a=mul(a,a),b>>=1){r=b&1?mul(r,a):r;}return r;}\n    int w[N>>1],wI[N>>1];\n    void init(int n){\n        int l=bceil(n)>>1;w[0]=wI[0]=1;\n        for(int i=1;i<l;i<<=1){w[i]=qpow(_g,((mod-1)>>2)/i),wI[i]=qpow(_g,mod-1-((mod-1)>>2)/i);}\n        for(int i=1;i<l;++i){w[i]=mul(w[i&(i-1)],w[i&-i]),wI[i]=mul(wI[i&(i-1)],wI[i&-i]);}\n    }\n    void dif(int *f,int lim){\n        for(int l=lim>>1,r=lim;l;l>>=1,r>>=1)\n            for(int*j=f,*o=w;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    (x=*k)>=mod&&(x-=mod),y=mul(k[l],*o),*k=x+y,k[l]=x-y+mod;\n    }\n    void dit(int *f,int lim){\n        for(int l=1,r=2;l<lim;l<<=1,r<<=1)\n            for(int*j=f,*o=wI;j!=f+lim;j+=r,++o)\n                for(int*k=j,x,y;k!=j+l;++k)\n                    x=*k,y=mod-k[l],(*k=x-y)<0&&(*k+=mod),k[l]=mul(x+y,*o);\n        for(int i=0,p=mod-(mod-1)/lim;i<lim;++i)f[i]=1ll*f[i]*p%mod;\n    }\n    void mul(int *f,int *g,int n){\n        static int gg[N];\n        memcpy(gg,g,n+2<<2);\n        dif(f,n),dif(gg,n);\n        for(int i=0;i<n;++i)f[i]=1ll*f[i]*gg[i]%M;\n        dit(f,n);\n    }\n    void mul(int *f,int n){\n        dif(f,n);int i;\n        for(i=0;i<n;++i)f[i]=1ll*f[i]*f[i]%M;\n        dit(f,n);\n    }\n};NTT<M>ntt;\nusing namespace MATH;\nint T,T2,n,m,ans,sz[N],f[N];\nint gf(int x){while(x!=f[x])x=f[f[f[f[x]]]];return x;}\nvector<int>lk[N];\nint stk[N],tp;\nstruct dat{\n    int l,r;\n    dat operator+(const dat &z)\n    const{return{min(l,z.l),max(r,z.r)};}\n}bc[N],d[N];\nbitset<N>vs;\nvoid mg(int x,int y){\n    x=gf(x),y=gf(y);\n    if(x!=y){\n        if(sz[x]<sz[y])swap(x,y);\n        sz[f[y]=x]+=sz[y];\n        stk[++tp]=y,bc[tp]=d[x],d[x]=d[x]+d[y];\n    }\n}\nvoid rec(){\n    int x=stk[tp];\n    d[f[x]]=bc[tp--];\n    sz[f[x]]-=sz[x],f[x]=x;\n}\nstruct Eg{int x,y;}g[N];\nint gt;\nvoid sol(int l,int r){\n    if(l==r){\n        int i,y,k,lt=tp;\n        gt=0;\n        for(int x:lk[l]){\n            y=gf(x);\n            // printf(""_l:%d y:%d l:%d r:%d\\n"",l,y,d[y].l,d[y].r);\n            if(d[y].l>1&&d[y].l-1!=l){\n                k=gf(d[y].l-1);\n                g[++gt]={d[y].l-1,d[y].l};\n                mg(k,y);\n            }y=gf(x);\n            if(d[y].r<n&&d[y].r+1!=l){\n                k=gf(d[y].r+1);\n                g[++gt]={d[y].r,d[y].r+1};\n                mg(k,y);\n            }\n        }\n        for(int x:lk[l]){\n            y=gf(x);\n            if(d[y].r==l-1&&l<n){\n                g[++gt]={l-1,l+1};\n                break;\n            }\n        }\n        while(tp>lt)rec();\n        for(i=1,k=0;i<=gt;++i)k+=g[i].y-g[i].x;\n        printf(""%d %d\\n"",k,gt);\n        for(i=1;i<=gt;++i)printf(""%d %d\\n"",g[i].x,g[i].y);\n        puts("""");\n    }else{\n        int md=l+r>>1,lt=tp,i,x;\n        for(x=r;x>md;--x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(l,md);\n        for(x=r;x>md;--x)vs[x]=0;\n        while(tp>lt)rec();\n        for(x=l;x<=md;++x){\n            vs[x]=1;\n            for(int y:lk[x])\n                if(vs[y])mg(x,y);\n        }sol(md+1,r);\n        for(x=l;x<=md;++x)vs[x]=0;\n        while(tp>lt)rec();\n    }\n}\nint main(){\n    ios::sync_with_stdio(false),cin.tie(0);\n    int i,j,k,l,r,x,y,z;\n    for(cin>>T;T--;){\n        cin>>n;\n        for(i=1;i<n;++i){\n            cin>>x>>y;\n            lk[x].push_back(y);\n            lk[y].push_back(x);\n        }\n        for(x=1;x<=n;++x)\n            sz[f[x]=x]=1,d[x]={x,x};\n        sol(1,n);\n        for(x=1;x<=n;++x)lk[x].clear();\n    }\n    return 0;\n}']","[1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0]",2800
Moamen has an array of n integers He wants to sort that array in non decreasing order by doing the following operations in order Split the array into exactly k non empty subarrays such that each element belongs to exactly one subarray Reorder these subarrays arbitrary Merge the subarrays in their new order A sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end Can you tell Moamen if there is a way to sort the array in non decreasing order using the operations written above ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nint n,K,a[100005],b[100005];\nint main(){\n\tint t;\n\tcin>>t;\n\twhile(t--){\n\t\tcin>>n>>K;\n\t\tfor(int i=1;i<=n;i++)scanf(""%d"",&a[i]),b[i]=a[i];\n\t\tsort(b+1,b+n+1);\n\t\tfor(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+n+1,a[i])-b;\n\t\tint cnt=0;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(a[i]!=a[i-1]+1)cnt++;\n\t\t}\n\t\tif(cnt<K)puts(""Yes"");\n\t\telse puts(""No"");\n\t}\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
We start with a permutation a 1 a 2 ldots a n and with an empty array b We apply the following operation k times On the i th iteration we select an index t i 1 le t i le n i 1 remove a t i from the array and append one of the numbers a t i 1 or a t i 1 if t i 1 or t i 1 are within the array bounds to the right end of the array b Then we move elements a t i 1 ldots a n to the left in order to fill in the empty space You are given the initial permutation a 1 a 2 ldots a n and the resulting array b 1 b 2 ldots b k All elements of an array b are Calculate the number of possible sequences of indices t 1 t 2 ldots t k modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing ld = long double;\nusing db = double; \nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst ld PI = acos((ld)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// helper funcs\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(u); } // element that doesn\'t exist from (multi)set\n\n// INPUT\n#define tcTUU tcT, class ...U\ntcT> void re(complex<T>& c);\ntcTU> void re(pair<T,U>& p);\ntcT> void re(vector<T>& v);\ntcT, size_t SZ> void re(AR<T,SZ>& a);\n\ntcT> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntcTUU> void re(T& t, U&... u) { re(t); re(u...); }\n\ntcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; }\ntcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\ntcT> void re(vector<T>& x) { trav(a,x) re(a); }\ntcT, size_t SZ> void re(AR<T,SZ>& x) { trav(a,x) re(a); }\ntcT> void rv(int& n, vector<T>& x) { re(n); x.rsz(n); trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntcT> str ts(complex<T> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntcTU> str ts(pair<T,U> p);\ntcT> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntcTU> str ts(pair<T,U> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntcT> void pr(T x) { cout << ts(x); }\ntcTUU> void pr(const T& t, const U&... u) { \n\tpr(t); pr(u...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntcTUU> void ps(const T& t, const U&... u) { \n\tpr(t); if (sizeof...(u)) pr("" ""); ps(u...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntcTUU> void DBG(const T& t, const U&... u) {\n\tcerr << ts(t); if (sizeof...(u)) cerr << "", "";\n\tDBG(u...); }\n#ifdef LOCAL // compile with -DLOCAL, chk -> fake assert\n\t#define dbg(...) cerr << ""Line("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n\t#define chk(...) if (!(__VA_ARGS__)) cerr << ""Line("" << __LINE__ << "") -> function("" \\\n\t\t << __FUNCTION__  << "") -> CHK FAILED: ("" << #__VA_ARGS__ << "")"" << ""\\n"", exit(0);\n#else\n\t#define dbg(...) 0\n\t#define chk(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { cin.tie(0)->sync_with_stdio(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n\t* also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp (ecnerwal)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\ntemplate<int MOD, int RT> struct mint {\n\tstatic const int mod = MOD;\n\tstatic constexpr mint rt() { return RT; } // primitive root for FFT\n\tint v; explicit operator int() const { return v; } // explicit -> don\'t silently convert to int\n\tmint() { v = 0; }\n\tmint(ll _v) { v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);\n\t\tif (v < 0) v += MOD; }\n\tfriend bool operator==(const mint& a, const mint& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mint& a, const mint& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mint& a, const mint& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mint& a) { ll x; re(x); a = mint(x); }\n\tfriend str ts(mint a) { return ts(a.v); }\n   \n\tmint& operator+=(const mint& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmint& operator-=(const mint& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmint& operator*=(const mint& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmint& operator/=(const mint& m) { return (*this) *= inv(m); }\n\tfriend mint pow(mint a, ll p) {\n\t\tmint ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans; }\n\tfriend mint inv(const mint& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmint operator-() const { return mint(-v); }\n\tmint& operator++() { return *this += 1; }\n\tmint& operator--() { return *this -= 1; }\n\tfriend mint operator+(mint a, const mint& b) { return a += b; }\n\tfriend mint operator-(mint a, const mint& b) { return a -= b; }\n\tfriend mint operator*(mint a, const mint& b) { return a *= b; }\n\tfriend mint operator/(mint a, const mint& b) { return a /= b; }\n};\n\ntypedef mint<MOD,5> mi; // 5 is primitive root for both common mods\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\n/**\n * Description: A set (not multiset!) with support for finding the $n$\'th\n * element, and finding the index of an element. Change \\texttt{null\\_type} for map.\n * Time: O(\\log N)\n * Source: KACTL\n   * https://codeforces.com/blog/entry/11080\n * Verification: many\n */\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, \n\trb_tree_tag, tree_order_statistics_node_update>; \n#define ook order_of_key\n#define fbo find_by_order\n\nvoid treeExample() {\n\tTree<int> t, t2; t.insert(8);\n\tauto it = t.insert(10).f; assert(it == t.lb(9));\n\tassert(t.ook(10) == 1 && t.ook(11) == 2 && *t.fbo(0) == 8);\n\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t\n}\n\n// int atMost(Tree<int>& T, int r) { \n// \treturn T.ook(r+1); }\n// int getSum(Tree<int>& T, int l, int r) { \n// \treturn atMost(T,r)-atMost(T,l-1); }\n\nint getSum(vi& v, int l, int r) {\n\treturn v[r]-v[l-1];\n}\n\nint N,K;\nvi A,B;\n\nvoid solve(int tc) {\n\tre(N,K);\n\tA.rsz(N), B.rsz(K); re(A,B);\n\tmap<int,int> m;\n\tF0R(i,N) m[A[i]] = i+1;\n\ttrav(t,B) {\n\t\tif (!m.count(t)) {\n\t\t\tps(0);\n\t\t\treturn;\n\t\t}\n\t\tt = m[t];\n\t}\n\tset<int> inds;\n\tinds.ins(0), inds.ins(N+1);\n\ttrav(t,B) inds.ins(t);\n\tvi emp(N+5);\n\tFOR(i,1,N+1) if (!inds.count(i)) emp[i] ++;\n\tFOR(i,1,sz(emp)) emp[i] += emp[i-1];\n\tmi ans = 1;\n\t// dbg(""WHOOPS"",B);\n\ttrav(t,B) {\n\t\tauto it = inds.find(t);\n\t\tint x = *prev(it), y = *next(it);\n\t\t// dbg(""HA"",getSum(emp,x+1,y-1));\n\t\tans *= (getSum(emp,x+1,*it-1) > 0) + (getSum(emp,*it+1,y-1) > 0);\n\t\tinds.erase(it);\n\t}\n\tps(ans);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0]",1800
Sergey just turned five years old When he was one year old his parents gave him a number when he was two years old his parents gave him an array of integers On his third birthday he received a string When he was four his mother woke him up in a quiet voice wished him to be a good boy and gave him a rooted tree Today he celebrates his birthday again He found a directed graph without loops as a present from his parents Since Sergey is a very curious boy he immediately came up with a thing to do He decided to find a set Q of vertices in this graph such that no two vertices x y in Q are connected by an edge and it is possible to reach any vertex z notin Q from some vertex of Q in no more than two moves After a little thought Sergey was able to solve this task Can you solve it too A vertex y is reachable from a vertex x in at most two moves if either there is a directed edge x y or there exist two directed edges x z and z y for some vertex z ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MAX = 1e6 + 1;\nint n,m;\nvector<int> d[MAX];\nint res[MAX];\nint deg[MAX];\nint nie[MAX];\nvoid take(int v){\n  res[v] = 1;\n  for(int el:d[v]){\n    if(res[el]){\n      deg[el]++;\n    }else{\n      res[el] = 2;\n    }\n  }\n}\nvector<int> out;\nvoid dfs(int v){\n  if(res[v] != 1 || deg[v] != 0)return;\n  deg[v] = -1;\n  if(!nie[v])out.PB(v);\n  for(int el:d[v]){\n    if(!nie[v]){\n      nie[el] = 1;\n    }\n    deg[el]--;\n    dfs(el);\n  }\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m;\n  R(i,m){\n    int a,b;\n    cin >> a >> b;\n    a--;b--;\n    d[a].PB(b);\n  }\n  R(i,n)if(res[i] == 0){\n    take(i);\n  }\n  R(i,n)dfs(i);\n  \n  cout << SZ(out) << ""\\n"";\n  for(int el:out){\n    cout << el+1 << "" "";\n  }\n  cout << ""\\n"";\n}\n']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3000
Iahub wants to enhance his multitasking abilities In order to do this he wants to sort arrays simultaneously each array consisting of integers Iahub can choose a pair of distinct indices and Then in each array the values at positions and are swapped only if the value at position is strictly greater than the value at position Iahub wants to find an array of pairs of distinct indices that chosen in order sort all of the arrays in ascending or descending order the particular order is given in input The size of the array can be at most at most pairs Help Iahub find any suitable array ,"['//Solution by Zhusupov Nurlan\n#include <iostream>\n#include <cassert>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef map<string , int> MSI;\ntypedef vector<int> VI;\n\n#define pb(x) push_back(x)\n#define sqr(x) ((x) * (x))\n#define F first\n#define S second\n#define SZ(t) ((int) t.size())\n#define len(t) ((int) t.length())\n#define base 10\n#define fname """"\n#define sz 1000 * 1000\n#define EPS (1e-8)\n#define INF ((int)1e9 + 9)\n#define write(xx) printf(""%d"" , xx);\n#define readln(xx) getline(cin , xx)\n#define read(xx) scanf(""%d"" , &xx)\n#define for(xx1 , yy1 , zz1) for(int zz1 = xx1 ; zz1 <= yy1 ; zz1++)\n#define mp make_pair\nconst double PI  = acos(-1.0);\n\nint n, m, k;\n\nint main(){\n\t//freopen(fname""in"", ""r"", stdin);\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> m >> k;\n    cout << m * (m - 1) / 2 << ""\\n"";\n\n    for (1, m, i)\n    \tfor (i + 1, m, j)\n    \t\tif (!k)\n    \t\t\tcout << i << "" "" << j << ""\\n"";\n    \t\telse\t\n    \t\t\tcout << j << "" "" << i << ""\\n"";\n    \t\t\n    \treturn 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1500
You are given a matrix consisting of n rows and m columns The j th cell of the i th row contains an integer a ij First you have to color each row of the matrix either red or blue in such a way that and Then you have to choose an integer k 1 le k m and cut the colored matrix in such a way that the first k columns become a separate matrix the matrix and the last m k columns become a separate matrix the matrix The coloring and the cut are called if two properties hold every red cell in the left matrix contains an integer greater than every blue cell in the left matrix every blue cell in the right matrix contains an integer greater than every red cell in the right matrix Find any perfect coloring and cut or report that there are none ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tint f=1;char c;x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\nconst int MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=1000005;\n\nint n,m,a[MAXN];\nint p[MAXN];\nint pl[MAXN],sl[MAXN],pr[MAXN],sr[MAXN];\nint lx[MAXN],ly[MAXN],rx[MAXN],ry[MAXN];\nchar res[MAXN];\nvoid solve()\n{\n\treadint(n),readint(m);\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=0;j<m;++j)\n\t\t\treadint(a[i*m+j]);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tlx[i*m]=ly[i*m]=a[i*m];\n\t\tfor(int j=1;j<m;++j)lx[i*m+j]=min(lx[i*m+j-1],a[i*m+j]),ly[i*m+j]=max(ly[i*m+j-1],a[i*m+j]);\n\t\trx[i*m+m-1]=ry[i*m+m-1]=a[i*m+m-1];\n\t\tfor(int j=m-2;j>=0;--j)rx[i*m+j]=min(rx[i*m+j+1],a[i*m+j]),ry[i*m+j]=max(ry[i*m+j+1],a[i*m+j]);\n\t}\n\tfor(int j=0;j<m-1;++j)\n\t{\n\t\tfor(int i=0;i<n;++i)p[i]=i;\n\t\tsort(p,p+n,[&](int x,int y){return ly[x*m+j]<ly[y*m+j];});\n\t\tpl[0]=ly[p[0]*m+j],pr[0]=rx[p[0]*m+j+1];\n\t\tfor(int i=1;i<n;++i)pl[i]=max(pl[i-1],ly[p[i]*m+j]),pr[i]=min(pr[i-1],rx[p[i]*m+j+1]);\n\t\tsl[n-1]=lx[p[n-1]*m+j],sr[n-1]=ry[p[n-1]*m+j+1];\n\t\tfor(int i=n-2;i>=0;--i)sl[i]=min(sl[i+1],lx[p[i]*m+j]),sr[i]=max(sr[i+1],ry[p[i]*m+j+1]);\n\t\tfor(int i=0;i<n-1;++i)\n\t\t\tif(pl[i]<sl[i+1] && pr[i]>sr[i+1])\n\t\t\t{\n\t\t\t\tprintf(""YES\\n"");\n\t\t\t\tfor(int t=0;t<n;++t)res[p[t]]=(t<=i?\'B\':\'R\');\n\t\t\t\tres[n]=\'\\0\';\n\t\t\t\tprintf(""%s %d\\n"",res,j+1);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tprintf(""NO\\n"");\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
Anya and Kirill are doing a physics laboratory work In one of the tasks they have to measure some value times and then compute the average value to lower the error Kirill has already made his measurements and has got the following integer values It is important that the values are close to each other namely the difference between the maximum value and the minimum value is Anya does not want to make the measurements however she can t just copy the values from Kirill s work because the error of each measurement is a random value and this coincidence will be noted by the teacher Anya wants to write such integer values in her work that the following conditions are met the average value of is equal to the average value of all Anya s measurements are in the same bounds as all Kirill s measurements that is the maximum value among Anya s values is not greater than the maximum value among Kirill s values and the minimum value among Anya s values is not less than the minimum value among Kirill s values the number of equal measurements in Anya s work and Kirill s work is as small as possible among options with the previous conditions met Formally the teacher goes through all Anya s values one by one if there is equal value in Kirill s work and it is not strike off yet he strikes off this Anya s value and one of equal values in Kirill s work The number of equal measurements is then the total number of values in Anya s work Help Anya to write such a set of measurements that the conditions above are met ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin >> n;\n\tint mn = 1000000;\n\tint mx = -1000000;\n\tvector<int> v(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> v[i];\n\t\tmn = min(v[i], mn);\n\t\tmx = max(v[i], mx);\n\t}\n\tint cnt[3] = {};\n\tint ans = n;\n\tif(mx - mn == 2) {\n\t\tint mid = mn + 1;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(v[i] == mn) cnt[0]++;\n\t\t\telse if(v[i] == mx) cnt[2]++;\n\t\t\telse cnt[1]++;\n\t\t}\n\t\tif((cnt[1]/2) > min(cnt[0],cnt[2])) {\n\t\t\tint cnt1, cnt2;\n\t\t\tcnt1 = cnt2 = cnt[1]/2;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(v[i] == mid) {\n\t\t\t\t\tif(cnt1) {\n\t\t\t\t\t\tv[i] += 1;\n\t\t\t\t\t\tcnt1--;\n\t\t\t\t\t\tans--;\n\t\t\t\t\t}\n\t\t\t\t\telse if(cnt2) {\n\t\t\t\t\t\tv[i] -= 1;\n\t\t\t\t\t\tcnt2--;\n\t\t\t\t\t\tans--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint abc = min(cnt[0], cnt[2]);\n\t\t\tint ab = abc;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(v[i] == mn && abc) {\n\t\t\t\t\tv[i]++;\n\t\t\t\t\t--abc;\n\t\t\t\t\tans--;\n\t\t\t\t}\n\t\t\t\tif(v[i] == mx && ab) {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\t--ab;\n\t\t\t\t\tans--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t}\n\tcout << ans << endl;\n\tfor(int i : v) cout << i << ' ';\n\tcout << endl;\n}\n""]","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Kilani and Abd are neighbors for 3000 years but then the day came and Kilani decided to move to another house As a farewell gift Kilani is going to challenge Abd with a problem written by their other neighbor with the same name Abd The problem is You are given a connected tree rooted at node 1 You should assign a character or to every node in the tree so that the total number of s is equal to x and the total number of s is equal to n x Let s define a string for each node v of the tree as follows if v is root then the string is just one character assigned to v otherwise let s take a string defined for the v s parent p v and add to the end of it a character assigned to v You should assign every node a character in a way that among the strings of all nodes ,"['/*\n    ___                         ______      __                  __\n   /   |____  __  ___________ _/ ____/___ _/ /___  ____  ______/ /____\n  / /| /_  / / / / / ___/ __ `/ /   / __ `/ __/ / / / / / / __  / ___/\n / ___ |/ /_/ /_/ (__  ) /_/ / /___/ /_/ / /_/ /_/ / /_/ / /_/ (__  )\n/_/  |_/___/\\__,_/____/\\__,_/\\____/\\__,_/\\__/\\__, /\\__, /\\__,_/____/\n                                            /____//____/\n\n\u3000\u3000\u3000\u3000\u3000／＞\u3000 フ\n\u3000\u3000\u3000\u3000\u3000| \u3000_\u3000 _|\n\u3000 \u3000\u3000\u3000／`ミ _x 彡\n\u3000\u3000 \u3000 /\u3000\u3000\u3000 \u3000 |\n\u3000\u3000\u3000 /\u3000  ヽ\u3000\u3000 ?\n\u3000／￣|\u3000\u3000 |\u3000|\u3000|\n\u3000| (￣ヽ＿_ヽ_)_)\n\u3000＼二つ\n\n*/\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c==\'-\') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = \'\\n\') {\n\tstatic short st[30];short tp=0;\n\tif(x<0) putchar(\'-\'),x=-x;\n\tdo st[++tp]=x%10,x/=10; while(x);\n\twhile(tp) putchar(\'0\'|st[tp--]);\n\tputchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int N = 200500;\nint ne[N<<1], to[N<<1], h[N], tot;\ninline void add(int x, int y) {\n\tne[++tot] = h[x], to[h[x] = tot] = y;\n}\n\nint cnt[N], D[N], mxdep, n, x;\nvector<int> vec[N];\n#include <bitset>\nbitset< 50019 > bit[355], B[355], nw;\nint ans[N], col[N], deg[N], bl, S = 350;\nvoid dfs(int x, int dep, int fa) {\n\tvec[D[x] = dep].push_back(x);\n\tcnt[dep]++, Mx(mxdep, dep);\n\tfor (int i = h[x]; i; i = ne[i]) \n\t\tif (to[i] != fa) deg[x]++, dfs(to[i], dep + 1, x);\n}\n\nint main() {\n//\tfreopen (""hs.in"",""r"",stdin);\n//\tfreopen (""hs.out"",""w"",stdout);\n\tread(n), read(x);\n\tfor (int i = 2, x;i <= n; ++i) read(x), add(x, i), add(i, x);\n\tdfs(1, 1, 0);\n\tchar a = \'a\', b = \'b\';\n\tif (x + x > n) x = n - x, swap(a, b);\n\tnw[0] = 1, bit[++bl] = nw;\n\tfor (int i = 1;i <= n; ++i) {\n\t\tif (!cnt[i]) break;\n\t\tnw |= nw << cnt[i];\n\t\tif (i % S == 0) bit[++bl] = nw;\n\t}\n\tif (!nw[x]) {\n\t\twrite(mxdep + 1);\n\t\tint spj = 0, y = n - x;\n\t\tfor (int i = 1;i <= mxdep; ++i) {\n\t\t\tif (cnt[i] <= x) {\n\t\t\t\tfor (auto t: vec[i]) ans[t] = a;\n\t\t\t\tx -= cnt[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (cnt[i] <= y) {\n\t\t\t\tfor (auto t: vec[i]) ans[t] = b;\n\t\t\t\ty -= cnt[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspj = i;\n\t\t}\n\t\tchar tt = x < y ? a : b; int k = min(x, y);\n\t\tfor (auto t: vec[spj]) \n\t\t\tif (!deg[t]) ans[t] = k ? (k -= 1, tt) : (a ^ b ^ tt);\n\t\tfor (auto t: vec[spj])\n\t\t\tif (!ans[t]) ans[t] = a ^ b ^ tt;\n\t\tfor (int i = 1;i <= n; ++i) putchar(ans[i]);\n\t\treturn 0;\n\t}\n\twrite(mxdep);\n\tfor (int i = bl;i >= 1; --i) {\n\t\tint st = (i - 1) * S;\n\t\tB[0] = bit[i];\n\t\tfor (int j = st + 1;j <= st + S; ++j) {\n\t\t\tif (!cnt[j]) break;\n\t\t\tB[j - st] = B[j - 1 - st] | B[j - 1 - st] << cnt[j];\n\t\t}\n\t\twhile (mxdep > st) {\n\t\t\tif (B[mxdep - st][x] && !B[mxdep - st - 1][x]) \n\t\t\t\tx -= cnt[mxdep], col[mxdep] = 1;\n\t\t\t--mxdep;\n\t\t}\n\t}\n\tfor (int i = 1;i <= n; ++i) putchar(col[D[i]] ? a : b);\n\treturn 0;\n}\n\n/*\n\n9 4\n1 2 2 2 2 2 1 2\n\n1 0\n\n*/']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3100
Polycarpus is an amateur businessman Recently he was surprised to find out that the market for paper scissors is completely free Without further ado Polycarpus decided to start producing and selling such scissors Polycaprus calculated that the optimal celling price for such scissors would be bourles However he read somewhere that customers are attracted by prices that say something like Special Offer Super price 999 bourles So Polycarpus decided to lower the price a little if it leads to the desired effect Polycarpus agrees to lower the price by no more than bourles so that the number of nines at the end of the resulting price is maximum If there are several ways to do it he chooses the maximum possible price Note Polycarpus counts only the nines in a price ,"['#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\nint main()\n{\n    LL a,b,ans;\n    cin >> a >> b;\n    b=a-b;\n    ans=a;\n    for (int i=0;i<=18;++i){\n        LL tail=0,base=1;\n        for (int j=0;j<i;++j){\n            tail=tail*10LL+9;\n            base*=10;\n        }\n        LL front=a/base;\n        if (tail>a%base) --front;\n        if (front<0) continue;\n        LL cur=front*base+tail;\n        if (cur>=b){\n            ans=cur;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Once upon a time DravDe an outstanding person famous for his professional achievements as you must remember he works in a warehouse storing Ogudar Olok a magical but non alcoholic drink came home after a hard day That day he had to drink 9875 boxes of the drink and having come home he went to bed at once DravDe dreamt about managing a successful farm He dreamt that every day one animal came to him and asked him to let it settle there However DravDe being unimaginably kind could send the animal away and it went rejected There were exactly days in DravDe s dream and the animal that came on the th day ate exactly tons of food daily starting from day But if one day the animal could not get the food it needed it got really sad At the very beginning of the dream there were exactly tons of food on the farm DravDe woke up terrified When he retold the dream to you he couldn t remember how many animals were on the farm by the end of the th day any more but he did remember that nobody got sad as it was a happy farm and that there was the maximum possible amount of the animals That s the number he wants you to find out It should be noticed that the animals arrived in the morning and DravDe only started to feed them in the afternoon so that if an animal willing to join them is rejected it can t eat any farm food But if the animal does join the farm it eats daily from that day to the th ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint n, X;\nint c[100];\n\nint dp[100][10001];\n\nint process(int i, int food){\n    if (i == n) return 0;\n    if (dp[i][food] != -1)\n        return dp[i][food];\n    int ans=0, v;\n    ans = process(i+1, food);\n    if ((n-i)*c[i] <= food) {\n        v = 1 + process(i+1, food - (n-i)*c[i]);\n        ans = max(ans, v);\n    }\n    dp[i][food] = ans;\n    return ans;\n}\n\nint main() {\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    memset(dp, -1, sizeof(dp));\n    scanf(""%d%d"", &n, &X);\n    for(int i=0; i<n; i++)\n        scanf(""%d"", &c[i]);\n    printf(""%d\\n"", process(0, X));\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
While swimming at the beach Mike has accidentally dropped his cellphone into the water There was no worry as he bought a cheap replacement phone with an old fashioned keyboard The keyboard has only ten digital equal sized keys located in the following way Together with his old phone he lost all his contacts and now he can only remember the way his fingers moved when he put some number in One can formally consider as a sequence of vectors connecting centers of keys pressed consecutively to put in a number For example the finger movements for number 586 are the same as finger movements for number 253 Mike has already put in a number by his finger memory and started calling it so he is now worrying can he be sure that he is calling the correct number In other words is there any other number that has the same finger movements ,"['#include <cassert>\n#include <fstream>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <bitset>\n#include <ctime>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <iostream>\n\nusing namespace std;\n\n#define FOR(i, a, n) for (int i = a; i <= n; ++i)\n#define ROF(i, n, a) for (int i = n; i >= a; i--)\n#define FIT(i, v) for (auto &i : v)\n#define pb push_back\n#define mp make_pair\n#define mt make_touple\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define sz(x) ((int)(x).size())\n#define log log2\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int mod = 1000000007;\nll powmod(ll a, ll b) {ll res=1; a %= mod; assert(b >= 0); for(; b; b >>= 1) {if (b & 1) res = res * a % mod; a = a * a % mod;} return res;}\n\nconst int N = 1010;\n\n\n\nint a[10][10];\nint n;\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(""a.in"", ""r"", stdin);\n    freopen(""a.out"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int n;\n    char s[11];\n    cin >> n;\n    cin >> (s + 1);\n    int px[] = {4, 1, 1, 1, 2, 2, 2, 3, 3, 3};\n    int py[] = {2, 1, 2, 3, 1, 2, 3, 1, 2, 3};\n    set<pair<int,int>> A;\n    FOR(i,0,9) {\n        a[px[i]][py[i]] = 1;\n    }\n    int cnt = 0;\n    FOR(j,-4,4) {\n        FOR(k,-4,4) {\n            int ok = 1;\n            FOR(i,1,n) {\n                int x = s[i] - \'0\';\n                int nx = px[x] + j;\n                int ny = py[x] + k;\n                if (nx >= 0 && ny >= 0 && a[nx][ny]) {\n                    ok = 1;\n                } else {\n                    ok = 0;\n                    break;\n                }\n            }\n            cnt += ok;\n        }\n    }\n    if (cnt == 1) {\n        cout << ""YES"";\n    } else {\n        cout << ""NO"";\n    }\n    return 0;\n}']","[0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Your friend Jeff Zebos has been trying to run his new online company but it s not going very well He s not getting a lot of sales on his website which he decided to call His big problem you think is that he s not ranking high enough on the search engines If only he could rename his products to have better names than his competitors then he ll be at the top of the search results and will be a millionaire After doing some research you find out that search engines only sort their results lexicographically If your friend could rename his products to lexicographically smaller strings than his competitor s then he ll be at the top of the rankings To make your strategy less obvious to his competitors you decide to swap no more than two letters of the product names Please help Jeff to find improved names for his products that are lexicographically smaller than his competitor s Given the string s representing Jeff s product name and the string c representing his competitor s product name find a way to swap of characters in s that is find two distinct indices i and j and swap s i and s j such that the resulting new name becomes strictly lexicographically smaller than c or determine that it is impossible String a is than string b if and only if one of the following holds a is a of b that is a is a of b such that a neq b There exists an integer 1 le i le min a b such that a i b i and a j b j for 1 le j i ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int t; cin >> t;\n    for (int tt = 0; tt < t; tt++) {\n        string s, c;\n        cin >> s >> c;\n        if (s < c) {\n            cout << s << ""\\n"";\n            continue;\n        }\n        string t = s;\n        sort(t.begin(), t.end());\n        int a = 0;\n        for (int i = 0; i < (int) s.size(); i++) {\n            if (s[i] > t[i]) {\n                for (int j = i + 1; j < (int) s.size(); j++) {\n                    swap(s[i], s[j]);\n                    if (s < c) {\n                        cout << s << ""\\n"";\n                        a = 1;\n                        i = s.size();\n                        break;\n                    }\n                    swap(s[i], s[j]);\n                }\n            }\n        }\n        if (a == 0) {\n            cout << ""---\\n"";\n        }\n    }\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Monocarp has a dictionary of n words consisting of 12 first letters of the Latin alphabet The words are numbered from 1 to n In every pair of adjacent characters in each word the characters are different For every word i Monocarp also has an integer c i denoting how often he uses this word Monocarp wants to design a keyboard that would allow him to type some of the words easily A keyboard can be denoted as a sequence of 12 first letters of the Latin alphabet where each letter from to appears exactly once A word can be typed with the keyboard easily if for every pair of adjacent characters in the word these characters are adjacent in the keyboard as well The of the keyboard is the sum of c i over all words i that can be typed easily with it Help Monocarp to design a keyboard with the maximum possible optimality ,"['#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include ""library/debug.cpp""\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    map<string, int> a;\n    for (int i = 0; i < n; i++) {\n        int c;\n        string s;\n        cin >> c >> s;\n        deque<char> d;\n        d.emplace_back(s[0]);\n        d.emplace_back(s[1]);\n        int now = 1;\n        for (int j = 2; j < (int) s.size(); j++) {\n            int p = -1;\n            for (int k = 0; k < (int) d.size(); k++) {\n                if (s[j] == d[k]) {\n                    p = k;\n                }\n            }\n            if (p == -1) {\n                if (now == 0) {\n                    d.emplace_front(s[j]);\n                } else if (now == (int) d.size() - 1) {\n                    d.emplace_back(s[j]);\n                    now++;\n                } else {\n                    now = -1;\n                    break;\n                }\n            } else {\n                if (abs(p - now) != 1) {\n                    now = -1;\n                    break;\n                }\n                now = p;\n            }\n        }\n        if (now != -1) {\n            string t;\n            for (char b : d) {\n                t += b;\n            }\n            a[t] += c;\n            reverse(t.begin(), t.end());\n            a[t] += c;\n        }\n    }\n    debug(a);\n    vector<map<string, long long>> dp(1 << 12);\n    vector<map<string, pair<int, string>>> pre(1 << 12);\n    dp[0][string()] = 0;\n    pre[0][string()] = make_pair(-1, """");\n    for (int mask = 0; mask < (1 << 12); mask++) {\n        for (auto [t, c] : dp[mask]) {\n            for (int i = 0; i < 12; i++) {\n                if (mask & (1 << i)) {\n                    continue;\n                }\n                int nmask = mask | (1 << i);\n                string nt = t + (char) (\'a\' + i);\n                while (!nt.empty()) {\n                    auto iter = a.lower_bound(nt);\n                    if (iter == a.end()) {\n                        nt.erase(nt.begin());\n                        continue;\n                    }\n                    string z = iter->first;\n                    if (z.size() < nt.size()) {\n                        nt.erase(nt.begin());\n                        continue;\n                    }\n                    z.resize(nt.size());\n                    if (nt != z) {\n                        nt.erase(nt.begin());\n                        continue;\n                    }\n                    break;\n                }\n                long long nc = c;\n                for (int j = 0; j < (int) nt.size(); j++) {\n                    string z = nt.substr(j);\n                    if (a.count(z)) {\n                        nc += a[z];\n                    }\n                }\n                if (dp[nmask][nt] <= nc) {\n                    dp[nmask][nt] = nc;\n                    pre[nmask][nt] = make_pair(i, t);\n                }\n            }\n        }\n    }\n    long long best = -1;\n    string s;\n    for (auto [t, c] : dp.back()) {\n        if (c > best) {\n            best = c;\n            s = t;\n        }\n    }\n    debug(best);\n    debug(dp.back());\n    string ans;\n    int now = (1 << 12) - 1;\n    while (now > 0) {\n        int i = pre[now][s].first;\n        s = pre[now][s].second;\n        now ^= 1 << i;\n        ans += (char) (\'a\' + i);\n    }\n    cout << ans << \'\\n\';\n    return 0;\n}']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]",2600
Polycarp has n coins the value of the i th coin is a i It is guaranteed that all the values are integer powers of 2 i e a i 2 d for some integer number d Polycarp wants to know answers on q queries The j th query is described as integer number b j The answer to the query is the minimum number of coins that is necessary to obtain the value b j using some subset of coins Polycarp can use only coins he has If Polycarp can t obtain the value b j the answer to the j th query is The queries are independent the answer on the query doesn t affect Polycarp s coins ,"['#include ""bits/stdc++.h""\n#define MAXN 100009\n#define INF 1000000007\n#define mp(x,y) make_pair(x,y)\n#define all(v) v.begin(),v.end()\n#define pb(x) push_back(x)\n#define wr cout<<""----------------""<<endl;\n#define ppb() pop_back()\n#define tr(ii,c) for(__typeof((c).begin()) ii=(c).begin();ii!=(c).end();ii++)\n#define ff first\n#define ss second\n#define my_little_dodge 46\n#define debug(x)  cerr<< #x <<"" = ""<< x<<endl;\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntemplate<class T>bool umin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T>bool umax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\nint cnt[33];\nint main(){\n    //~ freopen(""file.in"", ""r"", stdin);\n    int n,q;\n    scanf(""%d%d"",&n,&q);\n    while(n--){\n\t\tint x;\n\t\tscanf(""%d"",&x);\n\t\tcnt[int(log2(x))]++;\n\t}\n\twhile(q--){\n\t\tint x,ans=0;\n\t\tscanf(""%d"",&x);\n\t\tfor(int i=30;i>=0;i--){\n\t\t\tint need=min(cnt[i],x/(1<<i));\n\t\t\tx-=need*(1<<i);\n\t\t\tans+=need;\n\t\t}\n\t\tif(x)\n\t\t\tans=-1;\n\t\tprintf(""%d\\n"",ans);\t\n\t}\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
There are n traps numbered from 1 to n You will go through them one by one in order The i th trap deals a i base damage to you Instead of going through a trap you can jump it over You can jump over no more than k traps If you jump over a trap it does not deal any damage to you But there is an additional rule if you jump over a trap all next traps damages increase by 1 this is a bonus damage Note that if you jump over a trap you don t get any damage neither base damage nor bonus damage Also the bonus damage stacks so for example if you go through a trap i with base damage a i and you have already jumped over 3 traps you get a i 3 damage You have to find the minimal damage that it is possible to get if you are allowed to jump over no more than k traps ,"['/**\n *    author:  tourist\n *    created: 19.05.2022 18:46:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<int> order(n);\n    iota(order.begin(), order.end(), 0);\n    sort(order.begin(), order.end(), [&](int i, int j) {\n      return a[i] + i > a[j] + j;\n    });\n    vector<bool> skip(n, false);\n    for (int i = 0; i < k; i++) {\n      skip[order[i]] = true;\n    }\n    int bonus = 0;\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n      if (skip[i]) {\n        bonus += 1;\n      } else {\n        ans += a[i] + bonus;\n      }\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
You are given an n times m grid a of non negative integers The value a i j represents the depth of water at the i th row and j th column A lake is a set of cells such that each cell in the set has a i j 0 and there exists a path between any pair of cells in the lake by going up down left or right a number of times and without stepping on a cell with a i j 0 The volume of a lake is the sum of depths of all the cells in the lake Find the largest volume of a lake in the grid ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define bit(i, x) (x >> i & 1)\n#define _unique(x) (x).resize(unique((x).begin(), (x).end()) - (x).begin());\n#define all(x) (x).begin(), (x).end()\n#define rep(i, l, r) for(int i = l; i <= r; i++)\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst int N = 3e5 + 3;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r) {\n    return l+rng()%(r-l+1);\n}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\n#define fi first\n#define se second\n\nint n, m;\nint a[2002][2002];\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nlong long dfs(int x, int y) {\n    long long sz = a[x][y];\n    a[x][y] = 0;\n    for(int i = 0; i < 4; i++) {\n        int u = x + dx[i];\n        int v = y + dy[i];\n        if (u > 0 && v > 0 && u <= n && v <= m && a[u][v] > 0) {\n            sz += dfs(u, v);\n        }\n    }\n    return sz;\n}\n\nvoid solve() {\n    cin >> n >> m;\n    rep(i, 1, n) rep(j, 1, m) cin >> a[i][j];\n    long long res = 0;\n    rep(i, 1, n) rep(j, 1, m) if (a[i][j] > 0) res = max(res, dfs(i, j));\n    cout << res << ""\\n"";\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(NULL); cin.tie(nullptr); cout.tie(nullptr);\n\n//    freopen(""testing.txt"", ""r"", stdin);\n//    freopen(""outputing.txt"", ""w"", stdout);\n    #define task """"\n//    freopen(task"".inp"", ""r"", stdin);\n//    freopen(task"".out"", ""w"", stdout);\n//    #define Kawaii\n    #ifdef Kawaii\n        auto starttime = chrono::high_resolution_clock::now();\n    #endif\n\n    int t; cin >> t;\n    while (t--) solve();\n\n\n\n\n\n\n\n    #ifdef Kawaii\n        auto endtime = chrono::high_resolution_clock::now();\n        auto duration = chrono::duration_cast<chrono::milliseconds>(endtime - starttime).count();\n        cout << ""\\n====="" << ""\\nUsed: "" << duration << "" ms\\n"";\n    #endif\n\n    return 0 ^ 0;\n}\n// Okina Matara sitting in a wheelchair\n']","[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1100
Sasha reaches the work by car It takes exactly minutes On his way he listens to music All songs in his playlist go one by one after listening to the th song Sasha gets a pleasure which equals The th song lasts for minutes Before the beginning of his way Sasha turns on some song and then he listens to the songs one by one at first the song then the song then the song number and so on He listens to songs until he reaches the work or until he listens to the last song in his playlist Sasha can listen to each song to the end or In the second case he listens to the song for integer number of minutes at least half of the song s length Formally if the length of the song equals minutes Sasha listens to it for no less than minutes then he immediately switches it to the next song if there is such For example if the length of the song which Sasha wants to listen to equals minutes then he should listen to it for at least minutes if the length of the song equals minutes then he should listen to it for at least minutes It takes no time to switch a song Sasha wants to listen no more than songs If the last listened song plays for less than half of its length then Sasha doesn t get pleasure from it and that song is not included to the list of listened songs It is not allowed to skip songs A pleasure from a song does not depend on the listening mode for the th song this value equals Help Sasha to choose such and no more than songs for listening to get the maximum pleasure Write a program to find the maximum pleasure Sasha can get from the listening to the songs on his way to the work ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define N ((ll)501*1000)\n#define INF ((ll)2e9)\n#define MOD ((ll)1e9+7)\nll tavan(ll x,ll y){ll res=1;while(y){res*=y%2?x:1;res%=MOD;x*=x;x%=MOD;y/=2;}return res;}\n\nll n,w,k,a[N],t[N],ans;\nmultiset <ll> s,p;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>w>>k;\n    for(int i=0;i<n;i++)cin>>a[i];\n    for(int i=0;i<n;i++)cin>>t[i];\n    for(ll i=0,j=0,time=0,res=0;i<n;i++)\n    {\n    \twhile(j<n)\n    \t{\n    \t\tll now=time;\n    \t\tif((ll)s.size()<w)now+=(t[j]+1)/2;\n    \t\telse if(t[j]>(*s.begin()))now+=(t[j]+1)/2+((*s.begin())-((*s.begin())+1)/2);\n    \t\telse now+=t[j];\n    \t\t\n\t\t\tif(now>k)break;\n    \t\t\n    \t\tif((ll)s.size()<w)s.insert(t[j]);\n    \t\telse if(t[j]>(*s.begin()))p.insert(*s.begin()),s.erase(s.begin()),s.insert(t[j]);\n    \t\telse p.insert(t[j]);\n    \t\t\n\t\t\ttime=now;res+=a[j];j++;\n\t\t}\n\t\tans=max(ans,res);\n\t\t\n\t\tif(j<=i){j=i+1;continue;}\n\t\tres-=a[i];\n\t\tif(t[i]<*s.begin())p.erase(p.find(t[i])),time-=t[i];\n\t\telse \n\t\t{\n\t\t\ts.erase(s.find(t[i]));\n\t\t\ttime-=(t[i]+1)/2;\n\t\t\tif(p.size())\n\t\t\t{\n\t\t\t\tauto it=p.end();it--;\n\t\t\t\ts.insert(*it);\n\t\t\t\ttime-=(*it-(*it+1)/2);\n\t\t\t\tp.erase(it);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n    return 0;\n}']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2200
Gildong s town has a train system that has 100 trains that travel from the bottom end to the top end and 100 trains that travel from the left end to the right end The trains starting from each side are numbered from 1 to 100 respectively and all trains have the same speed Let s take a look at the picture below The train system can be represented as coordinates on a 2D plane The i th train starting at the bottom end is initially at i 0 and will be at i T after T minutes and the i th train starting at the left end is initially at 0 i and will be at T i after T minutes All trains arrive at their destinations after 101 minutes However Gildong found that some trains scheduled to depart at a specific time simultaneously are very dangerous At this time n trains are scheduled to depart from the bottom end and m trains are scheduled to depart from the left end If two trains are both at x y at the same time for some x and y they will crash into each other Therefore he is asking you to find the number of trains that should be cancelled to prevent all such crashes ,"['#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n        while(ch<=\'9\'&&ch>=\'0\')x=x*10+ch-\'0\',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nint T,n,m,num[105],tx;\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(""in.txt"",""r"",stdin);\n        freopen(""out.txt"",""w"",stdout);\n    #endif\n    read(T);\n\twhile(T--){\n\t\tread(n),read(m);\n\t\tF(i,1,100)num[i]=0;\n\t\tF(i,1,n)read(tx),num[tx]=1;\n\t\tF(i,1,m)read(tx),num[tx]=1;\n\t\tint res=0;\n\t\tF(i,1,100)res+=num[i];\n\t\tcout<<n+m-res<<\'\\n\';\n\t} \n    return 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Wilbur the pig really wants to be a beaver so he decided today to pretend he is a beaver and bite at trees to cut them down There are trees located at various positions on a line Tree is located at position All the given positions of the trees are distinct The trees are equal i e each tree has height Due to the wind when a tree is cut down it either falls left with probability or falls right with probability If a tree hits another tree while falling that tree will fall in the same direction as the tree that hit it A tree can hit another tree only if the distance between them is strictly less than For example imagine there are trees located at positions and while and the tree at position falls right It hits the tree at position and it starts to fall too In it s turn it hits the tree at position and it also starts to fall The distance between and is exactly so the tree at position will not fall As long as there are still trees standing Wilbur will select either the leftmost standing tree with probability or the rightmost standing tree with probability Selected tree is then cut down If there is only one tree remaining Wilbur always selects it As the ground is covered with grass Wilbur wants to know the expected total length of the ground covered with fallen trees after he cuts them all down because he is concerned about his grass eating cow friends Please help Wilbur ,"[""//In the name of God\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define int long long\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\ntemplate<class P, class Q> inline P smax (P &a, Q b) { if (a < b) a = b; return a; }\ntemplate<class P, class Q> inline P smin (P &a, Q b) { if (b < a) a = b; return a; }\n\n\nconst int maxN = 2049;\nconst int oo = 1e9 + 4 + 9;\nconst int mod = 0;\nconst int base = 727;\n\nld dp[maxN][maxN][2][2];\n\nll x[maxN], nx[maxN][2], val[maxN][2];\n\nint32_t main () {\n\tios_base :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tld p;\n\tint n, h; cin >> n >> h >> p;\n\tx[0] = -1e9;\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> x[i];\n\tx[n + 1] = 1e9; \n\tsort(x, x + n + 2);\n\tn += 2;\n\tfor (int i = 0; i < n; i++) {\n\t\tint pos = i;\n\t\twhile (pos < n - 1 && x[pos + 1] - x[pos] < h)\n\t\t\tpos++;\n\t\tnx[i][1] = pos;\n\t\tval[i][1] = x[pos] - x[i] + h;\n\t\tpos = i;\n\t\twhile (pos && x[pos] - x[pos - 1] < h)\n\t\t\tpos--;\n\t\tnx[i][0] = pos;\n\t\tval[i][0] = x[i] - x[pos] + h;\n\t}\n\tfor (int l = n - 2; l; --l) {\n\t\tfor (int r = l; r < n - 1; r++) {\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tint prv = a? x[l - 1] + h: x[l - 1];\n\t\t\t\t\tint nxt = b? x[r + 1]: x[r + 1] - h;\n\t\t\t\t\tif (r == l) {\n\t\t\t\t\t\tdp[l][r][a][b] += p * min(x[l] - prv, h) + (1 - p) * min(nxt - x[r], h); \n\t\t\t\t\t} else {\n\t\t\t\t\t\t//l falls left\n\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * (min(x[l] - prv, h) + dp[l + 1][r][0][b]));\n\t\t\t\t\t\t//r falls right\n\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * (min(nxt - x[r], h) + dp[l][r - 1][a][1]));\n\t\t\t\t\t\t//l falls right\n\t\t\t\t\t\tint pos = nx[l][1];\n\t\t\t\t\t\tif (pos >= r)\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * (min(nxt - x[r], h) + x[r] - x[l]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * ((1 - p) * ((val[l][1]) + dp[pos + 1][r][1][b]));\n\t\t\t\t\t\t//r falls left\n\t\t\t\t\t\tpos = nx[r][0];\n\t\t\t\t\t\tif (pos <= l)\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * (min(x[l] - prv, h) + x[r] - x[l]));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdp[l][r][a][b] += (0.5) * (p * ((val[r][0]) + dp[l][pos - 1][a][0]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << setprecision(7) << fixed << dp[1][n - 2][0][1] << '\\n';\n\t\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n""]","[0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
A sequence is if it does not contain three elements x y z such that x ge y ge z You are given an array a 1 a 2 dots a n and q queries Each query consists of two integers 1 le l le r le n For each query find the length of the longest subsequence of the subarray a l a l 1 dots a r A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nint main () {\n  ios_base::sync_with_stdio(0); cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(n), b(n);\n  for (int& x: a) cin >> x;\n  for (int i = 2; i < n; i++) {\n    b[i] = b[i-1] + (a[i] <= a[i-1] && a[i-1] <= a[i-2]);\n  }\n\n  while (q--) {\n    int l, r;\n    cin >> l >> r;\n    cout << r-l+1-(r == l ? 0 : b[r-1]-b[l]) << '\\n';\n  }\n}\n""]","[1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Some dwarves that are finishing the StUDY State University for Dwarven Youngsters Bachelor courses have been told no genome no degree That means that all dwarves should write a thesis on genome Dwarven genome is far from simple It is represented by a string that consists of lowercase Latin letters Dwarf Misha has already chosen the subject for his thesis determining by two dwarven genomes whether they belong to the same race Two dwarves belong to the same race if we can swap two characters in the first dwarf s genome and get the second dwarf s genome as a result Help Dwarf Misha and find out whether two gnomes belong to the same race or not ,"['#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <memory.h>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\nusing namespace std;\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,(int)(v).size())\n#define iinf 1000000000\n#define linf 1000000000000000000LL\n#define dinf 1e200\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define mp make_pair\n#define lng long long\n#define eps 1e-11\n#define EQ(a,b) (fabs((a)-(b))<eps)\n#define SQ(a) ((a)*(a))\n#define PI 3.14159265359\n#define index asdindex\n#define FI first\n#define SE second\n#define prev asdprev\n#define ends asdends\n#define PII pair<int,int> \n#define X first\n#define Y second\n#define mset(a,b) memset(a,b,sizeof(a))\n\n\n\nint n;\nint src[16];\nint s;\n\n\nint f(){\n    int res=0;\n    forn(i, n){\n        int sum = 0;\n        for(int j=i*n;j<(i+1)*n;++j){\n            sum += src[j];\n        }\n        res+=abs(sum-s);\n    }\n    forn(i, n){\n        int sum = 0;\n        for(int j=i;j<n*n;j+=n){\n            sum += src[j];\n        }\n        res+=abs(sum-s);\n    }\n    {\n        int sum = 0;\n        for(int i=0;i<n*n;i+=n+1)sum += src[i];\n        res+=abs(sum-s);\n    }\n    int sum = 0;\n    int j=0;\n    for(int i=n-1;i<n*n;i+=n-1,++j){\n        if (j==n)break;\n        sum += src[i];\n    }\n    res+=abs(sum-s);\n    return res;\n}\n\nvoid print(){\n    cout << s << endl;\n    forn(i,n*n){\n        cout<<src[i]<<"" "";\n        if (i%n==n-1)cout<<endl;\n    }\n    exit(0);\n}\n\nint main(){\n#ifdef __ASD__\n    freopen(""input.txt"",""r"",stdin);freopen(""output.txt"",""w"",stdout);\n#endif\n    ios::sync_with_stdio(false);\n    string s1, s2;\n    cin >> s1 >> s2;\n    if (s1==s2){\n        cout <<""YES"";\n        return 0;\n    }\n    if (s1.length()!=s2.length()){\n        cout<<""NO"";\n        return 0;\n    }\n    int cnt=0;\n    vector<int> diff;\n    forn(i, s1.length()){\n        if (s1[i]!=s2[i]){\n            diff.pb(i);\n        }\n    }\n    if (diff.size()!=2){\n        cout <<""NO"";\n        return 0;\n    }\n    if (s1[diff[0]]==s2[diff[1]] && s1[diff[1]]==s2[diff[0]]){\n        cout << ""YES"";\n    }else cout<<""NO"";\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1100
It was recycling day in Kekoland To celebrate it Adil and Bera went to Central Perk where they can take bottles from the ground and put them into a recycling bin We can think Central Perk as coordinate plane There are bottles on the ground the th bottle is located at position Both Adil and Bera can carry only one bottle at once each For both Adil and Bera the process looks as follows Choose to stop or to continue to collect bottles If the choice was to continue then choose some bottle and walk towards it Pick this bottle and walk to the recycling bin Go to step Adil and Bera may move independently They are allowed to pick bottles simultaneously all bottles may be picked by any of the two it s allowed that one of them stays still while the other one continues to pick bottles They want to organize the process such that the total distance they walk the sum of distance walked by Adil and distance walked by Bera is minimum possible Of course at the end all bottles should lie in the recycling bin ,"['#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 211111\n\n#define TASK ""1""\n\nusing namespace std;\n\ndouble Ax, Ay, Bx, By, Cx, Cy;\nint n;\n\ndouble a[N], b[N], o[N];\n\npair<double, int> qa[N], qb[N];\n\ndouble dist(double x, double y, double xx, double yy) {\n\treturn sqrt((x - xx) * (x - xx) + (y - yy) * (y - yy));\n}\n\nint main(){\n\t#ifdef home\n\t\tfreopen(TASK"".in"",""r"",stdin);\t\n\t\tfreopen(TASK"".out"",""w"",stdout);\n\t#endif\t\t\n\tios::sync_with_stdio(false);\n\tcin >> Ax >> Ay >> Bx >> By >> Cx >> Cy >> n;\n\tdouble sum = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\to[i] = dist(x, y, Cx, Cy) * 2;\n\t\tsum += o[i];\n\n\t\ta[i] = dist(x, y, Ax, Ay) + dist(x, y, Cx, Cy);\n\t\tb[i] = dist(x, y, Bx, By) + dist(x, y, Cx, Cy);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tqa[i] = mp(a[i] - o[i], i);\n\t\tqb[i] = mp(b[i] - o[i], i);\n\t}\n\tsort(qa, qa + n);\n\tsort(qb, qb + n);\n\n\n\tdouble ans = 1e20;\n\tfor (int i = 0; i < min(5, n); i++) for (int j = 0; j < min(5, n); j++) if (qa[i].S != qb[j].S) {\n\t\tdouble t = sum + qa[i].F + qb[j].F;\n\t\tans = min(ans, t);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tans = min(ans, sum - o[i] + a[i]);\n\t\tans = min(ans, sum - o[i] + b[i]);\n\t}\n\n\tprintf(""%.10lf\\n"", ans);\n\n\n\treturn 0;\n}']","[1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1800
A pair of positive integers a b is called if lfloor frac a b rfloor a bmod b Here lfloor frac a b rfloor is the result of the integer division between a and b while a bmod b is its remainder You are given two integers x and y Find the number of special pairs a b such that 1 leq a leq x and 1 leq b leq y ,"['#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint T,x,y;\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d%d"",&x,&y);\n\t\tll ans=0;\n\t\tfor(int k=1;k*k<=x;++k){\n\t\t\tint bl=k+1,br=min(x/k-1,y);\n\t\t\tif(bl<=br)ans+=br-bl+1;\n\t\t}\n\t\tprintf(""%I64d\\n"",ans);\n\t}\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1700
You had a sequence a 1 a 2 ldots a n consisting of integers from 1 to n not necessarily distinct For some unknown reason you decided to calculate the following of the sequence Let r i 1 le i le n be the smallest j ge i such that on the subsegment a i a i 1 ldots a j all distinct numbers from the sequence a appear More formally for any k in 1 n there exists l in i j such that a k a l If such j does not exist r i is considered to be equal to n 1 The characteristic of the sequence a is defined as the sequence r 1 r 2 ldots r n Unfortunately the sequence a got lost but you still have its characteristic r You want to reconstruct any sequence a that matches the characteristic or determine that there is an error in the characteristic and such a sequence does not exist ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\n// std::mt19937 rng;\n// int ok = 0;\nvoid solve() {\n    // int n = rng() % 10 + 1;\n    int n;\n    std::cin >> n;\n    \n    // std::vector<int> A(n + 1);\n    // std::set<int> S;\n    // for (int i = 1; i <= n; i++) {\n    //     A[i] = rng() % i + 1;\n    //     S.insert(A[i]);\n    // }\n    \n    std::vector<int> r(n + 2);\n    for (int i = 1; i <= n; i++) {\n        std::cin >> r[i];\n    }\n    // for (int i = 1; i <= n; i++) {\n    //     int j = i - 1;\n    //     std::set<int> T;\n    //     while (j <= n && T.size() < S.size()) {\n    //         j++;\n    //         if (j <= n) {\n    //             T.insert(A[j]);\n    //         }\n    //     }\n    //     r[i] = j;\n    //     // std::cin >> r[i];\n    // }\n    r[n + 1] = n + 1;\n    if (r[1] > n) {\n        std::cout << ""No\\n"";\n        return;\n    }\n    \n    if (!std::is_sorted(r.begin(), r.end())) {\n        std::cout << ""No\\n"";\n        return;\n    }\n    \n    std::vector<int> L(n + 2, -1), R(n + 2, -1);\n    for (int i = 0; i <= n; i++) {\n        if (r[i] < r[i + 1]) {\n            R[i] = r[i + 1];\n            L[r[i + 1]] = i;\n        }\n    }\n    \n    std::vector<int> pl, pr;\n    for (int i = 1; i <= n; i++) {\n        if (R[i] == -1) {\n            pl.push_back(i);\n        }\n        if (L[i] == -1) {\n            pr.push_back(i);\n        }\n    }\n    \n    int k = pl.size();\n    assert(pr.size() == k);\n    int res = 0;\n    for (int i = 0, j = 0; i < k; i++) {\n        while (j < k && pl[i] >= pr[j]) {\n            j++;\n        }\n        res = std::max(res, j - i);\n    }\n    for (int i = 0; i < k; i++) {\n        R[pl[i]] = i + res < k ? pr[i + res] : n + 1;\n        L[pr[i]] = i - res >= 0 ? pl[i - res] : 0;\n    }\n    \n    std::vector<int> a(n + 1);\n    int tot = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i] = L[i] == 0 ? ++tot : a[L[i]];\n    }\n    \n    std::vector<int> f(n + 2);\n    for (int i = 1; i <= n; i++) {\n        f[i] = std::max(f[i], R[i]);\n        f[L[i]] = std::max(f[L[i]], i);\n    }\n    for (int i = 1; i <= n + 1; i++) {\n        f[i] = std::max(f[i], f[i - 1]);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        if (r[i] < f[i - 1]) {\n            std::cout << ""No\\n"";\n            return;\n        }\n    }\n    \n    std::cout << ""Yes\\n"";\n    for (int i = 1; i <= n; i++) {\n        std::cout << a[i] << "" \\n""[i == n];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3400
You are given two lists of non zero digits Let s call an integer pretty if its base representation has at least one digit from the first list and at least one digit from the second list What is the smallest positive pretty integer ,"['#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint a[100],b[100];\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tint A;\n\t\tcin>>A;\n\t\ta[A]=1;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint A;\n\t\tcin>>A;\n\t\tb[A]=1;\n\t}\n\tfor(int i=1;i<100;i++){\n\t\tif((a[i%10]||(i>=10&&a[i/10]))&&(b[i%10]||(i>=10&&b[i/10]))){\n\t\t\tprintf(""%d\\n"",i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
Finished her homework Nastya decided to play computer games Passing levels one by one Nastya eventually faced a problem Her mission is to leave a room where a lot of monsters live as quickly as possible There are n manholes in the room which are situated on one line but unfortunately all the manholes are closed and there is one stone on every manhole There is exactly one coin under every manhole and to win the game Nastya should pick all the coins Initially Nastya stands near the k th manhole from the left She is thinking what to do In one turn Nastya can do one of the following if there is at least one stone on the manhole Nastya stands near throw exactly one stone from it onto any other manhole yes Nastya is strong go to a neighboring manhole if there are no stones on the manhole Nastya stays near she can open it and pick the coin from it After it she must close the manhole immediately it doesn t require additional moves Nastya can leave the room when she picks all the coins Monsters are everywhere so you need to compute the minimum number of moves Nastya has to make to pick all the coins Note one time more that Nastya can open a manhole only when there are no stones onto it ,"['#include<bits/stdc++.h>\nusing namespace std;\nint N, K;\nint main()\n{\n  scanf(""%d"", &N);\n  scanf(""%d"", &K);\n  printf(""%d\\n"", 3*N+min(N-K, K-1));\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Stepan is a very busy person Today he needs to send n messages at moments m 1 m 2 dots m n m i m i 1 Unfortunately by the moment 0 his phone only has f units of charge left At the moment 0 the phone is turned on The phone loses a units of charge for each unit of time it is on Also at any moment Stepan can turn off the phone and turn it on later This action consumes b units of energy each time Consider turning on and off to be instantaneous so you can turn it on at moment x and send a message at the same moment and vice versa send a message at moment x and turn off the phone at the same moment If at any point the charge level drops to 0 becomes le 0 it is impossible to send a message at that moment Since all messages are very important to Stepan he wants to know if he can send all the messages without the possibility of charging the phone ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll n,f,a,b;\n    cin>>n>>f>>a>>b;\n    ll m[n+1],s=0;\n    for(ll i=1;i<=n;i++) cin>>m[i];\n    m[0]=0;\n    for(ll i=1;i<=n;i++){\n        if((m[i]-m[i-1])*a>b) s+=b;\n        else s+=(m[i]-m[i-1])*a;\n    }\n    if(s<f) cout<<""YES"";\n    else cout<<""NO"";\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
You are given an array a consisting of n integers as well as an array b consisting of m integers Let text LIS c denote the length of the longest increasing subsequence of array c For example text LIS 2 underline 1 1 underline 3 2 text LIS underline 1 underline 7 underline 9 3 text LIS 3 underline 1 underline 2 underline 4 3 You need to insert the numbers b 1 b 2 ldots b m into the array a at any positions in any order Let the resulting array be c 1 c 2 ldots c n m You need to choose the positions for insertion in order to text LIS c Formally you need to find an array c 1 c 2 ldots c n m that simultaneously satisfies the following conditions The array a 1 a 2 ldots a n is a subsequence of the array c 1 c 2 ldots c n m The array c 1 c 2 ldots c n m consists of the numbers a 1 a 2 ldots a n b 1 b 2 ldots b m possibly rearranged The value of text LIS c is the possible among all suitable arrays c ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n,m;cin>>n>>m;\n\tvi a=readvi(n);\n\tvi b=readvi(m);\n\t\n\tvi buf(n,inf);\n\t\n\tvc<pi> z;\n\trep(i,n){\n\t\tint j=lwb(buf,a[i]);\n\t\tbuf[j]=a[i];\n\t\tif(j==0)z.eb(a[i],i);\n\t}\n\t\n\tsoin(b);\n\trein(b);\n\t\n\tvvc<int> ls(n+1);\n\tfor(auto v:b){\n\t\tint i=lower_bound(all(z),pi(v,-1),greater<pi>())-z.bg;\n\t\tif(i<si(z)){\n\t\t\tls[z[i].b].pb(v);\n\t\t}else{\n\t\t\tls[n].pb(v);\n\t\t}\n\t}\n\t\n\tvi ans;\n\trep(i,n+1){\n\t\tpb(ans,ls[i]);\n\t\tif(i<n)ans.pb(a[i]);\n\t}\n\t\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1700
Ford Prefect got a job as a web developer for a small company that makes towels His current work task is to create a search engine for the website of the company During the development process he needs to write a subroutine for comparing strings and of equal length to be similar After a brief search on the Internet he learned about the between two strings and of the same length which is defined as the number of positions in which and have different characters For example the Hamming distance between words and is two as these words differ in the fourth and sixth letters Moreover as he was searching for information he also noticed that modern search engines have powerful mechanisms to correct errors in the request to improve the quality of search Ford doesn t know much about human beings so he assumed that the most common mistake in a request is swapping two arbitrary letters of the string not necessarily adjacent Now he wants to write a function that determines which two letters should be swapped in string so that the Hamming distance between a new string and string would be as small as possible or otherwise determine that such a replacement cannot reduce the distance between the strings Help him do this ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nconst int N = 30, L = 2e5 + 5;\nint n, ans;\nchar s[L], t[L];\nbool app[N][N];\nvector<int> pos[N];\n\ninline bool check2() {\n\tint p1, p2;\n\tbool f1 = false, f2 = false;\n\tfor (int i = 0; i <= 25; ++i)\n\t\tfor (int j = 0; j <= 25; ++j)\n\t\t\tif (i != j)\n\t\t\t\tif (app[i][j] && app[j][i]) {\n\t\t\t\t\tans -= 2;\n\t\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\t\tif (!f1 && s[k] - \'a\' == i && t[k] - \'a\' == j) {\n\t\t\t\t\t\t\tf1 = true;\n\t\t\t\t\t\t\tp1 = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!f2 && s[k] - \'a\' == j && t[k] - \'a\' == i) {\n\t\t\t\t\t\t\tf2 = true;\n\t\t\t\t\t\t\tp2 = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (p1 > p2) swap(p1, p2);\n\t\t\t\t\tprintf(""%d\\n%d %d\\n"", ans, p1 + 1, p2 + 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\treturn false;\n}\n\ninline bool check1() {\n\tfor (int i = 0; i < n; ++i)\n\t\tif (s[i] != t[i]) {\n\t\t\tif (pos[t[i] - \'a\'].size() == 0) continue;\n\t\t\tint p1 = i, p2 = pos[t[i] - \'a\'][0];\n\t\t\t--ans;\n\t\t\tif (p1 > p2) swap(p1, p2);\n\t\t\tprintf(""%d\\n%d %d\\n"", ans, p1 + 1, p2 + 1);\n\t\t\treturn true;\n\t\t}\n\treturn false;\n}\n\nint main() {\n\tscanf(""%d"", &n);\n\tscanf(""%s%s"", s, t);\n\tfor (int i = 0; i < n; ++i)\n\t\tif (s[i] != t[i]) {\n\t\t\t++ans;\n\t\t\tapp[t[i] - \'a\'][s[i] - \'a\'] = true;\n\t\t\tpos[s[i] - \'a\'].push_back(i);\n\t\t}\n\tif (check2()) return 0;\n\tif (check1()) return 0;\n\tprintf(""%d\\n"", ans);\n\tputs(""-1 -1"");\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
The main walking trail in Geraldion is absolutely straight and it passes strictly from the north to the south it is so long that no one has ever reached its ends in either of the two directions The Geraldionians love to walk on this path at any time so the mayor of the city asked the Herald to illuminate this path with a few spotlights The spotlights have already been delivered to certain places and Gerald will not be able to move them Each spotlight illuminates a specific segment of the path of the given length one end of the segment is the location of the spotlight and it can be directed so that it covers the segment to the south or to the north of spotlight The trail contains a monument to the mayor of the island and although you can walk in either directions from the monument no spotlight is south of the monument You are given the positions of the spotlights and their power Help Gerald direct all the spotlights so that the total length of the illuminated part of the path is as much as possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=310;\nVI pos;\nint n,m,a[N],l[N],pm[N],pl[N],pr[N];\nll dp[N][N][N],ans;\ninline void upd(ll &a,ll b) { if (a<b) a=b;}\nint main() {\n//\tfreopen(""E.in"",""r"",stdin);\n\tscanf(""%d"",&n);\n\trep(i,0,n) {\n\t\tscanf(""%d%d"",a+i,l+i);\n\t\tpos.pb(a[i]); pos.pb(a[i]+l[i]); pos.pb(a[i]-l[i]);\n\t}\n\tsort(all(pos));\n\tpos.erase(unique(all(pos)),pos.end());\n\trep(i,0,n) {\n\t\tpm[i]=lower_bound(all(pos),a[i])-pos.begin();\n\t\tpl[i]=lower_bound(all(pos),a[i]-l[i])-pos.begin();\n\t\tpr[i]=lower_bound(all(pos),a[i]+l[i])-pos.begin();\n//\t\tprintf(""%d %d %d %d\\n"",i,pm[i],pl[i],pr[i]);\n\t}\n\tm=SZ(pos);\n\trep(i,0,m) rep(j,0,m) rep(k,0,m) dp[i][j][k]=-(1ll<<60);\n\trep(k,0,m) dp[0][0][k]=0;\n\trep(i,0,m-1) {\n//\t\tprintf(""%d\\n"",pos[i+1]-pos[i]);\n\t\tint ps=-1;\n\t\trep(j,0,n) if (pm[j]==i) ps=j;\n\t\trep(j,0,m) rep(k,0,m) if (dp[i][j][k]>=0) {\n//\t\t\tprintf(""%d %d %d %I64d\\n"",i,j,k,dp[i][j][k]);\n\t\t\tif (ps==-1) {\n\t\t\t\tupd(dp[i+1][j][k],dp[i][j][k]+(j>=i+1||k<=i?(pos[i+1]-pos[i]):0));\n\t\t\t} else {\n\t\t\t\tupd(dp[i+1][max(j,pr[ps])][k],dp[i][j][k]+pos[i+1]-pos[i]);\n\t\t\t\tif (k==pl[ps]) {\n\t\t\t\t\trep(l,k,m) upd(dp[i+1][max(j,i)][l],dp[i][j][k]+((j>=i+1||l<=i)?(pos[i+1]-pos[i]):0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tans=0;\n\trep(i,0,m) upd(ans,dp[m-1][i][m-1]);\n\tprintf(""%I64d\\n"",ans);\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3000
Once upon a time Oolimry saw a suffix array He wondered how many strings can produce this suffix array More formally given a suffix array of length n and having an alphabet size k count the number of strings that produce such a suffix array Let s be a string of length n Then the i th suffix of s is the substring s i ldots n 1 A suffix array is the array of integers that represent the starting indexes of all the suffixes of a given string after the suffixes are sorted in the lexicographic order For example the suffix array of is 3 2 4 1 0 5 6 as the array of sorted suffixes is texttt imry texttt limry texttt mry texttt olimry texttt oolimry texttt ry texttt y A string x is lexicographically smaller than string y if either x is a prefix of y and x neq y or there exists such i that x i y i and for any 1 leq j i x j y j ,"[""//#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <math.h>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <complex>\n//#include <ext/pb_ds/assoc_container.hpp>\n//#include <ext/pb_ds/tree_policy.hpp>\n#define itn int\n#define nit int\n#define ll long long\n#define ms multiset\n#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)\n#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)\n#define re register\n#define ri re int\n#define il inline\n#define pii pair<int,int>\n#define cp complex<double>\n#define mod 998244353\n//#pra gma G CC opti mize(3)\nusing namespace std;\nusing std::bitset;\n//using namespace __gnu_pbds;\nconst double Pi=acos(-1);\nnamespace fastIO {\n\ttemplate<class T>\n\tinline void read(T &x) {\n\t\tx=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>'9'||ch<'0') {\n\t\t\tch=getchar();\n\t\t\tif(ch=='-')fu=1;\n\t\t}\n\t\twhile(ch<='9'&&ch>='0') x=(x*10-48+ch),ch=getchar();\n\t\tif(fu)x=-x;\n\t}\n\tinline int read() {\n\t\tint x=0;\n\t\tbool fu=0;\n\t\tchar ch=0;\n\t\twhile(ch>'9'||ch<'0') {\n\t\t\tch=getchar();\n\t\t\tif(ch=='-')fu=1;\n\t\t}\n\t\twhile(ch<='9'&&ch>='0') x=(x*10-48+ch),ch=getchar();\n\t\treturn fu?-x:x;\n\t}\n\ttemplate<class T,class... Args>\n\tinline void read(T& t,Args&... args) {\n\t\tread(t);\n\t\tread(args...);\n\t}\n\tchar _n_u_m_[40];\n\ttemplate<class T>\n\tinline void write(T x ) {\n\t\tif(x==0){\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tT tmp = x > 0 ? x : -x ;\n\t\tif( x < 0 ) putchar('-') ;\n\t\tregister int cnt = 0 ;\n\t\twhile( tmp > 0 ) {\n\t\t\t_n_u_m_[ cnt ++ ] = tmp % 10 + '0' ;\n\t\t\ttmp /= 10 ;\n\t\t}\n\t\twhile( cnt > 0 ) putchar(_n_u_m_[ -- cnt ]) ;\n\t}\n\ttemplate<class T>\n\tinline void write(T x ,char ch) {\n\t\twrite(x);\n\t\tputchar(ch);\n\t}\n}\nusing namespace fastIO;\nint sa[1114514],rk[1114514],n,k;\nlong long fac[1000002],ifac[1000002],inv[1000002];\ninline long long pw(long long x,long long p){\n    long long res=1;\n    for(;p;p>>=1,x=x*x%mod)\n        if(p&1)res=res*x%mod;\n    return res;\n}\ninline long long getm(long long top,long long bot) {\n\treturn (top*pw(bot,mod-2))%mod;\n}\ninline long long C(long long top,long long bot){\n\tif(top<bot||top<0||bot<0)return 0;\n\treturn fac[top]*ifac[bot]%mod*ifac[top-bot]%mod;\n}\nint main() {\n\tn=1e6;\n\tfac[0]=1;\n\tF(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=getm(1,fac[n]);\n\tUF(i,n-1,0)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tF(i,1,n)inv[i]=ifac[i]*fac[i-1]%mod;\n\tcin>>n>>k;\n\tF(i,1,n)sa[i]=read()+1;\n\tF(i,1,n)rk[sa[i]]=i;\n\tF(i,2,n)if(rk[sa[i]+1]>rk[sa[i-1]+1])++k;\n\tcout<<C(k,n);\n\treturn 0;\n}\n""]","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2400
You are given two integer numbers n and x You may perform several operations with the integer x Each operation you perform is the following one choose any digit y that occurs in the decimal representation of x at least once and replace x by x cdot y You want to make the length of decimal representation of x without leading zeroes equal to n What is the minimum number of operations required to do that ,"['/**\n *    author:  tourist\n *    created: 23.05.2022 18:39:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  long long x;\n  cin >> n >> x;\n  vector<long long> p10(n);\n  p10[0] = 1;\n  for (int i = 1; i < n; i++) {\n    p10[i] = p10[i - 1] * 10;\n  }\n  long long goal = p10[n - 1];\n  const int inf = (int) 1e9;\n  int ans = inf;\n  function<void(int, long long)> Dfs = [&](int cnt, long long num) {\n    if (cnt >= ans) {\n      return;\n    }\n    if (num >= goal) {\n      ans = cnt;\n      return;\n    }\n    int need = 0;\n    long long tmp = num;\n    while (tmp < goal) {\n      tmp *= 9;\n      need += 1;\n    }\n    if (cnt + need >= ans) {\n      return;\n    }\n    array<bool, 10> has;\n    for (int d = 0; d < 10; d++) {\n      has[d] = false;\n    }\n    tmp = num;\n    while (tmp > 0) {\n      has[tmp % 10] = true;\n      tmp /= 10;\n    }\n    for (int d = 9; d >= 2; d--) {\n      if (has[d]) {\n        Dfs(cnt + 1, num * d);\n      }\n    }\n  };\n  Dfs(0, x);\n  cout << (ans == inf ? -1 : ans) << \'\\n\';\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1700
A lot of students spend their winter holidays productively Vlad has advanced very well in doing so For three days already fueled by salads and tangerines the leftovers from New Year celebration he has been calibrating his rating in his favorite MOBA game playing as a hero named Perun Perun has an ultimate ability called Thunderwrath At the instant of its activation each enemy on the map of them in total loses health points as a single time effect It also has a restriction it can only activated when the moment of time is an The initial bounty for killing an enemy is Additionally it increases by each second Formally if at some second the ability is activated and the th enemy is killed as a result i e his health drops to zero or lower Vlad earns units of gold Every enemy can receive damage as well as be healed There are multiple ways of doing so but Vlad is not interested in details For each of enemies he knows maximum number of health points for the th enemy initial health of the enemy on the th second the amount of health the th enemy can regenerate per second There also health updates Vlad knows about time when the health was updated the enemy whose health was updated updated health points for Obviously Vlad wants to maximize his profit If it s necessary he could even wait for years to activate his ability at the right second Help him determine the exact second note that it must be from inclusively to so that a single activation of the ability would yield Vlad the maximum possible amount of gold and print this amount ,"['#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\n#define pii pair<int,int>\nusing namespace std;\nint n, m, AA, inc, K, INF = 2e9;\nstruct point {\n\tint M, R;\n\tvector<pii>T;\n}w[101000];\nmap<int, int>B;\nint main() {\n\tint i, h, t, a, j;\n\tscanf(""%d%d%d%d%d"", &n,&m,&AA,&inc,&K);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d%d%d"", &w[i].M, &h, &w[i].R);\n\t\tw[i].T.push_back({ 0, h });\n\t}\n\tfor (i = 0; i < m; i++) {\n\t\tscanf(""%d%d%d"", &t, &a, &h);\n\t\tw[a].T.push_back({ t,h });\n\t}\n\tint ck = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tsort(w[i].T.begin(), w[i].T.end());\n\t\tif (w[i].M <= K && inc) {\n\t\t\tck = 1;\n\t\t}\n\t\tif (w[i].T.back().second <= K && w[i].R == 0 && inc) {\n\t\t\tck = 1;\n\t\t}\n\t\tw[i].T.push_back({ INF,0 });\n\t\tfor (j = 0; j < w[i].T.size() - 1; j++) {\n\t\t\tpii tp = w[i].T[j];\n\t\t\tint t1 = tp.first, hh = tp.second;\n\t\t\tint t2 = w[i].T[j + 1].first;\n\t\t\tif (hh > K)continue;\n\t\t\tif (w[i].R == 0 || w[i].M <= K) {\n\t\t\t\tB[t1]++;\n\t\t\t\tB[t2]--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tt = (K - hh) / w[i].R;\n\t\t\t\tB[t1]++;\n\t\t\t\tB[min(t2, t1 + tt + 1)]--;\n\t\t\t}\n\t\t}\n\t}\n\tif (ck) {\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tint s = 0;\n\tlong long r = 0;\n\tfor (auto &tp : B){\n\t\tlong long t = 1ll*s*AA + 1ll*s*inc*(tp.first - 1);\n\t\tr = max(r, t);\n\t\ts += tp.second;\n\t}\n\tprintf(""%lld\\n"", r);\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
There are n cities in the Kingdom of Autumn numbered from 1 to n People can travel between any two cities using n 1 two directional roads This year the government decides to separate the kingdom There will be regions of different levels The whole kingdom will be the region of level 1 Each region of i th level should be separated into several at least two regions of i 1 th level unless i th level is the last level Each city should belong to exactly one region of each level and for any two cities in the same region it should be possible to travel between them passing the cities in the same region only According to research for each city i there is a value a i which describes the importance of this city All regions of the same level should have an equal sum of city importances Your task is to find how many plans there are to determine the separation of the regions that all the conditions are satisfied Two plans are considered different if and only if their numbers of levels are different or there exist two cities in the same region of one level in one plan but in different regions of this level in the other plan Since the answer may be very large output it modulo 10 9 7 ,"['#include<cstdio>\nconst int mod=1000000007,hmod=10000019;\nint n,a[1000010],p[1000010],f[1000010];\nlong long sz[1000010];\nint g[1000010];\nlong long gcd(long long a,long long b){return b?gcd(b,a%b):a;}\nint main(){\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;i++)scanf(""%d"",a+i),sz[i]=a[i];\n\tfor(int i=2;i<=n;i++)scanf(""%d"",p+i);\n\tfor(int i=n;i>1;i--)sz[p[i]]+=sz[i];\n\tfor(int i=1;i<=n;i++){\n\t\tlong long j=sz[1]/gcd(sz[1],sz[i]);\n\t\tif(j<=n)g[j]++;\n\t}\n\tfor(int i=n;i;i--)\n\t\tfor(int j=i*2;j<=n;j+=i)g[j]+=g[i];\n\tfor(int i=n;i>=1;i--)if(g[i]>=i){\n\t\tf[i]=1;\n\t\tfor(int j=i*2;j<=n;j+=i)(f[i]+=f[j])%=mod;\n\t}\n\tprintf(""%d\\n"",f[1]);\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]",2700
And here goes another problem on arrays You are given positive integer and array which consists of integers Let s introduce two characteristics for the given array Let s consider an arbitrary interval of the array with length starting in position Value is the on the chosen interval In other words the modular sum is the sum of integers on the chosen interval with length taken in its absolute value Value is the of the array In other words the optimal sum of an array is the maximum of all modular sums on various intervals of array with length Your task is to calculate the optimal sum of the given array However before you do the calculations you are allowed to produce than consecutive operations of the following form with this array one operation means taking an arbitrary number from array and multiply it by 1 In other words no more than times you are allowed to take an arbitrary number from the array and replace it with Each number of the array is allowed to choose an arbitrary number of times Your task is to calculate the maximum possible optimal sum of the array after at most operations described above are completed ,"['#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <string.h>\n#include <sstream>\n#define _USE_MATH_DEFINES\n#define fo(i,n) for(i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define sz(x) x.size()\nusing namespace std;\n\ntypedef long long ll;\n\nenum colour {BLACK, RED};\n\ntemplate <class data>\n\nclass redblack\n{\npublic:\n    redblack *left, *right, *par;\n    int subTreeSize;\n    colour color;\n    data compVal;\n\n    data subTreeSum;\n    data sumOfMax(int k)\n    {\n        if (subTreeSize <= k) return subTreeSum;\n        ll ret = 0;\n        if (right != NULL)\n            {\n                ret += right->sumOfMax(k);\n                k -= right->subTreeSize;\n            }\n        if (k <= 0) return ret;\n        ret += compVal * min(k, nodeSize());\n        k -= nodeSize();\n        if (k <= 0) return ret;\n        ret += left->sumOfMax(k);\n        return ret;\n    }\n\n    redblack* root()\n    {\n        if (par != NULL) return par->root();\n        return this;\n    }\n    \n    static redblack* create()\n    {\n        redblack *tree = new redblack();\n        return tree;\n    }\n    \n    int nodeSize()\n    {\n        return sz(values);\n    }\n\n    vector < data > getValues()\n    {\n        return values;\n    }\n\n    redblack find(data val)\n    {\n        if (isNil) return NULL;\n        if (compVal == val) return this;\n        redblack next = getNext(val);\n        if (next == NULL) return NULL;\n        return next.find(val);\n    }\n\n    redblack* treeMin()\n    {\n        if (left == NULL) return this;\n        return treeMin(left);\n    }\n\n    redblack* treeMax()\n    {\n        if (right == NULL) return this;\n        return treeMax(right);\n    }\n\n    redblack* succesor()\n    {\n        if (isNil) return NULL;\n        if (right != NULL) return treeMin(right);\n        redblack *pr = par, *ptr = this;        \n        while(pr != NULL && ptr == pr->right)\n            {\n                ptr = pr;\n                pr = ptr->par;\n            }\n        return pr;\n    }\n\n    redblack* predecessor()\n    {\n        if (isNil) return NULL;\n        if (left != NULL) return treeMax(left);\n        redblack *pr = par, *ptr = this;        \n        while(pr != NULL && ptr == pr->left)\n            {\n                ptr = pr;\n                pr = ptr->par;\n            }\n        return pr;\n    }\n\n    bool remove(data val)\n    {\n        if (isNil) return false;\n        if (compVal == val)\n            {\n                if (sz(values))\n                    {\n                        values.pop_back();\n                        subTreeSize--;\n                        subTreeSum -= val;\n                        return true;\n                    }\n                return false;\n            }\n        redblack *next = getNext(val);\n        if (next == NULL) return false;\n        bool deleted = next->remove(val);\n        if (deleted)\n            {\n                subTreeSize--;\n                subTreeSum -= val;\n            }\n        return deleted;\n    }\n\n    redblack* insert(data val)\n      {\n          if (isNil)\n              {\n                  isNil = false;\n                  par = left = right = NULL;\n                  compVal = val;\n                  values.pb(val);\n                  subTreeSize = 1;                  \n                  subTreeSum = val;\n                  color = BLACK;\n                  return this;\n              }\n          if (compVal == val)\n              {\n                  values.pb(val);\n                  subTreeSize++;\n                  subTreeSum += val;\n                  return this;\n              }\n          redblack *next = getNext(val);\n          if (next == NULL)\n              {\n                  redblack *node = new redblack(this, val);\n                  if (val > compVal) right = node; else left = node;\n                  subTreeSize++;\n                  subTreeSum += val;\n                  return node;\n              }\n          redblack *inserted = next->insert(val);\n          subTreeSize++;\n          subTreeSum += val;\n          if (par == NULL) inserted->insertBalance();\n          return inserted;              \n      }\n\n    redblack* getNext(data val)\n    {\n        if (compVal > val) return left;\n        return right;\n    }\n\n    void clear()\n    {\n        if (left != NULL) left->clear();\n        if (right != NULL) right->clear();\n        delete(this);\n    }\n\nprivate:\n    bool isNil;\n    vector < data > values;\n\n    redblack()\n    {\n        par = left = right = NULL;\n        isNil = true;\n        color = RED;\n        subTreeSize = 0;\n        subTreeSum = 0;\n    }\n\n    redblack(redblack *parent, data val)\n    {\n        left = right = NULL;        \n        par = parent;\n        isNil = false;\n        color = RED;\n        compVal = val;\n        values.pb(val);\n        subTreeSize = 1;\n        subTreeSum = val;\n    }\n\n    void rightRotate()\n    {\n        redblack *x = this, *y = x->left;\n        if (x -> isNil || y == NULL || y->isNil) return;\n        x->left = y->right;\n        if (y->right != NULL) y->right->par = x;\n        y->par = x->par;\n        if (x->par != NULL)\n            {\n                if (x->par->left == x) x->par->left = y;\n                else x->par->right = y;\n            }\n        y->right = x;\n        x->par = y;\n        y->subTreeSize = x->subTreeSize;\n        x->subTreeSize = x->nodeSize() + ((x->left != NULL)?x->left->subTreeSize:0) + ((x->right != NULL)?x->right->subTreeSize:0);\n        y->subTreeSum = x->subTreeSum;\n        x->subTreeSum = x->nodeSize()*x->compVal + ((x->left != NULL)?x->left->subTreeSum:0) + ((x->right != NULL)?x->right->subTreeSum:0);\n    }\n\n    void leftRotate()\n    {\n        redblack *x = this, *y = x->right;\n        if (x->isNil || y == NULL || y->isNil ) return;\n        x->right = y->left;\n        if (y->left != NULL) y->left->par = x;\n        y->par = x->par;\n        if (x->par != NULL)\n            {\n                if (x->par->left == x) x->par->left = y;\n                else x->par->right = y;\n            }\n        y->left = x;\n        x->par = y;\n        y->subTreeSize = x->subTreeSize;\n        x->subTreeSize = x->nodeSize() + ((x->left != NULL)?x->left->subTreeSize:0) + ((x->right != NULL)?x->right->subTreeSize:0);\n        y->subTreeSum = x->subTreeSum;\n        x->subTreeSum = x->nodeSize()*x->compVal + ((x->left != NULL)?x->left->subTreeSum:0) + ((x->right != NULL)?x->right->subTreeSum:0);\n    }\n\n    void insertBalance()\n    {\n        redblack *x = this, *y;\n        \n        while(x->par != NULL && x->par->color == RED)\n            {\n                if (x->par->par == NULL) return;\n                if (x->par == x->par->par->left)\n                    {\n                        y = x->par->par->right;\n                        if (y != NULL && y->color == RED)\n                            {\n                                x->par->color = y->color = BLACK;\n                                x->par->par->color = RED;\n                                x = x->par->par;\n                            }\n                        else\n                            {\n                                if (x == x->par->right)\n                                    {\n                                        x = x->par;\n                                        x->leftRotate();\n                                    }\n                                x->par->color = BLACK;\n                                x->par->par->color = RED;\n                                x->par->par->rightRotate();\n                            }\n                    }\n                else\n                    {\n                        y = x->par->par->left;    \n                        if (y != NULL && y->color == RED)\n                            {\n                                x->par->color = y->color = BLACK;\n                                x->par->par->color = RED;\n                                x = x->par->par;\n                            }\n                        else\n                            {\n                                if (x == x->par->left)\n                                    {\n                                        x = x->par;\n                                        x->rightRotate();\n                                    }\n                                x->par->color = BLACK;\n                                x->par->par->color = RED;\n                                x->par->par->leftRotate();\n                            }\n                    }\n            }\n        this->root()->color = BLACK;\n    }\n};\n\nint n, len, k;\nint a[200000];\n\nll solve()\n{\n    ll ret = 0, posSum = 0;\n    int i;\n    redblack<ll> *tree = redblack<ll>::create();\n    fo(i,(len-1))\n        {\n            if (a[i] < 0) tree->root()->insert(-a[i]); else posSum += a[i];\n        }\n    for(i = len-1; i < n; i++)\n        {\n            if (a[i] < 0) tree->root()->insert(-a[i]); else posSum += a[i];\n            ll maxTreeSum = tree->root()->sumOfMax(k);\n            ll noChange = tree->root()->subTreeSum - maxTreeSum;\n            ret = max(ret, maxTreeSum + posSum - noChange);\n            if (a[i + 1 - len] < 0) tree->root()->remove(-a[i + 1 - len]); else posSum -= a[i + 1 - len];\n        }\n    tree->root()->clear();\n    return ret;\n}\n\nint main(void)\n{\n    int i;\n    cin >> n >> len;\n    fo(i,n)\n        {\n            cin >> a[i];\n        }\n    cin >> k;\n\n    ll ans = 0;\n    ans = max(ans, solve());\n    fo(i,n)\n        {\n            a[i] = -a[i];\n        }\n    ans = max(ans, solve());\n    cout << ans << endl;\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Mishka is a little polar bear As known little bears loves spending their free time playing dice for chocolates Once in a wonderful sunny morning walking around blocks of ice Mishka met her friend Chris and they started playing the game Rules of the game are very simple at first number of rounds is defined In every round each of the players throws a cubical dice with distinct numbers from to written on its faces Player whose value after throwing the dice is greater wins the round In case if player dice values are equal no one of them is a winner In average player who won most of the rounds is the winner of the game In case if two players won the same number of rounds the result of the game is draw Mishka is still very little and can t count wins and losses so she asked you to watch their game and determine its result Please help her ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define FZ(n) memset((n),0,sizeof(n))\n#define FMO(n) memset((n),-1,sizeof(n))\n#define MC(n,m) memcpy((n),(m),sizeof(n))\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) begin(x),end(x)\n#define IOS do { ios_base::sync_with_stdio(0);cin.tie(0); } while (0)\n#define SZ(x) ((int)(x).size())\n#ifndef OFFLINE\n    #define ONLINE_JUDGE\n#endif\n#ifdef ONLINE_JUDGE\n#define FILEIO(name) \\\n    do { \\\n        freopen(name"".in"", ""r"", stdin); \\\n        freopen(name"".out"", ""w"", stdout); \\\n    } while (0)\n#else\n    #define FILEIO(name) do { } while(0)\n#endif\n\n#define _TOKEN_CAT2(x, y) x ## y\n#define _TOKEN_CAT(x, y) _TOKEN_CAT2(x, y)\n#define _MACRO_OVERL3(_1, _2, _3, _N, ...) _N\n#define _RANGE1(a) int _TOKEN_CAT(_t, __LINE__)=0; _TOKEN_CAT(_t, __LINE__)<(a); (_TOKEN_CAT(_t, __LINE__))++\n#define _RANGE2(i, a) int (i)=0; (i)<(a); (i)++\n#define _RANGE3(i, a, b) int (i)=(a); (i)!=(b); (i)+=((b)>(a)?1:-1)\n#define loop(...) for (_MACRO_OVERL3(__VA_ARGS__, _RANGE3, _RANGE2, _RANGE1)(__VA_ARGS__))\n\n#ifdef OFFLINE\ntemplate<typename T>\nvoid _dump(const char* s, T&& head) { \n    cerr << s << "" = "" << head << "" <<"" << endl; \n}\n\ntemplate<typename T, typename... Args>\nvoid _dump(const char* s, T&& head, Args&&... tail) {\n    int c = 0;\n    while (*s!=\',\' || c!=0) {\n        if (*s==\'(\' || *s==\'[\' || *s==\'{\' || *s==\'<\') c++;\n        if (*s==\')\' || *s==\']\' || *s==\'}\' || *s==\'>\') c--;\n        cerr << *s++;\n    }\n    cerr << "" = "" << head << "", "";\n    _dump(s+1, tail...);\n}\n\n#define dump(...) do { \\\n    cerr << ""\\033[32m>> "" << __LINE__ << "": "" << __PRETTY_FUNCTION__ << endl; \\\n    cout << ""   ""; \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n    cout << ""\\033[0m""; \\\n} while (0)\n#else\n#define dump(...) \n#endif\n\n#define au auto\ntemplate<class T>\nusing vec = vector<T>;\n\ntemplate<typename Iter>\nostream& _IterOutput_(ostream &o, Iter b, Iter e, const string ss="""", const string se="""") {\n    o << ss;\n    for (auto it=b; it!=e; it++) o << (it==b ? """" : "", "") << *it;\n    return o << se;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const pair<T1, T2> &pair) {\n    return o << ""("" << pair.F << "", "" << pair.S << "")"";\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const vector<T> &vec) {\n    return _IterOutput_(o, ALL(vec), ""["", ""]"");\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const set<T> &st) {\n    return _IterOutput_(o, ALL(st), ""{"", ""}"");\n}\n\ntemplate<typename T, size_t N>\nostream& operator << (ostream &o, const array<T, N> &arr) {\n    return _IterOutput_(o, ALL(arr), ""|"", ""|"");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const map<T1, T2> &mp) {\n    o << ""{"";\n    for (auto it=mp.begin(); it!=mp.end(); it++) {\n        o << (it==mp.begin()?"""":"", "") << it->F << "":"" << it->S;\n    }\n    o << ""}"";\n    return o;\n}\n\nvoid lucky_test() {\n    srand(time(NULL));\n    long long a = rand(), b = rand();\n    if ((a * 32768 + b) % 100000 == 0) {\n        cout << ""Not lucky"" << endl;\n        exit(0);\n    }\n}\n\nint32_t main() {\n    IOS;\n    lucky_test();\n\n    int N;\n    cin >> N;\n    int a = 0, b = 0;\n    for (int i=0; i<N; i++) {\n        int x, y;\n        cin>>x>>y;\n        if (x>y) a++;\n        else if (x<y) b++;\n    }\n\n\n    cout << (a == b ? ""Friendship is magic!^^"" :\n             a > b ? ""Mishka"" : ""Chris"") << endl;\n    return 0;\n}\n\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given a rooted tree consisting of n vertices Vertices are numbered from 1 to n Any vertex can be the root of a tree A is a connected undirected graph without cycles A is a tree with a selected vertex which is called the The tree is specified by an array of parents p containing n numbers p i is a parent of the vertex with the index i The of a vertex u is a vertex that is the next vertex on the shortest path from u to the root For example on the simple path from 5 to 3 the root the next vertex would be 1 so the parent of 5 is 1 The root has no parent so for it the value of p i is i the root is the only vertex for which p i i Find such a set of paths that each vertex belongs to exactly one path each path can contain one or more vertices in each path each next vertex is a son of the current vertex that is paths always lead down from parent to son number of paths is For example if n 5 and p 3 1 3 3 1 then the tree can be divided into three paths 3 rightarrow 1 rightarrow 5 path of 3 vertices 4 path of 1 vertices 2 path of 1 vertices ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\ninline int reads(char* s){\n\tint t = 0;\n\tregister char c = getchar();\n\twhile (c != \'1\' && c != \'0\' && c != \'?\') c = getchar();\n\twhile (c == \'1\' || c == \'0\' || c == \'?\') s[++t] = c,c = getchar();\n\treturn t;\n}\n\nconst int N = 2e5;\nint T,rt,n,ans,etot,stop,fa[N + 1],indeg[N + 1],head[N + 1],stk[N + 1];\n\nstruct Edge{\n\tint u,v,next;\n}e[(N << 1) + 1];\n\nvoid adde(int u,int v) {e[++etot] = (Edge){u,v,head[u]},head[u] = etot;}\n\nvoid dfs(int now,int f){\n\tstk[++stop] = now;\n\tif (!indeg[now]){\n\t\tprintf(""%d\\n"",stop);\n\t\tfor (int i = 1;i <= stop;i++) printf(""%d "",stk[i]);\n\t\tputchar(\'\\n\');\n\t\tstop = 0;\n\t\treturn ;\n\t}\n\tfor (int i = head[now];i;i = e[i].next){\n\t\tif (e[i].v == f) continue;\n\t\tdfs(e[i].v,now);\n\t}\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\tn = read();\n\t\tans = stop = etot = 0;\n\t\tfor (int i = 1;i <= n;i++) indeg[i] = 0,fa[i] = 0,head[i] = 0;\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tfa[i] = read();\n\t\t\tif (fa[i] != i) ++indeg[fa[i]],adde(i,fa[i]),adde(fa[i],i);\n\t\t\telse rt = i;\n\t\t}\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tif (!indeg[i]) ++ans;\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t\tdfs(rt,0);\n\t\tputchar(\'\\n\');\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Today the Z city residents enjoy a shell game competition The residents are gathered on the main square to watch the breath taking performance The performer puts 3 non transparent cups upside down in a row Then he openly puts a small ball under one of the cups and starts to shuffle the cups around very quickly so that on the whole he makes exactly 3 shuffles After that the spectators have exactly one attempt to guess in which cup they think the ball is and if the answer is correct they get a prize Maybe you can try to find the ball too ,"['#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    int cup;\n    bool p[] = {false, false, false};\n    scanf(""%d"", &cup);\n    p[cup-1] = true;\n    for(int i=0; i<3; i++){\n        int a, b;\n        scanf(""%d%d"", &a, &b); a--; b--;\n        swap(p[a], p[b]);\n    }\n    for(int i=0; i<3; i++){\n        if (p[i]) {\n            printf(""%d\\n"", i+1);\n            break;\n        }\n    }\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
You are given an array a 1 a 2 dots a n You can perform the following operation any number of times Choose a pair of two neighboring equal elements a i a i 1 if there is at least one such pair Replace them by one element with value a i 1 After each such operation the length of the array will decrease by one and elements are renumerated accordingly What is the minimum possible length of the array a you can get ,"['#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 505;\nint dp[maxN][maxN];\nint what[maxN][maxN];\nint n;\nint a[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(""input.txt"", ""r"", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = i; j <= n; j++) {\n            if (i == j) {\n                dp[i][j] = true;\n                what[i][j] = a[i];\n            }\n            else {\n                dp[i][j] = j - i + 1;\n            }\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i + len - 1 <= n; i++) {\n            int j = i + len - 1;\n            for (int k = i; k < j; k++) {\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);\n                if (dp[i][k] == 1 && dp[k + 1][j] == 1 && what[i][k] == what[k + 1][j]) {\n                    dp[i][j] = 1;\n                    what[i][j] = what[i][k] + 1;\n                }\n            }\n        }\n    }\n    cout << dp[1][n];\n    return 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Xenia the vigorous detective faced foreign spies lined up in a row We ll consider the spies numbered from 1 to from left to right Spy has an important note He has to pass the note to spy Xenia interrogates the spies in several steps During one step the spy keeping the important note can pass the note to one of his neighbours in the row In other words if this spy s number is he can pass the note to another spy either or if or then the spy has only one neighbour Also during a step the spy can keep a note and not pass it to anyone But nothing is that easy During steps Xenia watches some spies attentively Specifically during step steps are numbered from 1 Xenia watches spies numbers Of course if during some step a spy is watched he can t do anything neither give the note nor take it from some other spy Otherwise Xenia reveals the spies cunning plot Nevertheless if the spy at the current step keeps the note Xenia sees nothing suspicious even if she watches him You ve got and Also you have the steps during which Xenia watches spies and which spies she is going to watch during each step Find the best way the spies should act in order to pass the note from spy to spy as quickly as possible in the minimum number of steps ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#define lson step << 1\n#define rson step << 1 | 1\n#define lowbit(x) (x & (-x))\n#define Key_value ch[ch[root][1]][0] \nusing namespace std;\ntypedef long long LL;\nconst int N = 500005;\nconst int inf = 1000000009;\nint n , m , s , f;\nint t[N] , l[N] , r[N];\nint main () {\n    #ifndef ONLINE_JUDGE\n        freopen (""input.txt"" , ""r"" , stdin);\n        // freopen (""output.txt"" , ""w"" , stdout);\n    #endif\n    cin >> n >> m >> s >> f;\n    for (int i = 0 ; i < m ; i ++) {\n        cin >> t[i] >> l[i] >> r[i];\n    }\n    int sgn = (f - s) > 0 ? 1 : -1;\n    for (int i = 1 , j = 0 ; ; i ++) {\n        if (s == f) break;\n        int nxt = s + sgn;\n        if (j < m && t[j] == i) {\n            if ((s >= l[j] && s <= r[j]) || (nxt >= l[j] && nxt <= r[j]))\n                putchar (\'X\');\n            else {\n                s = nxt;\n                if (sgn > 0) putchar (\'R\');\n                else putchar (\'L\');\n            }\n            j ++;\n        }\n        else {\n            s = nxt;\n            if (sgn > 0) putchar (\'R\');\n            else putchar (\'L\');\n        }\n    }\n    puts ("""");\n    return 0;\n}       \n\n']","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
To prevent the mischievous rabbits from freely roaming around the zoo Zookeeper has set up a special lock for the rabbit enclosure This lock is called the Rotary Laser Lock The lock consists of n concentric rings numbered from 0 to n 1 The innermost ring is ring 0 and the outermost ring is ring n 1 All rings are split equally into nm sections each Each of those rings contains a single metal arc that covers exactly m contiguous sections At the center of the ring is a core and surrounding the entire lock are nm receivers aligned to the nm sections The core has nm lasers that shine outward from the center one for each section The lasers can be blocked by any of the arcs A display on the outside of the lock shows how many lasers hit the outer receivers In the example above there are n 3 rings each covering m 4 sections The arcs are colored in green ring 0 purple ring 1 and blue ring 2 while the lasers beams are shown in red There are nm 12 sections and 3 of the lasers are not blocked by any arc thus the display will show 3 in this case Wabbit is trying to open the lock to free the rabbits but the lock is completely opaque and he cannot see where any of the arcs are Given the of the arcs Wabbit can open the lock on his own To be precise Wabbit needs n 1 integers p 1 p 2 ldots p n 1 satisfying 0 leq p i nm such that for each i 1 leq i n Wabbit can rotate ring 0 clockwise exactly p i times such that the sections that ring 0 covers perfectly aligns with the sections that ring i covers In the example above the relative positions are p 1 1 and p 2 7 To operate the lock he can pick any of the n rings and rotate them by 1 section either clockwise or anti clockwise You will see the number on the display after every rotation Because his paws are small Wabbit has asked you to help him to find the of the arcs You may perform up to 15000 rotations before Wabbit gets impatient ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=3007;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid ff()\n{\n\tfflush(stdout);\n}\n\nint n, m;\n\nint pole;\n\nint poz[nax];\n\nint zapy;\n\nint policz()\n{\n\tint ret=0;\n\tfor (int i=0; i<n*m; i++)\n\t{\n\t\tint czy=1;\n\t\tfor (int j=0; j<n; j++)\n\t\t{\n\t\t\tint x=i-poz[j];\n\t\t\tx%=(n*m);\n\t\t\tx+=(n*m);\n\t\t\tx%=(n*m);\n\t\t\tif (x<m)\n\t\t\t\tczy=0;\n\t\t}\n\t\tret+=czy;\n\t}\n\treturn ret;\n}\n\nvoid zrob(int v, int kier)\n{\n\tzapy++;\n\tassert(zapy<=15000);\n\tprintf(""? %d %d\\n"", v, kier);\n\tff();\n\tscanf(""%d"", &pole);\n\t\n\t//~ poz[v]=(poz[v]+kier+n*m)%(n*m);\n\t//~ pole=policz();\n}\n\nint los(int a, int b)\n{\n\treturn a+rng()%(b-a+1);\n}\n\nint k;\nvi gru[nax];\n\nvector<pii> graf[nax];\n\nvoid kra(int a, int b, int prz)\n{\n\tprz%=(n*m);\n\tprz+=(n*m);\n\tprz%=(n*m);\n\tgraf[a].push_back({b, prz});\n\tgraf[b].push_back({a, (n*m-prz)%(n*m)});\n}\n\nint malew[nax];\n\nint wyn[nax];\nint bylo[nax];\n\nvoid dfs(int v)\n{\n\tbylo[v]=1;\n\tfor (pii i : graf[v])\n\t{\n\t\tif (!bylo[i.first])\n\t\t{\n\t\t\twyn[i.first]=(wyn[v]+i.second)%(n*m);\n\t\t\tdfs(i.first);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\t//~ for (int i=0; i<n; i++)\n\t\t//~ poz[i]=los(0, n*m-1);\n\t\t//~ poz[i]=i*m;\n\t//~ debug() << range(poz, poz+n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tint x=los(-20, 20);\n\t\twhile(x)\n\t\t{\n\t\t\tzrob(i, x/abs(x));\n\t\t\tx-=x/abs(x);\n\t\t}\n\t}\n\tvi kol(n);\n\tiota(kol.begin(), kol.end(), 0);\n\tshuffle(kol.begin(), kol.end(), rng);\n\tfor (int i : kol)\n\t{\n\t\tint pam=pole;\n\t\twhile(1)\n\t\t{\n\t\t\tzrob(i, 1);\n\t\t\tif (pole<pam)\n\t\t\t{\n\t\t\t\tzrob(i, -1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpam=pole;\n\t\t}\n\t}\n\t//~ debug() << range(poz, poz+n);\n\t//~ debug() << imie(zapy);\n\t\n\tshuffle(kol.begin(), kol.end(), rng);\n\tfor (int i : kol)\n\t{\n\t\tint mam=0;\n\t\tzrob(i, 1);\n\t\tint pam=pole;\n\t\tfor (int j=0; j<k && !mam; j++)\n\t\t{\n\t\t\tint x=gru[j].back();\n\t\t\tzrob(x, 1);\n\t\t\tif (pole>=pam)\n\t\t\t{\n\t\t\t\tgru[j].push_back(i);\n\t\t\t\tmam=1;\n\t\t\t}\n\t\t\tzrob(x, -1);\n\t\t}\n\t\tzrob(i, -1);\n\t\tif (!mam)\n\t\t{\n\t\t\tgru[k].push_back(i);\n\t\t\tk++;\n\t\t}\n\t}\n\t//~ debug() << imie(k);\n\t//~ for (int i=0; i<k; i++)\n\t\t//~ debug() << gru[i];\n\tfor (int i=0; i<k; i++)\n\t\tfor (int j=1; j<(int)gru[i].size(); j++)\n\t\t\tkra(gru[i][0], gru[i][j], 0);\n\t//~ debug() << imie(zapy);\n\tfor (int i=0; i+1<k; i++)\n\t{\n\t\tint x=gru[i].back();\n\t\tint ruchy=0;\n\t\twhile(1)\n\t\t{\n\t\t\truchy++;\n\t\t\tint pam=pole;\n\t\t\tint oczek=pam;\n\t\t\tif (ruchy<=m)\n\t\t\t\toczek--;\n\t\t\tzrob(x, 1);\n\t\t\tif (pole==oczek)\n\t\t\t\tcontinue;\n\t\t\truchy--;\n\t\t\tzrob(x, -1);\n\t\t\tint znaj=0;\n\t\t\tfor (int j=0; j<k && !znaj; j++)\n\t\t\t{\n\t\t\t\tif (malew[j] || j==i)\n\t\t\t\t\tcontinue;\n\t\t\t\tpam=pole;\n\t\t\t\tint y=gru[j].back();\n\t\t\t\tzrob(y, -1);\n\t\t\t\tint nowe=pole;\n\t\t\t\tzrob(y, 1);\n\t\t\t\tif (nowe>=pam)\n\t\t\t\t{\n\t\t\t\t\tkra(x, y, ruchy+m);\n\t\t\t\t\tmalew[j]=1;\n\t\t\t\t\tznaj=1;\n\t\t\t\t\t//~ debug() << ""od "" << i << "" do "" << j << ""   "" << x << "" "" << y << "" "" << imie(ruchy) << imie(poz[x]) << imie(poz[y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(znaj);\n\t\t\twhile(ruchy--)\n\t\t\t\tzrob(x, -1);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(0);\n\t//~ for (int i=0; i<n; i++)\n\t\t//~ debug() << i << "" "" << graf[i];\n\t//~ debug() << range(poz, poz+n);\n\tprintf(""!"");\n\tfor (int i=1; i<n; i++)\n\t\tprintf("" %d"", wyn[i]);\n\tprintf(""\\n"");\n\tff();\n\t//~ for (int i=1; i<n; i++)\n\t\t//~ assert(wyn[i]==((poz[i]-poz[0]+n*m)%(n*m)));\n\t//~ debug() << imie(zapy);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3500
Mahmoud and Ehab continue their adventures As everybody in the evil land knows Dr Evil likes bipartite graphs especially trees A tree is a connected acyclic graph A bipartite graph is a graph whose vertices can be partitioned into sets in such a way that for each edge that belongs to the graph and belong to different sets You can find more formal definitions of a tree and a bipartite graph in the notes section below Dr Evil gave Mahmoud and Ehab a tree consisting of nodes and asked them to add edges to it in such a way that the graph is still bipartite Besides after adding these edges the graph should be simple doesn t contain loops or multiple edges What is the maximum number of edges they can add A loop is an edge which connects a node with itself Graph doesn t contain multiple edges when for each pair of nodes there is no more than one edge between them ,"['#include <cstdio>\n#include <vector>\nint head[100001], next[199999], to[199999], N, E, fa[100001], dep[100001], D;\nint main()\n{\n\tscanf(""%d"", &N);\n\tfor (int i = 1, u, v; i < N; i++)\n\t{\n\t\tscanf(""%d%d"", &u, &v);\n\t\tnext[++E] = head[u], to[E] = v, head[u] = E;\n\t\tnext[++E] = head[v], to[E] = u, head[v] = E;\n\t}\n\tstatic int q[100001];\n\tint H = 0, T = 1, u;\n\tq[1] = 1;\n\twhile (H < T)\n\t\tfor (int e = head[u = q[++H]]; e; e = next[e])\n\t\t\tif (to[e] != fa[u])\n\t\t\t{\n\t\t\t\tfa[q[++T] = to[e]] = u;\n\t\t\t\tdep[to[e]] = dep[u] ^ 1;\n\t\t\t}\n\tfor (int i = 1; i <= N; i++)\n\t\tD += dep[i];\n\tprintf(""%lld\\n"", (long long)D * (N - D) - N + 1);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Even if it s a really easy question she won t be able to answer it Cirno s perfect bitmasks classroom has just started Cirno gave her students a positive integer x As an assignment her students need to find the integer y which satisfies the following two conditions x texttt and y 0 x texttt xor y 0Where texttt and is the bitwise AND operation and texttt xor is the bitwise XOR operation Among the students was Mystia who was truly baffled by all these new operators Please help her ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconstexpr int inf = 1e18;\nconstexpr int maxn = 2e5 + 5;\nconstexpr int mod = 998244353;\n\ninline void solve()\n{\n  int x; cin >> x;\n  if (__builtin_popcount(x) > 1)\n    cout << (x & -x) << \'\\n\';\n  else if (x == 1)\n    cout << ""3\\n"";\n  else\n    cout << (x ^ 1) << \'\\n\';\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T; cin >> T;\n  while (T --)\n  solve();\n  return 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",800
There is a matrix of size n times n which consists of s and s The rows are numbered from 1 to n from top to bottom the columns are numbered from 1 to n from left to right The cell at the intersection of the x th row and the y th column is denoted as x y AquaMoon wants to turn all elements of the matrix to s In one step she can perform the following operation Select an arbitrary cell let it be i j then invert the element in i j and also invert all elements in cells x y for x i and x i ge left y j right To invert a value means to change it to the opposite changes to changes to Help AquaMoon determine the minimum number of steps she need to perform to turn all elements of the matrix to s We can show that an answer always exists ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=3007;\n\nint n;\nchar wcz[nax];\n\nint tab[nax][nax];\n\nint lew[nax][nax];\nint pra[nax][nax];\nint dol[nax][nax];\n\nint wyn;\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=0; i<=n+1; i++)\n\t\tfor (int j=0; j<=n+1; j++)\n\t\t\ttab[i][j]=lew[i][j]=pra[i][j]=dol[i][j]=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%s"", wcz+1);\n\t\tfor (int j=1; j<=n; j++)\n\t\t\ttab[i][j]=(wcz[j]-\'0\');\n\t}\n\twyn=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tpra[i][j]^=pra[i-1][j-1];\n\t\t\tlew[i][j]^=lew[i-1][j+1];\n\t\t\tdol[i][j]^=lew[i][j]^pra[i][j]^dol[i-1][j];\n\t\t\ttab[i][j]^=dol[i][j];\n\t\t\tif (tab[i][j])\n\t\t\t{\n\t\t\t\twyn++;\n\t\t\t\tlew[i+1][j-1]^=1;\n\t\t\t\tpra[i+1][j+1]^=1;\n\t\t\t\tdol[i+1][j]^=1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
One day Vasya the Hipster decided to count how many socks he had It turned out that he had red socks and blue socks According to the latest fashion hipsters should wear the socks of different colors a red one on the left foot a blue one on the right foot Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn t want to wash them Vasya wonders what is the maximum number of days when he can dress fashionable and wear different socks and after that for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he s got Can you help him ,"[""#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<string>\n#include<cmath>\n#include<cctype>\n#include<ctime>\n#include<bitset>\nusing namespace std;\nconst int maxlongint=2147483647;\nconst int inf=1000000000;\nint main()\n{\n\tint i,j;\n\tcin>>i>>j;\n\tcout<<min(i,j)<<' '<<abs(j-i)/2<<endl;\n}\n""]","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You ve got a string a 1 a 2 dots a n consisting of zeros and ones Let s call a sequence of consecutive elements a i a i 1 ldots a j 1 leq i leq j leq n a of string a You can apply the following operations any number of times Choose some substring of string a for example you can choose entire string and reverse it paying x coins for it for example to Choose some substring of string a for example you can choose entire string or just one symbol and replace each symbol to the opposite one zeros are replaced by ones and ones by zeros paying y coins for it for example to You can apply these operations in any order It is allowed to apply the operations multiple times to the same substring What is the minimum number of coins you need to spend to get a string consisting only of ones ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nint n,x,y;\nchar s[SZ];\nint main()\n{\n\tscanf(""%d%d%d%s"",&n,&x,&y,s+1);\n\tint b=0; ll ans=8e18;\n\tfor(int i=1;i<=n;++i)\n\t\tif(s[i]==\'0\'&&s[i-1]!=\'0\') ++b;\n\tif(!b) ans=0;\n\tfor(int i=0;i<b;++i)\n\t\tans=min(ans,y*(ll)(b-i)+x*(ll)i);\n\tprintf(""%lld\\n"",ans);\n}\n']","[1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
To defeat Lord Voldemort Harry needs to destroy all horcruxes first The last horcrux is an array a of n integers which also needs to be destroyed The array is considered destroyed if all its elements are zeroes To destroy the array Harry can perform two types of operations choose an index i 1 le i le n an integer x and subtract x from a i choose two indices i and j 1 le i j le n i ne j an integer x and subtract x from a i and x 1 from a j Note that x does not have to be positive Harry is in a hurry please help him to find the minimum number of operations required to destroy the array and exterminate Lord Voldemort ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n\t// for a tree of N items, you use N-1 edges, so parity must be N-1 total\n\t// If you just subtract 1, then the parity must be 1\n\tint N; cin >> N;\n\tvector<ll> A(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i];\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] == 0) {\n\t\t\tA.erase(A.begin() + i);\n\t\t\tN--, i--;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tassert(A[i]);\n\t}\n\n\tvector<ll> Asum(1<<N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int m = 0; m < (1<<i); m++) {\n\t\t\tAsum[m|(1<<i)] = Asum[m] + A[i];\n\t\t}\n\t}\n\n\tvector<bool> isTree(1<<N);\n\t{\n\t\tint L = int(N * 0.77);\n\t\tassert(0 <= L && L <= N);\n\n\t\t{\n\t\t\tvector<ll> sums;\n\t\t\tsums.reserve(1<<L);\n\t\t\tfor (int ml = 0; ml < (1 << L); ml++) {\n\t\t\t\tsums.clear();\n\t\t\t\tfor (int v = ml&(ml-1); v; --v &= ml) {\n\t\t\t\t\tassert(0 < v && v < ml);\n\t\t\t\t\tsums.push_back(Asum[ml] - 2 * Asum[v]);\n\t\t\t\t}\n\t\t\t\tsort(sums.begin(), sums.end());\n\t\t\t\tfor (int mr = 0; mr < (1<<N); mr += (1<<L)) {\n\t\t\t\t\tint n = __builtin_popcount(ml | mr);\n\t\t\t\t\tif (n <= 1) continue;\n\t\t\t\t\tif ((Asum[ml] ^ Asum[mr] ^ n ^ 1) & 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tbool isGood = false;\n\t\t\t\t\tfor (int v = mr; true; --v &= mr) {\n\t\t\t\t\t\tll val = Asum[mr] - 2 * Asum[v];\n\t\t\t\t\t\tif ((ml || v < mr) && v) {\n\t\t\t\t\t\t\tif (abs(val + Asum[ml]) <= n-1) {\n\t\t\t\t\t\t\t\tisGood = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((ml || v) && v < mr) {\n\t\t\t\t\t\t\tif (abs(val - Asum[ml]) <= n-1) {\n\t\t\t\t\t\t\t\tisGood = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tauto it = lower_bound(sums.begin(), sums.end(), -val);\n\t\t\t\t\t\tif (it != sums.end()) {\n\t\t\t\t\t\t\tif (*it + val <= n-1) {\n\t\t\t\t\t\t\t\tisGood = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (it != sums.begin()) {\n\t\t\t\t\t\t\t--it;\n\t\t\t\t\t\t\tif (*it + val >= -(n-1)) {\n\t\t\t\t\t\t\t\tisGood = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!v) break;\n\t\t\t\t\t}\n\t\t\t\t\tif (isGood) {\n\t\t\t\t\t\tisTree[ml | mr] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tauto fft = [&](vector<uint32_t>& v) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int mb = 0; mb < (1 << N); mb += (2<<i)) {\n\t\t\t\tfor (int m = 0; m < (1 << i); m++) {\n\t\t\t\t\tfor (int c = 0; c <= N; c++) {\n\t\t\t\t\t\tv[(mb+(1<<i)+m)*(N+1)+c] += v[(mb+m)*(N+1)+c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tauto ifft = [&](vector<uint32_t>& v) -> bool {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int mb = 0; mb < (1 << N); mb += (2<<i)) {\n\t\t\t\tfor (int m = 0; m < (1 << i); m++) {\n\t\t\t\t\tfor (int c = 0; c <= N; c++) {\n\t\t\t\t\t\tv[(mb+(1<<i)+m)*(N+1)+c] -= v[(mb+m)*(N+1)+c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool has = false;\n\t\tfor (int m = 0; m < (1<<N); m++) {\n\t\t\thas += (v[m*(N+1) + __builtin_popcount(m)] = bool(v[m*(N+1) + __builtin_popcount(m)]));\n\t\t\tfor (int c = __builtin_popcount(m)+1; c <= N; c++) {\n\t\t\t\tv[m*(N+1)+c] = 0;\n\t\t\t}\n\t\t}\n\t\treturn has;\n\t};\n\tauto mul = [&](const vector<uint32_t>& a, const vector<uint32_t>& b, vector<uint32_t>& v) {\n\t\tfor (int m = 0; m < (1<<N); m++) {\n\t\t\tfor (int c = N; c >= 0; c--) {\n\t\t\t\tuint32_t val = 0;\n\t\t\t\tfor (int c1 = 0; c1 <= c; c1++) {\n\t\t\t\t\tval += a[m*(N+1)+c1] * b[m*(N+1)+c-c1];\n\t\t\t\t}\n\t\t\t\tv[m*(N+1)+c] = val;\n\t\t\t}\n\t\t}\n\t};\n\n\tvector<vector<uint32_t>> p2fft;\n\tp2fft.emplace_back((1<<N) * (N+1));\n\tbool hasTree = false;\n\tfor (int m = 0; m < (1 << N); m++) {\n\t\tif (isTree[m]) {\n\t\t\thasTree = true;\n\t\t\tp2fft[0][m*(N+1) + __builtin_popcount(m)] = 1;\n\t\t}\n\t}\n\n\tif (!hasTree) {\n\t\tcout << N << '\\n';\n\t\texit(0);\n\t}\n\n\tint l = 0;\n\twhile (true) {\n\t\tfft(p2fft[l]);\n\t\tl++;\n\n\t\tif (2 * (1 << l) > N) {\n\t\t\t// no point in adding the next one, we'll just kill it\n\t\t\tbreak;\n\t\t}\n\n\t\tp2fft.emplace_back((1<<N) * (N+1));\n\t\tmul(p2fft[l-1], p2fft[l-1], p2fft[l]);\n\n\t\tif (!ifft(p2fft[l])) {\n\t\t\tp2fft.pop_back();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tassert(l == int(p2fft.size()));\n\n\tint ans = N;\n\tl--;\n\tans -= (1 << l);\n\tvector<uint32_t> curVec = p2fft[l];\n\tvector<uint32_t> nVec((1<<N)*(N+1));\n\twhile (l > 0) {\n\t\tl--;\n\n\t\tmul(curVec, p2fft[l], nVec);\n\n\t\tif (ifft(nVec)) {\n\t\t\tans -= (1 << l);\n\t\t\tswap(curVec, nVec);\n\t\t\tfft(curVec);\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n""]","[0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3100
Vasya used to be an accountant before the war began and he is one of the few who knows how to operate a computer so he was assigned as the programmer We all know that programs often store sets of integers For example if we have a problem about a weighted directed graph its edge can be represented by three integers the number of the starting vertex the number of the final vertex and the edge s weight So as Vasya was trying to represent characteristics of a recently invented robot in his program he faced the following problem Vasya is not a programmer so he asked his friend Gena what the convenient way to store integers is Gena used to code in language X and so he can use only the types that occur in this language Let s define what a type is in language X First a type is a string Second a type is a string that starts with then followed by angle brackets listing comma separated other types of language X This record contains no spaces No other strings can be regarded as types More formally For example Gena uses the following type for graph edges Gena was pleased to help Vasya he dictated to Vasya a type of language X that stores integers Unfortunately Gena was in a hurry so he omitted the punctuation Now Gena has already left and Vasya can t find the correct punctuation resulting in a type of language X however hard he tries Help Vasya and add the punctuation marks so as to receive the valid type of language X Otherwise say that the task is impossible to perform ,"['#include <stdio.h>\n#include <string.h>\nint cnt,tcnt=0;\nchar s[1000010][5];\nint find(int id)\n{\n    if (id>=cnt) return cnt+100;\n    if (strcmp(s[id],""int"")==0)\n    {\n        return id+1;\n    }\n    else\n    {\n        int next=find(id+1);\n        next=find(next);\n        return next;\n    }\n}\nint find2(int id)\n{\n    if (id>=cnt) return cnt+100;\n    if (strcmp(s[id],""int"")==0)\n    {\n        printf(""int"");\n        return id+1;\n    }\n    else\n    {\n        printf(""pair<"");\n        int next=find2(id+1);\n        printf("","");\n        next=find2(next);\n        printf("">"");\n        return next;\n    }\n}\nint main()\n{\n    int n;\n    scanf(""%d"",&n);\n    cnt=0;\n    while (scanf(""%s"",s[cnt])==1) cnt++;\n    if (find(0)==cnt)\n    {\n        find2(0);\n        puts("""");\n    }\n    else\n        puts(""Error occurred"");\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
William has two arrays of numbers a 1 a 2 dots a n and b 1 b 2 dots b m The arrays satisfy the conditions of being convex Formally an array c of length k is considered convex if c i c i 1 c i 1 c i for all i from 2 to k 1 and c 1 c 2 Throughout William s life he observed q changes of two types happening to the arrays Add the arithmetic progression d d cdot 2 d cdot 3 dots d cdot k to the suffix of the array a of length k The array after the change looks like this a 1 a 2 dots a n k a n k 1 d a n k 2 d cdot 2 dots a n d cdot k The same operation but for array b After each change a matrix d is created from arrays a and b of size n times m where d i j a i b j William wants to get from cell 1 1 to cell n m of this matrix From cell x y he can only move to cells x 1 y and x y 1 The length of a path is calculated as the sum of numbers in cells visited by William including the first and the last cells After each change William wants you to help find out the minimal length of the path he could take ,"['/**\n *    author:  tourist\n *    created: 28.11.2021 18:24:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass fenwick {\n public:\n  vector<T> fenw;\n  int n;\n\n  fenwick(int _n) : n(_n) {\n    fenw.resize(n);\n  }\n\n  void modify(int x, T v) {\n    while (x < n) {\n      fenw[x] += v;\n      x |= (x + 1);\n    }\n  }\n\n  T get(int x) {\n    T v{};\n    while (x >= 0) {\n      v += fenw[x];\n      x = (x & (x + 1)) - 1;\n    }\n    return v;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, q;\n  cin >> n >> m >> q;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> b(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n  }\n  auto init_b = b;\n  vector<long long> da(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    da[i] = a[i + 1] - a[i];\n  }\n  vector<long long> db(m - 1);\n  for (int i = 0; i < m - 1; i++) {\n    db[i] = b[i + 1] - b[i];\n  }\n  fenwick<int> fenw(m - 1);\n  fenwick<long long> fenw2(m - 1);\n  long long ans = 0;\n  for (int i = 0; i < m - 1; i++) {\n    ans += db[i] * (m - 1 - i);\n  }\n  while (q--) {\n    int type, k, d;\n    cin >> type >> k >> d;\n    if (type == 1) {\n      if (k == n) {\n        a[0] += d;\n        k -= 1;\n      }\n      for (int i = 0; i < k; i++) {\n        a[n - k + i] += d * (i + 1);\n        da[n - k + i - 1] += d;\n      }\n    } else {\n      if (k == m) {\n        b[0] += d;\n        k -= 1;\n      }\n      fenw.modify(m - k - 1, d);\n      fenw2.modify(m - k - 1, ((long long) -d) * (m - k - 2));\n      ans += ((long long) d) * k * (k + 1LL) / 2;\n    }\n    long long res = ans;\n    res += (a[0] + b[0]) * (n + m - 1);\n    for (int i = 0; i < n - 1; i++) {\n      int low = 0, high = m - 1;\n      while (low < high) {\n        int mid = (low + high) >> 1;\n        if (db[mid] + fenw.get(mid) > da[i]) {\n          high = mid;\n        } else {\n          low = mid + 1;\n        }\n      }\n      int my_id = (n - 2 - i) + (m - 1 - low) + 1;\n      res += da[i] * my_id;\n      res += init_b[low] - init_b[0];\n      res += fenw.get(low - 1) * (long long) (low - 1) + fenw2.get(low - 1);\n    }\n    cout << res << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3000
You are given an array a 1 a 2 dots a n which is sorted in non descending order You decided to perform the following steps to create array b 1 b 2 dots b n Create an array d consisting of n arbitrary integers Set b i a i d i for each b i Sort the array b in non descending order You are given the resulting array b For each index i calculate what is the minimum and maximum possible value of d i you can choose in order to get the given array b Note that the minimum maximum d i s are of each other i e they can be obtained from different possible arrays d ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    for (int i = 0, j = 0; i < n; i++) {\n        while (b[j] < a[i]) {\n            j++;\n        }\n        std::cout << b[j] - a[i] << "" \\n""[i == n - 1];\n    }\n    \n    for (int i = 0, j = 0; i < n; i++) {\n        j = std::max(j, i);\n        while (j + 1 < n && a[j + 1] <= b[j]) {\n            j++;\n        }\n        std::cout << b[j] - a[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1400
You have an array of integers initially empty You have to perform q queries Each query is of one of two types 1 x add the element x to the end of the array 2 x y replace all occurrences of x in the array with y Find the resulting array after performing all the queries ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T_vector>\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end = int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\n\nconst int X_MAX = int(5e5) + 5;\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int Q;\n    cin >> Q;\n    vector<int> type(Q), X(Q), Y(Q);\n\n    for (int q = 0; q < Q; q++) {\n        cin >> type[q] >> X[q];\n\n        if (type[q] == 2)\n            cin >> Y[q];\n    }\n\n    vector<int> A;\n    vector<int> final(X_MAX);\n    iota(final.begin(), final.end(), 0);\n\n    for (int q = Q - 1; q >= 0; q--)\n        if (type[q] == 1)\n            A.push_back(final[X[q]]);\n        else\n            final[X[q]] = final[Y[q]];\n\n    reverse(A.begin(), A.end());\n    output_vector(A);\n}\n']","[0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1900
Hanh lives in a shared apartment There are n people including Hanh living there each has a private fridge n fridges are secured by several steel chains Each steel chain connects two fridges and is protected by a digital lock The owner of a fridge knows passcodes of all chains connected to it A fridge can be open only if all chains connected to it are unlocked For example if a fridge has no chains connected to it at all then any of n people can open it The weights of these fridges are a 1 a 2 ldots a n To make a steel chain connecting fridges u and v you have to pay a u a v dollars Note that the landlord allows you to create Hanh s apartment landlord asks you to create exactly m steel chains so that all fridges are private A fridge is private if and only if among n people living in the apartment only the owner can open it i e no other person acting alone can do it In other words the fridge i is not private if there exists the person j i ne j that the person j can open the fridge i For example in the picture all the fridges are private On the other hand if there are n 2 fridges and only one chain which connects them then both fridges are not private both fridges can be open not only by its owner but also by another person Of course the landlord wants to minimize the total cost of all steel chains to fulfill his request Determine whether there exists any way to make exactly m chains and if yes output any solution that minimizes the total cost ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nlong long T, n, m, a[2000], ans, mini1, mini2;\n\nint main() {\n\tcin >> T;\n\twhile (T--) {\n\t\tcin >> n >> m;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tmini1 = 1;\n\t\tmini2 = 2;\n\t\tif (a[mini1] > a[mini2]) {\n\t\t\tswap(mini1, mini2);\n\t\t}\n\t\tif (n == 2 || m < n) {\n\t\t\tcout << ""-1\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i > 2) {\n\t\t\t\tif (a[i] < a[mini2]) {\n\t\t\t\t\tmini2 = i;\n\t\t\t\t\tif (a[mini2] < a[mini1]) {\n\t\t\t\t\t\tswap(mini1, mini2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += 2*a[i];\n\t\t}\n\t\tfor (int i = n+1; i <= m; i++) {\n\t\t\tans += a[mini1] + a[mini2];\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcout << i << "" "";\n\t\t\tif (i == n) cout << 1;\n\t\t\telse cout << i+1;\n\t\t\tcout << ""\\n"";\n\t\t}\n\t\tfor (int i = n+1; i <= m; i++) {\n\t\t\tcout << mini1 << "" "" << mini2 << ""\\n"";\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Phone number in Berland is a sequence of digits Often to make it easier to memorize the number it is divided into groups of two or three digits For example the phone number is easier to remember as Your task is to find for a given phone number any of its divisions into groups of two or three digits ,"['#include <assert.h>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\n#include <string>\n#include <list>\n#include <stack>\n#include <string.h>\n#include <stdlib.h>\n#include <vector>\n#include <utility>\n#include <list>\n#define INF 0x3fffffff\n#define LINF 0x3fffffffffffffffll\n#define DINF 1e100;\n\ntypedef long long ll;\n#define PII pair<int, int>\n#define PLL pair<ll, ll>\n#define PDD pair<double, double>\n#define PIL pair<int, ll>\n#define PLI pair<ll, int>\n#define PID pair<int, double>\n#define PDI pair<double, int>\n#define PLD pair<ll, double>\n#define PDL pair<double, ll>\n\n#define NUL(x) memset(x, 0, sizeof(x))\n#define MINUS(x) memset(x, 0xff, sizeof(x))\n#define PQ(x) priority_queue< x >  //highest first\n#define PQR(x) priority_queue< x , vector< x > , greater < x > > //lowest first\n#define MP make_pair\n#define PB push_back\n#define IT(x) for (typeof((x).begin()) it = (x).begin() ; it != (x).end() ; it++)\n#define IT2(x) for (typeof((x).begin()) it2 = (x).begin() ; it2 != (x).end() ; it2++)\n#define FOR(i, a, b) for (int i = (a) ; i< (b) ; i++)\n#define DEB(x...) fprintf(stderr,x);\n//#define DEB\n\nusing namespace std;\n\nbool testc(int tc=0)\n{\n\n}\n\nchar buf[150];\nint main()\n{\n  int n;\n  scanf(""%i "", &n);\n  gets(buf);\n  int i=0;\n  if (n%2)\n    {\n      printf(""%c"", buf[0]);\n      i++;\n    }\n  while(i<n)\n    {\n      printf(""%c%c"", buf[i], buf[i+1]);\n      i+=2;\n      if (i<n) printf(""-"");\n    }\n  printf(""\\n"");\n  return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Vasya has several phone books in which he recorded the telephone numbers of his friends Each of his friends can have one or several phone numbers Vasya decided to organize information about the phone numbers of friends You will be given strings all entries from Vasya s phone books Each entry starts with a friend s name Then follows the number of phone numbers in the current entry and then the phone numbers themselves It is possible that several identical phones are recorded in the same record Vasya also believes that if the phone number is a suffix of the phone number that is the number ends up with and both numbers are written by Vasya as the phone numbers of the same person then is recorded without the city code and it should not be taken into account The task is to print organized information about the phone numbers of Vasya s friends It is possible that two different people have the same number If one person has two numbers and and is a suffix of that is ends in then you shouldn t print number If the number of a friend in the Vasya s phone books is recorded several times in the same format it is necessary to take it into account exactly once Read the examples to understand statement and format of the output better ,"['#include <bits/stdc++.h>\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define ll long long\n\nusing namespace std;\n\nconst int N = (3e5), mod = (1e9) + 7;\n\nstring  s[N], r[N];\nint n, m;\nint t;\n\nstring name;\n\nmap <string, vector <string> > ma;\n\nbool cmp(string a, string b){\n\treturn (a.size() < b.size());\n}\n\nbool check(string a,string b){\n\tfor(int i = int(a.size()) - 1, j = int(b.size()) - 1;i >= 0; i--,j--){\n\t\tif(a[i] != b[j]) return 0;\n\t}\n\treturn 1;\n}\n\nint main(){\n\tcin >> t;\n\tfor(int j = 1; j <= t; j++){\n\t\tcin >> name >> n;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s[i];\n\t\t\tma[name].pb(s[i]);\n\t\t}\n\t}\n\tcout << int(ma.size()) << endl;\n\tfor(auto p : ma){\n\t\tcout << p.f << "" "";\n\t\tn = 0;\n\t\tfor(int i = 0; i < ma[p.f].size(); i++){\n\t\t\ts[n++] = ma[p.f][i];\n\t\t}\n\t\tsort(s, s + n, cmp);\n\t\tm = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tbool ok = 1;\n\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\tif(check(s[i],s[j])){\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) r[m++] = s[i];\n\t\t}\n\t\tcout << m;\n\t\tfor(int i = 0; i < m; i++){\n\t\t    cout << "" "" << r[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n \treturn 0;\n}             ']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1400
Iva gave Pav an array a of n elements Let s define f l r a l a l 1 dots a r here denotes the bitwise AND operation f l r l r Iva also gave Pav q queries Each query consists of 2 numbers k and l and she wants Pav to find the largest index r l le r le n such that f l r ge k Pav wants to solve this problem fast because he doesn t want to upset Iva He needs your help ,"['#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint a[200001], pre[200001][32];\ninline bool check(int l, int r, int k) {\n\tint ans = 0;\n\tfor (int i = 0; i ^ 32; ++i) {\n\t\tif (pre[r][i] - pre[l - 1][i] == r - l + 1)\n\t\t\tans |= 1 << i;\n\t}\n\treturn ans >= k;\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tint n, q;\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tcin >> a[i];\n\t\tcin >> q;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfor (int j = 0; j ^ 32; ++j)\n\t\t\t\tpre[i][j] = pre[i - 1][j] + (a[i] >> j & 1);\n\t\t}\n\t\tfor (; q--;) {\n\t\t\tint L, k;\n\t\t\tcin >> L >> k;\n\t\t\tif (a[L] < k) {\n\t\t\t\tcout << ""-1 "";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint l = L, r = n, mid;\n\t\t\tfor (; l < r;) {\n\t\t\t\tmid = l + r + 1 >> 1;\n\t\t\t\tif (check(L, mid, k))\n\t\t\t\t\tl = mid;\n\t\t\t\telse\n\t\t\t\t\tr = mid - 1;\n\t\t\t}\n\t\t\tcout << r << \' \';\n\t\t}\n\t\tcout << \'\\n\';\n\t}\n}']","[1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1400
There are n containers of water lined up numbered from left to right from 1 to n Each container can hold any amount of water initially the i th container contains a i units of water The sum of a i is divisible by n You can apply the following operation any possibly zero number of times pour any amount of water from the i th container to the j th container where i must be than j i e i j Any index can be chosen as i or j any number of times Determine whether it is possible to make the amount of water in all containers the same using this operation ,"['// Problem: B. Make Equal\n// Contest: Codeforces - Codeforces Round 925 (Div. 3)\n// URL: https://codeforces.com/contest/1931/problem/B\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <bits/stdc++.h>\n#define all(s) s.begin(), s.end()\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\nconst int _N = 1e5 + 5;\n\nint T;\n\nvoid solve() {\n\tint n; cin >> n;\n\tll sum = 0;\n\tvector<int> a(n + 1);\n\tfor (int i = 1; i <= n; i++) cin >> a[i], sum += a[i];\n\tll cur = 0;\n\tsum /= n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (a[i] + cur < sum) {\n\t\t\tcout << ""NO"" << \'\\n\';\n\t\t\treturn;\n\t\t}\n\t\tcur = a[i] + cur - sum;\n\t}\n\tcout << ""YES"" << \'\\n\';\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tsolve();\n\t}\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Haha try to solve this SelectorUnlimited antontrygubO oYour friends Alice and Bob practice fortune telling Fortune telling is performed as follows There is a well known array a of n non negative integers indexed from 1 to n The tellee starts with some non negative number d and performs one of the two operations for each i 1 2 ldots n The possible operations are replace their current number d with d a i replace their current number d with d oplus a i hereinafter oplus denotes the bitwise XOR operation Notice that the chosen operation may be different for different i and for different tellees One time Alice decided to start with d x and Bob started with d x 3 Each of them performed fortune telling and got a particular number in the end Notice that the friends chose operations independently of each other that is they could apply different operations for the same i You learnt that either Alice or Bob ended up with number y in the end but you don t know whose of the two it was Given the numbers Alice and Bob started with and y find out who Alice or Bob could get the number y after performing the operations It is guaranteed that on the jury tests of your friends could have actually gotten that number You cannot make hacks in this problem ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define reg register\nconst int maxn=10005;\nchar buffer[maxn],*S,*T;\ninline char Get_Char(){\n    if(S==T){\n        T=(S=buffer)+fread(buffer,1,maxn,stdin);\n        if(S==T)return EOF;\n    }\n    return *S++;\n}\n\ninline int read(){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)return -re;\n    return re;\n}\n\ninline void read(int&x){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\ninline void read(ll&x){\n    reg char c;\n    reg ll re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\nconst int mxn=1e5+5;\nll a[mxn];\nll x,y,n,p[33],q[33],lp[33],lq[33];\ninline void solve(){\n\tmemset(p,0,sizeof(p));\n\tmemset(q,0,sizeof(q));\n\tcin>>n>>x>>y;\n\tx%=32,y%=32;\n\tll c=x,d=x+3;\n\td%=32;\n\tp[c]=1,q[d]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[x];\n\t\tmemset(lp,0,sizeof(lp));\n\t\tmemset(lq,0,sizeof(lq));\n\t\tfor(int j=0;j<32;++j){\n\t\t\tif(p[j]==1){\n\t\t\t\tlp[(j+a[x])%32]=1;\n\t\t\t\tlp[(j^a[x])%32]=1;\n\t\t\t}\n\t\t\tif(q[j]==1){\n\t\t\t\tlq[(j+a[x])%32]=1;\n\t\t\t\tlq[(j^a[x])%32]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<32;++j)p[j]=lp[j],q[j]=lq[j];\n\t}\n\tif(p[y]==1)cout<<""Alice\\n"";\n\telse cout<<""Bob\\n"";\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0),cout.tie(0);\n\tint T=1;\n\tcin>>T;\n\tfor(;T--;)solve();\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1400
Edo has got a collection of refrigerator magnets He decided to buy a refrigerator and hang the magnets on the door The shop can make the refrigerator with any size of the door that meets the following restrictions the refrigerator door must be rectangle and both the length and the width of the door must be Edo figured out how he wants to place the magnets on the refrigerator He introduced a system of coordinates on the plane where each magnet is represented as a rectangle with sides parallel to the coordinate axes Now he wants to remove no more than magnets he may choose to keep all of them and attach all remaining magnets to the refrigerator door and the area of the door should be as small as possible A magnet is considered to be attached to the refrigerator door if lies on the door or on its boundary The relative positions of all the remaining magnets must correspond to the plan Let us explain the last two sentences Let s suppose we want to hang two magnets on the refrigerator If the magnet in the plan has coordinates of the lower left corner and the upper right corner then its center is located at may not be integers By saying the relative position should correspond to the plan we mean that the only available operation is translation i e the vector connecting the centers of two magnets in the original plan must be equal to the vector connecting the centers of these two magnets on the refrigerator ,"[""#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst db pi=acos(-1);\nvoid gn(int &x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n\tif(c=='-')sg=-1,x=0;else x=c-'0';\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n\tx*=sg;\n}\nvoid gn(ll &x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');\n\tif(c=='-')sg=-1,x=0;else x=c-'0';\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';\n\tx*=sg;\n}\nconst int mo=1000000007;\nconst int inf=1061109567;\nint qp(int a,ll b){int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nint n,k;\n\nstruct node{\n\tll x,y;int id;\n}p[111111],q[111111];\nint cmpx(const node &a,const node&b){\n\treturn a.x<b.x;\n}\nint cmpy(const node &a,const node&b){\n\treturn a.y<b.y;\n}\nint ind=0;\nint off[111111];\nint cnt=0;\nvoid mark(int i){\n\tif(off[i]!=ind){\n\t\toff[i]=ind;\n\t\tcnt++;\n\t}\n}\n\nint main(){\n\tgn(n);gn(k);\n\tfor (int i=1;i<=n;i++){\n\t\tint a,b,c,d;\n\t\tgn(a);\n\t\tgn(b);\n\t\tgn(c);\n\t\tgn(d);\n\t\tp[i].x=a+c;\n\t\tp[i].y=b+d;\n\t\tp[i].id=i;\n\t}\n\tfor (int i=1;i<=n;i++)q[i]=p[i];\n\tsort(p+1,p+1+n,cmpx);\n\tsort(q+1,q+1+n,cmpy);\n\t\n\tll mi=ll(6e18);\n\tfor (int l=0;l<=k;l++)\n\t\tfor (int r=0;r<=k;r++)\n\t\t\tfor (int u=0;u<=k;u++)\n\t\t\t\tfor (int d=0;d<=k;d++){\n\t\t\t\t\t++ind;cnt=0;\n\t\t\t\t\tfor (int i=1;i<=l;i++)mark(p[i].id);\n\t\t\t\t\tfor (int i=n;i>=n-r+1;i--)mark(p[i].id);\n\t\t\t\t\tfor (int i=1;i<=d;i++)mark(q[i].id);\n\t\t\t\t\tfor (int i=n;i>=n-u+1;i--)mark(q[i].id);\n\t\t\t\t\tif(cnt>k)continue;\n\n\t\t\t\t\tll w=max(2ll,p[n-r].x-p[l+1].x);\n\t\t\t\t\tll h=max(2ll,q[n-u].y-q[d+1].y);\n\t\t\t\t\tif(w&1)w++;\n\t\t\t\t\tif(h&1)h++;\n\t\t\t\t\tmi=min(mi,(w/2)*(h/2));\n\t\t\t\t}\n\tcout<<mi<<endl;\n\treturn 0;\n}\n""]","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",2300
Lunchbox has a tree of size n rooted at node 1 Each node is then assigned a value Lunchbox considers the tree to be beautiful if each value is distinct and ranges from 1 to n In addition a beautiful tree must also satisfy m requirements of 2 types The node with the smallest value on the path between nodes a and b must be located at c The node with the largest value on the path between nodes a and b must be located at c Now you must assign values to each node such that the resulting tree is beautiful If it is impossible to do so output 1 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e6 + 5;\nconst int M = 3e7 + 5;\nint n, m, op[N], A[N], B[N], C[N];\nvector<int> tr[N];\n\nint dep[N], fa[N], sz[N], son[N];\n\nvoid dfs1(int u, int pre) {\n\tdep[u] = dep[pre] + 1, fa[u] = pre, sz[u] = 1;\n\tfor (int v : tr[u]) {\n\t\tif (v == pre) continue;\n\t\tdfs1(v, u);\n\t\tsz[u] += sz[v];\n\t\tif (sz[v] > sz[son[u]]) son[u] = v;\n\t}\n}\n\nint st[N], ed[N], id[N], top[N], cnt;\n\nvoid dfs2(int u, int tp) {\n\tst[u] = ++cnt, id[cnt] = u, top[u] = tp;\n\tif (son[u]) dfs2(son[u], tp);\n\tfor (int v : tr[u])\n\t\tif (v != fa[u] && v != son[u])\n\t\t\tdfs2(v, v);\n\ted[u] = cnt;\n}\n\nstruct Edge {\n\tint to, next;\n} e[M];\n\nint head[N], deg[N], cnte;\n\ninline void addedge(int u, int v) {\n\te[++cnte] = Edge{v, head[u]}, head[u] = cnte;\n\t++deg[v];\n}\n\nint prf_in[N], prf_out[N], tot;\n\n#define ls(x) (x << 1)\n#define rs(x) (x << 1 | 1)\n\nint ver_in[N], ver_out[N];\n\nvoid build(int x = 1, int l = 1, int r = n) {\n\tif (l == r) {\n\t\tver_in[x] = ver_out[x] = id[l];\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(x), l, mid);\n\tbuild(rs(x), mid + 1, r);\n\tver_in[x] = ++tot, ver_out[x] = ++tot;\n\taddedge(ver_in[x], ver_in[ls(x)]);\n\taddedge(ver_in[x], ver_in[rs(x)]);\n\taddedge(ver_out[ls(x)], ver_out[x]);\n\taddedge(ver_out[rs(x)], ver_out[x]);\n}\n\nvoid addin(int L, int R, int s, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\taddedge(s, ver_in[x]);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (L <= mid) addin(L, R, s, ls(x), l, mid);\n\tif (R > mid) addin(L, R, s, rs(x), mid + 1, r);\n}\n\nvoid addout(int L, int R, int t, int x = 1, int l = 1, int r = n) {\n\tif (L <= l && r <= R) {\n\t\taddedge(ver_out[x], t);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (L <= mid) addout(L, R, t, ls(x), l, mid);\n\tif (R > mid) addout(L, R, t, rs(x), mid + 1, r);\n}\n\nint q[N], ans[N];\n\ninline void toposort() {\n\tint l = 1, r = 0, res = 0;\n\tfor (int i = 1; i <= tot; ++i)\n\t\tif (!deg[i]) q[++r] = i;\n\twhile (l <= r) {\n\t\tint u = q[l++];\n\t\tif (u <= n) ans[u] = ++res;\n\t\tfor (int i = head[u]; i; i = e[i].next) {\n\t\t\tint v = e[i].to;\n\t\t\t--deg[v];\n\t\t\tif (!deg[v]) q[++r] = v;\n\t\t}\n\t}\n\tif (r < tot) {\n\t\tcout << ""-1\\n"";\n\t} else {\n\t\tfor (int i = 1; i <= n; ++i) cout << ans[i] << \' \';\n\t\tcout << \'\\n\';\n\t}\n}\n\ninline void treeaddanc(int x, int y, int op, int v) {\n\twhile (top[x] != top[y]) {\n\t\tif (op == 1) addedge(v, prf_in[x]);\n\t\telse addedge(prf_out[x], v);\n\t\tx = fa[top[x]];\n\t}\n\tif (y == x) return;\n\tif (op == 1) addin(st[y] + 1, st[x], v);\n\telse addout(st[y] + 1, st[x], v);\n}\n\ninline void treeadd(int x, int y, int op, int v) {\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] >= dep[top[y]]) {\n\t\t\tif (op == 1) addedge(v, prf_in[x]);\n\t\t\telse addedge(prf_out[x], v);\n\t\t\tx = fa[top[x]];\n\t\t} else {\n\t\t\tif (op == 1) addedge(v, prf_in[y]);\n\t\t\telse addedge(prf_out[y], v);\n\t\t\ty = fa[top[y]];\n\t\t}\n\t}\n\tif (dep[x] < dep[y]) {\n\t\tif (op == 1) addin(st[x], st[y], v);\n\t\telse addout(st[x], st[y], v);\n\t} else {\n\t\tif (op == 1) addin(st[y], st[x], v);\n\t\telse addout(st[y], st[x], v);\n\t}\n} \n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\ttr[u].push_back(v);\n\t\ttr[v].push_back(u);\n\t}\n\tfor (int i = 1; i <= m; ++i) cin >> op[i] >> A[i] >> B[i] >> C[i];\n\tdfs1(1, 0);\n\tdfs2(1, 1);\n\ttot = n;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tprf_in[i] = ++tot;\n\t\tprf_out[i] = ++tot;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\taddedge(prf_in[i], i);\n\t\taddedge(i, prf_out[i]);\n\t\tif (i != top[i]) {\n\t\t\taddedge(prf_in[i], prf_in[fa[i]]);\n\t\t\taddedge(prf_out[fa[i]], prf_out[i]);\n\t\t}\n\t}\n\tbuild();\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (A[i] == B[i]) continue;\n\t\tif (A[i] != C[i]) {\n\t\t\tif (st[A[i]] >= st[C[i]] && ed[A[i]] <= ed[C[i]]) treeaddanc(A[i], C[i], op[i], C[i]);\n\t\t\telse treeadd(fa[C[i]], A[i], op[i], C[i]);\n\t\t}\n\t\tif (B[i] != C[i]) {\n\t\t\tif (st[B[i]] >= st[C[i]] && ed[B[i]] <= ed[C[i]]) treeaddanc(B[i], C[i], op[i], C[i]);\n\t\t\telse treeadd(fa[C[i]], B[i], op[i], C[i]);\n\t\t}\n\t}\n\ttoposort();\n\treturn 0;\n}\n']","[0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2800
Ethan runs a vaccination station to help people combat the seasonal flu He analyses the historical data in order to develop an optimal strategy for vaccine usage Consider there are n patients coming to the station on a particular day The i th patient comes at the moment t i We know that each of these patients can be asked to wait for no more than w time moments That means the i th patient can get vaccine at moments t i t i 1 ldots t i w Vaccines come in packs each pack consists of k doses Each patient needs exactly one dose Packs are stored in a special fridge After a pack is taken out of the fridge and opened it can no longer be put back The lifetime of the vaccine outside the fridge is d moments of time Thus if the pack was taken out of the fridge and opened at moment x its doses can be used to vaccinate patients at moments x x 1 ldots x d At moment x d 1 all the remaining unused doses of this pack are thrown away Assume that the vaccination station has enough staff to conduct an arbitrary number of operations at every moment of time What is the minimum number of vaccine packs required to vaccinate all n patients ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k, d, w;\n    std::cin >> n >> k >> d >> w;\n    \n    std::vector<int> t(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> t[i];\n    }\n    \n    int ans = 0;\n    for (int i = 0; i < n; ) {\n        ans += 1;\n        int j = i;\n        while (j < n && t[j] - t[i] <= d + w && j - i < k) {\n            j++;\n        }\n        i = j;\n    }\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Anya loves to fold and stick Today she decided to do just that Anya has cubes lying in a line and numbered from to from left to right with natural numbers written on them She also has stickers with exclamation marks We know that the number of stickers does not exceed the number of cubes Anya can stick an exclamation mark on the cube and get the factorial of the number written on the cube For example if a cube reads then after the sticking it reads which equals You need to help Anya count how many ways there are to choose some of the cubes and stick on some of the chosen cubes at most exclamation marks so that the sum of the numbers written on the chosen cubes after the sticking becomes equal to Anya can stick at most one exclamation mark on each cube Can you do it Two ways are considered the same if they have the same set of chosen cubes and the same set of cubes with exclamation marks ,"['#include <bits/stdc++.h>\n\n#define\tst first\n#define\tnd second\n#define\tmp make_pair\n#define\tpb push_back\n#define\tlli long long int\n#define\tall( gg )\tgg.begin(),gg.end()\n#define\tforeach( gg,itit )\tfor( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )\n#define\tFP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )\n#define\tFM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )\n#define\tdebug(ccc)\tcout << #ccc << "" = "" << ccc << endl;\n\n#define\tmod\t1000000007LL\n\nusing namespace std;\n\nlli\tfact[30]={1},S;\nint\tn,n1,n2,arr[30];\nint\tk;\n\nmap<lli,int>\tA[30],B[30];\n\nvoid\trec1( int ind,int t,lli s ){\n\tif( s>S or t>k )\treturn;\n\tif( ind==n1+1 ){\n\t\tA[t][s]++;\n\t\treturn;\n\t}\n\trec1( ind+1,t,s );\n\trec1( ind+1,t,s+arr[ind] );\n\tif( arr[ind]<=18 )\trec1( ind+1,t+1,s+fact[arr[ind]] );\n}\nvoid\trec2( int ind,int t,lli s ){\n\tif( s>S or t>k )\treturn;\n\tif( ind==n2+1 ){\n\t\tFP( i,t,k )\n\t\t\tB[i][s]++;\n\t\treturn;\n\t}\n\trec2( ind+1,t,s );\n\trec2( ind+1,t,s+arr[ind] );\n\tif( arr[ind]<=18 )\trec2( ind+1,t+1,s+fact[arr[ind]] );\n}\n\nint main(){\n\tFP( i,1,19 )\tfact[i] = fact[i-1]*i;\n\tcin >> n >> k >> S;\n\tFP( i,1,n )\n\t\tcin >> arr[i];\n\tsort( arr+1,arr+n+1 );\n\tn1 = (n+1)/2;\n\tn2 = n-n1;\n\trec1( 1,0,0 );\n\tFP( i,1,n2 )\n\t\tarr[i] = arr[i+n1];\n\trec2( 1,0,0 );\n\tlli\tres=0;\n\tFP( i,0,k )\n\t\tforeach( A[i],it )\n\t\t\tif( B[k-i].find( S-(it->st) )!=B[k-i].end() )\n\t\t\t\tres += (lli)(it->nd)*B[k-i][S-(it->st)];\n\tcout << res << endl;\n}\n']","[0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2100
We picked an array of whole numbers a 1 a 2 ldots a n 0 le a i le 10 9 and concealed zero in it Your goal is to find the location of this zero that is to find i such that a i 0 You are allowed to make several queries to guess the answer For each query you can think up three distinct indices i j k and we will tell you the value of max a i a j a k min a i a j a k In other words we will tell you the difference between the maximum and the minimum number among a i a j and a k You are allowed to make no more than 2 cdot n 2 queries and after that you have two tries to guess where the zero is That is you have to tell us two numbers i and j and you win if a i 0 or a j 0 Can you guess where we hid the zero Note that the array in each test case is fixed beforehand and will not change during the game In other words the interactor is not adaptive ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define reg register\nconst int maxn=10005;\nchar buffer[maxn],*S,*T;\ninline char Get_Char(){\n    if(S==T){\n        T=(S=buffer)+fread(buffer,1,maxn,stdin);\n        if(S==T)return EOF;\n    }\n    return *S++;\n}\n\ninline int read(){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)return -re;\n    return re;\n}\n\ninline void read(int&x){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\ninline void read(ll&x){\n    reg char c;\n    reg ll re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\nconst int mxn=1e3+3;\nint n;\nint a[mxn],b[mxn];\ninline int ask(int x,int y,int z){\n\tcout<<""? ""<<x<<\' \'<<y<<\' \'<<z<<endl;\n\tfflush(stdout);\n\tint rt;cin>>rt;\n\treturn rt;\n}\ninline void print(int x,int y){\n\tcout<<""! ""<<x<<\' \'<<y<<endl;\n\tfflush(stdout);\n\treturn;\n}\ninline void solve(){\n\tcin>>n;\n\tmemset(a,0,sizeof(a));\n\tmemset(b,0,sizeof(b));\n\tint pos1=1;\n\tint allsame=1;\n\tint lst=-1;\n\tfor(int i=3;i<=n;++i){\n\t\ta[i]=ask(1,2,i);\n\t\tif(a[i]>a[pos1])pos1=i;\n\t\tif(lst==-1)lst=a[i];\n\t\telse{\n\t\t\tif(a[i]!=lst){\n\t\t\t\tlst=a[i];\n\t\t\t\tallsame=0;\n\t\t\t}\n\t\t}\n\t}\n\tint allsame2=1,lst2=-1;\n\tint pos2=1;\n\tfor(int i=2;i<=n;++i){\n\t\tif(i==pos1)continue;\n\t\tb[i]=ask(1,i,pos1);\n\t\tif(b[i]>=b[pos2])pos2=i;\n\t\tif(lst2==-1)lst2=b[i];\n\t\telse if(lst2!=b[i])allsame2=0;\n\t}\n\tif(pos2==2)++pos2;\n\tif(pos2==pos1)++pos2;\n\n\tif(allsame==1){//this can all be x[1]-x[2]\n\t\tint t=ask(1,pos1,pos2);\n\t\tif(t<lst){\n\t\t\tprint(1,2);\n\t\t\treturn;\n\t\t}\n\t}\n//\tcerr<<""! wtf ""<<pos1<<\' \'<<pos2<<\'\\n\';\n\t//now if both x[1] and x[2] isn\'t 0 this is okay\n\t//if x[2] is 0? what will happen?\n\t//a[i] will be x[i]. How to ensure it?\n\t//we can ask(2,pos1,pos2) to check\n\t//if x[1] is 0: it is smaller than either a[pos1] or a[pos2] we can return [1,1]\n\t//if x[2] is 0: this returns a[pos1 or pos2] then we can return [2,pos1 or pos2]\n\t//otherwise we can return [pos1,pos2]\n\t//oops,there still can be x[1] is max and pos1 is zero\n\tif(allsame2==1){\n\t\tprint(1,pos1);\n\t\treturn;\n\t}\n\tint t=ask(2,pos1,pos2);\n\tif((t<a[pos1] and t<=a[pos2]) or (t<=a[pos1] and t<a[pos2])){\n\t\tprint(1,2);\n\t\treturn;\n\t}\n\tif(t==a[pos1]){\n\t\tprint(2,pos1);\n\t\treturn;\n\t}\n\tif(t==a[pos2]){\n\t\tprint(2,pos2);\n\t\treturn;\n\t}\n\n\tprint(pos1,pos2);\n\treturn;\n}\nint main(){\n\tint T=1;\n\tcin>>T;\n\tfor(;T--;)solve();\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Recently a new building with a new layout was constructed in Monocarp s hometown According to this new layout the building consists of three types of apartments three room five room and seven room apartments It s also known that each room of each apartment has exactly one window In other words a three room apartment has three windows a five room five windows and a seven room seven windows Monocarp went around the building and counted n windows Now he is wondering how many apartments of each type the building may have Unfortunately Monocarp only recently has learned to count so he is asking you to help him to calculate the possible quantities of three room five room and seven room apartments in the building that has n windows If there are multiple answers you can print any of them Here are some examples if Monocarp has counted 30 windows there could have been 2 three room apartments 2 five room apartments and 2 seven room apartments since 2 cdot 3 2 cdot 5 2 cdot 7 30 if Monocarp has counted 67 windows there could have been 7 three room apartments 5 five room apartments and 3 seven room apartments since 7 cdot 3 5 cdot 5 3 cdot 7 67 if Monocarp has counted 4 windows he should have mistaken since no building with the aforementioned layout can have 4 windows ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tscanf(""%d"",&n);\n\tFor(i,0,n/5) For(j,0,(n-5*i)/7)\n\t\tif ((n-5*i-7*j)%3==0){\n\t\t\tcout<<(n-5*i-7*j)/3<<\' \'<<i<<\' \'<<j<<endl;\n\t\t\treturn; \n\t\t}\n\tcout<<-1<<endl;\n}\nint main(){\n\tint T;\n\tscanf(""%d"",&T);\n\twhile (T--) solve();\n}']","[0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
You are given two integers n and m Find the operatorname MEX of the sequence n oplus 0 n oplus 1 ldots n oplus m Here oplus is the bitwise XOR operator operatorname MEX of the sequence of non negative integers is the smallest non negative integer that doesn t appear in this sequence For example operatorname MEX 0 1 2 4 3 and operatorname MEX 1 2021 0 ,"['#include<cstdio>\n\nusing namespace std;\n\nint main()\n{\n\tint T=0;scanf(""%d"",&T);\n\twhile(T--)\n\t{\n\t\tint n=0,m=0;scanf(""%d%d"",&n,&m);m++;\n\t\tint ans=0;\n\t\tfor(int i=30;i>=0;i--)\n\t\t{\n\t\t\tif((m&(1<<i))&&!(n&(1<<i)))ans|=1<<i;\n\t\t\telse if((n&(1<<i))&&!(m&(1<<i)))break;\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1800
You re given an integer n For every integer i from 2 to n assign a positive integer a i such that the following conditions hold For any pair of integers i j if i and j are coprime a i neq a j The maximal value of all a i should be minimized that is as small as possible A pair of integers is called coprime if their greatest common divisor is 1 ,"[' #include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> mypair;\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = getchar();\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == \'-\') f = -1;\n\t\tc = getchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tx = x * 10 + c - \'0\';\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\n\nint n, a[100005], prime[100005], pcnt = 0, mark[100005], sm[100005];\n\nvoid init(int n)\n{\n\tfor (int i = 2; i <= n; i ++)\n\t{\n\t\tif (!mark[i]) prime[++ pcnt] = i;\n\t\tfor (int j = 1; j <= pcnt; j ++)\n\t\t{\n\t\t\tint np = prime[j], now = np * i;\n\t\t\tif (now > n) break;\n\t\t\tmark[now] = 1;\n\t\t\tsm[now] = np;\n\t\t\tif (i % np == 0) break;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tn = read();\n\tinit(n);\n\tint ind = 0;\n\tfor (int i = 2; i <= n; i ++)\n\t{\n\t\tif (!mark[i]) a[i] = ++ ind;\n\t\telse a[i] = a[sm[i]];\n\t}\n\tfor (int i = 2; i <= n; i ++)\n\t\tprintf(""%d%c"", a[i], i == n ? 10 : 32);\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1300
You are given an integer n and an array a 1 a 2 dots a n of integers in the range 1 n A permutation p 1 p 2 dots p n of 1 2 dots n is good if for each i the following condition is true if a i neq 1 the number of values leq i in p 1 p 2 dots p i is exactly a i Count the good permutations of 1 2 dots n modulo 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\n//mint107 は verify してねえ\n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(ll x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(ll x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(ll x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(ll x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#define USE_GOOD_MOD\n\n//size of input must be a power of 2\n//output of forward fmt is bit-reversed\n//output elements are in the range [0,mod*4)\n//input of inverse fmt should be bit-reversed\ntemplate<class mint>\nvoid inplace_fmt(const int n,mint*const f,bool inv){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic constexpr int L=30;\n\tstatic mint g[L],ig[L],p2[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tmint w=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\tg[i]=w;\n\t\t\tig[i]=w.inv();\n\t\t\tp2[i]=mint(1<<i).inv();\n\t\t}\n\t}\n\tif(!inv){\n\t\tint b=n;\n\t\tif(b>>=1){//input:[0,mod)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*2)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\twhile(b){\n\t\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\t\tmint p=1;\n\t\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\t\trng(j,i,i+b){\n\t\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\t\tf[j].v+=x;\n\t\t\t\t\t}\n\t\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}else{\n\t\tint b=1;\n\t\tif(b<n/2){//input:[0,mod)\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t\tb<<=1;\n\t\t}\n\t\tfor(;b<n/2;b<<=1){\n\t\t\tmint p=1;\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b/2){//input:[0,mod*2)\n\t\t\t\t\tull x=f[j].v+mod2-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j].v=(f[j].v)<mod2?f[j].v:f[j].v-mod2;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\trng(j,i+b/2,i+b){//input:[0,mod)\n\t\t\t\t\tull x=f[j].v+mod-f[j+b].v;\n\t\t\t\t\tf[j].v+=f[j+b].v;\n\t\t\t\t\tf[j+b].v=x*p.v%mod;\n\t\t\t\t}\n\t\t\t\tp*=ig[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b<n){//input:[0,mod*2)\n\t\t\trep(i,b){\n\t\t\t\tuint x=f[i+b].v;\n\t\t\t\tf[i+b].v=f[i].v+mod2-x;\n\t\t\t\tf[i].v+=x;\n\t\t\t}\n\t\t}\n\t\tmint z=p2[__lg(n)];\n\t\trep(i,n)f[i]*=z;\n\t}\n}\n\ntemplate<class mint>\nvoid inplace_fmt(vector<mint>&f,bool inv){\n\tinplace_fmt(si(f),f.data(),inv);\n}\n\n//size of input must be a power of 2\n//output elements are in the range [0,mod*4)\ntemplate<class mint>\nvoid half_fmt(const int n,mint*const f){\n\tstatic constexpr uint mod=mint::mod;\n\tstatic constexpr uint mod2=mod*2;\n\tstatic const int L=30;\n\tstatic mint g[L],h[L];\n\tif(g[0].v==0){\n\t\trep(i,L){\n\t\t\tg[i]=-mint::root().pow(((mod-1)>>(i+2))*3);\n\t\t\th[i]=mint::root().pow((mod-1)>>(i+2));\n\t\t}\n\t}\n\tint b=n;\n\tint lv=0;\n\tif(b>>=1){//input:[0,mod)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\tif(b>>=1){//input:[0,mod*2)\n\t\tmint p=h[lv++];\n\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\trng(j,i,i+b){\n\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\tf[j].v+=x;\n\t\t\t}\n\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t}\n\t}\n\twhile(b){\n\t\tif(b>>=1){//input:[0,mod*3)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t\tif(b>>=1){//input:[0,mod*4)\n\t\t\tmint p=h[lv++];\n\t\t\tfor(int i=0,k=0;i<n;i+=b*2){\n\t\t\t\trng(j,i,i+b){\n\t\t\t\t\tuint x=(f[j+b]*p).v;\n\t\t\t\t\tf[j].v=(f[j].v<mod2?f[j].v:f[j].v-mod2);\n\t\t\t\t\tf[j+b].v=f[j].v+mod-x;\n\t\t\t\t\tf[j].v+=x;\n\t\t\t\t}\n\t\t\t\tp*=g[__builtin_ctz(++k)];\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<class mint>\nvoid half_fmt(vector<mint>&f){\n\thalf_fmt(si(f),f.data());\n}\n\n#ifdef USE_GOOD_MOD\n\ntemplate<class mint>\nvc<mint> multiply(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint n=si(x)+si(y)-1;\n\tint s=1;\n\twhile(s<n)s*=2;\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tstatic vc<mint> z;\n\t\tz.clear();z.resize(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);x.resize(n);\n\treturn x;\n}\ntemplate<class mint>\nvc<mint> multiply_givenlength(vc<mint> x,const vc<mint>&y,bool same=false){\n\tint s=si(x);\n\tassert(ispow2(s));\n\tassert(si(y));\n\tx.resize(s);inplace_fmt(x,false);\n\tif(!same){\n\t\tstatic vc<mint> z;\n\t\tz.clear();z.resize(s);\n\t\trep(i,si(y))z[i]=y[i];\n\t\tinplace_fmt(z,false);\n\t\trep(i,s)x[i]*=z[i];\n\t}else{\n\t\trep(i,s)x[i]*=x[i];\n\t}\n\tinplace_fmt(x,true);\n\treturn x;\n}\n\n#else\n\n//59501818244292734739283969-1=5.95*10^25 までの値を正しく計算\n//最終的な列の大きさが 2^24 までなら動く\n//最終的な列の大きさが 2^20 以下のときは，下の 3 つの素数を使ったほうが速い（は？）\n//VERIFY: yosupo\n//Yukicoder No980 (same=true)\nnamespace arbitrary_convolution{\n\tconstexpr modinfo base0{167772161,3};//2^25 * 5 + 1\n\tconstexpr modinfo base1{469762049,3};//2^26 * 7 + 1\n\tconstexpr modinfo base2{754974721,11};//2^24 * 45 + 1\n\t//extern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\t//extern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\t//extern constexpr modinfo base2{1053818881,7};//2^20 * 1005 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\tusing mint2=modular<base2>;\n\ttemplate<class t,class mint>\n\tvc<t> sub(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tauto d2=sub<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tvc<mint> res(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tres[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn res;\n\t}\n\ttemplate<class t,class mint>\n\tvc<t>&sub_givenlength(const vc<mint>&x,const vc<mint>&y,bool same=false){\n\t\tint s=si(x);\n\t\tassert(ispow2(s));\n\t\tassert(si(y)==s);\n\t\tstatic vc<t> z;\n\t\tz.clear();z.resize(s);\n\t\trep(i,si(x))z[i]=x[i].v;\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tstatic vc<t> w;\n\t\t\tw.clear();w.resize(s);\n\t\t\trep(i,si(y))w[i]=y[i].v;\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);\n\t\treturn z;\n\t}\n\ttemplate<class mint>\n\tvc<mint> multiply_givenlength(vc<mint> x,const vc<mint>&y,bool same=false){\n\t\tauto&d0=sub_givenlength<mint0>(x,y,same);\n\t\tauto&d1=sub_givenlength<mint1>(x,y,same);\n\t\tauto&d2=sub_givenlength<mint2>(x,y,same);\n\t\tint n=si(d0);\n\t\tx.resize(n);\n\t\tstatic const mint1 r01=mint1(mint0::mod).inv();\n\t\tstatic const mint2 r02=mint2(mint0::mod).inv();\n\t\tstatic const mint2 r12=mint2(mint1::mod).inv();\n\t\tstatic const mint2 r02r12=r02*r12;\n\t\tstatic const mint w1=mint(mint0::mod);\n\t\tstatic const mint w2=w1*mint(mint1::mod);\n\t\trep(i,n){\n\t\t\tull a=d0[i].v;\n\t\t\tull b=(d1[i].v+mint1::mod-a)*r01.v%mint1::mod;\n\t\t\tull c=((d2[i].v+mint2::mod-a)*r02r12.v+(mint2::mod-b)*r12.v)%mint2::mod;\n\t\t\tx[i].v=(a+b*w1.v+c*w2.v)%mint::mod;\n\t\t}\n\t\treturn x;\n\t}\n}\nusing arbitrary_convolution::multiply;\nusing arbitrary_convolution::multiply_givenlength;\n\n#endif\n\n//UTPC2021 C\nnamespace integer_convolution{\n\textern constexpr modinfo base0{1045430273,3};//2^20 * 997 + 1\n\textern constexpr modinfo base1{1051721729,6};//2^20 * 1003 + 1\n\t//extern constexpr modinfo base0{469762049,3};//2^26 * 7 + 1\n\t//extern constexpr modinfo base1{754974721,11};//2^24 * 45 + 1\n\tusing mint0=modular<base0>;\n\tusing mint1=modular<base1>;\n\ttemplate<class t>\n\tvc<t> sub(const vi&x,const vi&y,bool same=false){\n\t\tint n=si(x)+si(y)-1;\n\t\tint s=1;\n\t\twhile(s<n)s*=2;\n\t\tvc<t> z(s);rep(i,si(x))z[i]=x[i];\n\t\tinplace_fmt(z,false);\n\t\tif(!same){\n\t\t\tvc<t> w(s);rep(i,si(y))w[i]=y[i];\n\t\t\tinplace_fmt(w,false);\n\t\t\trep(i,s)z[i]*=w[i];\n\t\t}else{\n\t\t\trep(i,s)z[i]*=z[i];\n\t\t}\n\t\tinplace_fmt(z,true);z.resize(n);\n\t\treturn z;\n\t}\n\tvi multiply(const vi&x,const vi&y,bool same=false){\n\t\tauto d0=sub<mint0>(x,y,same);\n\t\tauto d1=sub<mint1>(x,y,same);\n\t\tconst mint1 r=mint1(mint0::mod).inv();\n\t\tconst ll v=ll(mint0::mod)*mint1::mod;\n\t\tint n=si(d0);\n\t\tvi res(n);\n\t\trep(i,n){\n\t\t\tres[i]=d0[i].v+(r*(d1[i]-d0[i].v)).v*(ull)mint0::mod;\n\t\t\tif(res[i]>v/2)res[i]-=v;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n//最大で 1<<mx のサイズの fft が登場！\ntemplate<class mint>\nvc<mint> large_convolution(const vc<mint>&a,const vc<mint>&b,int mx){\n\tint n=si(a),m=si(b);\n\tvc<mint> c(n+m-1);\n\tint len=1<<(mx-1);\n\tfor(int i=0;i<n;i+=len){\n\t\tfor(int j=0;j<n;j+=len){\n\t\t\tint x=min(len,n-i),y=min(len,m-j);\n\t\t\tauto d=multiply(vc<mint>(a.bg+i,a.bg+i+x),vc<mint>(b.bg+j,b.bg+j+y));\n\t\t\trep(k,si(d))\n\t\t\t\tc[i+j+k]+=d[k];\n\t\t}\n\t}\n\treturn c;\n}\n\n//input A: N 次,B ?,M\n//output D: M 次多項式\n//C を M 次多項式として\n//[x^N] A*B*C = [x^M] D*C\n//となるような D を返す\n//CF796F\ntemplate<class mint>\nvc<mint> transpose_advance(const vc<mint>&a,const vc<mint>&b,int m){\n\tint n=si(a)-1;\n\tauto d=multiply(a,b);\n\tvc<mint> res(m+1);\n\tif(n>=m){\n\t\trep(i,m+1)res[i]=d[i+n-m];\n\t}else{\n\t\trng(i,m-n,m+1)res[i]=d[i+n-m];\n\t}\n\treturn res;\n}\n\n//Yukicoder 2166\ntemplate<class mint>\nvoid chmult(vc<mint>&x,const vc<mint>&y,int s){\n\tx=multiply(move(x),y);\n\tx.resize(s);\n}\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//extern constexpr modinfo base{2147483579,0};//2^31 未満の最大の安全素数\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\nmint parity(int i){\n\treturn i%2==0?1:-1;\n}\n\n#ifdef LOCAL\nconst int vmax=10010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn inc(0,k,n)?fact[n]*finv[n-k]*finv[k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?fact[a+b]*finv[a]*finv[b]:0;\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n//対角線を超えず (x,y) に至る方法の数\nmint catalan(int x,int y){\n\tassert(y<=x);\n\treturn binom(x,y)-binom(x+1,y-1);\n}\n//y=x+c を超えず (x,y) に至る方法の数\nmint catalan(int x,int y,int c){\n\tassert(y<=x+c);\n\treturn binom(x,y)-binom(x+c+1,y-c-1);\n}\n\n/*\nconst int vmax=610;\nmint fact[vmax+1],binbuf[vmax+1][vmax+1];\nmint choose(int n,int k){\n\treturn 0<=k&&k<=n?binbuf[n-k][k]:0;\n}\nmint binom(int a,int b){\n\treturn 0<=a&&0<=b?binbuf[a][b]:0;\n}\nvoid initfact(int n){\n\tfact[0]=1;\n\trep(i,n)fact[i+1]=fact[i]*(i+1);\n\trep(i,n+1)rep(j,n+1){\n\t\tif(i==0&&j==0){\n\t\t\tbinbuf[i][j]=1;\n\t\t}else{\n\t\t\tbinbuf[i][j]=0;\n\t\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t\t}\n\t}\n}\n*/\n\nmint p2[vmax],p2inv[vmax];\nvoid initp2(){\n\tp2[0]=1;\n\trep(i,vmax-1)p2[i+1]=p2[i]*2;\n\tp2inv[vmax-1]=p2[vmax-1].inv();\n\tper(i,vmax-1)p2inv[i]=p2inv[i+1]*2;\n}\n\nbool dbg=false;\n\nmint sub(int h,int w,int k){\n\treturn choose(h,k)*choose(w,k)*fact[k];\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvc<pi> ls;\n\tls.eb(0,0);\n\tvi raw=readvi(n);\n\trng(i,1,n+1){\n\t\tint v=raw[i-1];\n\t\tif(i==n){\n\t\t\tif(v!=-1&&v!=n)\n\t\t\t\treturn print(0);\n\t\t\tv=n;\n\t\t}\n\t\tif(v==-1)continue;\n\t\tif(ls.back().b>v)return print(0);\n\t\tif(v!=-1)ls.eb(i,v);\n\t}\n\t//dmp(ls);\n\tmint ans=1;\n\trep(step,si(ls)-1){\n\t\tint s=ls[step+1].a-ls[step].a;\n\t\tint t=ls[step].a-ls[step].b;\n\t\tint k=ls[step+1].b-ls[step].b;\n\t\tvc<mint> a(k+1);\n\t\trep(x,k+1)a[x]=choose(t,x)*choose(s,k-x)*fact[k-x];\n\t\tauto b=multiply(a,a,true);\n\t\tmint w=0;\n\t\trep(xy,k+1){\n\t\t\tw+=b[xy]*finv[k-xy];\n\t\t}\n\t\t//dmp2(s,t,k,w);\n\t\tans*=w;\n\t}\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2500
Gennady is one of the best child dentists in Berland Today children got an appointment with him they lined up in front of his office All children love to cry loudly at the reception at the dentist We enumerate the children with integers from to in the order they go in the line Every child is associated with the value of his The children take turns one after another to come into the office each time the child that is the first in the line goes to the doctor While Gennady treats the teeth of the th child the child is crying with the volume of At that the of the first child in the line is reduced by the amount of the second one by value and so on The children in the queue after the th child almost do not hear the crying so their remains unchanged If at any point in time the of the th child is less than zero he begins to cry with the volume of and leaves the line running towards the exit without going to the doctor s office At this the of all the children after the th one in the line is reduced by the amount of All these events occur immediately one after the other in some order Some cries may lead to other cries causing a chain reaction Once in the hallway it is quiet the child who is first in the line goes into the doctor s office Help Gennady the Dentist to determine the numbers of kids whose teeth he will cure Print their numbers in the chronological order ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int N = 4040;\nint n;\nint m;\nint v[N], d[N], p[N];\nint ans[N];\nbool used[N];\nint q[N];\nint topQ;\n\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++)\n        scanf(""%d%d%d"", &v[i], &d[i], &p[i]);\n    int k = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (used[i]) continue;\n        ans[m++] = i + 1;\n        int r = v[i];\n        for (int j = i + 1; j < n && r > 0; j++)\n        {\n            if (used[j]) continue;\n            p[j] -= r;\n            if (p[j] < 0)\n            {\n                used[j] = 1;\n                q[topQ++] = j;\n            }\n            r--;\n        }\n        while(k < topQ)\n        {\n            int v = q[k++];\n            for (int j = v + 1; j < n; j++)\n            {\n                if (used[j]) continue;\n                p[j] -= d[v];\n                if (p[j] < 0)\n                {\n                    used[j] = 1;\n                    q[topQ++] = j;\n                }\n            }\n        }\n    }\n    printf(""%d\\n"", m);\n    for (int i = 0; i < m; i++)\n        printf(""%d "", ans[i]);\n\n    return 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Tenzing has n balls arranged in a line The color of the i th ball from the left is a i Tenzing can do the following operation any number of times select i and j such that 1 leq i j leq a and a i a j remove a i a i 1 ldots a j from the array and decrease the indices of all elements to the right of a j by j i 1 Tenzing wants to know the maximum number of balls he can remove ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:08:39       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    const int inf = (int) 1e9;\n    vector<int> dp(n + 1, -inf);\n    dp[0] = 0;\n    for (int i = 0; i < n; i++) {\n      int v = dp[a[i]];\n      dp[a[i]] = max(dp[a[i]], dp[0] - i);\n      dp[0] = max(dp[0], v + i + 1);\n    }\n    cout << dp[0] << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
An n times m grid of characters is called if it satisfies these three conditions Each character is either or Every 2 times 2 contiguous subgrid contains all three different letters Any two cells that share a common edge contain different letters Let x y denote the cell in the x th row from the top and y th column from the left You want to construct a great grid that satisfies k constraints Each constraint consists of two cells x i 1 y i 1 and x i 2 y i 2 that share exactly one corner You want your great grid to have the same letter in cells x i 1 y i 1 and x i 2 y i 2 Determine whether there exists a great grid satisfying all the constraints ,"['#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf("" %s"",ss);(st)=ss;}\n#define spln(i,n) (i==n?\'\\n\':\' \')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(""1.in"",""r"",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,k,i,j,fa[8005];\nint fnd(int x){if(fa[x]==x)return x;return fa[x]=fnd(fa[x]);}\nvoid merge(int x,int y){fa[fnd(x)]=fnd(y);}\nvoid solve()\n{\n\tread(n);read(m);read(k);fz1(i,n+m+n+m)fa[i]=i;\n\tfz1(i,k){\n\t\tint x1,y1,x2,y2;read(x1);read(y1);read(x2);read(y2);\n\t\tint x=min(x1,x2),y=min(y1,y2);\n\t\tif((x1==x)==(y1==y)){\n\t\t\tmerge(x,y+n);\n\t\t\tmerge(x+n+m,y+n+n+m);\n\t\t}\n\t\telse{\n\t\t\tmerge(x,y+n+n+m);\n\t\t\tmerge(x+n+m,y+n);\n\t\t}\n\t}\n\tfz1(i,n+m)if(fnd(i)==fnd(i+n+m)){\n\t\tputs(""NO"");return;\n\t}\n\tputs(""YES"");\n}\nint main()\n{\n\tint t;read(t);\n\twhile(t--)solve();\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2400
Ichihime is the current priestess of the Mahjong Soul Temple She claims to be human despite her cat ears These days the temple is holding a math contest Usually Ichihime lacks interest in these things but this time the prize for the winner is her favorite cookies Ichihime decides to attend the contest Now she is solving the following problem You are given four positive integers a b c d such that a leq b leq c leq d Your task is to find three integers x y z satisfying the following conditions a leq x leq b b leq y leq c c leq z leq d There exists a triangle with a positive non zero area and the lengths of its three sides are x y and z Ichihime desires to get the cookie but the problem seems too hard for her Can you help her ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t; \n    cin >> t;\n    while(t--)\n    {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n    \n        cout << b << "" "" << c << "" "" << c << ""\\n"";\n    }\n\n    return 0;\n}']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
City X consists of vertical and horizontal infinite roads forming intersections Roads both vertical and horizontal are numbered from to and the intersections are indicated by the numbers of the roads that form them Sand roads have long been recognized out of date so the decision was made to asphalt them To do this a team of workers was hired and a schedule of work was made according to which the intersections should be asphalted Road repairs are planned for days On the th day of the team arrives at the th intersection in the list and if of the two roads that form the intersection were already asphalted they asphalt both roads Otherwise the team leaves the intersection without doing anything with the roads According to the schedule of road works tell in which days at least one road will be asphalted ,"[""#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nint a[55],b[55],n;\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n*n;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(a[x]==0&&b[y]==0)a[x]=b[y]=1,cout<<i<<' ';\n\t}\n\treturn 0;\n}\n""]","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Alice and Bob play ping pong with simplified rules During the game the player serving the ball commences a play The server strikes the ball then the receiver makes a return by hitting the ball back Thereafter the server and receiver must alternately make a return until one of them doesn t make a return The one who doesn t make a return loses this play The winner of the play commences the next play Alice starts the first play Alice has x stamina and Bob has y To hit the ball while serving or returning each player spends 1 stamina so if they don t have any stamina they can t return the ball and lose the play or can t serve the ball in this case the other player serves the ball instead If both players run out of stamina the game is over Sometimes it s strategically optimal not to return the ball lose the current play but save the stamina On the contrary when the server commences a play they have to hit the ball if they have some stamina left Both Alice and Bob play optimally and want to firstly maximize their number of wins and secondly minimize the number of wins of their opponent Calculate the resulting number of Alice s and Bob s wins ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int X, Y;\n    cin >> X >> Y;\n    cout << X - 1 << \' \' << Y << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
A total of n depots are located on a number line Depot i lies at the point x i for 1 le i le n You are a salesman with n bags of goods attempting to deliver one bag to each of the n depots You and the n bags are initially at the origin 0 You can carry up to k bags at a time You must collect the required number of goods from the origin deliver them to the respective depots and then return to the origin to collect your next batch of goods Calculate the minimum distance you need to cover to deliver all the bags of goods to the depots You do have to return to the origin after you have delivered all the bags ,"[""#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define pb push_back\n#define fir first\n#define sec second\n#define SZ(x) (int(x.size()))\ninline int read(){\n    int x=0;char ch=getchar();\n    int f=0;\n    while(!isdigit(ch))f|=ch=='-',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-'0',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar('-'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\ntemplate<typename T>void print(T x,char let){\n    print(x),putchar(let);\n}\ntemplate<typename T1,typename T2>void ckmin(T1&x,T2 y){\n    if(x>y)x=y;\n}\ntemplate<typename T1,typename T2>void ckmax(T1&x,T2 y){\n    if(x<y)x=y;\n}\n\nconst int N=500005;\nll a[N],b[N];int lena,lenb;\nint n,k;\nll ans;\n\nvoid solve(){\n    lena=lenb=ans=0;\n    n=read(),k=read();\n    rep(i,1,n){\n        int x=read();\n        if(x>0)a[++lena]=x;\n        else b[++lenb]=-x;\n    }\n    sort(a+1,a+lena+1);\n    sort(b+1,b+lenb+1);\n    for(int i=lena;i>=1;i-=k){\n//        int j=max(i-k+1,1);\n        ans+=a[i]*2;\n    }\n    for(int i=lenb;i>=1;i-=k){\n//        int j=min(i+k-1,lenb);\n        ans+=b[i]*2;\n    }\n    if(lena&&lenb)ans-=max(a[lena],b[lenb]);\n    else if(lena)ans-=a[lena];\n    else if(lenb)ans-=b[lenb];\n    print(ans,'\\n');\n}\nint main(){\n    int T=read();\n    while(T--){\n        solve();\n    }\n    return 0;\n}""]","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
There are cities and two way roads in Berland each road connects two cities It is known that there is no more than one road connecting each pair of cities and there is no road which connects the city with itself It is possible that there is no way to get from one city to some other city using only these roads The road minister decided to make a reform in Berland and to orient all roads in the country i e to make each road one way The minister wants to the number of cities for which the number of roads that begins in the city to the number of roads that ends in it ,"['#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nconst int N(222);\n\nint n, m;\nint adj[N][N], visit[N], deg[N];\nvector<pair<int, int> > answer;\nset<pair<int, int> > baned;\n\nvoid dfs(int x) {\n\tvisit[x] = 1;\n\tfor (int y = 1; y <= n; y++) {\n\t\twhile (adj[x][y]) {\n\t\t\tadj[x][y]--;\n\t\t\tadj[y][x]--;\n\t\t\tdfs(y);\n\t\t\tanswer.push_back({x, y});\n\t\t}\n\t}\n}\n\nint main() {\n\tint test;\n\tscanf(""%d"", &test);\n\twhile (test--) {\n\t\tscanf(""%d %d"", &n, &m);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tvisit[i] = 0;\n\t\t\tdeg[i] = 0;\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tadj[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tbaned.clear();\n\t\tanswer.clear();\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint u, v;\n\t\t\tscanf(""%d %d"", &u, &v);\n\t\t\tadj[u][v] = adj[v][u] = 1;\n\t\t\tdeg[v]++;\n\t\t\tdeg[u]++;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (deg[i] % 2 == 1) {\n\t\t\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\t\t\tif (deg[j] % 2 == 1) {\n\t\t\t\t\t\tbaned.insert({i, j});\n\t\t\t\t\t\tadj[i][j]++;\n\t\t\t\t\t\tadj[j][i]++;\n\t\t\t\t\t\tdeg[i]++;\n\t\t\t\t\t\tdeg[j]++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!visit[i]) {\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdeg[i] = 0;\n\t\t}\n\t\tvector<pair<int, int> > result;\n\t\tfor (auto p : answer) {\n\t\t\tint a = p.first, b = p.second;\n\t\t\tif (baned.count({a, b}) || baned.count({b, a})) {\n\t\t\t\tbaned.erase({min(a, b), max(a, b)});\n\t\t\t} else {\n\t\t\t\tdeg[a]++;\n\t\t\t\tdeg[b]--;\n\t\t\t\tresult.push_back({a, b});\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (deg[i] == 0) {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", cnt);\n\t\tfor (int i = 0; i < result.size(); i++) {\n\t\t\tprintf(""%d %d\\n"", result[i].first, result[i].second);\n\t\t}\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
 Hey it s homework time thought Polycarpus and of course he started with his favourite subject IT Polycarpus managed to solve all tasks but for the last one in 20 minutes However as he failed to solve the last task after some considerable time the boy asked you to help him The sequence of integers is called a permutation if it contains all integers from to exactly once You are given an arbitrary sequence containing integers Each integer is not less than and not greater than Determine what minimum number of elements Polycarpus needs to change to get a permutation he should not delete or add numbers In a single change he can modify any single sequence element i e replace it with another integer ,"['#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int,int> PII;\n\nint main(){\n    int n,cnt[5001]={},ans=0;\n    scanf(""%d"",&n);\n    for(int i=0;i<n;i++){\n        int tmp;\n        scanf(""%d"",&tmp);\n        cnt[tmp]++;\n    }\n    for(int i=1;i<=n;i++) if(!cnt[i]) ans++;\n    printf(""%d\\n"",ans);\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
You the mighty Blackout are standing in the upper left 0 0 corner of NxM matrix You must move either right or down each second There are K transformers jumping around the matrix in the following way Each transformer starts jumping from position x y at time t and jumps to the next position each second The x axes grows downwards and y axes grows to the right The order of jumping positions is defined as x y x d y d x d y x y d and is periodic Before time t transformer is not in the matrix You want to arrive to the bottom right corner N 1 M 1 while slaying transformers and losing the least possible amount of energy When you meet the transformer or more of them in the matrix field you must kill them all and you lose the sum of the energy amounts required to kill each transformer After the transformer is killed he of course stops jumping falls into the abyss and leaves the matrix world Output minimum possible amount of energy wasted ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n#define x first\n#define y second\n\nconst int N = 505;\nconst ll INF = ll(1e18);\n\nint n, m, k;\nll d[N][N][2], a[N][N], hs[N], vs[N];\nvector<pii> va[N][N], vt[N];\nvector<pair<pii, int>> ht[N];\n\nint f(int x, int y, int t){\n    return (x + y >= t) && ((x + y - t) % 4 == 0);\n}\n\nint main(){ ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m >> k;\n    for(int i = 0; i < k; i++){\n        int x, y, d, t, v;\n        cin >> x >> y >> d >> t >> v;\n        int ul = f(x, y, t);\n        int ur = f(x, y + d, t + 3);\n        int dl = f(x + d, y - d, t + 1);\n        int dr = f(x + d, y, t + 2);\n        if(ul) a[x][y] += v;\n        if(ur) a[x][y + d] += v;\n        if(dl) a[x + d][y - d] += v;\n        if(dr) a[x + d][y] += v;\n        if(ul && ur){\n            vt[x].emplace_back(y + d, v);\n            va[x][y].emplace_back(y + d, v);\n        }\n        if(ul && dr){\n            a[x + d][y] -= v;\n            ht[x].emplace_back(pii(x + d, y), v);\n        }\n        if(dl && dr){\n            vt[x + d].emplace_back(y, v);\n            va[x + d][y - d].emplace_back(y, v);\n        }\n    }\n    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++)\n        if(i + j) d[i][j][0] = d[i][j][1] = INF;\n    for(int i = 0; i < n; i++){\n        for(pii &t : vt[i]) a[i][t.x] -= t.y;\n        for(int j = 0; j < m; j++){\n            ll cs = 0;\n            for(int t = i + 1; t < n; t++){\n                cs += a[t][j];\n                d[t][j][0] = min(d[t][j][0], d[i][j][1] + cs);\n            }\n            cs = 0;\n            for(int t = j + 1; t < m; t++){\n                cs += a[i][t];\n                d[i][t][1] = min(d[i][t][1], d[i][j][0] + cs);\n            }\n            for(pii &t : va[i][j]) a[i][t.x] += t.y;\n        }\n        for(auto &t : ht[i]) a[t.x.x][t.x.y] += t.y;\n    }\n    cout << min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]) << '\\n';\n}""]","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2600
n players are playing a game There are two different maps in the game For each player we know his strength on each map When two players fight on a specific map the player with higher strength on that map always wins No two players have the same strength on the same map You are the game master and want to organize a tournament There will be a total of n 1 battles While there is more than one player in the tournament choose any map and any two remaining players to fight on it The player who loses will be eliminated from the tournament In the end exactly one player will remain and he is declared the winner of the tournament For each player determine if he can win the tournament ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvi unko(int n){\n\tvi a=readvi(n);\n\tvi vs=a;sort(all(vs));\n\trep(i,n)a[i]=lwb(vs,a[i]);\n\treturn a;\n}\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=unko(n);\n\tvi b=unko(n);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\tvi ans(n);\n\tint mn=inf;\n\tper(i,n){\n\t\tassert(a[idx[i]]==i);\n\t\tchmin(mn,b[idx[i]]);\n\t\tif(mn==i){\n\t\t\trng(j,i,n){\n\t\t\t\tans[idx[j]]=1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\trep(i,n)cout<<ans[i];\n\tcout<<""\\n"";\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1700
You ve got a string S consisting of n lowercase English letters from your friend It turned out that this is a number written in numerals The poman numeral system is long forgotten All that s left is the algorithm to transform number from poman numerals to the numeral system familiar to us Characters of S are numbered from 1 to n from left to right Let s denote the value of S as f S it is defined as follows If S 1 an arbitrary integer m 1 le m S is chosen and it is defined that f S f S 1 m f S m 1 S where S l r denotes the substring of S from the l th to the r th position inclusively Otherwise S c where c is some English letter Then f S 2 pos c where pos c is the position of letter c in the alphabet pos 0 pos 25 Note that m is chosen independently on each step Your friend thinks it is possible to get f S T by choosing the right m on every step Is he right ,"['#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 100005;\n\nint n;\nint cnt[27];\n\nll T;\nll w[27];\n\nchar s[MAXN];\n\nint main()\n{\n\tscanf(""%d%lld%s"",&n,&T,s + 1);\n\tw[0] = 1;\n\tfor (int i = 1;i <= 26;i++)\n\t\tw[i] = w[i - 1] * 2;\n\tT -= w[s[n] - \'a\'];\n\tT += w[s[n - 1] - \'a\'];\n\tfor (int i = 1;i <= n - 2;i++)\n\t\tT -= w[s[i] - \'a\'];\n\tif (T > 0)\n\t{\n\t\tputs(""No"");\n\t\treturn 0;\n\t}\n\tT = -T;\n\tfor (int i = 1;i <= n - 2;i++)\n\t\tcnt[s[i] - \'a\' + 1]++;\n\tfor (int i = 26;i >= 0;i--)\n\t\twhile (cnt[i] && T >= w[i])\n\t\t{\n\t\t\tT -= w[i];\n\t\t\tcnt[i]--;\n\t\t}\n\tputs(!T ? ""Yes"" : ""No"");\n\treturn 0;\n}']","[1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2300
A permutation is a sequence of length n integers from 1 to n in which all the numbers occur exactly once For example 1 3 5 2 1 4 1 3 2 permutations and 2 3 2 4 3 1 0 no Polycarp was recently gifted a permutation a 1 dots n of length n Polycarp likes trees more than permutations so he wants to transform permutation a into a rooted binary tree He transforms an array of different integers into a tree as follows the maximum element of the array becomes the root of the tree all elements to the left of the maximum form a left subtree which is built according to the same rules but applied to the left part of the array but if there are no elements to the left of the maximum then the root has no left child all elements to the right of the maximum form a right subtree which is built according to the same rules but applied to the right side of the array but if there are no elements to the right of the maximum then the root has no right child For example if he builds a tree by permutation a 3 5 2 1 4 then the root will be the element a 2 5 and the left subtree will be the tree that will be built for the subarray a 1 dots 1 3 and the right one for the subarray a 3 dots 5 2 1 4 As a result the following tree will be built Another example let the permutation be a 1 3 2 7 5 6 4 In this case the tree looks like this Let us denote by d v the depth of the vertex a v that is the number of edges on the path from the root to the vertex numbered a v Note that the root depth is zero Given the permutation a for each vertex find the value of d v ,"[""#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint n;\nint arr[110];\nint ans[110];\n\nvoid recur(int s, int e, int depth)\n{\n\tint i;\n\tint mx;\n\tint idx;\n\n\tif (s > e) return;\n\n\tmx = -1;\n\tfor (i = s; i <= e; i++)\n\t{\n\t\tif (mx < arr[i])\n\t\t{\n\t\t\tmx = arr[i];\n\t\t\tidx = i;\n\t\t}\n\t}\n\n\tans[idx] = depth;\n\trecur(s, idx - 1, depth + 1);\n\trecur(idx + 1, e, depth + 1);\n}\n\nint main()\n{\n\tint t;\n\tint i;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> arr[i];\n\t\t}\n\n\t\trecur(0, n - 1, 0);\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcout << ans[i] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}""]","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Shrek and the Donkey as you can guess they also live in the far away kingdom decided to play a card game called YAGame The rules are very simple initially Shrek holds cards and the Donkey holds cards the players do not see each other s cards and one more card lies on the table face down so that both players cannot see it as well Thus at the beginning of the game there are overall cards Besides the players know which cards the pack of cards consists of and their own cards but they do not know which card lies on the table and which ones the other player has The players move in turn and Shrek starts During a move a player can Try to guess which card is lying on the table If he guesses correctly the game ends and he wins If his guess is wrong the game also ends but this time the other player wins Name any card from the pack If the other player has such card he must show it and put it aside so that this card is no longer used in the game If the other player doesn t have such card he says about that Recently Donkey started taking some yellow pills and winning over Shrek Now Shrek wants to evaluate his chances to win if he too starts taking the pills Help Shrek assuming the pills are good in quality and that both players using them start playing in the optimal manner ,"['#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\ndouble pd[2200][2200];\n\nint main(){\n    int n, m;\n    scanf(""%d%d"", &n, &m);\n    \n    int N = max(n,m);\n    \n    pd[0][0] = 1;\n    for(int i = 1; i <= N; i++){\n        pd[i][0] = 1;\n    }\n    for(int j = 1; j <= N; j++){\n        pd[0][j] = 1.0/(j+1);\n    }\n    \n    for(int sum = 2; sum <= 2*N; sum++){\n        for(int i = 1; i <= N; i++){\n            int j = sum-i;\n            if(j < 1 || j > N)continue;\n            pd[i][j] = 1.0/(j+1);\n            double a = 1;\n            double b = 1.0 - pd[j][i-1];\n            double c = j*(1.0-pd[j-1][i])/(j+1);\n            double d = c + 1.0/(j+1);\n            double p,q;\n            if(fabs(a-b-c+d) < 1E-8){\n                p = 1;\n                q = 1;\n            }else{\n                p = (d-c)/(a-b-c+d);\n                q = (d-b)/(a-b-c+d);\n            }\n            pd[i][j] = max(pd[i][j], p*q*a + p*(1.0-q)*b + (1.0-p)*q*c + (1.0-p)*(1.0-q)*d);\n        }\n    }\n    printf(""%.10lf %.10lf\\n"", pd[n][m], 1.0-pd[n][m]);\n    return 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
Anton s favourite geometric figures are regular polyhedrons Note that there are five kinds of regular polyhedrons Tetrahedron has triangular faces Cube has square faces Octahedron has triangular faces Dodecahedron has pentagonal faces Icosahedron has triangular faces All five kinds of polyhedrons are shown on the picture below Anton has a collection of polyhedrons One day he decided to know how many faces his polyhedrons have in total Help Anton and find this number ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\nconst int MX=22;\nint n;\n\nint main(){\n\tint ans=0;char s[MX];\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(""%s"",s);\n\t\tif(s[0]==\'T\')ans+=4;\n\t\telse if(s[0]==\'C\')ans+=6;\n\t\telse if(s[0]==\'O\')ans+=8;\n\t\telse if(s[0]==\'D\')ans+=12;\n\t\telse ans+=20;\n\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
Ivan is a programming teacher During the academic year he plans to give n lectures on n different topics Each topic should be used in exactly one lecture Ivan wants to choose which topic will he explain during the 1 st 2 nd n th lecture formally he wants to choose some permutation of integers from 1 to n let s call this permutation q q i is the index of the topic Ivan will explain during the i th lecture For each topic except there exists a prerequisite topic for the topic i the prerequisite topic is p i Ivan cannot give a lecture on a topic before giving a lecture on its prerequisite topic There exists at least one valid ordering of topics according to these prerequisite constraints Ordering the topics correctly can help students understand the lectures better Ivan has k special pairs of topics x i y i such that he knows that the students will understand the y i th topic better if the lecture on it is conducted the lecture on the x i th topic Ivan wants to satisfy the constraints on every such pair that is for every i in 1 k there should exist some j in 1 n 1 such that q j x i and q j 1 y i Now Ivan wants to know if there exists an ordering of topics that satisfies all these constraints and if at least one exists find any of them ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target (""sse4"")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nstruct graph {\nprivate:\n\tint n;\n\tvector<vector<int>> G, rG;\n\tvector<bool> used;\n\tvector<int> vs;\n\n\tint mk;\n\tvector<vector<int>> fG;\n\tvector<vector<int>> ori;\n\tvector<int> trans;\npublic:\n\tgraph(int sz) {\n\t\tn = sz;\n\t\tG.resize(n);\n\t\trG.resize(n);\n\t\tused.resize(n);\n\n\t\tfG.resize(n);\n\t\ttrans.resize(n, -1);\n\t\tori.resize(n);\n\t}\n\tvoid add_edge(int a, int b) {\n\t\tG[a].push_back(b);\n\t\trG[b].push_back(a);\n\t}\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\trep(i, G[v].size()) {\n\t\t\tif (!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.push_back(v);\n\t}\n\tvoid rdfs(int v, int k) {\n\t\tused[v] = true;\n\t\tqueue<int> q; q.push(v);\n\t\tvector<int> c;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\tori[k].push_back(id);\n\t\t\trep(j, rG[id].size()) {\n\t\t\t\tint to = rG[id][j];\n\t\t\t\tif (used[to]) {\n\t\t\t\t\tif (trans[to] >= 0)c.push_back(trans[to]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\tsort(c.begin(), c.end());\n\t\tint len = unique(c.begin(), c.end()) - c.begin();\n\t\trep(i, len) {\n\t\t\tfG[c[i]].push_back(k);\n\t\t}\n\t\trep(i, ori[k].size()) {\n\t\t\ttrans[ori[k][i]] = k;\n\t\t}\n\t}\n\tvoid scc() {\n\t\tfill(used.begin(), used.end(), false);\n\t\trep(i, n) {\n\t\t\tif (!used[i])dfs(i);\n\t\t}\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tper(i, (int)vs.size()) {\n\t\t\tif (!used[vs[i]]) {\n\t\t\t\trdfs(vs[i], k); k++;\n\t\t\t}\n\t\t}\n\t\tmk = k;\n\t}\n\tvector<int> query() {\n\t\trep(i, mk)if (ori[i].size() > 1)return {};\n\t\tvector<int> res;\n\t\trep(i, mk)res.push_back(ori[i][0]);\n\t\treturn res;\n\t}\n};\n\nvoid solve() {\n\tint n, k; cin >> n >> k;\n\tvector<int> p(n);\n\trep(i, n) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tvector<P> memo;\n\tvector<int> pre(n, -1);\n\tvector<int> nex(n, -1);\n\trep(i, k) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tpre[b] = a;\n\t\tnex[a] = b;\n\t\tmemo.push_back({ a,b });\n\t}\n\tuf u(n);\n\trep(i, k) {\n\t\tif (u.same(memo[i].first, memo[i].second)) {\n\t\t\tcout << 0 << ""\\n""; return;\n\t\t}\n\t\tu.unite(memo[i].first, memo[i].second);\n\t}\n\tgraph c(n);\n\trep(i, n) {\n\t\tif (p[i] >= 0)c.add_edge(p[i], i);\n\t}\n\trep(i, k) {\n\t\tc.add_edge(memo[i].first, memo[i].second);\n\t}\n\tc.scc();\n\tvector<int> cc = c.query();\n\tif (cc.empty()) {\n\t\tcout << 0 << ""\\n""; return;\n\t}\n\tgraph g(n);\n\trep(i, n) {\n\t\tif (p[i] >= 0) {\n\t\t\tint fr = u.find(p[i]);\n\t\t\tint sc = u.find(i);\n\t\t\tg.add_edge(fr, sc);\n\t\t}\n\t}\n\tg.scc();\n\tvector<int> ord = g.query();\n\tif (ord.empty()) {\n\t\tcout << 0 << ""\\n""; return;\n\t}\n\tvector<int> ans;\n\tvector<vector<int>> ids(n);\n\trep(i, n)ids[u.find(i)].push_back(i);\n\tfor (int id : ord) {\n\t\tif (ids[id].empty())continue;\n\t\tint sta = -1;\n\t\tfor (int v : ids[id])if (pre[v] < 0)sta = v;\n\t\twhile (sta>=0) {\n\t\t\tans.push_back(sta);\n\t\t\tsta = nex[sta];\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (i > 0)cout << "" "";\n\t\tcout << ans[i] + 1;\n\t}\n\tcout << ""\\n"";\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0]",2400
Recently Vasya learned that given two points with different x coordinates you can draw through them exactly one parabola with equation of type y x 2 bx c where b and c are reals Let s call such a parabola an U shaped one Vasya drew several distinct points with integer coordinates on a plane and then drew an U shaped parabola through each pair of the points that have different x coordinates The picture became somewhat messy but Vasya still wants to count how many of the parabolas drawn don t have any drawn point inside their internal area Help Vasya The internal area of an U shaped parabola is the part of the plane that lies strictly above the parabola when the y axis is directed upwards ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct Point {\n\tll x, y;\n\n\tPoint() : x(), y() {}\n\tPoint(ll _x, ll _y) : x(_x), y(_y) {}\n\n\tPoint operator + (const Point &a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\tPoint operator - (const Point &a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n\tll operator * (const Point &a) const {\n\t\treturn x * a.y - y * a.x;\n\t}\n\n\tdouble len() const {\n\t\treturn sqrtl((ld)x * x + (ld)y * y);\n\t}\n\n\tbool operator < (const Point &a) const {\n\t\tif (x != a.x) return x < a.x;\n\t\treturn y < a.y;\n\t}\n};\n\nconst int N = 100100;\nint n;\nPoint a[N];\nPoint h[N];\nint m;\n\nbool cmp(const Point &v, const Point &u) {\n\tll x = v * u;\n\tif (x != 0) return x > 0;\n\treturn v.len() < u.len();\n}\n\nvoid graham() {\n\tsort(a, a + n, cmp);\n\tfor (int i = 0; i < n; i++) {\n\t\twhile(m > 1 && (a[i] - h[m - 1]) * (a[i] - h[m - 2]) >= 0) m--;\n\t\th[m++] = a[i];\n\t}\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tll x, y;\n\t\tscanf(""%lld%lld"", &x, &y);\n\t\ta[i] = Point(x, y - x * x);\n\t}\n\tsort(a, a + n);\n\tfor (int i = n - 1; i >= 0; i--)\n\t\ta[i] = a[i] - a[0];\n\tgraham();\n\th[m] = h[0];\n\n\tint ans = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (h[i + 1].x < h[i].x)\n\t\t\tans++;\n\t}\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2400
Ayush devised a new scheme to set the password of his lock The lock has k slots where each slot can hold integers from 1 to n The password P is a sequence of k integers each in the range 1 n i th element of which goes into the i th slot of the lock To set the password of his lock Ayush comes up with an array A of n integers each in the range 1 n not necessarily distinct He then picks k subsets of indices S 1 S 2 S k S i underset i neq j cap S j emptyset and sets his password as P i max limits j notin S i A j In other words the i th integer in the password is equal to the maximum over all elements of A whose indices do not belong to S i You are given the subsets of indices chosen by Ayush You need to guess the password To make a query you can choose a non empty subset of indices of the array and ask the maximum of all elements of the array with index in this subset ,"['#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << "" : "" << x << \'\\n\'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007LL;\nconst int N = 1e3 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nint Ask(int i){\n\tcout << ""? "" << i;\n\tfor(int j = 1; j <= i; j++) cout << "" "" << j;\n\tcout << endl;\n\tint res;\n\tcin >> res;\n\treturn res;\n}\n\nvector<int> V[N];\n\nint ans[N];\nint Main(){\n\tint n, k, sz, v;\n\tcin >> n >> k;\n\tfor(int i = 1; i <= k; i++){\n\t\tcin >> sz;\n\t\tV[i].clear();\n\t\tfor(int j = 0; j < sz; j++){\n\t\t\tcin >> v;\n\t\t\tV[i].pb(v);\n\t\t}\n\t}\n\tint mx = Ask(n);\n\tint L = 0, R = n, mid;\n\t\n\twhile(L + 1 < R){\n\t\tmid = (L + R) >> 1;\n\t\tif(Ask(mid) == mx) R = mid;\n\t\telse L = mid;\n\t}\n\tfor(int i = 1; i <= k; i++){\n\t\tint flg = false;\n\t\tfor(auto x : V[i]) if(x == R) flg = true;\n\t\tif(!flg){\n\t\t\tans[i] = mx;\n\t\t\tcontinue;\n\t\t}\n\t\tmap<ll, ll> mp;\n\t\tfor(auto x : V[i]) mp[x] = 1;\n\t\tcout << ""? "" << n - V[i].size();\n\t\tfor(int j = 1; j <= n; j++) if(!mp[j]) cout << "" "" << j;\n\t\tcout << endl;\n\t\tcin >> ans[i];\n\t}\n\n\tcout << ""!"";\n\tfor(int i = 1; i <= k; i++) cout << "" "" << ans[i];\n\tcout << endl;\n\tstr rs;\n\tcin >> rs;\n\treturn 0;\n}\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tint tc;\n\tcin >> tc;\n\twhile(tc --) Main();\n\treturn 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Slime has a sequence of positive integers a 1 a 2 ldots a n In one operation Orac can choose an arbitrary subsegment l ldots r of this sequence and replace all values a l a l 1 ldots a r to the value of median of a l a l 1 ldots a r In this problem for the integer multiset s the median of s is equal to the lfloor frac s 1 2 rfloor th smallest number in it For example the median of 1 4 4 6 5 is 4 and the median of 1 7 5 8 is 5 Slime wants Orac to make a 1 a 2 ldots a n k using these operations Orac thinks that it is impossible and he does not want to waste his time so he decided to ask you if it is possible to satisfy the Slime s requirement he may ask you these questions several times ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 100100;\nint n, k;\nint a[N];\n\nint sgn(int x) {\n\tif (x > 0) return 1;\n\tif (x == 0) return 0;\n\treturn -1;\n}\n\nbool solve() {\n\tscanf(""%d%d"", &n, &k);\n\tbool hv = false;\n\tbool bad = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tx -= k;\n\t\thv |= (x == 0);\n\t\tx = sgn(x);\n\t\tbad |= x == -1;\n\t\tif (x == 0) x = 1;\n\t\ta[i + 1] = x;\n\t}\n\tif (!hv) return false;\n\tif (!bad) return true;\n\ta[0] = 0;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i + 1] += a[i];\n\tint minBal = n + 3;\n\tfor (int i = 3; i <= n; i++) {\n\t\tminBal = min(minBal, a[i - 3]);\n\t\tif (a[i] > minBal)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\tif (solve())\n\t\t\tprintf(""yes\\n"");\n\t\telse\n\t\t\tprintf(""no\\n"");\n\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Kana was just an ordinary high school girl before a talent scout discovered her Then she became an idol But different from the stereotype she is also a gameholic One day Kana gets interested in a new adventure game called In this game her quest is to beat a dragon The dragon has a of x initially When its goes to 0 or under 0 it will be defeated In order to defeat the dragon Kana can cast the two following types of spells Assume that the dragon s current is h after this spell its will become left lfloor frac h 2 right rfloor 10 Here left lfloor frac h 2 right rfloor denotes h divided by two rounded down This spell will decrease the dragon s by 10 Assume that the dragon s current is h after this spell its will be lowered to h 10 Due to some reasons Kana can only n and m She can cast the spells in any order and cast all the spells Kana isn t good at math so you are going to help her to find out whether it is possible to defeat the dragon ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int x, n, m;\n        cin >> x >> n >> m;\n\n        bool ok = false;\n\n        for(int i = 0; i <= n; i++)\n        {\n            int v = x;\n            for(int j = 0; j < i; j++)\n                v = v / 2 + 10;\n            for(int j = 0; j < m; j++)\n                v -= 10;\n\n            if(v <= 0)\n                ok = true;\n        }\n\n        cout << (ok ? ""YES\\n"" : ""NO\\n"");\n    }\n\n    return 0;\n}']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
Whoa You did a great job helping Team Rocket who managed to capture all the Pokemons sent by Bash Meowth part of Team Rocket having already mastered the human language now wants to become a master in programming as well He agrees to free the Pokemons if Bash can answer his questions Initially Meowth gives Bash a weighted tree containing nodes and a sequence which is a permutation of Now Mewoth makes queries of one of the following forms meaning Bash should report where is the length of the shortest path from node to node in the given tree meaning Bash should swap and in the given sequence This new sequence is used for later queries Help Bash to answer the questions ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long inf = (long long) 1e18;\n\nconst int N = 400010;\n\nvector < pair <int, long long> > forc[N];\nvector < pair <int, long long> > centroid[N];\nlong long dist[N];\nlong long last_dist[N];\nint sub[N];\nbool alive[N];\nvector < pair <int, int> > g[N];\nint perm[N], pos[N];\nint v_goes_to[N];\nvector <int> all;\nvector <int> in_forc[N];\n\nvoid dfs(int v, int pr) {\n  all.push_back(v);\n  sub[v] = 1;\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (!alive[u] || u == pr) {\n      continue;\n    }\n    int len = g[v][j].second;\n    dist[u] = dist[v] + len;\n    dfs(u, v);\n    sub[v] += sub[u];\n  }\n}\n\nvoid build(int v) {\n  all.clear();\n  dfs(v, -1);\n  {\n    // changing the root\n    int old_v = v;\n    int total = sub[v];\n    int pr = -1;\n    while (true) {\n      bool found = false;\n      int sz = g[v].size();\n      for (int j = 0; j < sz; j++) {\n        int u = g[v][j].first;\n        if (!alive[u] || u == pr) {\n          continue;\n        }\n        if (2 * sub[u] >= total) {\n          pr = v;\n          v = u;\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        break;\n      }\n    }\n    v_goes_to[old_v] = v;\n  }\n  all.clear();\n  dist[v] = 0;\n  dfs(v, -1);\n  int cnt = all.size();\n  for (int i = 0; i < cnt; i++) {\n    int u = all[i];\n    centroid[u].push_back(make_pair(v, dist[u]));\n  }\n  for (int i = 0; i < cnt; i++) {\n    int u = all[i];\n    forc[v].push_back(make_pair(pos[u], dist[u] - last_dist[u]));\n    last_dist[u] = dist[u];\n  }\n  sort(forc[v].begin(), forc[v].end());\n  for (int j = 1; j < cnt; j++) {\n    forc[v][j].second += forc[v][j - 1].second;\n  }\n  for (int i = 0; i < cnt; i++) {\n    int u = perm[forc[v][i].first];\n    in_forc[u].push_back(i);\n  }\n  vector <int> children;\n  for (int i = 0; i < (int) g[v].size(); i++) {\n    int u = g[v][i].first;\n    if (alive[u]) {\n      children.push_back(u);\n    }\n  }\n  alive[v] = false;\n  for (int i = 0; i < (int) children.size(); i++) {\n    build(children[i]);\n  }\n}\n\nint main() {\n  int n, tt;\n  scanf(""%d %d"", &n, &tt);\n  for (int i = 0; i < n; i++) {\n    scanf(""%d"", perm + i);\n    perm[i]--;\n    pos[perm[i]] = i;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int x, y, z;\n    scanf(""%d %d %d"", &x, &y, &z);\n    x--; y--;\n    g[x].push_back(make_pair(y, z));\n    g[y].push_back(make_pair(x, z));\n  }\n  for (int i = 0; i < n; i++) {\n    alive[i] = true;\n  }\n  build(0);\n  int last = 0;\n  while (tt--) {\n    int com;\n    scanf(""%d"", &com);\n    if (com == 1) {\n      int from, to, ver;\n      scanf(""%d %d %d"", &from, &to, &ver);\n      from ^= last;\n      to ^= last;\n      ver ^= last;\n      from--; to--; ver--;\n      long long ans = 0;\n      long long prev_d = 0;\n      for (pair <int, long long> p : centroid[ver]) {\n        int v = p.first;\n        long long d = p.second;\n        long long sumd = 0;\n        int cnt = 0;\n        {\n          int pf = lower_bound(forc[v].begin(), forc[v].end(), make_pair(from, -inf)) - forc[v].begin();\n          int pt = lower_bound(forc[v].begin(), forc[v].end(), make_pair(to + 1, -inf)) - forc[v].begin();\n          if (pf < pt) {\n            sumd += forc[v][pt - 1].second;\n            if (pf > 0) {\n              sumd -= forc[v][pf - 1].second;\n            }\n            cnt += pt - pf;\n          }\n        }\n        ans += sumd + cnt * (d - prev_d);\n        prev_d = d;\n      }\n      printf(""%I64d\\n"", ans);\n      last = ans & ((1 << 30) - 1);\n    } else {\n      int x;\n      scanf(""%d"", &x);\n      x ^= last;\n      x--;\n      int v1 = perm[x];\n      int v2 = perm[x + 1];\n      int c1 = centroid[v1].size();\n      int c2 = centroid[v2].size();\n      int i1 = 0;\n      int i2 = 0;\n      long long prev_d2 = 0;\n      while (i1 < c1 && i2 < c2 && centroid[v1][i1].first == centroid[v2][i2].first) {\n        int v = centroid[v1][i1].first;\n        long long d2 = centroid[v2][i2].second;\n        {\n          int at = in_forc[v1][i1];\n          forc[v][at].second = (at == 0 ? 0LL : forc[v][at - 1].second) + d2 - prev_d2;\n          swap(in_forc[v1][i1], in_forc[v2][i2]);\n        }\n        prev_d2 = d2;\n        i1++; i2++;\n      }\n      for (int rot = 0; rot < 2; rot++) {\n        while (i1 < c1) {\n          int v = centroid[v1][i1].first;\n          {\n            int at = in_forc[v1][i1];\n            forc[v][at].first = pos[v2];\n          }\n          i1++;\n        }\n        swap(v1, v2);\n        swap(c1, c2);\n        swap(i1, i2);\n      }\n      swap(perm[x], perm[x + 1]);\n      pos[perm[x]] = x;\n      pos[perm[x + 1]] = x + 1;\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3400
For a given sequence of non negative integers b 1 b 2 dots b k we determine if it is in the following way Consider a graph on k nodes with numbers from b 1 to b k written on them For every i from 1 to k find such j 1 le j le k j neq i for which b i oplus b j among all such j where oplus denotes the operation of bitwise XOR https en wikipedia org wiki Bitwise operation XOR Next draw an edge between vertices with numbers b i and b j in this graph We say that the sequence is if and only if the resulting graph forms a is connected and doesn t have any simple cycles It is possible that for some numbers b i and b j you will try to add the edge between them twice Nevertheless you will add this edge only once You can find an example below the picture corresponding to the first test case Sequence 0 1 5 2 6 good as we reach 1 from 5 However sequence 0 1 5 2 good You are given a sequence a 1 a 2 dots a n of non negative integers You would like to remove some of the elements possibly none to make the sequence good What is the minimum possible number of removals required to achieve this goal It can be shown that for any sequence we can remove some number of elements leaving at least 2 so that the remaining sequence is good ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int S = (int)7e6;\nconst int K = 30;\nint g[S][2];\nint n, m = 1;\nint ans = 1;\n\nvoid dfs(int v, int x) {\n\tif (g[v][0] == 0 && g[v][1] == 0) {\n\t\tans = max(ans, x);\n\t\treturn;\n\t}\n\tif (g[v][0] != 0 && g[v][1] != 0) x++;\n\tfor (int c = 0; c < 2; c++) {\n\t\tif (g[v][c] != 0)\n\t\t\tdfs(g[v][c], x);\n\t}\n} \n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tint v = 0;\n\t\tfor (int k = K - 1; k >= 0; k--) {\n\t\t\tint c = (x >> k) & 1;\n\t\t\tif (g[v][c] == 0) g[v][c] = m++;\n\t\t\tv = g[v][c];\n\t\t}\n\t}\n\tdfs(0, 1);\n\tprintf(""%d\\n"", n - ans);\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0]",2100
Yaroslav has an array consisting of distinct integers Also he has queries Query number is represented as a pair of integers The answer to the query is the number of pairs of integers such that is the divisor of Help Yaroslav answer all his queries ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n\nstruct Fen {\n\tint fen[200002];\n\tinline void upd(int x, int val) {\n\t\tfor (; x >= 0; x = (x & (x + 1)) - 1) fen[x] += val;\n\t}\n\tinline int sum(int x) {\n\t\tint ans = 0;\n\t\tfor (; x <= 200000; x |= x + 1) ans += fen[x];\n\t\treturn ans;\n\t}\n};\n\nint a,b,c,d,n,m,k;\nint mas[200002], inv[200002];\nint ans[200002];\nFen rt;\nint main() {\n\t//freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n\t\n\tscanf(""%d%d"", &n, &m);\n\trept(i, n) {\n\t\tscanf(""%d"", &mas[i]);\n\t\tinv[mas[i]] = i;\n\t}\n\t\n\tvector<pii> tot;\n\trep(i, n) {\n\t\tfor (int j = i; j <= n; j += i) {\n\t\t\ta = inv[i];\n\t\t\tb = inv[j];\n\t\t\tif (a > b) swap(a, b);\n\t\t\ttot.pb(mp(a, b));\n\t\t}\n\t}\n\n\tSORT(tot);\n\tvector<pair<pii, int> > quer;\n\trept(i, m) {\n\t\tscanf(""%d%d"", &a, &b); --a; --b;\n\t\tquer.pb(mp(mp(a, b), i));\n\t}\n\tSORT(quer);\n\n\ta = L(tot) - 1; b = 0;\n\tFORD(i, L(quer) - 1, 0) {\n\t\twhile (a >= 0 && tot[a].x >= quer[i].x.x) {\n\t\t\trt.upd(tot[a].y, 1);\n\t\t\t--a;\n\t\t\t++b;\n\t\t}\n\t\tint res = b - rt.sum(quer[i].x.y + 1);\n\t\tans[quer[i].y] = res;\n\t}\n\trept(i, m) {\n\t\tprintf(""%d\\n"", ans[i]);\n\t}\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
You are given a tree that has vertices which are numbered from to where the vertex number one is the root Each edge has weight and strength Botanist Innokentiy who is the only member of the jury of the Olympiad in Informatics doesn t like broken trees The tree is broken if there is such an edge the strength of which is less than the sum of weight of subtree s edges to which it leads It is allowed to reduce weight of any edge by arbitrary integer value but then the strength of its edge is reduced by the same value It means if the weight of the edge is and the strength is then by the reducing the weight by its weight will equal and the strength will equal It is not allowed to increase the weight of the edge Your task is to get the tree which is not broken by reducing the weight of edges of the given tree and also all edged should have the positive weight moreover the total weight of all edges should be as large as possible It is obvious that the strength of edges can not be negative however it can equal zero if the weight of the subtree equals zero ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\n#define fo(i, n) for(int i = 1; i <= n; ++i)\n#define rep(i, a, b) for(int (i) = (a); (i) < (b); ++(i))\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 200200;\nconst int mod = 1e9 + 7;\nconst ll INF = 1e18;\n\nll n, x, y, w, p, sum[N], sz[N];\n\nll can[N];\n\nstruct EDGE\n{\n\tll x, y, w, p;\n\tll mw, mp;\n} edge[N];\n\nvector<ll> g[N], we[N], pe[N];\n\ninline void calc(ll v, ll p = -1)\n{\n\tfor(ll i = 0 ; i < g[v].size() ; ++ i)\n\t{\n\t\tll id = g[v][i];\n\t\tll to = (edge[id].x == v ? edge[id].y : edge[id].x);\n\t\tif(to == p) continue;\n\t\tll weight = edge[id].w;\n\t\tll pr = edge[id].p;\n\t\tcalc(to, v);\n\t\tif(pr < can[to])\n\t\t{\n\t\t\tcout << -1;\n\t\t\texit(0);\n\t\t}\n\t\tll er = min(weight - 1, pr - can[to]);\n\t\tedge[id].w -= er;\n\t\tedge[id].p -= er;\n\t\tcan[v] += can[to] + edge[id].w;\n\t}\n}\n\ninline ll solve(int v, int p = -1, ll canadd = 2e18)\n{\n\tll ret = 0;\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tll id = g[v][i];\n\t\tll to = (edge[id].x == v ? edge[id].y : edge[id].x);\n\t\tif(to == p) continue;\n\t\tll weight = edge[id].w;\n\t\tll pr = edge[id].p;\n\t\tll er = edge[id].mw - edge[id].w;\n\t\tll cancuradd = min(canadd - ret, er);\n\t\tedge[id].w += cancuradd;\n\t\tedge[id].p += cancuradd;\n\t\tret += cancuradd;\n\t}\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tll id = g[v][i];\n\t\tll to = (edge[id].x == v ? edge[id].y : edge[id].x);\n\t\tif(to == p) continue;\n\t\tll weight = edge[id].w;\n\t\tll pr = edge[id].p;\n\t\tll mn = pr - can[to];\n\t\tret += solve(to, v, min(mn, canadd - ret));\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcin>>n;\n\tfor(ll i=1;i<n;++i)\n\t{\n\t\tcin>>x>>y>>w>>p;\n\t\tint id = i;\n\t\tg[x].pb(id);\n\t\tg[y].pb(id);\n\t\tedge[id].x = x;\n\t\tedge[id].y = y;\n\t\tedge[id].mp = p;\n\t\tedge[id].mw = w;\n\t\tedge[id].w = w;\n\t\tedge[id].p = p;\n\t}\n\tcalc(1);\n\tsolve(1);\n\tcout << n << ""\\n"";\n\tfor(ll i = 1; i < n; ++i)\n\t\tcout << edge[i].x << \' \' << edge[i].y << \' \' << edge[i].w << \' \' << edge[i].p << ""\\n"";\n\treturn 0;\t\n}                                      \t']","[1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2600
Greg has an array and operations Each operation looks as To apply operation to the array means to increase all array elements with numbers by value Greg wrote down queries on a piece of paper Each query has the following form That means that one should apply operations with numbers to the array Now Greg is wondering what the array will be after all the queries are executed Help Greg ,"['#include<algorithm>\n#include<cassert>\n#include<complex>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<queue>\n#include<set>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<cstring>\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define fup FOR\n#define fdo FORD\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define siz SZ\n#define CLR(x) memset((x), 0, sizeof(x))\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second \n#define FI X\n#define SE Y\n#define SQR(a) ((a)*(a))\n#define DEBUG 1\n#define debug(x) {if (DEBUG)cerr <<#x <<"" = "" <<x <<endl; }\n#define debugv(x) {if (DEBUG) {cerr <<#x <<"" = ""; FORE(it, (x)) cerr <<*it <<"", ""; cout <<endl; }}\nusing namespace std;\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int>P;\ntypedef vector<int>VI;\nconst int INF=1E9+7;\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\n#define MAXN 100007\n\nint n,m,k;\nint l[MAXN],r[MAXN],d[MAXN],x[MAXN],y[MAXN],a[MAXN];\nLL ile[MAXN], add[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(false);\n    cout << setprecision(15) << fixed;\n\t//in\n    cin >> n >> m >> k;\n    FOR(i,1,n) cin >> a[i];\n    FOR(i,1,m) cin >> l[i] >> r[i] >> d[i];\n    FOR(i,1,k) cin >> x[i] >> y[i];\n\t//sol\n    FOR(i,1,k)\n        ile[x[i]]++, ile[y[i]+1]--;\n    FOR(i,1,m) {\n        ile[i] += ile[i-1];\n        add[l[i]] += ile[i] * d[i];\n        add[r[i]+1] -= ile[i] * d[i];\n    }\n\t//out\n    FOR(i,1,n) {\n        add[i] += add[i-1];\n        cout << a[i] + add[i] << "" "" ;\n    }\n    cout << endl;\n\treturn 0;\n}\n\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
In this task you have to write a program dealing with nonograms on fields no larger than Simplified nonogram is a task where you have to build such field each cell is either white or black that satisfies the given information about rows and columns For each row and each column the number of contiguous black segments is specified For example if size of the field is nd numbers of contiguous black segments in rows are and in columns are then the solution may look like It is guaranteed that on each test in the testset there exists at least one solution ,"['#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nset<long long> seen;\n\nvoid display(vector<vector<bool>> potsol)\n{\n    if (potsol.size() > 0)\n    {\n        for (int i = 0; i < potsol[0].size(); ++i)\n        {\n            for (int j = 0; j < potsol.size(); ++j)\n            {\n                cout << ((potsol[j][i]) ? ""*"" : ""."");\n            }\n            cout << endl;\n        }\n        cout << endl;\n    }\n    else\n    {\n        cout << ""Empty"" << endl << endl;\n    }\n}\n\nvector<vector<bool>> possibles(int x, int n)\n{\n    vector<vector<bool>> ret;\n    for (int i = 0; i < (1 << n); ++i)\n    {\n        int y = i;\n        int cnt = 0;\n        bool on = false;\n        vector<bool> p;\n        for (int j = 0; j < n; ++j)\n        {\n            if (y&1)\n            {\n                if (!on)\n                {\n                    ++cnt;\n                }\n                on = true;\n            }\n            else\n            {\n                on = false;\n            }\n            p.push_back(y&1);\n            y>>=1;\n        }\n        if (cnt == x)\n        {\n            ret.push_back(p);\n        }\n    }\n    return ret;\n}\n\nbool dfs(vector<vector<bool>> &potsol, vector<int> &cnts, vector<bool> &ons, vector<int> &a, vector<vector<vector<bool>>> &ps)\n{\n    if (potsol.size() == ps.size())\n    {\n        for (int i = 0; i < a.size(); ++i)\n        {\n            if (cnts[i] != a[i])\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    else\n    {\n        long long hash = potsol.size();\n        for (int i = 0; i < a.size(); ++i)\n        {\n            hash = 32*hash + cnts[i];\n        }\n        for (int i = 0; i < a.size(); ++i)\n        {\n            hash = 2*hash+ons[i];\n        }\n        if (seen.find(hash) != seen.end())\n        {\n            return false;\n        }\n        seen.insert(hash);\n        for (int i = 0; i < a.size(); ++i)\n        {\n            if (cnts[i] > a[i])\n            {\n                return false;\n            }\n            if ((a[i] - cnts[i]) > (((ps.size() - potsol.size()) + 1)/2))\n            {\n                return false;\n            }\n        }\n        \n        for (int i = ps[potsol.size()].size()-1; i >= 0; --i)\n        {\n            vector<vector<bool>> pst = potsol;\n            vector<int> ct = cnts;\n            vector<bool> ot = ons;\n            potsol.push_back(ps[potsol.size()][i]);\n            for (int j = 0; j < a.size(); ++j)\n            {\n                if (potsol.back()[j])\n                {\n                    if (!ons[j])\n                    {\n                        ++cnts[j];\n                    }\n                    ons[j] = true;\n                }\n                else\n                {\n                    ons[j] = false;\n                }\n            }\n            if (dfs(potsol,cnts,ons,a,ps))\n            {\n                return true;\n            }\n            else\n            {\n                potsol = pst;\n                cnts = ct;\n                ons = ot;\n            }\n        }\n        return false;\n    }\n}\n\nint main(int argc, const char * argv[])\n{\n    int m,n;\n    cin >> n >> m;\n    vector<int> a(n,0);\n    vector<int> b(m,0);\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> a[i];\n    }\n    for (int i = 0; i < m; ++i)\n    {\n        cin >> b[i];\n    }\n    \n    vector<vector<vector<bool>>> ps;\n    for (int i = 0; i < m; ++i)\n    {\n        ps.push_back(possibles(b[i], n));\n    }\n    vector<vector<bool>> potsol;\n    vector<int> cnts(a.size(),0);\n    vector<bool> ons(a.size(), false);\n    dfs(potsol,cnts,ons,a,ps);\n    display(potsol);\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2400
One day Vasya was going home when he saw a box lying on the road The box can be represented as a rectangular parallelepiped Vasya needed no time to realize that the box is special as all its edges are parallel to the coordinate axes one of its vertices is at point and the opposite one is at point The six faces of the box contain some numbers exactly one number right in the center of each face The numbers are located on the box like that number is written on the face that lies on the ZOX plane is written on the face parallel to the plane from the previous point is written on the face that lies on the XOY plane is written on the face parallel to the plane from the previous point is written on the face that lies on the YOZ plane is written on the face parallel to the plane from the previous point At the moment Vasya is looking at the box from point Find the sum of numbers that Vasya sees Note that all faces of the box are not transparent and Vasya can t see the numbers through the box The picture contains transparent faces just to make it easier to perceive You can consider that if Vasya is looking from point lying on the plane of some face than he can not see the number that is written on this face It is enough to see the center of a face to see the corresponding number for Vasya Also note that Vasya always reads correctly the numbers that he sees independently of their rotation angle and other factors that is for example if Vasya sees some then he can t mistake this number for and so on ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <ctime>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-10;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define all(a) a.begin(),a.end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SS stringstream\n#define DBG1(a) rep(_X,sz(a)){printf(""%d "",a[_X]);}puts("""");\n#define DBG2(a) rep(_X,sz(a)){rep(_Y,sz(a[_X]))printf(""%d "",a[_X][_Y]);puts("""");}\n#define bitcount(b) __builtin_popcount(b)\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n\n#define delete(a,n) a.erase(remove(all(a),n),a.end())\ntemplate<typename T, typename S> vector<T>& operator<<(vector<T>& a, S b) { a.push_back(b); return a; }\ntemplate<typename T> void operator>>(vector<T>& a, int b) {while(b--)if(!a.empty())a.pop_back();}\nbool isprime(int n){ if(n<2)return false;  for(int i=2;i*i<=n;i++)if(n%i==0)return false;  return true;} \nll b_pow(ll x,ll n){return n ? b_pow(x*x,n/2)*(n%2?x:1) : 1ll;}\nstring itos(int n){stringstream ss;ss << n;return ss.str();}\n\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    ll x,y,z;\n    cin >> x >> y >> z;\n    ll x1,y1,z1;\n    cin >> x1 >> y1 >> z1;\n    ll v1,v2,v3,v4,v5,v6;\n    cin >> v1 >> v2 >> v3 >> v4 >> v5 >> v6;\n    ll c1,c2,c3,c4,c5,c6;\n    c1 = c2 = c3 = c4 = c5 = c6 = 1;\n    \n    if( x > x1 ) c6 = 1 , c5 = 0;\n    else if( x < 0 ) c6 = 0 , c5 = 1;\n    else c6 = 0 , c5 = 0;\n    \n    if( y > y1 ) c2 = 1 , c1 = 0;\n    else if( y < 0 ) c2 = 0 , c1 = 1;\n    else c2 = 0 , c1 = 0;\n    \n    if( z > z1 ) c4 = 1 , c3 = 0;\n    else if( z < 0 ) c4 = 0 , c3 = 1;\n    else c4 = 0 , c3 = 0;\n    \n    cout << c1 * v1 + c2 * v2 + c3 * v3 + c4 * v4 + c5 * v5 + c6 * v6 << endl;\n    \n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1600
It is known that fleas in Berland can jump only vertically and horizontally and the length of the jump is always equal to centimeters A flea has found herself at the center of some cell of the checked board of the size centimeters each cell is centimeters She can jump as she wishes for an arbitrary number of times she can even visit a cell more than once The only restriction is that she cannot jump out of the board The flea can count the amount of cells that she can reach from the starting position Let s denote this amount by Your task is to find the number of such starting positions which have the maximum possible value of ,"['#include <cstdio>\n\nunsigned __int64 n, m, s, d;\n\nvoid main() {\n\tscanf(""%I64u%I64u%I64u"", &n, &m, &s), --n, --m;\n\tprintf(""%I64u\\n"", ((n / s) + 1) * ((m / s) + 1) * ((n % s) + 1) * ((m % s) + 1));\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
The start of the new academic year brought about the problem of accommodation students into dormitories One of such dormitories has a square meter wonder room The caretaker wants to accommodate exactly students there But the law says that there must be at least 6 square meters per student in a room that is the room for students must have the area of at least square meters The caretaker can enlarge any possibly both side of the room by an arbitrary positive integer of meters Help him change the room so as all students could live in it and the total area of the room was as small as possible ,"['#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define MAXN 100005\n#define INF 0x7fffffffffffffffLL\nusing namespace std ;\ntypedef long long LL ;\n\nLL A, B, N, sq ;\nLL ta, tb, ba, bb, ans = INF ;\n\nint main()\n{\n\tint i, j ;\n\tscanf(""%I64d %I64d %I64d"", &N, &A, &B) ;\n\tN *= 6,\tsq = sqrt(N)+3 ;\n\tfor(ta = A; ta <= max(A, sq); ta ++)\n\t{\n\t\ttb = max(B, N/ta+(N%ta!=0)) ;\n\t\tif(ta*tb < ans) ans = ta*tb, ba = ta, bb = tb ;\n\t}\n\tfor(tb = B; tb <= max(B, sq); tb ++)\n\t{\n\t\tta = max(A, N/tb+(N%tb!=0)) ;\n\t\tif(ta*tb < ans) ans = ta*tb, ba = ta, bb = tb ;\n\t}\n\tprintf(""%I64d\\n%I64d %I64d\\n"", ans, ba, bb) ;\n\t//system(""pause"") ;\n\treturn 0 ;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Capitalization is writing a word with its first letter as a capital letter Your task is to capitalize the given word Note that during capitalization all the letters except the first one remains unchanged ,"['#include<iostream>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<string>\n#include<cstring>\n#include<map>\n#include<numeric>\n#include<sstream>\n#include<cmath>\nusing namespace std;\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pb push_back\n#define f(i,x,y) for(int i = x; i<y; i++ )\n#define FORV(it,A) for(vector<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define FORS(it,A) for(set<int>::iterator it = A.begin(); it!= A.end(); it++)\n#define quad(x) (x) * (x)\n#define mp make_pair\n#define clr(x, y) memset(x, y, sizeof x)\n#define fst first\n#define snd second\n#define eps 1e-7\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\n\nint main() {\n\tchar a[1500];\n\tscanf("" %s"", a);\n\tif (a[0] >= \'a\' && a[0] <= \'z\') a[0] = a[0]-\'a\'+\'A\';\n\tprintf(""%s\\n"", a); \n\n\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
You have 2n integers 1 2 dots 2n You have to redistribute these 2n elements into n pairs After that you choose x pairs and take minimum elements from them and from the other n x pairs you take maximum elements Your goal is to obtain the set of numbers b 1 b 2 dots b n as the result of taking elements from the pairs What is the number of different x s 0 le x le n such that it s possible to obtain the set b if for each x you can choose how to distribute numbers into pairs and from which x pairs choose minimum elements ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target (""sse4"")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> b(n);\n\trep(i, n) {\n\t\tcin >> b[i]; b[i]--;\n\t}\n\tvector<bool> exi(2 * n);\n\trep(i, n)exi[b[i]] = true;\n\t//[0,2n)\n\tauto canl = [&](int num)->bool {\n\t\tif (num == 0)return true;\n\t\tint sup = b[num - 1];\n\t\tint c = 0;\n\t\tper(i, 2 * n) {\n\t\t\tif (exi[i]) {\n\t\t\t\tif (i <= sup) {\n\t\t\t\t\tif (c == 0)return false;\n\t\t\t\t\tc--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tauto canr = [&](int num)->bool {\n\t\tif (num == 0)return true;\n\t\tint inf = b[n - num];\n\t\tint c = 0;\n\t\trep(i, 2 * n) {\n\t\t\tif (exi[i]) {\n\t\t\t\tif (i >= inf) {\n\t\t\t\t\tif (c == 0)return false;\n\t\t\t\t\tc--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tint l1 = -1, r1 = n + 1;\n\twhile (r1 - l1 > 1) {\n\t\tint m = (l1 + r1) / 2;\n\t\tif (canl(m)) {\n\t\t\tl1 = m;\n\t\t}\n\t\telse {\n\t\t\tr1 = m;\n\t\t}\n\t}\n\tint l2 = -1, r2 = n + 1;\n\twhile (r2 - l2 > 1) {\n\t\tint m = (l2 + r2) / 2;\n\t\tif (canr(m)) {\n\t\t\tl2 = m;\n\t\t}\n\t\telse {\n\t\t\tr2 = m;\n\t\t}\n\t}\n\t//cout << l1 << "" "" << l2 << ""\\n"";\n\tint ans = l1-(n - l2)+ 1; if (ans < 0)ans = 0;\n\tcout << ans << ""\\n"";\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1900
The USA Construction Operation USACO recently ordered Farmer John to arrange of n haybale piles on the farm The i th pile contains a i haybales However Farmer John has just left for vacation leaving Bessie all on her own Every day Bessie the naughty cow can choose to move one haybale in any pile to an adjacent pile Formally in one day she can choose any two indices i and j 1 le i j le n such that i j 1 and a i 0 and apply a i a i 1 a j a j 1 She may also decide to not do anything on some days because she is lazy Bessie wants to maximize the number of haybales in pile 1 i e to maximize a 1 and she only has d days to do so before Farmer John returns Help her find the maximum number of haybales that may be in pile 1 if she acts optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=110;\nint n,d,a[N],_;\n\nvoid solve() {\n\tscanf(""%d%d"",&n,&d);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\trep(i,2,n+1) {\n\t\twhile (a[i]>0&&d>=i-1) {\n\t\t\ta[1]++; a[i]--;\n\t\t\td-=i-1;\n\t\t}\n\t}\n\tprintf(""%d\\n"",a[1]);\n}\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tsolve();\n\t}\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Creatnx has n mirrors numbered from 1 to n Every day Creatnx asks exactly one mirror Am I beautiful The i th mirror will tell Creatnx that he is beautiful with probability frac p i 100 for all 1 le i le n Initially only the 1st mirror is a checkpoint It remains a checkpoint all the time Creatnx asks the mirrors one by one starting from the 1 st mirror Every day if he asks i th mirror there are two possibilities The i th mirror tells Creatnx that he is beautiful In this case if i n Creatnx will stop and become happy otherwise he will continue asking the i 1 th mirror next day In the other case Creatnx will feel upset The next day Creatnx will start asking You are given q queries each query is represented by an integer u If the u th mirror isn t a checkpoint then we set it as a checkpoint Otherwise the u th mirror is no longer a checkpoint After each query you need to calculate the expected number of days until Creatnx becomes happy Each of this numbers should be found by modulo 998244353 Formally let M 998244353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353 ;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\n\nint n,q,p,u;\nset<int> hs;\nll f[N],mf[N],imf[N],smf[N],ans;\n\nll query(int l,int r) {\n\treturn (smf[l]-smf[r+1])*imf[r+1]%mod;\n}\n\nint main() {\n\tscanf(""%d%d"",&n,&q);\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",&p);\n\t\tf[i]=100*powmod(p,mod-2)%mod;\n\t}\n\tmf[n+1]=1;\n\timf[n+1]=1;\n\tper(i,1,n+1) {\n\t\tmf[i]=f[i]*mf[i+1]%mod;\n\t\timf[i]=powmod(mf[i],mod-2);\n\t\tsmf[i]=(smf[i+1]+mf[i])%mod;\n\t}\n\ths.insert(1);\n\ths.insert(n+1);\n\tans=query(1,n);\n\trep(i,0,q) {\n\t\tscanf(""%d"",&u);\n\t\tif (hs.count(u)) {\n\t\t\tauto it=hs.find(u);\n\t\t\tauto pit=it,qit=it;\n\t\t\tpit--; qit++;\n\t\t\tans-=query(*pit,*it-1);\n\t\t\tans-=query(*it,*qit-1);\n\t\t\tans+=query(*pit,*qit-1);\n\t\t\ths.erase(u);\n\t\t} else {\n\t\t\ths.insert(u);\n\t\t\tauto it=hs.find(u);\n\t\t\tauto pit=it,qit=it;\n\t\t\tpit--; qit++;\n\t\t\tans+=query(*pit,*it-1);\n\t\t\tans+=query(*it,*qit-1);\n\t\t\tans-=query(*pit,*qit-1);\n\t\t}\n\t\tans%=mod;\n\t\tif (ans<0) ans+=mod;\n\t\tprintf(""%lld\\n"",ans);\n\t}\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
Let s call a string if it is symmetric about the middle of the string For example the string is but the string is not The string is not because the second half of it is not a mirror reflection of the first half You are given a string Check if the string is ,"['/*\nI\'ve used hammers made out of wood\nI have played games with pieces and rules\nI undeciphered tricks at the bar\nBut now you\'re gone, I haven\'t figured out why\nI\'ve come up with riddles and jokes about war\nI\'ve figured out numbers and what they\'re for\nI\'ve understood feelings and I\'ve understood words\nBut how could you be taken away?\n\nAnd wherever you\'ve gone\nAnd wherever we might go\nIt don\'t seem fair...\nToday just disappeared.\nYour light\'s reflected now, reflected from afar\nWe were but stones, your light made us stars.\n\nWith heavy breath, awakened regrets\nBack pages and days alone that could have been spent, together...\nBut we were miles apart.\nEvery inch between us becomes light years now\nNo time to be void or save up on life\nYou got to spend it all...\n\nAnd wherever you\'ve gone\nAnd wherever we might go\nIt don\'t seem fair...\nYou seem to like it here\nYour light\'s reflected now, reflected from afar\nWe were but stones, your light made us stars.\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n\n#define eps 1e-9\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 350\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int N = 1000031;\n\nchar w[1000];\nstring st;\n\nint main(){\n\t//freopen(""fabro.in"",""r"",stdin);\n\t//freopen(""fabro.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"", ""r"", stdin);\n\t//freopen(""F:/output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tfor (int i = 0; i <= 500; i++)\n\t\tw[i] = \'.\';\n\n\tw[\'A\'] = \'A\';\n\tw[\'H\'] = \'H\';\n\tw[\'I\'] = \'I\';\n\tw[\'M\'] = \'M\';\n\tw[\'O\'] = \'O\';\n\tw[\'o\'] = \'o\';\n\tw[\'T\'] = \'T\';\n\tw[\'U\'] = \'U\';\n\tw[\'V\'] = \'V\';\n\tw[\'v\'] = \'v\';\n\tw[\'W\'] = \'W\';\n\tw[\'w\'] = \'w\';\n\tw[\'X\'] = \'X\';\n\tw[\'x\'] = \'x\';\n\tw[\'Y\'] = \'Y\';\n\t\n\tw[\'b\'] = \'d\';\n\tw[\'d\'] = \'b\';\n\n\tw[\'p\'] = \'q\';\n\tw[\'q\'] = \'p\';\n\n\tcin >> st;\n\tstring memo = st;\n\tfor (int i = 0; i < st.size(); i++)\n\t{\n\t\tst[i] = w[st[i]];\n\t}\n\t\n\treverse(st.begin(), st.end());\n\tif (st == memo)\n\t\tcout << ""TAK"";\n\telse\n\t\tcout << ""NIE"";\n\n\tcin.get(); cin.get();\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1600
You are given two positive integers n 1 le n le 10 9 and k 1 le k le 100 Represent the number n as the sum of k positive integers of the same parity have the same remainder when divided by 2 In other words find a 1 a 2 ldots a k such that all a i 0 n a 1 a 2 ldots a k and either all a i are even or all a i are odd at the same time If such a representation does not exist then report it ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(1e9, 2e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n    void solve () {\n       \n       \n         /* --------- */\n       \n    int a,k;\n    cin>>a>>k;\n    if (a%2==0 && a>=2*k) { cout<<""YES\\n""; \n        for (int i=1;i<=k-1;i++) cout<<""2 ""; cout<<a+2-2*k<<""\\n""; return; \n    }\n    if (a%2==k%2 && a>=k) {\n        cout<<""YES\\n""; \n        for (int i=1;i<=k-1;i++) cout<<""1 ""; cout<<a+1-k<<""\\n""; return; \n    }\n    cout<<""NO\\n""; \n         /* --------- */   \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(false);\n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n       \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Little Maxim loves interesting problems He decided to share one such problem with you Initially there is an array consisting of zeroes The elements of the array are indexed starting from 1 Then follow queries to change array Each query is characterized by two integers In the answer to the query we should make the th array element equal Maxim thinks that some pairs of integers are good and some are not Maxim thinks that array consisting of integers is lucky if for all integer the pair of integers is good Note that the order of numbers in the pairs is important that is specifically After each query to change array Maxim wants to know how many ways there are to replace all zeroes in array with integers from one to three so as to make the resulting array without zeroes lucky Of course distinct zeroes can be replaced by distinct integers Maxim told you the sequence of queries and all pairs of integers he considers lucky Help Maxim solve this problem for him ,"['/*\n * cd2.cpp\n *\n *  Created on: 2012-12-17\n *      Author: mac\n */\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\n#define REP(i,n) for(int i=0;i<n;++i)\nusing namespace std;\nconst int MAX_N = 77777 + 10;\nconst int MOD = 777777777;\n\nint n, nQ;\nint w[3][3];\n\ntypedef long long int64;\n\nstruct Tree {\n\tint c[3][3];\n\tTree*pl, *pr;\n\tint l, r;\n\n\tvoid update() {\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\tint64 k = 0;\n\t\t\t\tfor (int pi = 0; pi < 3; ++pi) {\n\t\t\t\t\tfor (int pj = 0; pj < 3; ++pj)\n\t\t\t\t\t\tif (w[pi][pj]) {\n\t\t\t\t\t\t\tk += 1LL * pl->c[i][pi] * pr->c[pj][j];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc[i][j] = k % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tTree(int l, int r) :\n\t\t\tl(l), r(r) {\n\t\tmemset(c, 0, sizeof c);\n\t\tif (l + 1 == r) {\n\t\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\t\tc[i][i] = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpl = new Tree(l, l + r >> 1);\n\t\tpr = new Tree(l + r >> 1, r);\n\t\tupdate();\n\t}\n\n\tvoid change(int i, int x) {\n\t\tif (i < l || i >= r)\n\t\t\treturn;\n\t\tif (l + 1 == r) {\n\t\t\tif (x == 0) {\n\t\t\t\tmemset(c, 0, sizeof c);\n\t\t\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\t\t\tc[j][j] = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmemset(c, 0, sizeof c);\n\t\t\t\tc[x - 1][x - 1] = 1;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tpl->change(i, x);\n\t\tpr->change(i, x);\n\t\tupdate();\n\t}\n}*root;\n\nint main() {\n\tcin >> n >> nQ;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tcin >> w[i][j];\n\t\t}\n\t}\n\troot = new Tree(0, n);\n\tfor (int i = 0; i < nQ; ++i) {\n\t\tint a, x;\n\t\tscanf(""%d%d"", &a, &x);\n\t\t--a;\n\t\troot->change(a, x);\n\t\tint ans = 0;\n\t\tfor (int j = 0; j < 3; ++j) {\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tans += root->c[j][k];\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
Alyona has a tree with vertices The root of the tree is the vertex In each vertex Alyona wrote an positive integer in the vertex she wrote Moreover the girl wrote a positive integer to every edge of the tree possibly different integers on different edges Let s define as the sum of the integers written on the edges of the simple path from to The vertex controls the vertex if and only if is in the subtree of and Alyona wants to settle in some vertex In order to do this she wants to know for each vertex what is the number of vertices such that controls ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=201000;\nint n,a[N],p,w,sta[N],fg[N];\nvector<PII> s[N];\nll dis[N];\nvoid dfs(int u,ll d,int f) {\n\tsta[f]=u; dis[f]=d;\n\tint l=lower_bound(dis,dis+f+1,d-a[u])-dis-1;\n\tfg[sta[l]]--; fg[u]++;\n\tfor (auto v:s[u]) {\n\t\tdfs(v.fi,d+v.se,f+1);\n\t\tfg[u]+=fg[v.fi];\n\t}\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\trep(i,2,n+1) {\n\t\tscanf(""%d%d"",&p,&w);\n\t\ts[p].pb(mp(i,w));\n\t}\n\tdis[0]=-1ll<<60;\n\tdfs(1,0,1);\n\trep(i,1,n+1) printf(""%d "",fg[i]-1);\n\tputs("""");\n}\n']","[0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1900
A tree is a connected undirected graph consisting of vertices and edges Vertices are numbered through Limak is a little polar bear and Radewoosh is his evil enemy Limak once had a tree but Radewoosh stolen it Bear is very sad now because he doesn t remember much about the tree he can tell you only three values and The tree had exactly vertices The tree had diameter In other words was the biggest distance between two vertices Limak also remembers that he once rooted the tree in vertex and after that its height was In other words was the biggest distance between vertex and some other vertex The distance between two vertices of the tree is the number of edges on the simple path between them Help Limak to restore his tree Check whether there exists a tree satisfying the given conditions Find any such tree and print its edges in any order It s also possible that Limak made a mistake and there is no suitable tree in this case print ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <cassert>\n#include <vector>\n#define all(x) x.begin() , x.end()\n#define fi first\n#define se second\n#define pb push_back\n#define umax( x , y ) x = max( x , (y) )\n#define umin( x , y ) x = min( x , (y) )\n#define For( i , a ) for(int i=1;i<=a;i++)\n#define ort (((b+s) < 0 )? (b+s)/2-1:(b+s)/2)\n#define y2 asrwjaelkf\n#define y1 asseopirwjaelkf\n\nusing namespace std;\n\ninline int read() {\n\tint res = 0 ;int neg ;\n\twhile(true){char ch = getchar();if(ch>=\'0\' && ch<=\'9\' || ch==\'-\'){if(ch==\'-\') neg = -1;else neg = 1 , res = ch-\'0\';break;} }\n\twhile(true){char ch = getchar();if(ch>=\'0\' && ch<=\'9\') res*=10 , res+=ch-\'0\';else break;}\n\treturn res*neg;\n}\n\ntypedef long long Lint;\ntypedef double db;\ntypedef pair<int,int> ii;\ntypedef pair<int,ii> iii;\n\nconst int maxn = 1000020;\nconst int MOd = 1e9+7;\n\nint a, d, h;\nint ar[maxn], t[maxn];\n\nint main() {\n\t\n\tscanf(""%d %d %d"",&a,&d,&h);\n\t\n\tif( a == 2 && d == 1 && h == 1 ) {\n\t\tprintf(""1 2\\n"");\n\t\treturn 0;\n\t}\n\t\n\tif( d > h + h ) {\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tif( d < h ) {\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tint bag = 1;\n\tif( d == h ) {\n\t\tif( d < 2 ) {\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn 0;\n\t\t}\n\t\tbag = 2;\n\t}\n\tint n = 1;\n\tint back = 1;\n\tfor(int i=1;i<=h;i++) {\n\t\tprintf(""%d %d\\n"",back,++n);\n\t\tback = n;\n\t}\n\tback = 1;\n\tfor(int i=1;i<=d-h;i++) {\n\t\tprintf(""%d %d\\n"",back,++n);\n\t\tback = n;\n\t}\n\t\n\twhile( n < a ) {\n\t\tprintf(""%d %d\\n"",bag,++n);\n\t}\n\t\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Limak a bear isn t good at handling queries So he asks you to do it We say that powers of numbers are Other numbers are You are given a sequence of good integers Your task is to handle queries of three types print in a separate line for set to It s guaranteed that is a good number for increase by After this repeat the process while at least one is bad You can note that after each query all are good ,"['#include <bits/stdc++.h>\n\n#define fo(i,a,b) for (int i = (a); i < (b); i++)\n#define sz(v) int(v.size())\n\nusing namespace std;\n\ntypedef long long ll;\n#define inf ll(1e18)\n\ntypedef pair<ll,int> dstwt;\ndstwt dinf = dstwt(inf, -1);\n\nvector<ll> pws = {1, 42, 1764, 74088, 3111696, 130691232, 5489031744, 230539333248, 9682651996416, 406671383849472, 17080198121677824, 717368321110468608};\n\ndstwt recompd(dstwt a) {\n    while (a.first < 0) {\n        int pi = a.second;\n        ll nd = pws[pi+1] - pws[pi];\n        a.first += nd;\n        a.second++;\n    }\n    return a;\n}\n\nstruct stb {\n    // upds\n    // 1) a[i] = d,np\n    // 2) a[i].d -= x\n    // and: go to ranges of constant np where d < 0\n\n    struct nd {\n        dstwt mnd, smnd; \n        ll add;\n        dstwt set;\n        bool lset;\n\n        nd(dstwt a = dinf) {\n            mnd = a;\n            smnd = dinf;\n            add = 0; \n            lset = true;\n            set = a;\n        }\n    };\n\n    nd rt[400005];\n\n    void apply(int i, int op, dstwt x) {\n        nd &r = rt[i];\n        if (op == 1) {\n            ll y = x.first;\n            // add y\n            r.mnd.first -= y;\n            if (r.smnd != dinf) r.smnd.first -= y;\n            if (r.lset) r.set.first -= y;\n            else r.add += y;\n        } else if (op == 2) {\n            // set to x\n            r.mnd = x;\n            r.smnd = dinf;\n            r.add = 0;\n            r.lset = true;\n            r.set = x;\n        }\n    }\n\n    void merge(int i) {\n        nd &p = rt[i];\n        const nd &l = rt[2*i+1]; \n        const nd &r = rt[2*i+2];\n\n        p.mnd = min(l.mnd, r.mnd);\n        p.smnd = min(l.mnd == p.mnd ? l.smnd : l.mnd, r.mnd == p.mnd ? r.smnd : r.mnd);\n        p.add = 0;\n        p.lset = false;\n    }\n\n    void push(int i) {\n        const nd &r = rt[i];\n        if (r.lset) {\n            apply(2*i+1, 2, r.set);\n            apply(2*i+2, 2, r.set);\n        } else if (r.add) {\n            apply(2*i+1, 1, dstwt(r.add,0));\n            apply(2*i+2, 1, dstwt(r.add,0));\n        }\n        merge(i);\n    }\n\n    void upd(int i, int nl, int nr, int ql, int qr, int op, dstwt x) {\n        if (nl == ql && nr == qr) apply(i, op, x);\n        else {\n            push(i);\n            int nmd = (nl+nr)/2;\n            if (ql < nmd) upd(2*i+1, nl, nmd, ql, min(qr, nmd), op, x);\n            if (qr > nmd) upd(2*i+2, nmd, nr, max(ql, nmd), qr, op, x);\n            merge(i);\n        }\n    }\n\n    void recomp(int i, int nl, int nr) {\n        if (rt[i].mnd.first >= 0) return;\n        else if (rt[i].smnd == dinf) {\n            rt[i].mnd = recompd(rt[i].mnd);\n            rt[i].smnd = dinf;\n            rt[i].add = 0;\n            rt[i].lset = true;\n            rt[i].set = rt[i].mnd;\n        } else {\n            push(i);\n            int nmd = (nl+nr)/2;\n            recomp(2*i+1, nl, nmd);\n            recomp(2*i+2, nmd, nr);\n            merge(i);\n        }\n    }\n\n    ll qu(int i, int nl, int nr, int qi) {\n        if (rt[i].lset) return pws[rt[i].set.second] - rt[i].set.first;\n        push(i);\n        int nmd = (nl+nr)/2;\n        if (qi < nmd) return qu(2*i+1, nl, nmd, qi);\n        else return qu(2*i+2, nmd, nr, qi);\n    }\n\n    void set(int n, int ql, int qr, ll x) {\n        dstwt ux = recompd({1-x,0});\n        upd(0, 0, n, ql, qr, 2, ux);\n    }\n\n    void add(int n, int ql, int qr, ll x) {\n        dstwt ux(x,-1);\n        while (true) {\n            upd(0, 0, n, ql, qr, 1, ux);\n            recomp(0, 0, n);\n            if (rt[0].mnd.first > 0) break;\n            assert(rt[0].mnd.first == 0);\n        }\n    }\n\n    void init(int i, int nl, int nr, ll *v) {\n        if (nl+1 == nr) {\n            rt[i] = recompd({1-v[nl],0});\n        } else {\n            int nmd = (nl + nr) / 2;\n            init(2*i+1, nl, nmd, v);\n            init(2*i+2, nmd, nr, v);\n            merge(i);\n        }\n    }\n};\n\nstb s;\nll a[200005];\nint n, q;\n\nint main() {\n    scanf(""%d %d"", &n, &q);\n    fo(i,0,n) scanf(""%lld"", a+i);\n    s.init(0, 0, n, a);\n    fo(_,0,q) {\n        int qt;\n        scanf(""%d"", &qt);\n        if (qt == 1) {\n            int qi; scanf(""%d"", &qi); qi--;\n            printf(""%lld\\n"", s.qu(0, 0, n, qi));\n        } else {\n            int ql, qr;\n            ll x;\n            scanf(""%d %d %lld"", &ql, &qr, &x); ql--;\n            if (qt == 2) s.set(n, ql, qr, x);\n            else s.add(n, ql, qr, x);\n        }\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3100
Nauuo is a girl who loves playing games related to portals One day she was playing a game as follows In an n times n grid the rows are numbered from 1 to n from top to bottom the columns are numbered from 1 to n from left to right We denote a cell on the intersection of the r th row and c th column as r c A portal is doors You can travel from one of them to another without changing your direction More formally if you a cell with a door you will teleport to the cell with the other door of the same portal and then the facing the original direction There be more than one doors in a single cell The is the nearest cell in the direction you are facing For example if you are facing bottom the of 2 5 is 3 5 If you a cell without a door you must the after that without changing the direction If the does not exist you must exit the grid You have to set some possibly zero portals in the grid so that if you i 1 facing right you will eventually exit the grid from r i n if you 1 i facing bottom you will exit the grid from n c i It is guaranteed that both r 1 n and c 1 n are of n elements A permutation of n elements is a sequence of numbers p 1 p 2 ldots p n in which every integer from 1 to n appears exactly once She got confused while playing the game can you help her to find a solution ,"['#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#define maxn 1005\n#define sq 355\n#define ll long long\n#define ld double\n#define mod 998244353\nusing namespace std;\nint r[maxn], c[maxn];\nint cnt;\nint os[maxn][4];\nvoid push(int a, int b, int c, int d)\n{\n\tos[cnt][0] = a, \n\tos[cnt][1] = b;\n\tos[cnt][2] = c;\n\tos[cnt][3] = d;\n\tcnt++;\n}\nvoid work(int n)\n{\n\tif(n == 0) return;\n\tif(r[n] == n && c[n] == n) work(n - 1);\n\telse\n\t{\n\t\tfor(int j = 1; j <= n - 1; j++)\n\t\t\tif(r[j] == n) r[j] = r[n];\n\t\tfor(int j = 1; j <= n - 1; j++)\n\t\t\tif(c[j] == n) c[j] = c[n];\n\t\twork(n - 1);\n\t\tpush(r[n], n, n, c[n]);\t\n\t} \n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &r[i]);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &c[i]);\n\twork(n);\n\tcout<<cnt<<endl;\n\tfor(int i = 0; i < cnt; i++)\n\t\tprintf(""%d %d %d %d\\n"", os[i][0], os[i][1], os[i][2], os[i][3]);\n\treturn 0;\n} \n/*\n2 1 1 5\n\n \n*/']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2900
Vasiliy likes to rest after a hard work so you may often meet him in some bar nearby As all programmers do he loves the famous drink which can be bought in different shops in the city It s known that the price of one bottle in the shop is equal to coins Vasiliy plans to buy his favorite drink for consecutive days He knows that on the th day he will be able to spent coins Now for each of the days he want to know in how many different shops he can buy a bottle of ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << ""="" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int , int> pi;\ntypedef pair< int , pi> pii;\n\nconst int INF = ~0U >> 1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n\tint ret = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % Mod)\n\t\tif (x & 1) ret = 1ll * ret * a % Mod;\n\treturn ret;\n}\n\nconst int N = 100000 + 10;\n\nint n, a[N], q, x;\n\nint main() {\n\tscanf(""%d"", &n);\n\trep(i, 0, n) scanf(""%d"", a + i);\n\tsort(a, a + n);\n\tscanf(""%d"", &q);\n\trep(i, 0, q) {\n\t\tscanf(""%d"", &x);\n\t\tprintf(""%d\\n"", upper_bound(a, a + n, x) - a);\n\t}\n}']","[0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Monocarp has arranged n colored marbles in a row The color of the i th marble is a i Monocarp likes ordered things so he wants to rearrange marbles in such a way that all marbles of the same color form a contiguos segment and there is only one such segment for each color In other words Monocarp wants to rearrange marbles so that for every color j if the leftmost marble of color j is l th in the row and the rightmost marble of this color has position r in the row then every marble from l to r has color j To achieve his goal Monocarp can do the following operation any number of times choose two neighbouring marbles and swap them You have to calculate the minimum number of operations Monocarp has to perform to rearrange the marbles Note that the order of segments of marbles having equal color does not matter it is only required that for every color all the marbles of this color form exactly one contiguous segment ,"['#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nint n,x,S[25];\nll pr[25][25],f[(1<<20)];\nint main(){\n\tscanf(""%d"",&n);\n\tFor(i,1,n){\n\t\tscanf(""%d"",&x); --x;\n\t\tFor(j,0,19) if (x!=j) pr[j][x]+=S[j];\n\t\t++S[x];\n\t}\n\t//printf(""%d\\n"",pr[2][3]);\n\tmemset(f,60,sizeof(f));\n\tf[0]=0;\n\tFor(i,0,(1<<20)-1)\n\t\tFor(j,0,19) if (!(i&(1<<j))){\n\t\t\tll s=f[i];\n\t\t\tFor(k,0,19) if (i&(1<<k))\n\t\t\t\ts+=pr[j][k];\n\t\t\tf[i|(1<<j)]=min(f[i|(1<<j)],s);\n\t\t}\n\tprintf(""%lld\\n"",f[(1<<20)-1]);\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2200
Suppose you have two strings and and their length is equal You may perform the following operation any number of times choose two different characters and and replace every occurence of in both strings with Let s denote the between strings and as the minimum number of operations required to make these strings equal For example if is and is the between them is we may replace every occurence of with so becomes and then we may replace every occurence of with so both strings become You are given two strings and For every substring of consisting of characters you have to determine the between this substring and ,"['#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n    while(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n    return x*f;\n}\n#define MN 262144\nconst double pi=acos(-1);\nstruct cp\n{\n\tdouble r,i;\n\tcp(double r=0,double i=0):r(r),i(i){}\n\tcp operator+(cp b){return cp(r+b.r,i+b.i);}\n\tcp operator-(cp b){return cp(r-b.r,i-b.i);}\n\tcp operator*(cp b){return cp(r*b.r-i*b.i,r*b.i+i*b.r);}\n}w[2][MN+5],x[MN+5],y[MN+5];\nint N,R[MN+5],u[MN+5][6][6],f[6];\nchar a[MN+5],b[MN+5];\nint gf(int k){return f[k]<0?k:f[k]=gf(f[k]);}\nvoid init(int n)\n{\n\tfor(N=1;N<=n;N<<=1);\n\tcp g(cos(2*pi/N),sin(2*pi/N));int i,j,k;\n\tfor(i=w[0][0].r=1;i<N;++i)w[0][i]=w[0][i-1]*g;\n\tfor(i=w[1][0].r=1;i<N;++i)w[1][i]=w[0][N-i];\n\tfor(i=j=0;i<N;R[++i]=j)for(k=N>>1;(j^=k)<k;k>>=1);\n}\nvoid fft(cp*x,int v)\n{\n\tint i,j,k;\n\tfor(i=0;i<N;++i)if(i<R[i])swap(x[i],x[R[i]]);\n\tfor(i=1;i<N;i<<=1)for(j=0;j<N;j+=i<<1)for(k=0;k<i;++k)\n\t{\n\t\tcp p=x[i+j+k]*w[v][N/(i<<1)*k];\n\t\tx[i+j+k]=x[j+k]-p;x[j+k]=x[j+k]+p;\n\t}\n\tif(v)for(i=0;i<N;++i)x[i].r/=N,x[i].i/=N;\n}\nint main()\n{\n\tint n,m,i,j,k,ans=0;\n\tscanf(""%s%s"",a+1,b+1);\n\tn=strlen(a+1);m=strlen(b+1);init(n+n);\n\tfor(i=0;i<6;++i)for(j=0;j<6;++j)if(i!=j)\n\t{\n\t\tmemset(x,0,sizeof(x));memset(y,0,sizeof(y));\n\t\tfor(k=1;k<=n;++k)x[k]=a[k]==i+\'a\';\n\t\tfor(k=1;k<=m;++k)y[n-k]=b[k]==j+\'a\';\n\t\tfft(x,0);fft(y,0);\n\t\tfor(k=0;k<N;++k)x[k]=x[k]*y[k];\n\t\tfft(x,1);\n\t\tfor(k=0;k<=n-m;++k)u[k][i][j]=x[n+k].r>0.5;\n\t}\n\tfor(k=0;k<=n-m;++k)\n\t{\n\t\tmemset(f,-1,sizeof(f));ans=0;\n\t\tfor(i=0;i<6;++i)for(j=0;j<6;++j)if(u[k][i][j]&&gf(i)!=gf(j))f[gf(i)]=gf(j),++ans;\n\t\tprintf(""%d "",ans);\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
You are given two integers n and k along with a string s Your task is to check whether all possible strings of length n that can be formed using the first k lowercase English alphabets occur as a subsequence of s If the answer is you also need to print a string of length n that can be formed using the first k lowercase English alphabets which does not occur as a subsequence of s If there are multiple answers you may print any of them A string a is called a subsequence of another string b if a can be obtained by deleting some possibly zero characters from b without changing the order of the remaining characters ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k, m;\n    std::cin >> n >> k >> m;\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::string t;\n    int j = 0;\n    bool ok = true;\n    for (int i = 0; i < n; i++) {\n        int cnt = 0;\n        std::vector<int> occ(k);\n        while (cnt < k && j < m) {\n            cnt += !occ[s[j] - \'a\'];\n            occ[s[j] - \'a\'] = 1;\n            j += 1;\n        }\n        if (cnt < k) {\n            ok = false;\n            for (int x = 0; x < k; x++) {\n                if (!occ[x]) {\n                    t += \'a\' + x;\n                    break;\n                }\n            }\n        } else {\n            t += s[j - 1];\n        }\n    }\n    \n    if (ok) {\n        std::cout << ""YES\\n"";\n    } else {\n        std::cout << ""NO\\n"";\n        std::cout << t << ""\\n"";\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]",1500
A bracket sequence is a string containing only characters and A regular bracket sequence or shortly an RBS is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences and are regular the resulting expressions are and bracket sequences and are not Let s denote the concatenation of two strings x and y as x y For example You are given n bracket sequences s 1 s 2 dots s n You can rearrange them in any order you can rearrange only the strings themselves but not the characters in them Your task is to rearrange the strings in such a way that the string s 1 s 2 dots s n has as many non empty prefixes that are RBS as possible ,"[""/**\n *    author:  tourist\n *    created: 10.10.2021 12:24:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<string> s(n);\n  vector<int> len(n);\n  vector<vector<vector<int>>> at(n);\n  vector<int> min_delta(n);\n  vector<int> delta(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    len[i] = (int) s[i].size();\n    at[i].resize(2 * len[i] + 1);\n    int b = len[i];\n//    at[i][b].push_back(0);\n    for (int j = 0; j < len[i]; j++) {\n      b += (s[i][j] == '(' ? 1 : -1);\n      at[i][b].push_back(j + 1);\n      min_delta[i] = min(min_delta[i], b - len[i]);\n    }\n    delta[i] = b - len[i];\n  }\n  vector<int> dp(1 << n, -1);\n  dp[0] = 0;\n  int ans = 0;\n  for (int t = 0; t < (1 << n); t++) {\n    if (dp[t] == -1) {\n      continue;\n    }\n    int cur = 0;\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        cur += delta[i];\n      }\n    }\n    assert(cur >= 0);\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        continue;\n      }\n      int goal = len[i] - cur;\n      int ft = dp[t];\n      if (cur + min_delta[i] < 0) {\n        assert(goal > 0 && goal <= 2 * len[i]);\n        assert(!at[i][goal - 1].empty());\n        int bound = at[i][goal - 1][0];\n        ft += (int) (lower_bound(at[i][goal].begin(), at[i][goal].end(), bound) - at[i][goal].begin());\n        ans = max(ans, ft);\n        continue;\n      }\n      if (goal >= 0 && goal <= 2 * len[i]) {\n        ft += (int) at[i][goal].size();\n      }\n      dp[t | (1 << i)] = max(dp[t | (1 << i)], ft);\n    }\n  }\n  ans = max(ans, dp.back());\n  cout << ans << '\\n';\n  return 0;\n}\n""]","[0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2400
You ve got array consisting of integers Count the number of ways to split all the elements of the array into three contiguous parts so that the sum of elements in each part is the same More formally you need to find the number of such pairs of indices that ,"['#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define MAXN 500005\n#define INF 0x7fffffffffffffffLL\nusing namespace std ;\ntypedef long long LL ;\n\nmap<LL, LL> have[4] ;\nLL dp[MAXN][4] ;\nLL p[MAXN], sum[MAXN] ;\nint N ;\n\nint main()\n{\n\tint i, j ;\n\tscanf(""%d"", &N) ;\n\tfor(i = 1; i <= N; i ++)\n\t\tscanf(""%I64d"", &p[i]), sum[i] = sum[i-1]+p[i] ;\n\tfor(i = 1; i <= N; i ++)\n\t{\n\t\tdp[i][1] = 1 ;\n\t\tif(sum[i]%2 == 0) dp[i][2] = have[1][sum[i]/2] ;\n\t\tif(sum[i]%3 == 0) dp[i][3] = have[2][sum[i]/3] ;\n\t\thave[1][sum[i]] ++ ;\n\t\tif(sum[i]%2 == 0) have[2][sum[i]/2] += dp[i][2] ;\n\t\tif(sum[i]%3 == 0) have[3][sum[i]/3] += dp[i][3] ;\n\t}\n\tprintf(""%I64d\\n"", dp[N][3]) ;\n\t//system(""pause"") ;\n\treturn 0 ;\n}\n']","[0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1700
You are given a multiset consisting of n integers You have to process queries of two types add integer k into the multiset find the k th order statistics in the multiset and remove it k th order statistics in the multiset is the k th element in the sorted list of all elements of the multiset For example if the multiset contains elements 1 4 2 1 4 5 7 and k 3 then you have to find the 3 rd element in 1 1 2 4 4 5 7 which is 2 If you try to delete an element which occurs multiple times in the multiset only one occurence is removed After processing all queries print number belonging to the multiset or say that it is empty ,"['#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std;\nconst int lim = 1048576;\nint bit[1048588];\nvoid add(int pos, int val) {\n\tfor (int i = pos; i <= lim; i += i & (-i)) {\n\t\tbit[i] += val;\n\t}\n}\nint bsearch(int x) {\n\tif (x == 0) return 0;\n\tint ptr = 0;\n\tfor (int i = lim / 2; i >= 1; i >>= 1) {\n\t\tif (bit[ptr + i] < x) {\n\t\t\tx -= bit[ptr + i];\n\t\t\tptr += i;\n\t\t}\n\t}\n\treturn ptr + 1;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N, Q;\n\tcin >> N >> Q;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\tadd(x, 1);\n\t}\n\tint cnt = N;\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\tif (x >= 0) add(x, 1), ++cnt;\n\t\telse {\n\t\t\tint ptr = bsearch(-x);\n\t\t\tadd(ptr, -1);\n\t\t\t--cnt;\n\t\t}\n\t}\n\tif (cnt == 0) {\n\t\tcout << 0 << endl;\n\t}\n\telse {\n\t\tcout << bsearch(1) << endl;\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Creatnx has n mirrors numbered from 1 to n Every day Creatnx asks exactly one mirror Am I beautiful The i th mirror will tell Creatnx that he is beautiful with probability frac p i 100 for all 1 le i le n Creatnx asks the mirrors one by one starting from the 1 st mirror Every day if he asks i th mirror there are two possibilities The i th mirror tells Creatnx that he is beautiful In this case if i n Creatnx will stop and become happy otherwise he will continue asking the i 1 th mirror next day In the other case Creatnx will feel upset The next day Creatnx will start asking from the 1 st mirror again You need to calculate the expected number of days until Creatnx becomes happy This number should be found by modulo 998244353 Formally let M 998244353 It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod M Output the integer equal to p cdot q 1 bmod M In other words output such an integer x that 0 le x M and x cdot q equiv p pmod M ,"[""#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int maxn=2e5+5;\nconst int mod=998244353;\nint n,p[maxn];\ninline int ksm(int x,int k){\n\tint s=1;\n\tfor(;k;k>>=1,x=1ll*x*x%mod)if(k&1)s=1ll*s*x%mod;\n\treturn s;\n}\nint dp[maxn];\nint main(){\n\tn=read();\n\tint inv=ksm(100,mod-2);\n\tfor(int i=1;i<=n;i++){\n\t\tp[i]=read();\n\t\tp[i]=1ll*p[i]*inv%mod;\n\t}\n\tdp[1]=0;\n\tfor(int i=2;i<=n+1;i++)dp[i]=1ll*(dp[i-1]+1)*ksm(p[i-1],mod-2)%mod;\n\tcout<<dp[n+1]<<'\\n';\n\treturn 0;\n}\n\n""]","[0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
You are playing a game where your character should overcome different obstacles The current problem is to come down from a cliff The cliff has height h and there is a moving platform on each height x from 1 to h Each platform is either hidden inside the cliff or moved out At first there are n moved out platforms on heights p 1 p 2 dots p n The platform on height h is moved out and the character is initially standing there If you character is standing on some moved out platform on height x then he can pull a special lever which switches the state of In other words the platform you are currently standing on will hide in the cliff and the platform one unit below will change it state it will hide if it was moved out or move out if it was hidden In the second case you will safely land on it Your character is quite fragile so it can safely fall from the height no more than 2 In other words falling from the platform x to platform x 2 is okay but falling from x to x 3 or lower is certain death Sometimes it s not possible to come down from the cliff but you can always buy for donate currency several magic crystals Each magic crystal can be used to change the state of any single platform except platform on height h which is unaffected by the crystals After being used the crystal disappears What is the minimum number of magic crystal you need to buy to safely land on the 0 ground level ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n#pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint q;\nint main(){\n\tcin >> q;\n\twhile(q--){\n\t\tint n,r; cin >> r >> n;\n\t\tvector<int>vi;\n\t\trep(i,n){\n\t\t\tint a; scanf(""%d"",&a); vi.pb(a);\n\t\t}\n\t\tint look = 1;\n\t\twhile(vi.size() && vi.back() == look){\n\t\t\tvi.pop_back(); look++;\n\t\t}\n\t\tif(vi.empty()){ cout << 0 << endl; }\n\t\telse{\n\t\t\tvector<int>vecc;\n\t\t\tint cur = r+1;\n\t\t\tint len = 0;\n\t\t\trep(i,vi.size()){\n\t\t\t\tif(cur == vi[i]+1){\n\t\t\t\t\tcur--; len++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvecc.pb(len);\n\t\t\t\t\tlen = 1;\n\t\t\t\t\tcur = vi[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvecc.pb(len);\n\t\t\tint ans = 0;\n\t\t\tif(vecc[0]%2 == 0) ans++;\n\t\t\tfor(int i=1;i<vecc.size();i++) if(vecc[i]%2 == 1) ans++;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}']","[1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
You ve got string consisting of small English letters Some of the English letters are the rest are A substring of string where is the length of string is string The substring is if among the letters there are ones look at the sample s explanation to understand it more clear Your task is to find the number of distinct good substrings of the given string Two substrings and are considered distinct if their content is different i e ,"['#include<cstdio>\n#include<cstring>\nint ans,n,k;\nchar    a[50],C[2000];\nint T[1200000][26];\nint main(){\n    gets(C);n=strlen(C);\n    for(int i=0;i<26;i++){\n        char    c;\n        for(c=getchar();c!=\'0\'&&c!=\'1\';c=getchar());\n        a[i]=c;\n    }\n    scanf(""%d"",&k);\n    for(int i=0;i<n;i++){\n        int x=0,cnt=0;\n        for(int j=i;j<n;j++){\n            if(a[C[j]-\'a\']==\'0\')cnt++;\n            if(cnt>k)break;\n            if(!T[x][C[j]-\'a\'])T[x][C[j]-\'a\']=++ans;\n            x=T[x][C[j]-\'a\'];\n        }\n    }\n    printf(""%d"",ans);\n    getchar(),getchar();\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1800
Let s define a number if and only if its sum of digits is divisible by 2 but the number itself is not divisible by 2 For example 13 1227 185217 are numbers while 12 2 177013 265918 are not If you re still unsure what numbers are you can look at the sample notes for more clarification You are given a non negative integer s consisting of n digits You can delete some digits they are necessary consecutive successive to make the given number You cannot change the order of the digits that is after deleting the digits the remaining digits collapse The resulting number shouldn t contain leading zeros You can delete any number of digits between 0 do not delete any digits at all and n 1 For example if you are given s then one of possible ways to make it is rightarrow The sum of digits of is equal to 70 and is divisible by 2 but number itself is not divisible by 2 it means that the resulting number is Find resulting number that is If it s impossible to create an number from the given number report about it ,"['/*\nIZ*ONE\n\nLa vie en Rose\n2018.10.29\n\nVioleta\n2019.04.01\n\nFiesta\n2020.02.17\n*/\n\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\nusing namespace std;\n\nint n;\nchar p[3010];\n\nvoid Process() {\n\tint i;\n\tscanf(""%d"", &n);\n\tscanf(""%s"", p);\n\tvector<int>V;\n\tfor (i = 0; p[i]; i++) {\n\t\tif ((p[i] - \'0\') % 2 == 1)V.push_back(p[i] - \'0\');\n\t}\n\tif (V.size() < 2)puts(""-1"");\n\telse printf(""%d%d\\n"", V[0], V[1]);\n}\n\nint main() {\n\tint Tcase;\n\tscanf(""%d"", &Tcase);\n\twhile (Tcase--) {\n\t\tProcess();\n\t}\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",900
While Grisha was celebrating New Year with Ded Moroz Misha gifted Sasha a small rectangular pond of size divided into cells of size inhabited by tiny evil fishes no more than one fish per cell otherwise they ll strife The gift bundle also includes a square scoop of size designed for fishing If the lower left corner of the scoop net is located at cell all fishes inside the square get caught Note that the scoop net should lie completely inside the pond when used Unfortunately Sasha is not that skilled in fishing and hence throws the scoop randomly In order to not frustrate Sasha Misha decided to release fishes into the empty pond in such a way that the expected value of the number of caught fishes is as high as possible Help Misha In other words put fishes in the pond into distinct cells in such a way that when the scoop net is placed into a random position among possible positions the average number of caught fishes is as high as possible ,"['#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<queue>\nusing namespace std;\nint n, m, r;\nmap<int, int>Map[101000];\nint GetX(int a) {\n\treturn min(min(a, n + 1 - a), min(r, n + 1 - r));\n}\nint GetY(int a) {\n\treturn min(min(a, m + 1 - a), min(r, m + 1 - r));\n}\nstruct point {\n\tint x, y;\n\tbool operator <(const point &p)const {\n\t\treturn 1ll*GetX(x)*GetY(y) < 1ll*GetX(p.x)*GetY(p.y);\n\t}\n};\npriority_queue<point>PQ;\nint K, dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\ndouble res;\nvoid Calc(point a) {\n\tint xx = GetX(a.x);\n\tint yy = GetY(a.y);\n\tres += 1.0*xx/(n-r+1)*yy/(m-r+1);\n}\nint main() {\n\tint i, j;\n\tscanf(""%d%d%d%d"", &n, &m, &r, &K);\n\tMap[(n + 1) / 2][(m + 1) / 2] = 1;\n\tPQ.push({ (n+1) / 2,(m+1) / 2 });\n\tfor (i = 0; i < K; i++) {\n\t\tpoint tp = PQ.top();\n\t\tPQ.pop();\n\t\tCalc(tp);\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tint x = tp.x + dx[j], y = tp.y + dy[j];\n\t\t\tif (x<1 || x>n || y<1 || y>m || Map[x].count(y))continue;\n\t\t\tMap[x][y] = 1;\n\t\t\tPQ.push({ x,y });\n\t\t}\n\t}\n\tprintf(""%.10f\\n"", res);\n}']","[1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2100
A flowerbed has many flowers and two fountains You can adjust the water pressure and set any values and giving the distances at which the water is spread from the first and second fountain respectively You have to set such and that all the flowers are watered that is for each flower the distance between the flower and the first fountain doesn t exceed or the distance to the second fountain doesn t exceed It s OK if some flowers are watered by both fountains You need to decrease the amount of water you need that is set such and that all the flowers are watered and the is minimum possible Find this minimum value ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define e1 first\n#define e2 second\n#define pb push_back\n#define mp make_pair\n#define boost ios_base::sync_with_stdio(false)\n#define eb emplace_back\n#define OUT(x) {cout << x; exit(0); }\n#define scanf(...) scanf(__VA_ARGS__)?:0\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> PII;\ntypedef pair <ll, ll> PLL;\ntypedef pair <PLL, PLL> PP;\ntypedef pair <PII, int> PPI;\ntypedef pair <int, PII> PIP;\ntypedef pair <ll, int> PLI;\ntypedef pair <PII, ll> PIIL;\ntypedef pair <int, ll> PIL;\ntypedef unsigned int ui;\nconst int mod = 1e9+7;\nconst int inf = 1e9+9;\nconst ll MOD = 1e9+696969;\nconst ll INF = 1e18;\n#define maxn 2010\ninline ll sqr(ll a) {\n\treturn a*a;\n}\nint n;\nPII t[maxn];\nll d[maxn][2];\nll odl(int a, int b)\n{\n\treturn sqr(t[a].e1 - t[b].e1) + sqr(t[a].e2 - t[b].e2);\n}\n\nint main()\n{\n\tscanf(""%d%d%d"", &n, &t[0].e1, &t[0].e2);\n\tscanf(""%d%d"", &t[n+1].e1, &t[n+1].e2);\n\tfor (int i=1; i<=n; ++i) scanf(""%d%d"", &t[i].e1, &t[i].e2);\n\tfor (int i=1; i<=n; ++i)\n\t  d[i][0] = odl(0, i), d[i][1] = odl(n+1, i);\n\n\tll res = INF;\n\tfor (int j=0; j<2; ++j) {\n\tfor (int i=1; i<=n; ++i)\n\t{\n\t\tll wart = d[i][0]; //kwadrat\n\t\tll MIN = 0;\n\t\tfor (int j=1; j<=n; ++j)\n\t\t  if (d[j][0] > wart) MIN = max(MIN, d[j][1]);\n\t\tres = min(res, wart + MIN);\n\t}\n\tfor (int j=1; j<=n; ++j) swap(d[j][0], d[j][1]);\n\t}\n\n\tcout << res;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
It was decided in IT City to distinguish successes of local IT companies by awards in the form of stars covered with gold from one side To order the stars it is necessary to estimate order cost that depends on the area of gold plating Write a program that can calculate the area of a star A star figure having corners where is a prime number is constructed the following way On the circle of radius points are selected so that the distances between the adjacent ones are equal Then every point is connected by a segment with two maximally distant points All areas bounded by the segments parts are the figure parts ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 18:45:12       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\nnamespace point_output\n{\n    static char buf[8][30];\n    static int bufc = 0;\n}\n\nstruct pt\n{\n    dbl x, y;\n    pt() {}\n    pt(dbl xx, dbl yy): x(xx), y(yy) {}\n\n    void read()\n    {\n        double xx, yy;\n        scanf(""%lf%lf"", &xx, &yy);\n        x = xx, y = yy;\n    }\n    void draw(int color = 0) const\n    {\n        printf(""point %.4lf %.4lf %d\\n"", (double)x, (double)y, color);\n    }\n    void out() const\n    {\n        eprintf(""(%.4lf, %.4lf)\\n"", (double)x, (double)y);\n    }\n    char* str() const\n    {\n        using namespace point_output;\n        bufc = (bufc + 1) & 7;\n        sprintf(buf[bufc], ""%.10lf %.10lf"", (double)x, (double)y);\n        return buf[bufc];\n    }\n};\n\ninline pt operator + (pt const &p1, pt const &p2) { return pt(p1.x + p2.x, p1.y + p2.y); }\ninline pt operator - (pt const &p1, pt const &p2) { return pt(p1.x - p2.x, p1.y - p2.y); }\ninline pt operator * (pt const &p, dbl c) { return pt(p.x * c, p.y * c); }\ninline pt operator * (dbl c, pt const &p) { return pt(p.x * c, p.y * c); }\ninline pt operator / (pt const &p, dbl c) { return pt(p.x / c, p.y / c); }\n\ninline dbl vect(pt const &p1, pt const &p2) { return p1.x * p2.y - p1.y * p2.x; }\ninline dbl scal(pt const &p1, pt const &p2) { return p1.x * p2.x + p1.y * p2.y; }\ninline dbl len(pt const &p) { return sqrt(p.x * p.x + p.y * p.y); }\n\ninline dbl dist(pt const &p1, pt const &p2)\n{\n    dbl xx = p1.x - p2.x;\n    dbl yy = p1.y - p2.y;\n    return sqrt(xx * xx + yy * yy);\n}\n\ninline bool operator < (pt const &p1, pt const &p2) { return p1.x < p2.x - eps || (abs(p1.x - p2.x) < eps && p1.y < p2.y - eps); }\ninline bool operator > (pt const &p1, pt const &p2) { return p1.x > p2.x + eps || (abs(p1.x - p2.x) < eps && p1.y > p2.y + eps); }\ninline bool operator == (pt const &p1, pt const &p2) { return abs(p1.x - p2.x) < eps && abs(p1.y - p2.y) < eps; }\n\n\nstruct line\n{\n    dbl a, b, c;\n    line() {}\n    line(dbl aa, dbl bb, dbl cc): a(aa), b(bb), c(cc) {}\n    line(pt const &p1, pt const &p2)\n    {\n        a = p1.y - p2.y;\n        b = p2.x - p1.x;\n        c = p1.x * p2.y - p1.y * p2.x;\n    }\n    inline dbl operator () (pt const &p) const\n    {\n        return a * p.x + b * p.y + c;\n    }\n    void norm()\n    {\n        dbl dd = sqrt(a * a + b * b);\n        a /= dd;\n        b /= dd;\n        c /= dd;\n    }    \n    void draw(int color = 0) const\n    {\n        printf(""line %.4lf %.4lf %.4lf %d\\n"", (double)a, (double)b, (double)c, color);\n    }\n    void out() const\n    {\n        eprintf(""(%.4lf, %.4lf, %.4lf)\\n"", (double)a, (double)b, (double)c);\n    }\n};\n\ninline pt intersect(line const &l1, line const &l2)\n{\n    dbl D = l1.a * l2.b - l1.b * l2.a;\n    return pt((l1.b * l2.c - l2.b * l1.c) / D,\n              (l1.a * l2.c - l2.a * l1.c) / (-D));\n}\n\ninline pt proj(pt const &p, line const &l)\n{   \n    return p - pt(l.a, l.b) * (l(p) / sqrt(l.a * l.a + l.b * l.b));\n}\n\ninline dbl dist(pt const &p, line const &l) { return abs(l(p) / sqrt(l.a * l.a + l.b * l.b)); }\ninline dbl dist(line const &l, pt const &p) { return abs(l(p) / sqrt(l.a * l.a + l.b * l.b)); }\n  \n\n\nconst dbl PI = acos(-1);\n\nint n, r;\n\npt get(int i)\n{\n    dbl alp = 2 * PI * i / n;\n    return pt(cos(alp) * r, sin(alp) * r);\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    cin >> n >> r;\n    pt A = get(0), B = get(n / 2);\n    pt C = get(1), D = get(n / 2 + 2);\n    pt I = intersect(line(A, B), line(C, D));\n    pt I2 = pt(I.x, -I.y);\n    dbl S1 = vect(I - A, I2 - A) / 2;\n    dbl rad = len(I);\n    dbl S2 = rad * rad * sin(2 * PI / n) / 2;\n    dbl res = (S1 + S2) * n;\n    printf(""%.10f\\n"", res);\n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2100
Recently a dog was bought for Polycarp The dog s name is Cormen Now Polycarp has a lot of troubles For example Cormen likes going for a walk Empirically Polycarp learned that the dog needs at least walks for any two consecutive days in order to feel good For example if and yesterday Polycarp went for a walk with Cormen times today he has to go for a walk at least times Polycarp analysed all his affairs over the next days and made a sequence of integers where is the number of times Polycarp will walk with the dog on the th day while doing all his affairs for example he has to go to a shop throw out the trash etc Help Polycarp determine the minimum number of walks he needs to do additionaly in the next days so that Cormen will feel good during all the days You can assume that on the day before the first day and on the day after the th day Polycarp will go for a walk with Cormen exactly times Write a program that will find the minumum number of additional walks and the appropriate schedule the sequence of integers where means the total number of walks with the dog on the th day ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nint n , K , a[505] , b[505];\n\nint main(){\n    cin >> n >> K;\n    rep(i,0,n) cin >> a[i];\n    int add = 0;\n    rep(i,1,n){\n        int sum = a[i-1] + a[i];\n        if(sum < K) a[i] += K - sum , add += K - sum;\n    }\n    cout << add << endl;\n    rep(i,0,n) cout << a[i] << "" \\n""[i+1==n];\n    return 0;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
The well known Fibonacci sequence F 0 F 1 F 2 ldots is defined as follows F 0 0 F 1 1 For each i geq 2 F i F i 1 F i 2 Given an increasing arithmetic sequence of positive integers with n elements a a d a 2 cdot d ldots a n 1 cdot d You need to find another increasing arithmetic sequence of positive integers with n elements b b e b 2 cdot e ldots b n 1 cdot e such that 0 b e 2 64 for all 0 leq i n the decimal representation of a i cdot d appears as substring in the last 18 digits of the decimal representation of F b i cdot e if this number has less than 18 digits then we consider all its digits ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    long long x = 3337867500;\n    int n, a, d;\n    cin >> n >> a >> d;\n    cout << a * x << "" "" << d * x << endl;\n    return 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",3500
You are given a permutation p 1 p 2 dots p n You should answer q queries Each query is a pair l i r i and you should calculate f l i r i Let s denote m l r as the position of the maximum in subsegment p l p l 1 dots p r Then f l r r l 1 f l m l r 1 f m l r 1 r if l le r or 0 otherwise ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,Q;\nint P[1010101];\nint L[1010101],R[1010101];\n\nint Lma[1010101],Rma[1010101];\nvector<int> delL[1010101],delR[1010101];\nvector<int> QL[1010101],QR[1010101];\ntemplate<class V,int NV> class SegTree_1 {\npublic:\n\tvector<V> val;\n\tstatic V const def=0;\n\tV comp(V l,V r){ return max(l,r);};\n\t\n\tSegTree_1(){val=vector<V>(NV*2,def);};\n\tV getval(int x,int y,int l=0,int r=NV,int k=1) { // x<=i<y\n\t\tif(r<=x || y<=l) return def;\n\t\tif(x<=l && r<=y) return val[k];\n\t\treturn comp(getval(x,y,l,(l+r)/2,k*2),getval(x,y,(l+r)/2,r,k*2+1));\n\t}\n\tvoid update(int entry, V v) {\n\t\tentry += NV;\n\t\tval[entry]=comp(v,val[entry]);\n\t\twhile(entry>1) entry>>=1, val[entry]=comp(val[entry*2],val[entry*2+1]);\n\t}\n};\nSegTree_1<int,1<<20> st;\n\ntemplate<class V, int ME> class BIT {\npublic:\n\tV bit[1<<ME];\n\tV operator()(int e) {if(e<0) return 0;V s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s;}\n\tvoid add(int e,V v) { e++; while(e<=1<<ME) bit[e-1]+=v,e+=e&-e;}\n};\nBIT<ll,20> sum;\nBIT<int,20> mu;\n\nll ret[1010101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tscanf(""%d%d"",&N,&Q);\n\tfor(i=1;i<=N;i++) {\n\t\tscanf(""%d"",&P[i]);\n\t\tLma[i]=st.getval(P[i],N+1);\n\t\tdelL[Lma[i]].push_back(i);\n\t\tst.update(P[i],i);\n\t\tsum.add(i,i-Lma[i]);\n\t}\n\tFOR(i,st.val.size()) st.val[i]=0;\n\tfor(i=N;i>=1;i--) {\n\t\tRma[i]=N+1-st.getval(P[i],N+1);\n\t\tdelR[Rma[i]].push_back(i);\n\t\tst.update(P[i],N+1-i);\n\t}\n\t\n\tFOR(i,Q) {\n\t\tscanf(""%d"",&L[i]);\n\t\tQL[L[i]].push_back(i);\n\t}\n\tFOR(i,Q) {\n\t\tscanf(""%d"",&R[i]);\n\t\tQR[R[i]].push_back(i);\n\t}\n\t\n\tFOR(i,N+1) {\n\t\tFORR(q,QL[i]) ret[q]+=(sum(R[q])-sum(L[q]-1))-1LL*i*(mu(R[q])-mu(L[q]-1));\n\t\tFORR(x,delL[i]) {\n\t\t\tsum.add(x,x+1-(sum(x)-sum(x-1)));\n\t\t\tmu.add(x,1);\n\t\t}\n\t}\n\tZERO(mu.bit);\n\tZERO(sum.bit);\n\tfor(i=1;i<=N;i++) {\n\t\tsum.add(i,Rma[i]-i-1);\n\t}\n\tfor(i=N+1;i>=1;i--) {\n\t\tFORR(q,QR[i]) ret[q]+=(sum(R[q])-sum(L[q]-1))+1LL*i*(mu(R[q])-mu(L[q]-1));\n\t\tFORR(x,delR[i]) {\n\t\t\tsum.add(x,-x-(sum(x)-sum(x-1)));\n\t\t\tmu.add(x,1);\n\t\t}\n\t}\n\t\n\tFOR(i,Q) cout<<ret[i]<<"" "";\n\tcout<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+=\'\\n\'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
Igor is a post graduate student of chemistry faculty in Berland State University BerSU He needs to conduct a complicated experiment to write his thesis but laboratory of BerSU doesn t contain all the materials required for this experiment Fortunately chemical laws allow material transformations yes chemistry in Berland differs from ours But the rules of transformation are a bit strange Berland chemists are aware of materials numbered in the order they were discovered Each material can be transformed into some other material or vice versa Formally for each there exist two numbers and that denote a possible transformation kilograms of material can be transformed into kilogram of material and kilogram of material can be transformed into kilogram of material Chemical processing equipment in BerSU allows only such transformation that the amount of resulting material is For each Igor knows that the experiment requires kilograms of material and the laboratory contains kilograms of this material Is it possible to conduct an experiment after transforming some materials or none ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define N 101010\ntypedef long long LL;\nLL n , d[ N ] , p[ N ];\nvector< pair<LL,LL> > v[ N ];\nconst LL inf = 100000000000000000LL;\nvoid DP( int now ){\n  for( auto e : v[ now ] ){\n    LL son = e.first;\n    LL ki = e.second;\n    DP( son );\n    if( d[ son ] >= 0 )\n      d[ now ] += d[ son ];\n    else{\n      LL nd = -d[ son ];\n      if( nd >= inf / ki ){\n        puts( ""NO"" );\n        exit(0);\n      }\n      d[ now ] -= nd * ki;\n      if( d[ now ] < -inf ){\n        puts( ""NO"" );\n        exit(0);\n      }\n    }\n  }\n}\nint main(){\n  scanf( ""%lld"" , &n );\n  for( LL i = 1 , x ; i <= n ; i ++ ){\n    scanf( ""%lld"" , &x );\n    d[ i ] += x;\n  }\n  for( LL i = 1 , x ; i <= n ; i ++ ){\n    scanf( ""%lld"" , &x );\n    d[ i ] -= x;\n  }\n  for( LL i = 2 , x ; i <= n ; i ++ ){\n    scanf( ""%lld%lld"" , &p[ i ] , &x );\n    v[ p[ i ] ].push_back( { i , x } );\n  }\n  DP( 1 );\n  puts( d[ 1 ] >= 0 ? ""YES"" : ""NO"" );\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2300
Berland Intercollegiate Contest has just finished Monocarp and Polycarp as the jury are going to conduct an editorial Unfortunately the time is limited since they have to finish before the closing ceremony There were n problems in the contest The problems are numbered from 1 to n The editorial for the i th problem takes a i minutes Monocarp and Polycarp are going to conduct an editorial for exactly k of the problems The editorial goes as follows They have a full problemset of n problems before them in order They remove n k problems without changing the order of the remaining k problems Then Monocarp takes some prefix of these k problems possibly an empty one or all problems Polycarp takes the remaining suffix of them After that they go to different rooms and conduct editorials for their problems in parallel So the editorial takes as much time as the longer of these two does Please help Monocarp and Polycarp to choose the problems and the split in such a way that the editorial finishes as early as possible Print the duration of the editorial ,"['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int j = 0; j < n; j++){\n      cin >> a[j];\n    }\n    long long tv = 1000000000000000, fv = 0;\n    while (tv - fv > 1){\n      long long mid = (tv + fv) / 2;\n      vector<int> L(n + 1, 0);\n      priority_queue<int> pq1;\n      long long sum1 = 0;\n      for (int j = 0; j < n; j++){\n        pq1.push(a[j]);\n        sum1 += a[j];\n        if (sum1 > mid){\n          sum1 -= pq1.top();\n          pq1.pop();\n        }\n        L[j + 1] = pq1.size();\n      }\n      vector<int> R(n + 1, 0);\n      priority_queue<int> pq2;\n      long long sum2 = 0;\n      for (int j = n - 1; j >= 0; j--){\n        pq2.push(a[j]);\n        sum2 += a[j];\n        if (sum2 > mid){\n          sum2 -= pq2.top();\n          pq2.pop();\n        }\n        R[j] = pq2.size();\n      }\n      bool ok = false;\n      for (int j = 0; j <= n; j++){\n        if (L[j] + R[j] >= k){\n          ok = true;\n        }\n      }\n      if (ok){\n        tv = mid;\n      } else {\n        fv = mid;\n      }\n    }\n    cout << tv << endl;\n  }\n}']","[1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
You are given two positive integer numbers and Permute change order of the digits of to construct maximal number not exceeding No number in input and or output can start with the digit It is allowed to leave as it is ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\n\nmap<int, int>haveInt;\nvector<int>need;\nvector<int>answer;\n\nvoid prnt() {\n\tfor (auto x : answer)cout << x;\n\texit(0);\n}\n\nvoid formAll() {\n\twhile (!haveInt.empty()) {\n\t\tmap<int, int>::iterator it = haveInt.end();\n\t\tit--;\n\t\tanswer.push_back(it->first);\n\t\tit->second -= 1;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t}\n\tprnt();\n}\n\nvoid tryNum(int a) {\n\tif (haveInt.size()==0)\n\t\tprnt();\n\tmap<int, int>::iterator it = haveInt.lower_bound(need[a]);\n\tif (it != haveInt.end() && it->first == need[a]) {\n\t\tint x = it->first;\n\t\tit->second--;\n\t\tif (it->second == 0)\n\t\t\thaveInt.erase(it);\n\t\tanswer.push_back(x);\n\t\ttryNum(a + 1);\n\t\thaveInt[x]++;\n\t\tanswer.pop_back();\n\t}\n\tit = haveInt.lower_bound(need[a]);\n\tif (it == haveInt.begin())return;\n\tit--;\n\tanswer.push_back(it->first);\n\tit->second--;\n\tif (it->second == 0)\n\t\thaveInt.erase(it);\n\tformAll();\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tstring s1, s2;\n\tcin >> s1 >> s2;\n\tswap(s1, s2);\n\tfor (auto x : s2)\n\t\thaveInt[x - \'0\']++;\n\tif (s2.length() < s1.length())\n\t\tformAll();\n\tfor (auto x : s1)\n\t\tneed.push_back(x - \'0\');\n\ttryNum(0);\n\n\t\n\treturn 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Alice has just learned addition However she hasn t learned the concept of carrying fully instead of carrying to the column she carries to the column For example the way to evaluate the sum 2039 2976 would be as shown However Alice evaluates it as shown In particular this is what she does add 9 and 6 to make 15 and carry the 1 to the column i e to the column 0 9 add 3 and 7 to make 10 and carry the 1 to the column i e to the column 2 2 add 1 0 and 9 to make 10 and carry the 1 to the column i e to the column above the plus sign add 1 2 and 2 to make 5 add 1 to make 1 Thus she ends up with the incorrect result of 15005 Alice comes up to Bob and says that she has added two numbers to get a result of n However Bob knows that Alice adds in her own way Help Bob find the number of such that when Alice adds them she will get a result of n Note that pairs a b and b a are considered different if a ne b ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint val[111];\n\nint dfs(int x, int d) {\n\tif (d >= 12) {\n\t\tif (x == 0 && val[d - 2] == 0 && val[d - 1] == 0) return 1;\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i <= 18; i++) {\n\t\tint v = (i + ((d >= 2 && val[d - 2] >= 10) ? 1 : 0));\n\t\tval[d] = v;\n\t\tif (x % 10 == v % 10) ans += (10 - abs(i - 9)) * dfs(x / 10, d + 1);\n\t}\n\treturn ans;\n}\nvoid solve() {\n\tint n;\n\tscanf(""%d"", &n);\n\tprintf(""%d\\n"", dfs(n , 0) - 2);\n}\n\nint main() {\n\tint T;\n\tscanf(""%d"", &T);\n\tfor (int i = 0; i < T; i++) solve();\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0]",1600
The polar bears are going fishing They plan to sail from to However the boat can only sail by wind At each second the wind blows in one of these directions east south west or north Assume the boat is currently at If the wind blows to the east the boat will move to If the wind blows to the south the boat will move to If the wind blows to the west the boat will move to If the wind blows to the north the boat will move to Alternatively they can hold the boat by the anchor In this case the boat stays at Given the wind direction for seconds what is the earliest time they sail to ,"[""//In the Name of GOD\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#define MOD 1000000007ll\n\nusing namespace std;\n\n\n\n\nint main()\n{\n\tlong long n,x,y,a,b;\n\tcin>>n>>x>>y>>a>>b;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tchar ch;\n\t\tcin>>ch;\n\t\tif(ch=='S')\n\t\t{\n\t\t\tif(y>b)\n\t\t\t\ty--;\n\t\t}\n\t\tif(ch=='N')\n\t\t{\n\t\t\tif(y<b)\n\t\t\t\ty++;\n\t\t}\n\t\tif(ch=='E')\n\t\t\tif(x<a)\n\t\t\t\tx++;\n\t\tif(ch=='W')\n\t\t\tif(x>a)\n\t\t\t\tx--;\n\t\tif(x==a and y==b)\n\t\t{\n\t\t\tcout<<i+1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<-1;\n\treturn 0;\n}\n""]","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Your friend Mishka and you attend a calculus lecture Lecture lasts minutes Lecturer tells theorems during the th minute Mishka is really interested in calculus though it is so hard to stay awake for all the time of lecture You are given an array of Mishka s behavior If Mishka is asleep during the th minute of the lecture then will be equal to otherwise it will be equal to When Mishka is awake he writes down all the theorems he is being told during the th minute Otherwise he writes nothing You know some secret technique to keep Mishka awake for minutes straight However you can use it You can start using it at the beginning of any minute between and If you use it on some minute then Mishka will be awake during minutes such that and will write down all the theorems lecturer tells You task is to calculate the maximum number of theorems Mishka will be able to write down if you use your technique to wake him up ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint in1[100050];\nint in2[100050];\nll sum1[100050];\nll sum2[100050];\nint main() {\n\tint N, K, i, j;\n\tscanf(""%d %d"", &N, &K);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in1[i]);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in2[i]);\n\tfor (i = 1; i <= N; i++) {\n\t\tsum1[i] = sum1[i - 1] + in1[i] * in2[i];\n\t\tsum2[i] = sum2[i - 1] + in1[i];\n\t}\n\n\tll mx = 0;\n\tfor (i = 1; i <= N - K + 1; i++) {\n\t\tll v = sum1[i - 1] + (sum2[i + K - 1] - sum2[i - 1]) + (sum1[N] - sum1[i + K - 1]);\n\t\tmx = max(mx, v);\n\t}\n\treturn !printf(""%lld\\n"", mx);\n}']","[0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1200
Alice has n cards each card is white and the cards are stacked in a deck Alice deals the cards to herself and to Bob dealing at once several cards from the top of the deck in the following order one card to herself two cards to Bob three cards to Bob four cards to herself five cards to herself six cards to Bob seven cards to Bob eight cards to herself and so on In other words on the i th step Alice deals i top cards from the deck to one of the players on the first step she deals the cards to herself and then alternates the players every two steps When there aren t enough cards at some step Alice deals all the remaining cards to the current player and the process stops How many cards will Alice and Bob have at the end ,"[""// sir u r right, but plz supot Botswana thx\n#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define pc putchar\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define W(p) while(p--)\n#define pii pair<int, int>\n#define ull unsigned long long\n#define all(x) x.begin(), x.end()\n#define def(N, K, b) const K N = b;\n#define rep(i, b, s) for(int i = (b); i <= (s); ++i)\n#define per(i, b, s) for(int i = (b); i >= (s); --i)\n#define ios ios::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n\nnamespace IO {\n    const int SIZE = (1 << 20) + 1;\n    char ibuf[SIZE], *iS, *iT;\n    inline char gc() {\n        return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++) : *iS++);\n    }\n    inline void qread() {}\n    template<class T1, class ...T2>\n    inline void qread(T1 &IEE, T2&... ls) {\n        T1 __ = 0, ___ = 1;\n        char ch;\n        while(!isdigit(ch = gc())) ___ = (ch == '-') ? -___ : ___;\n        do {\n            __ = (__ << 1) + (__ << 3) + (ch ^ 48);\n        }while(isdigit(ch = gc()));\n        __ *= ___;\n        IEE = __;\n        qread(ls...);\n        return ;\n    }\n}\n\nusing namespace IO;\nusing namespace std;\n\nll qmul(ll x, ll y, ll p) {\n\tll l = x * (y >> 25) % p * (1 << 25) % p;\n\tll r = x * (y & ((1 << 25) - 1)) % p;\n\treturn (l + r) % p;\n}\n\nll qpow(ll n, ll base, ll mod = 1e18) {\n\tll ret = 1;\n\twhile(n) {\n\t\tif(n & 1) ret = ret * base % mod;\n\t\tbase = base * base % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret % mod;\n}\n\nll gcd(ll x, ll y) { return !y ? x : gcd(y, x % y); }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; } \n\nnamespace Comb {\n\tconst int SIZE = 1e6 + 5;\n\tint p;\n\t\n\tll fac[SIZE], Inv[SIZE];\n\t\n\tvoid init(int sz, int mod) {\n\t\tp = mod;\n\t\tfac[0] = Inv[0] = fac[1] = Inv[1] = 1;\n\t\trep(i, 2, sz) fac[i] = fac[i - 1] * i % p; Inv[sz] = qpow(mod - 2, fac[sz], mod);\n\t\tper(i, sz - 1, 2) Inv[i] = Inv[i + 1] * (i + 1) % p;\n\t}\n\t\n\tinline ll C(int n, int m) { return (n < m || m < 0) ? 0 : fac[n] * Inv[n - m] % p * Inv[m] % p; }\n} using Comb::C;\n\nint mod;\nstruct modint {\n\tint x;\n\t\n\tmodint() {}\n\tmodint(int _x) : x(_x) {}\n\t\n\tmodint operator + (const modint &y) { return modint((x + y.x) % mod); }\n\tmodint operator + (const int &y) { return modint((x + y) % mod); }\n\tmodint operator - (const modint &y) { return modint((x - y.x + mod) % mod); }\n\tmodint operator - (const int &y) { return modint((x - y + mod) % mod); }\n\tmodint operator * (const modint &y) { return modint((ll)x * y.x % mod); }\n\tmodint operator * (const int &y) { return modint((ll)x * y % mod); }\n\tmodint operator / (const modint &y) { return modint((ll)x * qpow(mod - 2, y.x, mod) % mod); }\n\tmodint operator / (const int &y) { return modint((ll)x * qpow(mod - 2, y, mod) % mod); }\n};\n\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n\nmt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count() + 1);\nll My_Rand(ll Mod) { return (ull)(rnd()) % Mod; }\n\ntemplate<class T1, class T2>\nvoid To_max(T1 &x, const T2 y) { x < y ? x = y : x = x; }\ntemplate<class T1, class T2>\nvoid To_min(T1 &x, const T2 y) { x > y ? x = y : x = x; }\n//header\n\ndef(N, int, 1e5 + 5)\n\nint n, m;\nint a[N];\n\nvoid solve() {\n\tqread(n);\n\tint c[] = {1, 0};\n\tint nw = 2, cc = 2, f = 1;\n\twhile(nw <= n) {\n\t\tint to = min(nw + cc - 1, n);\n\t\tc[f] += to - nw + 1; ++cc;\n\t\tnw = to + 1;\n\t\tto = min(nw + cc - 1, n);\n\t\tc[f] += to - nw + 1; ++cc;\n\t\tnw = to + 1; f ^= 1;\n\t}\n\tcout << c[0] << ' ' << c[1] << '\\n';\n}\n\nint main() {\n\tint T = 1;\n\tcin >> T;\n\twhile(T--) solve();\n\treturn 0;\n}\n""]","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Fafa owns a company that works on huge projects There are employees in Fafa s company Whenever the company has a new project to start working on Fafa has to divide the tasks of this project among all the employees Fafa finds doing this every time is very tiring for him So he decided to choose the best employees in his company as team leaders Whenever there is a new project Fafa will divide the tasks among only the team leaders and each team leader will be responsible of some positive number of employees to give them the tasks To make this process fair for the team leaders each one of them should be responsible for the same number of employees Moreover every employee who is not a team leader has to be under the responsibility of exactly one team leader and no team leader is responsible for another team leader Given the number of employees find in how many ways Fafa could choose the number of team leaders in such a way that it is possible to divide employees between them evenly ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint main(void) {\n  int n;\n  scanf(""%d"", &n);\n  int cnt = 0;\n  for (int i = 1; i < n; ++i) {\n    if (n % i == 0) {\n      ++cnt;\n    }\n  }\n  printf(""%d\\n"", cnt);\n  return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
On a number line there are balls At time moment for each ball the following data is known its coordinate speed possibly negative and weight The radius of the balls can be ignored The balls collide elastically i e if two balls weighing and and with speeds and collide their new speeds will be Your task is to find out where each ball will be seconds after ,"['#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<list>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<ctime>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair <int,int> ii;\ntypedef pair <double,ii> dii;\n#define sz(a) int((a).size())\n#define pb push_back\nconst int INF = 2147483647;\nconst double PI = 3.141592653589793;\n\nint kol[15],n,t,i,k1,k2;\nset<dii> zbior;\ndouble v[15],x[15],r,tim,nv1,nv2,m[15];\n\nbool cmp (int a, int b) {\n     return x[a] < x[b];\n}\n\nint main () {\nscanf (""%d %d"",&n,&t);\nfor (i=0;i<n;i++) {\n    scanf (""%lf %lf %lf"",&x[i],&v[i],&m[i]);\n    kol[i]=i;\n}\nsort (kol,kol+n,cmp);\ntim = 0.0;\nwhile (1) {\n      zbior.clear();\n      for (i=0;i<n-1;i++) {\n          k1 = kol[i];\n          k2 = kol[i+1];\n          if (v[k1]<0 && v[k2] > 0) continue;\n          if (v[k1] > 0 && v[k2] > v[k1]) continue;\n          if (v[k2] < 0 && v[k1] < v[k2]) continue;\n          zbior.insert(dii(abs(x[k1]-x[k2]) / abs(v[k1]-v[k2]),ii(k1,k2)));\n      }\n      if (zbior.size()==0) break;\n      r = (*zbior.begin()).first;\n      if ( tim + r > t) break;\n      k1 = (*zbior.begin()).second.first;\n      k2 = (*zbior.begin()).second.second;\n      for (i=0;i<n;i++) x[i]+=v[i]*r;\n      nv1 = ((m[k1]-m[k2])*v[k1]+2*m[k2]*v[k2])/(m[k1]+m[k2]);\n      nv2 = ((m[k2]-m[k1])*v[k2]+2*m[k1]*v[k1])/(m[k1]+m[k2]);\n      v[k1]=nv1;\n      v[k2]=nv2;\n      tim += r;\n}\nr = t-tim;\nfor (i=0;i<n;i++) x[i]+=v[i]*r;\nfor (i=0;i<n;i++) printf(""%.8lf\\n"",x[i]);\nreturn 0;\n}\n']","[0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Vasya came to the store to buy goods for his friends for the New Year It turned out that he was very lucky today the offer k of goods for the price of one is held in store Using this offer Vasya can buy exactly k of any goods paying only for the most expensive of them Vasya decided to take this opportunity and buy as many goods as possible for his friends with the money he has More formally for each good its price is determined by a i the number of coins it costs Initially Vasya has p coins He wants to buy the maximum number of goods Vasya can perform one of the following operations as many times as necessary Vasya can buy one good with the index i if he currently has enough coins i e p ge a i After buying this good the number of Vasya s coins will decrease by a i i e it becomes p p a i Vasya can buy a good with the index i and also choose exactly k 1 goods the price of which does not exceed a i if he currently has enough coins i e p ge a i Thus he buys all these k goods and his number of coins decreases by a i i e it becomes p p a i Please note that each good can be bought no more than once For example if the store now has n 5 goods worth a 1 2 a 2 4 a 3 3 a 4 5 a 5 7 respectively k 2 and Vasya has 6 coins then he can buy 3 goods A good with the index 1 will be bought by Vasya without using the offer and he will pay 2 coins Goods with the indices 2 and 3 Vasya will buy using the offer and he will pay 4 coins It can be proved that Vasya can not buy more goods with six coins Help Vasya to find out the maximum number of goods he can buy ,"['#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n#include <string>\n#include <time.h>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <stdint.h>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 200500\n#define MOD 998244353\n#define OFF 2001\nll n, x, k, z, m, pos, q, ans_v, y;\nll x1, p1, x2;\nll a[MAXN], b[MAXN], c[MAXN];\nvector<ll> f;\nvector<ll> g[MAXN];\nvoid solve() {\n    ll p;\n    cin >> n >> p >> k;\n    for (int i = 0;i < n; i++) {\n        cin >> a[i];\n    }\n    for (int i = 0; i <= n; i++) {\n        b[i] = c[i] = 0;\n    }\n    sort(a, a+n);\n    for (int i = 0; i < n; i++) {\n        c[i+1] = c[i] + a[i];\n        if (i < k) {\n            b[i] = a[i];\n        } else {\n            b[i] = b[i-k] + a[i];\n        }\n\n    }\n    ll x = 0;\n    for (ll i = 0; i < n; i++) {\n        if (b[i] <= p) {\n            ll suck = (i + 1) / k * k;\n            ll diff = i + 1 - suck;\n            ll diffp = p - b[i];\n            ll pos = upper_bound(c, c+diff, diffp) - c;\n            x = max(x, suck + pos);\n        }\n    }\n    cout << x << ""\\n"";\n}\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    ll t;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n\n\n\n    return 0;\n}']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Roland loves growing flowers He has recently grown a beautiful rose at point of the Cartesian coordinate system The rose is so beautiful that Roland is afraid that the evil forces can try and steal it To protect the rose Roland wants to build watch towers Let s assume that a tower is a point on the plane at the distance of at most from the rose Besides Roland assumes that the towers should be built at points with integer coordinates and the sum of squares of distances between all pairs of towers must be as large as possible Note that Roland may build several towers at the same point also he may build some of them at point Help Roland build the towers at the integer points so that the sum of squares of distances between all towers is maximum possible Note that the distance in this problem is defined as the Euclidian distance between points ,"['// #includes {{{\n#include <bits/stdc++.h>\nusing namespace std;\n// }}}\n// #defines {{{\n#define MP(x,y) make_pair(x,y)\n#define PB(x) push_back(x)\n#define POP() pop_back()\n#define F first\n#define S second\n#define PR printf\nvoid RI() {}\ntemplate<typename... T>\nvoid RI(int& head,T&... tail) {\n    scanf(""%d"",&head);\n    RI(tail...);\n}\nvoid PRI(int x) {\n    printf(""%d\\n"",x);\n}\ntemplate<typename... Args>\nvoid PRI(int head,Args... tail) {\n    printf(""%d "",head);\n    PRI(tail...);\n}\n#define RF(x) scanf(""%lf"",&(x))\n#define RS(x) scanf(""%s"",x)\n#define DPRI(x) fprintf(stderr,""<""#x""=%d>\\n"",x)\n#define DPRII(x,y) fprintf(stderr,""<""#x""=%d, ""#y""=%d>\\n"",x,y)\n#define DPRIII(x,y,z) fprintf(stderr,""<""#x""=%d, ""#y""=%d, ""#z""=%d>\\n"",x,y,z)\n#define DPRIIII(x,y,z,w) fprintf(stderr,""<""#x""=%d, ""#y""=%d, ""#z""=%d ""#w""=%d>\\n"",x,y,z,w)\n#define DPRF(x) fprintf(stderr,""<""#x""=%lf>\\n"",x)\n#define DPRS(x) fprintf(stderr,""<""#x""=%s>\\n"",x)\n#define DPRMSG(x) fprintf(stderr,#x""\\n"")\n#define DPRPII(x) fprintf(stderr,""<""#x""=(%d,%d)>\\n"",x.F,x.S)\ntypedef pair<int,int> pii;\n// }}}\n// #functions {{{\npii operator+(const pii &a,const pii &b) { return MP(a.F+b.F,a.S+b.S); }\npii operator-(const pii &a,const pii &b) { return MP(a.F-b.F,a.S-b.S); }\npii& operator+=(pii &a,const pii &b) { a.F+=b.F; a.S+=b.S; return a; }\npii& operator-=(pii &a,const pii &b) { a.F-=b.F; a.S-=b.S; return a; }\ntemplate <class T,class U>\nbool cmp_second(const pair<T,U> &a,const pair<T,U> &b) { return a.second<b.second; }\ntemplate <class T>\nT gcd(T a,T b) { a=abs(a); b=abs(b); while(b) { T t=b; b=a%b; a=t; } return a; }\ntemplate <class T>\npair<T,T> ext_gcd(T a,T b) {\n   T a0=1,a1=0,b0=0,b1=1;\n   if(a<0) { a=-a; a0=-1; }\n   if(b<0) { b=-b; b1=-1; }\n   while(b) {\n      T t,q=a/b;\n      t=b; b=a-b*q; a=t;\n      t=b0; b0=a0-b0*q; a0=t;\n      t=b1; b1=a1-b1*q; a1=t;\n   }\n   return MP(a0,a1);\n}\ninline int sg(int x) { return x>=0?1:-1; }\ninline string concatenate_strings(vector<string> ss) {\n   string s;\n   for(int i=0;i<ss.size();i++)\n      s+=ss[i];\n   return s;\n}\ntemplate <class T>\ninline vector<T> read_from_string(string s) {\n   vector<T> ret; stringstream ss(s,stringstream::in);\n   while(1) { T x; ss>>x; ret.push_back(x); if(ss.eof()) break; }\n   return ret;\n}\n// }}}\n\n#define MAXN 8\n#define MAXS 240\n#define MAXV 200\n\nconst int inf=1000000000;\n\nint n,r,pn;\nvector<pii> pts;\nint dp[MAXN+1][MAXS+1][MAXS+1];\npair<pair<int,pii>,pii> pred[MAXN+1][MAXS+1][MAXS+1];\n\nvoid solve() {\n    pn = pts.size();\n    for(int i=0;i<=n;i++)\n        for(int xs=0;xs<=MAXS;xs++)\n            for(int ys=0;ys<=MAXS;ys++)\n                dp[i][xs][ys] = -inf;\n    dp[0][0][0] = 0;\n    for(int i=0;i<n;i++) {\n        for(int xs=0;xs<=MAXS;xs++) {\n            for(int ys=0;ys<=MAXS;ys++) {\n                int old = dp[i][xs][ys];\n                //printf(""%d %d %d = %d\\n"",i,xs,ys,dp[i][xs][ys]);\n                if(old<0) continue;\n                for(int v=0;v<pn;v++) {\n                    int x = pts[v].F;\n                    int y = pts[v].S;\n                    int val = old + (n-1)*(x*x+y*y) - 2*x*xs - 2*y*ys;\n                    int nxs = abs(xs+x);\n                    int nys = abs(ys+y);\n                    if(val>dp[i+1][nxs][nys]) {\n                        dp[i+1][nxs][nys] = val;\n                        pred[i+1][nxs][nys] = MP(MP(v,MP(sg(xs+x),sg(ys+y))),MP(xs,ys));\n                    }\n                }\n            }\n        }\n    }\n    //\n    pair<int,pii> ss(-inf,MP(0,0));\n    for(int xs=0;xs<=MAXS;xs++)\n        for(int ys=0;ys<=MAXS;ys++)\n            ss = max(ss,MP(dp[n][xs][ys],MP(xs,ys)));\n    int sol = ss.F;\n    int xs = ss.S.F;\n    int ys = ss.S.S;\n    printf(""%d\\n"",sol);\n    int gx=1;\n    int gy=1;\n    for(int i=n;i>0;i--) {\n        int v = pred[i][xs][ys].F.F;\n        int sgx = pred[i][xs][ys].F.S.F;\n        int sgy = pred[i][xs][ys].F.S.S;\n        //printf("">> %d %d %d\\n"",v,sgx,sgy);\n        int pxs = pred[i][xs][ys].S.F;\n        int pys = pred[i][xs][ys].S.S;\n        gx*=sgx;\n        gy*=sgy;\n        xs = pxs;\n        ys = pys;\n        printf(""%d %d\\n"",gx*pts[v].F,gy*pts[v].S);\n    }\n}\n\nint main(void)\n{\n    RI(n,r);\n    for(int x=-r;x<=r;x++)\n        for(int y=-r;y<=r;y++)\n            if(x*x+y*y<=r*r&&x*x+y*y>(r-1)*(r-1)) pts.PB(MP(x,y));\n    //printf(""%d\\n"",(int)pts.size());\n    solve();\n    return 0;\n}\n\n// vim: fdm=marker:commentstring=//\\ %s:nowrap:autoread\n\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2700
During the hypnosis session Nicholas suddenly remembered a positive integer n which Soon when he returned home he got curious what is the maximum number of digits that can be removed from the number so that the number becomes that is either composite or equal to one For some numbers doing so is impossible for example for number 53 it s impossible to delete some of its digits to obtain a not prime integer However Note that you cannot remove all the digits from the number A prime number is a number that has no divisors except one and itself A composite is a number that has more than two divisors 1 is neither a prime nor a composite number ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint t,n;\nbool a[105];\nstring s;\ninline bool prime(int p){\n    if(p==1)return 1;\n    for(register int i=2;i*i<=p;i++)if(p%i==0)return 1;\n    return 0;\n}\nsigned main(){\n    ios::sync_with_stdio(false);cin.tie(0),cout.tie(0);\n    cin>>t;\n    for(register int i=1;i<=100;i++)a[i]=prime(i);\n    while(t--){\n        cin>>n>>s;\n        bool flag=1;\n        for(register int i=0;i<n&&flag;i++)if(s[i]==\'1\'||s[i]==\'4\'||s[i]==\'6\'||s[i]==\'9\'||s[i]==\'8\'){cout<<""1\\n""<<s[i]<<endl;flag=0;}\n        if(!flag)continue;\n        for(register int i=0;i<n&&flag;i++)\n        for(register int j=i+1;j<n&&flag;j++)if(a[(s[i]-\'0\')*10+s[j]-\'0\']){\n            cout<<""2\\n""<<s[i]<<s[j]<<endl;\n            flag=0;\n        }\n    }\n    return 0;\n}']","[0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1000
Ringo found a string s of length n in his yellow submarine The string contains only lowercase letters from the English alphabet As Ringo and his friends love palindromes he would like to turn the string s into a palindrome by applying two types of operations to the string The first operation allows him to choose i 2 le i le n 1 and to append the substring s 2s 3 ldots s i i 1 characters reversed to the front of s The second operation allows him to choose i 2 le i le n 1 and to append the substring s i s i 1 ldots s n 1 n i characters reversed to the end of s Note that characters in the string in this problem are indexed from 1 For example suppose s If he performs the first operation with i 3 then he appends to the front of s and the result will be Performing the second operation on the resulted string with i 5 will yield Your task is to help Ringo make the entire string a palindrome by applying any of the two operations in total It is guaranteed that under these constraints there always is a solution Also note you do not have to minimize neither the number of operations applied nor the length of the resulting string but they have to fit into the constraints ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing llint = long long;\n\ninline void err() { cerr << endl; }\n\ntemplate<typename hd, typename... tl> void err(hd a, tl... b) {\n#ifdef KH_CODE\n\tcerr << a << \' \'; err(b...);\n#endif\n}\n\ntemplate<typename hd, typename tl> void chkmin(hd& a, tl b) {\n\tif(b < a) a = b;\n}\n\ntemplate<typename hd, typename tl> void chkmax(hd& a, tl b) {\n\tif(a < b) a = b;\n}\n\nstring s;\n\nint main() {\n#ifdef KH_CODE\n\tfreopen(""in.txt"", ""r"", stdin);\n\tfreopen(""out.txt"", ""w"", stdout);\n#endif\n\n\tios_base::sync_with_stdio(0);\n\t\n\tcin >> s;\n\tint n = s.length();\n\tcout << 3 << endl;\n\tcout << ""L "" << 2 << endl;\n\tcout << ""R "" << 2 << endl;\n\tcout << ""R "" << 2 * n - 1 << endl;\n\n\treturn 0;\n}\n\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1400
Jellyfish has n green apples with values a 1 a 2 dots a n and Gellyfish has m green apples with values b 1 b 2 ldots b m They will play a game with k rounds For i 1 2 ldots k in this order they will perform the following actions If i is odd Jellyfish can choose to swap one of her apples with one of Gellyfish s apples or do nothing If i is even Gellyfish can choose to swap one of his apples with one of Jellyfish s apples or do nothing Both players want to maximize the sum of the values of their apples Since you are one of the smartest people in the world Jellyfish wants you to tell her the final sum of the value of her apples after all k rounds of the game Assume that both Jellyfish and Gellyfish play optimally to maximize the sum of values of their apples ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7;\nint n, m, k, a[N], b[N];\nvoid Main() {\n\tcin >> n >> m >> k;\n\tL(i, 1, n) {\n\t\tcin >> a[i];\n\t}\n\tL(i, 1, m) {\n\t\tcin >> b[i];\n\t}\n\tk -= max(k - 10, 0) / 2 * 2;\n\tint op = 0;\n\twhile(k--) {\n\t\tsort(a + 1, a + n + 1);\n\t\tsort(b + 1, b + m + 1);\n\t\tif(!op) {\n\t\t\tif(a[1] < b[m])\n\t\t\t\tswap(a[1], b[m]);\n\t\t} else {\n\t\t\tif(b[1] < a[n])\n\t\t\t\tswap(b[1], a[n]);\n\t\t}\n\t\top ^= 1;\n\t} \n\tcout << accumulate(a + 1, a + n + 1, 0LL) << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n""]","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Given an integer x Your task is to find out how many positive integers n 1 leq n leq x satisfy n cdot a n equiv b quad textrm mod p where a b p are all known constants ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef long long LL;\n\nint a,b,p,cnt;\nLL x,tmp,r,P,ans;\n\ninline LL Pow(LL a,int b)\n{\n    LL ans=1;\n    for(;b;b>>=1,a=a*a%p)if(b&1)ans=ans*a%p;\n    return ans;\n}\n\nsigned main()\n{\n    scanf(""%d%d%d%lld"",&a,&b,&p,&x);\n    P=(LL)p*(p-1);\n    for(int i=1;i<p;i++)\n    {\n        tmp=Pow(a,i);\n        tmp=b*Pow(tmp,p-2)%p;\n        r=((LL)p*i+(LL)(p-1)*(p-1)%P*tmp)%P;\n        ans+=x/P+(x%P>=r);\n    }\n    cout<<ans<<endl;\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2100
You are given the array of integer numbers For each element find the distance to the nearest zero to the element which equals to zero There is at least one zero element in the given array ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = (int)1e6 + 7;\nint n;\nint a[N];\nint b[N];\n\nint main()\n{\n//    freopen(""input.txt"", ""r"", stdin);\n//    freopen(""output.txt"", ""w"", stdout);\n\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++)\n        scanf(""%d"", &a[i]);\n    for (int i = 0; i < n; i++)\n        b[i] = n;\n    int lst = -n;\n    for (int i = 0; i < n; i++)\n    {\n        if (a[i] == 0)\n            lst = i;\n        b[i] = min(b[i], i - lst);\n    }\n    lst = 2 * n;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if (a[i] == 0) lst = i;\n        b[i] = min(b[i], lst - i);\n    }\n    for (int i = 0; i < n; i++)\n        printf(""%d "", b[i]);\n    printf(""\\n"");\n\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
This is an easier version of the problem In this version n le 500 Vasya is an experienced developer of programming competitions problems As all great minds at some time Vasya faced a creative crisis To improve the situation Petya gifted him a string consisting of opening and closing brackets only Petya believes that the beauty of the bracket string is a number of its cyclical shifts which form a correct bracket sequence To digress from his problems Vasya decided to select two positions of the string and swap characters located at this positions with each other Vasya will apply this operation exactly once He is curious what is the maximum possible beauty he can achieve this way Please help him We remind that bracket sequence s is called correct if s is empty s is equal to t where t is correct bracket sequence s is equal to t 1 t 2 i e concatenation of t 1 and t 2 where t 1 and t 2 are correct bracket sequences For example are correct while and are not The cyclical shift of the string s of length n by k 0 leq k n is a string formed by a concatenation of the last k symbols of the string s with the first n k symbols of string s For example the cyclical shift of string by 2 equals Cyclical shifts i and j are considered different if i ne j ,"['// #pragma comment(linker, ""/stack:200000000"")\n// #pragma GCC optimize(""Ofast,no-stack-protector"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n// #pragma GCC optimize(""unroll-loops"")\n \n#include <bits/stdc++.h>\n \n#define debug(x) std::cerr << (#x) << "":\\t"" << (x) << std::endl;\n#define fastIO std::ios_base::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);\n \ntypedef long long ll;\ntypedef long double ld;\n \nstd::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n \nconst double PI = atan2(0., -1.);\nconst int INF = 0x3f3f3f3f;\nconst int N = 1 << 19;\n \nint n;\nchar str[N];\nint bal[N];\nint q[N];\n \nint getAns() {\n\tfor (int i = 0; i <= 3 * n; ++i) {\n\t\tbal[i] = 0;\n\t\tq[i] = 0;\n\t}\n \n\t// std::map<int, int> q;\n \n\tfor (int i = 0; i < n; ++i) {\n\t\tbal[i + 1] += bal[i];\n \n\t\tif (str[i] == \'(\') {\n\t\t\t++bal[i + 1];\n\t\t} else {\n\t\t\t--bal[i + 1];\n\t\t}\n\t}\n \n\tif (bal[0] != bal[n]) {\n\t\treturn 0;\n\t}\n \n\tfor (int i = 0; i < n; ++i) {\n\t\t++q[bal[i] + n];\n\t}\n \n \tfor (int i = 0; i < N; ++i) {\n \t\tif (q[i] != 0) {\n \t\t\treturn q[i];\n \t\t}\n \t}\n\n \tthrow 228;\n\t// return q.begin()->second;\n}\n \nint main(void) {\n\tscanf(""%d\\n%s"", &n, str);\n \n\tint ans = getAns();\n\tint fi = 0;\n\tint se = 0;\n \n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tif (str[i] != str[j]) {\n\t\t\t\tstd::swap(str[i], str[j]);\n \n\t\t\t\tint curAns = getAns();\n\t\t\t\tif (curAns > ans) {\n\t\t\t\t\tans = curAns;\n\t\t\t\t\tfi = i;\n\t\t\t\t\tse = j;\n\t\t\t\t}\n \n\t\t\t\tstd::swap(str[i], str[j]);\n\t\t\t}\n\t\t}\n\t}\t\n \n\tprintf(""%d\\n%d %d\\n"", ans, fi + 1, se + 1);\n \n\treturn 0;\n}']","[1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
It is winter now and Max decided it s about time he watered the garden The garden can be represented as consecutive garden beds numbered from to beds contain water taps th tap is located in the bed which if turned on start delivering water to neighbouring beds If the tap on the bed is turned on then after one second has passed the bed will be watered after two seconds have passed the beds from the segment will be watered if they exist after seconds have passed the beds from the segment will be watered if they exist The garden from test White colour denotes a garden bed without a tap red colour a garden bed with a tap The garden from test after seconds have passed after turning on the tap White colour denotes an unwatered garden bed blue colour a watered bed Max wants to and now he wonders what is the minimum number of seconds that have to pass after he turns on some taps until the whole garden is watered Help him to find the answer ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nbool chk[205];\nbool tchk[205];\nint main() {\n\tint T;\n\tscanf(""%d"", &T);\n\twhile (T--) {\n\t\tint N, K, i, j;\n\t\tscanf(""%d %d"", &N, &K);\n\n\t\tfor (i = 0; i <= N + 1; i++) chk[i] = false;\n\t\tfor (i = 1; i <= K; i++) {\n\t\t\tint t;\n\t\t\tscanf(""%d"", &t);\n\t\t\tchk[t] = true;\n\t\t}\n\t\tfor (i = 0;; i++) {\n\t\t\tint c = 0;\n\t\t\tfor (j = 1; j <= N; j++) if (chk[j]) c++;\n\t\t\tif (c == N) break;\n\n\t\t\tfor (j = 1; j <= N; j++) tchk[j] = chk[j - 1] | chk[j] | chk[j + 1];\n\t\t\tfor (j = 1; j <= N; j++) chk[j] = tchk[j];\n\t\t}\n\t\tprintf(""%d\\n"", i + 1);\n\t}\n\treturn 0;\n}\n//*/']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
A bracket sequence is a string containing only characters and A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters 1 and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are 1 1 1 1 1 and and are not You are given n bracket sequences s 1 s 2 dots s n Calculate the number of pairs i j 1 le i j le n such that the bracket sequence s i s j is a regular bracket sequence Operation means concatenation i e If s i s j and s j s i are regular bracket sequences and i ne j then both pairs i j and j i must be counted in the answer Also if s i s i is a regular bracket sequence the pair i i must be counted in the answer ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 800015;\nconst int nil = 400005;\n\nchar tmp[Maxn];\nint n;\nint st[Maxn], mn[Maxn];\nvector <int> V[Maxn];\nll res;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%s"", tmp); int tlen = strlen(tmp);\n\t\tmn[i] = Maxn;\n\t\tfor (int j = 0; j < tlen; j++) {\n\t\t\tif (tmp[j] == \'(\') st[i]++;\n\t\t\telse st[i]--;\n\t\t\tmn[i] = min(mn[i], st[i]);\n\t\t}\n\t\tV[st[i] + nil].push_back(mn[i]);\n\t}\n\tfor (int i = 0; i < Maxn; i++) if (V[i].size())\n\t\tsort(V[i].begin(), V[i].end());\n\tfor (int i = 0; i < n; i++) if (mn[i] >= 0) {\n\t\tint ost = nil - st[i];\n\t\tint add = V[ost].end() - lower_bound(V[ost].begin(), V[ost].end(), -st[i]);\n\t\tres += add;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
There are n consecutive seat places in a railway carriage Each place is either empty or occupied by a passenger The university team for the Olympiad consists of a student programmers and b student athletes Determine the largest number of students from all a b students which you can put in the railway carriage so that no student programmer is sitting next to the student programmer and no student athlete is sitting next to the student athlete In the other words there should not be two consecutive adjacent places where two student athletes or two student programmers are sitting Consider that initially occupied seat places are occupied by jury members who obviously are not students at all ,"[""#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<double,double> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n,a,b,ans;\nvi v;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> a >> b;\n    string s; cin >> s;\n    vi v;\n    int cur = 0;\n    for (char c: s) {\n        if (c == '*') {\n            if (cur) v.pb(cur);\n            cur = 0;\n        } else cur ++;\n    }\n    if (cur) v.pb(cur);\n    for (int i: v) {\n        if (a < b) swap(a,b);\n        int x = min(a,(i+1)/2), y = min(b,i/2);\n        a -= x, b -= y;\n        ans += x+y;\n    }\n    cout << ans;\n}\n\n// read the question correctly (is y a vowel?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)""]","[1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Alice and Bob received n candies from their parents Now they want to divide all candies among themselves fairly so that the total weight of Alice s candies is equal to the total weight of Bob s candies Check if they can do that Note that candies ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 102;\n\nint t;\n\nint n;\n\nint a[N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        for(int i = 1; i <= n; i++)\n            cin >> a[i];\n        int x = 0, y = 0;\n        for(int i = 1; i <= n; i++)\n        {\n            if(a[i] == 1)\n                x++;\n            else\n                y++;\n        }\n        if(x % 2 == 0 && y % 2 == 0)\n            cout << ""YES\\n"";\n        else if(x % 2 == 0 && y % 2 == 1 && x > 0)\n            cout << ""YES\\n"";\n        else\n            cout << ""NO\\n"";\n    }\n    return 0;\n}\n']","[1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Shakespeare is a widely known esoteric programming language in which programs look like plays by Shakespeare and numbers are given by combinations of ornate epithets In this problem we will have a closer look at the way the numbers are described in Shakespeare Each constant in Shakespeare is created from non negative powers of 2 using arithmetic operations For simplicity we ll allow only addition and subtraction and will look for a representation of the given number which requires a minimal number of operations You are given an integer You have to represent it as where each of is a non negative power of 2 possibly multiplied by 1 Find a representation which minimizes the value of ,"['#pragma comment(linker, ""/STACK:65777216"")\n \n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\ntypedef unsigned long long ull;\n \n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nchar s[1111111];\nint  n;\nint main(){\n#ifdef LocalHost\n\n    freopen(""input.txt"",""r"",stdin);\n//  freopen(""output.txt"",""w"",stdout);\n#endif\n\t\n\tgets(s);\n\tn = strlen(s);\n\tll rrr=0;\n\tREP(i,n) rrr=rrr*2+(s[i]-\'0\');\n\n\tvector<pii> r;\n\tvector<pii> v;\n\tint res = 0;\n\tREP(i,n){\n\t\tint dig = s[i]-\'0\';\n\t\tif(v.size() && v.back().first==dig) v.back().second++;\n\t\telse v.pb(pii(dig,1));\n\t}\n\tvector<pii> w;\n\tswap(v,w);\n\n\tint sm=0;\n\tREP(i,w.size()){\n\t\tpii curr = w[i];\n\t\tsm += curr.second;\n\t\tif(v.size() && v.back().first==0 && v.back().second==1 && (curr.second>1 || v.size()>1 && v[v.size()-2].second>1)){\n\t\t\tv.pop_back();\n\t\t\tv.back().second++;\n\t\t\tv.back().second+=curr.second;\n\t\t\tr.pb(pii(0,n-(sm-curr.second)));\n\t\t}else v.pb(curr);\n\t}\n\n\tint sum=0;\n\tREP(i,v.size()){\n\t\tif(v[i].first==1){\n\t\t\tif(v[i].second==1){\n\t\t\t\tr.pb(pii(1,n-sum-1));\n\t\t\t}else{\n\t\t\t\tr.pb(pii(1,n-sum));\n\t\t\t\tr.pb(pii(0,n-sum-v[i].second));\n\t\t\t}\n\t\t}\n\t\tsum += v[i].second;\n\t}\n\tcout<<r.size()<<endl;\n\tll t = 0;\n\tREP(i,r.size()){\n\t\t//if(r[i].first) t += 1ll<<r[i].second;\n\t\t//else t-=1ll<<r[i].second;\n\t\tprintf(""%c2^%d\\n"",r[i].first?\'+\':\'-\',r[i].second);\n\t}\n\n\t\n#ifdef LocalHost\n    cout<<rrr<<\' \'<<t<<endl;\n\tcout<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']","[1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
For some array c let s denote a as a sequence of indices p 1 p 2 p l such that 1 le p 1 p 2 dots p l le c and for each i in 1 l 1 p i 1 is the minimum number such that p i 1 p i and c p i 1 c p i You are given an array a 1 a 2 dots a n For each its subsegment of length k calculate the length of its longest greedy subsequence ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 1000 * 1000 + 7;\nconst int INF = 1000 * 1000 * 1000 + 7;\n\nint t[4 * MX];\nint md[4 * MX];\n\nvoid push(int v) {\n    md[v + v] += md[v];\n    md[v + v + 1] += md[v];\n    md[v] = 0;\n}\n\nint gv(int v) {\n    return t[v] + md[v];\n}\n\nvoid pop(int v) {\n    t[v] = max(gv(v + v), gv(v + v + 1));\n}\n\nvoid ad(int v, int tl, int tr, int l, int r, int x) {\n    if (r < tl || l > tr) {\n        return;\n    }\n    if (tl >= l && tr <= r) {\n        md[v] += x;\n    } else {\n        push(v);\n        int tm = (tl + tr) >> 1;\n        ad(v + v, tl, tm, l, r, x);\n        ad(v + v + 1, tm + 1, tr, l, r, x);\n        pop(v);\n    }\n}\n\nvector<int> g[MX];\nint tin[MX], tout[MX];\nint timer = 1;\nint a[MX];\n\nvoid dfs(int v) {\n    tin[v] = timer;\n    timer++;\n    for (int to : g[v]) {\n        dfs(to);\n    }\n    tout[v] = timer - 1;\n}\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    vector<pair<int, int> > st;\n    st.emplace_back(INF, n + 1);\n    for (int i = n; i >= 1; i--) {\n        while (!st.empty() && st.back().first <= a[i]) {\n            st.pop_back();\n        }\n        if (st.back().second != n + 1) {\n            g[st.back().second].push_back(i);\n        }\n        st.emplace_back(a[i], i);\n    }\n    for (int i = n; i >= 1; i--) {\n        if (tin[i] == 0) {\n            dfs(i);\n        }\n    }\n    int l = 1, r = 1;\n    auto mvr = [&]() {\n        ad(1, 1, n, tin[r], tout[r], 1);\n        r++;\n    };\n    auto mvl = [&]() {\n        ad(1, 1, n, tin[l], tin[l], -INF);\n        l++;\n    };\n    for (int i = 1; i + k - 1 <= n; i++) {\n        int gl = i, gr = i + k;\n        while (r < gr) {\n            mvr();\n        }\n        while (l < gl) {\n            mvl();\n        }\n        cout << gv(1) << ""\\n"";\n    }\n    return 0;\n}\n\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2400
Two boys decided to compete in text typing on the site Key races During the competition they have to type a text consisting of characters The first participant types one character in milliseconds and has ping milliseconds The second participant types one character in milliseconds and has ping milliseconds If connection ping delay is milliseconds the competition passes for a participant as follows Exactly after milliseconds after the start of the competition the participant receives the text to be entered Right after that he starts to type it Exactly milliseconds after he ends typing all the text the site receives information about it The winner is the participant whose information on the success comes earlier If the information comes from both participants at the same time it is considered that there is a draw Given the length of the text and the information about participants determine the result of the game ,"['#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<cstdlib>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint main()\n{\n\tint s,v1,v2,t1,t2;\n\tint s1,s2;\n\tscanf(""%d%d%d%d%d"",&s,&v1,&v2,&t1,&t2);\n\ts1=2*t1+s*v1;\n\ts2=2*t2+s*v2;\n\tif(s1<s2)\n\t\tprintf(""First\\n"");\n\telse if(s2<s1)\n\t\tprintf(""Second\\n"");\n\telse\n\t\tprintf(""Friendship\\n"");\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Artsem has a friend Saunders from University of Chicago Saunders presented him with the following problem Let denote the set We will also write when a function is defined in integer points and all its values are integers from 1 to Now then you are given a function Your task is to find a positive integer and two functions such that for all and for all or determine that finding these is impossible ,"['#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = (int) 1e5 + 100;\nint a[N];\nint st[N];\nint sz = 0;\nint o2[N];\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(""%d"", &a[i] );\n\t\ta[i]--;\n\t}\n\tmemset(st, -1, sizeof st);\n\tfor (int i = 0; i < n; i++)\n\t\tif (i == a[i] )\n\t\t{\n\t\t\to2[sz] = i;\n\t\t\tst[i] = sz++;\n\t\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (st[a[i] ] == -1)\n\t\t{\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn 0;\n\t\t}\n\tprintf(""%d\\n"", sz);\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%d "", st[a[i] ] + 1);\n\tprintf(""\\n"");\n\tfor (int i = 0; i < sz; i++)\n\t\tprintf(""%d "", o2[i] + 1);\n\tprintf(""\\n"");\n\n\n\n\n\treturn 0;\n}\n\n\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",1700
Mihai and Bianca are playing with bags of candies They have a row a of n bags of candies The i th bag has a i candies The bags are given to the players in the order from the first bag to the n th bag If a bag has an even number of candies Mihai grabs the bag Otherwise Bianca grabs the bag Once a bag is grabbed the number of candies in it gets added to the total number of candies of the player that took it Mihai wants to show off so he wants to reorder the array so that at any moment except at the start when they both have no candies Mihai will have candies than Bianca Help Mihai find out if such a reordering exists ,"['#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++)\n    {\n        int n, sm1 = 0, sm2 = 0;\n        cin >> n;\n        for (int j = 0; j < n; j++)\n        {\n            int a;\n            cin >> a;\n            if (a % 2 == 0) sm1 += a;\n            else sm2 += a;\n        }\n        if (sm1 > sm2) cout << ""YES\\n"";\n        else cout << ""NO\\n"";\n    }\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
There is a rectangular grid of size n times m Each cell has a number written on it the number on the cell i j is a i j Your task is to calculate the number of paths from the upper left cell 1 1 to the bottom right cell n m meeting the following constraints You can move to the right or to the bottom only Formally from the cell i j you may move to the cell i j 1 or to the cell i 1 j The target cell can t be outside of the grid The of all the numbers on the path from the cell 1 1 to the cell n m must be equal to k operation is the bitwise exclusive OR it is represented as in Java or C and in Pascal Find the number of such paths in the given grid ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 20;\n\nint n, m;\nlong long k;\nlong long a[MAX_N + 1][MAX_N + 1];\nmap<long long, long long> f[MAX_N + 1][MAX_N + 1];\nlong long ans;\n\nvoid backtrack1(int x, int y, int step, long long xorsum) {\n\tif (step == n) {\n\t\tf[x][y][xorsum]++;\n\t\treturn;\n\t}\n\tif (x < n) {\n\t\tbacktrack1(x + 1, y, step + 1, xorsum ^ a[x + 1][y]);\n\t}\n\tif (y < m) {\n\t\tbacktrack1(x, y + 1, step + 1, xorsum ^ a[x][y + 1]);\n\t}\n}\n\nvoid backtrack2(int x, int y, int step, long long xorsum) {\n\tif (step == m) {\n\t\tans += f[x][y][k ^ a[x][y] ^ xorsum];\n\t\treturn;\n\t}\n\tif (x > 1) {\n\t\tbacktrack2(x - 1, y, step + 1, xorsum ^ a[x - 1][y]);\n\t}\n\tif (y > 1) {\n\t\tbacktrack2(x, y - 1, step + 1, xorsum^a[x][y - 1]);\n\t}\n}\n\nint main() {\n\t//freopen(""input.inp"", ""r"", stdin);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n >> m >> k;\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= m; ++j)\n\t\t\tcin >> a[i][j];\n\tans = 0;\n\tbacktrack1(1, 1, 1, a[1][1]);\n\tbacktrack2(n, m, 1, a[n][m]);\n\tcout << ans;\n\treturn 0;\n}']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2100
You are given a Young diagram Given diagram is a histogram with n columns of lengths a 1 a 2 ldots a n a 1 geq a 2 geq ldots geq a n geq 1 Your goal is to find the largest number of non overlapping dominos that you can draw inside of this histogram a domino is a 1 times 2 or 2 times 1 rectangle ,"[""/**\n *    author:  tourist\n *    created: 21.12.2019 14:08:24       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<long long> cnt(2, 0);\n  for (int i = 0; i < n; i++) {\n    cnt[i % 2] += a[i] / 2;\n    cnt[(i + 1) % 2] += (a[i] + 1) / 2;\n  }\n  cout << min(cnt[0], cnt[1]) << '\\n';\n  return 0;\n}\n""]","[1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Recently you bought a brand new smart lamp with programming features At first you set up a schedule to the lamp Every day it will turn power on at moment 0 and turn power off at moment M Moreover the lamp allows you to set a program of switching its state states are lights on and lights off Unfortunately some program is already installed into the lamp The lamp allows only programs Good program can be represented as a non empty array a where 0 a 1 a 2 dots a a M All a i must be integers Of course preinstalled program is a good program The lamp follows program a in next manner at moment 0 turns power and light on Then at moment a i the lamp flips its state to opposite if it was lit it turns off and vice versa The state of the lamp flips instantly for example if you turn the light off at moment 1 and then do nothing the total time when the lamp is lit will be 1 Finally at moment M the lamp is turning its power off regardless of its state Since you are not among those people who read instructions and you don t understand the language it s written in you realize after some testing the only possible way to alter the preinstalled program You can element into the program a so it still should be a program after alteration Insertion can be done between any pair of consecutive elements of a or even at the begining or at the end of a Find such a way to alter the program that the total time when the lamp is lit is maximum possible Maybe you should leave program untouched If the lamp is lit from x till moment y then its lit for y x units of time Segments of time when the lamp is lit are summed up ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 100100;\nconst long long Q = 2e18;\nconst long long mod = 1e9 + 7;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint m;\nint d[N][2][2];\n\nvoid solve()\n{\n        vector < int > a;\n        a.push_back(0);\n        cin >> n >> m;\n        for(int i = 1; i <= n; i++){\n                int x;\n                cin >> x;\n                a.push_back(x);\n                d[i][0][0] = -1e9;\n                d[i][1][0] = -1e9;\n                d[i][0][1] = -1e9;\n                d[i][1][1] = -1e9;\n        }\n        d[0][0][0] = -1e9;\n        d[0][1][0] = -1e9;\n        a.push_back(m);\n        for(int i = 1; i <= n + 1; i++){\n                d[i][0][0] = d[i - 1][0][1] + a[i] - a[i - 1];\n                d[i][0][1] = d[i - 1][0][0];\n                d[i][1][0] = d[i - 1][1][1] + a[i] - a[i - 1];\n                if(a[i - 1] + 1 < a[i]) d[i][1][0] = max(d[i][1][0], d[i - 1][0][0] + a[i] - a[i - 1] - 1);\n                d[i][1][1] = d[i - 1][1][0];\n                if(a[i - 1] + 1 < a[i]) d[i][1][1] = max(d[i][1][1], d[i - 1][0][1] + a[i] - a[i - 1] - 1);\n        }\n        n++;\n        int ans = d[n][0][0];\n        ans = max(ans, d[n][0][1]);\n        ans = max(ans, d[n][1][0]);\n        ans = max(ans, d[n][1][1]);\n        cout << ans << ""\\n"";\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
You are given a directed acyclic graph a directed graph that does not contain cycles of n vertices and m arcs The i th arc leads from the vertex x i to the vertex y i and has the weight w i Your task is to select an integer a v for each vertex v and then write a number b i on each arcs i such that b i a x i a y i You must select the numbers so that all b i are positive the value of the expression sum limits i 1 m w i b i is the lowest possible It can be shown that for any directed acyclic graph with non negative w i such a way to choose numbers exists ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=20;\nint n,m,S,ind[N];\nint e[1<<18|5];\nint f[1<<18|5];\nint fr[1<<18|5];\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tFor(i,1,m){\n\t\tint x,y,w;\n\t\tscanf(""%d%d%d"",&x,&y,&w);\n\t\t--x; --y;\n\t\tind[y]|=1<<x;\n\t\te[(1<<x)|(1<<y)]=w;\n\t\tS+=w;\n\t}\n\tFor(i,0,n-1)\n\t\tFor(S,0,(1<<n)-1)\n\t\t\tif (S&(1<<i))\n\t\t\t\te[S]+=e[S^(1<<i)];\n\tmemset(f,30,sizeof(f));\n\tf[0]=0;\n\tFor(i,0,(1<<n)-1){\n\t\t//cerr<<i<<endl;\n\t\tf[i]+=S-e[i]-e[(1<<n)-1-i];\n\t\tint SS=0;\n\t\tFor(j,0,n-1) if (!(i&(1<<j)))\n\t\t\tif ((ind[j]&i)==ind[j])\n\t\t\t\tSS|=1<<j;\n\t\tfor (int j=SS;j;j=(j-1)&SS)\n\t\t\tif (f[i|j]>f[i]) f[i|j]=f[i],fr[i|j]=j;\n\t}\n\tint res[20];\n\tFor(i,0,n-1) res[i]=0;\n\tint S=(1<<n)-1;\n\tfor (;S;S-=fr[S]){\n\t\t//cout<<S<<\' \'<<fr[S]<<endl;\n\t\tFor(i,0,n-1) if (S&(1<<i)) ++res[i];\n\t}\n\tFor(i,0,n-1) cout<<res[i]<<\' \';\n}']","[0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2600
There are n houses in a row They are numbered from 1 to n in order from left to right Initially you are in the house 1 You have to perform k moves to other house In one move you go from your current house to some other house You can t stay where you are i e in each move the new house differs from the current house If you go from the house x to the house y the total distance you walked increases by x y units of distance where a is the absolute value of a It is possible to visit the same house multiple times but you can t visit the same house in sequence Your goal is to walk exactly s units of distance in total If it is impossible print Otherwise print and any of the ways to do that Remember that you should do exactly k moves ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define p_b push_back\n#define pll pair<ll,ll>\n#define endl ""\\n""\n#define m_p make_pair\n#define all(x) x.begin(),x.end()\n#define ld long double\n\nusing namespace std;\ntypedef long long ll;\nconst ll MAXN = 1123456;\n\ntemplate <typename T>\nT sqr(T x){\n    return x * x;\n}\n\ntemplate <typename T>\nvoid vout(T s){\n    cout << s << endl;\n    exit(0);\n}\n\nll bp(ll a,ll n){\n    ll res = 1;\n    while(n){\n        if(n % 2)res *= a;\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main(){\n    ios_base :: sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n    ll n, k, s;\n    cin >> n >> k >> s;\n    vector <ll> ans(k);\n    if((n - 1) * k < s)vout(""NO"");\n    if(s < k)vout(""NO"");\n    cout << ""YES\\n"";\n    ll pos = 1;\n    for(int i = 0; i < k; i++){\n        ll ost = k - i - 1;\n        ll sum = min(n - 1, s - ost);\n        s -= sum;\n        if(pos + sum <= n)pos += sum; else pos -= sum;\n        ans[i] = pos;\n    }\n    for(auto i : ans)cout << i << "" "";\n\n    return 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
An online contest will soon be held on ForceCoders a large competitive programming platform The authors have prepared n problems and since the platform is very popular 998244351 coder from all over the world is going to solve them For each problem the authors estimated the number of people who would solve it for the i th problem the number of accepted solutions will be between l i and r i inclusive The creator of ForceCoders uses different criteria to determine if the contest is good or bad One of these criteria is the number of inversions in the problem order An inversion is a pair of problems x y such that x is located earlier in the contest x y but the number of accepted solutions for y is greater Obviously both the creator of ForceCoders and the authors of the contest want the contest to be good Now they want to calculate the probability that there will be inversions in the problem order assuming that for each problem i any number of accepted solutions for it between l i and r i is equally probable and all these numbers are independent ,"['// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < \'0\' || c > \'9\') && c != \'-\'; c = getc()) {\n        assert(~c);\n    }\n    if (c == \'-\') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= \'0\' && c <= \'9\'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 105;\nconst int MOD = 998244353;\n\nint qpow(int base, int e) {\n    int ret = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret = (LL) ret * base % MOD;\n        }\n        base = (LL) base * base % MOD;\n    }\n    return ret;\n}\n\nvoid iadd(int &dp, const int &val) {\n    dp += val;\n    if (dp >= MOD) {\n        dp -= MOD;\n    }\n}\n\nvoid ladd(int &dp, const LL &val) {\n    dp = (dp + val) % MOD;\n}\n\nint inv[N];\n\nvoid prep_inv() {\n    inv[0] = 1;\n    for (unsigned i = 1; i < N; ++i) {\n        inv[i] = (LL) inv[i - 1] * qpow(i, MOD - 2) % MOD;\n    }\n}\n\nint comb(int l, int n) {\n    if (!n) return 1;\n    int ret = (LL) inv[n] * qpow(l, MOD - 1 - n) % MOD;\n    for (int i = 0; i < n; ++i) {\n        ret = (LL) ret * (l + i) % MOD;\n    }\n    return ret;\n}\n\nint n, l[N], r[N];\nint f[N][N][N];\n\nint main() {\n    prep_inv();\n    n = read();\n    vector<int> vc = {-1};\n    for (int i = 0; i < n; ++i) {\n        l[i] = read();\n        r[i] = read() + 1;\n        vc.emplace_back(l[i]);\n        vc.emplace_back(r[i]);\n    }\n    reverse(l, l + n);\n    reverse(r, r + n);\n    sort(vc.begin(), vc.end());\n    vc.erase(unique(vc.begin(), vc.end()), vc.end());\n    int segs = (int) vc.size() - 1;\n    f[0][0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        int sum = 0;\n        for (int id = 0; id < segs; ++id) {\n            int lb = vc[id], rb = vc[id + 1];\n            if (l[i] <= lb && rb <= r[i]) {\n                int prob = min(rb, r[i]) - max(lb, l[i]);\n                f[i + 1][id][1] = (LL) sum * prob % MOD;\n                for (int j = 1; j < n; ++j) {\n                    f[i + 1][id][j + 1] = (LL) f[i][id][j] * prob % MOD;\n                }\n            }\n            for (int j = 0; j < n; ++j) {\n                if (f[i][id][j]) {\n                    if (id) {\n                        ladd(sum, (LL) f[i][id][j] * comb(rb - lb, j));\n                    } else {\n                        ladd(sum, f[i][id][j]);\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < segs; ++i) {\n        int len = vc[i + 1] - vc[i];\n        for (int j = 1; j <= n; ++j) {\n            ladd(ans, (LL) f[n][i][j] * comb(len, j));\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        ans = (LL) ans * qpow(r[i] - l[i], MOD - 2) % MOD;\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2700
Nadeko s birthday is approaching As she decorated the room for the party a long garland of Dianthus shaped paper pieces was placed on a prominent part of the wall Brother Koyomi will like it Still unsatisfied with the garland Nadeko decided to polish it again The garland has pieces numbered from to from left to right and the th piece has a colour denoted by a lowercase English letter Nadeko will repaint of the pieces to give each of them an arbitrary new colour still denoted by a lowercase English letter After this work she finds out all subsegments of the garland containing pieces of only colour Brother Koyomi s favourite one and takes the length of the longest among them to be the of the garland For instance let s say the garland is represented by and Brother Koyomi s favourite colour is Among all subsegments containing pieces of only is the longest with a length of Thus the of this garland equals But problem arises as Nadeko is unsure about Brother Koyomi s favourite colour and has swaying ideas on the amount of work to do She has plans on this each of which can be expressed as a pair of an integer and a lowercase letter meanings of which are explained above You are to find out the maximum achievable after repainting the garland according to each plan ,"['/*\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nint q[1600][26];\n\nstring s;\n\nint n;\n\nvoid precalc(){\n    for (int k = 1; k <= n; k++)\n        for (int col = 0; col < 26; col++){\n            vector<int> mas;\n            mas.push_back(-1);\n            for (int i = 0; i < n; i++)\n                if (s[i] != col + \'a\')\n                    mas.push_back(i);\n            mas.push_back(n);\n            if (mas.size() < k + 2)\n                q[k][col] = n;\n            else\n            for (int i = k; i < mas.size() - 1; i++)\n                q[k][col] = max(q[k][col], mas[i + 1] - mas[i - k] - 1);\n        }\n}\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(""a.in"");\n    ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #else\n    //ifstream cin(""a.in"");\n    //ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n >> s;\n    precalc();\n    int zap;\n    cin >> zap;\n    for (int i = 0; i < zap; i++){\n        int k;\n        char col;\n        cin >> k >> col;\n        cout << q[k][col - \'a\'] << \'\\n\';\n    }\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0]",1600
Hossam woke up bored so he decided to create an interesting array with his friend Hazem Now they have an array a of n positive integers Hossam will choose a number a i and Hazem will choose a number a j Count the number of interesting pairs a i a j that meet all the following conditions 1 le i j le n i neq j The absolute difference a i a j must be equal to the maximum absolute difference over all the pairs in the array More formally a i a j max 1 le p q le n a p a q ,"[""#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define sz(x) (int)(x).size()\nusing namespace std;\n\n// вправо, вниз, влево, вверх\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\n// ход конем\n//int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\n//int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n\nmt19937 rnd(chrono::system_clock::now().time_since_epoch().count());\nmt19937_64 rnd64(chrono::system_clock::now().time_since_epoch().count());\nint rndInteger (int l, int r) {\n    return uniform_int_distribution<int> (l, r)(rnd);\n}\n\nconst int MOD = (int) 998244353;\nconst int N = (int) 1e6 + 7;\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int T;\n    cin >> T;\n    while(T--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (auto &e : a) cin >> e;\n        sort(a.begin(), a.end());\n\n        int x = 0, y = 0;\n        for (int w : a)\n            if(w == a[n-1]) ++y;\n            else if(w == a[0]) ++x;\n        if(a[0] == a[n-1]) {\n            cout << n * (ll)(n-1) << '\\n';\n        } else {\n            cout << x * (ll)y * (ll)2 << '\\n';\n        }\n    }\n\n    return 0;\n}\n""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",900
You are given an array consisting of n integers a 1 a 2 dots a n and an integer x It is guaranteed that for every i 1 le a i le x Let s denote a function f l r which erases all values such that l le a i le r from the array a and returns the resulting array For example if a 4 1 1 4 5 2 4 3 then f 2 4 1 1 5 Your task is to calculate the number of pairs l r such that 1 le l le r le x and f l r is sorted in non descending order Note that the empty array is also considered sorted ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\nint tab[nax];\n\nvi wek[nax];\n\nll wyn;\n\nint pocz[nax];\nint kon[nax];\n\nint czyok(int a, int b)\n{\n\treturn pocz[a-1]<kon[b+1];\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%d"", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\twek[tab[i]].push_back(i);\n\tpocz[0]=0;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tif (wek[i].empty())\n\t\t{\n\t\t\tpocz[i]=pocz[i-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (wek[i][0]<pocz[i-1])\n\t\t\t\tpocz[i]=n+7;\n\t\t\telse\n\t\t\t\tpocz[i]=wek[i].back();\n\t\t}\n\t}\n\tkon[m+1]=n+1;\n\tfor (int i=m; i; i--)\n\t{\n\t\tif (wek[i].empty())\n\t\t{\n\t\t\tkon[i]=kon[i+1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (wek[i].back()>kon[i+1])\n\t\t\t\tkon[i]=-7;\n\t\t\telse\n\t\t\t\tkon[i]=wek[i][0];\n\t\t}\n\t}\n\t//~ debug() << range(pocz+1, pocz+m);\n\t//~ debug() << range(kon+1, kon+m);\n\tint w=0;\n\tfor (int i=1; i<=m && czyok(i, m); i++)\n\t{\n\t\tw=max(w, i);\n\t\twhile(!czyok(i, w))\n\t\t\tw++;\n\t\t//~ debug() << i << "" "" << w;\n\t\twyn+=m-w+1;\n\t}\n\t\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]",2100
Twilight Sparkle was playing Ludo with her friends Rainbow Dash Apple Jack and Flutter Shy But she kept losing Having returned to the castle Twilight Sparkle became interested in the dice that were used in the game The dice has faces the first face of the dice contains a dot the second one contains two dots and so on the th face contains dots Twilight Sparkle is sure that when the dice is tossed each face appears with probability Also she knows that each toss is independent from others Help her to calculate the expected maximum number of dots she could get after tossing the dice times ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n\n#define inf 0x3f3f3f3f\n#define Inf 0x3FFFFFFFFFFFFFFFLL\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define Rep(i, n) for (int i = 1; i <= (n); ++i)\n#define clr(x, a) memset(x, (a), sizeof x)\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tint m, n; scanf(""%d%d"", &m, &n);\n\tdouble ret = 0;\n\tdouble t = 1;\n\tfor (int i = m; i >= 1; --i) {\n\t\tt -= pow(1.0 * (i - 1) / m, n);\n\t\tret += t * i;\n\t\tt = pow(1.0 * (i - 1) / m, n);\n\t}\n\tprintf(""%.10lf\\n"", ret);\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1600
You are given an array a 1 a 2 dots a n of distinct positive integers You have to do the following operation choose a positive integer k for each i from 1 to n replace a i with a i text mod k dagger Find a value of k such that 1 leq k leq 10 18 and the array a 1 a 2 dots a n contains 2 distinct values at the end of the operation It can be shown that under the constraints of the problem at least one such k always exists If there are multiple solutions you can print any of them dagger a text mod b denotes the remainder after dividing a by b For example 7 text mod 3 1 since 7 3 cdot 2 1 15 text mod 4 3 since 15 4 cdot 3 3 21 text mod 1 0 since 21 21 cdot 1 0 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t,class u>\nint lwb(const vc<t>&v,const u&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t,class u>\nbool bis(const vc<t>&v,const u&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\ntemplate<class t,size_t K,class s=t>\ns SUM(const array<t,K>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class A>\nauto MIN(const A&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nvoid soin(S&s){\n\tsort(all(s));\n}\n\ntemplate<class S,class F>\nvoid soin(S&s,F&&f){\n\tsort(all(s),forward<F>(f));\n}\n\ntemplate<class S>\nS soout(S s){\n\tsoin(s);\n\treturn s;\n}\n\ntemplate<class S>\nvoid rein(S&s){\n\treverse(all(s));\n}\n\ntemplate<class S>\nS reout(S s){\n\trein(s);\n\treturn s;\n}\n\ntemplate<class t,class u>\npair<t,u>&operator+=(pair<t,u>&a,pair<t,u> b){\n\ta.a+=b.a;a.b+=b.b;return a;}\ntemplate<class t,class u>\npair<t,u>&operator-=(pair<t,u>&a,pair<t,u> b){\n\ta.a-=b.a;a.b-=b.b;return a;}\ntemplate<class t,class u>\npair<t,u> operator+(pair<t,u> a,pair<t,u> b){return mp(a.a+b.a,a.b+b.b);}\ntemplate<class t,class u>\npair<t,u> operator-(pair<t,u> a,pair<t,u> b){return mp(a.a-b.a,a.b-b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t,class u>\nvoid pb(vc<t>&a,const vc<u>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t,class...Args>\nvc<t> cat(vc<t> a,Args&&...b){\n\t(pb(a,forward<Args>(b)),...);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t>\nvc<t> operator+(const vc<t>&a,const vc<t>&b){\n\tvc<t> c(max(si(a),si(b)));\n\trep(i,si(a))c[i]+=a[i];\n\trep(i,si(b))c[i]+=b[i];\n\treturn c;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\ntemplate<class t,class u>\nvoid remval(vc<t>&a,const u&v){\n\ta.erase(remove(all(a),v),a.ed);\n}\n\ntemplate<class VS,class u>\nvoid fila(VS&vs,const u&a){\n\tfill(all(vs),a);\n}\n\ntemplate<class t,class u>\nint findid(const vc<t>&vs,const u&a){\n\tauto itr=find(all(vs),a);\n\tif(itr==vs.ed)return -1;\n\telse return itr-vs.bg;\n}\n\ntemplate<class t>\nvoid rtt(vc<t>&vs,int i){\n\trotate(vs.bg,vs.bg+i,vs.ed);\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;cin>>n;\n\tvi a=readvi(n);\n\tfor(int w=1;;w<<=1){\n\t\tvi b(n);\n\t\trep(i,n)b[i]=a[i]%w;\n\t\tmkuni(b);\n\t\tif(si(b)==2){\n\t\t\tprint(w);\n\t\t\treturn;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]",1200
As you know Martian scientists are actively engaged in space research One of the highest priorities is Pluto In order to study this planet in more detail it was decided to build a laboratory on Pluto It is known that the lab will be built of n square blocks of equal size For convenience we will assume that Pluto s surface is a plane divided by vertical and horizontal lines into unit squares Each square is either occupied by a lab block or not and only n squares are occupied Since each block is square it has four walls If a wall is adjacent to another block it is considered otherwise Pluto is famous for its extremely cold temperatures so the outside walls of the lab must be insulated One unit of insulation per exterior wall would be required Thus the greater the total length of the outside walls of the lab i e its perimeter the more insulation will be needed Consider the lab layout in the figure below It shows that the lab consists of n 33 blocks and all the blocks have a total of 24 outside walls i e 24 units of insulation will be needed You should build the lab optimally i e minimize the amount of insulation On the other hand there may be many optimal options so scientists may be interested in the number of ways to build the lab using the minimum amount of insulation modulo a prime number m Two ways are considered the same if they are the same when overlapping without turning Thus if a lab plan is rotated by 90 circ such a new plan can be considered a separate way To help scientists explore Pluto you need to write a program that solves these difficult problems ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define ll long long\n#define ii pair<int,int>\n#define iii tuple<int,int,int>\n#define fi first\n#define se second\n#define endl \'\\n\'\n#define debug(x) cout << #x << "": "" << x << endl\n\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define lb lower_bound\n#define ub upper_bound\n\n#define rep(x,start,end) for(int x=(start)-((start)>(end));x!=(end)-((start)>(end));((start)<(end)?x++:x--))\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n\nmt19937 rng(chrono::system_clock::now().time_since_epoch().count());\n\nint n,MOD;\nvector<int> area;\n\nint memo[1005]; //excess is at most this much???\n\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin.exceptions(ios::badbit | ios::failbit);\n\t\n\trep(x,0,2000) area.pub((x/2)*((x+1)/2));\n\t\n\tint TC,TYP;\n\tcin>>TC>>TYP;\n\tif (TYP==2){\n\t\tcin>>MOD;\n\t\t\n\t\tmemo[0]=1;\n\t\trep(x,1,1005) rep(z,0,4){\n\t\t\trep(y,0,1005-x){\n\t\t\t\tmemo[x+y]=(memo[x+y]+memo[y])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (TC--){\n\t\tcin>>n;\n\t\t\n\t\tint lo=0,hi=sz(area),mi;\n\t\twhile (hi-lo>1){\n\t\t\tmi=hi+lo>>1;\n\t\t\tif (area[mi]<n) lo=mi;\n\t\t\telse hi=mi;\n\t\t}\n\t\t\n\t\tint h=hi/2,w=(hi+1)/2;\n\t\t\t\n\t\tif (TYP==1){\n\t\t\tcout<<h<<"" ""<<w<<endl;\n\t\t\t\n\t\t\trep(x,0,h){\n\t\t\t\trep(y,0,w){\n\t\t\t\t\tif (n){\n\t\t\t\t\t\tcout<<""#"";\n\t\t\t\t\t\tn--;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tcout<<""."";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout<<endl;\n\t\t\t}\t\n\t\t}\n\t\telse{\n\t\t\tint p=h+w;\n\t\t\t\n\t\t\tint ans=0;\n\t\t\trep(x,h-105,h+105){\n\t\t\t\tint w=p-x;\n\t\t\t\tif (w>0 && x>0 && n<=x*w) ans=(ans+memo[x*w-n])%MOD;\n\t\t\t}\n\t\t\t\n\t\t\tcout<<2*p<<"" ""<<ans<<endl;\n\t\t}\n\t}\n}\n']","[1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
Luckily Serval got onto the right bus and he came to the kindergarten on time After coming to kindergarten he found the toy bricks very funny He has a special interest to create difficult problems for others to solve This time with many 1 times 1 times 1 toy bricks he builds up a 3 dimensional object We can describe this object with a n times m matrix such that in each cell i j there are h i j bricks standing on the top of each other However Serval doesn t give you any h i j and just give you the front view left view and the top view of this object and he is now asking you to restore the object Note that in the front view there are m columns and in the i th of them the height is the maximum of h 1 i h 2 i dots h n i It is similar for the left view where there are n columns And in the top view there is an n times m matrix t i j where t i j is 0 or 1 If t i j equals 1 that means h i j 0 otherwise h i j 0 However Serval is very lonely because others are bored about his unsolvable problems before and refused to solve this one although this time he promises there will be at least one object satisfying all the views As his best friend can you have a try ,"['//ihdignite\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 1e2;\n\nint n, m, h, a[MAXN], b[MAXN], c[MAXN][MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(NULL);\n\n\tcin >> n >> m >> h;\n\tfor(int i=0; i<m; ++i)\n\t\tcin >> a[i];\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> b[i];\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<m; ++j) {\n\t\t\tcin >> c[i][j];\n\t\t\tif(c[i][j])\n\t\t\t\tc[i][j]=min(a[j], b[i]);\n\t\t\tcout << c[i][j] << "" "";\n\t\t}\n\t\tcout << ""\\n"";\n\t}\n\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You are given a sequence of positive integers and two non negative integers and Your task is to transform into To do that you can perform the following moves subtract 1 from the current subtract mod from the current Operation mod means taking the remainder after division of number by number Now you want to know the minimum number of moves needed to transform into ,"['#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <set>\nusing namespace std;\n//#pragma comment(linker,""/STACK:102400000,102400000"")\n\nint n;\nvector <int> xs;\nvector <int> nex_xs;\nint A, B;\n\nmap <int, int> occur;\n\nint MAIN()\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint t;\n\t\tcin >> t;\n\t\tif(!occur.count(t))\n\t\t\txs.push_back(t);\n\t\toccur[t] = 1;\n\t}\n\tcin >> A >> B;\n\tint ans = 0;\n\twhile(A != B)\n\t{\n\t\tnex_xs.clear();\n\t\tint bestA = A - 1;\n\t\tfor(int i = 0; i < xs.size(); i++)\n\t\t{\n\t\t\tint t = xs[i];\n\t\t\tint v = (A / t) * t;\n\t\t\tif(v >= B)\n\t\t\t{\n\t\t\t\tnex_xs.push_back(t);\n\t\t\t\tbestA = min(bestA, v);\n\t\t\t}\n\t\t}\n\t\tA = bestA;\n\t\txs = nex_xs;\n\t\tans ++;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\nint main()\n{\n\t#ifdef LOCAL_TEST\n\t\tfreopen(""in.txt"", ""r"", stdin);\n\t\tfreopen(""out.txt"", ""w"", stdout);\n\t#endif\n\tios :: sync_with_stdio(false);\n\tcout << fixed << setprecision(16);\n\treturn MAIN();\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Someone give a strange birthday present to Ivan It is hedgehog connected undirected graph in which one vertex has degree at least 3 we will call it center and all other vertices has degree 1 Ivan thought that hedgehog is too boring and decided to make himself k multihedgehog Let us define k multihedgehog as follows 1 multihedgehog is hedgehog it has one vertex of degree at least 3 and some vertices of degree 1 For all k ge 2 k multihedgehog is k 1 multihedgehog in which the following changes has been made for each vertex v with degree 1 let u be its only neighbor remove vertex v create a new hedgehog with center at vertex w and connect vertices u and w with an edge New hedgehogs can differ from each other and the initial gift Thereby k multihedgehog is a tree Ivan made k multihedgehog but he is not sure that he did not make any mistakes That is why he asked you to check if his tree is indeed k multihedgehog ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, k;\n\nvi graf[nax];\n\nvoid nope()\n{\n\tprintf(""No\\n"");\n\texit(0);\n}\n\nvoid tak()\n{\n\tprintf(""Yes\\n"");\n\texit(0);\n}\n\nint korz=-1;\n\nvi stos;\n\nvoid dfs1(int v, int oj)\n{\n\tstos.push_back(v);\n\tif ((int)stos.size()==2*k+1)\n\t\tkorz=stos[k];\n\tfor (int i : graf[v])\n\t\tif (i!=oj)\n\t\t\tdfs1(i, v);\n\tstos.pop_back();\n}\n\nvoid dfs2(int v, int oj, int odl)\n{\n\tif ((int)graf[v].size()==1 && odl!=k)\n\t\tnope();\n\tfor (int i : graf[v])\n\t\tif (i!=oj)\n\t\t\tdfs2(i, v, odl+1);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tif (n<=3)\n\t\tnope();\n\tint lis=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif ((int)graf[i].size()==1)\n\t\t\tlis=i;\n\tdfs1(lis, 0);\n\tif (korz==-1)\n\t\tnope();\n\tif ((int)graf[korz].size()<3)\n\t\tnope();\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif ((int)graf[i].size()==1 || i==korz)\n\t\t\tcontinue;\n\t\tif ((int)graf[i].size()<4)\n\t\t\tnope();\n\t}\n\tdfs2(korz, 0, 0);\n\ttak();\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]",1800
You are given n integers a 1 a 2 ldots a n and an integer k Find the maximum value of i cdot j k cdot a i a j over all pairs i j of integers with 1 le i j le n Here is the bitwise OR operator ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint t,n,k,a[100005];\nint main()\n{\n    scanf(""%d"",&t);\n    while(t--)\n    {\n        scanf(""%d%d"",&n,&k);\n        for(int i=1;i<=n;i++)\n        {\n            scanf(""%d"",&a[i]);\n        }\n        long long ans=-1e9;\n        for(int i=max(1,n-105);i<=n;i++)\n        {\n            for(int j=i+1;j<=n;j++)\n            {\n                ans=max(ans,((long long)i)*j-(a[i]|a[j])*k);\n            }\n        }\n        printf(""%lld\\n"",ans);\n    }\n}']","[1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1700
A remote island chain contains islands labeled through Bidirectional bridges connect the islands to form a simple cycle a bridge connects islands and islands and and so on and additionally a bridge connects islands and The center of each island contains an identical pedestal and all but one of the islands has a fragile uniquely colored statue currently held on the pedestal The remaining island holds only an empty pedestal The islanders want to rearrange the statues in a new order To do this they repeat the following process First they choose an island directly adjacent to the island containing an empty pedestal Then they painstakingly carry the statue on this island across the adjoining bridge and place it on the empty pedestal Determine if it is possible for the islanders to arrange the statues in the desired order ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define jjs(i, s, x) for (int i = (s); i < int(x); i++)\n#define jjl(i, x) jjs(i, 0, x)\n#define ji(x) jjl(i, x)\n#define jj(x) jjl(j, x)\n#define jk(x) jjl(k, x)\n#define jij(a, b) ji(a) jj(b)\n#define ever ;;\n#define foreach(x, C) for (auto& x : (C))\n#define INF ((int) 1e9+10)\n#define LINF ((ll) 1e16)\n#define pb push_back\n#define mp make_pair\n#define nrint(x) int x; rint(x);\n#define nrlong(x) long long x; rint(x);\n#define rfloat(x) scanf(""%lf"", &(x))\n\n#define rint readInteger\ntemplate<typename T>\nbool readInteger(T& x)\n{\n\tchar c,r=0,n=0;\n\tx=0;\n\tfor (ever)\n\t{\n\t\tc=getchar();\n\t\tif ((c<0) && (!r))\n\t\t\treturn(0);\n\t\telse if ((c==\'-\') && (!r))\n\t\t\tn=1;\n\t\telse if ((c>=\'0\') && (c<=\'9\'))\n\t\t\tx=x*10+c-\'0\',r=1;\n\t\telse if (r)\n\t\t\tbreak;\n\t}\n\tif (n)\n\t\tx=-x;\n\treturn(1);\n}\n\ntemplate <typename T, T MOD>\nstruct ModInt\n{\n\tT value;\n\tModInt() : value(0)\n\t{}\n\tModInt(T x)\n\t{\n\t\tx %= MOD;\n\t\tif (x < 0)\n\t\t\tx += MOD;\n\t\tvalue = x;\n\t}\n\nprivate:\nT __________________(T ___, T ____) {\nif (!____) return ___;\nreturn __________________\n\n(____,___%____);} T _____________(T _, T __, T ____, T ___) {\nT _____,______,_______=____-_;\nassert(!(_______%\n__________________(__,___)));for(_____=______=0;_____-______!=_______;){\n\t_____=(_______+______+__-1)/\n__*__;______=(_____-_______+___-1)/___*___;}return _____+_;}\npublic:\n\tModInt& operator += (ModInt x)\n\t{\n\t\tvalue += x.value;\n\t\tif (value >= MOD)\n\t\t\tvalue -= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator -= (ModInt x)\n\t{\n\t\tvalue -= x.value;\n\t\tif (value < 0)\n\t\t\tvalue += MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator *= (ModInt x)\n\t{\n\t\tvalue *= x.value;\n\t\tvalue %= MOD;\n\t\treturn *this;\n\t}\n\tModInt& operator /= (ModInt x)\n\t{\n\t\tx.invert();\n\t\treturn *this *= x;\n\t}\n\n\tModInt operator + (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to += x;\n\t\treturn o;\n\t}\n\tModInt operator - (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to -= x;\n\t\treturn o;\n\t}\n\tModInt operator * (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to *= x;\n\t\treturn o;\n\t}\n\tModInt operator / (ModInt x) const\n\t{\n\t\tModInt o = *this;\n\t\to /= x;\n\t\treturn o;\n\t}\n\tbool operator == (ModInt x) const\n\t{\n\t\treturn value == x.value;\n\t}\n\tbool operator != (ModInt x) const\n\t{\n\t\treturn !(*this == x);\n\t}\n\n\tModInt operator - () const\n\t{\n\t\treturn ModInt(0) - *this;\n\t}\n\n\tModInt operator ^ (long long x) const\n\t{\n\t\tModInt ret = 1;\n\t\tModInt mul = *this;\n\t\twhile (x)\n\t\t{\n\t\t\tif (x & 1)\n\t\t\t\tret *= mul;\n\t\t\tmul *= mul;\n\t\t\tx >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tModInt& operator ^= (long long x)\n\t{\n\t\treturn *this = *this ^ x;\n\t}\n\nprivate:\n\tvoid invert()\n\t{\n\t\t*this ^= MOD-2;\n\t}\npublic:\n\tvoid answer()\n\t{\n\t\tstd::cout << value << std::endl;\n\t}\n};\ntypedef ModInt<long long, 1000000007> mint;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> VPI;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\n\nint main()\n{\n\tint n;\n\trint(n);\n\tVI a(n), b(n);\n\tji(n) rint(a[i]);\t\n\tji(n) rint(b[i]);\n\ta.erase(find(a.begin(), a.end(), 0));\n\tb.erase(find(b.begin(), b.end(), 0));\n\tn--;\n\tint idx = 0;\n\twhile (b[idx] != a[0])\n\t\t++idx;\n\tji(n)\n\t{\n\t\tif (a[i] != b[(idx+i)%n])\n\t\t{\n\t\t\tprintf(""NO\\n"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(""YES\\n"");\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Vanya has a table consisting of rows each row contains cells The rows are numbered by integers from to from bottom to top the columns are numbered from to from left to right In this table Vanya chose rectangles with sides that go along borders of squares some rectangles probably occur multiple times After that for each cell of the table he counted the number of rectangles it belongs to and wrote this number into it Now he wants to find the sum of values in all cells of the table and as the table is too large he asks you to help him find the result ,"['#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid setup(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(15);\n}\n\nint N, T;\nint X1, Y1, X2, Y2;\n\nint main(){\n    setup();\n    cin >> N;\n    for(int i=0; i<N; i++){\n        cin >> X1 >> Y1 >> X2 >> Y2;\n        T += (abs(X2 - X1) + 1) * (abs(Y2 - Y1) + 1);\n    }\n\n    cout << T << endl;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Once Leha found in the left pocket an array consisting of integers and in the right pocket queries of the form If there are queries then they must be answered Answer for the query is minimal such that occurs in the interval strictly more than times or if there is no such number Help Leha with such a difficult task ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nstruct KMajority {\n\tstatic const int K = 5;\n\tint d = 0;\n\tarray<pair<int, int>, K> b;\n\tvoid add(int x, int cnt) {\n\t\tassert(cnt > 0);\n\t\trep(i, d) if (b[i].first == x) {\n\t\t\tb[i].second += cnt;\n\t\t\treturn;\n\t\t}\n\t\tb[d ++] = { x, cnt };\n\t\tif (d == K) {\n\t\t\tint mincnt = cnt;\n\t\t\trep(i, d - 1)\n\t\t\t\tamin(mincnt, b[i].second);\n\t\t\tfor(int i = 0; i < d; ) {\n\t\t\t\tif ((b[i].second -= mincnt) == 0)\n\t\t\t\t\tswap(b[i], b[-- d]);\n\t\t\t\telse\n\t\t\t\t\t++ i;\n\t\t\t}\n\t\t\tassert(d < K);\n\t\t}\n\t}\n\tvoid merge(const KMajority &that) {\n\t\trep(j, that.d)\n\t\t\tadd(that.b[j].first, that.b[j].second);\n\t}\n};\n\nint main() {\n\tint n; int q;\n\twhile (~scanf(""%d%d"", &n, &q)) {\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(""%d"", &a[i]);\n\t\tint nNodes = 1;\n\t\twhile (nNodes < n) nNodes *= 2;\n\t\tvector<KMajority> nodes(nNodes * 2);\n\t\trep(i, n)\n\t\t\tnodes[nNodes + i].add(a[i], 1);\n\t\tfor (int i = nNodes - 1; i > 0; -- i) {\n\t\t\tnodes[i] = nodes[i * 2];\n\t\t\tnodes[i].merge(nodes[i * 2 + 1]);\n\t\t}\n\t\tvector<vi> indices(*max_element(a.begin(), a.end()) + 1);\n\t\trep(i, n)\n\t\t\tindices[a[i]].push_back(i);\n\t\tll sum = 0;\n\t\trep(ii, q) {\n\t\t\tint L; int R; int K;\n\t\t\tscanf(""%d%d%d"", &L, &R, &K), -- L;\n\t\t\tKMajority km;\n\t\t\tfor (int l = L + nNodes, r = R + nNodes; l < r; l >>= 1, r >>= 1) {\n\t\t\t\tif (l & 1) km.merge(nodes[l ++]);\n\t\t\t\tif (r & 1) km.merge(nodes[-- r]);\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\trep(j, km.d) {\n\t\t\t\tint x = km.b[j].first;\n\t\t\t\tconst auto &v = indices[x];\n\t\t\t\tint cnt = (int)(lower_bound(v.begin(), v.end(), R) - lower_bound(v.begin(), v.end(), L));\n\t\t\t\tif (cnt * K > R - L)\n\t\t\t\t\tamin(ans, x);\n\t\t\t}\n\t\t\tprintf(""%d\\n"", ans == INF ? -1 : ans);\n\t\t}\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
Dima and Seryozha live in an ordinary dormitory room for two One day Dima had a date with his girl and he asked Seryozha to leave the room As a compensation Seryozha made Dima do his homework The teacher gave Seryozha the coordinates of distinct points on the abscissa axis and asked to consecutively connect them by semi circus in a certain order first connect the first point with the second one then connect the second point with the third one then the third one with the fourth one and so on to the th point Two points with coordinates and should be connected by a semi circle that passes above the abscissa axis with the diameter that coincides with the segment between points Seryozha needs to find out if the line on the picture intersects itself For clarifications see the picture Seryozha showed to Dima the left picture has self intersections the right picture doesn t have any Seryozha is not a small boy so the coordinates of the points can be rather large Help Dima cope with the problem ,"['#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<map>\n#include<string>\n#include<vector>\n#include<set>\n\nusing namespace std;\n#define For(i,l,r) for (int i = l; i <= r; ++i)\n#define Cor(i,l,r) for (int i = l; i >= r; --i)\n#define Fill(a,b) memset(a,b,sizeof(a))\n#define FI first\n#define SE second\n#define MP make_pair\n#define PII pair<int,int>\n#define flt double\n#define INF (0x3f3f3f3f)\n#define MaxN 1020304\n#define MaxNode 1020304\n#define MD 1000000007\nint n;\nint a[MaxN];\nint main() {\n//  freopen(""input.txt"",""r"",stdin); freopen(""output.txt"",""w"",stdout);\n    cin >> n;\n    For(i,1,n) scanf(""%d"",&a[i]); int ans = 0;\n    For(i,2,n) For(j,2,n) {\n        int l1 = min(a[i],a[i - 1]), r1 = max(a[i],a[i - 1]);\n        int l2 = min(a[j],a[j - 1]), r2 = max(a[j],a[j - 1]);\n        int inter = min(r1,r2) - max(l1,l2) + 1;\n        if (inter > 1 && inter < r1 - l1 + 1 && inter < r2 - l2 + 1) {\n            ans = 1; break ;\n        }\n    }\n    if (ans) puts(""yes""); else puts(""no"");\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
There is a complete rooted binary tree that is a rooted tree in which each vertex has either 0 or 2 children The root of the tree is vertex 1 A node without children is called a Each leaf has a we denote the hunger value of leaf v by h v Each inner vertex of the tree has a selector pointing to one of the children of the vertex This tree accepts cookies Before launching the process you can choose the initial state of each selector individually The process is as follows Initially there are no cookies in vertices You insert cookies into the root one by one As long as the cookie is not in a leaf it falls to the child defined by the selector in the current vertex This selector then changes its state to the opposite one i e it starts pointing to the other child of the vertex You stop inserting cookies when each leaf v has at least h v cookies in it In this case we say that the tree is filled up You have q queries Each query changes the value of h v for some leaf v You need to print q 1 numbers the i th of them being the minimum number of cookies required to fill up the machine after i 1 updates if you can pick any initial state for every selector Since these numbers may be very large print the answers modulo 998 244 353 Please note that you can choose the initial state of all selectors independently between queries However the queries themselves are not independent when answering the i th query you should also consider the effect of queries 1 2 ldots i 1 ,"['/*\nAuthor: QAQAutoMaton\nLang: C++\nCode: H.cpp\nMail: [email\xa0protected]\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(qaq...) fprintf(stderr,qaq)\n#define DEBUG printf(""Passing [%s] in LINE %d\\n"",__FUNCTION__,__LINE__)\n#define Debug debug(""Passing [%s] in LINE %d\\n"",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\ntemplate<class T>bool sort2(T &a,T &b){return a>b?swap(a,b),1:0;}\ntemplate<class T,class ...T2>T mmin(T a,T2 ...b){return mmin(a,mmin(b...));}\ntemplate<class T,class ...T2>T mmax(T a,T2 ...b){return mmax(a,mmax(b...));}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tfill((unsigned char*)&inf,(unsigned char*)&inf+sizeof(inf),0x3f);\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < \'0\' || c > \'9\'; c = gc()) if (c == \'-\') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= \'9\' && c >= \'0\'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==\' \'||x==\'\\n\' || x==\'\\r\');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())==\'\\n\' || *x==\' \'||*x==\'\\r\');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x==\'\\n\'||*x==\' \'||*x==\'\\r\'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc (\'0\'); if (x < 0) putc (\'-\'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + \'0\',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nconst int p=998244353;\nint fpm(int a,int b){\n\tint c=1;\n\tfor(;b;b>>=1,a=(ll)a*a%p)if(b&1)c=(ll)c*a%p;\n\treturn c;\n}\nnamespace run{\n\tint n;\n\tvector<int> to[200005];\n\tint f[19][200005];\n\tint fa[200005],d[200005];\n\tint dfn[200005],low[200005],val[200005],t;\n\tvoid dfs(int x){\n\t\tf[0][x]=fa[x];\n\t\tdfn[x]=++t;\n\t\tval[t]=x;\n\t\tfor(int i=1;i<=18;++i)f[i][x]=f[i-1][f[i-1][x]];\n\t\tfor(auto i:to[x])dfs(i);\n\t\tlow[x]=t;\n\t}\n\tint lca(int x,int y){\n\t\tx=val[x];y=val[y];\n\t\tif(d[x]<d[y])swap(x,y);\n\t\tfor(int i=18;~i;--i)if(d[x]-(1<<i)>=d[y])x=f[i][x];\n\t\tif(x==y)return x;\n\t\tfor(int i=18;~i;--i)if(f[i][x]!=f[i][y]){x=f[i][x];y=f[i][y];}\n\t\treturn f[0][x];\n\t}\n\n\tint *s1[20000005],ov1[2000005],t1,t2,t3;\n\tvoid setv(int &a,int b){\n\t\ts1[++t1]=&a;ov1[t1]=a;a=b;\n\t}\n\tvoid revert1(){\n\t\t*s1[t1]=ov1[t1];--t1;\n\t}\n\tset<int> **s2[1000005],*ov2[1000005];//???\n\tset<int> *s3[10000005];\n\tint dlv[10000005];//???\n\tbitset<10000005>tp;\n\tvoid setv(set<int> * &a,set<int> *b){\n\t\ts2[++t2]=&a;\n\t\tov2[t2]=a;a=b;\n\t}\n\tvoid revert2(){\n\t\t*s2[t2]=ov2[t2];--t2;\n\t}\n\tvoid Ins(set<int> *x,int y){\n\t\ts3[++t3]=x;\n\t\tdlv[t3]=y;\n\t\ttp[t3]=0;\n\t\tx->insert(y);\n\t}\n\tvoid Del(set<int> *x,set<int>::iterator y){\n\t\ts3[++t3]=x;\n\t\tdlv[t3]=*y;\n\t\ttp[t3]=1;\n\t\tx->erase(y);\n\t}\n\tvoid revert3(){\n\t\tif(tp[t3])s3[t3]->insert(dlv[t3]);\n\t\telse s3[t3]->erase(dlv[t3]);\n\t\t--t3;\n\t}\n\n\tint pw[200005];\n\tint nxt[200005];\n\tset<int> stv[6000005],*cur=stv;\n\tset<int> *nodes[200005],*oval[1<<18|5];\n\tint mx[1<<18|5];\n\tint a[200005],at[200005];\n\tpii cmx(-1,0);\n\tint less(pii a,pii b){\n\t\tif(a.x<0)return 1;\n\t\tif((!a.x)!=(!b.x))return !a.x;\n\t\tif(!a.x && !b.x)return 0;\n\t\t// a.x*2^a.y+2c<y*2^d?\n\t\tif(abs(a.y-b.y)>30)return a.y<b.y;\n\t\tint v=min(a.y,b.y);\n\t\ta.y-=v;\n\t\tb.y-=v;\n\t\treturn (((ll)a.x)<<a.y) < (((ll)b.x)<<b.y);\n\t}\n\tint equal(pii a,pii b){\n\t\t// a.x*2^a.y+2c<y*2^d?\n\n\t\tif((!a.x)!=(!b.x))return 0;\n\t\tif(!a.x && !b.x)return 1;\n\t\tif(abs(a.y-b.y)>30)return 0;\n\t\tint v=min(a.y,b.y);\n\t\ta.y-=v;\n\t\tb.y-=v;\n\t\treturn (((ll)a.x)<<a.y) == (((ll)b.x)<<b.y);\n\t}\n\n\tconst int lim=1<<30;\n\tint xdp[200005];\n\tint merge(int x,int y){\n\t\treturn x==y?(x<<1|1):(max(x,y)<<1);\n\t\n\t}\n\tvoid setval(int x,int y){\n\t\t--y;\n\t\tif(!y){\n\t\t\tint dx=0;\n\t\t\tif(mx[y]>dx){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(mx[y]<dx){\n\t\t\t\tsetv(mx[y],dx);\n\t\t\t\tsetv(oval[y],++cur);\t\n\t\t\t\toval[y]->clear();\n\t\t\t}\n\t\t\tif(mx[y]==dx){\n\t\t\t\tpii mx={-inf,-inf};\n\t\t\t\tint cx=dfn[x];\n\t\t\t\tauto it=oval[y]->lower_bound(cx);\n\t\t\t\tif(it!=oval[y]->end()){\n\t\t\t\t\tif(*it==cx)return;\n\t\t\t\t\tint z=lca(cx,*it);\n\t\t\t\t\tchkmax(mx,pii(d[z],z));\n\t\t\t\t}\n\t\t\t\tif(it!=oval[y]->begin()){\n\t\t\t\t\t--it;\n\t\t\t\t\tint z=lca(cx,*it);\n\t\t\t\t\tchkmax(mx,pii(d[z],z));\n\t\t\t\t}\n\t\t\t\tIns(oval[y],cx);\n\t\t\t\tif(mx.x<0)goto ed;\n\t\t\t\ty|=1;\n\t\t\t\tx=mx.y;\n\t\t\t}\n\t\t}\n\t\tif(y<=xdp[x])return;\n\t\tsetv(xdp[x],y);\n\t\twhile(x!=1 && y<lim){\n\t\t\tx=fa[x];\n\t\t\tsetv(xdp[x],merge(xdp[to[x][0]],xdp[to[x][1]]));\n\t\t\tif((xdp[x]-y-y)>1)return;\n\t\t\ty=xdp[x];\n\t\t\t// dp[x]=y;\n\t\t}\n\t\ted:;\n\t\tif(less(cmx,{y,d[x]})){\n\t\t\tcmx={y,d[x]};\n\t\t\tsetv(nodes[n+1],++cur);\n\t\t\tsetv(nxt[n+1],-1);\n\t\t\tnodes[n+1]->clear();\n\t\t}\n\t\tif(equal(cmx,{y,d[x]})){\n\t\t\tint at=n+1;\n\t\t\tint cx=dfn[x];\n\t\t\twhile(1){\n\t\t\t\tpii mx={-inf,-inf};\n\t\t\t\tauto it=nodes[at]->lower_bound(cx);\n\t\t\t\tif(it!=nodes[at]->end()){\n\t\t\t\t\tif(*it==cx)return;\n\t\t\t\t\tint x=lca(cx,*it);\n\t\t\t\t\tif(dfn[x]==cx)return;\n\t\t\t\t\tchkmax(mx,pii(d[x],x));\n\t\t\t\t}\n\t\t\t\tif(it!=nodes[at]->begin()){\n\t\t\t\t\t--it;\n\t\t\t\t\tint x=lca(cx,*it);\n\t\t\t\t\twhile(dfn[x]==*it){\n\t\t\t\t\t\tif(it==nodes[at]->begin()){\n\t\t\t\t\t\t\tx=-1;\n\t\t\t\t\t\t\tDel(nodes[at],it);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tauto oit=it;\n\t\t\t\t\t\t--it;\n\t\t\t\t\t\tDel(nodes[at],oit);\n\t\t\t\t\t\tx=lca(cx,*it);\n\t\t\t\t\t}\n\t\t\t\t\tif(x!=-1)chkmax(mx,pii(d[x],x));\n\t\t\t\t}\n\t\t\t\tIns(nodes[at],cx);\n\t\t\t\tif(mx.x>nxt[at]){\n\t\t\t\t\tsetv(nxt[at],mx.x);\n\t\t\t\t\tsetv(nodes[nxt[at]],++cur);\n\t\t\t\t\tsetv(nxt[nxt[at]],-1);\n\t\t\t\t}\n\t\t\t\tif(mx.x==nxt[at]){\n\t\t\t\t\tcx=dfn[mx.y];\n\t\t\t\t\tat=nxt[at];\n\t\t\t\t}\n\t\t\t\telse return;\n\t\t\t}\n\t\t}\n\t}\n\tstruct smt{\n\t\tvector<pii> ask;\n\t\tint ls,rs;\n\t\tsmt *l,*r;\n\t\tsmt(){}\n\t\tsmt(int,int);\n\t\tvoid add(int la,int ra,pii w){\n\t\t\tif(la<=ls && rs<=ra){\n\t\t\t\task.emplace_back(w);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(la<=l->rs)l->add(la,ra,w);\n\t\t\tif(r->ls<=ra)r->add(la,ra,w);\n\t\t}\n\t\tvoid solve(){\n\t\t\tpii oc=cmx;\n\t\t\tint ct1=t1,ct2=t2,ct3=t3;\n\t\t\tset<int> *ocur=cur;\n\t\t\tfor(auto i:ask){\n\t\t\t\tsetval(i.x,i.y);\n\t\t\t}\n\t\t\tif(ls==rs){\n\t\t\t\tif(cmx.x<0){\n\t\t\t\t\twrite(""0\\n"");\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint ans=((ll)cmx.x*pw[cmx.y]+1)%p;\n\t\t\t\t\tfor(int i=nxt[n+1];i>=0;i=nxt[i])ans=(ans+pw[i])%p;\n\t\t\t\t\twrite(ans,\'\\n\');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl->solve();r->solve();\n\t\t\t}\n\t\t\tcmx=oc;\n\t\t\tcur=ocur;\n\t\t\twhile(t1>ct1)revert1();while(t2>ct2)revert2();\n\t\t\twhile(t3>ct3)revert3();\n\t\t}\n\t};\n\tsmt node[400005],*vat=node,*rt;\n\tsmt *newsmt(int la,int ra){\n\t\tsmt *rt=vat;++vat;\n\t\t*rt=smt(la,ra);\n\t\treturn rt;\n\t}\n\tsmt::smt(int la,int ra){\n\t\tls=la;rs=ra;\n\t\task.clear();\n\t\tif(ls==rs){\n\t\t\tl=r=0;return;\n\t\t}\n\t\tint mid=(ls+rs)>>1;\n\t\tl=newsmt(ls,mid);\n\t\tr=newsmt(mid+1,rs);\n\t}\n\tbool main(){\n\t\tread(n);\n\t\tcmx={-1,0};\n\t\tfor(int i=1;i<=n;++i)xdp[i]=-1;\n\t\tpw[0]=1;\n\t\tfor(int i=0;i<(1<<18);++i)mx[i]=-1;\n\t\tfor(int i=1;i<=n;++i)pw[i]=(pw[i-1]<<1)%p;\n\t\tfor(int i=0;i<=n+1;++i)nxt[i]=-1;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tread(fa[i]);\n\t\t\tto[fa[i]].emplace_back(i);\n\t\t\td[i]=d[fa[i]]+1;\n\t\t}\n\t\tdfs(1);\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tread(a[i]);\n\t\t\tat[i]=0;\n\t\t}\n\t\tint q;\n\t\tread(q);\n\t\trt=newsmt(0,q);\n\t\tfor(int i=1;i<=q;++i){\n\t\t\tint x,y;\n\t\t\tread(x,y);\n\t\t\tif(a[x])rt->add(at[x],i-1,{x,a[x]});\n\t\t\tat[x]=i;a[x]=y;\n\t\t}\n\t\tfor(int i=1;i<=n;++i)if(a[i])rt->add(at[i],q,{i,a[i]});\n\t\trt->solve();\n\t\treturn 0;\n\t}\n}\n// dp[x]=(dp[ls]==dp[rs]?dp[ls]<<1):(max(dp[ls],dp[rs])<<1)-1\n// 考虑所有能取到max的位置，把它们的虚树搞出来(?)\n// 找到最深的合并的位置，然后只留下这些位置递归一次，给答案加上这个2^深度\n// 线段树分治一下，改成仅chkmax\n// 那就维护每一层这样的结构(？\n// wc, 8s，那我3log了，蚌\n// 看上去O(n)-O(1)lca能2log\n// 不能，得set.lowerbound\n// 草，修不完了\n// tmd 根本过不了拍\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(""H.in"",""r"",stdin);\n\tfreopen(""H.out"",""w"",stdout);\n#endif\n\trun::main();\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3500
There is an undirected tree of n vertices connected by n 1 bidirectional edges There is also a snake stuck inside of this tree Its head is at vertex a and its tail is at vertex b The snake s body occupies all vertices on the unique simple path between a and b The snake wants to know if it can reverse itself that is to move its head to where its tail started and its tail to where its head started Unfortunately the snake s movements are restricted to the tree s structure In an operation the snake can move its head to an adjacent vertex not currently occupied by the snake When it does this the tail moves one vertex closer to the head so that the length of the snake remains unchanged Similarly the snake can also move its tail to an adjacent vertex not currently occupied by the snake When it does this the head moves one unit closer to the tail Let s denote a snake position by h t where h is the index of the vertex with the snake s head t is the index of the vertex with the snake s tail This snake can reverse itself with the movements 4 7 to 5 1 to 4 2 to 1 3 to 7 2 to 8 1 to 7 4 Determine if it is possible to reverse the snake with some sequence of operations ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n\t#define dbg(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n#else\n\t#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nint n,a,b;\nvi adj[MX];\nint up[MX], down[MX],depth[MX],par[MX];\n\nvoid dfs(int x, int y) {\n\tdepth[x] = depth[y]+1; par[x] = y;\n\ttrav(t,adj[x]) if (t != y) {\n\t\tdfs(t,x);\n\t\tckmax(down[x],down[t]);\n\t}\n\tdown[x] ++;\n}\n\nint del(pi a, int b) {\n\tif (a.f == b) return a.s;\n\treturn a.f;\n}\n\nvoid ad(pi& a, int b) {\n\tif (a.f < b) swap(a.f,b);\n\tif (a.s < b) swap(a.s,b);\n}\n\nvoid dfs2(int x, int y) {\n\tpi p = {1+up[x],0};\n\ttrav(t,adj[x]) if (t != y) ad(p,1+down[t]);\n\ttrav(t,adj[x]) if (t != y) {\n\t\tup[t] = del(p,1+down[t]);\n\t\tdfs2(t,x);\n\t}\n}\n\nint getPath(int x, int y) {\n\tif (par[y] == x) return down[y]+1;\n\tassert(par[x] == y); return up[x]+1;\n}\n\nint len;\n\nbool visLef[MX], visRig[MX];\nint lefVal[MX], rigVal[MX];\n\nvoid genLefVal(int a, int b) {\n\tlefVal[a] = lefVal[b]-1;\n\ttrav(t,adj[a]) if (t != b) genLefVal(t,a);\n}\n\nvoid genRigVal(int a, int b) {\n\trigVal[a] = rigVal[b]+1;\n\ttrav(t,adj[a]) if (t != b) genRigVal(t,a);\n}\n\nbool stuck() {\n\tFOR(i,1,n+1) {\n\t\tvisLef[i] = visRig[i] = 0;\n\t}\n\tvi path = {b};\n\twhile (path.bk != a) path.pb(par[path.bk]);\n\treverse(all(path));\n\t//dbg(""STUCK"");\n\tF0R(i,sz(path)) {\n\t\tint x = path[i]; lefVal[x] = rigVal[x] = i;\n\t\ttrav(t,adj[x]) {\n\t\t\tif (i && t == path[i-1]) continue;\n\t\t\tif (i+1 < sz(path) && t == path[i+1]) continue;\n\t\t\tdbg(path,x,t);\n\t\t\tgenLefVal(t,x); genRigVal(t,x);\n\t\t}\n\t}\n\t// dbg(""MIDDLE"");\n\t// return 0;\n\tint bet = sz(path)-1;\n\tqueue<int> lef, rig;\n\tauto adRig = [&](int x) {\n\t\tif (visRig[x]) return;\n\t\tvisRig[x] = 1; rig.push(x);\n\t};\n\tauto adLef = [&](int x) {\n\t\tif (visLef[x]) return;\n\t\tvisLef[x] = 1; lef.push(x);\n\t};\n\tauto processLef = [&](int x) {\n\t\t// dbg(""PROCESSLEF"",x);\n\t\t// trav(t,adj[x]) dbg(t,lefVal[t]);\n\t\ttrav(t,adj[x]) if (lefVal[t] < lefVal[x]) adLef(t);\n\t\tint ind = lefVal[x]+bet;\n\t\tif (0 <= ind && ind < sz(path)) adRig(path[ind]);\n\t};\n\tauto processRig = [&](int x) {\n\t\t// dbg(""PROCESSRIG"",x);\n\t\ttrav(t,adj[x]) if (rigVal[t] > rigVal[x]) adRig(t);\n\t\tint ind = rigVal[x]-bet;\n\t\tif (0 <= ind && ind < sz(path)) adLef(path[ind]);\n\t};\n\tadLef(a), adRig(b);\n\twhile (sz(lef) || sz(rig)) {\n\t\tif (sz(lef)) {\n\t\t\tint x = lef.ft; lef.pop();\n\t\t\tprocessLef(x);\n\t\t}\n\t\tif (sz(rig)) {\n\t\t\tint x = rig.ft; rig.pop();\n\t\t\tprocessRig(x);\n\t\t}\n\t}\n\tint mn = 0, mx = bet;\n\tFOR(i,1,n+1) {\n\t\tif (visLef[i]) ckmin(mn,lefVal[i]);\n\t\tif (visRig[i]) ckmax(mx,rigVal[i]);\n\t}\n\tdbg(mn,mx);\n\tif (mx-bet < mn+bet) return 1;\n\treturn 0;\n}\n\nvoid solve() {\n\tre(n,a,b); FOR(i,1,n+1) adj[i].clear(), up[i] = 0, down[i] = 0, par[i] = 0, depth[i] = 0;\n\tF0R(i,n-1) {\n\t\tint x,y; re(x,y);\n\t\tadj[x].pb(y), adj[y].pb(x);\n\t}\n\t//exit(0);\n\tdfs(a,0); dfs2(a,0);\n\tlen = depth[b];\n\t// dbg(a,len);\n\t//FOR(i,1,n+1) dbg(i,up[i],down[i],depth[i]);\n\t//exit(0);\n\tbool three = 0;\n\tFOR(i,1,n+1) {\n\t\tvi v;\n\t\ttrav(t,adj[i]) v.pb(getPath(i,t));\n\t\tsort(rall(v));\n\t\t//dbg(i,v);\n\t\tif (sz(v) >= 3 && v[2] >= len) three = 1;\n\t}\n\tif (!three || stuck()) { //  \n\t\tps(""NO"");\n\t\treturn;\n\t}\n\tps(""YES"");\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) solve();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0]",3000
You are given a rebus of form consisting of only question marks separated by arithmetic operation and equality and positive integer The goal is to replace each question mark with some positive integer from to such that equality holds ,"['#include<bits/stdc++.h>\n#include<unistd.h>\nusing namespace std;\n#define FZ(n) memset((n),0,sizeof(n))\n#define FMO(n) memset((n),-1,sizeof(n))\n#define F first\n#define S second\n#define PB push_back\n#define ALL(x) begin(x),end(x)\n#define SZ(x) ((int)(x).size())\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\ntemplate<typename A, typename B>\nostream& operator <<(ostream &s, const pair<A,B> &p) {\n  return s<<""(""<<p.first<<"",""<<p.second<<"")"";\n}\ntemplate<typename T>\nostream& operator <<(ostream &s, const vector<T> &c) {\n  s<<""[ "";\n  for (auto it : c) s << it << "" "";\n  s<<""]"";\n  return s;\n}\n// Let\'s Fight!\n\nconst int MAXN = 1050;\n\nint N;\nvector<string> vs;\nint target;\nbool sgn[MAXN];\nint ans[MAXN];\n\nbool calc()\n{\n  N = (vs.size() - 1) / 2;\n  for(int i=1; i<N; i++)\n    if(vs[2*i-1] == ""-"")\n      sgn[i] = 1;\n  target = stoi(vs.back().c_str());\n\n  int posnum = 0;\n  for(int i=0; i<N; i++)\n    if(!sgn[i])\n      posnum++;\n\n  for(int i=0; i<N; i++)\n    ans[i] = 1;\n  int dif = target - (posnum - (N - posnum));\n\n  for(int i=0; i<N; i++)\n  {\n    if(dif > 0 && !sgn[i])\n    {\n      int x = min(dif, target-1);\n      dif -= x;\n      ans[i] += x;\n    }\n    else if(dif < 0 && sgn[i])\n    {\n      int x = min(-dif, target-1);\n      dif += x;\n      ans[i] += x;\n    }\n  }\n\n  return dif == 0;\n}\n\nint main() {\n  IOS;\n\n  string s;\n  while(cin>>s) vs.PB(s);\n  bool res = calc();\n  if(!res)\n    cout<<""Impossible""<<endl;\n  else\n  {\n    cout<<""Possible""<<endl;\n    for(int i=0; i<N; i++)\n      cout<<ans[i]<<"" ""<<vs[2*i+1]<<"" "";\n    cout<<target<<endl;\n  }\n\n  return 0;\n}\n']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
You are given a string s consisting of lowercase Latin letters While there is at least one character in the string s that is you perform the following operation you choose the index i 1 le i le s such that the character at position i occurs times in the string s and delete the character at position i that is replace s with s 1 s 2 ldots s i 1 s i 1 s i 2 ldots s n For example if s then you can apply the following sequence of operations i 6 Rightarrow s i 1 Rightarrow s i 7 Rightarrow s Given a given string s find the lexicographically maximum string that can be obtained after applying a certain sequence of operations after which all characters in the string A string a of length n is lexicographically less than a string b of length m if there is an index i 1 le i le min n m such that the first i 1 characters of the strings a and b are the same and the i th character of the string a is less than i th character of string b the first min n m characters in the strings a and b are the same and n m For example the string a is lexicographically less than the string b ,"['#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\nint lst[205];\nint main(int argc, char** argv) {\n\tint T;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tstring a;\n\t\tcin >> a;\n\t\tint n=a.size();\n\t\tfor(int i=\'a\';i<=\'z\';i++) lst[i]=n;\n\t\tlst[0]=n;\n\t\tfor(int i=0;i<a.size();i++)\n\t\t\tlst[a[i]]=i;\n\t\tint pos=0;\n\t\tfor(int X=0;X<=26;X++)\n\t\t{\n\t\t\tchar mx=0;\n\t\t\tfor(int i=pos;i<n;i++)\n\t\t\t{\n\t\t\t\tmx=max(mx,a[i]);\n\t\t\t\tif(lst[a[i]]==i)\n\t\t\t\t{\n\t\t\t\t\tlst[mx]=n;\n\t\t\t\t\tcout << mx;\n\t\t\t\t\twhile(a[pos]!=mx) ++pos;\n\t\t\t\t\t++pos; \n\t\t\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\t\t\tif(a[i]==mx) a[i]=0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ""\\n"";\n\t}\n\treturn 0;\n}']","[1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2000
There are n 1 teleporters on a straight line located in points 0 a 1 a 2 a 3 a n It s possible to teleport from point x to point y if there are teleporters in of those points and it costs x y 2 energy You want to install some additional teleporters so that it is possible to get from the point 0 to the point a n possibly through some other teleporters spending than m energy in total Each teleporter you install must be located in an What is the minimum number of teleporters you have to install ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1000000000000000000;\nlong long cost(int d, int cnt){\n  int q = d / cnt;\n  int r = d % cnt;\n  return (long long) q * q * (cnt - r) + (long long) (q + 1) * (q + 1) * r;\n}\nint main(){\n  int n;\n  cin >> n;\n  vector<int> a(n + 1);\n  a[0] = 0;\n  for (int i = 1; i <= n; i++){\n    cin >> a[i];\n  }\n  long long m;\n  cin >> m;\n  long long tv = 1, fv = INF;\n  while (fv - tv > 1){\n    long long mid = (tv + fv) / 2;\n    long long sum = 0;\n    for (int i = 0; i < n; i++){\n      long long d = a[i + 1] - a[i];\n      int tv2 = 1, fv2 = d + 1;\n      while (fv2 - tv2 > 1){\n        int mid2 = (tv2 + fv2) / 2;\n        long long x1 = cost(d, mid2 - 1);\n        long long x2 = cost(d, mid2);\n        if (x1 - x2 >= mid){\n          tv2 = mid2;\n        } else {\n          fv2 = mid2;\n        }\n      }\n      sum += cost(d, tv2);\n    }\n    if (sum <= m){\n      tv = mid;\n    } else {\n      fv = mid;\n    }\n  }\n  long long ans = 0;\n  long long sum = 0;\n  for (int i = 0; i < n; i++){\n    long long d = a[i + 1] - a[i];\n    int tv2 = 1, fv2 = d + 1;\n    while (fv2 - tv2 > 1){\n      int mid2 = (tv2 + fv2) / 2;\n      long long x1 = cost(d, mid2 - 1);\n      long long x2 = cost(d, mid2);\n      if (x1 - x2 > tv){\n        tv2 = mid2;\n      } else {\n        fv2 = mid2;\n      }\n    }\n    ans += tv2 - 1;\n    sum += cost(d, tv2);\n  }\n  ans += (sum - m + tv - 1) / tv;\n  cout << ans << endl;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2600
Each of you probably has your personal experience of riding public transportation and buying tickets After a person buys a ticket which traditionally has an number of digits he usually checks whether the ticket is lucky Let us remind you that a ticket is lucky if the sum of digits in its first half matches the sum of digits in its second half But of course not every ticket can be lucky Far from it Moreover sometimes one look at a ticket can be enough to say right away that the ticket is not lucky So let s consider the following that can definitely determine an unlucky ticket We ll say that a ticket is definitely unlucky if each digit from the first half corresponds to some digit from the second half so that each digit from the first half is than the corresponding digit from the second one or each digit from the first half is than the corresponding digit from the second one Each digit should be used exactly once in the comparisons In other words there is such between the digits of the first and the second half of the ticket that either each digit of the first half turns out than the corresponding digit of the second half or each digit of the first half turns out than the corresponding digit from the second half For example ticket meets the following unluckiness criterion and will not be considered lucky the sought correspondence is and ticket also meets the criterion the sought correspondence is and and ticket does not meet the criterion You have a ticket in your hands it contains digits Your task is to check whether it meets the unluckiness criterion ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main() {\n\tint n;\n\tcin >> n;\n\tstring s;\n\tcin >> s;\n\tvector<int> a, b;\n\tfor (int i = 0; i < n * 2; ++i) {\n\t\tif (i < n)\n\t\t\ta.push_back(s[i] - \'0\');\n\t\telse\n\t\t\tb.push_back(s[i] - \'0\');\n\t}\n\tsort(a.begin(), a.end());\n\tsort(b.begin(), b.end());\n\n\tbool cmp = true;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] <= b[i])\n\t\t\tcmp = false;\n\t}\n\n\tif (cmp) {\n\t\tputs(""YES"");\n\t\treturn 0;\n\t}\n\n\tcmp = true;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (a[i] >= b[i])\n\t\t\tcmp = false;\n\t}\n\n\tif (cmp) {\n\t\tputs(""YES"");\n\t\treturn 0;\n\t}\n\n\tputs(""NO"");\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Igor has fallen in love with Tanya Now Igor wants to show his feelings and write a number on the fence opposite to Tanya s house Igor thinks that the larger the number is the more chance to win Tanya s heart he has Unfortunately Igor could only get liters of paint He did the math and concluded that digit requires liters of paint Besides Igor heard that Tanya doesn t like zeroes That s why Igor won t use them in his number Help Igor find the maximum number he can write on the fence ,"['#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <math.h>\n\n#include <vector>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\nusing namespace std;\n\ntemplate<typename T>inline string to_str(const T& v) {\n    ostringstream os; os << v; return os.str();\n}\ntemplate<typename T>inline T to_obj(const string& v) {\n    istringstream is(v); T r; is>>r; return r;\n}\ntemplate<class T>inline int cMin(T& a, T b) {return b<a ? a=b,1 : 0;}\ntemplate<class T>inline int cMax(T& a, T b) {return a<b ? a=b,1 : 0;}\n\n#define CLR(A,v) memset(A, v, sizeof(A))\n#define MP(a,b)  make_pair(a, b)\n#define F0(i, n) for(int i=0; i<(n); ++i)\n#define F1(i, n) for(int i=1; i<=(n); ++i)\n\n\nint A[16] = {0};\n\nint main(int argc, char *argv[]) {\n    int v;\n    scanf(""%d"", &v);\n\n    F1(i, 9) scanf(""%d"", A+i);\n    int g = A[1];\n    int idx = 1;\n    F1(i, 9) {\n        if(A[i] <= g) {\n            g = A[i];\n            idx = i;\n        }\n    }\n    int n = v / g;\n    if(n == 0) {\n        puts(""-1"");\n        return 0;\n    }\n    for(; n>0; --n) {\n        int rem = v - g*n;\n        int cur = g + rem;\n        int h = idx;\n        F1(i, 9) {\n            if(cur >= A[i]) h = i;\n        }\n        printf(""%d"", h);\n        v -= A[h];\n    }\n    printf(""\\n"");\n    return 0;\n}\n']","[1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Allen is hosting a formal dinner party 2n people come to the event in n pairs couples After a night of fun Allen wants to line everyone up for a final picture The 2n people line up but Allen doesn t like the ordering Allen prefers if each pair occupies adjacent positions in the line as this makes the picture more aesthetic Help Allen find the minimum number of swaps of positions he must perform to make it so that each couple occupies adjacent positions in the line ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n,p,ans;\nVI v[1010];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,2*n) {\n\t\tscanf(""%d"",&p); --p;\n\t\tv[p].pb(i);\n\t}\n\trep(i,0,n) rep(j,i+1,n) {\n\t\tauto p1=v[i],p2=v[j];\n\t\tif (p1[0]>p2[0]) swap(p1,p2);\n\t\tif (p1[1]<p2[0]) ans+=0;\n\t\telse if (p1[1]>p2[1]) ans+=2;\n\t\telse ans+=1;\n\t}\n\tprintf(""%d\\n"",ans);\n}\n']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
John is a lead programmer on a destroyer belonging to the space navy of the Confederacy of Independent Operating Systems One of his tasks is checking if the electronic brains of robots were damaged during battles A standard test is to order the robots to form one or several lines in each line the robots should stand one after another After that each robot reports the number of robots standing in front of it The i th robot reported number l i Unfortunately John does not know which line each robot stands in and can t check the reported numbers Please determine if it is possible to form the lines in such a way that all reported numbers are correct or not ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint t;\n\tcin >> t;\n\twhile(t--){\n\t\tint n; \n\t\tcin >> n;\n\t\tmap<int, int> l;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tl[x]++;\n\t\t}\n\t\t\n\t\tbool possible = true;\n\t\tfor(int i = 1; i < 100; ++i){\n\t\t\tpossible &= l[i] <= l[i - 1];\n\t\t}\n\t\t\n\t\tcout << (possible ? ""YES"" : ""NO"") << endl;\n\t}\n\t\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Two T shirt sizes are given a and b The T shirt size is either a string or a string consisting of several possibly zero characters and one of the characters or For example strings could be the size of some T shirts And the strings are not sizes The letter stands for medium for small for large The letter refers to the degree of size from eXtra For example is extra extra large bigger than and smaller than You need to compare two given sizes of T shirts a and b The T shirts are compared as follows any small size no matter how many letters is smaller than the medium size and any large size any large size regardless of the number of letters is larger than the medium size and any small size the more letters before the smaller the size the more letters in front of the larger the size For example ,"['#include <bits/stdc++.h>\n#define dprintf(...) printf(__VA_ARGS__)\nusing namespace std;\ntypedef long long LL;\n\nint parse(string s) {\n  if (s == ""M"") return 0;\n  int i = 0;\n  while (i < s.size() && s[i] == \'X\') i++;\n  i++;\n  if (s.back() == \'S\') i *= -i;\n  return i;\n}\n\nvoid solve() {\n  string s1, s2;\n  cin >> s1 >> s2;\n  if (s1 == s2) {\n    cout << ""=\\n"";\n  } else if (parse(s1) < parse(s2)) {\n    cout << ""<\\n"";\n  } else {\n    cout << "">\\n"";\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n\n  int T; cin >> T;\n  for (int cs = 1; cs <= T; cs++) {\n    solve();\n  }\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
Vasya got really tired of these credits from problem F and now wants to earn the money himself He decided to make a contest to gain a profit Vasya has n problems to choose from They are numbered from 1 to n The difficulty of the i th problem is d i Moreover the problems are given in the increasing order by their difficulties In order to add the i th problem to the contest you need to pay c i burles to its author For each problem in the contest Vasya gets a burles So the total earnings for the contest are calculated as follows if Vasya takes problem i to the contest he needs to pay c i to its author for each problem in the contest Vasya gets a burles let gap l r max limits l le i r d i 1 d i 2 If Vasya takes all the tasks with indices from l to r to the contest he also needs to pay gap l r If l r then gap l r 0 Calculate the maximum profit that Vasya can earn by taking a consecutive segment of tasks ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nstruct Data {\n    ll mp, ms;\n    ll sm;\n    ll ans;\n\n    Data(ll x = 0)\n        : mp(max(0ll, x))\n        , ms(max(0ll, x))\n        , sm(x)\n        , ans(max(0ll, x))\n    {\n    }\n};\n\nData mrg(Data l, Data r) {\n    Data res;\n    res.sm = l.sm + r.sm;\n    res.mp = max(l.mp, l.sm + r.mp);\n    res.ms = max(r.ms, l.ms + r.sm);\n    res.ans = max(max(l.ans, r.ans), l.ms + r.mp);\n    return res;\n}\n\nconst int MX = 300 * 1000 + 7;\nint p[MX], w[MX];\nData d[MX];\n\nll a[MX];\n\nint getp(int v) {\n    if (p[v] == -1) {\n        return v;\n    }\n    p[v] = getp(p[v]);\n    return p[v];\n}\n\nvoid join(int u, int v) {\n    u = getp(u);\n    v = getp(v);\n    assert(u != v);\n/*    if (w[u] < w[v]) {\n        swap(u, v);\n    } */\n    w[u] += w[v];\n    p[v] = u;\n    d[u] = mrg(d[u], d[v]);\n}\n\nll D[MX];\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n;\n    ll A;\n    cin >> n >> A;\n    ll ans = 0;\n    vector<pair<ll, int> > go;\n\n    for (int i = 0; i < n; i++) {\n        cin >> D[i];\n        cin >> a[i];\n        a[i] = A - a[i];\n        d[i] = Data(a[i]);\n        p[i] = -1;\n        ans = max(ans, a[i]);\n        if (i > 0) {\n            ll gap = (D[i] - D[i - 1]) * (D[i] - D[i - 1]);\n            go.emplace_back(gap, i);\n        }\n    }\n\n    sort(go.begin(), go.end());\n    for (const auto& [val, pos] : go) {\n        join(pos - 1, pos);\n        int v = getp(pos);\n        ans = max(ans, d[v].ans - val);\n    }\n\n    cout << ans << ""\\n"";\n    return 0;\n}\n\n']","[0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2400
You are given a binary array a all elements of the array are 0 or 1 of length n You wish to sort this array but unfortunately your algorithms teacher forgot to teach you sorting algorithms You perform the following operations until a is sorted Choose two random indices i and j such that i j Indices are chosen equally probable among all pairs of indices i j such that 1 le i j le n If a i a j then swap elements a i and a j What is the expected number of such operations you will perform before the array becomes sorted It can be shown that the answer can be expressed as an irreducible fraction frac p q where p and q are integers and q not equiv 0 pmod 998 244 353 Output the integer equal to p cdot q 1 bmod 998 244 353 In other words output such an integer x that 0 le x 998 244 353 and x cdot q equiv p pmod 998 244 353 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int cnt = std::count(a.begin(), a.end(), 0);\n    int bad = std::count(a.begin(), a.begin() + cnt, 1);\n    \n    Z ans = 0;\n    for (int i = 1; i <= bad; i++) {\n        ans += Z(1) / i / i;\n    }\n    ans *= Z(n) * (n - 1) / 2;\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
You are given two arrays of integers a 1 ldots a n and b 1 ldots b m Your task is to find a array c 1 ldots c k that is a subsequence of a 1 ldots a n and also a subsequence of b 1 ldots b m If there are multiple answers find one of the possible length If there are still multiple of the smallest possible length find any If there are no such arrays you should report about it A sequence a is a subsequence of a sequence b if a can be obtained from b by deletion of several possibly zero elements For example 3 1 is a subsequence of 3 2 1 and 4 3 1 but not a subsequence of 1 3 3 7 and 3 10 4 ,"['#pragma comment(linker, ""/STACK:10000000000"")\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdlib.h>\n#include <stdio.h>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <math.h>\n#include <map>\n#include <chrono>\n#include <set>\n#include <stack>\n#include <vector>\n#include <time.h>\n#include <random>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <queue>\n#include <deque>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <complex>\n#define rt return\n#define mp make_pair\n#define endl \'\\n\'\n#define sqr(x) ((x) * (x))\n#define all(x) (x).begin(), (x).end()\n#define rep(x) for (int rep_iter = 0; rep_iter < x; ++rep_iter)\n#define fnd(x, y) (x.find(y) != x.end())\n#define fndv(x, y) (find(all(x), y) != end(x))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<db, db> pdd;\ntypedef unsigned char bt;\ntypedef unsigned int uint;\nconst int MOD = 1000000007;\nconst int INF = 1000000007LL;\nconst ll INF2 = 1LL << 62LL;\nconst long double EPS = 1e-9;\n#ifdef _DEBUG\nconst int SIZE = 120;\n#endif\n#ifndef _DEBUG\nconst int SIZE = 200010; //200010\n#endif\nmt19937 rng(time(0));\nuniform_int_distribution<int> uid(-1000000000, 1000000000);\n\n\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tint tt;\n\tcin >> tt;\n\trep(tt) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tvector <int> v(n);\n\t\tfor (auto& i : v)\n\t\t\tcin >> i;\n\t\tbool f = 1;\n\t\trep(m) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tif (fndv(v, x) && f) {\n\t\t\t\tcout << ""YES\\n1 "" << x << endl;\n\t\t\t\tf = 0;\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t\tcout << ""NO\\n"";\n\t}\n\n\n\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Amr bought a new video game Guess Your Way Out II The goal of the game is to find an exit from the maze that looks like a perfect binary tree of height The player is initially standing at the root of the tree and the exit from the tree is located at some leaf node Let s index all the nodes of the tree such that The root is number Each internal node will have a left child with index and a right child with index The level of a node is defined as for a root or level of parent of the node otherwise The vertices of the level are called leaves The exit to the maze is located at some leaf node the player doesn t know where the exit is so he has to guess his way out In the new version of the game the player is allowed to ask questions on the format Does the node number belong to the range Here is the ancestor of a node that located in the level The game will answer with Yes or No only The game is designed such that it doesn t always answer correctly and sometimes it cheats to confuse the player Amr asked a lot of questions and got confused by all these answers so he asked you to help him Given the questions and its answers can you identify whether the game is telling contradictory information or not If the information is not contradictory and the exit node can be determined uniquely output its number If the information is not contradictory but the exit node isn t defined uniquely output that the number of questions is not sufficient Otherwise output that the information is contradictory ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define dbgs(x) cerr << (#x) << "" --> "" << (x) << \' \'\n#define dbg(x) cerr << (#x) << "" --> "" << (x) << endl\n\n#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)\n#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)\n#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta (bas + son >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n#define pii pair< int , int >\n\ntypedef long long ll;\n\nconst long long linf = 1e18+5;\nconst int mod = 1e9+7;\nconst int logN = 17;\nconst int inf = 1e9;\nconst int N = 2e6+5;\n\n#define int ll\n\nll i, j, k, n, m, h, q, x, y, z, dp[N], dp2[N], t, q1;\n\nll tt[N];\n\nmap< ll , int > hh, w;\n\nvector< pair< pii , int > > v;\n\nll L(ll x,ll y) { FOR(i,x+1,h) y *= 2; return y; } \nll R(ll x, ll y) { FOR(i,x+1,h) y = y * 2 + 1; return y; }\n\nmultiset< pair< ll , ll > > S;\n\nmultiset< pair< ll , ll > > :: iterator it, it2;\n\nvoid add(int x,int y,int l,int r) {\n    if(l <= x && y <= r) return ;\n    if(x > r || y < l) { S.insert(mp(x,y)); return ; } \n    if(x < l) S.insert(mp(x,l-1));\n    if(y > r) S.insert(mp(r+1,y));\n}\n\nvoid rem(int x,int y) {\n    it = S.lower_bound(mp(x,0)); \n    if(it != S.begin()) it--;\n    for(;it != S.end() && it->st <= y;){\n        it2 = it; it2++;\n        add(it->st,it->nd,x,y);\n        S.erase(it);it = it2;       \n    }    \n}\n\n main() {\n       \n   scanf(""%lld %lld"",&h,&q);\n   \n   hh[1LL<<h-1LL] = 1; hh[(1ll << h) - 1] = 1;\n   hh[(1LL<<h-1LL)-1] = 1; hh[(1ll << h)] = 1;\n   \n   S.insert(mp(1ll<<h-1,(1ll<<h)-1));\n   \n   \n   FOR(i,1,q) {\n       \n       scanf(""%lld %lld %lld %lld"",&x,&y,&z,&t);\n       ll l = L(x,y);\n       ll r = R(x,z);\n       \n      if(t == 0) rem(l,r);\n      else rem(0,l-1), rem(r+1,1ll<<h);\n       \n   }\n   \n   if(!S.size()) cout << ""Game cheated!"" << endl;\n   else if(S.size() != 1 || S.begin()->st != S.begin()->nd) { cout << ""Data not sufficient!\\n""; }\n   else cout << S.begin()->st << endl;\n    \n}']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
In a small town there is a workshop specializing in woodwork Since the town is small only carvers work there Soon a wooden toy festival is planned in the town The workshop employees want to prepare for it They know that n people will come to the workshop with a request to make a wooden toy People are different and may want different toys For simplicity let s denote the pattern of the toy that the i th person wants as a i 1 le a i le 10 9 Each of the carvers can choose an integer pattern x 1 le x le 10 9 in advance x is the integer During the preparation for the festival the carvers will perfectly work out the technique of making the toy of the chosen pattern which will allow them to cut it out of wood instantly To make a toy of pattern y for a carver who has chosen pattern x it will take x y time because the more the toy resembles the one he can make instantly the faster the carver will cope with the work On the day of the festival when the next person comes to the workshop with a request to make a wooden toy the carvers can choose who will take on the job At the same time the carvers are very skilled people and can work on orders for different people Since people don t like to wait the carvers want to choose patterns for preparation in such a way that the waiting time over all people is as as possible Output the maximum waiting time that the carvers can achieve ,"[""#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint a[200000], n;\ninline bool check(long long x) {\n\tlong long pre = a[0] + x;\n\tint cnt = 1;\n\tfor (int i = 0; i ^ n; ++i) {\n\t\tif (abs(a[i] - pre) > x) {\n\t\t\t++cnt;\n\t\t\tpre = a[i] + x;\n\t\t}\n\t}\n\treturn cnt <= 3;\n}\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tint t;\n\tcin >> t;\n\tfor (; t--;) {\n\t\tcin >> n;\n\t\tfor (int i = 0; i ^ n; ++i)\n\t\t\tcin >> a[i];\n\t\tsort(a, a + n);\n\t\tlong long l = 0, r = 1000000000, mid;\n\t\tfor (; l < r;) {\n\t\t\tmid = l + r >> 1;\n\t\t\tif (check(mid))\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid + 1;\n\t\t}\n\t\tcout << l << '\\n';\n\t}\n}\n""]","[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
You are given an integer array a 1 a 2 dots a n and integer k In one step you can either choose some index i and decrease a i by one make a i a i 1 or choose two indices i and j and set a i equal to a j make a i a j What is the minimum number of steps you need to make the sum of array sum limits i 1 n a i le k You are allowed to make values of array negative ,"[""/**\n *    author:  tourist\n *    created: 27.12.2021 17:38:21       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    long long k;\n    cin >> n >> k;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    vector<long long> pref(n + 1);\n    for (int i = 0; i < n; i++) {\n      pref[i + 1] = pref[i] + a[i];\n    }\n    long long ans = (long long) 9e18;\n    for (int t = 0; t <= n - 1; t++) {\n      long long sum = pref[n - t] + a[0] * t;\n      long long cur = t;\n      if (sum > k) {\n        long long diff = sum - k;\n        cur += (diff + t) / (t + 1);\n      }\n      ans = min(ans, cur);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n""]","[1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Recall that the binomial coefficient binom x y is calculated as follows x and y are non negative integers if x y then binom x y 0 otherwise binom x y frac x y cdot x y You are given an array a 1 a 2 dots a n and an integer k You have to calculate a new array b 1 b 2 dots b n where b 1 binom 1 k cdot a 1 bmod 998244353 b 2 binom 2 k cdot a 1 binom 1 k cdot a 2 bmod 998244353 b 3 binom 3 k cdot a 1 binom 2 k cdot a 2 binom 1 k cdot a 3 bmod 998244353 and so on Formally b i sum limits j 1 i binom i j 1 k cdot a j bmod 998244353 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int P = 998244353;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, x, y, m, k;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    std::cin >> a[0] >> x >> y >> m >> k;\n    \n    for (int i = 1; i < n; i++) {\n        a[i] = (1LL * a[i - 1] * x + y) % m;\n    }\n    \n    for (int i = 0; i <= k; i++) {\n        for (int j = 1; j < n; j++) {\n            a[j] = (a[j] + a[j - 1]) % P;\n        }\n    }\n    \n    i64 ans = 0;\n    for (int i = k - 1; i < n; i++) {\n        ans ^= 1LL * (i + 1) * a[i - k + 1];\n    }\n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2200
Petya loves hockey very much One day as he was watching a hockey match he fell asleep Petya dreamt of being appointed to change a hockey team s name Thus Petya was given the original team name and the collection of forbidden substrings All those strings consist of uppercase and lowercase Latin letters String has the length of its characters are numbered from to First Petya should find all the occurrences of forbidden substrings in the string During the search of substrings the case of letter shouldn t be taken into consideration That is strings and are considered equal After that Petya should perform the replacement of all letters covered by the occurrences More formally a letter in the position should be replaced by any other one if for position in string there exist pair of indices such that substring is contained in the collection when using case insensitive comparison During the replacement the letter s case should remain the same Petya is not allowed to replace the letters that aren t covered by any forbidden substring Letter uppercase or lowercase is considered lucky for the hockey players That s why Petya should perform the changes so that the occurred in the resulting string as many times as possible Help Petya to find such resulting string If there are several such strings find the one that comes first lexicographically Note that the process of replacements is not repeated it occurs only once That is if after Petya s replacements the string started to contain new occurrences of bad substrings Petya pays no attention to them ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int maxn=1000+10;\nchar st[maxn],c[maxn];\nchar b[maxn][maxn];\nint n;\nbool flag[maxn];\n\nbool cmp(int a,int b,char s1[],char s2[],int n)\n{\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tchar c1=s1[a+i];\n\t\tif (c1>=\'A\' && c1<=\'Z\') c1=c1-\'A\'+\'a\';\n\t\tchar c2=s2[b+i];\n\t\tif (c2>=\'A\' && c2<=\'Z\') c2=c2-\'A\'+\'a\';\n\t\tif (c1!=c2) return 0;\n\t}\n\t//if (s1[a+i]!=s2[b+i]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(""%d"",&n);\n\tfor (int i=0;i<n;i++) scanf(""%s"",b[i]);\n\tscanf(""%s"",st);\n\tscanf(""%s"",c);\n\n\tfor (int i=0;st[i];i++)\n\t{\n\t\tbool ok=0;\n\t\tfor (int k=0;!ok && k<n;k++)\n\t\t{\n\t\t\tint len=strlen(b[k]);\n\t\t\tfor (int j=0;!ok && j<=i;j++)\n\t\t\tif (j+len-1>=i)\n\t\t\t\tok|=cmp(j,0,st,b[k],len);\n\t\t}\n\t\tflag[i]=ok;\n\t}\n\t\n\tif (c[0]>=\'a\'&& c[0]<=\'z\')c[0]=c[0]-\'a\'+\'A\';\n\n\tfor (int i=0;st[i];i++)\n\n\t\tif (flag[i])\n\t\t{\n\t\t\tif (st[i]>=\'A\' && st[i]<=\'Z\')\n\t\t\t{\n\t\t\t\tif (st[i]==c[0])\n\t\t\t\t{\n\t\t\t\t\tif (st[i]==\'A\') st[i]=\'B\';\n\t\t\t\t\telse st[i]=\'A\';\n\t\t\t\t} else st[i]=c[0];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tif (st[i]==c[0]-\'A\'+\'a\')\n\t\t\t\t{\n\t\t\t\t\tif (st[i]==\'a\') st[i]=\'b\';\n\t\t\t\t\telse st[i]=\'a\';\n\t\t\t\t} else st[i]=c[0]-\'A\'+\'a\';\n\t\t\t} \n\t\t}\n\t\n\tprintf(""%s"",st);\n}\n\t\t']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1600
Mom bought the boy Vasya a n dimensional chocolate bar which is a n dimensional cube with the length of each side equal to 1 The chocolate is planned to be divided into slices According to the ith dimension it can be divided by hyperplanes into a i equal parts Thus the chocolate is divided in total into a 1 cdot a 2 cdot a 3 cdot ldots cdot a n slices each slice has a length of i th dimension equal to frac 1 a i respectively the volume of each slice is frac 1 a 1 a 2 cdots a n Vasya and his friends want to cut a chocolate bar to get at least k pieces while Vasya wants to maximize the volume of the smallest of them It is possible to cut the chocolate bar only at the junction of the lobules and each incision must pass through the entire chocolate bar along some hyperplane involved in the formation of lobules Only after making all the cuts Vasya disassembles the chocolate into pieces More formally Vasya wants to choose the numbers b 1 b 2 dots b n 1 le b i le a i the number of parts into which Vasya will cut the chocolate bar along each dimension The condition b 1 cdot b 2 cdot ldots cdot b n ge k must be met to get at least k pieces after all cuts It can be noted that with optimal cutting with such parameters the minimum piece will contain lfloor frac a 1 b 1 rfloor dotsm lfloor frac a n b n rfloor slices and its volume will be equal to lfloor frac a 1 b 1 rfloor dotsm lfloor frac a n b n rfloor cdot frac 1 a 1 a 2 cdots a n Vasya wants to get the maximum possible value of the volume of the minimum piece multiplied by k that is he wants to maximize the number of lfloor frac a 1 b 1 rfloor dotsm lfloor frac a n b n rfloor cdot frac 1 a 1 a 2 cdots a n cdot k Help him with this ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT で数列を管理するときに使う (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify してないや\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ソートして i 番目が idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//例えば sortidx で得た idx を使えば単にソート列になって返ってくる\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\nstruct N{\n\tvi vs;\n\tint n,n2,s;\n\tN(int n_):n(n_),n2(sqrtl(n)){\n\t\t{\n\t\t\tint v=n;\n\t\t\twhile(1){\n\t\t\t\tvs.pb(v);\n\t\t\t\tif(v==1)break;\n\t\t\t\tint w=(n+v-2)/(v-1);\n\t\t\t\tv=(n+w-1)/w;\n\t\t\t}\n\t\t}\n\t\ts=vs.size();\n\t}\n\tint getidx(int a){\n\t\treturn a<=n2?s-a:(n+a-1)/a-1;\n\t}\n};\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tN z(k);\n\tint s=z.s;\n\tdmp(z.vs);\n\tvvc<pi> g(s);\n\trep(i,s){\n\t\tint w=z.vs[i];\n\t\tint d=1;\n\t\twhile(1){\n\t\t\tint v=(w+d-1)/d;\n\t\t\tg[i].eb(z.getidx(v),d);\n\t\t\t\n\t\t\tif(v==1)break;\n\t\t\td=(w+v-2)/(v-1);\n\t\t}\n\t}\n\tdmp(g);\n\tusing ld=long double;\n\tvc<ld> dp(s,0);\n\tdp[0]=k;\n\tauto nx=dp;\n\trep(_,n){\n\t\tint a;cin>>a;\n\t\tfill(all(nx),0);\n\t\trep(i,s)for(auto [j,d]:g[i]){\n\t\t\tdmp2(i,j,dp[i],(a/d),a);\n\t\t\tchmax(nx[j],dp[i]*(a/d)/a);\n\t\t}\n\t\tswap(nx,dp);\n\t\tdmp(dp);\n\t}\n\tcout<<dp[s-1]<<endl;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2700
Fox Ciel has a board with rows and columns So the board consists of cells Each cell contains either a symbol or a symbol A cross on the board is a connected set of exactly five cells of the board that looks like a cross The picture below shows how it looks Ciel wants to draw several may be zero crosses on the board Each cross must cover exactly five cells with symbols and any cell with symbol must belong to some cross No two crosses can share a cell Please tell Ciel if she can draw the crosses in the described way ,"['#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=(a),_b=(b); i<=_b; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b); i>=_b; i--)\n#define REP(i,a) for(int i=0,_a=(a); i<_a; i++)\n\n#define DEBUG(x) { cout << #x << "" = ""; cout << x << endl; }\n#define PR(a,n) { cout << #a << "" = ""; FOR(_,1,n) cout << a[_] << \' \'; cout << endl; }\n#define PR0(a,n) { cout << #a << "" = ""; REP(_,n) cout << a[_] << \' \'; cout << endl; }\nusing namespace std;\n\nchar a[111][111];\n\nint main() {\n    ios :: sync_with_stdio(false);\n    int n;\n    while (cin >> n) {\n        FOR(i,1,n) FOR(j,1,n) cin >> a[i][j];\n\n        bool good = true;\n        FOR(i,1,n) FOR(j,1,n) if (a[i][j] == \'#\') {\n            if (a[i+1][j-1] == \'#\' && a[i+1][j] == \'#\' && a[i+1][j+1] == \'#\' && a[i+2][j] == \'#\') {\n                a[i+1][j-1] = a[i+1][j] = a[i+1][j+1] = a[i+2][j] = \'.\';\n            }\n            else good = false;\n        }\n        if (good) puts(""YES""); else puts(""NO"");\n    }\n    return 0;\n}\n']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Petya has a number consisting of digits without leading zeroes He represented it as an array of digits without leading zeroes Let s call it The numeration starts with starting from the most significant digit Petya wants to perform the following times find the minimum such that and if is odd then to assign otherwise to assign Note that if no was found then the operation counts as completed and the array doesn t change at all You are given the initial number as an array of digits and the number Help Petya find the result of completing operations ,"[""#include <algorithm>\n#include <iostream>\n#include <assert.h>\n#include <sstream>\n#include <complex>\n#include <numeric>\n#include <cstring>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define all(a)\t\t\t(a).begin(), (a).end()\n#define sz(a)\t\t\tint((a).size())\n#define FOR(i, a, b)\tfor (int i(a); i < b; ++i)\n#define REP(i, n)\t\tFOR(i, 0, n)\n#define UN(v)\t\t\tsort(all(v)), (v).erase(unique((v).begin(), (v).end()), (v).end())\n#define CL(a, b)\t\tmemset(a, b, sizeof a)\n#define pb\t\t\t\tpush_back\n#define X\t\t\t\tfirst\n#define Y\t\t\t\tsecond\n\ntypedef long long ll;\ntypedef vector <int> vi;\ntypedef pair <int, int> pii;\n\nint n, k;\nchar s[100500];\n\nint main() {\n\tcin >> n >> k >> s;\n\tint i = 0;\n\tfor (; k > 0; ) {\n\t\tif (s[i] == 0 || s[i + 1] == 0) break;\n\t\tif (s[i] == '4' && s[i + 1] == '7') {\n\t\t\tif (i % 2) {\n\t\t\t\ts[i] = '7';\n\t\t\t\t--k;\n\t\t\t\tif (i) {\n\t\t\t\t\t--i;\n\t\t\t\t\tif (s[i] == '4') {\n\t\t\t\t\t\tk %= 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ts[i + 1] = '4';\n\t\t\t\t--k;\n\t\t\t}\n\t\t} else ++i;\n\t}\n\tputs(s);\n\treturn 0;\n}\n""]","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1500
Tony Stark is playing a game with his suits they have auto pilot now He lives in Malibu Malibu has junctions numbered from to connected with roads One can get from a junction to any other junction using these roads graph of Malibu forms a tree Tony has suits There s a special plan for each suit The th suit will appear at the moment of time in the junction and will move to junction using the shortest path between and with the speed roads per second passing a junctions takes no time and vanishing immediately when arriving at if it reaches in time it s available there at moment but not in further moments Also suits move continuously for example if at time it s in the middle of a road Please note that if it means the suit will be at junction number only at moment and then it vanishes An explosion happens if at any moment of time two suits share the same exact location it may be in a junction or somewhere on a road while appearing vanishing or moving Your task is to tell Tony the moment of the the first explosion if there will be any ,"['#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\n// {{{\n// clang-format off\n#define all(a) (a).begin(), (a).end()\n#define sz(a) static_cast<int>((a).size())\n#define fillchar(a, x) memset(a, x, sizeof(a))\n#define rep(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define irep(i, a, b) for (int i = int(a); i >= int(b); --i)\n#define replr(i, a, b) rep(i, a, (b)-1)\n#define reprl(i, a, b) irep(i, (b)-1, a)\n#define repn(i, n) rep(i, 0, (n)-1)\n#define irepn(i, n) irep(i, (n)-1, 0)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define popcount __builtin_popcount\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<bool> VB;\ntypedef vector<string> VS;\ntypedef vector<PII> VPI;\ntypedef vector<PLL> VPL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VPI> VVPI;\ntypedef vector<VPL> VVPL;\ntemplate <class T, class S> ostream& operator<<(ostream& os, const pair<T, S>& v) { return os << ""("" << v.first << "", "" << v.second << "")""; }\ntemplate <class T> ostream& operator<<(ostream& os, const vector<T>& v) { os << ""[""; repn(i, sz(v)) { if(i) os << "", ""; os << v[i]; } return os << ""]""; }\ntemplate <class T> bool setmax(T& _a, T _b) { if(_a < _b) { _a = _b; return true; } return false; }\ntemplate <class T> bool setmin(T& _a, T _b) { if(_b < _a) { _a = _b; return true; } return false; }\ntemplate <class T> T gcd(T _a, T _b) { return _b == 0 ? _a : gcd(_b, _a % _b); }\nVI read_vi(int n = -1) { if (n < 0) scanf(""%d"", &n); VI a(n); repn(i, n) scanf(""%d"", &a[i]); return a; }\nVL read_vl(int n = -1) { if (n < 0) scanf(""%d"", &n); VL a(n); repn(i, n) scanf(""%lld"", &a[i]); return a; }\nVPI read_vpi(int n = -1) { if (n < 0) scanf(""%d"", &n); VPI a(n); repn(i, n) scanf(""%d%d"", &a[i].fi,&a[i].se); return a; }\nVPL read_vpl(int n = -1) { if (n < 0) scanf(""%d"", &n); VPL a(n); repn(i, n) scanf(""%lld%lld"", &a[i].fi,&a[i].se); return a; }\ninline LL powmod(LL a, LL b, LL m) { LL r = 1; for(; b > 0; b >>= 1, a = a * a % m) { if(b & 1) r = r * a % m; } return r; }\n// clang-format on\n// }}}\n\ntypedef long double R;\n\nconst R EPS = 1e-12;\nint sgn(R x) { return x < -EPS ? -1 : x > EPS; }\nstruct Point {\n    R x, y;\n    Point() {}\n    Point(R _x, R _y) : x(_x), y(_y) {}\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(R b) const { return Point(x * b, y * b); }\n    Point operator/(R b) const { return Point(x / b, y / b); }\n    void rotate90() {\n        swap(x, y);\n        x = -x;\n    }\n    R len() const { return sqrt(x * x + y * y); }\n    void normalize() { *this = *this / len(); }\n    friend R mult(Point p1, Point p2) { return p1.x * p2.y - p1.y * p2.x; }\n    friend R dot(Point p1, Point p2) { return p1.x * p2.x + p1.y * p2.y; }\n    friend R mult(Point p0, Point p1, Point p2) {\n        return mult(p1 - p0, p2 - p0);\n    }\n    friend R dot(Point p0, Point p1, Point p2) { return dot(p1 - p0, p2 - p0); }\n    friend R dist(Point p1, Point p2) { return (p1 - p2).len(); }\n    R lambda(Point s, Point t) const {  // return c: p=s+(t-s)*c\n        return dot(s, t, *this) / dot(s, t, t);\n    }\n};\nstruct Line {\n    R a, b, c;\n    Line() {}\n    Line(R _a, R _b, R _c) : a(_a), b(_b), c(_c) {}\n    Line(Point p1, Point p2) {\n        a = p2.y - p1.y, b = p1.x - p2.x;\n        c = -(p1.x * a + p1.y * b);\n    }\n    Point cross(const Line& l) const {\n        R t = a * l.b - b * l.a;\n        R x = b * l.c - c * l.b;\n        R y = c * l.a - a * l.c;\n        return Point(x / t, y / t);\n    }\n};\nstruct Segment {\n    Point p1, p2;\n    bool is_point = false;\n    Segment(R x, R y) : p1(x, y), p2(x, y), is_point(true) {}\n    Segment(R x1, R y1, R x2, R y2) : p1(x1, y1), p2(x2, y2) {\n        if(p1.y > p2.y) swap(p1, p2);\n    }\n    R at(R y) const {\n        if(is_point) {\n            assert(sgn(y - p1.y) == 0);\n            return p1.x;\n        }\n        return p1.x + (y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);\n    }\n};\n\nvector<Segment> prepare() {\n    int n, m;\n    scanf(""%d%d"", &n, &m);\n    VVI es(n);\n    repn(i, n - 1) {\n        int a, b;\n        scanf(""%d%d"", &a, &b), --a, --b;\n        es[a].pb(b), es[b].pb(a);\n    }\n    const int LOG = 20;\n    VI my(n, -1), dep(n);\n    VVI up(n, VI(LOG, -1));\n    const function<int(int, int)> cal_my = [&](int x, int fa) {\n        if(fa >= 0) dep[x] = dep[fa] + 1;\n        up[x][0] = fa;\n        for(int i = 0; up[x][i] >= 0; ++i) up[x][i + 1] = up[up[x][i]][i];\n        int size = 1, best = -1;\n        for(int y : es[x]) {\n            if(y != fa) {\n                int tmp = cal_my(y, x);\n                size += tmp;\n                if(setmax(best, tmp)) my[x] = y;\n            }\n        }\n        return size;\n    };\n    cal_my(0, -1);\n    VI head(n), where(n), arr;\n    const function<void(int, int, int)> dfs = [&](int x, int fa, int h) {\n        head[x] = h, where[x] = sz(arr), arr.pb(x);\n        if(my[x] >= 0) {\n            dfs(my[x], x, h);\n        }\n        for(int y : es[x]) {\n            if(y != fa && y != my[x]) {\n                arr.pb(x);\n                dfs(y, x, x);\n            }\n        }\n    };\n    dfs(0, -1, 0);\n    const auto lca = [&](int x, int y) {\n        if(dep[x] > dep[y]) swap(x, y);\n        repn(i, LOG) if((dep[y] - dep[x]) & (1 << i)) y = up[y][i];\n        irepn(i, LOG) if(up[x][i] != up[y][i]) x = up[x][i], y = up[y][i];\n        if(x != y) x = up[x][0];\n        return x;\n    };\n    const auto extract = [&](int x, int target) {\n        VPI r;\n        while(x != target) {\n            int y = head[x];\n            if(dep[y] < dep[target]) y = target;\n            int len = dep[x] - dep[y];\n            r.pb(mp(where[x], where[x] - len));\n            x = y;\n        }\n        return r;\n    };\n\n    // cout << head << endl;\n    // cout << where << endl;\n    // cout << arr << endl;\n\n    vector<Segment> segments;\n    while(m--) {\n        int t, c, x, y;\n        scanf(""%d%d%d%d"", &t, &c, &x, &y), --x, --y;\n        int z = lca(x, y);\n        VPI px = extract(x, z);\n        VPI py = extract(y, z);\n        bool covered = false;\n        if(!px.empty() && px.back().se == where[z]) covered = true;\n        if(!py.empty() && py.back().se == where[z]) covered = true;\n        int cur = 0;\n        for(const auto& p : px) {\n            int tmp = cur + abs(p.fi - p.se);\n            segments.pb(Segment(p.fi, t + R(cur) / c, p.se, t + R(tmp) / c));\n            cur = tmp;\n        }\n        if(!covered) {\n            segments.pb(Segment(where[z], t + R(cur) / c));\n        }\n        reverse(all(py));\n        for(auto& p : py) {\n            swap(p.fi, p.se);\n            int tmp = cur + abs(p.fi - p.se);\n            segments.pb(Segment(p.fi, t + R(cur) / c, p.se, t + R(tmp) / c));\n            cur = tmp;\n        }\n    }\n    return segments;\n}\n\nbool on_segment(Point p, Segment b) {\n    return sgn(dot(p, b.p1, b.p2)) <= 0 && sgn(mult(p, b.p1, b.p2)) == 0;\n}\n\nR intersection(Segment a, Segment b) {\n    if(sgn(mult(a.p1, a.p2, b.p1)) * sgn(mult(a.p1, a.p2, b.p2)) > 0)\n        return 1e50;\n    if(sgn(mult(b.p1, b.p2, a.p1)) * sgn(mult(b.p1, b.p2, a.p2)) > 0)\n        return 1e50;\n    if(sgn(mult(a.p1 - a.p2, b.p1 - b.p2)) == 0) {\n        R r = 1e50;\n        if(on_segment(a.p1, b)) setmin(r, a.p1.y);\n        if(on_segment(a.p2, b)) setmin(r, a.p2.y);\n        if(on_segment(b.p1, a)) setmin(r, b.p1.y);\n        if(on_segment(b.p2, a)) setmin(r, b.p2.y);\n        return r;\n    } else {\n        return Line(a.p1, a.p2).cross(Line(b.p1, b.p2)).y;\n    }\n}\n\nR cur = 0;\nvector<Segment> segments;\n\nvoid find_intersection() {\n    R found = 1e50;\n    vector<pair<R, int>> events;\n    repn(i, sz(segments)) {\n        events.pb(mp(segments[i].p1.y, -i - 1));\n        events.pb(mp(segments[i].p2.y + EPS / 5, i));\n    }\n    sort(all(events));\n    struct Id {\n        int i;\n        bool operator<(const Id& b) const {\n            int s = sgn(segments[i].at(cur) - segments[b.i].at(cur));\n            if(s == 0) s = i - b.i;\n            return s < 0;\n        }\n    };\n    set<Id> ids;\n    for(const auto& e : events) {\n        if(e.fi >= found) break;\n        cur = e.fi;\n        if(e.se < 0) {\n            auto it = ids.insert(Id{-e.se - 1}).fi;\n            auto p = it;\n            ++p;\n            if(p != ids.end()) {\n                setmin(found, intersection(segments[it->i], segments[p->i]));\n            }\n            p = it;\n            if(p != ids.begin()) {\n                --p;\n                setmin(found, intersection(segments[it->i], segments[p->i]));\n            }\n        } else {\n            assert(ids.erase(Id{e.se}) == 1);\n        }\n    }\n    if(found > 1e40) {\n        printf(""-1\\n"");\n    } else {\n        assert(found >= 0);\n        printf(""%.15lf\\n"", (double)found);\n    }\n}\n\nint main() {\n    segments = prepare();\n    find_intersection();\n    return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]",3300
Let s define a of length n as an array p of length n which contains every number from 1 to n exactly once You are given a permutation p 1 p 2 dots p n and a number k You need to sort this permutation in the ascending order In order to do it you can repeat the following operation any number of times possibly zero pick two elements of the permutation p i and p j such that i j k and swap them Unfortunately some permutations can t be sorted with some fixed numbers k For example it s impossible to sort 2 4 3 1 with k 2 That s why before starting the sorting you can make at most one choose any pair p i and p j and swap them Your task is to check whether is it possible to sort the permutation any preliminary exchanges if it s not check whether is it possible to sort the permutation using exactly preliminary exchange For example if k 2 and permutation is 2 4 3 1 then you can make a preliminary exchange of p 1 and p 4 which will produce permutation 1 4 3 2 which is possible to sort with given k ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005;\n\nint n,k,a[N];\n\nvoid ldc(){\n    cin >> n >> k;\n    for(int i=0; i<n; ++i) cin >> a[i],a[i]--;\n    int de=0;\n    for(int i=0; i<n; ++i) if(a[i]%k!=i%k) de++;\n    assert(de!=1);\n    if(de==0) cout << ""0\\n"";\n    else if(de==2) cout << ""1\\n"";\n    else cout << ""-1\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
Nastya likes reading and even spends whole days in a library sometimes Today she found a chronicle of Byteland in the library and it stated that there lived shamans long time ago It is known that at every moment there was exactly one shaman in Byteland and there were shamans in total enumerated with integers from to in the order they lived Also each shaman had a magic power which can now be expressed as an integer The chronicle includes a list of powers of the shamans Also some shamans can be king shamans if they gathered all the power of their predecessors i e their power is exactly the sum of powers of all previous shamans Nastya is interested in whether there was at least one king shaman in Byteland Unfortunately many of the powers are unreadable in the list so Nastya is doing the following Initially she supposes some power for each shaman After that she changes the power of some shaman times the shamans can differ and after that wants to check if there is at least one king shaman in the list If yes she wants to know the index of any king shaman Unfortunately the list is too large and Nastya wants you to help her ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 262144;\ntypedef long long ll;\n\nint n, q;\nll z[200005], a[200005];\n\nconst ll INF = 2123123123123123123ll;\n\nstruct stb {\n\tstruct node {\n\t\tll b, lo, hi;\n\t\tint z;\n\n\t\tnode& operator+= (const node& o) {\n\t\t\tlo = min(lo, o.lo);\n\t\t\thi = max(hi, o.hi);\n\t\t\tz = max(z, o.z);\n\t\t\treturn *this;\n\t\t}\n\n\t\tnode operator+ (const node& o) const {\n\t\t\tnode tmp = *this;\n\t\t\ttmp += o;\n\t\t\treturn tmp;\n\t\t}\n\t};\n\n\tnode d[2*MAXN];\n\n\tvoid push(int i) {\n\t\tif (d[i].b == 0)\n\t\t\treturn;\n\n\t\tif (i >= MAXN) {\n\t\t\td[i].lo += d[i].b;\n\t\t\td[i].hi += d[i].b;\n\t\t\td[i].z = d[i].lo == 0 ? i - MAXN + 1 : -1;\n\t\t\td[i].b = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tif (!(d[i].lo + d[i].b <= 0 && 0 <= d[i].hi + d[i].b)) {\n\t\t\td[i].lo += d[i].b;\n\t\t\td[i].hi += d[i].b;\n\t\t\td[2*i].b += d[i].b;\n\t\t\td[2*i+1].b += d[i].b;\n\t\t\td[i].b = 0;\n\t\t\td[i].z = -1;\n\t\t\treturn;\n\t\t}\n\n\t\td[2*i].b += d[i].b;\n\t\td[2*i+1].b += d[i].b;\n\t\tpush(2*i);\n\t\tpush(2*i+1);\n\t\td[i] = d[2*i] + d[2*i+1];\n\t}\n\n\tvoid init() {\n\t\tfor (int i=1; i<=n; i++)\n\t\t\td[i + MAXN - 1] = {0, z[i], z[i], z[i] == 0 ? i : -1};\n\t\tfor (int i=n+1; i<=MAXN; i++)\n\t\t\td[i + MAXN - 1] = {0, INF, INF, -1};\n\n\t\tfor (int i=MAXN-1; i>=1; i--)\n\t\t\td[i] = d[2*i] + d[2*i+1];\n\t}\n\n\tvoid add(int l, int r, ll val, int x = 1, int xl = 1, int xr = MAXN) {\n\t\tpush(x);\n\t\tif (r < xl || xr < l)\n\t\t\treturn;\n\t\tif (l <= xl && xr <= r) {\n\t\t\td[x].b += val;\n\t\t\tpush(x);\n\t\t\treturn;\n\t\t}\n\n\t\tint xm = (xl + xr) >> 1;\n\t\tadd(l, r, val, 2*x, xl, xm);\n\t\tadd(l, r, val, 2*x+1, xm+1, xr);\n\n\t\td[x] = d[2*x] + d[2*x+1];\n\t}\n\n\tint nula() {\n\t\tpush(1);\n\t\treturn d[1].z;\n\t}\n\n} drvo;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tcin >> n >> q;\n\n\tll ps = 0;\n\tfor (int i=1; i<=n; i++) {\n\t\tint x;\n\t\tcin >> x;\n\t\ta[i] = x;\n\t\tz[i] = x - ps;\n\t\tps += x;\n\t}\n\n\tdrvo.init();\n\n\tfor (int i=1; i<=q; i++) {\n\t\tint p;\n\t\tll v;\n\t\tcin >> p >> v;\n\t\tv -= a[p];\n\t\ta[p] += v;\n\n\t\tdrvo.add(p, p, v);\n\t\tif (p != n)\n\t\t\tdrvo.add(p+1, n, -v);\n\t\tcout << drvo.nula() << '\\n';\n\t}\n}""]","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
He loves this sequence very much and wants to play with it Let f 1 f 2 ldots f i ldots be an infinite sequence of positive integers Bob knows that for i k f i can be obtained by the following recursive equation f i left f i 1 b 1 cdot f i 2 b 2 cdot cdots cdot f i k b k right bmod p which in short isf i left prod j 1 k f i j b j right bmod p where p 998 244 353 a widely used prime b 1 b 2 ldots b k are known integer constants and x bmod y denotes the remainder of x divided by y Bob lost the values of f 1 f 2 ldots f k which is extremely troublesome these are the basis of the sequence Luckily Bob remembers the first k 1 elements of the sequence f 1 f 2 ldots f k 1 1 and the n th element f n m Please find any possible value of f k If no solution exists just tell Bob that it is impossible to recover his favorite sequence regardless of Bob s sadness ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 110;\nconst int P = 998244353;\n\nint D[N][N], E[N][N], F[N][N];\n\nint k;\n\nvoid mul(int A[N][N], int B[N][N], int C[N][N]) {\n\tfor (int i = 0; i < k; i++) {\n\t\tfor (int j = 0; j < k; j++) D[i][j] = A[i][j], E[i][j] = B[i][j];\n\t}\n\tfor (int i = 0; i < k; i++) {\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tlong long val = 0;\n\t\t\tfor (int l = 0; l < k; l++) {\n\t\t\t\tval += 1LL * D[i][l] * E[l][j];\n\t\t\t\tval %= (P - 1);\n\t\t\t}\n\t\t\tC[i][j] = val;\n\t\t}\n\t}\n}\n\nvoid pow(int A[N][N], int n, int B[N][N]) {\n\tif (n == 0) {\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\tif (i == j) B[i][j] = 1;\n\t\t\t\telse B[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tint hn = n / 2;\n\tpow(A, hn, B);\n\tmul(B, B, B);\n\tif (n & 1) mul(B, A, B);\n}\n\nint modExp(int a, long long n, int p) {\n\tint ret = 1; ((a %= p) < 0) && (a += p);\n\tfor (; n; n >>= 1, a = (long long)a * a % p)\n\t\tif (n & 1) ret = (long long)ret * a % p;\n\treturn ret;\n}\n\nmap<int, int> M;\n\ntemplate<typename T>\nT mod_inv(T a, T mod) {\n\tif (__gcd(a, mod) != 1) return -1;\n\tT b = mod, s = 1, t = 0;\n\twhile (b) {\n\t\tT q = a / b;\n\t\tswap(a -= q * b, b);\n\t\tswap(s -= q * t, t);\n\t}\n\treturn s < 0 ? s + mod : s;\n}\n\nint L = 100000;\n\nint A[N][N], B[N][N];\nint b[N];\n\nint main() {\n\tcin >> k;\n\tfor (int i = 0; i < k; i++) cin >> b[i];\n\tint n, m; cin >> n >> m;\n\tfor (int i = 0, j = 1; i < L; i++, j = 1LL * j * 3 % P) {\n\t\tM[j] = i;\n\t}\n\tint PJ = modExp(3, P-1-L, P);\n\tint pm;\n\tfor (int add = 0, cur = m; ; add += L, cur = 1LL * cur * PJ % P) {\n\t\tif (M.count(cur)) {\n\t\t\tpm = M[cur] + add;\n\t\t\tbreak;\n\t\t}\n\t}\n\tassert(modExp(3, pm, P) == m);\n\tmemset(A, 0, sizeof A);\n\tfor (int i = 0; i < k; i++) A[0][i] = b[i];\n\tfor (int i = 1; i < k; i++) {\n\t\tA[i][i-1] = 1;\n\t}\n\tpow(A, n - k, B);\n\tint a = B[0][0];\n\tint d = __gcd(a, P - 1);\n\tif (pm % d != 0) return puts(""-1""), 0;\n\ta /= d, pm /= d;\n\tint p = (P - 1) / d;\n\tint x = 1LL * mod_inv(a, p) * pm % p;\n\tcout << modExp(3, x, P) << endl;\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2400
After graduating from computer sciences Vlad has been awarded an array a 1 a 2 ldots a n of n non negative integers As it is natural he wanted to construct a graph consisting of n vertices numbered 1 2 ldots n He decided to add an edge between i and j if and only if a i a j 0 where denotes the bitwise AND operation Vlad also wants the graph to be connected which might not be the case initially In order to satisfy that he can do the following two types of operations on the array Choose some element a i and increment it by 1 Choose some element a i and decrement it by 1 possible only if a i 0 It can be proven that there exists a finite sequence of operations such that the graph will be connected So can you please help Vlad find the minimum possible number of operations to do that and also provide the way how to do that ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            if (a[i] == 0) a[i] = 1, ++ans;\n        }\n        auto check = [&](vector<int> a) {\n            vector<int> vis(31), f(31);\n            function<int(int)> find = [&](int x) {\n                if (f[x] == x) return f[x];\n                return f[x] = find(f[x]);\n            };\n            for (int i = 0; i <= 30; i++) f[i] = i;\n            for (auto i : a) {\n                int r = -1;\n                for (int b = 0; b <= 30; b++) {\n                    if ((i >> b) & 1) {\n                        vis[b] = 1;\n                        if (r == -1) r = b;\n                        f[find(b)] = find(r);\n                    }\n                }\n            }\n            int cnt = 0;\n            for (int i = 0; i < 30; i++) {\n                if (vis[i] && find(i) == i) {\n                    ++cnt;\n                }\n            }\n            return cnt == 1;\n        };\n        if (check(a)) {\n            cout << ans << endl;\n            for (auto i : a) cout << i << "" "";\n            cout << endl;\n            continue;\n        }\n        int ok = 0;\n        for (int i = 0; i < n; i++) {\n            if (a[i] != 1) {\n                --a[i];\n                if (check(a)) {\n                    cout << ans + 1 << endl;\n                    for (auto i : a) cout << i << "" "";\n                    cout << endl;\n                    ok = 1;\n                    break;\n                }\n                ++a[i];\n            }\n            ++a[i];\n            if (check(a)) {\n                cout << ans + 1 << endl;\n                for (auto i : a) cout << i << "" "";\n                cout << endl;\n                ok = 1;\n                break;\n            }\n            --a[i];\n        }\n        if (ok) continue;\n        vector<int> vis(30), f(30);\n        for (int i = 0; i < 30; i++) f[i] = i;\n        function<int(int)> find = [&](int x) {\n            if (f[x] == x) return f[x];\n            return f[x] = find(f[x]);\n        };\n        for (auto i : a) {\n            int r = -1;\n            for (int b = 0; b <= 29; b++) {\n                if ((i >> b) & 1) {\n                    vis[b] = 1;\n                    if (r == -1) r = b;\n                    int x = find(b), y = find(r);\n                    if (x > y) f[x] = y;\n                    else f[y] = x;\n                }\n            }\n        }\n        for (int i = 29; i >= 0; i--) {\n            if (vis[i] && find(i) == i) {\n                for (int j = 0; j < n; j++) {\n                    if ((a[j] >> i) & 1) {\n                        --a[j];\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            ++a[i];\n            if (check(a)) {\n                cout << ans + 2 << endl;\n                for (auto i : a) cout << i << "" "";\n                cout << endl;\n                break;\n            }\n            --a[i];\n        }\n    }\n    return 0;\n}']","[0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]",2500
You are given n chips on a number line The i th chip is placed at the integer coordinate x i Some chips You can perform each of the two following types of moves any possibly zero number of times on any chip Move the chip i by 2 to the left or 2 to the right i e replace the current coordinate x i with x i 2 or with x i 2 move the chip i by 1 to the left or 1 to the right and pay for this move i e replace the current coordinate x i with x i 1 or with x i 1 Note that it s allowed to move chips to any integer coordinate including negative and zero Your task is to find the minimum total number of coins required to move all n chips to the same coordinate i e all x i should be equal after some sequence of moves ,"['#include ""bits/stdc++.h""\nusing namespace std;\n// #define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n;\n    cin >> n;\n    int b0 = 0, b1 = 0;\n    fr(i, 1, n) {\n        int x;\n        cin >> x;\n        x %= 2;\n        if(x) b1++;\n        else b0++;\n    }\n    cout << min(b0, b1);\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
You are given a permutation p of length n an array of m integers a 1 a 2 ldots a m 1 le a i le n and an integer d Let mathrm pos x be the index of x in the permutation p The array a is if mathrm pos a i mathrm pos a i 1 le mathrm pos a i d for all 1 le i m For example with the permutation p 4 2 1 3 6 5 and d 2 a 2 3 6 is a not array a 2 6 5 is because mathrm pos a 1 2 mathrm pos a 2 5 so the condition mathrm pos a 2 le mathrm pos a 1 d is not satisfied a 1 6 3 is because mathrm pos a 2 5 mathrm pos a 3 4 so the condition mathrm pos a 2 mathrm pos a 3 is not satisfied In one move you can swap two adjacent elements of the permutation p What is the minimum number of moves needed such that the array a becomes It can be shown that there always exists a sequence of moves so that the array a becomes A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n//inline int fastpow(int x, int y){\n//\tint z=1;\n//\tfor (; y; y>>=1,x=1ll*x*x%mod)\n//\t\tif (y&1) z=1ll*z*x%mod;\n//\treturn z;\n//}\nint T,n,m,d,a[200005],p[200005],pos[200005];\nint main(){\n\tfor (cin>>T; T; T--){\n\t\tscanf(""%d%d%d"",&n,&m,&d);\n\t\tfor (int i=1; i<=n; i++) scanf(""%d"",&p[i]),pos[p[i]]=i;\n\t\tfor (int i=1; i<=m; i++) scanf(""%d"",&a[i]);\n\t\tint ans=1e9;\n\t\tfor (int i=1; i<m; i++){\n\t\t\tif (pos[a[i+1]]<pos[a[i]] || pos[a[i+1]]>pos[a[i]]+d) ans=0;\n\t\t\telse {\n\t\t\t\tans=min(ans,pos[a[i+1]]-pos[a[i]]);\n\t\t\t\tif (d+2<=n) ans=min(ans,d-(pos[a[i+1]]-pos[a[i]]-1));\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t}\n}']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Polycarp found the string s and the permutation p Their lengths turned out to be the same and equal to n A permutation of n elements is an array of length n in which every integer from 1 to n occurs exactly once For example 1 2 3 and 4 3 5 1 2 are permutations but 1 2 4 4 3 2 1 2 and 0 1 2 are not In one operation he can multiply s by p so he replaces s with string new in which for any i from 1 to n it is true that new i s p i For example with s wmbe and p 3 1 4 2 after operation the string will turn to s s 3 s 1 s 4 s 2 bwem Polycarp wondered after how many operations the string would become equal to its initial value for the first time Since it may take too long he asks for your help in this matter It can be proved that the required number of operations always exists It can be very large so use a 64 bit integer type ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int inf = 1\'000\'000\'001;\nconst int infll = (inf - 1) * (inf - 1) + 1;\nconst int mod = inf + 6;\nstring perm(string &s, vector<int> &p){\n    int n = s.size();\n    string t(n, \'1\');\n    for(int i = 0;i < n;i++){\n        t[p[i]] = s[i];\n    }\n    return t;\n}\nint lcm(int a, int b){\n    return a / __gcd(a, b) * b;\n}\nstring gt(string &s, vector<int> &d){\n    string t = """";\n    for(int i = 0;i < d.size();i++){\n        t += s[d[i]];\n    }\n    return t;\n}\nvoid solve(){\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    vector<int> p(n);\n    for(int i = 0;i < n;i++){\n        cin >> p[i];\n        p[i]--;\n    }\n    vector<vector<int>> cycles;\n    vector<bool> used(n, false);\n    for(int i = 0;i < n;i++){\n        if(used[i])continue;\n        vector<int> t;\n        int x = i;\n        while(!used[x]){\n            used[x] = true;\n            t.push_back(x);\n            x = p[x];\n        }\n        //sort(t.begin(), t.end());\n        cycles.push_back(t);\n    }\n    vector<string> d;\n    for(int i = 0;i < n + 1;i++){\n        d.push_back(s);\n        s = perm(s, p);\n    }\n    vector<int> need(cycles.size());\n    for(int i = 0;i < need.size();i++){\n        string t = gt(d[0], cycles[i]);\n        need[i] = 1;\n        for(int j = 1;j < d.size();j++){\n            string p = gt(d[j], cycles[i]);\n            if(p == t){\n                need[i] = j;\n                break;\n            }\n        }\n    }\n    int ans = 1;\n    for(int i = 0;i < need.size();i++){\n        ans = lcm(ans, need[i]);\n    }\n    cout << ans << endl;\n}\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n}']","[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0]",1700
After overcoming the stairs Dasha came to classes She needed to write a password to begin her classes The password is a string of length which satisfies the following requirements There is at least one digit in the string There is at least one lowercase small letter of the Latin alphabet in the string There is at least one of three listed symbols in the string Considering that these are programming classes it is not easy to write the password For each character of the password we have a fixed string of length on each of these strings there is a pointer on some character The th character displayed on the screen is the pointed character in the th string Initially all pointers are on characters with indexes in the corresponding strings all positions are numbered starting from one During one operation Dasha can move a pointer in one string one character to the left or to the right Strings are cyclic it means that when we move the pointer which is on the character with index to the left it moves to the character with the index and when we move it to the right from the position it moves to the position You need to determine the minimum number of operations necessary to make the string displayed on the screen a valid password ,"[""#include <iostream>\n#include <cmath>\n#include <vector>\n#include <time.h>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstdio>\n#include <cstdlib>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <string>\n#include <fstream>\n#include <assert.h>\n#include <list>\n#include <cstring>\nusing namespace std;\n\nnamespace fastinput\n{\n\t/** Interface */\n\n\tinline int readChar();\n\ttemplate <class T = int> inline T readInt();\n\ttemplate <class T> inline void writeInt(T x, char end = 0);\n\tinline void writeChar(int x);\n\tinline void writeWord(const char *s);\n\n\t/** Read */\n\n\tstatic const int buf_size = 16384;\n\n\tinline int getChar() {\n\t\tstatic char buf[buf_size];\n\t\tstatic int len = 0, pos = 0;\n\t\tif (pos == len)\n\t\t\tpos = 0, len = fread(buf, 1, buf_size, stdin);\n\t\tif (pos == len)\n\t\t\treturn -1;\n\t\treturn buf[pos++];\n\t}\n\n\tinline int readChar() {\n\t\tint c = getChar();\n\t\twhile (c <= 32)\n\t\t\tc = getChar();\n\t\treturn c;\n\t}\n\n\ttemplate <class T>\n\tinline T readInt() {\n\t\tint s = 1, c = readChar();\n\t\tT x = 0;\n\t\tif (c == '-')\n\t\t\ts = -1, c = getChar();\n\t\twhile ('0' <= c && c <= '9')\n\t\t\tx = x * 10 + c - '0', c = getChar();\n\t\treturn s == 1 ? x : -x;\n\t}\n\n\t/** Write */\n\n\tstatic int write_pos = 0;\n\tstatic char write_buf[buf_size];\n\n\tinline void writeChar(int x) {\n\t\tif (write_pos == buf_size)\n\t\t\tfwrite(write_buf, 1, buf_size, stdout), write_pos = 0;\n\t\twrite_buf[write_pos++] = x;\n\t}\n\n\ttemplate <class T>\n\tinline void writeInt(T x, char end) {\n\t\tif (x < 0)\n\t\t\twriteChar('-'), x = -x;\n\n\t\tchar s[24];\n\t\tint n = 0;\n\t\twhile (x || !n)\n\t\t\ts[n++] = (char)('0' + x % 10), x /= 10;\n\t\twhile (n--)\n\t\t\twriteChar(s[n]);\n\t\tif (end)\n\t\t\twriteChar(end);\n\t}\n\n\tinline void writeWord(const char *s) {\n\t\twhile (*s)\n\t\t\twriteChar(*s++);\n\t}\n\n\tstruct Flusher {\n\t\t~Flusher() {\n\t\t\tif (write_pos)\n\t\t\t\tfwrite(write_buf, 1, write_pos, stdout), write_pos = 0;\n\t\t}\n\t} flusher;\n}\n\nusing namespace fastinput;\n\nconst int N = 51;\nstring s[N];\nint dp[N][1 << 3]; //[had][num/char/special]\nint dist[N][1 << 3];\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> s[i];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tdist[i][0] = 0;\n\t\tdist[i][1] = m + 1;\n\t\tdist[i][2] = m + 1;\n\t\tdist[i][4] = m + 1;\n\n\t\tdist[i][3] = n * m;\n\t\tdist[i][5] = n * m;\n\t\tdist[i][6] = n * m;\n\t\tdist[i][7] = n * m;\n\n\t\tfor (int j = 0; j < m; ++j)\n\t\t{\n\t\t\tint calc = min(j, m - j);\n\t\t\tif (s[i][j] >= 'a' && s[i][j] <= 'z')\n\t\t\t\tdist[i][1] = min(dist[i][1], calc);\n\t\t\telse if (s[i][j] >= '0' && s[i][j] <= '9')\n\t\t\t\tdist[i][2] = min(dist[i][2], calc);\n\t\t\telse if (s[i][j] == '#' || s[i][j] == '*' || s[i][j] == '&')\n\t\t\t\tdist[i][4] = min(dist[i][4], calc);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; ++i)\n\t\tfor (int j = 0; j < 8; ++j)\n\t\t\tdp[i][j] = 1 << 20;\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < 8; ++j)\n\t\t\tfor (int z = 0; z < 8; ++z)\n\t\t\t{\n\t\t\t\tint to = j | z;\n\t\t\t\tdp[i + 1][to] = min(dp[i + 1][to], dp[i][j] + dist[i][z]);\n\t\t\t}\n\tcout << dp[n][7] << endl;\n\treturn 0;\n}""]","[0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
You are given a string s You have to reverse it that is the first letter should become equal to the last letter before the reversal the second letter should become equal to the second to last letter before the reversal and so on For example if your goal is to reverse the string you should get the string To accomplish your goal you can swap the Your task is to calculate the minimum number of swaps you have to perform to reverse the given string ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int N=200005;\nchar s[N],ns[N];\nint n,t[N],mat[N];\nvector<int> v1[N];\nvoid change(int x,int v){\n\tfor (;x<=n;x+=x&(-x)) t[x]+=v;\n}\nint ask(int x){\n\tint s=0;\n\tfor (;x;x-=x&(-x)) s+=t[x];\n\treturn s;\n}\nint main(){\n\tscanf(""%d%s"",&n,s+1);\n\t//n=strlen(s+1);\n\tmemcpy(ns,s,sizeof(ns));\n\treverse(ns+1,ns+n+1);\n\tFor(i,1,n) v1[s[i]].PB(i);\n\tRep(i,n,1){\n\t\tmat[i]=v1[ns[i]].back();\n\t\tv1[ns[i]].pop_back();\n\t}\n\tll ans=0;\n\tFor(i,1,n){\n\t\tchange(mat[i],1);\n\t\tans+=i-ask(mat[i]);\n\t}\n\tcout<<ans<<endl;\n}']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1900
Even polar bears feel cold when lying on the ice Therefore a polar bear Alice is going to make a carpet The carpet can be viewed as a grid with height and width Then the grid is divided into squares Alice is going to assign one of different colors to each square The colors are numbered from 1 to She may choose not to use all of the colors However there are some restrictions For every two adjacent squares squares that shares an edge and there is a in one of the forms or Example of the color constraints Ideally Alice wants to satisfy all color constraints But again life in the Arctic is hard It is not always possible to satisfy all color constraints Fortunately she will still be happy if at least of the color constraints are satisfied If she has colors she can color the carpet in the following way And she is happy because of the color constraints are satisfied and Your task is to help her color the carpet ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint a[4444][4444];\nchar hor[4444][4444], ver[4444][4444];\n\nint main() {\n  int h, w, k;\n  scanf(""%d %d %d"", &h, &w, &k);\n  for (int i=0;i<2*h-1;i++)\n    if (i % 2 == 0) {\n      scanf(""%s"", hor[i / 2]);\n    } else {\n      scanf(""%s"", ver[i / 2]);\n    }\n  if (k == 1) {\n    int cnt = 0;\n    for (int i=0;i<h;i++)\n      for (int j=0;j<w-1;j++)\n        if (hor[i][j] == \'E\') cnt++;\n    for (int i=0;i<h-1;i++)\n      for (int j=0;j<w;j++)\n        if (ver[i][j] == \'E\') cnt++;\n    int total = h*(w-1) + (h-1)*w;\n    if (4*cnt >= 3*total) {\n      printf(""YES\\n"");\n      for (int i=0;i<h;i++) {\n        for (int j=0;j<w-1;j++) printf(""%d "", 1);\n        printf(""%d\\n"", 1);\n      }\n    }\n    else printf(""NO\\n"");\n    return 0;\n  }\n  printf(""YES\\n"");\n  if (h*(w-1) >= (h-1)*w) {\n    for (int i=0;i<h;i++) {\n      a[i][0] = 1;\n      for (int j=0;j<w-1;j++)\n        if (hor[i][j] == \'E\') a[i][j+1] = a[i][j];\n        else a[i][j+1] = 3-a[i][j];\n      if (i > 0) {\n        int good = 0, bad = 0;\n        for (int j=0;j<w;j++)\n          if ((ver[i-1][j] == \'E\') != (a[i-1][j] == a[i][j])) bad++;\n          else good++;\n        if (bad > good) {\n          for (int j=0;j<w;j++) a[i][j] = 3-a[i][j];\n        }\n      }\n    }\n  } else {\n    for (int j=0;j<w;j++) {\n      a[0][j] = 1;\n      for (int i=0;i<h-1;i++)\n        if (ver[i][j] == \'E\') a[i+1][j] = a[i][j];\n        else a[i+1][j] = 3-a[i][j];\n      if (j > 0) {\n        int good = 0, bad = 0;\n        for (int i=0;i<h;i++)\n          if ((hor[i][j-1] == \'E\') != (a[i][j-1] == a[i][j])) bad++;\n          else good++;\n        if (bad > good) {\n          for (int i=0;i<h;i++) a[i][j] = 3-a[i][j];\n        }\n      }\n    }\n  }\n  for (int i=0;i<h;i++) {\n    for (int j=0;j<w-1;j++) printf(""%d "", a[i][j]);\n    printf(""%d\\n"", a[i][w-1]);\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
There are four stones on an infinite line in integer coordinates a 1 a 2 a 3 a 4 The goal is to have the stones in coordinates b 1 b 2 b 3 b 4 The order of the stones does not matter that is a stone from any position a i can end up in at any position b j provided there is a required number of stones in each position that is if a coordinate x appears k times among numbers b 1 ldots b 4 there should be exactly k stones at x in the end We are allowed to move stones with the following operation choose two stones at positions x and y with at least one stone each and move one stone from x to 2y x In other words the operation moves a stone to a symmetric position relative to some other stone At any moment it is allowed to have any number of stones at the same position Find any sequence of operations that achieves the goal or determine that it is impossible The sequence does not have to be shortest but it may contain at most 1000 operations ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define int long long\n\nint a[5],b[5];\nint gcd(int a,int b){return (!b)?a:gcd(b,a%b);}\nint Abs(int x){return (x<0)?-x:x;}\nint getgcd(int *a){\n\tint ans=0;\n\tfor(int i=1;i<=4;i++)\n\t\tfor(int j=1;j<=4;j++)\n\t\t\tans=gcd(ans,Abs(a[i]-a[j]));\n\treturn ans;\n}\nstruct info{\n\tinfo(){ope.clear(),p.clear();}\n\tstd::vector<std::pair<int,int> >ope,p;\n\tvoid flip(int x,int y){\n\t\tope.push_back(std::make_pair(p[x].first,p[y].first));\n\t\tp[x].first=(p[y].first<<1)-p[x].first;\n\t}\n\tstd::pair<int,int>& operator[](int n){return p[n];}\n};\nstd::vector<std::pair<int,int> >ans;\ninfo compress(int *a){\n\tinfo ans;\n\tfor(int i=1;i<=4;i++)ans.p.push_back(std::make_pair(a[i],i));\n\tfor(;;){\n\t\tstd::sort(ans.p.begin(),ans.p.end());\n//\t\tputs("""");\n//\tfor(int i=0;i<4;i++)printf(""%d %d\\n"",ans[i].first,ans[i].second);\n\t\tif(ans[0].first==ans[3].first-1)break;\n\t\tint old=(ans[3].first-ans[0].first);\n\t\tint l,r;\n\t\tl=ans[1].first,r=std::max(ans[3].first,(ans[1].first<<1)-ans[0].first);\n\t\tif(((r-l)<<2)<=(ans[3].first-ans[0].first)*3){\n//\t\t\tputchar(\'*\');\n\t\t\tans.flip(0,1);\n\t\t\tcontinue;\n\t\t}\n\t\tr=ans[2].first,l=std::min(ans[0].first,(ans[2].first<<1)-ans[3].first);\n\t\tif(((r-l)<<2)<=(ans[3].first-ans[0].first)*3){\n//\t\t\tputchar(\'*\');\n\t\t\tans.flip(3,2);\n\t\t\tcontinue;\n\t\t}\n\t\t{\n\t\t\tint d1=ans[3].first-ans[2].first,d0=ans[1].first-ans[0].first,tot=ans[3].first-ans[0].first;\n\t\t\tif(d1<(tot>>2)&&d0<(tot>>2)){\n\t\t\t\tans.flip(0,3);\n\t\t\t\tans.flip(1,2);\n\t\t\t\tans.flip(2,3);\n\t\t\t}\n\t\t\telse if(d1>d0){\n\t\t\t\tans.flip(2,3);\n\t\t\t\tans.flip(1,2);\n\t\t\t\tans.flip(1,3);\n\t\t\t\tans.flip(2,3);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans.flip(1,0);\n\t\t\t\tans.flip(2,1);\n\t\t\t\tans.flip(2,0);\n\t\t\t\tans.flip(1,0);\n\t\t\t}\n\t\t}\n\t}\n\tif(ans[0].first&1){\n\t\tans.flip(0,3);\n\t\tans.flip(1,3);\n\t\tans.flip(2,3);\n\t}\n\tstd::sort(ans.p.begin(),ans.p.end());\n\treturn ans;\n}\ninfo move(std::vector<std::pair<int,int> >pos1,std::vector<std::pair<int,int> >pos2){\n\tinfo ans;\n\tans.p=pos1;\n\tint delta=pos2[0].first-pos1[0].first,l=0;\n\tstd::vector<std::pair<int,int> >tem; \n//\tprintf(""-%d\\n"",delta);\n\tfor(;;){\n\t\tstd::sort(ans.p.begin(),ans.p.end());\n//\t\tprintf(""%lld %lld %lld\\n"",ans[3].first,ans[0].first,Abs(delta));\n\t\tif(ans[3].first-ans[0].first>Abs(delta))break;\n\t\t++l;\n\t\tans.flip(2,0);\n\t\tans.flip(1,3);\n\t}\n\tfor(;;){\n\t\tstd::sort(ans.p.begin(),ans.p.end());\n\t\tint change=(ans[3].first-ans[0].first)<<1;\n//\t\tprintf(""*%d\\n"",change);\n\t\tfor(;;){\n//\t\t\tprintf(""%d %d\\n"",delta,change);\n\t\t\tif(delta>=change){\n\t\t\t\tans.flip(0,3);\n\t\t\t\tans.flip(1,3);\n\t\t\t\tans.flip(2,3);\n\t\t\t\tans.flip(3,0);\n\t\t\t\tans.flip(2,0);\n\t\t\t\tans.flip(1,0);\n\t\t\t\tdelta-=change;\n\t\t\t}\n\t\t\telse if(delta<=-change){\n\t\t\t\tans.flip(1,0);\n\t\t\t\tans.flip(2,0);\n\t\t\t\tans.flip(3,0);\n\t\t\t\tans.flip(2,3);\n\t\t\t\tans.flip(1,3);\n\t\t\t\tans.flip(0,3);\n\t\t\t\tdelta+=change;\n\t\t\t}else break;\n\t\t}\n\t\tif(l){\n\t\t\t--l;\n\t\t\tans.flip(0,1);\n\t\t\tans.flip(3,2);\n\t\t}else break;\n\t}\n\treturn ans;\n}\nvoid add(std::vector<std::pair<int,int> >tem){for(int i=0;i<tem.size();i++)if(tem[i].first!=tem[i].second)ans.push_back(tem[i]);}\nsigned main(){\n\tfor(int i=1;i<=4;i++)scanf(""%lld"",a+i);\n\tfor(int i=1;i<=4;i++)scanf(""%lld"",b+i);\n\tint _gcd=getgcd(a);\n\tif(!_gcd){\n\t\tif(getgcd(b)==0&&b[1]==a[1])puts(""0"");\n\t\telse puts(""-1"");\n\t\treturn 0;\n\t}\n\tint x=((a[1]%_gcd)+_gcd)%_gcd;\n\tif(_gcd!=getgcd(b)||(b[1]%_gcd+_gcd)%_gcd!=(a[1]%_gcd+_gcd)%_gcd){\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=4;i++)(a[i]-=x)/=_gcd,(b[i]-=x)/=_gcd;\n\tint cnt=0;\n\tfor(int i=1;i<=4;i++)cnt+=(a[i]&1)-(b[i]&1);\n\tif(cnt){\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=4;i++)\n\t\tif((a[i]+b[i])&1){\n\t\t\tfor(int j=i+1;j<=4;j++)\n\t\t\t\tif((b[j]&1)==(a[i]&1)){\n\t\t\t\t\tstd::swap(b[i],b[j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n//\tfor(int i=1;i<=4;i++)printf(""%d "",b[i]);putchar(\'\\n\');\n\tauto nowa=compress(a),nowb=compress(b);\n\tadd(nowa.ope);\n\tadd(move(nowa.p,nowb.p).ope);\n\tstd::reverse(nowb.ope.begin(),nowb.ope.end());\n\tfor(int i=0;i<nowb.ope.size();i++){\n\t\tnowb.ope[i].first=(nowb.ope[i].second<<1)-nowb.ope[i].first;\n\t}\n\tadd(nowb.ope);\n\tprintf(""%d\\n"",ans.size());\n\tfor(int i=0;i<ans.size();i++)printf(""%lld %lld\\n"",ans[i].first*_gcd+x,ans[i].second*_gcd+x);\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3500
Jamie is getting very busy with his school life He starts to forget the assignments that he has to do He decided to write the things down on a to do list He assigns a value for each of his assignment so he can decide which he needs to spend more time on After a few days Jamie finds out the list is too large that he can t even manage the list by himself As you are a good friend of Jamie help him write a program to support the following operations on the to do list Add assignment to the to do list if it is not present and set its to If assignment is already in the to do list its to Remove assignment from the to do list if it is present in it Output the number of assignments that are more important have a value than assignment so Jamie can decide a better schedule Output if is not in the to do list Undo all changes that have been made in the previous days not including the day of this operation At day the to do list is empty In each of the following days Jamie will do out of the four operations If the operation is a you should or poor Jamie cannot make appropriate decisions ,"['#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define foreach(i, x)  for(type(x) i=x.begin() ; i != x.end() ; i++)\n#define FOR(ii, aa, bb) for(int ii = aa ; ii <= bb ; ii++)\n#define ROF(ii, aa, bb) for(int ii = aa ; ii >= bb ; ii--)\n\n#define type(x) __typeof(x.begin())\n\n#define orta ((bas + son) >> 1)\n#define sag (k + k + 1)\n#define sol (k + k)\n\n#define pb push_back\n#define mp make_pair\n\n#define nd second\n#define st first\n\n#define endl \'\\n\'\n\ntypedef pair< int, int > pii;\n\ntypedef long long ll;\n\nconst int logN = 17;\nconst ll mod  = 10000000000000061LL;//1e16 + 61ll;\nconst int inf  = 1e9;\nconst int N = 1e5 + 5;\n\nint n, m, x, y, z;\nchar str[123], test[123];\n\nclass node{\n\tpublic:\n\tint sum;\n\tnode *left, *right;\n\tnode(){ sum = 0; left = right = NULL; }\t\t\n};\n\ntypedef node* pnode;\n\npnode ST[N], ST2[N], T[N], T2[N];\n\nvoid init(pnode &t,ll bas,ll son){\n\tif(!t) t = new node;\n\treturn ;\n\tif(bas == son){ t->sum = 0; return ; }\n\tinit(t->left,bas,orta); init(t->right,orta+1,son);\n\tt->sum = t->left->sum + t->right->sum;\n}\n\nint sum(pnode p) { if(!p) return 0; return p->sum; }\n\nvoid update(pnode &bef,pnode &cur,ll bas,ll son,ll x, ll y){\n\tif(bas > x || son < x) { cur = bef; return ;}\n\tif(!cur) { cur = new node; cur->sum = sum(bef); } if(bas == son){ cur->sum += y; return ; }\n\tif(!bef) { bef = new node; }\n\tif(bas <= x && x <= orta){ cur->right = bef->right; update(bef->left,cur->left,bas,orta,x, y); }\n\telse { cur->left = bef->left; update(bef->right,cur->right,orta+1,son,x, y); }\n\tcur->sum = sum(cur->left) + sum(cur->right);\n}\n\nint query(pnode t,ll bas,ll son,ll x, ll y){\n\tif(!t) return 0;\n\tif(bas > y || son < x) return 0;\n\tif(x <= bas && son <= y) return t->sum;\n\treturn query(t->left,bas,orta,x,y) + query(t->right,orta+1,son,x,y);\n}\n\nll get() {\n\tll m = 0, nn = strlen(str + 1);\n\tfor(int i = 1; i <= nn; i++)\n\t\tm = (m * 37LL + str[i] - \'a\' + 1) % mod;\n\treturn m + 1;\n}\n\nint main(){\n\n\tscanf(""%d"",&n);\n\n\tinit(ST[0],1ll,inf);\n\tinit(ST2[0],1ll, mod);\n\n\tFOR(i, 1, n) {\n\t\tscanf(""%s"", test + 1);\n\t\tif(test[1] == \'s\') {\n\t\t\tscanf(""%s"", str + 1);\n\t\t\tll t = get();\n\t\t\tscanf(""%d"", &x);\n\t\t\tll k = query(ST2[i - 1], 1, mod, t, t);\n\t\t\tif(k) {\n\t\t\t\tupdate(ST[i - 1], T[i], 1, inf, k, -1);\n\t\t\t\tupdate(T[i], ST[i], 1, inf, x, +1);\n\t\t\t\tupdate(ST2[i - 1], T2[i], 1, mod, t, -k);\n\t\t\t\tupdate(T2[i], ST2[i], 1, mod, t, +x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tupdate(ST[i - 1], ST[i], 1, inf, x, 1);\n\t\t\t\tupdate(ST2[i - 1], ST2[i], 1, mod, t, x);\n\t\t\t}\n\t\t}\n\t\tif(test[1] == \'r\') {\n\t\t\tscanf(""%s"", str + 1);\n\t\t\tll t = get();\n\t\t\tll k = query(ST2[i - 1], 1ll, mod, t, t);\n\t\t\tupdate(ST[i - 1], ST[i], 1ll, inf, k, -1);\n\t\t\tupdate(ST2[i - 1], ST2[i], 1ll, mod, t, -k);\n\t\t}\n\t\tif(test[1] == \'q\') {\n\t\t\tscanf(""%s"", str + 1);\n\t\t\tll t = get();\n\t\t\tST[i] = ST[i - 1];\n\t\t\tST2[i] = ST2[i - 1];\n\t\t\tint t1 = query(ST2[i], 1, mod, t, t);\n\t\t\tif(t1 == 0) printf(""%d\\n"", -1);\n\t\t\telse printf(""%d\\n"", query(ST[i], 1ll, (ll) inf, 1, t1 - 1));\n\t\t\tcout << flush;\n\t\t}\n\t\tif(test[1] == \'u\') {\n\t\t\tscanf(""%d"", &x);\n\t\t\tST[i] = ST[i - x - 1];\n\t\t\tST2[i] = ST2[i - x - 1];\n\t\t}\n\t}\n\n   \treturn 0;\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Alice and Bob play a game Alice has got n treasure chests the i th of which contains a i coins and m keys the j th of which she can sell Bob for b j coins Firstly Alice puts some locks on the chests There are m types of locks the locks of the j th type can only be opened with the j th key To put a lock of type j on the i th chest Alice has to pay c i j dollars Alice can put any number of different types of locks on each chest possibly zero Then Bob buys some of the keys from Alice possibly none possibly all of them and opens each chest he can he can open a chest if he has the keys for all of the locks on this chest Bob s profit is the difference between the total number of coins in the opened chests and the total number of coins he spends buying keys from Alice If Bob s profit is greater than zero he wins the game Otherwise Alice wins the game Alice wants to put some locks on some chests so no matter which keys Bob buys she always wins Bob cannot get positive profit Of course she wants to spend the minimum possible number of dollars on buying the locks Help her to determine whether she can win the game at all and if she can how many dollars she has to spend on the locks ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nconst int INF = int(1e9) + 5;\nconst int COINS = 4;\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, M;\n    cin >> N >> M;\n    vector<int> A(N), B(M);\n\n    for (auto &a : A)\n        cin >> a;\n\n    for (auto &b : B)\n        cin >> b;\n\n    int a_total = accumulate(A.begin(), A.end(), 0);\n    int b_total = accumulate(B.begin(), B.end(), 0);\n\n    if (a_total > b_total) {\n        cout << -1 << \'\\n\';\n        return 0;\n    }\n\n    vector<vector<int>> C(N, vector<int>(M));\n\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            cin >> C[i][j];\n\n    vector<int> PC(M + 1, 1);\n\n    for (int i = 0; i < M; i++)\n        PC[i + 1] = (COINS + 1) * PC[i];\n\n    auto encode = [&](const vector<int> &remain) -> int {\n        assert(int(remain.size()) == M);\n        int encoded = 0;\n\n        for (int i = 0; i < M; i++)\n            encoded += remain[i] * PC[i];\n\n        return encoded;\n    };\n\n    auto get = [&](int encoded, int index) -> int {\n        return encoded / PC[index] % (COINS + 1);\n    };\n\n    auto reduce = [&](int encoded, int index, int subtract) -> int {\n        assert(subtract <= get(encoded, index));\n        return encoded - subtract * PC[index];\n    };\n\n    int states = PC[M];\n    vector<int> dp(states, INF);\n    dp[encode(B)] = 0;\n\n    for (int i = 0; i < N; i++) {\n        vector<int> ndp(states, INF);\n\n        auto recurse = y_combinator([&](auto self, int encoded, int key, int cost, int still) -> void {\n            if (key >= M) {\n                if (still == 0)\n                    ndp[encoded] = min(ndp[encoded], cost);\n\n                return;\n            }\n\n            self(encoded, key + 1, cost, still);\n            cost += C[i][key];\n\n            for (int take = 1; take <= min(get(encoded, key), still); take++)\n                self(reduce(encoded, key, take), key + 1, cost, still - take);\n        });\n\n        for (int encoded = 0; encoded < states; encoded++)\n            if (dp[encoded] < INF)\n                recurse(encoded, 0, dp[encoded], A[i]);\n\n        dp.swap(ndp);\n    }\n\n    cout << *min_element(dp.begin(), dp.end()) << \'\\n\';\n}\n']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",3200
You are given an integer n Check if n has an divisor greater than one does there exist such a number x x 1 that n is divisible by x and x is odd For example if n 6 then there is x 3 If n 4 then such a number does not exist ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> using V = vector<T>;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, int SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, int SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef std::decay <decltype(MOD)>::type mod_t;\nstruct mi {\n    mod_t val;\n    explicit operator mod_t() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend std::istream& operator >> (std::istream& in, mi& a) { \n        long long x; std::cin >> x; a = mi(x); return in; }\n    friend std::ostream& operator << (std::ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }    \n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO("""");\n    int tt; re(tt);\n    while (tt--) {\n        ll n; re(n);\n        while (n%2 == 0) n /= 2;\n        if (n != 1) {\n            cout << ""YES\\n"";\n        } else {\n            cout << ""NO\\n"";\n        }\n    }\n    return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",900
A system of vessels with water is given Several pairs of vessels are connected by tubes with transfusion mechanisms One may transfer an integer amount of liters of water between two vessels connected by such tube tube works in both directions There might be multiple tubes between two vessels Total number of tubes equals Volume of each vessel equals liters Of course the amount of the water in any vessel cannot exceed liters in the process of transfusions Given the initial amounts of water in the vessels and the desired amounts find a sequence of transfusions that deals with the task Total number of transfusions must not exceed ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define FOR(v,p,k) for(int v=p;v<=k;++v)\n#define FORD(v,p,k) for(int v=p;v>=k;--v)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define VAR(v,i) __typeof(i) v=(i)\n#define FORE(i,c) for(__typeof(c.begin()) i=(c.begin());i!=(c).end();++i)\n#define PB push_back\n#define ST first\n#define ND second\n#define SZ(x) (int)(x).size()\n#define ALL(c) c.begin(),c.end()\n#define ZERO(x) memset(x,0,sizeof(x))\n\nint sk[305];\n\nLL sum_sk[305];\n\nbool is_path[305][305];\nint nx[305][305];\n\nint current[305];\nint desired[305];\n\nint n, volume, m;\n\nvector<int> x;\nvector<int> y;\nvector<int> d;\n\nvoid dom(int a, int b, int c) {\n    x.PB(a);\n    y.PB(b);\n    d.PB(c);\n    current[a] -= c;\n    current[b] += c;\n}\n\nvoid move(vector<int>& v, int l, int r, int val) {\n    if (l + 1 == r) {\n        dom(v[l], v[r], val);\n        return;\n    }\n    if (current[v[r - 1]] >= val) {\n        dom(v[r - 1], v[r], val);\n        move(v, l, r - 1, val);\n    } else {\n        dom(v[r - 1], v[r], current[v[r - 1]]);\n        move(v, l, r - 1, val);\n        dom(v[r - 1], v[r], val - desired[v[r - 1]]);\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n >> volume >> m;\n    for (int i = 1; i <= n; ++i) {\n        cin >> current[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        cin >> desired[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        is_path[i][i] = true;\n    }\n    memset(nx, -1, sizeof(nx));\n    for (int i = 1; i <= m; ++i) {\n        int x, y;\n        cin >> x >> y;\n        is_path[x][y] = true;\n        nx[x][y] = y;\n        is_path[y][x] = true;\n        nx[y][x] = x;\n    }\n    for (int k = 1; k <= n; ++k) {\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (!is_path[i][j] && is_path[i][k] && is_path[k][j]) {\n                    is_path[i][j] = true;\n                    nx[i][j] = nx[i][k];\n                }\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        sk[i] = 1;\n        while (!is_path[i][sk[i]]) {\n            ++sk[i];\n        }\n        sum_sk[sk[i]] += current[i] - desired[i];\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (sum_sk[i] != 0) {\n            cout << ""NO"" << endl;\n            return 0;\n        }\n    }\n    while (true) {\n        int l = 1;\n        while (l <= n && current[l] <= desired[l]) {\n            ++l;\n        }\n        if (l > n) {\n            break;\n        }\n        int r = 1;\n        while (!is_path[l][r] || current[r] >= desired[r]) {\n            ++r;\n        }\n        vector<int> path;\n        for (int c = l; c != -1; c = nx[c][r]) {\n            path.PB(c);\n        }\n        for (int i = (int) path.size() - 1; ; --i) {\n            if (current[path[i]] > desired[path[i]]) {\n                l = i;\n                break;\n            }\n        }\n        for (int i = l; ; ++i) {\n            if (current[path[i]] < desired[path[i]]) {\n                r = i;\n                break;\n            }\n        }\n        int transferred = min(current[path[l]] - desired[path[l]], desired[path[r]] - current[path[r]]);\n        move(path, l, r, transferred);\n    }\n    cout << x.size() << endl;\n    for (int i = 0; i < (int) x.size(); ++i) {\n        cout << x[i] << "" "" << y[i] << "" "" << d[i] << ""\\n"";\n    }\n}\n']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2500
Paul is at the orchestra The string section is arranged in an rectangular grid and is filled with violinists with the exception of violists Paul really likes violas so he would like to take a picture including at least of them Paul can take a picture of any axis parallel rectangle in the orchestra Count the number of possible pictures that Paul can take Two pictures are considered to be different if the coordinates of corresponding rectangles are different ,"['#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#define REP(i,n) for (int i=1;i<=(n);++i)\n#define FOR(i,a,b) for (int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for (int i=(a);i>=(b);--i)\n#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)\nusing namespace std;\ntypedef long long LL;\n\nconst int N = 3005;\nconst int K = 12;\n\nint n, m, k, bl[N][K], br[N][K], cl[K], cr[K], tl[K], tr[K];\nLL ans;\n\n\nchar a[2][N][N];\nint s[2][N][N];\n\ninline void work(int u, int d, int l, int r, int id){\n    if (s[id][d][r] - s[id][u - 1][r] - s[id][d][l - 1] + s[id][u - 1][l - 1] == 0) {\n        ans += (d - u + 2) * (d - u + 1) * 1ll * (r - l + 2) * (r - l + 1) / 4;\n        return;\n    }\n    if (d-u > r-l) {\n        swap(u, l);\n        swap(d, r);\n        id ^= 1;\n    }\n\n    int m(l+r>>1);\n    FOR(i,u,d){\n        int t(0);\n        bl[i][0] = m;\n        char * T = a[id][i];\n        ROF(j,m,l){\n            if (T[j]) bl[i][++t] = j;\n            if (t == k+1) break;\n        }\n        while (t < k+1) bl[i][++t] = l-1;\n        t = 0;\n        br[i][0] = m;\n\n        FOR(j,m+1,r){\n            if (T[j]) br[i][++t] = j;\n            if (t == k+1) break;\n        }\n        while (t < k+1) br[i][++t] = r+1;\n    }\n    FOR(i,u,d){\n        cl[0] = cr[0] = m;\n        REP(t,k+1) cl[t] = l-1, cr[t] = r+1;\n        FOR(j,i,d){\n            FOR(t,0,k+1) tl[t] = cl[t], tr[t] = cr[t];\n            int p(1), q(1);\n            REP(t,k+1)\n                if (tl[p] > bl[j][q]) cl[t] = tl[p++]; else cl[t] = bl[j][q++];\n            p = 1, q = 1;\n            REP(t,k+1)\n                if (tr[p] < br[j][q]) cr[t] = tr[p++]; else cr[t] = br[j][q++];\n            FOR(t,0,k) ans += (cl[t]-cl[t+1])*(cr[k-t+1]-cr[0]);\n        }\n\n    }\n    if (l < m) work(u, d, l, m-1, id);\n    if (m < r) work(u, d, m+1, r, id);\n}\n\n\nint main(){\n    int u;\n    scanf(""%d%d%d%d"", &n, &m, &u, &k);\n\n    for (int i = 0; i < u; ++i) {\n        int x, y;\n        scanf(""%d%d"", &x, &y);\n        a[0][x][y] = 1;\n        a[1][y][x] = 1;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            a[1][j][i] = a[0][i][j];\n        }\n    }\n    for (int t = 0; t < 2; ++t) {\n        for (int i = 1; i < N; ++i) {\n            for (int j = 1; j < N; ++j) {\n                s[t][i][j] = a[t][i][j] + s[t][i - 1][j] + s[t][i][j - 1] - s[t][i - 1][j - 1];\n            }\n        }\n    }\n    --k;\n    work(1, n, 1, m, 0);\n    long long ans2 = ans;\n    cout << 1ll * (n + 1) * n / 2 * (m + 1) * m / 2 - ans2 << ""\\n"";\n    return 0;\n}']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",3000
You are given an array a consisting of n integers In one move you can choose some index i 1 le i le n 2 and shift the segment a i a i 1 a i 2 cyclically to the right i e replace the segment a i a i 1 a i 2 with a i 2 a i a i 1 Your task is to sort the initial array by or say that it is impossible to do that You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << "" is "" << x << endl\n// #define endl \'\\n\'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7, N = 505;\n\nvi ans;\nint a[N], b[N];\n\nvoid go(int i) {\n\tans.PB(i);\n\tint t = a[i];\n\ta[i] = a[i + 2];\n\ta[i + 2] = a[i + 1];\n\ta[i + 1] = t;\n}\n\nvoid solve() {\n\tans.clear();\n\tint n;\n\tcin >> n;\n\tunordered_set<int> s;\n\tfor(int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t\ts.insert(a[i]);\n\t}\n\tfor(int i = n - 1; i >= 2; i--) {\n\t\tint pos = max_element(a, a + i + 1) - a;\n\t\tif(pos == 0) {\n\t\t\tgo(pos);\n\t\t\tpos++;\n\t\t}\n\t\twhile(pos != i) {\n\t\t\tgo(pos - 1);\n\t\t\tpos++;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) b[i] = a[i];\n\tif(a[0] > a[1]) {\n\t\tif(s.size() == n) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\tif(a[i] <= a[i + 1]) continue;\n\t\t\tif(i + 1 == n - 1) break;\n\t\t\tif(a[i + 2] == a[i]) {\n\t\t\t\tgo(i), go(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgo(i + 1);\n\t\t\tgo(i);\n\t\t}\n\t}\n\tfor(int i = 0; i < n - 1; i++) {\n\t\tassert(a[i] <= a[i + 1]);\n\t}\n\tcout << ans.size() << endl;\n\tfor(int i:ans) cout << i + 1 << "" "";\n\tcout << endl;\n}\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tsolve();\n\t}\t\n\t\n}\n\n\n\n']","[0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
Ashish has an array a of size n A subsequence of a is defined as a sequence that can be obtained from a by deleting some elements possibly none without changing the order of the remaining elements Consider a subsequence s of a He defines the cost of s as the minimum between The maximum among all elements at odd indices of s The maximum among all elements at even indices of s Note that the index of an element is its index in s rather than its index in a The positions are numbered from 1 So the cost of s is equal to min max s 1 s 3 s 5 ldots max s 2 s 4 s 6 ldots For example the cost of 7 5 6 is min max 7 6 max 5 min 7 5 5 Help him find the minimum cost of a subsequence of size k ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint const maxn = 2e5 + 5;\nint a[maxn], good[maxn], pref[maxn], suff[maxn];\npair < int, int > b[maxn];\n\ninline int oks(int n, int k, int x) {\n    for (int i = 1; i <= n; ++i) good[i] = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (b[i].first <= x) good[b[i].second] = 1;\n    }\n    for (int i = 1; i <= n; ++i) {\n        pref[i] = pref[i - 1];\n        if (good[i]) {\n            pref[i] = max(pref[i], 1);\n            if (i >= 2) pref[i] = max(pref[i], pref[i - 2] + 2);\n        }\n    }\n    for (int i = n; i >= 1; --i) {\n        suff[i] = suff[i + 1];\n        if (good[i]) {\n            suff[i] = max(suff[i], 1);\n            if (i + 1 <= n) suff[i] = max(suff[i], suff[i + 2] + 2);\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        if (a[i] >= x) {\n            if (pref[i - 1] + 1 + suff[i + 1] >= k) return 1;\n        }\n    }\n    return 0;\n}\n\nmain() {\n    //freopen(""input.txt"", ""r"", stdin);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= n; ++i) b[i] = {a[i], i};\n    sort(b + 1, b + n + 1);\n    set < int > Q;\n    for (int i = 1; i <= n; ++i) Q.insert(a[i]);\n    vector < int > t;\n    for (auto key : Q) t.push_back(key);\n    int lef = -1, righ = (int)t.size();\n    while (righ - lef > 1) {\n        int mid = (righ + lef) / 2;\n        if (oks(n, k, t[mid])) righ = mid;\n        else lef = mid;\n    }\n    cout << t[righ];\n    return 0;\n}\n\n\n']","[1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2000
After you had helped Fedor to find friends in the Call of Soldiers 3 game he stopped studying completely Today the English teacher told him to prepare an essay Fedor didn t want to prepare the essay so he asked Alex for help Alex came to help and wrote the essay for Fedor But Fedor didn t like the essay at all Now Fedor is going to change the essay using the synonym dictionary of the English language Fedor does not want to change the meaning of the essay So the only change he would do change a word from essay to one of its synonyms basing on a replacement rule from the dictionary Fedor may perform this operation any number of times As a result Fedor wants to get an essay which contains as little letters the case doesn t matter as possible If there are multiple essays with minimum number of s he wants to get the one with minimum length length of essay is the sum of the lengths of all the words in it Help Fedor get the required essay Please note that in this problem For example if the synonym dictionary says that word can be replaced with word then it is allowed to replace the word with the word ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nstruct node {\n\tnode *next;\n\tint where;\n} *first[200001], a[200001];\n\nmap<string, int> events;\n\nint c[200001], w[200001][2], in[200001], total, n, m, l, A[200001][2],\n\t\tv[200001][2], dfn[200001], low[200001], pos[200001], len, cnt, num,\n\t\tcolor[200001];\nstring str[100001];\n\ninline void makelist(int x, int y) {\n\ta[++l].where = y;\n\ta[l].next = first[x];\n\tfirst[x] = &a[l];\n}\n\ninline void tarjan(int now) {\n\tdfn[now] = low[now] = ++cnt;\n\tc[++len] = now;\n\tpos[now] = len;\n\tfor (node *x = first[now]; x; x = x->next)\n\t\tif (!dfn[x->where])\n\t\t\ttarjan(x->where), low[now] = min(low[now], low[x->where]);\n\t\telse if (!color[x->where])\n\t\t\tlow[now] = min(low[now], dfn[x->where]);\n\tif (low[now] == dfn[now]) {\n\t\t++num;\n\t\tfor (int i = pos[now]; i <= len; i++)\n\t\t\tcolor[c[i]] = num;\n\t\tlen = pos[now] - 1;\n\t}\n}\n\nint calc(string str) {\n\tint len = str.size();\n\tfor (int i = 0; i < len; i++)\n\t\tif (str[i] >= \'A\' && str[i] <= \'Z\')\n\t\t\tstr[i] = str[i] - \'A\' + \'a\';\n\tif (events.find(str) != events.end())\n\t\treturn events[str];\n\tevents[str] = ++total;\n\tA[total][0] = 0;\n\tA[total][1] = len;\n\tfor (int i = 0; i < len; i++)\n\t\tif (str[i] == \'r\')\n\t\t\t++A[total][0];\n\treturn total;\n}\n\nint main() {\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> str[i];\n\tscanf(""%d"", &m);\n\tmemset(first, 0, sizeof(first));\n\tl = 0;\n\tevents.clear();\n\ttotal = 0;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tint x = calc(str);\n\t\tcin >> str;\n\t\tint y = calc(str);\n\t\tmakelist(x, y);\n\t\tw[i][0] = x;\n\t\tw[i][1] = y;\n\t}\n\tmemset(color, 0, sizeof(color));\n\tmemset(dfn, 0, sizeof(dfn));\n\tmemset(low, 0, sizeof(low));\n\tcnt = len = num = 0;\n\tfor (int i = 1; i <= total; i++)\n\t\tif (!dfn[i])\n\t\t\ttarjan(i);\n\tfor (int i = 1; i <= num; i++)\n\t\tv[i][0] = v[i][1] = 1 << 30;\n\tfor (int i = 1; i <= total; i++) {\n\t\tint j = color[i];\n\t\tif (A[i][0] < v[j][0] || (A[i][0] == v[j][0] && A[i][1] < v[j][1]))\n\t\t\tv[j][0] = A[i][0], v[j][1] = A[i][1];\n\t}\n\tmemset(first, 0, sizeof(first));\n\tl = 0;\n\tmemset(in, 0, sizeof(in));\n\tfor (int i = 1; i <= m; i++)\n\t\tif (color[w[i][0]] != color[w[i][1]])\n\t\t\tmakelist(color[w[i][0]], color[w[i][1]]), ++in[color[w[i][1]]];\n\tint k = 0;\n\tfor (int i = 1; i <= num; i++)\n\t\tif (!in[i])\n\t\t\tc[++k] = i;\n\tfor (int l = 1; l <= k; l++) {\n\t\tint m = c[l];\n\t\tfor (node *x = first[m]; x; x = x->next)\n\t\t\tif (!--in[x->where])\n\t\t\t\tc[++k] = x->where;\n\t}\n\tfor (int i = num; i; i--) {\n\t\tint m = c[i];\n\t\tfor (node *x = first[m]; x; x = x->next) {\n\t\t\tint j = x->where;\n\t\t\tif (v[j][0] < v[m][0] || (v[j][0] == v[m][0] && v[j][1] < v[m][1]))\n\t\t\t\tv[m][0] = v[j][0], v[m][1] = v[j][1];\n\t\t}\n\t}\n\tlong long ans1 = 0, ans2 = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint Q = str[i].size();\n\t\tfor (int j = 0; j < Q; j++)\n\t\t\tif (str[i][j] >= \'A\' && str[i][j] <= \'Z\')\n\t\t\t\tstr[i][j] = str[i][j] - \'A\' + \'a\';\n\t\tif (events.find(str[i]) == events.end()) {\n\t\t\tans2 += Q;\n\t\t\tfor (int j = 0; j < Q; j++)\n\t\t\t\tif (str[i][j] == \'r\')\n\t\t\t\t\t++ans1;\n\t\t} else {\n\t\t\tint j = color[events[str[i]]];\n\t\t\tans1 += v[j][0];\n\t\t\tans2 += v[j][1];\n\t\t}\n\t}\n\tcout << ans1 << "" "" << ans2 << endl;\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2400
You are given a permutation of length Remove one element from permutation to make the number of records the maximum possible We remind that in a sequence of numbers the element is a if for every integer the following holds ,"['#include<bits/stdc++.h>\n#define maxn 100200\n\nusing namespace std;\n\nint a[maxn],x[maxn],y[maxn],n,k,cnt[maxn];\n\nint main()\n{\n    scanf(""%d"",&n);for (int i=1;i<=n;i++) scanf(""%d"",&a[i]);\n    memset(x,0,sizeof(x));memset(y,0,sizeof(y));\n    for (int i=1;i<=n;i++)\n    {\n        x[i]=x[i-1];y[i]=y[i-1];\n        if (a[i]>x[i]) y[i]=x[i],x[i]=a[i];\n        else if (a[i]>y[i]) y[i]=a[i];\n    }\n    memset(cnt,0,sizeof(cnt));\n    for (int i=1;i<=n;i++) if (y[i]==a[i]) cnt[x[i]]++;\n    for (int i=1;i<=n;i++) if (x[i]==a[i]) cnt[a[i]]--;\n    k=1;for (int i=2;i<=n;i++) if (cnt[i]>cnt[k]) k=i;\n    printf(""%d\\n"",k);return 0;\n}\n']","[0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
The world is a grid with n rows and m columns The rows are numbered 0 1 ldots n 1 while the columns are numbered 0 1 ldots m 1 In this world the columns are i e the top and the bottom cells in each column are adjacent The cell on the i th row and the j th column 0 le i n 0 le j m is denoted as i j the cell i j where 0 le i n 0 le j m contains either a or The state of cell i j can be described using the integer a i j If a i j 1 there is a rock at i j If a i j 0 there is nothing at i j As a result of aftershocks from the earthquake the columns follow tectonic plate movements each column moves cyclically at a velocity of 1 cell per unit of time Formally for some 0 le i n 0 le j m if i j contains a rock at the moment it will move from i j to i 1 j or to n 1 j if i 0 The robot called RT is initially positioned at 0 0 It has to go to n 1 m 1 to carry out an earthquake rescue operation to the bottom rightmost cell The earthquake doesn t change the position of the robot they only change the position of rocks in the world Let RT s current position be x y 0 le x n 0 le y m it can perform the following operations Go one cell cyclically upwards i e from x y to x n 1 bmod n y using 1 unit of time Go one cell cyclically downwards i e x y to x 1 bmod n y using 1 unit of time Go one cell to the right i e x y to x y 1 using 1 unit of time RT may perform this operation only if y m 1 Unfortunately RT will explode upon colliding with a rock As such when RT is at x y and there is a rock at x 1 bmod n y or x 2 bmod n y RT cannot move down or it will be hit by the rock Similarly if y 1 m and there is a rock at x 1 bmod n y 1 RT cannot move right or it will be hit by the rock However it is worth noting that if there is a rock at x bmod n y 1 and x 1 bmod n y RT can still move right safely Find the minimum amount of time RT needs to reach n 1 m 1 without colliding with any rocks If it is impossible to do so output 1 ,"['/// My implementation sucks\n#include <bits/stdc++.h>\n#define ll long long\n#define f first\n#define s second\n#define ii pair<int,int>\n#define sz(x) (int) (x).size()\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntemplate<class T1,class T2> bool maximize(T1 &a,T2 b) {return(a<b ? a=b,1:0);};\ntemplate<class T1,class T2> bool minimize(T1 &a,T2 b) {return(a>b ? a=b,1:0);};\n\nconst int N=1e3+10;\nint n,m;\nint a[N][N],dp[N][N];\nvoid leeminhduc2()\n{\n    cin >> n >> m;\n    for (int i=0;i<n;i++)\n        for (int j=0;j<m;j++)\n            {\n                cin >> a[i][j];\n                dp[i][j]=-1;\n            }\n    dp[0][0]=0ll;\n    queue<ii> q;\n    q.push({0,0});\n    while (sz(q))\n    {\n        \n        auto [u,v]=q.front(); q.pop();\n        \n        if (dp[(u+2)%n][v]==-1&&a[(u+1)%n][v]==0&&a[(u+2)%n][v]==0)\n        {\n            dp[(u+2)%n][v]=dp[u][v]+1;\n            q.push({(u+2)%n,v});\n        }\n        if (v<m-1&&dp[(u+1)%n][(v+1)]==-1&&a[(u+1)%n][(v+1)]==0)\n        {\n            dp[(u+1)%n][(v+1)]=dp[u][v]+1;\n            q.push({(u+1)%n,(v+1)});\n        }\n    }\n    \n     \n    int res=1e9;\n    for (int i=0;i<n;i++) if (dp[i][m-1]!=-1)\n    {\n        int cur=(i-dp[i][m-1]%n+n)%n;\n       \n        if (cur==n-1) res=min(res,dp[i][m-1]);\n        else res=min(res,dp[i][m-1]+cur+1);\n    }\n    if (res==1e9) cout << ""-1\\n"";\n    else cout << res << ""\\n"";\n}\nsigned main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    int tc=1;\n    cin >> tc;\n    while (tc--)\n    leeminhduc2();\n}\n\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2100
Little Susie loves strings Today she calculates distances between them As Susie is a small girl after all her strings contain only digits zero and one She uses the definition of Hamming distance We will define the distance between two strings and of the same length consisting of digits zero and one as the number of positions such that isn t equal to As besides everything else Susie loves symmetry she wants to find for two strings and of length such string of length that the distance from to was equal to the distance from to It s time for Susie to go to bed help her find such string or state that it is impossible ,"['//In the name of God\n#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    string S,P;\n    cin >> S >> P;\n    int n = S.size();\n    int dis = 0;\n    for(int i = 0; i < n;i++) if(S[i] != P[i]) dis++;\n    if(dis % 2){\n        cout << ""impossible\\n"";\n        return 0;\n    }\n    int c = 0;\n    string ans = """";\n    for(int i = 0; i < n;i++){\n        if(S[i] == P[i]){\n            ans += S[i];\n            continue;\n        }\n        if(c % 2) ans += S[i];\n        else ans += P[i];\n        c++;\n    }\n    cout << ans << endl;\n    return 0;\n    \n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
You are given a tree consisting of n vertices numbered from 1 to n Every vertex is colored in some color denoted by an integer from 1 to n A simple path of the tree is called if it consists of at least 2 vertices the first and the last vertices of the path have the same color no other vertex on the path has the same color as the first vertex Count the number of the simple paths of the tree Note that paths are considered undirected i e the path from x to y is the same as the path from y to x ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> c[i];\n        c[i]--;\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    std::vector<std::map<int, int>> mp(n);\n    i64 ans = 0;\n    auto dfs = [&](auto self, int x, int p) -> void {\n        for (auto y : adj[x]) {\n            if (y == p) {\n                continue;\n            }\n            self(self, y, x);\n            if (mp[y].count(c[x])) {\n                ans += mp[y][c[x]];\n                mp[y].erase(c[x]);\n            }\n            if (mp[x].size() < mp[y].size()) {\n                std::swap(mp[x], mp[y]);\n            }\n            for (auto [a, b] : mp[y]) {\n                ans += 1LL * b * mp[x][a];\n                mp[x][a] += b;\n            }\n            mp[y].clear();\n        }\n        mp[x][c[x]] += 1;\n    };\n    dfs(dfs, 0, -1);\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0]",2000
Polycarp invited all his friends to the tea party to celebrate the holiday He has cups one for each of his friends with volumes His teapot stores milliliters of tea Polycarp wants to pour tea in cups in such a way that Every cup will contain tea for at least half of its volume Every cup will contain integer number of milliliters of tea All the tea from the teapot will be poured into cups All friends will be Friend with cup won t be if there exists such cup that cup contains less tea than cup but For each cup output how many milliliters of tea should be poured in it If it s impossible to pour all the tea and satisfy all conditions then output ,"['#include<cstdio>\n#include<algorithm>\nint n,w,a[107],b[107];\nint main(){\n\tscanf(""%d%d"",&n,&w);\n\tfor(int i=1;i<=n;++i)scanf(""%d"",a+i),w-=b[i]=a[i]+1>>1;\n\tif(w<0)return puts(""-1""),0;\n\twhile(w){\n\t\tint mw=0;\n\t\tfor(int i=1;i<=n;++i)if((!mw||a[i]>=a[mw])&&a[i]>b[i])mw=i;\n\t\tint x=std::min(a[mw]-b[mw],w);\n\t\tb[mw]+=x;\n\t\tw-=x;\n\t}\n\tfor(int i=1;i<=n;++i)printf(""%d "",b[i]);\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Slava plays his favorite game Peace Lightning Now he is flying a bomber on a very specific map Formally map is a checkered field of size the cells of which are numbered from to in each cell there can be one or several tanks Slava doesn t know the number of tanks and their positions because he flies very high but he can drop a bomb in any cell All tanks in this cell will be damaged If a tank takes damage for the first time it instantly moves to one of the neighboring cells a tank in the cell can only move to the cell a tank in the cell can only move to the cell If a tank takes damage for the second time it s counted as destroyed and never moves again The tanks move only when they are damaged for the first time they do not move by themselves Help Slava to destroy all tanks using as few bombs as possible ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\n#include<map>\n#include<queue>\nusing namespace std;\ntypedef long long  LL;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define F first\n#define S second\ninline int read(){\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = getchar())\tif (ch == \'-\')\tpositive = 0;\n\tfor (; isdigit(ch); ch = getchar())\tx = x * 10 + ch - \'0\';\n\treturn positive ? x : -x;\n}\ninline void write(int a){\n    if(a>=10)write(a/10);\n    putchar(\'0\'+a%10);\n}\ninline void writeln(int a){\n    if(a<0){\n    \ta=-a; putchar(\'-\');\n\t}\n\twrite(a); puts("""");\n}\n#include<string>\nint n;\nint main(){\n\tcin>>n;\n\twriteln(n+n/2);\n\tfor(int i=2;i<=n;i+=2){\n\t\twrite(i); putchar(\' \');\n\t}\n\tfor(int i=1;i<=n;i+=2){\n\t\twrite(i); putchar(\' \');\n\t}\n\tfor(int i=2;i<=n;i+=2){\n\t\twrite(i); putchar(\' \');\n\t}\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
You are given an array a consisting of n distinct integers a 1 a 2 ldots a n Define the of an array p 1 p 2 ldots p k as the minimum amount of time needed to sort this array using an arbitrary number of operations In each range sort operation you will do the following Choose two integers l and r 1 le l r le k Sort the subarray p l p l 1 ldots p r in r l seconds Please calculate the sum of beauty over all subarrays of array a A subarray of an array is defined as a sequence of consecutive elements of the array ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = int64_t;\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor(int& x : A) cin >> x;\n\tll ans = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tvector<pair<int,int> > cur = {};\n\t\tfor(int j = i; j < N; j++){\n\t\t\tpair<int, int> v = {A[j], A[j]};\n\t\t\twhile(!cur.empty() && cur.back().second >= v.first){\n\t\t\t\tv.first = min(v.first, cur.back().first);\n\t\t\t\tv.second = max(v.second, cur.back().second);\n\t\t\t\tcur.pop_back();\n\t\t\t}\n\t\t\tcur.push_back(v);\n\t\t\tans += (j-i+1) - (int)cur.size();\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","[1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0]",2000
Polycarp owns a shop in the capital of Berland Recently the criminal activity in the capital increased so Polycarp is thinking about establishing some better security in the storehouse of his shop The storehouse can be represented as a matrix with rows and columns Each element of the matrix is either an empty space or a wall Polycarp wants to hire some guards possibly zero to watch for the storehouse Each guard will be in some cell of matrix and will protect every cell to the right of his own cell and every cell to the bottom of his own cell until the nearest wall More formally if the guard is standing in the cell then he protects cell if all these conditions are met is an empty cell either and or and there are no walls between cells and Guards can be placed only in empty cells and can protect only empty cells The of placing the guards is some set of cells where guards will be placed of course two plans are different if there exists at least one cell that is included in the first plan but not included in the second plan or vice versa Polycarp calls a plan if there is empty cell that is not protected Polycarp wants to know the number of suitable plans Since it can be very large you have to output it modulo ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int Mod=1000000007;\ninline void add(int &x,int y)\n{\n    x+=y;\n    x=(x>=Mod ? x-Mod : x);\n}\nchar s[255][255],t[255][255];\nint dp[2][(1<<15)+5][2][2];\nint main()\n{\n    int n,m;\n    scanf(""%d%d"",&n,&m);\n    for(int i=0;i<n;i++)\n        scanf(""%s"",s[i]);\n    if(n<m)\n    {\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n                t[j][i]=s[i][j];\n        memcpy(s,t,sizeof(t));\n        swap(n,m);\n    }\n    int now=0,la=1;\n    dp[now][0][0][0]=1;\n    for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n        {\n            swap(now,la);\n            memset(dp[now],0,(1<<m)*sizeof(dp[now][0]));\n            for(int mask=0;mask<(1<<m);mask++)\n                for(int k=0;k<2;k++)\n                    for(int l=0;l<2;l++)\n                    {\n                        if(s[i][j]==\'x\')\n                            add(dp[now][mask&(~0^(1<<j))][0][l],dp[la][mask][k][l]);\n                        else\n                        {\n                            int gg=(~mask>>j&1) && (k==0 || j==0);\n                            if(gg+l<2)add(dp[now][mask][k&(j>0)][gg+l],dp[la][mask][k][l]);\n                            add(dp[now][mask|(1<<j)][1][l],dp[la][mask][k][l]);\n                        }\n                    }\n        }\n    int res=0;\n    for(int mask=0;mask<(1<<m);mask++)\n        for(int k=0;k<2;k++)\n            for(int l=0;l<2;l++)\n                add(res,dp[now][mask][k][l]);\n    return 0*printf(""%d\\n"",res);\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2500
The biggest event of the year Cota 2 world championship The Innernational is right around the corner 2 n teams will compete in a double elimination format please carefully read problem statement even if you know what is it to identify the champion Teams are numbered from 1 to 2 n and will play games one on one All teams start in the upper bracket All upper bracket matches will be held played between teams that haven t lost any games yet Teams are split into games by team numbers Game winner advances in the next round of upper bracket losers drop into the lower bracket Lower bracket starts with 2 n 1 teams that lost the first upper bracket game Each lower bracket round consists of two games In the first game of a round 2 k teams play a game with each other teams are split into games by team numbers 2 k 1 loosing teams are eliminated from the championship 2 k 1 winning teams are playing 2 k 1 teams that got eliminated in this round of upper bracket again teams are split into games by team numbers As a result of each round both upper and lower bracket have 2 k 1 teams remaining See example notes for better understanding Single remaining team of upper bracket plays with single remaining team of lower bracket in grand finals to identify championship winner You are a fan of teams with numbers a 1 a 2 a k You want the championship to have as many games with your favourite teams as possible Luckily you can affect results of every championship game the way you want What s maximal possible number of championship games that include teams you re fan of ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vector<bool> a(1 << n);\n  while (m--) {\n    int x;\n    cin >> x;\n    a[--x] = true;\n  }\n  vector<vector<int>> dp(1 << (n + 1), vector<int>(4, -1));\n  auto merge = [&](int x, int l, int r) {\n    for (int i = 0; i < 4; ++i) {\n      if (dp[l][i] == -1) {\n        continue;\n      }\n      for (int j = 0; j < 4; ++j) {\n        if (dp[r][j] == -1) {\n          continue;\n        }\n        int w1 = i / 2, w2 = j / 2;\n        int l1 = i % 2, l2 = j % 2;\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n        swap(w1, w2);\n        dp[x][w1 * 2 + max(w2, max(l1, l2))] = max(dp[x][w1 * 2 + max(w2, max(l1, l2))], dp[l][i] + dp[r][j] + max(w1, w2) + max(l1, l2) + max(w2, max(l1, l2)));\n      }\n    }\n  };\n  function<void(int, int, int)> solve = [&](int x, int l, int r) {\n    if (r - l == 2) {\n      if (!a[l] && !a[l + 1]) {\n        dp[x][0] = 0;\n      } else if (a[l] && a[l + 1]) {\n        dp[x][3] = 1;\n      } else {\n        dp[x][1] = dp[x][2] = 1;\n      }\n    } else {\n      int y = (l + r) >> 1, z = x + ((y - l) << 1);\n      solve(x + 1, l, y);\n      solve(z, y, r);\n      merge(x, x + 1, z);\n    }\n  };\n  solve(0, 0, 1 << n);\n  cout << max(dp[0][0], max(dp[0][1] + 1, max(dp[0][2] + 1, dp[0][3] + 1))) << ""\\n"";\n  return 0;\n}\n']","[0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
Wabbit is trying to move a box containing food for the rest of the zoo in the coordinate plane from the point x 1 y 1 to the point x 2 y 2 He has a rope which he can use to pull the box He can only pull the box if he stands 1 unit away from the box in the direction of one of two coordinate axes He will pull the box to where he is standing before moving out of the way in the same direction by 1 unit For example if the box is at the point 1 2 and Wabbit is standing at the point 2 2 he can pull the box right by 1 unit with the box ending up at the point 2 2 and Wabbit ending at the point 3 2 Also Wabbit can move 1 unit to the right left up or down without pulling the box In this case it is not necessary for him to be in exactly 1 unit away from the box If he wants to pull the box again he must return to a point next to the box Also Wabbit can t move to the point where the box is located Wabbit can start at any point It takes 1 second to travel 1 unit right left up or down regardless of whether he pulls the box while moving Determine the minimum amount of time he needs to move the box from x 1 y 1 to x 2 y 2 Note that the point where Wabbit ends up at does not matter ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nll a, b, c, d;\n\nvoid test()\n{\n\tscanf(""%lld%lld%lld%lld"", &a, &b, &c, &d);\n\tll wyn=abs(a-c)+abs(b-d)+(a!=c && b!=d)*2;\n\tprintf(""%lld\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are given two strings s and t and both consisting only of characters and Possible examples of strings s and t You have to find a string res consisting of 3n characters n characters should be n characters should be and n characters should be and s and t should not occur in res as substrings A substring of a string is a contiguous subsequence of that string So the strings and are substrings of the string but the strings and are not substrings of the string If there are multiple answers you can print any of them ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\n\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    string per = ""abc"";\n    int n;\n    cin >> n;\n    string a, b;\n    cin >> a >> b;\n    fr(p, 1, 6) {\n        next_permutation(all(per));\n        string lol = per + per;\n        bool pos = 1;\n        fr(i, 0, 2) {\n            if(lol.substr(i, 2) == a || lol.substr(i, 2) == b) pos = 0;\n        }\n        if(pos) {\n            cout << ""YES"" << endl;\n            fr(i, 1, n) {\n                cout << per;\n            }\n            return 0;\n        }\n    }\n    string c = b;\n    reverse(all(c));\n    if(a == c) {\n        cout << ""YES"" << endl;\n        fr(i, 1, n) {\n            cout << a[0];\n        }\n        fr(j, 0, 2) {\n            if((char)(\'a\' + j) == a[0] || (char)(\'a\' + j) == b[0]) continue;\n            fr(i, 1, n)\n                cout << (char)(\'a\' + j);\n            break;\n        }\n        fr(i, 1, n) {\n            cout << a[1];\n        }\n        return 0;\n    }\n    if(a[1] == b[1]) {\n        cout << ""YES"" << endl;\n        fr(i, 1, n) {\n            cout << a[1];\n        }\n        fr(j, 0, 2) {\n            if((char)(\'a\' + j) == a[1]) continue;\n            fr(i, 1, n)\n                cout << (char)(\'a\' + j);\n        }\n        return 0;\n    }\n    else if(a[0] == b[0]) {\n        cout << ""YES"" << endl;\n        fr(j, 0, 2) {\n            if((char)(\'a\' + j) == a[0]) continue;\n            fr(i, 1, n)\n                cout << (char)(\'a\' + j);\n        }\n        fr(i, 1, n) {\n            cout << a[0];\n        }\n        return 0;\n    }\n    cout << ""NO"";\n    return 0;\n}']","[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Oleg the bank client lives in Bankopolia There are cities in Bankopolia and some pair of cities are connected directly by bi directional roads The cities are numbered from to There are a total of roads in Bankopolia the th road connects cities and It is guaranteed that from each city it is possible to travel to any other city using some of the roads Oleg wants to give a label to each city Suppose the label of city is equal to Then it must hold that for all pairs of cities the condition holds if and only if there is a road connecting and Oleg wonders if such a labeling is possible Find an example of such labeling if the task is possible and state that it is impossible otherwise ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 300001;\nvector <int> e[MAXN];\npair <ll, int> a[MAXN];\nint g[MAXN];\nint sz[MAXN];\n\nll gethash(const vector<int>& x) {\n\tll cur = 0;\n\tfor (int u : x) {\n\t\tcur = (cur * ll(MAXN) + u);\n\t}\n\tcur = (cur * ll(MAXN) + x.size());\n\treturn cur;\n}\n\nvector<int> e2[MAXN];\nint x[MAXN];\n\nvoid no() {\n\tcout << ""NO"" << endl;\n\texit(0);\n}\n\nvoid ad(vector<int>& where, int x) {\n\tfor (int u : where)\n\t\tif (x == u) return;\n\tif (where.size() == 2) no();\n\twhere.push_back(x);\n}\n\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\te[i].push_back(i);\n\t\tsort(e[i].begin(), e[i].end());\n\t\ta[i] = make_pair(gethash(e[i]), i);\n\t}\n\tsort(a + 1, a + n + 1);\n\tint lc = 0, rc;\n\tint k = 0;\n\tfor (lc = 1; lc <= n; lc = rc) {\n\t\trc = lc;\n\t\twhile ((rc <= n) && (a[rc].first == a[lc].first)) rc++;\n\t\tfor (int j = lc; j < rc; j++)\n\t\t\tg[a[j].second] = k;\t\n\t\tsz[k] = rc - lc;\n\t\tk++;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint same = 0;\n\t\tfor (int u : e[i]) {\n\t\t\tif (g[i] != g[u])\n\t\t\t\tad(e2[g[i]], g[u]);\n\t\t\telse\n\t\t\t\tsame++;\n\t\t}\n\t\tif (same != sz[g[i]]) no();\n\t}\n\tint cx = 1;\n\tfor (int i = 0; i < k; i++) {\n\t\tif (x[i] != 0) continue;\n\t\tif (e2[i].size() == 0) {\n\t\t\tx[i] = cx + 2;\n\t\t\tcx += 5;\n\t\t\tcontinue;\n\t\t}\n\t\tif (e2[i].size() > 1) continue;\n\t\tcx += 2;\n\t\tx[i] = cx++;\n\t\tint nx = e2[i][0], pv = i;\n\t\twhile (e2[nx].size() != 1) {\n\t\t\tx[nx] = cx++;\n\t\t\tint nnx = e2[nx][0] + e2[nx][1] - pv;\n\t\t\tpv = nx;\n\t\t\tnx = nnx;\n\t\t}\n\t\tx[nx] = cx;\n\t\tcx += 2;\n\t}\n\n\tfor (int i = 0; i < k; i++)\n\t\tif (x[i] == 0) no();\n\n\tcout << ""YES\\n"";\n\tfor (int i = 1; i <= n; i++) {\n\t\tcout << x[g[i]] << "" "";\n\t}\n\tcout << ""\\n"";\n\n\treturn 0;\n}']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
Sasha decided to give his girlfriend the best handbag but unfortunately for Sasha it is very expensive Therefore Sasha wants to earn it After looking at earning tips on the internet he decided to go to the casino Sasha knows that the casino operates under the following rules If Sasha places a bet of y coins where y is a positive integer then in case of winning he will receive y cdot k coins i e his number of coins will increase by y cdot k 1 And in case of losing he will lose the entire bet amount i e his number of coins will decrease by y Note that the bet amount must always be a positive 0 integer and cannot exceed Sasha s current number of coins Sasha also knows that there is a promotion at the casino he cannot lose more than x times in a row Initially Sasha has a coins He wonders whether he can place bets such that he is guaranteed to win any number of coins In other words is it true that for any integer n Sasha can make bets so that for any outcome that does not contradict the rules described above at some moment of time he will have at least n coins ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nsigned main()\n{\n\tint t,k,x,a,ans=0;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tk=read();\n\t\tx=read();\n\t\ta=read();\n\t\tans=0;\n\t\tfor(int i=1;i<=x+1;i++)\n\t\t{\n\t\t\tint now=ans/(k-1)+1;\n\t\t\tans+=now;\n\t\t\tif(ans>a)break;\n\t\t}\n\t\t//printf(""orz%d\\n"",ans);\n\t\tif(ans<=a)printf(""YES\\n"");\n\t\telse printf(""NO\\n"");\n\t} \n}\n']","[1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
 Polycarp is a very famous freelancer His current rating is r units Some very rich customers asked him to complete some projects for their companies To complete the i th project Polycarp needs to have at least a i units of rating after he completes this project his rating will change by b i his rating will increase or decrease by b i b i can be positive or negative Polycarp s rating should not fall below zero because then people won t trust such a low rated freelancer Is it possible to complete all the projects Formally write a program to check if such an order of the projects exists that Polycarp has enough rating before starting each project and he has non negative rating after completing each project In other words you have to check that there exists such an order of projects in which Polycarp will complete them so he has enough rating before starting each project and has non negative rating after completing each project ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Project {\n\tint a, b;\n};\n\nvoid maximize(int &a, int b) {\n\tif (a < b) a = b;\n}\n\nint main() {\n\tint n, r;\n\tcin >> n >> r;\n\t\n\tvector<Project> pos, neg;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tif (b >= 0) {\n\t\t\tpos.push_back({a, b});\n\t\t} else {\n\t\t\tneg.push_back({a, -b});\n\t\t}\n\t}\n\n\tsort(begin(pos), end(pos), [](const Project &x, const Project &y) { return x.a < y.a; });\n\tint res = 0;\n\tfor (auto it : pos) {\n\t\tif (r >= it.a) {\n\t\t\tr += it.b;\n\t\t\t++res;\n\t\t}\n\t}\n\n\tsort(begin(neg), end(neg), [](const Project &x, const Project &y) { return x.a - x.b > y.a - y.b; });\n\tvector< vector<int> > dp(neg.size() + 1, vector<int>(r + 1, -1));\n\tdp[0][r] = 0;\n\tfor (int i = 0; i < neg.size(); ++i) {\n\t\tfor (int j = 0; j <= r; ++j) if (dp[i][j] >= 0) {\n\t\t\tif (j >= max(neg[i].a, neg[i].b)) {\n\t\t\t\tmaximize(dp[i + 1][j - neg[i].b], dp[i][j] + 1);\n\t\t\t}\n\t\t\tmaximize(dp[i + 1][j], dp[i][j]);\n\t\t}\n\t}\n\tres += *max_element(begin(dp[neg.size()]), end(dp[neg.size()]));\n\tcout << (res == n ? ""YES"" : ""NO"") << endl;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Archeologists have found a secret pass in the dungeon of one of the pyramids of Cycleland To enter the treasury they have to open an unusual lock on the door The lock consists of words each consisting of some hieroglyphs The wall near the lock has a round switch Each rotation of this switch changes the hieroglyphs according to some rules The instruction nearby says that the door will open only if words written on the lock would be sorted in the definition of lexicographical comparison in given in notes section The rule that changes hieroglyphs is the following One clockwise rotation of the round switch replaces each hieroglyph with the next hieroglyph in alphabet i e hieroglyph is replaced with hieroglyph and hieroglyph is replaced with hieroglyph Help archeologist determine how many clockwise rotations they should perform in order to open the door or determine that this is impossible i e no cyclic shift of the alphabet will make the sequence of words sorted lexicographically ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nconst double pi=acos(-1.0);\nconst double eps=1e-9;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define re return\n#define vi vector <int> \n#define pii pair <int,int>\n#define pll pair <long long , long long>\ntypedef long long ll;\n\nconst int N=(int)5e5+5;\nconst int C=(int)1e6+5;\n\nint n,c,l[N],a,b,t[C];\nvector <int> v[N];\nbool good[N];\n\nint main()\n{\n\tios:: sync_with_stdio(false);\n\tcin >> n >> c;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin >> l[i];\n\t\tfor(int j=0;j<l[i];j++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\ta--;\n\t\t\tv[i].pb(a);\n\t\t}\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(l[i+1]>=l[i])continue;\n\t\tbool ok=false;\n\t\tfor(int j=0;j<l[i+1];j++)\n\t\t\tif(v[i][j]!=v[i+1][j])\n\t\t\t{\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(!ok)\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//cout << ""Hi"";\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(l[i]>l[i+1])continue;\n\t\tbool ok=true;\n\t\tfor(int j=0;j<l[i];j++)\n\t\t\tif(v[i][j]!=v[i+1][j])\n\t\t\t{\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(ok)good[i]=true;\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(good[i])continue;\n\t\tfor(int j=0;j<min(l[i],l[i+1]);j++)\n\t\t\tif(v[i][j]!=v[i+1][j])\n\t\t\t{\n\t\t\t\ta=v[i][j];\n\t\t\t\tb=v[i+1][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(a<b)\n\t\t{\n\t\t\tt[c-b]++;\n\t\t\tt[c-a]--;\n\t\t} else\n\t\t{\n\t\t\tt[0]++;\n\t\t\tt[c-a]--;\n\t\t\tt[c-b]++;\n\t\t\tt[c]--;\n\t\t}\n\t}\n\tint cur=0;\n\tfor(int i=0;i<c;i++)\n\t{\n\t\tcur+=t[i];\n\t\tif(cur==0)\n\t\t{\n\t\t\tcout << i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << -1;\n\treturn 0;\n}']","[1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Let s denote that some array b is if it contains a subarray b l b l 1 dots b r of odd length more than 1 l r and r l 1 is odd such that forall i in 0 1 dots r l b l i b r i If an array is not bad it is Now you are given an array a 1 a 2 dots a n Some elements are replaced by 1 Calculate the number of good arrays you can obtain by replacing each 1 with some integer from 1 to k Since the answer can be large print it modulo 998244353 ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=500005,P=998244353;\nint n,k,a[N],b[N],m,f[N];\n\ninline void read(int &i){\n\ti=0;char c=getchar();bool j=0;\n\tfor(;!isdigit(c);c=getchar())if(c==\'-\')j=1;\n\tfor(;isdigit(c);c=getchar())i=(i<<1)+(i<<3)+c-\'0\';i=j?-i:i;\n}\ninline ll Pow(ll a,int b){ll c=1;for(;b;a=a*a%P,b>>=1)if(b&1)c=c*a%P;return c;}\n\ninline int F(int n,int c,int t){\n\tif(!c)return k*Pow(k-1,n-1)%P;\n\tif(c==1)return Pow(k-1,n);\n\tf[0]=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)f[i]=1ll*f[i-1]*(k-1)%P;\n\tfor(int i=n;i>=1;--i){\n\t\tif((n-i)&1)ans-=f[i];\n\t\telse ans+=f[i];\n\t\tans%=P;\n\t}\n\tif(ans<0)ans+=P;\n\tif(!t){\n\t\tans=Pow(k-1,n+1)-ans;\n\t\tif(ans<0)ans+=P;\n\t\tans=ans*Pow(k-1,P-2)%P;\n\t}\n\treturn ans;\n}\n\nint calc(){\n\tfor(int i=1;i<m;++i)if(b[i]>0&&b[i+1]>0&&b[i]==b[i+1])return 0;\n\tint as=1;\n\tfor(int i=1;i<=m;){\n\t\tint j=i;\n\t\tif(b[i]!=-1){i++;continue;}\n\t\twhile(j+1<=m&&b[j+1]==-1)j++;\n\t\tint c=0;\n\t\tif(i>1)c++;\n\t\tif(j<m)c++;\n\t\tas=1ll*as*F(j-i+1,c,b[i-1]==b[j+1])%P;\n\t\ti=j+1;\n\t}\n\treturn as;\n}\n\nint main(){\n\tread(n);read(k);\n\tfor(int i=1;i<=n;++i)read(a[i]);\n\tfor(int i=1;i<=n;i+=2)b[++m]=a[i];\n\tint ans=calc();\n\tm=0;\n\tfor(int i=2;i<=n;i+=2)b[++m]=a[i];\n\tans=1ll*ans*calc()%P;\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2200
Limak is an old brown bear He often goes bowling with his friends Today he feels really good and tries to beat his own record For rolling a ball one gets a score an integer maybe negative number of points Score for the th roll is multiplied by and scores are summed up So for rolls with scores the total score is The total score is if there were no rolls Limak made rolls and got score for the th of them He wants to maximize his total score and he came up with an interesting idea He can say that some first rolls were only a warm up and that he wasn t focused during the last rolls More formally he can cancel any prefix and any suffix of the sequence It is allowed to cancel all rolls or to cancel none of them The total score is calculated as if there were only non canceled rolls So the first non canceled roll has score multiplied by the second one has score multiplied by and so on till the last non canceled roll What maximum total score can Limak get ,"['# include <cstdio>\n# include <vector>\nusing namespace std;\nconst int MN = 2e5 + 44;\nlong long a[MN];\nvector <pair <int, long long> > hull;\nbool bad(pair <int, long long> x)\n{\n\tif (hull.size() < 2)\n\t\treturn false;\n\tpair <int, long long> y = hull.back();\n\tpair <int, long long> z = hull[hull.size() - 2];\n\treturn (x.second - y.second) * (z.first - y.first) < (z.second - y.second) * (x.first - y.first);\n}\nlong long eval(pair <int, long long> a, long long x, long long y)\n{\n// \tprintf(""return %I64d\\n"", a.first * x + a.second + y);\n\treturn a.first * x + a.second + y;\n}\nlong long sufsum[MN];\nlong long sufscores[MN];\nint main()\n{\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%I64d"", a + i);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufsum[i] = sufsum[i + 1] + a[i];\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufscores[i] = sufscores[i + 1] + sufsum[i];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tpair <int, long long> add = make_pair(i, sufscores[i]);\n// \t\tprintf(""add %d %I64d\\n"", add.first, add.second);\n\t\twhile (bad(add))\n\t\t\thull.pop_back();\n\t\thull.push_back(add);\n\t}\n// \tfor (auto x : hull)\n// \t\tprintf(""%d %I64d\\n"", x.first, x.second);\n\tlong long res = 0;\n\tlong long x = 0, y = 0;\n\tfor (int i = n - 1; i >= 0; --i)\n\t{\n// \t\tprintf(""i = %d x = %I64d y = %I64d\\n"", i, x, y);\n\t\tint low = 0, high = hull.size() - 1;\n\t\twhile (low < high - 3)\n\t\t{\n\t\t\tint med = (low + high) / 2;\n\t\t\tif (hull[med].first > i)\n\t\t\t\thigh = med - 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlong long val = eval(hull[med], x, y);\n// \t\t\t\tprintf(""include %d %I64d\\n"", hull[med].first, hull[med].second);\n\t\t\t\tres = max(res, val);\n\t\t\t\tif (eval(hull[med], x, y) > eval(hull[med + 1], x, y))\n\t\t\t\t\thigh = med;\n\t\t\t\telse\n\t\t\t\t\tlow = med;\n\t\t\t}\n\t\t}\n// \t\tprintf(""binsearch done\\n"");\n\t\tfor (int k = low; k <= high; ++k)\n\t\t\tif (hull[k].first <= i)\n\t\t\t{\n// \t\t\t\tprintf(""include %d %I64d\\n"", hull[k].first, hull[k].second);\n\t\t\t\tres = max(res, eval(hull[k], x, y));\n\t\t\t}\n\t\ty -= (i + 1) * a[i];\n\t\tx += a[i];\n\t}\n\tprintf(""%I64d\\n"", res);\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2500
n people sitting in a circle are trying to shuffle a deck of cards The players are numbered from 1 to n so that players i and i 1 are neighbours as well as players 1 and n Each of them has exactly k cards where k is The left neighbour of a player i is player i 1 and their right neighbour is player i 1 except for players 1 and n who are respective neighbours of each other Each turn the following happens if a player has x cards they give lfloor x 2 rfloor to their neighbour on the left and lceil x 2 rceil cards to their neighbour on the right This happens for all players simultaneously However one player p is the impostor and they just give all their cards to their neighbour on the right You know the number of players n and the number of cards k each player has initially but p is unknown to you Your task is to determine the value of p by asking questions like how many cards does player q have for an index q of your choice After each question all players will make exactly one move and give their cards to their neighbours You need to find the impostor by asking no more than 1000 questions ,"['/**\n *    author:  tourist\n *    created: 05.01.2021 18:11:34       \n**/\n#undef LOCAL\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n, k);\n  vector<int> b(n);\n  #ifdef LOCAL\n  mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n  int secret = rng() % n;\n  debug(secret);\n  int Q = 0;\n  #endif\n  auto Ask = [&](int pos) {\n    #ifdef LOCAL\n    Q += 1;\n    int res = a[pos];\n    for (int i = 0; i < n; i++) {\n      b[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n      int R = (i + 1) % n;\n      int L = (i + n - 1) % n;\n      if (i == secret) {\n        b[R] += a[i];\n      } else {\n        b[L] += a[i] / 2;\n        b[R] += (a[i] + 1) / 2;\n      }\n    }\n    swap(a, b);\n    return res;\n    #else\n    cout << ""? "" << pos + 1 << endl;\n    int foo;\n    cin >> foo;\n    return foo;\n    #endif\n  };\n  const int WAIT = 500;\n  for (int i = 0; i < WAIT; i++) {\n    Ask(0);\n  }\n  int step = (n + 399) / 400;\n  int L = -1;\n  int R = -1;\n  for (int i = 0; i < n; i += step) {\n    int x = Ask(i);\n    if (x > k) {\n      L = i - (n + 1) / 2;\n      R = i;\n      while (L + 1 < R) {\n        int M = L + (R - L) / 2;\n        x = Ask((M % n + n) % n);\n        if (x > k) {\n          R = M;\n        } else {\n          L = M;\n        }\n      }\n      int res = (L % n + n) % n;\n      cout << ""! "" << res + 1 << endl;\n      #ifdef LOCAL\n      debug(res);\n      debug(Q);\n      assert(res == secret);\n      #endif\n      return 0;\n    }\n    if (x < k) {\n      L = i;\n      R = i + (n + 1) / 2;\n      while (L + 1 < R) {\n        int M = L + (R - L) / 2;\n        x = Ask((M % n + n) % n);\n        if (x < k) {\n          L = M;\n        } else {\n          R = M;\n        }\n      }\n      int res = (R % n + n) % n;\n      cout << ""! "" << res + 1 << endl;\n      #ifdef LOCAL\n      debug(res);\n      debug(Q);\n      assert(res == secret);\n      #endif\n      return 0;\n    }\n  }\n  assert(false);\n  return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
After the contest in comparing numbers Shapur s teacher found out that he is a real genius and that no one could possibly do the calculations faster than him even using a super computer Some days before the contest the teacher took a very simple looking exam and all his students took part in the exam The teacher gave them strings and asked them to them Concatenating strings means to put them in some arbitrary order one after the other For example from concatenating and we can get to or depending on the order of concatenation Unfortunately enough the teacher forgot to ask students to concatenate their strings in a pre defined order so each student did it the way he she liked Now the teacher knows that Shapur is such a fast calculating genius boy and asks him to correct the students papers Shapur is not good at doing such a time taking task He rather likes to finish up with it as soon as possible and take his time to solve 3 SAT in polynomial time Moreover the teacher has given some advice that Shapur has to follow Here s what the teacher said As I expect you know the strings I gave to my students including you contained only lowercase and uppercase Persian Mikhi Script letters These letters are too much like Latin letters so to make your task much harder I converted all the initial strings and all of the students answers to Latin As latin alphabet has much less characters than Mikhi Script I added three odd looking characters to the answers these include and These characters are my own invention of course And I call them The length of all initial strings was less than or equal to and the lengths of my students answers are less than or equal to My son not all students are genius as you are It is quite possible that they make minor mistakes changing case of some characters For example they may write instead of Don t be picky and ignore these mistakes Those signs which I previously talked to you about are not important You can ignore them since many students are in the mood for adding extra signs or forgetting about a sign So something like is the same as You should indicate for any of my students if his answer was right or wrong Do this by writing for Wrong answer or for a correct answer I should remind you that none of the strings initial strings or answers are empty Finally do these as soon as possible You have less than hours to complete this ,"['# include <cstdio>\n# include <cctype>\n# include <cstring>\n\nchar inp1[101],inp2[101],inp3[101];\nchar check[6][301];\nchar student[601];\n\nvoid generate(char *i1,char *i2,char *i3,char* out)\n{\n\tstrcpy(out,i1);\n\tstrcat(out,i2);\n\tstrcat(out,i3);\n}\n\nvoid modify(char *inp)\n{\n\tint pos=0;\n\tfor(int i=0;inp[i];i++)\n\t\tif(isalpha(inp[i]))\n\t\t\tinp[pos++]=tolower(inp[i]);\n\tinp[pos]=0;\n}\n\nint main()\n{\n\tscanf(""%s%s%s"",inp1,inp2,inp3);\n\n\tmodify(inp1);\n\tmodify(inp2);\n\tmodify(inp3);\n\t\n\tgenerate(inp1,inp2,inp3,check[0]);\n\tgenerate(inp1,inp3,inp2,check[1]);\n\tgenerate(inp2,inp1,inp3,check[2]);\n\tgenerate(inp2,inp3,inp1,check[3]);\n\tgenerate(inp3,inp2,inp1,check[4]);\n\tgenerate(inp3,inp1,inp2,check[5]);\n\t\n\tint N;\n\tscanf(""%d"",&N);\n\t\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tscanf(""%s"",student);\n\t\tmodify(student);\n\t\tfor(int j=0;j<6;j++)\n\t\t\tif(strcmp(student,check[j])==0)\n\t\t\t{\n\t\t\t\tprintf(""ACC\\n"");\n\t\t\t\tgoto bpp;\n\t\t\t}\n\t\tprintf(""WA\\n"");\n\t\tbpp:;\n\t}\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1300
You are given three integers a b and c Find two positive integers x and y x 0 y 0 such that the decimal representation of x without leading zeroes consists of a digits the decimal representation of y without leading zeroes consists of b digits the decimal representation of gcd x y without leading zeroes consists of c digits gcd x y denotes the greatest common divisor GCD of integers x and y Output x and y If there are multiple answers output any of them ,"[""#include <bits/stdc++.h>\n\ntemplate <class T>\nconstexpr T power(T a, int64_t n) {\n  assert(n >= 0);\n  T res = n & 1 ? a : 1;\n  while (n >>= 1) {\n    a *= a;\n    if (n & 1) res *= a;\n  }\n  return res;\n}\n\ntemplate <int Id>\nclass DynamicModularInt64 {\n  using D = DynamicModularInt64;\n\n public:\n  static int64_t modulus() { return modulus_; }\n  static void modulus(int64_t modulus) {\n    assert(modulus >= 1);\n    modulus_ = modulus;\n  }\n  static D raw(uint64_t v) { return *reinterpret_cast<D*>(&v); }\n\n  DynamicModularInt64() : v_(0) {}\n  DynamicModularInt64(int64_t v)\n      : v_((v %= modulus()) < 0 ? v + modulus() : v) {}\n\n  template <class T>\n  explicit operator T() const {\n    return v_;\n  }\n  D& operator++() { return v_ = ++v_ == modulus_ ? 0 : v_, *this; }\n  D& operator--() { return --(v_ ? v_ : v_ = modulus_), *this; }\n  D operator+() const { return *this; }\n  D operator-() const { return raw(v_ ? modulus_ - v_ : 0); }\n  D& operator*=(D o) {\n    v_ = v_ * o.v_ - uint64_t((long double)v_ * o.v_ / modulus_) * modulus_;\n    v_ = int64_t(v_) < 0 ? v_ + modulus_ : v_;\n    v_ = v_ >= modulus_ ? v_ - modulus_ : v_;\n    return *this;\n  }\n  D& operator/=(D o) {\n    auto [inv, gcd] = extgcd(o.v_, modulus_);\n    assert(gcd == 1);\n    return *this *= inv;\n  }\n  D& operator+=(D o) {\n    return v_ = int64_t(v_ += o.v_ - modulus_) < 0 ? v_ + modulus_ : v_, *this;\n  }\n  D& operator-=(D o) {\n    return v_ = int64_t(v_ -= o.v_) < 0 ? v_ + modulus_ : v_, *this;\n  }\n\n  friend D operator++(D& a, int) { return std::exchange(a, ++D(a)); }\n  friend D operator--(D& a, int) { return std::exchange(a, --D(a)); }\n  friend D operator*(D a, D b) { return a *= b; }\n  friend D operator/(D a, D b) { return a /= b; }\n  friend D operator+(D a, D b) { return a += b; }\n  friend D operator-(D a, D b) { return a -= b; }\n  friend std::istream& operator>>(std::istream& is, D& x) {\n    int64_t v;\n    return is >> v, x = v, is;\n  }\n  friend std::ostream& operator<<(std::ostream& os, D x) { return os << x.v_; }\n  friend bool operator==(D a, D b) { return a.v_ == b.v_; }\n  friend bool operator!=(D a, D b) { return a.v_ != b.v_; }\n\n private:\n  static std::pair<int64_t, int64_t> extgcd(int64_t a, int64_t b) {\n    std::array<int64_t, 2> x{1, 0};\n    while (b) std::swap(x[0] -= a / b * x[1], x[1]), std::swap(a %= b, b);\n    return {x[0], a};\n  }\n\n  static inline uint64_t modulus_ = std::numeric_limits<int64_t>::max();\n\n  uint64_t v_;\n};\n\nbool miller_rabin(int64_t n, std::initializer_list<int64_t> bases) {\n  using Mint = DynamicModularInt64<__COUNTER__>;\n  Mint::modulus(n);\n  int tz = __builtin_ctzll(n - 1);\n  for (Mint a : bases) {\n    if (a == 0) continue;\n    a = power(a, n >> tz);\n    int i = tz;\n    while (a != 1 and a != -1 and i--) a *= a;\n    if (a != -1 and i != tz) return false;\n  }\n  return true;\n}\n\nbool is_prime(int64_t n) {\n  if (n < 2 or n % 6 % 4 != 1) return n == 2 or n == 3;\n  if (n < 291831) return miller_rabin(n, {126401071349994536});\n  if (n < 1050535501) return miller_rabin(n, {336781006125, 9639812373923155});\n  if (n < 273919523041)\n    return miller_rabin(n, {15, 7363882082, 992620450144556});\n  if (n < 47636622961201)\n    return miller_rabin(n, {2, 2570940, 211991001, 3749873356});\n  if (n < 7999252175582851)\n    return miller_rabin(n, {2, 4130806001517, 149795463772692060,\n                            186635894390467037, 3967304179347715805});\n  if (n < 585226005592931977)\n    return miller_rabin(\n        n, {2, 123635709730000, 9233062284813009, 43835965440333360,\n            761179012939631437, 1263739024124850375});\n  return miller_rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n}\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  vector<int> x, y;\n  for (int i : Rep(9)) {\n    int p = power(10, i);\n    while (not is_prime(p)) ++p;\n    x.push_back(p);\n    ++p;\n    while (not is_prime(p)) ++p;\n    y.push_back(p);\n  }\n  DUMP(x);\n  DUMP(y);\n  for (int tt = scan(); tt--;) {\n    int a = scan() - 1;\n    int b = scan() - 1;\n    int c = scan() - 1;\n    cout << x[a - c] * power(10, c) << ' ' << y[b - c] * power(10, c) << '\\n';\n  }\n}\n""]","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1100
There is a string s of length 3 consisting of uppercase and lowercase English letters Check if it is equal to without quotes where each letter can be in any case For example are all allowable ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define all(x) x.begin(), x.end()\nusing ll = long long;\nusing db = long double;\n\n#ifdef LOCAL\n#include ""./debug.h""\n#define fstart cout.setf(ios::fixed); cout.precision(10); int START = clock(); ifstream cin(""./input.txt""); ofstream cout(""output.txt"")\n#define finish cout << ""\\ntime: "" << setprecision(4) << (clock() - START) / (double)(CLOCKS_PER_SEC); return 0\n#else\n#define debug(x...) 1\n#define fstart cin.tie(0); cout.tie(0); cout.setf(ios::fixed); cout.precision(10); ios_base::sync_with_stdio(0)\n#define finish return 0\n#endif\n\n\n\nsigned main() {\n    fstart;\n\n    int T; cin >> T;\n    while (T--) {\n        string s; cin >> s;\n        char ok = (s[0] == \'Y\' || s[0] == \'y\');\n        ok &= (s[1] == \'E\' || s[1] == \'e\');\n        ok &= (s[2] == \'s\' || s[2] == \'S\');\n        cout << (ok ? ""YES"" : ""NO"") << ""\\n"";\n\n\n    }\n\n    finish;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
A chainword is a special type of crossword As most of the crosswords do it has cells that you put the letters in and some sort of hints to what these letters should be The letter cells in a chainword are put in a single row We will consider chainwords of length m in this task A hint to a chainword is a sequence of segments such that the segments don t intersect with each other and cover all m letter cells Each segment contains a description of the word in the corresponding cells The twist is that there are actually two hints one sequence is the row above the letter cells and the other sequence is the row below the letter cells When the sequences are different they provide a way to resolve the ambiguity in the answers You are provided with a dictionary of n words each word consists of lowercase Latin letters All words are pairwise distinct An instance of a chainword is the following triple a string of m lowercase Latin letters the first hint a sequence of segments such that the letters that correspond to each segment spell a word from the dictionary the second hint another sequence of segments such that the letters that correspond to each segment spell a word from the dictionary Note that the sequences of segments don t necessarily have to be distinct Two instances of chainwords are considered different if they have different strings different first hints different second hints Count the number of different instances of chainwords Since the number might be pretty large output it modulo 998 244 353 ,"['#include <bits/stdc++.h>\n\n// https :  // github.com/ecnerwala/cp-book/blob/master/src/bm.hpp\ntemplate <typename num>\nstd::vector<num> BerlekampMassey(const std::vector<num>& s) {\n  int n = int(s.size()), L = 0, m = 0;\n  std::vector<num> C(n), B(n), T;\n  C[0] = B[0] = 1;\n\n  num b = 1;\n  for (int i = 0; i < n; i++) {\n    ++m;\n    num d = s[i];\n    for (int j = 1; j <= L; j++) d += C[j] * s[i - j];\n    if (d == 0) continue;\n    T = C;\n    num coef = d / b;\n    for (int j = m; j < n; j++) C[j] -= coef * B[j - m];\n    if (2 * L > i) continue;\n    L = i + 1 - L;\n    B = T;\n    b = d;\n    m = 0;\n  }\n\n  C.resize(L + 1);\n  C.erase(C.begin());\n  for (auto& x : C) {\n    x = -x;\n  }\n  return C;\n}\n\ntemplate <typename num>\nnum linearRec(const std::vector<num>& S, const std::vector<num>& tr,\n              long long k) {\n  int n = int(tr.size());\n  assert(S.size() >= tr.size());\n\n  auto combine = [&](std::vector<num> a, std::vector<num> b) {\n    std::vector<num> res(n * 2 + 1);\n    for (int i = 0; i <= n; i++)\n      for (int j = 0; j <= n; j++) res[i + j] += a[i] * b[j];\n    for (int i = 2 * n; i > n; --i)\n      for (int j = 0; j < n; j++) res[i - 1 - j] += res[i] * tr[j];\n    res.resize(n + 1);\n    return res;\n  };\n\n  std::vector<num> pol(n + 1), e(pol);\n  pol[0] = e[1] = 1;\n\n  for (++k; k; k /= 2) {\n    if (k % 2) pol = combine(pol, e);\n    e = combine(e, e);\n  }\n\n  num res = 0;\n  for (int i = 0; i < n; i++) res += pol[i + 1] * S[i];\n  return res;\n}\n\ntemplate <uint32_t Modulus>\nclass ModularInt {\n  using M = ModularInt;\n\n public:\n  static_assert(int(Modulus) >= 1, ""Modulus must be in the range [1, 2^31)"");\n  static constexpr int modulus() { return Modulus; }\n  static M raw(uint32_t v) { return *reinterpret_cast<M*>(&v); }\n\n  ModularInt() : v_(0) {}\n  ModularInt(int64_t v) : v_((v %= Modulus) < 0 ? v + Modulus : v) {}\n\n  template <class T>\n  explicit operator T() const {\n    return v_;\n  }\n  M& operator++() { return v_ = ++v_ == Modulus ? 0 : v_, *this; }\n  M& operator--() { return --(v_ ? v_ : v_ = Modulus), *this; }\n  M operator+() const { return *this; }\n  M operator-() const { return raw(v_ ? Modulus - v_ : 0); }\n  M& operator*=(M o) { return v_ = uint64_t(v_) * o.v_ % Modulus, *this; }\n  M& operator/=(M o) {\n    auto [inv, gcd] = extgcd(o.v_, Modulus);\n    assert(gcd == 1);\n    return *this *= inv;\n  }\n  M& operator+=(M o) {\n    return v_ = int(v_ += o.v_ - Modulus) < 0 ? v_ + Modulus : v_, *this;\n  }\n  M& operator-=(M o) {\n    return v_ = int(v_ -= o.v_) < 0 ? v_ + Modulus : v_, *this;\n  }\n\n  friend M operator++(M& a, int) { return std::exchange(a, ++M(a)); }\n  friend M operator--(M& a, int) { return std::exchange(a, --M(a)); }\n  friend M operator*(M a, M b) { return a *= b; }\n  friend M operator/(M a, M b) { return a /= b; }\n  friend M operator+(M a, M b) { return a += b; }\n  friend M operator-(M a, M b) { return a -= b; }\n  friend std::istream& operator>>(std::istream& is, M& x) {\n    int64_t v;\n    return is >> v, x = v, is;\n  }\n  friend std::ostream& operator<<(std::ostream& os, M x) { return os << x.v_; }\n  friend bool operator==(M a, M b) { return a.v_ == b.v_; }\n  friend bool operator!=(M a, M b) { return a.v_ != b.v_; }\n\n private:\n  static std::pair<int, int> extgcd(int a, int b) {\n    std::array x{1, 0};\n    while (b) std::swap(x[0] -= a / b * x[1], x[1]), std::swap(a %= b, b);\n    return {x[0], a};\n  }\n\n  uint32_t v_;\n};\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nusing Mint = ModularInt<998244353>;\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n = scan();\n  int m = scan();\n  vector<string> s(n);\n  generate(ALL(s), scan<string>);\n  vector<string> suff;\n  for (auto&& e : s)\n    for (int i : Rep(size(e) + 1)) suff.push_back(e.substr(i));\n  sort(ALL(suff));\n  suff.erase(unique(ALL(suff)), end(suff));\n\n  int lim = 100;\n  vector f(lim + 1, vector<Mint>(size(suff)));\n  f[0][0] = 1;\n\n  for (int len : Rep(lim))\n    for (int i : Rep(size(suff)))\n      for (auto&& e : s)\n        if (size(e) < size(suff[i])) {\n          if (suff[i].substr(0, size(e)) != e) continue;\n          if (len + int(size(e)) > lim) continue;\n          f[len + size(e)][lower_bound(ALL(suff), suff[i].substr(size(e))) -\n                           begin(suff)] += f[len][i];\n        } else {\n          if (e.substr(0, size(suff[i])) != suff[i]) continue;\n          if (len + int(size(suff[i])) > lim) continue;\n          f[len + size(suff[i])]\n           [lower_bound(ALL(suff), e.substr(size(suff[i]))) - begin(suff)] +=\n              f[len][i];\n        }\n\n  vector<Mint> a(lim + 1);\n  for (int i : Rep(lim + 1)) a[i] = f[i][0];\n  cout << linearRec(a, BerlekampMassey(a), m) << \'\\n\';\n}\n']","[0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2700
Vasya like many others likes to participate in a variety of sweepstakes and lotteries Now he collects wrappings from a famous chocolate bar Jupiter According to the sweepstake rules each wrapping has an integer written on it the number of points that the participant adds to his score as he buys the bar After a participant earns a certain number of points he can come to the prize distribution center and exchange the points for prizes When somebody takes a prize the prize s cost is simply subtracted from the number of his points Vasya didn t only bought the bars he also kept a record of how many points each wrapping cost Also he remembers that he always stucks to the greedy strategy as soon as he could take at least one prize he went to the prize distribution centre and exchanged the points for prizes Moreover if he could choose between multiple prizes he chose the most expensive one If after an exchange Vasya had enough points left to get at least one more prize then he continued to exchange points The sweepstake has the following prizes the prizes are sorted by increasing of their cost a mug costs points a towel costs points a bag costs points a bicycle costs points a car costs points Now Vasya wants to recollect what prizes he has received You know sequence where is the number of points Vasya got for the th bar The sequence of points is given in the chronological order You also know numbers Your task is to find how many prizes Vasya received what prizes they are and how many points he s got left after all operations are completed ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<cstring>\n#include<iostream>\n#include<ctype.h>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<bitset>\n#include<iomanip>\n#include<complex>\n#include<utility>\n\n#define X first\n#define Y second\n#define REP_0(i,n) for(int i=0;i<(n);++i)\n#define REP_1(i,n) for(int i=1;i<=(n);++i)\n#define REP_2(i,a,b) for(int i=(a);i<(b);++i)\n#define REP_3(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c))\n#define DOW_0(i,n) for(int i=(n)-1;-1<i;--i)\n#define DOW_1(i,n) for(int i=(n);0<i;--i)\n#define DOW_2(i,a,b) for(int i=(b);(a)<i;--i)\n#define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i)\n#define FOREACH(a,b) for(typeof(b.begin()) a=(b).begin();a!=(b).end();++a)\n#define RFOREACH(a,b) for(typeof(b.rbegin()) a=(b).rbegin();a!=b.rend();++a)\n#define PB push_back\n#define PF push_front\n#define MP make_pair\n#define IS insert\n#define ES erase\n#define IT iterator\n#define RI reserve_iterator\n#define PQ priority_queue\n#define LB lower_bound\n#define UB upper_bound\n\n#define PI 3.1415926535897932384626433832795\n#define EXP 2.7182818284590452353602874713527\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef double DB;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef pair<int,PII> PIII;\ntypedef pair<LD,int> PLDI;\ntypedef vector<PII> VII;\n\ntemplate<class T>\nT By(T x,T y,T P){\n\tT F1=0;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1+=x;\n\t\t\tif(F1<0||F1>=P)F1-=P;\n\t\t}\n\t\tx<<=1;\n\t\tif(x<0||x>=P)x-=P;\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Mul(T x,T y,T P){\n\tT F1=1;x%=P;\n\twhile(y)\n\t{\n\t\tif(y&1)\n\t\t{\n\t\t\tF1=By(F1,x,P);\n\t\t}\n\t\tx=By(x,x,P);\n\t\ty>>=1;\n\t}\n\treturn F1;\n}\n\ntemplate<class T>\nT Gcd(T x,T y){\n\tif(y==0)return x;\n\tT z;\n\twhile(z=x%y){\n\t\tx=y,y=z;\n\t}\n\treturn y;\n}\n\nstruct EDGE{\n\tint T;EDGE *Nxt;\n};\n\ntemplate<class T>\nvoid UpdataMin(T &x,T y){\n\tif(y<x)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nvoid UpdataMax(T &x,T y){\n\tif(x<y)\n\t{\n\t\tx=y;\n\t}\n}\n\ntemplate<class T>\nT Sqr(const T x){\n\treturn x*x;\n}\n\n#define MaxBuffer 20000000\nclass ReadBuffer{\n\tchar buff[MaxBuffer];\n\tchar *buf;\n\tvoid init(int size=MaxBuffer)\n\t{\n\t\tfread(buff,1,size,stdin);\n\t}\n\ttemplate<class T>\n\tbool readInterger(T &x)\n\t{\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag;\n\t\tflag=0;\n\t\tif(*buf==\'-\') flag=true;\n\t\telse x=*buf-\'0\';\n\t\twhile(isdigit(*++buf)) x=x*10+*buf-\'0\';\n\t\tif(flag) x=-x;\n\t\treturn true;\n\t}\n\ttemplate<class T>\n\tbool readFloat(T &x)\n\t{\n\t\tlong double nowpos=0.1;\n\t\tx=0;\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(*buf==0) return false;\n\t\tstatic bool flag,decimal;\n\t\tdecimal=flag=0;\n\t\tif(*buf==\'-\') flag=true,++buf;\n\t\telse if(*buf==\'.\') decimal=true;\n\t\twhile(isdigit(*buf)||*buf==\'.\')\n\t\t{\n\t\t\tif(*buf==\'.\') decimal=true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(decimal)\n\t\t\t\t{\n\t\t\t\t\tx+=nowpos*(*buf-\'0\');\n\t\t\t\t\tnowpos*=0.1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tx=x*10+*buf-\'0\';\n\t\t\t\t}\n\t\t\t}\n\t\t\t++buf;\n\t\t}\n\t\treturn true;\n\t}\n\tbool readChar(char c)\n\t{\n\t\tif(*buf==0) return 0;\n\t\treturn c=*buf++,1;\n\t}\n\tbool readString(char *s)\n\t{\n\t\twhile(*buf&&isspace(*buf)) ++buf;\n\t\tif(!*buf) return false;\n\t\twhile(!isspace(*buf)) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn true;\n\t}\n\tint countSpacetonext(){\n\t\tint total=0;\n\t\twhile(*buf&&*buf==\' \') ++total,++buf;\n\t\treturn total;\n\t}\n\tbool splitBycharactor(char *s,char Split=\'\\n\'){\n\t\twhile(*buf&&*buf!=Split) *s++=*buf++;\n\t\t*s++=0;\n\t\treturn *buf!=0;\n\t}\n};\n\nLL P[55];\nLL nowP;\nLL ans[6];\nLL C[6],Get;\nint n;\n\nint main(){\n//\tfreopen(""a.in"",""r"",stdin);\n//\tfreopen(""a.out"",""w"",stdout);\n\tcin>>n;\n\tREP_1(i,n) cin>>P[i];\n\tREP_1(i,5) cin>>C[i];\n\tREP_1(i,n)\n\t{\n\t\tnowP+=P[i];\n\t\tDOW_1(j,5)\n\t\t{\n\t\t\tGet=nowP/C[j];\n\t\t\tnowP-=C[j]*Get;\n\t\t\tans[j]+=Get;\n\t\t}\n\t}\n\tREP_1(i,5) cout<<ans[i]<<(i==5?\'\\n\':\' \');\n\tcout<<nowP<<endl;\n\tcin>>n;\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Berland is a tourist country At least it can become such the government of Berland is confident about this There are cities in Berland some pairs of which are connected by two ways roads Each road connects two different cities In Berland there are no roads which connect the same pair of cities It is possible to get from any city to any other city using given two ways roads According to the reform each road will become one way It will be oriented to one of two directions To maximize the tourist attraction of Berland after the reform for each city the value will be calculated It will equal to the number of cities for which there is an oriented path from the city to the city In other words will equal the number of cities which can be reached from the city by roads The government is sure that tourist s attention will be focused on the minimum value of Help the government of Berland make the reform to maximize the minimum of ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int N = 404040;\nint n , m , u[N] , v[N];\nvector<pii> g[N];\npii ans[N];\n\nnamespace BCC{\n    vi key;\n    vector<pii> bcc[N];\n    int dfn[N] , low[N] , id[N] , st[N] , _st , _;\n    void dfs(int c,int dep,vector<pii> g[]){\n        int cc=0;st[_st++]=c;\n        dfn[c]=low[c]=dep;\n        //cout << c << "" "" << dep << endl;\n        for(auto e:g[c]){\n            int t=e.fi;\n            if(!dfn[t]){\n                ans[e.se] = mp(c,t);\n                dfs(t,dep+1,g);\n                low[c]=min(low[c],low[t]);\n                if(low[t]>dfn[c]) key.pb(e.se);\n            } else if(dfn[t] != dfn[c] - 1 || cc++){\n                low[c] = min(low[c] , dfn[t]);\n                if(dfn[t] < dfn[c]) ans[e.se] = mp(c , t);\n            }\n        }\n        if(low[c]==dfn[c]){\n            do{id[st[--_st]]=_;}while(st[_st]!=c);\n            _++;\n        }\n    }\n    int sz[N];\n    void dfs(int c,int fa){\n        for(auto t : bcc[c]) if(t.fi != fa){\n            int a = u[t.se] , b = v[t.se];\n            if(id[a] == c) swap(a , b);\n            ans[t.se] = mp(a , b);\n            //ans[t.se] = mp(0 , 0);\n            dfs(t.fi , c);\n        }\n    }\n    int solve(int n,vector<pii> g[]){\n        rep(i,0,n) if(!dfn[i]) dfs(i,1,g);\n        rep(i,0,n) sz[id[i]]++;\n        rep(i,0,n) for(auto j:g[i]) if(id[i]!=id[j.fi])\n            bcc[id[i]].pb(mp(id[j.fi],j.se));\n        int id = -1 , Max = -1;\n        rep(i,0,_) if(sz[i] > Max) Max = sz[i] , id = i;\n        dfs(id , -1);\n        printf(""%d\\n"",Max);\n        rep(i,0,m) printf(""%d %d\\n"",ans[i].fi + 1,ans[i].se + 1);\n        return _;\n    }\n};\n\nint main(){\n    scanf(""%d%d"",&n,&m);\n    rep(i,0,m){\n        scanf(""%d%d"",u + i , v + i);\n        --u[i];--v[i];\n        g[u[i]].pb(mp(v[i] , i));\n        g[v[i]].pb(mp(u[i] , i));\n    }\n    BCC::solve(n,g);\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
Manao has invented a new mathematical term a beautiful set of points He calls a set of points on a plane if it meets the following conditions The coordinates of each point in the set are integers For any two points from the set the distance between them is a non integer Consider all points which satisfy the inequations Choose their subset of maximum size such that it is also a beautiful set of points ,"['#include <vector> \n#include <list> \n#include <map> \n#include <set> \n#include <deque> \n#include <queue> \n#include <stack> \n#include <bitset> \n#include <algorithm> \n#include <functional> \n#include <numeric> \n#include <utility> \n#include <sstream> \n#include <iostream> \n#include <iomanip> \n#include <cstdio> \n#include <cmath> \n#include <cstdlib> \n#include <cctype> \n#include <string> \n#include <cstring> \n#include <ctime> \n\nusing namespace std;\n\n#define _int64 long long\n\nint main()\n{\n  int i,j,m,n;\n  scanf(""%d%d"",&n,&m);\n  if (n<m) printf(""%d\\n"",n+1);\n  else printf(""%d\\n"",m+1);\n  for (i=0;i<=n&&i<=m;i++)\n  {\n    printf(""%d %d\\n"",i,m-i);\n  }\n}\n']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Kate has a set S of n integers 1 dots n She thinks that of a subset M subseteq S is equal to the of gcd a b over all pairs a b such that both a and b are in M and a neq b Kate is a very neat girl and for each k in 2 dots n she wants to find a subset that has the among all subsets in S of size k There can be more than one subset with the smallest imperfection and the same size but you don t need to worry about it Kate wants to find all the subsets herself but she needs your help to find the smallest possible imperfection for each size k will name it I k Please help Kate to find I 2 I 3 I n ,"['#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <map>\n\nusing namespace std;\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nusing ll = long long;\nint const nmax = 500000;\nint fi[1 + nmax], sol[1 + nmax];\nint invsol[1 + nmax];\n\nint main()\n{\n  int n;\n  cin >> n;\n  for(int i = 1;i <= n; i++)\n    fi[i] = 1;\n  for(int i = 2;i <= n; i++){\n    for(int j = i * 2; j <= n; j += i)\n      fi[j] = i;\n  }\n\n  for(int i = 1;i <= n; i++)\n    sol[fi[i]]++;\n\n  for(int i = 1;i <= n; i++)\n    invsol[i] = n;\n\n  for(int i = 1;i <= n; i++)\n    sol[i] += sol[i - 1];\n\n  for(int i = n;1 <= i; i--)\n    invsol[sol[i]] = i;\n\n  for(int i = n - 1; 1 <= i; i--)\n    invsol[i] = min(invsol[i], invsol[i + 1]);\n\n  for(int i = 2;i <= n; i++)\n    cout << invsol[i] << "" "";\n\n  return 0;\n}\n']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0]",2200
Oscolcovo city has a campus consisting of student dormitories universities and military offices Initially the th dormitory belongs to the th university and is assigned to the th military office Life goes on and the campus is continuously going through some changes The changes can be of four types University merges with university After that all the dormitories that belonged to university are assigned to to university and university disappears Military office merges with military office After that all the dormitories that were assigned to military office are assigned to military office and military office disappears Students of university move in dormitories Lets is the number of dormitories that belong to this university at the time when the students move in Then the number of students in each dormitory of university increases by note that the more dormitories belong to the university the more students move in each dormitory of the university Military office number conducts raids on all the dormitories assigned to it and takes all students from there Thus at each moment of time each dormitory is assigned to exactly one university and one military office Initially all the dormitory are empty Your task is to process the changes that take place in the campus and answer the queries how many people currently live in dormitory ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 1511111\n\n#define TASK ""1""\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, m, V1, V2;\n\nchar type[N];\nint x[N], y[N];\n\nint in1[N], in2[N], out1[N], out2[N];\n\nint n1[N], n2[N];\n\nint par1[N], par2[N];\n\npair<int, int> chi1[N], chi2[N];\n\nlong long su[N], ans[N];\n\nvector<int> po[N];\n\nint T;\n\nint tz[N];\n\n\nvoid add(int x, int v) {\n\twhile (x < n) {\n\t\tsu[x] += v;\n\t\tx |= (x + 1);\t\t\n\t}\n}\n\nlong long fin(int x) {\n\tlong long r = 0;\n\twhile (x >= 0) {\n\t\tr += su[x];\n\t\tx = (x & (x + 1)) - 1;\n\t}\n\treturn r;\n}\n\n\n\nvoid go1(int x) {\n\tin1[x] = T;\n\tif (x < n) T++; else {\n\n\t\tgo1(chi1[x].F);\n\t\tgo1(chi1[x].S);\n\t}\t\t\n\n\tout1[x] = T - 1;\n}\n\nvoid go2(int x) {\n\tin2[x] = T;\n\tif (x < n) T++; else {\n\n\t\tgo2(chi2[x].F);       \n\t\tgo2(chi2[x].S);\n\t}\t\t\n\n\tout2[x] = T - 1;\n}\n\n\nint main(){\n//\tfreopen(TASK"".in"",""r"",stdin);\t\n//\tfreopen(TASK"".out"",""w"",stdout);\n\tscanf(""%d%d\\n"", &n, &m);\n\n\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(""%c"", &type[i]);\n\t\tif (type[i] == \'A\' || type[i] == \'Z\' || type[i] == \'Q\') {\n\t\t\tscanf(""%d\\n"", &x[i]);\n\t\t\tx[i]--;\n\t\t} else {\n\t\t\tscanf(""%d%d\\n"", &x[i], &y[i]);\n\t\t\tx[i]--;\n\t\t\ty[i]--;\n\t\t}\n\t}\n\tV1 = V2 = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tn1[i] = n2[i] = i;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (type[i] == \'U\') {\n\t\t\tchi1[V1] = mp(n1[x[i]], n1[y[i]]);\n\n\t\t\tpar1[n1[x[i]]] = V1;\n\t\t\tpar1[n1[y[i]]] = V1;\n\t\t\tn1[x[i]] = V1;\n\t\t\tn1[y[i]] = V1;\n\t\t\tV1++;\n\t\t}\n\t\tif (type[i] == \'M\') {\n\t\t\tchi2[V2] = mp(n2[x[i]], n2[y[i]]);\n\n\t\t\tpar2[n2[x[i]]] = V2;\n\t\t\tpar2[n2[y[i]]] = V2;\n\t\t\tn2[x[i]] = V2;\n\t\t\tn2[y[i]] = V2;\n\t\t\tV2++;\n\t\t}\n\t}\n\tT = 0;\n\tfor (int i = 0; i < V1; i++) if (par1[i] == 0) go1(i);\n\tT = 0;\n\tfor (int i = 0; i < V2; i++) if (par2[i] == 0) go2(i);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tn2[i] = i;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (type[i] == \'M\') {\n\t\t\tn2[x[i]] = par2[n2[x[i]]];\n\t\t\tn2[y[i]] = par2[n2[y[i]]];\n\t\t}\n\t\tif (type[i] == \'Z\') {\n\t\t\ttz[i] = n2[x[i]];\n\t\t}\n\t}\n\tset<pair<int, int> > Q;\n\tset<pair<int, int> >::iterator it, it2;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (type[i] == \'Q\') {\n\t\t\tQ.insert(mp(in2[x[i]], i));\n\t\t}\n\t\tif (type[i] == \'Z\') {\n\t\t\tint A = in2[tz[i]];\n\t\t\tint B = out2[tz[i]];\n\t\t\tit = Q.lower_bound(mp(A, 0));\n\t\t\twhile (it != Q.end() && (it -> F) <= B) {\n\t\t\t\tpo[i].pb(it -> S);\n\t\t\t\tit2 = it;\n\t\t\t\tit++;\n\t\t\t\tQ.erase(it2);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tn1[i] = i;\n\t}\n\n\tfor (int i = 0; i < m; i++) {\n\t\tif (type[i] == \'U\') {\n\t\t\tn1[x[i]] = par1[n1[x[i]]];\n\t\t\tn1[y[i]] = par1[n1[y[i]]];\t\t\t\n\t\t}\n\t\tif (type[i] == \'A\') {\n\t\t\tint sz = out1[n1[x[i]]] - in1[n1[x[i]]] + 1;\n\t\t\tadd(in1[n1[x[i]]], sz);\n\t\t\tadd(out1[n1[x[i]]] + 1, -sz);\n\t\t}\n\t\tfor (int j = 0; j < po[i].size(); j++) {\n\t\t\tint v = in1[x[po[i][j]]];\n\t\t\tans[po[i][j]] -= fin(v);\n\t\t}\n\t\tif (type[i] == \'Q\') {\n\t\t\tint v = in1[x[i]];\n\t\t\tans[i] += fin(v);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) if (type[i] == \'Q\') printf(""%I64d\\n"", ans[i]);\n\n\treturn 0;\n}\n\n\n\n\n\n\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]",3100
Anton goes to school his favorite lessons are arraystudying He usually solves all the tasks pretty fast but this time the teacher gave him a complicated one given two arrays and of length find array such that where means bitwise AND while means bitwise OR Usually Anton is good in arraystudying but this problem is too hard so Anton asks you to help ,"['#include <iostream>\n#include <fstream>\n#include <list>\n#include <stack>\n#include <deque>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <ctime>\n#include <iterator>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\nconst int maxn = 200500;\nconst int inf = 2e9;\nconst double eps = 1e-8;\nconst int base = 1073676287;\n\nll a[maxn];\nint b[maxn];\nint c[maxn];\nint bit[64];\nint bits2[64];\n\nvoid check( int n ) {\n    ll sum = 0LL;\n\tfor ( int j = 0; j < n; j++ ) {\n\t    sum += a[j];\n\t\tint x = a[j];\n\t\tint pos = 0;\n\t\twhile ( x ) {\n\t\t\tbit[pos++] += x % 2;\n\t\t\tx /= 2;\n\t\t}\n\t}\n\tfor ( int j = 0; j < n; j++ ) {\n\t\tint x = a[j];\n\t\tint pos = 0;\n\t\tfor ( int i = 0; i < 64; i++ )\n\t\t\tbits2[i] = 0;\n\t\twhile ( x ) {\n\t\t\tbits2[pos++] = x % 2;\n\t\t\tx /= 2;\n\t\t}\n\t\tll cnt = 0LL;\n\t\tll deg = 1LL;\n\t\tfor ( int i = 0; i < 60; i++ ) {\n\t\t\tif ( bits2[i] )\n\t\t\t\tcnt += 1LL * bit[i] * deg;\n\t\t\tdeg *= 2LL;\n\t\t}\n\t\tif ( cnt != b[j] ) {\n\t\t\tputs( ""-1"" );\n\t\t\texit( 0 );\n\t\t}\n\t\tif ( 1LL * a[j] * n + sum != 1LL * b[j] + 1LL * c[j] ) {\n\t\t\tputs( ""-1"" );\n\t\t\texit( 0 );\n        }\n    }\n}\n\nint main()\n{\n    srand( time( 0 ) );\n    // freopen( ""input.txt"", ""r"", stdin );\n    // freopen( ""output.txt"", ""w"", stdout );\n    // ios_base::sync_with_stdio(false);\n    int n;\n    ll sum = 0LL;\n    scanf ( ""%d"", &n );\n    for ( int j = 0; j < n; j++ ) {\n    \tscanf ( ""%d"", &b[j] );\n    \tsum += 1LL * b[j];\n    }\n    for ( int j = 0; j < n; j++ ) {\n   \t\tscanf ( ""%d"", &c[j] );\n   \t\tsum += 1LL * c[j];\n    }\n    if ( sum % ( 2LL * n ) != 0LL ) {\n    \tputs( ""-1"" );\n    \treturn 0;\n    }\n    sum /= 2LL * n;\n    for ( int j = 0; j < n; j++ ) {\n    \tint cur = b[j] + c[j];\n    \ta[j] = cur - sum;\n    \tif ( a[j] < 0LL ) {\n    \t\tputs( ""-1"" );\n    \t\treturn 0;\n    \t}\n    \tif ( 1LL * a[j] % n != 0LL ) {\n    \t\tputs( ""-1"" );\n    \t\treturn 0;\n    \t}\n    \ta[j] /= 1LL * n;\n    }\n    check( n );\n    for ( int j = 0; j < n; j++ )\n    \tcout << a[j] << \' \';\n    return 0;\n}\n']","[0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2500
Our bear s forest has a checkered field The checkered field is an table the rows are numbered from 1 to from top to bottom the columns are numbered from 1 to from left to right Let s denote a cell of the field on the intersection of row and column by record Each cell of the field contains growing raspberry at that the cell of the field contains raspberry bushes The bear came out to walk across the field At the beginning of the walk his speed is Then the bear spends exactly seconds on the field Each second the following takes place Let s suppose that at the current moment the bear is in cell First the bear eats the raspberry from all the bushes he has in the current cell After the bear eats the raspberry from bushes he increases each component of his speed by In other words if before eating the bushes of raspberry his speed was then after eating the berry his speed equals Let s denote the current speed of the bear it was increased after the previous step Then the bear moves from cell to cell Then one additional raspberry bush grows in each cell of the field You task is to predict the bear s actions Find the cell he ends up in if he starts from cell Assume that each bush has infinitely much raspberry and the bear will never eat all of it ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int kMat[6][6] = {\n    2, 1, 1, 0, 1, 2,\n    1, 2, 0, 1, 1, 2,\n    1, 1, 1, 0, 1, 2,\n    1, 1, 0, 1, 1, 2,\n    0, 0, 0, 0, 1, 1,\n    0, 0, 0, 0, 0, 1\n};\nint n, sx, sy, dx, dy;\nll t;\n\nstruct Matrix {\n    int v[6][6];\n    void clear() {\n        memset(v, 0, sizeof(v));\n    }\n    Matrix() {\n        clear();\n    }\n} e, f, a;\n\nMatrix operator*(const Matrix &a, const Matrix &b) {\n    Matrix c;\n    for (int i = 0; i < 6; ++ i)\n        for (int j = 0; j < 6; ++ j)\n            for (int k = 0; k < 6; ++ k)\n                c.v[i][j] = (c.v[i][j] + (ll)a.v[i][k] * b.v[k][j] % n) % n;\n    return c;\n}\n\nMatrix mat_pow(const Matrix &a, ll b) {\n    Matrix res = e, tmp = a;\n    while (b) {\n        if (b & 1) res = res * tmp;\n        b >>= 1;\n        tmp = tmp * tmp;\n    }\n    return res;\n}\n\nint main() {\n    scanf(""%d%d%d%d%d%I64d"", &n, &sx, &sy, &dx, &dy, &t);\n    -- sx, -- sy;\n    dx = (dx % n + n) % n;\n    dy = (dy % n + n) % n;\n    for (int i = 0; i < 6; ++ i) e.v[i][i] = 1;\n    memcpy(f.v, kMat, sizeof(kMat));\n    a.v[0][0] = sx, a.v[1][0] = sy;\n    a.v[2][0] = dx, a.v[3][0] = dy;\n    a.v[4][0] = 0, a.v[5][0] = 1;\n    a = mat_pow(f, t) * a;\n    printf(""%d %d\\n"", a.v[0][0] + 1, a.v[1][0] + 1);\n    return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
In this problem you are initially given an empty multiset You have to process two types of queries x add an element equal to 2 x to the multiset w say whether it is possible to take the sum of some subset of the current multiset and get a value equal to w ,"['/**\n *    author:  tourist\n *    created: 18.12.2023 09:38:49       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<int> cnt(30);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string op;\n    cin >> op;\n    if (op == ""1"") {\n      int x;\n      cin >> x;\n      cnt[x] += 1;\n    } else {\n      int w;\n      cin >> w;\n      for (int i = 29; i >= 0; i--) {\n        int take = min(w >> i, cnt[i]);\n        w -= take << i;\n      }\n      cout << (w == 0 ? ""YES"" : ""NO"") << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1300
There is a set S of n points on a coordinate plane Kanno starts from a point P that can be chosen on the plane P is not added to S if it doesn t belong to S Then the following sequence of operations altogether called a is repeated several times in the given order Choose a line l such that it passes through at least two elements in S and passes through Kanno s current position If there are multiple such lines one is chosen equiprobably Move to one of the points that belong to S and lie on l The destination is chosen equiprobably among all possible ones including Kanno s current position if it does belong to S There are q queries each consisting of two integers t i m i For each query you re to help Kanno maximize the probability of the stopping position being the t i th element in S after m i moves with a proper selection of P and output this maximum probability Note that according to rule 1 P should belong to at least one line that passes through at least two points from S ,"['/*\n * Author: ylx\n * LANG: c++\n * PROG: \n */\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nvoid qmax(int &x,int y) {if (x<y) x=y;}\nvoid qmin(int &x,int y) {if (x>y) x=y;}\ninline int read()\n{\n\tchar s;\n\tint k=0,base=1;\n\twhile ((s=getchar())!=\'-\'&&s!=EOF&&!(isdigit(s)));\n\tif (s==EOF) exit(0);\n\tif (s==\'-\') base=-1,s=getchar();\n\twhile (isdigit(s)) k=k*10+(s^\'0\'),s=getchar();\n\treturn k*base;\n}\ninline void write(int x)\n{\n\tstatic char cnt,num[15];cnt=0;\n\tif (!x)\n\t{\n\t\tputchar(\'0\');\n\t\treturn;\n\t}\n\tfor (;x;x/=10) num[++cnt]=x%10;\n\tfor (;cnt;putchar(num[cnt--]+48));\n}\nconst int maxn=210;\nconst double eps=1e-9;\nint n,T;\nint cnt[maxn*maxn],tot,s[maxn];//cnt[i]:直线i上的点的个数,s[i]:点i周围有的直线的条数\nstruct matrix\n{\n\tdouble a[maxn][maxn];\n\tvoid clear()\n\t{\n\t\tfor (int i=0;i<maxn;i++)\n\t\t{\n\t\t\tfor (int j=0;j<maxn;j++) a[i][j]=0;\n\t\t\ta[i][i]=1;\n\t\t}\n\t}\n\tfriend matrix operator * (const matrix &a,const matrix &b)\n\t{\n\t\tmatrix c;\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tfor (int k=1;k<=tot;k++) c.a[i][k]=0;\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tfor (int k=1;k<=tot;k++)\n\t\t\t\tfor (int j=1;j<=tot;j++) \n\t\t\t\t{\n\t\t\t\t\tc.a[i][k]+=a.a[i][j]*b.a[j][k];\n\t\t\t\t}\n\t\treturn c;\n\t}\n\tvoid sc()\n\t{\n\t\tfor (int i=1;i<=tot;i++)\n\t\t{\n\t\t\tfor (int j=1;j<=tot;j++)\n\t\t\t\tprintf(""%.10lf "",a[i][j]);\n\t\t\tprintf(""\\n"");\n\t\t}\n\t\tprintf(""-----------------\\n"");\n\t}\n} sum[20];\nstruct node\n{\n\tint x,y;\n} a[maxn];\nint F[maxn][maxn],id,vis[maxn*maxn],X,Y;\nbool check_line(node x,node y,node z)\n{\n\treturn (z.x-x.x)*(z.y-y.y)==(z.y-x.y)*(z.x-y.x);\n}\nvector<int> V[maxn*maxn];\ndouble p[maxn],P[maxn];\nint num[1<<20];\n#define lowbit(x) (x&-x)\nvoid work()\n{\n\tfor (int i=0;i<=13;++i) num[1<<i]=i;\n\tY--;\n\tif (!Y)\n\t{\n\t\tfor (int i=1;i<=n;i++) p[i]=0;\n\t\tp[X]=1;\n\t} else\n\t{\n\t\tY=min(Y,128);\n\t\tbool flag=false;\n\t\tfor (;Y;Y^=lowbit(Y)) \n\t\t{\n\t\t\tregister int i=num[lowbit(Y)];\n\t\t\tif (!flag)\n\t\t\t{\n\t\t\t\tflag=true;\n\t\t\t\tfor (int j=1;j<=n;j++) p[j]=sum[i].a[j][X];\n\t\t\t} else\n\t\t\t{\n\t\t\t\tdouble cur=.0;\n\t\t\t\tfor (int j=1;j<=n;j++,cur=.0)\n\t\t\t\t{\n\t\t\t\t\tfor (int k=1;k<=n;k++)\n\t\t\t\t\t\tcur+=sum[i].a[j][k]*p[k];\n\t\t\t\t\tP[j]=cur;\n\t\t\t\t}\n\t\t\t\tswap(p,P);\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans=0.0,sum=0.0;\n\tfor (int i=1;i<=id;i++)\n\t{\n\t\tsum=0.0;\n\t\tfor (int j=0;j<cnt[i];j++) sum+=p[V[i][j]]/(double)cnt[i];\n\t\tans=max(ans,sum);\n\t}\n\tprintf(""%.8f\\n"",ans);\n}\nint main()\n{\n#ifdef ylx\n\tfreopen(""989E.in"",""r"",stdin);\n\tfreopen(""989E.out"",""w"",stdout);\n#endif\n\tn=read();tot=n;\n\tfor (int i=1;i<=n;i++) a[i].x=read(),a[i].y=read();\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (!F[i][j])\n\t\t\t{\n\t\t\t\t++id;\n\t\t\t\tfor (int k=1;k<=n;k++) if (check_line(a[i],a[j],a[k])) V[id].push_back(k),s[k]++;\n\t\t\t\tcnt[id]=V[id].size();\n\t\t\t\tfor (int k=V[id].size()-1;k>=0;--k)\n\t\t\t\t\tfor (int l=V[id].size()-1;l>=0;--l) F[V[id][k]][V[id][l]]=id;\n\t\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (i^j)\n\t\t\t{\n\t\t\t\tsum[0].a[i][j]=1.0/(double)s[i]/cnt[F[i][j]];\n\t\t\t\tif (vis[F[i][j]]!=i)\n\t\t\t\t{\n\t\t\t\t\tvis[F[i][j]]=i;\n\t\t\t\t\tsum[0].a[i][i]+=1.0/s[i]/cnt[F[i][j]];\n\t\t\t\t}\n\t\t\t}\n\t}\n\tfor (int i=1;i<=13;i++) \n\t{\n\t\tsum[i]=sum[i-1]*sum[i-1];\n\t}\n\tT=read();\n\twhile (T--)\n\t{\n\t\tX=read();\n\t\tY=read();\n\t\twork();\n\t}\n\treturn 0;\n}\n//2018年 06月 12日 星期二 19:50:40 CST\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2700
You are at a dueling arena You also possess n Pok mons Initially only the 1 st Pok mon is standing in the arena Each Pok mon has m attributes The j th attribute of the i th Pok mon is a i j Each Pok mon also has a cost to be hired the i th Pok mon s cost is c i You want to have the n th Pok mon stand in the arena To do that you can perform the following two types of operations any number of times in any order Choose three integers i j k 1 le i le n 1 le j le m k 0 increase a i j by k permanently The cost of this operation is k Choose two integers i j 1 le i le n 1 le j le m and hire the i th Pok mon to duel with the current Pok mon in the arena based on the j th attribute The i th Pok mon will win if a i j is the j th attribute of the current Pok mon in the arena otherwise it will lose After the duel only the winner will stand in the arena The cost of this operation is c i Find the minimum cost you need to pay to have the n th Pok mon stand in the arena ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\nll kosz[nax];\nvll wek[nax];\n\nint k;\n\nvector<vector<pll>> graf;\n\nvll odl;\n\nvoid ogarnij()\n{\n\twhile((int)graf.size()<=k)\n\t\tgraf.push_back(vector<pll>(0));\n}\n\nvoid edge(int a, int b, ll w)\n{\n\tgraf[a].push_back({b, w});\n\t//~ debug() << imie(a) << imie(b) << imie(w);\n}\n\nvoid test()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld "", &kosz[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\twek[i].clear();\n\t\tfor (int j=0; j<m; j++)\n\t\t{\n\t\t\tll x;\n\t\t\tscanf(""%lld"", &x);\n\t\t\twek[i].push_back(x);\n\t\t}\n\t}\n\tk=n;\n\tgraf.clear();\n\togarnij();\n\tfor (int i=0; i<m; i++)\n\t{\n\t\tvector<pll> pos;\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tk++;\n\t\t\togarnij();\n\t\t\tedge(j, k, 0);\n\t\t\tedge(k, j, kosz[j]);\n\t\t\tpos.push_back({wek[j][i], k});\n\t\t}\n\t\tsort(pos.begin(), pos.end());\n\t\tfor (int j=1; j<n; j++)\n\t\t{\n\t\t\tedge(pos[j-1].second, pos[j].second, 0);\n\t\t\tedge(pos[j].second, pos[j-1].second, pos[j].first-pos[j-1].first);\n\t\t}\n\t}\n\todl.clear();\n\todl.resize(k+1, -1);\n\tpriority_queue<pll> kol;\n\todl[1]=0;\n\tkol.push({0, 1});\n\twhile(!kol.empty())\n\t{\n\t\tint v=kol.top().second;\n\t\tll w=-kol.top().first;\n\t\tkol.pop();\n\t\tif (odl[v]!=w)\n\t\t\tcontinue;\n\t\tfor (pll i : graf[v])\n\t\t{\n\t\t\tll x=i.second+w;\n\t\t\tif (odl[i.first]!=-1 && odl[i.first]<=x)\n\t\t\t\tcontinue;\n\t\t\todl[i.first]=x;\n\t\t\t//~ if (i.first==n && x==1)\n\t\t\t//~ {\n\t\t\t\t//~ debug() << imie(v) << imie(w) << imie(i);\n\t\t\t\t//~ exit(0);\n\t\t\t//~ }\n\t\t\tkol.push({-x, i.first});\n\t\t}\n\t}\n\tprintf(""%lld\\n"", odl[n]);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2400
Vova plans to go to the conference by train Initially the train is at the point 1 and the destination point of the path is the point L The speed of the train is 1 length unit per minute i e at the first minute the train is at the point 1 at the second minute at the point 2 and so on There are lanterns on the path They are placed at the points with coordinates divisible by v i e the first lantern is at the point v the second is at the point 2v and so on There is also one standing train which occupies all the points from l to r inclusive Vova can see the lantern at the point p if p is divisible by v and there is no standing train at this position p not in l r Thus if the point with the lantern is one of the points covered by the standing train Vova can t see this lantern Your problem is to say the number of lanterns Vova will see during the path Vova plans to go to t different conferences so you should answer t queries ,"['#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for (int i = (a); i >= (b); --i)\n#define REP(i, a) for (int i = 0; i < (a); ++i)\n#define DEBUG(x) { cerr << #x << \'=\' << x << endl; }\n#define Arr(a, l, r) { cerr << #a << "" = {""; FOR(_, l, r) cerr << \' \' << a[_]; cerr << ""}\\n""; }\n#define N 1010100\n#define pp pair<int, int>\n#define endl \'\\n\'\n#define IO ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define taskname """"\n#define bit(S, i) (((S) >> (i)) & 1)\n#define all(s) s.begin(), s.end()\nusing namespace std;\n\nint main() {\n    #ifdef NERO\n    freopen(""test.inp"",""r"",stdin);\n    freopen(""test.out"",""w"",stdout);\n    double stime = clock();\n    #else \n        //freopen(taskname"".inp"",""r"",stdin);\n        //freopen(taskname"".out"",""w"",stdout);\n    #endif //NERO\n    IO;\n    int t;\n    cin >> t;\n    FOR(i, 1, t) {\n    \tint L, v, l, r;\n    \tcin >> L >> v >> l >> r;\n    \tcout << L / v - r / v + (l - 1) / v << endl;\n    }\n    #ifdef NERO\n    double etime = clock();\n    cerr << ""Execution time: "" << (etime - stime) / CLOCKS_PER_SEC * 1000 << "" ms.\\n"";\n    #endif // NERO\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
A is a connected graph which has cycle and self loops Note that a pseudotree It can be shown that a pseudotree with n vertices always contains n edges After deleting all edges on the cycle in the pseudotree a forest dagger will be formed It can be shown that each tree in the forest will contain exactly one vertex which is on cycle before removing the edges If all trees in the forest have the same depth ddagger when picking the vertex on cycle as root we call the original pseudotree Our friend sszcdjr had a flower like pseudotree with n vertices and n edges However he forgot all the edges in the pseudotree Fortunately he still remembers the degrees of vertices Specifically the degree of the i th vertex is d i You have to help sszcdjr construct a possible flower like pseudotree with n vertices where the degree of the i th vertex is d i or tell him that it is impossible dagger A forest is a graph in which all connectivity components are trees A connected graph without cycles and self loops is called a tree ddagger The depth of a tree with a root is the maximum distance from the root to the vertex of this tree ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nint bitparity(ll t){\n\treturn __builtin_parityll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\ntemplate<class t>\nvc<t> presum(const vc<t>&a){\n\tvc<t> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT ã\x81§æ\x95°å\x88\x97ã\x82\x92ç®¡ç\x90\x86ã\x81\x99ã\x82\x8bã\x81¨ã\x81\x8dã\x81«ä½¿ã\x81\x86 (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify ã\x81\x97ã\x81¦ã\x81ªã\x81\x84ã\x82\x84\nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n//ã\x82½ã\x83¼ã\x83\x88ã\x81\x97ã\x81¦ i ç\x95ªç\x9b®ã\x81\x8c idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n//ä¾\x8bã\x81\x88ã\x81° sortidx ã\x81§å¾\x97ã\x81\x9f idx ã\x82\x92ä½¿ã\x81\x88ã\x81°å\x8d\x98ã\x81«ã\x82½ã\x83¼ã\x83\x88å\x88\x97ã\x81«ã\x81ªã\x81£ã\x81¦è¿\x94ã\x81£ã\x81¦ã\x81\x8fã\x82\x8b\n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MAXi(const vc<t>&a){\n\tauto itr=max_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t>\npair<t,int> MINi(const vc<t>&a){\n\tauto itr=min_element(all(a));\n\treturn mp(*itr,itr-a.bg);\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\ntemplate<class S>\nS revv(S s){\n\treverse(all(s));\n\treturn s;\n}\n\npi operator+(pi a,pi b){return pi(a.a+b.a,a.b+b.b);}\n\ntemplate<class t>\nt gpp(vc<t>&vs){\n\tassert(si(vs));\n\tt res=move(vs.back());\n\tvs.pop_back();\n\treturn res;\n}\n\ntemplate<class t>\nvoid pb(vc<t>&a,const vc<t>&b){\n\ta.insert(a.ed,all(b));\n}\n\ntemplate<class t>\nvc<t> cat(vc<t> a,const vc<t>&b){\n\tpb(a,b);\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator+=(vc<t>&a,u x){\n\tfor(auto&v:a)v+=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t> operator+(vc<t> a,u x){\n\treturn a+=x;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-=(vc<t>&a,u x){\n\tfor(auto&v:a)v-=x;\n\treturn a;\n}\n\ntemplate<class t,class u>\nvc<t>& operator-(vc<t> a,u x){\n\treturn a-=x;\n}\n\nbool dbg=false;\n\nvoid slv(){\n\tint n;\n\tif(dbg){\n\t\tn=10;\n\t}else{\n\t\tcin>>n;\n\t}\n\tvi d;\n\tif(dbg){\n\t\td=vi(n,1);\n\t\trep(_,n){\n\t\t\td[rand_int(n)]++;\n\t\t}\n\t}else{\n\t\td=readvi(n);\n\t}\n\tif(SUM(d)!=2*n||MAX(d)>n)return No(0);\n\tvi idx=sortidx(d);\n\tif(count(all(d),2)==n){\n\t\tYes(0);\n\t\trep(i,n){\n\t\t\tprint(i+1,(i+1)%n+1);\n\t\t}\n\t}else{\n\t\tint leaves=count(all(d),1);\n\t\tint head=0;\n\t\tvi q;\n\t\trep(i,leaves)q.pb(0);\n\t\trng(cut,leaves,n-1){\n\t\t\tint inner=cut-leaves;\n\t\t\tint len=inner/(n-cut);\n\t\t\tif(d[idx[cut]]>=3&&q.back()<=len){\n\t\t\t\t//dmp(cut);\n\t\t\t\tvc<pi> ans;\n\t\t\t\tauto ae=[&](int i,int j){\n\t\t\t\t\t//dmp2(i,j);\n\t\t\t\t\tassert(d[i]>0);\n\t\t\t\t\tassert(d[j]>0);\n\t\t\t\t\tans.eb(i,j);\n\t\t\t\t\td[i]--;\n\t\t\t\t\td[j]--;\n\t\t\t\t};\n\t\t\t\trng(i,cut,n){\n\t\t\t\t\tint j=i+1;\n\t\t\t\t\tif(j==n)j=cut;\n\t\t\t\t\tae(idx[i],idx[j]);\n\t\t\t\t}\n\t\t\t\tint s=0;\n\t\t\t\thead=0;\n\t\t\t\tvi root(n,-1),dep(n,-1),tail(n,-1),mx(n,-1),avail;\n\t\t\t\trng(i,cut,n){\n\t\t\t\t\tint v=idx[i];\n\t\t\t\t\troot[v]=v;\n\t\t\t\t\tdep[v]=0;\n\t\t\t\t\ttail[v]=v;\n\t\t\t\t\tmx[v]=0;\n\t\t\t\t\trep(_,d[v])avail.eb(v);\n\t\t\t\t}\n\t\t\t\tgnr(i,leaves,cut+1){\n\t\t\t\t\tif(s+(i-leaves)==len*(n-cut)){\n\t\t\t\t\t\t//dmp(i);\n\t\t\t\t\t\t//dmp(d);\n\t\t\t\t\t\t//dmp(mx);\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint k=i;\n\t\t\t\t\t\t\trng(j,cut,n){\n\t\t\t\t\t\t\t\tint v=idx[j];\n\t\t\t\t\t\t\t\tint tar=len-mx[v];\n\t\t\t\t\t\t\t\tv=tail[v];\n\t\t\t\t\t\t\t\trep(_,tar){\n\t\t\t\t\t\t\t\t\tassert(d[v]>=1);\n\t\t\t\t\t\t\t\t\tint u=idx[--k];\n\t\t\t\t\t\t\t\t\tae(u,v);\n\t\t\t\t\t\t\t\t\tv=u;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tavail.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t\trng(j,leaves,n){\n\t\t\t\t\t\t\tint v=idx[j];\n\t\t\t\t\t\t\trep(_,d[v])avail.pb(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(j,leaves){\n\t\t\t\t\t\t\tint v=idx[j];\n\t\t\t\t\t\t\tassert(si(avail));\n\t\t\t\t\t\t\tae(v,gpp(avail));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tassert(avail.empty());\n\t\t\t\t\t\tassert(si(ans)==n);\n\t\t\t\t\t\tYes(0);\n\t\t\t\t\t\tfor(auto [a,b]:ans){\n\t\t\t\t\t\t\tprint(a+1,b+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tassert(i>leaves);\n\t\t\t\t\tint v=idx[i-1];\n\t\t\t\t\tint u=avail[head++];\n\t\t\t\t\tae(u,v);\n\t\t\t\t\troot[v]=root[u];\n\t\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\t\ttail[root[v]]=v;\n\t\t\t\t\tassert(inc(0,dep[v]-mx[root[v]],1));\n\t\t\t\t\tif(chmax(mx[root[v]],dep[v])){\n\t\t\t\t\t\ts++;\n\t\t\t\t\t}\n\t\t\t\t\trep(_,d[v])avail.pb(v);\n\t\t\t\t}\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\tint v=d[idx[cut]]-1;\n\t\t\thead+=v;\n\t\t\tassert(head<=si(q));\n\t\t\tq.pb(q[head-1]+1);\n\t\t}\n\t\tNo(0);\n\t}\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tif(dbg){\n\t\twhile(1)slv();\n\t}else{\n\t\tint t;cin>>t;rep(_,t)\n\t\tslv();\n\t}\n}\n']","[1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3000
Vasya has n different points A 1 A 2 ldots A n on the plane No three of them lie on the same line He wants to place them in some order A p 1 A p 2 ldots A p n where p 1 p 2 ldots p n some permutation of integers from 1 to n After doing so he will draw oriented polygonal line on these points drawing oriented segments from each point to the next in the chosen order So for all 1 leq i leq n 1 he will draw oriented segment from point A p i to point A p i 1 He wants to make this polygonal line satisfying 2 conditions it will be non self intersecting so any 2 segments which are not neighbors don t have common points it will be Vasya has a string s consisting of n 2 symbols or Let s call an oriented polygonal line if its i th turn left if s i and right if s i More formally i th turn will be in point A p i 1 where oriented segment from point A p i to point A p i 1 changes to oriented segment from point A p i 1 to point A p i 2 Let s define vectors overrightarrow v 1 overrightarrow A p i A p i 1 and overrightarrow v 2 overrightarrow A p i 1 A p i 2 Then if in order to rotate the vector overrightarrow v 1 by the smallest possible angle so that its direction coincides with the direction of the vector overrightarrow v 2 we need to make a turn counterclockwise then we say that i th turn is to the left and otherwise to the right For better understanding look at this pictures with some examples of turns You are given coordinates of the points A 1 A 2 ldots A n on the plane and string s Find a permutation p 1 p 2 ldots p n of the integers from 1 to n such that the polygonal line drawn by Vasya satisfy two necessary conditions ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct Point {\n  int x, y;\n\n  Point operator-(const Point &P) const { return {x-P.x, y-P.y}; }\n  LL CrossProd(const Point &P) const {\n    return (LL)x * P.y - (LL)y * P.x;\n  }\n};\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  string s;\n  int N;\n  cin >> N;\n  vector<Point> pts(N);\n  for (Point &pt : pts) { cin >> pt.x >> pt.y; }\n  cin >> s;\n\n  vector<bool> avail(N, true);\n  int fst = 0;\n  for (int i = 0; i < N; ++i) {\n    if (pts[i].x < pts[fst].x) { fst = i; }\n  }\n\n  VI order{fst};\n  avail[fst] = false;\n\n  for (int step = 0; step < N - 2; ++step) {\n    const bool is_right = s[step] == \'R\';\n    const int last = order.back();\n\n    int cand = 0;\n    while (!avail[cand]) { ++cand; }\n\n    for (int i = cand + 1; i < N; ++i) {\n      if (!avail[i]) { continue; }\n      const bool right = (pts[cand] - pts[last]).CrossProd(pts[i] - pts[last]) > 0;\n      if (is_right == right) {\n        cand = i;\n      }\n    }\n\n    order.PB(cand);\n    avail[cand] = false;\n  }\n\n  int lst = 0;\n  while (!avail[lst]) { ++lst; }\n  order.PB(lst);\n\n  for (int x : order) { cout << x + 1 << "" ""; }\n  cout << ""\\n"";\n}\n\n']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",2600
You are given a sequence A where its elements are either in the form or where x is an integer For such a sequence S where its elements are either in the form or define f S as follows iterate through S s elements from the first one to the last one and maintain a multiset T as you iterate through it for each element if it s in the form add x to T otherwise erase the smallest element from T if T is empty do nothing after iterating through all S s elements compute the sum of all elements in T f S is defined as the sum The sequence b is a subsequence of the sequence a if b can be derived from a by removing zero or more elements without changing the order of the remaining elements For all A s subsequences B compute the sum of f B modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\nconst int MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=505;\n\nint n;\nchar op[MAXN];\nint a[MAXN];\nint dp[MAXN][MAXN];\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\treadint(n);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\top[i]=getchar();\n\t\tif(op[i]==\'+\')readint(a[i]);\n\t\telse getchar();\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(op[i]==\'-\')continue;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;\n\t\tfor(int j=1;j<i;++j)\n\t\t\tfor(int k=0;k<j;++k)\n\t\t\t{\n\t\t\t\tinc(dp[j][k],dp[j-1][k]);\n\t\t\t\tif(op[j]==\'-\')inc(dp[j][max(k-1,0)],dp[j-1][k]);\n\t\t\t\telse if(a[j]<=a[i])inc(dp[j][k+1],dp[j-1][k]);\n\t\t\t\telse inc(dp[j][k],dp[j-1][k]);\n\t\t\t}\n\t\tfor(int k=0;k<i;++k)\n\t\t\tinc(dp[i][k+1],dp[i-1][k]);\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tfor(int k=1;k<j;++k)\n\t\t\t{\n\t\t\t\tinc(dp[j][k],dp[j-1][k]);\n\t\t\t\tif(op[j]==\'-\')k>1?inc(dp[j][k-1],dp[j-1][k]):void(0);\n\t\t\t\telse if(a[j]<a[i])inc(dp[j][k+1],dp[j-1][k]);\n\t\t\t\telse inc(dp[j][k],dp[j-1][k]);\n\t\t\t}\n\t\tint sum=0;\n\t\tfor(int k=1;k<=n;++k)inc(sum,dp[n][k]);\n\t\tinc(res,1ll*a[i]*sum%MOD);\n\t}\n\tprintf(""%d\\n"",res);\n\treturn 0;\n}\n']","[0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2200
Find the minimum number with the given sum of digits s such that digits in it are distinct i e all digits are unique For example if s 20 then the answer is 389 This is the minimum number in which all digits are different and the sum of the digits is 20 3 8 9 20 For the given s print the required number ,"[""/*\nDiv 3, I literally don't care edition\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,a[N],d[N];\nvoid solo()\n{\n   cin>>n;\n   vector<ll> s;\n   ll k=9;\n   while (n!=0){\n       if (n<=k) k=n;\n       s.pb(k);\n       n-=k;\n       k--;\n   }\n   reb(i,s.size()-1,0) cout<<s[i];\n}\nint main()\n{\n   ios_base::sync_with_stdio(0);\n   cin.tie(0);\n   cout.tie(0);\n   ll ts=1;\n   cin>>ts;\n   while (ts--){\n       solo();\n       cout<<endl;\n   }\n}""]","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Bersoft company is working on a new version of its most popular text editor Bord 2010 Bord like many other text editors should be able to print out multipage documents A user keys a sequence of the document page numbers that he wants to print out separates them with a comma without spaces Your task is to write a part of the program responsible for standardization of this sequence Your program gets the sequence keyed by the user as input The program should output this sequence in format where for all from to and The new sequence should contain all the page numbers keyed by the user and nothing else If some page number appears in the input sequence several times its appearances starting from the second one should be ignored If for some element from the new sequence this element should be output as and not as For example sequence should be output as ,"['#include<cstdio>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<list>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<string>\n#include<ctime>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair <int,int> ii;\n#define sz(a) int((a).size())\n#define pb push_back\nconst int INF = 2147483647;\nconst double PI = 3.141592653589793;\n\nset <int> zbior;\nset<int>::iterator it;\nstring s;\nchar t[1000000];\nint last,pocz,i,a;\nbool bylo;\n\nint main () {\nscanf (""%s"",&t); s=t;\ni=0;\nzbior.clear();\nwhile (i<s.size()) {\n      a=0;\n      while (i<s.size() && s[i]!=\',\') {\n            a= a*10 + int(s[i])-48;\n            i++;\n      }\n      zbior.insert(a);\n      i++;\n}\nlast = -10; \nbylo=false;\nfor (it=zbior.begin();it!=zbior.end();it++) {\n    if (last < 0) {last = pocz = *it;}\n    else if (*it!=last+1) {\n         if (bylo) printf("",""); else bylo=true;\n         if (pocz==last) printf(""%d"",pocz); else printf(""%d-%d"",pocz,last);\n         pocz = *it;\n    }\n    last = *it;\n}\nif (bylo) printf("",""); else bylo=true;\nif (pocz==last) printf(""%d"",pocz); else printf(""%d-%d"",pocz,last);\nprintf(""\\n"");\n      \n\nreturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1300
There are n heaps of stone The i th heap has h i stones You want to change the number of stones in the heap by performing the following process once You go through the heaps from the 3 rd heap to the n th heap in this order Let i be the number of the current heap You can choose a number d 0 le 3 cdot d le h i move d stones from the i th heap to the i 1 th heap and 2 cdot d stones from the i th heap to the i 2 th heap So after that h i is decreased by 3 cdot d h i 1 is increased by d and h i 2 is increased by 2 cdot d You can choose different or same d for different operations Some heaps may become empty but they still count as heaps What is the maximum number of stones in the smallest heap after the process ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n; cin >> n;\n\t\tvector<int> a(n), b(n);\n\t\tfor (int i = 0; i < n; i++) cin >> a[i];\n\t\tint l = 0, r = 1e9, ans = 0;\n\t\twhile (l <= r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tfor (int i = 0; i < n; i++) b[i] = 0;\n\t\t\tint ok = 1;\n\t\t\tfor (int i = n - 1; i >= 2; i--) {\n\t\t\t\tif (a[i] + b[i] < mid) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint can = min(a[i] / 3, (a[i] + b[i] - mid) / 3);\n\t\t\t\tb[i - 2] += can * 2; b[i - 1] += can;\n\t\t\t}\n\t\t\tif (ok && a[0] + b[0] >= mid && a[1] + b[1] >= mid) ans = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Filip has a row of cells some of which are blocked and some are empty He wants all empty cells to have water in them He has two actions at his disposal 1 place water in an empty cell 2 remove water from a cell and place it in any other empty cell If at some moment cell i 2 le i le n 1 is empty and both cells i 1 and i 1 contains water then it becomes filled with water Find the minimum number of times he needs to perform action 1 in order to fill all empty cells with water Note that you don t need to minimize the use of action 2 Note that blocked cells neither contain water nor can Filip place water in them ,"['#include <bits/stdc++.h>\n/*\nstruct Fenwick{\n\tint C[100005];\n\tinline int lowbit(int x){\n\t\treturn x & -x;\n\t}\n\tinline int ask(int x);\n\tinline void update(int x, int y);\n};\n*/\n\n//Fenwick tree above\n\n/*\nconst int mod = 998244353, g = 3, gi = 332748118;\ninline int mul(int x, int y){\n\treturn (int)(1ll * x * y % (1ll * mod));\n}\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\ninline int minus(int x, int y){\n\treturn x < y ? x - y + mod : x - y;\n}\ninline int Qpow(int x, int y){\n\tint r = 1;\n\twhile(y){\n\t\tif(y & 1) r = mul(r, x);\n\t\tx = mul(x, x);\n\t\ty >>= 1;\n\t}\n\treturn r;\n}\nvoid ntt(int *A, int limit, int on){\n\tint rev[limit];\n\tmemset(rev, 0, sizeof(int) * limit);\n\tfor(int i = 1; i < limit; ++i)\n\t\trev[i] = (rev[i >> 1] >> 1) + (i & 1) * (limit >> 1);\n\tfor(int i = 0; i < limit; ++i)\n\t\tif(i < rev[i]) std::swap(A[i], A[rev[i]]);\n\tfor(int i = 2; i <= limit; i <<= 1){\n\t\tint t;\n\t\tif(on == 1) t = Qpow(g, (mod - 1) / i);\n\t\telse t = Qpow(gi, (mod - 1) / i);\n\t\tfor(int j = 0; j < limit; j += i){\n\t\t\tint r = 1;\n\t\t\tfor(int k = j; k < j + i / 2; ++k, r = mul(r, t)){\n\t\t\t\tint u = A[k], v = mul(A[k + i / 2], r);\n\t\t\t\tA[k] = add(u, v);\n\t\t\t\tA[k + i / 2] = minus(u, v);\n\t\t\t}\n\t\t}\n\t}\n\tif(on == -1){\n\t\tint uu = Qpow(limit, mod - 2);\n\t\tfor(int i = 0; i < limit; ++i) A[i] = mul(A[i], uu);\n\t}\n\treturn ;\n}\n*/\n\n//mod int above\ninline int read(){\n\tchar c = getchar();\n\tint x = 0;\n\twhile(c < \'0\' || c > \'9\') c = getchar();\n\twhile(c >= \'0\' && c <= \'9\') x = x * 10 + c - \'0\', c = getchar();\n\treturn x;\n}\nint ans, n, a[105], cnt = 0;\nchar s[105];\nvoid solve(){\n\tscanf(""%d%s"", &n, s + 1);\n\tcnt = 0; ans = 0;\n\tfor(int i = 1, j; i <= n; i = j + 1){\n\t\tj = i; if(s[j] == \'#\') continue;\n\t\twhile(j < n && s[j + 1] == \'.\') ++j;\n\t\ta[++cnt] = j - i + 1; \n\t}\n\tint yes = 0;\n\tfor(int i = 1; i <= cnt; ++i) if(a[i] >= 3) yes = 1;\n\tif(yes) printf(""2\\n"");\n\telse {\n\t\tfor(int i = 1; i <= cnt; ++i) ans += a[i];\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn ;\n}\nint main(){\n\tint T = 1;\n\tscanf(""%d"", &T);\n\twhile(T--) solve();\n\treturn 0;\n}\n\n\n\n']","[1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
Valera is a collector Once he wanted to expand his collection with exactly one antique item Valera knows sellers of antiques the th of them auctioned items Currently the auction price of the th object of the th seller is Valera gets on well with each of the sellers He is perfectly sure that if he outbids the current price of one of the items in the auction in other words offers the seller the money that is strictly greater than the current price of the item at the auction the seller of the object will immediately sign a contract with him Unfortunately Valera has only units of money Help him to determine which of the sellers he can make a deal with ,"['/* ***********************************************\nAuthor        :kuangbin\nCreated Time  :2014/6/8 23:29:30\nFile Name     :E:\\2014ACM\\Codeforces\\CF252\\A.cpp\n************************************************ */\n\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <math.h>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\nint a[100];\n\nint main()\n{\n    //freopen(""in.txt"",""r"",stdin);\n    //freopen(""out.txt"",""w"",stdout);\n    int n,v;\n\twhile(scanf(""%d%d"",&n,&v) == 2)\n\t{\n\t\tvector<int>ans;\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tint k;\n\t\t\tscanf(""%d"",&k);\n\t\t\tfor(int j = 0;j < k;j++)scanf(""%d"",&a[j]);\n\t\t\tfor(int j = 0;j < k;j++)\n\t\t\t\tif(a[j] < v)\n\t\t\t\t{\n\t\t\t\t\tans.push_back(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tint sz = ans.size();\n\t\tprintf(""%d\\n"",sz);\n\t\tfor(int i = 0;i < sz;i++)\n\t\t{\n\t\t\tprintf(""%d"",ans[i]);\n\t\t\tif(i < sz-1)printf("" "");\n\t\t\telse printf(""\\n"");\n\t\t}\n\t}\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
You are given an undirected connected graph consisting of n vertices and m edges k vertices of this graph are special You have to direct each edge of this graph or leave it undirected If you leave the i th edge undirected you pay w i coins and if you direct it you don t have to pay for it Let s call a vertex if it is reachable from each special vertex along the edges of the graph if an edge is undirected it can be traversed in both directions After you direct the edges of the graph possibly leaving some of them undirected you receive c i coins for each saturated vertex i Thus your total profit can be calculated as sum limits i in S c i sum limits j in U w j where S is the set of saturated vertices and U is the set of edges you leave undirected For each vertex i calculate the maximum possible profit you can get if you have to make the vertex i saturated ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 300300;\nint n, m, k;\nvector<int> g[N];\nvector<pii> G[N];\nint cntSpec[N];\nll sumVal[N];\nint h[N];\nint minH[N];\nint root;\nint ed[N][3];\nbool isBridge[N];\nint myComp[N];\nll val[N];\nmap<pii, ll> dp;\nint deg[N];\nll ans[N];\nint q[2 * N];\nint topQ;\n\nint getOther(int id, int v) {\n\treturn ed[id][0] ^ ed[id][1] ^ v;\n}\n\nvoid dfs1(int v) {\n//\teprintf(""dfs1 %d %d\\n"", v, h[v]);\n\tminH[v] = h[v];\n\tfor (int id : g[v]) {\n\t\tint u = getOther(id, v);\n\t\tif (h[u] != -1) {\n\t\t\tif (h[u] != h[v] - 1)\n\t\t\t\tminH[v] = min(minH[v], h[u]);\n\t\t\tcontinue;\n\t\t}\n\t\th[u] = h[v] + 1;\n\t\tdfs1(u);\n\t\tcntSpec[v] += cntSpec[u];\n//\t\tsumVal[v] += sumVal[u];\n\t\tminH[v] = min(minH[v], minH[u]);\n\t\tif (minH[u] > h[v] && cntSpec[u] > 0) {\n\t\t\tisBridge[id] = 1;\n\t\t}\n\t}\n}\nvoid dfsComp(int v) {\n\tmyComp[v] = k;\n\tval[k] += sumVal[v];\n\tfor (int id : g[v]) {\n\t\tif (isBridge[id]) continue;\n\t\tint u = getOther(id, v);\n\t\tif (myComp[u] == -1)\n\t\t\tdfsComp(u);\n\t}\n}\n\nvoid solve(int v) {\n\tif (deg[v] == 1) {\n\t\tpii u = mp(-1, -1);\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(v, w))) {\n\t\t\t\tsum += dp[mp(v, w)];\n\t\t\t} else {\n\t\t\t\tu = e;\n\t\t\t}\n\t\t}\n\t\tif (u.first != -1) {\n\t\t\tint w = u.first;\n\t\t\tsum = max(0LL, sum - u.second);\n\t\t\tdp[mp(w, v)] = sum;\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else if (deg[v] == 0) {\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tsum += dp[mp(v, w)];\n\t\t}\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(w, v))) continue;\n\t\t\tdp[mp(w, v)] = max(0LL, sum - dp[mp(v, w)] - e.second);\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else throw;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d%d"", &n, &m, &k);\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tx--;\n\t\troot = x;\n\t\tcntSpec[x]++;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%lld"", &sumVal[i]);\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(""%d"", &ed[i][2]);\n\tfor (int i = 0; i < m; i++) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\ted[i][0] = v;\n\t\ted[i][1] = u;\n\t\tg[v].push_back(i);\n\t\tg[u].push_back(i);\n\t}\n\tk = 0;\n\tfor (int i = 0; i < n; i++)\n\t\th[i] = -1;\n\th[root] = 0;\n\tdfs1(root);\n\t/*\n\tfor (int i = 0; i < m; i++)\n\t\teprintf(""%d"", (int)isBridge[i]);\n\teprintf(""\\n"");\n\t*/\n\tfor (int v = 0; v < n; v++)\n\t\tmyComp[v] = -1;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (myComp[v] != -1) continue;\n\t\tdfsComp(v);\n\t\tk++;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!isBridge[i]) continue;\n\t\tint v = myComp[ed[i][0]], u = myComp[ed[i][1]];\n\t\tassert(v != u);\n\t\tG[v].push_back(mp(u, ed[i][2]));\n\t\tG[u].push_back(mp(v, ed[i][2]));\n\t}\n\n\tif (k == 1) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(""%lld "", val[0]);\n\t\tprintf(""\\n"");\n\t\treturn 0;\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tdeg[v] = (int)G[v].size();\n\t\tif (deg[v] <= 1) q[topQ++] = v;\n\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tsolve(q[i]);\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tans[v] = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint u = e.first;\n\t\t\tans[v] += dp[mp(v, u)];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%lld "", ans[myComp[i]]);\n\tprintf(""\\n"");\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2800
In Byteland there are two political parties fighting for seats in the Parliament in the upcoming elections and As they want to convince as many citizens as possible to cast their votes on them they keep promising lower and lower taxes There are n cities in Byteland connected by m one way roads Interestingly enough the road network has no cycles it s impossible to start in any city follow a number of roads and return to that city Last year citizens of the i th city had to pay h i bourles of tax Parties will now alternately hold the election conventions in various cities If a party holds a convention in city v the party needs to the taxes in this city to a non negative integer amount of bourles However at the same time they can arbitrarily modify the taxes in each of the cities that can be reached from v using a single road The only condition that must be fulfilled that the tax in each city has to remain a non negative integer amount of bourles The first party to hold the convention is It s predicted that the party to hold the last convention will win the election Can win regardless of s moves ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nvector<int> g[N];\nint ord[N];\nint ordSz;\nbool used[N];\nint n, m;\nint a[N];\nint b[N];\nint c[N];\nbool mex[N];\n\nvoid dfs(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v]) {\n\t\tif (used[u]) continue;\n\t\tdfs(u);\n\t}\n\tord[ordSz++] = v;\n}\n\nvoid printAns(int v) {\n\ta[v] ^= c[b[v]];\n\tc[b[v]] = 0;\n\tfor (int u : g[v]) {\n\t\ta[u] ^= c[b[u]];\n\t\tc[b[u]] = 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%d "", a[i]);\n\tprintf(""\\n"");\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (used[i]) continue;\n\t\tdfs(i);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = ord[i];\n\t\tfor (int j = 0; j <= (int)g[v].size(); j++)\n\t\t\tmex[j] = 0;\n\t\tfor (int u : g[v])\n\t\t\tmex[b[u]] = 1;\n\t\tb[v] = 0;\n\t\twhile(mex[b[v]]) b[v]++;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tc[b[i]] ^= a[i];\n\tint mx = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (c[i] != 0)\n\t\t\tmx = i;\n\t}\n\tif (mx == -1) {\n\t\tprintf(""LOSE\\n"");\n\t\treturn 0;\n\t}\n\tprintf(""WIN\\n"");\n\tfor (int v = 0; v < n; v++) {\n\t\tif (b[v] != mx) continue;\n\t\tif ((a[v] ^ c[mx]) > a[v]) continue;\n\t\tprintAns(v);\n\t\treturn 0;\n\t}\n\tthrow;\n\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3200
Vasya has got a robot which is situated on an infinite Cartesian plane initially in the cell 0 0 Robot can perform the following four kinds of operations move from x y to x y 1 move from x y to x y 1 move from x y to x 1 y move from x y to x 1 y Vasya also has got a sequence of n operations Vasya wants to modify this sequence so after performing it the robot will end up in x y Vasya wants to change the sequence so the length of changed subsegment is minimum possible This length can be calculated as follows maxID minID 1 where maxID is the maximum index of a changed operation and minID is the minimum index of a changed operation For example if Vasya changes to then the operations with indices 2 5 and 7 are changed so the length of changed subsegment is 7 2 1 6 Another example if Vasya changes to then the length of changed subsegment is 1 Help Vasya Tell him the minimum length of subsegment that he needs to change so that the robot will go from 0 0 to x y or tell him that it s impossible ,"['#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool can(int x, int y, int n) {\n  x = abs(x);\n  y = abs(y);\n  return (x + y) % 2 == n % 2 && x + y <= n;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  int x, y;\n  cin >> x >> y;\n  if (!can(x, y, n)) {\n    cout << ""-1"" << endl;\n    return 0;\n  }\n  int r = n;\n  int l = -1;\n  while (r - l > 1) {\n    int m = (l + r) / 2;\n    int lx = 0;\n    int ly = 0;\n    int rx = 0;\n    int ry = 0;\n    for (int i = m; i < n; i++) {\n      if (s[i] == \'U\') ry++;\n      if (s[i] == \'D\') ry--;\n      if (s[i] == \'L\') rx--;\n      if (s[i] == \'R\') rx++;\n    }\n    bool ok = false;\n    for (int i = 0; i + m <= n; i++) {\n      ok |= can(x - lx - rx, y - ly - ry, m);\n      if (s[i] == \'U\') ly++;\n      if (s[i] == \'D\') ly--;\n      if (s[i] == \'L\') lx--;\n      if (s[i] == \'R\') lx++;\n      if (i + m < n) {\n        if (s[i+m] == \'U\') ly--;\n        if (s[i+m] == \'D\') ly++;\n        if (s[i+m] == \'L\') lx++;\n        if (s[i+m] == \'R\') lx--;\n      }\n    }\n    if (ok) {\n      r = m;\n    } else {\n      l = m;\n    }\n  }\n  cout << r << endl;\n}\n\n']","[0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1800
There is a board with a grid consisting of rows and columns the rows are numbered from from top to bottom and the columns are numbered from from left to right In this grid we will denote the cell that lies on row number and column number as A group of six numbers where is a and there is a set of cells that are assigned to it Cell belongs to this set if of two conditions are fulfilled and and Your task is to find the number of different groups of six numbers that determine the crosses of an area equal to which are placed entirely on the grid The cross is placed entirely on the grid if any of its cells is in the range of the grid that is for each cell of the cross holds The area of the cross is the number of cells it has ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,m,s;\nint main()\n{\n    while(~scanf(""%d %d %d"",&n,&m,&s))\n    {\n        long long ans=0;\n        for(int a=0;a<n;a++)\n        for(int b=0;b<m;b++)\n        for(int c=0;c<n;c++)\n        {\n            int cao=(2*a+1)*(2*b+1)-(2*min(a,c)+1)*(2*b+1);\n            cao=s-cao;\n            if(cao>0&&cao%(2*c+1)==0)\n            {\n                int d=cao/(2*c+1);\n                d--;\n                if(d>=0&&d%2==0)\n                {\n                    d/=2;\n                    if(b<=d)\n                    {\n                        int xr=n-max(a,c);\n                        int xl=1+max(a,c);\n                        int yr=m-max(b,d);\n                        int yl=1+max(b,d);\n                        if(xr>=xl&&yr>=yl)\n                        ans+=(xr-xl+1)*(yr-yl+1);\n                    }\n                }\n            }\n            cao=(2*a+1)*(2*b+1);\n            if(c==min(a,c))\n            {\n                if(cao==s)\n                {\n                        int xr=n-max(a,c);\n                        int xl=1+max(a,c);\n                        int yr=m-b;\n                        int yl=1+b;\n                        if(xr>=xl&&yr>=yl)\n                        ans+=(long long)(xr-xl+1)*(yr-yl+1)*b;\n                }\n            }\n            else\n            {\n                cao=s-cao;\n                if(cao>=0&&cao%(2*c-2*a)==0)\n                {\n                    cao/=2*(c-a);\n                    cao--;\n                    if(cao>=0&&cao%2==0)\n                    {\n                        int d=cao/2;\n                        if(d<b)\n                        {\n                            int xr=n-max(a,c);\n                            int xl=1+max(a,c);\n                            int yr=m-max(b,d);\n                            int yl=1+max(b,d);\n                            if(xr>=xl&&yr>=yl)\n                            ans+=(xr-xl+1)*(yr-yl+1);\n                        }\n                    }\n                }\n            }\n        }\n        printf(""%I64d\\n"",ans);\n    }\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
You are given numbers You can perform at most operations For each operation you can multiply one of the numbers by We want to make as large as possible where denotes the bitwise OR Find the maximum possible value of after performing at most operations optimally ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef long long ll;\n\nconst int N = 200100;\nll a[N];\nll b[N];\nll c[N];\nll x;\nint k;\nint n;\n\nint main()\n{\n    scanf(""%d%d%lld"", &n, &k, &x);\n    ll y = 1;\n    for (int i = 0; i < k; i++)\n        y *= x;\n    for (int i = 0; i < n; i++)\n        scanf(""%lld"", &a[i]);\n    b[0] = 0;\n    for (int i = 0; i < n; i++)\n        b[i + 1] = b[i] | a[i];\n    c[n] = 0;\n    for (int i = n - 1; i >= 0; i--)\n        c[i] = c[i + 1] | a[i];\n    ll ans = 0;\n    for (int i = 0; i < n; i++)\n    {\n        ans = max(ans, b[i] | c[i + 1] | (a[i] * y));\n    }\n    printf(""%lld\\n"", ans);\n\n    return 0;\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
You should process queries over a set of strings Each query is one of three kinds Add a string to the set It is guaranteed that the string was not added before Delete a string from the set It is guaranteed that the string is in the set For the given string find the number of occurrences of the strings from the set If some string from has several occurrences in you should count all of them Note that you should solve the problem in mode It means that you can t read the whole input at once You can read each query only after writing the answer for the last query of the third type Use functions in and in languages after each writing in your program ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 300010;\n\nconst int MAGIC = 500;\n\nconst int LONGS = N / MAGIC + 10;\n\nchar foo[N];\n\nstring s[LONGS]; \nint cost[LONGS];\n\nint a[N][29];\nint value[N];\nint p[N];\n\nint main() {\n  int tt;\n  scanf(""%d"", &tt);\n  int n = 1;\n  int cnt = 0;\n  while (tt--) {\n    int type;\n    scanf(""%d %s"", &type, foo);\n    int len = strlen(foo);\n    if (type == 1 || type == 2) {\n      if (len <= MAGIC) {\n        int t = 1;\n        for (int j = 0; j < len; j++) {\n          int c = foo[j] - \'a\';\n          if (a[t][c] == 0) {\n            a[t][c] = ++n;\n          }\n          t = a[t][c];\n        }\n        value[t] += 3 - 2 * type;\n      } else {\n        s[cnt] = """";\n        for (int j = 0; j < len; j++) {\n          s[cnt] += foo[j];\n        }\n        s[cnt] += ""{"";\n        cost[cnt] = 3 - 2 * type;\n        cnt++;\n      }\n    } else {\n      long long ans = 0;\n      for (int j = 0; j < len; j++) {\n        int t = 1;\n        for (int k = j; k < len; k++) {\n          int c = foo[k] - \'a\';\n          if (a[t][c] == 0) {\n            break;\n          }\n          t = a[t][c];\n          ans += value[t];\n        }\n      }\n      for (int id = 0; id < cnt; id++) {\n        int long_len = s[id].length();\n        long_len--;\n        if (long_len > len) {\n          continue;\n        }\n        int k = 0;\n        p[1] = 0;\n        for (int i = 2; i <= long_len; i++) {\n          while (k > 0 && s[id][i - 1] != s[id][k]) {\n            k = p[k];\n          }\n          if (s[id][i - 1] == s[id][k]) {\n            k++;\n          }\n          p[i] = k;\n        }\n        k = 0;\n        for (int i = 1; i <= len; i++) {\n          while (k > 0 && foo[i - 1] != s[id][k]) {\n            k = p[k];\n          }\n          if (foo[i - 1] == s[id][k]) {\n            k++;\n          }\n          if (k == long_len) {\n            ans += cost[id];\n          }\n        }\n      }\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2400
For an array a a 1 a 2 dots a n let s denote its a l r as the array a l a l 1 dots a r For example the array a 1 3 1 has 6 non empty subarrays a 1 1 1 a 1 2 1 3 a 1 3 1 3 1 a 2 2 3 a 2 3 3 1 a 3 3 1 You are given two integers n and k Construct an array a consisting of n integers such that all elements of a are from 1000 to 1000 a has exactly k subarrays with positive sums the rest dfrac n 1 cdot n 2 k subarrays of a have negative sums ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    int x = 0;\n    while ((x + 1) * (x + 2) / 2 <= k) {\n        x += 1;\n    }\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        if (i < x) {\n            a[i] = 2;\n        } else if (i == x) {\n            a[i] = -2 * x - 1 + 2 * (k - x * (x + 1) / 2);\n        } else {\n            a[i] = -1000;\n        }\n        std::cout << a[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Consider a number axis The capital of your empire is initially at 0 There are n unconquered kingdoms at positions 0 x 1 x 2 ldots x n You want to conquer all other kingdoms There are two actions available to you You can change the location of your capital let its current position be c 1 to any other kingdom let its position be c 2 at a cost of a cdot c 1 c 2 From the current capital let its current position be c 1 you can conquer an unconquered kingdom let its position be c 2 at a cost of b cdot c 1 c 2 You conquer a kingdom if there is an unconquered kingdom between the target and your capital Note that you place the capital at a point without a kingdom In other words at any point your capital can only be at 0 or one of x 1 x 2 ldots x n Also note that conquering a kingdom does not change the position of your capital Find the minimum total cost to conquer all kingdoms Your capital can be anywhere at the end ,"['#include<iostream>\nusing namespace std;\nint a[200010];\nlong long sum[200010];\nint main() {\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>T;\n\twhile(T--) {\n\t\tint n,x,y;\n\t\tcin>>n>>x>>y;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tcin>>a[i];\n\t\t\tsum[i]=sum[i-1]+a[i];\n\t\t}\n\t\tlong long ans=1e18,s=0;\n\t\tfor(int i=0; i<=n; i++) {\n\t\t\tif(i) {\n\t\t\t\ts+=a[i]-a[i-1];\n\t\t\t}\n\t\t\tans=min(ans,(long long)x*a[i]+y*(sum[n]-sum[i]-(long long)a[i]*(n-i)+s));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n']","[1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Li Hua has a tree of n vertices and n 1 edges The vertices are numbered from 1 to n A pair of vertices u v u v is considered if of the following two statements is true u is the vertex with the minimum index among all vertices on the path u v v is the vertex with the maximum index among all vertices on the path u v There will be m operations In each operation he decides an integer k j then inserts a vertex numbered n j to the tree connecting with the vertex numbered k j He wants to calculate the number of pairs before operations and after each operation Suppose you were Li Hua please solve this problem ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nint n,m;\nvector<int> Emx[1000005],Emn[1000005],E[1000005];\nint fa[1000005],famx[1000005],famn[1000005];\nint getfa(int x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}\n\ntemplate<int MAXN>struct BIT{\n\tint c[MAXN+5];\n\tint N;\n\tvoid init(int _N=0){\n\t\tN=_N;\n\t\tfor(int i=0;i<=N;++i)\n\t\t\tc[i]=0;\n\t}\n\tint lowbit(int x){return x&(-x);}\n\tvoid add(int x,int k){\n\t\tfor(;x<=N;x+=lowbit(x))\n\t\t\tc[x]+=k;\n\t}\n\tint query(int x){\n\t\tint ret=0;\n\t\tfor(;x;x-=lowbit(x))\n\t\t\tret+=c[x];\n\t\treturn ret;\n\t}\n};\n\nBIT<1000000> bit;\nint dep1[1000005],dep2[1000005],dfn[1000005],sz[1000005],dcnt;\nll A,B,C,ans;\nvoid dfs1(int x){\n\tdfn[x]=++dcnt;\n\tsz[x]=1;\n\tdep1[x]=dep1[famx[x]]+1;\n\tB+=dep1[x]-1;\n\tfor(int y:Emx[x]){\n\t\tdfs1(y);\n\t\tsz[x]+=sz[y];\n\t}\n}\n\nvoid dfs2(int x){\n\tdep2[x]=dep2[famn[x]]+1;\n\tA+=dep2[x]-1;\n\tC+=bit.query(dfn[x]+sz[x]-1)-bit.query(dfn[x]-1);\n\tbit.add(dfn[x],1);\n\tfor(int y:Emn[x])\n\t\tdfs2(y);\n\tbit.add(dfn[x],-1);\n}\n\n\nint main(){\n\tscanf(""%d"",&n);\n\tfor(int i=1;i<n;++i){\n\t\tint ui,vi;\n\t\tscanf(""%d %d"",&ui,&vi);\n\t\tE[ui].push_back(vi);\n\t\tE[vi].push_back(ui);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tsort(E[i].begin(),E[i].end());\n\tfor(int i=1;i<=n;++i)\n\t\tfa[i]=i;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j:E[i]){\n\t\t\tif(j>i)\n\t\t\t\tcontinue;\n\t\t\tj=getfa(j);\n\t\t\tfa[getfa(j)]=getfa(i);\n\t\t\tfamx[j]=i;\n\t\t\tEmx[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfa[i]=i;\n\tfor(int i=n;i>=1;--i){\n\t\tfor(int j:E[i]){\n\t\t\tif(j<i)\n\t\t\t\tcontinue;\n\t\t\tj=getfa(j);\n\t\t\tfa[getfa(j)]=getfa(i);\n\t\t\tfamn[j]=i;\n\t\t\tEmn[i].push_back(j);\n\t\t}\n\t}\n\tbit.init(n);\n\tdfs1(n);\n\tdfs2(1);\n\tans=A+B-2*C;\n\tprintf(""%lld\\n"",ans);\n\tscanf(""%d"",&m);\n\twhile(m--){\n\t\tint k;\n\t\tscanf(""%d"",&k);\n\t\tdep2[++n]=dep2[k]+1;\n\t\tans+=n-dep2[n];\n\t\tprintf(""%lld\\n"",ans);\n\t}\n}']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0]",3000
Famil Door s City map looks like a tree undirected connected acyclic graph so other people call it Treeland There are intersections in the city connected by bidirectional roads There are friends of Famil Door living in the city The th friend lives at the intersection and works at the intersection Everyone in the city is unhappy because there is exactly one simple path between their home and work Famil Door plans to construct exactly one new road and he will randomly choose one among possibilities Note that he may even build a new road between two cities that are already connected by one He knows that each of his friends will become happy if after Famil Door constructs a new road there is a path from this friend home to work and back that doesn t visit the same road twice Formally there is a simple cycle containing both and Moreover if the friend becomes happy his pleasure is equal to the length of such path it s easy to see that it s unique For each of his friends Famil Door wants to know his expected pleasure that is the expected length of the cycle containing both and if we consider only cases when such a cycle exists ,"['#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <math.h>\n#include <string>\n#include <string.h>\n#include <iostream>\nusing namespace std;\n#define fi ""input.txt""\n#define fo ""output.txt""\n#define fileopen freopen(fi,""r"",stdin);freopen(fo,""w"",stdout)\n#define FOR(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define FORD(i,l,r) for(int i=(int)(l);i>=(int)(r);i--)\n#define xy pair<int,int>\n#define int64 long long\n#define X first\n#define Y second\n#define pb push_back\n#define init(a,v) memset(a,v,sizeof(a))\n#define Sz(s) (int)(s.size())\n#define EL printf(""\\n"")\n#define digit(x) (\'0\'<=x&&x<=\'9\')\n#define forever while (true)\n#define ld long double\n\nconst int OO = (int) 2e9;\nconst int MOD = (int) 1e9+7;\nconst double Pi = 3.141592653589793;\nconst int N = (int) 1e5+5;\n\nint64 all[N],sub[N],all1=0;\nint s[N],h[N],P[N][18],n,q;\nvector<int> g[N];\n\nvoid dfs(int u,int p) {\n    int v=0;h[u]=h[p]+1;s[u]=1;P[u][0]=p;\n    FOR(i,0,Sz(g[u])-1) {\n        v=g[u][i];if (v==p) continue;\n        dfs(v,u);s[u]+=s[v];\n        sub[u]+=sub[v]+s[v];\n    }\n}\n\nvoid dfs2(int u,int p,int64 x) {\n    int v=0;all[u]=x;\n    FOR(i,0,Sz(g[u])-1) {\n        v=g[u][i];if (v==p) continue;\n        dfs2(v,u,x-s[v]+n-s[v]);\n    }\n}\n\nint LCA(int u,int v) {\n    if (h[u]<h[v]) swap(u,v);\n    FORD(i,17,0) if (h[P[u][i]]>=h[v]) u=P[u][i];\n    if (u==v) return u;\n    FORD(i,17,0) if (P[u][i]!=P[v][i]) u=P[u][i],v=P[v][i];\n    return P[u][0];\n}\n\nint dis(int u,int v,int p) {return h[u]+h[v]-2*h[p];}\n\nint child(int u,int p) {\n    FORD(i,17,0) if (h[P[u][i]]>h[p]) u=P[u][i];\n    return u;\n}\n\ndouble query(int u,int v) {\n    int64 sum,num;int p=LCA(u,v),ch;\n    if (h[u]<h[v]) swap(u,v);\n    if (p!=v) {\n        num=1LL*s[u]*s[v];\n        sum=sub[u]*s[v]+sub[v]*s[u]+1LL*num*(dis(u,v,p)+1);\n    } else {\n        ch=child(u,v);\n        num=1LL*s[u]*(n-s[ch]);\n        sum=sub[u]*(n-s[ch])+(all[v]-sub[ch]-s[ch])*s[u]+1LL*num*(dis(u,v,p)+1);\n    }\n    return 1.0*sum/num;\n}\n\nint main() {\n    cin>>n>>q;\n    int u,v;\n    FOR(i,1,n-1) {\n        cin>>u>>v;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n    dfs(1,0);\n    FOR(i,2,n) all1+=h[i]-h[1];\n    dfs2(1,0,all1);\n    FOR(j,1,17) FOR(i,1,n) P[i][j]=P[P[i][j-1]][j-1];\n    while (q--) {\n        cin>>u>>v;\n        double db=query(u,v);\n        printf(""%.8lf\\n"",db);\n    }\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0]",2300
Shaass has decided to hunt some birds There are horizontal electricity wires aligned parallel to each other Wires are numbered to from top to bottom On each wire there are some oskols sitting next to each other Oskol is the name of a delicious kind of birds in Shaass s territory Supposed there are oskols sitting on the th wire Sometimes Shaass shots one of the birds and the bird dies suppose that this bird sat at the th wire Consequently all the birds on the th wire to the left of the dead bird get scared and jump up on the wire number if there exists no upper wire they fly away Also all the birds to the right of the dead bird jump down on wire number if there exists no such wire they fly away Shaass has shot birds You re given the initial number of birds on each wire tell him how many birds are sitting on each wire after the shots ,"['#include <cstdio>\nint a[100000];\nint main()\n{\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%d"", &a[i]);\n\tint m;\n\tscanf(""%d"", &m);\n\twhile (m--)\n\t{\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\t--x; --y;\n\t\tif (x)\n\t\t\ta[x - 1] += y;\n\t\tif (x + 1 < n)\n\t\t\ta[x + 1] += a[x] - y - 1;\n\t\ta[x] = 0;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tprintf(""%d\\n"", a[i]);\n\treturn 0;\n}\n']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Dima loves making pictures on a piece of squared paper And yet more than that Dima loves the pictures that depict one of his favorite figures A piece of squared paper of size is represented by a table consisting of rows and columns All squares are white on blank squared paper Dima defines a as an image on a blank piece of paper obtained by painting some squares black The picture portrays one of Dima s favorite figures if the following conditions hold The picture contains at least one painted cell All painted cells form a connected set that is you can get from any painted cell to any other one you can move from one cell to a side adjacent one The minimum number of moves needed to go from the painted cell at coordinates to the painted cell at coordinates moving only through the colored cells equals Now Dima is wondering how many paintings are on an piece of paper that depict one of his favorite figures Count this number modulo ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define FOR(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)\n#define SZ(c) ((int)(c).size())\n\ntypedef long long LL;\nLL sum[2][2][2][155][155];\nLL dp[2][2][2][155][155];\nconst int MOD = 1e9+7;\nvoid add(LL &x, long long v) {\n    x = (x+v)%MOD;\n}\n\nLL require_sum(int u, int f1, int f2, int xL, int xR, int yL, int yR) {\n    return\n        sum[u][f1][f2][xR][yR] - sum[u][f1][f2][xL-1][yR]\n        -sum[u][f1][f2][xR][yL-1] + sum[u][f1][f2][xL-1][yL-1];\n}\nint main(void) {\n    int m, n;\n    LL sol=0;\n    scanf(""%d%d"", &m, &n);\n    int u=0;\n    for(int i=1;i<=m;i++)\n        for(int j=i;j<=m;j++) {\n            dp[0][0][0][i][j] = 1;\n            add(sol, (n+1-1)*dp[0][0][0][i][j]);\n        }\n    for(int i=1;i<=m;i++)\n        for(int j=1;j<=m;j++) {\n            sum[0][0][0][i][j] = (dp[0][0][0][i][j] + sum[0][0][0][i-1][j] + sum[0][0][0][i][j-1] - sum[0][0][0][i-1][j-1])%MOD;\n        }\n    for(int row=2;row<=n;row++) {\n        memset(dp[1-u],0,sizeof(dp[1-u]));\n        memset(sum[1-u],0,sizeof(sum[1-u]));\n        for(int i=1;i<=m;i++)\n            for(int j=i;j<=m;j++) {\n                dp[1-u][0][0][i][j] = require_sum(u, 0, 0, i, j, i, j);\n                dp[1-u][0][1][i][j] = require_sum(u, 0, 1, i, j, j, m);\n                if(j<m) add(dp[1-u][0][1][i][j], require_sum(u, 0, 0, i, j, j+1, m));\n                \n                dp[1-u][1][0][i][j] = require_sum(u, 1, 0, 1, i, i, j);\n                if(i>1) add(dp[1-u][1][0][i][j], require_sum(u, 0, 0, 1, i-1, i, j));\n\n                dp[1-u][1][1][i][j] = require_sum(u, 1, 1, 1, i, j, m);\n                if(i>1) add(dp[1-u][1][1][i][j], require_sum(u, 0, 1, 1, i-1, j, m));\n                if(j<m) add(dp[1-u][1][1][i][j], require_sum(u, 1, 0, 1, i, j+1, m));\n                if(i>1&&j<m) add(dp[1-u][1][1][i][j], require_sum(u, 0, 0, 1, i-1, j+1, m));\n            }\n        u=1-u;\n                for(int f1=0;f1<2;f1++)\n                    for(int f2=0;f2<2;f2++) {\n        for(int i=1;i<=m;i++)\n            for(int j=1;j<=m;j++)\n                sum[u][f1][f2][i][j] = (dp[u][f1][f2][i][j] + sum[u][f1][f2][i-1][j]+sum[u][f1][f2][i][j-1] - sum[u][f1][f2][i-1][j-1])%MOD;\n        add(sol, (n+1-row)*1LL*sum[u][f1][f2][m][m]);\n                    }\n    }\n    sol = (sol%MOD+MOD)%MOD;\n    printf(""%I64d\\n"", sol);\n    return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
Rhodoks has a tree with n vertices but he doesn t remember its structure The vertices are indexed from 1 to n A segment l r 1 leq l leq r leq n is good if the vertices with indices l l 1 r form a connected component in Rhodoks tree Otherwise it is bad For example if the tree is the one in the picture then only the segment 3 4 is bad while all the other segments are good For each of the frac n n 1 2 segments Rhodoks remembers whether it is good or bad Can you help him recover the tree If there are multiple solutions print any It is guaranteed that the there is at least one tree satisfying Rhodoks description ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst int maxn=2222,mod=998244353;\n#define fi first\n#define se second\n#define MP make_pair\n#define PB push_back\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline ll read(){\n\tchar ch=getchar();ll x=0,f=0;\n\twhile(ch<\'0\' || ch>\'9\') f|=ch==\'-\',ch=getchar();\n\twhile(ch>=\'0\' && ch<=\'9\') x=x*10+ch-\'0\',ch=getchar();\n\treturn f?-x:x;\n}\ninline int qpow(int a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;\n\treturn ans;\n}\nint n,al,tmp[maxn],tl,sum[maxn][maxn];\nPII ans[maxn];\nset<PII> s;\nchar str[maxn][maxn];\ninline void add(int u,int v){\n\tif(u>v) swap(u,v);\n\tans[++al]=MP(u,v);\n}\nvoid clear(){\n\tal=tl=0;\n\tFOR(i,1,n) tmp[i]=0,ans[i]=MP(0,0);\n\tFOR(i,1,n) FOR(j,1,n) sum[i][j]=0;\n\ts.clear();\n}\nvoid solve(){\n\tn=read();\n\tFOR(i,1,n) scanf(""%s"",str[i]+1);\n\tFOR(i,1,n) s.insert(MP(i,i));\n\tFOR(len,2,n) FOR(l,1,n-len+1){\n\t\tint r=l+len-1;\n\t\tif(str[l][len]==\'0\') continue;\n\t\t// last se>=l is the one before first fi>l\n\t\t// last fi<=r\n\t\tauto lft=s.lower_bound(MP(l+1,0)),rig=s.lower_bound(MP(r+1,0));\n\t\tlft--;rig--;\n//\t\tprintf(""l=%d,r=%d\\n"",l,r);\n\t\tif(lft==rig) continue;\n//\t\tputs(""in"");\n\t\ttmp[tl=1]=l;\n\t\tfor(auto it=lft;it!=rig;it++){\n\t\t\tif(it==lft) continue;\n\t\t\ttmp[++tl]=it->fi;\n\t\t}\n\t\ttmp[++tl]=r;\n//\t\tFOR(i,1,tl) printf(""%d "",tmp[i]);\n//\t\tputs("""");\n\t\tassert(tl!=3);\n\t\tif(tl>=4){\n\t\t\tif(tl%2==1){\n\t\t\t\tint lst=tmp[4];\n\t\t\t\tFOR(i,1,tl) if(i%2==1) add(lst,tmp[i]),lst=tmp[i];\n\t\t\t\tFOR(i,2,tl) if(i!=4 && i%2==0) add(lst,tmp[i]),lst=tmp[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint lst=tmp[2];\n\t\t\t\tFOR(i,4,tl) if(i%2==0) add(lst,tmp[i]),lst=tmp[i];\n\t\t\t\tFOR(i,1,tl) if(i%2==1) add(lst,tmp[i]),lst=tmp[i];\n\t\t\t}\n\t\t}\n\t\telse add(l,r);\n\t\tint x=lft->fi,y=rig->se;\n\t\trig++;\n\t\ts.erase(lft,rig);\n\t\ts.insert(MP(x,y));\n\t}\n\tassert(al==n-1);\n\tFOR(i,1,n-1) printf(""%d %d\\n"",ans[i].fi,ans[i].se),sum[ans[i].fi][ans[i].se]++;\n\tFOR(i,1,n) FOR(j,1,n) sum[i][j]+=sum[i][j-1];\n\tROF(i,n,1) FOR(j,1,n) sum[i][j]+=sum[i+1][j];\n\tFOR(i,1,n){\n\t\tFOR(j,i,n){\n\t\t\tassert((sum[i][j]==j-i)==(str[i][j-i+1]==\'1\'));\n\t\t\tif((sum[i][j]==j-i)!=(str[i][j-i+1]==\'1\')) printf(""at %d %d\\n"",i,j);\n\t\t}\n\t}\n\tclear();\n}\nint main(){\n\tint T=read();\n\twhile(T--) solve();\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3400
You have n stacks r 1 r 2 ldots r n Each stack contains some positive integers ranging from 1 to n Define the following functions function init pos stacks an array that contains n stacks r 1 r 2 r n return get stacks pos function get stacks pos if stacks pos is empty return pos else new pos the top element of stacks pos pop the top element of stacks pos return get stacks new pos You want to know the values returned by texttt init 1 texttt init 2 ldots texttt init n Note that during these calls the stacks r 1 r 2 ldots r n don t change so the calls texttt init 1 texttt init 2 ldots texttt init n are independent ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n/**\n * Description: Disjoint Set Union with path compression\n * and union by size. Add edges and test connectivity.\n * Use for Kruskal\'s or Boruvka\'s minimum spanning tree.\n * Time: O(\\alpha(N))\n * Source: CSAcademy, KACTL\n * Verification: *\n */\n\nstruct DSU {\n\tvi e;\n\tvoid init(int N) { e = vi(N, -1); }\n\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\n\tbool sameSet(int a, int b) { return get(a) == get(b); }\n\tint size(int x) { return -e[get(x)]; }\n\tvoid add_edge(int x, int y) {  // union by size\n\t\tx = get(x), y = get(y);\n\t\tassert(x != y);\n\t\t// if (x == y) return 0;\n\t\te[y] += e[x];\n\t\te[x] = y;\n\t}\n};\n\n/**tcT> T kruskal(int N, vector<pair<T,pi>> ed) {\n    sort(all(ed));\n    T ans = 0; DSU D; D.init(N); // edges that unite are in MST\n    each(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f;\n    return ans;\n}*/\n\nint N;\nV<vi> C;\n// DSU D;\nvi ans;\n\n// int query(int x) {\n// \tvi stk{x};\n// \twhile (true) {\n// \t\tif (final_ans[stk.bk]) {\n\n// \t\t}\n// \t}\n// }\n\nint timer = 0;\n\nvi vis;\n\nvoid dfs(int x) {\n\t++timer;\n\tvi stk{x};\n\tvis[stk.bk] = timer;\n\twhile (true) {\n\t\tif (!ans[stk.bk] && !sz(C[stk.bk])) { ans[stk.bk] = stk.bk; }\n\t\tif (ans[stk.bk]) {\n\t\t\teach(x, stk) ans[x] = ans[stk.bk];\n\t\t\treturn;\n\t\t}\n\t\tint nxt = C[stk.bk].bk;\n\t\tif (vis[nxt] != timer) {\n\t\t\tstk.pb(nxt);\n\t\t\tvis[stk.bk] = timer;\n\t\t} else {\n\t\t\twhile (true) {\n\t\t\t\tassert(sz(stk));\n\t\t\t\tC[stk.bk].pop_back();\n\t\t\t\tif (stk.bk == nxt) break;\n\t\t\t\tvis[stk.bk] = 0;\n\t\t\t\tstk.pop_back();\n\t\t\t}\n\t\t\tassert(stk.bk == nxt);\n\t\t}\n\t}\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tre(N);\n\t// D.init(N + 1);\n\t// D.add_edge(1, 2);\n\t// dbg(D.get(1), D.get(2));\n\t// exit(0);\n\tC.rsz(N + 1);\n\tFOR(i, 1, N + 1) {\n\t\tdef(int, K);\n\t\tC[i].rsz(K);\n\t\tre(C[i]);\n\t}\n\tans.rsz(N + 1);\n\tvis = vi(N + 1);\n\tFOR(i, 1, N + 1) dfs(i);\n\tans.erase(begin(ans));\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","[0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3000
You are given an array a consisting of n n ge 3 positive integers It is known that in this array all the numbers except one are the same for example in the array 4 11 4 4 all numbers except one are equal to 4 Print the index of the element that does not equal others The numbers in the array are numbered from one ,"['#include<bits/stdc++.h>\ntypedef unsigned long long ull;\ntypedef long long ll;\ntemplate<class T1,class T2,class T3>T1 ksm(T1 a,T2 b,T3 mod){T1 ans=1;while(b){if(b&1)ans=(ans*a)%mod;a=(a*a)%mod;b>>=1;}return ans;}\n#ifndef ONLINE_JUDGE\ntemplate<class T>T __gcd(T a,T b){ll r;while(b>0){r=a%b;a=b;b=r;}return a;}\n#endif\n#define inf INT_MAX\n#define Max(x,y) x=max(x,y)\n#define Min(x,y) x=min(x,y)\n#define Out(t) printf(""%s\\n"",(t)?""YES"":""NO"")\nconst double pi=acos(-1.);\nconst int def=100010;\nconst int mod=1000000007;\nusing namespace std;\n\nint num[def],pos[def];\n\nint main()\n{\tint _=1,__=1,n,x;\n\tfor(((1)?scanf(""%d"",&_):EOF);_;_--,__++){\n\t\tscanf(""%d"",&n);\n\t\tfor(int i=1;i<=100;i++)num[i]=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(""%d"",&x);\n\t\t\tnum[x]++;\n\t\t\tpos[x]=i;\n\t\t}\n\t\tfor(int i=1;i<=100;i++)if(num[i]==1){\n\t\t\tprintf(""%d\\n"",pos[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Alexey is travelling on a train Unfortunately due to the bad weather the train moves slower that it should Alexey took the train at the railroad terminal Let s say that the train starts from the terminal at the moment 0 Also let s say that the train will visit n stations numbered from 1 to n along its way and that Alexey destination is the station n Alexey learned from the train schedule n integer pairs a i b i where a i is the expected time of train s arrival at the i th station and b i is the expected time of departure Also using all information he has Alexey was able to calculate n integers tm 1 tm 2 dots tm n where tm i is the extra time the train need to travel from the station i 1 to the station i Formally the train needs exactly a i b i 1 tm i time to travel from station i 1 to station i if i 1 then b 0 is the moment the train leave the terminal and it s equal to 0 The train leaves the station i if both conditions are met it s on the station for at least left lceil frac b i a i 2 right rceil units of time division with ceiling current time ge b i Since Alexey spent all his energy on prediction of time delays help him to calculate the time of at the station n ,"['#include<bits/stdc++.h>\nusing namespace std;\nconst long long M=75161927681ll;\nconst int N=1505,E=524288;\nint n,m,i,j,a[N],b[N],tu[N],t;\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""a.in"",""r"",stdin);\n\tfreopen(""a.out"",""w"",stdout);\n#endif\n\tscanf(""%d"",&t);\n\twhile(t--)\n\t{\n\t\tscanf(""%d"",&n);\n\t\tfor(i=1;i<=n;++i)\n\t\t\tscanf(""%d %d"",&a[i],&b[i]);\n\t\tfor(i=1;i<=n;++i)\n\t\t\tscanf(""%d"",&tu[i]);\n\t\tint s=0;\n\t\tfor(i=1;i<=n;++i)\n\t\t{\n\t\t\ts+=a[i]-b[i-1]+tu[i];\n\t\t\tif(i!=n)\n\t\t\t\ts=max(b[i],s+(b[i]-a[i]+1)/2);\n\t\t}\n\t\tprintf(""%d\\n"",s);\n\t}\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Bran and his older sister Arya are from the same house Bran like candies so much so Arya is going to give him some Candies At first Arya and Bran have Candies There are days at the th day Arya finds candies in a box that is given by the Many Faced God Every day she can give Bran of her candies If she don t give him the candies at the same day they are saved for her and she can give them to him later Your task is to find the minimum number of days Arya needs to give Bran candies the end of the th day Formally you need to output the minimum day index to the end of which candies will be given out the days are indexed from 1 to Print if she can t give him candies during given days ,"['#include<bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nint n;\n\nlong long k;\nlong long zap;\n\nint main()\n{\n    scanf(""%d%lld"", &n, &k);\n    for (int i=1; i<=n; i++)\n    {\n        long long x;\n        scanf(""%lld"", &x);\n        zap+=x;\n        x=min(zap, 8LL);\n        zap-=x;\n        k-=x;\n        if (k<=0)\n        {\n            printf(""%d\\n"", i);\n            return 0;\n        }\n    }\n    printf(""-1\\n"");\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
Rubik is very keen on number permutations A with length is a sequence consisting of different numbers from 1 to Element number of this permutation will be denoted as Furik decided to make a present to Rubik and came up with a new problem on permutations Furik tells Rubik two number permutations permutation with length and permutation with length Rubik must give an answer to the problem how many distinct integers exist such that sequence of length is a subsequence of Sequence is a of sequence if there are such indices that where is the length of sequence and is the length of sequence You are given permutations and help Rubik solve the given problem ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <complex>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\nconst int maxn = 222222;\n\nunsigned long long p4423[maxn];\n\n#define IX(l, r) (((l) + (r)) | ((l) != (r)))\n\nstruct State {\n    unsigned long long hashValue;\n    int count;\n\n    void assign(int value) {\n        if (value == 0) {\n            hashValue = 0;\n            count = 0;\n        } else {\n            hashValue = value;\n            count = 1;\n        }\n    }\n\n    void assign(const State &l, const State &r) {\n        hashValue = p4423[r.count] * l.hashValue + r.hashValue;\n        count = l.count + r.count;\n    }\n};\n\nState states[maxn * 2];\n\nint n, m;\nint a[maxn], b[maxn];\nint pos[maxn];\n\nvoid update(int l, int r, int p, int v)\n{\n    if (l == r) {\n        if (p == l) {\n            states[IX(l, r)].assign(v);\n        }\n        return;\n    }\n    int m = l + r >> 1;\n    if (p <= m) {\n        update(l, m, p, v);\n    }\n    if (p > m) {\n        update(m + 1, r, p, v);\n    }\n    states[IX(l, r)].assign(states[IX(l, m)], states[IX(m + 1, r)]);\n}\n\nint main()\n{\n    p4423[0] = 1;\n    for (int i = 1; i < maxn; i++) {\n        p4423[i] = p4423[i-1] * 4423;\n    }\n    scanf(""%d%d"", &n, &m);\n    unsigned long long targetHash = 0, ones = 0;\n    for (int i = 0; i < n; i++) {\n        scanf(""%d"", a + i);\n        targetHash = targetHash * 4423 + a[i];\n        ones = ones * 4423 + 1;\n    }\n    for (int i = 0; i < m; i++) {\n        scanf(""%d"", b + i);\n        pos[b[i]] = i;\n    }\n    for (int i = 1; i < n; i++) {\n        update(0, m - 1, pos[i], i);\n    }\n    int ret = 0;\n    for (int i = n; i <= m; i++) {\n        update(0, m - 1, pos[i], i);\n        assert(states[IX(0, m - 1)].count == n);\n        if (states[IX(0, m - 1)].hashValue == targetHash) {\n            ret ++;\n        }\n        targetHash += ones;\n        update(0, m - 1, pos[i - n + 1], 0);\n    }\n    printf(""%d\\n"", ret);\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2700
Valera absolutely accidentally got a piece of ancient parchment on which an array of numbers was written He immediately thought that the numbers in this array were not random As a result of extensive research Valera worked out a wonderful property that a magical array should have an array is defined as magic if its He decided to share this outstanding discovery with you but he asks you for help in return Despite the tremendous intelligence and wit Valera counts very badly and so you will have to complete his work All you have to do is count the number of magical subarrays of the original array of numbers written on the parchment Subarray is defined as ,"['#pragma comment(linker, ""/STACK:60000000"")\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define forn(i, n) for(int i = 0; i < (int)(n); i++)\n#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define last(a) int(a.size() - 1)\n#define all(a) a.begin(), a.end()\n#define seta(a,x) memset (a, x, sizeof (a))\n#define I (int)\n\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst int64 inf64 = ((int64)1 << 62) - 1;\nconst long double pi = 3.1415926535897932384626433832795;\n\ntemplate <class T> T sqr (T x) {return x * x;}\n\nint n;\nint a[100000];\nint64 res;\n\nint main ()\n{\n//\tfreopen (""input.txt"", ""r"", stdin);\n//\tfreopen (""output.txt"", ""w"", stdout);\n\tres = 0;\n\tscanf (""%d"", &n);\n\tforn (i, n)\n\t\tscanf (""%d"", &a[i]);\n\tint l = 0;\n\twhile (l < n) {\n\t\tint r = l;\n\t\twhile (r + 1 < n && a[r+1] == a[l])\n\t\t\tr ++;\n\t\tint64 d = r - l + 1;\n\t\tres += d * (d + 1) / 2;\n\t\tl = r + 1;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Polycarp is practicing his problem solving skill He has a list of n problems with difficulties a 1 a 2 dots a n respectively His plan is to practice for exactly k days Each day he has to solve at least one problem from his list Polycarp solves the problems in the order they are given in his list he cannot skip any problem from his list He has to solve all n problems in exactly k days Thus each day Polycarp solves a contiguous sequence of consecutive problems from the start of the list He can t skip problems or solve them multiple times As a result in k days he will solve all the n problems The of the j th day of Polycarp s practice is the maximum among all the difficulties of problems Polycarp solves during the j th day i e if he solves problems with indices from l to r during a day then the of the day is max limits l le i le r a i The of his practice is the sum of the over all k days of his practice You want to help Polycarp to get the maximum possible over all valid ways to solve problems Your task is to distribute all n problems between k days satisfying the conditions above in such a way that the is maximum For example if n 8 k 3 and a 5 4 2 6 5 1 9 2 one of the possible distributions with maximum is 5 4 2 6 5 1 9 2 Here the equals 5 6 9 20 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2e3;\n\nint n, k;\npair<int, int> a[MAX_N + 1];\n\nint main() {\n\t//freopen(""input.inp"", ""r"", stdin);\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n >> k;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tcin >> a[i].first;\n\t\ta[i].second = i;\n\t}\n\tsort(a + 1, a + 1 + n, greater<pair<int, int> >());\n\tvector<int> v;\n\tv.push_back(0);\n\tint profit = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tv.push_back(a[i].second);\n\t\tprofit += a[i].first;\n\t}\n\tsort(v.begin(), v.end());\n\tcout << profit << \'\\n\';\n\tfor (int i = 1; i < v.size() - 1; ++i) {\n\t\tcout << v[i] - v[i - 1] << \' \';\n\t\tn -= v[i] - v[i - 1];\n\t}\n\tcout << n;\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Cat Furrier Transform is a popular algorithm among cat programmers to create longcats As one of the greatest cat programmers ever exist Neko wants to utilize this algorithm to create the perfect longcat Assume that we have a cat with a number x A perfect longcat is a cat with a number equal 2 m 1 for some non negative integer m For example the numbers 0 1 3 7 15 and so on are suitable for the perfect longcats In the Cat Furrier Transform the following operations can be performed on x Operation A you select any non negative integer n and replace x with x oplus 2 n 1 with oplus being a bitwise XOR operator Operation B replace x with x 1 The first applied operation must be of type A the second of type B the third of type A again and so on Formally if we number operations from one in the order they are executed then odd numbered operations must be of type A and the even numbered operations must be of type B Neko wants to produce perfect longcats at industrial scale thus for each cat Neko only wants to perform at most 40 operations Can you help Neko writing a transformation plan Note that it is to minimize the number of operations You just need to use no more than 40 operations ,"['#include<bits/stdc++.h>\n#define st first\n#define nd second\n#define pb push_back\n#define pf push_front\n#define ppb pop_back\n#define ppf pop_front\n#define umax(x,y) x=max(x,y)\n#define umin(x,y) x=min(x,y)\n#define ll long long \n#define ii pair<int,int>\n#define iii pair<ii,int>\n#define iiii pair<ii,ii>\n#define sz(x) ((int) x.size())\n#define orta ((bas+son)/2)\n#define all(x) x.begin(),x.end()\n#define pw(x) (1<<(x))\n#define inf 100000009\n#define MOD 1000003 \n#define N 100005\n#define M 1000003\n#define LOG 20\n#define KOK 300\n#define EPS 0.0000001\nusing namespace std;\n\nbool ok(int x) {\n\n\twhile(x) {\n\n\t\tif(x%2==0) return 0;\n\n\t\tx>>=1;\n\n\t}\n\n\treturn 1;\n\n}\n\nint main() {\n\n\tint n;\n\tint cnt=0;\n\n\tscanf(""%d"",&n);\n\n\tvector<int> op;\n\n\tfor(int i=20;i>0;i--) {\n\n\t\tif(n&pw(i-1)) continue ;\n\n\t\top.pb(i);\n\n\t\tn^=(pw(i)-1);\n\n\t\t++cnt;\n\n\t\tif(ok(n)) break ;\n\n\t\tn++;\n\n\t\t++cnt;\n\n\t}\n\n\tprintf(""%d\\n"",cnt);\n\n\tfor(int i:op) printf(""%d "",i);\n\n}']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1300
Abendsen assigned a mission to Juliana In this mission Juliana has a rooted tree with n vertices Vertex number 1 is the root of this tree Each vertex can be either black or white At first all vertices are white Juliana is asked to process q queries Each query is one of three types If vertex v is white mark it as black otherwise perform this operation on all direct sons of v instead Mark all vertices in the subtree of v including v as white Find the color of the i th vertex Can you help Juliana to process all these queries ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n,q;\nvi c[MX];\nvector<array<int,3>> c2[MX];\nvpi todo;\nbool use[MX], col[MX], clear[MX];\nint push[MX];\n\nvoid dfs1(int x, int p = 0, int white = 0, int dis = 0) {\n    if (use[x]) {\n        if (p) c2[p].pb({x,white,dis});\n        for (int y: c[x]) dfs1(y,x,0,0);\n    } else {\n        if (!col[x]) white ++;\n        for (int y: c[x]) dfs1(y,p,white,dis+1);\n    }\n}\n\nvoid dfs2(int x, int _push = 0, int _clear = 0) {\n    if (use[x]) {\n        _push = push[x];\n        _clear |= clear[x];\n    } else {\n        if (_clear) col[x] = 0;\n        if (_push && !col[x]) col[x] = 1, _push --;\n    }\n    for (int y: c[x]) dfs2(y,_push,_clear);\n}\n\nvoid ad(int x) {\n    if (!col[x]) { col[x] = 1; return; }\n    push[x] ++;\n    for (auto a: c2[x]) if (a[1] < push[x]) ad(a[0]);\n}\n\nvoid clr(int x) {\n    col[x] = 0; push[x] = 0; clear[x] = 1;\n    for (auto& a: c2[x]) { a[1] = a[2]; clr(a[0]); }\n}\n\nvoid process() {\n    FOR(i,1,n+1) {\n        use[i] = 0;\n        clear[i] = 0;\n        push[i] = 0;\n        c2[i].clear();\n    }\n    for (auto a: todo) use[a.s] = 1;\n    dfs1(1);\n    for (auto a: todo) {\n        if (a.f == 1) ad(a.s);\n        else if (a.f == 2) clr(a.s);\n        else cout << (col[a.s]?""black"":""white"") << ""\\n"";\n    }\n    dfs2(1);\n    todo.clear();\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> q;\n    FOR(i,2,n+1) {\n        int p; cin >> p;\n        c[p].pb(i);\n    }\n    F0R(i,q) {\n        int t,v; cin >> t >> v;\n        todo.pb({t,v});\n        if (sz(todo) >= 600) process();\n    }\n    process();\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3200
Consider a sequence of distinct integers a 1 ldots a n each representing one node of a graph There is an edge between two nodes if the two values are not coprime i e they have a common divisor greater than 1 There are q queries in each query you want to get from one given node a s to another a t In order to achieve that you can choose an existing value a i and create new value a n 1 a i cdot 1 a i with edges to all values that are not coprime with a n 1 Also n gets increased by 1 You can repeat that operation multiple times possibly making the sequence much longer and getting huge or repeated values What s the minimum possible number of newly created nodes so that a t is reachable from a s Queries are independent In each query you start with the initial sequence a given in the input ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 1000005;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n/**\n * Description: Disjoint Set Union with path compression\n \t* and union by size. Add edges and test connectivity. \n \t* Use for Kruskal\'s or Boruvka\'s minimum spanning tree.\n * Time: O(\\alpha(N))\n * Source: CSAcademy, KACTL\n * Verification: *\n */\n\nstruct DSU {\n\tvi e; void init(int N) { e = vi(N,-1); }\n\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); } \n\tbool sameSet(int a, int b) { return get(a) == get(b); }\n\tint size(int x) { return -e[get(x)]; }\n\tbool unite(int x, int y) { // union by size\n\t\tx = get(x), y = get(y); if (x == y) return 0;\n\t\tif (e[x] > e[y]) swap(x,y);\n\t\te[x] += e[y]; e[y] = x; return 1;\n\t}\n};\n\n/**template<class T> T kruskal(int N, vector<pair<T,pi>> ed) {\n\tsort(all(ed));\n\tT ans = 0; DSU D; D.init(N); // edges that unite are in MST\n\teach(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f; \n\treturn ans;\n}*/\n\nint N,Q;\nvi comps[MX], anses[MX];\n\nint main() {\n\tsetIO(); re(N,Q);\n\tvi A(N); re(A);\n\tvb active(MX);\n\teach(t,A) active.at(t) = 1;\n\tDSU D; D.init(MX);\n\tvi repr(MX);\n\tvb composite(MX);\n\tFOR(p,2,MX) if (!composite[p]) {\n\t\t// dbg(""TRYING"",p);\n\t\trepr[p] = -1;\n\t\t// dbg(""WHOOPS"",p);\n\t\tfor (int x = p; x < MX; x += p) {\n\t\t\tif (x > p) composite[x] = 1;\n\t\t\tif (active.at(x)) {\n\t\t\t\tif (repr[p] != -1) D.unite(repr[p],x);\n\t\t\t\trepr[p] = x;\n\t\t\t}\n\t\t}\n\t}\n\t// there aren\'t that many distinct components ...\n\t// FOR(i,1,MX) if (active[i]) {\n\t// \t// i and i+1\n\n\t// }\n\n\tFOR(p,2,MX) if (repr[p] != -1) {\n\t\tfor (int x = p; x < MX; x += p) {\n\t\t\tif (active[x-1]) comps[x-1].pb(repr[p]);\n\t\t}\n\t}\n\tFOR(x,2,MX) if (active[x]) {\n\t\t// comps[i]\n\t\t// i\n\t\tvi distinct; distinct.pb(D.get(x));\n\t\tfor (int j: comps[x]) distinct.pb(D.get(j));\n\t\tremDup(distinct);\n\t\tF0R(i,sz(distinct)) FOR(j,i+1,sz(distinct))\n\t\t\tanses[distinct[i]].pb(distinct[j]);\n\t}\n\tFOR(i,2,MX) remDup(anses[i]);\n\trep(Q) {\n\t\tints(S,T); \n\t\tS = D.get(A[S-1]);\n\t\tT = D.get(A[T-1]);\n\t\tif (S > T) swap(S,T);\n\t\tif (S == T) {\n\t\t\tps(0);\n\t\t} else {\n\t\t\tint ind = lwb(anses[S],T);\n\t\t\tif (ind < sz(anses[S]) && anses[S][ind] == T) ps(1);\n\t\t\telse ps(2);\n\t\t}\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]",2700
Jay managed to create a problem of difficulty x and decided to make it the second problem for Codeforces Round 921 But Yash fears that this problem will make the contest highly unbalanced and the coordinator will reject it So he decided to break it up into a problemset of n sub problems such that the difficulties of all the sub problems are a positive integer and their sum is equal to x The coordinator Aleksey defines the balance of a problemset as the GCD of the difficulties of all sub problems in the problemset Find the maximum balance that Yash can achieve if he chooses the difficulties of the sub problems optimally ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nvoid solve() {\n  int x, n;\n  cin >> x >> n;\n  int ans = 0;\n  for (int d = 1; d*d <= x; d++) {\n    if (x % d) continue;\n    if (d*n <= x)\n      ans = max(ans, d);\n    if (x/d*n <= x)\n      ans = max(ans, x/d);\n  }\n  cout << ans << endl;\n}\nsigned main() {\n  int t;\n  cin >> t;\n  while (t--) solve();\n}\n']","[1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1200
You are going to the beach with the idea to build the greatest sand castle ever in your head The beach is not as three dimensional as you could have imagined it can be decribed as a line of spots to pile up sand pillars Spots are numbered through infinity from left to right Obviously there is not enough sand on the beach so you brought packs of sand with you Let height of the sand pillar on some spot be the number of sand packs you spent on it There is a fence of height equal to the height of pillar with sand packs to the left of the first spot and you should prevent sand from going over it Finally you ended up with the following conditions to building the castle no sand from the leftmost spot should go over the fence For any large difference in heights of two neighboring pillars can lead sand to fall down from the higher one to the lower you really don t want this to happen you want to spend all the sand you brought with you As you have infinite spots to build it is always possible to come up with some valid castle structure Though you want the castle to be as compact as possible Your task is to calculate the minimum number of spots you can occupy so that all the aforementioned conditions hold ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nll n,H;\n\nld mx(ll mid) {\n    // 1 to mid \n    // H-1+x \n    // mid+1-x\n    // 2x = H+mid+2 \n    ll x = max((mid-H+2)/2,0LL);\n    // mid-x to 1 \n    return (ld)x*(H+H-1+x)/2+(ld)(mid-x)*(mid-x+1)/2;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> H;\n    ll lo = 1, hi = 10LL*MOD;\n    while (lo < hi) {\n        ll mid = (lo+hi)/2;\n        if (mx(mid) >= n) hi = mid;\n        else lo = mid+1;\n    }\n    cout << lo;\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)']","[0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2100
Rudolf is on his way to the castle Before getting into the castle the security staff asked him a question Given two binary numbers a and b of length n How many different ways of swapping two digits in a only in a not b so that bitwise OR of these two numbers will be changed In other words let c be the bitwise OR of a and b you need to find the number of ways of swapping two bits in a so that bitwise OR will not be equal to c Note that binary numbers can contain leading zeros so that length of each number is exactly n Bitwise OR is a binary operation A result is a binary number which contains a one in each digit if there is a one in at least one of the two numbers For example 01010 2 10011 2 11011 2 Well to your surprise you are not Rudolf and you don t need to help him ldots You are the security staff Please find the number of ways of swapping two bits in a so that bitwise OR will be changed ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nstring a,b;\nll ans = 0;\nint n;\nll co[4];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n;\n    cin >> a >> b;\n    F0R(i,n) {\n        co[2*(a[i]-\'0\')+(b[i]-\'0\')] ++;\n    }\n    //F0R(i,4) cout << co[i] << "" "";\n    //cout << ""\\n"";\n    cout << co[3]*co[0]+co[2]*co[1]+co[2]*co[0];\n}\n\n/* Look for:\n* the exact constraints (multiple sets are too slow for n=10^6 :( ) \n* special cases (n=1?)\n* overflow (ll vs int?)\n* array bounds\n*/']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You play a computer game In this game you lead a party of m heroes and you have to clear a dungeon with n monsters Each monster is characterized by its power a i Each hero is characterized by his power p i and endurance s i The heroes clear the dungeon day by day In the beginning of each day you choose a hero exactly one who is going to enter the dungeon this day When the hero enters the dungeon he is challenged by the first monster which was not defeated during the previous days so if the heroes have already defeated k monsters the hero fights with the monster k 1 When the hero fights the monster there are two possible outcomes if the monster s power is strictly greater than the hero s power the hero retreats from the dungeon The current day ends otherwise the monster is defeated After defeating a monster the hero either continues fighting with the next monster or leaves the dungeon He leaves the dungeon either if he has already defeated the number of monsters equal to his endurance during this day so the i th hero cannot defeat more than s i monsters during each day or if all monsters are defeated otherwise he fights with the next monster When the hero leaves the dungeon the current day ends Your goal is to defeat the last monster What is the minimum number of days that you need to achieve your goal Each day you have to use exactly one hero it is possible that some heroes don t fight the monsters at all Each hero can be used arbitrary number of times ,"[""#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nnamespace IO {\n    const int BUFFER_SIZE = 1 << 15;\n\n    char input_buffer[BUFFER_SIZE];\n    int input_pos = 0, input_len = 0;\n\n    char output_buffer[BUFFER_SIZE];\n    int output_pos = 0;\n\n    char number_buffer[100];\n    uint8_t lookup[100];\n\n    void _update_input_buffer() {\n        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);\n        input_pos = 0;\n\n        if (input_len == 0)\n            input_buffer[0] = EOF;\n    }\n\n    inline char next_char(bool advance = true) {\n        if (input_pos >= input_len)\n            _update_input_buffer();\n\n        return input_buffer[advance ? input_pos++ : input_pos];\n    }\n\n    template<typename T>\n    inline void read_int(T &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == '-')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - '0');\n        } while (isdigit(next_char(false)));\n\n        if (negative)\n            number = -number;\n    }\n\n    template<typename T, typename... Args>\n    inline void read_int(T &number, Args &... args) {\n        read_int(number);\n        read_int(args...);\n    }\n\n    void _flush_output() {\n        fwrite(output_buffer, sizeof(char), output_pos, stdout);\n        output_pos = 0;\n    }\n\n    inline void write_char(char c) {\n        if (output_pos == BUFFER_SIZE)\n            _flush_output();\n\n        output_buffer[output_pos++] = c;\n    }\n\n    template<typename T>\n    inline void write_int(T number, char after = '\\0') {\n        if (number < 0) {\n            write_char('-');\n            number = -number;\n        }\n\n        int length = 0;\n\n        while (number >= 10) {\n            uint8_t lookup_value = lookup[number % 100];\n            number /= 100;\n            number_buffer[length++] = (lookup_value & 15) + '0';\n            number_buffer[length++] = (lookup_value >> 4) + '0';\n        }\n\n        if (number != 0 || length == 0)\n            write_char(number + '0');\n\n        for (int i = length - 1; i >= 0; i--)\n            write_char(number_buffer[i]);\n\n        if (after)\n            write_char(after);\n    }\n\n    void init() {\n        // Make sure _flush_output() is called at the end of the program.\n        bool exit_success = atexit(_flush_output) == 0;\n        assert(exit_success);\n\n        for (int i = 0; i < 100; i++)\n            lookup[i] = (i / 10 << 4) + i % 10;\n    }\n}\n\n\nvoid solve_case() {\n    int N, M;\n    IO::read_int(N);\n    vector<int> A(N);\n    vector<int> best_power(N + 1, 0);\n\n    for (auto &a : A)\n        IO::read_int(a);\n\n    IO::read_int(M);\n\n    for (int i = 0; i < M; i++) {\n        int p, s;\n        IO::read_int(p, s);\n        best_power[s] = max(best_power[s], p);\n    }\n\n    for (int s = N - 1; s >= 0; s--)\n        best_power[s] = max(best_power[s], best_power[s + 1]);\n\n    if (*max_element(A.begin(), A.end()) > best_power[0]) {\n        IO::write_int(-1, '\\n');\n        return;\n    }\n\n    int start = 0, days = 0;\n\n    while (start < N) {\n        int monsters = 0, maximum = 0;\n\n        while (start + monsters < N) {\n            maximum = max(maximum, A[start + monsters]);\n\n            if (best_power[monsters + 1] >= maximum)\n                monsters++;\n            else\n                break;\n        }\n\n        start += monsters;\n        days++;\n    }\n\n    IO::write_int(days, '\\n');\n}\n\nint main() {\n    IO::init();\n\n    int T;\n    IO::read_int(T);\n\n    while (T-- > 0)\n        solve_case();\n}\n""]","[1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]",1700
The Little Elephant loves playing with arrays He has array consisting of positive integers indexed from 1 to Let s denote the number with index as Additionally the Little Elephant has queries to the array each query is characterised by a pair of integers and For each query the Little Elephant has to count how many numbers exist such that number occurs exactly times among numbers Help the Little Elephant to count the answers to all queries ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint in[101000];\nint l[101000],r[101000];\nint cnt[101000];\nvector<int> qs[1010];\nint ans[101000];\ninline bool cmp(int a,int b){return r[a]<r[b];}\nint qq;\nint n;\ninline void add(int x){\n    if(x>n)return;\n    if(cnt[x]==x)qq--;\n    cnt[x]++;\n    if(cnt[x]==x)qq++;\n}\ninline void del(int x){\n    if(x>n)return;\n    if(cnt[x]==x)qq--;\n    cnt[x]--;\n    if(cnt[x]==x)qq++;\n}\nint main(){\n    int m,i,j,k;\n    scanf(""%d%d"",&n,&m);\n    for(i=0;i<n;i++)scanf(""%d"",&in[i]);\n    int sn=(int)(sqrt(n)+1);\n    for(i=0;i<m;i++){\n        scanf(""%d%d"",&l[i],&r[i]);\n        l[i]--;r[i]--;\n        qs[l[i]/sn].push_back(i);\n    }\n    for(i=0;i<=n/sn;i++){\n        if(qs[i].size()==0)continue;\n        sort(qs[i].begin(),qs[i].end(),cmp);\n        memset(cnt,0,sizeof(cnt));\n        qq=0;\n        int ll=l[qs[i][0]],rr=r[qs[i][0]];\n        for(j=ll;j<=rr;j++)add(in[j]);\n        ans[qs[i][0]]=qq;\n        for(j=1;j<qs[i].size();j++){\n            int ii=qs[i][j];\n            int lll=l[ii],rrr=r[ii];\n            for(k=rr+1;k<=rrr;k++)add(in[k]);\n            if(lll<ll){\n                for(k=ll-1;k>=lll;k--)add(in[k]);\n            }else if(lll>ll){\n                for(k=ll;k<lll;k++)del(in[k]);\n            }\n            ll=lll;rr=rrr;\n            ans[ii]=qq;\n        }\n    }\n    for(i=0;i<m;i++)printf(""%d\\n"",ans[i]);\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Arthur has bought a beautiful big table into his new flat When he came home Arthur noticed that the new table is unstable In total the table Arthur bought has legs the length of the th leg is Arthur decided to make the table stable and remove some legs For each of them Arthur determined number the amount of energy that he spends to remove the th leg A table with legs is assumed to be stable if there are more than half legs of the maximum length For example to make a table with legs stable you need to make sure it has at least three out of these five legs of the maximum length Also a table with one leg is always stable and a table with two legs is stable if and only if they have the same lengths Your task is to help Arthur and count the minimum number of energy units Arthur should spend on making the table stable ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define PII pair <int, int> \nint leng [100005]; \nint energy [100005]; \nPII len [100005]; \nint totenergy [100005]; \nvector <int> energybyleng [100005]; \nint cur [205]; \nint main()\n{\n    ios_base::sync_with_stdio(0); \n    int N; cin >> N;\n    long long tot = 0; \n    for (int g=1; g<=N; g++) cin >> leng[g]; \n    for (int g=1; g<=N; g++) cin >> energy[g]; \n    for (int g=1; g<=N; g++) tot+=energy[g], totenergy[leng[g]]+=energy[g], len[g]=PII(leng[g], energy[g]), energybyleng[leng[g]].push_back(energy[g]); \n    sort(len+1, len+N+1); \n    for (int g=1; g<=100000; g++) sort(energybyleng[g].begin(), energybyleng[g].end()); \n    int checker=0; \n    for (int g=1; g<=100000; g++)\n    {\n        if (!energybyleng[g].size()) continue; \n        int x = totenergy[g]; \n        int cansave = energybyleng[g].size()-1; \n        for (int y=200; y>=1; y--)\n        {\n            if (cansave==0) break; \n            if (cur[y]>=cansave)\n            {\n                x+=(cansave*y); break;\n            }\n            else\n            {\n                x+=(cur[y]*y); \n                cansave-=cur[y]; \n            }\n        }\n        if (x>checker)checker=x; \n        for (int y=0; y<energybyleng[g].size(); y++)\n        {\n            cur[energybyleng[g][y]]++; \n        }\n    }   \n    cout << tot-checker; \n    return 0;\n}']","[1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Let x be an array of integers x x 1 x 2 dots x n Let s define B x as a minimal size of a partition of x into subsegments such that all elements in each subsegment are equal For example B 3 3 6 1 6 6 6 4 using next partition 3 3 6 1 6 6 6 Now you don t have any exact values of x but you know that x i can be any integer value from l i r i l i le r i uniformly at random All x i are independent Calculate expected value of B x 2 or E B x 2 It s guaranteed that the expected value can be represented as rational fraction frac P Q where P Q 1 so print the value P cdot Q 1 mod 10 9 7 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=1000*1000*1000+7;\n\nint n;\n\nll l[nax];\nll r[nax];\n\nll zm2, zm;\n\nll tu[nax];\n\nll dlu[nax];\n\nll dziel(ll a, ll b)\n{\n\t//~ debug() << a << "" "" << b;\n\ta%=mod;\n\tb%=mod;\n\tll wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\ta=(a*b)%mod;\n\t\tb=(b*b)%mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &l[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(""%lld"", &r[i]);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tll wsz=(r[i]-l[i]+1)*(r[i+1]-l[i+1]+1)%mod;\n\t\tll dob=0;\n\t\tll a=max(l[i], l[i+1]);\n\t\tll b=min(r[i], r[i+1]);\n\t\tif (a<=b)\n\t\t\tdob=b-a+1;\n\t\tdlu[i]=dob;\n\t\tll x=dziel(mod+wsz-dob, wsz);\n\t\tzm=(zm+x)%mod;\n\t\ttu[i]=x;\n\t}\n\tll s=0;\n\t//~ debug() << range(tu+1, tu+1+n);\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tzm2=(zm2+tu[i]*s)%mod;\n\t\ts=(s+tu[i-1])%mod;\n\t}\n\tfor (int i=1; i+2<=n; i++)\n\t{\n\t\tll wsz=(r[i]-l[i]+1)*(r[i+1]-l[i+1]+1)%mod*(r[i+2]-l[i+2]+1)%mod;\n\t\tll a=max(l[i], l[i+1]);\n\t\tll b=min(r[i], r[i+1]);\n\t\ta=max(a, l[i+2]);\n\t\tb=min(b, r[i+2]);\n\t\t//~ debug() << imie(wsz);\n\t\t//~ debug() << imie(dlu[i]*(r[i+2]-l[i+2]+1));\n\t\t//~ debug() << imie(dlu[i+1]*(r[i]-l[i]+1));\n\t\t//~ debug() << imie(max(0LL, b-a+1));\n\t\tzm2+=dziel(wsz-dlu[i]*(r[i+2]-l[i+2]+1)-dlu[i+1]*(r[i]-l[i]+1)+max(0LL, b-a+1), wsz);\n\t\tzm2%=mod;\n\t\tzm2+=mod;\n\t\tzm2%=mod;\n\t}\n\t\n\tdebug() << imie(zm);\n\tdebug() << imie(zm2);\n\t\n\tzm2=(zm2*2+zm)%mod;\n\t\n\tprintf(""%lld\\n"", (zm2+2*zm+1)%mod);\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2500
You are given a range of positive integers from l to r Find such a pair of integers x y that l le x y le r x ne y and x divides y If there are multiple answers print any of them You are also asked to answer T independent queries ,"['#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint T,l,r;\nint main()\n{\n    scanf(""%d"",&T);\n    while(T--)\n    {\n        scanf(""%d%d"",&l,&r);\n        if(l*2>r) puts(""-1""); else printf(""%d %d\\n"",l,l*2);\n    }\n    return 0;\n}\n\n']","[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You are playing one famous sandbox game with the three dimensional world The map of the world can be represented as a matrix of size n times m where the height of the cell i j is a i j You are in the cell 1 1 right now and want to get in the cell n m You can move only down from the cell i j to the cell i 1 j or right from the cell i j to the cell i j 1 There is an additional if the height of the current cell is x then you can move only to the cell with height x 1 you can perform several operations During one operation you can decrease the height of cell by one I e you choose some cell i j and assign set a i j a i j 1 Note that you make heights Also note that you decrease the height of the cell 1 1 Your task is to find the number of operations you have to perform to obtain at least one suitable path from the cell 1 1 to the cell n m It is guaranteed that the answer exists You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - простое\n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n          int a,b;\n          cin>>a>>b;\n          int m[a][b];\n          for (int i=0;i<a;i++) {\n              for (int j=0;j<b;j++) cin>>m[i][j]; \n          }\n          int min1=1000000000000000000;\n          int inf=1000000000000000000;\n          for (int i=0;i<a;i++) {\n              for (int j=0;j<b;j++) {\n                  int qq=m[i][j]-i-j; \n                  if (qq<=m[0][0]) { \n                  vector <vector<int>> dp(a,vector <int>(b)); \n                  dp[0][0]=m[0][0]-qq; \n                  for (int x=0;x<a;x++) {\n                      for (int y=0;y<b;y++) if (x+y>0) {\n                          dp[x][y]=inf; \n                          if (x>0) { if (m[x][y]>=qq+x+y) dp[x][y]=min(dp[x][y],dp[x-1][y]+m[x][y]-qq-x-y); } \n                          if (y>0) { if (m[x][y]>=qq+x+y) dp[x][y]=min(dp[x][y],dp[x][y-1]+m[x][y]-qq-x-y); } \n                      }\n                  }\n                  min1=min(min1,dp[a-1][b-1]); \n                  }\n              }\n          }\n   cout<<min1<<""\\n""; \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; // если нет запросов, то закоментить\n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Gerald got tired of playing board games with the usual six sided die and he bought a toy called Randomizer It functions as follows A Randomizer has its own coordinate plane on which a strictly convex polygon is painted the polygon is called a If you shake a Randomizer it draws some nondegenerate i e having a non zero area convex polygon with vertices at some vertices of the The result of the roll more precisely the result of the shaking is considered to be the number of points with integer coordinates which were strictly inside the points on the border are not considered the selected polygon Now Gerald is wondering what is the expected result of shaking the Randomizer During the shaking the Randomizer considers all the possible non degenerate convex polygons with vertices at the vertices of the Let s assume that there are versions of the polygons Then the Randomizer chooses each of them with probability ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define fi first\n#define se second\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\ntypedef long double LD;\nconst int N=101000;\nint n;\nll x[N],y[N];\nLD ans,pw[110];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%I64d%I64d"",x+i,y+i);\n\tpw[0]=1; rep(i,1,101) pw[i]=pw[i-1]/2;\n\tLD tot=1-pow(0.5,n)*(n*(n+1)/2+1);\n\tLD prob=1./4/tot;\n\trep(j,1,n) {\n\t\tLD r=prob; r*=1-pow(0.5,n-1-j);\n\t\tint k=j;\n\t\trep(i,0,n) {\n\t\t\tans+=r*(x[i]*y[k]-x[k]*y[i]-abs(__gcd(x[i]-x[k],y[i]-y[k])));\n\t\t\tif (k==n-1) k=0; else k++;\n\t\t}\n\t\tprob/=2;\n\t\tif (clock()>=2.2*CLOCKS_PER_SEC) break;\n\t}\n\tprintf(""%.10f\\n"",(double)ans/2+1);\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]",2800
Alice and Bob are playing a game They have two strings S and T of the same length n consisting of lowercase latin letters Players take turns alternately with Alice going first On her turn Alice chooses an integer i from 1 to n one of the strings S or T and any lowercase latin letter c and replaces the i th symbol in the chosen string with the character c On his turn Bob chooses one of the strings S or T and reverses it More formally Bob makes the replacement S operatorname rev S or T operatorname rev T where operatorname rev P P n P n 1 ldots P 1 The game lasts until the strings S and T are equal As soon as the strings become equal the game Define as the total number of moves made by both players during the game For example if Alice made 2 moves in total and Bob made 1 move then the duration of this game is 3 Alice s goal is to minimize the duration of the game and Bob s goal is to maximize the duration of the game What will be the duration of the game if both players play optimally It can be shown that the game will end in a finite number of turns ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nvoid mermermer()\n{\n\tint n;\n\tstring a,b;\n\tcin >> n >> a >> b;\n\tint ans1=0,ans2=0;\n\tfor(int i=0;i<n;i++) ans1+=a[i]!=b[i];\n\treverse(a.begin(),a.end());\n\tfor(int i=0;i<n;i++) ans2+=a[i]!=b[i];\n\tint ans=0,f=0,c=0;\n\twhile(1)\n\t{\n\t\tif(f==0&&c>=ans1) break;\n\t\tif(f==1&&c>=ans2) break;\n\t\tif(ans%2==0) ++c;\n\t\telse f^=1;\n\t\t++ans;\n\t}\n\tcout << ans << ""\\n"";\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) mermermer();\n\treturn 0;\n}\n//bu pa kun nan!!!']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1200
One day as Sherlock Holmes was tracking down one very important criminal he found a wonderful painting on the wall This wall could be represented as a plane The painting had several concentric circles that divided the wall into several parts Some parts were painted red and all the other were painted blue Besides any two neighboring parts were painted different colors that is the red and the blue color were alternating i e followed one after the other The outer area of the wall the area that lied outside all circles was painted blue Help Sherlock Holmes determine the total area of red parts of the wall ,"['#include<iostream>\n#include<vector>\n#include<string>\n#include<stack>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<queue>\n#include<sstream>\n#include<utility>\n\nusing std::pair;\nusing std::stringstream;\nusing std::next_permutation;\nusing std::sqrt;\nusing std::priority_queue;\nusing std::sort;\nusing std::stack;\nusing std::string;\nusing std::vector;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::min;\nusing std::max;\nusing std::set;\nusing std::swap;\nusing std::random_shuffle;\nusing std::queue;\nusing std::sin;\nusing std::cos;\nusing std::make_pair;\n\ntypedef long long ll; \ntypedef pair<ll, ll> pll;\nconst double PI = 3.14159265358979323846;  \n\n\n\nint main() {\n\tint n;\n\tcin >> n;\n\tvector<int> rad(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> rad[i];\n\tsort(rad.begin(), rad.end());\n\tint k = 1;\n\tint sum = 0;\n\tfor (int i = rad.size() - 1; i >= 0; --i) {\n\t\tsum = sum + k * rad[i] * rad[i];\n\t\tk = -k;\n\t}\n\tdouble s = PI * sum;\n\tprintf(""%0.10lf\\n"", s);\n\treturn 0;\t\n}\n                                             \n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1000
Vanya decided to walk in the field of size cells The field contains apple trees the th apple tree is at the cell with coordinates Vanya moves towards vector That means that if Vanya is now at the cell then in a second he will be at cell The following condition is satisfied for the vector where is the largest integer that divides both and Vanya ends his path when he reaches the square he has already visited Vanya wonders from what square of the field he should start his path to see as many apple trees as possible ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 1048576\nint co[MAX], ans[MAX];\nint main(){\n\tint n, m, dx, dy;\n\tcin >> n >> m >> dx >> dy;\n\tfor(int i = 0, nx = 0, ny = 0; i < n ; i++){\n\t\tco[nx] = ny;\n\t\tnx += dx;\n\t\tny += dy;\n\t\tnx %= n;\n\t\tny %= n;\n\t}\n\tint Max = 0, maxid;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tint t = (y+n-co[x])%n;\n\t\tans[t]++;\n\t\tif(ans[t] > Max){\n\t\t\tmaxid = t;\n\t\t\tMax = ans[t];\n\t\t}\n\t}\n\tcout << 0 << ' ' << maxid << endl;\n\n\treturn 0;\n}""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
As technologies develop manufacturers are making the process of unlocking a phone as user friendly as possible To unlock its new phone Arkady s pet dog Mu mu has to bark the password once The phone represents a password as a string of two lowercase English letters Mu mu s enemy Kashtanka wants to unlock Mu mu s phone to steal some sensible information but it can only bark distinct words each of which can be represented as a string of two lowercase English letters Kashtanka wants to bark several words not necessarily distinct one after another to pronounce a string containing the password as a substring Tell if it s possible to unlock the phone in this way or not ,"['#include <cstdio>\n\nchar a[4], b[101][4];\n\nint main() {\n\tint i, j, n;\n\tscanf(""%s%d"", a, &n);\n\tfor (i = 0; i < n; i++) scanf(""%s"", b[i]);\n\tfor (i = 0; i < n; i++) if (b[i][0] == a[0] && b[i][1] == a[1]) {\n\t\tputs(""YES"");\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < n; i++) for (j = 0; j < n; j++) if (b[i][0] == a[1] && b[j][1] == a[0]) {\n\t\tputs(""YES"");\n\t\treturn 0;\n\t}\n\tputs(""NO"");\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",900
Students of Winter Informatics School are going to live in a set of houses connected by underground passages Teachers are also going to live in some of these houses but they can not be accommodated randomly For safety reasons the following must hold All passages between two houses will be closed if there are no teachers in both of them All other passages will stay open It should be possible to travel between any two houses using the underground passages that are Teachers should not live in houses directly connected by a passage Please help the organizers to choose the houses where teachers will live to satisfy the safety requirements or determine that it is impossible ,"['/**\n *    author:  tourist\n *    created: 05.01.2021 18:05:09       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    vector<int> res(n, -1);\n    res[0] = 1;\n    vector<int> que;\n    for (int x : g[0]) {\n      que.push_back(x);\n      res[x] = 0;\n    }\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int v : g[que[b]]) {\n        if (res[v] == -1) {\n          res[v] = 1;\n          for (int x : g[v]) {\n            if (res[x] == -1) {\n              res[x] = 0;\n              que.push_back(x);\n            }\n          }\n        }\n      }\n    }\n    if (*min_element(res.begin(), res.end()) == -1) {\n      cout << ""NO"" << \'\\n\';\n      continue;\n    }\n    cout << ""YES"" << \'\\n\';\n    vector<int> ret;\n    for (int i = 0; i < n; i++) {\n      if (res[i] == 1) {\n        ret.push_back(i);\n      }\n    }\n    cout << ret.size() << \'\\n\';\n    for (int i = 0; i < (int) ret.size(); i++) {\n      if (i > 0) {\n        cout << "" "";\n      }\n      cout << ret[i] + 1;\n    }\n    cout << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Serval has two n bit binary integer numbers a and b He wants to share those numbers with Toxel Since Toxel likes the number b more Serval decides to change a into b by some possibly zero operations In an operation Serval can choose any integer k between 1 and n and change a into one of the following number a oplus a ll k a oplus a gg k In other words the operation moves every bit of a left or right by k positions where the overflowed bits are removed and the missing bits are padded with 0 The bitwise XOR of the shift result and the original a is assigned back to a Serval does not have much time He wants to perform n operations to change a into b Please help him to find out an operation sequence or determine that it is impossible to change a into b in at most n operations You do to minimize the number of operations In this problem x oplus y denotes the bitwise XOR operation of x and y a ll k and a gg k denote the logical left shift and logical right shift ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\nusing ll = long long;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string a, b;\n    cin >> a >> b;\n    if (a == b) {\n        cout << ""0\\n"";\n        return;\n    }\n    if (a == string(n, \'0\') || b == string(n, \'0\')) {\n        cout << ""-1\\n"";\n        return;\n    }\n    vector<int> ans;\n    auto Op = [&](int k) {\n        if (k > 0) {\n            for (int i = 0; i + k < n; ++i) {\n                a[i] ^= a[i + k] ^ \'0\';\n            }\n        } else {\n            for (int i = n - 1; i + k >= 0; --i) {\n                a[i] ^= a[i + k] ^ \'0\';\n            }\n        }\n        ans.push_back(k);\n    };\n    for (int i = 0; i < n; ++i) {\n        if (a[i] == b[i]) continue;\n        int bit = 0;\n        while (bit < n && a[bit] == \'0\') bit++;\n        if (i == bit) continue;\n        assert(bit != n);\n        Op(bit - i);\n        assert(a[i] == b[i]);\n    }\n    for (int i = n - 1; i >= 0; --i) {\n        if (a[i] == b[i]) continue;\n        int bit = n - 1;\n        while (bit >= 0 && a[bit] == \'0\') bit--;\n        assert(i != bit);\n        Op(bit - i);\n        assert(a[i] == b[i]);\n    }\n    int diff = 0;\n    for (int i = 0; i < n; ++i) diff += (a[i] != b[i]);\n    assert(diff == 0);\n    cout << ans.size() << \'\\n\';\n    for (auto &x: ans) cout << x << \' \';\n    cout << \'\\n\';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t = 1;\n    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}']","[0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2200
Vasya is studying in the last class of school and soon he will take exams He decided to study polynomials is a function Numbers are called of a polynomial non negative integer is called a of a polynomial Vasya has made a bet with his friends that he can solve any problem with polynomials They suggested him the problem Determine how many polynomials exist with coefficients so that and where and are given positive integers Vasya does not like losing bets but he has no idea how to solve this task so please help him to solve the problem ,"[""#include <cstdio>\n#include <map>\ntypedef long long LL;\ntypedef std::pair<LL, LL> node;\nconst int mod=1000000007;\n\nLL n, a, b;\ninline LL getint();\ninline void putint(int);\n\nstd::map<node, int> s;\nint solve(LL, LL);\n\nint main()\n{\n\tn=getint(), a=getint(), b=getint();\n\tif (n==1 && a==1)\n\t{\n\t\tif (b!=1) putint(0);\n\t\telse putchar('i'), putchar('n'), putchar('f'), putchar('\\n');\n\t}\n\telse if (n==a && a==b)\n\t\tputint(2);\n\telse\n\t\tputint(solve(a, b));\n\n\treturn 0;\n}\ninline LL getint()\n{\n\tregister LL num=0;\n\tregister char ch;\n\tdo ch=getchar(); while (ch<'0' || ch>'9');\n\tdo num=num*10+ch-'0', ch=getchar(); while (ch>='0' && ch<='9');\n\treturn num;\n}\ninline void putint(int num)\n{\n\tchar stack[11];\n\tregister int top=0;\n\tif (num==0) stack[top=1]='0';\n\tfor ( ;num;num/=10) stack[++top]=num%10+'0';\n\tfor ( ;top;top--) putchar(stack[top]);\n\tputchar('\\n');\n}\nint solve(LL x, LL y)\n{\n\tif (!x && !y) return 1;\n\tif (!x || !y) return 0;\n\tif (s.count(node(x, y))) return s[node(x, y)];\n\tint & t=s[node(x, y)];\n\tt=0;\n\tfor (LL i=y%a;i<=x;i+=a) if ((x-i)%n==0)\n\t\tt=(t+solve((x-i)/n, (y-i)/a))%mod;\n\treturn t;\n}\n""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2800
Let s call an array of size iff where is the greatest common divisor of the arguments You are given two numbers and For each you have to determine the number of arrays of size such that for every Since the answers can be very large you have to calculate them modulo ,"['#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, ""/STACK:167772160000"")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(""%d"", &n);\n#define read2(n, m) scanf(""%d%d"", &n, &m);\n#define readll(n) scanf(""%I64d"", &n);\n#define mp make_pair\nconst ll mod = 1000000007;\nconst int maxn = 2100000;\nvector<int>divisors[maxn];\nll power(ll a, ll b) {\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2 == 1)\n\t\t\tres = (res*a) % mod;\n\t\tb /= 2;\n\t\ta = (a*a) % mod;\n\t}\n\treturn res;\n}\n\nll multip[maxn];\nll takenIn[maxn];\nbool isPrime[maxn];\nll powers[maxn];\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\tint n, k; cin >> n >> k;\n\tswap(n, k);\n\tfori1(n)multip[i] = -1;\n\tmultip[1] = 0;\n\tll totalAns = 0;\n\tfori1(n)powers[i] = power(i, k);\n\tfori1(n)isPrime[i] = true;\n\tisPrime[1] = false;\n\tfori1(n) {\n\t\tif (multip[i] == 0)continue;\n\t\tif (isPrime[i])\n\t\t\tmultip[i] *= -1;\n\t\tfor (int j = i * 2; j <= n; j += i) {\n\t\t\tif (isPrime[i] && j % ((ll)i*i) == 0) {\n\t\t\t\tmultip[j] = 0;\n\t\t\t}\n\t\t\t//if(multip[i] != 0)\n\t\t\tdivisors[j].push_back(i);\n\t\t\tif(isPrime[i])\n\t\t\t\tisPrime[j] = false;\n\t\t\tif (isPrime[i])\n\t\t\t\tmultip[j] *= -1;\n\t\t}\n\t}\n\tll curAns = 0;\n\tfori1(n) {\n\t\tfor (auto x : divisors[i]) {\n\t\t\tcurAns -= multip[x] * takenIn[x];\n\t\t\ttakenIn[x] = powers[i/x];\n\t\t\tcurAns += multip[x] * takenIn[x];\n\t\t\tcurAns %= mod;\n\t\t}\n\t\ttakenIn[i] = 1;\n\t\tcurAns += multip[i]*1;\n\t\tll cur = powers[i] - curAns;\n\t\tcur %= mod;\n\t\tcur += mod;\n\t\tcur %= mod;\n\t\tcur ^= i;\n\t\tcur %= mod;\n\t\ttotalAns += cur;\n\t}\n\ttotalAns %= mod;\n\tcout << totalAns;\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2300
AquaMoon and Cirno are playing an interesting game with arrays Cirno has prepared two arrays a and b both consist of n non negative integers AquaMoon can perform the following operation an arbitrary number of times possibly zero She chooses two indices i and j 1 le i j le n then decreases the i th element of array a by 1 and increases the j th element of array a by 1 The resulting values at i th and j th index of array a are a i 1 and a j 1 respectively Each element of array a If i j this operation doesn t change the array a AquaMoon wants to make some operations to make arrays a and b equal Two arrays a and b are considered equal if and only if a i b i for all 1 leq i leq n Help AquaMoon to find a sequence of operations that will solve her problem or find that it is impossible to make arrays a and b equal Please note that you the number of operations ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"") \n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 1e16;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\nint n;\nint a[105],b[105];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n        }\n        for(int i = 1;i <= n;i++) {\n            cin >> b[i];\n        }\n        vec v,v2;\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= a[i]-b[i];j++) v.pb(i);\n            for(int j = 1;j <= b[i]-a[i];j++) v2.pb(i);\n        }\n        if(v.size() != v2.size()) {\n            cout << ""-1\\n"";\n            continue;\n        }\n        cout << v.size() << \'\\n\';\n        for(int i = 0;i < v.size();i++) {\n            cout << v[i] << \' \' << v2[i] << \'\\n\';\n        }\n    }\n}']","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Polycarpus likes giving presents to Paraskevi He has bought two chocolate bars each of them has the shape of a segmented rectangle The first bar is segments large and the second one is segments large Polycarpus wants to give Paraskevi one of the bars at the lunch break and eat the other one himself Besides he wants to show that Polycarpus s mind and Paraskevi s beauty are equally matched so the two bars must have the same number of squares To make the bars have the same number of squares Polycarpus eats a little piece of chocolate each minute Each minute he does the following he either breaks one bar exactly in half vertically horizontally and of the bar or he chips of exactly one third of a bar vertically or horizontally and of the bar In the first case he is left with a of the bar and in the second case he is left with of the bar Both variants aren t always possible and sometimes Polycarpus cannot chip off a half nor a third For example if the bar is then Polycarpus can chip off a half but not a third If the bar is then Polycarpus can chip off both a half and a third If the bar is then Polycarpus cannot chip off a half nor a third What is the minimum number of minutes Polycarpus needs to make two bars consist of the same number of squares Find not only the required minimum number of minutes but also the possible sizes of the bars after the process ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint n, m, x, c[1000001];\nmap<int, int> a1, a2, v1, v2;\nmap<long long, int> a, v;\n\nint main(){\n     //freopen(""d.in"", ""r"", stdin);\n     //freopen(""d.out"", ""w"", stdout);\n     scanf(""%d"", &x); a1.clear();\n     c[1] = x; a1[x] = 1;\n     for (int k = 1, l = 1; l <= k; l++)\n     {\n          int m = c[l];\n          if (!(m & 1) && !a1[m / 2])\n               a1[m / 2] = a1[m] + 1, c[++k] = m / 2;\n          if (!(m % 3) && !a1[m / 3])\n               a1[m / 3 * 2] = a1[m] + 1, c[++k] = m / 3 * 2;\n     }\n     \n     \n     scanf(""%d"", &x); a2.clear();\n     c[1] = x; a2[x] = 1;\n     for (int k = 1, l = 1; l <= k; l++)\n     {\n          int m = c[l];\n          if (!(m & 1) && !a2[m / 2])\n               a2[m / 2] = a2[m] + 1, c[++k] = m / 2;\n          if (!(m % 3) && !a2[m / 3])\n               a2[m / 3 * 2] = a2[m] + 1, c[++k] = m / 3 * 2;\n     }\n     \n     v1 = a1; v2 = a2;\n     \n     scanf(""%d"", &x); a1.clear();\n     c[1] = x; a1[x] = 1;\n     for (int k = 1, l = 1; l <= k; l++)\n     {\n          int m = c[l];\n          if (!(m & 1) && !a1[m / 2])\n               a1[m / 2] = a1[m] + 1, c[++k] = m / 2;\n          if (!(m % 3) && !a1[m / 3])\n               a1[m / 3 * 2] = a1[m] + 1, c[++k] = m / 3 * 2;\n     }\n     \n     scanf(""%d"", &x); a2.clear();\n     c[1] = x; a2[x] = 1;\n     for (int k = 1, l = 1; l <= k; l++)\n     {\n          int m = c[l];\n          if (!(m & 1) && !a2[m / 2])\n               a2[m / 2] = a2[m] + 1, c[++k] = m / 2;\n          if (!(m % 3) && !a2[m / 3])\n               a2[m / 3 * 2] = a2[m] + 1, c[++k] = m / 3 * 2;\n     }\n     \n     int ans = 0, x = 0, y = 0, z = 0, k = 0, Min1 = 1 << 30, Min2 = 1 << 30;\n     a.clear(); v.clear();\n     for (map<int, int>::iterator itr = a1.begin(); itr != a1.end(); itr++)\n          for (map<int, int>::iterator itr1 = a2.begin(); itr1 != a2.end(); itr1++)\n          {\n               if (a.find(1LL * itr->first * itr1->first) == a.end() || \n               itr->second + itr1->second - 2 < a[1LL * itr->first * itr1->first])\n               a[1LL * itr->first * itr1->first] = itr->second + itr1->second - 2,\n               v[1LL * itr->first * itr1->first] = itr->first;\n          }\n               \n     for (map<int, int>::iterator itr = v1.begin(); itr != v1.end(); itr++)\n          for (map<int, int>::iterator itr1 = v2.begin(); itr1 != v2.end(); itr1++)\n               if (a.find(1LL * itr->first * itr1->first) != a.end())\n               {\n                    int value = a[1LL * itr->first * itr1->first] + itr->second + \n                        itr1->second - 2;\n                    if (value < Min1) Min1 = value,\n                    x =  v[1LL * itr->first * itr1->first], y = 1LL * itr->first * itr1->first / x,\n                    z = itr->first, k = itr1->first;\n               }\n     if (Min1 == 1 << 30) printf(""-1\\n"");\n     else printf(""%d\\n%d %d\\n%d %d\\n"", Min1, z, k, x, y);\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1900
Vasya studies music He has learned lots of interesting stuff For example he knows that there are 12 notes He also knows that the notes are repeated cyclically after goes again and before stands We will consider the note in the row s beginning and the note after the similar and we will identify them with each other The distance between the notes along the musical scale is measured in tones between two consecutive notes there s exactly one semitone that is 0 5 tone The distance is taken from the lowest tone to the uppest one that is the distance between and is 4 semitones and between and is 8 semitonesVasya also knows what a chord is A chord is an unordered set of no less than three notes However for now Vasya only works with triads that is with the chords that consist of exactly three notes He can already distinguish between two types of triads major and minor Let s define a major triad Let the triad consist of notes and If we can order the notes so as the distance along the musical scale between and equals 4 semitones and the distance between and is 3 semitones then the triad is major The distance between and accordingly equals 7 semitones A minor triad is different in that the distance between and should be 3 semitones and between and 4 semitones For example the triad is major between and are 4 semitones and between and are 3 semitones And the triplet is minor because if we order the notes as than between and will be 3 semitones and between and 4 semitones Help Vasya classify the triad the teacher has given to him ,"['#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\nmap<string,int> XD;\nchar all[12][3]={\n    ""C"", ""C#"", ""D"", ""D#"", ""E"", ""F"", ""F#"", ""G"", ""G#"", ""A"", ""B"", ""H""\n};\nint gn(){\n    char tmp[3];\n    scanf(""%s"",tmp);\n    return XD[tmp];\n}\nint a[3];\nbool ismajor(){\n    return a[1]==(a[0]+4)%12&&a[2]==(a[1]+3)%12;\n}\nbool isminor(){\n    return a[1]==(a[0]+3)%12&&a[2]==(a[1]+4)%12;\n}\nint main(){\n    int i;\n    for(i=0;i<12;i++)XD[all[i]]=i;\n    for(i=0;i<3;i++)a[i]=gn();\n    sort(a,a+3);\n    do{\n\tif(ismajor()){\n\t    puts(""major"");\n\t    return 0;\n\t}\n\tif(isminor()){\n\t    puts(""minor"");\n\t    return 0;\n\t}\n    }while(next_permutation(a,a+3));\n    puts(""strange"");\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Apart from having lots of holidays throughout the year residents of Berland also have whole years Year is considered if it has no more than non zero digit in its number So years 100 40000 5 are and 12 3001 and 12345 are not You are given current year in Berland Your task is to find how long will residents of Berland wait till the next year ,"['#include<cstdio>\n#include<algorithm>\nlong long x,z=1,s[1007];\nint p=0;\nint main(){\n\tfor(int i=1;i<=10;++i){\n\t\tfor(int j=1;j<=9;++j)s[p++]=j*z;\n\t\tz*=10;\n\t}\n\tscanf(""%I64d"",&x);\n\tprintf(""%I64d"",*std::upper_bound(s,s+p,x)-x);\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
As he qualified for IOI this year Little Ericyi was given a gift from all his friends a tree of n nodes On the flight to IOI Little Ericyi was very bored so he decided to play a game with Little Yvonne with his new tree First Little Yvonne selects two not necessarily different nodes a and b on the tree without telling Ericyi and then gives him a hint f which is some node on the path from a to b Then Little Ericyi is able to ask the following question repeatedly If I rooted the tree at node r Ericyi gets to choose r what would be the Lowest Common Ancestor of a and b Little Ericyi s goal is to find the nodes a and b and report them to Little Yvonne However Little Yvonne thought this game was too easy so before he gives the hint f to Little Ericyi he also wants him to first find the maximum number of queries required to determine a and b over all possibilities of a b and f assuming Little Ericyi plays optimally Little Ericyi defines an optimal strategy as one that makes the minimum number of queries Of course once Little Ericyi replies with the maximum number of queries Little Yvonne will only let him use that many queries in the game The tree a b and f are all fixed before the start of the game and do not change as queries are made ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << endl; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nint N;\nvi adj[MX];\nint par[MX], depth[MX];\nint dp_sub[MX], op_query_sub[MX];\nint dp_without[MX], op_query_without[MX];\n\nvoid dfs(int x) { // if we know ans is in subtree of x, >= 1 query\n\tdp_sub[x] = 1; op_query_sub[x] = x;\n\tdepth[x] = depth[par[x]]+1;\n\tvpi child_dp;\n\teach(y,adj[x]) if (y != par[x]) {\n\t\tpar[y] = x;\n\t\tdfs(y);\n\t\tchild_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(child_dp));\n\tF0R(i,sz(child_dp)) {\n\t\tckmax(dp_sub[x],child_dp[i].f+i);\n\t\tif (i == 0) op_query_sub[x] = op_query_sub[child_dp[i].s];\n\t}\n}\n\nint get_opt_query(int x, int p) {\n\tassert(x && p);\n\tif (par[x] == p) {\n\t\tassert(op_query_sub[x]);\n\t\treturn op_query_sub[x];\n\t} else {\n\t\tassert(par[p] == x);\n\t\tassert(op_query_without[p]);\n\t\treturn op_query_without[p];\n\t}\n}\n\nvoid dfs2(int x) {\n\tdbg(""DFS2"",x);\n\tvpi child_dp;\n\teach(y,adj[x]) {\n\t\tif (y == par[x]) child_dp.pb({dp_without[x],y});\n\t\telse child_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(child_dp));\n\teach(t,child_dp) assert(t.f);\n\t// dbg(""GOT CHILD DP"",x,child_dp);\n\tvi pref(sz(child_dp)+1);\n\tvi suf(sz(child_dp)+1);\n\tF0R(i,sz(child_dp)) {\n\t\tpref[i+1] = max(pref[i],child_dp[i].f+i);\n\t}\n\tR0F(i,sz(child_dp)) {\n\t\tsuf[i] = max(suf[i+1],child_dp[i].f+i-1);\n\t}\n\tF0R(i,sz(child_dp)) {\n\t\tint y = child_dp[i].s;\n\t\tif (y != par[x]) {\n\t\t\tdp_without[y] = max(pref[i],suf[i+1]);\n\t\t\tif (dp_without[y] == 0) {\n\t\t\t\tassert(x == 1 && sz(adj[x]) == 1);\n\t\t\t\t// dbg(""LINE CASE"");\n\t\t\t\tdp_without[y] = 1;\n\t\t\t\top_query_without[y] = x;\n\t\t\t} else {\n\t\t\t\tif (i) op_query_without[y] = get_opt_query(child_dp[0].s,x);\n\t\t\t\telse {\n\t\t\t\t\tassert(i+1 < sz(child_dp));\n\t\t\t\t\top_query_without[y] = get_opt_query(child_dp[1].s,x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// dbg(""GEN DP WITHOUT"",y);\n\t\t\tassert(dp_without[y]);\n\t\t\tdfs2(y);\n\t\t}\n\t}\n}\n\nint queries_left;\n\nint query(int i) {\n\tassert(queries_left);\n\t--queries_left;\n\tps(""?"",i);\n\tints(x); \n\trtn x;\n}\n\nvoid finish(int ans) {\n\tps(""!"",ans);\n\texit(0);\n}\n\nvpi get_adj_dp(int x) {\n\tvpi adj_dp;\n\teach(y,adj[x]) {\n\t\tif (y == par[x]) adj_dp.pb({dp_without[x],y});\n\t\telse adj_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(adj_dp));\n\treturn adj_dp;\n}\n\nvpi get_adj_queries(int x) { // return {vert, vertex to query}\n\tvpi adj_dp;\n\teach(y,adj[x]) {\n\t\tif (y == par[x]) adj_dp.pb({dp_without[x],y});\n\t\telse adj_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(adj_dp));\n\teach(t,adj_dp) {\n\t\tswap(t.s,t.f);\n\t\tt.s = get_opt_query(t.f,x);\n\t}\n\treturn adj_dp;\n}\n\nvi endpoints;\n\nvb marked;\n\n// void process_query(int x, int y, int z) {\n// \tvi path = path_to(y,x);\n// \tif (z == x) {\n// \t\tmarked[path[sz(path)-2]] = 1;\n// \t}\n// }\n\nvi path_to(int a, int b) {\n\tvi st, en;\n\twhile (a != b) {\n\t\tif (depth[a] > depth[b]) {\n\t\t\tst.pb(a);\n\t\t\ta = par[a];\n\t\t} else {\n\t\t\ten.pb(b);\n\t\t\tb = par[b];\n\t\t}\n\t}\n\tst.pb(b);\n\treverse(all(en));\n\tst.ins(end(st),all(en));\n\treturn st;\n}\n\nvoid solve_subtree(int x, int p) {\n\tassert(marked.at(p));\n\tauto deal_path = [&](int y, int z) {\n\t\t// dbg(""DEAL PATH"",y,z);\n\t\tvi path = path_to(y,x);\n\t\tint ind = 0;\n\t\twhile (path.at(ind) != z) ++ind;\n\t\tx = path.at(ind);\n\t\tif (ind) marked[path.at(ind-1)] = 1;\n\t\tif (ind+1 < sz(path)) marked[path.at(ind+1)] = 1;\n\t};\n\t{\n\t\tint y = get_opt_query(x,p);\n\t\tint z = query(y); if (z == p) return;\n\t\tdeal_path(y,z);\n\t}\n\twhile (1) {\n\t\tassert(!marked.at(x));\n\t\tvpi cands;\n\t\t{\n\t\t\tvpi queries = get_adj_queries(x);\n\t\t\teach(t,queries) if (!marked.at(t.f)) cands.pb(t);\n\t\t}\n\t\tdbg(""FOUND"",x,cands);\n\t\tbool found = 0;\n\t\teach(t,cands) {\n\t\t\tint y = t.s; int z = query(y);\n\t\t\tif (z == x) continue;\n\t\t\tdeal_path(y,z);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (found) continue;\n\t\tendpoints.pb(x); return;\n\t}\n}\n\nvoid solve(int f) {\n\tvpi v = get_adj_dp(f);\n\teach(t,v) {\n\t\tsolve_subtree(t.s,f);\n\t\tif (sz(endpoints) == 2) break;\n\t}\n\twhile (sz(endpoints) < 2) endpoints.pb(f);\n\tps(""!"",endpoints[0],endpoints[1]);\n}\n\nint main() {\n\tre(N);\n\trep(N-1) {\n\t\tints(u,v);\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tdfs(1);\n\tdfs2(1);\n\tint ans = 0;\n\tFOR(x,1,N+1) {\n\t\tvpi adj_dp = get_adj_dp(x);\n\t\tF0R(i,sz(adj_dp)) {\n\t\t\tckmax(ans,adj_dp[i].f+i);\n\t\t\tif (i > 0) ckmax(ans,adj_dp[i].f+i+adj_dp[0].f-1);\n\t\t}\n\t}\n\t// FOR(x,1,N+1) dbg(x,op_query_sub[x],op_query_without[x]);\n\tps(ans);\n\tints(f);\n\tmarked = vb(N+1);\n\tmarked.at(f) = 1;\n\tqueries_left = ans;\n\tsolve(f);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3500
Dima s spent much time thinking what present to give to Inna and gave her an empty sequence Now they want to fill sequence with numbers zero and one For that they decided to play an amusing game Before the game begins Dima chooses integers Then Inna and Dima start playing that is adding numbers to sequence Each new number they choose is added to the end of the sequence At some moments of time Dima feels that the game is going to end too soon and he wants to play with Inna as long as possible so he hits a table hard with his fist At that the th th th th numbers from the beginning simultaneously fall out of the sequence the sequence gets numbers less Here is such maximum number that value doesn t exceed the current length of the sequence If number is larger than the current length of then nothing falls out of the sequence You are given the chronological sequence of events in the game Each event is either adding a number to the end of sequence or Dima s hit on the table Calculate the sequence after all these events happen ,"['#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <utility>\n#include <set>\n#include <map>\n\n#define reset(a , b) memset(a , b , sizeof(a))\n\nusing namespace std;\n\nconst int INF = 1000000007;\nconst int N = 5001000;\n\nint l[N] , h[N] , leaf[N] , node[N] , a[N] , cur;\nint  n , m , cmd[N] , nb , b[N];\n\nvoid build(int r , int low , int high ){\n    l[r] = low; h[r] = high;\n    if (low == high) {\n        leaf[low] = r;\n        return;\n    }\n    int mid = (low + high) / 2;\n    build(r*2,low,mid);\n    build(r*2+1,mid+1,high);\n}\n\nvoid update(int i , int val) {\n    i = leaf[i];\n    node[i] = val;\n    while (i > 1){\n        i /= 2;\n        node[i] = node[i * 2] + node[i * 2 + 1];\n    }\n}\n\nint Find(int r , int val) {\n    if (l[r] == h[r]) return l[r];\n    if (node[r*2] >= val)\n        return Find(r*2 , val);\n    else\n        return Find(r * 2 + 1 , val - node[r*2]);\n}\n\nint main() {\n    //freopen(""input.in"" , ""r"" , stdin);\n    //freopen(""output.out"" , ""w"" , stdout);\n\n    cin >> m >> n;\n    for (int i = 1 ; i <= n ; i++)\n        scanf(""%d"" , &a[i]);\n    build(1 , 1 , 1000001);\n\n    for (int i = 1 ; i <= m ; i++){\n        scanf(""%d"" , &cmd[i]);\n        if (cmd[i] == 1 || cmd[i] == 0)\n            update(i , 1),cur++;\n\n        if (cmd[i] == -1){\n            nb = 0;\n            for (int j = 1 ; j <= n ; j++){\n                if (a[j] > cur) break;\n                b[++nb] = Find(1 , a[j]);\n                //update(id , 0);\n            }\n            for (int j = 1 ; j <= nb ; j++)\n                update(b[j] , 0);\n            cur -= nb;\n        }\n    }\n    bool OK = true;\n    for (int i = 1 ; i <= m ; i++){\n        int j = leaf[i];\n        if (node[j] != 0){\n            printf(""%d"", cmd[i]);\n            OK = false;\n        }\n    }\n    if (OK) {\n        cout << ""Poor stack!"" << endl;\n        return 0;\n    }\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Overall there are actors in Berland Each actor has a personal identifier an integer from to distinct actors have distinct identifiers Vasya likes to watch Berland movies with Berland actors and he has favorite actors He watched the movie trailers for the next month and wrote the following information for every movie the movie title the number of actors who starred in it and the identifiers of these actors Besides he managed to copy the movie titles and how many actors starred there but he didn t manage to write down the identifiers of some actors Vasya looks at his records and wonders which movies may be his favourite and which ones may not be Once Vasya learns the exact cast of all movies his favorite movies will be determined as follows a movie becomes favorite movie if no other movie from Vasya s list has more favorite actors Help the boy to determine the following for each movie whether it surely will be his favourite movie whether it surely won t be his favourite movie can either be favourite or not ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\nusing namespace std;\nint m, k;\nbool favo[1000] = { };\nint mi[101], mx[101];\n\nint main() {\n\tfreopen(""input.txt"", ""r"", stdin);\n\tfreopen(""output.txt"", ""w"", stdout);\n\tcin >> m >> k;\n\tfor (int i = 0; i < k; ++i) {\n\t\tint x;\n\t\tcin >> x;\n\t\tfavo[x] = true;\n\t}\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint d;\n\t\tcin >> d;\n\t\tint unKnown = 0;\n\t\tint f = 0, nf = 0;\n\t\tfor (int j = 0; j < d; ++j) {\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\tif (t == 0) {\n\t\t\t\t++unKnown;\n\t\t\t} else {\n\t\t\t\tif (favo[t])\n\t\t\t\t\t++f;\n\t\t\t\telse\n\t\t\t\t\t++nf;\n\t\t\t}\n\t\t}\n\t\tint rf = k - f, rnf = m - k - nf;\n\t\t//min\n\t\tif (unKnown <= rnf)\n\t\t\tmi[i] = f;\n\t\telse\n\t\t\tmi[i] = unKnown - rnf + f;\n\t\t//max\n\t\tif (unKnown <= rf)\n\t\t\tmx[i] = f + unKnown;\n\t\telse\n\t\t\tmx[i] = f + rf;\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\t//check 0\n\t\tbool ok = true;\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tif (j != i) {\n\t\t\t\tif (mx[j] > mi[i]) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tif (ok) {\n\t\t\tputs(""0"");\n\t\t\tcontinue;\n\t\t}\n\t\tok = false;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (j != i) {\n\t\t\t\tif (mx[i] < mi[j]) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok) {\n\t\t\tputs(""1"");\n\t\t\tcontinue;\n\t\t}\n\t\tputs(""2"");\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
Natasha is going to fly to Mars She needs to build a rocket which consists of several stages in some order Each of the stages is defined by a lowercase Latin letter This way the rocket can be described by the string concatenation of letters which correspond to the stages There are n stages available The rocket must contain exactly k of them Stages in the rocket should be ordered by their weight So after the stage with some letter can go only stage with a letter which is at least two positions after in the alphabet skipping one letter in between or even more For example after letter can t go letters and but can go letters For the rocket to fly as far as possible its weight should be minimal The weight of the rocket is equal to the sum of the weights of its stages The weight of the stage is the number of its letter in the alphabet For example the stage weighs one ton weighs two tons and 26 tons Build the rocket with the minimal weight or determine that it is impossible to build a rocket at all Each stage can be used at most once ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nchar str[100];\n\nint main() {\n  int n,k;\n  scanf(""%d%d"",&n,&k);\n  scanf(""%s"",str+1);\n  sort(str+1,str+n+1);\n  int s=0,x=1,cnt=0;\n  while (x<=n&&cnt<k) {\n  \tcnt++;\n  \ts+=str[x]-\'a\'+1;\n  \tchar c=str[x];\n  \tfor(;x<=n&&str[x]-c<2;x++);\n  }\n  printf(""%d\\n"",(cnt<k)?-1:s);\n  return 0;\n}']","[1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
Vasya s birthday is approaching and Lena decided to sew a patterned handkerchief to him as a present Lena chose digits from to as the pattern The digits will form a rhombus The largest digit should be located in the centre The digits should decrease as they approach the edges For example for the handkerchief pattern should look like that 0 0 1 0 0 1 2 1 0 0 1 2 3 2 1 0 0 1 2 3 4 3 2 1 00 1 2 3 4 5 4 3 2 1 0 0 1 2 3 4 3 2 1 0 0 1 2 3 2 1 0 0 1 2 1 0 0 1 0 0Your task is to determine the way the handkerchief will look like by the given ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <string>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\n#define NextLine() { char c = getchar(); while (c != 10 && c != EOF) { c = getchar(); } }\n\nint n;\n\nvoid Load()\n{\n    cin >> n;\n}\n\nint res[30][30];\n\nvoid Solve()\n{\n    memset(res, 0xFF, sizeof(res));\n    int i, j;\n    for (i = 0; i <= n; i++)\n    {\n        int lj, rj;\n        lj = rj = n;\n        j = i;\n        while (j >= 0)\n        {\n            res[i][lj] = res[i][rj] = j;\n            j--;\n            lj--;\n            rj++;\n        }\n    }\n    int pos = n + 1;\n    for (i = n - 1; i >= 0; i--)\n    {\n        int lj, rj;\n        lj = rj = n;\n        j = i;\n        while (j >= 0)\n        {\n            res[pos][lj] = res[pos][rj] = j;\n            j--;\n            lj--;\n            rj++;\n        }\n        pos++;\n    }\n    for (i = 0; i < 2 * n + 1; i++)\n    {\n        int lst = 2 * n + 1;\n        while (res[i][lst] == -1) lst--;\n        for (j = 0; j <= lst; j++)\n        {\n            if (res[i][j] == -1) cout << "" "";\n            else cout << res[i][j];\n            if (j != lst) cout << "" "";\n        }\n        cout << ""\\n"";\n    }\n}\n\nint main()\n{\n    Load();\n    Solve();\n    return 0;\n}']","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Polycarp found on the street an array a of n elements Polycarp invented his criterion for the beauty of an array He calls an array a beautiful if at least one of the following conditions must be met i ne j a i is divisible by a j or a j is divisible by a i For example if n 5 and a 7 9 3 14 63 then the a array is not beautiful for i 4 and j 2 none of the conditions above is met n 3 and a 2 14 42 then the a array is beautiful n 4 and a 45 9 3 18 then the a array is not beautiful for i 1 and j 4 none of the conditions above is met Ugly arrays upset Polycarp so he wants to remove some elements from the array a so that it becomes beautiful Help Polycarp determine the smallest number of elements to remove to make the array a beautiful ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\ntemplate<class T> using V = vector<T>;\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, int SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, int SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef std::decay <decltype(MOD)>::type mod_t;\nstruct mi {\n    mod_t val;\n    explicit operator mod_t() const { return val; }\n    mi() { val = 0; }\n    mi(const long long& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend std::istream& operator >> (std::istream& in, mi& a) { \n        long long x; std::cin >> x; a = mi(x); return in; }\n    friend std::ostream& operator << (std::ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }    \n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (long long) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, long long p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nnamespace FactorBasic {\n\ntemplate <class T> std::vector<std::pair<T, int>> factor(T x) {\n    std::vector<std::pair<T, int>> pri;\n    for (T i = 2; i * i <= x; ++i) {\n        if (x % i == 0) {\n            int t = 0;\n            while (x % i == 0) x /= i, t++;\n            pri.push_back({i, t});\n        }\n    }\n    if (x > 1) pri.push_back({x, 1});\n    return pri;\n}\n\ntemplate <class T> T phi(T x) {\n    for (auto& a : factor(x)) x -= x / a.first;\n    return x;\n}\n\ntemplate <class T> void tour(std::vector<std::pair<T, int>>& v, std::vector<T>& res, int ind, T cur) {\n    if (ind == int(v.size())) res.push_back(cur);\n    else {\n        T mul = 1;\n        for (int i = 0; i < v[ind].second + 1; i++) {\n            tour(v, res, ind + 1, cur * mul);\n            mul *= v[ind].first;\n        }\n    }\n}\n\ntemplate <class T> std::vector<T> get_divisor(T x) {\n    auto v = factor(x);\n    std::vector<T> res; \n    tour(v, res, 0, (T) 1);\n    sort(res.begin(), res.end());\n    return res;\n}\n\n}\n\nusing namespace FactorBasic;\n\n\nconst int N = 2e5 + 5;\n\nvi divi[N];\nint dp[N];\n\nint main() {\n    setIO("""");\n    f1r(i, 1, N) {\n        divi[i] = get_divisor(i);\n        sort(all(divi[i]));\n    }\n\n    int tt; re(tt);\n    while (tt--) {\n        f1r(i, 1, N) dp[i] = 0;\n        int n; re(n);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        sort(all(a));\n        trav(x, a) {\n            int res = 0;\n            trav(d, divi[x]) {\n                if (x == d) break;\n                ckmax(res, dp[d] + 1);\n            }\n            ckmax(dp[x], max(res, dp[x] + 1));\n        }\n\n        int ans = 0;\n        f1r(i, 1, N) ckmax(ans, dp[i]);\n        ps(n - ans);\n    }\n    return 0;\n}']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1900
The floor office of international corporation CodeForces has the advanced elevator control system established It works as follows All office floors are sequentially numbered with integers from 1 to At time the elevator is on the first floor the elevator is empty and nobody is waiting for the elevator on other floors Next at times people come to the elevator For simplicity we assume that one person uses the elevator only once during the reported interval For every person we know three parameters the time at which the person comes to the elevator the floor on which the person is initially and the floor to which he wants to go The movement of the elevator between the floors is as follows At time is an integer the elevator is always at some floor First the elevator releases all people who are in the elevator and want to get to the current floor Then it lets in all the people waiting for the elevator on this floor If a person comes to the elevator exactly at time then he has enough time to get into it We can assume that all of these actions going in or out from the elevator are made instantly After that the elevator decides which way to move and at time the elevator gets to the selected floor The elevator selects the direction of moving by the following algorithm If the elevator is empty and at the current time no one is waiting for the elevator on any floor then the elevator remains at the current floor Otherwise let s assume that the elevator is on the floor number Then elevator calculates the directions priorities and is the sum of the number of people waiting for the elevator on the floors with numbers greater than and the number of people in the elevator who want to get to the floors with the numbers greater than is the sum of the number of people waiting for the elevator on the floors with numbers less than and the number of people in the elevator who want to get to the floors with the numbers less than If then the elevator goes one floor above the current one that is from floor to floor otherwise the elevator goes one floor below the current one that is from floor to floor Your task is to simulate the work of the elevator and for each person to tell the time when the elevator will get to the floor this person needs Please note that the elevator is large enough to accommodate all the people at once ,"['#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n\ntypedef long long int64;\n\nstruct Event\n{\n\tint floor, idx, target;\n\tfriend bool operator == (Event a, Event b)\n\t{\n\t\treturn a.idx == b.idx && a.floor == b.floor;\n\t}\n\tfriend bool operator < (Event a, Event b)\n\t{\n\t\treturn a.floor < b.floor || a.floor == b.floor && a.idx < b.idx;\n\t}\n\tstatic Event Null()\n\t{\n\t\tEvent ret;\n\t\tret.idx = -1;\n\t\treturn ret;\n\t}\n\tEvent(){}\n\tEvent(int a, int b, int c)\n\t{\n\t\tfloor = a, idx = b, target = c;\n\t}\n};\n\nstruct NODE{Event Val; int Pry, Size; struct NODE *L, *R;};\ntypedef struct NODE *TNODE;\n\nTNODE Head, Null;\n\ninline void Update(TNODE &Root){Root->Size= 1 + Root->L->Size + Root->R->Size;}\n\ninline void RotateLeft(TNODE &Root)\n{\n    TNODE Temp= Root->L;\n    Root->L= Temp->R;\n    Temp->R= Root;\n    Update(Root); Update(Temp);\n    Root= Temp;\n}\n\ninline void RotateRight(TNODE &Root)\n{\n    TNODE Temp= Root->R;\n    Root->R= Temp->L;\n    Temp->L= Root;\n    Update(Root); Update(Temp);\n    Root= Temp;\n}\n\nvoid Insert(TNODE &Root, Event Val)\n{\n    if(Root == Null)\n    {\n        Root= new(NODE);\n        Root->Val= Val;\n        Root->Size= 1;\n        Root->Pry= rand();\n        Root->L= Root->R= Null;\n        return ;\n    }\n    if(Root->Val < Val)\n    {\n        Insert(Root->R, Val);\n        if(Root->R->Pry < Root->Pry)RotateRight(Root);\n    }\n    else\n    {\n        Insert(Root->L, Val);\n        if(Root->L->Pry < Root->Pry)RotateLeft(Root);\n    }\n    Update(Root);\n}\n\nEvent FindNext(TNODE &Root, Event Val)\n{\n    if(Root == Null)return Event::Null();\n    if(Root->Val.floor < Val.floor)return FindNext(Root->R, Val);\n    Event Tmp= FindNext(Root->L, Val);\n    if(Tmp.idx != -1)return Tmp; else return Root->Val;\n}\n\nEvent FindPrev(TNODE &Root, Event Val)\n{\n    if(Root == Null)return Event::Null();\n    if(Val.floor < Root->Val.floor)return FindPrev(Root->L, Val);\n    Event Tmp= FindPrev(Root->R, Val);\n    if(Tmp.idx != -1)return Tmp; else return Root->Val;\n}\n\nint GetUp(TNODE &Root, int cur)\n{\n\tif(Root == Null)\n\t\treturn 0;\n\tif(Root->Val.floor > cur)\n\t\treturn Root->R->Size + 1 + GetUp(Root->L, cur);\n\treturn GetUp(Root->R, cur);\n}\n\nint GetDown(TNODE &Root, int cur)\n{\n\tif(Root == Null)\n\t\treturn 0;\n\tif(Root->Val.floor < cur)\n\t\treturn Root->L->Size + 1 + GetDown(Root->R, cur);\n\treturn GetDown(Root->L, cur);\n}\n\nvoid Delete(TNODE &Root, Event Val)\n{\n\tif(Root == Null)\n\t{\n\t\tprintf(""Delete Failed.\\n"");\n\t\texit(0);\n\t}\n\tif(Root->Val == Val)\n\t{\n\t\tif(Root->L == Null && Root->R == Null)\n\t\t{\n\t\t\tfree(Root);Root= Null; return ;\n\t\t}\n\t\tif(Root->L->Pry < Root->R->Pry)\n\t\t{\n\t\t\tRotateLeft(Root);\n\t\t\tDelete(Root->R, Val);\n\t\t}else\n\t\t{\n\t\t\tRotateRight(Root);\n\t\t\tDelete(Root->L, Val);\n\t\t}\n\t\tUpdate(Root);\n\t\treturn ;\n\t}\n\tif(Val < Root->Val)Delete(Root->L, Val);else Delete(Root->R, Val);\n\tUpdate(Root);\n}\n\nstruct Passenger\n{\n\tint t, s, f, idx;\n\tstatic bool Compare(Passenger a, Passenger b)\n\t{\n\t\treturn a.t < b.t;\n\t}\n}a[100005];\n\nint64 ans[100005];\n\nint n, m;\nint64 tick;\nint step;\n\nvoid Handle(Event x)\n{\n\tif(x.target == -1)\n\t{\n\t\t//printf(""Arrived : tick=%I64d, floor=%d, idx=%d\\n"", tick, x.floor, x.idx);\n\t\t++ step;\n\t\tans[x.idx] = tick;\n\t\tDelete(Head, x);\n\t}else\n\t{\n\t\t//printf(""Entered : tick=%I64d, floor=%d, target=%d, idx=%d\\n"", tick, x.floor, x.target, x.idx);\n\t\tDelete(Head, x);\n\t\tInsert(Head, Event(x.target, x.idx, -1));\n\t}\n}\n\nint main()\n{\n\tNull= new(NODE);\n\tNull->Val.idx = -1;\n    Null->Size= 0;\n    Null->Pry= 0x7fffffff;\n    Head= Null;\n\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i(1); i <= n; ++ i)\n\t{\n\t\tscanf(""%d%d%d"", &a[i].t, &a[i].s, &a[i].f);\n\t\ta[i].idx = i;\n\t}\n\tstd::sort(a + 1, a + 1 + n, Passenger::Compare);\n\tint pos = 1;\n\n\tEvent cur;\n\tcur.floor = 1;\n\twhile(step < n)\n\t{\n\t\tEvent Tmp;\n\t\twhile((Tmp = FindNext(Head, cur)).idx != -1)\n\t\t{\n\t\t\tif(Tmp.floor != cur.floor)\n\t\t\t\tbreak;\n\t\t\tHandle(Tmp);\n\t\t}\n\t\tif(step == n)\n\t\t\tbreak;\n\t\tif(Head->Size == 0)\n\t\t{\n\t\t\ttick = a[pos].t;\n\t\t\tfor(; pos <= n && a[pos].t == tick; ++ pos)\n\t\t\t{\n\t\t\t\t//printf(""Insert : tick=%I64d, cur=%d, floor=%d, idx=%d\\n"", tick, cur.floor, a[pos].s, a[pos].idx);\n\t\t\t\tInsert(Head, Event(a[pos].s, a[pos].idx, a[pos].f));\n\t\t\t}\n\t\t}else\n\t\t{\n\t\t\tint64 nextTime = tick;\n\t\t\tint Up = GetUp(Head, cur.floor), Down = GetDown(Head, cur.floor);\n\t\t\tEvent Next = FindNext(Head, cur), Prev = FindPrev(Head, cur);\n\t\t\tif(Up >= Down)\n\t\t\t\tnextTime += Next.floor - cur.floor;\n\t\t\telse\n\t\t\t\tnextTime += cur.floor - Prev.floor;\n\t\t\tif(pos <= n && a[pos].t <= nextTime)\n\t\t\t{\n\t\t\t\tint64 old = tick;\n\t\t\t\ttick = a[pos].t;\n\t\t\t\tfor(; pos <= n && a[pos].t == tick; ++ pos)\n\t\t\t\t{\n\t\t\t\t\t//printf(""Insert : tick=%I64d, cur=%d, floor=%d, idx=%d\\n"", tick, cur.floor, a[pos].s, a[pos].idx);\n\t\t\t\t\tInsert(Head, Event(a[pos].s, a[pos].idx, a[pos].f));\n\t\t\t\t}\n\t\t\t\tcur.floor = Up >= Down ? cur.floor + tick - old : cur.floor - tick + old;\n\t\t\t}else\n\t\t\t{\n\t\t\t\ttick = nextTime;\n\t\t\t\tcur.floor = Up >= Down ? Next.floor : Prev.floor;\n\t\t\t}\n\t\t}\n\n\t}\n\tfor(int i(1); i <= n; ++ i)\n\t\tprintf(""%I64d\\n"", ans[i]);\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
n heroes fight against each other in the Arena Initially the i th hero has level a i Each minute a fight between two different heroes occurs These heroes can be chosen arbitrarily When two heroes of equal levels fight nobody wins the fight When two heroes of different levels fight the one with the higher level wins and his level increases by 1 The winner of the tournament is the first hero that wins in at least 100 500 fights A is a hero such that there exists a sequence of fights that this hero becomes the winner of the tournament Calculate the number of among n heroes ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n\nvoid solve() {\n\n    int N; cin >> N;\n    vi A(N); F0R(i, N) cin >> A[i];\n    int cnt[101];\n    F0R(i, 101) cnt[i] = 0;\n    F0R(i, N) cnt[A[i]]++;\n    int lo= 101; F0R(i, N) ckmin(lo, A[i]);\n    cout << N - cnt[lo] << nl;\n\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
To get money for a new aeonic blaster ranger Qwerty decided to engage in trade for a while He wants to buy some number of items or probably not to buy anything at all on one of the planets and then sell the bought items on another planet Note that this operation is not repeated that is the buying and the selling are made only once To carry out his plan Qwerty is going to take a bank loan that covers all expenses and to return the loaned money at the end of the operation the money is returned without the interest At the same time Querty wants to get as much profit as possible The system has planets in total On each of them Qwerty can buy or sell items of types such as food medicine weapons alcohol and so on For each planet and each type of items Qwerty knows the following the cost of buying an item the cost of selling an item the number of remaining items It is not allowed to buy more than items of type on planet but it is allowed to sell any number of items of any kind Knowing that the hold of Qwerty s ship has room for no more than items determine the maximum profit which Qwerty can get ,"['#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long i64;\ntypedef unsigned long long ui64;\n\nconst int intINF=999999999;\nconst i64 i64INF=99999999999999999ll;\nconst double doubleINF=9999999999.;\n\nusing namespace std;\n\nstruct good{int pr,q;};\n\nint res=0;\nint n,m,k;\nint p[11][111][4];\n\nint max(int a,int b){\n\tif(a<b) a=b;\n\treturn a;\n}\n\nbool gsort(good a,good b){\n\treturn a.pr>b.pr;\n}\n\nvoid go(int fr,int to){\n\tgood g[111];\n\tfor(int i=1;i<=m;i++){\n\t\tg[i].q=p[fr][i][3];\n\t\tg[i].pr=p[to][i][2]-p[fr][i][1];\n\t}\n\tg[m+1].q=9999999;\n\tg[m+1].pr=0;\n\tsort(g+1,g+m+2,gsort);\n\tint left=k,got=0,cnt=1;\n\twhile(left>0){\n\t\tif(g[cnt].q>left){\n\t\t\tgot+=g[cnt].pr*left;\n\t\t\tleft=0;\n\t\t}\n\t\telse{\n\t\t\tgot+=g[cnt].pr*g[cnt].q;\n\t\t\tleft-=g[cnt].q;\n\t\t\tg[cnt].q=0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\tres=max(res,got);\n}\n\nint main(){\n\tchar c;\n\tscanf(""%d%d%d%*c"",&n,&m,&k);\n\tfor(int i=1;i<=n;i++){\n\t\twhile(scanf(""%c"",&c),c!=\'\\n\');\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tfor(int h=1;h<=3;h++)\n\t\t\t\tscanf(""%d"",&p[i][j][h]);\n\t\tscanf(""%*c"");\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tgo(i,j);\n\tprintf(""%d\\n"",res);\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
You are fed up with your messy room so you decided to clean it up Your room is a bracket sequence s s 1 s 2 dots s n of length n Each character of this string is either an opening bracket or a closing bracket In one operation you can choose any consecutive substring of s and reverse it In other words you can choose any substring s l dots r s l s l 1 dots s r and change the order of elements in it into s r s r 1 dots s l For example if you will decide to reverse substring s 2 dots 4 of string s it will be equal to s A aka balanced bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are and and are not A prefix of a string s is a substring that starts at position 1 For example for s there are 6 prefixes and In your opinion a neat and clean room s is a bracket sequence that the whole string s is a bracket sequence there are exactly k prefixes of this sequence which are regular including whole s itself For example if k 2 then is a neat and clean room You want to use at most n operations to make your room neat and clean Operations are applied one after another sequentially It is guaranteed that the answer exists Note that you to minimize the number of operations find any way to achieve the desired configuration in n or less operations ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n#ifdef LOCAL\n  freopen(""input.txt"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    string s, t;\n    cin >> n >> m >> s;\n    for (int i = 0; i < n / 2 - (m - 1); ++i) {\n      t.push_back(\'(\');\n    }\n    for (int i = 0; i < n / 2 - (m - 1); ++i) {\n      t.push_back(\')\');\n    }\n    for (int i = 0; i < m - 1; ++i) {\n      t.push_back(\'(\');\n      t.push_back(\')\');\n    }\n    vector<pair<int, int>> ans;\n    for (int i = 0; i < n; ++i) {\n      if (s[i] != t[i]) {\n        int j = i;\n        while (j < n && s[j] != t[i]) {\n          j++;\n        }\n        reverse(s.begin() + i, s.begin() + j + 1);\n        ans.emplace_back(i + 1, j + 1);\n      }\n    }\n    cout << ans.size() << ""\\n"";\n    for (auto p : ans) {\n      cout << p.first << "" "" << p.second << ""\\n"";\n    }\n  }\n  return 0;\n}\n']","[1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Omkar s most recent follower Ajit has entered the Holy Forest Ajit realizes that Omkar s forest is an n by m grid 1 leq n m leq 2000 of some non negative integers Since the forest is blessed by Omkar it satisfies some special conditions For any two adjacent sharing a side cells the absolute value of the difference of numbers in them is at most 1 If the number in some cell is strictly larger than 0 it should be strictly greater than the number in of the cells adjacent to it Unfortunately Ajit is not fully worthy of Omkar s powers yet He sees each cell as a 0 or a If a cell is labeled as 0 then the number in it must equal 0 Otherwise the number in it can be any nonnegative integer Determine how many different assignments of elements exist such that these special conditions are satisfied Two assignments are considered different if there exists at least one cell such that the numbers written in it in these assignments are different Since the answer may be enormous find the answer modulo 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2005,mod=1e9+7;\nll n,m,ans,c1,c2;\nchar s[N][N];\nint read()\n{\n\tint res=0,fl=0; char a=getchar();\n\twhile(a<\'0\'||a>\'9\') fl|=a==\'-\',a=getchar();\n\twhile(a>=\'0\'&&a<=\'9\') res=res*10+a-\'0\',a=getchar();\n\treturn fl? -res:res;\n}\nll ksm(ll di,ll mi) {ll res=1; for(;mi;mi>>=1,di=di*di%mod) if(mi&1) res=res*di%mod; return res;}\n//ll c(ll a,ll b) {return a>=b? jc[a]*jv[b]%mod*jv[a-b]%mod:0;}\nint main()\n{\n\tint i,j,t=read();\n\twhile(t--)\n\t{\n\t\tn=read(),m=read(),c1=0,c2=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(scanf(""%s"",s[i]+1),j=1;j<=m;j++) if(s[i][j]==\'#\') c1++; else c2++;\n\t\tcout<<(ksm(2,c1)+mod-1+(!!c2))%mod<<\'\\n\';\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]",2300
An electrical grid in Berland palaces consists of 2 grids main and reserve Wires in palaces are made of expensive material so selling some of them would be a good idea Each grid main and reserve has a head node its number is 1 Every other node gets electricity from the head node Each node can be reached from the head node by a unique path Also both grids have exactly n nodes which do not spread electricity further In other words every grid is a rooted directed tree on n leaves with a root in the node which number is 1 Each tree has independent enumeration and nodes from one grid are not connected with nodes of another grid Also the palace has n electrical devices Each device is connected with one node of the main grid and with one node of the reserve grid Devices connect only with nodes from which electricity is not spread further these nodes are the tree s leaves Each grid s leaf is connected with exactly one device It is guaranteed that the whole grid two grids and n devices can be shown in this way like in the picture above main grid is a top tree whose wires are directed from the top to the down reserve grid is a lower tree whose wires are directed from the down to the top devices horizontal row between two grids which are numbered from 1 to n from the left to the right wires between nodes do not intersect Formally for each tree exists a depth first search from the node with number 1 that visits leaves in order of connection to devices 1 2 dots n firstly the node that is connected to the device 1 then the node that is connected to the device 2 etc Businessman wants to sell remove amount of wires so that each device will be powered from at least one grid main or reserve In other words for each device should exist at least one path to the head node in the main grid or the reserve grid which contains only nodes from one grid ,"['#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nint dp[2][1002]; // last used left(0), right(1). other side was used by (j-1)\nint ndp[2][1002];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  int A, B;\n  scanf(""%d"", &A);\n  vector<int> pA(A, -1), dA(n);\n  for (int i = 1; i < A; i++) { scanf(""%d"", &pA[i]); pA[i]--; }\n  for (int i = 0; i < n; i++) { scanf(""%d"", &dA[i]); dA[i]--; }\n  scanf(""%d"", &B);\n  vector<int> pB(B, -1), dB(n);\n  for (int i = 1; i < B; i++) { scanf(""%d"", &pB[i]); pB[i]--; }\n  for (int i = 0; i < n; i++) { scanf(""%d"", &dB[i]); dB[i]--; }\n  vector<vector<int>> aPath;\n  for (int i = 0; i < A; i++) {\n    vector<int> cur;\n    int p = i;\n    while (p != 0) {\n      cur.push_back(p);\n      p = pA[p];\n    }\n    aPath.emplace_back(cur);\n  }\n  vector<vector<int>> bPath;\n  for (int i = 0; i < B; i++) {\n    vector<int> cur;\n    int p = i;\n    while (p != 0) {\n      cur.push_back(p);\n      p = pB[p];\n    }\n    bPath.emplace_back(cur);\n  }\n\n  for (int i = 0; i < n; i++) {\n    set<int> sideAcache, sideBcache;\n    sideAcache.insert(aPath[dA[i]].begin(), aPath[dA[i]].end());\n    sideBcache.insert(bPath[dB[i]].begin(), bPath[dB[i]].end());\n\n    for (int side = 0; side < 2; side++) fill(ndp[side], ndp[side] + 1002, INT_MAX/2);\n    for (int side = 0; side < 2; side++) {\n      int same_cost = 0;\n      if (side == 0) {\n        same_cost = sideAcache.size();\n      } else {\n        same_cost = sideBcache.size();\n      }\n      if (i > 0) {\n        if (side == 0) {\n          for (auto p : aPath[dA[i - 1]]) if (sideAcache.count(p)) same_cost--;\n        } else {\n          for (auto p : bPath[dB[i - 1]]) if (sideBcache.count(p)) same_cost--;\n        }\n      }\n\n      for (int j = 0; j <= i; j++) {\n        int last_other = j - 1;\n        int base = dp[side][j];\n        if (base >= INT_MAX / 2) continue;\n        // use same side\n        {\n          ndp[side][j] = min(ndp[side][j], base + same_cost);\n        }\n        // use different side\n        {\n          int diff_cost = (side == 0) ? sideBcache.size() : sideAcache.size();\n          if (last_other >= 0) {\n            if (side == 0) { // use B side\n              int bans = bPath[dB[last_other]].size();\n              int low = 0, high = bans - 1;\n              while (low <= high) {\n                int mid = (low + high) >> 1;\n                if (sideBcache.count(bPath[dB[last_other]][mid])) {\n                  bans = mid;\n                  high = mid - 1;\n                } else {\n                  low = mid + 1;\n                }\n              }\n              diff_cost -= (int)bPath[dB[last_other]].size() - bans;\n            } else { // use A side\n              int bans = aPath[dA[last_other]].size();\n              int low = 0, high = bans - 1;\n              while (low <= high) {\n                int mid = (low + high) >> 1;\n                if (sideAcache.count(aPath[dA[last_other]][mid])) {\n                  bans = mid;\n                  high = mid - 1;\n                } else {\n                  low = mid + 1;\n                }\n              }\n              diff_cost -= (int)aPath[dA[last_other]].size() - bans;\n            }\n          }\n          ndp[side ^ 1][i] = min(ndp[side ^ 1][i], base + diff_cost);\n        }\n      }\n    }\n    memcpy(dp, ndp, sizeof(dp));\n  }\n  int ans = min(*min_element(ndp[0], ndp[0] + 1002), *min_element(ndp[1], ndp[1] + 1002));\n  ans = A + B - ans - 2;\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2400
To make a paper airplane one has to use a rectangular piece of paper From a sheet of standard size you can make s airplanes A group of k people decided to make n airplanes each They are going to buy several packs of paper each of them containing p sheets and then distribute the sheets between the people Each person should have enough sheets to make n airplanes How many packs should they buy ,"['#include <bits/stdc++.h>\n\n#define ll long long\n#define pb push_back\n#define f first\n#define s second\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint k, n, s, p;\n\nint main() {\n cin >> k >> n >> s >> p;\n cout << (((n + s - 1) / s) * k + p - 1) / p;\n return 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
A revolution took place on the Buka Island New government replaced the old one The new government includes parties and each of them is entitled to some part of the island according to their contribution to the revolution However they can t divide the island The island can be conventionally represented as two rectangles and unit squares in size correspondingly The rectangles are located close to each other At that one of the sides with the length of and one of the sides with the length of lie on one line You can see this in more details on the picture The th party is entitled to a part of the island equal to unit squares Every such part should fully cover several squares of the island it is not allowed to cover the squares partially and be a connected figure A connected figure presupposes that from any square of this party one can move to any other square of the same party moving through edge adjacent squares also belonging to that party Your task is to divide the island between parties ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nchar s[105][105];\n\n#define h(x) (x >= a ? d : b)\n\nint main (void)\n{\n  int a, b, c, d, n;\n  scanf(""%d%d%d%d%d"", &a, &b, &c, &d, &n);\n\n  for (int i=0; i<max(b,d); i++)\n    memset(s[i], \'.\', a + c);\n\n  int x = 0, y = 0, dy = 1;\n  if (a % 2 == 1) {\n    y = b - 1;\n    dy = -1;\n  }\n\n  for (int i=0; i<n; i++) {\n    int t;\n    scanf(""%d"", &t);\n    while (t--) {\n//      cerr << y << "" "" << x << "" "" << i << endl;\n      s[y][x] = \'a\' + i;\n      y += dy;\n      if (y < 0) {\n        y = 0;\n        x++;\n        dy = 1;\n      } else if (y >= h(x)) {\n        x++;\n        y=h(x) - 1;\n        dy = -1;\n      }\n    }\n  }\n\n  puts(""YES"");\n\n  for (int i=0; i<max(b,d); i++)\n    puts(s[i]);\n  \n  return 0;\n}']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1900
Valera is a coder Recently he wrote a funny program The pseudo code for this program is given below input integers x k pa x for step 1 step k step step 1 rnd random integer from 1 to 100 if rnd p a a 2 else a a 1 s 0 while remainder after dividing a by 2 equals 0 a a 2 s s 1 Now Valera wonders given the values and what is the expected value of the resulting number ,"['#include <cstdio>\n\nint count(int x) {\n    if (x == 0)\n        return 0;\n    int ret = 0;\n    for (; x % 2 == 0; x /= 2)\n        ++ ret;\n    return ret;\n}\n\nint get(int x) {\n    int ret = count(x);\n    if (ret > 0)\n        return 50 + ret;\n    else\n        return 51 - count(x + 1);\n}\n\ndouble dp[201][300][256];\n\nint add(int x) {\n    if (x > 50)\n        return 50;\n    else {\n        x = 51 - x;\n        return x + 50;\n    }\n}\n\nint mul(int x, int y) {\n    y /= 128;\n    if (y == 0) {\n        if (x <= 50)\n            return 51;\n        else\n            return x + 1;\n    } else {\n        if (x <= 50)\n            return x - 1;\n        else\n            return 50;\n    }\n}\n\nint main() {\n    int x, k, p;\n    scanf(""%d%d%d"", &x, &k, &p);\n    if (x < 256)\n        x += 1 << 20;\n    dp[0][get(x / 256)][x % 256] = 1;\n    for (int i = 0; i < k; ++ i)\n        for (int j = 0; j < 300; ++ j) {\n            for (int l = 0; l < 256; ++ l)\n                if (dp[i][j][l] > 0) {\n                    if (l >= 128)\n                        dp[i + 1][mul(j, l)][l * 2 - 256] += p / 100.0 * dp[i][j][l];\n                    else\n                        dp[i + 1][mul(j, l)][l * 2] += p / 100.0 * dp[i][j][l];\n                    if (l == 255)\n                        dp[i + 1][add(j)][0] += (100 - p) / 100.0 * dp[i][j][l];\n                    else\n                        dp[i + 1][j][l + 1] += (100 - p) / 100.0 * dp[i][j][l];\n                }\n        }\n    double ans = 0;\n    for (int j = 0; j <= 50; ++ j)\n        ans += dp[k][j][0] * 8;\n    for (int j = 51; j < 300; ++ j)\n        ans += dp[k][j][0] * (8 + j - 50);\n    for (int i = 1; i < 256; ++ i) {\n        int cnt = count(i);\n        for (int j = 0; j < 300; ++ j)\n            ans += dp[k][j][i] * cnt;\n    }\n    printf(""%.12f\\n"", ans);\n    return 0;\n}\n']","[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2400
Information technologies are developing and are increasingly penetrating into all spheres of human activity Incredible as it is the most modern technology are used in farming A large farm has a meadow with grazing sheep Overall there are sheep and each of them contains a unique number from 1 to because the sheep need to be distinguished and you need to remember information about each one and they are so much alike The meadow consists of infinite number of regions numbered from 1 to infinity It s known that sheep likes regions from to There are two shepherds taking care of the sheep First and Second First wakes up early in the morning and leads the sheep graze on the lawn Second comes in the evening and collects all the sheep One morning First woke up a little later than usual and had no time to lead the sheep graze on the lawn So he tied together every two sheep if there is a region they both like First thought that it would be better Second would have less work in the evening because sheep won t scatter too much being tied to each other In the evening Second came on the lawn gathered the sheep and tried to line them up in a row But try as he might the sheep wouldn t line up as Second want Second had neither the strength nor the ability to untie the sheep so he left them as they are but with one condition he wanted to line up the sheep so that the maximum distance between two tied sheep was as small as possible The distance between the sheep is the number of sheep in the ranks that are between these two Help Second find the right arrangement ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(""%d"", &x); return x; }\n\n#define MAXN 2010\n\nint N;\nint A[MAXN], B[MAXN];\nbool G[MAXN][MAXN];\n\nint L[MAXN], M[MAXN];\nbool S[MAXN];\nint cnt[MAXN];\n\nbool solve(int k) {\n// cout<<""**** k = ""<<k<<"" ****""<<endl;\n\tint u;\n\tfor (u = 0; u < N; ++u) {\n\t\tL[u] = 0;\n\t\tM[u] = N;\n\t\tS[u] = 1;\n\t}\n\tint q = 0, j;\n\tfor (; ; ) {\n\t\tint um = -1;\n\t\tfor (u = 0; u < N; ++u) if (S[u]) {\n\t\t\tif (!~um || B[um] > B[u]) {\n\t\t\t\tum = u;\n\t\t\t}\n\t\t}\n// cout<<""um = ""<<um<<endl;\n\t\tL[um] = ++q;\n\t\tif (q == N) {\n\t\t\treturn 1;\n\t\t}\n\t\tfor (u = 0; u < N; ++u) if (!L[u]) {\n\t\t\tif (G[um][u] && M[u] == N) {\n\t\t\t\tM[u] = min(L[um] + k, N);\n\t\t\t}\n\t\t}\n\t\tmemset(cnt, 0, (N + 1) * 4);\n\t\tfor (u = 0; u < N; ++u) if (!L[u]) {\n\t\t\t++cnt[max(M[u] - q, 0)];\n\t\t}\n\t\tfor (j = 1; j <= N; ++j) {\n\t\t\tcnt[j] += cnt[j - 1];\n\t\t}\n// cout<<""L : "";pv(L,L+N);\n// cout<<""M : "";pv(M,M+N);\n// cout<<""cnt : "";pv(cnt,cnt+N+1);\n\t\tfor (j = max(k - q + 1, 0); j <= N; ++j) {\n\t\t\tif (cnt[j] > j) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tfor (j = max(k - q + 1, 1); j <= N; ++j) {\n\t\t\tif (cnt[j] == j) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (u = 0; u < N; ++u) {\n\t\t\tS[u] = !L[u] && (M[u] <= q + j);\n\t\t}\n// cout<<""j = ""<<j<<endl;\n// cout<<""S : "";pv(S,S+N);\n\t}\n}\n\n\nint perm[MAXN];\n\nint brute() {\n\tint u, v;\n\tfor (u = 0; u < N; ++u) {\n\t\tperm[u] = u;\n\t}\n\tint opt = N;\n\tdo {\n\t\tint tmp = 0;\n\t\tfor (u = 0; u < N; ++u) for (v = u + 1; v < N; ++v) if (G[u][v]) {\n\t\t\tchmax(tmp, abs(perm[u] - perm[v]));\n\t\t}\n\t\tchmin(opt, tmp);\n\t} while (next_permutation(perm, perm + N));\n\treturn opt;\n}\n\nint ans[MAXN];\n\nint main() {\n\tint u, v;\n\tint q;\n\t\n\tfor (; ~scanf(""%d"", &N); ) {\n\t\tfor (u = 0; u < N; ++u) {\n\t\t\tA[u] = in();\n\t\t\tB[u] = in();\n\t\t}\n\t\tfor (u = 0; u < N; ++u) for (v = 0; v < N; ++v) if (u != v) {\n\t\t\tG[u][v] = (A[u] <= B[v] && A[v] <= B[u]);\n\t\t}\n\t\tint lo = -1, ho = N - 1;\n\t\tfor (; lo + 1 < ho; ) {\n\t\t\tint mo = (lo + ho) / 2;\n\t\t\t(solve(mo) ? ho : lo) = mo;\n\t\t}\n\t\tsolve(ho);\n// cout<<""k = ""<<ho<<endl;\n// cout<<""L : "";pv(L,L+N);\n// assert(ho==brute());\nfor(u=0;u<N;++u)for(v=u+1;v<N;++v)if(G[u][v])assert(abs(L[u]-L[v])<=ho);\n\t\tfor (u = 0; u < N; ++u) {\n\t\t\tans[L[u]] = u;\n\t\t}\n\t\tfor (q = 1; q <= N; ++q) {\n\t\t\tif (q > 1) printf("" "");\n\t\t\tprintf(""%d"", ans[q] + 1);\n\t\t}\n\t\tputs("""");\n\t}\n\t\n\treturn 0;\n}\n\n']","[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2900
At a geometry lesson Bob learnt that a triangle is called right angled if it is nondegenerate and one of its angles is right Bob decided to draw such a triangle immediately on a sheet of paper he drew three points with integer coordinates and joined them with segments of straight lines then he showed the triangle to Peter Peter said that Bob s triangle is not right angled but is right angled the triangle itself is not right angled but it is possible to move one of the points exactly by distance 1 so that all the coordinates remain integer and the triangle become right angled Bob asks you to help him and find out if Peter tricks him By the given coordinates of the triangle you should find out if it is right angled almost right angled or neither of these ,"['#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <functional>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <cstdarg>\n\nusing namespace std;\n\n#define TASKNAME ""f""\n#define pb push_back\n#define mp make_pair\n#define first fi\n#define second se\n#define forn(i, n) for (int i=0; i<(int)n; i++)\n#define all(a) a.begin(), a.end()\n\ntypedef long double ldb;\ntypedef long long lld;\ntypedef unsigned long long uld;\ntypedef vector<int> vi;\ntypedef complex<double> cd;\n\ndouble const eps=1e-9;\nldb const epsl=1e-9;\nint const inf=0x3fffffff;\nint const infu=0x7fffffff;\nlld const infl=0x3fffffffffffffffLL;\nuld const inful=0x7fffffffffffffffLL;\ntemplate <class T>\ninline T sqr(const T &a) {\n    return a*a;\n}\nint X[3], Y[3], x[3], y[3];\nbool vp(int x1, int y1, int x2, int y2) {\n    return (x1*x1+y1*y1) && (x2*x2+y2*y2) && !(x1*x2+y1*y2);    \n}\n\n\nint main () {\n//  freopen (TASKNAME"".in"", ""r"", stdin);\n//  freopen (TASKNAME"".out"", ""w"", stdout);\n    forn(i,3)\n        cin >> x[i] >> y[i];\n    for (int i=0; i<3; i++)\n        for (int j=0; j<3; j++)\n            for (int k=0; k<3; k++)\n                if (i!=j && j!=k && i!=k && vp(x[j]-x[i], y[j]-y[i], x[k]-x[i], y[k]-y[i])) {\n                    cout << ""RIGHT\\n"";\n                    return 0;\n                }\n    for (int q=0; q<3; q++)\n        for (int dx=-1; dx<=1; dx++)\n            for (int dy=-1; dy<=1; dy++) \n                if (abs(dx)+abs(dy)==1) {\n                    for (int p=0; p<3; p++)\n                        X[p]=x[p], Y[p]=y[p];\n                    X[q]=x[q]+dx, Y[q]=y[q]+dy;\n                    for (int i=0; i<3; i++)\n                        for (int j=0; j<3; j++)\n                            for (int k=0; k<3; k++)\n                                if (i!=j && j!=k && i!=k && vp(X[j]-X[i], Y[j]-Y[i], X[k]-X[i], Y[k]-Y[i])) {\n                                    cout << ""ALMOST\\n"";\n                                    return 0;\n                                }\n                }\n    cout << ""NEITHER\\n"";\n    return 0;\n}']","[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1500
Recently Petya walked in the forest and found a magic stick Since Petya really likes numbers the first thing he learned was spells for changing numbers So far he knows only two spells that can be applied to a integer If the chosen number a is even then the spell will turn it into frac 3a 2 If the chosen number a is greater than one then the spell will turn it into a 1 Note that if the number is even and greater than one then Petya can choose which spell to apply Petya now has only one number x He wants to know if his favorite number y can be obtained from x using the spells he knows The spells can be used any number of times in any order It is not required to use spells Petya can leave x as it is ,"['#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n\n    while (T-- > 0) {\n        int X, Y;\n        cin >> X >> Y;\n\n        if (X >= 4)\n            cout << ""YES"" << \'\\n\';\n        else if (X == 2 || X == 3)\n            cout << (Y <= 3 ? ""YES"" : ""NO"") << \'\\n\';\n        else if (X == 1)\n            cout << (Y <= 1 ? ""YES"" : ""NO"") << \'\\n\';\n        else\n            assert(false);\n    }\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1000
Kris works in a large company Blake Technologies As a best engineer of the company he was assigned a task to develop a printer that will be able to print horizontal and vertical strips First prototype is already built and Kris wants to tests it He wants you to implement the program that checks the result of the printing Printer works with a rectangular sheet of paper of size Consider the list as a table consisting of rows and columns Rows are numbered from top to bottom with integers from to while columns are numbered from left to right with integers from to Initially all cells are painted in color Your program has to support two operations Paint all cells in row in color Paint all cells in column in color If during some operation there is a cell that have already been painted the color of this cell also changes to Your program has to print the resulting table after operation ,"[""#include <iostream>\nusing namespace std;\n\nconst int N = 5011;\n\nint pr[N], nr[N];\nint pc[N], nc[N];\n\nint main()\n{\n\tios :: sync_with_stdio(false);\n\tint n, m, k;\n\tcin >> n >> m >> k;\n\tfor(int i = 1; i <= k; i ++)\n\t{\n\t\tint t, x, a;\n\t\tcin >> t >> x >> a;\n\t\tif(t == 1)\n\t\t{\n\t\t\tpr[x] = a;\n\t\t\tnr[x] = i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpc[x] = a;\n\t\t\tnc[x] = i;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tfor(int j = 1; j <= m; j ++)\n\t\t\tif(nr[i] > nc[j])\n\t\t\t\tcout << pr[i] << ' ';\n\t\t\telse\n\t\t\t\tcout << pc[j] << ' ';\n\t\tcout << '\\n';\n\t}\n\treturn 0;\n}""]","[0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
In the summer Vika likes to visit her country house There is everything for relaxation comfortable swings bicycles and a river There is a wooden bridge over the river consisting of n planks It is quite old and unattractive so Vika decided to paint it And in the shed they just found cans of paint of k colors After painting each plank in one of k colors Vika was about to go swinging to take a break from work However she realized that the house was on the other side of the river and the paint had not yet completely dried so she could not walk on the bridge yet In order not to spoil the appearance of the bridge Vika decided that she would still walk on it but only stepping on planks of the same color Otherwise a small layer of paint on her sole will spoil the plank of another color Vika also has a little paint left but it will only be enough to repaint plank of the bridge Now Vika is standing on the ground in front of the first plank To walk across the bridge she will choose some planks of the same color after repainting which have numbers 1 le i 1 i 2 ldots i m le n planks are numbered from 1 from left to right Then Vika will have to cross i 1 1 i 2 i 1 1 i 3 i 2 1 ldots i m i m 1 1 n i m planks as a result of each of m 1 steps Since Vika is afraid of falling she does not want to take too long steps Help her and tell her the minimum possible maximum number of planks she will have to cross if she can repaint one plank a different color while crossing the bridge ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define all(x) x.begin(), x.end()\n#define rep(i, a, b) for(int i = (a); i < ((int)(b)); ++i)\n#define per(i, a, b) for(int i = (a) - 1; i >= ((int)(b)); --i)\n#define sz(a) ((int)a.size())\nconst int mod = 998244353, N = 200005;\nint n, k, a[N];\nvector<int> vec[N];\n \nvoid frank() {\n    cin >> n >> k;\n    for (int i = 0; i < k; ++i) vec[i].clear(), vec[i].pb(-1);\n    for (int i = 0; i < n; ++i) cin >> a[i], a[i]--, vec[a[i]].pb(i);\n    for (int i = 0; i < k; ++i) vec[i].pb(n);\n    int res = (n + 2) / 2;\n    for (int i = 0; i < k; ++i) if(sz(vec[i]) > 2) {\n        vector<int> vec1;\n        for (int j = 0; j < sz(vec[i]) - 1; ++j) vec1.pb(vec[i][j + 1] - vec[i][j]);\n        sort(all(vec1), greater<int>());\n        res = min(res, max(vec1[1], (vec1[0] + 1) / 2));\n    }\n    cout << res - 1 << ""\\n"";\n}\n \nint main () {\n    ios::sync_with_stdio(false), cin.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        frank();\n    }\n}']","[1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1200
Sam started playing with round buckets in the sandbox while also scattering pebbles His mom decided to buy him a new bucket so she needs to solve the following task You are given n distinct points with integer coordinates A 1 A 2 ldots A n All points were generated from the square 10 8 10 8 times 10 8 10 8 uniformly and independently You are given positive integers k l such that k leq l leq n You want to select a subsegment A i A i 1 ldots A i l 1 of the points array for some 1 leq i leq n 1 l and some circle on the plane containing geq k points of the selected subsegment inside or on the border What is the smallest possible radius of that circle ,"['/**\n *    author:  tourist\n *    created: 23.02.2022 14:47:30       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\n// code below from https://www.codechef.com/viewsolution/12429578\n\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""avx"")\n\nconst double _0=1e-10;\nstruct pos{\n\tdouble x,y;\n\tpos operator+(pos w){return (pos){x+w.x,y+w.y};}\n\tpos operator-(pos w){return (pos){x-w.x,y-w.y};}\n\tpos operator*(double k){return (pos){x*k,y*k};}\n\tdouble abs(){return sqrt(x*x+y*y);}\n\tdouble atan2(){return ::atan2(y,x);}\n\tbool operator<(pos w)const{return x<w.x;}\n}ps[50007],ps2[50007];\ndouble _c=cos(0.937),_s=sin(0.937);\nvoid mins(double&a,double b){if(a>b)a=b;}\nstruct dir{\n\tdouble d;int t;\n\tbool operator<(dir w)const{return d<w.d;}\n}ds[100007];\nconst double pi=acos(-1),_2pi=pi*2;\ndouble fix(double x){\n\twhile(x<0)x+=_2pi;\n\twhile(x>=_2pi)x-=_2pi;\n\treturn x;\n}\nvoid Solve(vector<pair<double, double>> PTS, int m, double& ans){\n        int n = (int) PTS.size();\n\tfor(int i=1;i<=n;++i){\n\t\tdouble x,y;\n\t        x = PTS[i - 1].first;\n\t        y = PTS[i - 1].second;\n\t\tps[i]=ps2[i]=(pos){_c*x+_s*y,-_s*x+_c*y};\n\t}\n\tsrand(n+m+2571);\n\tstd::random_shuffle(ps+1,ps+n+1);\n\tfor(int i=1;i<=n;++i)std::swap(ps[rand()%n+1],ps[rand()%n+1]);\n\tstd::sort(ps2+1,ps2+n+1);\n\tfor(int i=1;i<=n;++i){\n\t\tdouble L=0,R=ans,M;\n\t\tbool ed=0;\n\t\twhile((R-L)/max(1.0, L)>_0){\n\t\t\tif (L < 1 && R > 1) M=1; else\n\t\t\tif (L < 1) M = (L+R)/2;\n\t\t\telse M = sqrt(L*R);\n\t\t\tif(!ed)M=R,ed=1;\n\t\t\tint ls=std::lower_bound(ps2+1,ps2+n+1,(pos){ps[i].x-M*2-_0,0})-ps2;\n\t\t\tint rs=std::upper_bound(ps2+1,ps2+n+1,(pos){ps[i].x+M*2+_0,0})-ps2;\n\t\t\tint c=0,ab=0;\n\t\t\tif(rs-ls>=m){\n\t\t\t\tint dp=0;\n\t\t\t\tfor(int j=ls;j<rs;++j){\n\t\t\t\t\tpos p=ps2[j]-ps[i];\n\t\t\t\t\tdouble d=p.abs(),r=M*2;\n\t\t\t\t\tif(d>r)continue;\n\t\t\t\t\tif(d<_0){\n\t\t\t\t\t\t++c;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble a=p.atan2(),b=asin(sqrt(1-d*d/(r*r)));\n\t\t\t\t\tdouble la=fix(a-b),ra=fix(a+b);\n\t\t\t\t\tif(la>ra)++c;\n\t\t\t\t\tds[dp++]=(dir){la,1};\n\t\t\t\t\tds[dp++]=(dir){ra,-1};\n\t\t\t\t}\n\t\t\t\tstd::sort(ds,ds+dp);\n\t\t\t\tif(c>=m)ab=1;\n\t\t\t\tfor(int j=0;j<dp;++j){\n\t\t\t\t\tc+=ds[j].t;\n\t\t\t\t\tif(c>=m)ab=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ab)R=ans=M;\n\t\t\telse L=M;\n\t\t}\n\t}\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, l, k;\n    cin >> n >> l >> k;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n      cin >> x[i] >> y[i];\n    }\n    double ans = 1e9;\n    set<pair<int, int>> s;\n    for (int i = 0; i < n; i++) {\n//      if (i % 1000 == 0) debug(i, ans, clock());\n      s.emplace(x[i], y[i]);\n      if (i - l >= 0) {\n        s.erase(make_pair(x[i - l], y[i - l]));\n      }\n      vector<pair<double, double>> ps;\n      auto it = s.lower_bound(make_pair((int) (x[i] - 2 * ans - 2), (int) -1e9));\n      while (it != s.end()) {\n        auto p = *it;\n        long long dx = p.first - x[i];\n        if (dx > 2 * ans + 2) {\n          break;\n        }\n        dx = abs(dx);\n        long long dy = abs(p.second - y[i]);\n        if (dx * dx + dy * dy < 4 * ans * ans) {\n          ps.emplace_back(p.first, p.second);\n        }\n        ++it;\n      }\n      Solve(ps, k, ans);\n    }\n    cout << fixed << setprecision(17) << ans << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",3500
Pasha has many hamsters and he makes them work out Today hamsters is even came to work out The hamsters lined up and each hamster either sat down or stood up For another exercise Pasha needs exactly hamsters to stand up and the other hamsters to sit down In one minute Pasha can make some hamster ether sit down or stand up How many minutes will he need to get what he wants if he acts optimally well ,"['#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define forint(i, a, b) for(int i=(int)(a); i<=(int)(b); ++i)\n#define forintdown(i, a, b) for(int i=(int)(a); i>=(int)(b); --i)\n#define forn(i, n) forint(i, 0, (n)-1)\n#define forndown(i, n) forintdown(i, (n)-1, 0)\n#define fillchar(a, x) memset(a, x, sizeof(a))\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPI;\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n\nint main() {\n\tchar s[999]; scanf(""%*d%s"", s); int n=strlen(s);\n\tint c=0; forint(i, 0, n-1) c+=(s[i]==\'x\');\n\tint d=c-n/2;\n\tif(d<0) {\n\t\td=-d; int cd=d;\n\t\tforn(i, n) if(s[i]==\'X\' && d>0) s[i]=\'x\', --d;\n\t\tprintf(""%d\\n%s\\n"", cd,s);\n\t} else {\n\t\tint cd=d;\n\t\tforn(i, n) if(s[i]==\'x\' && d>0) s[i]=\'X\', --d;\n\t\tprintf(""%d\\n%s\\n"", cd,s);\n\t}\n\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
Vasya participates in a ski race along the axis The start is at point and the finish is at that is at a distance meters from the start in the positive direction of the axis Vasya has been training so hard that he can run one meter in exactly one second Besides there are take off ramps on the track each ramp is characterized by four numbers represents the ramp s coordinate represents from how many meters Vasya will land if he goes down this ramp represents the flight time in seconds is the number indicating for how many meters Vasya should gather speed to get ready and fly off the ramp As Vasya gathers speed he should ski on the snow that is he should not be flying but his speed still equals one meter per second Vasya is allowed to move in on the axis but he is prohibited to cross the start line that is go to the negative semiaxis Vasya himself chooses which take off ramps he will use and in what order that is he is not obliged to take off from all the ramps he encounters Specifically Vasya can skip the ramp It is guaranteed that that is Vasya cannot cross the finish line in flight Your task is to find the minimum time that Vasya will spend to cover the distance ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector< string > VS;\ntypedef vector< int > VI;\ntypedef pair< int, int > PRII;\ntypedef pair< double, double > PRDD;\n\n#define p_b push_back\n#define m_p make_pair\n#define x first\n#define y second\n\n#define Size(a) ((int)a.size())\n#define sqr(x) ((x)*(x))\n\n#define oo 1000000001\n#define eps 1e-9\nconst double pi = acos(-1.0);\n\n#define maxn 200000 + 10\n#define maxm 500000 + 10\n\nint n,m = 0;\nmap< int, int > s;\nmap< int, int >::iterator itr1,itr2;\n\nint totm = 0,e[maxm],last[maxm],f[maxm],g[maxm],now[maxn];\nint dist[maxn],pre[maxn],ramp[maxn],ans[maxn];\npriority_queue< PRII > que;\n\ninline void build( int u, int v, int d, int k )\n{\n    ++totm;\n    e[totm] = v;\n    last[totm] = now[u];\n    f[totm] = d;\n    g[totm] = k;\n    now[u] = totm;\n}\n\nint main()\n{\n    int i,L,x,d,t,p;\n    \n    scanf(""%d%d"",&n,&L);\n    s[0] = ++m;\n    s[L] = ++m;\n    for( i = 1 ; i <= n ; ++i )\n        {\n            scanf(""%d%d%d%d"",&x,&d,&t,&p);\n            if( x-p < 0 )\n                continue;\n            if( s.find(x-p) == s.end() )\n                s[x-p] = ++m;\n            if( s.find(x+d) == s.end() )\n                s[x+d] = ++m;\n            build(s[x-p],s[x+d],p+t,i);\n        }\n    for( itr1 = s.begin() ; ; ++itr1 )\n        {\n            itr2 = itr1, ++itr2;\n            if( itr2 == s.end() )\n                break;\n            build(itr1->y,itr2->y,itr2->x-itr1->x,0);\n            build(itr2->y,itr1->y,itr2->x-itr1->x,0);\n        }\n    \n    for( i = 1 ; i <= m ; ++i )\n        dist[i] = oo;\n    dist[1] = 0;\n    que.push(m_p(0,1));\n    while( Size(que) )\n        {\n            PRII tmp = que.top();\n            que.pop();\n            for( i = now[tmp.y] ; i ; i = last[i] )\n                if( dist[e[i]] > -tmp.x+f[i] )\n                    {\n                        dist[e[i]] = -tmp.x+f[i];\n                        que.push(m_p(-dist[e[i]],e[i]));\n                        pre[e[i]] = tmp.y;\n                        ramp[e[i]] = g[i];\n                    }\n        }\n        \n    printf(""%d\\n"",dist[2]);\n    for( i = 2 ; i != 1 ; i = pre[i] )\n        if( ramp[i] )\n            ans[++ans[0]] = ramp[i];\n    printf(""%d\\n"",ans[0]);\n    for( i = ans[0] ; i >= 1 ; --i )\n        printf(""%d%c"",ans[i],i>1?\' \':\'\\n\');    \n        \n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]",2300
The classic programming language of Bitland is Bit This language is so peculiar and complicated The language is that peculiar as it has exactly one variable called Also there are two operations Operation increases the value of variable by 1 Operation decreases the value of variable by 1 A statement in language Bit is a sequence consisting of exactly one operation and one variable The statement is written without spaces that is it can only contain characters Executing a statement means applying the operation it contains A programme in Bit is a sequence of statements each of them needs to be executed Executing a programme means executing all the statements it contains You re given a programme in language Bit The initial value of is Execute the programme and find its final value the value of the variable when this programme is executed ,"['#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <string>\nusing namespace std;\n#define LL long long\n#define maxn 200100\n#define maxe 210000\n\nchar s[20];\nint main()\n{\n\tint n,ans=0;\n\tcin>>n;\n\twhile(n--)\n\t{\n\t\tscanf(""%s"",s);\n\t\tif(s[1]==\'+\')\n\t\t\tans++;\n\t\telse\n\t\t\tans--;\n\t}\n\tcout<<ans<<endl;\n}\t']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
Petya is having a party soon and he has decided to invite his n friends He wants to make invitations in the form of origami For each invitation he needs red sheets green sheets and blue sheets The store sells an infinite number of notebooks of each color but each notebook consists of only color with k sheets That is each notebook contains k sheets of either red green or blue Find the minimum number of notebooks that Petya needs to buy to invite all n of his friends ,"['#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\ntypedef long long LL;\n\nint main(){\n  int n, k;\n  scanf(""%d%d"", &n, &k);\n  printf(""%d\\n"", (n * 2 + k - 1) / k + (n * 5 + k - 1) / k + (n * 8 + k - 1) / k);\n  return 0;\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You re given an array consisting of n integers You have to perform n turns Initially your score is 0 On the i th turn you are allowed to leave the array as it is or swap any one pair of 2 adjacent elements in the array and change exactly one of them to 0 and leave the value of other element unchanged after swapping In either case whether you swap or not after this you add a i to your score What s the maximum possible score you can get ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC> bool cmin(typC &x,const typC &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC> bool cmax(typC &x,const typC &y) { if (x<y) { x=y; return 1; } return 0; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// void inc(ui &x,const ui &y) { if ((x+=y)>=p) x-=p; }\n// void dec(ui &x,const ui &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nvector<int> lg(2);\ntemplate <typename T> struct maxtable\n{\n\tvector<T> a;\n\tvector<vector<T>> st;\n\tmaxtable(const vector<T> &b):a(all(b))\n\t{\n\t\tint n=a.size(),i,j,k,r;\n\t\twhile (lg.size()<=n) lg.push_back(lg[lg.size()>>1]+1);\n\t\tst.assign(lg[n]+1,vector<T>(n));\n\t\tiota(all(st[0]),0);\n\t\tfor (j=1; j<=lg[n]; j++)\n\t\t{\n\t\t\tr=n-(1<<j);\n\t\t\tk=1<<j-1;\n\t\t\tfor (i=0; i<=r; i++) st[j][i]=a[st[j-1][i]]<a[st[j-1][i+k]]?st[j-1][i+k]:st[j-1][i];\n\t\t}\n\t}\n\tT rmq(int l,int r) const\n\t{\n\t\tassert(0<=l&&l<=r&&r<a.size());\n\t\tint z=lg[r-l+1];\n\t\treturn max(a[st[z][l]],a[st[z][r-(1<<z)+1]]);\n\t}\n};\nconst int inf=1e9;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<setiosflags(ios::fixed)<<setprecision(15);\n\tint n,i,j,k,l;\n\tcin>>n;\n\tvector<int> a(n),s(n+1);\n\tvector f(n+1,vector(n+1,vector(n+1,-inf)));\n\tcin>>a;\n\tfor (i=0; i<n; i++) s[i+1]=s[i]+a[i];\n\tmaxtable t(a);\n\tf[0][0][0]=0;\n\tf[1][1][0]=a[0];\n\tf[1][0][1]=a[1];\n\tfor (i=1; i<n; i++)\n\t{\n\t\tfor (j=0; j<=i; j++)\n\t\t{\n\t\t\tfor (k=0; k<i; k++)\n\t\t\t{\n\t\t\t\tcmax(f[i+1][j+1][i],f[i][j][k]+a[i]);\n\t\t\t\tcmax(f[i+1][j][k],f[i][j][k]+a[k]);\n\t\t\t}\n\t\t\tfor (k=i; k<n; k++)\n\t\t\t{\n\t\t\t\tcmax(f[i+1][j+1][k],f[i][j][k]);\n\t\t\t\tcmax(f[i+1][j][k],f[i][j][k]+a[k]);\n\t\t\t}\n\t\t}\n\t\tvector g(n+1,-inf);\n\t\tfor (j=0; j<=i; j++) g[j]=*max_element(all(f[i][j]));\n\t\tfor (j=0; j<=i; j++) for (k=i+1; k<n&&k-i-1<=j; k++)\n\t\t{\n\t\t\tcmax(f[i+1][j-(k-i-1)][k],g[j]+a[k]);\n\t\t}\n\t}\n\t// for (i=0; i<=n; i++) for (j=0; j<=i; j++) cerr<<f[i][j]<<"" \\n""[j==i];\n\t// dbg(f);\n\tint res=0;\n\tfor (auto &v:f[n]) cmax(res,*max_element(all(v)));\n\tcout<<res<<endl;\n}\n']","[1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2600
There are n distinct points on a coordinate line the coordinate of i th point equals to x i Choose a subset of the given set of points such that the distance between each pair of points in a subset is an integral power of two It is necessary to consider each pair of points not only adjacent Note that any subset containing one element satisfies the condition above Among all these subsets choose a subset with maximum possible size In other words you have to choose the maximum possible number of points x i 1 x i 2 dots x i m such that for each pair x i j x i k it is true that x i j x i k 2 d where d is some non negative integer number not necessarily the same for each pair of points ,"['/// In The Name Of God\n\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#include <bits/stdc++.h>\n\n#define f first\n#define s second\n\n#define pb push_back\n#define pp pop_back\n#define mp make_pair\n\n#define sz(x) (int)x.size()\n#define sqr(x) ((x) * 1ll * (x))\n#define all(x) x.begin(), x.end()\n\n#define rep(i, l, r) for (int i = (l); i <= (r); i++)\n#define per(i, l, r) for (int i = (l); i >= (r); i--)\n\n#define Kazakhstan ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\n#define nl \'\\n\'\n#define ioi exit(0);\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nconst int N = (int)5e5 + 7;\nconst int inf = (int)1e9 + 7;\nconst int mod = (int)1e9 + 7;\nconst ll linf = (ll)1e18 + 7;\n\nconst int dx[] = {-1, 0, 1, 0, 1, -1, -1, 1};\nconst int dy[] = {0, 1, 0, -1, 1, -1, 1, -1};\n\nusing namespace std;\n\nint n;\nll a[N];\nint main() {\n\t#ifdef IOI2018\n\t\tfreopen (""in.txt"", ""r"", stdin);\n\t#endif\n\tKazakhstan\n\tcin >> n;\n\tset <ll> st;\n\trep(i, 1, n) {\n\t\tint x;\n\t\tcin >> x;\n\t\tst.insert(x);\n\t}\n\tn = 0;\n\tfor (auto it : st) a[++n] = it;\n\trep(i, 1, n) {\n\t\tll x = 1;\n\t\trep(d, 0, 30) {\n\t\t\tif (st.count(a[i] + x) && st.count(a[i] + x + x)) cout << 3 << nl << a[i] << \' \' << a[i] + x << \' \' << a[i] + x + x, ioi\n\t\t\tx *= 2;\n\t\t}\n\t}\n\trep(i, 1, n) {\n\t\tll x = 1;\n\t\trep(d, 0, 30) {\n\t\t\tif (st.count(a[i] + x)) cout << 2 << nl << a[i] << \' \' << a[i] + x, ioi\n\t\t\tx *= 2;\n\t\t}\n\t}\n\tcout << 1 << nl << a[1];\n\tioi\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Yaroslav calls an array of integers if it meets the following conditions at that An array of integers is called if it meets the following conditions The elements in it do not decrease If the inequalities and hold If we can rearrange its elements and get at least one and at most distinct good arrays Yaroslav has three integers He needs to count the number of distinct great arrays Help Yaroslav As the answer may be rather large print the remainder after dividing it by Two arrays are considered distinct if there is a position in which they have distinct numbers ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n#define MOD 1000000007\n\ninline void add(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nconst int mod = 65536;\nconst int N = 100002;\nstruct hmap {\n    pair<int, string> key[N + 1];\n    unsigned ll ck[N + 1];\n    int val[N + 1], nx[N + 1], last[mod], hc;\n    hmap() {\n        reset();\n    }\n    inline void reset() {\n        memset(last, -1, sizeof(last));\n        hc = 0;\n    }\n    inline unsigned ll gh(const pair<int, string> &k) {\n        unsigned ll h = 1;\n        h = (h * 1000000009) ^ (k.x + 101);\n        rept(i, L(k.y)) {\n            h = (h * 10000019) ^ (k.y[i] + 2);\n        }\n        return h;\n    }\n    inline int &add(const pair<int, string> &k) {\n        unsigned ll h = gh(k);\n        int th = h & (mod - 1);\n        for (int w = last[th]; w >= 0; w = nx[w]) {\n            if (ck[w] == h) return val[w];\n        }\n        key[hc] = k; ck[hc] = h; val[hc] = 0; nx[hc] = last[th]; last[th] = hc++;\n        return val[hc - 1];\n    }\n};\n\nint a,b,c,d,n,m,k;\nhmap dp[2];\n//map<pair<int, string>, int> cur, nx;\nchar now[52], tmp[52];\nint ce[102][102];\ninline void decode(string s, char *a) {\n    memset(a, 0, 52 * sizeof(char));\n    rept(i, min(51, L(s))) {\n        a[i] = s[i] - 1;\n    }\n}\ninline void code(char *a, string &s) {\n    int last = 0;\n    rept(i, 51) {\n        if (a[i]) last = i;\n    }\n    s.resize(last + 1);\n    rept(i, last + 1) {\n        s[i] = a[i] + 1;\n    }\n}\nint main() {\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n\n    rept(i, 101) {\n        ce[i][0] = ce[i][i] = 1;\n        rep(j, i - 1) {\n            ce[i][j] = ce[i - 1][j - 1] + ce[i - 1][j];\n            if (ce[i][j] > 101) ce[i][j] = 101;\n        }\n    }\n\n    scanf(""%d%d%d"", &n, &m, &k);\n    int cur = 1, nx = 0;\n    rep(i, 50) {\n        C(now);\n        now[i] = 1;\n        string s;\n        code(now, s);\n        int &t = dp[nx].add(mp(n - i, s));\n        t  = 1;\n    }\n\n    int ans = 0;\n    int ms = 0;\n    FOR(i, 2, m) {\n        swap(cur, nx);\n        ms = max(ms, dp[cur].hc);\n        dp[nx].reset();\n        rept(it, dp[cur].hc) {\n            int cd = dp[cur].val[it];\n            if (!cd) continue;\n            decode(dp[cur].key[it].y, now);\n            int can = dp[cur].key[it].x, last = 0;\n            rept(j, 51) {\n                if (now[j]) last = j;\n            }\n            rep(cadd, can) {\n\t\t\t\tif (cadd > 50) break;\n                C(tmp);\n                rep(fr, last) {\n                    if (!now[fr]) continue;\n                    if (cadd < fr) break;\n                    int ways = now[fr];\n                    ways *= ce[cadd - 1][fr - 1];\n                    if (ways > k) ways = k + 1;\n                    if (cadd - fr == 0) {\n                        if (ways <= k && ways) {\n                            ans = (ans + (ll)cd * (m - i + 1)) % MOD;\n                        }\n                        continue;\n                    }\n                    tmp[cadd - fr] += ways;\n                    if (tmp[cadd - fr] > k) tmp[cadd - fr] = k + 1;\n                }\n                int ns = can - cadd;\n                rep(j, last) {\n                    if (j > ns) {\n                        tmp[j] = 0;\n                    }\n                    if (tmp[j] > k) {\n                        FOR(z, j, last) tmp[z] = 0;\n                        ns = min(ns, j - 1);\n                        break;\n                    }\n                }\n                if (!ns) continue;\n                string h;\n                code(tmp, h);\n                \n                int &t = dp[nx].add(mp(ns, h));\n                add(t, cd);\n            }\n        }\n    }\n    printf(""%d\\n"", ans);\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2800
Serval loves Brain Power and his brain power problem Serval defines that a string T is iff T can be obtained by concatenating some string T multiple times Formally speaking T is powerful iff there exist a string T and an integer k geq 2 such that T underbrace T T dots T k text times For example is powerful because it can be obtained by concatenating three times but is not powerful Serval has a string S consists of lowercase English letters He is curious about the longest powerful subsequence of S and he only needs you to find out the length of it If all the non empty subsequences of S is not powerful the answer is considered to be 0 A string a is a subsequence of a string b if a can be obtained from b by the deletion of several possibly zero or all characters ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\nusing ll = long long;\n\nstring s;\nint n;\nstring cur;\nint ans = 0;\nconst int K = 16;\n\nbool check() {\n    if (cur.empty()) return true;\n    int j = 0;\n    int sz = (int) cur.size();\n    int cnt = 0;\n    for (auto &x: s) {\n        if (x == cur[j]) {\n            j++;\n            if (j == sz) {\n                cnt++;\n                j = 0;\n            }\n        }\n    }\n    if (cnt >= 2) {\n        ans = max(ans, cnt * sz);\n        return true;\n    }\n    return false;\n}\n\nvoid chkmx(int &x, int y) { x = max(x, y); }\n\nvoid relax(string x, string y, string z) {\n    int nx = x.size();\n    int ny = y.size();\n    int nz = z.size();\n    vector<vector<vector<int>>> dp(nx + 1, vector<vector<int>>(ny + 1, vector<int>(nz + 1)));\n    int res = 0;\n    for (int i = 0; i <= nx; ++i) {\n        for (int j = 0; j <= ny; ++j) {\n            for (int e = 0; e <= nz; ++e) {\n                if (i + 1 <= nx) chkmx(dp[i + 1][j][e], dp[i][j][e]);\n                if (j + 1 <= ny) chkmx(dp[i][j + 1][e], dp[i][j][e]);\n                if (e + 1 <= nz) chkmx(dp[i][j][e + 1], dp[i][j][e]);\n                if (i < nx && j < ny && e < nz && x[i] == y[j] && x[i] == z[e])\n                    chkmx(dp[i + 1][j + 1][e + 1], dp[i][j][e] + 1);\n                chkmx(res, dp[i][j][e]);\n            }\n        }\n    }\n    ans = max(ans, res * 3);\n}\n\n\nvoid relax(string x, string y) {\n    int nx = x.size();\n    int ny = y.size();\n    vector<vector<int>> dp(nx + 1, vector<int>(ny + 1));\n    int res = 0;\n    for (int i = 0; i <= nx; ++i) {\n        for (int j = 0; j <= ny; ++j) {\n            if (i + 1 <= nx) chkmx(dp[i + 1][j], dp[i][j]);\n            if (j + 1 <= ny) chkmx(dp[i][j + 1], dp[i][j]);\n            if (i < nx && j < ny && x[i] == y[j])\n                chkmx(dp[i + 1][j + 1], dp[i][j] + 1);\n            chkmx(res, dp[i][j]);\n        }\n    }\n    ans = max(ans, res * 2);\n}\n\nvoid solve() {\n    cin >> s;\n    n = (int) s.size();\n    for (int i = 0; i < n; ++i) {\n        for (int mask = 1; mask < (1 << K); mask += 2) {\n            for (int j = 0; j < K; ++j) {\n                if (mask & (1 << j)) cur.push_back(s[i + j]);\n            }\n            check();\n            cur.clear();\n        }\n    }\n    // 3\n    for (int l = K + 1; l < n; ++l) {\n        for (int r = l + K + 1; r + K < n; ++r) {\n            relax(s.substr(0, l), s.substr(l, r - l), s.substr(r, n));\n        }\n        relax(s.substr(0, l), s.substr(l, n));\n    }\n    cout << ans << \'\\n\';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--) {\n        solve();\n    }\n\n    return 0;\n}']","[1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]",2700
You are an all powerful being and you have created a rectangular world In fact your world is so bland that it could be represented by a r times c grid Each cell on the grid represents a country Each country has a dominant religion There are only two religions in your world One of the religions is called Beingawesomeism who do good for the sake of being good The other religion is called Pushingittoofarism who do murders for the sake of being bad Oh and you are actually not really all powerful You just have one power which you can use infinitely many times Your power involves When a missionary group of a certain country say a passes by another country b they change the dominant religion of country b to the dominant religion of country a In particular a single use of your power is this You choose a horizontal 1 times x subgrid or a vertical x times 1 subgrid That value of x is up to you You choose a direction d If you chose a horizontal subgrid your choices will either be NORTH or SOUTH If you choose a vertical subgrid your choices will either be EAST or WEST You choose the number s of steps You command each country in the subgrid to send a missionary group that will travel s steps towards direction d In each step they will visit and in effect convert the dominant religion of all s countries they pass through as detailed above The parameters x d s must be chosen in such a way that any of the missionary groups won t leave the grid The following image illustrates one possible single usage of your power Here represents a country with dominant religion Beingawesomeism and represents a country with dominant religion Pushingittoofarism Here we ve chosen a 1 times 4 subgrid the direction NORTH and s 2 steps You are a being which believes in free will for the most part However you just really want to stop receiving murders that are attributed to your name Hence you decide to use your powers and try to make Beingawesomeism the dominant religion in every country What is the minimum number of usages of your power needed to convert everyone to Beingawesomeism With god nothing is impossible But maybe you re not god If it is impossible to make Beingawesomeism the dominant religion in all countries you must also admit your mortality and say so ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> s(n);\n\tfor(int i = 0; i < n; i++) cin >> s[i];\n\tbool is0 = false;\n\tbool is1 = false;\n\tbool is2 = false;\n\tbool is3 = false;\n\tbool is4 = false;\n\tis0 = true;\n\n\tbool f1 = true, f2 = true, f3 = true, f4 = true;\n\tfor(int i = 0; i < n; i++){\n\t\tbool row_works = true;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == \'P\') row_works = false;\n\t\t}\n\t\tif(row_works) is2 = true;\n\t}\n\tfor(int j = 0; j < m; j++){\n\t\tbool col_works = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(s[i][j] == \'P\') col_works = false;\n\t\t}\n\t\tif(col_works) is2 = true;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == \'P\'){\n\t\t\t\tis0 = false;\n\t\t\t\tif(i == 0) f1 = false;\n\t\t\t\tif(i == n-1) f2 = false;\n\t\t\t\tif(j == 0) f3 = false;\n\t\t\t\tif(j == m-1) f4 = false;\n\t\t\t} else {\n\t\t\t\tif((i == 0 || i == n-1) && (j == 0 || j == m-1)){\n\t\t\t\t\tis2 = true;\n\t\t\t\t}\n\t\t\t\tif((i == 0 || i == n-1) || (j == 0 || j == m-1)){\n\t\t\t\t\tis3 = true;\n\t\t\t\t}\n\t\t\t\tis4 = true;\n\t\t\t}\n\t\t}\n\t}\n\tis1 = f1 | f2 | f3 | f4;\n\tif(is0){\n\t\tcout << 0 << \'\\n\';\n\t} else if(is1){\n\t\tcout << 1 << \'\\n\';\n\t} else if(is2){\n\t\tcout << 2 << \'\\n\';\n\t} else if(is3){\n\t\tcout << 3 << \'\\n\';\n\t} else if(is4){\n\t\tcout << 4 << \'\\n\';\n\t} else {\n\t\tcout << ""MORTAL"" << \'\\n\';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}']","[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1800
Masha meets a new friend and learns his phone number s She wants to remember it as soon as possible The phone number is a string of length m that consists of digits from 0 to 9 The phone number may start with Masha already knows n phone numbers all numbers have the same length m It will be easier for her to remember a new number if the s is represented as segments of numbers she already knows Each such segment must be of length otherwise there will be too many segments and Masha will get confused For example Masha needs to remember the number s and she already knows n 4 numbers You can represent s as a 3 segment of number one of number two and of number three There are other ways to represent s Masha asks you for help she asks you to break the string s into segments of length 2 or more of the numbers she already knows If there are several possible answers print of them ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class...Args>\nvoid debug(Args... args) {\n    auto tmp = {(cout << args << ' ', 0)...};\n    cout << endl;\n}\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 1e3 + 10;\nconst int mod = 998244353;\nchar a[N][N];\nchar c[N];\nstruct pos {\n    int x, y, id;\n};\npos b[N * 2];\nint f[N];\nint s2i(char x, char y) {\n    return (x - '0') * 10 + y - '0';\n}\nint s2i(char x, char y, char z) {\n    return (x - '0') * 100 + (y - '0') * 10 + z - '0' + 1000;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 0; i < 2000; ++i) {\n            b[i].x = b[i].y = b[i].id = -1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            cin >> (a[i] + 1);\n            for (int j = 1; j <= m; ++j) {\n                if (j + 1 <= m) {\n                    int v = s2i(a[i][j], a[i][j + 1]);\n                    b[v].x = j;\n                    b[v].y = j + 1;\n                    b[v].id = i;\n                }\n                if (j + 2 <= m) {\n                    int v = s2i(a[i][j], a[i][j + 1], a[i][j + 2]);\n                    b[v].x = j;\n                    b[v].y = j + 2;\n                    b[v].id = i;\n                }\n            }\n        }\n        cin >> (c + 1);\n        memset(f, -1, sizeof f);\n        f[0] = 0;\n        for (int i = 1; i <= m; ++i) {\n            if (i - 2 >= 0 && f[i - 2] != -1 && b[s2i(c[i - 1], c[i])].id != -1) {\n                f[i] = i - 2;\n            }\n            if (i - 3 >= 0 && f[i - 3] != -1 && b[s2i(c[i - 2], c[i - 1], c[i])].id != -1) {\n                f[i] = i - 3;\n            }\n        }\n        if (f[m] == -1) {\n            cout << -1 << '\\n';\n        } else {\n            vector<pos> ans;\n            for (int i = m; i; i = f[i]) {\n                if (i - f[i] == 2) {\n                    ans.emplace_back(b[s2i(c[i - 1], c[i])]);\n                } else {\n                    ans.emplace_back(b[s2i(c[i - 2], c[i - 1], c[i])]);\n                }\n            }\n            reverse(ans.begin(), ans.end());\n            cout << ans.size() << '\\n';\n            for (auto& i : ans) {\n                cout << i.x << ' ' << i.y << ' ' << i.id << '\\n';\n            }\n        }\n    }\n}""]","[0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2000
For a sequence of integers between and inclusive denote as the number of distinct subsequences of including the empty subsequence You are given two positive integers and Let be the set of all sequences of length consisting of numbers from to Compute the sum over all in modulo ,"['# include <cstdio>\nconst int MOD = 1e9 + 7;\nlong long pow(int b, int e)\n{\n\tif (e == 0)\n\t\treturn 1;\n\telse if (e % 2)\n\t\treturn pow(b, e - 1) * b % MOD;\n\tlong long h = pow(b, e / 2);\n\treturn h * h % MOD;\n}\nconst int MN = 1e6 + 44;\nlong long f[MN], fin[MN];\nlong long bin(int a, int b)\n{\n\treturn f[a] * fin[b] % MOD * fin[a - b] % MOD;\n}\nint main()\n{\n\tf[0] = 1;\n\tfor (int i = 1; i < MN; ++i)\n\t\tf[i] = f[i - 1] * i % MOD;\n\tfin[MN - 1] = pow(f[MN - 1], MOD - 2);\n\tfor (int i = MN - 2; i >= 0; --i)\n\t\tfin[i] = fin[i + 1] * (i + 1) % MOD;\n// \tfor (int i = 0; i < 10; ++i)\n// \t{\n// \t\tfor (int k = 0; k <= i; ++k)\n// \t\t\tprintf(""%d "", bin(i, k));\n// \t\tprintf(""\\n"");\n// \t}\n\tint n, m;\n\tscanf(""%d%d"", &n, &m);\n\tlong long res = 0;\n\tlong long sum = 0;\n\tfor (int k = 0; k <= n; ++k)\n\t{\n// \t\tprintf(""k = %d sum = %lld\\n"", k, sum);\n\t\tres = (res + pow(m, k) * (pow (m, n) - sum)) % MOD;\n\t\tsum = (sum + bin(n, k) * pow(m - 1, n - k)) % MOD;\n\t}\n\tif (res < 0)\n\t\tres += MOD;\n\tprintf(""%d\\n"", (int) res);\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",2300
Seyyed and MoJaK are friends of Sajjad Sajjad likes a permutation Seyyed wants to change the permutation in a way that Sajjad won t like it Seyyed thinks more swaps yield more probability to do that so he makes MoJaK to perform a swap between every pair of positions where exactly once MoJaK doesn t like to upset Sajjad Given the permutation determine whether it is possible to swap all pairs of positions so that the permutation stays the same If it is possible find how to do that ,"['#include <iostream>\n#include <tuple>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <bitset>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nvector<pii> ans4 = {{0, 1}, {0, 2}, {1, 3}, {0, 3}, {1, 2}, {2, 3}};\nvector<pii> ans5 = {{0, 1},\n{0, 2},\n{0, 3},\n{1, 2},\n{1, 4},\n{2, 4},\n{0, 4},\n{2, 3},\n{1, 3},\n{3, 4}};\nint sh44[] = {0, 3, 1, 2};\nvector<pii> ans44;\nvector<pii> ans45;\n\nvector<pii> ans;\n\nvoid sh(vi v, vector<pii> p) {\n    for (pii q: p) ans.pb({v[q.fi], v[q.se]});\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    forn(i, 4) forn(j, 4) ans44.pb({j, 4 + (j + sh44[i]) % 4});\n\n    int n;\n    cin >> n;\n    int m = n % 4;\n    if (m != 0 && m != 1) {\n        cout << ""NO\\n"";\n        return 0;\n    }\n    for (int i = 0; i < n - 1; i += 4) {\n        vi v;\n        forn(j, 4) v.pb(i + j);\n        if (n % 4) v.pb(n - 1);\n        sh(v, n % 4 ? ans5 : ans4);\n        for (int j = 0; j < i; j += 4) {\n            vi u;\n            forn(k, 4) u.pb(i + k);\n            forn(k, 4) u.pb(j + k);\n            sh(u, ans44);\n        }\n    }\n\n    cout << ""YES\\n"";\n    for (pii p: ans) {\n        if (p.fi > p.se) swap(p.fi, p.se);\n        cout << p.fi + 1 << \' \' << p.se + 1 << \'\\n\';\n    }\n\n/*    vi a(n);\n    forn(i, n) a[i] = i;\n    vi c = a;\n    for (pii p: ans) {\n        assert(p.fi != p.se);\n        swap(a[p.fi], a[p.se]);\n    }\n    assert(set<pii>(all(ans)).size() == n * (n - 1) / 2);\n    assert(a == c);*/\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3100
Ksenia has a chessboard of size Each cell of the chessboard contains one of the characters The cells that contain character are blocked We know that all chessboard cells that touch the border are blocked Ksenia is playing with two pawns on this chessboard Initially she puts the pawns on the chessboard One cell of the chessboard can contain two pawns if and only if the cell is blocked In other cases two pawns can not stand in one cell The game begins when Ksenia put pawns on the board In one move Ksenia moves each pawn to a side adjacent cell in the direction of arrows painted on the cell on which the corresponding pawn sits if the pawn sits on it does not move Assume that Ksenia moves pawns simultaneously see the second test case Of course Ksenia plays for points How can one calculate the points per game Very simply Let s count how many movements the first pawn made and how many movements the second pawn made sum these two numbers it will be the resulting score of the game Ksenia wonders what is the maximum number of points she can earn for that she should place the pawns optimally well early in the game Help her and find that number ,"['#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nchar s[3001][3001];\nint d[3001][3001];\nconst int dx[]={0,1,0,-1};\nconst int dy[]={1,0,-1,0};\nconst char ds[]="">v<^"";\nbool vis[3001][3001];\nint dp[3001][3001][2];\nint n,m;\nint bfs[3001*3001][2];\nint T;\nint anss[2];\nvoid Update(int ans[],int x,int y){\n\tif(x>ans[1]){\n\t\tans[1]=x;\n\t\tif(ans[1]>ans[0]) swap(ans[1],ans[0]);\n\t\tif(y>ans[1]) ans[1]=y;\n\t}\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=0;i<n;++i) scanf(""%s"",s[i]);\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j){\n\t\tdp[i][j][0]=0,dp[i][j][1]=-1;\n\t\tif(s[i][j]!=\'#\'){\n\t\t\tfor(int k=0;k<4;++k) if(ds[k]==s[i][j]){\n\t\t\t\t++d[i+dx[k]][j+dy[k]];\n\t\t\t}\n\t\t}\n\t}\n\tT=-1;\n\tfor(int i=0;i<n;++i) for(int j=0;j<m;++j){\n\t\tif(!d[i][j]) ++T,bfs[T][0]=i,bfs[T][1]=j;\n\t}\n\tfor(int i=0;i<=T;++i){\n\t\tint x=bfs[i][0],y=bfs[i][1];\n\t\tif(s[x][y]==\'#\'){\n\t\t\tUpdate(anss,dp[x][y][0],dp[x][y][1]);\n\t\t}\n\t\telse{\n\t\t\tif(dp[x][y][0]==dp[x][y][1]) --dp[x][y][1];\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tif(s[x][y]==ds[k]){\n\t\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\t\tUpdate(dp[nx][ny],dp[x][y][0]+1,dp[x][y][1]+1);\n\t\t\t\t\tif(--d[nx][ny]==0) ++T,bfs[T][0]=nx,bfs[T][1]=ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(T!=n*m-1) printf(""-1\\n"");\n\telse printf(""%d\\n"",anss[0]+anss[1]);\n\tscanf(""%d"",&n);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2200
Bob recently read about bitwise operations used in computers and He have studied their properties and invented a new game Initially Bob chooses integer bit depth of the game which means that all numbers in the game will consist of bits Then he asks Peter to choose some bit number After that Bob computes the values of variables Each variable is assigned either a constant bit number or result of bitwise operation Operands of the operation may be either variables defined before or the number chosen by Peter After that Peter s score equals to the sum of all variable values Bob wants to know what number Peter needs to choose to get the minimum possible score and what number he needs to choose to get the maximum possible score In both cases if there are several ways to get the same score find the minimum number which he can choose ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<ll> vi;\ntypedef pair<ll, ll> pii;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n\n    ios::sync_with_stdio(false);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\ntemplate<typename Op>\nstatic void combine(vector<array<int, 2>> &out,\n                    const vector<array<int, 2>> &left,\n                    const vector<array<int, 2>> &right,\n                    const Op &op)\n{\n    int M = SZ(out);\n    for (int i = 0; i < M; i++)\n        for (int j = 0; j < 2; j++)\n            out[i][j] = op(left[i][j], right[i][j]);\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N, M;\n    cin >> N >> M;\n    map<string, vector<array<int, 2>>> vars;\n    vector<array<int, 2>> peter(M);\n    for (int i = 0; i < M; i++)\n    {\n        peter[i][0] = 0;\n        peter[i][1] = 1;\n    }\n    for (int i = 0; i < N; i++)\n    {\n        string name, assign, left;\n        cin >> name >> assign >> left;\n        vector<array<int, 2>> out(M);\n        if (left[0] == \'0\' || left[0] == \'1\')\n        {\n            for (int j = 0; j < M; j++)\n                out[j][0] = out[j][1] = left[j] - \'0\';\n        }\n        else\n        {\n            string op, right;\n            cin >> op >> right;\n            const auto &leftv = (left == ""?"") ? peter : vars[left];\n            const auto &rightv = (right == ""?"") ? peter : vars[right];\n            if (op == ""XOR"")\n                combine(out, leftv, rightv, [](int x, int y) { return x ^ y; });\n            else if (op == ""AND"")\n                combine(out, leftv, rightv, [](int x, int y) { return x & y; });\n            else if (op == ""OR"")\n                combine(out, leftv, rightv, [](int x, int y) { return x | y; });\n        }\n        vars[name] = out;\n    }\n    vector<int> lo(M), hi(M);\n    for (int i = 0; i < M; i++)\n    {\n        int sums[2] = {0, 0};\n        for (const auto &entry : vars)\n        {\n            for (int j = 0; j < 2; j++)\n                sums[j] += entry.second[i][j];\n        }\n        if (sums[1] > sums[0])\n            hi[i] = 1;\n        if (sums[1] < sums[0])\n            lo[i] = 1;\n    }\n    for (int i = 0; i < M; i++)\n        cout << lo[i];\n    cout << \'\\n\';\n    for (int i = 0; i < M; i++)\n        cout << hi[i];\n    cout << \'\\n\';\n\n    return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",1800
Demodogs from the Upside down have attacked Hawkins again El wants to reach Mike and also kill as many Demodogs in the way as possible Hawkins can be represented as an n times n grid The number of Demodogs in a cell at the i th row and the j th column is i cdot j El is at position 1 1 of the grid and she has to reach n n where she can find Mike The only directions she can move are the right from i j to i j 1 and the down from i j to i 1 j She can t go out of the grid as there are doors to the Upside down at the boundaries Calculate the maximum possible number of Demodogs mathrm ans she can kill on the way considering that she kills all Demodogs in cells she visits including starting and finishing cells Print 2022 cdot mathrm ans modulo 10 9 7 Modulo 10 9 7 because the result can be too large and multiplied by 2022 because we are never gonna see it again Note you firstly multiply by 2022 and that take the remainder ,"['//这回只花了114514min就打完了。\n//真好。记得多手造几组。ACM拍什么拍。 \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef __int128 lll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nconst ll p=1e9+7;\nlll g(lll n)\n{\n\treturn n*(n+1)/2;\n}\nlll f(lll n)\n{\n\treturn n*(n+1)*(2*n+1)/6;\n}\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tll n,m,i,j;\n\t\tcin>>n;\n\t\tcout<<(ll)((f(n)+f(n-1)+g(n-1))%p*2022%p)<<\'\\n\';\n\t}\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1100
Sayaka Saeki is a member of the student council which has n other members excluding Sayaka The i th member has a height of a i millimeters It s the end of the school year and Sayaka wants to take a picture of all other members of the student council Being the hard working and perfectionist girl as she is she wants to arrange all the members in a line such that the amount of consecutive pairs of members is A pair of two consecutive members u and v on a line is considered if their average height is an integer i e frac a u a v 2 is an integer Help Sayaka arrange the other members to the number of photogenic consecutive pairs ,"['#include <ctime>\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx"")\n#pragma warning(disable : 4996)\n#include <algorithm>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <iterator>\n#include <vector>\n#include <queue>\n#include <math.h>\n#include <cassert>\n#include <unordered_map>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\n\n// #define int long long\n#define F first\n#define S second\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define len(s) (int)(s).size()\n// #define endl \'\\n\'\n\n\ninline void accell() {\n    cin.tie(0);\n    cout.tie(0);\n    ios_base::sync_with_stdio(0);\n}\n\ntemplate<class T> ostream& operator<< (ostream& out, const pair<int, int>&X) {\n    out << X.first << \' \' << X.second << endl;\n    return out;\n}\n\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T> &X) {\n    for (const auto& it : X)\n        out << it << \' \';\n    return out;\n}\ntemplate<class T> ostream& operator<< (ostream& out, const set<T> &X) {\n    for (const auto& it : X)\n        out << it << \' \';\n    return out;\n}\ntemplate<class T> void dbg(const T &X) {\n    cerr << ""DEBUG: "" << "": "";\n    cerr << X << endl;\n}\nconst int mod = 1e9 + 7;\nconst int N = 1e5 + 5;\n\n\nsigned main() {\n    accell();\n    int t;\n    cin >> t;\n    while (t--) {\n        int n;\n        cin >> n;\n        vector<int> a(n);\n        for (int i = 0; i < n; ++i) cin >> a[i];\n        sort(all(a), [](int x, int y) {\n            return x % 2 < y % 2; \n        });\n        for (int i = 0; i < a.size(); ++i) {\n            cout << a[i] << \' \';\n        }\n        cout << \'\\n\';\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",800
You have an array a consisting of n distinct positive integers numbered from 1 to n Define p k as p k sum 1 le i j le k a i bmod a j where x bmod y denotes the remainder when x is divided by y You have to find and print p 1 p 2 ldots p n ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 3e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n/**\n * Description: range sum queries and point updates for $D$ dimensions\n * Source: https://codeforces.com/blog/entry/64914\n * Verification: SPOJ matsum\n * Usage: \\texttt{BIT<int,10,10>} gives 2D BIT\n * Time: O((\\log N)^D)\n */\n\ntemplate <class T, int ...Ns> struct BIT {\n\tT val{}; void upd(T v) { val += v; }\n\tT query() { return val; }\n};\ntemplate <class T, int N, int... Ns> struct BIT<T, N, Ns...> {\n\tBIT<T,Ns...> bit[N+1];\n\ttemplate<typename... Args> void upd(int pos, Args... args) { assert(pos > 0);\n\t\tfor (; pos<=N; pos+=pos&-pos) bit[pos].upd(args...); }\n\ttemplate<typename... Args> T sum(int r, Args... args) {\n\t\tT res=0; for (;r;r-=r&-r) res += bit[r].query(args...); \n\t\treturn res; }\n\ttemplate<typename... Args> T query(int l, int r, Args... \n\t\targs) { return sum(r,args...)-sum(l-1,args...); }\n}; \n// template<class T, int N> int get_kth(const BIT<T,N>& bit, T des) { \n// \tassert(des > 0);\n// \tint ind = 0;\n// \tfor (int i = 1<<bits(N); i; i /= 2)\n// \t\tif (ind+i <= N && bit.bit[ind+i].val < des)\n// \t\t\tdes -= bit.bit[ind += i].val;\n// \tassert(ind < N); return ind+1;\n// }\n\nBIT<ll,MX> sub, num;\nint N;\n\nint main() {\n\tsetIO();\n\tre(N);\n\tvl A(N); re(A);\n\tll ans = 0, prefix_sum = 0;\n\tF0R(i,N) {\n\t\t// dbg(""??"",i,A[i],prefix_sum,ans);\n\t\tans += A[i]*i;\n\t\tans += prefix_sum; prefix_sum += A[i];\n\n\t\t// dbg(""BEFORE ANS"",i,ans);\n\t\tfor (ll cur = A[i]; cur < MX; cur += A[i]) {\n\t\t\tll p = i-num.sum(cur-1); // how many at least cur\n\t\t\tans -= p*A[i];\n\t\t}\n\n\t\t// dbg(""END ANS"",i,ans,sub.sum(A[i]));\n\t\tans -= sub.sum(A[i]); // OK\n\t\tnum.upd(A[i],1); // OK\n\t\tfor (int cur = A[i]; cur < MX; cur += A[i]) sub.upd(cur,A[i]);\n\t\t// A[i]%x\n\t\tpr(ans,\' \');\n\t}\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2300
You are given strings S and T consisting of lowercase English letters It is guaranteed that T is a permutation of the string Find string S the permutation of S such that T is a subsequence of S String a is a of string b if the number of occurrences of each distinct character is the same in both strings A string a is a of a string b if a can be obtained from b by deletion of several possibly zero or all elements A string a is than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tfor (cin >> t; t; t -= 1) {\n\t\tstring S, T;\n\t\tcin >> S >> T;\n\t\tranges::sort(S);\n\t\tif (T != ""abc"" or S[0] != \'a\') cout << S << ""\\n"";\n\t\telse {\n\t\t\tfor (int i = 0; i < 26; i += 1)\n\t\t\t\tfor (char c : S) {\n\t\t\t\t\tif (i == 0 or i >= 3) {\n\t\t\t\t\t\tif (c == \'a\' + i) cout << c;\n\t\t\t\t\t}\n\t\t\t\t\telse if (c == \'a\' + 3 - i) cout << c;\n\t\t\t\t}\n\t\t\tcout << ""\\n"";\n\t\t}\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",800
The Beroil corporation structure is hierarchical that is it can be represented as a tree Let s examine the presentation of this structure as follows name of an employee That is the description of each employee consists of his name a colon the descriptions of all his subordinates separated by commas and finally a dot If an employee has no subordinates then the colon is not present in his description For example line is the correct way of recording the structure of a corporation where the director has subordinates and has a subordinate whose name is just as the name of his boss and two subordinates of are called just like himself In the Beroil corporation every employee can only correspond with his subordinates at that the subordinates are not necessarily direct Let s call an uncomfortable situation the situation when a person whose name is writes a letter to another person whose name is also In the example given above are two such pairs a pair involving and two pairs for a pair for each of his subordinates Your task is by the given structure of the corporation to find the number of uncomfortable pairs in it ,"['//#pragma comment(linker,""/STACK:256000000"")\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <stdio.h>\n#include <string>\n#include <memory.h>\n\nusing namespace std;\n\n#define ldb long double\n#define LL long long\n#define nextline() {int c; while ((c = getchar()) != 10 && c != EOF);}\n\n#define PI 3.1415926535897932384626433832795\n#define EPS 1e-9\n\n#define sqr(x) ((x) * (x))\n#define ABS(a) ((a)<0?-(a):(a))\n#define EQ(a,b) (ABS((a)-(b))<EPS)\n\n#define all(a) a.begin(), a.end()\n#define two(i) (1 << (i))\n#define has(mask, i) ((((mask) & two(i)) == 0) ? false : true)\n\nconst int inf = 1000 * 1000 * 1000;\nconst LL inf64 = 1000LL * 1000LL * 1000LL * 1000LL * 1000LL * 1000LL;\n\nvector <int> next[2000];\nstring str[2000];\n\nstring s;\nint n;\nint node = 0;\n\nint parse(int l)\n{\n\tint cur_node = node;\n\tstring x = """";\n\twhile (s[l] != \'.\' && s[l] != \':\')\t\n\t{\n\t\tx += s[l];\n\t\tl++;\n\t}\n\tstr[cur_node] = x;\n\tif (s[l] == \':\')\n\t{\n\t\tl++;\n\t\tnode++;\n\t\tnext[cur_node].push_back(node);\n\t\tl = parse(l);\n\t\twhile (s[l] != \'.\')\n\t\t{\n\t\t\tl++;\n\t\t\tnode++;\n\t\t\tnext[cur_node].push_back(node);\n\t\t\tl = parse(l);\t\t\n\t\t}\n\n\t\t\t\t\n\t}\n\treturn l + 1;\n}\n\n\nvoid Load()\n{\n\tcin >> s;\n\n\tparse(0);\n}\n\nint ans = 0;\n\nvoid dfs (int n)\n{\n\tif (s == str[n]) ans++ ;\n\tfor (int i = 0; i < (int)next[n].size(); i++)\n\t\tdfs(next[n][i]);\n\t\n}\n\nvoid Solve()\n{\n   \tfor (int i = 0; i < node; i++)\n   \t{\n   \t\ts = str[i];\n   \t\tdfs (i);\n   \t}\n   \tans -= node;\n   \tcout << ans;\n}\n                \nint main()\n{\n\t//ios_base::sync_with_stdio(0);\n#ifndef ONLINE_JUDGE\n\tfreopen(""in"", ""rt"", stdin);\n\tfreopen(""out"", ""wt"", stdout);\n#endif\n\tLoad();\n\tSolve();\n\treturn 0;\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1700
Even a cat has things it can do that AI cannot Fei Fei LiYou are given m arrays of positive integers Each array is of even length You need to split all these integers into two multisets L and R that is each element of each array should go into one of two multisets but not both Additionally for each of the m arrays of its elements should go into L and the rest should go into R Give an example of such a division or determine that no such division exists ,"['#include<bits/stdc++.h>\nusing namespace std;\nint m,n,dg[100003],cnt;\nvector<int>v[100003],g[100003],h[100003],val[100003],V[100003],G[100003],rev[100003];\nstring ans[100003];\nvoid dfs(int x,int ed,bool ok){\n\tif(x==ed&&!ok)return;\n\tfor(int i=0;i<g[x].size();i++)\n\t\tif(h[x][i]==1){\n//\t\t\tcout<<x<<\' \'<<g[x][i]<<\' \'<<V[x][i]-1<<\' \'<<G[x][i]-1<<endl;\n\t\t\tdg[x]--;\n\t\t\th[x][i]--;\n\t\t\tdg[g[x][i]]--;\n\t\t\th[g[x][i]][rev[x][i]]--;\n\t\t\tans[x][V[x][i]-1]=\'L\';\n\t\t\tans[g[x][i]][G[x][i]-1]=\'R\';\n\t\t\tdfs(g[x][i],ed,0);\n\t\t\treturn;\n\t\t}\n}\nint main(){\n\tcin>>m;\n\tmap<int,int>MP,idx;\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>n;cnt+=n;\n\t\tmap<int,int>mp;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tans[i]+=\' \';\n\t\t\tif(mp[x]){\n\t\t\t\tans[i][mp[x]-1]=\'L\';\n\t\t\t\tans[i][j-1]=\'R\';\n\t\t\t\tmp[x]=0;\n\t\t\t\tcnt-=2;\n\t\t\t}else\n\t\t\t\tmp[x]=j;\n\t\t\tv[i].push_back(x);\n\t\t}\n\t\tsort(v[i].begin(),v[i].end());\n\t\tv[i].erase(unique(v[i].begin(),v[i].end()),v[i].end());\n\t\tfor(int j=0;j<v[i].size();j++)\n\t\t\tif(mp[v[i][j]])\n\t\t\t\tif(MP[v[i][j]]){\n\t\t\t\t\trev[i].push_back(dg[MP[v[i][j]]]);\n\t\t\t\t\trev[MP[v[i][j]]].push_back(dg[i]);\n\t\t\t\t\tdg[i]++;\n\t\t\t\t\tdg[MP[v[i][j]]]++; \n\t\t\t\t\tg[i].push_back(MP[v[i][j]]);\n\t\t\t\t\tg[MP[v[i][j]]].push_back(i);\n\t\t\t\t\th[i].push_back(1);\n\t\t\t\t\th[MP[v[i][j]]].push_back(1);\n\t\t\t\t\tV[i].push_back(mp[v[i][j]]);\n\t\t\t\t\tG[i].push_back(idx[v[i][j]]);\n\t\t\t\t\tG[MP[v[i][j]]].push_back(mp[v[i][j]]);\n\t\t\t\t\tV[MP[v[i][j]]].push_back(idx[v[i][j]]);\n\t\t\t\t\tcnt-=2;\n\t\t\t\t\tMP[v[i][j]]=0;\n\t\t\t\t}else{\n\t\t\t\t\tMP[v[i][j]]=i;\n\t\t\t\t\tidx[v[i][j]]=mp[v[i][j]];\n\t\t\t\t}\n\t}\n\tif(cnt){cout<<""NO\\n"";return 0;}\n\tcout<<""YES\\n"";\n\tfor(int i=1;i<=m;i++)\n\t\twhile(dg[i])\n\t\t\tdfs(i,i,1);\n\tfor(int i=1;i<=m;i++)\n\t\tcout<<ans[i]<<endl;\n}\n']","[0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
The secondary diagonal of a square matrix is a diagonal going from the top right to the bottom left corner Let s define an degree as a square matrix containing no squares above the secondary diagonal the picture below shows a 5 degree staircase The squares of the degree staircase contain sportsmen A sportsman needs one second to move to a side neighboring square of the staircase Before the beginning of the competition each sportsman must choose one of the shortest ways to the secondary diagonal After the starting whistle the competition begins and all sportsmen start moving along the chosen paths When a sportsman reaches a cell of the secondary diagonal he stops and moves no more The competition ends when all sportsmen reach the secondary diagonal The competition is considered successful if during it no two sportsmen were present in the same square simultaneously Any square belonging to the secondary diagonal also cannot contain more than one sportsman If a sportsman at the given moment of time leaves a square and another sportsman comes to it then they are not considered to occupy the same square simultaneously Note that other extreme cases for example two sportsmen moving towards each other are impossible as the chosen ways are the shortest ones You are given positions of sportsmen on the staircase Your task is to choose among them the maximum number of sportsmen for who the competition can be successful that is so that there existed such choice of shortest ways for the sportsmen at which no two sportsmen find themselves in the same square simultaneously All other sportsmen that are not chosen will be removed from the staircase before the competition starts ,"['#include <string>\n#include <algorithm>\n#include <utility>\n#include <stdlib.h>\n#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <utility>\n#include <time.h>\n#include <string.h>\nusing namespace std;\n\n\nint main( void )\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector< pair<pair<int,int>,int> > R(m);\n\tfor( int i = 0; i < m; i ++ ){\n\t\tint r, c;\n\t\tcin >> r >> c;\n\t\tR.push_back(pair<pair<int,int>,int>(pair<int,int>(n-r+1, c), i));\n\t}\n\tsort( R.begin(), R.end() );\n\tpriority_queue<pair<int,int> > wl;\n\tint ans = 0;\n\tvector<int> ANS;\n\tfor( int pos = 1, j = 0; pos <= n; pos ++ ){\n\t\twhile( j < R.size() && R[j].first.first <= pos ){\n\t\t\twl.push( pair<int,int>(-R[j].first.second, R[j].second) ); j ++;\n\t\t}\n\t\twhile( !wl.empty() && (-wl.top().first) < pos )\n\t\t\twl.pop();\n\t\tif( !wl.empty() ){\n\t\t\tANS.push_back(wl.top().second);\n\t\t\twl.pop();\n\t\t\t++ ans;\n\t\t}\n\t}\n\tcout << ans << endl;\n\tfor( int i = 0; i < ANS.size(); i ++ ){\n\t\tif( i > 0 )\n\t\t\tcout << "" "";\n\t\tcout << (ANS[i]+1);\n\t}\n\tcout << endl;\n}\n']","[1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2200
You are given four integer values a b c and m Check if there exists a string that contains a letters b letters c letters no other letters exactly m pairs of adjacent equal letters exactly m such positions i that the i th letter is equal to the i 1 th one ,"['/**\n *    author:  tourist\n *    created: 20.09.2021 17:36:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int a, b, c, m;\n    cin >> a >> b >> c >> m;\n    int other = a + b + c - max(a, max(b, c));\n    int L = a + b + c - 1 - 2 * other;\n    int R = a - 1 + b - 1 + c - 1;\n    cout << (L <= m && m <= R ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1100
Vasya learns to type He has an unusual keyboard at his disposal it is rectangular and it has rows of keys containing keys in each row Besides the keys are of two types Some of the keys have lowercase Latin letters on them and some of the keys work like the Shift key on standard keyboards that is they make lowercase letters uppercase Vasya can press one or two keys with one hand However he can only press two keys if the Euclidean distance between the centers of the keys does not exceed The keys are considered as squares with a side equal to 1 There are no empty spaces between neighbouring keys Vasya is a very lazy boy that s why he tries to type with one hand as he eats chips with his other one However it is possible that some symbol can t be typed with one hand only because the distance between it and the closest Shift key is strictly larger than In this case he will have to use his other hand Having typed the symbol Vasya returns other hand back to the chips You are given Vasya s keyboard and the text Count the minimum number of times Vasya will have to use the other hand ,"['#include<stdio.h>\n#include<string.h>\nint can[30],canb[30];\nchar in[33][33];\nchar tmp[500010];\nint main(){\n    int n,m,i,j,k,l;\n    int x;\n    scanf(""%d%d%d"",&n,&m,&x);\n    for(i=0;i<n;i++)scanf(""%s"",in[i]);\n    bool hass=0;\n    for(i=0;i<n;i++){\n\tfor(j=0;j<m;j++){\n\t    if(in[i][j]==\'S\'){\n\t\thass=1;\n\t\tfor(k=0;k<n;k++){\n\t\t    for(l=0;l<m;l++){\n\t\t\tif((k-i)*(k-i)+(l-j)*(l-j)<=x*x&&in[k][l]!=\'S\'){\n\t\t\t    canb[in[k][l]-\'a\']=1;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }else{\n\t\tcan[in[i][j]-\'a\']=1;\n\t    }\n\t}\n    }\n    int q;\n    scanf(""%d%s"",&q,tmp);\n    int ans=0;\n    for(i=0;i<q;i++){\n\tif(tmp[i]>=\'A\'&&tmp[i]<=\'Z\'){\n\t    if(!hass)break;\n\t    if(canb[tmp[i]-\'A\']){\n\t    }else if(can[tmp[i]-\'A\']){\n\t\tans++;\n\t    }else break;\n\t}else{\n\t    if(can[tmp[i]-\'a\']){\n\t    }else break;\n\t}\n    }\n    if(i<q)puts(""-1"");\n    else printf(""%d\\n"",ans);\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
There are n players numbered from 1 to n sitting around a round table The i 1 th player sits to the right of the i th player for 1 le i n and the 1 st player sits to the right of the n th player There are n 2 cards each of which has an integer between 1 and n written on it For each integer from 1 to n there are exactly n cards having this number Initially all these cards are distributed among all the players in such a way that each of them has exactly n cards In one operation each player chooses one of his cards and passes it to the player to his right All these actions are performed Player i is called if all his cards have the integer i written on them Their objective is to reach a configuration in which everyone is solid Find a way to do it using at most n 2 n operations You do need to minimize the number of operations ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int n;\n    cin >> n;\n    vector c(n, vector<int>(n));\n    vector<vector<int>> ans;\n    for (int i = 0; i < n; i += 1)\n        for (int j = 0; j < n; j += 1) {\n            cin >> c[i][j];\n            c[i][j] -= 1;\n        }\n    while (true) {\n        int ready = 1;\n        for (int i = 0; i < n; i += 1) {\n            vector<int> p(n);\n            for (int j : c[i]) {\n                if (p[j]) ready = 0;\n                p[j] = 1;\n            }\n        }\n        if (ready) break;\n        vector<int> d(n);\n        for (int i = 0; i < n; i += 1) {\n            vector<int> p(n);\n            for (int j : c[i]) p[j] += 1;\n            while (d[i] < n and p[d[i]] <= 1) d[i] += 1;\n        }\n        for (int k = 0; k < 2; k += 1)\n            for (int i = 0; i < n; i += 1)\n                if (d[(i + 1) % n] == n)\n                    d[(i + 1) % n] = d[i];\n        ans.push_back(d);\n        for (int i = 0; i < n; i += 1) {\n            for (int& j : c[i])\n                if (j == d[i]) {\n                    j = d[(i + n - 1) % n];\n                    break;\n                }\n        }\n    }\n    for (int i = 1; i < n; i += 1)\n        for (int j = 0; j < i; j += 1) {\n            vector<int> d(n);\n            for (int k = 0; k < n; k += 1) d[k] = (k + i + n - j) % n;\n            ans.push_back(d);\n            for (int i = 0; i < n; i += 1) {\n                for (int& j : c[i])\n                    if (j == d[i]) {\n                        j = d[(i + n - 1) % n];\n                        break;\n                    }\n            }\n        }\n    for (int i = 0; i < n; i += 1)\n        for (int j : c[i])\n            assert(i == j);\n    cout << ans.size() << ""\\n"";\n    for (auto ansi : ans) {\n        for (int ansij : ansi) cout << ansij + 1 << "" "";\n        cout << ""\\n"";\n    }\n    return 0;\n}']","[1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2900
Alice got many presents these days So she decided to pack them into boxes and send them to her friends There are n kinds of presents Presents of one kind are identical i e there is no way to distinguish two gifts of the same kind Presents of different kinds are different i e that is two gifts of different kinds are distinguishable The number of presents of each kind that Alice has is very big so we can consider Alice has an infinite number of gifts of each kind Also there are m boxes All of them are for different people so they are pairwise distinct consider that the names of m friends are written on the boxes For example putting the first kind of present into the first box but not into the second box is different from putting the first kind of present into the second box but not into the first box Alice wants to pack presents with the following rules She won t pack more than one present of each kind into the same box so each box should contain presents of different kinds i e each box contains a subset of n kinds empty boxes are allowed For each kind at least one present should be packed into some box Now Alice wants to know how many different ways to pack the presents exists Please help her and calculate this number Since the answer can be huge output it by modulo 10 9 7 See examples and their notes for clarification ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define endl '\\n'\ntypedef long long ll;\n\n\n//returns a^pw % mod\nll fastPow(ll a, ll pw, ll mod) {\n    ll res = 1;\n    a %= mod;\n    while(pw > 0) {\n        if(pw & 1) res = (res*a)%mod;\n        a = (a*a)%mod;\n        pw >>= 1;\n    }\n    return res;\n}\n\nconst int mod = 1e9+7;\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,m;\n    cin >> n >> m;\n    cout << fastPow((fastPow(2,m,mod)-1+mod),n,mod);\n\n\n}\n""]","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]",1500
You are given a bipartite graph G with the vertex set in the left part L in the right part R and m edges connecting these two sets We know that L R n For any subset S subseteq L let N S denote the set of all neighbors of vertices in S We say that a subset S subseteq L in graph G is if S N S We say that graph G is if forall S subseteq L S leq N S Your task is to verify whether the graph is good and if so to optimize it If the graph is not good find a subset S subseteq L such that S N S However if the graph is good your task is to find a good bipartite graph G with the same set of vertices L cup R in which forall S subseteq L S is tight in G if and only if S is tight in G If there are multiple such graphs choose one with the smallest possible number of edges If there are still multiple such graphs print any ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 1010;\nint n, m;\nbool G[N][N];\nint mt[N];\nbool used[N];\nvector<int> g[N], rg[N];\nint ord[N];\nint ordSz;\nint col[N];\nint id[N];\nint a[N];\nvector<int> forCol[N];\n\nvoid addEdge(int v, int u) {\n\tg[v].push_back(u);\n\trg[u].push_back(v);\n}\n\nvoid dfsOrd(int v) {\n\tused[v] = 1;\n\tfor (int u : g[v]) if (!used[u])\n\t\tdfsOrd(u);\n\tord[ordSz++] = v;\n}\nvoid dfsCol(int v) {\n\tcol[v] = m;\n\tfor (int u : rg[v]) if (col[u] == 0)\n\t\tdfsCol(u);\n}\n\nbool dfs(int x) {\n\teprintf(""dfs %d\\n"", x);\n\tif (used[x]) return false;\n\tused[x] = 1;\n\tfor (int y = 0; y < n; y++) if (G[x][y]) {\n\t\tif (mt[y] == -1) {\n\t\t\tmt[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int y = 0; y < n; y++) if (G[x][y]) {\n\t\tif (dfs(mt[y])) {\n\t\t\tmt[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &m);\n\twhile(m--) {\n\t\tint x, y;\n\t\tscanf(""%d%d"", &x, &y);\n\t\tx--;\n\t\ty -= n + 1;\n\t\tG[x][y] = 1;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tmt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tused[j] = 0;\n\t\tif (dfs(i)) continue;\n\t\tprintf(""NO\\n"");\n\t\tvector<int> w;\n\t\tfor (int j = 0; j < n; j++) if (used[j])\n\t\t\tw.push_back(j);\n\t\tprintf(""%d\\n"", (int)w.size());\n\t\tfor (int x : w)\n\t\t\tprintf(""%d "", x + 1);\n\t\tprintf(""\\n"");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(""mt %d %d\\n"", mt[i], i);\n\tfor (int x = 0; x < n; x++)\n\t\tfor (int y = 0; y < n; y++) if (G[x][y]) {\n\t\t\tif (mt[y] == x) continue;\n\t\t\taddEdge(x, mt[y]);\n\t\t}\n\tfor (int v = 0; v < n; v++)\n\t\tused[v] = 0;\n\tfor (int v = 0; v < n; v++) if (!used[v])\n\t\tdfsOrd(v);\n\treverse(ord, ord + ordSz);\n\tm = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = ord[i];\n\t\tif (col[v] != 0) continue;\n\t\tm++;\n\t\tdfsCol(v);\n\t}\n\tfor (int v = 0; v < n; v++) {\n\t\tcol[v]--;\n\t\tforCol[col[v]].push_back(v);\n\t}\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tG[i][j] = 0;\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int u : g[v]) {\n\t\t\tif (col[v] != col[u])\n\t\t\t\tG[col[v]][col[u]] = 1;\n\t\t}\n\tfor (int k = 0; k < m; k++)\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tG[i][j] |= G[i][k] & G[k][j];\n\tvector<pii> ans;\n\tfor (int i = 0; i < n; i++)\n\t\tans.push_back(mp(i, i));\n\tfor (int c = 0; c < m; c++) if ((int)forCol[c].size() > 1) {\n\t\tfor (int i = 0; i < (int)forCol[c].size() - 1; i++)\n\t\t\tans.push_back(mp(forCol[c][i], forCol[c][i + 1]));\n\t\tans.push_back(mp(forCol[c].back(), forCol[c][0]));\n\t}\n\tfor (int v = 0; v < m; v++)\n\t\tfor (int u = 0; u < m; u++) if (G[v][u]) {\n\t\t\tbool ok = true;\n\t\t\tfor (int w = 0; w < m; w++)\n\t\t\t\tif (G[v][w] && G[w][u])\n\t\t\t\t\tok = false;\n\t\t\tif (ok) ans.push_back(mp(forCol[v].back(), forCol[u].back()));\n\t\t}\n\tprintf(""YES\\n"");\n\tprintf(""%d\\n"", (int)ans.size());\n\tfor (pii e : ans)\n\t\tprintf(""%d %d\\n"", 1 + e.first, n + 1 + e.second);\n\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",3500
Vasya studies positional numeral systems Unfortunately he often forgets to write the base of notation in which the expression is written Once he saw a note in his notebook saying and that the base of the positional notation wasn t written anywhere Now Vasya has to choose a base and regard the expression as written in the base positional notation Vasya understood that he can get different results with different bases and some bases are even invalid For example expression in the base 16 positional notation is equal to in the base 15 positional notation it is equal to in the base 10 one to in the base 9 one to and in the base 8 or lesser based positional notations the expression is invalid as all the numbers should be strictly less than the positional notation base Vasya got interested in what is the length of the longest possible expression value Help him to find this length The length of a number should be understood as the number of numeric characters in it For example the length of the longest answer for is 3 It is calculated like that in the base 15 base 10 base 9 positional notations for example and in some other ones ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n  int a,b;\n  scanf(""%d%d"",&a,&b);\n  int base=0;\n  int x=a;\n  //int y=b;\n  int i;\n  while(x)\n  {\n    i=x%10;\n    x/=10;\n    base = max(base,i+1);\n  }\n  x=b;\n  while(x)\n  {\n    i=x%10;\n    x/=10;\n    base = max(base,i+1);\n  }\n//   printf(""base - %d\\n"",base);\n  int c=0;\n  int cnt=0;\n  while(a&&b)\n  {\n if((a%10+b%10+c)>=base)\n {\n   c = (a%10+b%10+c)/base;\n//   printf(""true %d\\n"",c);\n }\n    else c=0;\n    cnt++;\n    a/=10;\n    a+=c;\n    c=0;\n    b/=10;\n    \n  }\n//   printf(""%d %d %d\\n"",a,b,c);\n  while(a)\n  {\n    if((a%10+b%10+c)>=base)\n    c = (a%10+b%10+c)/base;\n    else c=0;\n    cnt++;\n    a/=10;\n    a+=c;\n    c=0;\n    b/=10;\n  }\n// printf(""%d %d %d\\n"",a,b,c);\n    while(b)\n  {\nif((a%10+b%10+c)>=base)\n    c = (a%10+b%10+c)/base;\n    else c=0;\n    cnt++;\n    b/=10;\n    b+=c;\n    c=0;\n   \n  }\n//  printf(""%d %d %d\\n"",a,b,c);\n  printf(""%d\\n"",cnt);\n  return 0;\n\n}']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
Absent minded Masha got set of cubes for her birthday At each of 6 faces of each cube there is exactly one digit from 0 to 9 Masha became interested what is the largest natural such she can make using her new cubes all integers from 1 to To make a number Masha can rotate her cubes and put them in a row After that she looks at upper faces of cubes from left to right and reads the number The number can t contain leading zeros It s not required to use all cubes to build a number Pay attention Masha can t make digit 6 from digit 9 and vice versa using cube rotations ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ull unsigned long long\n#define pii pair < int , int >\n#define pipii pair < int , pii >\n#define pid pair <int, double>\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define pp pop_back()\n#define sz size()\n#define iz insert\n#define lg length()\n#define FRNAME ""A""\n#define inf (int)1e6\n#define fr freopen(FRNAME"".in"",""r"",stdin); freopen (FRNAME"".out"",""w"",stdout);\n#define fr2 freopen(""input.txt"",""r"",stdin); freopen (""output.txt"",""w"",stdout)\nint a[100];\nint b[5][100];\nint c[5][10];\nint go[5];\nint n;\nbool solve (int t)\n{\n\tint cnt = 0;\n\twhile (t)\n\t{\n\t\tint w = t%10;\n\t\tif (!b[go[cnt]][w]) return false;\n\t\tcnt++;\n\t\tt /= 10;\n\t}\n\treturn true;\n}\t\nbool check (int t)\n{\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tgo[i] = i;\n\t}\n\tif (solve(t)) return true;\n\twhile(next_permutation(go,go+n))\n\t{\n\t\tif(solve(t)) return true;\n\t}\n\treturn false;\n}\t\nint main ()\n{\n\tcin >> n;\n\tfor (int q = 0; q < n; q++)\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tcin >> c[q][i];\n\t\tb[q][c[q][i]] = 1;\n\t}\t\n\tint t = 1;\n\twhile (true)\n\t{\n\t\tif (!check(t)) \n\t\t{\n\t\t\tcout << t - 1;\n\t\t\treturn 0;\n\t\t}\t\n\t\tt++;\n\t}\t\n\treturn 0;\n}\t']","[0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Valera s lifelong ambition was to be a photographer so he bought a new camera Every day he got more and more clients asking for photos and one day Valera needed a program that would determine the maximum number of people he can serve The camera s memory is megabytes Valera s camera can take photos of high and low quality One low quality photo takes megabytes of memory one high quality photo take megabytes of memory For unknown reasons each client asks him to make several low quality photos and several high quality photos More formally the th client asks to make low quality photos and high quality photos Valera wants to serve as many clients per day as possible provided that they will be pleased with his work To please the th client Valera needs to give him everything he wants that is to make low quality photos and high quality photos To make one low quality photo the camera must have at least megabytes of free memory space Similarly to make one high quality photo the camera must have at least megabytes of free memory space Initially the camera s memory is empty Valera also does not delete photos from the camera so that the camera s memory gradually fills up Calculate the maximum number of clients Valera can successfully serve and print the numbers of these clients ,"['#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iomanip>\n#include<string>\n#include<vector>\n#include<map>\n#include<queue>\n#include<ctime>\nusing namespace std;\n\nint a[100005][2];\nint n,d,p,q;;\nint stk[1000005];\n\ninline int cmp(const void *a,const void *b)\n{\n\treturn ((int*)a)[0]-((int*)b)[0];\n}\n\nint main()\n{\n\tscanf(""%d%d%d%d"",&n,&d,&p,&q);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(""%d%d"",&x,&y);\n\t\ta[i][0]=x*p+y*q;\n\t\ta[i][1]=i;\n\t}\n\tqsort(a+1,n,sizeof(a[0]),cmp);\n\tint ans=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(a[i][0]<=d)\n\t\t{\n\t\t\td-=a[i][0];\n\t\t\tans++;\n\t\t\tstk[ans]=a[i][1];\n\t\t}\n\t}\n\tprintf(""%d\\n"",ans);\n\tfor(int i=1;i<=ans;i++)\n\tprintf(""%d "",stk[i]);\n\tprintf(""\\n"");\n\t\n\treturn 0;\n}\n/*\n3 10\n2 3\n1 4\n2 1\n1 0\n*/\n\n']","[1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1400
Ashish has a string s of length n containing only characters and He wants to find the length of the smallest substring which satisfies the following conditions Length of the substring is 2 occurs strictly more times in this substring than occurs strictly more times in this substring than Ashish is busy planning his next Codeforces round Help him solve the problem A string a is a substring of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ,"['// Problem: C. Dominant Character\n// Contest: Codeforces\n// URL: https://codeforces.com/contest/1605/problem/C\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\n// #pragma GCC optimize(""Ofast"")\n// #pragma GCC optimize(""unroll-loops"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nchar s[1000003];\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read();\n\t\tscanf(""%s"",s+1);\n\t\tbool flg=0;\n\t\tfor(int i=1; i<n; ++i) if(s[i]==\'a\'&&s[i+1]==\'a\')\n\t\t{\n\t\t\tflg=1;\n\t\t}\n\t\tif(flg)\n\t\t{\n\t\t\tputs(""2"");\n\t\t\tcontinue;\n\t\t}\n\t\tint len=n+5;\n\t\tfor(int i=1; i<=n; ++i) if(s[i]==\'a\')\n\t\t{\n\t\t\tint sa=0,sb=0,sc=0;\n\t\t\tfor(int j=i; j<=i+10&&j<=n; ++j)\n\t\t\t{\n\t\t\t\tif(s[j]==\'a\') ++sa;\n\t\t\t\telse if(s[j]==\'b\') ++sb;\n\t\t\t\telse ++sc;\n\t\t\t\tif(j>i&&sa>sb&&sa>sc)\n\t\t\t\t{\n\t\t\t\t\tlen=min(len,j-i+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(len>n) puts(""-1"");\n\t\telse printf(""%lld\\n"",len);\n\t}\n\treturn 0;\n}']","[1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",1400
Recently the bear started studying data structures and faced the following problem You are given a sequence of integers of length and queries each of them is characterized by two integers Let s introduce to represent the number of such indexes that is divisible by The answer to the query is the sum where is a set of prime numbers from segment both borders are included in the segment Help the bear cope with the problem ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kMaxX = 10000000, kMaxP = 664579;\nint n, pr[kMaxP + 1];\nbool not_pr[kMaxX + 1];\nint sum[kMaxX + 1];\n\nvoid init() {\n    for (int i = 2; i <= kMaxX; ++ i) {\n        if (!not_pr[i]) pr[++ pr[0]] = i;\n        for (int j = 1, k; j <= pr[0] && (k = pr[j] * i) <= kMaxX; ++ j) {\n            not_pr[k] = true;\n            if (i % pr[j] == 0) break;\n        }\n    }\n}\n\nint main() {\n    init();\n    scanf(""%d"", &n);\n    for (int x; n --; ) {\n        scanf(""%d"", &x);\n        for (int i = 1; pr[i] * pr[i] <= x; ++ i)\n            if (x % pr[i] == 0) {\n                ++ sum[pr[i]];\n                while (x % pr[i] == 0) x /= pr[i];\n            }\n        if (x != 1) ++ sum[x];\n    }\n    for (int i = 3; i <= kMaxX; ++ i) sum[i] += sum[i - 1];\n    scanf(""%d"", &n);\n    for (int l, r; n --; ) {\n        scanf(""%d%d"", &l, &r);\n        l = min(l, kMaxX);\n        r = min(r, kMaxX);\n        printf(""%d\\n"", sum[r] - sum[l - 1]);\n    }\n    return 0;\n}\n']","[0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",1700
Slastyona likes to watch life of nearby grove s dwellers This time she watches a strange red black spider sitting at the center of a huge cobweb The cobweb is a set of nodes connected by threads each of the treads is either red of black Using these threads the spider can move between nodes No thread connects a node to itself and between any two nodes there is a unique sequence of threads connecting them Slastyona decided to study some special qualities of the cobweb She noticed that each of the threads has a value of However Slastyona is mostly interested in of the cobweb Consider those of the shortest paths between each pair of nodes on which the numbers of red and black threads differ at most twice For each such path compute the product of the clamminess of threads on the path The jelliness of the cobweb is the product of all obtained values among all paths Those paths that differ by direction only are counted only once Of course this number can be huge so Slastyona asks you to compute the jelliness of the given cobweb and print the answer modulo ,"['//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE\'Y, MINIMALNE I MAKSYMALNE WEJŚCIE I WYJŚCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nconst int nax=1000*1007;\nconst int vax=500*1007;\nconst long long mod=1000*1000*1000+7;\n\n//potengowe\nint drzewo[nax];\n\nvoid pisz(int v, int w)\n{\n\tv+=vax;\n\tfor (int i=v; i; i-=(-i&i))\n\t\tdrzewo[i]+=w;\n}\n\nint czyt(int v)\n{\n\tv+=vax;\n\tint ret=0;\n\tfor (int i=v; i<nax; i+=(-i&i))\n\t\tret+=drzewo[i];\n\treturn ret;\n}\n//kuniec potengi\n\nint n;\nvector <pair <int,int> > graf[nax];\n\nint kol[nax];\nlong long wag[nax];\nlong long nailu[nax];\n\nlong long wyn=1;\n\nlong long pot(long long v, long long wyk)\n{\n\tlong long ret=1;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t{\n\t\t\tret*=v;\n\t\t\tret%=mod;\n\t\t}\n\t\tv*=v;\n\t\tv%=mod;\n\t\twyk>>=1;\n\t}\n\treturn ret;\n}\n\nint bylcen[nax];\n\nvector <int> spo;\nint roz[nax];\nint maxroz[nax];\n\nvoid dfs1(int v, int oj)\n{\n\troz[v]=1;\n\tmaxroz[v]=0;\n\tspo.push_back(v);\n\tfor (auto i : graf[v])\n\t{\n\t\tif (i.first==oj || bylcen[i.first])\n\t\t\tcontinue;\n\t\tdfs1(i.first, v);\n\t\troz[v]+=roz[i.first];\n\t\tmaxroz[v]=max(maxroz[v], roz[i.first]);\n\t}\n}\n\nlong long dp[nax];\nint bila[nax];\nint bilb[nax];\nint l;\n\nvector <int> wek;\n\nvoid dfs2(int v, int oj)\n{\n\twek.push_back(v);\n\tfor (auto i : graf[v])\n\t{\n\t\tif (i.first==oj || bylcen[i.first])\n\t\t\tcontinue;\n\t\tbila[i.first]=bila[v];\n\t\tbilb[i.first]=bilb[v];\n\t\tif (kol[i.second])\n\t\t{\n\t\t\tbila[i.first]+=2;\n\t\t\tbilb[i.first]-=1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbila[i.first]-=1;\n\t\t\tbilb[i.first]+=2;\n\t\t}\n\t\tdfs2(i.first, v);\n\t}\n}\n\nbool mniej(int a, int b)\n{\n\treturn bilb[a]<bilb[b];\n}\n\nvoid opierdol(int raz)\n{\n\t//debug() <<  wek << "" "" << raz;\n\tsort(wek.begin(), wek.end(), mniej);\n\tint wsk=wek.size();\n\tfor (int i : wek)\n\t{\n\t\twhile(wsk && bilb[i]+bilb[wek[wsk-1]]>=0)\n\t\t{\n\t\t\twsk--;\n\t\t\tpisz(bila[wek[wsk]], 1);\n\t\t}\n\t\tdp[i]+=raz*czyt(-bila[i]);\n\t}\n\twhile(wsk<(int)wek.size())\n\t{\n\t\tpisz(bila[wek[wsk]], -1);\n\t\twsk++;\n\t}\n}\n\nlong long dfs3(int v, int oj)\n{\n\tlong long ret=dp[v];\n\tfor (auto i : graf[v])\n\t{\n\t\tif (i.first==oj || bylcen[i.first])\n\t\t\tcontinue;\n\t\tlong long w=dfs3(i.first, v);\n\t\tnailu[i.second]+=w;\n\t\tret+=w;\n\t}\n\treturn ret;\n}\n\ninline void jebaj(int c)\n{\n\tfor (int i : spo)\n\t\tdp[i]=0;\n\tl=0;\n\tbila[c]=bilb[c]=0;\n\twek.clear();\n\tdfs2(c, 0);\n\topierdol(1);\n\tfor (auto i : graf[c])\n\t{\n\t\tif (bylcen[i.first])\n\t\t\tcontinue;\n\t\twek.clear();\n\t\tdfs2(i.first, c);\n\t\topierdol(-1);\n\t}\n\t//for (int i : spo)\n\t//\tdebug() << i << "" "" << dp[i];\n\tdfs3(c, 0);\n}\n\nvoid szuk(int v)\n{\n\tif (bylcen[v])\n\t\treturn;\n\tspo.clear();\n\tdfs1(v, 0);\n\tint c=-1;\n\tfor (int i : spo)\n\t\tif (maxroz[i]*2<=roz[v] && (roz[v]-roz[i])*2<=roz[v])\n\t\t\tc=i;\n\tassert(c>0);\n\t//debug() << imie(c);\n\t\n\tjebaj(c);\n\t\n\tbylcen[c]=1;\n\tfor (auto i : graf[c])\n\t\tszuk(i.first);\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(""%d%d"", &a, &b);\n\t\tgraf[a].push_back({b, i});\n\t\tgraf[b].push_back({a, i});\n\t\tscanf(""%lld%d"", &wag[i], &kol[i]);\n\t}\n\tszuk(1);\n\tfor (int i=1; i<n; i++)\n\t\twyn=(wyn*pot(wag[i], nailu[i]))%mod;\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2800
You are given a string s consisting of lowercase Latin letters and q queries for this string Recall that the substring s l r of the string s is the string s l s l 1 dots s r For example the substrings of are but not and There are two types of queries 1 pos c 1 le pos le s c is lowercase Latin letter replace s pos with c set s pos c 2 l r 1 le l le r le s calculate the number of distinct characters in the substring s l r ,"['#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << ""="" << (X) << endl;\n#else\n\t#define DBG(X)\n#endif\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::pair;\nusing std::swap;\nusing std::sort;\nusing std::lower_bound;\nusing std::unique;\n\nusing int64 = long long int;\nusing pii   = pair<int, int>;\nusing pii64 = pair<int64, int64>;\n\nconst int NIL = -1;\n\nvoid init_IO() {\n\tstd::ios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n}\n\nconst int MAX_N = (int)1e5 + 777;\nconst int A     = 26;\n\nint tree[2 * MAX_N], n;\n\nvoid solve() {\n\tstring str;\n\tcin >> str;\n\n\tn = len(str);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint code = str[i] - \'a\';\n\t\ttree[i + n] = 1 << code;\n\t}\n\n\tfor(int i = n - 1; i > 0; --i) {\n\t\ttree[i] = tree[2 * i] | tree[2 * i + 1];\n\t}\n\n\tint q;\n\tcin >> q;\n\n\twhile(q--) {\n\t\tint type;\n\t\tcin >> type;\n\n\t\tif(type == 1) {\n\t\t\tint pos;\n\t\t\tchar chr;\n\t\t\tcin >> pos >> chr;\n\t\t\t--pos;\n\t\t\tpos += n;\n\n\t\t\tint code = chr - \'a\';\n\t\t\ttree[pos] = 1 << code;\n\n\t\t\tfor(; pos > 0; pos /= 2)\n\t\t\t\ttree[pos / 2] = tree[pos] | tree[pos ^ 1];\n\t\t} else {\n\t\t\tint l, r;\n\t\t\tcin >> l >> r;\n\t\t\t--l, --r;\n\t\t\tl += n, r += n;\n\t\t\t++r;\n\n\t\t\tint msk = 0;\n\n\t\t\twhile(l < r) {\n\t\t\t\tif(l & 1)\n\t\t\t\t\tmsk |= tree[l++];\n\n\t\t\t\tif(r & 1)\n\t\t\t\t\tmsk |= tree[--r];\n\n\t\t\t\tl /= 2;\n\t\t\t\tr /= 2;\n\t\t\t}\n\n\t\t\tint answ = 0;\n\n\t\t\tfor(int j = 0; j < A; ++j) {\n\t\t\t\tansw += (msk >> j) & 1;\n\t\t\t}\n\n\t\t\tcout << answ << \'\\n\';\n\t\t}\n\t}\n}\n\nint main() {\n\tinit_IO();\n\tsolve();\n\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1600
An identity permutation of length n is an array 1 2 3 dots n We performed the following operations to an identity permutation of length n firstly we cyclically shifted it to the right by k positions where k is unknown to you the only thing you know is that 0 le k le n 1 When an array is cyclically shifted to the right by k positions the resulting array is formed by taking k last elements of the original array without changing their relative order and then appending n k first elements to the right of them without changing relative order of the first n k elements as well For example if we cyclically shift the identity permutation of length 6 by 2 positions we get the array 5 6 1 2 3 4 secondly we performed the following operation m times pick any two elements of the array and swap them You are given the values of n and m and the resulting array Your task is to find all possible values of k in the cyclic shift operation ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n/**\n * Description: Disjoint Set Union with path compression\n \t* and union by size. Add edges and test connectivity. \n \t* Use for Kruskal\'s or Boruvka\'s minimum spanning tree.\n * Time: O(\\alpha(N))\n * Source: CSAcademy, KACTL\n * Verification: *\n */\n\nstruct DSU {\n\tvi e; void init(int N) { e = vi(N,-1); }\n\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); } \n\tbool sameSet(int a, int b) { return get(a) == get(b); }\n\tint size(int x) { return -e[get(x)]; }\n\tbool unite(int x, int y) { // union by size\n\t\tx = get(x), y = get(y); if (x == y) return 0;\n\t\tif (e[x] > e[y]) swap(x,y);\n\t\te[x] += e[y]; e[y] = x; return 1;\n\t}\n};\n\n/**template<class T> T kruskal(int N, vector<pair<T,pi>> ed) {\n\tsort(all(ed));\n\tT ans = 0; DSU D; D.init(N); // edges that unite are in MST\n\teach(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f; \n\treturn ans;\n}*/\n\nint N,M;\n\nvoid solve(int tc) {\n\tre(N,M);\n\tvi P(N); re(P); each(t,P) --t;\n\tmap<int,vi> eq;\n\tF0R(i,N) {\n\t\t// (N-K+i)%N equiv P[i]\n\t\teq[(i-P[i]+N)%N].pb(i);\n\t}\n\tvi ans;\n\teach(t,eq) if (sz(t.s) >= N-2*M) {\n\t\tint K = t.f;\n\n\t\t// (N-K+i)%N\n\t\tDSU D; D.init(N);\n\t\tvi nex(N);\n\t\tF0R(i,N) D.unite(P[i],(N-K+i)%N);\n\t\tint comps = 0;\n\t\tF0R(i,N) comps += D.get(i) == i;\n\t\tint moves = N-comps;\n\t\tif (moves <= M) ans.pb(K);\n\t}\n\tpr(sz(ans));\n\teach(t,ans) pr(\' \',t);\n\tps();\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0]",2100
Omkar is watching In Okabe Rintarou needs to complete n tasks 1 leq n leq 2 cdot 10 5 Unfortunately he doesn t know when he needs to complete the tasks Initially the time is 0 Time travel will now happen according to the following rules For each k 1 2 ldots n Okabe will realize at time b k that he was supposed to complete the k th task at time a k a k b k When he realizes this if k th task was already completed at time a k Okabe keeps the usual flow of time Otherwise he time travels to time a k then immediately completes the task If Okabe time travels to time a k all tasks completed after this time will become incomplete again That is for every j if a j a k the j th task will become incomplete if it was complete if it was incomplete nothing will change Okabe has bad memory so he can time travel to time a k getting to time b k and learning that he was supposed to complete the k th task at time a k That is even if Okabe already had to perform k th task before he wouldn t remember it before stumbling on the info about this task at time b k again Please refer to the notes for an example of time travelling There is a certain set s of tasks such that the first moment that all of the tasks in s are simultaneously completed regardless of whether any other tasks are currently completed a funny scene will take place Omkar loves this scene and wants to know how many times Okabe will time travel before this scene takes place Find this number modulo 10 9 7 It can be proven that eventually all n tasks will be completed and so the answer always exists ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nstruct fwt\n{\n\tint dat[400005];\n\tvoid add(int id, int val)\n\t{\n\t\tfor(; id > 0; id -= id & -id) dat[id] = (dat[id] + val) % MOD;\n\t}\n\tint query(int id)\n\t{\n\t\tint ret = 0;\n\t\tfor(; id <= 400000; id += id & -id) ret = (ret + dat[id]) % MOD;\n\t\treturn ret;\n\t}\n}tre;\nint n, t, b[200005], dp[200005];\nPII dat[200005];\nbool nd[200005];\n\nint main()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) {\n\t\tscanf(""%d%d"", &dat[i].second, &dat[i].first); b[i] = dat[i].first;\n\t}\n\tsort(dat, dat + n);\n\tscanf(""%d"", &t);\n\trep(i, t) {\n\t\tint x; scanf(""%d"", &x);\n\t\tnd[lower_bound(dat, dat + n, MP(b[x - 1], 0)) - dat] = true;\n\t}\n\t\n\ttre.add(2 * n, 1);\n\trep(i, n) {\n\t\tdp[i] = tre.query(dat[i].second);\n\t\ttre.add(dat[i].second, dp[i]);\n\t}\n\t\n\tint pv = 1, ans = 0;\n\tfor(int i = n - 1; i >= 0; i --) {\n\t\ttre.add(dat[i].second, (MOD - dp[i]) % MOD);\n\t\tif(nd[i] && dat[i].second >= pv) {\n\t\t\tans = (ans + tre.query(pv)) % MOD;\n\t\t\tpv = dat[i].second;\n\t\t}\n\t}\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}']","[0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3000
You are given set of points in 5 dimensional space The points are labeled from to No two points coincide We will call point if there are different points and not equal to from the given set such that angle between vectors and is acute i e strictly less than Otherwise the point is called The angle between vectors and in 5 dimensional space is defined as where is the scalar product and is length of Given the list of points print the indices of the good points in ascending order ,"['#include<map>\n#include<set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\nconst int N = 1000000 + 10;\n\nint n;\nint x[N][5];\n\nvoid solve()\n{\n    cin >> n;\n    if (n > 100) {\n        cout << 0 << endl;\n        return;\n    }\n    for(int i = 0; i < n; ++ i) {\n        for(int j = 0; j < 5; ++ j) {\n            scanf(""%d"", &x[i][j]);\n        }\n    }\n    vector<int> vec;\n    for(int i = 0; i < n; ++ i) {\n        int flag = true;\n        for(int j = 0; j < n; ++ j) {\n            if (j == i) continue;\n            for(int k = j + 1; k < n; ++ k) {\n                if (k == i) continue;\n                long long sum = 0;\n                for(int w = 0; w < 5; ++ w) {\n                    sum += (x[j][w] - x[i][w]) * (x[k][w] - x[i][w]);\n                }\n                if (sum > 0) {\n                    flag = false;\n                }\n            }\n        }\n        if (flag) vec.push_back(i + 1);\n    }\n    cout << vec.size() << endl;\n    for(auto e: vec) {\n        cout << e << endl;\n    }\n}\n\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1700
Some country consists of cities located along a straight highway Let s number the cities with consecutive integers from to in the order they occur along the highway Thus the cities are connected by segments of the highway the th segment connects cities number and Every segment of the highway is associated with a positive integer the period of traffic jams appearance on it In order to get from city to city some drivers use the following tactics Initially the driver is in city and the current time equals zero Until the driver arrives in city he perfors the following actions if the current time is a multiple of then the segment of the highway number is now having traffic problems and the driver stays in the current city for one unit of time formally speaking we assign if the current time is not a of then the segment of the highway number is now clear and that s why the driver uses one unit of time to move to city formally we assign and You are developing a new traffic control system You want to consecutively process queries of two types determine the final value of time after the ride from city to city assuming that we apply the tactics that is described above Note that for each query is being reset to replace the period of traffic jams appearing on the segment number by value formally assign Write a code that will effectively process the queries given above ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <ctime>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <iostream>\n\n#define pb push_back\n#define mp make_pair\n#define TASKNAME """"\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(""["" #x ""] Time = %.3lfs\\n"",clock()*1.0/CLOCKS_PER_SEC)\n\n#ifdef _WIN32\n#define LLD ""%I64d""\n#else\n#define LLD ""%lld""\n#endif\n\n#define sz(x) ((int)(x).size())\n#define forn(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, ll> pll;\ntypedef vector<pii> vpii;\n\nconst int inf = 1e9;\nconst double eps = 1e-9;\nconst int INF = inf;\nconst double EPS = eps;\n\n#ifdef DEBUG\nstruct __timestamper {\n  ~__timestamper(){\n    TIMESTAMP(end);\n  }\n} __Timestamper;\n#else\nstruct __timestamper {};\n#endif\n\n/*Template end*/\n\nconst int PER = 60;\n\nclass segm_tree {\n  struct Data {\n    int toadd[PER];\n\n    Data() {\n      fill(toadd, toadd + PER, 0);\n    }\n    Data(int x) {\n      assert(2 <= x && PER % x == 0);\n      fill(toadd, toadd + PER, 1);\n      for (int i = 0; i < PER; i += x)\n        toadd[i]++;\n    }\n    int &operator[](int x) { return toadd[x]; }\n    int  operator[](int x) const { return toadd[x]; }\n\n    friend Data operator+(const Data &a, const Data &b) {\n      Data res;\n      for (int st = 0; st < PER; st++) {\n        res[st] = a[st] + b[(st + a[st]) % PER];\n      }\n      return res;\n    }\n  };\n  int off;\n  vector<Data> tr;\n\npublic:\n  segm_tree(vector<int> &as) {\n    off = 1; while (off < sz(as)) off <<= 1;\n    tr = vector<Data>(2 * off);\n    forn (i, sz(as))\n      tr[off + i] = as[i];\n    for (int i = off - 1; i >= 1; i--)\n      tr[i] = tr[2 * i] + tr[2 * i + 1];\n  }\n  void set(int x, int v) {\n    tr[x += off] = v;\n    for (x >>= 1; x >= 1; x >>= 1)\n      tr[x] = tr[2 * x] + tr[2 * x + 1];\n  }\n  int get(int l, int r) {\n    Data resl, resr;\n    l += off; r += off;\n    while (l <= r) {\n      if (l & 1) resl = resl + tr[l++];\n      if (!(r & 1)) resr = tr[r--] + resr;\n      l >>= 1; r >>= 1;\n    }\n    Data res = resl + resr;\n    return res[0];\n  }\n};\n\nint main() {\n  #ifdef DEBUG\n  freopen(TASKNAME"".in"",""r"",stdin);\n  freopen(TASKNAME"".out"",""w"",stdout);\n  #endif\n\n  int n;\n  while (scanf(""%d"", &n) == 1) {\n    vi as(n);\n    forn (i, n) scanf(""%d"", &as[i]);\n\n    segm_tree tr(as);\n    int q;\n    scanf(""%d"", &q);\n    while (q --> 0) {\n      char op;\n      scanf("" %c"", &op);\n      if (op == \'A\') {\n        int l, r;\n        scanf(""%d%d"", &l, &r), l--, r -= 2;\n        printf(""%d\\n"", tr.get(l, r));\n      } else if (op == \'C\') {\n        int x, v;\n        scanf(""%d%d"", &x, &v), x--;\n        tr.set(x, v);\n      } else {\n        assert(false);\n      }\n    }\n  }\n\n  return 0;\n}\n']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2400
You are given a multiset S Over all pairs of subsets A and B such that B subset A B A 1 greatest common divisor of all elements in A is equal to one find the sum of sum x in A x cdot sum x in B x modulo 998 244 353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#include <debug-template.hpp>\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate<int MOD>\nstruct ModInt {\n\tModInt() : ModInt(0) {}\n\ttemplate<class U> ModInt(const U& x) { val = (1LL * x % MOD + MOD) % MOD; }\n\tModInt(const ModInt& x) { val = static_cast<int>(x); }\n\ttemplate<class U> inline operator U() const { return static_cast<U>(val); }\n\tinline ModInt& operator=(const ModInt& x) { val = static_cast<int>(x); return *this; }\n\ttemplate<class U> inline ModInt& operator=(const U& x) { val = static_cast<int>(ModInt(x)); return *this; }\n\tinline ModInt& operator+=(const ModInt& x) { val = (val + static_cast<long long>(x)) % MOD; return *this; }\n\tinline ModInt& operator-=(const ModInt& x) { val = (val - static_cast<long long>(x) + MOD) % MOD; return *this; }\n\tinline ModInt& operator*=(const ModInt& x) { val = (val * static_cast<long long>(x)) % MOD; return *this; }\n\tinline ModInt& operator/=(const ModInt& x) { *this *= ~x; return *this; }\n\ttemplate<class U> inline ModInt& operator+=(const U& x) { *this += ModInt(x); return *this; }\n\ttemplate<class U> inline ModInt& operator-=(const U& x) { *this -= ModInt(x); return *this; }\n\ttemplate<class U> inline ModInt& operator*=(const U& x) { *this *= ModInt(x); return *this; }\n\ttemplate<class U> inline ModInt& operator/=(const U& x) { *this /= ModInt(x); return *this; }\n\tinline ModInt& operator++() { return *this += 1; }\n\tinline ModInt operator++(int) { ModInt tmp = *this; *this += 1; return tmp; }\n\tinline ModInt& operator--() { return *this -= 1; }\n\tinline ModInt operator--(int) { ModInt tmp = *this; *this -= 1; return tmp; }\n\tfriend inline ModInt operator+(const ModInt& x, const ModInt& y) { return ModInt(x) += y; }\n\tfriend inline ModInt operator-(const ModInt& x, const ModInt& y) { return ModInt(x) -= y; }\n\tfriend inline ModInt operator*(const ModInt& x, const ModInt& y) { return ModInt(x) *= y; }\n\tfriend inline ModInt operator/(const ModInt& x, const ModInt& y) { return ModInt(x) /= y; }\n\tfriend inline bool operator==(const ModInt& x, const ModInt& y) { return static_cast<int>(x) == static_cast<int>(y); };\n\tfriend inline bool operator!=(const ModInt& x, const ModInt& y) { return static_cast<int>(x) != static_cast<int>(y); };\n\tinline ModInt operator+() const { return ModInt(+val); }\n\tinline ModInt operator-() const { return ModInt(-val); }\n\tinline ModInt operator~() const { return Pow(MOD - 2); }\n\ttemplate<class U> friend inline ModInt operator+(const ModInt& x, const U& y) { return ModInt(x) += y; }\n\ttemplate<class U> friend inline ModInt operator-(const ModInt& x, const U& y) { return ModInt(x) -= y; }\n\ttemplate<class U> friend inline ModInt operator*(const ModInt& x, const U& y) { return ModInt(x) *= y; }\n\ttemplate<class U> friend inline ModInt operator/(const ModInt& x, const U& y) { return ModInt(x) /= y; }\n\ttemplate<class U> friend inline ModInt operator+(const U& x, const ModInt& y) { return ModInt(x) += y; }\n\ttemplate<class U> friend inline ModInt operator-(const U& x, const ModInt& y) { return ModInt(x) -= y; }\n\ttemplate<class U> friend inline ModInt operator*(const U& x, const ModInt& y) { return ModInt(x) *= y; }\n\ttemplate<class U> friend inline ModInt operator/(const U& x, const ModInt& y) { return ModInt(x) /= y; }\n\ttemplate<class U> friend inline bool operator==(const ModInt& x, const U& y) { return x == ModInt(y); };\n\ttemplate<class U> friend inline bool operator!=(const ModInt& x, const U& y) { return x != ModInt(y); };\n\ttemplate<class U> friend inline bool operator==(const U& x, const ModInt& y) { return ModInt(x) == y; };\n\ttemplate<class U> friend inline bool operator!=(const U& x, const ModInt& y) { return ModInt(x) != y; };\n\ttemplate<class U> friend inline U& operator<<(U& ost, const ModInt& y) { return ost << static_cast<int>(y); }\n\ttemplate<class U> friend inline U& operator>>(U& ist, ModInt& x) { int t; ist >> t; x = t; return ist; }\n\ttemplate<class U> friend inline U& operator+=(U& x, const ModInt& y) { x = static_cast<U>(x + y); return x; }\n\ttemplate<class U> friend inline U& operator-=(U& x, const ModInt& y) { x = static_cast<U>(x - y); return x; }\n\ttemplate<class U> friend inline U& operator*=(U& x, const ModInt& y) { x = static_cast<U>(x * y); return x; }\n\ttemplate<class U> friend inline U& operator/=(U& x, const ModInt& y) { x = static_cast<U>(x / y); return x; }\n\ttemplate<class U> inline ModInt Pow(U n) const {\n\t\tif (n < 0) return ~Pow(-n);\n\t\tModInt rlt = 1, tmp = *this;\n\t\twhile (n) {\n\t\t\tif (n & 1) rlt *= tmp;\n\t\t\ttmp *= tmp;\n\t\t\tn /= 2;\n\t\t}\n\t\treturn rlt;\n\t}\nprivate:\n\tint val;\n};\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\t\n\tusing mint = ModInt<998244353>;\n\tint M; cin >> M;\n\tvector<int> freq(100001);\n\tvector<mint> ans(100001);\n\twhile (M--) {\n\t\tint a; cin >> a;\n\t\tcin >> freq[a];\n\t}\n\tmint tp = 2;\n\tfor (int i = freq.size() - 1; i >= 1; i--) {\n\t\tlong long k = 0; mint s = 0, t = 0;\n\t\tfor (int j = i; j < freq.size(); j += i) {\n\t\t\tk += freq[j];\n\t\t\ts += freq[j] * mint(j);\n\t\t\tt += mint(j) * freq[j] * j;\n\t\t}\n\t\ts = (s * s - t);\n\t\t// a[i] * a[i] (k - 1) * 2 ^ (k - 2)\n\t\t// a[i] * a[j] k * 2 ^ (k - 2)\n\t\tans[i] = tp.Pow(k-3) * (s * k + t * (k - 1) * tp);\n\t\tfor (int j = i * 2; j < freq.size(); j += i) ans[i] -= ans[j];\n\t}\n\tcout << ans[1];\n\t\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0]",2800
While Patrick was gone shopping Spongebob decided to play a little trick on his friend The naughty Sponge browsed through Patrick s personal stuff and found a sequence of length consisting of integers from to not necessarily distinct Then he picked some sequence of length and for each number got number To finish the prank he erased the initial sequence It s hard to express how sad Patrick was when he returned home from shopping We will just say that Spongebob immediately got really sorry about what he has done and he is now trying to restore the original sequence Help him do this or determine that this is impossible ,"['#include <bits/stdc++.h>\nusing namespace std;\nint used[100005];\nint f[100005];\nint o[100005];\nint freq[100005], rev[100005];\nint main() {\n  int n, m, x;\n  scanf(""%d %d"", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(""%d"", &f[i]);\n    freq[f[i]]++;\n    rev[f[i]] = i;\n  }\n  bool amb = false;\n  for (int i = 1; i <= m; i++) {\n    scanf(""%d"", &x);\n    if (freq[x] == 1) {\n      o[i] = rev[x];\n    } else if (freq[x] == 0) {\n      printf(""Impossible\\n"");\n      return 0;\n    } else {\n      amb = true;\n    }\n  }\n  if (amb) {\n    printf(""Ambiguity\\n"");\n    return 0;\n  }\n  printf(""Possible\\n"");\n  for (int i = 1; i <= m; i++) {\n    printf(""%d%c"", o[i], i == m ? \'\\n\' : \' \');\n  }\n  return 0;\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1500
You have a connected undirected graph made of n nodes and m edges The i th node has a value v i and a target value t i In an operation you can choose an edge i j and add k to both v i and v j where k can be any In particular k can be negative Your task to determine if it is possible that by doing some finite number of operations possibly zero you can achieve for every node i v i t i ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <queue>\n#include <random>\n#include ""map""\ntypedef double ld;\ntypedef long long ll;\n#define all(x) x.begin(), x.end()\nusing namespace std;\n#define int long long\nvector<int> seen;\nbool gd = 0;\nvector<vector<int>> g;\nvoid dfs(int v, int se) {\n    if (seen[v]) {\n        if (se + seen[v] == 3)\n            gd = 1;\n        return;\n    }\n    seen[v] = se;\n    for (auto i : g[v])\n        dfs(i, 3 - se);\n}\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    g.assign(n, {});\n    gd = 0;\n    vector<int> a(n);\n    for (auto &i : a) {\n        cin >> i;\n    }\n    int res = 0;\n    for (auto &i : a) {\n        int b;\n        cin >> b;\n        i -= b;\n        res += i % 2;\n    }\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--;v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    if (res % 2) {\n        cout << ""NO\\n"";return;\n    }\n    seen.assign(n, 0);\n    dfs(0, 1);\n    if (gd) {\n        cout << ""YES\\n"";return;\n    }\n    int r1 = 0, r2 = 0;\n    for (int i = 0; i < n; ++i) {\n       // cout << i << \' \' << seen[i] << endl;\n        if (seen[i] == 1) {\n            r1 += a[i];\n        } else{\n            r2 += a[i];\n        }\n    }\n    //cout << r1 << \' \' << r2 << endl;\n    if (r1 == r2) {\n        cout << ""YES\\n"";\n    } else {\n        cout << ""NO\\n"";\n    }\n}\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    int q = 1;\n    cin >> q;\n    while (q--) solve();\n}\n']","[1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2200
Let s be some string consisting of symbols or Let s call a string t a substring of string s if there exists such number 1 leq l leq s t 1 that t s l s l 1 ldots s l t 1 Let s call a substring t of string s unique if there exist only one such l For example let s A string t is an unique substring of s because l 2 is the only one suitable number But for example t isn t a unique substring of s because l 1 and l 3 are suitable And for example t at all isn t a substring of s because there is no suitable l Today Vasya solved the following problem at the informatics lesson given a string consisting of symbols and the task is to find the length of its minimal unique substring He has written a solution to this problem and wants to test it He is asking you to help him You are given 2 positive integers n and k such that n bmod 2 k bmod 2 where x bmod 2 is operation of taking remainder of x by dividing on 2 Find any string s consisting of n symbols or such that the length of its minimal unique substring is equal to k ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, K;\n  cin >> N >> K;\n\n  const int ss = (N - K) / 2;\n\n  string ptn(ss, \'1\');\n  ptn += ""0"";\n\n  string s;\n  while (SZ(s) < N) { s += ptn; }\n  s.resize(N);\n  cout << s << ""\\n"";\n}\n\n']","[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0]",2200
Sereja has non empty sets of integers What a lucky coincidence The given sets are a partition of the set of all integers from 1 to In other words for any integer there is exactly one set such that Also Sereja has integer Sereja decided to choose some sets from the sets he has Let s suppose that are indexes of the chosen sets Then let s define an array of integers sorted in ascending order as a union of the chosen sets that is We ll represent the element with number in this array in ascending order as Sereja considers his choice of sets if the following conditions are met Sereja wants to know what is the minimum number of sets that he can choose so that his choice will be correct Help him with that ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nint N,K,D;\nint a[100010];\nint freq[30];\nbool bad[(1<<20)];\n\nvoid add(void){\n    int mask = 0;\n    int i;\n    REP(i,K) if(freq[i] == 0) mask |= (1<<i);\n    bad[mask] = true;\n//  cout << mask << endl;\n}\n\nint main(void){\n    int i,j,mask;\n    \n    cin >> N >> K >> D;\n    REP(i,K){\n        int sz;\n        cin >> sz;\n        int x;\n        REP(j,sz){\n            scanf(""%d"", &x);\n            a[x-1] = i;\n        }\n    }\n    \n    REP(i,D) freq[a[i]]++;\n    add();\n    for(i=D;i<N;i++){\n        freq[a[i]]++;\n        freq[a[i-D]]--;\n        add();\n    }\n    \n    int ans = K;\n    for(mask=(1<<K)-1;mask>=0;mask--){\n        if(!bad[mask]){\n            int cnt = 0;\n            REP(i,K) if(mask&(1<<i)) cnt++;\n            ans = min(ans, cnt);\n        } else {\n            REP(i,K) if(mask&(1<<i)) bad[mask^(1<<i)] = true;\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0]",2400
Vasya has started watching football games He has learned that for some fouls the players receive yellow cards and for some fouls they receive red cards A player who receives the second yellow card automatically receives a red card Vasya is watching a recorded football match now and makes notes of all the fouls that he would give a card for Help Vasya determine all the moments in time when players would be given red cards if Vasya were the judge For each player Vasya wants to know only the moment of time when he would receive a red card from Vasya ,"['#include<iostream>\n#include<string.h>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<map>\nusing namespace std;\n\nstring home, away;\n\nstruct Node\n{\n\tint time;\n\tstring name;\n\tstring num;\n\tstring type;\n};\n\nNode node[10000];\n\nbool cmp(Node a, Node b)\n{\n\treturn a.time < b.time;\n}\n\nint main()\n{\n\tcin>>home>>away;\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tcin>>node[i].time>>node[i].name>>node[i].num>>node[i].type;\n\t}\n\t\n\tsort(node, node+n, cmp);\n\tmap<string, int> m;\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tstring key = node[i].name + node[i].num;\n\t\tmap<string, int>::iterator iter = m.find(key);\n\t\tint old = 0;\n\t\tif(iter != m.end())\n\t\t{\n\t\t\told = iter->second;\n\t\t}\n\t\t\n\t\tint next = 0;\n\t\tif(node[i].type == ""y"")\n\t\t{\n\t\t\tnext = old + 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnext = old + 2;\n\t\t}\n\t\t\n\t\tif(old < 2 && next >= 2)\n\t\t{\n\t\t\tif(node[i].name == ""h"")\n\t\t\t\tcout<<home<<"" "";\n\t\t\telse\n\t\t\t\tcout<<away<<"" "";\n\t\t\tcout<<node[i].num<<"" ""<<node[i].time<<endl;\n\t\t}\n\t\t\n\t\tm[key] = next;\n\t}\n\t\n\treturn 0;\n}']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Mahmoud wants to write a new dictionary that contains words and relations between them There are two types of relations synonymy i e the two words mean the same and antonymy i e the two words mean the opposite From time to time he discovers a new relation between two words He know that if two words have a relation between them then each of them has relations with the words that has relations with the other For example if means and is the opposite of then is also the opposite of One more example if is the opposite of and is the opposite of then means and so on Sometimes Mahmoud discovers a wrong relation A wrong relation is a relation that makes two words equal and opposite at the same time For example if he knows that means and is the opposite of and then he figures out that means the last relation is absolutely wrong because it makes and opposite and have the same meaning at the same time After Mahmoud figured out many relations he was worried that some of them were wrong so that they will make other relations also wrong so he decided to tell every relation he figured out to his coder friend Ehab and for every relation he wanted to know is it correct or wrong basing on the previously discovered relations If it is wrong he ignores it and doesn t check with following relations After adding all relations Mahmoud asked Ehab about relations between some words based on the information he had given to him Ehab is busy making a Codeforces round so he asked you for help ,"['#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <sstream>\n#include <numeric>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++)\n#define np(v) next_permutation(v.begin(), v.end())\n#define pll pair < long long, long long>\n#define all(a) a.begin(), a.end()\n#define ull unsigned long long\n#define pii pair < int, int >\n#define sz(a) (int)a.size()\n#define sqr(x) ((x) * (x))\n#define y1 stupid_cmath\n#define vi vector <int>\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define f first\n#define s second\n\nconst int inf = (int)1e9;\nconst int mod = inf + 7;\nconst double eps = 1e-9;\nconst double pi = acos(-1.0);\n\nstring u, v;\nint n, m, q;\nint t;\nstring s[100100];\nmap <string, int> id;\nint p[200200];\n\nint get(int v){\n    if(p[v] == v) return v;\n    return p[v] = get(p[v]);\n}\n\nint main(){\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    cin >> n >> m >> q;\n    for(int i = 0; i < n; ++i){\n        cin >> s[i];\n        id[s[i]] = i;\n        p[i] = i;\n        p[i + n] = i + n;\n    }\n    for(int i = 0; i < m; ++i){\n        cin >> t >> u >> v;\n        int x = id[u];\n        int y = id[v];\n        if(t == 1){\n            if(get(x) == get(y + n)) cout << ""NO"" << ""\\n"";\n            else{\n                if(get(x) != get(y)){\n                    p[get(x)] = get(y);\n                }\n                if(get(x + n) != get(y + n)){\n                    p[get(x + n)] = get(y + n);\n                }\n                cout << ""YES"" << ""\\n"";\n            }\n        }else{\n            if(get(x) == get(y)){\n                cout << ""NO"" << ""\\n"";\n            }else{\n                if(get(x) != get(y + n)){\n                    p[get(x)] = get(y + n);\n                }\n                if(get(x + n) != get(y)){\n                    p[get(x + n)] = get(y);\n                }\n                cout << ""YES"" << ""\\n"";\n            }\n        }\n    }\n    for(int i = 0; i < q; ++i){\n        cin >> u >> v;\n        int x = id[u];\n        int y = id[v];\n        if(get(x) == get(y)) cout << 1 << ""\\n"";\n        else{\n            if(get(x) == get(y + n)) cout << 2 << ""\\n"";\n            else cout << 3 << ""\\n"";\n        }\n    }\n}\n']","[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]",2000
This winter is so well you ve got the idea The Nvodsk road system can be represented as junctions connected with bidirectional roads so that there is a path between any two junctions The organizers of some event want to choose a place to accommodate the participants junction and the place to set up the contests junction Besides at the one hand they want the participants to walk about the city and see the neighbourhood that s why the distance between and should be no less than On the other hand they don t want the participants to freeze so the distance between and should be no more than Besides for every street we know its beauty some integer from to Your task is to choose the path that fits in the length limits and has the largest average beauty We shall define the average beauty as a median of sequence of the beauties of all roads along the path We can put it more formally like that let there be a path with the length Let be a non decreasing sequence that contains exactly elements Each number occurs there exactly the number of times a road with such beauty occurs along on path We will represent the path median as number assuming that is used is number rounded down to the nearest integer For example if then the median equals to and if then the median is number It is guaranteed that there will be at least one path with the suitable quantity of roads ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <climits>\n#include <numeric>\n#include <vector>\n#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)\nusing namespace std;\nconst int MAX_N = 100000;\nconst int INF = ~0U >> 3;\nstruct Edge {\n\tint t, c;\n};\nvector<Edge> E[MAX_N];\nint n, pl, pr;\nbool del[MAX_N];\n\nint size[MAX_N], ord[MAX_N], cur, cnt[MAX_N], dep[MAX_N], fa[MAX_N];\nvoid dfs(int u, int par, int chk, int d, int c) {\n\tdep[u] = d, cnt[u] = c, size[u] = 1, ord[cur++] = u, fa[u] = par;\n\tforeach(e,E[u])\n\t\tif (!del[e->t] && e->t != par) {\n\t\t\tdfs(e->t, u, chk, d + 1, c + (e->c >= chk ? 1 : -1));\n\t\t\tsize[u] += size[e->t];\n\t\t}\n}\n\nint ansU, ansV, ans;\n\nint mx[MAX_N], who[MAX_N], maxd;\nint nmx[MAX_N], nwho[MAX_N], nmaxd;\n\nbool cmp(int a, int b) {\n\treturn size[a] < size[b];\n}\n\nint lstU, lstV;\n\nbool check() {\n\tstatic int que[MAX_N];\n\tint qh = 0, qt = 0;\n\tint l = maxd;\n\n\tfor (int i = 1; i <= nmaxd; ++i) {\n\t\twhile (l + i >= pl && l >= 0) {\n\t\t\twhile (qh < qt && mx[que[qt - 1]] <= mx[l])\n\t\t\t\t--qt;\n\t\t\tque[qt++] = l;\n\t\t\t--l;\n\t\t}\n\t\twhile (qh < qt && que[qh] + i > pr)\n\t\t\t++qh;\n\t\tif (qh < qt) {\n\t\t\tif (mx[que[qh]] + nmx[i] >= 0) {\n\t\t\t\tlstU = who[que[qh]];\n\t\t\t\tlstV = nwho[i];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(int rt) {\n\tcur = 0;\n\tdfs(rt, -1, -1, 0, 0);\n\tint mi = INF, sp;\n\tfor (int i = 0; i < cur; ++i) {\n\t\tint u = ord[i];\n\t\tint opt = size[rt] - size[u];\n\t\tforeach(e,E[u])\n\t\t\tif (!del[e->t] && e->t != fa[u])\n\t\t\t\topt = max(opt, size[e->t]);\n\t\tif (opt < mi)\n\t\t\tmi = opt, sp = u;\n\t}\n\n\trt = sp;\n\tcur = 0, dfs(rt, -1, -1, 0, 0);\n\t//cout << ""ROOT:"" << rt << endl;\n\tdel[rt] = true;\n\tstatic int ch[MAX_N];\n\tint nCh = 0;\n\tforeach(e,E[rt])\n\t\tif (!del[e->t])\n\t\t\tch[nCh++] = e->t;\n\tsort(ch, ch + nCh, cmp);\n\tint l = -1, r = 1e9 + 1;\n\tfor (;;) {\n\t\tint m = (l + r) >> 1;\n\t\tforeach(e,E[rt])\n\t\t\tif (!del[e->t])\n\t\t\t\tcnt[e->t] = e->c >= m ? 1 : -1;\n\t\tbool ok = false;\n\t\tmaxd = 0;\n\t\tmx[0] = 0, who[0] = rt;\n\t\tfor (int it = 0; it < nCh; ++it) {\n\t\t\tint u = ch[it];\n\t\t\tcur = 0, dfs(u, -1, m, 1, cnt[u]);\n\t\t\tnmaxd = 0;\n\t\t\tfor (int i = 0; i < cur; ++i) {\n\t\t\t\tnmaxd = max(nmaxd, dep[ord[i]]);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= nmaxd; ++i) {\n\t\t\t\tnmx[i] = -INF;\n\t\t\t}\n\t\t\tfor (int i = 0; i < cur; ++i) {\n\t\t\t\tint v = ord[i];\n\t\t\t\tif (cnt[v] > nmx[dep[v]])\n\t\t\t\t\tnmx[dep[v]] = cnt[v], nwho[dep[v]] = v;\n\t\t\t}\n\t\t\tif (check()) {\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= nmaxd; ++i) {\n\t\t\t\tif (i > maxd || nmx[i] > mx[i])\n\t\t\t\t\tmx[i] = nmx[i], who[i] = nwho[i];\n\t\t\t}\n\t\t\tmaxd = max(maxd, nmaxd);\n\t\t}\n\t\tif (l + 1 == r)\n\t\t\tbreak;\n\t\tif (ok)\n\t\t\tl = m;\n\t\telse\n\t\t\tr = m;\n\t}\n\tif (l > ans)\n\t\tans = l, ansU = lstU, ansV = lstV;\n\tforeach(e,E[rt])\n\t\tif (!del[e->t])\n\t\t\tsolve(e->t);\n}\n\nint main() {\n\tcin >> n >> pl >> pr;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b, c;\n\t\tscanf(""%d%d%d"", &a, &b, &c), --a, --b;\n\t\tE[a].push_back((Edge) {b,c});\n\t\tE[b].push_back((Edge) {a,c});\n\t}\n\tans = -1;\n\tsolve(0);\n\tcout << ansU + 1 << "" "" << ansV + 1 << endl;\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",3000
You are organizing a boxing tournament where n boxers will participate n is a power of 2 and your friend is one of them All boxers have different strength from 1 to n and boxer i wins in the match against boxer j if and only if i is stronger than j The tournament will be organized as follows n boxers will be divided into pairs the loser in each pair leaves the tournament and frac n 2 winners advance to the next stage where they are divided into pairs again and the winners in all pairs advance to the next stage and so on until only one boxer remains who is declared the winner Your friend really wants to win the tournament but he may be not the strongest boxer To help your friend win the tournament you may bribe his opponents if your friend is fighting with a boxer you have bribed your friend wins even if his strength is lower Furthermore during each stage you distribute the boxers into pairs as you wish The boxer with strength i can be bribed if you pay him a i dollars What is the minimum number of dollars you have to spend to make your friend win the tournament provided that you arrange the boxers into pairs during each stage as you wish ,"['#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main() {\n    int n;\n    vector<int> A;\n    scanf(""%d"", &n);\n    int l = 0;\n    while ((1 << l) != n) l++;\n    int f = -1;\n    for (int i = 0; i < n; i++) {\n        int a;\n        scanf(""%d"", &a);\n        if (a == -1) {\n            f = i;\n            continue;\n        }\n        A.push_back(f != -1 ? a : 0);\n    }\n    reverse(A.begin(), A.end());\n    const ll inf = 1e18;\n    ll dp[20] = {};\n    int cnt[20] = { n / 2 };\n    for (int i = 1; i < l; i++) cnt[i] = cnt[i - 1] + (1 << l - i - 1);\n    for (int i = 1; i < l; i++) dp[i] = inf;\n    dp[0] = A[0];\n    for (int i = 1; i < int(A.size()); i++) {\n        ll nxt[20] = {};\n        for (int j = 0; j < l; j++) nxt[j] = inf;\n        for (int j = 0; j < l; j++) {\n            if (i + 1 <= cnt[j]) nxt[j] = min(nxt[j], dp[j]);\n            nxt[j + 1] = min(nxt[j + 1], dp[j] + A[i]);\n        }\n        for (int j = 0; j < l; j++) dp[j] = nxt[j];\n    }\n    printf(""%lld\\n"", dp[l - 1]);\n}']","[1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
Little Vasya s uncle is a postman The post offices are located on one circular road Besides each post office has its own gas station located next to it Petya s uncle works as follows in the morning he should leave the house and go to some post office In the office he receives a portion of letters and a car Then he must drive in the given car exactly one round along the circular road and return to the starting post office the uncle can drive along the circle in any direction counterclockwise or clockwise Besides since the car belongs to the city post it should also be fuelled with gasoline only at the Post Office stations The total number of stations equals to One can fuel the car at the th station with no more than liters of gasoline Besides one can fuel the car no more than once at each station Also the distance between the st and the nd station is kilometers the distance between the nd and the rd one is kilometers between the th and the th ones the distance is kilometers and between the th and the st one the distance is kilometers Petya s uncle s high tech car uses only one liter of gasoline per kilometer It is known that the stations are located so that the sum of all is equal to the sum of all The th gas station and th post office are very close so the distance between them is kilometers Thus it becomes clear that if we start from some post offices then it is not always possible to drive one round along a circular road The uncle faces the following problem to what stations can he go in the morning to be able to ride exactly one circle along the circular road and visit all the post offices that are on it Petya who used to attend programming classes has volunteered to help his uncle but his knowledge turned out to be not enough so he asks you to help him write the program that will solve the posed problem ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""e""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nint N, a[100005], b[100005], good[100005];\n\nlong long s[200005];\n\nset <pair <long long, int> > st;\n\nvoid Load ()\n{\n    scanf (""%d"", &N);\n\n    for (int i = 0;i < N;i++)\n        scanf (""%d"", &a[i]);\n    for (int i = 0;i < N;i++)\n        scanf (""%d"", &b[i]);\n}\n\nvoid go (bool rev)\n{\n    st.clear();\n    s[0] = a[0] - b[0];\n    for (int i = 1;i < 2 * N;i++)\n        s[i] = s[i - 1] + a[i%N] - b[i%N];\n\n    for (int i = 0;i < N;i++)\n        st.insert (make_pair (s[i], i));\n\n    for (int i = 0;i < N;i++)\n    {\n        int cur = (*st.begin()).second;\n        if (s[cur] - (i > 0 ? s[i - 1] : 0) >= 0)\n            good[rev ? N - (i % N) - 1 : (i % N)] = 1;\n\n        st.erase (make_pair (s[i], i));\n        st.insert (make_pair (s[i + N], i + N));\n    }\n}\n\nvoid Solve ()\n{\n    go (0);\n    reverse (a, a + N);\n    reverse (b, b + N);\n    int t = b[0];\n    for (int i = 0;i < N - 1;i++)\n        b[i] = b[i + 1];\n    b[N - 1] = t;\n    go (1);\n\n    int ans = 0;\n    for (int i = 0;i < N;i++)\n        if (good[i]) ans++;\n    cout << ans << endl;\n\n    for (int i = 0;i < N;i++)\n        if (good[i]) printf (""%d "", i + 1);\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']","[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
Petya has a simple graph that is a graph without loops or multiple edges consisting of n vertices and m edges The weight of the i th vertex is a i The weight of the i th edge is w i A subgraph of a graph is some set of the graph vertices and some set of the graph edges The set of edges must meet the condition both ends of each edge from the set must belong to the chosen set of vertices The weight of a subgraph is the sum of the weights of its edges minus the sum of the weights of its vertices You need to find the maximum weight of subgraph of given graph ,"['/*\nI\'m just a man and I am what I am, yeah\nNobody will ever change my ways\nI don\'t need money and I don\'t need no lies, yeah\nI only need to live for today\nBut I\'d like to talk things over with you\nI want to hear the things you say, today\nAlthough you won\'t change me anyway, oh no way\n\nI wish you\'d come and see me, I\'d like to hold you\nI want to set my mind all free\nYou understand me woman, you give me time, yeah\nBut I don\'t need no sympathy\nStill I wonder what it\'s like to be loved\nInstead of hiding in myself\nNobody will change me anyway, no no way\n\nNobody\'s gonna change my world\nThat\'s something too unreal\nNobody will change the way I feel\n\nSo listen to me now, hear what I say, yeah\nPlease give me time and maybe love\nIf there\'s a God up there, well I hope he helps me\nI need him now to set me free\n\'Cause it may be that it\'s over for me\nIf you don\'t hear the things that I say, today\nNobody will change me anyway, no no way\n\nNobody\'s gonna change my world\nThat\'s something too unreal\nNobody will change the way I feel\n*/\n\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 600031;\n\nlong long n,m,s,t;\n\nstruct edge {\n\tint a, b;\n\tlong long cap, flow;\n};\n\nconst int MAXN = N;\n\nlong long d[MAXN], ptr[MAXN], q[MAXN];\nvector<edge> e;\nvector<int> g[MAXN];\n\nvoid add_edge (int a, int b, long long cap) {\n\tedge e1 = { a, b, cap, 0 };\n\tedge e2 = { b, a, 0, 0 };\n\tg[a].push_back ((int) e.size());\n\te.push_back (e1);\n\tg[b].push_back ((int) e.size());\n\te.push_back (e2);\n}\n\nbool bfs() {\n\tint qh=0, qt=0;\n\tq[qt++] = s;\n\tmemset (d, -1, n * sizeof d[0]);\n\td[s] = 0;\n\twhile (qh < qt && d[t] == -1) {\n\t\tint v = q[qh++];\n\t\tfor (size_t i=0; i<g[v].size(); ++i) {\n\t\t\tint id = g[v][i],\n\t\t\t\tto = e[id].b;\n\t\t\tif (d[to] == -1 && e[id].flow < e[id].cap) {\n\t\t\t\tq[qt++] = to;\n\t\t\t\td[to] = d[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t] != -1;\n}\n\nlong long dfs (int v, long long flow) {\n\tif (!flow)  return 0;\n\tif (v == t)  return flow;\n\tfor (; ptr[v]<(int)g[v].size(); ++ptr[v]) {\n\t\tint id = g[v][ptr[v]],\n\t\t\tto = e[id].b;\n\t\tif (d[to] != d[v] + 1)  continue;\n\t\tint pushed = dfs (to, min (flow, e[id].cap - e[id].flow));\n\t\tif (pushed) {\n\t\t\te[id].flow += pushed;\n\t\t\te[id^1].flow -= pushed;\n\t\t\treturn pushed;\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long dinic() {\n\tlong long flow = 0;\n\tfor (;;) {\n\t\tif (!bfs())  break;\n\t\tfor (int i=0;i<=n;i++)\n\t\t\tptr[i]=0;\n\t\twhile (true){\n\t\t\tlong long pushed = dfs (s, 1000000000000000ll);\n\t\t\tif (pushed==0)\n\t\t\t\tbreak;\n\t\t\tflow += pushed;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint main(){\n//\tfreopen(""apache.in"",""r"",stdin);\n//\tfreopen(""apache.out"",""w"",stdout);\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin>>n>>m;\n\ts=0;\n\tt=n+m+1;\n\tfor (int i=1;i<=n;i++){\n\t\tint val;\n\t\tcin>>val;\n\t\tadd_edge(s,i,val);\n\t}\n\n\tlong long ttl=0;\n\n\tfor (int i=1;i<=m;i++){\n\t\tint a,b;\n\t\tint val;\n\t\tcin>>a>>b>>val;\n\t\tadd_edge(a,i+n,1e15);\n\t\tadd_edge(b,i+n,1e15);\n\t\tadd_edge(i+n,t,val);\n\t\tttl+=val;\n\t}\n\n\t// some magic shit happens.\n\tn=t+1;\n\tlong long here=dinic();\n\n\tcout<<ttl-here<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2400
You have a rectangular chocolate bar consisting of single squares You want to eat squares so you may need to break the chocolate bar In one move you can break any single rectangular piece of chocolate in two rectangular pieces You can break only by lines between squares horizontally or vertically The cost of breaking is equal to square of the break length For example if you have a chocolate bar consisting of unit squares then you can break it horizontally and get two pieces the cost of such breaking is or you can break it vertically in two ways and get two pieces and the cost of such breaking is For several given values and find the minimum total cost of breaking You can eat exactly squares of chocolate if after all operations of breaking there is a set of rectangular pieces of chocolate with the total size equal to squares The remaining squares are not necessarily form a single rectangular piece ,"[""//ITNOA\n#include<bits/stdc++.h> \n\nusing namespace std;\n \n\n#define scan(x) do{while((x=getchar())<'0'); for(x-='0'; '0'<=(_=getchar()); x=(x<<3)+(x<<1)+_-'0');}while(0)\nchar _;\n\n//#define int long long\n#define rep(i, s, e) for(int i = s; i < e; i ++)\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxN = 1000 + 5;\nconst int mod = 1000*1000*1000 + 7;\nconst int base = 701;\nconst int SQ = 600;\nconst int maxL = 302;\n\n\nint dp[32][32][52];\n\nint32_t main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    rep(i,0,32) rep(j,0,32) rep(k,0,52)\n\tdp[i][j][k] = mod;\n\n    rep(i,1,32) rep(j,1,32)\n    {\n\tif(i * j < 52) dp[i][j][i*j] = 0;\n\tdp[i][j][0] = 0;\n\n\tint x = min(52, i*j);\n\trep(k,1,x)\n\t{\n\t    rep(who,0,k+1)\n\t    {\n\t\trep(wh,1,j)\n\t\t    dp[i][j][k] = min(dp[i][j][k], dp[i][wh][who] + dp[i][j-wh][k-who] + i * i);\n\t\trep(wh,1,i)\n\t\t    dp[i][j][k] = min(dp[i][j][k], dp[wh][j][who] + dp[i-wh][j][k-who] + j * j);\n\t    }\n\t}\n    }\n\n    int q; cin >> q;\n    rep(i,0,q)\n    {\n\tint n, m, k; cin >> n >> m >> k;\n\tcout << dp[n][m][k] << endl;\n    }\n    return 0;    \n}\n""]","[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2000
You are given a simple undirected graph with n vertices n is even You are going to write a letter on each vertex Each letter should be one of the first k letters of the Latin alphabet A path in the graph is called Hamiltonian if it visits each vertex exactly once A string is called palindromic if it reads the same from left to right and from right to left A path in the graph is called palindromic if the letters on the vertices in it spell a palindromic string without changing the order A string of length n is good if each letter is one of the first k lowercase Latin letters if you write the i th letter of the string on the i th vertex of the graph there will exist a palindromic Hamiltonian path in the graph Note that the path doesn t necesserily go through the vertices in order 1 2 dots n Count the number of good strings ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 13; \n\nint N, M, K;\nll ans = 0;\nvi color, match;\nvi cc[MX];\nint nc = 0;\nset<vi> okMatches;\nll numWays[MX];\nbool graph[MX][MX];\n\n\nbool goMatch(int p) {\n    if (p == N) {\n        if (okMatches.count(match)) { \n            ans += numWays[nc];\n            return true;\n        }\n        return false;\n    }\n    if (match[p] != -1) {\n        return goMatch(p+1); \n    }\n\n    trav(a, cc[color[p]]) {\n        if (a == p || match[a] != -1) continue;\n        match[a] = p; match[p] = a;\n        if (goMatch(p+1)) return true;\n        match[p] = -1; match[a] = -1;\n    }\n    return false;\n    \n}\n\nvoid goColor(int p) {\n    if (p == N) {\n        F0R(i, nc) if (sz(cc[i])%2) return;\n        match = vi(N, -1);\n        goMatch(0);\n        return;\n    }\n    int onc = nc;\n    F0R(i, onc+1) {\n        ckmax(nc, i+1);\n        color[p] = i;\n        cc[i].pb(p);\n        goColor(p+1);\n        cc[i].pop_back();\n    }\n    nc = onc;\n}\n\nvoid initMatch(int p) {\n    if (p == N) {\n        //dbg(match);\n        //check if hamiltonian path\n        vector<vi> pairs;\n        F0R(i, N) {\n            if (i < match[i]) {\n                pairs.pb({i, match[i]});\n            }\n        }\n        bool ok[N/2][N/2]; F0R(i, N/2) F0R(j, N/2) ok[i][j] = false;\n        F0R(i, N/2) {\n            F0R(j, N/2) {\n                F0R(a, 2) {\n                    F0R(b, 2) {\n                        if (graph[pairs[i][a]][pairs[j][b]] && graph[pairs[i][1-a]][pairs[j][1-b]]) { \n                            ok[i][j] = true;\n                            /*if (i == j) {\n                                dbg(i, pairs[i]);\n                            }*/\n                        }\n                        if (i == j && graph[pairs[i][a]][pairs[j][b]]) {\n                            ok[i][j] = true;\n                            //dbg(i, pairs[i]);\n                        }\n                    }\n                }\n            }\n        }\n        vi perm; F0R(i, sz(pairs)) perm.pb(i);\n        do {\n            bool val = true;\n            F0R(i, N/2 - 1) if (!ok[perm[i]][perm[i+1]]) val = false;\n            if (!ok[perm[0]][perm[0]]) val = false;\n            if (val) {\n                //dbg(match, perm);\n                okMatches.ins(match); return;\n            }\n        } while (next_permutation(all(perm)));\n\n        return;\n    }\n    if (match[p] != -1) {\n        initMatch(p+1); return;\n    }\n\n    FOR(a, p+1, N) {\n        if (a == p || match[a] != -1) continue;\n        match[a] = p; match[p] = a;\n        initMatch(p+1);\n        match[p] = -1; match[a] = -1;\n    }\n}\n\nvoid solve() {\n    cin >> N >> M >> K;\n    numWays[0] = 1;\n    FOR(i, 1, MX) numWays[i] = numWays[i-1] * (K-i+1);\n    F0R(i, M) {\n        int X, Y; cin >> X >> Y; X--; Y--;\n        graph[X][Y] = true;\n        graph[Y][X] = true;\n    }\n    match = vi(N, -1);\n    color = vi(N);\n    initMatch(0);\n    goColor(0);\n    cout << ans << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n']","[0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]",3000
The Super Duper Secret Meeting of the Super Duper Secret Military Squad takes place in a Super Duper Secret Place The place is an infinite plane with introduced Cartesian coordinate system The meeting table is represented as a rectangle whose sides are parallel to the coordinate axes and whose vertexes are located at the integer points of the plane At each integer point which belongs to the table perimeter there is a chair in which a general sits Some points on the plane contain radiators for the generals not to freeze in winter Each radiator is characterized by the number the radius of the area this radiator can heat That is if the distance between some general and the given radiator is less than or equal to than the general feels comfortable and warm Here distance is defined as Euclidean distance so the distance between points and is Each general who is located outside the radiators heating area can get sick Thus you should bring him a warm blanket Your task is to count the number of warm blankets you should bring to the Super Duper Secret Place The generals who are already comfortable do not need a blanket Also the generals never overheat ever if they are located in the heating area of several radiators The radiators can be located at any integer points on the plane even inside the rectangle under the table or on the perimeter directly under some general Even in this case their radius does not change ,"['#include <string>\n#include <algorithm>\n#include <utility>\n#include <stdlib.h>\n#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <utility>\n#include <time.h>\n#include <string.h>\nusing namespace std;\n\n\nint main( void )\n{\n\tint x0,y0,X,Y;\n\tint n;\n\n\tcin >> x0 >> y0 >> X >> Y;\n\tif( x0 > X ){ int t = x0; x0 = X; X = t; }\n\tif( y0 > Y ){ int t = y0; y0 = Y; Y = t; }\n\tX -= x0;\n\tY -= y0;\n\tcin >> n;\n\tvector<int> Rx(n), Ry(n), Rr(n);\n\tfor( int i = 0; i < n; i ++ ){\n\t\tcin >> Rx[i] >> Ry[i] >> Rr[i];\n\t\tRx[i] -= x0;\n\t\tRy[i] -= y0;\n\t\tRr[i] *= Rr[i];\n\t}\n\tint ans = 0;\n#define CHECK(xx,yy) \\\n{ \\\n\tbool OK = false; \\\n\tfor( int i = 0; i < n; i ++ ){ \\\n\t\tif( (Rx[i] - xx) * (Rx[i] - xx) + (Ry[i] - yy) * (Ry[i] - yy) <= Rr[i] ) { OK = true; break; } \\\n\t} \\\n\tif( !OK ) ++ ans; \\\n}\n\n\tfor( int x = 0; x <= X; x ++ ){\n\t\tCHECK(x,0);\n\t\tCHECK(x,Y);\n\t}\n\tfor( int y = 1; y < Y; y ++ ){\n\t\tCHECK(0,y);\n\t\tCHECK(X,y);\n\t}\n\tcout << ans << endl;\n\n}\n']","[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
Flowey has planted a bomb in Snowdin The bomb has a timer that is initially set to b Every second the timer will decrease by 1 When the timer reaches 0 the bomb will explode To give the residents of Snowdin enough time to evacuate you will need to delay the bomb from exploding for as long as possible You have n tools Each tool can only be used once If you use the i th tool the timer will increase by x i However if the timer is changed to an integer larger than a the timer will be set to a due to a bug More specifically the following events will happen every second in the following order You will choose some possibly none of your tools that have not been used before If you choose the i th tool and the bomb s timer is currently set to c the timer will be changed to min c x i a The timer decreases by 1 If the timer reaches 0 the bomb explodes Jellyfish now wants to know the maximum time in seconds until the bomb explodes if the tools are used optimally ,"[""#include<iostream>\nusing namespace std;\n#define ll long long\nvoid solve()\n{  \n    int a, n, x; ll b; cin >> a >> b >> n;\n    while (n--)cin >> x, b += min(a - 1, x);\n    cout << b << '\\n';\n}\nint main()\n{   \n    ios::sync_with_stdio(0); cin.tie(0);\n    int t = 1; cin >> t;\n    while (t--)solve();\n}""]","[1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",900
Utkarsh is forced to play yet another one of Ashish s games The game progresses turn by turn and as usual Ashish moves Consider the 2D plane There is a token which is initially at In one move a player must increase either the x coordinate or the y coordinate of the token by k In doing so the player must ensure that the token stays within a Euclidean distance d from 0 0 In other words if after a move the coordinates of the token are p q then p 2 q 2 leq d 2 must hold The game ends when a player is unable to make a move It can be shown that the game will end in a finite number of moves If both players play optimally determine who will win ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define unrequited_love ios_base::sync_with_stdio(0);cin.tie(0);\n\nvoid solve(vi a)\n{\n\tint n=a.size();\n\tsort(a.rbegin(), a.rend());\n\tint k = 1;\n\twhile (k + 1 <= n && a[k] >= k + 1) {\n\t\tk += 1;\n\t}\n\tint up = a[k - 1] - k;\n\tint right = 0;\n\twhile (k + right < n && a[k + right] == k) {\n\t\t++right;\n\t}\n\tcout << (up % 2 == 0 && right % 2 == 0 ? ""Ashish"" : ""Utkarsh"") << \'\\n\';\n}\n\nint main()\n{\n\tunrequited_love\n\tint t; cin>>t;\n\twhile(t--)\n\t{\n\t\tll d,k; cin>>d>>k;\n\t\tll bestr = (d*d)/(k*k);\n\t\tvi ans;\n\t\tll cur=0;\n\t\twhile(cur*cur<=bestr)\n\t\t{\n\t\t\tll rem = bestr-cur*cur;\n\t\t\tll ps = max(ll(floor(sqrt(double(rem))))-1,0LL);\n\t\t\twhile((ps+1)*(ps+1)<=rem) ps++;\n\t\t\t//cerr<<""CUR, PS = ""<<cur<<\' \'<<ps<<\'\\n\';\n\t\t\tans.pb(ps);\n\t\t\tcur++;\n\t\t}\n\t\t/*\n\t\tfor(int x:ans)\n\t\t{\n\t\t\tcout<<x<<\' \';\n\t\t}\n\t\tcout<<\'\\n\';\n\t\t*/\n\t\tsolve(ans);\n\t}\n}\n']","[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]",1700
The of a binary string is the number of texttt 1 s divided by the length of the string For example the of texttt 01101 is frac 3 5 Juju has a binary string s of length n She wants to choose some non intersecting subsegments of s such that their concatenation has length m and it has the same as the string s More specifically she wants to find two arrays l and r of equal length k such that 1 leq l 1 leq r 1 l 2 leq r 2 ldots l k leq r k leq n and also sum limits i 1 k r i l i 1 m The of s l 1 r 1 s l 2 r 2 ldots s l k r k is equal to the of s where s x y denotes the subsegment s x s x 1 ldots s y and denotes string concatenation Juju does not like splitting the string into many parts so she also wants to the value of k Find the minimum value of k such that there exist l and r that satisfy the constraints above or determine that it is impossible to find such l and r for any k ,"['#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long \nusing namespace std;\nint sum[500005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tstring s;\n\t\tcin >> s;\n\t\tint cnt1=0,cnt0=0;\n\t\tfor(auto t:s)\n\t\t\tcnt1+=t==\'1\',cnt0+=t==\'0\';\n\t\tcnt1*=m,cnt0*=m;\n\t\tif(cnt1%n||cnt0%n)\n\t\t{\n\t\t\tcout << ""-1\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\ts=\' \'+s+s;\n\t\tfor(int i=1;i<=n+n;i++)\n\t\t{\n\t\t\tif(s[i]==\'1\') sum[i]=cnt0;\n\t\t\telse sum[i]=-cnt1;\n\t\t}\n\t\tfor(int i=1;i<=n+n;i++)\n\t\t\tsum[i]+=sum[i-1];\n\t\tint pos=0;\n\t\tfor(int i=m;i<=n;i++)\n\t\t\tif(sum[i]==sum[i-m]) pos=i;\n\t\tif(pos)\n\t\t{\n\t\t\tcout << ""1\\n"";\n\t\t\tcout << pos-m+1 << "" "" << pos << ""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=n+1;i<=n+n;i++)\n\t\t\tif(sum[i]==sum[i-m]) pos=i;\n\t\tif(pos)\n\t\t{\n\t\t\tcout << ""2\\n"";\n\t\t\tint l=pos-m+1,r=pos;\n\t\t\tcout << 1 << "" "" << r-n << ""\\n"";\n\t\t\tcout << l << "" "" << n << ""\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\texit(1);\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",2700
Petya had a tree consisting of vertices numbered with integers from to Accidentally he lost his tree Petya remembers information about vertices distances from each of them to each of the tree vertices Your task is to restore any tree that satisfies the information that Petya remembers or report that such tree doesn t exist ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge {c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\nvector<pair<int,int>> output;\nconst int nax = 30123;\nvector<int> w_ans[nax];\nvoid add_edge(int a, int b) {\n\tdebug() << imie(a) imie(b);\n\tw_ans[a].push_back(b);\n\tw_ans[b].push_back(a);\n\toutput.push_back({a+1, b+1});\n}\n\nvoid NO() {\n\tputs(""-1"");\n\texit(0);\n}\n\nint n, k;\n\nvector<vector<int>> input;\nvector<int> where_zero;\n\nvoid rec(const vector<vector<int>> & tree, int which_line) {\n\t\n\tdebug() << ""rec"" imie(tree) imie(which_line);\n\t\n\tassert(!tree.empty());\n\tassert((int) tree[0].size() == 1);\n\tfor(const vector<int> & row : tree)\n\t\tif(row.empty())\n\t\t\tNO();\n\t\n\tif(which_line == k) {\n\t\tfor(int i = 1; i < (int) tree.size(); ++i)\n\t\t\tfor(int x : tree[i])\n\t\t\t\tadd_edge(tree[i-1][0], x);\n\t\treturn;\n\t}\n\t\n\tconst int spec = where_zero[which_line];\n\tint depth = -1;\n\t\n\tfor(int d = 0; d < (int) tree.size(); ++d)\n\t\tfor(int x : tree[d])\n\t\t\tif(x == spec)\n\t\t\t\tdepth = d;\n\t\n\tif(depth == -1) {\n\t\trec(tree, which_line + 1);\n\t\treturn;\n\t}\n\t\n\tvector<  vector<vector<int>> > new_trees;\n\t\n\tfor(int h = 0; h < (int) tree.size(); ++h)\n\t\tfor(int x : tree[h]) {\n\t\t\tint dist = input[which_line][x];\n\t\t\tint lca = h + depth - dist;\n\t\t\tif(lca % 2) NO();\n\t\t\tlca /= 2;\n\t\t\tdebug() << imie(lca);\n\t\t\tif(!(0 <= lca && lca < n)) NO();\n\t\t\t\n\t\t\tif((int) new_trees.size() <= lca)\n\t\t\t\tnew_trees.push_back({});\n\t\t\tif((int) new_trees.size() <= lca)\n\t\t\t\tNO();\n\t\t\t\n\t\t\tvector<vector<int>> & that_tree = new_trees[lca];\n\t\t\tint how = h - lca;\n\t\t\tif((int) that_tree.size() <= how)\n\t\t\t\tthat_tree.push_back({});\n\t\t\tif((int) that_tree.size() <= how)\n\t\t\t\tNO();\n\t\t\tthat_tree[how].push_back(x);\n\t\t}\n\t\n\tfor(const vector<vector<int>> & tr : new_trees)\n\t\tif(tr.empty() || tr[0].empty())\n\t\t\tNO();\n\t\n\tfor(int i = 1; i < (int) new_trees.size(); ++i) {\n\t\tadd_edge(new_trees[i][0][0], new_trees[i-1][0][0]);\n\t}\n\t\n\tfor(const auto & xx : new_trees)\n\t\trec(xx, which_line + 1);\n}\n\nvoid dfs(int a, int par, int so_far, const vector<int> & should) {\n\tdebug() << ""dfs"" imie(a) imie(par) imie(so_far) imie(should);\n\tif(so_far != should[a])\n\t\tNO();\n\tfor(int b : w_ans[a]) if(b != par)\n\t\tdfs(b, a, so_far + 1, should);\n}\n\nint main() {\n\tscanf(""%d%d"", &n, &k);\n\t\n\tinput.resize(k, vector<int>(n));\n\twhere_zero.resize(k);\n\t\n\tfor(int which = 0; which < k; ++which) {\n\t\tvector<int> & line = input[which];\n\t\tint zeros = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tscanf(""%d"", &line[i]);\n\t\t\tif(line[i] == 0) {\n\t\t\t\t++zeros;\n\t\t\t\twhere_zero[which] = i;\n\t\t\t}\n\t\t}\n\t\tif(zeros != 1) NO();\n\t}\n\t\n\tvector<vector<int>> tree;\n\tfor(int i = 0; i < n; ++i) {\n\t\tint v = input[0][i];\n\t\twhile((int) tree.size() <= v)\n\t\t\ttree.push_back({});\n\t\ttree[v].push_back(i);\n\t}\n\tdebug() << imie(tree);\n\trec(tree, 1);\n\t\n\tfor(int i = 0; i < k; ++i)\n\t\tdfs(where_zero[i], -1, 0, input[i]);\n\t\n\tfor(pair<int,int> p : output)\n\t\tprintf(""%d %d\\n"", p.first, p.second);\n}\n']","[1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]",2900
Once in found an array a consisting of positive integers Now he wants to reorder the elements of a to maximize the value of the following function sum i 1 n operatorname gcd a 1 a 2 dots a i where operatorname gcd x 1 x 2 ldots x k denotes the greatest common divisor of integers x 1 x 2 ldots x k and operatorname gcd x x for any integer x Reordering elements of an array means changing the order of elements in the array arbitrary or leaving the initial order Of course can solve this problem However he found it interesting so he decided to share it with you ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 2e7 + 7; bool nprm[_]; int prm[_ / 10] , cnt , num[_]; long long mx[_];\n\nint main(){\n\tios::sync_with_stdio(0);\n\tfor(int i = 2 ; i < _ ; ++i){\n\t\tif(!nprm[i]){prm[++cnt] = i;}\n\t\tfor(int j = 1;  prm[j] * i < _ ; ++j){nprm[prm[j] * i] = 1; if(i % prm[j] == 0) break;}\n\t}\n\tint N; cin >> N;\n\tfor(int i = 1 ; i <= N ; ++i){int v; cin >> v; ++num[v];}\n\tfor(int i = 1 ; i <= cnt ; ++i) for(int j = 2e7 / prm[i] + 1e-9 ; j >= 1 ; --j) num[j] += num[prm[i] * j];\n\tfor(int i = 2e7 ; i ; --i){\n\t\tmx[i] = 1ll * num[i] * i;\n\t\tfor(int j = 1 ; j <= cnt && prm[j] * i <= 2e7 ; ++j) mx[i] = max(mx[i] , mx[i * prm[j]] + 1ll * (num[i] - num[i * prm[j]]) * i);\n\t}\n\tcout << mx[1] << endl; return 0;\n}\n']","[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]",2100
A country has cities Initially there is no road in the country One day the king decides to construct some roads connecting pairs of cities Roads can be traversed either way He wants those roads to be constructed in such a way that it is possible to go from each city to any other city by traversing at most two roads You are also given pairs of cities roads cannot be constructed between these pairs of cities Your task is to construct the minimum number of roads that still satisfy the above conditions The constraints will guarantee that this is always possible ,"['#include <stdio.h>\n#define N 1002\n\nbool vis[N][N];\n\nint main() {\n//\tfreopen (""in.txt"", ""r"", stdin);\n\tint n, m;\n\tint i, j, k;\n\tscanf (""%d %d"", &n, &m);\n\twhile (m--) {\n\t\tscanf (""%d %d"", &i, &j);\n\t\tvis[i][j] = 1;\n\t\tvis[j][i] = 1;\n\t}\n\n\tfor (i=1; i<=n; i++) {\n\t\tfor (j=1; j<=n; j++) {\n\t\t\tif (vis[i][j]) break;\n\t\t}\n\t\tif (j > n) break;\n\t}\n\n\tprintf (""%d\\n"", n-1);\n\tfor (j=1; j<=n; j++) {\n\t\tif (j == i) continue;\n\t\tprintf (""%d %d\\n"", i, j);\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]",1300
