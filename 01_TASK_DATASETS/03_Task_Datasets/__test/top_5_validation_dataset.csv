problem_statement,problem_solution,tags,dificulty
You are given an array a consisting of n positive integers Let s call a concatenation of numbers x and y the number that is obtained by writing down numbers x and y one right after another without changing the order For example a concatenation of numbers 12 and 3456 is a number 123456 Count the number of ordered pairs of positions i j i neq j in array a such that the concatenation of a i and a j is divisible by k ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define INF 1000000005\n#define LINF 1000000000000000005\n#define MAXN 100005\n#define pi pair<int,int>\n#define pl pair<ll,ll>\n#define int ll\n\nint n,a[200005],k,c[200005],ans,b[200005];\n\nint cntc(int x){\n    int ans=0;\n    while(x) ans++,x/=10;\n    return ans;\n}\n\nmap <int,int> m;\n\nint op(int x){\n    x%=k;\n    if(x) return k-x;\n    else return 0;\n}\n\nint32_t main(){\n    ios_base :: sync_with_stdio(0);\n    cin >> n >> k;\n    for(int i=1;i<=n;i++){\n        cin >> a[i]; b[i]=a[i];\n        c[i]=cntc(a[i]);\n    }\n    for(int i=1;i<=10;i++){\n        m.clear();\n        for(int j=1;j<=n;j++) b[j]*=10,b[j]%=k,m[b[j]]++;\n        for(int j=1;j<=n;j++){\n            if(c[j]==i){\n                ans+=m[op(a[j])];\n                if(b[j]==op(a[j])) ans--;\n            }\n        }\n    }\n    cout << ans;\n}\n']","[1, 1, 0, 0, 0]",1900
Andryusha has found a perplexing arcade machine The machine is a vertically adjusted board divided into square cells The board has columns numbered from to from left to right and rows numbered from to from the bottom to the top Further there are barriers in some of board rows There are barriers in total and th of them occupied the cells through of the row Andryusha recollects well that no two barriers share the same row Furthermore no row is completely occupied with a barrier that is at least one cell in each row is free The player can throw a marble to any column of the machine from above A marble falls downwards until it encounters a barrier or falls through the bottom of the board A marble disappears once it encounters a barrier but is replaced by two more marbles immediately to the left and to the right of the same barrier In a situation when the barrier is at an edge of the board both marbles appear next to the barrier at the side opposite to the edge More than one marble can occupy the same place of the board without obstructing each other s movement Ultimately all marbles are bound to fall from the bottom of the machine Peculiarly sometimes marbles can go through barriers as if they were free cells That is so because the barriers are in fact alive and frightened when a marble was coming at them from a very high altitude More specifically if a marble falls towards the barrier from relative height more than that is it started its fall strictly higher than then the barrier evades the marble If a marble is thrown from the top of the board it is considered to appear at height Andryusha remembers to have thrown a marble once in each of the columns Help him find the total number of marbles that came down at the bottom of the machine Since the answer may be large print it modulo ,"['#pragma comment(linker, ""/STACK:1000000000"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <bitset>\n#include <memory>\n#include <cassert>\n#include <cstdlib>\n#include <cmath>\n#include <ctime> \n#include <stack>\n\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\n\nusing namespace std;\n\nconst int MAXN = 100001;\nconst int INF = 1000 * 1000 * 1000 + 2;\nconst int MODULE = 1000 * 1000 * 1000 + 7;\n\nstruct lane\n{\n\tint l, r, s, u;\n};\n\nstack <pair <int, int> > sc[MAXN];\nint top[MAXN];\nlane a[MAXN];\nint rid[MAXN];\n\n\n\nvoid er(int id)\n{\n\tsc[id].pop();\n\ttop[id] = sc[id].top().first;\n}\n\nbool cmp(lane l1, lane l2)\n{\n\treturn l1.s > l2.s;\n}\n\nint rmq[4 * MAXN];\n\ninline int bst(int i1, int i2)\n{\n\treturn (top[i1] < top[i2]) ? i1 : i2;\n}\n\nvoid create_rmq(int v, int l, int r)\n{\n\tif (l == r)\n\t{\n\t\trid[l] = v;\n\t\trmq[v] = l;\n\t\treturn;\n\t}\n\tcreate_rmq(v * 2 + 1, l, (l + r) / 2);\n\tcreate_rmq(v * 2 + 2, (l + r) / 2 + 1, r);\n\trmq[v] = bst(rmq[v * 2 + 1], rmq[v * 2 + 2]);\n}\n\nint lv, rv;\n\nint get_rmq(int v, int l, int r)\n{\n\tif ((lv > r) || (l > rv)) return 0;\n\tif ((lv <= l) && (r <= rv)) return rmq[v];\n\treturn bst(get_rmq(v * 2 + 1, l, (l + r) / 2), get_rmq(v * 2 + 2, (l + r) / 2 + 1, r));\n}\n\nvoid modify_rmq(int l)\n{\n\tint v = rid[l];\n\twhile (v != 0)\n\t{\n\t\tv = (v - 1) / 2;\n\t\trmq[v] = bst(rmq[v * 2 + 1], rmq[v * 2 + 2]);\n\t}\n}\n\nvoid psh(int id, int x, int y)\n{\n\tsc[id].push(mp(x, y));\n\ttop[id] = x;\n\tmodify_rmq(id);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n\tint h, w, n;\n\tcin >> h >> w >> n;\n\ttop[0] = 2 * INF + 4;\n\tfor (int i = 1; i <= w; i++)\n\t{\n\t\tpsh(i, 2 * INF + 3, 0);\n\t\tpsh(i, h + 1, 1);\n\t}\n\tcreate_rmq(0, 1, w);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i].s >> a[i].l >> a[i].r >> a[i].u;\n\t}\n\tsort(a, a + n, cmp);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tlv = a[i].l, rv = a[i].r;\n\t\tint y = a[i].s;\n\t\tint ly = a[i].s + a[i].u;\n\t\tint cur = 0;\n\t\twhile (true)\n\t\t{\n\t\t\tint v = get_rmq(0, 1, w);\n\t\t\tif (top[v] > ly) break;\n\t\t\tcur = (cur + sc[v].top().second) % MODULE;\n\t\t\ter(v);\n\t\t\tmodify_rmq(v);\n\t\t}\n\t\tif (lv == 1)\n\t\t\tpsh(rv + 1, y, (cur * 2) % MODULE);\n\t\telse if (rv == w) psh(lv - 1, y, (cur * 2) % MODULE);\n\t\telse psh(lv - 1, y, cur), psh(rv + 1, y, cur);\n\t}\n\tint ans = 0;\n\tfor (int i = 1; i <= w; i++)\n\t{\n\t\twhile (!sc[i].empty())\n\t\t{\n\t\t\tans += sc[i].top().second;\n\t\t\tans %= MODULE;\n\t\t\tsc[i].pop();\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}']","[0, 0, 0, 1, 0]",2700
