problem_statement,problem_solution,tags,dificulty
You are responsible for installing a gas pipeline along a road Let s consider the road for simplicity as a segment 0 n on OX axis The road can have several crossroads but for simplicity we ll denote each crossroad as an interval x x 1 with integer x So we can represent the road as a binary string consisting of n characters where character means that current interval doesn t contain a crossroad and means that there is a crossroad Usually we can install the pipeline along the road on height of 1 unit with supporting pillars in each integer point so if we are responsible for 0 n road we must install n 1 pillars But on crossroads we should lift the pipeline up to the height 2 so the pipeline won t obstruct the way for cars We can do so inserting several zig zag like lines Each zig zag can be represented as a segment x x 1 with integer x consisting of three parts 0 5 units of horizontal pipe 1 unit of vertical pipe 0 5 of horizontal Note that if pipeline is currently on height 2 the pillars that support it should also have length equal to 2 units Each unit of gas pipeline costs us a bourles and each unit of pillar b bourles So it s not always optimal to make the whole pipeline on the height 2 Find the shape of the pipeline with minimum possible cost and calculate that cost Note that you start and finish the pipeline on height 1 and also it s guaranteed that the first and last characters of the input string are equal to ,"['#include <bits/stdc++.h>\nusing namespace std;\nchar s[200010];\ntypedef long long ll;\nint a, b, n;\nll dp[200010][2];\nint main() {\n    int t;\n    scanf(""%d"", &t);\n    while(t--) {\n        scanf(""%d%d%d"", &n, &a, &b);\n        scanf(""%s"", s);\n        dp[0][0] = b, dp[0][1] = 1e15;\n        for(int i = 0; i < n; i++) {\n            if(s[i] == \'0\') {\n                dp[i + 1][0] = min(dp[i][0] + a, dp[i][1] + a + a) + b;\n                dp[i + 1][1] = min(dp[i][1] + a, dp[i][0] + a + a) + b + b;\n            }\n            else {\n                dp[i + 1][0] = 1e15;\n                dp[i + 1][1] = dp[i][1] + b + b + a;\n            }\n        }\n        printf(""%I64d\\n"", dp[n][0]);\n    }\n}']","[0, 0, 1, 0, 1]",1500
The outskirts of the capital are being actively built up in Berland The company Kernel Panic manages the construction of a residential complex of skyscrapers in New Berlskva All skyscrapers are built along the highway It is known that the company has already bought n plots along the highway and is preparing to build n skyscrapers one skyscraper per plot Architects must consider several requirements when planning a skyscraper Firstly since the land on each plot has different properties each skyscraper has a limit on the largest number of floors it can have Secondly according to the design code of the city it is unacceptable for a skyscraper to simultaneously have higher skyscrapers both to the left and to the right of it Formally let s number the plots from 1 to n Then if the skyscraper on the i th plot has a i floors it must hold that a i is at most m i 1 le a i le m i Also there mustn t be integers j and k such that j i k and a j a i a k Plots j and k are required to be adjacent to i The company wants the total number of floors in the built skyscrapers to be as large as possible Help it to choose the number of floors for each skyscraper in an optimal way i e in such a way that all requirements are fulfilled and among all such construction plans choose any plan with the maximum possible total number of floors ,"['#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch==\'-\',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-\'0\',ch=getchar();\n\treturn f?x:-x;\n}\nint h[500010];\nll L[500010],R[500010];\nint stk[500010],tot[500010];ll sum;\nint main(){\n#ifdef LOCAL\n\tfreopen(""in.in"",""r"",stdin);\n\t//freopen(""out.out"",""w"",stdout);\n#endif\n\tint n=gi();\n\tfor(int i=1;i<=n;++i)h[i]=gi();\n\tint tp=0;\n\tfor(int i=1;i<=n;++i){\n\t\tint TOT=1;\n\t\twhile(tp&&stk[tp]>h[i])TOT+=tot[tp],sum-=1ll*tot[tp]*stk[tp],--tp;\n\t\tstk[++tp]=h[i],tot[tp]=TOT,sum+=1ll*h[i]*TOT;\n\t\tL[i]=sum;\n\t}\n\ttp=0;\n\tsum=0;\n\tfor(int i=n;i;--i){\n\t\tint TOT=1;\n\t\twhile(tp&&stk[tp]>h[i])TOT+=tot[tp],sum-=1ll*tot[tp]*stk[tp],--tp;\n\t\tstk[++tp]=h[i],tot[tp]=TOT,sum+=1ll*h[i]*TOT;\n\t\tR[i]=sum;\n\t}\n\tll mx=0,p=0;\n\tfor(int i=1;i<=n;++i)if(L[i]+R[i]-h[i]>mx)mx=L[i]+R[i]-h[i],p=i;\n\tfor(int i=p-1;i;--i)h[i]=std::min(h[i],h[i+1]);\n\tfor(int i=p+1;i<=n;++i)h[i]=std::min(h[i],h[i-1]);\n\tfor(int i=1;i<=n;++i)printf(""%d "",h[i]);puts("""");\n\treturn 0;\n}\n']","[0, 0, 1, 1, 1]",1900
