problem_statement,problem_solution,problem_tags,problem_dificulty,problem_editorial
We all steal a little bit But I have only one hand while my adversaries have two lvaro Obreg n lvaro and Jos are the only candidates running for the presidency of Tepito a rectangular grid of 2 rows and n columns where each cell represents a house It is guaranteed that n is a multiple of 3 Under the voting system of Tepito the grid will be split into districts which consist of any 3 houses that are connected text Each house will belong to exactly one district Each district will cast a single vote The district will vote for lvaro or Jos respectively if at least 2 houses in that district select them Therefore a total of frac 2n 3 votes will be cast As lvaro is the current president he knows exactly which candidate each house will select If lvaro divides the houses into districts optimally determine the maximum number of votes he can get text A set of cells is connected if there is a path between any 2 cells that requires moving only up down left and right through cells in the set ,"['#line 1 ""library/Template/template.hpp""#include <bits/stdc++.h>using namespace std;\xa0#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); i++)#define rrep(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)#define ALL(v) (v).begin(), (v).end()#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())#define SZ(v) (int)v.size()#define MIN(v) *min_element(ALL(v))#define MAX(v) *max_element(ALL(v))#define LB(v, x) int(lower_bound(ALL(v), (x)) - (v).begin())#define UB(v, x) int(upper_bound(ALL(v), (x)) - (v).begin())\xa0using uint = unsigned int;using ll = long long int;using ull = unsigned long long;using i128 = __int128_t;using u128 = __uint128_t;const int inf = 0x3fffffff;const ll INF = 0x1fffffffffffffff;\xa0template <typename T> inline bool chmax(T &a, T b) {    if (a < b) {        a = b;        return 1;    }    return 0;}template <typename T> inline bool chmin(T &a, T b) {    if (a > b) {        a = b;        return 1;    }    return 0;}template <typename T, typename U> T ceil(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? (x + y - 1) / y : x / y);}template <typename T, typename U> T floor(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? x / y : (x - y + 1) / y);}template <typename T> int popcnt(T x) {    return __builtin_popcountll(x);}template <typename T> int topbit(T x) {    return (x == 0 ? -1 : 63 - __builtin_clzll(x));}template <typename T> int lowbit(T x) {    return (x == 0 ? -1 : __builtin_ctzll(x));}\xa0template <class T, class U>ostream &operator<<(ostream &os, const pair<T, U> &p) {    os << ""P("" << p.first << "", "" << p.second << "")"";    return os;}template <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {    os << ""{"";    for (int i = 0; i < vec.size(); i++) {        os << vec[i] << (i + 1 == vec.size() ? """" : "", "");    }    os << ""}"";    return os;}template <typename T, typename U>ostream &operator<<(ostream &os, const map<T, U> &map_var) {    os << ""{"";    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {        os << ""("" << itr->first << "", "" << itr->second << "")"";        itr++;        if (itr != map_var.end())            os << "", "";        itr--;    }    os << ""}"";    return os;}template <typename T> ostream &operator<<(ostream &os, const set<T> &set_var) {    os << ""{"";    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {        os << *itr;        ++itr;        if (itr != set_var.end())            os << "", "";        itr--;    }    os << ""}"";    return os;}#ifdef LOCAL#define show(...) _show(0, #__VA_ARGS__, __VA_ARGS__)#else#define show(...) true#endiftemplate <typename T> void _show(int i, T name) {    cerr << \'\\n\';}template <typename T1, typename T2, typename... T3>void _show(int i, const T1 &a, const T2 &b, const T3 &...c) {    for (; a[i] != \',\' && a[i] != \'\\0\'; i++)        cerr << a[i];    cerr << "":"" << b << "" "";    _show(i + 1, a, c...);}#line 2 ""library/Utility/fastio.hpp""#include <unistd.h>namespace fastio {static constexpr uint32_t SZ = 1 << 17;char ibuf[SZ];char obuf[SZ];char out[100];// pointer of ibuf, obuf\xa0uint32_t pil = 0, pir = 0, por = 0;\xa0struct Pre {    char num[10000][4];    constexpr Pre() : num() {        for (int i = 0; i < 10000; i++) {            int n = i;            for (int j = 3; j >= 0; j--) {                num[i][j] = n % 10 | \'0\';                n /= 10;            }        }    }} constexpr pre;\xa0inline void load() {    memmove(ibuf, ibuf + pil, pir - pil);    pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);    pil = 0;    if (pir < SZ)        ibuf[pir++] = \'\\n\';}\xa0inline void flush() {    fwrite(obuf, 1, por, stdout);    por = 0;}\xa0void rd(char &c) {    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));}\xa0void rd(string &x) {    x.clear();    char c;    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));    do {        x += c;        if (pil == pir)            load();        c = ibuf[pil++];    } while (!isspace(c));}\xa0template <typename T> void rd_real(T &x) {    string s;    rd(s);    x = stod(s);}\xa0template <typename T> void rd_integer(T &x) {    if (pil + 100 > pir)        load();    char c;    do        c = ibuf[pil++];    while (c < \'-\');    bool minus = 0;    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (c == \'-\') {            minus = 1, c = ibuf[pil++];        }    }    x = 0;    while (\'0\' <= c) {        x = x * 10 + (c & 15), c = ibuf[pil++];    }    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (minus)            x = -x;    }}\xa0void rd(int &x) {    rd_integer(x);}void rd(ll &x) {    rd_integer(x);}void rd(i128 &x) {    rd_integer(x);}void rd(uint &x) {    rd_integer(x);}void rd(ull &x) {    rd_integer(x);}void rd(u128 &x) {    rd_integer(x);}void rd(double &x) {    rd_real(x);}void rd(long double &x) {    rd_real(x);}\xa0template <class T, class U> void rd(pair<T, U> &p) {    return rd(p.first), rd(p.second);}template <size_t N = 0, typename T> void rd_tuple(T &t) {    if constexpr (N < std::tuple_size<T>::value) {        auto &x = std::get<N>(t);        rd(x);        rd_tuple<N + 1>(t);    }}template <class... T> void rd(tuple<T...> &tpl) {    rd_tuple(tpl);}\xa0template <size_t N = 0, typename T> void rd(array<T, N> &x) {    for (auto &d : x)        rd(d);}template <class T> void rd(vector<T> &x) {    for (auto &d : x)        rd(d);}\xa0void read() {}template <class H, class... T> void read(H &h, T &...t) {    rd(h), read(t...);}\xa0void wt(const char c) {    if (por == SZ)        flush();    obuf[por++] = c;}void wt(const string s) {    for (char c : s)        wt(c);}void wt(const char *s) {    size_t len = strlen(s);    for (size_t i = 0; i < len; i++)        wt(s[i]);}\xa0template <typename T> void wt_integer(T x) {    if (por > SZ - 100)        flush();    if (x < 0) {        obuf[por++] = \'-\', x = -x;    }    int outi;    for (outi = 96; x >= 10000; outi -= 4) {        memcpy(out + outi, pre.num[x % 10000], 4);        x /= 10000;    }    if (x >= 1000) {        memcpy(obuf + por, pre.num[x], 4);        por += 4;    } else if (x >= 100) {        memcpy(obuf + por, pre.num[x] + 1, 3);        por += 3;    } else if (x >= 10) {        int q = (x * 103) >> 10;        obuf[por] = q | \'0\';        obuf[por + 1] = (x - q * 10) | \'0\';        por += 2;    } else        obuf[por++] = x | \'0\';    memcpy(obuf + por, out + outi + 4, 96 - outi);    por += 96 - outi;}\xa0template <typename T> void wt_real(T x) {    ostringstream oss;    oss << fixed << setprecision(15) << double(x);    string s = oss.str();    wt(s);}\xa0void wt(int x) {    wt_integer(x);}void wt(ll x) {    wt_integer(x);}void wt(i128 x) {    wt_integer(x);}void wt(uint x) {    wt_integer(x);}void wt(ull x) {    wt_integer(x);}void wt(u128 x) {    wt_integer(x);}void wt(double x) {    wt_real(x);}void wt(long double x) {    wt_real(x);}\xa0template <class T, class U> void wt(const pair<T, U> val) {    wt(val.first);    wt(\' \');    wt(val.second);}template <size_t N = 0, typename T> void wt_tuple(const T t) {    if constexpr (N < std::tuple_size<T>::value) {        if constexpr (N > 0) {            wt(\' \');        }        const auto x = std::get<N>(t);        wt(x);        wt_tuple<N + 1>(t);    }}template <class... T> void wt(tuple<T...> tpl) {    wt_tuple(tpl);}template <class T, size_t S> void wt(const array<T, S> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(\' \');        wt(val[i]);    }}template <class T> void wt(const vector<T> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(\' \');        wt(val[i]);    }}\xa0void print() {    wt(\'\\n\');}template <class Head, class... Tail> void print(Head &&head, Tail &&...tail) {    wt(head);    if (sizeof...(Tail))        wt(\' \');    print(forward<Tail>(tail)...);}void __attribute__((destructor)) _d() {    flush();}} // namespace fastio\xa0using fastio::flush;using fastio::print;using fastio::read;\xa0inline void first(bool i = true) {    print(i ? ""first"" : ""second"");}inline void Alice(bool i = true) {    print(i ? ""Alice"" : ""Bob"");}inline void Takahashi(bool i = true) {    print(i ? ""Takahashi"" : ""Aoki"");}inline void yes(bool i = true) {    print(i ? ""yes"" : ""no"");}inline void Yes(bool i = true) {    print(i ? ""Yes"" : ""No"");}inline void No() {    print(""No"");}inline void YES(bool i = true) {    print(i ? ""YES"" : ""NO"");}inline void NO() {    print(""NO"");}inline void Yay(bool i = true) {    print(i ? ""Yay!"" : "":("");}inline void Possible(bool i = true) {    print(i ? ""Possible"" : ""Impossible"");}inline void POSSIBLE(bool i = true) {    print(i ? ""POSSIBLE"" : ""IMPOSSIBLE"");}\xa0/** * @brief Fast IO */#line 3 ""sol.cpp""\xa0void solve(int _rot) {    // write(""Case #""+to_string(_rot)+"": "");    int n;    read(n);    string S, T;    read(S, T);    auto ch = [&](char A, char B, char C) -> int {        int cnt = (A == \'A\') + (B == \'A\') + (C == \'A\');        return cnt >= 2;    };\xa0    vector dp(n + 1, vector<int>(5, -inf));    dp[0][0] = 0;    rep(i, 0, n) {        // 0        if (i + 2 < n) {            chmax(dp[i + 3][0], dp[i][0] + ch(S[i], S[i + 1], S[i + 2]) +                                    ch(T[i], T[i + 1], T[i + 2]));        }        if (i + 1 < n) {            chmax(dp[i + 1][1], dp[i][0] + ch(S[i], T[i], T[i + 1]));            chmax(dp[i + 1][2], dp[i][0] + ch(T[i], S[i], S[i + 1]));        }        // 1        if (i + 2 < n) {            chmax(dp[i + 1][4], dp[i][1] + ch(S[i], S[i + 1], S[i + 2]));        }        if (i + 1 < n) {            chmax(dp[i + 2][0], dp[i][1] + ch(S[i], S[i + 1], T[i + 1]));        }        // 2        if (i + 2 < n) {            chmax(dp[i + 1][3], dp[i][2] + ch(T[i], T[i + 1], T[i + 2]));        }        if (i + 1 < n) {            chmax(dp[i + 2][0], dp[i][2] + ch(T[i], T[i + 1], S[i + 1]));        }        // 3        if (i + 2 < n) {            chmax(dp[i + 2][2], dp[i][3] + ch(S[i], S[i + 1], S[i + 2]));        }        // 4        if (i + 2 < n) {            chmax(dp[i + 2][1], dp[i][4] + ch(T[i], T[i + 1], T[i + 2]));        }    }    int ret = MAX(dp[n]);    print(ret);}\xa0int main() {    int t;    read(t);    rep(rot, 0, t) solve(rot + 1);    return 0;}']","[0, 0, 1, 1, 0]",1800,Step 1We will use dynamic programming to keep track of the maximum number of votes lvaro can secure as we move from column to column note that there are many ways to implement the DP we will use the easiest to understand An important observation is that if you use a horizontal piece in one row you also have to use it in the other to avoid leaving holes 
The fox Yae climbed the of the Sacred Sakura A tree is a connected undirected graph that does not contain cycles The fox uses her magical powers to move around the tree Yae can jump from vertex v to another vertex u if and only if the distance between these vertices does not exceed 2 In other words in one jump Yae can jump from vertex v to vertex u if vertices v and u are connected by an edge or if there exists such vertex w that vertices v and w are connected by an edge and also vertices u and w are connected by an edge After Yae was able to get the sakura petal she wondered if there was a route in the tree v 1 v 2 ldots v n such that the fox can jump from vertex v i to vertex v i 1 the fox can jump from vertex v n to vertex v 1 all v i are pairwise distinct Help the fox determine if the required traversal exists ,"['#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(""Ofast,unroll-loops"")\n\n#define ll long long\n#define int ll\n#define ull unsigned ll\n#define ld long double\n#define rep(a) rep1(i,a)\n#define rep1(i,a) rep2(i,0,a)\n#define rep2(i,b,a) for(int i=(b); i<((int)(a)); i++)\n#define rep3(i,b,a) for(int i=(b); i>=((int)(a)); i--)\n#define chkmin(a,b) (a=min(a,b))\n#define chkmax(a,b) (a=max(a,b))\n#define all(a) a.begin(),a.end()\n#define pii pair<int,int>\n#define pb push_back\n#define eb emplace_back\n#define sort_unique(a) sort(all(a)),a.resize(unique(all(a))-a.begin())\n//#define inf 1010000000\n#define inf 4000000000000000000\n#define eps 1e-9\n#define sz(a) ((int)a.size())\n#define pow2(x) (1ll<<(x))\n#define ceiling(a,b) (((a)+(b)-1)/(b))\n#define print0(a) cout << (a) << \' \'\n#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\n#ifdef i_am_noob\n#define bug(...) cerr << ""#"" << __LINE__ << \' \' << #__VA_ARGS__ << ""- "", _do(__VA_ARGS__)\ntemplate<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}\ntemplate<typename T> void _do(set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}\ntemplate<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << \' \';cerr << ""\\n"";}\ntemplate<typename T> void _do(T && x) {cerr << x << endl;}\ntemplate<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << "", ""; _do(y...);}\n#else\n#define bug(...) 777771449\n#endif\ntemplate<typename T> void print(T && x) {cout << x << ""\\n"";}\ntemplate<typename T, typename... S> void print(T && x, S&&... y) {cout << x << \' \';print(y...);}\n\nconst int Mod=1000000007,Mod2=998244353;\nconst int MOD=Mod2;\ntemplate <int mod>\nstruct Modint{\n    int val;\n    Modint(int _val=0){val=_val%mod;if(val<0) val+=mod;}\n    Modint operator +(const Modint& o) const {\n        Modint res;\n        res.val=val+o.val;\n        if(res.val>=mod) res.val-=mod;\n        return res;\n    }\n    Modint operator +(const int& o) const {return Modint(val+o);}\n    Modint operator -() const {\n        Modint res;\n        res.val=-val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const Modint& o) const {\n        Modint res;\n        res.val=val-o.val;\n        if(res.val<0) res.val+=mod;\n        return res;\n    }\n    Modint operator -(const int& o) const {return Modint(val-o);}\n    Modint operator *(const Modint& o) const {return Modint(val*o.val);}\n    Modint operator *(const int& o) const {return Modint(val*(o%mod));}\n    Modint operator +=(const Modint& o){*this=(*this)+o;return *this;}\n    Modint operator -=(const Modint& o){*this=(*this)-o;return *this;}\n    Modint operator *=(const Modint& o){*this=(*this)*o;return *this;}\n    Modint Pow(int b) const {\n        Modint tmp(val),ret(1);\n        while(b){\n            if(b&1) ret*=tmp;\n            b>>=1;tmp*=tmp;\n        }\n        return ret;\n    }\n    Modint Pow(const Modint& a, int b) const {return a.Pow(b);}\n    inline Modint inv() const {return (*this).Pow(mod-2);}\n    Modint operator /(const Modint& o) const {return *this*o.inv();}\n    Modint operator /(const int& o) const {return *this*Modint(o).inv();}\n    bool operator ==(const Modint& o) const {return val==o.val;}\n};\ntemplate<int mod>\nostream& operator << (ostream& o, Modint<mod> x){return o << x.val;}\ntemplate<int mod>\nModint<mod> operator +(const int& x, const Modint<mod>& y){return Modint<mod>(x+y.val);}\ntemplate<int mod>\nModint<mod> operator -(const int& x, const Modint<mod>& y){return Modint<mod>(x-y.val);}\ntemplate<int mod>\nModint<mod> operator *(const int& x, const Modint<mod>& y){return Modint<mod>(x%mod*y.val);}\n#define modint Modint<MOD>\nvector<modint> inv,fac,invfac;\nvoid init_comb(int N){\n    inv.resize(N),fac.resize(N),invfac.resize(N);\n    inv[1]=1,fac[0]=1,invfac[0]=1;\n    rep2(i,2,N) inv[i]=inv[MOD%i]*(MOD-MOD/i);\n    rep2(i,1,N) fac[i]=fac[i-1]*i;\n    rep2(i,1,N) invfac[i]=invfac[i-1]*inv[i];\n}\ninline modint C(int n, int m){return m>n||m<0?modint(0):fac[n]*invfac[m]*invfac[n-m];}\ninline modint H(int n, int m){return C(n+m-1,n);}\n\nconst int maxn=200005,maxm=pow2(17),maxk=7777714;\n\n//i_am_noob\n//#define wiwihorz  \nvoid balbitorz(){}\nint n,dis[2][maxn],a[maxn];\nvector<int> adj[maxn],vec[maxn];\n\nvoid dfs(int u, int par, int t){\n    dis[t][u]=par==-1?0:dis[t][par]+1;\n    for(auto v: adj[u]) if(v!=par) dfs(v,u,t);\n}\n\nvoid orzck(){\n    cin >> n;\n    rep(n-1){\n        int u,v; cin >> u >> v; u--,v--;\n        adj[u].pb(v),adj[v].pb(u);\n    }\n    dfs(0,-1,0);\n    int p=max_element(dis[0],dis[0]+n)-dis[0];\n    dfs(p,-1,0);\n    int q=max_element(dis[0],dis[0]+n)-dis[0];\n    dfs(q,-1,1);\n    int d=dis[0][q];\n    rep(n){\n        assert(dis[0][i]+dis[1][i]-d>=0&&(dis[0][i]+dis[1][i]-d)%2==0);\n        if(dis[0][i]+dis[1][i]-d>2){\n            print(""No"");\n            return;\n        }\n        if(dis[0][i]+dis[1][i]-d==0){\n            a[dis[0][i]]=i;\n            for(auto j: adj[i]) if(dis[0][j]+dis[1][j]-d==2) vec[i].pb(j);\n        }\n    }\n    vector<int> res;\n    for(int i=0; i<d; i+=2){\n        res.pb(a[i]);\n        for(auto j: vec[a[i+1]]) res.pb(j);\n    }\n    int dd=d;\n    if(d%2==0){\n        dd--;\n        res.pb(a[d]);\n    }\n    for(int i=dd; i>=1; i-=2){\n        res.pb(a[i]);\n        for(auto j: vec[a[i-1]]) res.pb(j);\n    }\n    assert(sz(res)==n);\n    print(""Yes"");\n    for(auto i: res) print0(i+1);\n    cout << ""\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    // #ifdef i_am_noob\n    // freopen(""input1.txt"",""r"",stdin);\n    // freopen(""output1.txt"",""w"",stdout);\n    // freopen(""output2.txt"",""w"",stderr);\n    // #endif\n    cout << fixed << setprecision(15);\n    ld start=clock();\n    balbitorz();\n    int t;\n    #ifdef wiwihorz\n    cin >> t;\n    #else\n    t=1;\n    #endif\n    while(t--) orzck();\n    bug((clock()-start)/CLOCKS_PER_SEC);\n    return 0;\n}']","[0, 1, 1, 1, 0]",2400,Note that if the tree contains the subgraph shown below then there is no answer To prove this it is enough to consider all possible cases for how a cyclic route can pass through the upper vertex and understand that it is impossible to construct such route Let s assume that the tree does not contain the subgraph shown It is easy to see that in this case the tree can be represented as a path and vertices directly attached to it To check that the tree can be represented in this way we will find the diameter of the tree and check that all other vertices are directly connected to it Now we need to learn how to build a cyclic route Number the vertices of the diameter from to in the order of traversal of the diameter from one end to the other Now let s build the route as follows Firstly visit vertex then visit all vertices not on the diameter attached to vertex then move to vertex then to all vertices not on the diameter attached to vertex and so on When we reach the end of the diameter we will visit all vertices of the diameter with even numbers as well as all vertices of the tree not on the diameter attached to the vertices of the diameter with odd numbers Now let s make the same route in the opposite direction along the diameter but through vertices of a different parity which reaches vertex Time complexity 
Limak is an old brown bear He often goes bowling with his friends Today he feels really good and tries to beat his own record For rolling a ball one gets a score an integer maybe negative number of points Score for the th roll is multiplied by and scores are summed up So for rolls with scores the total score is The total score is if there were no rolls Limak made rolls and got score for the th of them He wants to maximize his total score and he came up with an interesting idea He can say that some first rolls were only a warm up and that he wasn t focused during the last rolls More formally he can cancel any prefix and any suffix of the sequence It is allowed to cancel all rolls or to cancel none of them The total score is calculated as if there were only non canceled rolls So the first non canceled roll has score multiplied by the second one has score multiplied by and so on till the last non canceled roll What maximum total score can Limak get ,"['# include <cstdio>\n# include <vector>\nusing namespace std;\nconst int MN = 2e5 + 44;\nlong long a[MN];\nvector <pair <int, long long> > hull;\nbool bad(pair <int, long long> x)\n{\n\tif (hull.size() < 2)\n\t\treturn false;\n\tpair <int, long long> y = hull.back();\n\tpair <int, long long> z = hull[hull.size() - 2];\n\treturn (x.second - y.second) * (z.first - y.first) < (z.second - y.second) * (x.first - y.first);\n}\nlong long eval(pair <int, long long> a, long long x, long long y)\n{\n// \tprintf(""return %I64d\\n"", a.first * x + a.second + y);\n\treturn a.first * x + a.second + y;\n}\nlong long sufsum[MN];\nlong long sufscores[MN];\nint main()\n{\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%I64d"", a + i);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufsum[i] = sufsum[i + 1] + a[i];\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufscores[i] = sufscores[i + 1] + sufsum[i];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tpair <int, long long> add = make_pair(i, sufscores[i]);\n// \t\tprintf(""add %d %I64d\\n"", add.first, add.second);\n\t\twhile (bad(add))\n\t\t\thull.pop_back();\n\t\thull.push_back(add);\n\t}\n// \tfor (auto x : hull)\n// \t\tprintf(""%d %I64d\\n"", x.first, x.second);\n\tlong long res = 0;\n\tlong long x = 0, y = 0;\n\tfor (int i = n - 1; i >= 0; --i)\n\t{\n// \t\tprintf(""i = %d x = %I64d y = %I64d\\n"", i, x, y);\n\t\tint low = 0, high = hull.size() - 1;\n\t\twhile (low < high - 3)\n\t\t{\n\t\t\tint med = (low + high) / 2;\n\t\t\tif (hull[med].first > i)\n\t\t\t\thigh = med - 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlong long val = eval(hull[med], x, y);\n// \t\t\t\tprintf(""include %d %I64d\\n"", hull[med].first, hull[med].second);\n\t\t\t\tres = max(res, val);\n\t\t\t\tif (eval(hull[med], x, y) > eval(hull[med + 1], x, y))\n\t\t\t\t\thigh = med;\n\t\t\t\telse\n\t\t\t\t\tlow = med;\n\t\t\t}\n\t\t}\n// \t\tprintf(""binsearch done\\n"");\n\t\tfor (int k = low; k <= high; ++k)\n\t\t\tif (hull[k].first <= i)\n\t\t\t{\n// \t\t\t\tprintf(""include %d %I64d\\n"", hull[k].first, hull[k].second);\n\t\t\t\tres = max(res, eval(hull[k], x, y));\n\t\t\t}\n\t\ty -= (i + 1) * a[i];\n\t\tx += a[i];\n\t}\n\tprintf(""%I64d\\n"", res);\n}']","[0, 0, 0, 0, 1]",2500,The problem was prepared by Kamil Debowski Errichto The problem analysis is also prepared by him The key is to use divide and conquer We need a recursive function f left right that runs f left mid and f mid 1 right where and also considers all intervals going through We will eventually need a convex hull of lines linear functions and let s see how to achieve it For variables we will try to write the score of interval as a linear function It would be good to get something close to where and depend on and depends on only For each we should find a linear function where should fit the equation Now we have a set of linear functions representing all possible left endpoints For each right endpoint we should find and to fit equation again With value of we can iterate over functions to find the one maximizing value of And still for fixed we should add to get the maximum possible score of interval ending in Brute Force with functions 
Little Elephant loves Furik and Rubik who he met in a small city Kremenchug The Little Elephant has two strings of equal length and consisting only of uppercase English letters The Little Elephant selects a pair of substrings of equal length the first one from string the second one from string The choice is equiprobable among all possible pairs Let s denote the substring of as and the substring of as The Little Elephant gives string to Furik and string to Rubik Let s assume that is the number of such positions of that where is the length of lines and and are the th characters of strings and correspondingly Help Furik and Rubik find the expected value of ,"['#pragma comment(linker, ""/STACK:65777216"")\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include<sstream>\n#include<string.h>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include<stack>\n#include <set>\n#include <map>\n#include<ctime>\n#include<list>\n\nusing namespace std;\n \ntypedef double ll;\ntypedef double ull;\n\ntypedef vector<int> vi;\t \ntypedef pair<int,int> pii;\ntypedef pair<double,double> pdd;\n\n\n#define FOR(i,a,b) for (int i(a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define SORT(v) sort((v).begin(),(v).end())\n#define UN(v) sort((v).begin(),(v).end()),v.erase(unique(v.begin(),v.end()),v.end())\n#define CL(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n\nchar a[222222];\nchar b[222222];\n\nvi v1[30];\nvi v2[30];\nint n;\nint u[222222];\nint now;\null same(vi v1,vi v2){\n\tull res = 0;\n\tnow++;\n\tREP(i,v1.size()) u[v1[i]]=now;\n\tREP(i,v2.size()) if(u[v2[i]]==now) res+=ull(v2[i]+1)*(n-v2[i]);\n\treturn res;\n}\n\null solve(vi v1,vi v2){\n\tull res = 0;\n\tull sum = 0;\n\tREP(i,v2.size()) sum += n - v2[i];\n\tint pos = 0;\n\tREP(i,v1.size()){\n\t\twhile(pos<v2.size() && v2[pos]<=v1[i]) sum -= (n - v2[pos]), pos++;\n\t\tres += sum * (v1[i] + 1);\n\t\t//cout<<""add ""<<sum<<""*""<<(v1[i]+1)<<endl;\n\t}\n\treturn res;\n}\n\nint main(){\n#ifdef LocalHost\n    freopen(""input.txt"",""r"",stdin);\n\t//freopen(""output.txt"",""w"",stdout);\n#endif\n\n\tcin>>n;\n//\tn=200000;\n\n\tscanf("" %s %s"",a,b);\n\t//REP(i,n) a[i]=b[i]=\'A\';\n\n\tREP(i,n) v1[a[i]-\'A\'].pb(i);\n\tREP(i,n) v2[b[i]-\'A\'].pb(i);\n\n\tll num = 0;\n\tFOR(i,1,n+1){\n\t\tll t = n-i+1;\n\t\tnum += t*t;\n\t}\n\tull c = 0;\n\n\tREP(i,30) if(v1[i].size() && v2[i].size()){\n\t\tc += solve(v1[i], v2[i]);\n\t\tc += solve(v2[i], v1[i]);\n\t\tc += same(v1[i], v2[i]);\n\t}\n\n\tprintf(""%.10lf\\n"",double(c)/num);\n//\tcout<<num<<endl;\n\t//cout<<c<<endl;\n\t//cout<<ll(1e18)<<endl;\n#ifdef LocalHost\n\tcerr<<endl<<endl<<""TIME: ""<<clock()<<endl;\n#endif\n    return 0;\n}']","[0, 1, 0, 0, 0]",2000,This problem is to find the expected value Important fact here is the linearity of the expected value This means that we can for each element of the first strings find the probability that exactly this element will me matched with some other but of course equal from the second string The answer will be the sum of all such probabilities Let the current character of the first string be the i th character 1 based numeration Firstly we try to solve problem in O N2 time Namely as it was said above we need to find the number of such pairs of substrings that i th character which is on probably some other position in substring is the same as the corresponding character of the second substring Iterate through all j j i such that Ai Bj The number of such pairs of substrings that have match in that characters is j n i 1 considering 1 based numeration This is O N2 And because we need to find the sum of such values for all possible j we can rewrite it as Si n i 1 where Si equals to the sum of all integers j j i that Ai Bi Array S can be simply computed in a linear time Analogically you should process all indices to the right from i After we know the number of pairs of substrings with the match with the i th character let it be count the probability is count total where total is the total number of pair of substrings it can be found by loop or with some simple formula 
Vivek has encountered a problem He has a maze that can be represented as an n times m grid Each of the grid cells may represent the following Empty Wall Good person Bad person The only escape from the maze is at cell n m A person can move to a cell only if it shares a side with their current cell and does not contain a wall Vivek wants to block some of the empty cells by replacing them with walls in such a way that all the good people are able to escape while none of the bad people are able to A cell that initially contains or and Help him determine if there exists a way to replace some zero or more empty cells with walls to satisfy the above conditions Vivek can also block this cell ,"['#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint getTile(){\n\tchar c;\n\tfor(;;){\n\t\tc=getchar();\n\t\tif(c==\'.\')return 0;\n\t\tif(c==\'#\')return 1;\n\t\tif(c==\'G\')return 2;\n\t\tif(c==\'B\')return 3;\n\t}\n}\nconst int movex[]={1, -1, 0, 0};\nconst int movey[]={0, 0, 1, -1};\nvector <int> p;\nvoid par(int x){\n\tif(p[x]==x)return;\n\tpar(p[x]);\n\tp[x]=p[p[x]];\n}\nint main(){\n\tint t=1;\n\tscanf(""%d"" ,&t);\n\twhile(t--){\n\t\tint n, m;\n\t\tscanf(""%d%d"", &n, &m);\n\t\tvector <vector <int> > b(n, vector <int> (m));\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tb[i][j]=getTile();\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tif(b[i][j]==3){\n\t\t\t\t\tfor(int k = 0;k < 4;k ++){\n\t\t\t\t\t\tif(i+movex[k]==n||i+movex[k]==-1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(j+movey[k]==m||j+movey[k]==-1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif(b[i+movex[k]][j+movey[k]]==0){\n\t\t\t\t\t\t\tb[i+movex[k]][j+movey[k]]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp.resize(n*m);\n\t\tfor(int i = 0;i < n*m;i ++){\n\t\t\tp[i]=i;\n\t\t}\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m-1;j ++){\n\t\t\t\tif(b[i][j]!=1&&b[i][j+1]!=1){\n\t\t\t\t\tint x=i*m+j, y=i*m+j+1;\n\t\t\t\t\tpar(x), par(y);\n\t\t\t\t\tif(p[x]!=p[y]){\n\t\t\t\t\t\tp[p[x]]=p[y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n-1;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tif(b[i+1][j]!=1&&b[i][j]!=1){\n\t\t\t\t\tint x=i*m+j+m, y=i*m+j;\n\t\t\t\t\tpar(x), par(y);\n\t\t\t\t\tif(p[x]!=p[y]){\n\t\t\t\t\t\tp[p[x]]=p[y];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool good=true;\n\t\tbool bad=false;\n\t\tint y=n*m-1;\n\t\tfor(int i = 0;i < n;i ++){\n\t\t\tfor(int j = 0;j < m;j ++){\n\t\t\t\tif(b[i][j]==2){\n\t\t\t\t\tint x=i*m+j;\n\t\t\t\t\tpar(x), par(y);\n\t\t\t\t\tif(p[x]!=p[y]){\n\t\t\t\t\t\tgood=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(b[i][j]==3){\n\t\t\t\t\tint x=i*m+j;\n\t\t\t\t\tpar(x), par(y);\n\t\t\t\t\tif(p[x]==p[y]){\n\t\t\t\t\t\tbad=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!good){\n\t\t\tprintf(""No\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tif(bad){\n\t\t\tprintf(""No\\n"");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(""Yes\\n"");\n\t}\n}']","[1, 0, 1, 0, 0]",1700,We can block all empty neighbouring cells of bad people and then check if all good people can escape and no bad people are able to escape Consider all the neighbouring cells of bad people There shouldn t be any path from these cells to the cell If there is a path from any such cell the bad person adjacent to that cell can also then reach the cell So if any good and bad people are in adjacent cells the answer is Based on this idea we can block any empty cell neighbouring a bad person Suppose there is another solution in which a cell neighbouring a bad person does not need to be blocked There still won t be any path from to in that solution So we can block in that solution too without affecting the solution itself It is sufficient to block only the empty neighbouring cells of bad people and check the required conditions which can be done using a bfs on the grid Proof We will assume there are no adjacent good and bad people since in that case the answer is There are three cases A bad person is adjacent to the cell In this case the cell must be blocked Now no one will be able to escape If there is at least one good person present the answer is If after blocking the neighbouring cells of bad people there is some good person who is not able to escape then the answer is again Otherwise the answer is always Suppose there is some path from a bad person at cell to the cell One of the neighbours of this person must be another bad person since the only other case is an adjacent good person which is already covered above Extending this all the cells on the path from to must have bad people This is not possible since in this case there must be a bad person adjacent to and this case is already covered above Time complexity 
Given an array a of length n you can do at most k operations of the following type on it choose 2 different elements in the array add 1 to the first and subtract 1 from the second However all the elements of a have to remain non negative after this operation What is lexicographically the smallest array you can obtain An array x is lexicographically smaller than an array y if there exists an index i such that x i y i and x j y j for all 1 le j i Less formally at the first index i in which they differ x i y i ,"['#include<bits/stdc++.h>\n#define re register\nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint n,k,a[102],pos;\nint main(){\n\tint t=read();\n\twhile(t--){\n\t\tn=read(),k=read();\n\t\tfor(re int i=1;i<=n;++i)a[i]=read();\n\t\tpos=1;\n\t\twhile(k--){\n\t\t\twhile(pos<=n&&(!a[pos]))++pos;\n\t\t\tif(pos>n)break;\n\t\t\t--a[pos],++a[n];\n\t\t}\n\t\tfor(re int i=1;i<=n;++i)printf(""%d "",a[i]);\n\t\tputs("""");\n\t}\n}\n']","[1, 0, 0, 0, 0]",800,The general approach to minimizing an array lexicographically is to try to make the first element as small as possible then the second element and so on So greedily in each operation we ll pick the first non zero element and subtract from it and we ll add that to the very last element You can make the implementation faster by doing as many operations as you can on the first non zero element simultaneously but it s not necessary Code link https pastebin com pBsychs2 
You are given an integer n You have to apply m operations to it In a single operation you replace every digit d of the number with the decimal representation of integer d 1 For example 1912 becomes 21023 after applying the operation once You have to find the length of n after applying m operations Since the answer can be very large print it modulo 10 9 7 ,"['#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\nusing namespace std;\nconst int N = 200010;\nconst int M = 200010;\nconst int mod = 1e9 + 7;\n\nint a[M][10];\nvoid prec() {\n    for (int i = 0; i < 9; ++i) a[1][i] = 1;\n    a[1][9] = 2;\n    for (int i = 2; i < M; ++i) {\n        for (int j = 0; j < 9; ++j) a[i][j] = a[i - 1][j + 1];\n        a[i][9] = (a[i - 1][1] + a[i - 1][0]) % mod;\n    }\n}\n\nvoid solve() {\n    int n, m;\n    scanf(""%d%d"", &n, &m);\n    string s = to_string(n);\n    int ans = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        ans = (ans + a[m][s[i] - \'0\']) % mod;\n    }\n    printf(""%d\\n"", ans);\n}\n\nint main() {\n#ifdef FLOWMASTER\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n    prec();\n    int t;\n    scanf(""%d"", &t);\n    for (int i = 0; i < t; ++i) solve();\n    return 0;\n}\n']","[0, 0, 0, 1, 0]",1600,We can solve this problem using 1D dp Let be defined as the length of the string after applying operation times to the number Then in if The final number after applying operations to the number is Otherwise length would be the sum of operations and operations We can precalculate the above table until Now for each test case the final answer is where is in form of string Time Complexity O where 
You are given two distinct non negative integers x and y Consider two infinite sequences a 1 a 2 a 3 ldots and b 1 b 2 b 3 ldots where a n n oplus x b n n oplus y Here x oplus y denotes the bitwise XOR operation of integers x and y For example with x 6 the first 8 elements of sequence a will look as follows 7 4 5 2 3 0 1 14 ldots Note that the indices of elements start with 1 Your task is to find the length of the longest common subsegment dagger of sequences a and b In other words find the maximum integer m such that a i b j a i 1 b j 1 ldots a i m 1 b j m 1 for some i j ge 1 daggerA subsegment of sequence p is a sequence p l p l 1 ldots p r where 1 le l le r ,"['#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));int main(){\tios::sync_with_stdio(false);\t// freopen(""Otomachi_Una.in"",""r"",stdin);\t// freopen(""Otomachi_Una.out"",""w"",stdout);\tint _;cin>>_;\twhile(_--){\t\tint x,y;cin>>x>>y;\t\tx^=y;\t\tcout<<(x&-x)<<\'\\n\';\t}\treturn 0;}']","[1, 0, 0, 0, 0]",1000,SolutionConsider two numbers and such that Then consider the numbers and Let s look at the last bit of and Possible scenarios Both bits are equal to adding one will change the bits at the same positions therefore Both bits are equal to adding one will change the bits at the same positions and also add one to the next bit therefore we can similarly consider the next bit Bits are different adding one to the zero bit will only change one bit while the subsequent bit of the other number will be changed This means that It is clear that we need to maximize the number of zeros in the maximum matching suffix of and Obviously this number is equal to the maximum matching suffix of and Let be the length of the maximum matching suffix of and then the answer is This can be calculated in time for one test case where is the limit on and 
Petya and Gena love playing table tennis A single match is played according to the following rules a match consists of multiple sets each set consists of multiple serves Each serve is won by one of the players this player scores one point As soon as one of the players scores points he wins the set then the next set starts and scores of both players are being set to 0 As soon as one of the players wins the total of sets he wins the match and the match is over Here and are some positive integer numbers To spice it up Petya and Gena choose new numbers and before every match Besides for the sake of history they keep a record of each match that is for each serve they write down the winner Serve winners are recorded in the chronological order In a record the set is over as soon as one of the players scores points and the match is over as soon as one of the players wins sets Petya and Gena have found a record of an old match Unfortunately the sequence of serves in the record isn t divided into sets and numbers and for the given match are also lost The players now wonder what values of and might be Can you determine all the possible options ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n#endif\n\n#define forn(i,n) for (int i = 0; i < int(n); ++i)\n#define ford(i,n) for (int i = int(n) - 1; i >= 0; --i)\n#define forv(i,v) for (auto i = v.begin(); i != v.end(); ++i)\n#define forr(i,v) for (auto i = v.end(); i != v.begin() && (--i, 1); )\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned char uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\nconst ld pi = 3.1415926535897932384626433832795l;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T> inline T abs (T x) {return x > T() ? x : -x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 100000;\n\nstruct Input {\n\tint n;\n\tint a[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(""%d"", &a[i]);\n\t\t\t--a[i];\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tve<pii> ans;\n\t\n\tvoid write () {\n\t\tcout << sz(ans) << endl;\n\t\tforn (i, sz(ans)) {\n\t\t\tprintf(""%d %d\\n"", ans[i].fs, ans[i].sc);\n\t\t}\n\t}\n\t\n\tvirtual void solve () {}\n\t\n\tvirtual void clear () {\n\t\t*this = Data();\n\t}\n};\n\nstruct Solution: Data {\n\tint s0[N + 1], s1[N + 1];\n\tint p0[N], p1[N];\n\tint cnt0, cnt1;\n\t\n\tvoid solve () {\n\t\tcnt0 = cnt1 = 0;\n\t\ts0[0] = s1[0] = 0;\n\t\tforn (i, n) {\n\t\t\ts0[i + 1] = s0[i] + (a[i] == 0);\n\t\t\ts1[i + 1] = s1[i] + (a[i] == 1);\n\t\t\tif (a[i] == 0) {\n\t\t\t\tp0[cnt0++] = i;\n\t\t\t} else {\n\t\t\t\tp1[cnt1++] = i;\n\t\t\t}\n\t\t}\n\t\tfor (int k = 1; k <= n; ++k) {\n\t\t\tint t0 = 0, t1 = 0;\n\t\t\tint i = 0;\n\t\t\tbool ok = 1;\n\t\t\tint lst = 0;\n\t\t\twhile (i < n) {\n\t\t\t\tint j0 = (s0[i] + k > cnt0) ? n + 1 : p0[s0[i] + k - 1] + 1;\n\t\t\t\tint j1 = (s1[i] + k > cnt1) ? n + 1 : p1[s1[i] + k - 1] + 1;\n\t\t\t\tif (min(j0, j1) > n) {\n\t\t\t\t\tok = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (j0 < j1) {\n\t\t\t\t\ti = j0;\n\t\t\t\t\tt0++;\n\t\t\t\t\tlst = 0;\n\t\t\t\t} else {\n\t\t\t\t\ti = j1;\n\t\t\t\t\tt1++;\n\t\t\t\t\tlst = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t0 == t1 || ((t0 < t1) ^ lst)) {\n\t\t\t\tok = 0;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tans.pb(mp(max(t0, t1), k));\n\t\t\t}\n\t\t}\n\t\tsort(all(ans));\n\t}\n\t\n\tvoid clear () {\n\t\t*this = Solution();\n\t}\n};\n\nSolution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n#ifdef SG\n\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\twhile (sol.read()) {\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n#else\n\tsol.read();\n\tsol.solve();\n\tsol.write();\n#endif\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0]",1900,Choose some now emulate how the match will go ensure that the record is valid for this and by the way find the corresponding value of Print all valid options for and This solution works in time which is not good enough but we will try to optimize it Suppose the current set if finished and we have processed serves by now Let us process the next set as follows find th and th after position If th occurs earlier then the first player wins the set and the set concludes right after the th the other case is handled symmetrically If the match is not over yet and in the rest of the record there are no ones nor twos then the record is clearly invalid This way every single set in the record can be processed in time using binary search or time using precomputed arrays of positions for each player Now observe that for any a match of serves can not contain more than sets as each set contains at least serves If we sum up the upper limits for the number of sets for each we obtain the total upper limit for the number of sets we may need to process which is the famous harmonic sum Using one of the approaches discussed above one obtains a solution with complexity of or each of these solutions fits the limit nicely Obviously for every there is no more than one valid choice for however maybe a bit unexpected for a given there may exist more than one valid choice of The first test where this takes place is pretest 12 The statement requires that the pairs are printed lexicographically ordered it is possible to make a mistake here and print the pairs with equal by descending if we fill the array by increasing and then simply reverse the array Challenge while preparing this problem I discovered that it s quite hard to find a test such that the number of pairs in the answer is large in the actual tests the maximal number is 128 which is the number of divisors of the number 83160 Can you beat this record If you have a test with that has larger number of pairs in the answer feel free to brag in the comments also don t hesitate to share any insights on how one could bound the maximal number analytically 
Monocarp has n numbers 1 2 dots n and a set initially empty He adds his numbers to this set n times in some order During each step he adds a new number which has not been present in the set before In other words the sequence of added numbers is a permutation of length n Every time Monocarp adds an element into the set he writes out a character if the element Monocarp is trying to insert becomes the maximum element in the set Monocarp writes out the character if the element Monocarp is trying to insert becomes the minimum element in the set Monocarp writes out the character if none of the above Monocarp writes out the character You are given a string s of n 1 characters which represents the characters written out by Monocarp in the order he wrote them out You have to process m queries to the string Each query has the following format i c replace s i with the character c Both before processing the queries and after each query you have to calculate the number of different ways to order the integers 1 2 3 dots n such that if Monocarp inserts the integers into the set in that order he gets the string s Since the answers might be large print them modulo 998244353 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        m = std::min(m, Z::getMod() - 1);\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    n--;\n    \n    Z ans = 1;\n    std::string s;\n    std::cin >> s;\n    \n    for (int i = 1; i < n; i++) {\n        if (s[i] == \'?\') {\n            ans *= i;\n        }\n    }\n    \n    auto query = [&]() {\n        if (s[0] == \'?\') {\n            std::cout << 0 << ""\\n"";\n        } else {\n            std::cout << ans << ""\\n"";\n        }\n    };\n    \n    query();\n    while (m--) {\n        int x;\n        char y;\n        std::cin >> x >> y;\n        x--;\n        if (x && s[x] == \'?\') {\n            ans *= comb.inv(x);\n        }\n        s[x] = y;\n        if (x && y == \'?\') {\n            ans *= x;\n        }\n        query();\n    }\n    \n    return 0;\n}\n']","[0, 1, 0, 0, 1]",2100,The key observation to this problem is that it s much easier to consider the process in reverse Suppose Monocarp has a set of integers and starts removing elements from it one by one During the th deletion if is he removes the minimum element if is he removes the maximum element and if is he removes any element which is neither the minimum nor the maximum If you consider the process backwards it s quite easy to see that it doesn t actually matter which numbers are present in the set we are interested only in their quantity So for each action we can choose an element to remove independently if is or there is only one way otherwise there are ways where is the number of elements in the set for the th deletion operation it is So the answer to the problem is the product of for every character that is equal to To recalculate the answer efficiently when you change a character you can use one of the following options build a segment tree with operation product on segment modulo or use modular inverse to maintain division operations Note that sometimes you have to divide by zero i e remove the zero from the product when changes from to another character to handle it you can store the product for every from to and explicitly multiply it by before printing when is 
Bankopolis the city you already know finally got a new bank opened Unfortunately its security system is not yet working fine Meanwhile hacker Leha arrived in Bankopolis and decided to test the system Bank has cells for clients money A sequence from numbers describes the amount of money each client has Leha wants to make requests to the database of the bank finding out the total amount of money on some subsegments of the sequence and changing values of the sequence on some subsegments Using a bug in the system Leha can requests two types of queries to the database denoting that Leha changes each digit to digit in each element of sequence for which is holds For example if we change in number digit to we get It s worth noting that Leha in order to stay in the shadow never changes digits in the database to i e denoting that Leha asks to calculate and print the sum of such elements of sequence for which holds As Leha is a white hat hacker he don t want to test this vulnerability on a real database You are to write a similar database for Leha to test ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MAXN = 100001;\n\nstruct Perm {\n\tint a[10];\n\n\tPerm() {\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\ta[i] = i;\n\t}\n\n\tfriend Perm operator * (const Perm& b, const Perm& c) {\n\t\tPerm ans;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tans.a[i] = c.a[b.a[i]];\n\t\treturn ans;\n\t}\n\n\tPerm(int fr, int t) {\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\ta[i] = i;\n\t\ta[fr] = t;\n\t}\n\n};\n\nstruct Value {\n\tll a[10];\n\n\tValue(int x = 0) {\n\t\tfor (int i = 0; i < 10; i++) a[i] = 0;\n\t\tll cur = 1;\n\t\twhile (x > 0) {\n\t\t\ta[x % 10] += cur;\n\t\t\tcur *= 10;\n\t\t\tx /= 10;\n\t\t}\n\t}\n\n\tValue(const Value& b, const Value& c) {\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\ta[i] = b.a[i] + c.a[i];\n\t}\n\n\tfriend Value operator * (const Value& c, const Perm& b) {\n\t\tValue ans;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tans.a[i] = 0;\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tans.a[b.a[i]] += c.a[i];\n\t\treturn ans;\n\t}\n\n};\n\nconst int RMN = 300000;\nValue rmq[RMN];\nPerm mdf[RMN];\n\nint arr[MAXN];\nint n;\n\n\nvoid Upd(int v) {\n\trmq[v] = Value(rmq[v * 2 + 1], rmq[v * 2 + 2]);\n}\n\nvoid UpdV(int v, const Perm& perm) {\n\tmdf[v] = mdf[v] * perm;\n\trmq[v] = rmq[v] * perm;\n}\n\nvoid Push(int v) {\n\tUpdV(v * 2 + 1, mdf[v]);\n\tUpdV(v * 2 + 2, mdf[v]);\n\tmdf[v] = Perm();\n}\n\nvoid Build(int v = 0, int l = 1, int r = n) {\n\tif (l == r) {\n\t\trmq[v] = Value(arr[l]);\n\t} else {\n\t\tBuild(v * 2 + 1, l, (l + r) / 2);\n\t\tBuild(v * 2 + 2, (l + r) / 2 + 1, r);\n\t\tUpd(v);\n\t}\n}\n\nint lv, rv;\nPerm vl;\n\nvoid Modify(int v = 0, int l = 1, int r = n) {\n\tif ((lv > r) || (l > rv)) return;\n\tif ((lv <= l) && (r <= rv)) {\n\t\tUpdV(v, vl);\n\t\treturn;\n\t}\n\tPush(v);\n\tModify(v * 2 + 1, l, (l + r) / 2);\n\tModify(v * 2 + 2, (l + r) / 2 + 1, r);\n\tUpd(v);\n}\n\nValue Get(int v = 0, int l = 1, int r = n) {\n\tif ((lv > r) || (l > rv)) return Value();\n\tif ((lv <= l) && (r <= rv)) {\n\t\treturn rmq[v];\n\t}\n\tPush(v);\n\treturn Value(Get(v * 2 + 1, l, (l + r) / 2), Get(v * 2 + 2, (l + r) / 2 + 1, r));\n}\n\n\nint main() {\n\t//freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20);\n\tint q;\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i = 1; i <= n; i++) scanf(""%d"", arr + i);\n\tBuild();\n\tfor (int i = 0; i < q; i++) {\n\t\tint tp, x, y;\n\t\tscanf(""%d%d%d"", &tp, &lv, &rv);\n\t\tif (tp == 1) {\n\t\t\tscanf(""%d%d"", &x, &y);\n\t\t\tvl = Perm(x, y);\n\t\t\tModify();\n\t\t} else {\n\t\t\tauto ans = Get();\n\t\t\tll av = 0;\n\t\t\tfor (int j = 1; j <= 9; j++) {\n\t\t\t\tav += ans.a[j] * j;\n\t\t\t}\n\t\t\tcout << av << ""\\n"";\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 1]",2800,We use a segment tree to solve this problem For each node it is sufficient to store two arrays sum i denoting the total contribution of the digit i in the current segment if a digit is in the tens digit then it contributes 10 to the sum and etc and also nxt i what all the digits i in the current segment are changed to Maintaining these arrays is quite straightforward with lazy propogation When we push an update down a node we need to update the nxt array of the children First we change st id nxt u to v where the current update is to change all digits u to v Then we change st id 2 nxt i to st id nxt st id 2 nxt i where st id is the current node and st id 2 is one of the children nodes Do the same for the right children You can see the code if you need more details Finally update the sum array of the current segment The total complexity of the code is which is fast enough 
Nauuo is a girl who loves random picture websites One day she made a random picture website by herself which includes n pictures When Nauuo visits the website she sees exactly one picture The website does not display each picture with equal probability The i th picture has a non negative weight w i and the probability of the i th picture being displayed is frac w i sum j 1 nw j That is to say the probability of a picture to be displayed is proportional to its weight However Nauuo discovered that some pictures she does not like were displayed too often To solve this problem she came up with a great idea when she saw a picture she likes she would add 1 to its weight otherwise she would subtract 1 from its weight Nauuo will visit the website m times She wants to know the expected weight of each picture after all the m visits modulo 998244353 Can you help her The expected weight of the i th picture can be denoted by frac q i p i where gcd p i q i 1 you need to print an integer r i satisfying 0 le r i 998244353 and r i cdot p i equiv q i pmod 998244353 It can be proved that such r i exists and is unique ,"['#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <unordered_map>\n#define maxn 300005\n#define ll long long\n#define ld double\n#define mod 998244353\n#define maxm 3005\nusing namespace std;\nint n, m; \nint a[maxn], w[maxn];\nll ksm(ll a, ll b)\n{\n\tif(!b) return 1;\n\tll ns = ksm(a, b >> 1);\n\tns = ns * ns % mod;\n\tif(b & 1) ns = ns * a % mod;\n\treturn ns;\n}\nll dp[maxm][maxm];\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tll S[2] = {0, 0};\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &w[i]), \n\t\tS[a[i]] += w[i], \n\t\tS[a[i]] %= mod;\n\tll f[2] = {S[0], S[1]};\n\tdp[1][0] = 1;\n\tfor(int i = 1; i <= m; i++)\n\t\tfor(int j = 0; j <= i; j++)\n\t\t{\n\t\t\tll n1 = S[1] + j, n2 = S[0] - (i - 1 - j);\n\t\t\tif(!dp[i][j]) continue;\n\t\t\tll bk = ksm((n1 + n2) % mod, mod - 2);\n\t\t\tn1 = n1 * bk % mod, \n\t\t\tn2 = n2 * bk % mod;\n\t\t\tdp[i + 1][j] += n2 * dp[i][j], dp[i + 1][j] %= mod;\n\t\t\tdp[i + 1][j + 1] += n1 * dp[i][j], dp[i + 1][j + 1] %= mod;\n\t\t}\n\tfor(int j = 0; j <= m + 1; j++)\n\t\tf[1] += dp[m + 1][j] * j, f[1] %= mod, \n\t\tf[0] -= dp[m + 1][j] * (m - j), f[0] %= mod;\n\tS[0] = ksm(S[0], mod - 2);\n\tS[1] = ksm(S[1], mod - 2);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tll ns = f[a[i]] * S[a[i]] % mod * w[i] % mod;\n\t\tif(ns < 0) ns += mod;\n\t\tprintf(""%lld\\n"", ns);\n\t}\n\treturn 0;\n}']","[0, 0, 0, 1, 0]",2300,Tutorial First let s focus on a single picture with weight which Nauuo likes so we only have to know the sum of the weights of the pictures Nauuo likes and the sum of the disliked ones instead of all the weights Then we can use DP to solve this problem Let be the expected weight of a picture Nauuo likes with weight after another visits since and Obviously The state transition The next visit displays the picture we focus on Probaility Lead to The next visit displays a picture Nauuo likes but is not the one we focus on Probaility Lead to The next visit displays a picture Nauuo doesn t like Probaility Lead to So Let be the expected weight of a picture Nauuo doesn t like with weight after another visits since and The state transition is similar Note that have some relation In fact we can let be and are the initial ones here But up to now we can only solve the easy version To solve the hard version let s introduce a lemma Proof Obviously this is true when Then suppose we have already proved Also a brief but not so strict proof the increment in each step is proportional to the expectation So we only have to calculate In conclusion If the expected weight of the th picture is otherwise the expected weight is Last question how to calculate the result modulo If you don t know how please read the wiki to learn it You can calculate and store all the inverses at first then you can get an solution instead of here 
Artsem has a friend Saunders from University of Chicago Saunders presented him with the following problem Let denote the set We will also write when a function is defined in integer points and all its values are integers from 1 to Now then you are given a function Your task is to find a positive integer and two functions such that for all and for all or determine that finding these is impossible ,"['#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int N = (int) 1e5 + 100;\nint a[N];\nint st[N];\nint sz = 0;\nint o2[N];\n\nint main(int,  char **)\n{\n#ifdef LOCAL\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(""%d"", &a[i] );\n\t\ta[i]--;\n\t}\n\tmemset(st, -1, sizeof st);\n\tfor (int i = 0; i < n; i++)\n\t\tif (i == a[i] )\n\t\t{\n\t\t\to2[sz] = i;\n\t\t\tst[i] = sz++;\n\t\t}\n\tfor (int i = 0; i < n; i++)\n\t\tif (st[a[i] ] == -1)\n\t\t{\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn 0;\n\t\t}\n\tprintf(""%d\\n"", sz);\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%d "", st[a[i] ] + 1);\n\tprintf(""\\n"");\n\tfor (int i = 0; i < sz; i++)\n\t\tprintf(""%d "", o2[i] + 1);\n\tprintf(""\\n"");\n\n\n\n\n\treturn 0;\n}\n\n\n']","[0, 1, 0, 0, 0]",1700,Suppose that that is the functions match on all inputs and the identity function Hence we must have It means that if then that is all distinct values of must be its stable points If this is violated we can have no answer We will put equal to the number of stable points Let s enumerate all distinct values of as and define a function that maps a point to the index We will determine functions and We can see that if then if then All enumeration can be done in linear time 
Tsondu and Tenzing are playing a card game Tsondu has n monsters with ability values a 1 a 2 ldots a n while Tenzing has m monsters with ability values b 1 b 2 ldots b m Tsondu and Tenzing take turns making moves with Tsondu going first In each move the current player chooses two monsters one on their side and one on the other side Then these monsters will fight each other Suppose the ability values for the chosen monsters are x and y respectively then the ability values of the monsters will become x y and y x respectively If the ability value of any monster is smaller than or equal to 0 the monster dies The game ends when at least one player has no monsters left alive The winner is the player with at least one monster left alive If both players have no monsters left alive the game ends in a draw Find the result of the game when both players play optimally ,"['/**\n *    author:  tourist\n *    created: 24.06.2023 10:07:10       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    long long x = 0;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      x += a[i];\n    }\n    vector<int> b(m);\n    for (int i = 0; i < m; i++) {\n      cin >> b[i];\n      x -= b[i];\n    }\n    cout << (x > 0 ? ""Tsondu"" : (x == 0 ? ""Draw"" : ""Tenzing"")) << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 1, 0, 0, 0]",800,TutorialLet s view it as when monsters and fight their health changes into and respectively So any monster with health is considered dead Therefore a player loses when the health of his monsters are all Notice that and Therefore after each step the sum of the health of monsters decrease by the same amount for both players Therefore we only need to know and to determine who wins If Tsondu wins Else if Tenzing wins Else it is a draw 
A permutation is a sequence of length n integers from 1 to n in which all the numbers occur exactly once For example 1 3 5 2 1 4 1 3 2 permutations and 2 3 2 4 3 1 0 no Polycarp was recently gifted a permutation a 1 dots n of length n Polycarp likes trees more than permutations so he wants to transform permutation a into a rooted binary tree He transforms an array of different integers into a tree as follows the maximum element of the array becomes the root of the tree all elements to the left of the maximum form a left subtree which is built according to the same rules but applied to the left part of the array but if there are no elements to the left of the maximum then the root has no left child all elements to the right of the maximum form a right subtree which is built according to the same rules but applied to the right side of the array but if there are no elements to the right of the maximum then the root has no right child For example if he builds a tree by permutation a 3 5 2 1 4 then the root will be the element a 2 5 and the left subtree will be the tree that will be built for the subarray a 1 dots 1 3 and the right one for the subarray a 3 dots 5 2 1 4 As a result the following tree will be built Another example let the permutation be a 1 3 2 7 5 6 4 In this case the tree looks like this Let us denote by d v the depth of the vertex a v that is the number of edges on the path from the root to the vertex numbered a v Note that the root depth is zero Given the permutation a for each vertex find the value of d v ,"[""#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint n;\nint arr[110];\nint ans[110];\n\nvoid recur(int s, int e, int depth)\n{\n\tint i;\n\tint mx;\n\tint idx;\n\n\tif (s > e) return;\n\n\tmx = -1;\n\tfor (i = s; i <= e; i++)\n\t{\n\t\tif (mx < arr[i])\n\t\t{\n\t\t\tmx = arr[i];\n\t\t\tidx = i;\n\t\t}\n\t}\n\n\tans[idx] = depth;\n\trecur(s, idx - 1, depth + 1);\n\trecur(idx + 1, e, depth + 1);\n}\n\nint main()\n{\n\tint t;\n\tint i;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tcin >> n;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> arr[i];\n\t\t}\n\n\t\trecur(0, n - 1, 0);\n\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcout << ans[i] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}""]","[0, 0, 1, 0, 0]",1200,We will construct the required tree recursively Let us describe the state of tree construction by three values where is the segment of the permutation and is the current depth Then the following transitions can be described find the position of the maximum element on the segment that is the depth of the vertex is equal to if then make the transition to the state if then make the transition to the state Then in order to construct the required tree it is necessary to take as the initial state 
Ilya has recently taken up archaeology He s recently found two numbers written in the based notation Each of the found numbers consisted of exactly digits Ilya immediately started looking for information about those numbers He learned that the numbers are part of a cyphered code and the one who can decypher it can get the greatest treasure After considerable research Ilya understood that to decypher the code he should do the following Rearrange digits in the first number in some manner Similarly rearrange digits in the second number in some manner As a result of this operation the numbers can get leading zeroes Add numbers digit by digit modulo In other words we need to get the third number of length each digit of the number is the sum of the respective numbers of the found numbers For example suppose there are two numbers recorded in the ternary notation 001210 and 012111 then if you add them to each other digit by digit modulo 3 you will get number 010021 The key to the code is the maximum possible number that can be obtained in the previous step Help Ilya find the key to the code ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nint n, m;\nint a[111111], b[111111];\nint la[111111], ra[111111];\nint Next[111111], Prev[111111];\nbool ma[111111], mb[111111];\n\nstruct data {\n    int i, j;\n    data (int _i, int _j) {\n        i = _i; j = _j;\n    }\n    inline friend bool operator < (data x, data y) {\n        return (a[x.i] + b[x.j]) % m < (a[y.i] + b[y.j]) % m;\n    }\n};\n\npriority_queue<data> f;\nset<int> idx;\n\nint main() {\n    // freopen(""E.in"", ""r"", stdin);\n\n    scanf(""%d%d"", &n, &m);\n    for(int i = 1; i <= n; i++) scanf(""%d"", a+i);\n    for(int i = 1; i <= n; i++) scanf(""%d"", b+i);\n\n    sort(a+1, a+1+n);\n    sort(b+1, b+1+n);\n    b[n+1] = m;\n    for(int i = 1; i <= n; i++)\n        idx.insert(-i);\n\n    memset(ma, 0, sizeof ma);\n    memset(mb, 0, sizeof mb);\n\n    for(int i = 1; i <= n; i++) {\n        int need = m-a[i]-1;\n        int l = 1, r = n+1;\n        while (l < r) {\n            int mid = (l+r)/2;\n            if (b[mid] <= need) l = mid+1;\n            else r = mid;\n        }\n        l--;\n        if (l) f.push(data(i, l));\n        if (l < n) f.push(data(i, n));\n    }\n\n    while (!f.empty()) {\n        data t = f.top(); f.pop();\n        if (!ma[t.i]) {\n            if (!mb[t.j]) {\n                printf(""%d "", (a[t.i] + b[t.j]) % m);\n                ma[t.i] = 1;\n                mb[t.j] = 1;\n                idx.erase(-t.j);\n            }\n            else {\n                set<int>::iterator it = idx.lower_bound(-t.j);\n                if (it != idx.end()) {\n                    t.j = -(*it);\n                    f.push(t);  \n                }\n                \n            }\n        }\n    }\n    return 0;\n}\n']","[1, 0, 0, 0, 1]",2300, 1 Get the number of our sequences in sorted by frequencies Thus from the first sequence hereinafter the first type in a direct order from the second to the contrary 2 These numbers are put on the stack where if recording onto the stack of the second type we find the number at the top of the first type then this pair of extract and add to the answer 3 At the end obviously the stack we can find a number of properties of the second type and the first bottom on Then their grouping in response pairs with the start and end For better understanding you can look at solution 
Alexandra has a paper strip with numbers on it Let s call them from left to right Now Alexandra wants to split it into some pieces possibly For each piece of strip it must satisfy Each piece should contain at least numbers The difference between the maximal and the minimal number on the piece should be at most Please help Alexandra to find the minimal number of pieces meeting the condition above ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef unsigned long long uint64;\n#define two(X) (1<<(X))\n#define twoL(X) (((int64)(1))<<(X))\n#define contain(S,X) (((S)&two(X))!=0)\n#define containL(S,X) (((S)&twoL(X))!=0)\nconst double pi=acos(-1.0);\nconst double eps=1e-11;\ntemplate<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}\ntemplate<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}\ntemplate<class T> inline T sqr(T x){return x*x;}\ntypedef pair<int,int> ipair;\n#define SIZE(A) ((int)A.size())\n#define LENGTH(A) ((int)A.length())\n#define MP(A,B) make_pair(A,B)\n#define PB(X) push_back(X)\n\nconst int maxn=200000+10;\nconst int INF=100000000;\n\nint n,l,d;\nint a[maxn];\nint p[maxn];\nint f[maxn];\n\nint main()\n{\n#ifdef _MSC_VER\n\tfreopen(""input.txt"",""r"",stdin);\n#endif\n\tscanf(""%d%d%d"",&n,&d,&l);\n\tfor (int i=0;i<n;i++) scanf(""%d"",&a[i]);\n\tmultiset<int> S;\n\tfor (int k=0,i=0;i<n;i++)\n\t{\n\t\tfor (;!S.empty();)\n\t\t{\n\t\t\tint v1=*S.begin();\n\t\t\tint v2=*(--S.end());\n\t\t\tif (abs(v1-a[i])<=d && abs(v2-a[i])<=d) break;\n\t\t\tS.erase(S.lower_bound(a[k]));\n\t\t\tk++;\n\t\t}\n\t\tp[i]=k;\n\t\tS.insert(a[i]);\n\t}\n\tS.clear();\n\tf[0]=0;\n\tfor (int k=0,i=1;i<=n;i++)\n\t{\n\t\tif (i-l>=0) S.insert(f[i-l]);\n\t\tfor (;k<=i-l && k<p[i-1];k++) S.erase(S.lower_bound(f[k]));\n\t\tf[i]=(S.empty()?INF:((*S.begin())+1));\n\t}\n\tif (f[n]>=INF) f[n]=-1;\n\tprintf(""%d\\n"",f[n]);\n\treturn 0;\n}\n\n']","[0, 0, 0, 1, 1]",2000,We can use dynamic programming to solve this problem Let denote the minimal number of pieces that the first numbers can be split into denote the maximal length of substrip whose right border is included and it satisfy the condition Then where We can use monotonic queue to calculate g i and f i And this can be implemented in We can also use sparse table or segment tree to solve the problem the time complexity is or It should be well implemented For more details about monotonic queue you can see here 
Petr wants to make a calendar for current month For this purpose he draws a table in which columns correspond to weeks a week is seven consequent days from Monday to Sunday rows correspond to weekdays and cells contain dates For example a calendar for January 2017 should look like on the picture Petr wants to know how many columns his table should have given the month and the weekday of the first date of that month Assume that the year is non leap ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int c[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcout.tie(0); cin.tie(0);\n\n\tint n, d; cin >> n >> d;\n\tcout << (c[n - 1] + d - 1 + 6) / 7 << endl;\n}\n']","[0, 1, 1, 0, 0]",800,Just implement writing dates one by one and keeping current column and row or use the formula where is the number of days in the month 
 There is a deck of n cards each of which is characterized by its power There are two types of cards a hero card the power of such a card is always equal to 0 a bonus card the power of such a card is always positive You can do the following with the deck take a card from the top of the deck if this card is a bonus card you can put it of your bonus deck or discard if this card is a hero card then the power of card from your bonus deck is added to his power if it is not empty after that the hero is added to your army and the used bonus discards Your task is to use such actions to gather an army with the maximum possible total power ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lo; \ntypedef pair< lo,lo > PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define endl ""\\n""\n#define pb push_back\n#define int long long\n#define fio() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n#define FOR for(int i=1;i<=n;i++)\n#define mid ((start+end)/2)\n#define ort ((bas+son)/2)\n\nconst lo inf = 1000000000000000000;\nconst lo KOK = 100000;\nconst lo LOG = 30;\nconst lo li = 500005;\nconst lo mod = 1000000007;\n\nint n,m,b[li],a[li],k,flag,t;\nint cev;\nstring s;\nvector<int> v;\n\ninline int in(){\n    int x;\n    scanf(""%lld"",&x);\n    return x;\n}\n\nint32_t main(void){\n    t=in();\n    while(t--){\n        n=in();\n        FOR a[i]=in();\n        priority_queue<int> pq;\n        cev=0;\n        FOR{\n\t\t\tif(a[i])pq.push(a[i]);\n\t\t\telse{\n\t\t\t\tif(pq.size()){cev+=pq.top();pq.pop();}\n\t\t\t}\n\t\t}\n\t\tprintf(""%lld\\n"",cev);\n    }\n    return 0;\n}\n']","[1, 0, 0, 0, 1]",1000,To solve it it should be noted that despite the way the deck with bonuses works the order in which they will be applied is not important Then when we meet the hero card we just need to add to the answer the maximum of the available bonuses Constraints allow you to sort the current array with bonus values each time and remove the maximum element 
Bear Limak likes watching sports on TV He is going to watch a game today The game lasts minutes and there are no breaks Each minute can be either interesting or boring If consecutive minutes are boring then Limak immediately turns TV off You know that there will be interesting minutes Your task is to calculate for how many minutes Limak will watch the game ,"['#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <functional>\n#include <vector>\n#include <numeric>\n#include <deque>\n#include <utility>\n#include <bitset>\n#include <limits.h>\n#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long llu;\ntypedef double lf;\ntypedef unsigned int uint;\ntypedef long double llf;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint N;\nbool C[100];\n\nint main() {\n\tscanf(""%d"", &N);\n\twhile(N--) {\n\t\tint t; scanf(""%d"", &t);\n\t\tC[t] = 1;\n\t}\n\n\tint con = 0;\n\tfor(int i = 1; i <= 90; i++) {\n\t\tif(!C[i]) ++con; else con = 0;\n\t\tif(con == 15) {\n\t\t\treturn 0 & printf(""%d\\n"", i);\n\t\t}\n\t}\n\n\tprintf(""%d\\n"", 90);\n    return 0;\n}\n']","[0, 0, 1, 0, 0]",800,You are supposed to implement what is described in the statement When you read numbers check if two consecutive numbers differ by more than i e If yes then you should print You can assume that and then you don t have to care about some corner case at the beginning Also you can assume that or both should work do you see why If your program haven t found two consecutive numbers different by more than then print If you still have problems to solve this problem then check codes of other participants 18286606 invented by Errichto Some prefix of problems must belong to one division and the remaining suffix must belong to the other division Thus we can say that we should choose the place between two numbers where we split problems Each pair let s say that means that the splitting place must be between and In other words it must be on the right from and on the left from For each pair if then we swap these two numbers Now the splitting place must be on the right from so it must be on the right from In linear time you can calculate and similarly calculate Then the answer is It may turn out that though but we don t want to print a negative answer So we should print 18286633 invented by Errichto We are going to iterate over all intervals Let s first fix the left end of the interval and denote it by Now we iterate over the right end When we go from to then we get one extra ball with color In one global array we can keep the number of occurrences of each color we can clear the array for each new We should increase by one and then check whether becomes a new dominant color But how to do it Additionally let s keep one variable with the current dominant color When we go to then we should whether or and The second condition checks which color has smaller index in case of a tie And we must increase by one then because we know that is dominant for the current interval At the end print values 18286663 invented by Errichto There is no solution if or But for and you can construct the following graph Here cities denote other cities in any order you choose cities different than You should print in the first line and in the second line Two not very hard challenges for you Are you able to prove that the answer doesn t exist for Can you solve the problem if the four given cities don t have to be distinct but it s guaranteed that and 18286683 invented by Radewoosh When we repeat something and each time we have probability to succeed then the expected number or tries is till we succeed How to calculate the expected time for one region For each in some moment we will try to beat this level and then there will be tokens in the bag including tokens allowing us to beat this new level The probability to succeed is so the expected time is So in total we should sum up values for Ok we managed to understand the actual problem You can now stop and try to find a slow solution in Hint use the dynamic programming Now let s write formula for as the minimum over denoting the end of the previous region So we can use convex hull trick to calculate it in You should also get AC with a bit slower divide conquer trick if it s implemented carefully 18286696 invented by Radewoosh Let s say that every company has one parent a company it follows Also every copmany has some maybe empty set of children It s crucial that sets of children are disjoint For each company let s keep and always update one value equal to the sum of It turns out that after each query only the above sum changes only for a few values If starts to follows then you should care about And maybe and if you want to be sure You can stop reading now for a moment and analyze that indeed other companies will keep the same sum described above Ok but so far we don t count the income coming from parent s fanpage But for each company we can store all its children in one set All children have the same income from parent s fanpage because they have the same parent So in set you can keep children sorted by the sum described above Then we should always puts the extreme elements from sets in one global set In the global set you care about the total income equal to the sum described above and this new income from parent Check codes for details The complexity should be with big constant factor 18286747 invented by Errichto Let denote the probability that subtree if attacked now would have height at most The first observation is that we don t care about big because it s very unlikely that a path with e g 100 edges will survive Let s later talk about choosing and now let s say that it s enough to consider up to When we should answer a query for subtree then we should sum up to get the answer The other query is harder Let s say that a new vertex is attached to vertex Then among only changes other values stay the same Also one value changes and so does and so on You should iterate over vertices each time going to parent and update the corresponding value TODO puts here come formula for updating value The complexity is You may think that is enough because is small enough Unfortunately there exist malicious tests Consider a tree with paths from root each with length Now we talk about the probability of magnitude which is more than for http www wolframalpha com input i 1 1 1 
You are given a positive integer n In this problem the operatorname MEX of a collection of integers c 1 c 2 dots c k is defined as the smallest integer x which does not occur in the collection c The of an array a 1 dots a n is defined as the number of pairs l r such that 1 le l le r le n and operatorname MEX a l dots a r is a prime number Find any permutation of 1 2 dots n with the maximum possible primality among all permutations of 1 2 dots n Note A prime number is a number greater than or equal to 2 that is not divisible by any positive integer except 1 and itself For example 2 5 13 are prime numbers but 1 and 6 are not prime numbers A permutation of 1 2 dots n is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf("" %s"",ss);(st)=ss;}\n#define spln(i,n) (i==n?\'\\n\':\' \')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(""1.in"",""r"",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\nint n,m,i,j;\nvoid solve()\n{\n\tread(n);\n\tif(n==1){puts(""1"");return;}\n\tif(n==2){puts(""1 2"");return;}\n\tprintf(""2 "");\n\tvector<int> v1,v2;\n\tfz(i,4,n)if(v1.size()<v2.size())v1.push_back(i);else v2.push_back(i);\n\tff(v1,it) printf(""%d "",*it);\n\tprintf(""1 "");\n\tff(v2,it) printf(""%d "",*it);\n\tputs(""3"");\n}\nint main()\n{\n\tint t;read(t);\n\twhile(t--)solve();\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",1000,The cases can be handled separately For any construction with is optimal We can prove this as follows Note that since and are both prime any with has a prime except for possibly where Therefore the primality of this array is where if proposition is true and if is false On the other hand for any permutation of let be the index with The primality of this array cannot exceed since any pair with prime must satisfy and additionally no matter what the permutation is The function is a quadratic which is maximized at so as required The time complexity is note that we don t even need to sieve for primes 
It s tough to be a superhero And it s twice as tough to resist the supervillain who is cool at math Suppose that you re an ordinary Batman in an ordinary city of Gotham Your enemy Joker mined the building of the city administration and you only have several minutes to neutralize the charge To do that you should enter the cancel code on the bomb control panel However that mad man decided to give you a hint This morning the mayor found a playing card under his pillow There was a line written on the card The bomb has a note saying where is some positive integer You suspect that the cancel code is some integer that meets the equation Now in order to decide whether you should neutralize the bomb or run for your life you ve got to count how many distinct positive integers meet this equation ,"['#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 1000100;\n\nll A;\nvector <ll> pfac;\nvector <int> pcnt;\nll fac[MAXN];\nll dp[MAXN];\nint nfac;\nmap <ll, int> dloc;\nbool prime[MAXN];\n\nbool cprime (ll x)\n{\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            return false;\n        }\n    return true;\n}\n\nvoid factorise()\n{\n    ll x = A;\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            int cnt = 0;\n            while (x % i == 0)\n            {\n                x /= i;\n                cnt++;\n            }\n            \n            pfac.push_back (i);\n            pcnt.push_back (cnt);\n        }\n    \n    if (x > 1)\n    {\n        pfac.push_back (x);\n        pcnt.push_back (1);\n    }\n    \n    nfac = 1;\n    for (int i = 0; i < pcnt.size(); i++)\n    {\n        //cout << pfac[i] << "" "" << pcnt[i] << ""\\n"";\n        nfac *= (pcnt[i] + 1);\n    }\n    \n    for (int i = 0; i < nfac; i++)\n    {\n        ll res = 1;\n        \n        int tval = i;\n        for (int j = 0; j < pcnt.size(); j++)\n        {\n            int c = tval % (pcnt[j] + 1);\n            tval /= pcnt[j] + 1;\n            \n            for (int k = 0; k < c; k++)\n                res *= pfac[j];\n        }\n        \n        fac[i] = res;\n        dloc[res] = i;\n    }\n}\n\nbool cpow (ll x)\n{\n    for (ll i = 2; i * i <= x; i++)\n        if (x % i == 0)\n        {\n            while (x % i == 0)\n                x /= i;\n            return x == 1;\n        }\n    return true;\n}\n\nvector <ll> cposs;\n\nvoid run() // run dp on cposs\n{\n    for (int i = 0; i < nfac; i++)\n    {\n        for (int j = 0; j < cposs.size(); j++)\n        {\n            ll cval = cposs[j];\n            if (fac[i] % cval == 0)\n            {\n                int nloc = dloc[fac[i] / cval];\n                dp[nloc] += dp[i];\n            }\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin >> A;\n    factorise();\n    \n    for (int i = 0; i < nfac; i++)\n        dp[i] = 0;\n    dp[nfac-1] = 1;\n    \n    for (int i = 0; i < MAXN; i++)\n        prime[i] = true;\n    prime[0] = prime[1] = false;\n    \n    for (int i = 2; i * i < MAXN; i++)\n    {\n        if (prime[i])\n            for (int j = i * i; j < MAXN; j += i)\n                prime[j] = false;\n    }\n    \n    //for (int i = 0; i < nfac; i++)\n    //    cout << fac[i] << ""\\n"";\n    \n    for (int i = 2; i < MAXN; i++)\n    {\n        if (prime[i])\n        {\n            ll cval = i;\n            \n            cposs.clear();\n            while (cval < A)\n            {\n                if (dloc.find(cval + 1) != dloc.end())\n                    cposs.push_back (cval + 1);\n                cval *= i;\n            }\n            \n            if (cposs.size() > 0)\n                run();\n        }\n    }\n    \n    for (int i = 0; i < nfac; i++)\n    {\n        if (fac[i] > MAXN && cprime (fac[i] - 1))\n        {\n            cposs.clear();\n            cposs.push_back (fac[i]);\n            run ();\n        }\n    }\n    \n    cout << dp[0] << ""\\n"";\n    return 0;\n}']","[0, 1, 0, 1, 0]",2600,First step is to understand the properties of a Joker function It s important property is that it is multiplicative for so we can write the value of function knowing the factorization of an argument Let s use this knowledge in order to solve the task with dynamic programming Let s denote as the set of prime such that the multiple including it may appear in There are not that many such primes each divisor of number can correspond no more than one such prime namely the one whose power the number is if it is a prime power at all Let s calculate the set and also remember for each prime number in it in which powers the value divides Now we can calculate value that is equal to the number of ways to get a divisor of a number as a product of brackets of first primes in set Such value can be caluclated by using dynamic programming in time where is the number of divisors of as it was shown above that So overall complexity of the solution is Challenge How the behaves when increases What is the maximum values of over all The answer Nice estimate that is not an exact asymptotic though is that Challenge What is the maximum answer in this task If you are able to create a test with answer larger than million a great respect from me 
You are given a sequence of positive integers Your task is to construct an undirected graph such that there are exactly vertices there are no self loops there are no multiple edges there are no more than edges its is equal to Vertices should be numbered through is an array with length equal to the number of vertices in a graph such that is the number of vertices adjacent to th vertex is a sorted in increasing order sequence of all distinct values from the It is guaranteed that there exists such a graph that all the conditions hold and it contains no more than edges Print the resulting graph ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint in[305];\n\nbool chk[1050][1050];\nint main() {\n\tint N, i, j, k;\n\tscanf(""%d"", &N);\n\tfor (i = 1; i <= N; i++) scanf(""%d"", &in[i]);\n\n\tint X = in[N] + 1;\n\n\tint st = 1, en = in[N] + 1;\n\tint sti = 1, eni = N;\n\twhile (1) {\n\t\tif (sti == eni) {\n\t\t\tfor (i = st; i <= en; i++) for (j = i + 1; j <= en; j++) chk[i][j] = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (sti + 1 == eni) {\n\t\t\tfor (i = st; i < st + in[sti]; i++) for (j = st; j <= en; j++) chk[i][j] = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (i = sti + 1; i <= eni - 1; i++) in[i] -= in[sti];\n\n\t\tfor (i = st; i < st + in[sti]; i++) for (j = st; j <= en; j++) chk[i][j] = true;\n\t\tst = st + in[sti];\n\t\ten = st + in[eni - 1];\n\t\tsti++, eni--;\n\t}\n\t\n\tvector <pii> Va;\n\tfor (i = 1; i <= X; i++) for (j = i + 1; j <= X; j++) if (chk[i][j] || chk[j][i]) Va.emplace_back(i, j);\n\n\tprintf(""%d\\n"", (int)Va.size());\n\tfor (auto it : Va) printf(""%d %d\\n"", it.first, it.second);\n}']","[0, 0, 1, 0, 0]",2500,We prove that the answer always always exists by constructing it Graph for is a single vertex Graph for is a clique of vertices Graph for some is obtained from the graph by adding vertices initially connected to nothing and vertices connected to all previously mentioned ones The vertices connected to nothing got degrees the vertices from the previous step increased their degrees by and finally there appeared vertices of degree The number is vertices is as needed 
Jellyfish loves playing a game called Inscryption which is played on a directed acyclic graph with n vertices and m edges All edges a to b satisfy a b You need to move from vertex 1 to vertex n along the directed edges and then fight with the final boss You will collect and in the process Each has two attributes HP and damage If a HP is a and its damage is b then the power of the is a times b Each has only one attribute power In addition to vertex 1 and vertex n there are some vertices that trigger special events The special events are You will get a with a HP and b damage If you have at least one choose one of your and increase its HP by x If you have at least one choose one of your and increase its damage by y You will get a with w power When you get to vertex n you can choose of your and multiply its damage by 10 9 The final boss is very strong so you want to maximize the sum of the power of all your and Find the maximum possible sum of power of all your and if you play the game optimally ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n// slow ...\n\nconst int K = 200;\nint N, M;\nvi type, hp, damage, power;\nvpi card;\nll ans = 0;\nV<vi> in, out;\n\nV<vpi> dp_flash;\nV<V<vi>> F;\n\nconst pi EMP{-1, 0};\nvoid solve_flash() {\n\tdp_flash.rsz(N + 1);\n\tvi max_power(N + 1);\n\t// vpi(N * K + 1, {-1, 0})\n\tROF(x, 1, N + 1) {\n\t\t// dp[x][a]: have a upon entering this\n\t\tdp_flash.at(x) = vpi((N - x) * K + 1, EMP);\n\t\tdp_flash.at(x).at(0) = {0, 0};\n\t\tfor (int y : out[x]) {\n\t\t\tckmax(max_power[x], max_power[y]);\n\t\t\tF0R(a, sz(dp_flash.at(y))) {\n\t\t\t\tckmax(dp_flash.at(x).at(a), dp_flash.at(y).at(a));\n\t\t\t}\n\t\t}\n\t\tif (type[x] == 0) {\n\t\t\t// nothing\n\t\t} else if (type[x] == 1) {\n\t\t\tassert(card[x].f);\n\t\t\teach(t, dp_flash.at(x)) if (t != EMP) t.s += card[x].f * card[x].s;\n\t\t} else if (type[x] == 2) {\n\t\t\tassert(hp[x]);\n\t\t\tdp_flash.at(x).ins(begin(dp_flash.at(x)), hp[x], EMP);\n\t\t} else if (type[x] == 3) {\n\t\t\teach(t, dp_flash.at(x)) if (t != EMP) t.f += damage[x];\n\t\t} else if (type[x] == 4) {\n\t\t\tmax_power[x] += power[x];\n\t\t\tassert(power[x]);\n\t\t\teach(t, dp_flash.at(x)) if (t != EMP) t.s += power[x];\n\t\t}\n\t}\n\tckmax(ans, (ll)max_power[1]);\n\t// each(t, dp_flash.at(1)) ckmax(ans, (ll)t.s);  // no cards\n}\n\nvoid finish_slow() {\n\tV<V<vi>> G;\n\tF.rsz(N + 1), G.rsz(N + 1);\n\tFOR(x, 1, N + 1) {\n\t\tF[x] = V<vi>(K + 1, vi(x * K + 1, -1));\n\t\tG[x] = V<vi>(K + 1, vi(x * K + 1, -1));\n\t\tF[x].at(0).at(0) = 0;\n\t\tfor (int y : in.at(x)) {\n\t\t\tF0R(a, sz(F[y])) F0R(b, sz(F[y][a])) {\n\t\t\t\tckmax(F[x].at(a).at(b), F[y].at(a).at(b));\n\t\t\t}\n\t\t\tF0R(a, sz(G[y])) F0R(b, sz(G[y][a])) {\n\t\t\t\tckmax(G[x].at(a).at(b), G[y].at(a).at(b));\n\t\t\t}\n\t\t}\n\t\tif (type[x] == 0) {\n\n\t\t} else if (type[x] == 1) {  // add card\n\t\t\tint max_ans = 0;\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) ckmax(max_ans, F[x][a][b]);\n\t\t\tF0R(a, sz(G[x]))\n\t\t\tF0R(b, sz(G[x][a]))\n\t\t\tif (G[x][a][b] != -1) ckmax(max_ans, G[x][a][b] + a * b);\n\t\t\t{  // case: start flash here\n\t\t\t\t// dbg(""BEFORE"", x, ans, max_ans);\n\t\t\t\tF0R(a, sz(dp_flash.at(x))) if (dp_flash.at(x).at(a) != EMP) {\n\t\t\t\t\tconst ll MUL = 1e9;\n\t\t\t\t\tauto [b, extra] = dp_flash.at(x).at(a);\n\t\t\t\t\tckmax(ans, max_ans + extra +\n\t\t\t\t\t               (card[x].f + a) * (card[x].s + b) * MUL -\n\t\t\t\t\t               card[x].f * card[x].s);\n\t\t\t\t\t// dbg(""GOT"", a, b, card[x], ans);\n\t\t\t\t}\n\t\t\t\t// dbg(""AFTER"", x, ans);\n\t\t\t}\n\t\t\t{  // F -> F\n\t\t\t\tF0R(a, sz(F[x]))\n\t\t\t\tF0R(b, sz(F[x][a]))\n\t\t\t\tif (F[x][a][b] != -1) F[x][a][b] += card[x].f * card[x].s;\n\t\t\t\tR0F(a, sz(F[x]))\n\t\t\t\tR0F(b, sz(F[x][a])) {\n\t\t\t\t\tckmax(F[x].at(a).at(card[x].s), F[x][a][b]);\n\t\t\t\t\tckmax(F[x].at(card[x].f).at(b), F[x][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{  // G -> F\n\t\t\t\tF0R(a, sz(G[x]))\n\t\t\t\tF0R(b, sz(G[x][a]))\n\t\t\t\tif (G[x][a][b] != -1) {\n\t\t\t\t\tG[x][a][b] += card[x].f * card[x].s;\n\t\t\t\t\tckmax(F[x][a][card[x].s], G[x][a][b] + a * b);\n\t\t\t\t\tckmax(F[x][card[x].f][b], G[x][a][b] + a * b);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// -> G\n\t\t\tckmax(G[x].at(card[x].f).at(card[x].s), max_ans);\n\t\t} else if (type[x] == 2) {  // increase HP\n\t\t\tassert(hp[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += hp[x] * b;\n\t\t\t}\n\t\t\tR0F(a, sz(G[x]))\n\t\t\tR0F(b, sz(G[x][a])) if (a + hp[x] <= K) {\n\t\t\t\tckmax(G[x][a + hp[x]][b], G[x][a][b]);\n\t\t\t}\n\t\t} else if (type[x] == 3) {  // increase damage\n\t\t\tassert(damage[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += a * damage[x];\n\t\t\t}\n\t\t\tR0F(a, sz(G[x]))\n\t\t\tR0F(b, sz(G[x][a])) if (b + K < sz(G[x][a])) {\n\t\t\t\tckmax(G[x][a][b + damage[x]], G[x][a][b]);\n\t\t\t}\n\t\t} else {\n\t\t\tassert(type[x] == 4);\n\t\t\teach(a, F[x]) each(b, a) if (b != -1) b += power[x];\n\t\t\teach(a, G[x]) each(b, a) if (b != -1) b += power[x];\n\t\t}\n\t}\n}\n\nvoid finish_fast() {\n\tV<V<vi>> G_a;\n\tF.rsz(N + 1), G_a.rsz(N + 1);\n\tFOR(x, 1, N + 1) {\n\t\tF[x] = V<vi>(K + 1, vi(K + 1, -1));\n\t\tG_a[x] = V<vi>(K + 1, vi(K + 1, -1));\n\t\tF[x].at(0).at(0) = 0;\n\t\tfor (int y : in.at(x)) {\n\t\t\tF0R(a, sz(F[y])) F0R(b, sz(F[y][a])) {\n\t\t\t\tckmax(F[x].at(a).at(b), F[y].at(a).at(b));\n\t\t\t}\n\t\t\tF0R(a, sz(G_a[y])) F0R(b, sz(G_a[y][a])) {\n\t\t\t\tckmax(G_a[x].at(a).at(b), G_a[y].at(a).at(b));\n\t\t\t}\n\t\t}\n\t\tif (type[x] == 0) {\n\n\t\t} else if (type[x] == 1) {  // add card\n\t\t\t// TODO: fix\n\t\t\tint max_ans = 0;\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) ckmax(max_ans, F[x][a][b]);\n\t\t\t{  // case: start flash here\n\t\t\t\t// dbg(""BEFORE"", x, ans, max_ans);\n\t\t\t\tF0R(a, sz(dp_flash.at(x))) if (dp_flash.at(x).at(a) != EMP) {\n\t\t\t\t\tconst ll MUL = 1e9;\n\t\t\t\t\tauto [b, extra] = dp_flash.at(x).at(a);\n\t\t\t\t\tckmax(ans, max_ans + extra +\n\t\t\t\t\t               (card[x].f + a) * (card[x].s + b) * MUL -\n\t\t\t\t\t               card[x].f * card[x].s);\n\t\t\t\t\t// dbg(""GOT"", a, b, card[x], ans);\n\t\t\t\t}\n\t\t\t\t// dbg(""AFTER"", x, ans);\n\t\t\t}\n\t\t\t{  // F -> F\n\t\t\t\tF0R(a, sz(F[x]))\n\t\t\t\tF0R(b, sz(F[x][a]))\n\t\t\t\tif (F[x][a][b] != -1) F[x][a][b] += card[x].f * card[x].s;\n\t\t\t\tR0F(a, sz(F[x]))\n\t\t\t\tR0F(b, sz(F[x][a])) {\n\t\t\t\t\tckmax(F[x].at(a).at(card[x].s), F[x][a][b]);\n\t\t\t\t\tckmax(F[x].at(card[x].f).at(b), F[x][a][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t{  // G_a: replace a\n\t\t\t\tF0R(a, sz(G_a[x]))\n\t\t\t\tF0R(b, sz(G_a[x][a]))\n\t\t\t\tif (G_a[x][a][b] != -1) G_a[x][a][b] += card[x].f * card[x].s;\n\t\t\t\tF0R(a, sz(G_a[x]))\n\t\t\t\tF0R(b, sz(G_a[x][a])) ckmax(G_a[x][card[x].f][b], G_a[x][a][b]);\n\t\t\t}\n\t\t\t// -> G_a\n\t\t\tF0R(b, K - card[x].f + 1) {\n\t\t\t\tckmax(G_a[x][card[x].f + b][b],\n\t\t\t\t      max_ans + (card[x].f + b) * card[x].s);\n\t\t\t}\n\t\t} else if (type[x] == 2) {  // OK\n\t\t\t                        // increase HP\n\t\t\tassert(hp[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += hp[x] * b;\n\t\t\t}\n\t\t\tR0F(a, sz(G_a[x]))\n\t\t\tF0R(b, sz(G_a[x][a])) if (b >= hp[x] && G_a[x][a][b] != -1) {\n\t\t\t\tckmax(G_a[x][a][b - hp[x]], G_a[x][a][b]);\n\t\t\t}\n\t\t} else if (type[x] == 3) {  // OK\n\t\t\t                        // increase damage\n\t\t\tassert(damage[x]);\n\t\t\tF0R(a, sz(F[x])) F0R(b, sz(F[x][a])) if (F[x][a][b] != -1) {\n\t\t\t\tF[x][a][b] += a * damage[x];\n\t\t\t}\n\t\t\tR0F(a, sz(G_a[x]))\n\t\t\tR0F(b, sz(G_a[x][a])) if (G_a[x][a][b] != -1) {\n\t\t\t\tG_a[x][a][b] += a * damage[x];\n\t\t\t\t// ckmax(G[x][a][b + damage[x]], G[x][a][b]);\n\t\t\t}\n\t\t} else {  // OK\n\t\t\tassert(type[x] == 4);\n\t\t\teach(a, F[x]) each(b, a) if (b != -1) b += power[x];\n\t\t\teach(a, G_a[x]) each(b, a) if (b != -1) b += power[x];\n\t\t}\n\t\tFOR(a, 1, sz(G_a[x])) ckmax(F[x][a][0], G_a[x][a][0]);\n\t}\n}\n\nvoid solve() {\n\tsolve_flash();\n\t// finish_slow();\n\tfinish_fast();\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tre(N, M);\n\ttype.rsz(N + 1);\n\thp.rsz(N + 1);\n\tdamage.rsz(N + 1);\n\tcard.rsz(N + 1);\n\tpower.rsz(N + 1);\n\tFOR(i, 1, N + 1) {\n\t\tre(type[i]);\n\t\tif (type[i] == 0) {\n\t\t} else if (type[i] == 1) re(card[i]);\n\t\telse if (type[i] == 2) re(hp[i]);\n\t\telse if (type[i] == 3) re(damage[i]);\n\t\telse {\n\t\t\tassert(type[i] == 4);\n\t\t\tre(power[i]);\n\t\t}\n\t}\n\t// dbg(card[2]);\n\tin.rsz(N + 1);\n\tout.rsz(N + 1);\n\trep(M) {\n\t\tdef(int, u, v);\n\t\tout[u].pb(v), in[v].pb(u);\n\t}\n\tsolve();\n\tdbg(""MID"", ans);\n\teach(t, card) swap(t.f, t.s);\n\tswap(hp, damage);\n\tFOR(i, 1, N + 1) if (2 <= type[i] && type[i] <= 3) type[i] ^= 1;\n\tsolve();\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","[0, 0, 0, 1, 0]",3500,TutorialFor convenience let s define use operation 1 for You will get a card with HP and damage operation 2 for If you have at least one card choose one of your cards and increase its HP by and operation 3 for If you have at least one card choose one of your cards and increase its damage by operation 4 for You will get a prop with power operation 5 for You can choose at most one of your cards and multiply its damage by the th card for the card we get from vertex It must be operation 1 on vertex do operation 2 3 5 onto card for When we do this operation 2 3 5 we will choose the card and increase his HP or damage Let us consider the problem without the operation 5 what s the maximum possible answer If you want to maximize the the sum of the power of your cards the answer will not exceeding If you you want to maximize the the sum of the power of your props the answer will not exceeding Because so the operation is the most important Let s called the card we wil do the operation 5 onto it the flash card Let s use meet in the middle the problem is divided into two subproblems the game before we get the flash card and the game after we get the flash card 1 The game after we get the flash cardIt s a easy problem we can use dynamic programming to solve this problem Since the most important thing is the HP and damage of the flash card so we define the following dynamic programming state means we are current at vertex the current HP of the flash card is the maximum damage of the flash card means we are current at vertex the current HP of the flash card is the damage of the flash card is the maximum sum of the power of all the other cards and props Since the time complexity of the transition is 2 The game before we get the flash cardThis is the key of the problem and since it s much more difficult we first consider the subproblems of this problem I If the graph is a chain and all the operation 2 and operation 3 is after the operation 1Lemma We will do all the operation 2 onto one of the cards symmetrically we will also do all the operation 3 onto one of the cards Proof We consider a sequence of operations let s consider if we do all the operation 1 on the card with the max damage after doing all the operation 2 the answer won t be worse we can do all the operation 1 onto this card instead then we make a symmetrical adjustment the answer won t be worse and all the operation 2 is done onto one of the cards all the operation 3 is done onto one of the cards II If the graph is a chainIt s similar to the subproblem I If we say subproblem I is like a global max value then subproblem II is like a prefix max value Let s define means we will do the operation 2 3 on vertex onto the th card Lemma1 If there is a operation 2 on vertex and a operation 2 on vertex if we will have Proof Let s consider the final HP and damage of the cards after all the operations Because we do the operation 2 on vertex onto the th card for all the damage of the th card is not larger than the th card So for if we don t do the operation 2 on vertex j onto the th card we can do it onto the th card instead the answer won t be worse Symmetrically Lemma1 is also correct for operation 3 Now we can use dynamic programming to solve the problem we define the following dynamic programming state means we are current at vertex we will do the next several operation 3 onto a card with HP after all the operations and we will do the next several operation 2 onto a card with damage after all the operations and this two cards are not the same means we are current at vertex We will do the next several operation 2 and operation 3 onto a card currently having HP and damage The time complexity is but it s not enough Lemma2 If a card has HP and damage after all the operations and it s not the flash card Proof If we use this card as the flash card instead of the last one and do all the operations done onto the last flash card onto this card the power of the flash card will be larger So it won t exist in this half problem Now the time complexity becomes it s still not enough Lemma3 Let s define as the maximum HP of all the cards except the flash card after all the operations as the maximum damage of all the cards except the flash card after all the operations Proof Let s assume that the th card has HP after all the operations the th card has damage after all the operations and If it conflicts with Lemma 2 If because of the Lemma 2 the HP of the th card after all the operations won t exceed let s use as the HP of the th card after all the operations and so we have done some operation 3 onto the th card But because if we do these operations onto the th card the answer will be better If it s symmetric with But we can make the dynamic programming state better means we are current at vertex we will do the next several operation 3 onto a card with HP after all the operations and we will do the next several operation 2 onto a card with damage after all the operations and this two cards are not the same means we are current at vertex we will do the next several operation 3 onto a card with HP after all the operations we will do the next several operation 2 onto a card and totally increase HP in the next several operations to reach it s HP after all the operations it s symmetric with just swap HP and damage Let s define as the maximum HP of all the cards except the flash card after all the operations as the maximum damage of all the cards except the flash card after all the operations We will find the in is because if using we can get the right answer if using we can get the right answer the time complexity of the transition is The transition is very complex you can see more details in my code In my code I use to make the transition better When or reaches we reaches the vertex and there is a operation 1 on vertex I don t enumerate the value of the next and while transiting I transit it to first and enumerate the value of the next and together III the problem itselfSince the path is a chain and we use dynamic programming to solve the problem There s no difference whether the graph is a chain Time complexity Memory complexity 
There are n cities and n 1 undirected roads connecting pairs of cities Citizens of any city can reach any other city traveling by these roads Cities are numbered from 1 to n and the city 1 is a capital In other words the country has a tree structure There are m citizens living in the country A p i people live in the i th city but all of them are working in the capital At evening all citizens return to their home cities using the shortest paths Every person has its own mood somebody leaves his workplace in good mood but somebody are already in bad mood Moreover any person can ruin his mood on the way to the hometown Happiness detectors are installed in each city to monitor the happiness of person who visits the city The detector in the i th city calculates a happiness index h i as the number of people in good mood minus the number of people in bad mood Let s say for the simplicity that Happiness detector is still in development so there is a probability of a mistake in judging a person s happiness One late evening when all citizens successfully returned home the government asked uncle Bogdan the best programmer of the country to check the correctness of the collected happiness indexes Uncle Bogdan successfully solved the problem Can you do the same More formally ,"['#pragma GCC optimize(""O3"")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 200000\n\nlong long h[N];\nlong long a[N];\nvector<long long>e[N];\nbool used[N];\nbool v;\n\nlong long dfs(long long k) {\n\tused[k] = true;\n\tlong long re = 0;\n\tlong long s = 0;\n\tlong long sz = e[k].size();\n\tf(i, sz) {\n\t\tif (!used[e[k][i]]) {\n\t\t\tre += dfs(e[k][i]);\n\t\t\ts += h[e[k][i]];\n\t\t}\n\t}\n\tre += a[k];\n    s-=a[k];\n\tif (s > h[k])v = false;\n\telse if (re < h[k])v = false;\n\telse if ((re - h[k]) % 2 != 0)v = false;\n\treturn re;\n}\n\n\nint main() {\n\n\tf(i, N) {\n\t\ta[i] = 0;\n\t\th[i] = 0;\n\t}\n\tlong long n, m,k, t;\n\tlong long x, y, z;\n\tlong long s, ans;\n\tans = 0;\n\tscanf(""%lld"", &t);\n\tf(tt, t) {\n\t\tscanf(""%lld %lld"", &n, &m);\n\t\tf(i, n) {\n\t\t\tscanf(""%lld"", &a[i]);\n\t\t}\n\t\tf(i, n) {\n\t\t\tscanf(""%lld"", &h[i]);\n\t\t}\n\t\tf(i, n-1) {\n\t\t\tscanf(""%lld %lld"", &x, &y);\n\t\t\tx--;\n\t\t\ty--;\n\t\t\te[x].push_back(y);\n\t\t\te[y].push_back(x);\n\t\t}\n\t\tv = true;\n\t\tf(i, n)used[i] = false;\n\t\tdfs(0);\n\t\tif (v)printf(""YES\\n"");\n\t\telse printf(""NO\\n"");\n\t\tf(i, n)e[i].clear();\n\t}\n\n\treturn 0;\n}']","[1, 1, 0, 0, 0]",1800,For each city count how many people will visit it Knowing this value and the value of the level of happiness we can calculate how many people visited the city in a good mood We can single out the criterions for the correctness of the values of the happiness indices is a multiple of For each an integer In each city the number of residents who passed this city in a good mood a non negative number not exceeding where are the cities where the resident can move out of the city on the way home This follows from the fact that the mood of the inhabitants can be deteriorated and cannot be improved This is enough since these conditions guarantee the correctness of the happiness indices by definition as well as the peculiarities of changes in the mood of residents 
Arul has a array text a of length n He will take all subsequences text of length k k is odd of this array and find their median text What is the sum of all these values As this sum can be very large output it modulo 10 9 7 In other words print the remainder of this sum when divided by 10 9 7 text A binary array is an array consisting only of zeros and ones text An array b is a subsequence of an array a if b can be obtained from a by the deletion of several possibly zero or all elements Subsequences have to be contiguous text The median of an array of odd length k is the frac k 1 2 th element when sorted ,"['#include<bits/stdc++.h>using namespace std;int T,a[200005];const int mod=1e9+7;int power(int x,int y){\tint ret=1;\tdo{\t\tif(y&1)ret=1ll*ret*x%mod;\t\tx=1ll*x*x%mod;\t}while(y>>=1);\treturn ret;}int fact[200005],inv[200005];int C(int n,int m){\treturn 1ll*fact[n]*inv[m]%mod*inv[n-m]%mod;}int main(){\tfact[0]=1;inv[0]=1;\tfor(int i=1;i<=2e5;i++){\t\tfact[i]=1ll*fact[i-1]*i%mod;\t\tinv[i]=power(fact[i],mod-2);\t}\tcin>>T;\twhile(T--){\t\tint n,k;cin>>n>>k;\t\tfor(int i=1;i<=n;i++)cin>>a[i];\t\tint cnt=0;\t\tfor(int i=1;i<=n;i++)cnt+=a[i];\t\tint ans=0;\t\tfor(int i=k/2+1;i<=k;i++){\t\t\tif(cnt>=i&&(n-cnt)>=k-i){\t\t\t\tans=(ans+1ll*C(cnt,i)*C(n-cnt,k-i))%mod;\t\t\t}\t\t}\t\tcout<<ans<<endl;\t}\treturn 0;}']","[0, 1, 0, 0, 0]",1500,Say the array has x ones and y zeroes If the median of a subsequence of length k is 1 then there are at least k2 1 ones in the array Let s iterate over the number of ones in the subsequence from k2 1 to x Suppose there are i ones Then there are k i zeroes The number of ways to choose i ones from x is xi that is x choose i this is the so called binomial coefficient Similarly the number of ways to choose k i zeroes from y of them is yk i Therefore the answer is the sum of xi yk i over all i from k2 1 to x You can compute binomial coefficients in many ways for example precomputing all factorials and then using the formula nk n n k k Depending on your implementation it can take O nlogMOD or O n logMOD time 
Rick and Morty want to find MR PBH and they can t do it alone So they need of Mr Meeseeks They Have generated Mr Meeseeks standing in a line numbered from to Each of them has his own color th Mr Meeseeks color is Rick and Morty are gathering their army and they want to divide Mr Meeseeks into some squads They don t want their squads to be too colorful so each squad should have Mr Meeseeks of at most different colors Also each squad should be a continuous subarray of Mr Meeseeks in the line Meaning that for each if Mr Meeseeks number and Mr Meeseeks number are in the same squad then Mr Meeseeks number should be in that same squad Also each squad needs its own presidio and building a presidio needs money so they want the total number of squads to be minimized Rick and Morty haven t finalized the exact value of so in order to choose it for each between and inclusive need to know the minimum number of presidios needed ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nint n,c[N],ocr[N],nxtocr[N],cnt[N],a[N];\nVI r[N];\nvoid modify(int x,int s) {\n\tfor (;x<=n+1;x+=x&(-x)) c[x]+=s;\n}\nint find(int x) {\n\tint p=0;\n\tper(i,0,20) {\n\t\tif (p+(1<<i)<=n+1&&c[p+(1<<i)]<x) {\n\t\t\tx-=c[p+(1<<i)];\n\t\t\tp+=(1<<i);\n\t\t}\n\t}\n\treturn p+1;\n}\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\trep(i,1,n+1) ocr[i]=n+1;\n\tper(i,1,n+1) {\n\t\tnxtocr[i]=ocr[a[i]];\n\t\tocr[a[i]]=i;\n\t}\n\trep(i,1,n+1) {\n\t\tmodify(ocr[i],1);\n\t\tr[1].pb(i);\n\t}\n\trep(i,1,n+1) {\n\t\tfor (auto d:r[i]) {\n\t\t\tint k=find(d+1);\n//\t\t\tprintf(""%d %d %d\\n"",i,d,k);\n\t\t\tcnt[d]++;\n\t\t\tr[k].pb(d);\n\t\t}\n\t\tmodify(i,-1);\n\t\tmodify(nxtocr[i],1);\n\t}\n\trep(i,1,n+1) printf(""%d "",cnt[i]);\n}\n']","[0, 0, 0, 0, 1]",2400,Your task is to find the minimum number of parts needed to partition this such that each part contains no more than different numbers For a fixed we can greedily find the answer First fix a maximal partition with at most different numbers in it then a maximal after that and so on If answer for is we can find this number in The only thing we want is to find maximum for a fixed so that has at most distinct numbers This can be done with binary search segment tree but it s too slow We can do this using a persistent segment tree in for a fixed we define to be if and there s no such that and otherwise So if we have a segment tree on every we can use this segment tree to find the first for an arbitrary it s like finding one in this array So we find the answer in so the total complexity is and because so Total time complexity 
A bus moves along the coordinate line from the point to the point After starting from the point it reaches the point immediately turns back and then moves to the point After returning to the point it immediately goes back to the point and so on Thus the bus moves from to and back Moving from the point to or from the point to is called a In total the bus must make journeys The petrol tank of the bus can hold liters of gasoline To pass a single unit of distance the bus needs to spend exactly one liter of gasoline The bus starts its first journey with a full petrol tank There is a gas station in point This point is between points and There are no other gas stations on the bus route While passing by a gas station in either direction the bus can stop and completely refuel its tank Thus after stopping to refuel the tank will contain liters of gasoline What is the minimum number of times the bus needs to refuel at the point to make journeys The first journey starts in the point ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nint main()\n{\n\tint a,b,f,k;\n\tscanf(""%d%d%d%d"",&a,&b,&f,&k);\n\tint s=b;\n\ts-=f;\n\tint ans=0;\n\tf=a-f;\n\tfor(k--;k;k--)\n\t{\n\t\tif(s<0)\n\t\t{\n\t\t\tprintf(""-1\\n"");\n\t\t\treturn 0;\n\t\t}\n\t\tif(2*f>s)\n\t\t{\n\t\t\ts=b;\n\t\t\tans++;\n\t\t}\n\t\ts-=2*f;\n\t\tf=a-f;\n\t}\n\tif(s<0)\n\t{\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tif(f>s)\n\t{\n\t\ts=b;\n\t\tans++;\n\t}\n\ts-=f;\n\tif(s<0)\n\t{\n\t\tprintf(""-1\\n"");\n\t\treturn 0;\n\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']","[1, 1, 1, 0, 0]",1500,If the bus can not reach the first gas station i e print In the other case the bus will reach the first gas station with liters in the gasoline tank Then we need to iterate through journeys from to and calculate a value how many liters of the gasoline needed to bus reach the next gas station If more than print because it means that the bus can not reach the next gas station even with full gasoline tank If more than current level of gasoline in the tank the bus needs to refuel In the other case refuel is not necessary After described operations we need to move to the point of next gas station and recalculate the fuel level in the tank 
You are living on an infinite plane with the Cartesian coordinate system on it In one move you can go to any of the four adjacent points left right up down More formally if you are standing at the point x y you can go left and move to x 1 y or go right and move to x 1 y or go up and move to x y 1 or go down and move to x y 1 There are n boxes on this plane The i th box has coordinates x i y i It is guaranteed that the boxes are either on the x axis or the y axis That is either x i 0 or y i 0 You can collect a box if you and the box are at the same point Find the minimum number of moves you have to perform to collect all of these boxes if you have to at the point 0 0 ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\n\nbool solve(int caseN) {\n    int n;\n    cin >> n;\n\n    int minX = 0, maxX = 0, minY = 0, maxY = 0;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        minX = min(minX, x);\n        maxX = max(maxX, x);\n        minY = min(minY, y);\n        maxY = max(maxY, y);\n    }\n    cout << 2*(maxX-minX+maxY-minY) << ""\\n"";\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""complexity.in"", ""r"", stdin);\n    // freopen(""complexity.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(i); /*\n    for (int i = 1; solve(i); i++); /**/\n    cout.flush();\n    return 0;\n}']","[1, 0, 1, 0, 0]",800,Suppose we only have boxes on the axis then the optimal strategy is going in the following way There is no way to do in less than moves What if we have boxes on two axis Let s assume it is suppose we have a strategy to go in the following way In this case it is optimal to fill the three dots with which is just solving each axis independently Therefore the number of axis does not matters For each axis that has at least one box go from to the farthest one then come back to Time complexity Solution 
A ticket is a string consisting of six digits A ticket is considered lucky if the sum of the first three digits is equal to the sum of the last three digits Given a ticket output if it is lucky or not Note that a ticket can have leading zeroes ,"['#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tint t;\n\tstring s;\n\tint n;\n\tint x, y;\n\t\n\tcin >> t;\n\twhile(t --)\n\t{\n\t\tcin >> s;\n\t\t\n\t\tn = s.length();\n\t\tx = (s[0] - \'0\') + (s[1] - \'0\') + (s[2] - \'0\');\n\t\ty = (s[n - 3] - \'0\') + (s[n - 2] - \'0\') + (s[n - 1] - \'0\');\n\t\t\n\t\tcout << (x == y ? ""YES"" : ""NO"") << endl;\n\t}\n\t\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0]",800,We need to check if the sum of the first three digits is equal to the sum of the last three digits This is doable by scanning the input as a string then comparing the sum of the first three characters with the sum of the last three characters using the if statement and the addition operation 
You are given segments on the Ox axis You can drive a nail in any integer point on the Ox axis line nail so that all segments containing this point are considered nailed down If the nail passes through endpoint of some segment this segment is considered to be nailed too What is the smallest number of nails needed to nail all the segments down ,"['#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nbool cmp(pair <int, int> a, pair <int, int> b){\n    if(a.first<b.first){\n        return true;\n    }else{\n        if(a.first==b.first){\n            return a.second<b.second;\n        }\n        return false;\n    }\n}\n\n\nint main(){\n\n    int n;\n    pair <int, int> a[1013];\n    cin>>n;\n    for(int i=0; i<n; i++){\n        cin>>a[i].first>>a[i].second;\n        if(a[i].first>a[i].second) swap(a[i].first,a[i].second);\n    }\n    sort(a,a+n,cmp);\n    int m=0;\n    queue <int> q;\n    int f=0;\n    pair<int ,int> t;\n    while(f<n){\n        t=a[f];\n        int p=f;\n        bool fl=false;\n        while(p<n && max(t.first,a[p].first)<=min(t.second,a[p].second)){\n            t.first=max(t.first,a[p].first);\n            t.second=min(t.second,a[p].second);\n            fl=true;\n            p++;\n        }\n        q.push(t.first);\n        if(!fl) p++;\n        f=p;\n    }\n    cout<<q.size()<<endl;\n    while(!q.empty()){\n        cout<<q.front()<<"" "";\n        q.pop();\n    }\n    return 0;\n}']","[1, 0, 0, 0, 0]",1900,In this problem one should place minimal number of points on the line such that any given segment touches at least one of these points Let s call the coordinate of ending of any segment as event There will be events of two types beginning of a segment and its ending Let s sort this events by coordinates In the case of equality of some events consider that the event of the beginning will be less than the event of ending Look at our events from left to right if there is a beginning event then push the number of this segment to the special queue Once we take an ending of some segment place the point here and clear the special queue because each of segment in this queue will touch this point 
There are two sequences of colorful stones The color of each stone is one of red green or blue You are given two strings and The th 1 based character of represents the color of the th stone of the first sequence Similarly the th 1 based character of represents the color of the th stone of the second sequence If the character is or the color of the corresponding stone is red green or blue respectively Initially Squirrel Liss is standing on the first stone of the first sequence and Cat Vasya is standing on the first stone of the second sequence You can perform the following instructions zero or more times Each instruction is one of the three types or After an instruction the animals standing on stones whose colors are will move one stone forward For example if you perform an instruction the animals standing on red stones will move one stone forward You are not allowed to perform instructions that lead some animals out of the sequences In other words if some animals are standing on the last stones you can t perform the instructions of the colors of those stones A pair of positions position of Liss position of Vasya is called a state A state is called if the state is reachable by performing instructions zero or more times from the initial state 1 1 Calculate the number of distinct reachable states ,"['#pragma comment(linker, ""/STACK:60000000"")\n//#define _MY_OPT_MODE_\n#define _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <list>\n\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long double ldb;\ntypedef long long int64;\ntypedef pair <int, int> pii;\ntypedef pair <double, double> pdd;\n\n#define y0 wwwwwww\n#define y1 qqqqqqq\n#define next NEXT\n#define prev PREV\n#define forn(i, n) for (int i = 0; i < (int) n; i++)\n#define ford(i, n) for (int i = (int) n - 1; i >= 0; i--)\n#define seta(a, b) memset(a, b, sizeof(a))\n#define pb push_back\n#define all(a) (a).begin(), (a).end()\n#define last(a) a[a.size() - 1]\n#define mp make_pair\n#define fs first\n#define sc second\n\ntemplate <class T> T sqr(T x) { return x * x; }\n\ndouble const pi = 3.1415926535897932384626433832795;\nint const inf = (int) 1e9;\nint64 const inf64 = (int64) 4e18;\nconst string name = ""d"";\n\nconst int NMAX = 1001000;\n\nint f(int c)\n{\n\tif (c == \'R\') return 0;\n\tif (c == \'G\') return 1;\n\tif (c == \'B\') return 2;\n\tassert(0);\n}\n\nint n, m, l, r, pre[NMAX][3][3];\nint64 ans;\nchar s[NMAX], t[NMAX];\n\nint calc(int idx, int ept)\n{\n\tif (idx < 0 || ept == 0) return 0;\n\treturn pre[idx][f(s[ept])][f(s[ept - 1])];\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen((name + "".in"").data(), ""r"", stdin);\n\tfreopen((name + "".out"").data(), ""w"", stdout);\n#endif\n\n\tscanf(""%s"", s);\n\tscanf(""%s"", t);\n\tn = strlen(s);\n\tm = strlen(t);\n\n\tseta(pre, 0);\n\tforn(i, m)\n\t\tif (i)\n\t\t{\n\t\t\tmemcpy(pre[i], pre[i - 1], sizeof(pre[i]));\n\t\t\tpre[i][f(t[i - 1])][f(t[i])]++;\n\t\t\tforn(j, 3)\n\t\t\t\tpre[i][j][j] = 0;\n\t\t}\n\n\tl = 0, r = 0;\n\tans = 0;\n\tforn(i, n)\n\t{\n\t\twhile (r < m - 1 && s[i] != t[r]) r++;\n\t\tans += r - l + 1 - (calc(r, i) - calc(l - 1, i));\n\t\tif (r < m - 1) r++;\n\t\tif (s[i] == t[l]) l++;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0]",2500,First let s consider a simpler version of the problem You are given a start state and a goal state Check whether the goal state is reachable from the start state Define A B C and D as in the picture below and let I be the string of your instructions A and B are substrings of s and C and D are substrings of t It is possible to reach the goal state from the start state if there exists an instruction I such that 1 A is a subsequence of I 2 B is not a subsequence of I 3 C is a subsequence of I 4 D is not a subsequence of I So we want to check if such string I exists string s1 is called a subsequence of s2 if it is possible to get s2 by removing some characters of s1 There are some obvious NO cases When D is a subsequence of A it is impossible to satisfy both conditions 1 and 4 Similarly B must not be a subsequence of C Are these sufficient conditions Let s try to prove this hypothesis To simplify the description we will introduce some new variables Let A B C and D be strings that can be obtained by removing the first characters of A B C and D Let c1 and c2 be the first characters of A and C Suppose that currently the conditions are satisfied i e D is not a subsequence of A and B is not a subsequence of C If c1 c2 you should perform the instruction c1 c2 The new quatruplet will be A B C D and this also satisies the conditions If c1 c2 and B is not a subsequnce of C you should perform the instruction c1 The new quatruplet will be A B C D and this also satisies the conditions If c1 c2 and D is not a subsequnce of A you should perform the instruction c2 The new quatruplet will be A B C D and this also satisies the conditions What happens if all of the above three conditions don t hold In this case A and C have the same length and A c1c2c1c2 B c2c1c2c1 In particular the last two characters of A and B are swapped there are different characters x and y and A xy B yx Now you found a new necessary condition Generally if A and B are of the form A xy and B yx the goal state is unreachable If the last instruction is x Vasya must be in the goal before the last instruction but then Vasya will go further after the last instruction If the last instruction is y we will also get a contradiction Finally we have a solution The goal state is reachable from the start state if and only if D is not a subsequence of A B is not a subsequnce of C and A and C are not of the form A xy C yx The remaining part is relatively easy so I ll leave it as an exercise for readers 
You are given an array a consisting of n nonnegative integers You can swap the elements at positions i and j if a i mathsf XOR a j 4 where mathsf XOR is the bitwise XOR operation Find the lexicographically smallest array that can be made with any number of swaps An array x is lexicographically smaller than an array y if in the first position where x and y differ x i y i ,"['#include <iostream>#include <set>#include <map>#include <vector>#include <algorithm>#include <cmath>using namespace std;typedef long long ll;const int N = 5e5 + 10;int a[N];void solve() {\tint n;\tcin >> n;\tmap <int, vector<pair<int, int>>> mp;\tfor (int i = 1; i <= n; i++) {\t\tcin >> a[i];\t\tmp[a[i] / 4].push_back({ a[i], i });\t}\tfor (auto it : mp) {\t\tvector <pair<int, int>> v = it.second;\t\tvector <int> w;\t\tfor (auto &qwe : v) {\t\t\tw.push_back(qwe.second);\t\t}\t\tsort(w.begin(), w.end());\t\tsort(v.begin(), v.end());\t\tfor (int i = 0; i < (int)v.size(); i++) {\t\t\ta[w[i]] = v[i].first;\t\t}\t}\tfor (int i = 1; i <= n; i++) {\t\tcout << a[i] << "" "";\t}\tcout << ""\\n"";}int main() {\tint t = 1;\tcin >> t;\twhile (t--) {\t\tsolve();\t} }']","[0, 0, 0, 0, 1]",1700,Note that if then and must share all bits in their binary representation except for the last bits This is because if they have a mismatch in any greater bit their will include this bit making its value This means that we can group the numbers by removing the last two bits and putting equal numbers into the same group In each group we can order the numbers freely since we can swap any two of them so it s optimal to sort the numbers in each group Thus we can just divide the numbers into groups and sort each solving the problem in There are several ways to implement this for instead you can use a storing all the groups and then sort the values in each group The implementation we used maps each integer to a priority queue which automatically will sort the numbers in each group 
Kawasiro Nitori is excellent in engineering Thus she has been appointed to help maintain trains There are n models of trains and Nitori s department will only have at most one train of each model at any moment In the beginning there are no trains at each of the following m days one train will be added or one train will be removed When a train of model i is added at day t it works for x i days day t inclusive then it is in maintenance for y i days then in work for x i days again and so on until it is removed In order to make management easier Nitori wants you to help her calculate how many trains are in maintenance in each day ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\nconst int MAGIC = 450;\n\nint n, m, x[200005], y[200005], cur, sum;\nint d0[200005], d1[455][455];\nint beg[200005];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep1(i, n) scanf(""%d%d"", &x[i], &y[i]);\n\t\n\trep(i, m) {\n\t\tint op, k, coef = 1;\n\t\tscanf(""%d%d"", &op, &k);\n\t\tif(op == 1) beg[k] = i;\n\t\telse {\n\t\t\tcoef = -1;\n\t\t\tif((i - 1 - beg[k]) % (x[k] + y[k]) < x[k]) cur --;\n\t\t}\n\t\tsum += coef;\n\t\tif(x[k] + y[k] < MAGIC) {\n\t\t\td1[x[k] + y[k]][beg[k] % (x[k] + y[k])] += coef; d1[x[k] + y[k]][(beg[k] + x[k]) % (x[k] + y[k])] -= coef;\n\t\t} else {\n\t\t\tfor(LL tmp = beg[k]; tmp < m; tmp += x[k] + y[k]) d0[tmp] += coef;\n\t\t\tfor(LL tmp = beg[k] + x[k]; tmp < m; tmp += x[k] + y[k]) d0[tmp] -= coef;\n\t\t}\n\t\tcur += d0[i];\n\t\tfor(int tmp = 2; tmp < MAGIC; tmp ++) cur += d1[tmp][i % tmp];\n\t\tprintf(""%d\\n"", sum - cur);\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 1]",2200,Let s distinguish the trains according to If the total times of maintenance and running don t exceed So we can find every date that the train of model begin or end maintenance in and we can maintain a differential sequence We can add 1 to the beginning date and minus 1 to the end date and the prefix sum of this sequence is the number of trains in maintenance If suppose the train of model is repaired at day For a date that the train of model is in maintenance if and only if Thus for each we can use an array of length to record the date of all trains that satisfy are in maintenance modulo And for one period of maintenance the total days aren t exceed So we can maintain in Thus the intended time complexity is and the intended memory complexity is 
There are three points marked on the coordinate plane The goal is to make a simple polyline without self intersections and self touches such that it passes through all these points Also the polyline must consist of only segments parallel to the coordinate axes You are to find the minimum number of segments this polyline may consist of ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 10\n\n#define TASK ""1""\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint x[N], y[N];\n\nbool check() {\n    for (int i = 0; i < 3; i++) if (y[(i + 1) % 3] == y[(i + 2) % 3]) {\n        if ((x[i] >= x[(i + 1) % 3] && x[i] >= x[(i + 2) % 3]) || (x[i] <= x[(i + 1) % 3] && x[i] <= x[(i + 2) % 3])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n//  freopen(TASK"".in"",""r"",stdin);   \n//  freopen(TASK"".out"",""w"",stdout);\n    for (int i = 0; i < 3; i++) cin >> x[i] >> y[i];\n    if ((x[0] == x[1] && x[1] == x[2]) || (y[0] == y[1] && y[1] == y[2])) {\n        cout << 1 << endl;\n    } else {\n        if (check()) {\n            cout << 2 << endl;\n            return 0;\n        }\n        for (int i = 0; i < 3; i++) swap(x[i], y[i]);\n        if (check()) {\n            cout << 2 << endl;\n            return 0;\n        }\n        cout << 3 << endl;\n    }\n}']","[0, 0, 1, 0, 0]",1700,Answer equals to one if all coordinates x or y of points are same When answer equals to two Let s iterate over all pairs of points Let first point in pair is beginning of polyline second point is end Only one or two such polylines with answer two exist If third point is on the polyline it belongs to rectangle with corners in first two points We can just check it Else answer equals to three We can build vertical lines which contains the most left and the most right point and horizontal line through third point If we erase some excess rays we will get polyline Solution 15550843 
Given an array of n integers a 1 a 2 ldots a n check if you can make this array sorted by using the following operation any number of times possibly zero An array is sorted if its elements are arranged in a non decreasing order select two indices i and j 1 le i j le n such that a i and a j have In other words one must be positive and one must be negative swap the of a i and a j For example if you select a i 3 and a j 2 then they will change to a i 3 and a j 2 Prof Slim saw that the problem is still too easy and isn t worth his time so he decided to give it to you to solve ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nint a[1000005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tcin >> a[i];\n\t\t\tif(a[i]<0) ++cnt;\n\t\t\ta[i]=max(a[i],-a[i]);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(i<=cnt) a[i]*=-1;\n\t\tint flag=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tif(a[i]<a[i-1]) flag=0;\n\t\tif(flag) cout << ""YES\\n"";\n\t\telse cout << ""NO\\n"";\n\t}\n\treturn 0;\n}']","[1, 0, 1, 0, 0]",800,We can notice that to make the array sorted we must move all the negative signs to the beginning of the array So let s say the number of negative elements is Then we must check that the first elements are non increasing and the remaining elements are non decreasing Complexity is 
You are given a string s consisting of lowercase Latin letters and and question marks Let the number of question marks in the string s be k Let s replace each question mark with one of the letters and Here we can obtain all 3 k possible strings consisting only of letters and For example if s then we can obtain the following strings Your task is to count the total number of subsequences in all resulting strings Since the answer can be very large print it modulo 10 9 7 A subsequence of the string t is such a sequence that can be derived from the string t after removing some possibly zero number of letters without changing the order of remaining letters For example the string contains two subsequences a subsequence consisting of letters at positions 2 5 6 and a subsequence consisting of letters at positions 3 5 6 ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll long long \n#define pb push_back\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define memf(a) memset(a,false,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define sz(a) (ll)a.size()\n#define F first\n#define S second\n#define INF 2000000000000000000\n#define endl ""\\n""\n#define _time_ 1.0 * clock() / CLOCKS_PER_SEC\n#define popcount(x) __builtin_popcountll(x)\n#define pll pair<ll,ll> \n#define ld long double\n\nconst int M=1000000007;\nconst int MM=998244353;\nconst long double PI = acos(-1);\n\nll power(ll b,ll e,ll m)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b%m,e/2,m)%m;\n    return power(b*b%m,e/2,m);\n}\nll power( ll b, ll e)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b,e/2);\n    return power(b*b,e/2);\n}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\ntemplate<typename T, typename U> ostream& operator<<(ostream &os, const pair<T, U> &p)\n{ \n    return os<<\'(\'<<p.F<< "",""<<p.S<<\')\'; \n}\n\n    \nconst int MOD=1000000007;\nstruct Mint {\n    int val;\n \n    Mint(long long v = 0) {\n        if (v < 0)\n            v = v % MOD + MOD;\n        if (v >= MOD)\n            v %= MOD;\n        val = v;\n    }\n \n    static int mod_inv(int a, int m = MOD) {\n        int g = m, r = a, x = 0, y = 1;\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        } \n        return x < 0 ? x + m : x;\n    } \n    explicit operator int() const {\n        return val;\n    }\n    Mint& operator+=(const Mint &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    Mint& operator-=(const Mint &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n           #if !defined(_WIN32) || defined(_WIN64)\n                return x % m;\n           #endif\n           unsigned x_high = x >> 32, x_low = (unsigned) x;\n           unsigned quot, rem;\n           asm(""divl %4\\n""\n            : ""=a"" (quot), ""=d"" (rem)\n            : ""d"" (x_high), ""a"" (x_low), ""r"" (m));\n           return rem;\n    }\n    Mint& operator*=(const Mint &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n    Mint& operator/=(const Mint &other) {\n        return *this *= other.inv();\n    }\n    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }\n    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }\n    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }\n    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }\n    Mint& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n    Mint& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }\n    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }\n    Mint operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n    bool operator==(const Mint &other) const { return val == other.val; }\n    bool operator!=(const Mint &other) const { return val != other.val; }\n    Mint inv() const {\n        return mod_inv(val);\n    }\n    Mint power(long long p) const {\n        assert(p >= 0);\n        Mint a = *this, result = 1;\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n \n            a *= a;\n            p >>= 1;\n        }\n        return result;\n    }\n    friend ostream& operator << (ostream &stream, const Mint &m) {\n        return stream << m.val;\n    }\n    friend istream& operator >> (istream &stream, Mint &m) {\n        return stream>>m.val;   \n    }\n};\n\n\nconst int N = 200005;\nstring s;\nint n;\n\nMint dp[N][3];\n\nint _runtimeTerror_()\n{\n    cin>>n>>s;\n    int cnt = 0;\n    for(int i=1;i<=n;++i)\n    {\n        dp[i][0] = dp[i-1][0];\n        dp[i][1] = dp[i-1][1];\n        dp[i][2] = dp[i-1][2];\n        char c = s[i-1];\n        if(s[i-1] != \'?\')\n        {\n            if(c==\'a\')\n                dp[i][0] += Mint(3).power(cnt);\n            else if(c==\'b\')\n                dp[i][1] += dp[i-1][0];\n            else if(c==\'c\')\n                dp[i][2] += dp[i-1][1];\n        }\n        else\n        {\n            dp[i][0] += Mint(3).power(cnt)+ 2*dp[i-1][0];\n            dp[i][1] += dp[i-1][0] + 2*dp[i-1][1];\n            dp[i][2] += dp[i-1][1] + 2*dp[i-1][2];\n        }\n        if(s[i-1]==\'?\')\n            ++cnt;\n    }\n    // for(int i=1;i<=n;++i)\n    // {\n    //     for(int j=0;j<3;++j)\n    //         cout<<dp[i][j]<<"" "";\n    //     cout<<""\\n"";\n    // }\n    cout<<dp[n][2]<<""\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    //cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']","[0, 0, 0, 1, 0]",2000,There are several more or less complicated combinatorial solutions to this problem but I will describe a dynamic programming one which I think is way easier to understand and to implement Suppose we have fixed the positions of and that compose the subsequence let these positions be and How many strings contain the required subsequence on these positions Obviously if some of these characters is already not a question mark and does not match the expected character on that position the number of strings containing the subsequence on that position is Otherwise since we have fixed three characters all question marks on other positions can be anything we want so the number of such strings is where is the number of question marks on positions other than and It allows us to write an solution by iterating on and and for every such triple calculating the number of strings containing the required subsequence on those positions But that s too slow Let s notice that for every such subsequence the number of strings containing it is where is the number of positions from that contain a question mark So for each integer from to let s calculate the number of subsequences matching that contain exactly question marks and that will allow us to solve the problem faster How can we calculate the required number of subsequences for every In my opinion the simplest way is dynamic programming let be the number of subsequences of that end up in position match first characters of and contain question marks The transitions in this dynamic programming are quadratic since we have to iterate on the next previous position from the subsequence but can be sped up to linear if we rewrite as the number of subsequences of that end up in position match first characters of and contain question marks Each transition is either to take the current character or to skip it so they can be modeled in and overall this dynamic programming solution works in 
A group of n dancers rehearses a performance for the closing ceremony The dancers are arranged in a row they ve studied their dancing moves and can t change positions For some of them a white dancing suit is already bought for some of them a black one and for the rest the suit will be bought in the future On the day when the suits were to be bought the director was told that the participants of the olympiad will be happy if the colors of the suits on the scene will form a palindrome A palindrome is a sequence that is the same when read from left to right and when read from right to left The director liked the idea and she wants to buy suits so that the color of the leftmost dancer s suit is the same as the color of the rightmost dancer s suit the 2nd left is the same as 2nd right and so on The director knows how many burls it costs to buy a white suit and how many burls to buy a black suit You need to find out whether it is possible to buy suits to form a palindrome and if it s possible what s the minimal cost of doing so Remember that dancers can not change positions and due to bureaucratic reasons it is not allowed to buy new suits for the dancers who already have suits even if it reduces the overall spending ,"['#include<bits/stdc++.h>\n#define mod 1000000007LL\n#define fi first\n#define se second\n#define mp make_pair\nusing namespace std;\ntypedef long long ll;\n\nint n,a,b,d[30],ans;\n\nvoid en()\n{\n    puts(""-1"");\n    exit(0);\n}\n\nint main()\n{\n    scanf(""%d %d %d"",&n,&a,&b);\n    //if(a<b) swap(a,b);\n\n    for(int i=0;i<n;i++) scanf(""%d"",&d[i]);\n    for(int i=0;i<n/2;i++)\n    {\n        if(d[i]==0)\n        {\n            if(d[n-i-1]==1) en();\n            if(d[n-i-1]==2) ans+=a;\n        }\n\n        if(d[i]==1)\n        {\n            if(d[n-i-1]==0) en();\n            if(d[n-i-1]==2) ans+=b;\n        }\n\n        if(d[i]==2)\n        {\n            if(d[n-i-1]==0) ans+=a;\n            if(d[n-i-1]==1) ans+=b;\n            if(d[n-i-1]==2) ans+=2*min(a,b);\n        }\n    }\n\n    if(n%2==1 && d[n/2]==2) ans+=min(a,b);\n\n    printf(""%d"",ans);\n}\n']","[1, 0, 0, 0, 0]",1000,Consider a pair of dancers located symmetrically with respect to the center of the stage If they already have different suits the answer is definitely impossible If they both have same suits they are fine If one of them doesn t have a suit buy him a matching one Finally if both don t have suits buy them two same suits of the cheaper color Also if is odd and the central dancer doesn t have a suit buy him a cheaper one 
You are given an array a consisting of n integers numbered from 1 to n You can perform the following operation no more than 3n times choose three integers i j and x 1 le i j le n 0 le x le 10 9 assign a i a i x cdot i a j a j x cdot i After each operation all elements of the array should be Can you find a sequence of no more than 3n operations after which all elements of the array are equal ,"['/**\n *    author:  tourist\n *    created: 27.09.2020 18:16:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n + 1);\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n      cin >> a[i];\n      sum += a[i];\n    }\n    if (sum % n != 0) {\n      cout << -1 << \'\\n\';\n      continue;\n    }\n    int avg = sum / n;\n    vector<tuple<int, int, int>> ret;\n    auto Do = [&](int i, int j, int x) {\n      assert(a[i] >= x * i);\n      ret.emplace_back(i, j, x);\n      a[i] -= x * i;\n      a[j] += x * i;\n    };\n    for (int i = 2; i <= n; i++) {\n      int r = (i - a[i] % i) % i;\n      Do(1, i, r);\n      assert(a[i] % i == 0);\n      Do(i, 1, a[i] / i);\n    }\n    for (int i = 2; i <= n; i++) {\n      Do(1, i, avg);\n    }\n    cout << ret.size() << \'\\n\';\n    for (auto& t : ret) {\n      cout << get<0>(t) << "" "" << get<1>(t) << "" "" << get<2>(t) << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","[1, 1, 0, 0, 0]",2000,Let be the sum of the array If is not divisible by then the answer is obviously Otherwise there always exists a solution which uses no more than queries We will solve this problem in two phases First phase gather the sum in Let s iterate over in increasing order If is divisible by we can immediately transfer it using one operation Otherwise we have to make it divisible by transferring from to Note that this operation does not break a condition on non negativity because all are initially positive This way we successfully finish this phase using at most operations Second phase distribute the sum across all elements Just iterate over all and make a transfer of from to This phase takes exactly operations Time complexity Space complexity 
Toad Mikhail has an array of 2 k integers a 1 a 2 ldots a 2 k Find two permutations p and q of integers 0 1 ldots 2 k 1 such that a i is equal to p i oplus q i for all possible i or determine there are no such permutations Here oplus denotes the bitwise XOR operation ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define maxN 5678\n\nmt19937 mrand(random_device{}());\n\nint k, a[maxN], posb[maxN], posc[maxN], b[maxN], c[maxN];\n\nint main() {\n\tscanf(""%d"", &k);\n\tint n = 1 << k;\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%d"", a + i);\n\t\ts ^= a[i];\n\t}\n\tmemset(posb, -1, sizeof(posb));\n\tmemset(posc, -1, sizeof(posc));\n\tauto nextInt = [&](int *pos) {\n\t\twhile (true) {\n\t\t\tint x = mrand() % n;\n\t\t\tif (pos[x] == -1)\n\t\t\t\treturn x;\n\t\t}\n\t};\n\tif (s != 0) {\n\t\tprintf(""Fou\\n"");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = nextInt(posb);\n\t\tposb[b[i]] = i;\n\t\tc[i] = a[i] ^ b[i];\n\t\tint which = 0;\n\t\tint idx = i;\n\t\twhile (1) {\n\t\t\tif (which == 0) {\n\t\t\t\tif (posc[c[idx]] == -1) {\n\t\t\t\t\tposc[c[idx]] = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tswap(posc[c[idx]], idx);\n\t\t\t\t\tc[idx] = nextInt(posc);\n\t\t\t\t\tposc[c[idx]] = idx;\n\t\t\t\t\tposb[b[idx]] = -1;\n\t\t\t\t\tb[idx] = a[idx] ^ c[idx];\n\t\t\t\t\twhich = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (posb[b[idx]] == -1) {\n\t\t\t\t\tposb[b[idx]] = idx;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tswap(posb[b[idx]], idx);\n\t\t\t\t\tb[idx] = nextInt(posb);\n\t\t\t\t\tposb[b[idx]] = idx;\n\t\t\t\t\tposc[c[idx]] = -1;\n\t\t\t\t\tc[idx] = a[idx] ^ b[idx];\n\t\t\t\t\twhich = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""Shi\\n"");\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%d "", b[i]);\n\tprintf(""\\n"");\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(""%d "", c[i]);\n\tprintf(""\\n"");\n}\n']","[0, 1, 0, 0, 0]",3100,If xor of all elements of the array is not zero then the answer is Fou Now let s assume that you have two permutations and when xored they are producing an array I will show that it is possible to change any two elements to elements with some transformation of the given permutations Let s change to Let s find such that If is equal to or then you can make some swaps to fix the array to make it satisfy for all Now you have at position at position at position Let s make some swaps at these positions to transform it to at position at position at position Now after you make these transition you will have and now you need to fix positions and and just process recursively Lemma this thing will end in operations Proof Let s assume that at some two moments you have coincided with some earlier let s check the first that moment For simplicity of the proof let s assume that numbers are moving like that at position at position at position So s are constant and s are changing now Obviously it is equivalent to the previous transformation Now assume that you had numbers at position at position 1 at position 2 and then you will make one transformation and everything will go to at position at position at position After that before you will be stuck into described earlier equality at position at position at position And after swapping with at position 3 at position 4 Let s look at 1 2 and 3 4 From 1 2 we can see From 3 4 we can see So but so it is a contradiction because is a permutation Ok using these operations it is pretty simple to get an arbitrary array Just start with two equal permutations And then make at the end you will have one element rest and it will be good because initially xor was zero My solution 
Barbara was late for her math class so as a punishment the teacher made her solve the task on a sheet of paper Barbara looked at the sheet of paper and only saw n numbers a 1 a 2 ldots a n without any mathematical symbols The teacher explained to Barbara that she has to place the available symbols between the numbers in a way that would make the resulting expression s value as large as possible To find out which symbols were available the teacher has given Barbara a string s which contained that information It s easy to notice that Barbara has to place n 1 symbols between numbers in total The expression must start with a number and all symbols must be allowed i e included in s Note that multiplication takes precedence over addition or subtraction addition and subtraction have the same priority and performed from left to right Help Barbara and create the required expression ,"[""#include <iostream>\n#include <vector>\n#include <string>\n\nconstexpr int N = 100005;\n\nint n;\nint a[N];\nstd::string s;\nbool vis[3], ans[N];\nint last[N], pre[N];\nlong long mul[N], f[N];\n\ninline void solve(int l, int r) {\n    while (l <= r && a[l] == 1) ans[l++] = 1;\n    while (l <= r && a[r] == 1) ans[--r] = 1;\n    if (l >= r) return;\n    mul[l - 1] = 1;\n    for (int i = l; i <= r; ++i) {\n        mul[i] = mul[i - 1] * a[i];\n        if (mul[i] > 1e16) return;\n    }\n    for (int i = l; i <= r; ++i)\n        if (a[i] == 1) {\n            last[i] = i;\n            if (i > l && a[i - 1] == 1) last[i] = last[i - 1];\n        }\n    std::vector<int> id;\n    id.push_back(l);\n    for (int i = l + 1; i < r; ++i)\n        if (a[i] > 1) id.emplace_back(i);\n        else if (a[i + 1] > 1) id.emplace_back(i);\n    id.push_back(r);\n    f[id[0]] = a[l];\n    pre[id[0]] = 0;\n    for (int i = 1; i < id.size(); ++i) {\n        f[id[i]] = mul[id[i]];\n        pre[id[i]] = 0;\n        if (last[id[i]] && f[id[i - 1]] + id[i] - id[i - 1] > f[id[i]]) {\n            f[id[i]] = f[id[i - 1]] + id[i] - id[i - 1];\n            pre[id[i]] = id[i - 1];\n        }\n        for (int j = 0; j < i; ++j)\n            if (f[id[j]] + mul[id[i]] / mul[id[j]] > f[id[i]]) {\n                f[id[i]] = f[id[j]] + mul[id[i]] / mul[id[j]];\n                pre[id[i]] = id[j];\n            }\n    }\n    for (int i = r; pre[i]; i = pre[i]) {\n        ans[pre[i]] = 1;\n        if (last[i] && pre[i] == last[i] - 1) for (int j = pre[i]; j <= i; ++j) ans[j] = 1;\n    }\n}\n\nint main() {\n    std::cin >> n;\n    for (int i = 1; i <= n; ++i) std::cin >> a[i];\n    std::cin >> s;\n    for (char i : s)\n        if (i == '+') vis[0] = 1;\n        else if (i == '*') vis[1] = 1;\n        else vis[2] = 1;\n    if (vis[0] && !vis[1]) {\n        for (int i = 1; i < n; ++i) std::cout << a[i] << '+';\n        std::cout << a[n] << '\\n';\n        return 0;\n    }\n    if (vis[1] && !vis[0] && !vis[2]) {\n        for (int i = 1; i < n; ++i) std::cout << a[i] << '*';\n        std::cout << a[n] << '\\n';\n        return 0;\n    }\n    if (vis[2] && !vis[0] && !vis[1]) {\n        for (int i = 1; i < n; ++i) std::cout << a[i] << '-';\n        std::cout << a[n] << '\\n';\n        return 0;\n    }\n    if (vis[1] && vis[2] && !vis[0]) {\n        for (int i = 1; i <= n; ++i)\n            if (!a[i])\n                ans[i - 1] = 1;\n        for (int i = 1; i < n; ++i) std::cout << a[i] << (ans[i] ? '-' : '*');\n        std::cout << a[n] << '\\n';\n        return 0;\n    }\n    int last = 0;\n    for (int i = 1; i <= n; ++i)\n        if (!a[i]) {\n            ans[i - 1] = ans[i] = 1;\n            solve(last + 1, i - 1);\n            last = i;\n        }\n    solve(last + 1, n);\n    for (int i = 1; i < n; ++i) std::cout << a[i] << (ans[i] ? '+' : '*');\n    std::cout << a[n] << '\\n';\n    return 0;\n}\n""]","[1, 0, 0, 1, 0]",2700,First let s solve the problem without the multiplication sign It is always beneficial for us to put a plus or a minus if there is no plus sign Now we will solve the problem when there is a sign to multiply The case when the plus sign is missing is very easy to solve We put the sign to multiply to the first zero then we put a minus sign in front of the zero and after the multiplication signs Let s consider the case when there is a plus sign and multiply Note that it is never beneficial for us to use the minus sign If there are zeros in the expression then we simply put plus signs between them and the expressions are split into other independent expressions Now you need to be able to solve an expression that has no zeros To begin with we take out all units at the beginning and at the end separately with plus signs The following solution is now proposed If the product of numbers is greater than or equal to then it is beneficial for us to put the multiplication sign everywhere Otherwise we can use dynamic programming because the number of numbers greater than one is no more than Dynamic programming will be one dimension is the most profitable answer if you put signs on the prefix Let us now stand at and want to go to this means that between the numbers at the th and th positions there will be a sign to multiply and after the th position there will be a sign a plus 
Bashar was practicing for the national programming contest Because of sitting too much in front of the computer without doing physical movements and eating a lot Bashar became much fatter Bashar is going to quit programming after the national contest and he is going to become an actor just like his father so he should lose weight In order to lose weight Bashar is going to run for k kilometers Bashar is going to run in a place that looks like a grid of n rows and m columns In this grid there are two one way roads of one kilometer length between each pair of adjacent by side cells one road is going from the first cell to the second one and the other road is going from the second cell to the first one So there are exactly 4 n m 2n 2m roads Let s take for example n 3 and m 4 In this case there are 34 roads It is the picture of this case arrows describe roads Bashar wants to run by these rules He starts at the top left cell in the grid In one move Bashar may go up the symbol down the symbol left the symbol or right the symbol More formally if he stands in the cell in the row i and in the column j i e in the cell i j he will move to in the case to the cell i 1 j in the case to the cell i 1 j in the case to the cell i j 1 in the case to the cell i j 1 He wants to run exactly k kilometers so he wants to make exactly k moves Bashar can finish in any cell of the grid He can t go out of the grid so at any moment of the time he should be on some cell Bashar doesn t want to get bored while running so he must visit the same road twice Bashar asks you if it is possible to run by such rules If it is possible you should tell him how should he run You should give him a steps to do and since Bashar can t remember too many steps a should not exceed 3000 In every step you should give him an integer f and a string of moves s of length at most 4 which means that he should repeat the moves in the string s for f times He will perform the steps in the order you print them For example if the steps are 2 3 then the moves he is going to move are Can you help him and give him a correct sequence of moves such that the total distance he will run is equal to k kilometers or say that it is impossible ,"['#include <bits/stdc++.h>\n\nint n, m, k;\nstd::vector<std::pair<int, char>> vec, ans;\n\ninline void insert(int x, char c) {\n    if (x > 0) { vec.push_back({x, c}); }\n}\ninline void insertt(int x, char c) {\n    if (x > 0) { ans.push_back({x, c}); }\n}\n\nbool solve() {\n    for (auto i : vec) {\n        insertt(std::min(i.first, k), i.second);\n        k -= std::min(i.first, k);\n    }\n    return k <= 0;\n}\n\nint main() {\n    scanf(""%d%d%d"", &n, &m, &k);\n    for (int i = 1; i < n; i++) {\n        insert(m - 1, \'R\');\n        insert(m - 1, \'L\');\n        insert(1, \'D\');\n    }\n    insert(m - 1, \'R\');\n    for (int i = 1; i < m; i++) {\n        insert(n - 1, \'U\');\n        insert(n - 1, \'D\');\n        insert(1, \'L\');\n    }\n    insert(n - 1, \'U\');\n    if (!solve()) {\n        printf(""NO\\n"");\n    } else {\n        printf(""YES\\n"");\n        printf(""%d\\n"", ans.size());\n        for (auto i : ans) {\n            printf(""%d %c\\n"", i.first, i.second);\n        }\n    }\n    return 0;\n}']","[0, 0, 1, 0, 0]",2000,A strategy that guarantees that you can visit all the edges exactly once 1 keep going right until you reach the last column in the first row 2 keep going left until you reach the first column in the first row again 3 go down 4 keep going right until you reach the last column in the current row 5 keep going up down left until you reach the first column in the current row again 6 if you were at the last row just keep going up until you reach the top left cell again otherwise repeat moves 3 4 and 5 We need only to take the first moves and we can print them in about steps complexity code https ideone com PkCMZM 
Koa the Koala and her best friend want to play a game The game starts with an array a of length n consisting of non negative integers Koa and her best friend move in turns and each have initially a score equal to 0 Koa starts Let s describe a move in the game During his move a player chooses any element of the array and removes it from this array xor ing it with the current score of the player More formally if the current score of the player is x and the chosen element is y his new score will be x oplus y Here oplus denotes bitwise XOR operation Note that after a move element y is removed from a The game ends when the array is empty At the end of the game the winner is the player with the maximum score If both players have the same score then it s a draw If both players play optimally find out whether Koa will win lose or draw the game ,"['/**\n *    author:  tourist\n *    created: 24.07.2020 17:42:08       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    int x = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      x ^= a[i];\n    }\n    if (x == 0) {\n      cout << ""DRAW"" << \'\\n\';\n      continue;\n    }\n    int bit = 30;\n    while (!(x & (1 << bit))) {\n      --bit;\n    }\n    int k0 = 0, k1 = 0;\n    for (int y : a) {\n      if (y & (1 << bit)) {\n        k1 += 1;\n      } else {\n        k0 += 1;\n      }\n    }\n    assert(k1 % 2 == 1);\n    if (k0 % 2 == 0 && k1 % 4 == 3) {\n      cout << ""LOSE"" << \'\\n\';\n    } else {\n      cout << ""WIN"" << \'\\n\';\n    }\n  }\n  return 0;\n}\n']","[1, 1, 0, 1, 0]",1900,Let be the number of ones and be the numbers of zeros in the most significant bit of the numbers if is even whatever decision players take both will end with the same score in that bit so go to the next bit if it doesn t exist the game ends in a draw Indeed the parity of the result of both players will be the same since is even if is odd one of the players ends with in this bit and the other with the player with in this bit wins the game because the well know inequality for so the game is equivalent to play on an array of ones and zeros Lemma The second player wins iff and otherwise the first player wins Proof We know that so can be or if the first player can choose one and the remaining number of is a multiple of if the first player always repeats the last move of the second player if and the second player takes the last both players start taking all the remaining ones then both ends with the same number of ones which divided by is even and therefore the first player wins if if the second player can repeat the last move of the first player always so the first ends with a even numbers of and therefore the second player wins if the first player takes one and the game now is exactly the previous case with the first player as the second player Time complexity per testcase 
You have unweighted tree of n vertices You have to assign a weight to each edge so that the following condition would hold For every two different leaves v 1 and v 2 of this tree bitwise XOR of weights of all edges on the simple path between v 1 and v 2 has to be equal to 0 Note that you can put positive integers like 10 10 10 It s guaranteed that such assignment always exists under given constraints Now let s define f as in assignment In this example assignment is valid because bitwise XOR of all edge weights between every pair of leaves is 0 f value is 2 here because there are 2 distinct edge weights 4 and 5 In this example assignment is invalid because bitwise XOR of all edge weights between vertex 1 and vertex 6 3 4 5 4 is not 0 What are the minimum and the maximum possible values of f for the given tree Find and print both ,"['/**\n *    author:  tourist\n *    created: 12.04.2020 17:16:56       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass forest : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  forest(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    assert(id < n - 1);\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n\ntemplate <typename T>\nclass dfs_forest : public forest<T> {\n public:\n  using forest<T>::edges;\n  using forest<T>::g;\n  using forest<T>::n;\n\n  vector<int> pv;\n  vector<int> pe;\n  vector<int> order;\n  vector<int> pos;\n  vector<int> end;\n  vector<int> sz;\n  vector<int> root;\n  vector<int> depth;\n  vector<T> dist;\n\n  dfs_forest(int _n) : forest<T>(_n) {\n  }\n\n  void init() {\n    pv = vector<int>(n, -1);\n    pe = vector<int>(n, -1);\n    order.clear();\n    pos = vector<int>(n, -1);\n    end = vector<int>(n, -1);\n    sz = vector<int>(n, 0);\n    root = vector<int>(n, -1);\n    depth = vector<int>(n, -1);\n    dist = vector<T>(n);\n  }\n\n  void clear() {\n    pv.clear();\n    pe.clear();\n    order.clear();\n    pos.clear();\n    end.clear();\n    sz.clear();\n    root.clear();\n    depth.clear();\n    dist.clear();\n  }\n\n private:\n  void do_dfs(int v) {\n    pos[v] = (int) order.size();\n    order.push_back(v);\n    sz[v] = 1;\n    for (int id : g[v]) {\n      if (id == pe[v]) {\n        continue;\n      }\n      auto &e = edges[id];\n      int to = e.from ^ e.to ^ v;\n      depth[to] = depth[v] + 1;\n      dist[to] = dist[v] + e.cost;\n      pv[to] = v;\n      pe[to] = id;\n      root[to] = (root[v] != -1 ? root[v] : to);\n      do_dfs(to);\n      sz[v] += sz[to];\n    }\n    end[v] = (int) order.size() - 1;\n  }\n\n  void do_dfs_from(int v) {\n    depth[v] = 0;\n    dist[v] = T{};\n    root[v] = v;\n    pv[v] = pe[v] = -1;\n    do_dfs(v);\n  }\n\n public:\n  void dfs(int v, bool clear_order = true) {\n    if (pv.empty()) {\n      init();\n    } else {\n      if (clear_order) {\n        order.clear();\n      }\n    }\n    do_dfs_from(v);\n  }\n\n  void dfs_all() {\n    init();\n    for (int v = 0; v < n; v++) {\n      if (depth[v] == -1) {\n        do_dfs_from(v);\n      }\n    }\n    assert((int) order.size() == n);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  dfs_forest<int> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g.add(x, y);\n  }\n  int root = 0;\n  while (g.g[root].size() < 2) {\n    ++root;\n  }\n  g.dfs(root);\n  vector<int> has(2, 0);\n  for (int i = 0; i < n; i++) {\n    if (g.g[i].size() == 1) {\n      has[g.depth[i] % 2] += 1;\n    }\n  }\n  cout << ((has[0] && has[1]) ? 3 : 1) << "" "";\n  set<pair<int, int>> s;\n  for (auto& e : g.edges) {\n    int x = e.from;\n    int y = e.to;\n    x = (g.g[x].size() == 1 ? -1 : x);\n    y = (g.g[y].size() == 1 ? -1 : y);\n    s.emplace(min(x, y), max(x, y));\n  }\n  cout << s.size() << \'\\n\';\n  return 0;\n}\n']","[1, 1, 0, 0, 0]",1800,Let s make an easy and good construction which can solve actual problem Now reroot this tree at any leaf like picture below Our goal in this construction is we are trying to make for all two leaves and to satisfy First let s solve about minimum value You can prove that minimum value of is at most by following construction Since we pick any leaf as root root is not at the top in this picture Weight of edges are only determined by degree of two vertices and whether that edge is connected to leaf or not So answer for minimum value is at most If there is any construction such that then it is always possible to have construction of Because if then there should be even number of edges for each weight and you can simply change all weights them to single value without violating validity of edge weight assignment If you want to check validity of assignment then you can simply check if all leaves have same parity of distance from root Because distances between all nodes should be even Now let s solve about maximum value You can solve maximum value of by following construction So for each non root vertex assign weight to edge between and by followings is parent of vertex If is not leaf then assign as weight Otherwise assign as weight This will differentize all edges weights except for multiple leaves s edges which are connected to single vertex because every non leaf vertex have different weights of edge to its parent So the answer for maximum value is where is number of edges in this tree is number of leaves in this tree is number of non leaves which has at least one leaf as its neighbor Time complexity is Update There is an another way to approach provided by Darooha If you label vertices instead of edges where all leaves have same label and none of neighbors have same label then you can consider edge weight as xor of two vertices labels so this is basically equivalent to original problem Now for minimum you can see that labelling to leaves and to non leaves are enough so you can prove minimum value of is at most In same manner you can try parity checking to check if value can be or not For maximum assign to all leaves and assign all different values to non leaf vertices then you can see all edge weights except leaves connected to same vertex are different 
As he qualified for IOI this year Little Ericyi was given a gift from all his friends a tree of n nodes On the flight to IOI Little Ericyi was very bored so he decided to play a game with Little Yvonne with his new tree First Little Yvonne selects two not necessarily different nodes a and b on the tree without telling Ericyi and then gives him a hint f which is some node on the path from a to b Then Little Ericyi is able to ask the following question repeatedly If I rooted the tree at node r Ericyi gets to choose r what would be the Lowest Common Ancestor of a and b Little Ericyi s goal is to find the nodes a and b and report them to Little Yvonne However Little Yvonne thought this game was too easy so before he gives the hint f to Little Ericyi he also wants him to first find the maximum number of queries required to determine a and b over all possibilities of a b and f assuming Little Ericyi plays optimally Little Ericyi defines an optimal strategy as one that makes the minimum number of queries Of course once Little Ericyi replies with the maximum number of queries Little Yvonne will only let him use that many queries in the game The tree a b and f are all fixed before the start of the game and do not change as queries are made ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << endl; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\nint N;\nvi adj[MX];\nint par[MX], depth[MX];\nint dp_sub[MX], op_query_sub[MX];\nint dp_without[MX], op_query_without[MX];\n\nvoid dfs(int x) { // if we know ans is in subtree of x, >= 1 query\n\tdp_sub[x] = 1; op_query_sub[x] = x;\n\tdepth[x] = depth[par[x]]+1;\n\tvpi child_dp;\n\teach(y,adj[x]) if (y != par[x]) {\n\t\tpar[y] = x;\n\t\tdfs(y);\n\t\tchild_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(child_dp));\n\tF0R(i,sz(child_dp)) {\n\t\tckmax(dp_sub[x],child_dp[i].f+i);\n\t\tif (i == 0) op_query_sub[x] = op_query_sub[child_dp[i].s];\n\t}\n}\n\nint get_opt_query(int x, int p) {\n\tassert(x && p);\n\tif (par[x] == p) {\n\t\tassert(op_query_sub[x]);\n\t\treturn op_query_sub[x];\n\t} else {\n\t\tassert(par[p] == x);\n\t\tassert(op_query_without[p]);\n\t\treturn op_query_without[p];\n\t}\n}\n\nvoid dfs2(int x) {\n\tdbg(""DFS2"",x);\n\tvpi child_dp;\n\teach(y,adj[x]) {\n\t\tif (y == par[x]) child_dp.pb({dp_without[x],y});\n\t\telse child_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(child_dp));\n\teach(t,child_dp) assert(t.f);\n\t// dbg(""GOT CHILD DP"",x,child_dp);\n\tvi pref(sz(child_dp)+1);\n\tvi suf(sz(child_dp)+1);\n\tF0R(i,sz(child_dp)) {\n\t\tpref[i+1] = max(pref[i],child_dp[i].f+i);\n\t}\n\tR0F(i,sz(child_dp)) {\n\t\tsuf[i] = max(suf[i+1],child_dp[i].f+i-1);\n\t}\n\tF0R(i,sz(child_dp)) {\n\t\tint y = child_dp[i].s;\n\t\tif (y != par[x]) {\n\t\t\tdp_without[y] = max(pref[i],suf[i+1]);\n\t\t\tif (dp_without[y] == 0) {\n\t\t\t\tassert(x == 1 && sz(adj[x]) == 1);\n\t\t\t\t// dbg(""LINE CASE"");\n\t\t\t\tdp_without[y] = 1;\n\t\t\t\top_query_without[y] = x;\n\t\t\t} else {\n\t\t\t\tif (i) op_query_without[y] = get_opt_query(child_dp[0].s,x);\n\t\t\t\telse {\n\t\t\t\t\tassert(i+1 < sz(child_dp));\n\t\t\t\t\top_query_without[y] = get_opt_query(child_dp[1].s,x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// dbg(""GEN DP WITHOUT"",y);\n\t\t\tassert(dp_without[y]);\n\t\t\tdfs2(y);\n\t\t}\n\t}\n}\n\nint queries_left;\n\nint query(int i) {\n\tassert(queries_left);\n\t--queries_left;\n\tps(""?"",i);\n\tints(x); \n\trtn x;\n}\n\nvoid finish(int ans) {\n\tps(""!"",ans);\n\texit(0);\n}\n\nvpi get_adj_dp(int x) {\n\tvpi adj_dp;\n\teach(y,adj[x]) {\n\t\tif (y == par[x]) adj_dp.pb({dp_without[x],y});\n\t\telse adj_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(adj_dp));\n\treturn adj_dp;\n}\n\nvpi get_adj_queries(int x) { // return {vert, vertex to query}\n\tvpi adj_dp;\n\teach(y,adj[x]) {\n\t\tif (y == par[x]) adj_dp.pb({dp_without[x],y});\n\t\telse adj_dp.pb({dp_sub[y],y});\n\t}\n\tsort(rall(adj_dp));\n\teach(t,adj_dp) {\n\t\tswap(t.s,t.f);\n\t\tt.s = get_opt_query(t.f,x);\n\t}\n\treturn adj_dp;\n}\n\nvi endpoints;\n\nvb marked;\n\n// void process_query(int x, int y, int z) {\n// \tvi path = path_to(y,x);\n// \tif (z == x) {\n// \t\tmarked[path[sz(path)-2]] = 1;\n// \t}\n// }\n\nvi path_to(int a, int b) {\n\tvi st, en;\n\twhile (a != b) {\n\t\tif (depth[a] > depth[b]) {\n\t\t\tst.pb(a);\n\t\t\ta = par[a];\n\t\t} else {\n\t\t\ten.pb(b);\n\t\t\tb = par[b];\n\t\t}\n\t}\n\tst.pb(b);\n\treverse(all(en));\n\tst.ins(end(st),all(en));\n\treturn st;\n}\n\nvoid solve_subtree(int x, int p) {\n\tassert(marked.at(p));\n\tauto deal_path = [&](int y, int z) {\n\t\t// dbg(""DEAL PATH"",y,z);\n\t\tvi path = path_to(y,x);\n\t\tint ind = 0;\n\t\twhile (path.at(ind) != z) ++ind;\n\t\tx = path.at(ind);\n\t\tif (ind) marked[path.at(ind-1)] = 1;\n\t\tif (ind+1 < sz(path)) marked[path.at(ind+1)] = 1;\n\t};\n\t{\n\t\tint y = get_opt_query(x,p);\n\t\tint z = query(y); if (z == p) return;\n\t\tdeal_path(y,z);\n\t}\n\twhile (1) {\n\t\tassert(!marked.at(x));\n\t\tvpi cands;\n\t\t{\n\t\t\tvpi queries = get_adj_queries(x);\n\t\t\teach(t,queries) if (!marked.at(t.f)) cands.pb(t);\n\t\t}\n\t\tdbg(""FOUND"",x,cands);\n\t\tbool found = 0;\n\t\teach(t,cands) {\n\t\t\tint y = t.s; int z = query(y);\n\t\t\tif (z == x) continue;\n\t\t\tdeal_path(y,z);\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (found) continue;\n\t\tendpoints.pb(x); return;\n\t}\n}\n\nvoid solve(int f) {\n\tvpi v = get_adj_dp(f);\n\teach(t,v) {\n\t\tsolve_subtree(t.s,f);\n\t\tif (sz(endpoints) == 2) break;\n\t}\n\twhile (sz(endpoints) < 2) endpoints.pb(f);\n\tps(""!"",endpoints[0],endpoints[1]);\n}\n\nint main() {\n\tre(N);\n\trep(N-1) {\n\t\tints(u,v);\n\t\tadj[u].pb(v), adj[v].pb(u);\n\t}\n\tdfs(1);\n\tdfs2(1);\n\tint ans = 0;\n\tFOR(x,1,N+1) {\n\t\tvpi adj_dp = get_adj_dp(x);\n\t\tF0R(i,sz(adj_dp)) {\n\t\t\tckmax(ans,adj_dp[i].f+i);\n\t\t\tif (i > 0) ckmax(ans,adj_dp[i].f+i+adj_dp[0].f-1);\n\t\t}\n\t}\n\t// FOR(x,1,N+1) dbg(x,op_query_sub[x],op_query_without[x]);\n\tps(ans);\n\tints(f);\n\tmarked = vb(N+1);\n\tmarked.at(f) = 1;\n\tqueries_left = ans;\n\tsolve(f);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 0, 0, 1, 0]",3500,For now let s only look at finding for fixed We will expand for all later We know that is on the path from to Let us root the tree at Thus we know that the path will pass through the root and that there are exactly non negative length chains beginning at the root With that in mind let s take a look at what a question r really does What happens if is on the path from to In this case we obtain as the answer What happens if is not on the path from to In this case we obtain the node to on the path from to Let s try to find one endpoint of one of these chains first Consider the following dynamic programming structure Let denote the minimum number of questions required to solve the subtree rooted at By solve we mean to determine if the endpoint of a chain is in the subtree or not and if it is in the subtree the exact node The base case is pretty obvious For a leaf node it will take exactly question to solve a leaf node If the endpoint of the chain does indeed end at the leaf node then a question will return the leaf node Otherwise it ll return an ancestor of the leaf Let s move on to a non base case at a node Let s call the most expensive child of as the child with the largest i e takes the most number of questions to solve For now assume we know that an endpoint exists in the subtree rooted at and is not Thus we will need to iterate through each child to determine in which child s subtree the endpoint exists We will need to use one question per child However note that not all of these questions count towards our question count There are two cases In the current child we are exploring the endpoint does exist there In this case the question we used does not count towards our question count We can use a question from the child s question count This may seem a bit strange but if we query correctly then in the same time we check if the endpoint exists in the child s subtree we also process the most expensive child of the child and determine if the endpoint exist in that child of the child s subtree In the current child we are exploring the endpoint doesn t exist there In this case the question we used must count towards our question count We could consider this a wasted question as we didn t learn anything new about where the endpoint is just that it s not in this child Now in which order should be explore the children We can greedy this Recall that any wasted questions count towards our question count Thus for more expensive children we want to have wasted less questions when we get to the child as in the case the endpoint does exist there we would need even more questions adding the wasted questions to where is the child This gives us the following idea To determine if the indexed child of contains the endpoint we would need to waste questions If the endpoint does exist in we would need to use a total of questions to solve the subtree rooted at Since we are trying to find the worst case we want to order the children of such as to minimize the maximum of all The optimal ordering is the non increasing order of The transition is thus where the values are sorted in non increasing order and are the children of Now wait We haven t handled the case where the endpoint doesn t exist in or the case where the endpoint is yet Turns out both of these cases are already handled for us We only need to be a bit careful when we actually perform the interaction later on If the endpoint doesn t exist in we would have already realized when one of the questions to a child of returns an ancestor of This question count won t be lost though It will simply be counted towards a wasted question for one of the ancestors of If the endpoint is then all of the questions to a child of will return not a ancestor of Thus we will know that the endpoint is with exactly wasted questions Notice however that by the nature of the transition Thus this case will never be our worst case so we can ignore it for the dynamic programming We now have the dynamic programming complete but notice that it s only for the endpoint of one chain At our root there are two chains with two endpoints Thus our final answer won t be simply taking It will require a bit more computation For now assume that both endpoints are not i e both chains have positive length Following a similar analysis as the dynamic programming transition we have that for any child that does not contain either chain endpoint we would need to waste a question Once again the optimal ordering is to process in non increasing order However adding to the child is no longer correct Consider the following observations When processing a child that doesn t contain a chain that child only takes one question to determine that chains are not in that child For the first child that we know contains a chain we don t waste a question This question is included in that child s question count With observation we are basically figuring out the first chain s endpoint for free There are no wasted questions as all wasted questions will be counted for the second chain With observation we have that adding wasted questions is no longer correct We only waste questions for the child as one of the processed children contains the first chain and thus doesn t waste a question Thus for the root our formula is where the values are sorted in non increasing order and is the children of Note that this formula has an worst case for a star graph so we will need to optimize it Our optimized formula is where the values are sorted in non increasing order and is the children of Once again with a similar analysis as what was done for the computation the case that one or both chains have a zero length will never be the worst case and so we can ignore it for the dynamic programming However the case must still be handled during interaction Recall that the above was for a fixed To find the maximum for all we can perform a tree walk When transitioning from one root to an adjacent root use a prefix and suffix max array to compute ignoring the that is the new root Both max arrays should store not Remember to subtract from the suffix array values as there is one less wasted question If you understood the initial dynamic programming computation for determining the theoretical maximum the interaction should be relatively straightforward and so we will leave it as an exercise for the reader Be careful when handling the special cases that were ignored during the dynamic programming The final time complexity is and memory complexity is 
Dima is a beginner programmer During his working process he regularly has to repeat the following operation again and again to remove every second element from the array One day he has been bored with easy solutions of this problem and he has come up with the following extravagant algorithm Let s consider that initially array contains numbers from to and the number is located in the cell with the index Indices are numbered starting from one and other cells of the array are empty Each step Dima selects a non empty array cell with the maximum index and moves the number written in it to the nearest empty cell to the left of the selected one The process continues until all numbers will appear in the first cells of the array For example if the array is changing as follows You have to write a program that allows you to determine what number will be in the cell with index after Dima s algorithm finishes ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:336777216"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define Se second\n#define Fi first\n\nint main() {\n\tll N, Q;\n\tscanf(""%lld %lld"", &N, &Q);\n\twhile (Q--) {\n\t\tll t;\n\t\tscanf(""%lld"", &t);\n\n\t\tll ans = 0;\n\t\tll x = N, y = t;\n\t\twhile (x >= 2) {\n\t\t\tif (x % 2 == 0) {\n\t\t\t\tif (y % 2 == 1) {\n\t\t\t\t\tans += (y + 1) / 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans += x / 2;\n\t\t\t\tx /= 2, y /= 2;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (y % 2 == 1) {\n\t\t\t\t\tans += (y + 1) / 2;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans += (x + 1) / 2;\n\t\t\t\tx /= 2, y /= 2;\n\t\t\t\ty--;\n\t\t\t\tif (y == 0) y = x;\n\t\t\t}\n\t\t}\n\t\tif (x == 1) ans++;\n\t\tprintf(""%lld\\n"", ans);\n\t}\n}']","[0, 1, 0, 0, 0]",1700,In odd position value will be set For even position let s find out position from which value has arrived and iterate over such position until we will arrive to odd position for which we know answer At the moment of jumping to cell there are elements to the right of the position So there are elements to the right of this position and jump to cell was done from position During each such jump length of jump decreases at least by 2 times so there are no more than jumps and solution works in 
A ticket is a non empty string of digits from 1 to 9 A ticket is such a ticket that it has an even length the sum of digits in the first half is equal to the sum of digits in the second half You are given n ticket pieces s 1 s 2 dots s n How many pairs i j for 1 le i j le n are there such that s i s j is a ticket Note that it s possible that i j Here the operator denotes the concatenation of the two strings For example if s i is and s j is then s i s j is ,"['#include <bits/stdc++.h>\n#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?""YES\\n"":""Yes\\n""); else cout<<(upp?""NO\\n"":""No\\n"");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<\'{\';for(int i=0;i<(int)p.size();i++){if(i){cout<<"","";}cout<<\'""\'<<p[i]<<\'""\';}cout<<""}\\n"";}\nelse{if(ty==1){cout<<p.size()<<""\\n"";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<"" "";cout<<p[i];}cout<<""\\n"";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    //cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    int N;\n\tcin>>N;\n\tvector<string> S(N);\n\trep(i,0,N) cin>>S[i];\n\tauto f=[&](int a,string S) -> int {\n\t\tint K=0;\n\t\trep(i,0,S.size()){\n\t\t\tif(i<a) K+=S[i]-\'0\';\n\t\t\telse K-=S[i]-\'0\';\n\t\t}\n\t\treturn K;\n\t};\n\tll ans=0;\n\tfor(int len=2;len<=10;len+=2){\n\t\tvector<map<int,int>> m(6);\n\t\trep(i,0,N){\n\t\t\treverse(all(S[i]));\n\t\t\tm[S[i].size()][f(len/2,S[i])]++;\n\t\t}\n\t\trep(i,0,N){\n\t\t\treverse(all(S[i]));\n\t\t\tint v=f(len/2,S[i]);\n\t\t\tint a=len-(int)S[i].size();\n\t\t\tif(1<=a&&a<=5) ans+=m[a][v];\n\t\t}\n\t}\n\tcout<<ans<<""\\n"";\n}']","[0, 1, 1, 1, 0]",1400,There is an obvious approach iterate over the first part the second part and check the sum In order to improve it let s try to get rid of the second iteration Consider the case where the first part is longer or equal than the second part So we still iterate over the first part in However instead of iterating over the exact second part let s just iterate over its length Now we know the total length of the parts but not their sums of digits Hmm not exactly By fixing the longer part we actually know what the required sum of each half should be It s fully inside the first part However this first part also contains some digits that belong to the second half So if the sum of the second part was the total sum of the second half would be these digits plus Let be the total length of the ticket the length of the fixed first part plus the fixed length of the second part Let be the sum of the first digits of the first part and be the sum of its remaining digits Then Rewrite into Thus we just know what should be the sum of the second half And every ticket part that is exactly of the fixed length and has sum exactly will form a lucky ticket with the fixed part So we have to precalculate which is the number of ticket parts that have length and sum and use that structure to speed up the solution The mirror case where the second part is strictly longer than the first part can be handled similarly Overall complexity 
You are given a correct solution of the sudoku puzzle If you don t know what is the sudoku you can read about it here The picture showing the correct sudoku solution Blocks are bordered with bold black color Your task is to change 9 elements of this field i e choose some 1 le i j le 9 and change the number at the position i j to any other number in range 1 9 to make it The is the 9 times 9 field in which Any number in this field is in range 1 9 each row contains at least two equal elements each column contains at least two equal elements each 3 times 3 block you can read what is the block in the link above contains at least two equal elements It is guaranteed that the answer exists You have to answer t independent test cases ,"['#include<bits/stdc++.h>\n#define IOS ios_base::sync_with_stdio(false),cin.tie(NULL)\n#define fi first\n#define se second\n#define  all(d) d.begin(),d.end()\n#define allr(d) d.rbegin(),d.rend()\n#define For(i,d,c) for(int i = d;i <= c;++i)\nstd::mt19937 rgn(std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace io\n{\n\ttemplate<typename T> inline void read(T&a){\n\t\tint c = getchar(),sign = 0;\n\t\ta = 0;\n\t\twhile(c < \'0\' || c >\'9\') sign += (c == \'-\'),c = getchar();\n\t\twhile (c >=\'0\' && c <=\'9\') a = (a << 1) + (a << 3) + c-48,c = getchar();\n\t\tif (sign&1) a = -a;\n\t}\n\ttemplate<typename T,typename... _T>\n\tinline void read(T&a,_T& ...argc)\n\t{\n\t\tread(a);read(argc...);\n\t}\n\ttemplate<typename T>\n\tinline void Write(T a)\n\t{\n\t\tif (a > 9) Write(a/10);\n\t\tputchar(a % 10 + \'0\');\n\t}\n\ttemplate<typename T>\n\tinline void write(T a,char ch = \' \')\n\t{\n\t\tif (a < 0) putchar(\'-\'),a = -a;\n\t\tWrite(a);\n\t\tputchar(ch);\n\t}\n\ttemplate<typename T> inline void Min(T&a,T b){if (a > b) a = b;}\n\ttemplate<typename T> inline void Max(T&a,T b){if (a < b) a = b;}\n\ttemplate<typename T,typename... _T> inline void Min(T&a,T b,_T ...c){Min(a,b);Min(a,c...);}\n\ttemplate<typename T,typename... _T> inline void Max(T&a,T b,_T ...c){Max(a,b);Max(a,c...);}\n}\nusing namespace io;\nconst int maxn= 1e6 + 3;\nconst int N = 4e5 + 3;\nconst int mod= 1e9 + 7 ;\nint n,m,q;\nint dem[N],id[N],chot[N],a[N],b[N];\nint k,h;\nll t[N + 3];\nstring  s;\nbool kt[N];\nmap<long long,int> maps;\nvector<int> edge[N];\nmap<int,int> ::iterator it;\ntemplate<typename T>\nvoid answer(T x) {cout << x;exit(0);}\nvoid putstring(string x,char ch = \' \') {for (char c:x) putchar(c);putchar(ch);}\n\nint main() {\n\tIOS;\n\tcin >> q;\n\tvector<pair<int,int>> can;\n\tcan.emplace_back(0,0);\n\tcan.emplace_back(1,3);\n\tcan.emplace_back(2,6);\n\tcan.emplace_back(3,1);\n\tcan.emplace_back(4,4);\n\tcan.emplace_back(5,7);\n\tcan.emplace_back(6,2);\n\tcan.emplace_back(7,5);\n\tcan.emplace_back(8,8);\n\twhile (q--) {\n\t\tvector<string> s(9);\n\t\tfor (int i = 0;i < 9;i++) cin >> s[i];\n\t\tfor (auto&x : can) {\n\t\t\tint value = s[x.first][x.second] - \'0\';\n\t\t\tvalue++;\n\t\t\tif (value > 9) value = 1;\n\t\t\ts[x.first][x.second] = char(value + \'0\');\n\t\t}\n\t\tfor (int i = 0; i < 9;i++) {\n\t\t\tcout << s[i] <<""\\n"";\n\t\t}\n\t}\n}\n\n/*********************************************************************************************************************************************************************************************************\n *ti;.                               .:,:i:          .:,;itt;:      GLDEEGEEEEEEEEEEEEEEEEEEDEEEEEEEEEEE#W#WEKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKKKKKKG.     .::.      f:,...,ijLGDDDDDDDDEEEEEE *\n *ti;.                               .:,:i:            :,;;iti,    :fDDEEEEEEEEEEEEEEEKEEEEDEEEEEEEEEEEW##WEEEKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWWKKKKKKEG     .::.       .f,::,ijLGDDDDDDDDEEEEEE *\n *ti;.                               .:,:i:             .,,;iti;.  LDDEEEEEEEEEEKEEEEWEEEDDEEEEEEEEEEE#WWWEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWKKKKKEDj    .::.        .:L;;ijfGDDDDDDDDDEEEEE *\n *ti;.                               .:,:i:              .:,;;iii:LLDEEEEEEEEEEEKEEEEEEEEDEEEEEEEEEEEW#WWEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWKWWWWWWWWWWWWWWKKKKKKKEL    .::.         .:;LijLGGDDDDDDDDEEEEE *\n *ti;.                               .:,:;:                :,;;ittfDEEEEEEEEEEEEEEEEKEEEGEEEEEEEEEEEKWWWEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWKKKKKKKELj   .::.          :,;jffGGDDDDDDDDDEEEE *\n *ti;.                               .:,:i:                 .,;;tGGDEEEEEEEEEEEKEEEKEEEDEEEEEEEEEEEEWWWEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWKWWWWWWKKKKKKKEEL   .::.          .:;itDGGDDDDDDDDDEEEE *\n *ti;.                               .:::;:                   :;ifDEEEEEEEEEEEEKEEEKEEEEEEEEEEEEEEEWWWEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WWWKKKKKKKKEEf   .::.           :,itfGEDDDDDDDDDDDEE *\n *ti;.                               .:::;:                    :GGEEEEEEEEEEEKEKEEKEEEEEEEEEEEEEEEEWWEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKKEEDG  .::.           .,;jfLGKDLDDDDDDEEDD *\n *ti;.                               .:::;:                     fDEEEEEEKKKKKKKKKEKEEEEEEEEEEEEEEE#WEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#KKKKKKKKKKEEf .:::.           .,;tfLGDEDDDDDDDDEEE *\n *ti;.                                :::;:                    fDEEEEEEKKKKKKKKKKWKEEEEEEEEEEEEEEEWKEEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKKKEEft :::.           .,;tfLGDDDKDDDDDDDDD *\n *ti;.                                .::;:                    fDEEEEEEKKKKKKKWKKKKKEEEEEEEEEEEEE#WEEWEEEEEDEEDEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKEEGG :,:.           .,;tfLGGDDDKDDDDDDDD *\n *ti;.                                .:.;:                   tGDEEEEKKKKKKKKKKKKKKKKKEEEEEEEEEEEWEEKWEEEEEEEDEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKKKKKEEDf :::.           .,;tfLGGDDDDEDDDDDDD *\n *ti;.                                .::;:                   fDEEEEEKKKKKKKKKKKWKKKKKKKKEEEEEEEWWEEWEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKEEEft.::.           .,;tfLGGDDDDDDEDDDDD *\n *ti;.                                .:.;:                  tGDEEEKKKKKKKKKKKKKKKKKKKKKKEKEEEEE#EEWWEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKEEEGD:::.           .,;tfLGGDDDDDDDEDDDD *\n *ti;.                                .:.,.                  LDEEEEKKKKKKKKKKWKWKKKKKKKKKKKKEEEKWEKW#EEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKW##KKKKKKEEEEf,,:.           .,;tfLGGDDDDDDDDEDDD *\n *ti;.                               ..:.,.                 LGDEEEEKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEEW#WEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKK##KKKKKEEEEEfi;,.           .,;tfLGGDDDDDDDDDKDD *\n *tt;.                                .:.,:                 jDEEEEKKKKKKKKKKWWKKKKKKKKKKKKKKKKKWKE#WWEEEEEEEEEEEEEEWEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKWWKKKKEEEEDfG;,:           .,;tfLGGDDDDDDDDDDKD *\n *tii,.                               .:.,.                tGDEEEEKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKKWWWKEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKW#KKKKEEEEDGGi;,.          .,;tfLGGDDDDDDDDDDDE *\n *ti;;,:.                             .:.,:                fDEEEEKKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEK#WWKEEEEEEEEEEEEDEEEEEEEEEEEEEEGEEEEEEEEEEEEEEEEEEEKKKKKKKWWKKEEEEEEDDf;;;,.         .,;tfLGGDDDDDDDDDDDD *\n *tii;,,:..                           ...,.               ;LEEEEEKKKKKKWKKKKWKKKKKKKKKKKKKKKKKEKKW#WEEEEEEEEEEEEEjEEEEEEEEEKEEEEGEEEEEEEEEKEEEEEEEEEEEEEEEEE#WKEEEEEEDDf;;;;,:        .,itfLGGDDDDDDDDDDDD *\n *ti;,,,,,:.                          ...,.               LDEEEEKKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKK#W#WEEEEEEEEEEEDDLEEEEEEEEEWEEEEDEEEEEEEEEKEEEEEEEEEEEEEEEEEWWEEEEEEEDDfj,,,,,:.      .,itfGGGDDDDDDDDDDDD *\n *tii,,,,::::.                        ...,:              .fDEEEEKKKKKKWKKKKWWWKKKKKKKKKKKKKKKEKKW#WWEEEEEEEEEEEKiKEEKEEEEEEWEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEEWWEEEEEEEDDLD:::,,,:.     .,ijfGGGDDDDDDDDDDDD *\n *ti;:::::::::..                      .:.,:              LDEEEEKKKKKKKWKKKKWWKKKKKKKKKKKKKKKKtKKWWWWKEEEEEEEEEDiiDEEEEEEEEWWEEEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEWKEEEEEDDDGL:. .:,,,:    .,ijLGGGDDDDDDDDDDDD *\n *tt;. .::::::::..                    ...,:             :fDEEEKKKKKKKKKKKKWW#KKKKKKKKKKKKKKKKfKKWWWWKEEEEEEEEDti,DEKEEEEEEWWEEEDEEEEEEEEEKEEEEEEEEEEEEEDEEEEE#WEEEEEGGDGf:.  .:,;,:.  .,ijLGGDDDDDDDDDDDDD *\n *tt;.   .:::::::..                   ...,:             GDEEEKKKKKKKKWKKKKWWWKKKWKKKKKKKWWWKDEKLWWWWKKEEEEEEDEi,LDEEEEEEEEWWEEEEEEEEEEEEEEEEEEEEEEEEEDEDEEEEEW#EEEEDDDDGf,.    :,,,:...,ijLGGGDDDDDDDDDDDD *\n *tt;.    .....::::..                 ...,:             fDEEEKKKKKKKKWKKKKWWWWKKKWKKKKKKKKKKfWKiWWW#KKEEEEEEEi;.EDfEEEDEEiWWEEEEEEEEEEEEDGKEEEEEEEEEEDEEEEEEEWWEEEEDDDGGLi.     .,;,:::,ijLGGGDDDDDDDDDDDD *\n *tt;.      ....:::::.                ...,.            iDEEEEKKKKKKKKWKKWKWWWWWKKWWWKKKKKKKKtWKt#WWWKKEEEEEDji..DDKDDEDEGiWKEEEEEEEEEEDDEjEEEEEEEEEEEDEEEEEEEKWKEEDDDDGGff.      .:,;,,;ijLGGGDDDDDDDDDDDD *\n *tt;.        ....::::..              .:.,:           .LDEEEKKKKKKKKKKKKWWWWKWWWWWWWWWWKKKKWtKKiDWWWKKKEEEEKi:..DEDDDDDDiiWKEEEEEEEEEEDDEijDEEEEEKEEEEEEEEEEEEWWEEGDDDGGLG.       .:,;;iijLGGGDDDDDDDDDDDD *\n *tt;.          .....:::..            ...,.           .fEEEEKKKKKKKKWKKKKWWWWWWWWWWWWWWKWKKKiKDiLWWWWKEEEEEi,..fD:DDDDDti;WEEEEEEEEEEKDDi:iDDEEEEWEEEEEEEEEEEE#WEEGDDDDGGG.         :,iitjLGGGDDDDDDDDDDDD *\n *tti.            .....:::..          ...,.           GDEEEKKKKKKKKKWKKKWWW#WWWWWWWWWWWKWKKjiEjitWWWKKWEEEDi...DDLDDDDji;;WEEEEEEEEEEEDEj.iDDEEEEWEEEEEEEEEEEEWWEEDDDDDDGf.          .,;tjfLGGDDDDDDDDDDDD *\n *tti.              ....::::..        ...,.           fEEEKKKKKKKKKKKKKKKW#WWWWWWWWWWWWWWWWtiEiiiWWWKKEWKEi....D.EDDDEi;.fWEEEEEEEEEEDDfL.;EDDEEEWEEEEEEEEEEEEWWEEEDDDDDGf.           :;ijfLGGDDDDDDDDDDDD *\n *tti.                ....::::..      ...,.          LDEEEKKKKKKKKKKKKKKWWWWWWWWWWWWWWWW####WKiiiWWWKKKEEK,...:E:DDDEii..GWEEEEEEEEDWDDiL.,KDDEEEWEEEEEEEEEEEEWWKEEDDDDDGf:           .,itfLGGDDDDDDDDDDDD *\n *tti.                 .....:::..     ...,.          fDEEEKKKKKKKKKWKKKKWWWWWWWWWWWWW########WLiiWWWKKKEEjD...G,DDDDi;...EWEEEEEEEEDKDEii..LDDEEEWEEEEEEEEEEEEWWWEEDDDDDGfi           .,;tfLGGGDDDDDDDDDDD *\n *tti.                   .....:::..   ...,.         iGEEEKKKKKKKKKKWKKKKWWWWWWWWWWWW###########KiWWWKKEEE,.D..D.DDDii:...KKEEEEEEEEEDDj:...tEDEEEWEEEEEEEEEEEEWWWEEEDDDDDLL           .,;tjLLGGDDDDDDDDDDD *\n *tti.                     ....::::......:.         LEEEKKKKKKKKKKWWKKKWWW#KWWWWWWWW#####W####W##KWWKKEEL..:D.jjDDi;,....KKEEEEEEEDfDDi...:iKDEEEWKEEEEEEEEEEEWWWEEEEDDDDLG           .,;tjLLGGDDDDDDDDDDD *\n *tti.                        ...::::::..,.        :GEEEKKKKKKKKKKKKWWWWW##WWWWWWWWW##WKWK#W#W####WWKEEK.....G.DDti,.....KKEEEEEEDWGDf.,...iKDEEEWWEEEEEEEEEEEW#WEEEEEDDDGL           .,;tjLLGGDDDDDDDDDDD *\n *tti.                         ....::::::,.        GDEEKKKKKKKKKKKKKWWWW###WWWWWWWWWW#WWWK###W#####WKEKK.....jDDL;;......KKEEEEEEEEEDi.f...;KDEEEWWEEEEEEEEEEEWWWWEEEEEDDGf           .,;tjLLGGDDDDDDDDDDD *\n *tti.                           ....:::,,.       .LEEEKKKKKWKKKKKWWWWWW###WWWWWWWWWW#WWKW#WW##W#WWWKEKD:....:DD:;......;KEEEEEEEKiDD..f...,KKEEEWWEEEEEEEEEEEWWWWEEEEEDDDf           .:;tjLLGGGDDDDDDDDDD *\n *tti.                             ...::,,,:.     GDEEKKKKKKKKKKKKWWWWWWW#WWWWWWWWWWW#KjKWWWWWWWWWWWWEK.j,..;fD.;.......fKEEEEEDKG:Di..,....DKEEEWWEEEEEEKEKKKWWWWEEEEEEDDf           .:;tjLLGGDDDDDDDDDDD *\n *jti.                              ...::,,,,:.  .fEEEKKKKKWKKKKKKWWWWWWW#WWWWWWWWWWK#KKKWWWWWWWWWWWWWK..f:.:G.,:.......EKEEEEEKK;:E:.......fKEEEWWKEKEKKKKKKKW#WWEEEEEEDDf:          .,;tfLLGGDDDDDDDDDDD *\n *tti.                               ...:,,,;;,: iDEEKKKKKWKKKKKKKWWWWWWW#WWWWWWWWWWK#WDKWWKKWWWWWWWWWE..;G:G..,........KKEEEEEKi.Gi..:.....tKEEKWWWKKKKKKKKKKW##WKEEEEEEDfi          .,;tfLLGGGDDDDDDDDDD *\n *tti.                               ....::,,;;;,LEEKKKKKKWKKKKKWWWWWWW###WWWWWWWWWWKWWDKWEEEWKKWWWWWKKj.:LG..;.........EKEEEEKG;.G...;.....;KKEKWWWKKKKKKKKKKW##WWKEEEEEDfL          .,;tfLGGGDDDDDDDDDDD *\n *jti.                                ...::::,;ijDEEKKKKKWKKKKKKWKWWWWW##WWWWWWWWWWWKK#KKGDGDWEEWKKWKKGE,.i;.:.........:EKEEEKE;.:L...j.....,KWEKWWWKKKKKKKKKK####WKKEEEEDLG          .,;tfLGGGGDDDDDDDDDD *\n *jti.                                ...:...,,;GEEKKKKKWWKKKKKWWWWWWWW###WWWWWWWWWKKKWWKiLGGEDEDEKGKKiEG..;...........jKEEEKK;:.G....,.....:KKEWWWWKKKKKKKWKK####WKKKKEEEGL          .,;tfLGGGGDDDDDDDDDD *\n *jti.                                ...:.  .:,GEEKKKKKWKKKKKWWWWWWWW####WWWWWWWWWKKKWWKii;fDLGDK: EEi:E:.............EKEEKK;;..L...........KKKWWWWKKKKKKKWKK####WKKKWKEEDf          .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    ,EEKKKKKWWKKKKKWWWWWWWWW###WWWWWWWWKKKKfWWLt;i,. fi  EG..D:.............EKEKK;;..t....:.......KWKWWWWKKKKKKKWKK####WKKKWEEEDf:.        .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    GEEKKKKKWKKKKKWWWWWWWWW####WWWWWWWKKKKKt;KKEfff     .;t.................KKKKi;:..GtGGfG.......KWWWWWWKKKKKKKWKK###WWWKKKKEEEf,,:       .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    GEKKKKKWWKKKKKWWWWWWWWWW##WWWWWWWKKKKKKt;EiKKKK,   ...t................jEKKG;;..,.....,LGi....KWWWWWWKKKKKKWKKKW####WKKKKKEEL,,,:.     .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.  .GEEKKKKKWKKKKKWWWWWWWWWW###WWWWWWWKKKKKKtiE::tGG........................EEEj;;...,.........:D..DKWWWWWWKKKKK#KKW###W#WKKKKKEEfj:,,,:.   .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.   DEKKKKKWWKKKKKWWWWWWWWW####WWWWWWWKKKKKKiiE:::.::.......................EEi;;...j.....f......:iDKWWWWWWKKKKK#WW######WKKKKKEELG :,,,,:. .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.  fEEKKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKK;tE::..........................DD;.;,.::......;........EWWWWWWWKKKKW#WW#####WWKKKWKKELG  .:,,,:::,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:. .DEKEKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKE,iD::..........................D..,;.,;tLffi...........DWDWWWW#KKKWWWWW#####W#KKKWKEEGL    .:,;,,,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:. ;EEKKKKWWKKKKKWWWWWW#WWWW####WWWWWWKKKKKEL:iD:..........................j ..;..;;:.....i,........DKtWWWWWKKWWWWWW#####WWWKKKEKEDf     .:,;;;itfGGGDDDDDDDDDDDD *\n *jti.                                ...:. DEKKKKKWWKKKKWWWWWWW#WWWW####WWWWWWKKKKKEj:iG...............................:....................GKiWWWWWKKWW#WWW######WWKKKKKEEf       .,;iitfGGGDDDDDDDDDDDD *\n *jti.                                ...:.:EKKKKKWWKKKKKWWWWWWW#WWW#####WWWWWKWKKKKEi:if:.................................iEKEKKKKKKDj......DKiWWWWWKWK##WW#######WWKKK:KEEL        .:;itfGGGDDDDDDDDDDDD *\n *jji.                                ...:,DEEKKKWWWKWKKWWWWWWWWWWWW#####WWWWWWWKKKKEi:it..................................j.  KKKKKKKKKKKf..DKiWWWWWKWW##WW#######WWKKK,KEEf         .,;tfGGGDDDDDDDDDDDD *\n *jji.                                ..L:iDEEKKKWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKKi.i;..................................  . KKKWWWWWWWWK..DGiWWWWWKK##WWW#####W#WWKKKjEKEL,        .:;tfGGGDDDDDDDDDDDD *\n *jji.                               .f:::EEEKKKWWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKK;.i,.................................::  KKEKWWWWWWfWK..EiiWWWWWKWW#WW##########KKKD,KELj        .:;tfGGDDDDDDDDDDDDD *\n *jji.                             .t::::,DEEKKKWWKKKKWWWWWWWWW#WWWW#####WWWWKKWKKKEK;.i:.................................GDDEEEKKKWWWWWtWWD.E;iWWWWWW###WW#########WWKKK.EEDG        .:;tfGGGDDDDDDDDDDDD *\n *jji.                          . j..::::EKEKKKWWWKKKKWWWWWWWWW#WWW######WWWWKKWKKKEK;.t:.................................ELLEDDEEEWWWWEtWK,.KiiWWWWWW###W##########WWKKK:EEEG     .;tjfLLGDDDDDDDDDDDDDDD *\n *jji.                          i.::::::,EEEKKWWWKKKKKWWWWWWWWW#WWW#####WWWWWKWKKKKEE,.t..................................DfiEGDDDEEKKKttKWG.KiiWWWWW##WWW##########WWKKK:fEEL  ,fGGGDDDDDDDDEEEDDDDDDDDDD *\n *jji.                        .;:..:::::DEEEKKWWWKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKED,.t..................................ifjDDGGEGDKK.ttKKE.DiWWWWW###WW##########WWWKKK:.KELiLGGGGDDDDDDDDDDDDEEEDDDDDDD *\n *jji.                       i.:.::::::,KEEKKWWWKKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKEL:.j..................................GGf,;ifLLED .iiKKi:fWWWWWW##W#W##########WWWKKK:.KKLGGDDDDDDDDDDDDDDDDEDDEEDDDDD *\n *jji.                     .j:.::::::::EEEKKKWWWKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKf:.f..................................:EEfftf .,. ;iE,..jWWWWWWW###W############WWKKK,:KKGDDDDDDDDDDDDDDDDDDDDDDDEDDDD *\n *jji.                    .:.::::::::,,EEEKKWWWKKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKt..G....................................EEELL;   .j....tKWWWWWWW################WWWKKtfGKGEDDDDDDDDDDDDDDDDDDDDDDDEEDD *\n *jji.                   :...:::::::,,jEEKKWWWWKKKKKKWWWWWWWWW##KWW#####KWWWWWWKKKKEi..D....................................:jEEE.........;KKWWWWWWWW#WW##W##########WWKKDLGKEKDDDDDDDDDDDDDDDDDDDDDDDDDED *\n *jji.                  i:.::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWW##WWW#####WWWWWWWKKKKKi..D......................................:::::......,KKKWWWWWWWWW#####W########WWWKKKGGKKEGGGGGGGGDDDDDDDDDDDDDDDDDDE *\n *jji.                 i..:::::::::,,tEEKKWWWWKKKKKWWWWWWWWWWW##WW######WWWWWWWKKKKKi..D......................................::::......:EKKKWWWWWWWWWWW##WW########W#WKKWGGKKGGGGGGGGGGGGGGGDDDDDDDDDDDDD *\n *jji.                .:::::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWWW##WW#####WWWWWWWWKKKKKi..D....................................:::::::::..tELii;KWWWWWWWWWW##WW######WWWWWWKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGDG *\n *jjt.                :.::::::::,,,,fEEKKWWWWKKKKKKWWWWWWWWWW###WW####WWWWWWW#WKKKKKi..D....................................:::::::.:.,;;;;;;,KKWWWWWWWWW#WW########WWWKKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGGG *\n *jji.               ;.::::::::,,,,;EEEKWWWWWKKKKKWWWWWWWWWWWW##WW###WKWWWWWK#WKKKKKi..G......................................:::::::,;;;;:...KKKWWWWWWWWWKWW#######WWWWKKGLGKDGGGGGGLLGGGGGGGGGGGGGGGGGGG *\n *jjt.              f.:::::::::,,,,fEEKKWWWWWKKKKKWWWWWWWWWWW###WW##WKKWWWWWW#WKKKKK;.jt........i.............................:::::::;j;;....:E.KKKWWWWWWWKWW#####W#WWWWKKLLGWEEGGGGGLGGGGGGGGGGGGGGGGGGGG *\n *jjt.             ...:::::::,,,,,;DEEKWWWWWKKKKKWWWWWWWWWWWW####WWWKKKWWWWWWWWKKKKK;.E;.........t.............................:::::ii;;.....D...KKWWWWWWWKWW#####WWEWWWKKGGGEKKGGGGGLGGGGGGGGGGGGGLGGGGGG *\n *fji.             ;.:::::::,,,,,;LEEKKWWWWWKKKKKWWWWWWWWWWWW####KWKKKKWWWWWWWWKKKKKi.D;..........j.............................:::tt;,.....:.....KKWWWWWWKWWWW##WWWGWWWKKGGGGKEGGGGGGGGGGGGGGGGGGGLLGGGGL *\n *fji.            t::::::::,,,,,,;EEEKWWWWWKKKKKKKWWWWWWWWWWW##WKWKKKKKWWWWWWWWKKKKKi:D;............j...........................::LL;,.............KKWWWWWKWWWWWWWWWGWWWKKGGGGKGGGGGGGGGGGGGGGGGGGGLLGGGGL *\n *fjt:            .:::::::,,,,,,,DEEKWWWWWWKKKKKKKWWWWWWWWWWWWKKWKKKKKKWWWWK#WWKKKKWitE;........... ............................:G;;:...............KKKWWKKWWWWWWWWWGWWWKKGGGGWGGGGGGGGGGGGGGGGGGGGGGGGGGL *\n *fjji;:.       .f:::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWWKKKKKKKKKKKWWKWWWWWKKKKWGKD;........................................L;;..................DKKWKKWWWWWWWWWGWWWKKDGGGKDGGGGGGGGGGGGGGGGGGGGGGGGGG *\n *fjjtii;,:.     :::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWKKKKKKKKKKKKWWWWWW#WWKKKKWiEj;......................................:i,;....,...............;KKEKWWWWWWWWWGKWWKKDDGGDEGGGDGGGGGDGGGGGGGGGGGGGGGG *\n *fjtiiiii;;:.  j::::::,,,,,,,;;EEEKWWWWW#KKKKKWWWWWWWWWKKKKKKWKKKKKKKWWWWWWWWWKKKKWtEL;:....................................;;;:...,;j................:KEEWWWWWWWWWDDWWKKDDDDDKDDDDDDDDDDDDDDDGGGGGGGGGGG *\n *fjti;;iiii;;,:::::::,,,,,,,,;EEEKWWWWWWWKKKKWWWWWWWWKKKKKKKWKKKKKKKWWWWWWW#W#KKKKWEEii;...................................f;:....,;L...................EEKWWWWWWWWDDWWKKDDDDDKEDDDDDDDDDDDDDDDDDDDDDGGGG *\n *fjt,,,;;;;ii;f::::::,,,,,,,;;EEKWWWWWWWKKKKKWWWKWWKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWKEij;:...............................:G;,.....,;f....................:tKKWWWWWWWDDWWKKDDDDDKKDDDDDDDDDDDDDDDDDDDDDDDDD *\n *jjt. ..:,;;;;,::::,,,,,,,,;;GEEWWWWWWWWKKKKWKKWKKKKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWEDi;j;............................,Li;L;;;..,;;f........................KKKKWWWKDDWWKKDDDGDKKGGGGGGGGDGDDDDDDDDDDDDDDD *\n *fjt.    .:,,,:::::,,,,,,,;;;EEKWWWWWWWKKKKKKWKKKKKKKKKKKKKKKKKKKKKWKKKWKW##W#KKKKWEti;;G;........................tEEEL;;;;;;;;;;L..........................DKKKKKEDDWWKEDGftiLE;;;;itjLGGGGGGDDDDDDDDDDD *\n *fjt.       .j::::,,,,,,,;;;DEEWWWWWWWWKKKKWKKKKKKKKKKKKKKKKKKKKKKKWKKWWWK##W#KKKKKEii;;;L;...................iDEEEEEEKKi;j;;;;jD.....:......................,KKKKDGGEKKE:::::;E::::::::::,tLGGDDDDDDDDDD *\n *fjt.       .;:::,,,,,,,;;;;EEKWWWWWWWWKWKKKKKKKKKKKKKKKWKKKKKKKKKKWKKWWWW#WW#KKKKKKii;;;;f;.............:tDEEEEEKKKKKKKKEti;;;L...............................EEKf;:iKKE::::::E::::::::::::::ifDDDDDDDDD *\n *fjt:        :::,,,,,,,,;;;DEEWWWWWWWWWEKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####KKKKKEiii;;;;f,.........iDEEEEKKKKKKKKKKKKKKKf;iG......i..........................fK::::KKE::::::E::::::::::::::::,tGGDDDDD *\n *fjt:       t:::,,,,,,;;;;iDEKWWWWWWKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####WKKKKLiii;;;;;L,....,Li;EDEEEEKKKKKKKKKKKKKKKKiG......;:...........................:i:::KKE:::::,E,::::::::::::::::::iGDDDD *\n *jjt.       f::,,,,,,,;;;;GEEWWWWKEEKEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKWWWWW###WWKKKKiii;;;;;;;G,;L;;iiEEEEEEEKKKKKKKKKKKKKWWKE......;t.........:....................j::KEE:,::,,D,,::::,,,,,,:::::::::tDDD *\n *fjt:.      ,::,,,,,,,;;;;EEWWKEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKKWWWWW#W#KKKKKKiiiiii;;;;;i;;iiiEEKEEKKWKKKKKKKWKKKKKWWWGi;...;t......,;;;;,....................:,EEE,,,,,,D,,,,,,,,,,,,,,,,::,::::tG *\n *fjt:.     ,::,,,,,,,;;;;DEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWW#W#KKKKKKiiiii;;i;;;;;iiiKKKEKKKKWWKWWWWWWKKKKWWWWW;;;:;L.....;;;;;;;;;....................,KEE,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,; *\n *fjt:.     f:,,,,,,,;;;;jEDEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWW#W##KKKKKKiiiiiiii;i;;iiiEKKKKKKKKWKWWWWWWWWKKKWWWWWKi;;i.....,jEEfGi;;;;;...................EED,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,, *\n *fjt:.    .f::,,,,,,;;jEEDEEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWKWWWWW###KKKKKLiiiiiiiiiiiiiiEEKKKKKKKKWWWWWWWWWWWWKWWWWWWGi;i;,..;jDDDKEGi;;;;;;:................EED,,,,,,D,,,,,,,,,,,,,,,,,,,,,,,,, *\n *fjt:.  .. ;::,,,,,;;EDDEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKW#WW####KWKKKiiiiiiiiiiiiijKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWt;i;;;;i;DDDDDDGi;;;;;;;;:.............EDf;,,,;,G;;;;;;;;;;;;;;;,,,,,,,,,, *\n *fjt:......:,,,,,,;LDDDEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWWKWWWW####KKKKKiiiiiiiiiiijKEKKWKKKKKKKWWWWWWWWWWWWWWWWWWWWWWiLiii;i;DEEEEDDE;i;;;;;;;;;:..........EDi,;;;;;L;;;;;;;;;;;;;;;;;;,,,,,,, *\n *fjt:......:,,,,,;EDDDEEKEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKWWWWKKWWW##W#KWKKWEiiiiiijGKKKKKWWKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKi;iiiiDDEEEEEEDEi;;;;;;;;;;;;;,:.....ED;;;;;;;j;;;;;;;;;;;;;;;;;;;;;;;,, *\n *fjt:.....t,,,,,;DDDDEEEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKWWWW##WKWKKWKiiiKKKKKKKKKWWKKKKKKKKWWWWWWWWWWWWWWW#WWWWWWWWWiiiiifLEEEEEEEEDi;i;;;;;;;;;;;;.....DD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n *fjt:.....G,,,,,GDDDEEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKKWWWKKKWWW###WKWKKWKitKKKKKKKKKWKKKKKKKKKKWWWWWWWWWWWWWW###WWWWWWWWEiiiiiiiEEEEEEEEDGiiii;;;;;;;;;.....GD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n *fjt:.....L,,,,;GDDDEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWDGWWW###KKWWKWKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWW####WWWWWWWWWiiiiiiiiEEEEEEEEEEDi;i;;;;;;;;.....Lj;;;;;;i;iiiiii;;;;;;ii;;;;;;;;;;; *\n ***********************************************************************************************************************************************************************************************************/\n']","[0, 0, 1, 0, 0]",1300,Well if we replace all occurrences of the number with the number then the initial solution will be anti sudoku It is easy to see that this replacement will make exactly two copies of in every row column and block There are also other correct approaches but I found this one the most pretty 
Unlike Knights of a Round Table Knights of a Polygonal Table deprived of nobility and happy to kill each other But each knight has some power and a knight can kill another knight if and only if his power is greater than the power of victim However even such a knight will torment his conscience so he can kill no more than k other knights Also each knight has some number of coins After a kill a knight can pick up all victim s coins Now each knight ponders how many coins he can have if only he kills other knights You should answer this question for each knight ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair <int, int> pii; \ntypedef pair <pair <int, int>, int> piii; \nint answers [200005];\nmain(){\n    ios_base::sync_with_stdio(0);\n    int a, b; cin >> a >> b; \n    vector <int> x, y; \n    vector <piii> den; \n    for (int i=0; i<a; i++){\n        int r; cin >> r; x.push_back(r); \n    }\n    for (int i=0; i<a; i++){\n        int r; cin >> r; y.push_back(r); \n        den.push_back(piii(pii(x[i], y[i]), i)); \n    }\n    sort(den.begin(), den.end()); \n    multiset <int> xk; \n    \n    for (int i=0; i<den.size(); i++){\n        int rz = 0; \n        int ans = den[i].first.second; \n        if (xk.size() > 0){\n            auto rf = --xk.end(); \n            while (rz < b){\n                rz+=1; \n                ans+=(*rf); \n                if (rf == xk.begin()) break; \n                --rf; \n            }\n        }\n        answers[den[i].second] = ans; \n        xk.insert(den[i].first.second);\n    }\n    for (int i=0; i<a; i++) cout << answers[i] << '\\n';\n    return 0;\n}""]","[1, 0, 1, 0, 0]",1400,Sort the knights by increasing the power Now we can iterate over an array and greedy store set of prevous knights with maximum if coins After handling knight if set contains less than elements we add current knight in set Else if number of coins from current knight greater than from knight with minimum coins in set we can replace this knight with current knight You can store the set in or Be careful with overflowing and corner case Time complexity is or 
There is a string s of length n consisting of the characters and You are walking on this string You start by standing on top of the first character of s and you want to make a sequence of moves such that you end on the n th character In one step you can move one space to the left if you are not standing on the first character or one space to the right if you are not standing on the last character You may not stay in the same place however you may visit any character including the first and last character number of times At each point in time you write down the character you are currently standing on We say the string is if there exists some sequence of moves that take you from the first character to the last character such that the string you write down is a regular bracket sequence A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters and between the original characters of the sequence For example bracket sequences are regular the resulting expressions are and and are not You are given q queries Each query flips the value of a character from to or vice versa After each query determine whether the string is walkable Queries are so the effects of each query carry on to future queries ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n    int n,q; cin>>n>>q;\n    set<int> bl;\n    for (int i = 0; i < n; ++i) {\n        char c; cin>>c;\n        bool b = c == \'(\';\n        if (b ^ (i % 2 == 0)) {\n            bl.insert(i);\n        }\n    }\n    for (int qi = 0; qi < q; ++qi) {\n        int i; cin>>i; --i;\n        if (n % 2 == 1) {\n            cout << ""NO\\n"";\n            continue;\n        }\n        if (bl.count(i)) {\n            bl.erase(i);\n        } else {\n            bl.insert(i);\n        }\n        if (bl.empty() || (*bl.begin() % 2 == 1 && *bl.rbegin() % 2 == 0)) {\n            cout << ""YES\\n"";\n        } else {\n            cout << ""NO\\n"";\n        }\n    }\n}\n']","[1, 0, 0, 0, 1]",2100,For a string to be walkable we need to be even because the parity of the balance factor changes on each move and it has to be zero at the end of the process So if is odd the string is never walkable Now consider the set that contains all indices indexed satisfying one of the below conditions is even and is odd and Now consider a few cases If is empty then is of the form and is therefore trivially walkable by just moving to the right If is odd then is of the form We can show that it is never walkable because for every in the first section when we land on this before leaving this section of the string for the first time the balance factor must be Therefore when we try to move across the the balance factor will go to and the walk will no longer be valid If is even then is of the form and we can show that it is never walkable using a somewhat symmetric argument to the previous case but considering the ending of the walk instead of the beginning Otherwise is even and is odd We will prove that it is walkable In this case s is of the form To form a valid walk keep moving to the right until you hit the then alternate back and forth on the times After this move to the right until you hit the Note that during this process the balance factor can never go negative because it will always be at least Once you reach the alternate back and forth on it until the balance factor hits Because n is even this will happen on the rightmost character of the At this point just walk to the right until you hit the end at which point the balance factor will once again be So we just need to maintain the set across all of the queries and do these simple checks after each query to see if is walkable Complexity 
For a long time no one could decipher Sumerian cuneiform However it has finally succumbed to pressure Today you have the chance to decipher Yandex cuneiform Yandex cuneiform is defined by the following rules An empty string is a Yandex cuneiform If you insert exactly one copy of each of the three letters and into a Yandex cuneiform in such a way that no two adjacent letters become equal after the operation you obtain a Yandex cuneiform If a string can t be obtained using the above rules it is not a Yandex cuneiform You are given a template A template is a string consisting of the characters and You need to check whether there exists a way to replace each question mark with or to obtain a Yandex cuneiform and if it exists output any of the matching options as well as a sequence of insertion operations to obtain the resulting cuneiform In this version of the problem there are in the template ,"['#include <bits/stdc++.h>using namespace std;#define fwd(i, a, n) for (int i = (a); i < (n); i++)#define rep(i, n) fwd(i, 0, n)#define all(X) X.begin(), X.end()#define sz(X) int(size(X))#define pb push_back#define eb emplace_back#define st first#define nd secondusing pii = pair<int, int>; using vi = vector<int>;using ll = long long; using ld = long double;#ifdef LOCauto SS = signal(6, [](int) { *(int *)0 = 0; });#define DTP(x, y) auto operator << (auto &o, auto a) -> decltype(y, o) { o << ""(""; x; return o << "")""; }DTP(o << a.st << "", "" << a.nd, a.nd);DTP(for (auto i : a) o << i << "", "", all(a));#define deb(x...) cerr << setw(4) << __LINE__ << "":["" #x ""]: "", [](auto... y) { (( cerr << y << "", "" ), ...) << \'\\n\'; }(x)#else#define deb(...) 0#endif\xa0#include <bits/extc++.h>using namespace __gnu_pbds;template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\xa0vi char_to_int;string int_to_char;\xa0void solve() {    int n;    vi s;    string ss;    {        cin >> ss;        n = sz(ss);        s.resize(n);        rep(i, n) s[i] = char_to_int[ss[i]];    }    array<int, 3> cnts{};    rep(i, n) ++cnts[s[i]];\xa0    if (cnts[0] != cnts[1] || cnts[0] != cnts[2]) {        cout << ""NO\\n"";        return;    }\xa0    rep(i, n-1) if (s[i] == s[i+1]) {        cout << ""NO\\n"";        return;    };    cout << ""YES\\n"" << ss << \'\\n\';\xa0    set<int> active;    Tree<int> tree;    rep(i, n) active.insert(i), tree.insert(i);    array<array<set<int>, 3>, 3> where;\xa0    auto nx = [&](int i) {        auto it = active.upper_bound(i);        return it == active.end() ? -1 : *it;    };    auto pr = [&](int i) {        auto it = active.lower_bound(i);        return it == active.begin() ? -1 : *--it;    };\xa0    auto clear = [&](int i) {        if (i == -1) return;        rep(b, 3) where[s[i]][b].erase(i);    };\xa0    auto re = [&](int i, int j) {        if (i == -1 || j == -1) return;        clear(i);        where[s[i]][s[j]].insert(i);    };\xa0    rep(i, n - 1) re(i, i+1);\xa0    auto remove = [&](int i) {        active.erase(active.find(i));        tree.erase(i);        clear(i);        int pi = pr(i), ni = nx(i);\xa0        re(pi, ni);    };\xa0    vector<pair<char, int>> anss;\xa0    auto ans = [&](int i, int j, int k) {        set<int> st = {s[i], s[j], s[k]};        assert(sz(st) == 3);\xa0        remove(i);        anss.eb(int_to_char[s[i]], tree.order_of_key(i));        remove(j);        anss.eb(int_to_char[s[j]], tree.order_of_key(j));        remove(k);        anss.eb(int_to_char[s[k]], tree.order_of_key(k));    };\xa0    rep(_, n / 3) {        int S = nx(-1);        int ok = s[S];\xa0        bool fi = false;        int a = (ok + 1) % 3, b = (ok + 2) % 3;\xa0        rep(__, 2) {            if (fi) break;\xa0            if (where[a][b].empty()) {                swap(a, b);                continue;            }            fi = true;\xa0            int i = *where[a][b].begin();            int ni = nx(i);\xa0            int pi = pr(i);            assert(pi != -1);            int nni = nx(ni);\xa0            if (nni == -1) {                ans(i, ni, S);                continue;            }\xa0            if (s[pi] == s[nni]) {                ans(i, ni, pi);                continue;            }            else {                ans(i, ni, S);                continue;            }        }\xa0        assert(fi);    }\xa0    reverse(all(anss));    for (auto [c, i] : anss)        cout << c << \' \' << i << \'\\n\';}\xa0int32_t main() {    cin.tie(0)->sync_with_stdio(0);    cout << fixed << setprecision(10);\xa0    int_to_char = ""YDX"";    char_to_int.resize(256);    rep(i, 3)        char_to_int[int_to_char[i]] = i;\xa0    int z = 1;    cin >> z;    rep(_, z) solve();\xa0    #ifdef LOCF    cout.flush(); cerr << ""- - - - - - - - -\\n"";    (void)!system(""grep VmPeak /proc/$PPID/status | sed s/....kB/\\\' MB\\\'/1 >&2""); // 4x.kB ....kB    #endif\xa0    cout << flush;    _Exit(0);}']","[1, 0, 0, 0, 1]",3300,It can be noted that if the string contains the correct number of symbols Y D X and does not have two consecutive identical symbols then it can be obtained using the given operations To demonstrate this we will provide an algorithm that constructs a sequence of operations leading to the desired string We will start from the end from the string we want to obtain to the empty string gradually removing symbols Let s look at the current string Without loss of generality let its first symbol be Y Then the string must contain the substring DX and or the substring XD This is true because for the absence of DX and XD it is necessary that between any pair of symbols not equal to Y there is at least one symbol Y This can be achieved at best by placing Y between every symbol Thus the number of symbols not equal to Y with n 1 Y can be at most n But 3n 1 n when n 0 Thus the string has the form Y ADXB If A B we can remove the symbols Y D X and nothing will break If A B then A B Y since A D and A X Then the string has the form Y YDXY and we can remove the substring YDX and still have an unbroken string Y Y 
There is a legend in the IT City college A student that failed to answer all questions on the game theory exam is given one more chance by his professor The student has to play a game with the professor The game is played on a square field consisting of cells Initially all cells are empty On each turn a player chooses and paint an empty cell that has no common sides with previously painted cells Adjacent corner of painted cells is allowed On the next turn another player does the same then the first one and so on The player with no cells to paint on his turn loses The professor have chosen the field size and allowed the student to choose to be the first or the second player in the game What should the student choose to win the game Both players play optimally ,"['/**\n *    author:  enot.1.10, Vladimir Smykalov ([email\xa0protected])\n *    created: 18.02.2016 17:50:32       \n**/\n#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(),a.end()\n#define pw(x) (1LL<<(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double dbl;\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1.01e9;\nconst dbl eps = 1e-9;\n\n/* --- main part --- */\n\n#define TASK ""1""\n\nll cnk(ll n, int k)\n{\n    ll res = 1;\n    forn(i, k) res = (res * (n - i)) / (i + 1);\n    return res;\n}\n\nint main()\n{\n    #ifdef home\n        assert(freopen(TASK"".in"", ""r"", stdin));\n        assert(freopen(TASK"".out"", ""w"", stdout));\n    #endif\n    ll n;\n\n    cin >> n;\n    ll res = 2 - (n & 1);\n    cout << res;\n    #ifdef home\n        eprintf(""Time: %d ms\\n"", (int)(clock() * 1000. / CLOCKS_PER_SEC));\n    #endif\n    return 0;\n}\n']","[0, 1, 0, 0, 0]",1200,For the field of an even size there is a winning strategy for the second player Namely to paint a cell that is symmetrical with respect to the center of the field to the cell painted by the first player on the previous turn After each turn of the second player the field is centrosymmetrical and so there is always a cell that can be painted that is symmetrical with respect to the center of the field to any cell that the first player can choose to paint 1 1 1 1 2 2 2 2 For the field of an odd size there is a winning strategy for the first player Namely on the first turn to paint the central cell then to paint a cell that is symmetrical with respect to the center of the field to the cell painted by the second player on the previous turn After each turn of the first player the field is centrosymmetrical and so there is always a cell that can be painted that is symmetrical with respect to the center of the field to any cell that the second player can choose to paint 2 2 2 2 1 1 1 1 1 1 1 1 1 So for even n the answer is 2 for odd n the answer is 1 One of the possible formulas for the problem is n can be up to 1018 so at least 64 bit integer type should be used to input it 
A is a sequence of integers consisting of distinct positive integers each of them doesn t exceed Let s denote the th element of permutation as We ll call number the size of permutation Nickolas adores permutations He likes some permutations more than the others He calls such permutations perfect A permutation is such permutation that for any is the permutation size the following equations hold and Nickolas asks you to print any perfect permutation of size for the given ,"['#include<cstdio>\n\nint n;\n\nint main()\n{\nscanf(""%d"",&n);\nif (n&1) printf(""-1\\n"");\nelse\n  for (int i=1;i<=n/2;i++) printf(""%d %d "",i*2,i*2-1);\nreturn 0;\n}\n']","[0, 1, 1, 0, 0]",800,Consider permutation p such that pi i Actually p is a sequence of numbers from 1 to n Obviously ppi i Now the only trick is to change the permutation to satisfy the second equation pi i Let s swap every two consequtive elements More formally for each k 2k n let s swap p2k 1 and p2k It s easy to see that the obtained permutation satisfies both equations for every n with the only exception when n is odd there is no answer and we should print 1 
There is an infinite line consisting of cells There are n boxes in some cells of this line The i th box stands in the cell a i and has weight w i All a i are distinct moreover a i 1 a i holds for all valid i You would like to put together some boxes Putting together boxes with in the segment l r means that you will move some of them in such a way that their will form some segment x x r l In one step you can move any box to a neighboring cell if it isn t occupied by another box i e you can choose i and change a i by 1 all positions should remain distinct You spend w i units of energy moving the box i by one cell You can move any box any number of times in arbitrary order Sometimes weights of some boxes change so you have queries of two types id nw weight w id of the box id becomes nw l r you should compute the minimum total energy needed to put together boxes with indices in l r Since the answer can be rather big print the remainder it gives when divided by 1000 000 007 10 9 7 Note that the boxes are not moved during the query you only should compute the answer ,"['#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x"".in"",""r"",stdin);freopen(#x"".out"",""w"",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 666666\nconst int MOD=1e9+7;\nint n,q,a[SZ],w[SZ];\nstruct Fenwick1\n{\nll bs[SZ];\nvoid edt(int x,ll y)\n{\n\tfor(;x<=n;x+=x&-x) bs[x]+=y;\n}\nll qs(int x)\n{\n\tll s=0;\n\tfor(;x>=1;x-=x&-x) s+=bs[x];\n\treturn s;\n}\n}B0;\nstruct Fenwick\n{\nint bs[SZ];\nvoid edt(int x,int y)\n{\n\tfor(;x<=n;x+=x&-x) (bs[x]+=y)%=MOD;\n}\nll qs(int x)\n{\n\tint s=0;\n\tfor(;x>=1;x-=x&-x) (s+=bs[x])%=MOD;\n\treturn s;\n}\n}B1;\nint main()\n{\n\tscanf(""%d%d"",&n,&q);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(""%d"",a+i),a[i]-=i;\n\tfor(int i=1;i<=n;++i) scanf(""%d"",w+i);\n\tfor(int i=1;i<=n;++i)\n\t\tB0.edt(i,w[i]),\n\t\tB1.edt(i,w[i]*(ll)a[i]%MOD);\n\twhile(q--)\n\t{\n\t\tint x,y;\n\t\tscanf(""%d%d"",&x,&y);\n\t\tif(x<0)\n\t\t{\n\t\t\tx=-x; int dt=y-w[x];\n\t\t\tw[x]=y; B0.edt(x,dt);\n\t\t\tB1.edt(x,dt*(ll)a[x]%MOD);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll sl=B0.qs(x-1),\n\t\t\tsu=B0.qs(y)-sl;\n\t\t\tsu=(su+1)/2;\n\t\t\tint l=x,r=y;\n\t\t\twhile(l<r)\n\t\t\t{\n\t\t\t\tint m=(l+r)>>1;\n\t\t\t\tif(B0.qs(m)-sl>=su) r=m;\n\t\t\t\telse l=m+1;\n\t\t\t}\n\t\t\tint m=l;\n\t\t\t//mid pos is m\n\t\t\tll ans=(B1.qs(y)-B1.qs(m))-\n\t\t\t(B0.qs(y)-B0.qs(m))%MOD*(a[m])%MOD\n\t\t\t-(B1.qs(m)-B1.qs(x-1))\n\t\t\t+(B0.qs(m)-B0.qs(x-1))%MOD*(a[m])%MOD;\n\t\t\tans=(ans%MOD+MOD)%MOD;\n\t\t\tprintf(""%d\\n"",int(ans));\n\t\t}\n\t}\n}\n']","[0, 0, 0, 0, 1]",2500,Firstly let s prove that it s always optimal to leave one of the boxes untouched By contradiction if all boxes will move so some left part will move right and right part will move left Let the total cost of shifting the whole left part by one be equal to Sl and cost of the right part be Sr We can replace the move of one of the parts by extra move of the other part so we can change max Sl Sr by min Sl Sr total cost doesn t increase contradiction Let S l r i lrwi Then secondly let s prove that for some segment l r it s always optimal to choose untouched box k such that S l k 1 S l r 2 but S l k S l r 2 Again if it is not true then either S l k 1 S l r 2 or S k 1 r S l r 2 And we again can replace either S l k 1 by S k r or S k 1 r by S l k Total cost is decreasing contradiction So finally all we need is to process the following queries for given l r find maximum k that S l k 1 S l r 2 but S l k S l r 2 or doesn t really matter It can be done with binary search BIT in O log2n time or by descending down the Segment Tree in O logn time Next part is how to calculate the answer for the known k Since the cost of moving box i to the right place is equal to wi ak ai k i if i k and wi ai ak i k otherwise so if we shift from ai to ai i then the cost to move all left indices are equal to i lk 1wi ak ai ak S l k 1 i lk 1wiai The right part transforms in the same way Since answer is modulo 109 7 we can calculate i lk 1 wiaimod109 7 using another BIT Result complexity is O nlogn qlog2n or O n q logn which isn t really faster in this task 
Our dear Cafe s owner JOE Miller will soon take part in a new game TV show 1 vs n The game goes in rounds where in each round the host asks JOE and his opponents a common question All participants failing to answer are eliminated The show ends when only JOE remains we assume that JOE never answers a question wrong For each question JOE answers if there are s s 0 opponents remaining and t 0 le t le s of them make a mistake on it JOE receives displaystyle frac t s dollars and consequently there will be s t opponents left for the next question JOE wonders what is the maximum possible reward he can receive in the best possible scenario Yet he has little time before show starts so can you help him answering it instead ,['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(void) {\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    int n;\n    cin >> n;\n    double ans = 0;\n    for (int i = 1; i <= n; ++i) ans += 1.0 / i;\n    cout << setprecision(12) << fixed << ans << endl;\n    return 0;\n}\n'],"[1, 1, 0, 0, 0]",1000,This is a greedy problem with the optimal scenario being each question eliminating a single opponent It is easy to see that we will want each question to eliminate one opponent only since after each elimination the ratio will be more and more rewarding as lowers overtime as a result each elimination should have the lowest possible i e so more opponents would have their rewards increased Time complexity is 
You have an array of a 1 a 2 ldots a n of length n You can perform two types of operations on it Choose an index i such that 1 le i le n and a i 0 and assign 1 to a i Choose a pair of indices l and r such that 1 le l le r le n a l 1 a r 1 a l ldots a r ge lceil frac r l 1 2 rceil and assign 1 to a i for all l le i le r What is the minimum number of operations of the needed to make all elements of the array equal to one ,"['#include <bits/stdc++.h>using namespace std;\xa0using ll = long long;using ld = long double;using pii = pair<int, int>;using pll = pair<ll, ll>;using vi = vector<int>;using vll = vector<ll>;\xa0constexpr int MOD = 1e9 + 7;constexpr int INF = 1e9;constexpr ll LINF = 1e18;constexpr ld EPS = 1e-9;\xa0#define fast_io() ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr)#define all(x) (x).begin(), (x).end()#define rall(x) (x).rbegin(), (x).rend()#define pb push_back#define eb emplace_back#define fi first#define se second#define sz(x) ((int)(x).size())#define dbg(x) cerr << #x << "" = "" << (x) << \'\\n\'\xa0void solve() {    ll n;    cin >> n;    if(n==1){        cout << 1 << ""\\n"";        return;    }    ll k = 1;    while(true){        ll res = 3LL*((ll)1 << (k-1)) - 2;        if(res>=n) {cout << k << ""\\n""; break;}        k++;    }\xa0}\xa0int main() {    fast_io();    int t = 1;    cin >> t;    while (t--) solve();    return 0;}']","[1, 1, 0, 0, 0]",1000,At each moment of time the array contains a number of non intersecting segments consisting only of ones Using an operation of the first type can increase the number of these segments by Using an operation of the second type decreases the number of these segments by where is the number of segments that this operation covers Therefore the number of operations of the second type is no more than the number of operations of the first type minus The optimal strategy is to perform one operation of the first type and then alternate operations of the first and second types increasing the number of ones from to on each such pair of operations There is no point in doing more operations of the first type on the prefix of operations since we still must cover no more than two segments of ones with operations of the second type otherwise we will reduce the possible number of operations of the second type 
You are given a tetrahedron Let s mark its vertices with letters and correspondingly An ant is standing in the vertex of the tetrahedron The ant is quite active and he wouldn t stay idle At each moment of time he makes a step from one vertex to another one along some edge of the tetrahedron The ant just can t stand on one place You do not have to do much to solve the problem your task is to count the number of ways in which the ant can go from the initial vertex to itself in exactly steps In other words you are asked to find out the number of different cyclic paths with the length of from vertex to itself As the number can be quite large you should print it modulo ,"['#pragma comment(linker, ""/stack:64000000"")\n#include <algorithm>\n#include <iostream>\n#include <cassert>\n#include <climits>\n#include <utility>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <memory.h>\n#include <vector>\n#include <bitset>\n#include <string>\n#include <deque>\n#include <queue>\n#include <ctime>\n#include <set>\n#include <map>\n#include <deque>\n#include <stack>\n#include <cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define forn(i, n) for (int i = 0; i < int(n); i++)\n#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define for1(i, n) for (int i = 1; i <= int(n); i++)\n#define fore(i, l, r) for (int i = int(l); i < int(r); i++)\n#define all(a) (a).begin(), (a).end()\n#define sz(a) int((a).size())\n#define pb push_back\n#define pii pair <int, int>\n#define vi vector <int>\n#define mp make_pair\n\ntemplate <typename X> inline X abs (const X &a) {return a < 0? -a: a;}\ntemplate <typename X> inline X sqr (const X &a) {return a * a;}\n\nconst int INF = INT_MAX / 2;\nconst ll INF64 = LLONG_MAX / 2LL;\nconst ld EPS = 1E-9, PI = 3.1415926535897932384626433832795;\n\nconst ll MOD = 1000000007LL;\n\ninline vector <vector <ll> > mul (const vector <vector <ll> > &a, const vector <vector <ll> > &b)\n{\n    vector <vector <ll> > res (4);\n    forn (i, 4)\n        res[i].resize (4);\n\n    forn (i, 4)\n        forn (j, 4)\n            forn (k, 4)\n            {\n                res[i][j] = (res[i][j] + ((a[i][k] % MOD) * (b[k][j] % MOD)) % MOD) % MOD;\n            }       \n\n    return res;\n}\n\nvector <vector <ll> > binPow (const vector <vector <ll> > &a, int k)\n{\n    if (k == 0)\n    {\n        vector <vector <ll> > res (4);\n        forn (i, 4)\n            res[i].resize (4);\n\n        forn (i, 4)\n            res[i][i] = 1;\n\n        return res;\n    }\n\n    if (k & 1)\n        return mul (binPow (a, k - 1), a);\n    else\n    {\n        vector <vector <ll> > res = binPow (a, (k >> 1));\n        return mul (res, res);\n    }\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""rt"", stdin);\n    freopen(""output.txt"", ""wt"", stdout);\n#endif\n\n    int n;\n    cin >> n;\n\n    vector <vector <ll> > g;\n    \n    g.resize (4);\n    forn (i, 4)\n        g[i].resize (4);\n\n    forn (i, 4)\n        forn (j, 4)\n            g[i][j] = (i == j? 0: 1);\n\n    vector <vector <ll> > ans = binPow (g, n);\n\n    cout << ans[0][0] << endl;\n\n    return 0;\n}']","[0, 1, 0, 1, 0]",1500,Obvious solution with dynamics you need to know only how many moves are left and where is the ant This is states each with 3 options most of such solution passes Observe that the vertices A B C are equivalent This allows writing such solution Also this problem could be solved by with binary exponentiation of some matrix into power 
You have an array a of n integers You perform exactly k operations on it In one operation you select any contiguous subarray of the array a possibly empty and insert the sum of this subarray anywhere in the array Your task is to find the maximum possible sum of the array after k such operations As this number can be very large output the answer modulo 10 9 7 Reminder the remainder of a number x modulo p is the smallest non negative y such that there exists an integer q and x p cdot q y ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MP make_pair\nmt19937 rnd(time(0));\nconst int MAXN=2e5+5;\nconst int MOD=1e9+7;\nll n,k,a[MAXN];\nll ksm(ll a,int b){ll r=1;while(b){if(b&1)r=r*a%MOD;a=a*a%MOD,b>>=1;}return r;}\nvoid solve(){\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) cin>>a[i],a[i]+=a[i-1];\n\tll s=0,mn=0;\n\tfor(int i=1;i<=n;i++){\n\t\tmn=min(mn,a[i]);\n\t\ts=max(s,a[i]-mn);\n\t}\n\tcout<<((a[n]+s%MOD*(ksm(2,k)-1))%MOD+MOD)%MOD<<\'\\n\';\n}\nint main(){\n\tios::sync_with_stdio(false);\n\t// freopen(""Otomachi_Una.in"",""r"",stdin);\n\t// freopen(""Otomachi_Una.out"",""w"",stdout);\n\tint _;cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}']","[1, 1, 0, 1, 0]",1100,Let s denote as the sum of the original array and as the sum of the subarray with the maximum sum from the original array We solve the problem when equals In this case we need to find the subarray of the array with the maximum sum and insert this sum anywhere in the array so the answer is Now let be In this case there is already a value where we insert the sum of the subarray with the maximum sum Then we can increase the sum of the subarray with the maximum sum by no more than we can increase it by simply by inserting it into the subarray with the maximum sum and obtain the sum of the subarray with the maximum sum Then insert it anywhere in the array thus obtaining the sum of the final array equal to Similarly for any the sum of the subarray with the maximum sum is initially then then then the answer is equal to 
Ivan had string consisting of small English letters However his friend Julia decided to make fun of him and hid the string Ivan preferred making a new string to finding the old one Ivan knows some information about the string Namely he remembers that string occurs in string at least times or more he also remembers exactly positions where the string occurs in string these positions are He remembers such strings You are to reconstruct string such that it fits all the information Ivan remembers Strings and string consist of small English letters only ,"['#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef int in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nset<in> unseen;\nconst in mx=2e6+9;\nchar ans[mx];\nin mxl=0;\nstring t;\nchar tt[mx];\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  forn(i,mx)\n    ans[i]=\'a\';\n  forn(i,mx)\n    unseen.insert(i);\n  in n;\n  scanf(""%d"",&n);\n  in k,x;\n  set<in>::iterator it,it2;\n  forn(z,n){\n    scanf(""%s"",tt);\n    t=string(tt);\n    scanf(""%d"",&k);\n    forn(zz,k){\n      scanf(""%d"",&x);\n      --x;\n      mxl=max(mxl,x+sz(t));\n      it=unseen.lower_bound(x);\n      while(it!=unseen.end() && *it<x+sz(t)){\n\tit2=it;\n\t++it;\n\tans[*it2]=t[*it2-x];\n\tunseen.erase(it2);\n      }\n    }\n  }\n  ans[mxl]=\'\\0\';\n  printf(""%s\\n"",ans);\n  return 0;\n}\n']","[1, 0, 0, 0, 1]",1700,At first let s sort all given string by their positions and also determine the length of the answer string After that fill the answer string with letters because the answer string must be lexicographically minimal Let s use variable the minimal index of letter in the answer string which did not already processed After that we need to iterate through the sorted strings If the next string ends before we skip it In the other case we need to impose this string to the answer string beginning from necessary position and write down all letters beginning from or from the beginning of impose depending on which of these values is greater If the imposing of string ends in position we need to make and move to the next string 
Sereja is a coder and he likes to take part in Codesorfes rounds However Uzhland doesn t have good internet connection so Sereja sometimes skips rounds Codesorfes has rounds of two types for advanced coders and for beginner coders Two rounds and can go simultaneously round cannot be held without in all other cases the rounds don t overlap in time Each round has a unique identifier a positive integer The rounds are sequentially without gaps numbered with identifiers by the starting time of the round The identifiers of rounds that are run simultaneously are different by one also the identifier of the round is always greater Sereja is a beginner coder so he can take part only in rounds of type At the moment he is taking part in a round its identifier equals to Sereja remembers very well that he has taken part in exactly rounds before this round Also he remembers all identifiers of the rounds he has taken part in and all identifiers of the rounds that went simultaneously with them Sereja doesn t remember anything about the rounds he missed Sereja is wondering what minimum and what maximum number of rounds could he have missed Help him find these two numbers ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nconst int maxn=4005;\n\nint vis[maxn];\nint n,k,m,x;\n\nint main()\n{\n    memset(vis,0,sizeof(vis));\n    scanf(""%d%d"",&k,&n);\n    while(n--)\n    {\n        scanf(""%d"",&m);\n        if(m==2)\n        {\n            scanf(""%d"",&x);\n            vis[x]=-1;\n        }\n        else if(m==1)\n        {\n            scanf(""%d"",&x);\n            vis[x]=-2;\n            scanf(""%d"",&x);\n            vis[x]=-1;\n        }\n    }\n    int ans1=0,ans2=0;;\n    for(int i=1;i<k;i++)\n        if(!vis[i])\n        {\n            ans2++;\n            if(vis[i-1]==2)vis[i]=1;\n            else vis[i]=2,ans1++;\n        }\n    printf(""%d %d\\n"",ans1,ans2);\n    return 0;\n}\n']","[1, 1, 1, 0, 0]",1200,You must identify the array of numbers contests that remember Sereja as employed If we want to find maximal answer we must count the number of immune cells If we want to find mininum answer we must do the following if i th element is free and i 1 th element is free and i x then we using round type of Div1 Div2 and answer i th and i 1 th elements define as employed if i th element is free and i 1 th element is employed then we usign round type Div2 and answer i th element define as employed Solution B 
You have a device with two CPUs You also have k programs numbered 1 through k that you can run on the CPUs The i th program 1 le i le k takes cold i seconds to run on some CPU However if the last program we ran on this CPU was also program i it only takes hot i seconds hot i le cold i Note that this only applies if we run program i multiple times consecutively if we run program i then some different program then program i again it will take cold i seconds the second time You are given a sequence a 1 a 2 ldots a n of length n consisting of integers from 1 to k You need to use your device to run programs a 1 a 2 ldots a n in sequence For all 2 le i le n you cannot start running program a i until program a i 1 has completed Find the minimum amount of time needed to run all programs a 1 a 2 ldots a n in sequence ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 inf = 1E18;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> cold(k + 1), hot(k + 1), profit(k + 1);\n    i64 sum = 0;\n    for (int i = 1; i <= k; i++) {\n        std::cin >> cold[i];\n    }\n    for (int i = 1; i <= k; i++) {\n        std::cin >> hot[i];\n        profit[i] = cold[i] - hot[i];\n    }\n    for (int i = 0; i < n; i++) {\n        sum += cold[a[i]];\n    }\n    \n    std::vector<i64> dp(k + 1, -inf);\n    dp[0] = 0;\n    \n    i64 max = 0;\n    i64 add = 0;\n    \n    for (int i = 1; i < n; i++) {\n        i64 val = std::max(max, dp[a[i]] + add + profit[a[i]]);\n        \n        if (a[i] == a[i - 1]) {\n            max += profit[a[i]];\n            add += profit[a[i]];\n        }\n        \n        dp[a[i - 1]] = std::max(dp[a[i - 1]], val - add);\n        max = std::max(max, val);\n    }\n    \n    i64 ans = sum - max;\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 0]",1900,But when I just changed the variable MLong from 2 63 1 to 2 62 1 it was accepted I usually make MLong assigned to 2 63 1 since it s equivalent to sys maxsize but I dont t know why it gives TLE Is that because of using of Big integers in python or another issue 
In Berland there are two types of coins having denominations of 2 and k burles Your task is to determine whether it is possible to represent n burles in coins i e whether there exist non negative integers x and y such that 2 cdot x k cdot y n ,"['#pragma GCC optimize(""O3"")\n#pragma GCC optimize(""unroll-loops"")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n\ta = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n\ta = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n\tvector<T> res;\n\tint ida = 0, idb = 0;\n\twhile (ida < a.size() || idb < b.size()) {\n\t\tif (idb == b.size()) {\n\t\t\tres.push_back(a[ida]); ida++;\n\t\t}\n\t\telse if (ida == a.size()) {\n\t\t\tres.push_back(b[idb]); idb++;\n\t\t}\n\t\telse {\n\t\t\tif (a[ida] < b[idb]) {\n\t\t\t\tres.push_back(a[ida]); ida++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.push_back(b[idb]); idb++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n\trep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << "" ""; cout << v[i];\n\t}\n\tcout << ""\\n"";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n\tif (n < 0) {\n\t\tll res = mod_pow(x, -n, m);\n\t\treturn mod_pow(res, m - 2, m);\n\t}\n\tif (abs(x) >= m)x %= m;\n\tif (x < 0)x += m;\n\t//if (x == 0)return 0;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\n//mod should be <2^31\nstruct modint {\n\tint n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) {\n\t\tif (m < 0 || mod <= m) {\n\t\t\tm %= mod; if (m < 0)m += mod;\n\t\t}\n\t\tn = m;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\ta = abs(a); b = abs(b);\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n\tif (loc >= v.size())v.resize(loc + 1, 0);\n\tv[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n\tfill(isp + 2, isp + mn, true);\n\tfor (int i = 2; i < mn; i++) {\n\t\tif (!isp[i])continue;\n\t\tps.push_back(i);\n\t\tfor (int j = 2 * i; j < mn; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\tif (res == st.begin())return st.end();\n\tres--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\treturn res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n\ta = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n\ta = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n\ta = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n\ta = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = ""DRUL"";\nstring senw = ""SENW"";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\nvoid solve() {\n\tll n, k; cin >> n >> k;\n\tif (n % 2 == 0) {\n\t\tcout << ""YES\\n""; return;\n\t}\n\tif (k % 2) {\n\t\tcout << ""YES\\n""; return;\n\t}\n\tcout << ""NO\\n"";\n}\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//init();\n\t//while(true)\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\t\tsolve();\n\treturn 0;\n}']","[0, 1, 1, 0, 0]",800,Note that coins with denomination can be replaced with coins with denomination So if the answer exists then there is also such a set of coins where there is no more than one coin with denomination Therefore it is enough to iterate through the number of coins with denomination from to and check that the remaining number is non negative and even i e it can be represented as some number of coins with denomination 
Two polar bears Menshykov and Uslada from the St Petersburg zoo and elephant Horace from the Kiev zoo got six sticks to play with and assess the animals creativity Menshykov Uslada and Horace decided to make either an elephant or a bear from those sticks They can make an animal from sticks in the following way Four sticks represent the animal s legs these sticks should have the same length Two remaining sticks represent the animal s head and body The bear s head stick must be shorter than the body stick The elephant however has a long trunk so his head stick must be as long as the body stick Note that there are no limits on the relations between the leg sticks and the head and body sticks Your task is to find out which animal can be made from the given stick set The zoo keeper wants the sticks back after the game so they must never be broken even bears understand it ,"['#include <vector>\n#include <list>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <tr1/unordered_set>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nint main(){\n    map<int,int> S;\n    S.clear();\n    int f[6];\n    for(int i=0;i<6;i++){\n        scanf(""%d"",&f[i]);\n        S[f[i]]++;\n    }\n    bool flag=false;\n    for(int i=0;i<6;i++)\n        if(S[f[i]]>=4){\n            S[f[i]]-=4;\n            flag=true;\n            break;\n        }\n    if(!flag){\n        puts(""Alien"");\n        return 0;\n    }\n    flag=false;\n    for(int i=0;i<6;i++)\n        if(S[f[i]]==2)flag=true;\n    if(flag)puts(""Elephant"");\n    else puts(""Bear"");\n    return 0;\n}\n']","[0, 0, 1, 0, 0]",1100,Given six sticks and their lengths we need to decide whether we can make an elephant or a bear using those sticks The only common requirement for both animals is that four leg sticks should have same length This means that the answer Alien should be given only if we can t find four sticks for the legs Otherwise we will be able to make some animal The type of the animal will depend on the relation of the remaining sticks lengths If they are equal then it will an elephant if they are different we will have a bear So this algorithm should solve the problem Find the number which appears at least four times in the input If no such number exist then the answer is Alien Otherwise remove four entries of that number from the input After removing that number you will have two numbers left compare them and decide whether it s an elephant or a bear One shortcut for this problem might be to sort the input array then if it s a bear or an elephant then 3rd and 4th elements in the sorted should be animal s legs So you can assume that one of these numbers is the length of the leg and count how many times you see this number in the input Author s solution 7977022 Since the numbers in the input are very small you can implement brute force solution as well By brute force solution in this case I mean that you can actually check all possible values for leg length head length and body length If in total they give the same set as the input then you found a matching all you need is to check whether it s a bear or an elephant And it s an alien if you checked all possible combinations and found nothing matching to the input Though in this case the brute force solution is not easier than another one Checking all possible lengths solution 7975645 It seems that there were two common mistakes people were making in this problem Not taking into account that legs can be of the same length as body or head So you can t just count the number of distinct numbers in the input to decide which type of animal is that We assumed that people might make such a mistake there was a relevant warning in the statement Trying to sort the input and then check whether some elements in this array are equal to other elements and based on this comparison decide which type of animal is that People were simply making mistakes when deciding which elements to compare The correct way to implement this is Solution 7977214 This solution seems to be shorter but there are many failed solutions like this because people were not paying enough attention to the details So I would prefer implementing more straightforward approach Hope you liked the pictures 
Alice and Borys are playing tennis A tennis match consists of In each game one of the players is and the other one is Players serve in turns after a game where Alice is serving follows a game where Borys is serving and vice versa Each game ends with a victory of one of the players If a game is won by the serving player it s said that this player If a game is won by the receiving player it s said that this player It is known that Alice won a games and Borys won b games during the match It is unknown who served first and who won which games Find all values of k such that exactly k breaks could happen during the match between Alice and Borys in total ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint a, b;\n\tcin >> a >> b;\n\tint n = (a + b);\n\tint x = n / 2;\n\tint y = (n+1) / 2;\n\tset<int> val;\n\tfor(int _ = 0; _ < 2; _++){\n\t\tfor(int z = min(a, x) + min(b, y); z >= max(a + x, b + y) - n; z -= 2) val.insert(n - z);\n\t\tswap(a, b);\n\t}\n\tcout << val.size() << '\\n';\n\tfor(int z : val){\n\t\tcout << z << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","[0, 1, 0, 0, 0]",1300,First of all we don t know who served first but there are only two options so let s just try both and unite the sets of s we get Assume that Alice served first Exactly games were played If is even both players served exactly times and if is odd Alice served one more time than Borys The simplest way to consider both cases is to say that Alice served times and Borys served times denotes rounding up and denotes rounding down Let be the number of times Borys broke Alice s serve and let be the number of times Alice broke Borys serve In this case the number of games Alice won is and the number of games Borys won is We know neither nor but let s loop over From we can calculate If the values of and represent a valid scenario of the match with exactly breaks in total The case when Borys served first is handled similarly Analyzing the formulas further we can find a closed form solution Let If is even all possible values of are If is odd all possible values of are 
Analyzing the mistakes people make while typing search queries is a complex and an interesting work As there is no guaranteed way to determine what the user originally meant by typing some query we have to use different sorts of heuristics Polycarp needed to write a code that could given two words check whether they could have been obtained from the same word as a result of typos Polycarpus suggested that the most common typo is skipping exactly one letter as you type a word Implement a program that can given two distinct words and of the same length determine how many words of length are there with such property that you can transform into both and by deleting exactly one character Words and consist of lowercase English letters Word also should consist of lowercase English letters ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 100101\nint n;\nchar t[MAX],s[MAX];\nmain(){\n  make(n);\n  scanf(""%s%s"",t,s);\n  int a = 0;\n  while(t[a] == s[a])a++;\n  int b = 0;\n  while(t[n-b-1] == s[n-b-1])b++;\n  int wyn = 0;\n  int il = n-a-b-1;\n  bool cz = 1;\n  R(i,il)if(t[a+i] != s[a+i+1])cz = 0;\n  if(cz)wyn ++;\n  cz = 1;\n  R(i,il)if(t[a+i+1] != s[a+i])cz = 0;\n  if(cz)wyn ++;\n  printf(""%d\\n"",wyn);\n}']","[1, 0, 0, 1, 0]",1800,Suppose that S is obtained from W by deleteing the earlier symbol than T Then it is true that W A x B y C S A x B C T A B y C where x and y are deleted symbols and A B C are some possibly empty strings Let s calculate A as a longest common prefix of S and T and C as a longest common suffix Remove both of them from strings Now we now that x and y are respectively the first letter of string S and last letter of string T Remove them too The only thing left is to check if remaining parts of strings are equal Perform such operation for S and T and for T and S 
Your math teacher gave you the following problem There are n segments on the x axis l 1 r 1 l 2 r 2 ldots l n r n The segment l r includes the bounds i e it is a set of such x that l le x le r The length of the segment l r is equal to r l Two segments a b and c d have a common point intersect if there exists x that a leq x leq b and c leq x leq d For example 2 5 and 3 10 have a common point but 5 6 and 1 4 don t have You should add one segment which has at least one common point with each of the given segments and as short as possible i e has minimal length The required segment can degenerate to be a point i e a segment with length zero The added segment may or may not be among the given n segments In other words you need to find a segment a b such that a b and every l i r i have a common point for each i and b a is minimal ,"['//#pragma comment(linker, ""/stack:200000000"")\n//#pragma GCC optimize(""Ofast"")\n//#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//#pragma GCC optimize(""unroll-loops"")\n \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n \n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define plus fsghsf\n#define minus ytryr\n \nusing namespace std;\n \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n \nconst int N = 100000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-12;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nint main()\n{\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int T;\n    cin >> T;\n    while (T--) {\n        int n;\n        cin >> n;\n        int a1 = inf, a2 = -inf;\n        rep(i, 0, n) {\n            int l, r;\n            cin >> l >> r;\n            setmin(a1, r);\n            setmax(a2, l);\n        }\n        if (a1 <= a2) {\n            cout << a2 - a1 << ""\\n"";\n        } else {\n            cout << 0 << ""\\n"";\n        }\n    }\n    return 0;\n}']","[1, 1, 0, 0, 0]",1100,Find the left most right point for all segments call it r min The right most left point for all segments call it l max It s easy to see that the answer is max 0 l max r min 
The prehistoric caves of El Toll are located in Moi Barcelona You have heard that there is a treasure hidden in one of possible spots in the caves You assume that each of the spots has probability to contain a treasure You cannot get into the caves yourself so you have constructed a robot that can search the caves for treasure Each day you can instruct the robot to visit exactly distinct spots in the caves If none of these spots contain treasure then the robot will obviously return with empty hands However the caves are dark and the robot may miss the treasure even when visiting the right spot Formally if one of the visited spots does contain a treasure the robot will obtain it with probability otherwise it will return empty Each time the robot searches the spot with the treasure his success probability is independent of all previous tries that is the probability to miss the treasure after searching the right spot times is What is the expected number of days it will take to obtain the treasure if you choose optimal scheduling for the robot Output the answer as a rational number modulo Formally let the answer be an irreducible fraction then you have to output It is guaranteed that is not divisible by ,"['#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == \'-\')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - \'0\';\n\treturn x * f;\n}\n\nconst int mod = 1e9 + 7;\n\ninline int Qow(int x, int y)\n{\n\tint r = 1;\n\tfor (; y; y >>= 1, x = 1LL * x * x % mod)\n\t\tif (y & 1)\n\t\t\tr = 1LL * r * x % mod;\n\treturn r;\n}\n\ninline int F(int a, int q)\n{\n\tif (q <= 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn q;\n\treturn 1LL * (Qow(a, q) - 1) * Qow(a - 1, mod - 2) % mod;\n}\n\ninline int G(int a, int q)\n{\n\tif (q <= 0)\n\t\treturn 0;\n\tif (a == 1)\n\t\treturn (1LL * q * (q + 1) >> 1) % mod;\n\tint v = Qow(a - 1, mod - 2);\n\treturn 1LL * (1LL * (Qow(a, q) - 1) * a % mod * v % mod + mod - q) * v % mod;\n}\n\ninline int Solve(int n, int k, int A_1, int A_0, int B_1, int B_0, int S1_1, int S2_1, int S_0)\n{\n\tif (n == 1)\n\t\treturn (1LL * S1_1 * B_0 % mod * Qow(mod + 1 - B_1, mod - 2) + S_0) % mod;\n\t\n\tint q = (n - 1) / k, r = n - q * k, A__1, A__0, B__1, B__0, S1__1, S2__1, S__0, x, y;\n\t\n\tx = 1LL * B_1 * Qow(A_1, q - 1) % mod, y = (1LL * A_0 * B_1 % mod * F(A_1, q - 1) % mod + B_0) % mod;\n\tA__1 = Qow(x, mod - 2), A__0 = (mod - 1LL * y * A__1 % mod) % mod;\n\t\n\tx = 1LL * B_1 * Qow(A_1, q) % mod, y = (1LL * A_0 * B_1 % mod * F(A_1, q) % mod + B_0) % mod;\n\tB__1 = Qow(x, mod - 2), B__0 = (mod - 1LL * y * B__1 % mod) % mod;\n\n\tS1__1 = (1LL * S2_1 * A_1 % mod * F(A_1, q) + S1_1) % mod;\n\tS2__1 = (1LL * S2_1 * A_1 % mod * F(A_1, q - 1) + S1_1) % mod;\n\n\tS__0 = (1LL * S2_1 * A_0 % mod * (1LL * r * F(A_1, q) % mod + 1LL * k * G(A_1, q - 1) % mod) + S_0) % mod;\n\t\n\treturn Solve(k, r, A__1, A__0, B__1, B__0, S1__1, S2__1, S__0);\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(""data.in"", ""r"", stdin);\n#endif\n\tfor (int T = Read(); T; T --)\n\t{\n\t\tint n = Read(), k = Read(), d = __gcd(n, k);\n\t\tn /= d, k /= d;\n\t\tprintf(""%d\\n"", 1LL * Solve(n, k, 1, 1, mod + 1 >> 1, 1, 1, 1, 0) * Qow(n, mod - 2) % mod);\n\t}\n}\n']","[0, 1, 0, 0, 0]",3300,Let be the number of times we have checked spot after days Assuming that the spot contains the treasure we can see that the expected number of days to find the treasure is Hence the unconditional expectation of the answer is This formula implies that the optimal strategy is to keep the visiting frequencies for all spots as close as possible since the sum is minimized under when is the smoothest partition of One implementation of this strategy is to visit spots on day Note further that this strategy always visits spots in batches of size hence we can divide both and by their GCD Let us now consider an example of Let be the expected number of days to find the treasure in spot according to the optimal strategy above We can see that because a cell is visited on day iff the cell was visited on day We also have for the same reason except for that the cell was visited on the first day This argument allows to express say as a linear expression of itself and find the answer in time Another approach is to substitute the expressions until we cross the end of the sequence once also but We have obtained a similar set of linear relations of three spots with difference 2 To reduce to let us group by We can see that the total contribution of all for is a linear function in with coefficients depending on whether The main idea is that we continue this process with a different set of linear equations effectively obtaining Euclid s algorithm that stores some additional data Let us now describe the general solution Assume that we have a set of variables satisfying for and for Assume further that the answer Let For by applying relations and successively we obtain hence for Similarly for Also where It follows that the transformation produces the same answer In the end of this process we have hence we have a linear equation After finding the answer is The number of reductions of the above type is with each transformation possible to do in time and require fast matrix exponentation The total number of operations is per test 
You were dreaming that you are traveling to a planet named Planetforces on your personal spaceship Unfortunately its piloting system was corrupted and now you need to fix it in order to reach Planetforces Space can be represented as the XY plane You are starting at point 0 0 and Planetforces is located in point p x p y The piloting system of your spaceship follows its list of orders which can be represented as a string s The system reads s from left to right Suppose you are at point x y and current order is s i if s i text U you move to x y 1 if s i text D you move to x y 1 if s i text R you move to x 1 y if s i text L you move to x 1 y Since string s could be corrupted there is a possibility that you won t reach Planetforces in the end Fortunately Can you delete several orders possibly zero from s in such a way that you ll reach Planetforces after the system processes all orders ,"['#include<bits/stdc++.h>\nusing namespace std;\nmain(){\n    int t;\n    cin >> t;\n    while(t--){\n        int x, y;\n        string s;\n        cin >>x>>y>>s;\n        int l=0,r=0,d=0,u=0;\n        for(char i : s){\n            if(i==\'L\') l++;\n            if(i==\'R\') r++;\n            if(i ==\'U\') u++;\n            if(i == \'D\') d++;\n        }\n        if(x < 0) x = -x, swap(l,r);\n        if(y < 0) y = -y, swap(d,u);\n        if(r >= x && u >= y) cout<<""YES""<<endl;\n        else cout<<""NO""<<endl;\n    }\n}']","[1, 0, 0, 0, 0]",800,Hint 1 You can think of this problem as 2 independent 1D questions one is up and down and the other is left and right instead of 1 2D question Hint 2 For each 1D part what is the interval of positions that you can reach and see if the end point is in this interval Hint 3 The interval of up and down is The count of D The count of U and the interval of left and right is The count of L The count of R 
A sequence of n non negative integers n ge 2 a 1 a 2 dots a n is called good if for all i from 1 to n 1 the following condition holds true a 1 a 2 dots a i a i 1 a i 2 dots a n where denotes the bitwise AND operation You are given an array a of size n n geq 2 Find the number of permutations p of numbers ranging from 1 to n for which the sequence a p 1 a p 2 a p n is good Since this number can be large output it modulo 10 9 7 ,"['#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\nusing namespace std;\nconst int N = 200010;\nconst int mod = 1e9 + 7;\nint a[N];\nint b[N];\nvoid solve() {\n    int n;\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; ++i) scanf(""%d"", &a[i]);\n    for (int i = 0; i < n; ++i) b[i] = 0;\n    vector<int> v;\n    for (int j = 0; j < 30; ++j) {\n        int cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            if (a[i] & (1 << j)) cnt++;\n        }\n        if (cnt == n - 1) {\n            puts(""0"");\n            return;\n        }\n        for (int i = 0; i < n; ++i) {\n            if (cnt == n || !(a[i] & (1 << j))) b[i]++;\n        }\n    }\n    int cnt2 = 0;\n    for (int i = 0; i < n; ++i) {\n        if (b[i] == 30) cnt2++;\n    }\n    long long ans = cnt2 * 1ll * (cnt2 - 1) % mod;\n    for (int i = 1; i <= n - 2; ++i) ans = ans * i % mod;\n    printf(""%lld\\n"", ans);\n}\n\nint main() {\n#ifdef FLOWMASTER\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n    int t;\n    scanf(""%d"", &t);\n    for (int i = 0; i < t; ++i) solve();\n    return 0;\n}\n']","[0, 1, 0, 0, 0]",1400,Consider an arbitrary sequence First let us define the arrays and of length where and According to the definition of good sequence which means Now Also according to definition of good sequence This means that Similarly for all from to we get and Therefore for the sequence to be good and the must be a super mask of for all from to Initially we have an array Let the minimum value among these elements be Let the number of elements that have the value of be In order to rearrange the elements of to a good sequence we need to have and the remaining elements need to be a super mask of If we don t meet this criterion then the answer is Else the answer will be The time complexity is 
The translation from the Berland language into the Birland language is not an easy task Those languages are very similar a berlandish word differs from a birlandish word with the same meaning a little it is spelled and pronounced reversely For example a Berlandish word corresponds to a Birlandish word However it s easy to make a mistake during the translation Vasya translated word from Berlandish into Birlandish as Help him find out if he translated the word correctly ,"['#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<list>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<utility>\n#include<sstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I=(A);I<=(B);I++)\n#define REP(I,N) for(int I=0;I<(N);I++)\n#define ALL(X) (X).begin(),(X).end()\n#define VAR(A,B) __typeof(B) A=B\n#define FORE(I,X) for(VAR(I,(X).begin());I!=(X).end();I++)\n#define F first\n#define S second\n#define INF 1000000007\n#define PB push_back\n#define MP make_pair\ntypedef pair<int,int> PII;\ntypedef long long LL;\nstring a,b;\nchar tab[1007];\n\nint main(){\n\tscanf(""%s"",tab); a=tab;\n\tscanf(""%s"",tab); b=tab;\n\treverse(ALL(a));\n\tif (a==b) printf(""YES\\n"");\n\telse printf(""NO\\n"");\n}\n']","[0, 0, 1, 0, 0]",800,Many languages have built in reverse function for strings we can reverse one of the strings and check if it s equal to the other one or we can check it manually I prefer the second 
You re given integers k and n For each integer x from 1 to k count the number of integer arrays a such that all of the following are satisfied 1 leq a leq n where a represents the length of a 1 leq a i leq k for all 1 leq i leq a a 1 times a 2 times dots times a a x i e the product of all elements is x Note that two arrays b and c are different if either their lengths are different or if there exists an index 1 leq i leq b such that b i neq c i Output the answer modulo 998 244 353 ,"[""#include <bits/stdc++.h>using namespace std;\xa0static const int MOD = 998244353;static const int MAXK = 100000;\xa0inline long long modAdd(long long a, long long b) {\tlong long r = a + b;\tif (r >= MOD) r -= MOD;\treturn r;}inline long long modSub(long long a, long long b) {\tlong long r = a - b;\tif (r < 0) r += MOD;\treturn r;}inline long long modMul(long long a, long long b) {\treturn (a % MOD) * (b % MOD) % MOD;}long long modExp(long long base, long long exp) {\tlong long result = 1 % MOD;\tbase %= MOD;\twhile (exp > 0) {\t\tif (exp & 1) result = (result * base) % MOD;\t\tbase = (base * base) % MOD;\t\texp >>= 1;\t}\treturn result;}inline long long modInv(long long x) {\treturn modExp(x, MOD-2);}\xa0static int spf[MAXK+1];  void build_spf() {\tfor (int i = 2; i <= MAXK; i++) {\t\tif (!spf[i]) { \t\t\t// i is prime\t\t\tfor (long long j = (long long)i; j <= MAXK; j += i) {\t\t\t\tif (!spf[j]) spf[j] = i;\t\t\t}\t\t}\t}}\xa0vector<pair<int,int>> factor_small(int x) {\tvector<pair<int,int>> f;\twhile (x > 1) {\t\tint p = spf[x];\t\tint cnt = 0;\t\twhile (spf[x] == p) {\t\t\tx /= p;\t\t\tcnt++;\t\t}\t\tf.push_back({p,cnt});\t}\treturn f;}\xa0typedef long long ll;typedef vector<ll> Poly;Poly polyMul(const Poly &A, const Poly &B) {\tPoly C(A.size()+B.size()-1, 0LL);\tfor (size_t i=0; i<A.size(); i++){\t\tfor (size_t j=0; j<B.size(); j++){\t\t\tC[i+j] = modAdd(C[i+j], modMul(A[i], B[j]));\t\t}\t}\treturn C;}\xa0// P(m) = ( (m + 0)*(m + 1)*...*(m + a-1) ) / a!Poly bino(int a) {\tif (a == 0) {\t\treturn Poly(1, 1LL);\t}\tPoly res(1, 1LL); // constant 1\tfor(int j=0; j<a; j++){\t\tPoly tmp(res.size()+1, 0LL);\t\tfor (size_t i=0; i<res.size(); i++){\t\t\tll coeff = res[i];\t\t\t// (m + j) => \t\t\t//    newPoly[i+1] += coeff (coefficient for m^(i+1))\t\t\t//    newPoly[i]   += j*coeff\t\t\ttmp[i+1] = modAdd(tmp[i+1], coeff);\t\t\ttmp[i]   = modAdd(tmp[i], modMul(coeff, j));\t\t}\t\tres.swap(tmp);\t}\xa0\t// divide by a! mod\tstatic bool factInit = false;\tstatic ll fact[40], invfact[40];\tif (!factInit) {\t\tfactInit = true;\t\tfact[0]=1; for(int i=1;i<40;i++) fact[i]=modMul(fact[i-1], i);\t\tinvfact[39] = modInv(fact[39]);\t\tfor(int i=38;i>=0;i--){\t\t\tinvfact[i] = modMul(invfact[i+1], i+1);\t\t}\t}\tll invA = invfact[a]; // 1/(a!) mod\tfor (auto &c : res) {\t\tc = modMul(c, invA);\t}\treturn res;}static const int MAXP = 16; \xa0static vector<ll> sumPoly[MAXP+1];long long evalPoly(const Poly &poly, long long x) {\tlong long ans = 0;\tfor (int i=(int)poly.size()-1; i>=0; i--){\t\tans = modMul(ans, x);\t\tans = modAdd(ans, poly[i]);\t}\treturn ans;}long long sumpow(long long n, int p) {\tif (n < 0) return 0; // safety\treturn evalPoly(sumPoly[p], n);}void bsp() {\tfor(int p=0; p<=MAXP; p++){\t\tvector<long long> X(p+2), Y(p+2);\t\tX[0] = 0; Y[0] = 0;\t\tfor(int i=1; i<=p+1; i++){\t\t\tX[i] = i;\t\t\t// i^p mod\t\t\tlong long ipow = 1;\t\t\tfor(int r=0;r<p;r++){\t\t\t\tipow = modMul(ipow, i);\t\t\t}\t\t\tY[i] = modAdd(Y[i-1], ipow); \t\t}\t\tint L = p+2; // number of points\t\tvector<vector<long long>> F(L, vector<long long>(L,0LL));\t\tfor(int i=0;i<L;i++){\t\t\tF[i][0] = Y[i] % MOD;\t\t}\t\tfor(int j=1;j<L;j++){\t\t\tfor(int i=0; i<L-j;i++){\t\t\t\tlong long num = modSub(F[i+1][j-1], F[i][j-1]);\t\t\t\tlong long den = modSub(X[i+j], X[i]); // X[i+j] - X[i]\t\t\t\tlong long invDen = modInv((den+MOD)%MOD);\t\t\t\tF[i][j] = modMul(num, invDen);\t\t\t}\t\t}\t\tPoly res(1, 0LL);\t\tPoly curTerm(1, 1LL);\t\tfor(int j=0;j<L;j++){\t\t\tlong long coeff = F[0][j];\t\t\tPoly polyTerm(curTerm.size());\t\t\tfor(size_t u=0; u<curTerm.size(); u++){\t\t\t\tpolyTerm[u] = modMul(curTerm[u], coeff);\t\t\t}\t\t\tif (polyTerm.size() > res.size())\t\t\t\tres.resize(polyTerm.size(), 0);\t\t\tfor(size_t u=0; u<polyTerm.size(); u++){\t\t\t\tres[u] = modAdd(res[u], polyTerm[u]);\t\t\t}\t\t\tif (j+1 < L) {\t\t\t\tPoly newCur(curTerm.size()+1, 0LL);\t\t\t\tfor(size_t i=0; i<curTerm.size(); i++){\t\t\t\t\tnewCur[i+1] = modAdd(newCur[i+1], curTerm[i]);\t\t\t\t\tlong long tmp = modMul(curTerm[i], (MOD - (X[j] % MOD)));\t\t\t\t\tnewCur[i] = modAdd(newCur[i], tmp);\t\t\t\t}\t\t\t\tcurTerm.swap(newCur);\t\t\t}\t\t}\t\tsumPoly[p] = res;  // store\t}}\xa0int main(){\tios::sync_with_stdio(false);\tcin.tie(nullptr);\xa0\tbuild_spf();\tbsp();\tint t;\tcin >> t;\twhile(t--){\t\tlong long n;\t\tint k;\t\tcin >> k >> n;\xa0\t\tvector<long long> ans(k+1, 0);\xa0\t\tfor(int x=1; x<=k; x++){\t\t\tauto factx = factor_small(x);\t\t\tPoly polyRes(1, 1LL);\t\t\tfor (auto &pe : factx) {\t\t\t\tint expnt = pe.second;\t\t\t\tPoly pf = bino(expnt); \t\t\t\tpolyRes = polyMul(polyRes, pf);\t\t\t}\t\t\tlong long total = 0;\t\t\tfor (int i=0; i<(int)polyRes.size(); i++){\t\t\t\tif (polyRes[i] != 0) {\t\t\t\t\tlong long c = polyRes[i];\t\t\t\t\tlong long sp = sumpow(n, i);\t\t\t\t\ttotal = modAdd(total, modMul(c, sp));\t\t\t\t}\t\t\t}\t\t\tans[x] = total;\t\t}\t\tfor(int x=1; x<=k; x++){\t\t\tcout << ans[x];\t\t\tif (x<k) cout << ' ';\t\t}\t\tcout << '\\n';\t}\treturn 0;}""]","[0, 0, 0, 1, 0]",2200,The naive solution is to define fk n as the number of arrays containing n elements with a product of k We could then try to compute this by considering the last element of the array among the divisors of k giving us fk n j kfj n 1 with fk 1 1 The answers would then be ni 1f1 i ni 1f2 i ni 1fk i However this leads to an O nklogk solution which exceeds our time constraints We need to optimize this approach We can prove that there are at most 16 non 1 elements in our arrays This is because The prime factorization of k p1p2 pt divides k into the most non 1 elements With 17 non 1 elements the smallest possible value would be k 217 131072 105 Based on this observation we can define our dynamic programming state as Let dp i j represent the number of arrays with product i containing only j non 1 elements The recurrence relation becomes dp i j p i p 1dp ip j 1 Base case dp i 1 1 for i 1 This computation has a time complexity of O klog2k as we perform kj 1d j O klogk additions for each i To calculate fk n we Enumerate the number of non 1 elements from 1 to 16 For j non 1 elements in the array We have n j elements that are 1 We need to choose j positions for non 1 elements Fill these positions with dp k j possible sequences This gives us fk n 16j 1 nj dp k j Therefore i 1nfk n i 1n j 116 ij dp k j j 116 dp k j i 1n ij j 116 n 1j 1 dp k j Note that ni 1 ij n 1j 1 is given by the Hockey Stick Identity Each answer can be calculated in O log2k time giving an overall time complexity of O klog2k 
You are given an undirected unweighted graph consisting of n vertices and m edges which represents the map of Bertown and the array of prices p of length m It is guaranteed that there is a path between each pair of vertices districts Mike has planned a trip from the vertex district a to the vertex district b and then from the vertex district b to the vertex district c He can visit the same district twice or more But there is one issue authorities of the city want to set a price for using the road so if someone goes along the road then he should pay the price corresponding to this road The list of prices that will be used p is ready and they just want to distribute it between all roads in the town in such a way that each price from the array corresponds to exactly one road You are a good friend of Mike and suddenly a mayor of Bertown and want to help him to make his trip as cheap as possible So your task is to distribute prices between roads in such a way that if Mike chooses the optimal path then the price of the trip is the possible You have to answer t independent test cases ,"['#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=200000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) (x)&(-x)\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 998244353\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<\'0\') || (ch>\'9\')) {if (ch==\'-\') f=-1;ch=getchar();}\n    while ((ch>=\'0\') && (ch<=\'9\')) {x=x*10+(ch-\'0\');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n\t#define N 100000\n\n\tint fac[N+100],invfac[N+100];\n\n\tint add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n\tint dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n\tint mul(int x,int y) {return 1ll*x*y%maxd;}\n\tll qpow(ll x,int y)\n\t{\n\t\tll ans=1;\n\t\twhile (y)\n\t\t{\n\t\t\tif (y&1) ans=mul(ans,x);\n\t\t\tx=mul(x,x);y>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n\tint getinv(int x) {return qpow(x,maxd-2);}\n\n\tint C(int n,int m)\n\t{\n\t\tif ((n<m) || (n<0) || (m<0)) return 0;\n\t\treturn mul(mul(fac[n],invfac[m]),invfac[n-m]);\n\t}\n\n\tvoid math_init()\n\t{\n\t\tfac[0]=invfac[0]=1;\n\t\trep(i,1,N) fac[i]=mul(fac[i-1],i);\n\t\tinvfac[N]=getinv(fac[N]);\n\t\tper(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n\t}\n\t#undef N\n}\nusing namespace My_Math;\n\nstruct node{int to,nxt;}sq[N<<1];\nint all=0,head[N];\nint n,m,a,b,c,dis[3][N];\nbool vis[N];\nll w[N];\nstruct hnode{int u,dis;};\nbool operator <(hnode p,hnode q) {return p.dis>q.dis;}\npriority_queue<hnode> q;\n\nvoid addedge(int u,int v)\n{\n\t//cout << ""edge "" << u << "" "" << v << endl;\n\tall++;sq[all].to=v;sq[all].nxt=head[u];head[u]=all;\n}\n\nvoid dij(int st,int *dis)\n{\n\t//cout << ""start "" << st << endl;\n\trep(i,1,n) dis[i]=maxd,vis[i]=0;\n\tq.push((hnode){st,0});dis[st]=0;\n\t//rep(i,1,n) cout << dis[i] <<"" "";cout << endl;\n\twhile (!q.empty())\n\t{\n\t\tint u=q.top().u;q.pop();\n\t\tif (vis[u]) continue;vis[u]=1;\n\t\t//cout << ""now "" << u << endl;\n\t\tgo(u,i)\n\t\t{\n\t\t\t//cout << ""towards "" << v << endl;\n\t\t\tif (dis[v]>dis[u]+1)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tif (!vis[v]) q.push((hnode){v,dis[v]});\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i,1,n) cout << dis[i] << "" "";cout << endl;\n}\n\nll calc(int l,int r) \n{\n\tif (r>m) return 1e18;\n\telse return w[r]-w[l-1];\n}\n\nint main()\n{\n\tint T=read();\n\twhile (T--)\n\t{\n\t\tn=read();m=read();a=read();b=read();c=read();\n\t\trep(i,1,m) w[i]=read();\n\t\tsort(w+1,w+1+m);\n\t\trep(i,1,m) w[i]+=w[i-1];\n\t\trep(i,1,m)\n\t\t{\n\t\t\tint u=read(),v=read();\n\t\t\taddedge(u,v);addedge(v,u);\n\t\t}\n\t\tdij(b,dis[0]);dij(a,dis[1]);dij(c,dis[2]);\n\t\t//rep(i,1,n) cout << dis[0][i] << "" "";\n\t\t//cout << endl;\n\t\tll ans=1e18;\n\t\trep(i,1,n)\n\t\t{\n\t\t\tint x=dis[0][i],y=dis[1][i],z=dis[2][i];\n\t\t\t//cout << i << "" "" << x << "" ""<< y << "" ""<< z << endl;\n\t\t\tll now=calc(1,x)*2+calc(x+1,x+y)+calc(x+y+1,x+y+z);\n\t\t\t//cout << now << endl;\n\t\t\tans=min(ans,now);\n\t\t}\n\t\tprintf(""%lld\\n"",ans);\n\t\trep(i,1,n) head[i]=0;all=0;\n\t}\n\treturn 0;\n}\n\n\n\n']","[1, 0, 0, 0, 0]",2100,If we distribute costs optimally then this pair of paths and can look like just a straight path that doesn t visit the same vertex twice or like three straight paths with one intersection point The first case is basically a subcase of the second one with the intersection point or So if we fix the intersection point then these two paths and become four paths and We can notice that each path we denoted should be the shortest possible because if it isn t the shortest one then we used some prices that we couldn t use Let the length of the shortest path from to be Then it is obvious that for the fixed intersection point we don t need to use more than smallest costs Now we want to distribute these costs between these three paths somehow We can see that the path from to is used twice so it is more optimally to distribute the smallest costs along this part So let be the sum of the first smallest costs just prefix sums on the sorted array Then for the intersection point the answer is if We can calculate distances from and to each vertex with three runs of bfs Time complexity 
Some number of people this number is even have stood in a circle The people stand in the circle evenly They are numbered clockwise starting from a person with the number 1 Each person is looking through the circle s center at the opposite person You don t know the exact number of people standing in the circle but this number is even no doubt It is known that the person with the number a is looking at the person with the number b and vice versa of course What is the number associated with a person being looked at by the person with the number c If for the specified a b and c no such circle exists output ,"['/*#pragma GCC optimize(""Ofast"")\n#pragma GCC optimize(""unroll-loops"")\n#pragma GCC target(""avx,avx2,fma"")*/\n// only when really needed\n\n/* GNU G++17 7.3.0: No long long for faster code\n   GNU G++17 9.2.0 (64 bit, msys 2): Long long only for faster code */\n \n#include <bits/stdc++.h>\n  \n#define for1(i,a,b) for (int i = a; i <= b; i++)\n#define for2(i,a,b) for (int i = a; i >= b; i--)\n#define int long long\n\n#define sz(a) (int)a.size()\n#define pii pair<int,int>\n \n/*\n__builtin_popcountll(x) : Number of 1-bit\n__builtin_ctzll(x) : Number of trailing 0\n*/\n \n#define PI 3.1415926535897932384626433832795\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define MOD2 1000000009\n#define EPS 1e-6\n\nusing namespace std;\n\nsigned main() {\n    \n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    // freopen(""cf.inp"", ""r"", stdin);\n    // freopen(""cf.out"", ""w"", stdout);\n\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int a, b, c;\n        cin >> a >> b >> c;\n\n        if (a > b) swap(a, b);\n        int p = (b - a) + (b - a);\n        if (c > p) cout << ""-1\\n"";\n        else if (p < max(a, b)) cout << ""-1\\n"";\n        else {\n            if (c > b - a) cout << c - (b - a) << ""\\n"";\n            else cout << c + (b - a) << ""\\n"";\n        }\n    }\n    \n}']","[0, 1, 0, 0, 0]",800,The person with the number looks at the person with the number so the count of people standing to the left of between and is equal to the count of people standing to the right of between and Therefore both counts are equal to hence must be a solution of the equation The only solution of the equation is Let s check that in the circle of people can occur the numbers and i e let s check that If it s false there s no solution output Since the person with the number looks at the person with the number the condition must be met Let s solve the equation for There are two solutions We can output any of such that It s easy to prove that exactly one of the solutions meets the condition 
You are given an integer x and an array of integers a 1 a 2 ldots a n You have to determine if the number a 1 a 2 ldots a n is divisible by x Here k is a factorial of k the product of all positive integers less than or equal to k For example 3 1 cdot 2 cdot 3 6 and 5 1 cdot 2 cdot 3 cdot 4 cdot 5 120 ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, x;\n    std::cin >> n >> x;\n    \n    std::vector<int> cnt(x + 1);\n    for (int i = 0; i < n; i++) {\n        int a;\n        std::cin >> a;\n        cnt[std::min(a, x)]++;\n    }\n    \n    for (int i = 1; i < x; i++) {\n        if (cnt[i] % (i + 1)) {\n            std::cout << ""No\\n"";\n            return 0;\n        }\n        cnt[i + 1] += cnt[i] / (i + 1);\n    }\n    std::cout << ""Yes\\n"";\n    \n    return 0;\n}']","[0, 1, 0, 0, 0]",1600,Let s create an array where equals to number of elements equals to in the initial array Note that equals to sum of over all from to does not affect anything because divides itself We have to check if this sum is divisible by Suppose there exists some such that In this case we can make two transformations and the sum of will not change because Let s perform this operation until it is possible for all numbers from to After all operations the sum of will not change and for each the inequality will be satisfied because if we could perform an operation with this element Let s see what is the maximum value of sum of over all from to after all operations We know that for all so the maximum value of the sum is the sum of over all Note that It means that the sum of such values over all from to equals to Each factorial from to will be added and subtracted from the sum So the result is So the only one case when this sum is divisible by is when the sum equals to It means that equals to zero for all from to after performing all operations Time complexity 
Alice and Bob have received three big piles of candies as a gift Now they want to divide these candies as fair as possible To do this Alice takes one pile of candies then Bob takes one of the other two piles The last pile is split between Alice and Bob as they want for example it is possible that Alice takes the whole pile and Bob gets nothing from it After taking the candies from the piles if Alice has more candies than Bob she discards some candies so that the number of candies she has is equal to the number of candies Bob has Of course Bob does the same if he has more candies Alice and Bob want to have as many candies as possible and they plan the process of dividing candies accordingly Please calculate the maximum number of candies Alice can have after this division process of course Bob will have the same number of candies You have to answer q independent queries Let s see the following example 1 3 4 Then Alice can choose the third pile Bob can take the second pile and then the only candy from the first pile goes to Bob then Alice has 4 candies and Bob has 4 candies Another example is 1 10 100 Then Alice can choose the second pile Bob can choose the first pile and candies from the third pile can be divided in such a way that Bob takes 54 candies and Alice takes 46 candies Now Bob has 55 candies and Alice has 56 candies so she has to discard one candy and after that she has 55 candies too ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int q;\n    scanf(""%d"", &q);\n    while (q--) {\n        long long a, b, c;\n        scanf(""%lld%lld%lld"", &a, &b, &c);\n        printf(""%lld\\n"", 1LL * (a + b + c) / 2);\n    }\n    return 0;\n}']","[0, 1, 0, 0, 0]",800,The answer is always Let s understand why it is so Let Then let Bob take the pile with candies and Alice take the pile with candies Then because of we can see that Bob s pile always can reach size of Alice s pile and remaining candies can be divided between them fairly except one candy if is odd 
 Polycarp is a very famous freelancer His current rating is r units Some very rich customers asked him to complete some projects for their companies To complete the i th project Polycarp needs to have at least a i units of rating after he completes this project his rating will change by b i his rating will increase or decrease by b i b i can be positive or negative Polycarp s rating should not fall below zero because then people won t trust such a low rated freelancer Polycarp can choose the order in which he completes projects Furthermore he can even skip some projects altogether To gain more experience and money of course Polycarp wants to choose the subset of projects and the order in which he will complete them so he has enough rating before starting each project and has non negative rating after completing each project Your task is to calculate the maximum possible size of such subset of projects ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Project {\n\tint a, b;\n};\n\nvoid maximize(int &a, int b) {\n\tif (a < b) a = b;\n}\n\nint main() {\n\tint n, r;\n\tcin >> n >> r;\n\t\n\tvector<Project> pos, neg;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tif (b >= 0) {\n\t\t\tpos.push_back({a, b});\n\t\t} else {\n\t\t\tneg.push_back({a, -b});\n\t\t}\n\t}\n\n\tsort(begin(pos), end(pos), [](const Project &x, const Project &y) { return x.a < y.a; });\n\tint res = 0;\n\tfor (auto it : pos) {\n\t\tif (r >= it.a) {\n\t\t\tr += it.b;\n\t\t\t++res;\n\t\t}\n\t}\n\n\tsort(begin(neg), end(neg), [](const Project &x, const Project &y) { return x.a - x.b > y.a - y.b; });\n\tvector< vector<int> > dp(neg.size() + 1, vector<int>(r + 1, -1));\n\tdp[0][r] = 0;\n\tfor (int i = 0; i < neg.size(); ++i) {\n\t\tfor (int j = 0; j <= r; ++j) if (dp[i][j] >= 0) {\n\t\t\tif (j >= max(neg[i].a, neg[i].b)) {\n\t\t\t\tmaximize(dp[i + 1][j - neg[i].b], dp[i][j] + 1);\n\t\t\t}\n\t\t\tmaximize(dp[i + 1][j], dp[i][j]);\n\t\t}\n\t}\n\tcout << res + *max_element(begin(dp[neg.size()]), end(dp[neg.size()])) << endl;\n}']","[1, 0, 0, 1, 0]",2300,To view the main idea of the problem read the editorial of easy version The only difference is that for non negative we don t need to print if we cannot take the project we just need to skip it because we cannot take it at all And for negative we need to write the knapsack dynamic programming to take the maximum possible number of projects we need to consider them in order of their sorting Dynamic programming is pretty easy means that we consider projects and our current rating is and the value of dp is the maximum number of negative projects we can take If the current project is the th negative project in order of sorting we can do two transitions and if then we can make the transition And then we just need to find the maximum value among all values of dp and add the number of positive projects we take to find the answer 
You are given two integers n and m You have to construct the array a of length n consisting of i e integers greater than or equal to zero such that the sum of elements of this array is m and the value sum limits i 1 n 1 a i a i 1 is the maximum possible Recall that x is the absolute value of x In other words you have to maximize the sum of absolute differences between adjacent consecutive elements For example if the array a 1 3 2 5 5 0 then the value above for this array is 1 3 3 2 2 5 5 5 5 0 2 1 3 0 5 11 Note that this example but it shows how the required value for some array is calculated You have to answer t independent test cases ,"['#include <bits/stdc++.h>\n#define int long long \nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count()); //uid<int> u1(5, 10); u1(rnd);\n    long long powmod(long long a,long long b,long long mod) {\n        if (b==0 || a==1)  {if (mod==1) return 0; else return 1; }\n       \n        if (b%2==0) { long long k=powmod(a,b/2,mod); return (k*k)%mod; }\n        else {long long k=powmod(a,b/2,mod); return ( (k*k) %mod *a)% mod; }\n    }\n    long long gcd(long long a, long long b) {\n        if (a==0) return b;\n        if (b==0) return a;\n        if (a>b) return gcd(a%b,b); else return gcd(b%a,a);\n    }\n      int prime(int p) { // 1 - \n        for (int i=2;i*i<=p;i++) {\n            if (p%i==0 && i<p) return i;  \n        }\n        return 1;\n    }\n    \n     int inv(int a, int mod) {\n        return powmod(a,mod-2,mod); \n    }\n  int random_modul() {\n    \n    uniform_int_distribution <int> u1(5e8, 1e9);\n    int pepega=u1(rnd); \n    while (prime(pepega)!=1) pepega=u1(rnd); \n    return pepega; \n}\n \n \n    void solve () {\n       \n       \n         /* --------- */\n            \n           int a,b;\n           cin>>a>>b;\n           if (a==1) {cout<<""0\\n""; return; }\n           if (a==2) {cout<<b<<""\\n""; return; }\n           cout<<2*b<<""\\n""; return; \n            \n   \n         /* --------- */  \n            return;\n    }\n     \n     \n     \n    signed main() {\n       ios_base::sync_with_stdio(0); \n       cin.tie(0);\n       cout.tie(0); \n       \n       //  cout<<fixed<<setprecision(10); \n       \n          int tututu;\n          tututu=1;\n          \n        cin>>tututu; //   ,  \n        \n          for (int qwerty=0;qwerty<tututu;qwerty++) solve();\n      \n       \n        return 0;\n    }']","[1, 1, 0, 0, 0]",800,If then the answer is Otherwise the best way is to construct the array For we can t reach answer more than and for we can t reach the answer more than because each unit can t be used more than twice So the answer can be represented as 
You are given an array a of n integers You can perform the following operations on array elements choose any index i 1 le i le n and move the element a i to the of the array choose any index i 1 le i le n and move the element a i to the of the array For example if n 5 a 4 7 2 3 9 then the following sequence of operations can be performed after performing the operation of the first type to the second element the array a will become 7 4 2 3 9 after performing the operation of the second type to the second element the array a will become 7 2 3 9 4 You can perform operations of any type any number of times in any order Find the minimum total number of operations of the first and second type that will make the a array sorted in non decreasing order In other words what is the minimum number of operations that must be performed so the array satisfies the inequalities a 1 le a 2 le ldots le a n ,"[""#include <bits/stdc++.h> \nusing namespace std;\n#define fl(i,a,b) for(int i=a;i<b;i++)\n#define ff first\n#define ss second\n#define endl '\\n'\n#define pb push_back\n#define khushi ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\ntypedef long long ll;\nconst int  mod  = 1000000007;\n#define int long long\nconst int mx = 200005;\nvoid f()\n{\n\tint n;\n\tcin >> n;\n\tint dp[n + 1] = {0};\n\tint arr[n + 1];\n\tarr[0] = -5;\n\tvector<int> comp;\n\tfl(i,1,n + 1)\n\t{\n\t\tcin >> arr[i];\n\t\tcomp.pb(arr[i]);\n\t}\n\tsort(comp.begin(), comp.end());\n\tcomp.resize(unique(comp.begin(), comp.end()) - comp.begin());\n\tfl(i,1,n + 1)\n\t{\n\t\tarr[i] = upper_bound(comp.begin(), comp.end(),arr[i]) - comp.begin();\n\t}\n\tfl(i,1,n + 1)\n\t{\n\t\tdp[i] = 0;\n\t}\n\tint ans = 0;\n\tfl(i,1,n + 1)\n\t{\n\t\tdp[i] = 1;\n\t\tfl(j,0,i)\n\t\t{\n\t\t\tif(arr[j] + 1 ==  arr[i])\n\t\t\t{\n\t\t\t\tdp[i] = max(dp[i],dp[j] + 1);\n\t\t\t}\n\t\t}\n\t\tans = max(ans,dp[i]);\n\t}\n\tcout << n - ans << endl;\n}\nmain()\n{\n\tkhushi;\n\tint t = 1;\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tf();\n\t}\n}""]","[1, 0, 0, 1, 0]",2100,Let s replace each number ai with the number of unique numbers less than ai For example the array a 3 7 1 2 1 3 will be replaced by 2 3 0 1 0 2 Note that the values of the numbers themselves were not important to us only the order between them was important Let s sort such an array Let s see what maximum length of the segment from the array a is already sorted it forms a subsequence This segment can be left in place and all other numbers can be moved either to the beginning or to the end That is the task came down to finding the maximum sorted subsequence in the array This problem can be solved with the help of simple dynamic programming Let dp i be the maximum length of a subsequence ending in position i To calculate it we will find the closest past position which also has the value a i and the position with value a i 1 lower numbers cannot be used since a i 1 must stand between them Any of these positions can be extended so we take the maximum out of them and add 1 It is necessary to separately consider the first numbers in the subsequence and the last since the first should include their suffix and the last should have their prefix 
Being a physicist Charlie likes to plan his life in simple and precise terms For the next m months starting with no money Charlie will work hard and earn x pounds per month For the i th month 1 le i le m there ll be a single opportunity of paying cost c i pounds to obtain one unit of happiness You cannot buy more than one unit each month Borrowing is not allowed Money earned in the i th month can only be spent in a later j th month j i Since physicists don t code help Charlie find the maximum reachable units of happiness ,"['#include <iostream>#include <cmath>#include <algorithm>#include <vector>#include <chrono>#include <random>#include <map>#include <set>using namespace std;typedef long long ll;const int N = 2e5 + 10;int tree[4 * N];int lazy[4 * N];pair<int, int> a[N];int m, x, c;bool cmp(pair<int, int> x, pair<int, int> y) {\tif (x.first != y.first) return x.first < y.first;\treturn x.second > y.second;}void pushh(int v, int tl, int tr) {\tif (!lazy[v]) return;\tif (tl != tr) {\t\tlazy[2 * v] += lazy[v];\t\ttree[2 * v] -= lazy[v];\t\tlazy[2 * v + 1] += lazy[v];\t\ttree[2 * v + 1] -= lazy[v];\t}\tlazy[v] = 0;}void build_tree(int v, int tl, int tr) {\tlazy[v] = 0;\tif (tl == tr) {\t\ttree[v] = ((tl - 1) * 1ll * x);\t}\telse {\t\tint tm = (tl + tr) / 2;\t\tbuild_tree(2 * v, tl, tm);\t\tbuild_tree(2 * v + 1, tm + 1, tr);\t\ttree[v] = min(tree[2 * v], tree[2 * v + 1]);\t}}void update(int v, int tl, int tr, int l, int r, int val) {\tif (tl > r || tr < l) return;\tif (tl >= l && tr <= r) {\t\ttree[v] -= val;\t\tlazy[v] += val;\t\treturn;\t}\tpushh(v, tl, tr);\tint tm = (tl + tr) / 2;\tupdate(2 * v, tl, tm, l, r, val);\tupdate(2 * v + 1, tm + 1, tr, l, r, val);\ttree[v] = min(tree[2 * v], tree[2 * v + 1]);}int Min(int v, int tl, int tr, int l, int r) {\tif (tl > r || tr < l) return 1000000000;\tif (tl >= l && tr <= r) {\t\t//cout << tl << "" "" << tr << "" "" << tree[v] << ""\\n"";\t\treturn tree[v];\t}\tpushh(v, tl, tr);\tint tm = (tl + tr) / 2;\treturn min(Min(2 * v, tl, tm, l, r), \t\tMin(2 * v + 1, tm + 1, tr, l, r));}void solve() {\tcin >> m >> x;\tfor (int i = 1; i <= m; i++) {\t\tcin >> a[i].first;\t\ta[i].second = i;\t}\tbuild_tree(1, 1, m);\tsort(a + 1, a + m + 1, cmp);\tint ans = 0;\tfor (int i = 1; i <= m; i++) {\t\tint w = Min(1, 1, m, a[i].second, m);\t\t//cout << ""? "" << w << ""\\n"";\t\tif (a[i].first <= w) {\t\t\tupdate(1, 1, m, a[i].second, m, a[i].first);\t\t\tans++;\t\t}\t} \tcout << ans << ""\\n"";}int main() {\tint t;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}']","[1, 0, 0, 0, 1]",2000,Let us consider the smallest element and the rightmost if equal Suppose we do not take it Now we emulate the decisions from the first month up to month Note that if we chose some element on the left of we could have chosen the smallest one instead Thus we can go greedy go over the costs in the sorted order and check whether we can take it To check whether there are enough pounds from the previous months we can use the segment tree When we take the happiness during month we need to reduce the amount of pounds on the left by This greedy approach can be implemented simpler We just need to go over the costs from the first month and maintain the heap or set priority queue of chosen costs When we go over a new cost we check whether we can pay for it and if positive we add it to our answer Otherwise we remove the largest chosen cost from the heap compare it with the current cost and put back the smaller one 
Allen is hosting a formal dinner party 2n people come to the event in n pairs couples After a night of fun Allen wants to line everyone up for a final picture The 2n people line up but Allen doesn t like the ordering Allen prefers if each pair occupies adjacent positions in the line as this makes the picture more aesthetic Help Allen find the minimum number of swaps of positions he must perform to make it so that each couple occupies adjacent positions in the line ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n,p,ans;\nVI v[1010];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,2*n) {\n\t\tscanf(""%d"",&p); --p;\n\t\tv[p].pb(i);\n\t}\n\trep(i,0,n) rep(j,i+1,n) {\n\t\tauto p1=v[i],p2=v[j];\n\t\tif (p1[0]>p2[0]) swap(p1,p2);\n\t\tif (p1[1]<p2[0]) ans+=0;\n\t\telse if (p1[1]>p2[1]) ans+=2;\n\t\telse ans+=1;\n\t}\n\tprintf(""%d\\n"",ans);\n}\n']","[1, 1, 1, 0, 0]",1400,We describe a greedy algorithm that achieves the minimum number of swaps If the leftmost person is in pair swap the other person in pair left to the second position Now the first two people are both in pair and we repeat the process on the remaining pairs of people recursively We now prove that this number of swaps is optimal and we accomplish this by showing that every swap we made is necessary For two pairs numbered and we can consider the number of times people of pair and are swapped by our process There are possible relative orderings and In the case our algorithm will never swap and In the case any correct swap sequence must swap and at least once and our algorithm will swap the second left of the first when is the leftmost person In the case any correct swap sequence must swap and at least twice and our algorithm will swap the second left of both when is the leftmost person Therefore every swap in our greedy algorithm is necessary so it is optimal We can directly simulate this algorithm in time We can also use data structures such as a binary indexed tree or balanced binary search tree to compute the answer in Maybe it can be even done in anyone 
An undirected graph is called if the degrees of all its vertices are equal An edge of a connected graph is called a if after removing it the graph is being split into two connected components Build a connected undirected regular graph containing at least one bridge or else state that such graph doesn t exist ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst double EPS = 1e-9;\nconst int oo = 0x3f3f3f3;\nconst int MAXN = (int)1e5 + 10;\n\nvoid print(int s, int k){\n\n    for (int i = 1; i < k; ++i){\n        cout << s << "" "" << s + i << endl;\n        if (i % 2 == 0)\n            cout << s + k - 1 + i << "" "" << s + k - 2 + i << endl;\n        for (int j = 1; j < k; ++j){\n            cout << s + i << "" "" << s + k - 1 + j << endl;\n        }\n    }\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n; cin >> n;\n\n    if (n % 2 == 0){\n        cout << ""NO"" << endl;\n        return 0;\n    }\n\n    int tot = 2 * (2 * n - 1);\n    int edg = tot * n / 2;\n\n    cout << ""YES"" << endl;\n    cout << tot << "" "" << edg << endl;\n\n    print(1, n);\n    print(2 * n, n);\n    cout << 1 << "" "" << 2 * n << endl;\n\n    return 0;\n}\n']","[0, 0, 1, 0, 0]",1900,Let s prove that there is no solution for even Suppose our graph contains some bridges even all degrees are Then there always exists strongly connected component that is connected to other part of the graph with exactly one bridge Consider this component Let s remove bridge that connects it to the remaining graph Then it has one vertex with degree and some vertices with degrees But then the graph consisting of this component will contain only one vertex with odd degree which is impossible by Handshaking Lemma Let s construct the answer for odd Let For graph consisting of two nodes connected by edge works For let s construct graph with nodes Let it consist of two strongly connected components connected by bridge Enumerate nodes of first component from to second component will be the same as the first one Let vertex be connected to the second component by bridge Also connect it with edges to vertices Connect vertices to each other add all possible edges between them and then remove edges between every neighbouring pair for example edges Then we connect vertices with vertices and And finally add an edge between nodes and Build the second component in the similar manner and add a bridge between components Constructed graph has one bridge all degrees of and consists of nodes and edges Complexity of the solution 
Fox Ciel is going to travel to New Foxland during this summer New Foxland has attractions that are linked by undirected roads Two attractions are called adjacent if they are linked by a road Fox Ciel has days to visit this city and each day she will visit exactly one attraction There is one important rule in New Foxland you can t visit an attraction if it has more than one adjacent attraction that you haven t visited yet At the beginning Fox Ciel haven t visited any attraction During her travelling she may move aribtrarly between attraction After visiting attraction she may travel to attraction satisfying conditions above that hasn t been visited yet even if it is not reachable from by using the roads Ciel uses boat for travelling between attractions so it is possible She wants to know how many different travelling plans she can make Calculate this number modulo for every from to since she hasn t decided for how many days she is visiting New Foxland ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T>\nbool uin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool uax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst i64 P = 1000000000 + 9;\nconst int MAXN = 110;\ni64 CNK[301][301];\nint vis[MAXN], ok[MAXN];\nint p[MAXN], d[MAXN], mr[MAXN];\nvvi e, pe;\n\ni64 ans[MAXN];\n\ni64 deg(i64 x, i64 d) {\n    i64 res = 1;\n    while (d) {\n        if (d & 1) {\n            res *= x; res %= P;\n        }\n        x *= x; x %= P;\n        d /= 2;\n    }\n    return res;\n}\n\nvoid add(i64 &x, i64 y) {\n    x += y; x %= P;\n}\n\nvi64 mul(vi64 a, vi64 b) {\n    vi64 c(a.size() + b.size() - 1);\n    forn(i, a.size()) forn(j, b.size()) {\n        add(c[i + j], a[i] * b[j] % P * CNK[i + j][i]);\n    }\n    return c;\n}\n\nvi64 dfs_cnt(int v, int p, vvi &e) {\n    vi64 res(1, 1);\n    for (int u: e[v]) {\n        if (!ok[u] || u == p) continue;\n        res = mul(res, dfs_cnt(u, v, e));\n    }\n    i64 x = res.back();\n    res.pb(x);\n    return res;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    CNK[0][0] = 1;\n    for1(i, 300) {\n        CNK[i][0] = 1;\n        for1(j, i) CNK[i][j] = (CNK[i - 1][j - 1] + CNK[i - 1][j]) % P;\n    }\n    int N, M;\n    cin >> N >> M;\n    e.resize(N);\n    pe.resize(N);\n    forn(i, M) {\n        int x, y;\n        cin >> x >> y;\n        --x; --y;\n        e[x].pb(y); e[y].pb(x);\n        ++d[x]; ++d[y];\n    }\n    forn(i, N) p[i] = -1;\n\n    while (1) {\n        bool ch = false;\n        forn(i, N) {\n            if (!vis[i] && d[i] == 1) {\n                vis[i] = 1;\n                ok[i] = 1;\n                for (int v: e[i]) {\n                    if (!vis[v]) {\n                        p[i] = v;\n                        pe[v].pb(i);\n                        --d[i];\n                        --d[v];\n                    }\n                }\n                ch = true;\n                break;\n            }\n        }\n        if (!ch) break;\n    }\n    vi64 ans(1, 1);\n    forn(i, N) {\n        if (!ok[i]) {\n            if (d[i] == 0) {\n                ok[i] = 1;\n                vi q;\n                q.pb(i);\n                int cur = 0;\n                while (cur < q.size()) {\n                    int v = q[cur++];\n                    for (int u: pe[v]) {\n                        q.pb(u);\n                    }\n                }\n\n                vi64 res(1);\n                for (int v: q) {\n                    vi64 r = dfs_cnt(v, -1, e);\n                    if (res.size() < r.size()) res.resize(r.size());\n                    forn(i, r.size()) add(res[i], r[i]);\n                }\n                forn(i, res.size()) {\n                    if (i + 1 < res.size()) res[i] = (res[i] * deg(res.size() - i - 1, P - 2)) % P;\n                }\n                ans = mul(ans, res);\n            } else if (pe[i].size()) {\n                vi64 r = dfs_cnt(i, -1, e);\n                r.pop_back();\n                ans = mul(ans, r);\n            }\n        }\n    }\n\n    while (ans.size() < N + 1) ans.pb(0);\n    forn(i, N + 1) cout << ans[i] << \'\\n\';\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","[0, 0, 0, 1, 0]",2900,We could find that some nodes cannot be visited And more specific if one node is in a cycle then it cannot be visited So what about the structure of nodes that we can visit Let s first find a way to get all nodes that could be visited We can deal with this by something like biconnected decomposition but that is not easy to implement In fact we can use this simple method each time we pick one node that have at most 1 neighborhood and delete it Repeat this process until we can t do it anymore We could find these nodes are actually belonging to these 2 kinds 1 A tree 2 Rooted tree that means the root is attached to a cycle The rooted tree case is simple we can solve it by tree DP The state will be dp i j the way to remove j nodes in the subtree rooted at i Then how to solve the unrooted tree case The way to deal with that is to transform it into rooted case We have 2 solution We select one unvisited node as the root by some rules for example we select one with minimal index Then we just need to modify the DP a bit to adjust this additional condition We could find if the tree has n nodes and we visit k nodes in the end then there will be max 1 n k ways to choose the root That means if we choose every node as the root and sum up them we will count this case exactly max 1 n k times So we just do the rooted DP for from node n times and divide max 1 n k for ans k The overall complicity is and it can be optimize into if you like 
You are given a array a 1 a 2 dots a n for each index i 1 condition a i ge a i 1 holds and an integer k You are asked to divide this array into k non empty consecutive subarrays Every element in the array should be included in exactly one subarray Let max i be equal to the maximum in the i th subarray and min i be equal to the minimum in the i th subarray The cost of division is equal to sum limits i 1 k max i min i For example if a 2 4 5 5 8 11 19 and we divide it into 3 subarrays in the following way 2 4 5 5 8 11 19 then the cost of division is equal to 4 2 5 5 19 8 13 Calculate the minimum cost you can obtain by dividing the array a into k non empty consecutive subarrays ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 300300;\nint n, k;\nint a[N];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d"", &a[i]);\n\tn--;\n\tk--;\n\tint ans = a[n] - a[0];\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = a[i + 1] - a[i];\n\tsort(a, a + n);\n\treverse(a, a + n);\n\tfor (int i = 0; i < k; i++)\n\t\tans -= a[i];\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",1400,Let s carefully look at the coefficients with which the elements of the array will be included in the answer If pair of adjacent elements and belong to different subarrays then element will be included in the answer with coefficient and element with coefficient So they add value to the answer If element belongs to subarray with length then it will be included in the sum with coefficient because it will be included with coefficient and simultaneously Elements at positions and will be included with coefficients and respectively So initially our answer is All we have to do is consider values and add up the minimal ones to the answer 
Polycarp likes numbers that are divisible by 3 He has a huge number s Polycarp wants to cut from it the maximum number of numbers that are divisible by 3 To do this he makes an arbitrary number of vertical cuts between pairs of adjacent digits As a result after m such cuts there will be m 1 parts in total Polycarp analyzes each of the obtained numbers and finds the number of those that are divisible by 3 For example if the original number is s 3121 then Polycarp can cut it into three parts with two cuts 3 1 21 As a result he will get two numbers that are divisible by 3 Polycarp can make an arbitrary number of vertical cuts where each cut is made between a pair of adjacent digits The resulting numbers cannot contain extra leading zeroes that is the number can begin with if and only if this number is exactly one character For example and are not valid numbers but and are valid What is the maximum number of numbers divisible by 3 that Polycarp can obtain ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl ""\\n""\n#define ft first\n#define sd second\n#define openfiles ifstream cin (""input.txt""); ofstream cout (""output.txt"");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, old;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    string s;\n    cin >> s;\n    int sc = 0;\n\n    set<int> A;\n\n    for (int i: s) {\n        set<int> B;\n        i -= \'0\';\n        bool cut = 0;\n\n        for (int j: A) {\n            B.in(j+i);\n        }\n        B.in(i);\n        set<int> C;\n        for (int j: B) {\n            if (j % 3) {\n                C.in(j % 3);\n            } else {\n                cut = 1;\n            }\n        }\n\n        if (!cut) {\n            swap(A, C);\n        } else {\n            A.clear();\n            sc++;\n        }\n\n    }\n\n    cout << sc;\n\n}\n\n\n\n\n\n\n\n\n\n']","[1, 0, 0, 1, 0]",1500,There are multiple approaches to solve this problem We will use dynamic programming approach Let s calculate values of the array where is the answer for prefix of the length Obviously since for the empty string the prefix of the length the answer is For you can find in the following way Let s look in the last digit of the prefix of length It has index Either it doesn t belong to segment divisible by or it belongs If it doesn t belongs it means we can t use the last digit so If it belongs we need to find shortest that is divisible by and try to update with the value It means that we bite off the shortest divisible by suffix and reduce the problem to a previous A number is divisible by if and only if sum of its digits is divisible by So the task is to find the shortest suffix of with sum of digits divisible by If such suffix is then and have the same remainder of sum of digits modulo Let s maintain array of the length where is the length of the longest processed prefix with sum of digits equal to modulo Use if there is no such prefix It is easy to see that where is the sum of digits on the th prefix modulo So to find the maximal that substring is divisible by just check that and use where is the sum of digits on the th prefix modulo It means that to handle case that the last digit belongs to divisible by segment you should try to update with value In other words just do Sequentially calculating the values of we obtain a linear solution 
You are given an array of elements you must make it a co prime array in as few moves as possible In each move you can insert any positive integral number you want not greater than in any place in the array An array is co prime if any two adjacent numbers of it are co prime In the number theory two integers and are said to be co prime if the only positive integer that divides both of them is ,"['# include <cstdio>\nint gcd(int a, int b)\n{\n\tif (b == 0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b, a % b);\n}\nconst int MN = 1111;\nint a[MN];\nint main()\n{\n\tint n;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(""%d"", a + i);\n\tint k = 0;\n\tfor (int i = 0; i < n - 1; ++i)\n\t{\n\t\tif (gcd(a[i], a[i + 1]) != 1)\n\t\t\tk++;\n\t}\n\tprintf(""%d\\n"", k);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tprintf(""%d "", a[i]);\n\t\tif (i != n - 1 && gcd(a[i], a[i + 1]) != 1)\n\t\t\tprintf(""1 "");\n\t}\n}']","[1, 1, 1, 0, 0]",1200,The problem was suggested by Ali Ibrahim C137 Note that we should insert some number between any adjacent not co prime elements On other hand we always can insert the number solution 
You have n stacks r 1 r 2 ldots r n Each stack contains some positive integers ranging from 1 to n Define the following functions function init pos stacks an array that contains n stacks r 1 r 2 r n return get stacks pos function get stacks pos if stacks pos is empty return pos else new pos the top element of stacks pos pop the top element of stacks pos return get stacks new pos You want to know the values returned by texttt init 1 texttt init 2 ldots texttt init n Note that during these calls the stacks r 1 r 2 ldots r n don t change so the calls texttt init 1 texttt init 2 ldots texttt init n are independent ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n/**\n * Description: Disjoint Set Union with path compression\n * and union by size. Add edges and test connectivity.\n * Use for Kruskal\'s or Boruvka\'s minimum spanning tree.\n * Time: O(\\alpha(N))\n * Source: CSAcademy, KACTL\n * Verification: *\n */\n\nstruct DSU {\n\tvi e;\n\tvoid init(int N) { e = vi(N, -1); }\n\tint get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }\n\tbool sameSet(int a, int b) { return get(a) == get(b); }\n\tint size(int x) { return -e[get(x)]; }\n\tvoid add_edge(int x, int y) {  // union by size\n\t\tx = get(x), y = get(y);\n\t\tassert(x != y);\n\t\t// if (x == y) return 0;\n\t\te[y] += e[x];\n\t\te[x] = y;\n\t}\n};\n\n/**tcT> T kruskal(int N, vector<pair<T,pi>> ed) {\n    sort(all(ed));\n    T ans = 0; DSU D; D.init(N); // edges that unite are in MST\n    each(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f;\n    return ans;\n}*/\n\nint N;\nV<vi> C;\n// DSU D;\nvi ans;\n\n// int query(int x) {\n// \tvi stk{x};\n// \twhile (true) {\n// \t\tif (final_ans[stk.bk]) {\n\n// \t\t}\n// \t}\n// }\n\nint timer = 0;\n\nvi vis;\n\nvoid dfs(int x) {\n\t++timer;\n\tvi stk{x};\n\tvis[stk.bk] = timer;\n\twhile (true) {\n\t\tif (!ans[stk.bk] && !sz(C[stk.bk])) { ans[stk.bk] = stk.bk; }\n\t\tif (ans[stk.bk]) {\n\t\t\teach(x, stk) ans[x] = ans[stk.bk];\n\t\t\treturn;\n\t\t}\n\t\tint nxt = C[stk.bk].bk;\n\t\tif (vis[nxt] != timer) {\n\t\t\tstk.pb(nxt);\n\t\t\tvis[stk.bk] = timer;\n\t\t} else {\n\t\t\twhile (true) {\n\t\t\t\tassert(sz(stk));\n\t\t\t\tC[stk.bk].pop_back();\n\t\t\t\tif (stk.bk == nxt) break;\n\t\t\t\tvis[stk.bk] = 0;\n\t\t\t\tstk.pop_back();\n\t\t\t}\n\t\t\tassert(stk.bk == nxt);\n\t\t}\n\t}\n}\n\nint main() {\n\t// read read read\n\tsetIO();\n\tre(N);\n\t// D.init(N + 1);\n\t// D.add_edge(1, 2);\n\t// dbg(D.get(1), D.get(2));\n\t// exit(0);\n\tC.rsz(N + 1);\n\tFOR(i, 1, N + 1) {\n\t\tdef(int, K);\n\t\tC[i].rsz(K);\n\t\tre(C[i]);\n\t}\n\tans.rsz(N + 1);\n\tvis = vi(N + 1);\n\tFOR(i, 1, N + 1) dfs(i);\n\tans.erase(begin(ans));\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","[0, 0, 1, 0, 0]",3000,Let s first consider an easy version of the problem what if there is only one element in each stack Let be the element in stack If we link these edges will form several directed pseudo trees For each pseudo tree there is a cycle It s not hard to find that those cycles actually can be ignored because if we go on the cycle we will come back to the first node on the cycle and the cycle will be eliminated After deleting the edges on the cycle there are only trees left Thus the root of each tree is the answer of nodes on the tree When it comes back to the original problem similarly let be the top element of stack The rest are the same cycles can be eliminated In this case we should run cycle elimination process many times until there is no cycle in the graph Time complexity 
Alice and Bob are playing a game on a graph They have an undirected graph without self loops and multiple edges All vertices of the graph have The graph may consist of several components Note that if such graph has n vertices it will have exactly n edges Alice and Bob take turn Alice goes first In each turn the player can choose k l le k le r l r vertices that form and erase these vertices from the graph including all incident edges The player who can t make a step loses For example suppose they are playing on the given graph with given l 2 and r 3 A valid vertex set for Alice to choose at the first move is one of the following 1 2 1 3 2 3 4 5 4 6 5 6 1 2 3 4 5 6 Suppose Alice chooses subgraph 4 6 Then a valid vertex set for Bob to choose at the first move is one of the following 1 2 1 3 2 3 1 2 3 Suppose Bob chooses subgraph 1 2 3 Alice can t make a move so she loses You are given a graph of size n and integers l and r Who will win if both Alice and Bob play optimally ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005,mod=998244353;\nint add(int x, int y){x+=y; if(x>=mod) x-=mod; return x;}\nint sub(int x, int y){x-=y; if(x<0) x+=mod; return x;}\nint mul(int x, int y){return ((ll)x)*y%mod;}\nint Pow(int x, ll y=mod-2){int res=1; for(; y; x=mul(x,x),y>>=1) if(y&1) res=mul(res,x); return res;}\n\nint n,l,r;\nvector<int> adj[N];\nbool vis[N];\n\nint cnt;\nvoid dfs(int u){\n    cnt++;\n    vis[u]=1;\n    for(auto v: adj[u]) if(!vis[v]) dfs(v);\n}\n\nvoid ldc(){\n    cin >> n >> l >> r;\n    for(int i=0; i<n; ++i){\n        int u,v; cin >> u >> v; u--,v--;\n        adj[u].pb(v),adj[v].pb(u);\n    }\n    int res=0;\n    for(int i=0; i<n; ++i) if(!vis[i]){\n        cnt=0;\n        dfs(i);\n        if(cnt<l+r) res^=cnt/l;\n    }\n    cout << (res?""Alice"":""Bob"") << ""\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    t=1;\n    while(t--) ldc();\n}']","[0, 1, 0, 1, 0]",2500,The solution requires knowledge of the Sprague Grundy theory Recall that means the operation and is equal to the minimum non negative number that is not in the set The given graph is a set of cycles and the game runs independently in each cycle If we can calculate nim value for a cycle of each size then nim value of the whole game is equal to of these values To calculate nim value for the cycle of length we need to take of nim values from all transitions But since all transitions transform a cycle to a chain then we will calculate nim values for chains as well or To calculate nim value for the chain we need to consider all possible transitions We can either cut off from the end of the chain or from the middle of the chain In either case we end up with two smaller chains maybe one of them is empty which are themselves independent games so Implementing this directly requires time A more accurate implementation with recalculations requires time For a complete solution something needs to be noticed in nim values Consider an example Let index0123456789101112131415161718190000111122223333444400001111222233334400 on is obviously equal to on segment proof is below for all since you can always split the chain in two equal chains This transition adds nim value into that s why is equal to up to it s because is equal to for it s because for So if then otherwise We have to calculate the sizes of all cycles in the graph and calculate of those values If it is zero the winner is Bob otherwise winner is Alice Let s prove that on segment there are transitions to pairs of chains where and is any number from Their nim value is equal to so is exactly equal to we can prove that for any pair of chains with value 
The snails are climbing a tree The tree height is h meters and snails start at position 0 Each snail has two attributes a and b a b Starting from the 1 st day one snail climbs the tree like this during the daylight hours of the day he climbs up a meters during the night the snail rests and he slides down b meters If on the n th day the snail reaches position h for the first time that is the top of the tree he will finish climbing and we say that the snail spends n days climbing the tree Note that on the last day of climbing the snail doesn t necessarily climb up a meters in case his distance to the top is smaller than a Unfortunately you don t know the exact tree height h at first but you know that h is a positive integer There are q events of two kinds Event of type 1 a snail with attributes a b comes and claims that he spent n days climbing the tree If this message contradicts previously adopted information i e there is no tree for which all previously adopted statements and this one are true ignore it Otherwise adopt it Event of type 2 a snail with attributes a b comes and asks you how many days he will spend if he climbs the tree You can only give the answer based on the information you have adopted so far If you cannot determine the answer precisely report that You need to deal with all the events in order ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int q;\n    std::cin >> q;\n    \n    i64 lo = 1, hi = 1E18;\n    \n    while (q--) {\n        int t;\n        std::cin >> t;\n        \n        if (t == 1) {\n            int a, b, n;\n            std::cin >> a >> b >> n;\n            \n            i64 x, y;\n            if (n == 1) {\n                x = 1;\n                y = a;\n            } else {\n                x = 1LL * a * (n - 1) - 1LL * b * (n - 2) + 1;\n                y = 1LL * a * n - 1LL * b * (n - 1);\n            }\n            if (x <= hi && lo <= y) {\n                lo = std::max(lo, x);\n                hi = std::min(hi, y);\n                std::cout << 1 << "" "";\n            } else {\n                std::cout << 0 << "" "";\n            }\n        } else {\n            int a, b;\n            std::cin >> a >> b;\n            \n            i64 t1 = lo <= a ? 1LL : (lo - b + a - b - 1) / (a - b);\n            i64 t2 = hi <= a ? 1LL : (hi - b + a - b - 1) / (a - b);\n            \n            if (t1 == t2) {\n                std::cout << t1 << "" "";\n            } else {\n                std::cout << -1 << "" "";\n            }\n        }\n    }\n    std::cout << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[0, 1, 0, 0, 0]",1700,TutorialThe main idea is to that for each the possible is a interval We will show how to calculate that In the first days the snail will climb meters And in the daytime of the th day the snail will climb meters So after days the snail climbs at most meters which means Also the snail can not reach before days which means So is a special case where Now after each operation we can maintain a possible interval When a snail comes we let the new be where is the possible interval for the new snail If the new interval is empty we ignore this information otherwise adopt it Now let s focus on another problem for a fixed how to calculate the number of days the snail needs to climb We can solve the equation and get which means equals to Still special judge for where in this case Then for each query of type we just calculate the number of days we need for and If they are the same output that number Otherwise output 
You are given an integer and a list of distinct integers between and You would like to construct a sequence satisfying the properties Each element is an integer between and inclusive All prefix products of the sequence modulo are distinct No prefix product modulo appears as an element of the input list The length of the sequence is maximized Construct any sequence satisfying the properties above ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 200000;\n\nstruct Input {\n\tint n, m;\n\tint a[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n >> m)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(""%d"", &a[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tvi ans;\n\t\n\tvoid write () {\n\t\tcout << sz(ans) << endl;\n\t\tforn (i, sz(ans)) {\n\t\t\tif (i) {\n\t\t\t\tprintf("" "");\n\t\t\t}\n\t\t\tprintf(""%d"", ans[i]);\n\t\t}\n\t\tputs("""");\n\t}\n};\n\n\nnamespace Main {\n\t\n\tstruct Solution: Data {\n\t\t\n\t\tint gcd (int x, int y) {\n\t\t\tif (!x) {\n\t\t\t\treturn y;\n\t\t\t}\n\t\t\treturn gcd(y % x, x);\n\t\t}\n\t\t\n\t\tset<int> v[N + 1];\n\t\t\n\t\tint d[N + 1], pr[N + 1];\n\t\tll rev[N];\n\t\t\n\t\tll cur;\n\t\t\n\t\tvoid rec (int i) {\n\t\t\tif (pr[i] != -1) {\n\t\t\t\trec(pr[i]);\n\t\t\t}\n\t\t\tfor (ll x : v[i]) {\n\t\t\t\tll p = x;\n\t\t\t\tll q = cur;\n\t\t\t\tll g = gcd(p, q);\n\t\t\t\tp /= g;\n\t\t\t\tq /= g;\n\t\t\t\tll val = p * rev[q] % m;\n\t\t\t\tans.pb(val);\n\t\t\t\tcur = cur * val % m;\n\t\t\t\tassert(cur == x);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid solve () {\n\t\t\tint phi = m;\n\t\t\t{\n\t\t\t\tint m0 = m;\n\t\t\t\tforn (i, 2, N + 1) {\n\t\t\t\t\tif (m0 % i == 0) {\n\t\t\t\t\t\twhile (m0 % i == 0) {\n\t\t\t\t\t\t\tm0 /= i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tphi /= i;\n\t\t\t\t\t\tphi *= i - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tforn (i, m) {\n\t\t\t\trev[i] = 1;\n\t\t\t\tll x = i;\n\t\t\t\tll pw = phi - 1;\n\t\t\t\twhile (pw) {\n\t\t\t\t\tif (pw & 1) {\n\t\t\t\t\t\t(rev[i] *= x) %= m;\n\t\t\t\t\t}\n\t\t\t\t\t(x *= x) %= m;\n\t\t\t\t\tpw >>= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tforn (i, m) {\n\t\t\t\tv[gcd(i, m)].insert(i);\n\t\t\t}\n\t\t\tforn (i, n) {\n\t\t\t\tv[gcd(a[i], m)].erase(a[i]);\n\t\t\t}\n\t\t\t\n\t\t\tmemset(d, 0, sizeof d);\n\t\t\tmemset(pr, -1, sizeof pr);\n\t\t\tforn (i, m + 1) {\n\t\t\t\td[i] = sz(v[i]);\n\t\t\t}\n\t\t\tforn (i, 1, m + 1) {\n\t\t\t\tfor (int j = 2 * i; j <= m; j += i) {\n\t\t\t\t\tif (umx(d[j], d[i] + sz(v[j]))) {\n\t\t\t\t\t\tpr[j] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bst = 0;\n\t\t\tint mx = 0;\n\t\t\tforn (i, m + 1) {\n\t\t\t\tif (umx(mx, d[i])) {\n\t\t\t\t\tbst = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = 1;\n\t\t\tdebug(mx);\n\t\t\trec(bst);\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + "".in"").c_str(), ""r"", stdin);\n//\t\tfreopen((problemname + "".out"").c_str(), ""w"", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0]",2300,Let s consider a directed graph with m nodes labeled from 1 to m where there is an edge between nodes i and node j if there exists a number x such that Now we can notice there is an edge between node i and node j if and only if gcd n i divides gcd n j So there are two directed edges between two nodes i and j if and only if gcd n i gcd n j So these form some directed cliques in our graphs We can also notice that this happens to form the SCC decomposition of our graph i e condensation So this problem reduces to finding the heaviest path in a DAG with weights on nodes The nodes in this dag correspond to divisors of n and the weight corresponds to the number of allowed numbers with that gcd 
There s a famous museum in the city where Kleof lives In the museum exhibits numbered through had been displayed for a long time the th of those exhibits has value and mass Then the museum was bought by a large financial group and started to vary the exhibits At about the same time Kleof gained interest in the museum so to say You should process events of three types type the museum displays an exhibit with value and mass the exhibit displayed in the th event of this type is numbered see sample explanation for more details type the museum removes the exhibit with number and stores it safely in its vault type Kleof visits the museum and wonders for no important reason at all of course if there was a robbery and exhibits with total mass at most were stolen what would their maximum possible total value be For each event of type 3 let be the maximum possible total value of stolen exhibits with total mass Formally let be the set of numbers of all exhibits that are currently displayed so initially 1 n Let be the set of all subsets of and let Then is defined as Compute for each Note that the output follows a special format ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007,P=10000000+19;\nll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=30100;\nint dp[30][N];\nint n,k,st[N],ed[N],ty,it,qur[N],q;\nPII p[N];\nVI ps;\nvoid query(int d,int l,int r,VI item) {\n\trep(i,0,k+1) dp[d][i]=dp[d-1][i];\n//\tprintf(""L R %d %d\\n"",l,r);\n//\trep(j,0,SZ(item)) printf(""%d "",item[j]); puts("""");\n\trep(j,0,SZ(item)) if (st[item[j]]<=l&&ed[item[j]]>=r) {\n//\t\tprintf(""Add %d\\n"",item[j]);\n\t\tint v=p[item[j]].fi,w=p[item[j]].se;\n\t\tper(i,0,k+1) {\n\t\t\tif (i>=w) dp[d][i]=max(dp[d][i],dp[d][i-w]+v);\n\t\t}\n\t}\n\tif (l==r) {\n\t\tll ret=0;\n\t//\trep(i,1,k+1) printf(""%d "",dp[d][i]); puts("""");\n\t\tper(i,1,k+1) ret=(ret*P+dp[d][i])%mod;\n\t\trep(j,0,qur[l]) printf(""%d\\n"",(int)ret);\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tVI lt,rt;\n\t\trep(j,0,SZ(item)) {\n\t\t\tif (st[item[j]]<=l&&ed[item[j]]>=r) continue;\n\t\t\tif (ed[item[j]]<=md) lt.pb(item[j]);//,printf(""LL %d\\n"",item[j]);\n\t\t\telse if (st[item[j]]>md) rt.pb(item[j]);//,printf(""RR %d\\n"",item[j]);\n\t\t\telse lt.pb(item[j]),rt.pb(item[j]);//,printf(""LR %d\\n"",item[j]);\n\t\t}\n\t\tquery(d+1,l,md,lt);\n\t\tquery(d+1,md+1,r,rt);\n\t}\n}\nint main() {\n//\tfreopen(""in"",""r"",stdin);\n\tscanf(""%d%d"",&n,&k);\n\trep(i,1,n+1) scanf(""%d%d"",&p[i].fi,&p[i].se),st[i]=1;\n\tscanf(""%d"",&q);\n\tint cur=1,im=n;\n\trep(i,0,q) {\n\t\tscanf(""%d"",&ty);\n\t\tif (ty==3) {\n\t\t\tqur[cur]++;\n\t\t} else if (ty==2) {\n\t\t\tscanf(""%d"",&it);\n\t\t\ted[it]=cur++;\n\t\t} else {\n\t\t\tim++;\n\t\t\tscanf(""%d%d"",&p[im].fi,&p[im].se);\n\t\t\tst[im]=++cur;\n\t\t}\n\t}\n\trep(i,1,im+1) ps.pb(i);\n\trep(i,1,im+1) if (ed[i]==0) ed[i]=cur;\n//\trep(i,1,im+1) printf(""%d %d %d\\n"",i,st[i],ed[i]);\n\tquery(1,1,cur,ps);\n}\n']","[0, 0, 0, 1, 1]",2800,Can you solve the problem without events of type 1 or 2 Also how about solving it offline as queries on subsets 
Alice s potion making professor gave the following assignment to his students brew a potion using n ingredients such that the proportion of ingredient i in the final potion is r i 0 and r 1 r 2 cdots r n 1 He forgot the recipe and now all he remembers is a set of n 1 facts of the form ingredients i and j should have a ratio of x to y i e if a i and a j are the amounts of ingredient i and j in the potion respectively then it must hold a i a j x y where x and y are positive integers However it is guaranteed that the set of facts he remembers is sufficient to uniquely determine the original values r i He decided that he will allow the students to pass the class as long as they submit a potion which satisfies all of the n 1 requirements there may be many such satisfactory potions and contains a positive integer amount of each ingredient Find the minimum total amount of ingredients needed to make a potion which passes the class As the result can be very large you should print the answer modulo 998 244 353 ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\npair<vector<int>, vector<int>> sieve(int n) {\n\tvector<int> erat(n + 1);\n\tvector<int> primes;\n\terat[1] = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tif (erat[i] == 0) {\n\t\t\terat[i] = i;\n\t\t\tprimes.push_back(i);\n\t\t}\n\t\tfor (int p : primes) {\n\t\t\tif (p > erat[i] || i * p > n) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\terat[i * p] = p;\n\t\t}\n\t}\n\treturn {erat, primes};\n}\n\ntemplate <class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate <class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate <class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\ntemplate <uint32_t base>\nstruct Montgomery {\n\tusing i32 = int32_t;\n\tusing u32 = uint32_t;\n\tusing u64 = uint64_t;\n\n\tstatic constexpr u32 mod() {\n\t\treturn base;\n\t}\n\n\tstatic constexpr u32 np = []() {\n\t\tu32 x = base;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tx *= 2u - base * x;\n\t\t}\n\t\treturn -x;\n\t}();\n\tstatic constexpr u32 r2 = -(u64)(base) % base;\n\n\tstatic_assert(base < (1u << 30));\n\tstatic_assert(base * np + 1 == 0);\n\n\tstatic u32 reduce(u64 x) {\n\t\treturn (x + (u64)((u32)x * np) * base) >> 32;\n\t}\n\n\tu32 x;\n\tMontgomery(): x(0) {}\n\tconstexpr Montgomery(long long y): x(y ? reduce((u64)(y % base + base) * r2) : 0) {}\n\n\tMontgomery& operator +=(const Montgomery& ot) {\n\t\tif ((i32)(x += ot.x - 2 * base) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator -=(const Montgomery& ot) {\n\t\tif ((i32)(x -= ot.x) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator *=(const Montgomery& ot) {\n\t\tx = reduce((u64)x * ot.x);\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator /=(const Montgomery& ot) {\n\t\treturn *this *= ot.inverse();\n\t}\n\n\tfriend Montgomery operator +(Montgomery a, const Montgomery& b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator -(Montgomery a, const Montgomery& b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator *(Montgomery a, const Montgomery& b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator /(Montgomery a, const Montgomery& b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\n\tMontgomery operator -() const {\n\t\treturn Montgomery() - *this;\n\t}\n\n\tu32 get() const {\n\t\tu32 res = reduce(x);\n\t\treturn res < base ? res : res - base;\n\t}\n\n\tu32 operator ()() const {\n\t\treturn get();\n\t}\n\n\tMontgomery inverse() const {\n\t\treturn pow(base - 2);\n\t}\n\n\tMontgomery inv() const {\n\t\treturn inverse();\n\t}\n\n\tMontgomery pow(int64_t p) const {\n\t\tif (p < 0) {\n\t\t\treturn pow(-p).inverse();\n\t\t}\n\t\tMontgomery res = 1;\n\t\tMontgomery a = *this;\n\t\twhile (p) {\n\t\t\tif (p & 1) {\n\t\t\t\tres *= a;\n\t\t\t}\n\t\t\tp >>= 1;\n\t\t\ta *= a;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfriend istream& operator >>(istream& istr, Montgomery& m) {\n\t\tlong long x;\n\t\tistr >> x;\n\t\tm = Montgomery(x);\n\t\treturn istr;\n\t}\n\n\tfriend ostream& operator <<(ostream& ostr, const Montgomery& m) {\n\t\treturn ostr << m.get();\n\t}\n\n\tbool operator ==(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) == (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\tbool operator !=(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) != (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\texplicit operator int64_t() const {\n\t\treturn x;\n\t}\n\n\texplicit operator bool() const {\n\t\treturn x;\n\t}\n};\n\nconstexpr int mod = 998\'244\'353;\nusing Mint = Montgomery<mod>;\n\nstruct Edge {\n\tint to;\n\tint x, y;\n};\n\nvoid remin(int& x, int y) {\n\tx = (x < y) ? x : y;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tauto erat = sieve(n).first;\n\tvector<vector<Edge>> a(n);\n\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\tint x = nxt(), y = nxt();\n\t\ta[u].push_back({v, x, y});\n\t\ta[v].push_back({u, y, x});\n\t}\n\n\tvector<int> mind(n + 1);\n\tvector<int> curd(n + 1);\n\tauto add = [&](int x, int val) {\n\t\twhile (x > 1) {\n\t\t\tint p = erat[x];\n\t\t\tx /= p;\n\t\t\tremin(mind[p], curd[p] += val);\n\t\t}\n\t};\n\n\tvector<Mint> val(n, 1);\n\n\tauto dfs = y_combinator([&](auto self, int v, int p) -> void {\n\t\tfor (auto [to, x, y] : a[v]) {\n\t\t\tif (to == p) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tadd(y, 1);\n\t\t\tadd(x, -1);\n\t\t\tval[to] = val[v] * y / x;\n\t\t\tself(to, v);\n\t\t\tadd(x, 1);\n\t\t\tadd(y, -1);\n\t\t}\n\t});\n\tdfs(0, -1);\n\n\tMint ans = accumulate(all(val), Mint(0));\n\tfor (int i = 1; i <= n; ++i) {\n\t\tans *= Mint(i).pow(-mind[i]);\n\t}\n\tcout << ans << ""\\n"";\n}\n\nint main() {\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0]",2100,SolutionRead the hints The rest is just implementation Start a DFS from node Keep an array such that is the exponent of in the amount of ingredients of the current node Keep also At the beginning the amount of ingredients of node is so for each Whenever you move from node to node and for each such that and decrease by for each such that and increase by Notice that there exist such values of for each edge and you can find them by precalculating either the smallest prime factor with the sieve of Eratosthenes or the whole factorization of every integer in Let be the minimum value of during the DFS Then for every you have to multiply the amount of ingredients of node by The answer is the sum of multiplied by the amount of ingredients of node Complexity 
You are given a tree consisting of n vertices Initially each vertex has a value 0 You need to perform m queries of two types You are given a vertex index v Print the value of the vertex v You are given two vertex indices u and v and values k and d d le 20 You need to add k to the value of each vertex such that the distance from that vertex to the path from u to v is less than or equal to d The between two vertices x and y is equal to the number of on the path from x to y For example the distance from x to x itself is equal to 0 The distance from the vertex v to some path from x to y is equal to the minimum among distances from v to any vertex on the path from x to y ,"['//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << "" "" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<""Yes""<<endl;else cout<<""No""<<endl;}\nvoid ans2(bool x){if(x) cout<<""YES""<<endl;else cout<<""NO""<<endl;}\nvoid ans3(bool x){if(x) cout<<""Yay!""<<endl;else cout<<"":(""<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv="" ""){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv="" ""){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<""[""<<z.first<<""]=""<<z.second<<"","";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << "" "" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << "" "";cout<<""|""; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\ntemplate<typename T>\nstruct HLD{\n  using D=long long;\n  int n;\n  vector<int>sz;//\n  vector<D>dep;\n  vector<int>par;\n  vector<int>head;\n  Graph<T> &g;//\n  vector<edge<T>>edges;//edge\n  vector<int>in,out;//[in,out)[ina,inb]a~b(a)\n  vector<int>comp;//\n  //inindexedge\n  HLD(Graph<T> &g,int r=-1):g(g),n(g.size()){\n    hld_build(r);\n  }\n  void hld_build(int root = -1){\n    in.assign(n,-1);out.assign(n,-1);dep.assign(n,0);\n    par.assign(n,-1);head.assign(n,-1);sz.assign(n,-1);comp.assign(n,-1);\n    edges.assign(n,edge<T>());\n    if(root == -1){//()\n      for(int i=0;i<n;i++){\n        if(sz[i] == -1){\n          head[i] = i;\n          dfs_sz(i, 0, i);\n          dfs_hld(i);\n        }\n      }\n    }\n    else{\n      head[root] = root;\n      dfs_sz(root, 0, root);\n      dfs_hld(root);\n    }\n  }\n  void dfs_sz(int k, D d,int r){\n    sz[k] = 1;\n    comp[k] = r;\n\tdep[k] = d;\n    for(auto &e: g[k]){\n      if(e.to == par[k])continue;\n      par[e.to] = k;\n      dfs_sz(e.to, d+e.cost, r);\n      sz[k] += sz[e.to];\n      if(sz[e.to] > sz[g[k][0].to])swap(e, g[k][0]);\n    }\n  }\n  int time = 0;\n  void dfs_hld(int k){\n    in[k] = time++;\n    for(auto e:g[k]){\n      if(e.to == par[k])continue;\n      head[e.to] = (e.to == g[k][0].to ? head[k]: e.to);\n      edges[time] = e;\n      dfs_hld(e.to);\n    }\n    out[k] = time;\n  }\n  int lca(int p,int q){\n    while(1){\n      if(in[p] < in[q])swap(p,q);\n      if(head[p] == head[q])return q;\n      p = par[head[p]];\n    }\n  }\n  vector<pair<int,int>>query_path(int p,int q,bool isEdge){\n    int r=lca(p,q);\n    vector<pair<int,int>>ret;\n    for(int i=0;i<2;i++){\n      if(i == 1)swap(p,q);\n      while(1){\n        if(isEdge&&p==r)break;\n        if(head[p]==head[r]){\n          ret.emplace_back(in[r]+(isEdge?1:i),in[p]+1);\n          break;\n        }\n        ret.emplace_back(in[head[p]],in[p]+1);\n        p = par[head[p]];\n      }\n    }\n    return ret;\n  }\n  vector<vector<pair<int,int>>>query_order_path(int p,int q,bool isEdge){\n\t//01\n    vector<vector<pair<int,int>>>ret(2);\n    int r=lca(p,q);\n    for(int i=0;i<2;i++){\n      if(i == 1)swap(p,q);\n      while(1){\n        if(isEdge&&p==r)break;\n        if(head[p]==head[r]){\n          if(i==0) ret[i].emplace_back(n-(in[p]+1),n-(in[r]+(isEdge?1:i)));\n          else ret[i].emplace_back(in[r]+(isEdge?1:i),in[p]+1);\n          break;\n        }\n        if(i==0) ret[i].emplace_back(n-(in[p]+1),n-(in[head[p]]));\n        else ret[i].emplace_back(in[head[p]],in[p]+1);\n        p = par[head[p]];\n      }\n    }\n    reverse(ret[1].begin(), ret[1].end());\n    return ret;\n  }\n  pair<int,int>query_subtree(int p,bool isEdge){\n    return make_pair(in[p]+isEdge,out[p]);\n  }\n  //uv (in,out)\n  int child(int u,int v){\n    while(1){\n      if(head[u]==head[v]){\n        v=g[u][0].to;\n        break;\n      }\n      v=head[v];\n      if(par[v]==u)break;\n      v=par[v];\n    }\n    return v;\n  }\n  //uv\n  int move(int u,int v){\n    assert(u!=v);\n    if(in[u]<in[v]&&in[v]<out[u])return child(u,v);\n    else return par[u];\n  }\n  D dist(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n  vector<int>rev_in;\n  int climb(int u,int k){\n    if(rev_in.empty()){\n      rev_in.resize(n);\n      for(int i=0;i<n;i++)rev_in[in[i]]=i;\n    }\n    int nd=max<int>(dep[u]-k, 0);\n    while(dep[u]>nd){\n      if(dep[head[u]]>nd){\n        u=par[head[u]];\n      }\n      else{\n        u=rev_in[in[head[u]]+nd-dep[head[u]]];\n      }\n    }\n    return u;\n  }\n  int jump(int from,int to, int k){\n    int r = lca(from, to);\n    int d1 = dep[from] - dep[r];\n    int d2 = dep[to] - dep[r];\n    if(d1 + d2 < k)return -1;\n    else if(k <= d1)return climb(from, k);\n    else return climb(to, d1 + d2 - k); \n  }\n  template<typename I>\n  Graph<T>lca_tree(vector<I>&v){\n    auto compare=[&](int x,int y){return in[x]<in[y];};\n    sort(v.begin(),v.end(),compare);\n    int sz1=v.size();\n    for(int i=0;i<sz1-1;i++)v.push_back(lca(v[i],v[i+1]));\n    sort(v.begin(),v.end(),compare);\n    v.erase(unique(v.begin(),v.end()),v.end());\n    int sz2=v.size();\n    Graph<T>ret(sz2);\n    stack<int>st;\n    for(int i=0;i<sz2;i++){\n      while(!st.empty()&&out[v[st.top()]]<=in[v[i]])st.pop();\n      if(!st.empty()){\n        ret[st.top()].emplace_back(i,dep[v[i]]-dep[v[st.top()]]);\n        ret[i].emplace_back(st.top(),dep[v[i]]-dep[v[st.top()]]);\n      }\n      st.push(i);\n    }\n    return ret;\n  }\n};\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    n++;\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  //[l,r)\n  void add(ll l,ll r,T w){\n\tif(l>=r)return;\n    add(l,w);add(r,-w);\n  }\n  T sum(ll a){//[0,a)\n\t  if(a<=0)return 0;\n    T ret = 0;\n    for(ll i=a;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  //[a,b)\n  T sum(ll a,ll b){return a>=b?0:sum(b)-sum(a);}\n  T operator[](ll pos){\n    return sum(0,pos+1);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n-1;i++){\n      if(i!=0)cout<<"" "";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  int n;cin>>n;\n  int sz=20;\n  vector<BIT<ll>>bit(sz+1,BIT<ll>(n+1));\n  auto g=readGraph<int>(n,n-1);\n  HLD hld(g);\n  auto s=vec(sz+1,n,0LL);\n  int q;cin>>q;\n  while(q--){\n    int type;cin>>type;\n    if(type==1){\n      int v;cin>>v;v--;\n      int cl=0;\n      ll ret=0;\n      while(v!=-1&&cl<=sz){\n        if(v==0){\n          rep(i,cl,sz+1){\n            ret+=bit[i][hld.in[0]];\n            //cout<<i spa bit[i][hld.in[0]] spa ""bit""<<endl;\n            ret+=s[i][0];\n          }\n        }\n        else{\n          ret+=bit[cl][hld.in[v]];\n          ret+=s[cl][v];\n          if(cl+1<=sz)ret+=s[cl+1][v];\n        }\n        cl++;\n        v=hld.par[v];\n      }\n      cout<<ret<<endl;\n    }\n    else{\n      int u,v,k,d;cin>>u>>v>>k>>d;u--;v--;\n      int r=hld.lca(u,v);\n      for(auto z:{u,v}){\n        if(z!=r){\n          auto tmp=hld.query_path(hld.move(r,z),z,false);\n          //cout<<z spa r spa hld.move(r,z)<<endl;\n          for(auto z:tmp){\n            //cout<<""hld"" spa z.fi spa z.se<<endl;\n            bit[d].add(z.fi,z.se,k);\n          }\n        }\n      }\n      while(r!=-1&&d>=0){\n        s[d][r]+=k;\n        d--;\n        r=hld.par[r];\n      }\n    }\n  }\n  return 0;\n}']","[0, 0, 0, 0, 1]",2800,For the purpose of solving the task let s choose some root in the tree and introduce another operation to the tree add to all vertices that are in the subtree of the given vertex and on the distance from For example if it s itself or if then it s all children of Let s be the parent of vertex and so on So how to perform this operation Instead of adding to all vertices in the subtree we can add only to the vertex And when we need to get the answer for some vertex we will get it from Of course since there are different s we ll create different arrays for each possible So the answer for the vertex will be equal to Now let s discuss how to use the introduced operation to perform the given one We can make the given operation using ours in the following way Let s find using any standard algorithm binary lifting for example Let s split all affected vertices in three groups subtrees of path inclusive exclusive subtrees of path and subtrees of path Note that in such way all affected vertices belong to at least one group Let s look at group of path The lowest vertices are on distance from the next level are on distance from the next level are on distance from and so on The last level we ll consider in this group is the vertices in the subtree of the on distance from it In such a way all we need to do is add to all on the path from The group of the path is handled in the same way What s left It s vertices in subtree of on distances in subtree of on distances in subtree of on distances in subtree of on distance Note that vertices in subtree of on distance are included in vertices in subtree of on distance Analogically vertices on distance from are included in vertices on distance from Moreover vertices on distance from are included in from that are included in from and so on In other words all we need to proccess are vertices in subtree of on distances and in subtree of on distances and in subtree of on distances and In total it s at most operations add to some vertex As a result all we need to do is add on path from to some ancestor of add in some vertex can be done as operation on path ask value in some vertex We can do all of these operations in using Fenwick tree BIT on s and s we can get from binary lifting So the first statement operation will work in time and the second one also in In total complexity is time and space P S the second operation can be further optimized to but it s not really necessary 
You are given a tree consisting exactly of n vertices Tree is a connected undirected graph with n 1 edges Each vertex v of this tree has a value a v assigned to it Let dist x y be the distance between the vertices x and y The distance between the vertices is the number of edges on the simple path between them Let s define the cost of the tree as the following value firstly let s fix some vertex of the tree Let it be v Then the cost of the tree is sum limits i 1 n dist i v cdot a i Your task is to calculate the of the tree if you can choose v arbitrarily ,"['#include<cstdio>\n#include<vector>\nusing namespace std;\nvector<int>e[200001];\nlong long dp0[200001],s[200001];\nlong long a[200001];\nvoid dfs0(int x,int lt){\n    s[x]=a[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs0(y,x);\n        dp0[x]+=dp0[y]+s[y];\n        s[x]+=s[y];\n    }\n}\nlong long an;\nvoid dfs(int x,int lt,long long v){\n    if(v+dp0[x]>an)an=v+dp0[x];\n    for(int y:e[x]){\n        if(y==lt)continue;\n        dfs(y,x,v+dp0[x]-dp0[y]-s[y]*2+s[1]);\n    }\n}\nint main(){\n    int n;\n    scanf(""%d"",&n);\n    for(int i=1;i<=n;i++)scanf(""%lld"",&a[i]);\n    for(int i=1;i<n;i++){\n        int u,v;\n        scanf(""%d%d"",&u,&v);\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    dfs0(1,1);\n    dfs(1,1,0);\n    printf(""%lld\\n"",an);\n    return 0;\n}\n']","[0, 0, 0, 1, 0]",1900,Firstly let s calculate the answer let it be for some fixed vertex Let this vertex be the vertex Just run simple and calculate the result using the formula from the problem statement Also let s calculate the sum of values let the sum in the subtree of the vertex be in each subtree of the given tree if its root is the vertex It can be easily done with simple dynamic programming And now the magic part let s apply the technique which is called at least we called it so Let s maintain the correct values in subtrees at each step of our algorithm How will values and the answer change if we will go through the edge The following sequence of changes will change all values correctly Firstly it can be seen that will decrease by because the distance to each vertex in this subtree will decrease by one then will decrease by because we change the root of the tree we need this step to maintain the correct values then will increase by because the distance to each vertex in this subtree will increase by one and then will increase by because we change the root of the tree we need this step to maintain the correct values So we can recalculate all the values we need if we go through the edge So now we can write another one to try to update the answer for each vertex as a root as the chosen vertex 
is tired and resentful of the narrow mindset of his village since they are content with staying where they are and are not trying to become the perfect life form Being a top notch inventor wishes to enhance his body and become the perfect life form Unfortunately n of the villagers have become suspicious of his ideas The i th villager has a suspicion of a i on him Individually each villager is scared of Kars so they form into groups to be more powerful The power of the group of villagers from l to r be defined as f l r where f l r a l a l 1 a l 1 a l 2 ldots a r 1 a r Here x y is the absolute value of x y A group with only one villager has a power of 0 wants to break the villagers into exactly k contiguous subgroups so that the sum of their power is minimized Formally he must find k 1 positive integers 1 le r 1 r 2 ldots r k 1 n such that f 1 r 1 f r 1 1 r 2 ldots f r k 1 1 n is minimised Help in finding the minimum value of f 1 r 1 f r 1 1 r 2 ldots f r k 1 1 n ,"[""#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define N 300'005\n\nint n, k, a[N];\nvoid solve()\n{\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++)\n        cin >> a[i];\n    vector<int> tmp;\n    for (int i = 2; i <= n; i++)\n        tmp.push_back(abs(a[i] - a[i - 1]));\n    sort(tmp.begin(), tmp.end(), greater<>());\n    i64 ans = 0;\n    for (int i = 2; i <= n; i++)\n        ans += abs(a[i] - a[i - 1]);\n    for (int i = 0; i < k - 1; i++)\n        ans -= tmp[i];\n    cout << ans << '\\n';\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    cin >> t;\n    while (t--)\n        solve();\n}""]","[1, 0, 0, 0, 0]",800,Let us find Now you need to divide the array into more parts When you split an array of size into two parts the suspicion changes from to Also Substituting this in previous change we get changes to That is gets subtracted Now to get minimum suspicion we need to break the array at such that gets maximised Now we have array of size where We can solve the problem using any of the two approaches Find the least element in and remove that from and add that element to the answer Do this exactly times Time complexity We can sort and don t take maximum elements or take first elements Time Complexity 
Andrew and Eugene are playing a game Initially Andrew has string consisting of digits Eugene sends Andrew multiple queries of type that means replace all digits in string with substrings equal to For example if then query transforms to and query replace 3 by an empty string transforms it to After all the queries Eugene asks Andrew to find the remainder after division of number with decimal representation equal to by When you represent as a decimal number please ignore the leading zeroes also if is an empty string then it s assumed that the number equals to zero Andrew got tired of processing Eugene s requests manually and he asked you to write a program for that Help him ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long)a * b % md;\n}\n\nconst int N = 400010;\n\nchar s[N];\n\nchar foo[N];\n\nchar dig[N];\nvector <char> to[N];\n\nint pw[N], val[N];\n\nint main() {\n  scanf(""%s"", s);\n  int n = strlen(s);\n  int m;\n  scanf(""%d"", &m);\n  for (int i = 0; i < m; i++) {\n    scanf(""%s"", foo);\n    dig[i] = foo[0];\n    to[i].clear();\n    for (int j = 3; foo[j]; j++) {\n      to[i].push_back(foo[j]);\n    }\n  }\n  for (int d = 0; d < 10; d++) {\n    pw[d] = 10;\n    val[d] = d;\n  }\n  for (int i = m - 1; i >= 0; i--) {\n    int d = dig[i] - \'0\';\n    int n_pw = 1;\n    int n_val = 0;\n    int sz = to[i].size();\n    for (int j = 0; j < sz; j++) {\n      int t = to[i][j] - \'0\';\n      n_val = mul(n_val, pw[t]);\n      add(n_val, val[t]);\n      n_pw = mul(n_pw, pw[t]);\n    }\n    pw[d] = n_pw;\n    val[d] = n_val;\n  }\n  int res = 0;\n  for (int i = 0; i < n; i++) {\n    int t = s[i] - \'0\';\n    res = mul(res, pw[t]);\n    add(res, val[t]);\n  }\n  printf(""%d\\n"", res);\n  return 0;\n}\n']","[0, 0, 0, 1, 0]",2100,It is quite diffcult to store the whole string after each query as its length grows exponentially and queries may change it dramatically The good advice is if you can t come up with a solution for a problem try solving it from the other end Suppose we know for some sequence of queries that digit will turn into string for every digit Then string will turn into for concatenation Denote numeric value of Then can be expressed as So can be computed if we know and for all As we need answer modulo we can store these numbers modulo Now prepend some new query to given sequence How will and change Clearly for all these numbers won t change and for they can be computed according to the rule above This recounting is done in time After adding all queries find answer for using the same procedure in time Finally our time complexity is The code for this problem pretty much consists of the above formula so implementation is as easy as it gets once you grasp the idea Optimized simple solutions which just replaced substrings could manage to pass pretests Sorry for that A challenge this problem has a natural modification when you have to give an answer after each query Using algorithm described above it can be solved offline in time Can we do better than this What if we are limited to answer online 
You are playing yet another game where you kill monsters using magic spells There are n cells in the row numbered from 1 to n Initially the i th cell contains the i th monster with h i health You have a basic spell that costs 1 MP and deals 1 damage to the monster you choose You can cast it any number of times Also you have a special scroll with Explosion spell you can use only once You want to finish killing monsters with explosion that s why you firstly cast the basic spell several times possibly zero and then after that you cast one Explosion How does Explosion spell work Firstly you choose the power of the spell if you pour x MP into it Explosion will deal x damage Secondly you choose some monster i which will be targeted by the spell That s what happens next if its health h i x then he stays alive with health decreased by x if h i le x the i th monster dies with an explosion that deals h i 1 damage to monsters in the neighboring cells i 1 and i 1 if these cells exist and monsters inside are still alive if the damage dealt by the explosion is enough to kill the monster i 1 or i 1 i e the current h i 1 le h i 1 or h i 1 le h i 1 then that monster also dies creating a secondary explosion of power h i 1 1 or h i 1 1 that may deals damage to their neighbors and so on until the explosions end Your goal is to kill all the remaining monsters with those chaining explosions that s why you need a basic spell to decrease h i of some monsters or even kill them beforehand monsters die when their current health h i becomes less or equal to zero Note that monsters don t move between cells so for example monsters i and i 2 will never become neighbors What is the minimum total MP you need to kill all monsters in the way you want The total MP is counted as the sum of the number of basic spells you cast and the power x of explosion scroll you ve chosen ,"['/**\n *    author:  tourist\n *    created: 16.02.2023 18:54:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> h(n);\n    for (int i = 0; i < n; i++) {\n      cin >> h[i];\n    }\n    vector<long long> L(n);\n    vector<long long> R(n);\n    for (int rot = 0; rot < 2; rot++) {\n      vector<pair<long long, long long>> st;\n      long long sum = 0;\n      for (int i = 0; i < n; i++) {\n        long long cnt = 1;\n        while (!st.empty() && h[i] - cnt < st.back().first) {\n          long long diff = st.back().first - (h[i] - cnt);\n          sum += diff * st.back().second;\n          cnt += st.back().second;\n          st.pop_back();\n        }\n        if (cnt - 1 > h[i]) {\n          long long extra = cnt - 1 - h[i];\n          sum -= extra * (extra + 1) / 2;\n          cnt = h[i];\n        }\n        L[i] = sum;\n        st.emplace_back(h[i], cnt);\n      }\n      reverse(L.begin(), L.end());\n      reverse(R.begin(), R.end());\n      reverse(h.begin(), h.end());\n      swap(L, R);\n    }\n    long long ans = (long long) 1e18;\n    for (int i = 0; i < n; i++) {\n      ans = min(ans, L[i] + R[i] + h[i]);\n    }\n    cout << ans << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 1, 0, 1, 1]",2200,Note that each unit of damage dealt by explosions save us from using one more basic spell In other words the more the damage from explosions the better So the answer will be equal to Note that in order to kill all remaining monsters with the last spell the array should have the following structure there is a monster we cast the spell onto it and is strictly increasing in and strictly decreasing in ignoring prefix and suffix of s Let s focus on the left part of array segment since solving the right part is exactly the same Maximizing the total damage is equivalent to maximizing the sum of right before the final spell Note that we can use the straight greedy strategy to kill the chosen monster we should use Explosion spell of power exactly it s not optimal to make it either more or less powerful After that monster will create an explosion of power If we must decrease it to exactly to continue the chain of explosions of maximum total damage If we also decrease it to exactly and so on The general formula is This series will stop either if or or there are no monsters left or we met the monster with The two first cases are easy to check in constant time so let s look at the last case Suppose that monster position is equal to then or That monster is interesting to us because after death it creates an explosion of damage that already doesn t depend on and next calculation is practically the same task what chain of explosion we can have if we start from That idea drives us to dp let be the maximum damage of chaining explosion we can deal if we start from and move to the left For simplicity let s include into that total damage Calculating is next let s find the first such that If there are no such or if that is too far from i e we will set Now we know that on interval the damage dealt is the arithmetic progression for it s for it s for it s In total And if such exists and not too far away we increase by as well The last question is finding for each the closest such that Note that if we define we need just need to find last and that s quite standard task that can be solved with stack Let s iterate over and maintain a stack of previous When we need to find for the current let s just look at the top of the stack if we found we wanted otherwise just pop it and check the new top again and so on until either we find or stack becomes empty that would mean that there are no After processing the th element push on top of the stack Why it works Consider some The element on top of the stack is firstly it s but we are talking about general case If we found what we want Otherwise but it also means that previous elements that was popped on previous iteration was greater than So is bigger than as well and there were no need to even consider them i e popping them out earlier doesn t break anything Since each element is pushed in the stack once and popped out once then the complexity is for all for to or amortized The answer for the chosen position then is where is dp we discussed above is the same dp but on reversed array and because we included into both and Both and are calculated in so the total comlpexity is 
You are asked to build an array a consisting of n integers each element should be from 1 to k The array should be non decreasing a i le a i 1 for all i from 1 to n 1 You are also given additional constraints on it Each constraint is of one of three following types 1 i x a i be equal to x 2 i j x a i a j should be less than or equal to x 3 i j x a i a j should be greater than or equal to x Build any non decreasing array that satisfies all constraints or report that no such array exists ,"['/**\n *    author:  tourist\n *    created: 12.06.2022 19:00:43       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) {\n    g.resize(n);\n  }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\ntemplate <typename T>\nclass digraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  digraph(int _n) : graph<T>(_n) {\n  }\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int) edges.size();\n    g[from].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n\n  digraph<T> reverse() const {\n    digraph<T> rev(n);\n    for (auto &e : edges) {\n      rev.add(e.to, e.from, e.cost);\n    }\n    return rev;\n  }\n};\n\ntemplate <typename T>\nvector<int> find_scc(const digraph<T> &g, int &cnt) {\n  digraph<T> g_rev = g.reverse();\n  vector<int> order;\n  vector<bool> was(g.n, false);\n  function<void(int)> dfs1 = [&](int v) {\n    was[v] = true;\n    for (int id : g.g[v]) {\n      auto &e = g.edges[id];\n      int to = e.to;\n      if (!was[to]) {\n        dfs1(to);\n      }\n    }\n    order.push_back(v);\n  };\n  for (int i = 0; i < g.n; i++) {\n    if (!was[i]) {\n      dfs1(i);\n    }\n  }\n  vector<int> c(g.n, -1);\n  function<void(int)> dfs2 = [&](int v) {\n    for (int id : g_rev.g[v]) {\n      auto &e = g_rev.edges[id];\n      int to = e.to;\n      if (c[to] == -1) {\n        c[to] = c[v];\n        dfs2(to);\n      }\n    }\n  };\n  cnt = 0;\n  for (int id = g.n - 1; id >= 0; id--) {\n    int i = order[id];\n    if (c[i] != -1) {\n      continue;\n    }\n    c[i] = cnt++;\n    dfs2(i);\n  }\n  return c;\n}\n\nclass twosat {\n public:\n  digraph<int> g;\n  int n;\n\n  twosat(int _n) : g(digraph<int>(2 * _n)), n(_n) {\n  }\n\n  inline void add(int x, int value_x) {\n    assert(0 <= x && x < n);\n    assert(0 <= value_x && value_x <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * x + value_x);\n  }\n  \n  inline void add(int x, int value_x, int y, int value_y) {\n    assert(0 <= x && x < n && 0 <= y && y < n);\n    assert(0 <= value_x && value_x <= 1 && 0 <= value_y && value_y <= 1);\n    g.add(2 * x + (value_x ^ 1), 2 * y + value_y);\n    g.add(2 * y + (value_y ^ 1), 2 * x + value_x);\n  }\n\n  inline vector<int> solve() {\n    int cnt;\n    vector<int> c = find_scc(g, cnt);\n    vector<int> res(n);\n    for (int i = 0; i < n; i++) {\n      if (c[2 * i] == c[2 * i + 1]) {\n        return vector<int>();\n      }\n      res[i] = (c[2 * i] < c[2 * i + 1]);\n    }\n    return res;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m, k;\n    cin >> n >> m >> k;\n    twosat ts(n * (k + 1));\n    for (int i = 0; i < n; i++) {\n      ts.add(i * (k + 1) + 0, 0);\n      ts.add(i * (k + 1) + k, 1);\n      for (int j = 0; j < k; j++) {\n        ts.add(i * (k + 1) + j, 0, i * (k + 1) + (j + 1), 1);\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      for (int j = 1; j < k; j++) {\n        ts.add(i * (k + 1) + j, 1, (i + 1) * (k + 1) + j, 0);\n      }\n    }\n    while (m--) {\n      int op;\n      cin >> op;\n      if (op == 1) {\n        int i, x;\n        cin >> i >> x;\n        --i;\n        ts.add(i * (k + 1) + x - 1, 1, i * (k + 1) + x, 0);\n      }\n      if (op == 2) {\n        int i, j, x;\n        cin >> i >> j >> x;\n        --i; --j;\n        for (int p = 0; p <= k; p++) {\n          int q = x - 1 - p;\n          if (q >= 0 && q <= k) {\n            ts.add(i * (k + 1) + p, 1, j * (k + 1) + q, 1);\n          }\n        }\n      }\n      if (op == 3) {\n        int i, j, x;\n        cin >> i >> j >> x;\n        --i; --j;\n        for (int p = 0; p <= k; p++) {\n          int q = x - 1 - p;\n          if (q >= 0 && q <= k) {\n            ts.add(i * (k + 1) + p, 0, j * (k + 1) + q, 0);\n          }\n        }\n      }\n    }\n    auto res = ts.solve();\n    if (res.empty()) {\n      cout << -1 << \'\\n\';\n      continue;\n    }\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      for (int j = 1; j <= k; j++) {\n        if (res[i * (k + 1) + j]) {\n          a[i] = j;\n          break;\n        }\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      cout << a[i] << "" \\n""[i == n - 1];\n    }\n  }\n  return 0;\n}\n']","[0, 0, 1, 0, 0]",2800,Imagine there were no constraints of the second or the third types Then it would be possible to solve the problem with some greedy algorithm Unfortunately when both these constraints are present it s not immediately clear how to adapt the greedy Dynamic programming is probably also out of question because you can t maintain all possible cuts between equal values on each prefix Thus let s try to make a graph problem out of this Who knows maybe a flow or something else could work Create nodes for each position Let the th of them on the th position represent the condition of kind is equal to Then all constraints can be described as edges on this graph Binary variables restrictive edges Surely this is 2 SAT Connect the pairs of values that satisfy each constraint Add the edges between the adjacent positions to enforce the restriction on the non decreasing order Prohibit each position to be assigned to multiple values Force each position to be assigned at least one value Huh it s not that easy That s where the 2 SAT idea fails We want the conditions of form But that is not allowed since 2 SAT has to have two variables in a clause That s where the main idea of the problem comes up Instead of making our nodes represent let s make them and try building the graph again If then all nodes for will be true and the rest will be false So if is false then is false That will enforce the validity of the nodes themselves First the order If is true then is true The first type of constraints is basically the same as or For our conditions it s rather not or The second type of constraints Let be greater than or equal to some Then for this constraint to hold should be no greater than Thus if is true then should be false Same for and swapped The third type of constraints is similar Let be less than or equal to some Then for this constraint to hold should be greater than or equal to Thus if is false then should be true Same for and swapped And that s it Solve the 2 SAT and restore the answer I can advise making not but actually nodes for and force the values to be between and That will simplify the checks while adding the constraints Overall complexity 
There is a game called Unique Bid Auction You can read more about it here https en wikipedia org wiki Unique bid auction though you don t have to do it to solve this problem Let s simplify this game a bit Formally there are n participants the i th participant chose the number a i The winner of the game is such a participant that the number he chose is i e nobody else chose this number except him and is i e among all unique values of a the minimum one is the winning one Your task is to find the of the participant who won the game or if there is no winner Indexing is 1 based i e the participants are numbered from 1 to n You have to answer t independent test cases ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef double db;\ntypedef string str;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<db, db> pd;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef vector<ll> vl;\ntypedef vector<db> vd;\ntypedef vector<str> vs;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<pd> vpd;\n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int) (x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend()\n#define sor(x) sort(all(x))\n#define rsz resize\n#define resz resize\n#define ins insert\n#define ft front()\n#define bk back()\n#define pf push_front\n#define pb push_back\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n\n#define f1r(i, a, b) for(int i = (a); i < (b); ++i)\n#define f0r(i, a) f1r(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i,0,a)\n#define ROF(i, a, b) for (int i = (b) - 1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define trav(a, x) for (auto& a : x)\n\nmt19937 rng((uint32_t) chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n\n#ifdef LOCAL\n#define dbg(...) debug(#__VA_ARGS__, __VA_ARGS__);\n#else\n#define dbg(...) 17;\n#endif\n\ntemplate<typename T, typename S> ostream& operator << (ostream &os, const pair<T, S> &p) { return os << ""("" << p.first << "", "" << p.second << "")""; }\ntemplate<typename C, typename T = decay<decltype(*begin(declval<C>()))>, typename enable_if<!is_same<C, string>::value>::type* = nullptr>\nostream& operator << (ostream &os, const C &c) { bool f = true; os << ""{""; for (const auto &x : c) { if (!f) os << "", ""; f = false; os << x; } return os << ""}""; }\ntemplate<typename T> void debug(string s, T x) { cerr << s << "" = "" << x << ""\\n""; }\ntemplate<typename T, typename... Args> void debug(string s, T x, Args... args) { cerr << s.substr(0, s.find(\',\')) << "" = "" << x << "" | ""; debug(s.substr(s.find(\',\') + 2), args...); }\n\nconstexpr int pct(int x) { return __builtin_popcount(x); }\nconstexpr int bits(int x) { return 31 - __builtin_clz(x); } // floor(log2(x))\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1, T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T, SZ>& a);\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class T, class... Ts> void re(T& t, Ts&... ts) {\n        re(t); re(ts...); }\n    template<class T> void re(complex<T>& x) { T a, b; re(a, b); x = cd(a, b); }\n    template<class T1, class T2> void re(pair<T1, T2>& p) { re(p.f, p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i, sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T, SZ>& a) { F0R(i, SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    void pr(int x) { cout << x; }\n    void pr(long x) { cout << x; }\n    void pr(ll x) { cout << x; }\n    void pr(unsigned x) { cout << x; }\n    void pr(unsigned long x) { cout << x; }\n    void pr(unsigned long long x) { cout << x; }\n    void pr(float x) { cout << x; }\n    void pr(double x) { cout << x; }\n    void pr(ld x) { cout << x; }\n    void pr(char x) { cout << x; }\n    void pr(const char* x) { cout << x; }\n    void pr(const string& x) { cout << x; }\n    void pr(bool x) { pr(x ? ""true"" : ""false""); }\n    template<class T> void pr(const complex<T>& x) { cout << x; }\n    template<class T1, class T2> void pr(const pair<T1, T2>& x);\n    template<class T> void pr(const T& x);\n    template<class T, class... Ts> void pr(const T& t, const Ts&... ts) {\n        pr(t); pr(ts...); }\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(""{"", x.f, "", "", x.s, ""}""); }\n    template<class T> void pr(const T& x) {\n        pr(""{""); // const iterator needed for vector<bool>\n        bool fst = 1; for (const auto& a: x) pr(!fst ? "", "" : """", a), fst = 0;\n        pr(""}""); }\n    void ps() { pr(""\\n""); } // print w/ spaces\n    template<class T, class... Ts> void ps(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("" ""); ps(ts...); }\n    void pc() { pr(""]\\n""); } // debug w/ commas\n    template<class T, class... Ts> void pc(const T& t, const Ts&... ts) {\n        pr(t); if (sizeof...(ts)) pr("", ""); pc(ts...); }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(), ""r"", stdin); }\n    void setOut(string s) { freopen(s.c_str(), ""w"", stdout); }\n    void setIO(string s = """") {\n        cin.sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s + "".in""), setOut(s + "".out""); }\n    }\n}\n\nusing namespace io;\n\nconst int MOD = 1e9 + 7; // 998244353;\nconst ld PI = acos((ld) -1);\n\ntypedef decay<decltype(MOD)>::type T;\nstruct mi {\n    T val;\n    explicit operator T() const { return val; }\n    mi() { val = 0; }\n    mi(const ll& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD; }\n    friend ostream& operator << (ostream& os, const mi& a) { return os << a.val; }\n    friend void pr(const mi& a) { pr(a.val); }\n    friend void re(mi& a) { ll x; re(x); a = mi(x); }\n    friend bool operator == (const mi& a, const mi& b) { return a.val == b.val; }\n    friend bool operator != (const mi& a, const mi& b) { return !(a == b); }\n    friend bool operator < (const mi& a, const mi& b) { return a.val < b.val; }\n    friend bool operator > (const mi& a, const mi& b) { return a.val > b.val; }\n    friend bool operator <= (const mi& a, const mi& b) { return a.val <= b.val; }\n    friend bool operator >= (const mi& a, const mi& b) { return a.val >= b.val; }\n    mi operator - () const { return mi(-val); }\n    mi& operator += (const mi& m) {\n        if ((val += m.val) >= MOD) val -= MOD;\n        return *this; }\n    mi& operator -= (const mi& m) {\n        if ((val -= m.val) < 0) val += MOD;\n        return *this; }\n    mi& operator *= (const mi& m) { val = (ll) val * m.val % MOD;\n        return *this; }\n    friend mi pow(mi a, ll p) {\n        mi ans = 1; assert(p >= 0);\n        for (; p; p /= 2, a *= a) if (p & 1) ans *= a;\n        return ans; }\n    friend mi inv(const mi& a) { assert(a != 0); return pow(a, MOD - 2); }\n    mi& operator /= (const mi& m) { return (*this) *= inv(m); }\n    friend mi operator + (mi a, const mi& b) { return a += b; }\n    friend mi operator - (mi a, const mi& b) { return a -= b; }\n    friend mi operator * (mi a, const mi& b) { return a *= b; }\n    friend mi operator / (mi a, const mi& b) { return a /= b; }\n};\n\ntypedef pair<mi, mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint main() {\n    setIO("""");\n    int tt; re(tt);\n    while (tt--) {\n        int n; re(n);\n        vi a(n);\n        f0r(i, n) re(a[i]);\n        map<int, vi> use;\n        f0r(i, n) use[a[i]].eb(i);\n        bool ok = false;\n        for (auto x : use) {\n            if (sz(x.s) == 1) {\n                ok = true;\n                ps(x.s[0] + 1);\n                break;\n            }\n        }\n        if (ok) continue;\n        ps(-1);\n    }\n    return 0;\n}']","[0, 0, 1, 0, 0]",800,This is a simple implementation problem Let s calculate two values for each from to the number of occurrences of in and any position of in Then let s iterate through from to and if just print because if it is the only such element then we found the winner If we didn t find any such element we have to print 
Consider a linear function Let s define and for For the given integer values and find the value of modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int Q = 1e9 + 7;\nstruct Matrix {\n    int n , m , a[2][2];\n    Matrix (int _n = 0, int _m = 0) {\n        n = _n , m = _m;\n        memset(a , 0 , sizeof(a));\n    }\n    Matrix operator * (const Matrix &R) const {\n        Matrix res(n , R.m);\n        for (int i = 0 ; i < n ; ++ i) {\n            for (int j = 0 ; j < m ; ++ j) {\n                for (int k = 0 ; k < R.m ; ++ k) {\n                    res.a[i][k] += (LL)a[i][j] * R.a[j][k] % Q;\n                    res.a[i][k] %= Q;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    LL A , B , n , x;\n    cin >> A >> B >> n >> x;\n    Matrix I(1 , 2);\n    I.a[0][0] = x , I.a[0][1] = 1;\n    Matrix P(2 , 2);\n    P.a[0][0] = A;\n    P.a[1][0] = B;\n    P.a[1][1] = 1;\n    while (n) {\n        if (n & 1) {\n            I = I * P;\n        }\n        P = P * P;\n        n >>= 1;\n    }\n    cout << I.a[0][0] << endl;\n}\n']","[0, 1, 0, 0, 0]",1700,The problem was suggested by Zi Song Yeoh zscoder The problem can be solved using closed formula it s need to calculate the sum of geometric progression The formula can be calculated using binary exponentiation I ll describe more complicated solution but it s more general If we have a set of variables and at each step all variables are recalculating from each other using linear function we can use binary matrix exponentiation There is only one variable in our problem The new variable is calculating using formula Consider the matrix and the vector Let s multiply and Easy to see that we will get the vector So to make iterations we should multiply and times We can do that using binary matrix exponentiation because matrix multiplication is associative As an exercise try to write down the matrix for the Fibonacci numbers and calculate the th Fibonacci number in time The matrix and the vector is under the spoiler The matrix and the vector for the Fibonacci numbersz 0 1 1 1 v 0 1 
Let s define a of length n as an array p of length n which contains every number from 1 to n exactly once You are given a permutation p 1 p 2 dots p n and a number k You need to sort this permutation in the ascending order In order to do it you can repeat the following operation any number of times possibly zero pick two elements of the permutation p i and p j such that i j k and swap them Unfortunately some permutations can t be sorted with some fixed numbers k For example it s impossible to sort 2 4 3 1 with k 2 That s why before starting the sorting you can make at most one choose any pair p i and p j and swap them Your task is to check whether is it possible to sort the permutation any preliminary exchanges if it s not check whether is it possible to sort the permutation using exactly preliminary exchange For example if k 2 and permutation is 2 4 3 1 then you can make a preliminary exchange of p 1 and p 4 which will produce permutation 1 4 3 2 which is possible to sort with given k ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\n\n#define all(a) a.begin(),a.end()\n#define pb push_back\n#define sz(a) ((int)a.size())\n\nconst int N=200005;\n\nint n,k,a[N];\n\nvoid ldc(){\n    cin >> n >> k;\n    for(int i=0; i<n; ++i) cin >> a[i],a[i]--;\n    int de=0;\n    for(int i=0; i<n; ++i) if(a[i]%k!=i%k) de++;\n    assert(de!=1);\n    if(de==0) cout << ""0\\n"";\n    else if(de==2) cout << ""1\\n"";\n    else cout << ""-1\\n"";\n}\n\nsigned main(){\n    ios_base::sync_with_stdio(0),cin.tie(0);\n    int t;\n    cin >> t;\n    while(t--) ldc();\n}']","[0, 1, 0, 0, 0]",900,Let s fix a number and consider all indices such that Note that numbers in these positions can be reordered however we want but they can t leave this set of positions since stay the same Moreover in the sorted permutation these positions must contain numbers such that In total itm means that the permutation can be sorted if holds for all By preliminary exchange we can swap two elements from different sets Therefore if the last equality fails for exactly two elements they can be swapped making sorting possible Otherwise the answer is 
It s Piegirl s birthday soon and Pieguy has decided to buy her a bouquet of flowers and a basket of chocolates The flower shop has different types of flowers available The th type of flower always has exactly petals Pieguy has decided to buy a bouquet consisting of exactly flowers He may buy the same type of flower multiple times The flowers are then arranged into a bouquet The position of the flowers within a bouquet matters You can think of a bouquet as an ordered list of flower types The chocolate shop sells chocolates in boxes There are different types of boxes available The th type of box contains pieces of chocolate Pieguy can buy any number of boxes and can buy the same type of box multiple times He will then place these boxes into a basket The position of the boxes within the basket matters You can think of the basket as an ordered list of box types Pieguy knows that Piegirl likes to pluck a petal from a flower before eating each piece of chocolate He would like to ensure that she eats the last piece of chocolate from the last box just after plucking the last petal from the last flower That is the total number of petals on all the flowers in the bouquet should equal the total number of pieces of chocolate in all the boxes in the basket How many different bouquet basket combinations can Pieguy buy The answer may be very large so compute it modulo ,"['/**\n *    author:  tourist\n *    created: 06.01.2019 23:15:40       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular inverse() const {\n    Type a = value, b = mod(), u = 0, v = 1;\n    while (a != 0) {\n      Type t = b / a;\n      b -= t * a; swap(a, b);\n      u -= t * v; swap(u, v);\n    }\n    assert(b == 1);\n    return Modular(u);\n  }\n  Modular& operator/=(const Modular& other) { return *this *= other.inverse(); }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  stream >> number.value;\n  number.value = Modular<T>::normalize(number.value);\n  return stream;\n}\n\nstruct VarMod { static int value; };\nint VarMod::value;\n\n//using Mint = Modular<VarMod>;\nusing Mint = Modular<std::integral_constant<int, (int) 1e9 + 7>>;\n\ntemplate <typename T>\nvector<T>& operator+=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] += b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator+(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c += b;\n}\n\ntemplate <typename T>\nvector<T>& operator-=(vector<T>& a, const vector<T>& b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < (int) b.size(); i++) {\n    a[i] -= b[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator-(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c -= b;\n}\n\ntemplate <typename T>\nvector<T>& operator*=(vector<T>& a, const vector<T>& b) {\n  if (a.empty() || b.empty()) {\n    a.clear();\n  } else {\n    vector<T> c = a;\n    a.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < (int) c.size(); i++) {\n      for (int j = 0; j < (int) b.size(); j++) {\n        a[i + j] += c[i] * b[j];\n      }\n    }\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator*(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c *= b;\n}\n\ntemplate <typename T>\nvector<T> inverse(const vector<T>& a) {\n  assert(!a.empty());\n  int n = (int) a.size();\n  vector<T> b = {1 / a[0]};\n  while ((int) b.size() < n) {\n    vector<T> x = b * b * vector<T>(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    b.resize(b.size() << 1);\n    for (int i = (int) b.size() >> 1; i < (int) min(x.size(), b.size()); i++) {\n      b[i] = -x[i];\n    }\n  }\n  b.resize(n);\n  return b;\n}\n\ntemplate <typename T>\nvector<T>& operator/=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<T> d = b;\n    reverse(a.begin(), a.end());\n    reverse(d.begin(), d.end());\n    d.resize(n - m + 1);\n    a *= inverse(d);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator/(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c /= b;\n}\n\ntemplate <typename T>\nvector<T>& operator%=(vector<T>& a, const vector<T>& b) {\n  int n = (int) a.size();\n  int m = (int) b.size();\n  if (n >= m) {\n    vector<T> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; i++) {\n      a[i] -= c[i];\n    }\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<T> operator%(const vector<T>& a, const vector<T>& b) {\n  vector<T> c = a;\n  return c %= b;\n}\n\ntemplate <typename T, typename U>\nvector<T> power(const vector<T>& a, const U& b, const vector<T>& c) {\n  assert(b >= 0);\n  vector<U> binary;\n  U bb = b;\n  while (bb > 0) {\n    binary.push_back(bb & 1);\n    bb >>= 1;\n  }\n  vector<T> res = vector<T> {1} % c;\n  for (int j = (int) binary.size() - 1; j >= 0; j--) {\n    res = res * res % c;\n    if (binary[j] == 1) {\n      res = res * a % c;\n    }\n  }\n  return res;\n}\n\nnamespace fft {\n\ntypedef double dbl;\n\nstruct num {\n  dbl x, y;\n  num() { x = y = 0; }\n  num(dbl x_, dbl y_) : x(x_), y(y_) {}\n};\n\ninline num operator+(num a, num b) { return num(a.x + b.x, a.y + b.y); }\ninline num operator-(num a, num b) { return num(a.x - b.x, a.y - b.y); }\ninline num operator*(num a, num b) { return num(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\ninline num conj(num a) { return num(a.x, -a.y); }\n\nint base = 1;\nvector<num> roots = {{0, 0}, {1, 0}};\nvector<int> rev = {0, 1};\n\nconst dbl PI = static_cast<dbl>(acosl(-1.0));\n\nvoid ensure_base(int nbase) {\n  if (nbase <= base) {\n    return;\n  }\n  rev.resize(1 << nbase);\n  for (int i = 0; i < (1 << nbase); i++) {\n    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n  }\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    dbl angle = 2 * PI / (1 << (base + 1));\n//      num z(cos(angle), sin(angle));\n    for (int i = 1 << (base - 1); i < (1 << base); i++) {\n      roots[i << 1] = roots[i];\n//        roots[(i << 1) + 1] = roots[i] * z;\n      dbl angle_i = angle * (2 * i + 1 - (1 << base));\n      roots[(i << 1) + 1] = num(cos(angle_i), sin(angle_i));\n    }\n    base++;\n  }\n}\n\nvoid fft(vector<num> &a, int n = -1) {\n  if (n == -1) {\n    n = (int) a.size();\n  }\n  assert((n & (n - 1)) == 0);\n  int zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; i++) {\n    if (i < (rev[i] >> shift)) {\n      swap(a[i], a[rev[i] >> shift]);\n    }\n  }\n  for (int k = 1; k < n; k <<= 1) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        num z = a[i + j + k] * roots[j + k];\n        a[i + j + k] = a[i + j] - z;\n        a[i + j] = a[i + j] + z;\n      }\n    }\n  }\n}\n\nvector<num> fa, fb;\n\nvector<int64_t> square(const vector<int>& a) {\n  if (a.empty()) {\n    return {};\n  }\n  int need = (int) a.size() + (int) a.size() - 1;\n  int nbase = 1;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if ((sz >> 1) > (int) fa.size()) {\n    fa.resize(sz >> 1);\n  }\n  for (int i = 0; i < (sz >> 1); i++) {\n    int x = (2 * i < (int) a.size() ? a[2 * i] : 0);\n    int y = (2 * i + 1 < (int) a.size() ? a[2 * i + 1] : 0);\n    fa[i] = num(x, y);\n  }\n  fft(fa, sz >> 1);\n  num r(1.0 / (sz >> 1), 0.0);\n  for (int i = 0; i <= (sz >> 2); i++) {\n    int j = ((sz >> 1) - i) & ((sz >> 1) - 1);\n    num fe = (fa[i] + conj(fa[j])) * num(0.5, 0);\n    num fo = (fa[i] - conj(fa[j])) * num(0, -0.5);\n    num aux = fe * fe + fo * fo * roots[(sz >> 1) + i] * roots[(sz >> 1) + i];\n    num tmp = fe * fo;\n    fa[i] = r * (conj(aux) + num(0, 2) * conj(tmp));\n    fa[j] = r * (aux + num(0, 2) * tmp);\n  }\n  fft(fa, sz >> 1);\n  vector<int64_t> res(need);\n  for (int i = 0; i < need; i++) {\n    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n  }\n  return res;\n}\n\nvector<int64_t> multiply(const vector<int>& a, const vector<int>& b) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  if (a.size() == b.size() && a == b) {\n    return square(a);\n  }\n  int need = (int) a.size() + (int) b.size() - 1;\n  int nbase = 1;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if (sz > (int) fa.size()) {\n    fa.resize(sz);\n  }\n  for (int i = 0; i < sz; i++) {\n    int x = (i < (int) a.size() ? a[i] : 0);\n    int y = (i < (int) b.size() ? b[i] : 0);\n    fa[i] = num(x, y);\n  }\n  fft(fa, sz);\n  num r(0, -0.25 / (sz >> 1));\n  for (int i = 0; i <= (sz >> 1); i++) {\n    int j = (sz - i) & (sz - 1);\n    num z = (fa[j] * fa[j] - conj(fa[i] * fa[i])) * r;\n    fa[j] = (fa[i] * fa[i] - conj(fa[j] * fa[j])) * r;\n    fa[i] = z;\n  }\n  for (int i = 0; i < (sz >> 1); i++) {\n    num A0 = (fa[i] + fa[i + (sz >> 1)]) * num(0.5, 0);\n    num A1 = (fa[i] - fa[i + (sz >> 1)]) * num(0.5, 0) * roots[(sz >> 1) + i];\n    fa[i] = A0 + A1 * num(0, 1);\n  }\n  fft(fa, sz >> 1);\n  vector<int64_t> res(need);\n  for (int i = 0; i < need; i++) {\n    res[i] = llround(i % 2 == 0 ? fa[i >> 1].x : fa[i >> 1].y);\n  }\n  return res;\n}\n\nvector<int> multiply_mod(const vector<int>& a, const vector<int>& b, int m) {\n  if (a.empty() || b.empty()) {\n    return {};\n  }\n  int eq = (a.size() == b.size() && a == b);\n  int need = (int) a.size() + (int) b.size() - 1;\n  int nbase = 0;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  if (sz > (int) fa.size()) {\n    fa.resize(sz);\n  }\n  for (int i = 0; i < (int) a.size(); i++) {\n    int x = (a[i] % m + m) % m;\n    fa[i] = num(x & ((1 << 15) - 1), x >> 15);\n  }\n  fill(fa.begin() + a.size(), fa.begin() + sz, num {0, 0});\n  fft(fa, sz);\n  if (sz > (int) fb.size()) {\n    fb.resize(sz);\n  }\n  if (eq) {\n    copy(fa.begin(), fa.begin() + sz, fb.begin());\n  } else {\n    for (int i = 0; i < (int) b.size(); i++) {\n      int x = (b[i] % m + m) % m;\n      fb[i] = num(x & ((1 << 15) - 1), x >> 15);\n    }\n    fill(fb.begin() + b.size(), fb.begin() + sz, num {0, 0});\n    fft(fb, sz);\n  }\n  dbl ratio = 0.25 / sz;\n  num r2(0, -1);\n  num r3(ratio, 0);\n  num r4(0, -ratio);\n  num r5(0, 1);\n  for (int i = 0; i <= (sz >> 1); i++) {\n    int j = (sz - i) & (sz - 1);\n    num a1 = (fa[i] + conj(fa[j]));\n    num a2 = (fa[i] - conj(fa[j])) * r2;\n    num b1 = (fb[i] + conj(fb[j])) * r3;\n    num b2 = (fb[i] - conj(fb[j])) * r4;\n    if (i != j) {\n      num c1 = (fa[j] + conj(fa[i]));\n      num c2 = (fa[j] - conj(fa[i])) * r2;\n      num d1 = (fb[j] + conj(fb[i])) * r3;\n      num d2 = (fb[j] - conj(fb[i])) * r4;\n      fa[i] = c1 * d1 + c2 * d2 * r5;\n      fb[i] = c1 * d2 + c2 * d1;\n    }\n    fa[j] = a1 * b1 + a2 * b2 * r5;\n    fb[j] = a1 * b2 + a2 * b1;\n  }\n  fft(fa, sz);\n  fft(fb, sz);\n  vector<int> res(need);\n  for (int i = 0; i < need; i++) {\n    int64_t aa = llround(fa[i].x);\n    int64_t bb = llround(fb[i].x);\n    int64_t cc = llround(fa[i].y);\n    res[i] = static_cast<int>((aa + ((bb % m) << 15) + ((cc % m) << 30)) % m);\n  }\n  return res;\n}\n\n}  // namespace fft\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type& operator*=(\n    vector<Modular<T>>& a,\n    const vector<Modular<T>>& b) {\n  vector<int> A(a.size());\n  for (int i = 0; i < (int) A.size(); i++) {\n    A[i] = static_cast<int>(a[i]);\n  }\n  vector<int> B(b.size());\n  for (int i = 0; i < (int) B.size(); i++) {\n    B[i] = static_cast<int>(b[i]);\n  }\n  vector<int> C = fft::multiply_mod(A, B, T::value);\n  a.resize(C.size());\n  for (int i = 0; i < (int) C.size(); i++) {\n    a[i] = C[i];\n  }\n  return a;\n}\n\ntemplate <typename T>\ntypename enable_if<is_same<typename Modular<T>::Type, int>::value, vector<Modular<T>>>::type operator*(\n    const vector<Modular<T>>& a,\n    const vector<Modular<T>>& b) {\n  vector<Modular<T>> c = a;\n  return c *= b;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int f, b;\n  long long n;\n  cin >> f >> b >> n;\n  vector<int> p(f);\n  for (int i = 0; i < f; i++) {\n    cin >> p[i];\n  }\n  vector<int> c(b);\n  for (int i = 0; i < b; i++) {\n    cin >> c[i];\n  }\n  int mx = *max_element(c.begin(), c.end());\n  vector<Mint> md(mx + 1);\n  md[mx]++;\n  for (int i = 0; i < b; i++) {\n    md[mx - c[i]]--;\n  }\n  vector<Mint> sum;\n  for (int i = 0; i < f; i++) {\n    sum += power({0, 1}, p[i], md);\n  }\n  vector<Mint> res = power(sum, n, md);\n  vector<Mint> final(mx);\n  final[mx - 1] = 1;\n  res = res * final % md;\n  debug(res);\n  cout << ((int) res.size() <= mx - 1 ? Mint(0) : res[mx - 1]) << \'\\n\';\n  return 0;\n}\n']","[0, 1, 0, 0, 0]",3300,Let s first consider how to compute the number of ways to make a bouquet with exactly K petals Define a polynomial Then if we compute P x N the coefficient of xK gives the number of ways to make a bouquet with exactly K petals This is because each possible bouquet produces a term with an exponent equal to its number of petals Now lets consider how to compute the number of ways to make a basket with exactly K chocolates Define a polynomial Then if we compute the coefficient of x0 gives the number of ways to make a basket with exactly K chocolates This can be derived from a Generating Function but we will provide an alternate derivation Now let s define a polynomial Initially W x 1 Lines 3 through 5 add a multiple of Q x to W x and line 6 divides W x by x It follows that the resulting polynomial is congruent to x K modulo Q x The final answer is the sum over all values of K of the number of bouquets with K petals times the number of baskets with K chocolates The number of bouquets is given by the xK coefficient of P x N or equivalently the x K coefficient of P x 1 N and the number of baskets is given by the coefficient of x0 of It follows that the answer is simply the coefficient of x0 of This can be computed using polynomial multiplications each of which takes O max ci 2 time using naive multiplication for a total runtime of 
At the Byteland State University marks are strings of the same length Mark is considered better than if string is lexicographically smaller than Recently at the BSU was an important test work on which Vasya recived the mark It is very hard for the teacher to remember the exact mark of every student but he knows the mark such that every student recieved mark strictly smaller than Vasya isn t satisfied with his mark so he decided to improve it He can swap characters in the string corresponding to his mark as many times as he like Now he want to know only the number of different ways to improve his mark so that his teacher didn t notice something suspicious More formally you are given two strings of the same length and you need to figure out the number of different strings such that 1 can be obtained from by swapping some characters in other words is a permutation of 2 String is lexicographically smaller than 3 String is lexicographically smaller than For two strings and of the same length it is true that is lexicographically smaller than if there exists such that Since the answer can be very large you need to find answer modulo ,"['#include""bits/stdc++.h""\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,""r"",stdin)\n#define fw(x) freopen(x,""w"",stdout)\n#define iout(x) printf(""%d\\n"",x)\n#define lout(x) printf(""%lld\\n"",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<"" = ""<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 1000010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch==\'-\')f=-1;}while(ch<\'0\'||ch>\'9\');do x=x*10+ch-\'0\',ch=getchar();while(ch<=\'9\'&&ch>=\'0\');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,ans;\n\nchar A[maxn],B[maxn];\n\nint fac[maxn],inv[maxn],has[30],pre[30],suf[30];\n\n\nvoid Work(){\n\tREP(j,1,n){\n\t\tpre[0]=1;\n\t\tREP(i,1,26)pre[i]=1ll*pre[i-1]*inv[has[i]]%mod;\n\t\tsuf[27]=1;\n\t\tRREP(i,26,1)suf[i]=1ll*suf[i+1]*inv[has[i]]%mod;\n\t\tREP(i,1,B[j]-\'a\')if(has[i]){\n\t\t\tans=(1ll*fac[n-j]*pre[i-1]%mod*suf[i+1]%mod*inv[has[i]-1]+ans)%mod;\n\t\t}\n\t\tif(!has[B[j]-\'a\'+1])break;\n\t\thas[B[j]-\'a\'+1]--;\n\t}\n\tREP(i,1,26)has[i]=0;\n\tREP(i,1,n)has[A[i]-\'a\'+1]++;\n\tREP(j,1,n){\n\t\tpre[0]=1;\n\t\tREP(i,1,26)pre[i]=1ll*pre[i-1]*inv[has[i]]%mod;\n\t\tsuf[27]=1;\n\t\tRREP(i,26,1)suf[i]=1ll*suf[i+1]*inv[has[i]]%mod;\n\t\tREP(i,1,A[j]-\'a\')if(has[i]){\n\t\t\tans=(ans-1ll*fac[n-j]*pre[i-1]%mod*suf[i+1]%mod*inv[has[i]-1]%mod+mod)%mod;\n\t\t}\n\t\thas[A[j]-\'a\'+1]--;\n\t}\n\tans=(ans-1+mod)%mod;\n\tiout(ans);\n}\n\nvoid Init(){\n\tscanf(""%s%s"",A+1,B+1);\n\tn=strlen(A+1);\n\tREP(i,1,n)has[A[i]-\'a\'+1]++;\n\tfac[0]=1;REP(i,1,n)fac[i]=1ll*fac[i-1]*i%mod;\n\tREP(i,0,n)inv[i]=fexp(fac[i],mod-2);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n\n']","[0, 1, 0, 0, 0]",2100,Suppose that we can calculate the function equal to the number of permutations of the string strictly less than Then the answer is Now we need to understand how to find First we should count the number of occurrences of each letter in the string Than we can iterate through the position of the first different symbol in the permutation and the string and update the number of remaining symbols For each such position we need to iterate through the symbol in the permutation of which will stand in this position It must be less than the character at this position in the string For each such situation we can calculate and add to the answer the number of different permutations that can be obtained using symbols not currently involved Their number is stored in In its simplest form this solution works in where is the size of the alphabet Such a solution can t pass the tests but it can be optimized to and that is enough to solve the problem Time complexity where is the size of alphabet Solution Arpa s solution 
Patrick calls a substring dagger of a binary string ddagger if this substring contains exactly one Help Patrick count the number of binary strings s such that s contains exactly n good substrings and has no good substring of length strictly greater than k Note that substrings are differentiated by their location in the string so if s you should count both occurrences of dagger A string a is a substring of a string b if a can be obtained from b by the deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ddagger A binary string is a string that only contains the characters and ,"[""#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define isz(x) ((int)x.size())\n#define sumof(x) accumulate(all(x), 0ll)\n\nconst int N=2510, mod=998244353;\nint f[N][N], n, k;\n\nvoid add(int &x, int y){\n   x=x+y>=mod?x+y-mod:x+y;\n}\n\nvoid solve(){\n   cin >> n >> k;\n   for (int i=0; i<=n; ++i) f[0][i]=1;\n   for (int i=1; i<=n; ++i){\n      for (int j=0; j<=i; ++j){\n         for (int t=0; t<=n; ++t){\n            int d=i-(j+1)*(t+1);\n            if (d<0 || j+t+1>k) break;\n            add(f[i][j], f[d][t]);\n         }\n      }\n   }\n   int ans=0;\n   for (int i=0; i<=n; ++i) add(ans, f[n][i]);\n   cout << ans << '\\n';\n   for (int i=0; i<=n; ++i) for (int j=0; j<=n; ++j) f[i][j]=0;\n}\n\nint32_t main(){\n   ios_base::sync_with_stdio(false);\n   cin.tie(nullptr);\n   int ntests=1;\n   cin >> ntests;\n   for (int i=1; i<=ntests; ++i) solve();\n   return 0;\n}\n""]","[0, 1, 0, 1, 0]",2100,Let s first solve the problem where we are given some string s and must count the number of good substrings To do this we use the technique of counting contributions For every 1 in s we find the number of good substrings containing that 1 Consider the following example 00001 a10001 a200000001 a30001 a4000 a5 The number of good substrings in this example is a1a2 a2a3 a3a4 a4a5 We can create such array for any string s and the number of good substrings of s is the sum of the products of adjacent elements of the array This motivates us to reformulate the problem Instead we count the number of arrays a1 a2 am such that every element is positive and the sum of the products of adjacent elements is exactly equal to n Furthermore every pair of adjacent elements should have sum minus 1 be less than or equal to k We can solve this with dynamic programming dpi j number of arrays with sum i and last element j dpi j p 1min ij k j 1 dpi j p p The key observation is that we only have to iterate p up to ij since if p is any greater j p will exceed i At j 1 we will iterate over at most i1 values of p At j 2 we will iterate over at most i2 values of p In total at each i we will iterate over at most i1 i2 ii ilogi values of p Thus the time complexity of our solution is O nklogn 
Serega loves fun However everyone has fun in the unique manner Serega has fun by solving query problems One day Fedor came up with such a problem You are given an array consisting of positive integers and queries to it The queries can be of two types Make a unit cyclic shift to the right on the segment from to both borders inclusive That is rearrange elements of the array in the following manner Count how many numbers equal to are on the segment from to both borders inclusive Fedor hurried to see Serega enjoy the problem and Serega solved it really quickly Let s see can you solve it ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 200010;\nconst int MAGIC = 474;\n\nint len;\nint a[N];\n\nint cnt, from[N], to[N];\nvector <int> where[N];\n\nvoid init() {\n  cnt = 1;\n  from[0] = 1;\n  to[0] = len;\n  for (int i = 1; i <= len; i++) {\n    where[i].clear();\n  }\n  for (int i = 1; i <= len; i++) {\n    where[a[i]].push_back(i);\n  }\n}\n\nint get_count(int k, int from, int to) {\n  int sz = where[k].size();\n  if (sz == 0) {\n    return 0;\n  }\n  int low = 0, high = sz;\n  while (low < high) {\n    int mid = (low + high) >> 1;\n    if (where[k][mid] < from) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  int X = low;\n  low = -1, high = sz - 1;\n  while (low < high) {\n    int mid = (low + high + 1) >> 1;\n    if (where[k][mid] > to) {\n      high = mid - 1;\n    } else {\n      low = mid;\n    }\n  }\n  int Y = low;\n  return (Y - X + 1);\n}\n\nint new_from[N], new_to[N];\n\nint bounds[4], bound_id;\n\nvoid cut(int b0, int b1, int b2) {\n  bounds[0] = b0;\n  bounds[1] = b1;\n  bounds[2] = b2;\n  bounds[3] = 123456789;\n  bound_id = 0;\n  int new_cnt = 0;\n  int sum = 0;\n  for (int i = 0; i < cnt; i++) {\n    int new_sum = sum + (to[i] - from[i] + 1);\n    if (new_sum <= bounds[bound_id]) {\n      if (new_sum == bounds[bound_id]) {\n        bound_id++;\n      }\n      new_from[new_cnt] = from[i];\n      new_to[new_cnt] = to[i];\n      new_cnt++;\n      sum = new_sum;\n      continue;\n    }\n    int get = bounds[bound_id] - sum;\n    new_from[new_cnt] = from[i];\n    new_to[new_cnt] = from[i] + get - 1;\n    new_cnt++;\n    from[i] += get;\n    sum += get;\n    bound_id++;\n    i--;\n  }\n  cnt = new_cnt;\n  for (int i = 0; i < cnt; i++) {\n    from[i] = new_from[i];\n    to[i] = new_to[i];\n  }\n}\n\nint new_a[N];\n\nint main() {\n  scanf(""%d"", &len);\n  for (int i = 1; i <= len; i++) {\n    scanf(""%d"", a + i);\n  }\n  init();\n  int tt;\n  scanf(""%d"", &tt);\n  int lastans = 0;\n  for (int qq = 1; qq <= tt; qq++) {\n    int com;\n    scanf(""%d"", &com);\n    if (com == 2) {\n      int ll, rr, kk;\n      scanf(""%d %d %d"", &ll, &rr, &kk);\n      ll = ((ll + lastans - 1) % len) + 1;\n      rr = ((rr + lastans - 1) % len) + 1;\n      kk = ((kk + lastans - 1) % len) + 1;\n      if (ll > rr) {\n        swap(ll, rr);\n      }\n      int ans = 0;\n      int sum = 0;\n      for (int i = 0; i < cnt; i++) {\n        int x = from[i], y = to[i];\n        int begin = sum + 1, end = sum + (y - x + 1);\n        if (ll > begin) {\n          x += ll - begin;\n        }\n        if (rr < end) {\n          y -= end - rr;\n        }\n        if (x <= y) {\n          ans += get_count(kk, x, y);\n        }\n        sum = end;\n      }\n      lastans = ans;\n      printf(""%d\\n"", ans);\n    } else {\n      int ll, rr;\n      scanf(""%d %d"", &ll, &rr);\n      ll = ((ll + lastans - 1) % len) + 1;\n      rr = ((rr + lastans - 1) % len) + 1;\n      if (ll > rr) {\n        swap(ll, rr);\n      }\n      if (ll == rr) {\n        continue;\n      }\n      cut(ll - 1, rr - 1, rr);\n      int first = -1;\n      int sum = 0;\n      for (int i = 0; i < cnt; i++) {\n        if (sum == ll - 1) {\n          first = i;\n        }\n        sum += to[i] - from[i] + 1;\n        if (sum == rr) {\n          int p = from[i];\n          for (int j = i; j > first; j--) {\n            from[j] = from[j - 1];\n            to[j] = to[j - 1];\n          }\n          from[first] = to[first] = p;\n          break;\n        }\n      }\n    }\n    if (cnt > MAGIC) {\n      int pos = 0;\n      for (int i = 0; i < cnt; i++) {\n        for (int j = from[i]; j <= to[i]; j++) {\n          new_a[++pos] = a[j];\n        }\n      }\n      for (int i = 1; i <= len; i++) {\n        a[i] = new_a[i];\n      }\n      init();\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 0, 1]",2700,Let s change the query type to two more simple requests Erase a number from th position Insert this number after th position Now let s keep our array as blocks In each block will store the numbers themselves in such a manner as in the array and will store an array number of integers in block This requires space Now we can fast process the queries of the st type We can erase number from th position in operations And we can insert this number after th position in operations Also we can fast recalc after transformations Also we can fast process the queries of the Unable to parse markup type CF TEX To keep the size of the blocks close to we need rebuild our structure after each th query of the st type We can rebuild structure in operations Asymptotics 
Paprika loves permutations She has an array a 1 a 2 dots a n She wants to make the array a of integers 1 to n In order to achieve this goal she can perform operations on the array In each operation she can choose two integers i 1 le i le n and x x 0 then perform a i a i bmod x that is replace a i by the remainder of a i divided by x In different operations the chosen i and x Determine the minimum number of operations needed to make the array a permutation of integers 1 to n If it is impossible output 1 A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tint t;\n\tfor (cin >> t; t; t -= 1) {\n\t\t//b < a / 2\n\t\tint n;\n\t\tcin >> n;\n\t\tset<int> s;\n\t\tfor (int i = 1; i <= n; i += 1) s.insert(i);\n\t\tvector<int> v;\n\t\tfor (int i = 1, a; i <= n; i += 1) {\n\t\t\tcin >> a;\n\t\t\tif (s.contains(a)) s.erase(a);\n\t\t\telse v.push_back(a);\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint ok = 1;\n\t\tfor (int i = 0; int x : s)\n\t\t\tif (x * 2 >= v[i ++]) ok = 0;\n\t\tif (ok) cout << v.size() << ""\\n"";\n\t\telse cout << ""-1\\n"";\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 0]",1300,SolutionKey observation if and if Notice that the bigger the the bigger the range of values that can be obtained after one operation So intuitively we want to assign smaller to smaller numbers in the resulting permutation However if satisfies we can just leave it there and use it in the resulting permutation if multiple satisfy and have the same value just choose one Let s suppose in the optimal solution we change to and change to for some are values not indices Then changing to i e doing nothing and changing to uses less operation And if it is possible to change to then it must be possible to change to However if it is not possible to change to it might still be possible to change to Therefore the solution is as follows Sort the array For each element in the sorted array If and it is the first occurrence of element with value leave it there Else let the current least unassigned value in the resulting permutation be if we can assign the current element to value and add the number of operations by Else output directly The solution works in 
Spyofgame founder of Orzlim religionA long time ago Spyofgame invented the famous array a 1 indexed of length n that contains information about the world and life After that he decided to convert it into the matrix b 0 indexed of size n 1 times n 1 which contains information about the world life and beyond Spyofgame converted a into b with the following rules b i 0 0 if 0 leq i leq n b 0 i a i if 1 leq i leq n b i j b i j 1 oplus b i 1 j if 1 leq i j leq n Here oplus denotes the bitwise XOR operation Today archaeologists have discovered the famous matrix b However many elements of the matrix has been lost They only know the values of b i n for 1 leq i leq n note that these are some elements of the last not the last The archaeologists want to know what a possible array of a is Can you help them reconstruct any array that could be a ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define Maxn 2000007\nint n,a[Maxn];\nint main()\n{\n    scanf(""%d"",&n);\n    for (int i=0;i<n;i++)\n        scanf(""%d"",&a[i]);\n    int k=0;\n    while ((1<<k)<n) ++k;\n    for (int id=0;id<k;id++)\n        for (int i=0;i<n;i++)\n            if (i&(1<<id)) a[i]^=a[i^(1<<id)];\n    for (int id=0;id<k;id++)\n        for (int i=0;i<n;i++)\n            if (i&(1<<id)) a[i^(1<<id)]^=a[i];\n    for (int i=n-1;i;i--)\n        printf(""%d "",a[i]);\n    printf(""%d\\n"",a[0]);\n    return 0;\n}']","[0, 1, 0, 1, 0]",2900,First we can see that contribute times to which can calculate similar to Pascal s Triangle It s easy to see that the value that contribute to equal to when is odd otherwise Let s solve the inverse problem Given array Construct for all By Lucas Theorem is odd when is a submask of with is inverse mask of Let define with smallest satisfy Set and then is the Zeta transform of So we could apply Mobius transform in to get Since the operation is xor mobius transform is as same as zeta transform But unlike the inverse problem there are some differences We don t know the value of for in Let be the sum over supermasks array of with is supermasks of when then set for in After that do another sum over supermasks on to get original value of Now we can find from and from Complexity Solution 
There is an infinite 2 dimensional grid The robot stands in cell 0 0 and wants to reach cell x y Here is a list of possible commands the robot can execute move north from cell i j to i j 1 move east from cell i j to i 1 j move south from cell i j to i j 1 move west from cell i j to i 1 j stay in cell i j The robot wants to reach cell x y in as few commands as possible However he can t execute the same command two or more times in a row What is the minimum number of commands required to reach x y from 0 0 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tint tc; scanf(""%d"", &tc);\n\twhile(tc--) {\n\t\tint x, y; scanf(""%d%d"", &x, &y);\n\t\tif(x < y) swap(x, y);\n\t\tif(x == y) printf(""%d\\n"", x + y);\n\t\telse printf(""%d\\n"", 2 * y + 1 + (x - y - 1) * 2);\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",800,Obviously you can always obtain the optimal answer without using west or south moves So the shortest path consists of east moves and north moves Let s estimate the lower bound of the answer Take a look at these constructions and let question mark be any command different from the used one That s the tightest you can put east or north moves in So the answer is at least For you can put them just as in the construction and fill the rest of question marks with a stay in place move case works differently though You can do it only in moves by taking alternating moves Overall complexity per testcase 
Peter wrote on the board a strictly increasing sequence of positive integers Then Vasil replaced some digits in the numbers of this sequence by question marks Thus each question mark corresponds to exactly one lost digit Restore the the original sequence knowing digits remaining on the board ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, f[100001][11], pos[100001], len[100001];\nchar str[100001][11], ans[100001][11];\nbool b[100001][11];\n\nint main(){\n     //freopen(""e.in"", ""r"", stdin);\n     //freopen(""e.out"", ""w"", stdout);\n     scanf(""%d"", &n);\n     for (int i = 1; i <= n; i++) \n     {\n          scanf(""%s"", str[i] + 1);\n          pos[i] = 0; len[i] = strlen(str[i] + 1);\n     }\n     for (int j = 1; j <= len[1]; j++)\n          if (str[1][j] == \'?\')\n               if (j == 1) ans[1][j] = \'1\';\n               else ans[1][j] = \'0\';\n          else ans[1][j] = str[1][j];\n     bool ok = true;\n     for (int i = 2; i <= n; i++)\n     {\n          if (len[i] < len[i - 1])\n          {\n               ok = false;\n               break;\n          }\n          else\n          if (len[i] > len[i - 1])\n          {\n               for (int j = 1; j <= len[i]; j++)\n                    if (str[i][j] == \'?\')\n                         if (j == 1) ans[i][j] = \'1\';\n                         else ans[i][j] = \'0\';\n                    else ans[i][j] = str[i][j];\n          }\n          else\n          {\n               bool status = true, big = false;\n               for (int j = 1; j <= len[i] && status; j++)\n                    if (str[i][j] != \'?\')\n                    {\n                         if (!big && str[i][j] < ans[i - 1][j])\n                              status = false;\n                         else \n                         {\n                              ans[i][j] = str[i][j];\n                              if (str[i][j] > ans[i - 1][j]) big = true;\n                         }\n                    }\n                    else\n                    {\n                         char now[11];\n                         for (int k = 1; k < j; k++) now[k] = ans[i][k];\n                         int up = 0; if (j == 1) up = 1;\n                         bool find = false;\n                         for (int k = up; k < 10 && !find; ++k)\n                         {\n                              now[j] = k + \'0\';\n                              for (int l = j + 1; l <= len[i]; l++)\n                                   if (str[i][l] == \'?\') now[l] = \'9\';\n                                   else now[l] = str[i][l];\n                              bool r = false;\n                              for (int e = 1; e <= len[i]; e++)\n                                   if (now[e] > ans[i - 1][e]) \n                                   {\n                                        r = true;\n                                        break;\n                                   }\n                                   else\n                                   if (now[e] < ans[i - 1][e]) \n                                   {\n                                        r = false;\n                                        break;\n                                   }\n                              if (r) \n                              {\n                                   find = true, ans[i][j] = now[j];\n                                   if (ans[i][j] > ans[i - 1][j]) big = true;\n                              }\n                         }\n                         if (!find) status = false;\n                    }\n               if (!status || !big) \n               {\n                    ok = false;\n                    break;\n               }\n          }\n     }\n     if (!ok) printf(""NO\\n"");\n     else\n     {\n          printf(""YES\\n"");\n          for (int i = 1; i <= n; i++)\n          {\n               for (int j = 1; j <= len[i]; j++) printf(""%c"", ans[i][j]);\n               printf(""\\n"");\n          }\n     }\n}\n']","[1, 0, 1, 0, 0]",2000,Let s iterate on specified numbers and try to make from current number minimal possible which value more than value of previous number Let s current number is previous number is If length of number less than length of number let s print this problem has not solution If length of number more than length of number replace all signs in number to digit except case when sign in first position replace him on digit because numbers in answer must be without leading zeroes Another case when lengths of numbers and are equal Let s iterate on positions in which prefix number more than prefix of number Now we need to try for this position make minimal possible number which more than In all positions which less than replace all on In all positions which more than replace all on digit If than make If received number less or equal to this position is bad From all good positions choose minimal number received with operations above and assign him number and will continue iteration If count of such positions is we need to print 
You have r red and b blue beans You d like to distribute them among several maybe one packets in such a way that each packet has at least one red bean or the number of red beans r i ge 1 has at least one blue bean or the number of blue beans b i ge 1 the number of red and blue beans should differ in no more than d or r i b i le d Can you distribute all beans ,"['#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int64_t R, B, D;\n    cin >> R >> B >> D;\n\n    if (R > B)\n        swap(R, B);\n\n    cout << (R * (D + 1) >= B ? ""YES"" : ""NO"") << \'\\n\';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","[0, 1, 0, 0, 0]",800,Without loss of generality let s say otherwise we can swap them Note that you can t use more than packets at least one red bean in each packet so can t exceed at most blue beans in each packet So if then asnwer is Otherwise we can form exactly packets 
Anton goes to school his favorite lessons are arraystudying He usually solves all the tasks pretty fast but this time the teacher gave him a complicated one given two arrays and of length find array such that where means bitwise AND while means bitwise OR Usually Anton is good in arraystudying but this problem is too hard so Anton asks you to help ,"['#include <iostream>\n#include <fstream>\n#include <list>\n#include <stack>\n#include <deque>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <ctime>\n#include <iterator>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\nconst int maxn = 200500;\nconst int inf = 2e9;\nconst double eps = 1e-8;\nconst int base = 1073676287;\n\nll a[maxn];\nint b[maxn];\nint c[maxn];\nint bit[64];\nint bits2[64];\n\nvoid check( int n ) {\n    ll sum = 0LL;\n\tfor ( int j = 0; j < n; j++ ) {\n\t    sum += a[j];\n\t\tint x = a[j];\n\t\tint pos = 0;\n\t\twhile ( x ) {\n\t\t\tbit[pos++] += x % 2;\n\t\t\tx /= 2;\n\t\t}\n\t}\n\tfor ( int j = 0; j < n; j++ ) {\n\t\tint x = a[j];\n\t\tint pos = 0;\n\t\tfor ( int i = 0; i < 64; i++ )\n\t\t\tbits2[i] = 0;\n\t\twhile ( x ) {\n\t\t\tbits2[pos++] = x % 2;\n\t\t\tx /= 2;\n\t\t}\n\t\tll cnt = 0LL;\n\t\tll deg = 1LL;\n\t\tfor ( int i = 0; i < 60; i++ ) {\n\t\t\tif ( bits2[i] )\n\t\t\t\tcnt += 1LL * bit[i] * deg;\n\t\t\tdeg *= 2LL;\n\t\t}\n\t\tif ( cnt != b[j] ) {\n\t\t\tputs( ""-1"" );\n\t\t\texit( 0 );\n\t\t}\n\t\tif ( 1LL * a[j] * n + sum != 1LL * b[j] + 1LL * c[j] ) {\n\t\t\tputs( ""-1"" );\n\t\t\texit( 0 );\n        }\n    }\n}\n\nint main()\n{\n    srand( time( 0 ) );\n    // freopen( ""input.txt"", ""r"", stdin );\n    // freopen( ""output.txt"", ""w"", stdout );\n    // ios_base::sync_with_stdio(false);\n    int n;\n    ll sum = 0LL;\n    scanf ( ""%d"", &n );\n    for ( int j = 0; j < n; j++ ) {\n    \tscanf ( ""%d"", &b[j] );\n    \tsum += 1LL * b[j];\n    }\n    for ( int j = 0; j < n; j++ ) {\n   \t\tscanf ( ""%d"", &c[j] );\n   \t\tsum += 1LL * c[j];\n    }\n    if ( sum % ( 2LL * n ) != 0LL ) {\n    \tputs( ""-1"" );\n    \treturn 0;\n    }\n    sum /= 2LL * n;\n    for ( int j = 0; j < n; j++ ) {\n    \tint cur = b[j] + c[j];\n    \ta[j] = cur - sum;\n    \tif ( a[j] < 0LL ) {\n    \t\tputs( ""-1"" );\n    \t\treturn 0;\n    \t}\n    \tif ( 1LL * a[j] % n != 0LL ) {\n    \t\tputs( ""-1"" );\n    \t\treturn 0;\n    \t}\n    \ta[j] /= 1LL * n;\n    }\n    check( n );\n    for ( int j = 0; j < n; j++ )\n    \tcout << a[j] << \' \';\n    return 0;\n}\n']","[0, 1, 1, 0, 0]",2500,We ll prove that At first let s prove that it s true when To do it let s consider all the possible values of and Here we can see that the equality is true Now we ll prove it for any positive integers To do it let s divide and into bits Here mean the bits of and mean the bits of Now let s divide and into bits Rewrite the initial equality Now it s not hard to observe that is true because the equality is true for bits Similarly we see that is true and so on From all this it follows that the equality is true Let s create an array where It s obvious thatSee thatfrom where Now it s not hard to find Now we only must check the answer for correctness It s obvious then if answer exists it s alway unique because it s explicitly derived from the formula above To check if the answer exists let s build arrays and from the found array and compare it with the arrays given in the input We ll do this separately for every bit Let s calculate amount of numbers in array that has a one in the th bit Let s denote the th bit of as Now let s count and such as It s not hard to do since we know See that if we calculate it will be easy to find Time complexity is where 
You are given n chips on a number line The i th chip is placed at the integer coordinate x i Some chips You can perform each of the two following types of moves any possibly zero number of times on any chip Move the chip i by 2 to the left or 2 to the right i e replace the current coordinate x i with x i 2 or with x i 2 move the chip i by 1 to the left or 1 to the right and pay for this move i e replace the current coordinate x i with x i 1 or with x i 1 Note that it s allowed to move chips to any integer coordinate including negative and zero Your task is to find the minimum total number of coins required to move all n chips to the same coordinate i e all x i should be equal after some sequence of moves ,"['#include ""bits/stdc++.h""\nusing namespace std;\n// #define int long long\n#define pb push_back\n#define fi first\n#define se second\n#define FF first\n#define SS second\n#define mp make_pair\n#define pii pair<int,int>\n#define sd(x) scanf(""%d"",&x)\n#define slld(x) scanf(""%lld"",&x)\n#define pd(x) printf(""%d\\n"",x)\n#define plld(x) printf(""%lld\\n"",x)\n#define endl \'\\n\'\n#define fr(i, a, b) for(int i = a; i <= b; i++)\n#define sz(x) (int)x.size()\n#define all(x) x.begin(), x.end()\n\ntypedef long long ll;\ntypedef long double f80;\n\nconst int mod = 1e9 + 7;\n\nll pwr(ll a, ll b) {\n    a %= mod;\n    ll ans = 1;\n    while(b) {\n        if(b & 1) ans = (ans * a) % mod;\n        a = (a * a) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\n\nsigned main()\n{\n    #ifdef LOCAL\n        freopen(""inp.txt"", ""r"", stdin);\n        freopen(""out.txt"", ""w"", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    int n;\n    cin >> n;\n    int b0 = 0, b1 = 0;\n    fr(i, 1, n) {\n        int x;\n        cin >> x;\n        x %= 2;\n        if(x) b1++;\n        else b0++;\n    }\n    cout << min(b0, b1);\n    return 0;\n}']","[0, 1, 0, 0, 0]",900,We can see that the only information we need is the parity of the coordinate of each chip because we can move all chips that have the same parity to one coordinate for free So if the number of chips with odd coordinate is then the answer is 
You are given an array consisting of integers You have to process queries to this array each query is given as four numbers and denoting that for every such that and you have to set equal to Print the array after all queries are processed ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic void adjust(list<int> &X, list<int> &Y, int l, int r)\n{\n    auto it = X.begin();\n    while (it != X.end())\n    {\n        auto nxt = next(it);\n        if (*it >= l && *it < r)\n            Y.splice(Y.begin(), X, it);\n        it = nxt;\n    }\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N;\n    cin >> N;\n    int S = min(500, N);\n    int M = (N + S - 1) / S;\n    int H = 101;\n    vector<vector<list<int>>> pos(H, vector<list<int>>(M));\n    for (int i = 0; i < N; i++)\n    {\n        int s = i / S;\n        int a;\n        cin >> a;\n        pos[a][s].push_back(i);\n    }\n    int Q;\n    cin >> Q;\n    for (int i = 0; i < Q; i++)\n    {\n        int l, r, x, y;\n        cin >> l >> r >> x >> y;\n        l--;\n        if (x == y)\n            continue;\n        int sl = l / S;\n        int sr = (r - 1) / S;\n        adjust(pos[x][sl], pos[y][sl], l, r);\n        if (sl != sr)\n            adjust(pos[x][sr], pos[y][sr], l, r);\n        for (int i = sl + 1; i < sr; i++)\n            pos[y][i].splice(pos[y][i].begin(), std::move(pos[x][i]));\n    }\n\n    vi a(N);\n    for (int i = 0; i < M; i++)\n        for (int j = 0; j < H; j++)\n            for (int p : pos[j][i])\n                a[p] = j;\n\n    for (int i = 0; i < N; i++)\n        cout << a[i] << \' \';\n    cout << \'\\n\';\n\n    return 0;\n}\n']","[0, 0, 0, 0, 1]",2500,We can represent a query as a function if If we want to apply two functions then we can calculate a composition of these functions in time in this problem is So we can do the following Use scanline technique Build a segment tree over queries where we store a composition of functions on segment in each vertex Initially all transformations are When a segment where we apply a query begins we update the segment tree we change the transformations on this query s index to the following if When a segment ends we revert the transformation on this index to The trick is that the composition of all current transformations is stored in the root of the segment tree so we can easily calculate the result of transformation 
You are given a square matrix A of size n times n whose elements are integers We will denote the element on the intersection of the i th row and the j th column as A i j You can perform operations on the matrix In each operation you can choose an integer k then for each index i 1 leq i leq n swap A i k with A k i Note that cell A k k remains unchanged For example for n 4 and k 3 this matrix will be transformed like this You can perform this operation any number of times Find the lexicographically smallest matrix dagger you can obtain after performing arbitrary number of operations dagger For two matrices A and B of size n times n let a i 1 cdot n j A i j and b i 1 cdot n j B i j Then the matrix A is lexicographically smaller than the matrix B when there exists an index i 1 leq i leq n 2 such that a i b i and for all indices j such that 1 leq j i a j b j ,"['#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp> //gp_hash_table\n\n#define all(a) a.begin(), a.end()\n#define pb push_back\n#define eb emplace_back\n#define sz(a) (int) a.size()\n#define bitcount(a) (int) __builtin_popcount(a)\n#define rep(i, from, to) for (int i = from; i < (to); ++i)\n#define bitat(n, a) ((n>>a)&1)\n\nusing namespace std;\n// using namespace __gnu_pbds;\n\n\ntypedef long long int ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\ntemplate <class T> int sgn(T x) { return (x > 0) - (x < 0); }\n\ntemplate <typename T>\nistream& operator>>(istream& stream, vector<T>& v) {\n    for (T& i : v) stream >> i;\n    return stream;\n}\nint caseN;\n\nstruct UF {\n\tvi e;\n\tUF(int n) : e(n, -1) {}\n\tbool sameSet(int a, int b) { return find(a) == find(b); }\n\tint size(int x) { return -e[find(x)]; }\n\tint find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\tbool join(int a, int b) {\n\t\ta = find(a), b = find(b);\n\t\tif (a == b) return false;\n\t\tif (e[a] > e[b]) swap(a, b);\n\t\te[a] += e[b]; e[b] = a;\n\t\treturn true;\n\t}\n};\n\n\nbool solve() {\n    int n;\n    cin >> n;\n\n    vector<vi> arr(n, vi(n));\n    cin >> arr;\n\n    UF dsu(2*n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (arr[i][j] < arr[j][i]) {\n                // don\'t swap\n                if (!dsu.sameSet(2*i+1, 2*j)) {\n                    dsu.join(2*i, 2*j);\n                    dsu.join(2*i+1, 2*j+1);\n                }\n                else {\n                    swap(arr[i][j], arr[j][i]);\n                }\n            }\n            else if (arr[j][i] < arr[i][j]) {\n                // do swap\n                if (!dsu.sameSet(2*i, 2*j)) {\n                    dsu.join(2*i+1, 2*j);\n                    dsu.join(2*i, 2*j+1);\n                    swap(arr[i][j], arr[j][i]);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cout << arr[i][j] << "" "";\n        }\n        cout << ""\\n"";\n    }\n\n    return false;\n}\n\n\nint main() {\n    // freopen(""input.in"", ""r"", stdin);\n    // freopen(""input.out"", ""w"", stdout);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    int t; cin >> t; for(int i = 1; i <= t; ++i) solve(); /*\n    for (caseN = 1; solve(); caseN++); /**/\n    cout.flush();\n    return 0;\n}']","[1, 0, 0, 0, 1]",2400,Let s take a look at what the lexicographically smallest matrix is Let s call a cell that is in the intersection of row and column of the matrix and the integer written on that cell is A cell of this matrix is called more significant than the another cell if and only if or and The problem asks us to find the smallest matrix so the best suitable way to solve this problem is to traverse through the most to the least significant cell of the matrix then determine if the current cell can be minimized or not Suppose the current cell we are looking at is If then its position will not change after performing the operations But if there are exactly operations that swap with another cell that is and Both of these operations swap with the same cell So the only way we can minimize the value of is to try swapping it with if and in some way As a result we have our constructive algorithm Remind that for each operation of the matrix there are states it is being performed and not being performed Suppose we have traversed to the cell If ignore it If then we try to make by deciding to swap or not to swap the cells If try to swap with by making operations and having different states And if then we should keep their positions unchanged by making operations and having the same state Note that if we do nothing Let s implement this algorithm using a simple DSU where the node represents the operation We define the value in such a way that suppose is the root of the node s component if operations and should have the same state or if operations and should have different states Define another function to union nodes and to the same component Note that and are always in the same component and Thus for the current cell we want to swap it with by calling or keep its position unchanged by calling After constructing the graphs the last thing to do is to determine which operations should be performed One way to do so is for each root of the components of the DSU we perform the operation which this root represents for Then for other nodes just check for the node and if it is true the operation should be performed When we have the list of the operations that need to be performed we can bruteforcely perform each operation from the list one by one and the final matrix will be the lexicographically smallest matrix Time complexity Solution 
You are given a huge decimal number consisting of n digits It is guaranteed that this number has no leading zeros Each digit of this number is either or You may perform several possibly zero operations with this number During each operation you are allowed to change any digit of your number you may change to or to It is possible that after some operation you can obtain a number with leading zeroes but it does not matter for this problem You are also given two integers 0 le y x n Your task is to calculate the minimum number of operations you should perform to obtain the number that has remainder 10 y modulo 10 x In other words the obtained number should have remainder 10 y when divided by 10 x ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define PII pair<int,int>\n#define PB push_back\n#define POP pop_back\n#define FI first\n#define SE second\n#define endl \'\\n\'\n#define ls x<<1\n#define rs x<<1|1\nconst int N=3e6+7,mod=1e9+7,INF=1e9;\nint n,m,x,y;\nint a[N],b[N];\nchar s[N],ss[N];\nint main()\n{\n    cin>>n>>x>>y;\n    scanf(""%s"",s);\n    int ans=0;\n    for(int i=n-x;i<n;i++){\n        if(i==n-y-1&&s[i]==\'0\')ans++;\n        else if(i!=n-y-1&&s[i]==\'1\')ans++;\n    }\n    cout<<ans;\n    return 0;\n}\n\n']","[0, 1, 1, 0, 0]",1100,As we can see last digits of the resulting number will be zeros except the th So we need to change all ones to zeros if needed among last digits if the position of the digit is not and change zero to one if needed otherwise It can be done with simple cycle 
Omkar is building a house He wants to decide how to make the floor plan for the last floor Omkar s floor starts out as n rows of m zeros 1 le n m le 100 Every row is divided into intervals such that every 0 in the row is in exactly 1 interval For every interval for every row Omkar can change exactly one of the 0s contained in that interval to a 1 Omkar defines the quality of a floor as the sum of the squares of the sums of the values in each column i e if the sum of the values in the i th column is q i then the quality of the floor is sum i 1 m q i 2 Help Omkar find the maximum quality that the floor can have ,"['#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> ii;\n#define db(x) cout<<#x<<"" = ""<<x<<""\\n"";\n#define fore(i,a,b) for(int i=a,ggdem=b;i<ggdem;i++)\n#define FIN ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define SZ(a) ((int)(a).size())\n#define ALL(a) a.begin(),a.end()\n#define mset(a,b) memset(a,b,sizeof(a));\n#define pb push_back\n#define fst first\n#define snd second\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n\nconst int N=101;\nint n,m,a[N][N],id[N][N],vis[N][N],l[N][N],r[N][N],dp[N][N];\nvector<ii>g[N*N];\nint solve(int i,int j) {\n  if(i>j)return 0;\n  if(dp[i][j]!=-1)return dp[i][j];\n  int res=0;\n  fore(col,i,j+1) {\n    int cur=0;\n    fore(row,0,n)if(i<=l[row][col] && r[row][col]<=j)cur++;\n    res=max(res,solve(i,col-1)+cur*cur+solve(col+1,j));\n  }\n  return dp[i][j]=res;\n}\nvoid debug() {\n  cout<<""done input""<<endl;\n  cout<<""id:""<<endl;fore(i,0,n){fore(j,0,m)cout<<id[i][j]<<"" "";cout<<endl;}\n  cout<<""l:""<<endl;fore(i,0,n){fore(j,0,m)cout<<l[i][j]<<"" "";cout<<endl;}\n  cout<<""r:""<<endl;fore(i,0,n){fore(j,0,m)cout<<r[i][j]<<"" "";cout<<endl;}\n  cout<<""g: ""<<endl;\n  fore(i,0,n*m) {\n    if(!(SZ(g[i])))continue;\n    cout<<i<<"" : "";for(auto it:g[i])cout<<it.fst<<"" ""<<it.snd<<endl;\n  }\n}\nmain() {FIN;\n  memset(dp,-1,sizeof(dp));\n  cin>>n>>m;\n  fore(i,0,n) {\n    int k,cur=0;cin>>k;\n    while(k--) {\n      int x,y;cin>>x>>y;\n      x=y-x+1;\n      fore(j,0,x) {\n        id[i][cur+j]=m*i+cur;\n        l[i][cur+j]=cur,r[i][cur+j]=cur+x-1;\n        g[id[i][cur+j]].pb({i,cur+j});\n      }\n      cur+=x;\n    }\n  }\n  // debug();\n  cout<<solve(0,m-1)<<""\\n"";\n}']","[1, 0, 0, 1, 0]",2900,Let be the answer for the columns from to To solve it is optimal to always fill some column within to to the max Let s call this column The transition is thus number of intervals that are fully within and and include For every loop through all possible columns to be and take the max The answer is The efficiency is There are dp states For every state you transition based on cases of and it takes to determine how much the max column contributes Proof Consider an optimal arrangement and the column with the most 1 s in that arrangement If there is an interval intersecting that column whose 1 isn t in that column then moving the 1 to that column would not decrease and possibly would increase the quality of that arrangement Thus it s optimal for the column with the most 1s to have all the possible 1s that it can have 
The guys lined up in a queue of n people starting with person number i 1 to ask Serafim the Owl about the meaning of life Unfortunately Kirill was very busy writing the legend for this problem so he arrived a little later and stood at the end of the line after the n th person Kirill is completely dissatisfied with this situation so he decided to bribe some people ahead of him For the i th person in the queue Kirill knows two values a i and b i If at the moment Kirill is standing at position i then he can choose any position j such that j i and exchange places with the person at position j In this case Kirill will have to pay him a j coins And for each k such that j k i Kirill will have to pay b k coins to the person at position k Kirill can perform this action any number of times Kirill is thrifty so he wants to spend as few coins as possible but he doesn t want to wait too long so Kirill believes he should be among the first m people in line Help Kirill determine the minimum number of coins he will have to spend in order to not wait too long ,"['#ifdef LOCAL\n#define _GLIBCXX_DEBUG\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst ll INF = LLONG_MAX, MOD = 1e9 + 7, P = 239;\nconst ld PI = 3.1415926535897938462643383279502, EPS = 1e-7;\n\ntemplate <typename T>\ninline ll sz(const T &a) {\n    return a.size();\n}\n\ntemplate <typename T, typename C>\nistream &operator >> (istream &in, pair<T, C> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <typename T, typename C>\nostream &operator << (ostream &out, pair<T, C> a) {\n    return out << a.first << \' \' << a.second;\n}\n\ntemplate <typename T>\nistream & operator >> (istream &in, vector<T> &a) {\n    for (auto &i : a) {\n        in >> i;\n    }\n    return in;\n}\n\ntemplate <typename T>\nostream &operator << (ostream &out, vector<T> a) {\n    for (auto i : a) {\n        out << i << \' \';\n    }\n    return out;\n}\n\ntemplate <typename T>\nvoid print(vector<T> a, string c = ""\\n"") {\n    for (T i : a) {\n        cout << i << c;\n    }\n}\n\nvoid solve() {\n    ll n, m;\n    cin >> n >> m;\n    vector<ll> a(n), b(n);\n    cin >> a >> b;\n    ll ans = 0;\n    for (int i = m; i < n; ++i) {\n        ans += min(a[i], b[i]);\n    }\n    ll sum2 = 0, ans2 = INF;\n    for (int i = m - 1; i >= 0; --i) {\n        ans2 = min(sum2 + a[i], ans2);\n        sum2 += b[i];\n    }\n    cout << ans + ans2;\n}\n\nsigned main() {\n#ifdef LOCAL\n    freopen(""inp.txt"", ""r"", stdin);\n    freopen(""out.txt"", ""w"", stdout);\n    freopen(""err.txt"", ""w"", stderr);\n\n    auto start_time = clock();\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int times = 1;\n    cin >> times;\n    while (times--)\n        solve(), cout << \'\\n\';\n\n#ifdef LOCAL\n    auto end_time = clock();\n    cerr << setprecision(3) << fixed << ""Execution time: "" << (end_time - start_time) * (int) 1e3 / CLOCKS_PER_SEC << "" ms\\n"";\n#endif\n    return 0;\n}\n']","[1, 0, 0, 1, 0]",1300,Let s consider a greedy approach Suppose we are standing at position Find the first such that and If such exists and then swap with This will be optimal because in any case we will have to pay the people at positions some amount of coins and in this way we will pay each person at position where coins According to the greedy condition so is the minimum amount of coins we can pay th person We will also pay the th person coins hence we will pay the minimum amount of coins to all people If such does not exist then it is advantageous for us to choose the final position such that in order to finish the movements and overpay as little as possible Simply check each recalculating the answer using prefix sums on array and choose the smallest one Asymptotics 
AquaMoon and Cirno are playing an interesting game with arrays Cirno has prepared two arrays a and b both consist of n non negative integers AquaMoon can perform the following operation an arbitrary number of times possibly zero She chooses two indices i and j 1 le i j le n then decreases the i th element of array a by 1 and increases the j th element of array a by 1 The resulting values at i th and j th index of array a are a i 1 and a j 1 respectively Each element of array a If i j this operation doesn t change the array a AquaMoon wants to make some operations to make arrays a and b equal Two arrays a and b are considered equal if and only if a i b i for all 1 leq i leq n Help AquaMoon to find a sequence of operations that will solve her problem or find that it is impossible to make arrays a and b equal Please note that you the number of operations ,"['#include <bits/stdc++.h>\n#define x first\n#define y second\n#define pb push_back\n#define all(v) v.begin(),v.end()\n#pragma gcc optimize(""O3"")\n#pragma gcc optimize(""Ofast"") \n#pragma gcc optimize(""unroll-loops"")\nusing namespace std;\nconst int INF = 1e9;\nconst int TMX = 1 << 18;\nconst long long llINF = 1e16;\nconst long long mod = 1e9+7;\nconst long long hashmod = 100003;\nconst int MAXN = 100000;\nconst int MAXM = 1000000;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int,int> pi;\ntypedef pair <ll,ll> pl;\ntypedef vector <int> vec;\ntypedef vector <pi> vecpi;\ntypedef long long ll;\nint n;\nint a[105],b[105];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int T; cin >> T;\n    while(T--) {\n        cin >> n;\n        for(int i = 1;i <= n;i++) {\n            cin >> a[i];\n        }\n        for(int i = 1;i <= n;i++) {\n            cin >> b[i];\n        }\n        vec v,v2;\n        for(int i = 1;i <= n;i++) {\n            for(int j = 1;j <= a[i]-b[i];j++) v.pb(i);\n            for(int j = 1;j <= b[i]-a[i];j++) v2.pb(i);\n        }\n        if(v.size() != v2.size()) {\n            cout << ""-1\\n"";\n            continue;\n        }\n        cout << v.size() << \'\\n\';\n        for(int i = 0;i < v.size();i++) {\n            cout << v[i] << \' \' << v2[i] << \'\\n\';\n        }\n    }\n}']","[1, 0, 0, 0, 0]",800,First if the sum of elements in is not equal to the sum of elements in then the solution does not exist Each time find a position satisfying and find such a satisfying Then let until the two arrays become the same 
Stepan is a very busy person Today he needs to send n messages at moments m 1 m 2 dots m n m i m i 1 Unfortunately by the moment 0 his phone only has f units of charge left At the moment 0 the phone is turned on The phone loses a units of charge for each unit of time it is on Also at any moment Stepan can turn off the phone and turn it on later This action consumes b units of energy each time Consider turning on and off to be instantaneous so you can turn it on at moment x and send a message at the same moment and vice versa send a message at moment x and turn off the phone at the same moment If at any point the charge level drops to 0 becomes le 0 it is impossible to send a message at that moment Since all messages are very important to Stepan he wants to know if he can send all the messages without the possibility of charging the phone ,"['#include<bits/stdc++.h>\n#define pb push_back\n#define pf push_front\n#define F first\n#define S second\n#define ff first\n#define ss second\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pll pair<ll,ll>\n#define plll pair<pll,ll>\n#define pllll pair<pll,pll>\n#define vl vector<ll>\n#define vll vector<pll>\n#define vlll vector<plll>\n#define vllll vector<pllll>\n#define vb vector<bool>\n#define sz size()\n#define fr front()\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define bk back();\nusing namespace std;\nconst ld pi=3.14159265359;\nconst ll e5=1e5;\nconst ll e6=1e6;\nconst ll e9=1e9;\nconst ll inf=1e18;\nconst ll mod=1e9+7;\nconst ll mod2=998244353;\nconst ll N=1e5+5;\nll bpm(ll x,ll y,ll m){if(y==0)return 1%m;if(y==1)return x%m;ll p=bpm(x,y/2,m);\nif(y%2==0)return p*p%m;else return p*p%m*x%m;}\nll bp(ll x,ll y){if(y==0)return 1;if(y==1)return x;ll p=bp(x,y/2);\nif(y%2==0)return p*p;else return p*p*x;}\nvoid solve(/**/){\n    ll n,f,a,b;\n    cin>>n>>f>>a>>b;\n    ll m[n+1],s=0;\n    for(ll i=1;i<=n;i++) cin>>m[i];\n    m[0]=0;\n    for(ll i=1;i<=n;i++){\n        if((m[i]-m[i-1])*a>b) s+=b;\n        else s+=(m[i]-m[i-1])*a;\n    }\n    if(s<f) cout<<""YES"";\n    else cout<<""NO"";\n    return;\n}\nint main(/*Aldk*/){\n    ios_base::sync_with_stdio(false);cin.tie(NULL);\n    //freopen("".in"", ""r"", stdin);\n    //freopen("".out"", ""w"", stdout);    \n    //cout<<setprecision(6)<<fixed;\n    ll T=1;\n    cin>>T;\n    for(ll i=1;i<=T;i++){\n        //cout<<""Case #""<<i<<"": "";\n        solve();\n        cout<<\'\\n\';\n    }\n    return 0;\n}']","[1, 1, 0, 0, 0]",900,The most challenging part of this problem was probably carefully understanding the problem statement The problem can be reduced to the following There are time intervals from 0 to from to from to For each interval we need to find a way to spend as little charge of the phone as possible and check that the total amount of charge we spend is less than the initial charge of the phone To spend the minimum amount of charge for one time interval we can act in one of two ways Let the length of the interval be We either leave the phone on and spend units of charge or turn off the phone at the very beginning of the interval and turn it on at the very end spending units of charge The total time complexity of this solution is 
Given a sequence of integers a of length n a tuple i j k is called monotone triples if 1 le i j k le n a i le a j le a k or a i ge a j ge a k is satisfied For example a 5 3 4 5 then 2 3 4 is monotone triples for sequence a while 1 3 4 is not Bob is given a sequence of integers a of length n in a math exam The exams itself contains questions of form L R for each of them he is asked to find any subsequence b of sequence a L a L 1 ldots a R Recall that an sequence b is a subsequence of sequence a if b can be obtained by deletion of several possibly zero or all elements However he hates monotone stuff and he wants to find a subsequence Besides he wants to find one subsequence with the length among all subsequences free from monotone triples for every query Please help Bob find out subsequences meeting the above constraints ,"['#include <bits/stdc++.h>\n#define p2 p << 1\n#define p3 p << 1 | 1\n\ntemplate <class T>\ninline void read(T &res)\n{\n\tres = 0; bool bo = 0; char c;\n\twhile (((c = getchar()) < \'0\' || c > \'9\') && c != \'-\');\n\tif (c == \'-\') bo = 1; else res = c - 48;\n\twhile ((c = getchar()) >= \'0\' && c <= \'9\')\n\t\tres = (res << 3) + (res << 1) + (c - 48);\n\tif (bo) res = ~res + 1;\n}\n\ntemplate <class T>\ninline T Max(const T &a, const T &b) {return a > b ? a : b;}\n\ntemplate <class T>\ninline T Min(const T &a, const T &b) {return a < b ? a : b;}\n\nconst int N = 2e5 + 5, M = N << 2, E = 20;\n\nint n, q, a[N], top, stk[N], pre0[N], pre1[N], nxt0[N], nxt1[N], pre[N], nxt[N],\nlt[N], mx[M], rmin[N][E], rmax[N][E], Log[N], ml[N], mr[N], l0[N], r0[N],\nl1[N], r1[N];\nstd::vector<int> oz[N];\n\nvoid change(int l, int r, int pos, int v, int p)\n{\n\tmx[p] = Max(mx[p], v); if (l == r) return;\n\tint mid = l + r >> 1;\n\tif (pos <= mid) change(l, mid, pos, v, p2);\n\telse change(mid + 1, r, pos, v, p3);\n}\n\nint query(int l, int r, int x, int p)\n{\n\tif (l == r) return mx[p];\n\tint mid = l + r >> 1;\n\tif (x <= mid) return query(l, mid, x, p2);\n\telse return Max(mx[p2], query(mid + 1, r, x, p3));\n}\n\nint qmin(int l, int r)\n{\n\tint k = Log[r - l + 1];\n\treturn a[rmin[l][k]] < a[rmin[r - (1 << k) + 1][k]]\n\t\t? rmin[l][k] : rmin[r - (1 << k) + 1][k];\n}\n\nint qmax(int l, int r)\n{\n\tint k = Log[r - l + 1];\n\treturn a[rmax[l][k]] > a[rmax[r - (1 << k) + 1][k]]\n\t\t? rmax[l][k] : rmax[r - (1 << k) + 1][k];\n}\n\nint main()\n{\n\tint l, r;\n\tread(n); read(q);\n\tfor (int i = 1; i <= n; i++) read(a[i]), rmin[i][0] = rmax[i][0] = i;\n\tLog[0] = -1;\n\tfor (int i = 1; i <= n; i++) Log[i] = Log[i >> 1] + 1;\n\tfor (int j = 1; j <= 17; j++)\n\t\tfor (int i = 1; i + (1 << j) - 1 <= n; i++)\n\t\t{\n\t\t\trmin[i][j] = a[rmin[i][j - 1]] < a[rmin[i + (1 << j - 1)][j - 1]]\n\t\t\t\t? rmin[i][j - 1] : rmin[i + (1 << j - 1)][j - 1];\n\t\t\trmax[i][j] = a[rmax[i][j - 1]] > a[rmax[i + (1 << j - 1)][j - 1]]\n\t\t\t\t? rmax[i][j - 1] : rmax[i + (1 << j - 1)][j - 1];\n\t\t}\n\tstk[top = 0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\twhile (top && a[stk[top]] >= a[i]) top--;\n\t\tpre0[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = 0;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\twhile (top && a[stk[top]] <= a[i]) top--;\n\t\tpre1[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = n + 1;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\twhile (top && a[stk[top]] >= a[i]) top--;\n\t\tnxt0[i] = stk[top]; stk[++top] = i;\n\t}\n\tstk[top = 0] = n + 1;\n\tfor (int i = n; i >= 1; i--)\n\t{\n\t\twhile (top && a[stk[top]] <= a[i]) top--;\n\t\tnxt1[i] = stk[top]; stk[++top] = i;\n\t}\n\tfor (int i = 1; i <= n; i++) pre[i] = std::min(pre0[i], pre1[i]),\n\t\tnxt[i] = std::max(nxt0[i], nxt1[i]), oz[pre[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt[i] <= n) change(1, n, nxt[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tml[i] = ml[i - 1]; mr[i] = mr[i - 1];\n\t\tif (lt[i] > ml[i]) ml[i] = lt[i], mr[i] = i;\n\t}\n\tmemset(mx, 0, sizeof(mx)); memset(lt, 0, sizeof(lt));\n\tfor (int i = 1; i <= n; i++) oz[i].clear();\n\tfor (int i = 1; i <= n; i++) oz[pre0[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt0[i] <= n) change(1, n, nxt0[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tl0[i] = l0[i - 1]; r0[i] = r0[i - 1];\n\t\tif (lt[i] > l0[i]) l0[i] = lt[i], r0[i] = i;\n\t}\n\tmemset(mx, 0, sizeof(mx)); memset(lt, 0, sizeof(lt));\n\tfor (int i = 1; i <= n; i++) oz[i].clear();\n\tfor (int i = 1; i <= n; i++) oz[pre1[i]].push_back(i);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (nxt1[i] <= n) change(1, n, nxt1[i], i, 1);\n\t\tfor (int j = 0; j < oz[i].size(); j++)\n\t\t\tlt[oz[i][j]] = query(1, n, oz[i][j], 1);\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tl1[i] = l1[i - 1]; r1[i] = r1[i - 1];\n\t\tif (lt[i] > l1[i]) l1[i] = lt[i], r1[i] = i;\n\t}\n\twhile (q--)\n\t{\n\t\tread(l); read(r);\n\t\tif (ml[r] >= l)\n\t\t{\n\t\t\tputs(""4""); int x = qmin(ml[r], mr[r]), y = qmax(ml[r], mr[r]);\n\t\t\tif (x > y) std::swap(x, y);\n\t\t\tprintf(""%d %d %d %d\\n"", ml[r], x, y, mr[r]);\n\t\t}\n\t\telse if (l0[r] >= l)\n\t\t\tputs(""3""), printf(""%d %d %d\\n"", l0[r], qmin(l0[r], r0[r]), r0[r]);\n\t\telse if (l1[r] >= l)\n\t\t\tputs(""3""), printf(""%d %d %d\\n"", l1[r], qmax(l1[r], r1[r]), r1[r]);\n\t\telse puts(""0"");\n\t}\n\treturn 0;\n}']","[0, 0, 0, 0, 1]",3100,We will solve this task with the following observations If an array of length has no monotone triple then one of the following is true If an array of length has no monotone triple then its subsequence has no monotone triple If an array of length 4 has no monotone triple then vice versa WLOG we assume by observation 1 we will know that since we get a monotone triple leading to contradiction Second part can be verified easily For every array of length must have monotone triple WLOG we just need to prove the observation holds when and cases when not all elements are equal In that case one of extremal can be reached in position other than WLOG we will assume that maximum is reached at position However cannot be monotone triple free leading to contradiction Combining those observations or Erdos Szekeres theorem if you know it we would like to get the following solution which runs in If the subsequence is monotone the answer should be 0 If there exists such that and fails to reach maximum and minimum among those four numbers the answer should be 4 Otherwise the answer should be 3 In the following paragraphs we will only focus on the case of Other stuffs can be dealt similarly or easily the observation is crucial to obtain a faster solution Notice that constraint is equivalent to that there exists such that fails to reach maximum and minimum among This observation allows us to solve this task in with some precalculation though it s still not enough to get accepted Let s solve the task for a sequence of a pairwise distinct numbers and then change the conditions to a general sequence Let s fix the leftmost element of and look at what we are asked to find So there should be some position to the right of so that the range of values on positions excluding the greatest and the smallest values includes both and Let s process the array from right to left maintaining two stacks The top element in both stacks is the currently processed one Next element of the first stack is the closest to the right element greater than the top one and the next element of the second stack is the closest to the right smaller than the top one And the stacks go like that until the end of array Iterating over one of these stacks will show the increase of the range of values in one direction iterating over both at the same time will show how the range of values changes in total So I claim that the sequence we are looking for exists iff both stacks include more than element and there is an element to the right of second elements of both stacks such that it is included in neither of the stacks Naturally that condition tells that there is some position in which neither maximum nor minimum values are updated The values that are in neither of stacks can be maintained in a queue or in a BIT Basically the position when the range of values doesn t change is such a value which is both smaller than the maximum value on the segment and greater than the minimum one Thus we can choose the latest elements in both stacks up to that position and that position itself How to deal with not pairwise distinct elements Well it s enough to change the conditions in stacks to the next greater or equal and the next smaller or equal However that will push the elements equal to the current one right next to it to the both stacks Previously we kinda used the fact that no element except the current one is in both stacks I think that the easiest way to deal with it is to get the answer for the rightmost of the consecutive equal elements and then just say that the answer for the rest of them is the same Finally push all these consecutive equal elements to the both stacks As for queries I previously said that we can take the position where the value range doesn t change Basically the first valid position is coincidentally the shortest length valid segment starting from So to find the first position you just need to do a binary search over that queue or BIT of the values which are in neither of the stacks We can easily remember it for each position and then do a range minimum query checking if any of the positions in have their shortest right border smaller than 
Dr Evil kidnapped Mahmoud and Ehab in the evil land because of their performance in the Evil Olympiad in Informatics EOI He decided to give them some problems to let them go Dr Evil is interested in sets He has a set of integers Dr Evil calls a set of integers if the of it is exactly the of a set of integers is the minimum non negative integer that doesn t exist in it For example the of the set is and the of the set is Dr Evil is going to make his set To do this he can perform some operations During each operation he can add some non negative integer to his set or erase some element from it What is the minimal number of operations Dr Evil has to perform to make his set ,"['#include <cstdio>\nint N, cnt[101], K, O;\nint main()\n{\n\tscanf(""%d%d"", &N, &K);\n\tfor (int i = 0, x; i < N; i++)\n\t{\n\t\tscanf(""%d"", &x);\n\t\tif (x == K)\n\t\t\tO++;\n\t\telse if (x < K)\n\t\t\tcnt[x] = 1;\n\t}\n\tfor (int i = 0; i < K; i++)\n\t\tif (!cnt[i])\n\t\t\tO++;\n\tprintf(""%d\\n"", O);\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0]",1000,One can see that in the final set all the elements less than should exist shouldn t exist and any element greater than doesn t matter so we will count the number of elements less than that don t exist in the initial set and add this to the answer If exists we ll add 1 to the answer because should be removed Time complexity Solution link me https pastebin com ALfcu8Ab Solution link mahmoudbadawy https pastebin com yXLkmA5F 
You are given a set of 2n 1 integer points on a Cartesian plane Points are numbered from 0 to 2n inclusive Let P i be the i th point The x coordinate of the point P i equals i The y coordinate of the point P i equals zero initially Thus initially P i i 0 The given points are vertices of a plot of a piecewise function The j th piece of the function is the segment P j P j 1 In one move you can increase the y coordinate of any point with odd x coordinate i e such points are P 1 P 3 dots P 2n 1 by 1 Note that the corresponding segments also change For example the following plot shows a function for n 3 i e number of points is 2 cdot3 1 7 in which we increased the y coordinate of the point P 1 three times and y coordinate of the point P 5 one time Let the area of the plot be the area below this plot and above the coordinate axis OX For example the area of the plot on the picture above is 4 the light blue area on the picture above is the area of the plot drawn on it Let the height of the plot be the maximum y coordinate among all initial points in the plot i e points P 0 P 1 dots P 2n The height of the plot on the picture above is 3 Your problem is to say which minimum possible height can have the plot consisting of 2n 1 vertices and having an area equal to k Note that it is unnecessary to minimize the number of moves It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding 10 18 ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\nLL n, k;\nvoid init(){\n  cin>>n>>k;\n}\nvoid solve(){\n  LL per=k/n;\n  if(n * per < k) per++;\n  cout<<per<<endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n']","[0, 1, 0, 0, 0]",1000,It is easy to see that the area of the plot is the sum of areas of all triangles in this plot Each move increases area by one We cannot obtain the answer less than but we always can obtain such an answer 
You are given a tree consisting of n vertices numbered from 1 to n Every vertex is colored in some color denoted by an integer from 1 to n A simple path of the tree is called if it consists of at least 2 vertices the first and the last vertices of the path have the same color no other vertex on the path has the same color as the first vertex Count the number of the simple paths of the tree Note that paths are considered undirected i e the path from x to y is the same as the path from y to x ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> c(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> c[i];\n        c[i]--;\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    std::vector<std::map<int, int>> mp(n);\n    i64 ans = 0;\n    auto dfs = [&](auto self, int x, int p) -> void {\n        for (auto y : adj[x]) {\n            if (y == p) {\n                continue;\n            }\n            self(self, y, x);\n            if (mp[y].count(c[x])) {\n                ans += mp[y][c[x]];\n                mp[y].erase(c[x]);\n            }\n            if (mp[x].size() < mp[y].size()) {\n                std::swap(mp[x], mp[y]);\n            }\n            for (auto [a, b] : mp[y]) {\n                ans += 1LL * b * mp[x][a];\n                mp[x][a] += b;\n            }\n            mp[y].clear();\n        }\n        mp[x][c[x]] += 1;\n    };\n    dfs(dfs, 0, -1);\n    std::cout << ans << ""\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[0, 0, 0, 1, 1]",2000,Let s consider what the paths passing through some vertex look like First root the tree arbitrarily Let be the children of Then for some color there are top level vertices in their subtrees Top level here means that there are no vertices of color on the path from them to If the color of is not then you can combine all top level vertices from every pair of children into paths If the color is then all top level vertices can only be paired with Moreover the top level vertices of color in subtree of is only itself now With these ideas some small to large can be implemented Store for all colors such that there exist top level vertices of this color In order to recalculate from the values of its children you can first calculate the sum of for each then replace with regardless of if it appeared in children or not So that can be done by adding all values to the values of the largest child of largest by its size of for example During this process you can calculate the number of paths as well The complexity will be for each testcase and that should pass freely There s also an idea for a faster solution Two words virtual trees Basically you can build a virtual tree of all vertices of each color Now there are vertices colored in it and some auxiliary vertices The answer for that color can be calculated with some sort of dynamic programming Similar to the first solution for each vertex store the number of top level vertices of color in its subtree All the calculations are exactly the same You can build all virtual trees in in total 
You have given an array a of length n and an integer x to a brand new robot What the robot does is the following it iterates over the elements of the array let the current element be q If q is divisible by x the robot adds x copies of the integer frac q x to the end of the array and moves on to the next element Note that the newly added elements could be processed by the robot later Otherwise if q is not divisible by x the robot shuts down Please determine the sum of all values of the array at the end of the process ,"['// Author: wlzhouzhuan\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(""Ofast"")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { if (a < b) a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - \'0\', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar(\'-\'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + \'0\');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\nconst int N=100005;\nint a[N],b[N];\nint main() {\n  int T=read();\n  while(T--){\n    int n=read(),k=read();\n    ll ans=0,lst=1e9,id=0;\n    rep(i,1,n){\n      a[i]=read();\n      int x=a[i];\n      b[i]=0;\n      while(x%k==0)x/=k,b[i]++;\n      if(b[i]<lst)lst=b[i],id=i;\n    }\n    rep(i,1,n)ans+=1ll*(lst+1)*a[i];\n    rep(i,1,id-1)ans+=1ll*a[i];\n    printf(""%lld\\n"",ans);\n  }\n  return 0;\n}']","[1, 1, 1, 0, 0]",1100,Let s represent each element as where is the maximal possible Let s take minimum over all values and let s assume it s attained at position The robot will add each element to the array times element at position will be the first one which will stop being divisible by However we should not forget about the prefix before position each of those number is divisible by a higher power of and this prefix will count towards the total sum The final answer is In this solution we divide each number by to generate the array and then it takes to compute both sums The final complexity of the solution is where denotes the maximum possible element of the array Let s maintain the list of pairs it indicates a range of elements equal to Then we can easily implement the operation performed by the robot if we consider pair we either append the array with a pair or terminate the process The answer to the problem equals to sum of values Each number will be copied to the end of the array at most times since each time is divided by Since there are elements in the array initially the total complexity of this solution is 
Nothing has changed since the last round Dima and Inna still love each other and want to be together They ve made a deal with Seryozha and now they need to make a deal with the dorm guards There are four guardposts in Dima s dorm Each post contains two guards in Russia they are usually elderly women You can bribe a guard by a chocolate bar or a box of juice For each guard you know the minimum price of the chocolate bar she can accept as a gift and the minimum price of the box of juice she can accept as a gift If a chocolate bar for some guard costs less than the minimum chocolate bar price for this guard is or if a box of juice for some guard costs less than the minimum box of juice price for this guard is then the guard doesn t accept such a gift In order to pass through a guardpost one needs to bribe both guards The shop has an unlimited amount of juice and chocolate of any price starting with Dima wants to choose some guardpost buy one gift for each guard from the guardpost and spend rubles on it Help him choose a post through which he can safely sneak Inna or otherwise say that this is impossible Mind you Inna would be very sorry to hear that ,"['#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main ()\n{\n\tint n, a, b, c, d;\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tscanf(""%d%d%d%d"", &a, &b, &c, &d);\n\t\ta = min(a, b);\n\t\tc = min(c, d);\n\t\tif (a + c <= n)\n\t\t{\n\t\t\tprintf(""%d %d %d\\n"", i + 1, a, n - a);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(""-1\\n"");\n\treturn 0;\n}\n\n']","[0, 0, 1, 0, 0]",1100,The solution doesn t exist only if the mimimal way to bribe is grater than Otherwise we can increase the gift price to make Let s find the miminal way to bribe We should buy that gift for old lady which costs less It means if we have 2 guards with params then minimum bribe price will be Let s choose the guard with the minimal bribe price If the minimal bribe price is greater than answer Otherwise the possible answer is for example Guard number 
Vasiliy is fond of solving different tasks Today he found one he wasn t able to solve himself so he asks you to help Vasiliy is given strings consisting of lowercase English letters He wants them to be sorted in lexicographical order as in the dictionary but he is not allowed to swap any of them The only operation he is allowed to do is to reverse any of them first character becomes last second becomes one before last and so on To reverse the th string Vasiliy has to spent units of energy He is interested in the minimum amount of energy he has to spent in order to have strings sorted in lexicographical order String is lexicographically smaller than string if it is shorter than and is its prefix or if none of them is a prefix of the other and at the first position where they differ character in is smaller than the character in For the purpose of this problem two equal strings nearby do not break the condition of sequence being sorted lexicographically ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << ""="" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int , int> pi;\ntypedef pair< int , pi> pii;\n\nconst int INF = ~0U >> 1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n\tint ret = 1;\n\tfor (; x; x >>= 1, a = 1ll * a * a % Mod)\n\t\tif (x & 1) ret = 1ll * ret * a % Mod;\n\treturn ret;\n}\n\nconst int N = 100000 + 10;\n\nint n, c[N];\nstring t[N], rt[N];\nll dp[N][2], answer;\nchar s[N];\n\nint main() {\n\tscanf(""%d"", &n);\n\trep(i, 1, n + 1) scanf(""%d"", c + i);\n\trep(i, 1, n + 1) {\n\t\tscanf(""%s"", s);\n\t\tt[i] = string(s);\n\t\trt[i] = t[i];\n\t\treverse(rt[i].begin(), rt[i].end());\n\t}\n\tdp[1][0] = 0;\n\tdp[1][1] = c[1];\n\trep(i, 2, n + 1) {\n\t\tdp[i][0] = dp[i][1] = 1ll << 60;\n\t\tif (t[i] >= t[i - 1]) dp[i][0] = min(dp[i][0], dp[i - 1][0]);\n\t\tif (t[i] >= rt[i - 1]) dp[i][0] = min(dp[i][0], dp[i - 1][1]);\n\t\tif (rt[i] >= t[i - 1]) dp[i][1] = min(dp[i][1], dp[i - 1][0] + c[i]);\n\t\tif (rt[i] >= rt[i - 1]) dp[i][1] = min(dp[i][1], dp[i - 1][1] + c[i]);\n\t}\n\tanswer = min(dp[n][0], dp[n][1]);\n\tif (answer > 1ll << 50) puts(""-1"");\n\telse printf(""%lld\\n"", answer);\n}']","[0, 0, 0, 1, 0]",1600,We will solve the problem with the help of dynamic programming dp i j is the minimum amount of energy that should be spent to make first i strings sorted in lexicographical order and i th of them will be reversed if j 1 and not reversed if j 0 dp i j is updated by dp i 1 0 and dp i 1 1 It remains to verify that the i th string is lexicographically greater than i 1 th if j 1 then we should check reversed i th string similar to i 1 th Then we update dp i j min dp i j dp i 1 0 c i j dp i j min dp i j dp i 1 1 j c i The answer is a minimum of dp n 0 and dp n 1 
Vadim loves decorating the Christmas tree so he got a beautiful garland as a present It consists of n light bulbs in a single row Each bulb has a number from 1 to n in arbitrary order such that all the numbers are distinct While Vadim was solving problems his home Carp removed some light bulbs from the garland Now Vadim wants to put them back on Vadim wants to put all bulb back on the garland Vadim defines of a garland to be the number of pairs of adjacent bulbs with numbers with different parity remainder of the division by 2 For example the complexity of is 2 and the complexity of is 1 No one likes complexity so Vadim wants to minimize the number of such pairs Find the way to put all bulbs back on the garland such that the complexity is as small as possible ,"['#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint w[110], n, C0, C1, D[110][110][2];\nint main() {\n\tint i, j, k, l;\n\tscanf(""%d"", &n);\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &w[i]);\n\t\tif (i % 2 == 0)C0++;\n\t\telse C1++;\n\t}\n\tfor (i = 0; i <= n; i++) {\n\t\tfor (j = 0; j <= n; j++) {\n\t\t\tD[i][j][0]=D[i][j][1] = 1e9;\n\t\t}\n\t}\n\tD[0][0][0]=D[0][0][1] = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tfor (k = 0; k < 2; k++) {\n\t\t\t\tint t = D[i - 1][j][k];\n\t\t\t\tif (w[i]) {\n\t\t\t\t\tif (w[i] % 2 == 0) {\n\t\t\t\t\t\tD[i][j + 1][0] = min(D[i][j + 1][0], t+(k!=0));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tD[i][j][1] = min(D[i][j][1], t + (k!=1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (l = 0; l < 2; l++) {\n\t\t\t\t\t\tD[i][j + 1 - l][l] = min(D[i][j + 1 - l][l], t + (k != l));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", min(D[n][C0][0], D[n][C0][1]));\n}']","[1, 0, 0, 1, 0]",1800,The problem can be solved using a greedy algorithm Notice that the only information we need is parity of numbers on bulbs So let s replace numbers by their remainders modulo Than of garland will be the number of pairs of adjacent numbers that are different Let s call such pairs as bad Divide garland into segments of removed bulbs Let s call number before segment as and number after segment as If there s no number before after the segment than the segment doesn t have left right border Notice that when filling a segment one should place the same numbers in a row if any If the segment has different borders then the optimal way is to place all zeroes near zero border and all ones near one border If the segment has the same borders and we place both numbers in the segment that there will be at least two bad pairs and we will achieve it by placing all zeroes and then all ones Similarly one could prove cases with the absence of one or two borders If the segment has both borders and they are different then this segment always will increase the complexity by If the segment has both borders and they are different then this segment will increase the complexity by or will be in case we fill segment by numbers of the same parity as its borders Otherwise it will be If the segment doesn t have at least one of borders it will increase the complexity by if all numbers have the same parity as its border if any and otherwise So in order to minimize the complexity of garland first of all we should fill segments with the same borders by the numbers of the same parity Obviously we should consider such segments in increasing length order Then we should fill segments with only one border such that complexity won t increase After that we can place the remaining numbers arbitrary but inside one segment we should place the same numbers in a row Because for all remaining segments number of bad pairs is fixed Time complexity is Also this problem could be solved using dynamic programming 
Let s call a binary string T of length m indexed from 1 to m if we can obtain a string of length 1 by performing the following two kinds of operations m 1 times in any order Select any substring of T that is equal to and then replace it with Select any substring of T that is equal to and then replace it with For example if T we can select the substring T 2T 3 and perform the first operation So we obtain T You are given a binary string S of length n indexed from 1 to n Find the number of pairs of integers l r 1 le l le r le n such that S l ldots r the substring of S from l to r is a string ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename Fun>\nstruct y_combinator {\n    const Fun fun;\n\n    explicit y_combinator(const Fun&& fun) : fun(std::forward<const Fun>(fun)) {}\n\n    template <typename... Args>\n    auto operator()(Args&&... args) const {\n        return fun(std::ref(*this), std::forward<Args>(args)...);\n    }\n};\n\nvoid solve() {\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    long long ans = n;\n    for (int i = 1; i < n; ++i) {\n        if (s[i] != s[i - 1]) {\n            ans += i;\n        }\n    }\n    cout << ans << '\\n';\n}\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int t = 1;\n    cin >> t;\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n""]","[1, 0, 0, 0, 0]",1200,We want to show that a binary string of length is if and only if or and In the case of We can never delete the last two characters because they will always remain equal So is not In the case of If we can reach our goal by one operation Otherwise assume that the last character is Now the last three characters are either or In the first case perform the operation on and in the second case perform the operation on Then the last two characters will be and we can continue this algorithm on the new string until we reach The number of substrings of length is equal to To count the number of longer substrings we can fix from index to if holds we should add to the answer complexity 
Mike is trying rock climbing but he is awful at it There are holds on the wall th hold is at height off the ground Besides let the sequence increase that is for all from 1 to we will call such sequence a Mike thinks that the track has In other words difficulty equals the maximum distance between two holds that are adjacent in height Today Mike decided to cover the track with holds hanging on heights To make the problem harder Mike decided to remove one hold that is remove one element of the sequence for example if we take the sequence and remove the third element from it we obtain the sequence However as Mike is awful at climbing he wants the final difficulty i e the maximum difference of heights between adjacent holds after removing the hold to be as small as possible among all possible options of removing a hold The first and last holds stay at their positions Help Mike determine the minimum difficulty of the track after removing one hold ,"['#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<fstream>\n#include<sstream>\n#include<iomanip>\n\n\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    while (1)\n    {\n        a = a % b;\n        if (a == 0)\n            return b;\n        b = b % a;\n\n        if (b == 0)\n            return a;\n    }\n}\n\nconst int inf = 1e9;\ntypedef long long ll;\nint dis[2000];\n\nint main()\n{\n    //freopen(""in.txt"", ""r"", stdin);\n    //freopen(""a.txt"", ""w"", stdout);\n    int n, t, t1, mx = 0;\n    cin >> n;\n    memset(dis, 0, sizeof dis);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> t;\n        if (i>0)    dis[i] = t - t1;\n        if (dis[i] > mx)mx = dis[i];\n        t1 = t;\n    }\n    int mx2 = inf,lo;\n    for (int i = 1; i < n-1; i++)\n    {\n        if (dis[i] + dis[i + 1] < mx2)\n        {\n            mx2 = dis[i] + dis[i + 1];\n            lo = i;\n        }\n    }\n    if (mx2 < mx)cout << mx << endl;\n    else cout << mx2 << endl;\n    //system(""pause"");\n    return 0;\n}']","[0, 1, 1, 0, 0]",900,For every option of removing an element we run through the remaining elements and find the maximal difference between adjacent ones print the smallest found answer The solution has complexity It can be noticed that after removing an element the difficulty either stays the same or becomes equal to the difference between the neighbours of the removed element whatever is larger thus the difficulty for every option of removing an element can be found in for the total complexity of Any of these solutions or even less efficient ones could pass the tests Challenge suppose we now have to remove exactly arbitrary elements but the first and the last elements have to stay in their places How small the maximal difference between adjacent elements can become Solve this problem assuming the limitations are as follows 
Natasha is planning an expedition to Mars for n people One of the important tasks is to provide food for each participant The warehouse has m daily food packages Each package has some food type a i Each participant must eat exactly one food package each day Due to extreme loads each participant must eat the same food type throughout the expedition Different participants may eat different or the same types of food Formally for each participant j Natasha should select his food type b j and each day j th participant will eat one food package of type b j The values b j for different participants may be different What is the maximum possible number of days the expedition can last following the requirements above ,"['#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint cnt[105];\n\nint main() {\n  int n,m;\n  scanf(""%d%d"",&m,&n);\n  for(int i=1;i<=n;i++) {\n  \tint x;\n  \tscanf(""%d"",&x);\n  \tcnt[x]++;\n  }\n  int ans=0;\n  for(int i=n;i>0;i--) {\n  \tint s=0;\n  \tfor(int j=1;j<=100;j++) s+=cnt[j]/i;\n  \tif (s>=m) {\n  \t\tans=i;\n  \t\tbreak;\n\t  }\n  }\n  printf(""%d\\n"",ans);\n  return 0;\n}']","[0, 0, 1, 0, 0]",1200,Let c i be the number of food packages that equal to i Calculate the array c For any d we can calculate the maximum number of people k who can participate in the expedition for d days To do this we ll go over all the elements of the array c Let now be considered c i If c i ge d we can decrease c i by d and increase k by 1 that is take d daily food packages for one person If still c i ge d repeat the algorithm and so on That is for i th iteration number k increases by left lfloor dfrac c i d right rfloor After all the iterations the number k will be the required number of people It is clear that the answer does not exceed m every day at least one food package is used Let s iterate d from m to 1 each time checking whether the answer can be equal d To do this we calculate the maximum number of people k who can participate in the expedition for d days If k ge n then the answer is d If no answer was received on any iteration then the answer is 0 Complexity O m 2 Bonus Try to improve the complexity to O m log m 
Today Sonya learned about long integers and invited all her friends to share the fun Sonya has an initially empty multiset with integers Friends give her queries each of one of the following type add non negative integer to the multiset Note that she has a multiset thus there may be many occurrences of the same integer delete a single occurrence of non negative integer from the multiset It s guaranteed that there is at least one in the multiset count the number of integers in the multiset with repetitions that match some pattern consisting of and In the pattern stands for the even digits while stands for the odd Integer matches the pattern if the parity of the th from the right digit in decimal notation matches the th from the right digit of the pattern If the pattern is shorter than this integer it s supplemented with s from the left Similarly if the integer is shorter than the pattern its decimal notation is supplemented with the s from the left For example if the pattern is than integers and match the pattern while integers and do not ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, M, ap[(1 << 19) + 2];\nchar sir[30];\n\nint main ()\n{\n//freopen (""input"", ""r"", stdin);\n//freopen (""output"", ""w"", stdout);\n\nscanf (""%d\\n"", &M);\nwhile (M --)\n{\n    char type;\n    scanf (""%c "", &type);\n    if (type == \'+\' || type == \'-\')\n    {\n        long long x;\n        scanf (""%I64d\\n"", &x);\n        long long msk = 0;\n        for (int i=18; i>=0; i--)\n        {\n            int dig = x % 10;\n            if (dig & 1) msk |= 1 << i;\n            x /= 10;\n        }\n        if (type == \'+\') ap[msk] ++;\n        else ap[msk] --;\n        continue;\n    }\n    gets (sir + 1), N = strlen (sir + 1);\n    int j = N, msk = 0;\n    for (int i=18; i>=0; i--)\n    {\n        bool curr = 0;\n        if (j >= 1) curr = sir[j] - \'0\', j --;\n        if (curr) msk |= 1 << i;\n    }\n    printf (""%d\\n"", ap[msk]);\n}\n\nreturn 0;\n}\n']","[0, 0, 1, 0, 1]",1400,Lets exchange every digit by value of digit modulo and receive binary string We will convert it to binary form in number array for counts If we have query we increase If we have query we decrease Otherwise we output 
You are given two integers n and k For an array of length n let s define its as the maximum number of contiguous subarrays of this array that can be chosen so that each element belongs to at most one subarray the length of each subarray is exactly k each subarray contains each integer from 1 to k exactly once For example if n 10 k 3 and the array is 1 2 1 3 2 3 2 3 1 3 its cost is 2 because for example we can choose the subarrays from the 2 nd element to the 4 th element and from the 7 th element to the 9 th element and we can show that it s impossible to choose more than 2 subarrays Calculate the sum of costs over all arrays of length n consisting of integers from 1 to k and print it modulo 998244353 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=4007;\nconst ll mod=998244353;\n\nint n, k;\n\nll dp[nax][nax];\n\nll wyn;\n\nll pot[nax];\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tpot[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tpot[i]=pot[i-1]*k%mod;\n\tdp[0][0]=1;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tll s=0;\n\t\tfor (int j=k-1; j>=0; j--)\n\t\t{\n\t\t\t//~ if (!dp[i][j])\n\t\t\t\t//~ continue;\n\t\t\tif (!j)\n\t\t\t{\n\t\t\t\tdod(dp[i+1][1], dp[i][j]*k);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdod(s, dp[i][j]);\n\t\t\t\tdod(dp[i+1][j], s);\n\t\t\t\tif (j+1<k)\n\t\t\t\t{\n\t\t\t\t\tdod(dp[i+1][j+1], dp[i][j]*(k-j));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdod(dp[i+1][0], dp[i][j]);\n\t\t\t\t\tdod(wyn, dp[i][j]*pot[n-i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","[0, 1, 1, 1, 0]",2300,Let s try to solve another problem first we are given an array and a value of we need to compute its cost How can we do it We can solve it greedily find the leftmost subarray of length that contains all values from to and doesn t intersect with previously added subarrays add it to the answer rinse and repeat How do we search for the subarray with distinct values Let s go through the array from left to right and maintain the i e the longest suffix that consists of pairwise distinct elements When this number of elements reaches we add to the cost of the array and drop the number of pairwise distinct elements on suffix to because we can t reuse them When we meet an element that already belongs to the longest suffix we maintain we need to shorten this suffix it should start right after the last occurrence of that element Okay Now back to the original problem Let s try to design a dynamic programming solution that will use the number of last distinct elements we can use as one of the states For example it could be something like this how many arrays of length exist such that the number of elements on the suffix we can use is and the current cost of the array is The transitions can be done as follows When we transition from to we need to consider two cases the new element does not appear among the last elements The number of ways to choose it is and we transition either to or to the latter transition is used when since we increase the cost by and cannot reuse the elements the new element appears among the last elements Let s iterate which of them is that element let it be the th element from the back then the current number of elements we can use becomes and we transition to However this is since the number of states is the second state is up to the third state is up to Let s optimize it to The transitions that actually make our solution slow are the transitions of the second type Let s look at them in detail From there are transitions of the second type to every state such that and in every such transition the new element is chosen uniquely so they have the same coefficient equal to This means that we can compute all of those transitions efficiently using partial sums the difference between the value of and the value of is just So all transitions of the second type can be handled in and there are only transitions of the first type This is enough to solve the problem but I want to add one final touch that allows to implement the solution much easier We can use Contribution To The Sum technique let s rewrite our dynamic programming without the third state and every time we try to increase the second state to instead of increasing the third state we calculate how many arrays have this subarray contributing to the cost This is just the current value of dynamic programming multiplied by the number of ways we can choose the remaining elements which is That way the implementation becomes much simpler and the complexity of the solution is now 
You have two integers l and r Find an integer x which satisfies the conditions below l le x le r All digits of x are different If there are multiple answers print any of them ,"['#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint main() {\n#ifdef LBT\n  freopen(""test.in"", ""r"", stdin);\n  int nol_cl = clock();\n#endif\n\n  int l, r;\n  scanf(""%d%d"", &l, &r);\n  for (int i = l; i <= r; ++i) {\n    static bool m[10];\n    memset(m, 0, sizeof(m));\n    int x = i;\n    bool flag = false;\n    while (x) {\n      if (m[x % 10]) {\n        flag = true;\n        break;\n      }\n      m[x % 10] = true;\n      x /= 10;\n    }\n    if (!flag) {\n      printf(""%d\\n"", i);\n      return 0;\n    }\n  }\n  puts(""-1"");\n\n#ifdef LBT\n  LOG(""Time: %dms\\n"", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n']","[0, 0, 1, 0, 0]",800,Let s see how to check if all digits of are different Since there can be only different numbers to in single digit you can count the occurrences of numbers by looking all digits of You can count all digits by using modulo or changing whole number to string For example if then occurrence of each number will be because there are two s single and single in So is invalid number Now do the same thing for all where If you find any valid number then print it Otherwise print Time complexity is 
Alice has an integer sequence a of length n and She will choose a subsequence of a of length m and defines the value of a subsequence a b 1 a b 2 ldots a b m as sum i 1 m m cdot a b i sum i 1 m sum j 1 m f min b i b j max b i b j where f i j denotes min a i a i 1 ldots a j Alice wants you to help her to maximize the value of the subsequence she choose A sequence s is a subsequence of a sequence t if s can be obtained from t by deletion of several possibly zero or all elements ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst LL INF = 0x3f3f3f3f3f3f3f3f;\n\nint n, m, a[4005], cnt;\nLL dp[4005][4005];\n\nint solve(int l, int r, int id)\n{\n\tint mid = l;\n\tfor(int i = l + 1; i <= r; i ++) if(a[i] < a[mid]) mid = i;\n\tint siz;\n\tif(l == r) {\n\t\tsiz = 0;\n\t\tdp[id][0] = 0;\n\t} else if(mid == l) {\n\t\tint tmp = cnt;\n\t\tsiz = solve(mid + 1, r, cnt ++) ;\n\t\tfor(int i = 0; i <= cnt; i ++) dp[id][i] = dp[tmp][i];\n\t} else if(mid == r) {\n\t\tint tmp = cnt;\n\t\tsiz = solve(l, mid - 1, cnt ++) ;\n\t\tfor(int i = 0; i <= cnt; i ++) dp[id][i] = dp[tmp][i];\n\t} else {\n\t\tint tl = cnt;\n\t\tint ls = solve(l, mid - 1, cnt ++);\n\t\tint tr = cnt;\n\t\tint rs = solve(mid + 1, r, cnt ++);\n\t\tsiz = ls + rs;\n\t\tfor(int i = 0; i <= siz; i ++) dp[id][i] = -INF;\n\t\tfor(int i = 0; i <= ls; i ++) for(int j = 0; j <= rs; j ++)\n\t\tdp[id][i + j] = max(dp[id][i + j], dp[tl][i] + dp[tr][j] - 2LL * i * j * a[mid]);\n\t}\n\t\n\tsiz ++; dp[id][siz] = -INF;\n\tfor(int i = siz; i >= 1; i --) dp[id][i] = max(dp[id][i], dp[id][i - 1] + 1LL * (m + 1 - 2 * i) * a[mid]);\n\treturn siz;\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\trep(i, n) scanf(""%d"", &a[i]);\n\t\n\tcnt = 1;\n\tsolve(0, n - 1, 0);\n\tprintf(""%lld\\n"", dp[0][m]);\n\treturn 0;\n}']","[1, 0, 0, 1, 0]",2900,First we can change the way we calculate the value of a subsequence We can easily see the value of a subsequence is also which is very similar to the distance of two node on a tree Thus we can build the cartesian tree of the sequence and set the weight of a edge between node and as Then we can see what we are going to calculate turns into follows choosing nodes maximize the total distance between every two nodes Thus we can solve this task using dynamic programming with the time complexity 
You are given a forest an undirected graph with n vertices such that each its connected component is a tree The diameter aka longest shortest path of a connected undirected graph is the maximum number of edges in the path between any pair of its vertices You task is to add some edges possibly zero to the graph so that it becomes a tree and the diameter of the tree is minimal possible If there are multiple correct answers print any of them ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long   ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<pii > vpi;\n\n#define F first\n#define S second\n#define PB push_back\n#define MP make_pair\n#define INF 0x3f3f3f3f\n#define INFLL 0x3f3f3f3f3f3f3f3f\n#define all(x) x.begin(),x.end()\n#define MOD 1000000007LL\n#define endl \'\\n\'\n#define mdc(a, b) (__gcd((a), (b)))\n#define mmc(a, b) (((a)*(b))/__gcd((a), (b)))\n#define MAXN 110\n\nint n, m;\nbool processado[1010];\nvector<int> adj[1010];\nset<int> componentes[1010];\nint grau[1010];\nint c = 0;\n\nvoid dfs_c(int v, int p){\n\tif(processado[v])\n\t\treturn;\n\t\n\tprocessado[v] = true;\n\tcomponentes[c].insert(v);\n\t\n\tfor(int u: adj[v]){\n\t\tif(u == p)\n\t\t\tcontinue;\n\t\t\t\n\t\tdfs_c(u, v);\n\t}\n}\n\nint dist_ult, ult;\n\nvoid dfs_d(int v, int p, int d){\t\n\tif(d > dist_ult){\n\t\tult = v;\n\t\tdist_ult = d;\t\n\t}\n\t\n\tfor(int u: adj[v]){\n\t\tif(u == p)\n\t\t\tcontinue;\n\t\t\t\n\t\tdfs_d(u, v, d+1);\n\t}\n}\nint central;\nint max_d;\n\nint main(){\n\tcin.tie(0);\n\tcin.sync_with_stdio(0);\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i=0; i<m; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\n\t\t\n\t\tgrau[x]++;\n\t\tgrau[y]++;\n\t}\n\t\n\tfor(int i=1; i<=n; i++){\n\t\tif(!processado[i]){\n\t\t\tdfs_c(i, 0);\n\n\t\t\tult = 0;\n\t\t\tdist_ult = 0;\n\t\t\t\n\t\t\tdfs_d(i, 0, 0);\n\t\t\tdfs_d(ult,0, 0);\n\n\t\t\tif(dist_ult > max_d){\n\t\t\t\tcentral = c;\n\t\t\t\tmax_d = dist_ult;\n\t\t\t}\t\t\t\t\t\t\n\t\t\t\n\t\t\tc++;\n\t\t}\n\t}\n\t\n\tfor(int ic=0; ic<c; ic++){\n\t\tqueue<int> fila;\n\t\t\n\t\tfor(int v: componentes[ic]){\n\t\t\tif(grau[v] == 1)\n\t\t\t\tfila.push(v);\n\t\t}\n\t\t\n\t\twhile(componentes[ic].size() > 2u){\n\t\t\tint qtd = fila.size();\n\t\t\t\n\t\t\tfor(int i=0; i<qtd; i++){\n\t\t\t\tint f = fila.front();\n\t\t\t\tfila.pop();\n\t\t\t\t\n\t\t\t\tfor(int u: adj[f]){\n\t\t\t\t\tif(grau[u] > 0){\n\t\t\t\t\t\tgrau[u]--;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(grau[u] == 1)\t\t\t\t\t\n\t\t\t\t\t\tfila.push(u);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcomponentes[ic].erase(f);\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int ic=0; ic < c; ic++){\n\t\tif(ic == central)\n\t\t\tcontinue;\n\t\t\t\n\t\tint x = *(componentes[central].begin());\n\t\tint y = *(componentes[ic].begin());\n\t\t\n\t\tadj[x].push_back(y);\n\t\tadj[y].push_back(x);\t\t\n\t}\t\t\n\t\n\tult = 0;\n\tdist_ult = 0;\n\t\n\tdfs_d(1, 0, 0);\n\tdfs_d(ult,0, 0);\n\t\n\tcout << dist_ult << endl;\n\t\n\tfor(int ic=0; ic < c; ic++){\n\t\tif(ic == central)\n\t\t\tcontinue;\n\t\t\t\n\t\tint x = *(componentes[central].begin());\n\t\tint y = *(componentes[ic].begin());\n\t\t\n\t\tcout << x << "" "" << y << endl;\n\t}\t\t\n\t\n\t\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",2000,Let s start with the solution and then proceed to the proof For each tree in a forest find such a vertex that the maximal distance from it to any vertex is minimal possible a center of a tree Tree may include two centers take any of them in that case Find the the tree with the maximum diameter Connect the centers of other trees with its center Overall complexity is the complexity of looking for a diameter or The center is the best vertex in a tree to connect to The diameter of merging two trees and by in and in with being the maximum shortest path from to any other vertex in being the same for in is Thus minimizing both and will produce the best result The most optimal structure is a star The center tree will be connected directly to any other tree The other trees will be connected through a single vertex among each other which leads to the answer no more than 1 worse than connecting them directly And building the answer the other way will exceed this difference as some tree will be connected to the center tree of the star through one vertex as well The previous fact implies that the center tree of the star should have the maximal diameter among all trees 
Vanya has a table consisting of rows each row contains cells The rows are numbered by integers from to from bottom to top the columns are numbered from to from left to right In this table Vanya chose rectangles with sides that go along borders of squares some rectangles probably occur multiple times After that for each cell of the table he counted the number of rectangles it belongs to and wrote this number into it Now he wants to find the sum of values in all cells of the table and as the table is too large he asks you to help him find the result ,"['#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nvoid setup(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cout.precision(15);\n}\n\nint N, T;\nint X1, Y1, X2, Y2;\n\nint main(){\n    setup();\n    cin >> N;\n    for(int i=0; i<N; i++){\n        cin >> X1 >> Y1 >> X2 >> Y2;\n        T += (abs(X2 - X1) + 1) * (abs(Y2 - Y1) + 1);\n    }\n\n    cout << T << endl;\n}\n']","[0, 1, 1, 0, 0]",1000,In this problem we can get AC with many solutions 1 With every new rectangle we will add his area to the result so for each line we will add to answer Time complexity 2 We can just do all that is written in the statement create an array and with each new rectangle we can just increment every element inside rectangle In the end we can just add all elements inside this array Time complexity C code Wild Hamster Java code Wild Hamster Python code Zlobober 
An is a string yes in the real world accordions are musical instruments but let s forget about it for a while which can be represented as a concatenation of an opening bracket ASCII code 091 a colon ASCII code 058 some possibly zero vertical line characters ASCII code 124 another colon and a closing bracket ASCII code 093 The length of the accordion is the number of characters in it For example and are accordions having length 4 6 and 7 are not accordions You are given a string s You want to transform it into an accordion by removing some possibly zero characters from it Note that you may not insert new characters or reorder existing ones Is it possible to obtain an accordion by removing characters from s and if so what is the maximum possible length of the result ,"['#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXLEN=500000;\n\nchar s[MAXLEN+1]; int slen;\n\nint solve() {\n\tint l=0; while(l<slen&&s[l]!=\'[\') ++l; while(l<slen&&s[l]!=\':\') ++l; if(l>=slen) return -1;\n\tint r=slen-1; while(r>=0&&s[r]!=\']\') --r; while(r>=0&&s[r]!=\':\') --r; if(l>=r) return -1;\n\tint ret=4; FORE(i,l+1,r-1) if(s[i]==\'|\') ++ret; return ret;\n}\n\nvoid run() {\n\tscanf(""%s"",s); slen=strlen(s);\n\tprintf(""%d\\n"",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}']","[1, 0, 1, 0, 0]",1300,No cases No any special thoughts Just greedy The solution consists of six steps Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Reverse the string Remove the prefix of the string until the position of leftmost character If there is no such character print Remove the prefix of the string until the position of leftmost character If there is no such character print Print the number of characters in the remaining string plus four 
In 2013 the writers of Berland State University should prepare problems for Olympiads We will assume that the Olympiads are numbered with consecutive integers from 1 to For each Olympiad we know how many members of the jury must be involved in its preparation as well as the time required to prepare the problems for her Namely the Olympiad number should be prepared by people for days the preparation for the Olympiad should be a continuous period of time and end exactly one day before the Olympiad On the day of the Olympiad the juries who have prepared it already do not work on it For example if the Olympiad is held on December 9th and the preparation takes 7 people and 6 days all seven members of the jury will work on the problems of the Olympiad from December 3rd to December 8th the jury members won t be working on the problems of this Olympiad on December 9th that is some of them can start preparing problems for some other Olympiad And if the Olympiad is held on November 3rd and requires 5 days of training the members of the jury will work from October 29th to November 2nd In order not to overload the jury the following rule was introduced one member of the jury can not work on the same day on the tasks for different Olympiads Write a program that determines what the minimum number of people must be part of the jury so that all Olympiads could be prepared in time ,"['#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[1000];\nint mon[13];\nconst int dt = 366;\nint main()\n{\n\tint n;\n\tfreopen( ""input.txt"", ""r"", stdin);\n\tfreopen( ""output.txt"", ""w"", stdout);\n\tmon[0] = 0;\n\tmon[1] = 31;\n\tmon[2] = 31 + 28;\n\tmon[3] = mon[2] + 31;\n\tmon[4] = mon[3] + 30;\n\tmon[5] = mon[4] + 31;\n\tmon[6] = mon[5] + 30;\n\tmon[7] = mon[6] + 31;\n\tmon[8] = mon[7] + 31;\n\tmon[9] = mon[8] + 30;\n\tmon[10] = mon[9] + 31;\n\tmon[11] = mon[10] + 30;\n\tmon[12] = mon[11] + 31;\n\tscanf( ""%d"", &n );\n\tfor ( int i = 0; i < n; i++ )\n\t{\n\t\tint m,d,r,t,l;\n\t\tscanf( ""%d%d%d%d"", &m, &d, &r, &t );\n\t\t\tl = mon[m - 1] + d - t;\n\t\t\tfor ( int j = 0; j < t; j++ )\n\t\t\t{\n\t\t\t\ta[l+dt+j]+=r;\n//\t\t\t\tprintf( ""%d\\n"", l+dt+j );\n\t\t\t}\n\t}\n\tint m = 0;\n\tfor ( int i = 0; i < 800; i++ )\n\tif ( a[i] > m ) m = a[i];\n\tprintf( ""%d\\n"", m );\n\treturn 0;\n}']","[0, 0, 1, 0, 0]",1500,One of the possible solutions is for each Olympiad find the period of the preparation This can be done by iterating the days back from the day of the Olympiad For each day of the preparation add to the number of distinct jury members that have to work on problems on day Then the answer is maximum calculated sum over all days Be careful with the year 2012 
You are given two strings s and t In a single move you can choose any of two strings and delete the first that is the leftmost character After a move the length of the string decreases by 1 You can t choose a string if it is empty For example by applying a move to the string the result is the string by applying a move to the string the result is an empty string You are required to make two given strings equal using the fewest number of moves It is possible that in the end both strings will be equal to the empty string and so are equal to each other In this case the answer is obviously the sum of the lengths of the initial strings Write a program that finds the minimum number of moves to make two given strings s and t equal ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <long long, long long> pll;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n\n#define endl ""\\n""\n#define ft first\n#define sd second\n#define openfiles ifstream cin (""input.txt""); ofstream cout (""output.txt"");\n#define INF 2000000000\n#define INFLL 2000000000000000000\n#define pii pair<int, int>\n#define pb push_back\n#define in insert\n#define faster ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\n#define EPS 0.0000000000001\n#define kolvobit 22\n//#define KlishkevichVadimka\n\n    int n, m, old;\n    vector<int> A;\n\nint main()\n{\n#ifndef KlishkevichVadimka\n    faster\n#else\n    openfiles\n#endif\n\n    string s1, s2;\n    cin >> s1 >> s2;\n    int i;\n    for (i = 0; i < min(s1.size(), s2.size());) {\n        if (s1[s1.size()-1-i] != s2[s2.size()-1-i]) {\n            break;\n        }\n        i++;\n    }\n\n    cout << s1.size()+s2.size()-2*i;\n\n\n}\n\n\n\n\n\n\n\n\n\n']","[0, 0, 1, 0, 0]",900,Let s find the value the length of the longest common suffix of and You can easily find it in one linear loop just compare the last letters of and If they are equal then compare before the last letters of and And so on The last letters of and are two equal strings which will be the result of after optimal moves So the answer is 
Roger Waters has a square grid of size n times n and he wants to traverse his grid from the upper left 1 1 corner to the lower right corner n n Waters can move from a square to any other square adjacent by a side as long as he is still in the grid Also except for the cells 1 1 and n n every cell has a value 0 or 1 in it Before starting his traversal he will pick either a 0 or a 1 and will be able to only go to cells values in which are equal to the digit he chose The starting and finishing cells 1 1 and n n are exempt from this rule he may go through them regardless of picked digit Because of this the cell 1 1 takes value the letter and the cell n n takes value the letter For example in the first example test case he can go from 1 1 to n n by using the zeroes on this path 1 1 2 1 2 2 2 3 3 3 3 4 4 4 The rest of the band Pink Floyd wants Waters to not be able to do his traversal so while he is not looking they will in the grid from 0 to 1 or vice versa They are afraid they will not be quick enough and asked for your help in choosing the cells We can show that there always exists a solution for the given constraints Also note that Waters will pick his digit of the traversal after the band has changed his grid so he must not be able to reach n n no matter what digit he picks ,"['#include<bits/stdc++.h>\n\nusing namespace std;\nchar s[505][505];\nint main(){\n\tint t, n;\n\tfor(cin >> t; t--;) {\n\t\tcin >> n;\n\t\tfor(int i = 0; i < n ; i ++) cin >> s[i];\n\t\tif(s[0][1] == s[1][0]) {\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tif(s[0][1] != s[n - 1][n - 2]) {\n\t\t\t\t\tcout << 0 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << 2 << endl;\n\t\t\t\t\tcout << ""1 2"" << endl;\n\t\t\t\t\tcout << ""2 1"" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == s[0][1]) {\n\t\t\t\t\tcout << n << \' \' << n - 1 << endl;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << n - 1<< \' \' << n << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(s[n - 1][n - 2] == s[n - 2][n - 1]){\n\t\t\t\tcout << 1 << endl;\n\t\t\t\tif(s[0][1] == s[n - 1][n - 2]) {\n\t\t\t\t\tcout << ""1 2"" << endl;\n\t\t\t\t}\n\t\t\t\telse cout << ""2 1"" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << 2 << endl;\n\t\t\t\tif(s[n - 1][n - 2] == \'1\') cout << n << \' \' << n - 1 << endl;\n\t\t\t\telse cout << n - 1 << "" "" << n << endl;\n\t\t\t\tif(s[0][1] == \'0\') cout << ""1 2"" << endl;\n\t\t\t\telse cout << ""2 1"" << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n']","[0, 0, 1, 0, 0]",1100,SolutionIf we pick the neighbours of to be we can make the neighbours of and there would be no way to go from to But this requires in the worst case switches which is not good enough Luckily in order to get down to switches we only have to consider the other way around making the squares neighboring become and the squares neighboring There must be a solution of the two with at most two switches and you won t get from to since you re forced to pick or and can t get past the neighbours of which are opposite 
Let p 1 ldots p n be a permutation of 1 ldots n Let the q subsequence of p be a permutation of 1 q whose elements are in the same relative order as in p 1 ldots p n That is we extract all elements not exceeding q together from p in the original order and they make the q subsequence of p For a given array a let pre i be the largest value satisfying pre i i and a pre i a i If it does not exist let pre i 10 100 Let nxt i be the smallest value satisfying nxt i i and a nxt i a i If it does not exist let nxt i 10 100 For each q such that 1 leq q leq n let a 1 ldots a q be the q subsequence of p For each i such that 1 leq i leq q pre i and nxt i will be calculated as defined Then you will be given some integer values of x and for each of them you have to calculate sum limits i 1 q min nxt i pre i x ,"['//Author: Kevin#include<bits/stdc++.h>#pragma GCC optimize(3)#pragma GCC target(""sse3"",""sse2"",""sse"")#pragma GCC target(""avx"",""sse4"",""sse4.1"",""sse4.2"",""ssse3"")using namespace std;#define ll long long#define ull unsigned ll#define pb emplace_back#define mp make_pair#define ALL(x) (x).begin(),(x).end()#define rALL(x) (x).rbegin(),(x).rend()#define srt(x) sort(ALL(x))#define rev(x) reverse(ALL(x))#define rsrt(x) sort(rALL(x))#define sz(x) (int)(x.size())#define inf 0x3f3f3f3f#define pii pair<int,int>#define lb(v,x) (int)(lower_bound(ALL(v),x)-v.begin())#define ub(v,x) (int)(upper_bound(ALL(v),x)-v.begin())#define uni(v) v.resize(unique(ALL(v))-v.begin())#define longer __int128_tvoid die(string S){puts(S.c_str());exit(0);}const int B=400;int p[300300],pos[300300],n;vector<int> vq[300300];vector<ll> vans[300300];int nxt[300300];vector<ll> vec[300300],psum[300300],vec2[300300],psum2[300300];int cur;int cnt[300300],cnt2[300300],tag[300300],tag2[300300];int mx[300300],mx2[300300];inline int get_ind(int x){return cnt[x/B]+cnt2[x];}void calc(){\tmemset(cnt,0,sizeof(int)*(n+10));\tmemset(cnt2,0,sizeof(int)*(n+10));\tmemset(tag,0,sizeof(int)*(n+10));\tmemset(nxt,inf,sizeof(int)*(n+10));\tmemset(tag2,0,sizeof(int)*(n+10));\tmemset(mx,-inf,sizeof(int)*(n+10));\tmemset(mx2,-inf,sizeof(int)*(n+10));\tfor(int i=0;i<=n/B;i++)\t{\t\tvec[i].clear();\t\tvec2[i].clear();\t\tpsum2[i]={0};\t\tpsum[i]={0};\t}\tfor(cur=1;cur<=n;cur++)\t{\t\tint po=pos[cur];\t\tint b=po/B;\t\tfor(int i=b+1;i<=n/B;i++)\t\t{\t\t\tcnt[i]++;\t\t\ttag[i]++;\t\t}\t\tfor(int i=po+1;i/B==b&&i<=n;i++)\t\t\tcnt2[i]++;\t\tint L=max(1,b*B),R=min(n,b*B+B-1);\t\tint ind=get_ind(po);\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<cur)\t\t\t\tif(nxt[j]==mx[b])\t\t\t\t\tnxt[j]+=tag2[b];\t\ttag2[b]=0;\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<cur)\t\t\t\tnxt[j]+=tag[b];\t\ttag[b]=0;\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<cur)\t\t\t{\t\t\t\tif(j>po)\t\t\t\t\tnxt[j]++;\t\t\t\telse\t\t\t\t\tnxt[j]=min(nxt[j],ind);\t\t\t}\t\tmx[b]=-inf;\t\tfor(int j=L;j<=R;j++)\t\t\tif(p[j]<=cur)\t\t\t\tmx[b]=max(mx[b],nxt[j]);\t\tmx2[b]=-inf;\t\tfor(register int j=L;j<=R;j++)\t\t\tif(p[j]<=cur)\t\t\t\tif(nxt[j]<mx[b])\t\t\t\t\tmx2[b]=max(mx2[b],nxt[j]);\t\tvec[b].clear();\t\tfor(register int j=L;j<=R;j++)\t\t\tif(p[j]<=cur&&nxt[j]<mx[b])\t\t\t\tvec[b].pb(nxt[j]-get_ind(j));\t\tvec2[b].clear();\t\tfor(register int j=L;j<=R;j++)\t\t\tif(p[j]<=cur&&nxt[j]==mx[b])\t\t\t\tvec2[b].pb(nxt[j]-get_ind(j));\t\tsrt(vec[b]);\t\tpsum[b].clear();\t\tpsum[b].pb(0);\t\tfor(auto x:vec[b])\t\t\tpsum[b].pb(psum[b].back()+x);\t\tsrt(vec2[b]);\t\tpsum2[b].clear();\t\tpsum2[b].pb(0);\t\tfor(auto x:vec2[b])\t\t\tpsum2[b].pb(psum2[b].back()+x);\t\tfor(int j=0;j<b;j++) if(tag[j]+mx[j]+tag2[j]>ind)\t\t{\t\t\tif(tag[j]+mx2[j]<ind)\t\t\t{\t\t\t\ttag2[j]=ind-mx[j]-tag[j];\t\t\t\tcontinue;\t\t\t}\t\t\tint L2=max(1,j*B),R2=min(n,j*B+B-1);\t\t\tfor(register int j2=L2;j2<=R2;j2++)\t\t\t\tif(p[j2]<cur)\t\t\t\t\tif(nxt[j2]==mx[j])\t\t\t\t\t\tnxt[j2]+=tag2[j];\t\t\ttag2[j]=0;\t\t\tfor(register int j2=L2;j2<=R2;j2++)\t\t\t\tif(p[j2]<cur)\t\t\t\t{\t\t\t\t\tnxt[j2]+=tag[j];\t\t\t\t\tnxt[j2]=min(nxt[j2],ind);\t\t\t\t}\t\t\ttag[j]=0;\t\t\tmx[j]=-inf;\t\t\tfor(register int j2=L2;j2<=R2;j2++) if(p[j2]<=cur)\t\t\t\tmx[j]=max(mx[j],nxt[j2]);\t\t\tmx2[j]=-inf;\t\t\tfor(register int j2=L2;j2<=R2;j2++) if(p[j2]<=cur) if(nxt[j2]!=mx[j])\t\t\t\tmx2[j]=max(mx2[j],nxt[j2]);\t\t\tvec[j].clear();\t\t\tfor(int j2=L2;j2<=R2;j2++)\t\t\t\tif(p[j2]<=cur) if(nxt[j2]<mx[j])\t\t\t\t\tvec[j].pb(nxt[j2]-get_ind(j2));\t\t\tsrt(vec[j]);\t\t\tpsum[j].clear();\t\t\tpsum[j].pb(0);\t\t\tfor(auto x:vec[j])\t\t\t\tpsum[j].pb(psum[j].back()+x);\t\t\tvec2[j].clear();\t\t\tfor(int j2=L2;j2<=R2;j2++) if(p[j2]<=cur) if(nxt[j2]==mx[j])\t\t\t\tvec2[j].pb(nxt[j2]-get_ind(j2));\t\t\tsrt(vec2[j]);\t\t\tpsum2[j].clear();\t\t\tpsum2[j].pb(0);\t\t\tfor(auto x:vec2[j])\t\t\t\tpsum2[j].pb(psum2[j].back()+x);\t\t}\t\tfor(int qind=0;qind<sz(vq[cur]);qind++) if(!qind||vq[cur][qind]!=vq[cur][qind-1])\t\t{\t\t\tint X=vq[cur][qind];\t\t\tfor(int j=0;j<=n/B;j++)\t\t\t{\t\t\t\tint pos=lb(vec[j],X);\t\t\t\tvans[cur][qind]+=psum[j][pos]+1ll*X*(sz(vec[j])-pos);\t\t\t\tint pos2=lb(vec2[j],X-tag2[j]);\t\t\t\tvans[cur][qind]+=psum2[j][pos2]+1ll*tag2[j]*pos2+1ll*X*(sz(vec2[j])-pos2);\t\t\t}\t\t}\t}}int main(){\tios_base::sync_with_stdio(false);\tcin.tie(0);\tcout.tie(0);\tint t;\tcin>>t;\twhile(t--)\t{\t\tcin>>n;\t\tfor(int i=1;i<=n;i++)\t\t{\t\t\tcin>>p[i];\t\t\tpos[p[i]]=i;\t\t}\t\tfor(int i=1;i<=n;i++)\t\t{\t\t\tint k;\t\t\tcin>>k;\t\t\tvq[i].resize(k);\t\t\tvans[i]=vector<ll>(k,0);\t\t\tfor(auto &x:vq[i])\t\t\t\tcin>>x;\t\t}\t\tcalc();\t\treverse(p+1,p+n+1);\t\tfor(int i=1;i<=n;i++)\t\t\tpos[p[i]]=i;\t\tcalc();\t\tfor(int i=1;i<=n;i++)\t\t\tfor(int j=0;j<sz(vq[i]);j++)\t\t\t\tif(!j||vq[i][j]!=vq[i][j-1])\t\t\t\t\tvans[i][j]-=i+vq[i][j]-1;\t\t\t\telse\t\t\t\t\tvans[i][j]=vans[i][j-1];\t\tfor(int i=1;i<=n;i++)\t\t\tfor(auto x:vans[i])\t\t\t\tcout<<x<<\'\\n\';\t}\treturn 0;}']","[0, 0, 1, 0, 1]",3200,Consider an array with length For each integer from to consider s t we tag the untagged that is a position will not be tagged for a second time positions in the range By examining the total number of positions tagged we haveSymmetrically on the other side we only have to compute We want to maintain all in a sorted order so that queries can be done using binary search This can be done with the help of chunking Let the length of each block be In each block we divide the positions into two categories Positions with the maximum hereinafter referred to as and positions without the maximum hereinafter referred to as We sort the positions by for A and for B respectively How does an update affect the values For the block that the new number is inserted we brutely reconstruct it For an affected complete block the update is or A operation can just be handled with a lazy tag For a operation if it only affects the elements with maximum it can be done lazily otherwise you can reconstruct the whole block Let the potential of a block Similar to the segment tree beats each insertion increases by at most and each brute reconstruction takes time and decreases by at least Therefore the overall time complexity for the insertion part would be To answer a query we iterate over all the different blocks If we precalculate the prefix sums of in the sorted order with a simple binary search this part can be done easily in Let The time complexity would be while the space complexity is Merge sorting or fractional cascading will make the time complexity but it runs slower than the previously mentioned solution 
Famous worldwide astrophysicist Mleil waGrasse Tysok recently read about the existence of Before he shares this knowledge with the broader audience in his podcast called he wants to prove their presence on his own Mleil is aware that the vastness of the universe is astounding almost as astounding as his observation skills and decides to try his luck and find some new pair of twin clusters To do so he used his TLEscope to observe a part of the night sky that was not yet examined by humanity in which there are exactly 2 k 1 galaxies in a row i th of them consist of exactly 0 le g i 4 k stars A galaxy cluster is any non empty contiguous segment of galaxies Moreover its is said to be equal to the bitwise XOR of all values g i within this range Two galaxy clusters are considered twins if and only if they have the same traits and their corresponding segments are Write a program that for many scenarios will read a description of a night sky part observed by Mleil and outputs a location of two intervals belonging to some twin clusters pair or a single value 1 if no such pair exists ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 300300;\nll a[N];\nint k;\nmap<ll, pii> mem;\nmap<ll, int> firstOcc;\n\nvoid solve() {\n\tscanf(""%d"", &k);\n\tint n = 1 << (k + 1);\n\ta[0] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(""%lld"", &a[i + 1]);\n\t\ta[i + 1] ^= a[i];\n\t}\n\teprintf(""read\\n"");\n\tfirstOcc.clear();\n\tint prevZero = -1;\n\tfor (int i = 0; i <= n; i++) {\n\t\tif (firstOcc.count(a[i])) {\n\t\t\tint p = firstOcc[a[i]];\n\t\t\tif (p != i - 1) {\n\t\t\t\tprintf(""%d %d %d %d\\n"", p + 1, p + 1, p + 2, i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (prevZero != -1) {\n\t\t\t\tprintf(""%d %d %d %d\\n"", prevZero, prevZero, i, i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprevZero = i;\n\t\t} else {\n\t\t\tfirstOcc[a[i]] = i;\n\t\t}\n\t}\n\teprintf(""before while true\\n"");\n\tmem.clear();\n\twhile(true) {\n\t\tint l = myRand(n + 1), r = myRand(n + 1);\n\t\tif (l == r) continue;\n\t\tif (l > r) swap(l, r);\n\t\tll x = a[l] ^ a[r];\n\t\tif (mem.count(x)) {\n\t\t\tpii t = mem[x];\n\t\t\tif (t.first == l || t.second == r) continue;\n\t\t\tvector<int> w = {t.first, t.second, l, r};\n\t\t\tsort(all(w));\n\t\t\tassert(w[0] < w[1] && w[1] <= w[2] && w[2] < w[3]);\n\t\t\tprintf(""%d %d %d %d\\n"", w[0] + 1, w[1], w[2] + 1, w[3]);\n\t\t\treturn;\n\t\t} else {\n\t\t\tmem[x] = mp(l, r);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\tfor (int i = 1; i <= t; i++) {\n\t\teprintf(""--- Case #%d start ---\\n"", i);\n\t\t//printf(""Case #%d: "", i);\n\n\t\tsolve();\n\n\t\t//printf(""%lld\\n"", (ll)solve());\n\n\t\t/*\n\t\tif (solve()) {\n\t\t\tprintf(""Yes\\n"");\n\t\t} else {\n\t\t\tprintf(""No\\n"");\n\t\t}\n\t\t*/\n\n\t\teprintf(""--- Case #%d end ---\\n"", i);\n\t\teprintf(""time = %.5lf\\n"", getCurrentTime());\n\t\teprintf(""++++++++++++++++++++\\n"");\n\t}\n\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0]",2600,Deterministic solution Let us first look for segments that zeros first out of bits Since we have then we have prefix xors of the array along with en empty prefix Let us look at the xor prefix modulo Each time we have a prefix xor that has already occurred before let us match it with this previous occurrence We will find at least such segments Note that segments have pairwise different ends and pairwise different beginnings Each of those segments generates some kind of xor value on the other bits Since there is only different possible values due to pigeon principle there will be two segments that generate same xor We select those two intervals If they are disjoint then we already found the answer Otherwise the final answer will be the xor of those two segments values that are covered only by one of them It can be showed that we will obtain two disjoint non empty segments Nondeterministic solution If there are any duplicates in the array then we can take two one element arrays and obtain answer From now on we will assume that no duplicates occur in the array Let us observe that number of valid segments is equal to which is over twice larger than all possible xor values for a segment which is This suggest that chances of collision of two random segments is quite high For simplicity let us assume there is exactly segments Let us look at the final distribution over the xors used by segments It can be showed by exchange argument that the the distribution that needs the most random tosses to obtain collision is the one in which every xor value is used by exactly two segments Since we choose segments randomly by birthday paradox the expected time of obtaining a collision is around 2 k Now there is a chance that we will toss the same segment twice but if we multiply the number of tossing by then chance that we find two different segments is very high in reality even less random choices are necessary There is another issue even if we find two different segments with the same xor values They can use common elements But then we can simply take only the elements that belong to the exactly one of them Still if the segments had common end one of the obtained segments would be empty To omit this issue let us see that the second obtained segment would have xor equal to So now we can take any prefix and corresponding suffix as an answer Unfortunately this segment can have length But in this case the only element in the segment has to be equal to There must be at most one number in the array so we can simply get rid of it shorten the array by one The analysis still holds with some slight modifications 
You are given two integers l le r You need to find integers a and b such that the following conditions are simultaneously satisfied l le a b le r gcd a b neq 1or report that they do not exist gcd a b denotes the greatest common divisor of numbers a and b For example gcd 6 9 3 gcd 8 9 1 gcd 4 2 2 ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define vll vector<ll>\n#define vvll vector<vll>\n\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        ll l, r;\n        cin >> l >> r;\n        if (l != r) {\n            if (r <= 3)\n                cout << -1 << '\\n';\n            else\n                cout << r/2 << ' ' << r/2 << '\\n';\n        } else {\n            bool prime = true;\n            for (ll i = 2; i*i <= l; i++) {\n                if (l % i == 0) {\n                    prime = false;\n                    cout << i << ' ' << l-i << '\\n';\n                    break;\n                }\n            }\n            if (prime) cout << -1 << '\\n';\n        }\n    }\n}""]","[0, 1, 0, 0, 0]",1100,To begin with let s learn how to solve the problem when In other words we need to find a value such that Notice that Then it is easy to see that if is prime then for any otherwise any divisor of except and will work as Thus we can solve the problem when using the standard algorithm for primality testing in time Next we can solve the problem in several ways Sequentially check for primality all numbers from to and stop and output the answer as soon as we find the first composite number This works faster than because there are no two adjacent prime numbers starting from so the answer will be found very quickly Handle the case separately Also separately consider the case in which the answer is Otherwise notice that since there are at least numbers in the interval there must be an even number in this interval And for the maximum even number in the interval will be so for example will be a valid answer To find the maximum even number in the interval we can use the formula 
You are given a binary matrix A of size n times n Let s denote an x compression of the given matrix as a matrix B of size frac n x times frac n x such that for every i in 1 n j in 1 n the condition A i j B lceil frac i x rceil lceil frac j x rceil is met Obviously x compression is possible only if x divides n but this condition is not enough For example the following matrix of size 2 times 2 does not have any 2 compression 01 10 For the given matrix A find maximum x such that an x compression of this matrix is possible ,"['#ifndef BZ\n#pragma GCC optimize ""-O3""\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst int MX = 5300;\n\nbool a[MX][MX];\n\nbool er[MX], ec[MX];\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n;\n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < n / 4; j++) {\n            int x = 0;\n            if (s[j] >= \'0\' && s[j] <= \'9\') {\n                x = s[j] - \'0\';\n            } else {\n                x = s[j] - \'A\' + 10;\n            }\n            for (int k = 3; k >= 0; k--) {\n                if (x % 2 == 1) {\n                    a[i][4 * j + k] = true;\n                }\n                x /= 2;\n            }\n        }\n    }\n\n    for (int i = 1; i < n; i++) {\n        ec[i] = true;\n        for (int j = 0; j < n; j++) {\n            if (a[i][j] != a[i - 1][j]) {\n                ec[i] = false;\n            }\n        }\n    }\n\n    for (int j = 1; j < n; j++) {\n        er[j] = true;\n        for (int i = 0; i < n; i++) {\n            if (a[i][j] != a[i][j - 1]) {\n                er[j] = false;\n            }\n        }\n    }\n\n    int ans = 1;\n    for (int i = 1; i <= n; i++) {\n        if (n % i) {\n            continue;\n        }\n        bool ok = true;\n        for (int j = 0; j < n; j++) {\n            if (j % i != 0 && (!ec[j] || !er[j])) {\n                ok = false;\n            }\n        }\n        if (ok) {\n            ans=  i;\n        }\n    }\n    cout << ans << ""\\n"";\n    return 0;\n}\n\n']","[0, 1, 1, 1, 0]",1800,After some tinkering with the given condition we notice that an compression is possible iff divides and the matrix is divisible into matrices such that each matrix is either all 1 or all 0 We can loop over all such and check the condition in time per but this is potentially too slow To speed this up we can precompute rectangle sums for every rectangle containing the upper left corner which enables us to compute the sum of any rectangle in This improves our time complexity to Since really this means our solution is Code 49028814 
Recently you bought a brand new smart lamp with programming features At first you set up a schedule to the lamp Every day it will turn power on at moment 0 and turn power off at moment M Moreover the lamp allows you to set a program of switching its state states are lights on and lights off Unfortunately some program is already installed into the lamp The lamp allows only programs Good program can be represented as a non empty array a where 0 a 1 a 2 dots a a M All a i must be integers Of course preinstalled program is a good program The lamp follows program a in next manner at moment 0 turns power and light on Then at moment a i the lamp flips its state to opposite if it was lit it turns off and vice versa The state of the lamp flips instantly for example if you turn the light off at moment 1 and then do nothing the total time when the lamp is lit will be 1 Finally at moment M the lamp is turning its power off regardless of its state Since you are not among those people who read instructions and you don t understand the language it s written in you realize after some testing the only possible way to alter the preinstalled program You can element into the program a so it still should be a program after alteration Insertion can be done between any pair of consecutive elements of a or even at the begining or at the end of a Find such a way to alter the program that the total time when the lamp is lit is maximum possible Maybe you should leave program untouched If the lamp is lit from x till moment y then its lit for y x units of time Segments of time when the lamp is lit are summed up ,"['#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, ""r"", stdin );\n#define fout(s) freopen( s, ""w"", stdout );\n\nconst long long N = 100100;\nconst long long Q = 2e18;\nconst long long mod = 1e9 + 7;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint m;\nint d[N][2][2];\n\nvoid solve()\n{\n        vector < int > a;\n        a.push_back(0);\n        cin >> n >> m;\n        for(int i = 1; i <= n; i++){\n                int x;\n                cin >> x;\n                a.push_back(x);\n                d[i][0][0] = -1e9;\n                d[i][1][0] = -1e9;\n                d[i][0][1] = -1e9;\n                d[i][1][1] = -1e9;\n        }\n        d[0][0][0] = -1e9;\n        d[0][1][0] = -1e9;\n        a.push_back(m);\n        for(int i = 1; i <= n + 1; i++){\n                d[i][0][0] = d[i - 1][0][1] + a[i] - a[i - 1];\n                d[i][0][1] = d[i - 1][0][0];\n                d[i][1][0] = d[i - 1][1][1] + a[i] - a[i - 1];\n                if(a[i - 1] + 1 < a[i]) d[i][1][0] = max(d[i][1][0], d[i - 1][0][0] + a[i] - a[i - 1] - 1);\n                d[i][1][1] = d[i - 1][1][0];\n                if(a[i - 1] + 1 < a[i]) d[i][1][1] = max(d[i][1][1], d[i - 1][0][1] + a[i] - a[i - 1] - 1);\n        }\n        n++;\n        int ans = d[n][0][0];\n        ans = max(ans, d[n][0][1]);\n        ans = max(ans, d[n][1][0]);\n        ans = max(ans, d[n][1][1]);\n        cout << ans << ""\\n"";\n}\n\nbool mtest = false; int main()\n{\n        //fin(""input.txt"");\n        //fout(""output.txt"");\n        //fin(""island.in"");\n        //fout(""island.out"");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n']","[1, 0, 0, 0, 0]",1500,At first let s insert and in array so all possible positions for inserting will always belong to At second let be value to insert and It can be proven that it s always optimal to move to or to So for each we need to check only and To check it fast enough we need to know total time of lamp is lit for each prefix and precalculate for each total time of lamp is lit if starting from light is on lights is off Result complexity is 
You are given an array with elements Each element of is either or Let s denote the length of the longest subsegment of consecutive elements in consisting of only numbers one as You can change no more than zeroes to ones to maximize ,"['# include <cstdio>\n# include <set>\nusing namespace std;\nconst int MN = 3e5 + 44;\nint a[MN];\nint main()\n{\n\tint n, k;\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(""%d"", a + i);\n\t\ta[i] ^= 1;\n\t}\n\tint res = 0;\n\tint sum = 0;\n\tint h = 0;\n\tint l = 0, r = 0;\n\tfor (int t = 0; t < n; ++t)\n\t{\n\t\twhile (sum + a[h] <= k && h < n)\n\t\t{\n\t\t\tsum += a[h];\n\t\t\th++;\n\t\t}\n\t\tif (h - t > res)\n\t\t{\n\t\t\tres = h - t;\n\t\t\tl = t;\n\t\t\tr = h;\n\t\t}\n\t\tres = max(res, h - t);\n\t\tsum -= a[t];\n\t}\n\tprintf(""%d\\n"", res);\n\tfor (int i = l; i < r; ++i)\n\t\ta[i] = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tprintf(""%d "", 1 - a[i]);\n\tprintf(""\\n"");\n}']","[0, 0, 0, 1, 0]",1600,The problem was suggested by Mohammad Amin Raeisi Smaug Let s call the segment good if it contains no more than zeroes Note if segment is good than the segment is also good So we can use the method of two pointers the first pointer is and the second is Let s iterate over from the left to the right and move while we can to do that we should simply maintain the number of zeroes in the current segment C solution 
You are given a rectangular parallelepiped with sides of positive integer lengths A B and C Find the number of different groups of three integers a b c such that 1 leq a leq b leq c and parallelepiped A times B times C can be paved with parallelepipeds a times b times c Note that all small parallelepipeds For example parallelepiped 1 times 5 times 6 can be divided into parallelepipeds 1 times 3 times 5 but can not be divided into parallelepipeds 1 times 2 times 3 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<class T> ostream& operator<<(ostream& os, const V<T> &v) {\n    cout << ""["";\n    for (auto p: v) cout << p << "", "";\n    cout << ""]"";\n    return os;\n}\n\nconst int MN = 100100;\nV<int> fac[MN];\n\nvoid first() {\n    for (int i = 1; i < MN; i++) {\n        for (int j = i; j < MN; j += i) {\n            fac[j].push_back(i);\n        }\n    }\n}\n\nvoid calc() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    V<int> res_ab, res;\n    merge(begin(fac[a]), end(fac[a]), begin(fac[b]), end(fac[b]), back_inserter(res_ab));\n    merge(begin(res_ab), end(res_ab), begin(fac[c]), end(fac[c]), back_inserter(res));\n    res.erase(unique(begin(res), end(res)), end(res));\n\n    ll cnt[8] = {};\n    for (int d: res) {\n        int f = 0;\n        if (a % d == 0) f += 1;\n        if (b % d == 0) f += 2;\n        if (c % d == 0) f += 4;\n        assert(f);\n        cnt[f]++;\n    }\n    ll ans = 0;\n    for (int i = 1; i <= 7; i++) {\n        for (int j = i; j <= 7; j++) {\n            for (int k = j; k <= 7; k++) {\n                if ((i | j | k) != 7) continue;\n                if ((i == j || j == k) && (j == 1 || j == 2 || j == 4)) continue;\n\n                ll z = cnt[j];\n                if (i == j && j == k) {\n                    ans += z * (z+1) * (z+2) / 6;\n                    continue;\n                }\n                if (i == j) {\n                    ans += z * (z+1) * cnt[k] / 2;\n                    continue;\n                }\n                if (j == k) {\n                    ans += z * (z+1) * cnt[i] / 2;\n                    continue;                    \n                }\n                ans += cnt[i] * cnt[j] * cnt[k];\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    first();\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++) {\n        calc();\n    }\n    return 0;\n}\n']","[0, 1, 0, 0, 0]",2400,First for every natural number up to we count its number of divisors in Also for every unordered set of masks of length we check if there is way to enumerate them in such a way that and We will call such sets Now let s consider two parallelepipeds For each dimension of the second parallelepiped let s construct a mask of length which contains the numbers of the dimensions of the first parallelepiped for which the length of the first parallelepiped along this dimension is divisible by the length of the second parallelepiped along the chosen dimension Now these three masks form an acceptable set iff we can pave the first parallelepiped with the second one Now for a given parallelepiped let s calculate for every mask of length the number of possible lengths of the second parallelepiped which would produce this mask We can do this by taking the GCD of the lengths of the first parallelepiped along the dimensions whose numbers are in the mask and subtracting from it the calculated numbers for every submask Now let s iterate over acceptable sets of masks For each different mask from the set which is included into the set times we need to calculate the number of ways to take unordered lengths which produce this mask and multiply these numbers The sum of these numbers is the answers to the query So for every query we need operations where is the number of dimensions of the parallelepiped First for every natural number up to we count its number of divisors in Then for every query for every subset of numbers in it we keep their GCD and the number of its divisors So for every subset of this three numbers we know the number of their common divisors Let s look at the parallelepiped The way we orient it with respect to the large parallelepiped is determined by a permutation of size that is which dimension would correspond to every dimension in the large one Using the inclusion exclusion principle on this permutations we can count how many there are such parallelepipeds considering the orientation that we can orient some way to then pave the large parallelepiped with it Namely we fix the set of permutations for which our parallelepiped shall satisfy Then for every side of the small parallelepiped we know which sides of the large one it shall divide To find the number of such sides of the small one we shall take the number of common divisors of the corresponding sides of the large one Now to find the number of such small parallelepipeds we must multiply the three resultant numbers In such way every satisfying this criteria parallelepiped not considering the orientation with three different side lengths was counted times with two different lengths was counted times with one different length was counted time But it won t be difficult for us to use the same approach in counting such parallelepipeds but with no less than two same side lengths let s say the first and the second To do this when we fix which permutations this parallelepiped shall satisfy we should just add the condition that its first and second side lengths must be equal this means they both must divide both of the sets corresponding to them so instead of this two sets we must take their union Let s add the resultant number multiplied by three to the answer Now every parallelepiped with three different side length is still counted times with two different is now counted also times and with one different is counted times The number of satisfying parallelepipeds with equal sides is just the number of common divisors of all the sides of the large parallelepiped Let s add it multiplied by two and now every needed parallelepiped is counted times We divide this number by and get the answer So for every query we need operations where is the number of partitions of and is the number of dimensions of the parallelepiped 
Boboniu gives you r red balls g green balls b blue balls w white balls He allows you to do the following operation as many times as you want Pick a red ball a green ball and a blue ball and then change their color to white You should answer if it s possible to arrange all the balls into a after several possibly zero number of described operations ,"['#include<bits/stdc++.h>\nusing namespace std;\nint T,a,b,c,d;\nbool ok;\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d%d%d%d"",&a,&b,&c,&d),ok=false;\n\t\tok|=((a&1)+(b&1)+(c&1)+(d&1)<=1);\n\t\tif(a&&b&&c)a--,b--,c--,d+=3;\n\t\tok|=((a&1)+(b&1)+(c&1)+(d&1)<=1);\n\t\tputs(ok?""Yes"":""No"");\n\t}\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0]",1000,If there are less than or equal to one odd number in then you can order them to be a palindrome Otherwise do the operation once if you can and check the condition above It is meaningless to do operation more than once because we only care about the parity of 
Gargari is jealous that his friend Caisa won the game from the previous problem He wants to prove that he is a genius He has a chessboard Each cell of the chessboard has a number written on it Gargari wants to place two bishops on the chessboard in such a way that there is no cell that is attacked by both of them Consider a cell with number written on it if this cell is attacked by one of the bishops Gargari will get dollars for it Tell Gargari how to place bishops on the chessboard to get maximum amount of money We assume a cell is attacked by a bishop if the cell is located on the same diagonal with the bishop the cell where the bishop is also considered attacked by it ,"['#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <functional>\n\ntypedef long long lld;\nconst int N = 2000 + 5;\nlld l[N][N],r[N][N],u[N][N],d[N][N],A[N][N];\nint n;\n\nint main() {\n\tscanf(""%d"",&n);\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tscanf(""%I64d"",&A[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tl[i][j] = l[i-1][j-1] + A[i][j];\n\t\t\tr[i][j] = r[i-1][j+1] + A[i][j];\n\t\t}\n\t}\n\tfor (int i = n; i >= 1; -- i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tu[i][j] = u[i+1][j-1] + A[i][j];\n\t\t\td[i][j] = d[i+1][j+1] + A[i][j];\n\t\t}\n\t}\n\tlld sum[2] = {-1,-1};\n\tint x[2],y[2];\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tfor (int j = 1; j <= n; ++ j) {\n\t\t\tint c = (i+j&1);\n\t\t\tlld value = l[i][j] + r[i][j] + u[i][j] + d[i][j] - 3*A[i][j];\n\t\t\tif (sum[c] < value) {\n\t\t\t\tsum[c] = value;\n\t\t\t\tx[c] = i;\n\t\t\t\ty[c] = j;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%I64d\\n"",sum[0]+sum[1]);\n\tprintf(""%d %d %d %d\\n"",x[0],y[0],x[1],y[1]);\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0]",1900,We preprocess the sum for all the diagonals principals and secondary diagonals in two arrays so that for every element i j we can find sum of elements which are attacked in O 1 time Also for avoiding the intersection we need to find two cells so that for one the sum of row and column is even and for the other one the sum of row and column is odd Finally we analyze every cell we see if the sum of row and column is even or odd and update that two positions solutions 
You are given a permutation p of length n an array consisting of integers from 1 to n all distinct Let p l r denote a subarray an array formed by writing down elements from index l to index r inclusive Let mathit maxpos l r denote the of the maximum element on p l r Similarly let mathit minpos l r denote the index of the minimum element on it Calculate the number of subarrays p l r such that mathit maxpos l r mathit minpos l r ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> p[i];\n    }\n    \n    std::vector<int> lmin(n, -1), rmin(n, n), lmax(n, -1), rmax(n, n);\n    std::vector<int> smin, smax;\n    for (int i = 0; i < n; i++) {\n        while (!smin.empty() && p[i] < p[smin.back()]) {\n            rmin[smin.back()] = i;\n            smin.pop_back();\n        }\n        if (!smin.empty()) {\n            lmin[i] = smin.back();\n        }\n        smin.push_back(i);\n        \n        while (!smax.empty() && p[i] > p[smax.back()]) {\n            rmax[smax.back()] = i;\n            smax.pop_back();\n        }\n        if (!smax.empty()) {\n            lmax[i] = smax.back();\n        }\n        smax.push_back(i);\n    }\n    \n    i64 ans = 0;\n    std::vector<int> s{-1};\n    std::vector<i64> sum{0LL};\n    for (int i = 0; i < n; i++) {\n        while (s.size() > 1 && p[i] < p[s.back()]) {\n            rmin[s.back()] = i;\n            s.pop_back();\n            sum.pop_back();\n        }\n        int l = std::upper_bound(s.begin(), s.end(), lmax[i]) - s.begin();\n        if (l < s.size()) {\n            ans += 1LL * (s[l] - std::max(s[l - 1], lmax[i]))\n                * (std::min(rmax[i], rmin[s[l]]) - i);\n            l++;\n            int m = std::partition_point(s.begin() + l, s.end(), [&](int x) {\n                return rmin[x] > rmax[i];\n            }) - s.begin();\n            ans += 1LL * (s[m - 1] - s[l - 1]) * rmax[i];\n            ans -= 1LL * (s.back() - s[l - 1]) * i;\n            ans += sum.back() - sum[m - 1];\n        }\n        sum.push_back(sum.back() + 1LL * (i - s.back()) * rmin[i]);\n        s.push_back(i);\n    }\n    \n    std::cout << ans << ""\\n"";\n    \n    return 0;\n}']","[0, 0, 0, 1, 1]",2300,The problem was originally prepared as part of the lecture on a monotonic stack Thus I will omit its explanation First recall a common technique of counting all segments satisfying some property You can count the segments that have the same right border at the same time Consider all segments with a fixed How do the minimums and the maximums on them change from each other If you look at the segments in the order of decreasing we can write down the sequence of the following events the minimum becomes smaller or the maximum becomes larger In fact we can maintain both of these types with two monotonic stacks Now which correspond to good segments with regard to the events Consider two adjacent events and where is the index of the event and is the type for min for max It s easy to see that if then all segments that have from to are good It means that while going from right to left the last event we encountered was the minimum getting smaller Thus the index of the minimum becomes to the left from the index of the maximum As for the implementation we will maintain these events in a set of pairs index of the event type of the event This way it s not that hard to maintain the sum of distances from each event of type to the left to the previous event When you erase an event only a few distances can be affected the distance from the next one to the current one from the current one to the previous one and the newly created distance from the next one to the previous one Just check for the types When you add an event you only add it to the very end of the set so it s trivial to recalculate That will be just from the set the monotonic stacks by themselves are linear You can optimize this solution to by using a doubly linked list but it really was not necessary for the problem There s also a different solution for which you can maintain the intervals of good values explicitly First compress them in such a way that the segments don t touch at borders Now you can notice that by going from to we can only affect the rightmost ones of them possibly remove some then change the last one and add a new one So we can actually simulate this behavior with another stack The details are left as an exercise to a reader With the correct implementation this solution will be 
Sofia has a string s of length n consisting only of lowercase English letters She can perform operations of the following types with this string Select an index 1 le i le s and remove the character s i from the string Select a pair of indices l r 1 le l le r le s and sort the substring s l s l 1 ldots s r in alphabetical order Here s denotes the current length of s In particular s n before the first operation For example if s mathtt sofia then performing the operation of the first type with i 4 results in s becoming mathtt sofa and performing the operation of the second type with l r 2 4 after that results in s becoming mathtt safo Sofia wants to obtain the string t of length m after performing zero or more operations on string s as described above Please determine whether it is possible or not ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<int> in[26];\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    string s, t;\n    cin >> s >> t;\n    for (int i = 0; i < 26; ++i) {\n        in[i].clear();\n    }\n    for (int i = 0; i < n; ++i) {\n        in[s[i] - \'a\'].push_back(i);\n    }\n    vector<int> pos(26, -1);\n    for (auto ch : t) {\n        int id = ch - \'a\';\n        int mx = -1;\n        for (int i = id; i < 26; ++i) {\n            mx = max(mx, pos[i]);\n        }\n        auto it = upper_bound(in[id].begin(), in[id].end(), mx);\n        if (it == in[id].end()) {\n            cout << ""NO\\n"";\n            return;\n        }\n        pos[id] = *it;\n    }\n    cout << ""YES\\n"";\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']","[1, 0, 0, 0, 1]",2200,SolutionWe sort only the substrings of length We can swap two adjacent characters if the first is greater than or equal to the second Let us fix some character and presume we want to change its position to We have to perform the described swaps if they are possible More formally if then every character in the segment must be greater than or equal to if then every character in the segment must be smaller than or equal to We want to reorder the string and get the string Then we check if we can delete some characters in to achieve In other words we want to be a subsequence of A general algorithm that checks if the string is a subsequence of the string is as follows We iterate through and for each character we find its first next appearance in If such a character does not exist we conclude that is not a subsequence of If we complete the iteration gracefully then is a subsequence of We will try to check if is a subsequence of but we allow ourselves to modify along the way We maintain queues for positions of each lowercase English letter in the string We iterate through the string and for every character we try to move the first available equivalent character in to position In other words at every moment the prefix of string is equal to the prefix of string if possible For the current character and the corresponding prefixes and are the same which means that To move to position we need to delete all characters between and that are smaller than We will delete them and all characters from the current prefix from the queues because they are no longer candidates for By doing so will be the first character in the corresponding queue If at some moment in our greedy algorithm the queue we are looking for becomes empty then the answer is NO Otherwise we will make the prefix equal to the and delete the remaining characters from Why is this greedy approach optimal Let s suppose for some character we chose and for we chose such that and We need to prove that if we can move to position and to position when we can move to and to In the moment when we chose prefixes and are the same so Similarly which means the only possibility is If we can move to position than we can also move to because and Also if we can move to than we can move to because from which it follows that we can move to because and The overall complexity is where is the alphabet size in this problem 
A permutation of size is an array of size such that each integer from to occurs exactly once in this array An inversion in a permutation is a pair of indices such that and For example a permutation contains inversions You are given a permutation of size and queries to it Each query is represented by two indices and denoting that you have to reverse the segment of the permutation For example if and a query is applied then the resulting permutation is After each query you have to determine whether the number of inversions is odd or even ,"['#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N;\n    cin >> N;\n    vi a(N);\n    for (int i = 0; i < N; i++)\n        cin >> a[i];\n    int swap = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = i + 1; j < N; j++)\n            if (a[i] > a[j])\n                swap++;\n    swap &= 1;\n    int M;\n    cin >> M;\n    for (int i = 0; i < M; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        ll s = r - l + 1;\n        ll c = s * (s - 1) / 2;\n        swap ^= c & 1;\n        cout << (swap ? ""odd\\n"" : ""even\\n"");\n    }\n\n    return 0;\n}\n']","[0, 1, 0, 0, 0]",1800,Permutaion with one swap is called transposition Any permutation can be expressed as the composition product of transpositions Simpler you can get any permutation from any other one of the same length by doing some number of swaps The sign of the permutation is the number of transpositions needed to get it from the identity permutation Luckily not really this is pure math check out all proofs at wiki e g the sign can also tell us the parity of inversion count Now you can start with computing parity of inversion count of the original permutation naively check all pairs of indices Finally you can decompose queries into swaps any method will be ok Like you can swap and then and and so on this is swaps Then parity of inversion count of the resulting permutation will change if you applied odd number of swaps Overall complexity 
Find an matrix with different numbers from to so the sum in each row column and both main diagonals are odd ,"['#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <ctype.h>\n#include <deque>\n#include <queue>\n#include <cstring>\n#include <set>\n#include <list>\n#include <map>\n#include <random>\n#include <unordered_map>\n#include <stdio.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef std::vector<int> vi;\ntypedef std::vector<bool> vb;\ntypedef std::vector<string> vs;\ntypedef std::vector<double> vd;\ntypedef std::vector<long long> vll;\ntypedef std::vector<std::vector<int> > vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vll> vvll;\ntypedef std::vector<std::pair<int, int> > vpi;\ntypedef vector<vpi> vvpi;\ntypedef std::pair<int, int> pi;\ntypedef std::pair<ll, ll> pll;\ntypedef std::vector<pll> vpll;\n\nconst long long mod = 1000000007;\n\n#define all(c) (c).begin(),(c).end()\n#define sz(c) (int)(c).size()\n#define forn(i, a, b) for(int i = a; i < b; i++)\n\n#define pb push_back\n#define mp make_pair\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(""input.txt"", ""rt"", stdin);\n    freopen(""output.txt"", ""wt"", stdout);\n#endif\n    int n;\n    cin>>n;\n    vvi a(n, vi(n,1));\n    int o = 1;\n    int e = 2;\n    int p = (n*n+1)/2;\n    int q = n*n - p;\n    forn(i,0,n/2) forn(j,0,n/2) {\n        if(q>0) {\n            q-=4;\n            a[i][j] = 0;\n            a[n-1-i][j]=0;\n            a[n-1-i][n-1-j]=0;\n            a[i][n-1-j]=0;\n        }\n    }\n    forn(i,0,n) forn(j,0,n) {\n        if(a[i][j] == 0) {\n            a[i][j] = e;\n            e+=2;\n        }\n        else {\n            a[i][j]= o;\n            o+=2;\n        }\n    }\n    forn(i,0,n) {\n        forn(j,0,n) {\n            cout<<a[i][j];\n            if(j<n-1) cout<<\' \';\n        }\n        cout<<endl;\n    }\n    \n    \n    \n}\n\n\n']","[0, 1, 0, 0, 0]",1500,The problem was suggested by Resul Hangeldiyev Resul The solution can be got from the second sample testcase Easy to see that if we place all odd numbers in the center in form of rhombus we will get a magic square C solution 
Little Rosie has a phone with a desktop or launcher as it is also called The desktop can consist of several screens Each screen is represented as a grid of size 5 times 3 i e five rows and three columns There are x applications with an icon size of 1 times 1 cells such an icon occupies only one cell of the screen There are also y applications with an icon size of 2 times 2 cells such an icon occupies a of 4 cells on the screen Each cell of each screen can be occupied by no more than one icon Rosie wants to place the application icons on the minimum number of screens Help her find the minimum number of screens needed ,"['#include <iostream>#include <cmath>#include <algorithm>#include <vector>#include <chrono>#include <random>#include <map>#include <set>using namespace std;const int N = 120000;void solve() {\tint x, y;\tcin >> x >> y;\tif (y % 2 == 0) {\t\tif (x <= (y / 2) * 7) {\t\t\tcout << (y / 2) << ""\\n"";\t\t}\t\telse cout << (y / 2) + (x - (y / 2) * 7 + 14) / 15 << ""\\n"";\t}\telse {\t\tif (x <= (y / 2) * 7 + 11) {\t\t\tcout << (y / 2) + 1 << ""\\n"";\t\t}\t\telse cout << (y / 2) + 1 + (x - (y / 2) * 7 - 11 + 14) / 15 << ""\\n"";\t}}int main() {\tint t;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}']","[1, 1, 0, 0, 0]",800,Note that on one screen we can put no more than two icons Thus we need at least screens Then we check how many icons we can put on these screens The icons left we need to put on additional screens 
Imp likes his plush toy a lot Recently he found a machine that can clone plush toys Imp knows that if he applies the machine to an original toy he additionally gets one more original toy and one copy and if he applies the machine to a copied toy he gets two additional copies Initially Imp has only one original toy He wants to know if it is possible to use machine to get exactly toys and toys He can t throw toys away and he can t apply the machine to a copy if he doesn t currently have any copies ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define F first\n#define S second\nvoid shit(){\n    cout << ""No"" << endl;\n    exit(0);\n}\nint main(){\n    int c, o;\n    cin >> c >> o;\n    if(o < 1) shit();\n    if((c + o) % 2 != 1) shit();\n    int tot = (c + o - 1) / 2;\n    int op = o - 1;\n    int lef = tot - op;\n\tif (lef < 0)\n\t\tshit();\n    if(c == lef * 2 + op){\n        if(op == 0 && lef != 0) shit();\n        cout << ""Yes"" << endl;\n    }\n    else shit();\n}\n']","[0, 0, 1, 0, 0]",1300,Consider a few cases If the answer is always If then the answer is possible only if if the answer is We can observe that the original was cloned times to produce the requested amount of originals then the additional copies were created by cloning the copies emerged from cloning the original As every cloning of a copy results in additional two we need to check whether is divisible by 2 We also need to take care of the case when is less than zero in this case the answer is also 
Allen dreams of one day owning a enormous fleet of electric cars the car of the future He knows that this will give him a big status boost As Allen is planning out all of the different types of cars he will own and how he will arrange them he realizes that he has a problem Allen s future parking lot can be represented as a rectangle with 4 rows and n n le 50 columns of rectangular spaces each of which can contain at most one car at any time He imagines having k k le 2n cars in the grid and all the cars are initially in the second and third rows Each of the cars also has a different designated parking space in the first or fourth row Allen has to put the cars into corresponding parking places However since Allen would never entrust his cars to anyone else only one car can be moved at a time He can drive a car from a space in any of the four cardinal directions to a neighboring empty space Furthermore Allen can only move one of his cars into a space on the first or fourth rows if it is the car s designated parking space Allen knows he will be a very busy man and will only have time to move cars at most 20000 times before he realizes that moving cars is not worth his time Help Allen determine if he should bother parking his cars or leave it to someone less important ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=1010;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nPII q[N];\nint vis[5][N],car[5][N],n;\nPII pre[5][N];\nvector<VI> ret;\nvoid getpath(int x,int y) {\n\trep(i,0,4) rep(j,0,n) vis[i][j]=0,pre[i][j]=mp(-1,-1);\n\tint t=0;\n\tq[t++]=mp(x,y);\n\tvis[x][y]=1;\n\trep(i,0,t) {\n\t\tint px=q[i].fi,py=q[i].se;\n\t\tif (car[px][py]==0) {\n\t\t\twhile (1) {\n\t\t\t\tint qx=pre[px][py].fi,qy=pre[px][py].se;\n\t\t\t\tif (qx==-1&&qy==-1) break;\n\t\t\t\tassert(car[qx][qy]>0);\n\t\t\t\tret.pb(VI{car[qx][qy],px,py});\n\t\t\t\tcar[px][py]=car[qx][qy];\n\t\t\t\tcar[qx][qy]=0;\n\t\t\t\tpx=qx; py=qy;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\trep(k,0,4) {\n\t\t\tint qx=px+dx[k],qy=py+dy[k];\n\t\t\tif (qx>=1&&qx<=2&&qy>=0&&qy<n&&car[qx][qy]!=-1&&!vis[qx][qy]) {\n\t\t\t\tpre[qx][qy]=mp(px,py);\n\t\t\t\tvis[qx][qy]=1;\n\t\t\t\tq[t++]=mp(qx,qy);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid go(int x,int y,int c) {\n\tint posx=-1,posy=-1;\n\trep(i,1,3) rep(j,0,n) if (car[i][j]==c) {\n\t\tposx=i; posy=j;\n\t\tbreak;\n\t}\n\tint goalx=x^1,goaly=y;\n\twhile (posx!=goalx||posy!=goaly) {\n\t\tint nxtx=-1,nxty=-1;\n\t\trep(i,0,4) {\n\t\t\tint curx=posx+dx[i],cury=posy+dy[i];\n\t\t\tif (abs(curx-goalx)+abs(cury-goaly)<abs(posx-goalx)+abs(posy-goaly)) {\n\t\t\t\tnxtx=curx,nxty=cury;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcar[posx][posy]=-1;\n\t\tgetpath(nxtx,nxty);\n\t\tret.pb(VI{c,nxtx,nxty});\n\t\tcar[posx][posy]=0;\n\t\tcar[nxtx][nxty]=c;\n\t\tposx=nxtx; posy=nxty;\n\t}\n\tret.pb(VI{c,goalx^1,goaly});\n\tcar[goalx][goaly]=car[goalx^1][goaly]=0;\n}\nint main() {\n\tscanf(""%d%*d"",&n);\n\trep(i,0,4) rep(j,0,n) scanf(""%d"",&car[i][j]);\n\trep(j,0,n) {\n\t\tif (car[0][j]==car[1][j]&&car[0][j]!=0) {\n\t\t\tret.pb(VI{car[1][j],0,j});\n\t\t\tcar[0][j]=car[1][j]=0;\n\t\t}\n\t\tif (car[2][j]==car[3][j]&&car[2][j]!=0) {\n\t\t\tret.pb(VI{car[2][j],3,j});\n\t\t\tcar[2][j]=car[3][j]=0;\n\t\t}\n\t}\n\tbool empty=0;\n\trep(j,0,n) if (car[1][j]==0||car[2][j]==0) empty=1;\n\tif (!empty) {\n\t\tputs(""-1"");\n\t\treturn 0;\n\t}\n\trep(j,0,n) {\n\t\tif (car[0][j]) go(0,j,car[0][j]);\n\t\tif (car[3][j]) go(3,j,car[3][j]);\n\t}\n\tprintf(""%d\\n"",SZ(ret));\n\tfor (auto p:ret) {\n\t\tprintf(""%d %d %d\\n"",p[0],p[1]+1,p[2]+1);\n\t}\n}\n']","[0, 0, 1, 0, 0]",2100,First whenever any cars are directly to their parking spot we should move them into the correct parking spot Now we can view rows and as a cycle In at most moves we can spin the entire cycle of cars counterclockwise By repeating this times each car will have been adjacent to each parking space and will have had some chance to park The exception to this rule is when there are no empty spaces in rows and In this case no cars can even make a valid move so the answer is This requires and no cars are initially adjacent to their parking space This process will can be implemented in or time with at most which fits below the move limit 
Hyakugoku has just retired from being the resident deity of the South Black Snail Temple in order to pursue her dream of becoming a cartoonist She spent six months in that temple just playing Cat s Cradle so now she wants to try a different game Snakes and Ladders Unfortunately she already killed all the snakes so there are only ladders left now The game is played on a 10 times 10 board as follows At the beginning of the game the player is at the bottom left square The objective of the game is for the player to reach the Goal the top left square by following the path and climbing vertical ladders Once the player reaches the Goal the game ends The path is as follows if a square is not the end of its row it leads to the square next to it along the direction of its row if a square is the end of its row it leads to the square above it The direction of a row is determined as follows the direction of the bottom row is to the right the direction of any other row is opposite the direction of the row below it See Notes section for visualization of path During each turn the player rolls a standard six sided dice Suppose that the number shown on the dice is r If the Goal is less than r squares away on the path the player doesn t move but the turn is performed Otherwise the player advances exactly r squares along the path and then stops If the player stops on a square with the bottom of a ladder the player that ladder If she chooses not to climb then she stays in that square for the beginning of the next turn Some squares have a ladder in them Ladders are only placed vertically each one leads to the same square of some of the upper rows In order for the player to climb up a ladder after rolling the dice she must stop at the square containing the bottom of the ladder After using the ladder the player will end up in the square containing the top of the ladder She cannot leave the ladder in the middle of climbing And if the square containing the top of the ladder also contains the bottom of another ladder she is not allowed to use that second ladder The numbers on the faces of the dice are 1 2 3 4 5 and 6 with each number having the same probability of being shown Please note that it is possible for ladders to overlap but the player cannot switch to the other ladder while in the middle of climbing the first one it is possible for ladders to go straight to the top row but not any higher it is possible for two ladders to lead to the same tile it is possible for a ladder to lead to a tile that also has a ladder but the player will not be able to use that second ladder if she uses the first one the player can only climb up ladders not climb down Hyakugoku wants to finish the game as soon as possible Thus on each turn she chooses whether to climb the ladder or not optimally Help her to determine the minimum expected number of turns the game will take ,"['#include<bits/stdc++.h>\nusing namespace std;\nint p2i(int x, int y)\n{\n    if(x%2 == 0) return x*10+y;\n    return x*10+9-y;\n}\nint arr[10][10];\nint flatten[100];\ndouble dp[100];\nint main()\n{\n    for(int i=0; i<10; ++i)\n        for(int j=0; j<10; ++j)\n        {\n            scanf(""%d"", &arr[i][j]);\n            int c = p2i(i, j);\n            flatten[c] = -1;\n            if(arr[i][j])\n            {\n                int ni = i-arr[i][j];\n                int nj = j;\n                flatten[c] = p2i(ni, nj);\n            }\n        }\n    dp[0] = 0;\n    for(int i=1; i<100; ++i)\n    {\n        double ans = 0;\n        int pass = 0;\n        for(int j=1; j<=6; ++j)\n        {\n            if(j>i)\n            {\n                ++pass; continue;\n            }\n            int dest = i-j;\n            double cost = dp[dest];\n            \n            if(flatten[dest] != -1)\n                cost = min(cost, dp[flatten[dest]]);\n            ans += cost;\n        }\n        dp[i] = (ans+6)/(6-pass);\n    }\n    printf(""%.12f\\n"", dp[99]);\n}']","[0, 0, 0, 1, 0]",2300,To make implementation easier flatten the board into an array such that the th tile on the path is Define a function as follows if has no ladder otherwise where is such that the ladder from leads to Then do dp Define to be the minimum expected number of turns before the game ends when the player is at Then since is the Goal Next use the formula where if and otherwise Thus for transition should be And for transition is the same as the formula Answer is Alternatively instead of doing dp we can use numerical methods Initialize and Then repeat the following several times from to assign to After each iteration will get closer to the answer For this problem 1000 iterations is more than enough to get AC using this method 
You got a box with a combination lock The lock has a display showing digits There are two buttons on the box each button changes digits on the display You have quickly discovered that the first button adds 1 to all the digits all digits 9 become digits 0 and the second button shifts all the digits on the display one position to the right the last digit becomes the first one For example if the display is currently showing number then if we push the first button the display will show and if after that we push the second button the display will show You know that the lock will open if the display is showing the smallest possible number that can be obtained by pushing the buttons in some order The leading zeros are ignored while comparing numbers Now your task is to find the desired number ,"['#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cassert>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<fstream>\n#include<sstream>\n#include<iomanip>\n\n\nusing namespace std;\n\nint gcd(int a, int b)\n{\n    while (1)\n    {\n        a = a % b;\n        if (a == 0)\n            return b;\n        b = b % a;\n\n        if (b == 0)\n            return a;\n    }\n}\n\nconst int inf = 1e9;\ntypedef long long ll;\nset <string> ans;\n\nint main()\n{\n    //freopen(""in.txt"", ""r"", stdin);\n    //freopen(""a.txt"", ""w"", stdout);\n    int n;\n    cin >> n;\n    string tmp;\n    cin >> tmp;\n    for (int i = 0; i < tmp.size(); i++)\n    {\n        int u = tmp[i] - \'0\';\n        u = 10 - u;\n        string tmp2 = tmp;\n        for (int j = 0; j < tmp2.size(); j++)\n        {\n            tmp2[j] += u;\n            if (tmp2[j] - \'0\' >= 10) tmp2[j] -= 10;\n        }\n        string tmp3 = tmp2.substr(i) + tmp2.substr(0, i);\n        ans.insert(tmp3);\n    }\n    tmp = *ans.begin();\n    cout << tmp << endl;\n    //system(""pause"");\n    return 0;\n}']","[0, 0, 1, 0, 0]",1500,We observe that the order of operations is not important we may first perform all the shifts and after that all the additions Note that after shifts the sequence returns to its original state therefore it is sufficient to consider only the options with less than shifts Also after 10 times of adding 1 to all digits the sequence does not change we may consider only options with less than 10 additions Thus there are overall reasonable options for performing the operations for every option perform the operations and find the smallest answer among all the options As performing the operations for every option and comparing two answers to choose the best takes operations this solution performs about elementary operations The multiple of can be get rid of if we note that after all shifts are made the best choice is to make the first digit equal to zero and this leaves us but a single option for the number of additions However implementing this optimization is not necessary to get accepted Challenge can you solve the problem in time in time 
There is an unknown integer x 1 le x le n You want to find x At first you have a set of integers 1 2 ldots n You can perform the following operations no more than 10000 times a find how many numbers are multiples of a in the current set a find how many numbers are multiples of a in this set and then delete all multiples of a but x will never be deleted even if it is a multiple of a In this operation a must be greater than 1 a it means that you know that x a This operation can be only performed once Remember that in the operation of type a 1 must hold Write a program that will find the value of x ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define ff first\n#define ss second\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\n#define pb push_back\n#define FASTIO ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n#define endl \'\\n\'\n#define int long long\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<ll> vl;\ntypedef vector<pii> vpi;\ntypedef pair<ll,ll> pll;\ntypedef vector<string> vs;\ntypedef vector<pll> vpl;\ntypedef vector<int> vi;\n\n\nconst int N = 100100;\nvi primes;\nbool mark[N];\n  int n;\nvoid crivo(){\n\n  for(int i=2;i<=n;i++){\n    if(!mark[i]){\n      if(i<=n)primes.pb(i);\n      for(int j=2*i;j<=n;j+=i)mark[j]=1;\n    }\n  }\n\n}\n\nbool saiu[N];\n\nint askB(int p){\n  if(p > n)return 0;\n  cout <<\'B\' << "" ""<<p<<endl;\n  cout.flush();\n  int ans;\n  cin >> ans;\n  return ans;\n}\nint askA(int p){\n  if(p > n)return 0;\n  cout << ""A ""<<p<<endl;\n  cout.flush();\n  int ans;\n  cin >> ans;\n  return ans;\n}\n\nint get(int p){\n  int res=0;\n  for(int i=p;i<=n;i+=p){\n    if(saiu[i])continue;\n    res++;\n    saiu[i] = 1;\n  }\n  return res;\n}\nll getlog(ll x,ll mx){\n  ll r = 1;\n  ll p = x;\n  while(p * x<=mx){\n    p*=x;\n    r++;\n  }\n  return r;\n}\nint elevate(int p,int pwr){\n  int r = 1;\n  for(int i=0;i<pwr;i++)r*=p;\n  return r;\n}\n\nconst int sq = 100;\n\nint P=1;\n#define DB 0\nvoid solve(vi cur){\n  //if(DB)cout <<""ENTREI""<<endl;\n  for(int p : cur){\n    int x = askB(p);\n    if(x!=0){\n\n      int l = 2,r = getlog(p,n/P);\n      int res = 1;\n      while(l<=r){\n        int mid=(l+r)/2;\n        int per = askA(P * elevate(p,mid));\n        if(per!=0){\n          res = mid,l = mid + 1;\n        }else r = mid - 1;\n      }\n\n      P*=elevate(p,res);\n    }\n  }\n  \n}\n\nint32_t main(){\n  FASTIO;\n  cin>>n;\n  crivo();\n  \n  vi cur;\n  int fora = 0;\n  int i=0;\n  for(i=0;i<=sz(primes);i++){\n    if(i == sz(primes)){\n      \n    //  if(DB)cout<<""AQUI\\n"";\n\n      solve(cur);\n      break;\n    }\n    cur.pb(primes[i]);\n    int x = askB(primes[i]);\n    int s = get(primes[i]);\n    fora+=x;\n    if(s!=x){\n      solve(cur);\n      break;\n    }\n    if(sz(cur) == sq){\n      \n     // if(DB)cout <<""Aqui ... ""<<sz(cur)<<"" ""<<sq<<endl;\n\n      int A = askA(1);\n      if(A != n-fora){\n        solve(cur);\n        break;\n      }\n      cur.clear();\n    }\n  }\n  if(P == 1){\n    cout <<""C ""<<1<<endl;cout.flush();\n    return 0;\n  }\n  i++;\n  for(;i<sz(primes);i++){\n    int p = primes[i];\n    if(p<=1 || p > n)continue;\n    int per = askA(primes[i] * P);\n    if(per!=0){\n      int l = 2,r = getlog(p,n/P);\n      int res = 1;\n      while(l<=r){\n        int mid = (l+r)/2;\n        per = askA(elevate(p,mid) * P);\n        if(per!=0){\n          l = mid + 1;\n          res = mid;\n        }else r = mid - 1;\n      }\n\n\n      P *= elevate(p,res);\n    }\n  }\n\n  cout <<""C ""<<P<<endl;\n  cout.flush();\n  return 0;\n\n}']","[0, 1, 0, 0, 0]",2600,If we know what prime factors x has we can find just using bruteforce To find the prime factors we can just do for every prime in ascending order meanwhile calculate the numbers there supposed to be without if it differs with the number the interactor gives then contains the prime factor This way we can find every prime factor except for the smallest one Let be the number of primes no greater than Then we can split the prime numbers into groups After finishing asking a group ask and check if the return value same as it supposed to be without If it s the first time finding it different it means the smallest prime number is in the range then just check every prime numbers in the range by asking After finding the prime factors for each factor ask it can be proved this step will be done around times The total number of operations if around the total time complexity is 
You are given an array a consisting of n integer numbers Let of the array be the following value max limits i 1 n a i min limits i 1 n a i You have to remove element from this array to minimize of the resulting n 1 elements array Your task is to calculate the minimum possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define disp(x) cout<<x<<"" "";\ntypedef long long ll;\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define endl \'\\n\'\n#define show(x) cout<<x<<endl;\n#define rf(i,a,b) for(int i=a;i>=b;i--) \n#define pret(x) cout<<x<<endl; return 0;\n#define fast_io ios_base::sync_with_stdio(0);\n#define let(x,y) cout<<x<<"" ""<<y<<endl;\ntypedef vector<int> vi;\nll MOD=1e9+7;\nll MAX=9223372036854775807;\n\nint main(){\n\tfast_io;\n\tint n;\n\tcin>>n;\n\tint a[n];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin>>a[i];\n\t}\n\tsort(a,a+n);\n\tint ans=1e6;\n\tif(n==2){\n\t\tpret(0);\n\t}\n\tans=min(ans,a[n-1]-a[1]);\n\tans=min(ans,a[n-2]-a[0]);\n\tshow(ans);\n\treturn 0;\n}']","[0, 0, 1, 0, 0]",900,It is easy to see that we always have to remove either minimum or maximum of the array So we can sort the array and the answer will be We also can do it without sort because two minimal and two maximal elements of the array can be found in linear time 
Polycarp has three sisters Alice Barbara and Cerene They re collecting coins Currently Alice has a coins Barbara has b coins and Cerene has c coins Recently Polycarp has returned from the trip around the world and brought n coins He wants to distribute these n coins between his sisters in such a way that the number of coins Alice has is equal to the number of coins Barbara has and is equal to the number of coins Cerene has In other words if Polycarp gives A coins to Alice B coins to Barbara and C coins to Cerene A B C n then a A b B c C that A B or C the number of coins Polycarp gives to Alice Barbara and Cerene correspondingly can be 0 Your task is to find out if it is possible to distribute n coins between sisters in a way described above You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define PB push_back\n#define LL long long\n#define PII pair<int,int>\n#define FI first\n#define SE second\nconst int INF=0x3f3f3f3f;\nconst int N=1e6+7,mod=1e9+7;\nint n,m;\nint a[N];\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--){\n        int a[3];\n        scanf(""%d%d%d%d"",&a[0],&a[1],&a[2],&n);\n        sort(a,a+3);\n        if(a[2]-a[0]+a[2]-a[1]>n||(a[0]+a[1]+a[2]+n)%3!=0){\n            puts(""NO"");\n        }\n        else puts(""YES"");\n    }\n    return 0;\n}\n']","[0, 1, 0, 0, 0]",800,Suppose If it isn t true then let s rearrange our variables Then we need at least coins to make and equal So if then the answer is Otherwise the answer if if the number is divisible by This is true because after making and equal we need to distribute all remaining candies between three sisters 
Vasya s got a birthday coming up and his mom decided to give him an array of positive integers of length Vasya thinks that an array s beauty is the greatest common divisor of all its elements His mom of course wants to give him as beautiful an array as possible with largest possible beauty Unfortunately the shop has only one array left On the plus side the seller said that he could decrease some numbers in the array no more than by for each number The seller can obtain array from array if the following conditions hold for all Help mom find the maximum possible beauty of the array she will give to Vasya that seller can obtain ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\n#define M 1000000\n\nint K;\nint s[M+10];\n\nbool check(int p){\n    for(int x=0;x<=M;x+=p){\n        int ymax = min(x+p-1, M);\n        int ymin = ((x == 0) ? 1 : (x+K+1));\n        if(ymin <= ymax && s[ymin] < s[ymax+1]) return false;\n    }\n    return true;\n}\n\nint main(void){\n    int N,x,i;\n    \n    cin >> N >> K;\n    REP(i,N){\n        scanf(""%d"", &x);\n        s[x+1] = 1;\n    }\n    \n    REP(i,M+5) s[i+1] += s[i];\n    \n    for(i=M;i>=2;i--) if(check(i)) break;\n    cout << i << endl;\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 0]",2100,The problem was to find greatest such that holds for each Let then Let consider two cases In this case we will brute force answer from to We can check if number is a correct answer in the following way We have to check that for some fixed which is equals to where Since all these intervals doesn t intersects each with other we can just check that where count of numbers in the interval Time complexity proof is based on the sum of harmonic series 
Will shares a psychic connection with the Upside Down Monster so everything the monster knows Will knows Suddenly he started drawing page after page non stop Joyce his mom and Chief Hopper put the drawings together and they realized it s a labeled tree A tree is a connected acyclic graph Will s tree has vertices Joyce and Hopper don t know what that means so they re investigating this tree and similar trees For each such that they re going to investigate all labeled trees with vertices that share exactly edges with Will s tree Two labeled trees are different if and only if there s a pair of vertices such that there s an edge between and in one tree and not in the other one Hopper and Joyce want to know how much work they have to do so they asked you to tell them the number of labeled trees with vertices that share exactly edges with Will s tree for each The answer could be very large so they only asked you to tell them the answers modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=110;\nint n,u,v,gg[N][N];\nll f[N][N],ff[N];\nll det() {\n\tll ans=1;\n\trep(i,1,n) {\n\t\tbool fg=0;\n\t\trep(j,i,n) if (f[j][i]!=0) {\n\t\t\trep(k,i,n) swap(f[i][k],f[j][k]);\n\t\t\tif (j!=i) ans=-ans;\n\t\t\tfg=1;\n\t\t\tbreak;\n\t\t}\n\t\tif (!fg) return 0;\n\t\trep(j,i+1,n) {\n\t\t\tll tmp=-f[j][i]*powmod(f[i][i],mod-2)%mod;\n\t\t\trep(k,i,n) f[j][k]=(f[j][k]+tmp*f[i][k])%mod;\n\t\t}\n\t\t\n\t}\n\trep(i,1,n) ans=ans*f[i][i]%mod;\n\tif (ans<0) ans+=mod;\n\treturn ans;\n}\n\nll inv[N],g[N],c[N],w[N];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\t--u; --v;\n\t\tgg[u][v]=gg[v][u]=1;\n\t}\n\trep(x,0,n+1) {\n\t\trep(i,0,n) f[i][i]=0;\n\t\trep(i,0,n) rep(j,0,n) if (i!=j) {\n\t\t\tf[i][j]=-(gg[i][j]?x:1);\n\t\t\tf[i][i]-=f[i][j];\n\t\t}\n\t\tff[x]=det();\n\t}\n\tinv[0]=inv[1]=1;\n\tfor (int i=2;i<=n;i++) inv[i]=mod-(inv[mod%i]*(mod/i))%mod;\n\tg[0]=g[1]=1;\n\tfor (int i=2;i<=n;i++) g[i]=g[i-1]*inv[i]%mod;\n\tfor (int i=0;i<=n;i++) w[i]=powmod(i,n);\n\tfor (int i=n;i>=0;i--) {\n\t\tfor (int j=0;j<=i;j++) {\n\t\t\tif (j&1) {\n\t\t\t\tc[i]-=g[j]*g[i-j]%mod*ff[i-j]%mod;\n\t\t\t\tif (c[i]<0) c[i]+=mod;\n\t\t\t} else {\n\t\t\t\tc[i]+=g[j]*g[i-j]%mod*ff[i-j]%mod;\n\t\t\t\tif (c[i]>=mod) c[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor (int j=1;j<=n;j++) {\n\t\t\tff[j]-=c[i]*w[j]%mod;\n\t\t\tif (ff[j]<0) ff[j]+=mod;\n\t\t\tw[j]=w[j]*inv[j]%mod;\n\t\t}\n\t}\n\trep(i,0,n) printf(""%lld "",c[i]); puts("""");\n}\n']","[0, 1, 0, 1, 0]",2600,Solution 1 First for every such that we are going to find for every edges in the original tree we are going to find the number of labeled trees having these edges then we will add them all to But Mr Author aren t we going to count some tree that has exactly where common edges with the original tree in Yes that s true But we only count it times So after computing the res array we are going to iterate from to assuming that the res is correct for all our current iteration and then reduce the fixed res from Then we ll have the correct value for But Mr Author how are we going to find in the first place Let s first find out for a fixed edges forest in how ways we connect the remaining vertices to get a tree Let s look at the components in the forest Only their sizes are relevant because we can t connect anything inside them Let the sizes be if you assume that the sizes are all the number of resulting trees are Kayley s theorem To solve this subproblem let s go to another subproblem Let s assume that for every additional edge we know which components it is going to go connect Then the number of resulting trees is where is the degree of component edges between this component and other components The reason is that we have vertices inside component to give to every edge that has one endpoint in Ok going back to the parent subproblem huh I ve heard that vertex appears in the Prufer code of a tree times so we ve gotta multiply the answer by every time it appears in Prufer code It s also multiplied by because we haven t multiplied it one time not But how to make it get multiplied by every time component is chosen Look at this product If in the th parenthesis is chosen then let the th place on the Prufer code of the tree connecting the components be the component The good thing about this product is that if component has come in the Prufer code times then the multiplication of the parenthesis has in it So it counts exactly what we want to count is the answer for some fixed edges corresponds to in the original problem and corresponds to so we want to count Okay Mr Author so how do we count this for every fixed edges in the original tree Lets count which contains of every component inside s subtree which doesn t include s component and We can update this from s children Let s add s children one by one to the by assuming that the children we didn t go over don t exist in s subtree let s go over and we either fix the edge between and then it ll add to and otherwise it ll add to We can also divide it by at the end with modulo inverses We can find with the sum of with as a corner case The solution may look that it s because it s inside fors But it s actually if the and fors go until and actually only the subtree of that we ve iterated on So the cost is Let s look at it like every vertex from s subtree is handshaking with every vertex of s subtree and the cost of their handshaking is We know that two vertices handshake only once That s why it ll be which is of Solution 2 Let s define as the number of spanning trees of the graph plus copies of the original tree If we look at we ll see that it is actually because it has ways to choose which of the multiple edges it should choose for the common edges So the problem is to find s coefficients We can do that by polynomial interpolation if we have sample answers of Let s just get instances of for till We can find that using Kirchhoff s matrix tree theorem to find the number of spanning trees of a graph So the complexity is So we have an complexity This is how to do it in I don t know it yet I ll update it when I have it ready 
Seryozha conducts a course dedicated to building a map of heights of Stepanovo recreation center He laid a rectangle grid of size n times m cells on a map rows of grid are numbered from 1 to n from north to south and columns are numbered from 1 to m from west to east After that he measured the average height of each cell above Rybinsk sea level and obtained a matrix of heights of size n times m The cell i j lies on the intersection of the i th row and the j th column and has height h i j Seryozha is going to look at the result of his work in the browser The screen of Seryozha s laptop can fit a subrectangle of size a times b of matrix of heights 1 le a le n 1 le b le m Seryozha tries to decide how the weather can affect the recreation center for example if it rains where all the rainwater will gather To do so he is going to find the cell having minimum height among all cells that are shown on the screen of his laptop Help Seryozha to calculate the sum of heights of such cells for all possible subrectangles he can see on his screen In other words you have to calculate the sum of minimum heights in submatrices of size a times b with top left corners in i j over all 1 le i le n a 1 and 1 le j le m b 1 Consider the sequence g i g i 1 cdot x y bmod z You are given integers g 0 x y and z By miraculous coincidence h i j g i 1 cdot m j 1 i 1 cdot m j 1 is the index ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 3005;\n\nint tmp[N], q[N], h[N][N];\n\nint main() {\n    int n, m, a, b;\n    cin >> n >> m >> a >> b;\n    LL g, x, y, z;\n    cin >> g >> x >> y >> z;\n    for (int i = 0; i < n; i++) {\n        int head = 0, tail = -1;\n        for (int j = 0; j < m; j++) {\n            tmp[j] = g;\n            g = (g * x + y) % z;\n            while (head <= tail && tmp[q[tail]] > tmp[j]) --tail;\n            q[++tail] = j;\n            while (head <= tail && q[head] <= j-b) ++head;\n            if (j >= b-1) h[i][j-b+1] = tmp[q[head]];\n        }\n    }\n    LL res = 0;\n    for (int j = 0; j <= m-b; j++) {\n        int head = 0, tail = -1;\n        for (int i = 0; i < n; i++) {\n            while (head <= tail && h[q[tail]][j] > h[i][j]) --tail;\n            q[++tail] = i;\n            while (head <= tail && q[head] <= i-a) ++head;\n            if (i >= a-1) res += h[q[head]][j];\n        }\n    }\n    cout << res << endl;\n}']","[0, 0, 0, 0, 1]",2100,There is almost nothing to say about this problem It is pretty standard data structure problem Let be the minimum value over all values If is less than then its value does not matter for us because the corresponding submatrix is not counted in the answer These values can be calculated using or minimum queue You can read more about it here https cp algorithms com data structures stack queue modification html After building such matrix we can actually calculate the answer Let s iterate over all rows of the matrix starting from row and carry the floating window of width of values And when the size of the queue with minimums reaches we know the minimum on the corresponding submatrix that ends in the current element and we can add it to the answer Time complexity 
There are two binary strings a and b of length n a binary string is a string consisting of symbols 0 and 1 In an operation you select a prefix of a and simultaneously invert the bits in the prefix 0 changes to 1 and 1 changes to 0 and reverse the order of the bits in the prefix For example if a 001011 and you select the prefix of length 3 it becomes 011011 Then if you select the entire string it becomes 001001 Your task is to transform the string a into b in at most 2n operations It can be proved that it is always possible ,"['#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)(x).size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nconstexpr int pct(int x) { return __builtin_popcount(x); } \nconstexpr int bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\nll half(ll x) { return fdiv(x,2); }\n\ntemplate<class T, class U> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi);\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntemplate<class T, class U> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = half(lo+hi+1);\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntemplate<class T> void remDup(vector<T>& v) { \n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\nstr ts(bool b) { \n\t#ifdef LOCAL\n\t\treturn b ? ""true"" : ""false""; \n\t#else \n\t\treturn ts((int)b);\n\t#endif\n}\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) {\n\tstr res = ""{""; F0R(i,sz(v)) res += char(\'0\'+v[i]);\n\tres += ""}""; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = """"; F0R(i,SZ) res += char(\'0\'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\t#ifdef LOCAL\n\t\tbool fst = 1; str res = ""{"";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "", "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\tres += ""}""; return res;\n\t#else\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += "" "";\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\n\t#endif\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\t#ifdef LOCAL\n\t\treturn ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; \n\t#else\n\t\treturn ts(p.f)+"" ""+ts(p.s);\n\t#endif\n}\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(""\\n""); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr("" ""); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << ""]"" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << "", "";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n\t#define dbg(...) cerr << ""LINE("" << __LINE__ << "") -> ["" << #__VA_ARGS__ << ""]: ["", DBG(__VA_ARGS__)\n#else\n\t#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(str s) { freopen(s.c_str(),""r"",stdin); }\nvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(str s = """") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+"".in""), setOut(s+"".out""); } // for USACO\n}\n\nint n;\nstr a,b;\n\nvi nor(str& x) {\n\tvi res;\n\tint ind = 0;\n\twhile (1) {\n\t\twhile (ind < n-1 && x[ind] == x[ind+1]) ind ++;\n\t\tif (ind == n-1) return res;\n\t\tres.pb(ind+1);\n\t\tx[ind] = \'0\'+\'1\'-x[ind];\n\t}\n}\n\nvoid solve() {\n\tre(n); re(a,b);\n\tvi x = nor(a);\n\tvi y = nor(b);\n\tif (a[n-1] != b[n-1]) {\n\t\tx.pb(n);\n\t}\n\treverse(all(y)); trav(t,y) x.pb(t);\n\tpr(sz(x),\' \'); ps(x);\n}\n\nint main() {\n\tsetIO();\n\tint T; re(T);\n\tF0R(i,T) solve();\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n']","[0, 0, 1, 0, 1]",1700,There are several ways to solve the hard version as well Solution 1 Given an arbitrary binary string s we can make all bits 0 in at most n operations Simply scan the string from left to right If bits i and i 1 disagree apply the operation to the prefix of length i This is also easy to simulate in O n time We can make s all zeros in at most n operations and we can make t all zeros in at most n operations By reversing the order of the operations on t we have transformed s into t in at most 2n operations as desired Solution 2 Another approach is to optimize the simulation for solution 2 from the easy version You can do this with a data structure such as a balanced binary search tree in O nlogn time but there is no need Instead we can observe that after making the last k bits correct with our procedure the prefix of s of length n k will correspond to some segment of the original string s except it will be possibly flipped inverted and reversed So we need only keep track of the starting index of this segment and a flag for whether it is flipped Complexity is O n Solution 3 A third solution uses randomization to improve the number of operations from 3n in solution 1 of the easy version We can observe that in a random test case approximately half the bits of s will be mismatches with t Solution 1 in the easy version uses 3 operations per mismatch which is 3n 2 operations in expectation Obviously you don t get to decide that all test cases are random But you can spend a small number of operations initially flipping random prefixes to make the string more random If it doesn t work you can try again repeatedly Flipping random prefixes is a complicated process that might be hard to compute the exact probability But if the probability is p and we try to flip k prefixes randomly the time complexity is O k 1 n logp If you find a deterministic solution with a strictly lower ratio than 2 operations per bit we would love to hear about it 
Vova s family is building the Great Vova Wall named by Vova himself Vova s parents grandparents grand grandparents contributed to it Now it s totally up to Vova to put the finishing touches The current state of the wall can be respresented by a sequence a of n integers with a i being the height of the i th part of the wall Vova can only use 2 times 1 bricks to put in the wall he has infinite supply of them however Vova can put bricks on the neighboring parts of the wall of equal height It means that if for some i the current height of part i is the same as for part i 1 then Vova can put a brick there and thus increase both heights by 1 Obviously Vova can t put bricks in such a way that its parts turn out to be off the borders to the left of part 1 of the wall or to the right of part n of it Vova can also put bricks vertically That means increasing height of any part of the wall by 2 Vova is a perfectionist so he considers the wall completed when all parts of the wall has the same height the wall has no empty spaces inside it Can Vova complete the wall using any amount of bricks possibly zero ,"['#include<cstdio>\nint m;\nint a[200000];\nint main(){\n    int n;\n    scanf(""%d"",&n);\n    int v1=0,v2=0;\n    for(int i=0;i<n;i++){\n        int x;\n        scanf(""%d"",&x);\n        if(x&1){\n            if(i&1)v1++;\n            else v1--;\n        }\n        else{\n            if(i&1)v2++;\n            else v2--;\n        }\n    }\n    puts((v1==0||v2==0)?""YES"":""NO"");\n    return 0;\n}\n']","[1, 1, 1, 0, 0]",2200,Fairly enough solutions of both versions of the problem are pretty similar The major difference between them are the vertical bricks As you aren t required to minimize the total height you can work not with the heights themselves but with their parities instead Vertical brick now does nothing and horizontal brick changes the parity of neighbouring parts of the same parity Now imagine the following greedy solution While you have some segment of the same parities of even length fill it with horizontal bricks This operation merges this segment with one to the left and to the right If there is a single segment left then the answer is Otherwise it s The proof is left to the readers Implementing this as it is will be at best You ll need to keep the whole set of segments and the set with only even length ones But there exists more fun approach We don t even need the lengths of the segments just the parities of the lengths Then merging the even segment with something will just erase that segment and xor the length of the left and right ones Moreover you don t even need to erase the whole even segment you can do it brick by brick as this operations are now the same Let s simulate this with a stack When the new number comes push its parity to the stack If the topmost two elements of the stack have the same parity pop them both Now the answer is if at the end stack has no more than one element When I heard of this problem I actually had not that stack itself in mind but the correct bracket sequences Like let s define parity 0 as and and parity 1 as and Now the operations we perform with stack are greedily put the closing bracket if the last unclosed bracket was of the same type and put opening otherwise Then the stack will have like all the brackets which are still to be closed and you ll close them as early as you can This idea helped to both prove the correctness of algo and implement it Overall complexity 
The Berland National team takes part in the local Football championship which now has a group stage Let s describe the formal rules of the local championship the team that kicked most balls in the enemy s goal area wins the game the victory gives 3 point to the team the draw gives 1 point and the defeat gives 0 points a group consists of four teams the teams are ranked by the results of six games each team plays exactly once with each other team the teams that get places 1 and 2 in the group stage results go to the next stage of the championship In the group stage the team s place is defined by the total number of scored points the more points the higher the place is If two or more teams have the same number of points then the following criteria are used the criteria are listed in the order of falling priority starting from the most important one the difference between the total number of scored goals and the total number of missed goals in the championship the team with a higher value gets a higher place the total number of scored goals in the championship the team with a higher value gets a higher place the lexicographical order of the name of the teams countries the country with the lexicographically smaller name gets a higher place The Berland team plays in the group where the results of 5 out of 6 games are already known To be exact there is the last game left There the Berand national team plays with some other team The coach asks you to find such score where is the number of goals Berland scored and is the number of goals the opponent scored in the game that fulfills the following conditions that is Berland is going to win this game after the game Berland gets the 1st or the 2nd place in the group if there are multiple variants you should choose such score where value is minimum if it is still impossible to come up with one score you should choose the score where value the number of goals Berland misses is minimum ,"['#include<stdio.h>\n#include<map>\n#include<string.h>\n#include<set>\n#include<string>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nmap<string,int> points;\nmap<string,int> goals;\nmap<string,int> misses;\nset<string> playedWithBerland;\nvoid parseS(char *t1,char *t2,int p1,int p2)\n{\n\tif(p1>p2)\n\t{\n\t\tpoints[t1]+=3;\n\t}\n\telse if(p2>p1)\n\t{\n\t\tpoints[t2]+=3;\n\t}\n\telse \n\t{\n\t\tpoints[t1]+=1;\n\t\tpoints[t2]+=1;\n\t}\n\tif(!strcmp(t1,""BERLAND""))\n\t{\n\t\tplayedWithBerland.insert(t2);\n\t}\n\n\tif(!strcmp(t2,""BERLAND""))\n\t{\n\t\tplayedWithBerland.insert(t1);\n\t}\n\n\tgoals[t1]+=p1;\n\tgoals[t2]+=p2;\n\tmisses[t1]+=p2;\n\tmisses[t2]+=p1;\n\n}\nchar s1[100];\nchar s2[100];\nint p1;\nint p2;\nchar s[1000];\nstruct cntr\n{\n\tstring name;\n\tint points;\n\tint misses;\n\tint goals;\n};\nbool cmp(cntr &c1, cntr &c2)\n{\n\treturn c1.points>c2.points ||  \n\t\tc1.points==c2.points && c1.goals-c1.misses>c2.goals-c2.misses ||\n\t\tc1.points==c2.points && c1.goals-c1.misses == c2.goals-c2.misses && c1.goals>c2.goals ||\n\t\tc1.points==c2.points && c1.goals-c1.misses == c2.goals-c2.misses && c1.goals==c2.goals && c1.name<c2.name;\n\n\t\t \n}\nbool ifok(vector<cntr> & C)\n{\n\tsort(C.begin(),C.end(),cmp);\n\treturn C[0].name==""BERLAND"" || C[1].name==""BERLAND"";\n}\nint main()\n{\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tgets(s);\n\t\tsscanf(s,""%s %s %d:%d"",s1,s2,&p1,&p2);\n\t\tparseS(s1,s2,p1,p2);\n\t}\n\n\tstring defC;\n\tfor(map<string,int>::iterator it=points.begin();it!=points.end();it++)\n\t{\n\t\tif(it->first!=""BERLAND"" && playedWithBerland.find(it->first)==playedWithBerland.end())\n\t\t{\n\t\t\tdefC=it->first;\n\t\t}\n\t}\n\tpoints[""BERLAND""]+=3;\n\tvector<pair<int,int> > goodSc;\n\tfor(int dx=1;dx<100;dx++)\n\t{\n\t\tfor(int Y=0;Y<100;Y++)\n\t\t{\n\t\t\tint X=Y+dx;\n\t\t\tgoals[defC]+=Y;\n\t\t\tgoals[""BERLAND""]+=X;\n\t\t\tmisses[defC]+=X;\n\t\t\tmisses[""BERLAND""]+=Y;\n\t\t\tvector<cntr> C;\n\t\t\tfor(map<string,int>::iterator it=points.begin();it!=points.end();it++)\n\t\t\t{\n\t\t\t\tcntr c1;\n\t\t\t\tc1.name=it->first;\n\t\t\t\tc1.misses=misses[it->first];\n\t\t\t\tc1.goals=goals[it->first];\n\t\t\t\tc1.points=points[it->first];\n\t\t\t\tC.push_back(c1);\n\t\t\t}\n\t\n\t\t\tif(ifok(C))\n\t\t\t{\n\t\t\t\tprintf(""%d:%d"",X,Y);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tgoals[defC]-=Y;\n\t\t\tgoals[""BERLAND""]-=X;\n\t\t\tmisses[defC]-=X;\n\t\t\tmisses[""BERLAND""]-=Y;\n\t\t}\n\t}\n\tprintf(""IMPOSSIBLE\\n"");\n\n}']","[0, 0, 1, 0, 0]",1800,In this problem was given description of the group stage of some football competition and scoring system There were given results of all matches excepting one and you had to find result of the last match satisfied some given criterias Also Berland s team must be first or the second team of the group after than match Lets note that in each finished match were not greater than 18 goals It means that we can brute force all results of the last match when score is not greater than 200 goals and find the best one One of the easiest way is to fill table to the end it means to change points value and balls value than to sort teams according to the given rules and to check that Berland is the first or the second team of the group 
Consider a number axis The capital of your empire is initially at 0 There are n unconquered kingdoms at positions 0 x 1 x 2 ldots x n You want to conquer all other kingdoms There are two actions available to you You can change the location of your capital let its current position be c 1 to any other kingdom let its position be c 2 at a cost of a cdot c 1 c 2 From the current capital let its current position be c 1 you can conquer an unconquered kingdom let its position be c 2 at a cost of b cdot c 1 c 2 You conquer a kingdom if there is an unconquered kingdom between the target and your capital Note that you place the capital at a point without a kingdom In other words at any point your capital can only be at 0 or one of x 1 x 2 ldots x n Also note that conquering a kingdom does not change the position of your capital Find the minimum total cost to conquer all kingdoms Your capital can be anywhere at the end ,"['#include<iostream>\nusing namespace std;\nint a[200010];\nlong long sum[200010];\nint main() {\n\tios::sync_with_stdio(false);\n\tint T;\n\tcin>>T;\n\twhile(T--) {\n\t\tint n,x,y;\n\t\tcin>>n>>x>>y;\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tcin>>a[i];\n\t\t\tsum[i]=sum[i-1]+a[i];\n\t\t}\n\t\tlong long ans=1e18,s=0;\n\t\tfor(int i=0; i<=n; i++) {\n\t\t\tif(i) {\n\t\t\t\ts+=a[i]-a[i-1];\n\t\t\t}\n\t\t\tans=min(ans,(long long)x*a[i]+y*(sum[n]-sum[i]-(long long)a[i]*(n-i)+s));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n']","[1, 1, 1, 1, 0]",1500,Clearly we should always move from left to right Also assume for simplicity Let us analyze what our cost would look like It will be composed of a part due to moving capitals and a part due to conquering kingdoms If we shift our capital from to the cost is If we conquer kingdoms from with capital the cost is which can be written as where Now notice that and are linear Also if we isolate the parts involving the sum will be like This means we can simply write the final sum of this part as where is the final position of the capital We can say the same thing about except that the final kingdom conquered is always So the final sum of this part is always so they weren t written explicitly Our final cost then looks like where is composed of terms like If we want to minimise we want to maximise That is achieved if we always increase Then we can write We cannot increase beyond since that is the final position of our capital Hence our final answer is given by Time complexity 
In the fourth labor of Rostam the legendary hero from the Shahnameh an old witch has created a magical maze to trap him The maze is a rectangular grid consisting of n rows and m columns Each cell in the maze points in a specific direction up down left or right The witch has enchanted Rostam so that whenever he is in a cell he will move to the next cell in the direction indicated by that cell If Rostam eventually exits the maze he will be freed from the witch s enchantment and will defeat her However if he remains trapped within the maze forever he will never escape The witch has not yet determined the directions for all the cells She wants to assign directions to the unspecified cells in such a way that the number of starting cells from which Rostam will be trapped forever is maximized Your task is to find the maximum number of starting cells which make Rostam trapped ,"[""#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7;int n, m;string s[N];int P(int x, int y) {\treturn (x - 1) * m + y;}int dt[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};map<char,int>mp;int go[N];vi e[N];int vis[N];void dfs(int x) {\tfor(auto v : e[x]) {\t\tvis[v] = 1;\t\tdfs(v);\t}}void Main() {\tcin >> n >> m;\tL(i, 1, n) {\t\tcin >> s[i];\t\ts[i].insert(s[i].begin(), ' ');\t}\tL(i, 1, n * m) vis[i] = 0;\tL(i, 1, n) {\t\tL(j, 1, m) {\t\t\tgo[P(i, j)] = -1;\t\t\tif(s[i][j] != '?') {\t\t\t\tint d = mp[s[i][j]];\t\t\t\tint ni = i + dt[d][0];\t\t\t\tint nj = j + dt[d][1];\t\t\t\tif(1 <= ni && ni <= n && 1 <= nj && nj <= m) {\t\t\t\t\tgo[P(i, j)] = P(ni, nj);\t\t\t\t} else {\t\t\t\t\tgo[P(i, j)] = 0;\t\t\t\t}\t\t\t\te[go[P(i, j)]].pb(P(i, j));\t\t\t}\t\t}\t}\tdfs(0);\tint ans = 0;\tL(i, 1, n) L(j, 1, m) {\t\tif(s[i][j] != '?') {\t\t\tans += !vis[P(i, j)];\t\t} else {\t\t\tint win = 1;\t\t\tL(d, 0, 3) {\t\t\t\tint ni = i + dt[d][0];\t\t\t\tint nj = j + dt[d][1];\t\t\t\tif(1 <= ni && ni <= n && 1 <= nj && nj <= m) {\t\t\t\t\twin &= vis[P(ni, nj)];\t\t\t\t} \t\t\t}\t\t\tif(!win) ans += 1;\t\t}\t}\tcout << ans << '\\n';\tL(i, 0, n * m) e[i].clear();}int main() {\tmp['D']=0;\tmp['U']=1;\tmp['R']=2;\tmp['L']=3;\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tint t; cin >> t; while(t--) Main();\treturn 0;}""]","[0, 0, 1, 0, 0]",1400,Solution If a cell has a fixed direction i e it points to another cell and following that direction leads outside the maze it must eventually exit the maze Such cells cannot be part of any loop We can analyze the remaining cells once we identify cells that lead out of the maze Any undirected cell or cell might either lead to the exit or form part of a loop If all neighboring cells of a cell can eventually lead out of the maze then this cell will also lead out of the maze The state of such cells can be determined based on their surroundings For any remaining cells directed cells that do not lead out of the maze or other cells that cannot be determined to lead to an exit we can assign directions such that starting from those cells will eventually lead to a loop These cells will form the loops To find how many cells will eventually lead to a loop we can use a Depth First Search DFS on the reversed graph where all directions are reversed By performing DFS starting from the out of maze cells we can identify all cells that are reachable from the outside and thus will eventually lead out of the maze Count the number of cells that can reach the exit Subtract this number from the total number of cells in the maze to determine how many are part of loops i e cells that cannot reach the exit 
There is a matrix of size filled with integers For every Obviously every integer from occurs exactly once in this matrix You have traversed some path in this matrix Your path can be described as a sequence of visited cells denoting that you started in the cell containing the number then moved to the cell with the number and so on From the cell located in th line and th column we denote this cell as you can move into one of the following cells only if only if only if only if Notice that making a move requires you to go to an adjacent cell It is not allowed to stay in the same cell You don t know and exactly but you have to find any possible values for these numbers such that you could start in the cell containing the integer then move to the cell containing in one step then move to the cell containing also in one step and so on Can you choose and so that they don t contradict with your sequence of moves ,"['#include<bits/stdc++.h>\n#define MN 200005\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n    while(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n    return x*f;\n}\nint n,M,mx,a[MN];\nint main()\n{\n\tregister int i,x,y;\n\tn=read();\n\tfor (i=1;i<=n;++i) mx=max(mx,a[i]=read());\n\tfor (i=2;i<=n;++i)\n\t\tif ((y=abs(a[i]-a[i-1]))>1)\n\t\t\tif (M) {if (M!=y) return 0*printf(""NO"");}\n\t\t\telse M=y;\n\t\telse if (y==0) return 0*printf(""NO"");\n\tif (!M) return 0*printf(""YES\\n1 %d"",mx);\n\tfor (i=2;i<=n;++i)\n\t\tif (abs(a[i]-a[i-1])==1)\n\t\t\tif (min(a[i],a[i-1])%M==0) return 0*printf(""NO"");\n\tputs(""YES"");\n\tprintf(""%d %d"",(mx-1)/M+1,M);\n}']","[0, 0, 1, 0, 0]",1700,You can notice that moves of kind and are changing value to and Thus you can determine by checking adjacent nodes in the path The answer is if there are one or zero distinct values of differences not counting difference of You can also set to arbitrary big value it doesn t really matter until you can fit all values will work just fine Finally knowing and simulate the process and check that all moves are valid Overall complexity 
Those unwilling to return home from a long journey will be affected by the oddity of the snail and lose their way Mayoi the oddity s carrier wouldn t like this to happen but there s nothing to do with this before a cure is figured out For now she would only like to know the enormous number of possibilities to be faced with if someone gets lost There are towns in the region numbered from to The town numbered is called the capital The traffic network is formed by bidirectional roads connecting pairs of towns No two roads connect the same pair of towns and no road connects a town with itself The time needed to travel through each of the roads is the same Lost travelers will not be able to find out how the towns are connected but the residents can help them by providing the following facts Starting from each town other than the capital the shortest path i e the path passing through the minimum number of roads to the capital exists and is unique Let be the number of roads on the shortest path from town to the capital then holds for all For town the number of roads connected to it is denoted by which equals either or You are to count the number of different ways in which the towns are connected and give the answer modulo Two ways of connecting towns are considered different if a pair exists such there is a road between towns and in one of them but not in the other ,"['/*\n\n         o###########oo\n      o##""          """"##o\n    o#""                ""##\n  o#""                    ""#o\n #""  ##              ##   ""##\n#""                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n""#o                         ##\n ""#o                       ##\n  ""#o                    o#""\n   ""#o                  ##\n     ""#o              o#""\n       ""#ooo      ooo#######oo\n        ###############   ""######o\n     o###""""        ""###o      # ###\n   o###o     oooo    ###    oo####""\n o###**#     #**#   ############""\n """"##""""""""""""""""""""###########    #\n    # oooooooo#""#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##""   """"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##""  """"#############""""     ##****###\n##""         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              """"###\n ###\n  ###\n*/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef long double ld;\n\ntypedef vector<vector<ll> > matrix;\n\nmatrix mul(matrix a, matrix b){\n    matrix c;\n    c.resize(a.size());\n    for (int i = 0; i < c.size(); i++)\n        c[i].resize(b[0].size(), 0);\n    for (int i = 0; i < c.size(); i++)\n        for (int j = 0; j < c[i].size(); j++)\n            for (int k = 0; k < b.size(); k++)\n                c[i][j] = (c[i][j] + a[i][k] * b[k][j]);\n    return c;\n}\n\nmatrix def;\n\nmatrix bpow(matrix a, ll st){\n    if (st == 0)\n        return def;\n    if (st == 1)\n        return a;\n    matrix b = bpow(a, st >> 1);\n    b = mul(b, b);\n    if (st & 1)\n        b = mul(a, b);\n    return b;\n}\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MOD = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MOD;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nll sqr(ll x){\n    return x * x;\n}\n\nconst ll llinf = 2e18;\n\nconst ld EPS = 1e-9;\n\nconst int maxn = 2e5 + 100, inf = 1e9 + 100, mod = 1e9 + 7;\n\nll md(ll x){\n    return x % mod;\n}\n\nint n;\n\nint d[maxn];\n\nll sq[55][55][55][55];\n\nll q[55][55];\n\nll bpow(ll x, ll y){\n    if (y == 0)\n        return 1;\n    if (y == 1)\n        return x;\n    ll ret = bpow(x, y >> 1);\n    ret = md(ret * ret);\n    if (y & 1)\n        ret = md(ret * x);\n    return ret;\n}\n\nll bdiv(ll x, ll y){\n    return md(x * bpow(y, mod - 2));\n}\n\nll fact[55];\n\nvoid prefact(){\n    fact[0] = 1;\n    for (ll i = 1; i <= n; i++)\n        fact[i] = md(fact[i - 1] * i);\n}\n\nvoid presq(){\n    for (int l = 1; l < n; l++){\n        if (d[l] == 3)\n            sq[l][l][2][1] = 1;\n        else\n            sq[l][l][1][0] = 1;\n        for (int r = l; r < n - 1; r++)\n            for (int k = 0; k <= (r - l + 1) * 2; k++)\n                for (int db = 0; db <= r - l + 1; db++)\n                if (sq[l][r][k][db] != 0){\n                    ll val = sq[l][r][k][db];\n                    if (d[r + 1] == 2){\n                        sq[l][r + 1][k + 1][db] = md(sq[l][r + 1][k + 1][db] + val);\n                        if (db > 0)\n                            sq[l][r + 1][k - 1][db - 1] = md(sq[l][r + 1][k - 1][db - 1] + val * db);\n                        if (k - 2 * db > 0)\n                            sq[l][r + 1][k - 1][db] = md(sq[l][r + 1][k - 1][db] + val * (k - 2 * db));\n                    }\n                    else{\n                        sq[l][r + 1][k + 2][db + 1] = md(sq[l][r + 1][k + 2][db + 1] + val);\n                        if (db > 0)\n                            sq[l][r + 1][k][db - 1] = md(sq[l][r + 1][k][db - 1] + val * db);\n                        if (k - 2 * db > 0)\n                            sq[l][r + 1][k][db] = md(sq[l][r + 1][k][db] + val * (k - 2 * db));\n                        if (k - 2 * db > 1)\n                            sq[l][r + 1][k - 2][db] = md(sq[l][r + 1][k - 2][db] + val * (k - 2 * db) * (k - 2 * db - 1) / 2);\n                        if (k - 2 * db > 0 && db > 0)\n                            sq[l][r + 1][k - 2][db - 1] = md(sq[l][r + 1][k - 2][db - 1] + val * (k - 2 * db) * db);\n                        if (db > 1)\n                            sq[l][r + 1][k - 2][db - 2] = md(sq[l][r + 1][k - 2][db - 2] + val * db * (db - 1) / 2);\n                    }\n                }\n    }\n}\n\nvoid preq(){\n    if (d[0] == 2)\n        q[1][2] = 1;\n    else\n        q[1][3] = 1;\n    for (int r = 2; r < n; r++)\n        for (int l = 1; l <= r; l++)\n        if (q[l][r] > 0)\n            for (int k = 0; k <= (r - l + 1) * 2; k++)\n                for (int db = 0; db <= r - l + 1; db++)\n                    if (r + k < n)\n                        q[r + 1][r + k] = md(q[r + 1][r + k] + bdiv(md(md(q[l][r] * sq[l][r][k][db]) * fact[k]), bpow(2, db)));\n}\n\nint main()\n{\n    #ifdef ONPC\n    ifstream cin(""a.in"");\n    ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #else\n    //ifstream cin(""a.in"");\n    //ofstream cout(""a.out"");\n    //freopen(""a.in"", ""r"", stdin);\n    //freopen(""a.out"", ""w"", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        cin >> d[i];\n    if (d[0] == 3 && n == 3){\n        cout << 0;\n        return 0;\n    }\n    prefact();\n    presq();\n    preq();\n    ll answer = 0;\n    for (int l = 1; l < n; l++)\n        answer = md(answer + q[l][n - 1] * sq[l][n - 1][0][0]);\n    cout << answer;\n}\n']","[0, 0, 0, 1, 0]",2600,Let s make it intuitive the graph looks like this Formally if we find out the BFS levels of the graph it will look like a tree with extra edges among vertices of the same level and indices of vertices in the same level form a consecutive interval Therefore we can add vertices from number to number to the graph without missing or violating anything Consider the case when we want to add vertex to a graph formed by the first vertices The state only depend on the current and the previous level We can t start level without finishing level thus there are only two unfinished levels The whole thing is described by four parameters the number of 1 plug having one outgoing edge that is not determined and 2 plug similar definition vertices in the previous and the current level Let be the number of ways to build the graph with the first vertices with 1 plug vertices and 2 plug vertices in the previous level and and in the current one respectively For vertex we must choose one vertex in the previous layer and connect to it For the remaining degree s of we can choose either to connect them to vertices in the same layer or simply leave them for future Also we may start a new level if This gives us an recursion There are states giving us a time complexity of and a space complexity of if the first dimension is reused The constant factor can be rather small since See solution 1 for detailed recursion Let s try to improve this a bit Instead of adding one vertex at a time we consider the layer as a whole Let be the number of ways to build a single level with vertices their plugs don t matter and connect it to the previous layer which has 1 plug vertices and 2 plug ones Recursion over can be done in Then let be the number of ways to build the graph with vertices from to while vertices from to form the first level note that this level should be connected to another previous one The recursion over can be done in The final answer should be since the capital must be directly connected to vertices from to The overall time complexity is Huge thanks to Nikolay Kalinin KAN for this Figure out the solution P 
The Squareland national forest is divided into equal 1 times 1 square plots aligned with north south and east west directions Each plot can be uniquely described by integer Cartesian coordinates x y of its south west corner Three friends Alice Bob and Charlie are going to buy three distinct plots of land A B C in the forest Initially all plots in the forest including the plots A B C are covered by trees The friends want to visit each other so they want to clean some of the plots from trees After cleaning one should be able to reach any of the plots A B C from any other one of those by moving through adjacent cleared plots Two plots are adjacent if they share a side Of course the friends don t want to strain too much Help them find out the smallest number of plots they need to clean from trees ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int xs[3], ys[3];\n  for (int i = 0; i < 3; ++i)\n    cin >> xs[i] >> ys[i];\n\n  int x1 = -1, y1 = -1;\n  const int M = 1024;\n  int ans = 1e9;\n\n  for (int x = 0; x <= M; ++x)\n    for (int y = 0; y <= M; ++y) {\n      int cand = 0;\n      for (int i = 0; i < 3; ++i)\n        cand += abs(xs[i] - x) + abs(ys[i] - y);\n      if (ans > cand) {\n        mini(ans, cand);\n        x1 = x; y1 = y;\n      }\n    }\n\n  set<PII> s;\n  for (int i = 0; i < 3; ++i) {\n    int x = x1, y = y1;\n    s.emplace(x, y);\n    while (x != xs[i]) {\n      if (x > xs[i]) { --x; } else { ++x; }\n      s.emplace(x, y);\n    }\n    while (y != ys[i]) {\n      if (y > ys[i]) { --y; } else { ++y; }\n      s.emplace(x, y);\n    }\n    debug(x, y, x1, y1);\n  }\n\n  cout << SZ(s) << ""\\n"";\n  for (auto [x, y] : s)\n    cout << x << "" "" << y << ""\\n"";\n}\n\n']","[1, 0, 1, 0, 0]",1600,The smallest possible number of plots required to connect all three plots is at least where and here are extreme coordinate values among the three given plots It now suffices to find any suitable collection of plots of this size Let and be the median values of and For each of the plots connect it with the plot with any shortest path if one of coincides with just do nothing One can check that the resulting collection has size exactly and it clearly connects and together The above solution has complexity where is the largest coordinate value Given that is quite small one could go with slower solutions for instance instead of try all plots as the connecting plot 
During the break the schoolchildren boys and girls formed a queue of people in the canteen Initially the children stood in the order they entered the canteen However after a while the boys started feeling awkward for standing in front of the girls in the queue and they started letting the girls move forward each second Let s describe the process more precisely Let s say that the positions in the queue are sequentially numbered by integers from to at that the person in the position number is served first Then if at time a boy stands on the th position and a girl stands on the th position then at time the th position will have a girl and the th position will have a boy The time is given in seconds You ve got the initial position of the children at the initial moment of time Determine the way the queue is going to look after seconds ,"[""#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\nconst int BIGINT = 0x0FFFFFFF;\nconst ll BIGLL = 0x0FFFFFFFFFFFFFFFll;\nconst int MAXN = 1005;\n\n\nint n,t;\nstring s;\n\nint main()\n{\n    cin>>n>>t;\n    cin>>s;\n\n    while(t--)\n    {\n        for(int i=0;i<n-1;i++)\n            if( s[i]=='B' && s[i+1]=='G')\n            {\n                swap(s[i],s[i+1]);\n                i++;\n            }\n    }\n\n    cout << s << '\\n';\n\n    \n    return 0;\n}""]","[0, 0, 1, 0, 0]",800,In this you should realize the given process You should times swap elements and if on the place was a girl and on the place was a boy You should not push some girl to the left multiple times at once The solution can be written using time 
You are given a permutation p 1 p 2 dots p n Recall that sequence of n integers is called a if it contains all integers from 1 to n exactly once Find three indices i j and k such that 1 le i j k le n p i p j and p j p k Or say that there are no such indices ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        int N; cin >> N;\n        int A[N]; F0R(i, N) cin >> A[i];\n\n        int L = 0, R = N-1;\n        F0Rd(i, N) {\n            if (A[L] == i+1) {\n                L++;\n            } else if (A[R] == i+1) {\n                R--;\n            } else {\n                int P;\n                F0R(j, N) {\n                    if (A[j] == i+1) {\n                        P = j;\n                    }\n                }\n                cout << ""YES"" << nl;\n                cout << L+1 << "" "" << P+1 << "" "" << R+1 << nl;\n                goto done;\n            }\n        }\n        cout << ""NO"" << nl;\n        done:\n        ;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[0, 0, 0, 0, 1]",900,A solution in iterate on check that there exists an element lower than to the left of it and check that there exists an element lower than to the right of it Can be optimized to with prefix suffix minima A solution in note that if there is some answer we can find an index such that and if there is no such triple the array descends to some point and ascends after that so there is no answer So we only have to check consecutive triples 
A MIPT student named Misha has a birthday today and he decided to celebrate it in his country house in suburban Moscow friends came by and after a typical party they decided to play blind man s buff The birthday boy gets blindfolded and the other players scatter around the house The game is played in several rounds In each round Misha catches exactly one of his friends and has to guess who it is The probability of catching the th friend does not change between rounds and is equal to percent as we know it is directly proportional to the amount of alcohol consumed by the th friend and holds Misha has no information about who he caught After Misha makes an attempt to guess the caught person the round ends Even then Misha isn t told whether he guessed correctly and a new round begins The game ends when Misha guesses every friend at least once that is there exists such set of rounds that during round number Misha caught the th friend and guessed him Misha wants to minimize the expectation of the number of rounds of the game Despite the fact that at any point in the game Misha has no information about who he has already guessed his friends are honest and if they see that the condition for the end of the game is fulfilled the game ends immediately Find the expectation of the number of rounds in the game if Misha plays optimally ,"['#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 101;\n\nint N;\nint rval[MAXN];\ndouble cprob[MAXN];\npriority_queue <pair <double, int> > pq;\n\nint main()\n{\n    cin >> N;\n    for (int i = 0; i < N; i++)\n        cin >> rval[i];\n    \n    for (int i = 0; i < N; i++)\n    {\n        pq.push (make_pair (1e9, i));\n        cprob[i] = 0;\n    }\n    \n    double ans = 0, tot = 0;\n    for (int i = 1; i <= 3e6; i++)\n    {\n        pair <double, int> ptop = pq.top();\n        pq.pop();\n        \n        double rrate = ptop.first;\n        int rloc = ptop.second;\n        \n        cprob[rloc] += rval[rloc] / 100. * (1 - cprob[rloc]);\n        \n        if (rrate > 1e8)\n        {\n            tot = 1.;\n            for (int j = 0; j < N; j++)\n                tot *= cprob[j];\n            ans += tot * i;\n        }\n        else\n        {\n            ans += (rrate - 1) * tot * i;\n            tot *= rrate;\n        }\n        \n        double nadd = rval[rloc] / 100. * (1 - cprob[rloc]);\n        pq.push (make_pair (nadd / cprob[rloc] + 1, rloc));\n    }\n    \n    cout << fixed << setprecision(8);\n    cout << ans << ""\\n"";\n    //system (""Pause"");\n    return 0;\n}\n']","[1, 1, 0, 0, 0]",2700,Let s denote Main idea first of all guess each friend once then maximize probability to end game on current step Let s simulate first 300000 steps and calculate where how many times we called th friend Expectation with some precision equals So it is enough to prove that 1 Greedy strategy gives maximum values for all 2 On 300000 step precision error will be less than Proof 1 Suppose that for some there exists set not equal to set produced by greedy algorithm gives the maximum value of Let s take some and it is easy to prove tgat if we change to to then new set of gives bigger value of contradiction 2 Let s take set it gives probability of end of the game not less than optimal Then Precision error does not exceed It could be estimated as sum of geometric progression If precision error doesn t exceed 
You are given a string s Each character is either or You want all s in the string to form a contiguous subsegment For example if the string is or then all s form a contiguous subsegment and if the string is or then this condition is not met You may erase some possibly none s from the string What is the minimum number of s that you have to erase ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tint l=0, r=s.size()-1;\n\t\twhile(l<s.size()&&s[l]==\'0\')\n\t\t\t++l;\n\t\twhile(~r&&s[r]==\'0\')\n\t\t\t--r;\n\t\tint c=0;\n\t\tfor(int i=l; i<=r; ++i)\n\t\t\tc+=s[i]!=\'1\';\n\t\tcout << c << ""\\n"";\n\t}\n}']","[0, 0, 1, 0, 0]",800,Let s find the first and the last position of characters denote them as and respectively Since the can t delete characters all characters between and will remain So we have to delete all characters between and 
people are standing in a line to play table tennis At first the first two players in the line play a game Then the loser goes to the end of the line and the winner plays with the next person from the line and so on They play until someone wins games in a row This player becomes the winner For each of the participants you know the power to play table tennis and for all players these values are different In a game the player with greater power always wins Determine who will be the winner ,"['#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define FORE(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\nconst int N = 1000;\nint n;\nlong long k;\nint a[N],win[N];\n\nint main() {\n  scanf(""%d%I64d"",&n,&k);\n  REP(i,n) {\n    scanf(""%d"", &a[i]); --a[i];\n  }\n  while (true) {\n    if (a[1] > a[0]) { swap(a[1], a[0]); }\n    if (++win[a[0]] >= k || a[0] == n-1) { printf(""%d\\n"", a[0]+1); return 0; }\n    rotate(a+1,a+2,a+n);\n  }\n}\n']","[0, 0, 1, 0, 1]",1200,It s not very difficult to solve this problem in The statement hints us that we can use the data structure We need to maintain the queue of players the current winner and the number of wins he has Each game is processed in It can be shown that number of games is less than Of course this solution is too slow Let s think what happens if is large More precisely assume that The winner need to win at least games in a row that is he need to win against all the other players Hence the winner is just the strongest player So if we can solve the problem in Otherwise simulation works in 
Kostya is a progamer specializing in the discipline of Dota 2 Valve Corporation the developer of this game has recently released a new patch which turned the balance of the game upside down Kostya as the captain of the team realizes that the greatest responsibility lies on him so he wants to resort to the analysis of innovations patch from the mathematical point of view to choose the best heroes for his team in every game A Dota 2 match involves two teams each of them must choose some heroes that the players of the team are going to play for and it is forbidden to choose the same hero several times even in different teams In large electronic sports competitions where Kostya s team is going to participate the matches are held in the Captains Mode In this mode the captains select the heroes by making one of two possible actions in a certain predetermined order pick or ban To pick a hero for the team After the captain picks the picked hero goes to his team later one of a team members will play it and can no longer be selected by any of the teams To ban a hero After the ban the hero is not sent to any of the teams but it still can no longer be selected by any of the teams The team captain may miss a pick or a ban If he misses a pick a random hero is added to his team from those that were available at that moment and if he misses a ban no hero is banned as if there was no ban Kostya has already identified the strength of all the heroes based on the new patch fixes Of course Kostya knows the order of picks and bans The strength of a team is the sum of the strengths of the team s heroes and both teams that participate in the match seek to maximize the difference in strengths in their favor Help Kostya determine what team the first one or the second one has advantage in the match and how large the advantage is ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n\nusing namespace std;\n\nconst int inf = (int)1e9;\n\nchar c[123];\nint who[123], skill[123];\n\nint f[1234567];\nint kb[1234567];\n\nint main() {\n  int _n;\n  scanf(""%d"", &_n);\n  for (int i = 0; i < _n; i++) scanf(""%d"", skill + i);\n  sort(skill, skill + _n);\n  reverse(skill, skill + _n);\n  int m;\n  scanf(""%d"", &m);\n  for (int i = 0; i < m; i++) {\n    char ch = getchar();\n    while (ch != \'p\' && ch != \'b\') ch = getchar();\n    c[i] = ch;\n    scanf(""%d"", who + i);\n  }\n  kb[0] = 0;\n  for (int t = 1; t < (1 << m); t++) kb[t] = kb[t & (t - 1)] + 1;\n  f[(1 << m) - 1] = 0;\n  for (int t = (1 << m) - 2; t >= 0; t--) {\n    if (who[kb[t]] == 1) {\n      f[t] = -inf;\n      for (int i = 0; i < m; i++)\n        if (!(t & (1 << i))) {\n          int ft = f[t + (1 << i)];\n          if (c[kb[t]] == \'p\') ft += skill[i];\n          if (ft > f[t]) f[t] = ft;\n        }\n    } else {\n      f[t] = inf;\n      for (int i = 0; i < m; i++)\n        if (!(t & (1 << i))) {\n          int ft = f[t + (1 << i)];\n          if (c[kb[t]] == \'p\') ft -= skill[i];\n          if (ft < f[t]) f[t] = ft;\n        }\n    }\n  }\n  printf(""%d\\n"", f[0]);\n  return 0;\n}\n']","[0, 0, 0, 1, 0]",2200,There are some observations that do the problem very simple The first one is that we always should pick the strongest hero But we cannot say something similar about the bans in different situations different bans are the best But the most important observation is that we should consider only strongest heroes Indeed in every game where only strongest heroes are picked no hero except strongest can be picked That s why we don t need to ban them and therefore we don t need to consider them So now we have only 20 heroes It means we can solve the problem using the dynamic programming with bitmasks will be the difference between the teams strengths when only those heroes are picked or banned whose bits are set to 1 in the At every state we try to pick or ban every available hero and go to the other state The simpliest way to implement it is the recursion with memoization The answer will be stored in Unfortunately we couldn t estimate the real complexity of this problem despite it has the simple solution this solution is not so easy to think of standard 1500 points for problem C would be better and set too big TL many solutions written in C whose complexity is passed we should have been set TL to 1 second or even to 0 75 seconds So if you solved it in you may assume that you re just lucky and your correct verdict is Time Limit Exceeded Why it can be solved in There is no point of missing a ban if we ban the weakest hero nothing will change since the weakest hero won t be picked Also this problem has weak pretests so you could hack solutions without bitmasks with almost any big random test 
There is a bookshelf which can fit n books The i th position of bookshelf is a i 1 if there is a book on this position and a i 0 otherwise It is guaranteed that there is on the bookshelf In one move you can choose some contiguous segment l r consisting of books i e for each i from l to r the condition a i 1 holds and Shift it to the right by 1 move the book at index i to i 1 for all l le i le r This move can be done only if r 1 le n and there is no book at the position r 1 Shift it to the left by 1 move the book at index i to i 1 for all l le i le r This move can be done only if l 1 ge 1 and there is no book at the position l 1 Your task is to find the number of moves required to collect all the books on the shelf as a consecutive segment i e the segment without any gaps For example for a 0 0 1 0 1 there is a gap between books a 4 0 when a 3 1 and a 5 1 for a 1 1 0 there are no gaps between books and for a 0 0 0 there are also no gaps between books You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define forinc(i,a,b) for(int i=a;i<=b;++i)\n#define fordec(i,a,b) for(int i=a;i>=b;--i)\n#define forv(i,x) for(auto &i:x)\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r)\n{\n    return l+rng()%(r-l+1);\n}\n#define in ({int x=0;int c=getchar(),n=0;for(;!isdigit(c);c=getchar()) n=(c==\'-\');for(;isdigit(c);c=getchar()) x=x*10+c-\'0\';n?-x:x;})\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define batbit(i,x) (x|(1ll<<i))\n#define getbit(i,x) ((x>>i)&1)\n\nint a[500],s[500];\n\nmain()\n{\n    int t;\n    cin >> t;\n    while(t--)\n    {\n        int n;\n        cin >> n;\n        int tmp=0,kq=0,mi=1e9,ma=0;\n        forinc(i,1,n)\n        {\n            cin >> a[i];\n            if(a[i]==0) s[i]=s[i-1]+1;\n            else s[i]=s[i-1];\n        }\n        forinc(i,1,n) if(a[i])\n        {\n            mi=min(mi,i);\n            ma=max(ma,i);\n        }\n        cout << s[ma]-s[mi-1] << ""\\n"";\n    }\n}\n']","[1, 0, 1, 0, 0]",800,We can notice that the answer is the number of zeros between the leftmost occurrence of and the rightmost occurrence of Why is it true Let s take the leftmost maximum by inclusion segment of and just shift it right We can see that using this algorithm we will do exactly described amount of moves and there is no way improve the answer 
You have an array a of size n initially filled with zeros a 1 a 2 ldots a n 0 You also have an array of integers c of size n Initially you have k coins By paying c i coins you can add 1 to all elements of the array a from the first to the i th element a j mathrel 1 for all 1 leq j leq i You can buy any c i any number of times A purchase is only possible if k geq c i meaning that at any moment k geq 0 must hold true Find the lexicographically largest array a that can be obtained An array a is lexicographically smaller than an array b of the same length if and only if in the first position where a and b differ the element in array a is smaller than the corresponding element in b ,"[""#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = (j); i <= (k); ++i)\n#define R(i, j, k) for(int i = (j); i >= (k); --i)\n#define ll long long \n#define vi vector < int > \n#define sz(a) ((int) (a).size())\n#define ll long long \n#define ull unsigned long long\n#define me(a, x) memset(a, x, sizeof(a)) \nusing namespace std;\nconst int N = 1e6 + 7;\nint n, k;\nint c[N];\nint cnt[N];\nint a[N];\nvoid Main() {\n\tcin >> n;\n\tL(i, 1, n) {\n\t\tcin >> c[i];\n\t}\n\tR(i, n - 1, 0) {\n\t\tc[i] = min(c[i], c[i + 1]);\n\t}\n\tcin >> k;\n\tL(i, 1, n) {\n\t\ta[i] = 0;\n\t}\n\tint cur = 1e9 + 7;\n\tL(i, 1, n) {\n\t\tint ban = c[i] - c[i - 1];\n\t\tint buy = ban == 0 ? cur : min(cur, k / ban);\n\t\ta[i] = buy;\n\t\tcur = buy;\n\t\tk -= buy * ban;\n\t}\n\tL(i, 1, n) {\n\t\tcout << a[i] << ' ';\n\t} \n\tcout << '\\n';\n}\nint main() {\n\tios :: sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n\tint t; cin >> t; while(t--) Main();\n\treturn 0;\n}\n""]","[1, 0, 1, 0, 0]",1800,TutorialNote that if there is a prefix for which there is a longer prefix that costs less then it is useless to buy the shorter prefix All its purchases can be replaced with purchases of the longer prefix and the answer will only improve Therefore we can replace each with the minimum among the minimum price of a prefix of length at least After this we will have Now let s solve the problem greedily We want to maximize the first element of the resulting array It will be equal to since we cannot buy more prefixes of length is the smallest price After buying prefixes of length we will have some coins left Now we can replace some purchases of with purchases of longer prefixes to improve the answer How much will it cost to replace with It will cost coins Moreover note that to replace with we can sequentially replace with with with since This means that we can make only replacements of purchases of with purchases of Let s say we have maximized the first elements of the answer and we have coins left Now we want to replace some purchases of with How many replacements can we make We can afford to make no more than replacements if then we can replace all and we cannot replace more purchases than we have made so no more than replacements this is the number of purchases of Therefore as we want to maximize Finally subtract the cost of replacements from the number of coins and move on to 
Little Johnny has recently learned about set theory Now he is studying binary relations You ve probably heard the term equivalence relation These relations are very important in many areas of mathematics For example the equality of the two numbers is an equivalence relation A set of pairs of elements of some set is called a binary relation on set For two elements and of the set we say that they are in relation if pair in this case we use a notation Binary relation is if It is reflexive for any it is true that It is symmetric for any it is true that if then It is transitive if and than Little Johnny is not completely a fool and he noticed that the first condition is not necessary Here is his proof Take any two elements and If then according to property 2 which means according to property 3 It s very simple isn t it However you noticed that Johnny s proof is wrong and decided to show him a lot of examples that prove him wrong Here s your task count the number of binary relations over a set of size such that they are symmetric transitive but not an equivalence relations i e they are not reflexive Since their number may be very large not according to Little Johnny print the remainder of integer division of this number by ,"['#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cassert>\n#include <ctime>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#ifdef WIN32\n\t#define LLD ""%I64d""\n#else\n\t#define LLD ""%lld""\n#endif\n\n#define pb push_back\n#define all(x) begin(x), end(x)\n\nconst int MOD = 1000000007;\n\nconst int maxn = 4005;\n\nint c[maxn][maxn];\nint cnt[maxn], cnt2[maxn];\n\nvoid add(int &a, ll b)\n{\n    a = (a + b) % MOD;\n}\n\nint main()\n{\n    int n;\n    scanf(""%d"", &n);\n    c[0][0] = 1;\n    for (int i = 1; i <= n; i++)\n    {\n        c[i][0] = 1;\n        for (int j = 1; j <= i; j++) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD;\n    }\n    cnt[0] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 1; j + i <= n; j++) add(cnt[i + j], (ll)cnt[i] * c[n - i - 1][j - 1]);\n    }\n    cnt2[0] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 1; j + i <= n; j++) add(cnt2[i + j], (ll)cnt2[i] * c[n - i - 1][j - 1]);\n        add(cnt2[i + 1], cnt2[i]);\n    }\n    int answer = (cnt2[n] - cnt[n] + MOD) % MOD;\n//     for (int i = 0; i < n; i++) add(answer, cnt[i]);\n    cout << answer << endl;\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0]",1900,Let s find Johnny s mistake It is all right in his proof except If part What if there is no such for an given Then obviously otherwise we ll take We can see that our binary relation is some equivalence relation which was expanded by some empty elements For empty element there is no such that Thus we can divide our solution into two parts Count the number of equivalence relations on sets of size For every size count the number of ways to expand it with some empty elements We can define equivalence relation using its equivalence classes So first part can be solved using dynamic programming the numbers of ways to divide first elements to equivalence classes When we handle next element we can send it to one of the existing equivalence classes or we can create new class Let s solve second part Consider set of size We have found that there are ways to build equivalence relation on this set We have to add empty elements to this set The number of ways to choose their positions is We can calculate all the binomial coefficients using Pascal s triangle So the answer to the problem is Complexity 
Lesha plays the recently published new version of the legendary game hacknet In this version character skill mechanism was introduced Now each player character has exactly skills Each skill is represented by a non negative integer the current skill level All skills have the same maximum level Along with the skills global ranking of all players was added Players are ranked according to the so called Force The of a player is the sum of the following values The number of skills that a character has perfected i e such that multiplied by coefficient The minimum skill level among all skills multiplied by coefficient Now Lesha has hacknetian currency units which he is willing to spend Each currency unit can increase the current level of any skill by if it s not equal to yet Help him spend his money in order to achieve the maximum possible value of the Force ,"['#include<cassert>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N = 100005;\n\nint n, A, cf, cm;\n\nlong long m;\n\nint a[N], b[N], ord[N];\n\nlong long sum[N];\n\nbool byA(const int &i, const int &j) {\n    return a[i] < a[j];\n}\n\nint main() {\n    scanf(""%d%d%d%d"", &n, &A, &cf, &cm);\n    cin >> m;\n    for (int i = 0; i < n; ++i) {\n        scanf(""%d"", a + i);\n        b[i] = a[i];\n        ord[i] = i;\n    }\n    sort(ord, ord + n, byA);\n    sort(a, a + n);\n    for (int i = 0; i < n; ++i) {\n        sum[i + 1] = sum[i] + a[i];\n    }\n    long long ans = -1, ansi = -1, ansm = -1;\n    for (int i = 0, j = 0; i <= n; ++i) {\n        //i to n - 1 shall be all perfect then maxmize the minimum among 0 to i - 1\n        long long cost = 0, tmp = 0;\n        cost = (long long)A * (n - i) - (sum[n] - sum[i]);\n        if (cost > m) {\n            continue;\n        }\n        tmp += (n - i) * cf;\n        long long left = m - cost;\n        while (j < i && (long long)j * a[j] - sum[j] <= left) {\n            ++j;\n        }\n        int mins = 0;\n        if (j) {\n            mins = min((long long)A, (left + sum[j]) / j);\n        } else {\n            mins = A;\n        }\n        tmp += (long long)mins * cm;\n        if (tmp > ans) {\n            ans = tmp;\n            ansi = i;\n            ansm = mins;\n        }\n    }\n    cout << ans << endl;\n    long long cost = 0, mins = A, maxs = 0;\n    for (int i = 0; i < n; ++i) {\n        int delta = 0, u = b[ord[i]];\n        if (i >= ansi) {\n            delta = A - u;\n        } else {\n            delta = max(0ll, ansm - u);\n        }\n        b[ord[i]] += delta;\n        cost += delta;\n        mins = min(mins, (long long)b[ord[i]]);\n        maxs += b[ord[i]] == A;\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(""%d%c"", b[i], i == n - 1 ? \'\\n\' : \' \');\n    }\n    assert(cost <= m && mins * cm + maxs * cf == ans);\n    return 0;\n}']","[1, 0, 0, 1, 0]",1900,Let s save the original positions of skills and then sort the skills in non increasing order almost decreasing by current level We can always restore original order after Imagine that we have decided that we want to use the minimum level X and now we re choosing which skills we should bring to the maximum At first let s rise all skills below X to level X this will set some tail of array to X But the original array was sorted and this new change will not break the sort So our array is still sorted Obviously the skills we want to take to the maximum are the ones with highest current level They are in the prefix of array It is easy to show that any other selection is no better than this greedy one Now we have shown that the optimal strategy is to max out the skills in some prefix Now let s solve the problem Let s iterate over prefix to max out now on each iteration we need to know the highest minimum we can achieve let s store the index of the first element outside the prefix such that it is possible to reach the minimum level arrindex It is easy to recalc this index it slightly moves forward each turn and after precalcing the sum of all array s tails you can update it easily just move it forward until the invariant above holds And knowing this index is enough to calc the current highest possible minimum level min A arrindex sparemoney n index How to restore the answer Actually all you need to know is the count of maximums to take and minimum level to reach 
Tom loves vowels and he likes long words with many vowels His favorite words are vowelly words We say a word of length k is vowelly if there are positive integers n and m such that n cdot m k and when the word is written by using n rows and m columns the first row is filled first then the second and so on with each row filled from left to right every vowel of the English alphabet appears at least once in every row and every column You are given an integer k and you must either print a vowelly word of length k or print 1 if no such word exists In this problem the vowels of the English alphabet are ,"['#pragma GCC optimize(""Ofast"")\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define y0 holdtheflower\n#define y1 enjoythecolorandscent\n#define yn walkthroughthesoulgarden\n#define j1 feelthewarmbreathofkindnessandsalvation\n\n#define endl \'\\n\'\nmt19937 rng32(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng64(chrono::steady_clock::now().time_since_epoch().count());\n\nint k;\nstring vowel = ""aeiou"";\n\nvoid Input() {\n\tcin >> k;\n}\n\nvoid Solve() {\n\tfor (int i=5; i<=sqrt(k); i++) {\n\t\tif (k % i != 0) continue;\n\t\tint j = k / i;\n\t\tvector<vector<char>> Mat(i, vector<char>(j, \'t\'));\n\t\tfor (int x=0; x<i; x++) {\n\t\t\tfor (int y=0; y<j; y++) {\n\t\t\t\tMat[(x+y) % i][y] = vowel[x % 5];\n\t\t\t}\n\t\t}\n\t\tfor (int x=0; x<i; x++) {\n\t\t\tfor (int y=0; y<j; y++) {\n\t\t\t\tcout << Mat[x][y];\n\t\t\t}\n\t\t}\n\t\tcout << endl; return;\n\t}\n\tcout << ""-1\\n"";\n}\n\nint main(int argc, char* argv[]) {\n\tios_base::sync_with_stdio(0); cin.tie(NULL);\n\tInput(); Solve(); return 0;\n}\n\n/******************************************\\\n *  Thuy-Trang Tran, #Team4T\'s Leader     *\n *  #Team4T Primary Flagship - Salvation  *\n\\******************************************/']","[0, 1, 0, 0, 0]",1100,First which boards could we feasibly fill with characters satisfying that every row and column contains one vowel at least once Well if we have a board with less than 5 rows then each column contains less than 5 characters so we cannot have every vowel on each column and we can t fill the board Similarly we can t fill a board with less than 5 columns Ok so say now that we have a board with at least 5 rows and at least 5 columns Can we fill it Yes we can It s enough to fill it by diagonals as shown in the following picture Now we can easily solve the problem If n cdot m k then n must divide k and m frac k n So we can iterate over all possible n from 5 to k check whether n divides k and in that case check whether m frac k n is at least 5 If this works for at least one value of n then we can fill the n cdot m board by diagonals as shown before and obtain our vowelly word by reading the characters row by row If we don t find any values of n satisfying this then no vowelly word exists Complexity mathcal O k 
Leha plays a computer game where is on each level is given a connected graph with vertices and edges Graph can contain multiple edges but can not contain self loops Each vertex has an integer which can be equal to or To pass the level he needs to find a good subset of edges of the graph or say that it doesn t exist Subset is called good if by by leaving only edges from this subset in the original graph we obtain the following for every vertex i 1 or it s degree modulo 2 is equal to Leha wants to pass the game as soon as possible and ask you to help him In case of multiple correct answers print any of them ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nstruct UnionFind {\n\tvector<int> data;\n\tvoid init(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n};\n\nvector<int> t_parent;\nvector<int> t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile (!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor (int j = (int)g[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = g[i][j];\n\t\t\tif (t_parent[c] == -1 && c != root) {\n\t\t\t\tt_parent[c] = i;\n\t\t\t\tstk.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint n; int m;\n\twhile (~scanf(""%d%d"", &n, &m)) {\n\t\tvector<int> d(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(""%d"", &d[i]);\n\t\tvector<pair<int, int> > edges(m);\n\t\tmap<pii, int> eindex;\n\t\tfor (int i = 0; i < m; ++ i) {\n\t\t\tint u; int v;\n\t\t\tscanf(""%d%d"", &u, &v), -- u, -- v;\n\t\t\tedges[i] = { u,v };\n\t\t\teindex[minmax(u, v)] = i;\n\t\t}\n\t\tint arb = -1;\n\t\tvector<int> odd;\n\t\trep(i, n) {\n\t\t\tif (d[i] == -1 && arb == -1)\n\t\t\t\tarb = i;\n\t\t\tif (d[i] == 1)\n\t\t\t\todd.push_back(i);\n\t\t}\n\t\tif (odd.size() % 2 != 0) {\n\t\t\tif (arb == -1) {\n\t\t\t\tputs(""-1"");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\td[arb] = 1;\n\t\t\todd.push_back(arb);\n\t\t}\n\t\tvector<vi> g(n);\n\t\tUnionFind uf; uf.init(n);\n\t\tfor (auto e : edges) if (uf.unionSet(e.first, e.second)) {\n\t\t\tg[e.first].push_back(e.second);\n\t\t\tg[e.second].push_back(e.first);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tvector<int> add(n);\n\t\trep(k, odd.size() / 2) {\n\t\t\tint a = odd[k * 2], b = odd[k * 2 + 1];\n\t\t\tadd[a] ^= 1;\n\t\t\tadd[b] ^= 1;\n\t\t}\n\t\tvector<int> sum(add.begin(), add.end());\n\t\tfor (int ix = (int)t_ord.size() - 1; ix > 0; -- ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tsum[p] ^= sum[i];\n\t\t}\n\t\tvi ans;\n\t\treu(i, 1, n) if (sum[i] % 2 != 0) {\n\t\t\tans.push_back(eindex[minmax(t_parent[i], i)]);\n\t\t}\n\t\tprintf(""%d\\n"", (int)ans.size());\n\t\tfor (int i = 0; i < (int)ans.size(); ++ i) {\n\t\t\tif (i != 0) putchar(\' \');\n\t\t\tprintf(""%d"", ans[i] + 1);\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1]",2100,Model solution uses the fact that the graph is connected We ll prove that good subset exists iff 1 values among di can be changed to 0 1 so that is even If the sum can only be odd there is no solution obviously every single valid graph has even sum of degrees Now we ll show how to build the answer for any case with even sum First of all change all 1 values so that the sum becomes even Then let s find any spanning tree and denote any vertex as the root The problem is actually much easier now Let s process vertices one by one by depth from leaves to root Let s denote current vertex as cur There are two cases 1 dcur 0 In this case we ignore the edge from cur to parentcur and forget about cur Sum remains even 2 dcur 1 In this case we add the edge from cur to parentcur to the answer change dparentcur to the opposite value and forget about cur As you can see sum changed its parity when we changed dparentcur but then it changed back when we discarded cur So again sum remains even Using this simple manipulations we come up with final answer 
You have an array with length you can perform operations Each operation is like this choose two elements from say and and replace one of them with where denotes the greatest common divisor What is the minimum number of operations you need to make all of the elements equal to ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=2010;\nint n,a[N];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\tbool hav1=0;\n\trep(i,1,n+1) if (a[i]==1) hav1=1;\n\tif (hav1) {\n\t\tint cnt=0;\n\t\trep(i,1,n+1) if (a[i]!=1) cnt++;\n\t\tprintf(""%d\\n"",cnt);\n\t\treturn 0;\n\t}\n\tint len=n+1;\n\trep(i,1,n+1) {\n\t\tint d=a[i];\n\t\trep(j,i,n+1) {\n\t\t\td=gcd(d,a[j]);\n\t\t\tif (d==1) len=min(len,j-i+1);\n\t\t}\n\t}\n\tif (len>n) puts(""-1""); else printf(""%d\\n"",len-1+n-1);\n}\n']","[1, 1, 0, 1, 0]",1500,Consider cnt1 as number of 1s in the a If 0 cnt1 then the answer is n cnt1 otherwise We should find a segment with its gcd equal to 1 and minimum length consider a segment as L R which L R and it s gcd as D L R We fix L and then iterate through all R in order Consider we know that D L R G then D L R 1 gcd G A R 1 If D L R 1 then you can make all the elements in R L 1 n 1 Answer is minimum possible D L R over all possible segments 
You are given an array with distinct integers Construct an array by permuting such that for every non empty subset of indices the sums of elements on that positions in and are different i e ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=30;\nint n,a[N],b[N];\nPII p[N];\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,0,n) scanf(""%d"",a+i),p[i]=mp(a[i],i);\n\tsort(p,p+n);\n\trep(i,0,n) b[p[(i+1)%n].se]=p[i].fi;\n\trep(i,0,n) {\n\t\tprintf(""%d "",b[i]);\n\t}\n\tputs("""");\n}\n']","[1, 0, 0, 0, 0]",2000,Sort the array and shift it by one This array will be an answer Proof When we shift the sorted array all of the elements become greater except the first one consider and if 1 wasn t in t we would have otherwise consider then 1 can t be in and we have so and we are done 
Nastya baked m pancakes and spread them on n dishes The dishes are in a row and numbered from left to right She put a i pancakes on the dish with the index i Seeing the dishes Vlad decided to bring order to the stacks and move some pancakes In one move he can shift one pancake from any dish to the closest one that is select the dish i a i 0 and do one of the following if i 1 put the pancake on a dish with the previous index after this move a i a i 1 and a i 1 a i 1 1 if i n put the pancake on a dish with the following index after this move a i a i 1 and a i 1 a i 1 1 Vlad wants to make the array a after moving as few pancakes as possible Help him find the minimum number of moves needed for this The array a a 1 a 2 dots a n is called non increasing if a i ge a i 1 for all i from 1 to n 1 ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\nconst int N = 255,INF = 0x3f3f3f3f;\nint ans,n,m,inp[N + 1],dp[2][N + 1][(N << 1) + 10],minn[2][N + 1][(N << 1) + 10],sum[N + 1];\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tans = INF;\n\tn = read(),m = read();\n\tfor (int i = 1;i <= n;i++) inp[i] = read(),sum[i] = sum[i - 1] + inp[i];\n\tif (n == 1) {puts(""0"");return 0;}\n\tmemset(dp,63,sizeof(dp)),memset(minn,63,sizeof(minn));\n\tfor (int j = 0;j <= m;j++){\n\t\tdp[1][j][j - inp[1] + m] = abs(j - inp[1]);\n\t\tminn[1][j][j - inp[1] + m] = abs(j - inp[1]);\n\t}\n\tfor (int k = 0;k <= (m << 1);k++){\n\t\tfor (int j = m;j >= 0;j--){\n\t\t\tminn[1][j][k] = min(dp[1][j][k],minn[1][j + 1][k]);\n\t\t}\n\t}\n\tfor (int i = 2;i <= n;i++){\n\t\tfor (int j = 0;j <= m;j++){\n\t\t\tfor (int k = 0;k <= (m << 1);k++) dp[i & 1][j][k] = minn[i & 1][j][k] = INF;\n\t\t}\n\t\tfor (int j = 0;j <= m;j++){\n\t\t\tfor (int k = 0;k <= (m << 1);k++){\n\t\t\t\tif (k - j + inp[i] >= 0 && k - j + inp[i] <= (m << 1)){\n\t\t\t\t\tdp[i & 1][j][k] = min(dp[i & 1][j][k],minn[(i & 1) ^ 1][j][k - j + inp[i]] + abs(k - m));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0;k <= (m << 1);k++){\n\t\t\tfor (int j = m;j >= 0;j--){\n\t\t\t\tminn[i & 1][j][k] = min(minn[i & 1][j + 1][k],dp[i & 1][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0;j <= m;j++) ans = min(ans,dp[n & 1][j][m]);\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}']","[0, 0, 0, 1, 0]",2300,For convenience we will calculate the prefix sums on the array we will also enter the array containing the indexes of all pancakes and calculate the prefix sums on it Let s use dynamic programming Let s define as the required number of operations to correctly lay out the th prefix with the final and Then you can go to from the previous number must be greater and the sum is fixed To it will be necessary to add a certain number of actions necessary to get let s call it all the terrible prefix sums are needed to count it Since depends only on and we only need to choose the minimum the choice can be optimized by suffix minima As a result the solution works for that s how many states need to be processed 
This is an easier version of the problem In this version n le 500 Vasya is an experienced developer of programming competitions problems As all great minds at some time Vasya faced a creative crisis To improve the situation Petya gifted him a string consisting of opening and closing brackets only Petya believes that the beauty of the bracket string is a number of its cyclical shifts which form a correct bracket sequence To digress from his problems Vasya decided to select two positions of the string and swap characters located at this positions with each other Vasya will apply this operation exactly once He is curious what is the maximum possible beauty he can achieve this way Please help him We remind that bracket sequence s is called correct if s is empty s is equal to t where t is correct bracket sequence s is equal to t 1 t 2 i e concatenation of t 1 and t 2 where t 1 and t 2 are correct bracket sequences For example are correct while and are not The cyclical shift of the string s of length n by k 0 leq k n is a string formed by a concatenation of the last k symbols of the string s with the first n k symbols of string s For example the cyclical shift of string by 2 equals Cyclical shifts i and j are considered different if i ne j ,"['// #pragma comment(linker, ""/stack:200000000"")\n// #pragma GCC optimize(""Ofast,no-stack-protector"")\n// #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n// #pragma GCC optimize(""unroll-loops"")\n \n#include <bits/stdc++.h>\n \n#define debug(x) std::cerr << (#x) << "":\\t"" << (x) << std::endl;\n#define fastIO std::ios_base::sync_with_stdio(false);std::cin.tie(0);std::cout.tie(0);\n \ntypedef long long ll;\ntypedef long double ld;\n \nstd::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n \nconst double PI = atan2(0., -1.);\nconst int INF = 0x3f3f3f3f;\nconst int N = 1 << 19;\n \nint n;\nchar str[N];\nint bal[N];\nint q[N];\n \nint getAns() {\n\tfor (int i = 0; i <= 3 * n; ++i) {\n\t\tbal[i] = 0;\n\t\tq[i] = 0;\n\t}\n \n\t// std::map<int, int> q;\n \n\tfor (int i = 0; i < n; ++i) {\n\t\tbal[i + 1] += bal[i];\n \n\t\tif (str[i] == \'(\') {\n\t\t\t++bal[i + 1];\n\t\t} else {\n\t\t\t--bal[i + 1];\n\t\t}\n\t}\n \n\tif (bal[0] != bal[n]) {\n\t\treturn 0;\n\t}\n \n\tfor (int i = 0; i < n; ++i) {\n\t\t++q[bal[i] + n];\n\t}\n \n \tfor (int i = 0; i < N; ++i) {\n \t\tif (q[i] != 0) {\n \t\t\treturn q[i];\n \t\t}\n \t}\n\n \tthrow 228;\n\t// return q.begin()->second;\n}\n \nint main(void) {\n\tscanf(""%d\\n%s"", &n, str);\n \n\tint ans = getAns();\n\tint fi = 0;\n\tint se = 0;\n \n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\tif (str[i] != str[j]) {\n\t\t\t\tstd::swap(str[i], str[j]);\n \n\t\t\t\tint curAns = getAns();\n\t\t\t\tif (curAns > ans) {\n\t\t\t\t\tans = curAns;\n\t\t\t\t\tfi = i;\n\t\t\t\t\tse = j;\n\t\t\t\t}\n \n\t\t\t\tstd::swap(str[i], str[j]);\n\t\t\t}\n\t\t}\n\t}\t\n \n\tprintf(""%d\\n%d %d\\n"", ans, fi + 1, se + 1);\n \n\treturn 0;\n}']","[1, 0, 1, 1, 0]",2000,Note first that the number of opening brackets must be equal to the number of closing brackets otherwise the answer is always Note that the answer to the question about the number of cyclic shifts which are correct bracket sequences equals the number of minimal prefix balances For example for string the array of prefix balances is and the number of cyclic shifts the number of minimums in it Now we have a solution of complexuty let s iterate over all pairs of symbols that can be swapped Let s do this and find the number of cyclic shifts that are correct bracket sequences according to the algorithm described above 
The School 0 of the capital of Berland has children studying in it All the children in this school are gifted some of them are good at programming some are good at maths others are good at PE Physical Education Hence for each child we know value if the th child is good at programming if the th child is good at maths if the th child is good at PE Each child happens to be good at exactly one of these three subjects The Team Scientific Decathlon Olympias requires teams of three students The school teachers decided that the teams will be composed of three children that are good at different subjects That is each team must have one mathematician one programmer and one sportsman Of course each child can be a member of no more than one team What is the maximum number of teams that the school will be able to present at the Olympiad How should the teams be formed for that ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint n, m;\nvector<int> a[4];\n\nint main(){\n     //freopen(""a.in"", ""r"", stdin);\n     //freopen(""a.out"", ""w"", stdout);\n     scanf(""%d"", &n);\n     for (int i = 0; i < 4; i++) a[i].clear();\n     for (int i = 1; i <= n; i++)\n     {\n          int x;\n          scanf(""%d"", &x);\n          a[x].push_back(i);\n     }\n     int m = min(min(a[1].size(), a[2].size()), a[3].size());\n     printf(""%d\\n"", m);\n     for (int i = 0; i < m; i++) printf(""%d %d %d\\n"", a[1][i], a[2][i], a[3][i]);\n}\n']","[1, 0, 1, 0, 0]",800,The teams could be formed using greedy algorithm We can choose any three children with different skills who are not participants of any team yet and form a new team using them After some time we could not form any team so the answer to the problem is minimum of the number of ones twos and threes in given array We can get solution if we add children with different skills into three different arrays Also the problem could be solved in every iteration find new three children for new team 
You are an all powerful being and you have created a rectangular world In fact your world is so bland that it could be represented by a r times c grid Each cell on the grid represents a country Each country has a dominant religion There are only two religions in your world One of the religions is called Beingawesomeism who do good for the sake of being good The other religion is called Pushingittoofarism who do murders for the sake of being bad Oh and you are actually not really all powerful You just have one power which you can use infinitely many times Your power involves When a missionary group of a certain country say a passes by another country b they change the dominant religion of country b to the dominant religion of country a In particular a single use of your power is this You choose a horizontal 1 times x subgrid or a vertical x times 1 subgrid That value of x is up to you You choose a direction d If you chose a horizontal subgrid your choices will either be NORTH or SOUTH If you choose a vertical subgrid your choices will either be EAST or WEST You choose the number s of steps You command each country in the subgrid to send a missionary group that will travel s steps towards direction d In each step they will visit and in effect convert the dominant religion of all s countries they pass through as detailed above The parameters x d s must be chosen in such a way that any of the missionary groups won t leave the grid The following image illustrates one possible single usage of your power Here represents a country with dominant religion Beingawesomeism and represents a country with dominant religion Pushingittoofarism Here we ve chosen a 1 times 4 subgrid the direction NORTH and s 2 steps You are a being which believes in free will for the most part However you just really want to stop receiving murders that are attributed to your name Hence you decide to use your powers and try to make Beingawesomeism the dominant religion in every country What is the minimum number of usages of your power needed to convert everyone to Beingawesomeism With god nothing is impossible But maybe you re not god If it is impossible to make Beingawesomeism the dominant religion in all countries you must also admit your mortality and say so ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> s(n);\n\tfor(int i = 0; i < n; i++) cin >> s[i];\n\tbool is0 = false;\n\tbool is1 = false;\n\tbool is2 = false;\n\tbool is3 = false;\n\tbool is4 = false;\n\tis0 = true;\n\n\tbool f1 = true, f2 = true, f3 = true, f4 = true;\n\tfor(int i = 0; i < n; i++){\n\t\tbool row_works = true;\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == \'P\') row_works = false;\n\t\t}\n\t\tif(row_works) is2 = true;\n\t}\n\tfor(int j = 0; j < m; j++){\n\t\tbool col_works = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(s[i][j] == \'P\') col_works = false;\n\t\t}\n\t\tif(col_works) is2 = true;\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == \'P\'){\n\t\t\t\tis0 = false;\n\t\t\t\tif(i == 0) f1 = false;\n\t\t\t\tif(i == n-1) f2 = false;\n\t\t\t\tif(j == 0) f3 = false;\n\t\t\t\tif(j == m-1) f4 = false;\n\t\t\t} else {\n\t\t\t\tif((i == 0 || i == n-1) && (j == 0 || j == m-1)){\n\t\t\t\t\tis2 = true;\n\t\t\t\t}\n\t\t\t\tif((i == 0 || i == n-1) || (j == 0 || j == m-1)){\n\t\t\t\t\tis3 = true;\n\t\t\t\t}\n\t\t\t\tis4 = true;\n\t\t\t}\n\t\t}\n\t}\n\tis1 = f1 | f2 | f3 | f4;\n\tif(is0){\n\t\tcout << 0 << \'\\n\';\n\t} else if(is1){\n\t\tcout << 1 << \'\\n\';\n\t} else if(is2){\n\t\tcout << 2 << \'\\n\';\n\t} else if(is3){\n\t\tcout << 3 << \'\\n\';\n\t} else if(is4){\n\t\tcout << 4 << \'\\n\';\n\t} else {\n\t\tcout << ""MORTAL"" << \'\\n\';\n\t}\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}']","[0, 1, 1, 0, 0]",1800,If everything is P then it is clearly impossible MORTAL Otherwise you can turn everything into A in at most 4 moves starting from any single A Thus the answer is between 0 and 4 We can exhaust all possibilities The answer is 0 if Everything is an A Otherwise at least 1 move is needed The answer is 1 if At least one of the edge rows columns is all As Otherwise it can be shown that at least 2 moves are needed because if every edge has at least one P then no single move can simultaneously turn all four edges into A To see this note that our move must simultaneously touch all four edges This forces us to select our initial row column to be an entire edge row column of the grid But then we are forced to have at least one P in our selection and this P cannot be removed in this move The answer is 2 if There is one corner that s an A because in a single move we can turn an edge into all As There s a whole column or row of As because again in a single move we can turn an edge into all As This case could be tricky to spot Otherwise it can be shown that at least 3 moves are needed This is because if we are only allowed 2 moves then our first move must take us to a configuration where only 1 move is needed In other words in a single move we must ensure that one edge has all As Now suppose we have decided which edge to turn into all As Since all corners are Ps our move must touch both corners of that edge and so we are forced to copy an entire row column up to that edge But since every row column has a P this means that the edge will contain a P after the move and hence we have failed to turn that edge into all As We cannot also have accidentally turned another edge into all As since the other corners are still Ps The answer is 3 if There is at least one A in one of the edges because in a single move we can ensure that one corner becomes an A Otherwise it can be shown that at least 4 moves are needed because we can t turn any corner into A in a single move because all edges are Ps and only cells in edges get copied onto corners and we also can t turn any row column into all As in a single move since that requires copying an entire row column onto it but again note that the edges are all Ps The answer is 4 if It is not one of the cases above since 4 moves are always enough 
There are n people participating in some contest they start participating in x minutes intervals That means the first participant starts at time 0 the second participant starts at time x the third at time 2 cdot x and so on Duration of contest is t minutes for each participant so the first participant finishes the contest at time t the second at time t x and so on When a participant finishes the contest their dissatisfaction equals to the number of participants that started the contest or starting it now but haven t yet finished it Determine the sum of dissatisfaction of all participants ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tx=0;int f=1;char c;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\n/*const int MOD=;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}*/\n\nvoid solve()\n{\n\tll n,x,t;cin>>n>>t>>x;\n\tx/=t;\n\tif(x>n)cout<<n*(n-1)/2<<endl;\n\telse cout<<x*(n-x)+x*(x-1)/2<<endl;\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0]",1000,Let s find which participants will disturb participant Those are participants with number between and So each of first participants will get dissatisfaction and each next participant will get 1 dissatisfaction less than previous So the total answer is 
You ve got a matrix consisting of zeroes and a single number one Let s index the matrix rows by numbers from to from top to bottom let s index the matrix columns by numbers from to from left to right In one move you are allowed to apply one of the two following transformations to the matrix Swap two neighboring matrix rows that is rows with indexes and for some integer Swap two neighboring matrix columns that is columns with indexes and for some integer You think that a matrix looks if the single number one of the matrix is located in its middle in the cell that is on the intersection of the third row and the third column Count the minimum number of moves needed to make the matrix beautiful ,"['#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <map>\n\nint mm[10][10], ans;\n\nint abs(int a) {return a>0 ? a : -a;}\n\nint main() {\n    for(int i=0; i<5; i++)\n        for(int j=0; j<5; j++) {\n            scanf(""%d"", &mm[i][j]);\n            if(mm[i][j] == 1) {\n                ans += abs(i-2);\n                ans += abs(j-2);\n            }\n        }\n    printf(""%d\\n"", ans);\n}\n']","[0, 0, 1, 0, 0]",800,If the single is located on the intersection of the th row and the th column 1 based numeration then the answer is 
The Little Elephant enjoys recursive functions This time he enjoys the sorting function Let is a permutation of an integers from 1 to inclusive and denotes the th element of the permutation The Little Elephant s recursive function that sorts the first permutation s elements works as follows If exit the function Otherwise call and then make swap the th and th elements of The Little Elephant s teacher believes that this function does not work correctly But that be do not get an F the Little Elephant wants to show the performance of its function Help him find a permutation of numbers from 1 to such that after performing the Little Elephant s function that is call the permutation will be sorted in ascending order ,"['#include <vector>\n#include <queue>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define sz size\n#define re return\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define abs(x) ((x) < 0 ? -(x) : (x))\n#define INF 2000000000\n#define sqr(x) ((x) * (x))\n#define all(x) x.begin(), x.end()\n\nint n;\n\nint main() {\n\n#ifndef ONLINE_JUDGE\t          \n\tfreopen(""a.in"", ""r"", stdin);\n\tfreopen(""a.out"", ""w"", stdout);\n#endif\n\n\tcin >> n;\n\tif(n == 1) cout << 1;\n\telse\n\tif(n == 2) cout << ""2 1"";\n\telse {\n\t\tcout << n << "" ""; \n\t\tfor(int i = 1; i < n; i++)\n\t\t\tcout << i << "" "";\n\t}\n\treturn 0;\n}\n\n\t\n\n']","[0, 1, 1, 0, 0]",1000,In this problems you should notice that the answer for the problem is always of the following form 1 2 3 1 In such case array will be always sorted after the end of the algorithm 
Given an array a of n elements print any value that appears at least three times or print if there is no such value ,"['#include <bits/stdc++.h>\n \nusing namespace std;\n     \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n     \n#define pb push_back\n#define mp make_pair\n#define cotu cout\n#define itn int\n#define Red ios_base::sync_with_stdio(0);cin.tie(0)\n#define F first\n#define S second\n#define sz(x) (int)x.size()\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define repr(i,n) for(int i = n - 1; i >= 0; --i)\n#define Rep(i, a, n) for(int i = (a); i <=(n); ++i)\n#define repst(i, n) for(auto it = n.begin(); it != n.end(); ++it)\n#define Repr(i, a, n) for(int i = (n); i >= (a); --i)\n#define setp(x) fixed << setprecision(x)\n#define ordered_set tree<pair<long double, int> , null_type,less<pair<long double, int> >, rb_tree_tag,tree_order_statistics_node_update> \n    \n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\n     \nconst int inf = int(1e9) + 1;\nconst ll INF = ll(1e17);\nconst ll mod = 1e9 + 7;\nconst double PI = acos(-1.0);\n \nll bp(ll a, ll n, ll md = mod){\n  ll r = 1;\n  while(n){\n    if(n & 1) r = r * a % md;\n    a = a * a % md;\n    n >>= 1;\n  }\n  return r; \n}\ntemplate<typename T_vector> // neal\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end =  int(v.size());\n    \n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\nstruct segtree\n{\n  vector<long long> T;\n  vector<long long> add;\n  void init(int n){\n    T.resize(4 * n + 1);\n    add.resize(4 * n + 1);\n    for(int i = 0; i < 4 * n; ++i) T[i] = -INF;\n  }\n  long long merge(long long x, long long y){\n    return max(x, y);\n  }\n  void push(int v){\n      T[v * 2] += add[v];\n      T[v * 2 + 1] += add[v];\n      add[v * 2] += add[v];\n      add[v * 2 + 1] += add[v];\n      add[v] = 0; \n  }\n  void updval(int v, int tl, int tr, int pos, ll val){\n    if(tl == tr)  T[v] = max(T[v], val);\n    else{\n      push(v);\n      int tm = tl + tr >> 1;\n      if(pos <= tm) updval(2 * v, tl, tm, pos, val);\n      else updval(2 * v + 1, tm + 1, tr, pos, val);\n      T[v] = merge(T[v * 2], T[v * 2 + 1]);\n    }\n  }\n  void updrange(int v, int tl, int tr, int l, int r, long long val){\n    if(l <= tl && tr <= r){\n      T[v] += val;\n      add[v] += val;\n      return;\n    }\n    if(l > tr || r < tl) return;\n    push(v);\n    int tm = tl + tr >> 1;\n    updrange(2 * v, tl, tm, l, r, val);\n    updrange(2 * v + 1, tm + 1, tr, l, r, val);\n    T[v] = merge(T[v * 2], T[v * 2 + 1]);\n  }\n  long long get(int v, int tl, int tr, int l, int r){\n    if(l <= tl && tr <= r) return T[v];\n    if(l > tr || r < tl) return -INF;\n    push(v);\n    int tm = tl + tr >> 1;\n    return merge(get(2 * v, tl, tm, l, r),\n    get(2 * v + 1, tm + 1, tr, l, r));\n  }\n};\n\nvoid solve(){\n  int n;\n  cin >> n;\n  map<int, int> x;\n  rep(i, n){\n    int t;\n    cin >> t;\n    x[t]++;\n  }\n  for(auto it : x){\n    if(it.S >= 3){\n      cout << it.F << \'\\n\';\n      return;\n    }\n  }\n  cout << -1 << \'\\n\';\n}\n\n\nint main()\n{\n    // freopen(""input.txt"", ""r"", stdin);\n    // freopen(""output.txt"", ""w"", stdout);\n    Red;\n    int T;\n    T = 1;\n    cin >> T;\n    for(int i = 1; i <= T; ++i){\n      // cout << ""Case #"" << i << "": "";\n      solve();\n    }\n    return 0;\n}   ']","[0, 0, 1, 0, 0]",800,Approach 1 Sort the array using an efficient sorting algorithm For every element check if the next two in the array are equal to it If you find such an element output it Time complexity is Approach 2 Notice that elements have an upper bound of you can use an auxiliary array to store the count of each value Go through each value and see if its count is bigger than or equal to Time complexity is 
You are given a matrix consisting of n rows and m columns The j th cell of the i th row contains an integer a ij First you have to color each row of the matrix either red or blue in such a way that and Then you have to choose an integer k 1 le k m and cut the colored matrix in such a way that the first k columns become a separate matrix the matrix and the last m k columns become a separate matrix the matrix The coloring and the cut are called if two properties hold every red cell in the left matrix contains an integer greater than every blue cell in the left matrix every blue cell in the right matrix contains an integer greater than every red cell in the right matrix Find any perfect coloring and cut or report that there are none ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tint f=1;char c;x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c==\'-\')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-\'0\');\n\tx*=f;\n}\nconst int MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=1000005;\n\nint n,m,a[MAXN];\nint p[MAXN];\nint pl[MAXN],sl[MAXN],pr[MAXN],sr[MAXN];\nint lx[MAXN],ly[MAXN],rx[MAXN],ry[MAXN];\nchar res[MAXN];\nvoid solve()\n{\n\treadint(n),readint(m);\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=0;j<m;++j)\n\t\t\treadint(a[i*m+j]);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tlx[i*m]=ly[i*m]=a[i*m];\n\t\tfor(int j=1;j<m;++j)lx[i*m+j]=min(lx[i*m+j-1],a[i*m+j]),ly[i*m+j]=max(ly[i*m+j-1],a[i*m+j]);\n\t\trx[i*m+m-1]=ry[i*m+m-1]=a[i*m+m-1];\n\t\tfor(int j=m-2;j>=0;--j)rx[i*m+j]=min(rx[i*m+j+1],a[i*m+j]),ry[i*m+j]=max(ry[i*m+j+1],a[i*m+j]);\n\t}\n\tfor(int j=0;j<m-1;++j)\n\t{\n\t\tfor(int i=0;i<n;++i)p[i]=i;\n\t\tsort(p,p+n,[&](int x,int y){return ly[x*m+j]<ly[y*m+j];});\n\t\tpl[0]=ly[p[0]*m+j],pr[0]=rx[p[0]*m+j+1];\n\t\tfor(int i=1;i<n;++i)pl[i]=max(pl[i-1],ly[p[i]*m+j]),pr[i]=min(pr[i-1],rx[p[i]*m+j+1]);\n\t\tsl[n-1]=lx[p[n-1]*m+j],sr[n-1]=ry[p[n-1]*m+j+1];\n\t\tfor(int i=n-2;i>=0;--i)sl[i]=min(sl[i+1],lx[p[i]*m+j]),sr[i]=max(sr[i+1],ry[p[i]*m+j+1]);\n\t\tfor(int i=0;i<n-1;++i)\n\t\t\tif(pl[i]<sl[i+1] && pr[i]>sr[i+1])\n\t\t\t{\n\t\t\t\tprintf(""YES\\n"");\n\t\t\t\tfor(int t=0;t<n;++t)res[p[t]]=(t<=i?\'B\':\'R\');\n\t\t\t\tres[n]=\'\\0\';\n\t\t\t\tprintf(""%s %d\\n"",res,j+1);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tprintf(""NO\\n"");\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(""code.in"",""r"",stdin);\n//\tfreopen(""code.out"",""w"",stdout);\n\t#endif\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}']","[0, 0, 1, 0, 0]",2400,Imagine you fixed some cut and then colored one row red Which rows can now be colored red or blue so that the condition on the left matrix is satisfied If the row has at least one number greater or equal than the numbers in the red row then the row must be red Otherwise it can be either red or blue However imagine a weaker condition Let s look only at the first cell in each row Sort the rows by the first cell in them Similarly if a row is colored red all the rows that are further in the sorted order should also be red because they already have a greater or equal number in them It implies that after you sort the rows the only possible colorings are color some prefix of the rows in blue and the remaining suffix in red So there are possible colorings and possible cuts If we learn to check if they are perfect in we can get the solution in Turns out the condition all numbers in the submatrix should be greater than all numbers in the other submatrix is the same as the minimum in the first submatrix should be greater than the maximum in the second submatrix Thus you can first precalculate prefix and suffix minimums and maximums and check a coloring and a cut in Overall complexity per testcase 
Let s denote the following function f This function takes an array a of length n and returns an array Initially the result is an empty array For each integer i from 1 to n we add element a i to the end of the resulting array if it is greater than all previous elements more formally if a i max limits 1 le j i a j Some examples of the function f if a 3 1 2 7 7 3 6 7 8 then f a 3 7 8 if a 1 then f a 1 if a 4 1 1 2 3 then f a 4 if a 1 3 1 2 6 8 7 7 4 11 10 then f a 1 3 6 8 11 You are given two arrays array a 1 a 2 dots a n and array b 1 b 2 dots b m You can delete some elements of array a possibly zero To delete the element a i you have to pay p i coins the value of p i can be negative then you get p i coins if you delete this element Calculate the minimum number of coins possibly negative you have to spend for fulfilling equality f a b ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=501000;\nstruct node {\n\tll fg;\n\tll val;\n}nd[4*N];\nvoid upd(int p) {\n\n}\nvoid setf(int p,ll v) {\n\tnd[p].fg+=v;\n\tnd[p].val+=v;\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tnd[p].val=1ll<<60;\n\tif (l==r) {\n\t\tif (l==0) nd[p].val=0;\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nvoid push(int p) {\n\tif (nd[p].fg) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\nll query(int p,int l,int r,int x) {\n\tif (l==r) return nd[p].val;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (x<=md) return query(p+p,l,md,x);\n\t\telse return query(p+p+1,md+1,r,x);\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,ll v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n\nint n,a[N],p[N],b[N],m;\n\nint main() {\n\tscanf(""%d"",&n);\n\trep(i,1,n+1) scanf(""%d"",a+i);\n\trep(i,1,n+1) scanf(""%d"",p+i);\n\tscanf(""%d"",&m);\n\trep(i,1,m+1) scanf(""%d"",b+i);\n\tb[m+1]=1<<30;\n\tbuild(1,0,m);\n\trep(i,1,n+1) {\n\t\tint j=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (b[j]==a[i]) {\n\t\t\tmodify(1,0,m,j+1,m,min(p[i],0));\n\t\t\tll a=query(1,0,m,j);\n\t\t\tll x=a+min(p[i],0),y=query(1,0,m,j-1);\n\t\t\tmodify(1,0,m,j,j,min(x,y)-a);\n\t\t\tmodify(1,0,m,0,j-1,p[i]);\n\t\t} else {\n\t\t\tmodify(1,0,m,j,m,min(p[i],0));\n\t\t\tmodify(1,0,m,0,j-1,p[i]);\n\t\t}\n\t\t//rep(j,0,m+1) printf(""%lld "",query(1,0,m,j));\n\t\t//puts("""");\n\t}\n\tll a=query(1,0,m,m);\n\tif (a>=1ll<<55) puts(""NO""); else printf(""YES\\n%lld\\n"",a);\n}']","[1, 0, 0, 1, 1]",2500,The naive version of the solution is just dynamic programming let be the minimum cost of removed elements or the maximum cost of remaining elements if we considered first elements of and the resulting sequence maps to the first elements of There are two versions of this solution both working in calculate this dp as it is so there are states and transitions from each state ensure that the th element is taken into so there are states since each element appears in exactly once the second state can be deduces from the first one but up to transitions from each state It turns out that we can optimize the second approach Let s calculate the values of in ascending order of first of all we calculate the values of such that then transition into states such that and so on Calculating for is easy since the first element of is always the first element of we should delete all elements before the th if we want it to be the first element in So if is the maximum possible sum of costs of remaining elements if we considered the first elements of and the th element gets included in then for indices such that Okay now let s consider advancing from to If we want to go from to such that and we should leave the element in the array and delete some elements between indices and Which ones should be deleted First of all they are all elements with negative deletion cost but we should also get rid of all elements which could replace in that is all elements that are greater than So the remaining elements are which have and and we should be able to compute the sum of such elements Even if we manage to do it in which is possible there may be up to possible pairs of and to consider The easiest way to get rid of that is to sort all occurences of and and process them in ascending order maintaining the best that was already met That way each of the elements of will be considered at most twice so this solution runs in We know how to calculate the values now but how to determine the answer We should consider all values of such that and delete all elements with negative costs and all elements that are greater than from the suffix so this is another query of the form compute the sum of over which have and The most straightforward way to process them in is to use a persistent segment tree but since does not decrease in these queries as we process them we may maintain the elements we are interested in with a much simpler data structure for example Fenwick tree 
n students attended the first meeting of the Berland SU programming course n is even All students will be divided into two groups Each group will be attending exactly one lesson each week during one of the five working days Monday Tuesday Wednesday Thursday and Friday and the days chosen for the groups must be different Furthermore both groups should contain the same number of students Each student has filled a survey in which they told which days of the week are convenient for them to attend a lesson and which are not Your task is to determine if it is possible to choose two different week days to schedule the lessons for the group the first group will attend the lesson on the first chosen day the second group will attend the lesson on the second chosen day and divide the students into two groups so the groups have equal sizes and for each student the chosen lesson day for their group is convenient ,"['/**\n *    author:  tourist\n *    created: 10.10.2021 12:06:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<vector<int>> a(n, vector<int>(5));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 5; j++) {\n        cin >> a[i][j];\n      }\n    }\n    bool ok = false;\n    for (int x = 0; x < 5; x++) {\n      for (int y = x + 1; y < 5; y++) {\n        int ka = 0;\n        int kb = 0;\n        int kab = 0;\n        for (int i = 0; i < n; i++) {\n          if (a[i][x] == 1 && a[i][y] == 1) {\n            kab += 1;\n          } else {\n            if (a[i][x] == 1) {\n              ka += 1;\n            }\n            if (a[i][y] == 1) {\n              kb += 1;\n            }\n          }\n        }\n        if (ka + kb + kab == n && ka + kab >= n / 2 && kb + kab >= n / 2) {\n          ok = true;\n        }\n      }\n    }\n    cout << (ok ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","[0, 0, 1, 0, 0]",1000,Since there are only five days we can iterate over the two of them that will be the answer Now we have fixed a pair of days and and want to check if it can be the answer All students can be divided into four groups marked neither of days and marked only day marked only day and marked both days Obviously if the first group is non empty days and can t be the answer Let s call the number of students who only marked day and the number of students who only marked day If either of or exceed then days and can t be the answer as well Otherwise we can always choose students from the ones who marked both days and send them to day The rest of the students can go to day 
Oh New Year The time to gather all your friends and reflect on the heartwarming events of the past year n friends live in a city which can be represented as a number line The i th friend lives in a house with an integer coordinate x i The i th friend can come celebrate the New Year to the house with coordinate x i 1 x i 1 or stay at x i Each friend is allowed to move no more than once For all friends 1 le x i le n holds however they can come to houses with coordinates 0 and n 1 if their houses are at 1 or n respectively For example let the initial positions be x 1 2 4 4 The final ones then can be 1 3 3 4 0 2 3 3 2 2 5 5 2 1 3 5 and so on The number of occupied houses is the number of distinct positions among the final ones So all friends choose the moves they want to perform After that the number of occupied houses is calculated What is the minimum and the maximum number of occupied houses can there be ,"['#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int lli;\ntypedef pair<int,int> pii;\n\nconst int MAXN = 200010;\n\nint n;\n\nint v[MAXN];\n\nbool marc[MAXN];\n\nint getMin()\n{\n\tint ans = 0;\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t{\n\t\tint x = v[i];\n\n\t\tif( !marc[x - 1] && !marc[x] && !marc[x + 1] )\n\t\t{\n\t\t\tans++;\n\t\t\tmarc[x + 1] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint getMax()\n{\n\tint ans = 0;\n\n\tmemset( marc , false , sizeof(marc) );\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t{\n\t\tint x = v[i];\n\n\t\tif( !marc[x - 1] )\n\t\t{\n\t\t\tans++;\n\t\t\tmarc[x - 1] = true;\n\t\t}\n\t\telse if( !marc[x] )\n\t\t{\n\t\t\tans++;\n\t\t\tmarc[x] = true;\n\t\t}\n\t\telse if( !marc[x + 1] )\n\t\t{\n\t\t\tans++;\n\t\t\tmarc[x + 1] = true;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(""%d"",&n);\n\n\tfor(int i = 1 ; i <= n ; i++)\n\t\tscanf(""%d"",&v[i]);\n\n\tsort( v + 1 , v + n + 1 );\n\n\tprintf(""%d "",getMin());\n\tprintf(""%d "",getMax());\n}']","[1, 0, 0, 1, 0]",1800,At first treat the two subtasks as completely independent problems For both solutions the array of frequences is more convinient to use so let s build it is the number of friends living in house 1 MinimumCollect the answer greedily from left to right If then proceed to otherwise add to the answer and proceed to To prove that let s maximize the number of merges of houses instead of minimizing the actual count of them It s easy to show that the final number of houses is the initial one minus the number of merges So if there are people in all consecutive houses starting from then merges is the absolute best you can do with them skipping any of the merges won t get the better answer For only of them occupied merge is the best and we can achieve that merge And a single occupied house obviously will do merges 2 MaximumAlso greedy but let s process the houses in segments of consecutive positions with positive Take a look at the sum of some segment of houses If the sum is greater than the length then you can enlarge that segment house to the left or to the right If the sum is greater by at least than you can enlarge it both directions at the same time Thus the following greedy will work Let s update the segments from left to right For each segments check the distance to the previous one if it was enlarged to the right then consider the new right border If you can enlarge the current segment and there is space on the left then enlarge it And if you still have possibility to enlarge the segment then enlarge it to the right Notice that it doesn t matter which of any pair of consecutive segments will take the spot between them as the answer changes the same The initial segments can be obtained with two pointers Overall complexity 
Dima s spent much time thinking what present to give to Inna and gave her an empty sequence Now they want to fill sequence with numbers zero and one For that they decided to play an amusing game Before the game begins Dima chooses integers Then Inna and Dima start playing that is adding numbers to sequence Each new number they choose is added to the end of the sequence At some moments of time Dima feels that the game is going to end too soon and he wants to play with Inna as long as possible so he hits a table hard with his fist At that the th th th th numbers from the beginning simultaneously fall out of the sequence the sequence gets numbers less Here is such maximum number that value doesn t exceed the current length of the sequence If number is larger than the current length of then nothing falls out of the sequence You are given the chronological sequence of events in the game Each event is either adding a number to the end of sequence or Dima s hit on the table Calculate the sequence after all these events happen ,"['#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <utility>\n#include <set>\n#include <map>\n\n#define reset(a , b) memset(a , b , sizeof(a))\n\nusing namespace std;\n\nconst int INF = 1000000007;\nconst int N = 5001000;\n\nint l[N] , h[N] , leaf[N] , node[N] , a[N] , cur;\nint  n , m , cmd[N] , nb , b[N];\n\nvoid build(int r , int low , int high ){\n    l[r] = low; h[r] = high;\n    if (low == high) {\n        leaf[low] = r;\n        return;\n    }\n    int mid = (low + high) / 2;\n    build(r*2,low,mid);\n    build(r*2+1,mid+1,high);\n}\n\nvoid update(int i , int val) {\n    i = leaf[i];\n    node[i] = val;\n    while (i > 1){\n        i /= 2;\n        node[i] = node[i * 2] + node[i * 2 + 1];\n    }\n}\n\nint Find(int r , int val) {\n    if (l[r] == h[r]) return l[r];\n    if (node[r*2] >= val)\n        return Find(r*2 , val);\n    else\n        return Find(r * 2 + 1 , val - node[r*2]);\n}\n\nint main() {\n    //freopen(""input.in"" , ""r"" , stdin);\n    //freopen(""output.out"" , ""w"" , stdout);\n\n    cin >> m >> n;\n    for (int i = 1 ; i <= n ; i++)\n        scanf(""%d"" , &a[i]);\n    build(1 , 1 , 1000001);\n\n    for (int i = 1 ; i <= m ; i++){\n        scanf(""%d"" , &cmd[i]);\n        if (cmd[i] == 1 || cmd[i] == 0)\n            update(i , 1),cur++;\n\n        if (cmd[i] == -1){\n            nb = 0;\n            for (int j = 1 ; j <= n ; j++){\n                if (a[j] > cur) break;\n                b[++nb] = Find(1 , a[j]);\n                //update(id , 0);\n            }\n            for (int j = 1 ; j <= nb ; j++)\n                update(b[j] , 0);\n            cur -= nb;\n        }\n    }\n    bool OK = true;\n    for (int i = 1 ; i <= m ; i++){\n        int j = leaf[i];\n        if (node[j] != 0){\n            printf(""%d"", cmd[i]);\n            OK = false;\n        }\n    }\n    if (OK) {\n        cout << ""Poor stack!"" << endl;\n        return 0;\n    }\n}\n']","[0, 0, 0, 1, 1]",2000,Lets note that not more than numbers thus it will be not more than dropings We will run this process using data structure Segment Tree you can use another structures Lets calculate the number of numbers in current segment When the number is added we should simply go down from the root to the leaf and increase value for each segment on the way by 1 Deletetion vice versa If there is enough numbers in the left subtree we should go into the right one othervise into the left one Don t forget to shift the position by decreasing on as all numbers are droped immidiately And don t forget to break the cycle as soon as you reach first such that there is no number to be droped out from it 
You are given a matrix a consisting of positive integers It has n rows and m columns Construct a matrix b consisting of positive integers It should have the same size as a and the following conditions should be met 1 le b i j le 10 6 b i j is a multiple of a i j the absolute value of the difference between numbers in any adjacent pair of cells two cells that share the same side in b is equal to k 4 for some integer k ge 1 k is not necessarily the same for all pairs it is own for each pair We can show that the answer always exists ,"['#include<bits/stdc++.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,m,a[505][505];\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tint x;\n\t\t\tscanf(""%d"",&x);\n\t\t\tif((i+j)&1)a[i][j]=720720;\n\t\t\telse a[i][j]=720720-x*x*x*x;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<m;++j)printf(""%d "",a[i][j]);\n\t\tprintf(""%d\\n"",a[i][m]);\n\t}\n    return 0;\n}\n']","[0, 1, 0, 0, 0]",2200,SolutionBuild a matrix with a checkerboard pattern let if is even and otherwise The difference between two adjacent cells is obviously a fourth power of an integer We choose because it is This ensures that is a multiple of because it is either itself or the sum of two multiples of Complexity 
Danil decided to earn some money so he had found a part time job The interview have went well so now he is a light switcher Danil works in a rooted tree undirected connected acyclic graph with vertices vertex is the root of the tree There is a room in each vertex light can be switched on or off in each room Danil s duties include switching light in all rooms of the subtree of the vertex It means that if light is switched on in some room of the subtree he should switch it off Otherwise he should switch it on Unfortunately or fortunately Danil is very lazy He knows that his boss is not going to personally check the work Instead he will send Danil tasks using personal messages There are two types of tasks describes a task to switch lights in the subtree of vertex describes a task to count the number of rooms in the subtree of in which the light is turned on Danil should send the answer to his boss using messages A subtree of vertex is a set of vertices for which the shortest path from them to the root passes through In particular the vertex is in the subtree of Danil is not going to perform his duties He asks you to write a program which answers the boss instead of him ,"['#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=200005;\nint ti,n,q,a[N],nextt[N],ed[N],son[N];\nint nedge,tree[N<<2],in[N],out[N],lazy[N<<2];\ninline int p(int a,int b){\n\treturn a+b;\n}\ninline void cao(int p,int l,int r){\n\ttree[p]=r-l+1-tree[p];\n}\ninline void pushdown(int p,int l,int r){\n\tif(!lazy[p])return; int mid=(l+r)>>1;\n\tlazy[p<<1]^=lazy[p]; lazy[(p<<1)+1]^=lazy[p]; cao(p<<1,l,mid); cao((p<<1)^1,mid+1,r); lazy[p]=0;\n}\ninline int ask(int l,int r,int i,int j,int nod){int mid=(l+r)>>1;\n\tif (l==i&&j==r) return tree[nod]; pushdown(nod,l,r);\n\tif (j<=mid) return ask(l,mid,i,j,nod<<1);\n\telse if(i>mid) return ask(mid+1,r,i,j,(nod<<1)+1);\n\tint left=ask(l,mid,i,mid,nod<<1);\n\tint right=ask(mid+1,r,mid+1,j,(nod<<1)+1);\n\treturn p(left,right);\n}\ninline void insert(int l,int r,int i,int j,int nod){int mid=(l+r)>>1;\n\tif(l==i&&r==j){\n\t\tlazy[nod]^=1; cao(nod,l,r); return;\n\t}\n    pushdown(nod,l,r);\n    if(j<=mid)insert(l,mid,i,j,nod<<1); else\n    if(i>mid)insert(mid+1,r,i,j,(nod<<1)+1); else{\n    \tinsert(l,mid,i,mid,nod<<1); insert(mid+1,r,mid+1,j,(nod<<1)+1);\n\t}\n\ttree[nod]=p(tree[nod<<1],tree[(nod<<1)^1]);\n}\ninline void build(int l,int r,int nod){int mid=(l+r)>>1;\n\tif (l==r) {tree[nod]=a[l]; return;}\n\tbuild(l,mid,nod<<1); build(mid+1,r,(nod<<1)+1);\n\ttree[nod]=p(tree[nod<<1],tree[(nod<<1)+1]);\n}\ninline void write(int a){\n\tif(a>=10)write(a/10);\n\tputchar(\'0\'+a%10);\n}\ninline void writeln(int a){\n\twrite(a); puts("""");\n}\ninline int\tread(){\n\tint x = 0; char ch = getchar(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = getchar())\tif (ch == \'-\')\tpositive = 0;\n\tfor (; isdigit(ch); ch = getchar())\tx = x * 10 + ch - \'0\';\n\treturn positive ? x : -x;\n}\ninline void aedge(int a,int b){\n\tnextt[++nedge]=son[a]; son[a]=nedge; ed[nedge]=b;\n}\ninline void dfs(int p){\n\tin[p]=++ti;\n\tfor(int i=son[p];i;i=nextt[i]){\n\t\tdfs(ed[i]);\n\t}\n\tout[p]=ti;\n}\nchar ch[10];\nint main(){\n\tn=read();\n\tfor(int i=2;i<=n;i++){\n\t\tint t1=read();\n\t\taedge(t1,i);\n\t}\n\tdfs(1);\n\tfor(int i=1;i<=n;i++)a[in[i]]=read();\n\tbuild(1,n,1);\n\tq=read();\n\twhile(q--){\n\t\tscanf(""%s"",&ch); int s1=read();\n\t\tif(ch[0]==\'g\'){\n\t\t\twriteln(ask(1,n,in[s1],out[s1],1));\n\t\t}else{\n\t\t\tinsert(1,n,in[s1],out[s1],1);\n\t\t}\n\t}\n}']","[0, 0, 0, 0, 1]",2000,Let s construct Euler tour tree We ll put vertex in vector when first time visit it For each vertext subtree is segment in this vector borders of which we can calculate while constructing Now we need to make inversion on segment and get sum of segment Segment tree is good for it 
You are given an array a 1 a 2 dots a n such that 1 le a i le 10 9 Let S be the sum of all elements of the array a Let s call an array b of n integers if 1 le b i le 10 9 for each i from 1 to n for every pair of adjacent integers from the array b i b i 1 either b i divides b i 1 or b i 1 divides b i or both 2 sum limits i 1 n a i b i le S Your task is to find any beautiful array It can be shown that at least one beautiful array always exists ,"['#pragma GCC optimize(""Ofast"")\n#pragma GCC target (""sse4"")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tvector<int> ans(n);\n\trep(i, n) {\n\t\tint x = 1; while (x * 2 <= a[i])x *= 2;\n\t\tans[i] = x;\n\t}\n\trep(i, n) {\n\t\tif (i > 0)cout << "" "";\n\t\tcout << ans[i];\n\t}\n\tcout << ""\\n"";\n\t\n}\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}']","[1, 0, 0, 0, 0]",1400,It is enough to consider two possible arrays and It is not difficult to notice that in these arrays the condition is met that among two neighboring elements one divides the other It remains to show that at least one of these two arrays satisfies the condition Let s consider the sum of elements at odd positions and the sum of elements at even positions Since at least one of the values of and does not exceed because otherwise their sum will be strictly greater than Without losing generality assume that Note that for the second variant of the array the condition holds so 
Let operatorname lowbit x denote the value of the lowest binary bit of x e g operatorname lowbit 12 4 operatorname lowbit 8 8 For an array a of length n if an array s of length n satisfies s k left sum limits i k operatorname lowbit k 1 k a i right bmod 998 244 353 for all k then s is called the of a Let s denote it as s f a For a positive integer k and an array a f k a is defined as follows f k a begin cases f a textrm if k 1 f f k 1 a textrm otherwise end cases You are given an array b of length n and a positive integer k Find an array a that satisfies 0 le a i 998 244 353 and f k a b It can be proved that an answer always exists If there are multiple possible answers you may print any of them ,"['/** *    author:  tourist *    created: 30.04.2024 11:03:36**/#include <bits/stdc++.h>\xa0using namespace std;\xa0#ifdef LOCAL#include ""algo/debug.h""#else#define debug(...) 42#endif\xa0template <typename T>T inverse(T a, T m) {  T u = 0, v = 1;  while (a != 0) {    T t = m / a;    m -= t * a; swap(a, m);    u -= t * v; swap(u, v);  }  assert(m == 1);  return u;}\xa0template <typename T>class Modular { public:  using Type = typename decay<decltype(T::value)>::type;\xa0  constexpr Modular() : value() {}  template <typename U>  Modular(const U& x) {    value = normalize(x);  }\xa0  template <typename U>  static Type normalize(const U& x) {    Type v;    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);    else v = static_cast<Type>(x % mod());    if (v < 0) v += mod();    return v;  }\xa0  const Type& operator()() const { return value; }  template <typename U>  explicit operator U() const { return static_cast<U>(value); }  constexpr static Type mod() { return T::value; }\xa0  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }  Modular& operator++() { return *this += 1; }  Modular& operator--() { return *this -= 1; }  Modular operator++(int) { Modular result(*this); *this += 1; return result; }  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }  Modular operator-() const { return Modular(-value); }\xa0  template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));    return *this;  }  template <typename U = T>  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());    value = normalize(value * rhs.value - q * mod());    return *this;  }  template <typename U = T>  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {    value = normalize(value * rhs.value);    return *this;  }\xa0  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\xa0  friend const Type& abs(const Modular& x) { return x.value; }\xa0  template <typename U>  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\xa0  template <typename U>  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\xa0  template <typename V, typename U>  friend V& operator>>(V& stream, Modular<U>& number);\xa0 private:  Type value;};\xa0template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\xa0template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\xa0template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\xa0template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\xa0template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\xa0template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\xa0template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\xa0template<typename T, typename U>Modular<T> power(const Modular<T>& a, const U& b) {  assert(b >= 0);  Modular<T> x = a, res = 1;  U p = b;  while (p > 0) {    if (p & 1) res *= x;    x *= x;    p >>= 1;  }  return res;}\xa0template <typename T>bool IsZero(const Modular<T>& number) {  return number() == 0;}\xa0template <typename T>string to_string(const Modular<T>& number) {  return to_string(number());}\xa0// U == std::ostream? but done this way because of fastoutputtemplate <typename U, typename T>U& operator<<(U& stream, const Modular<T>& number) {  return stream << number();}\xa0// U == std::istream? but done this way because of fastinputtemplate <typename U, typename T>U& operator>>(U& stream, Modular<T>& number) {  typename common_type<typename Modular<T>::Type, long long>::type x;  stream >> x;  number.value = Modular<T>::normalize(x);  return stream;}\xa0/*using ModType = int;\xa0struct VarMod { static ModType value; };ModType VarMod::value;ModType& md = VarMod::value;using Mint = Modular<VarMod>;*/\xa0constexpr int md = 998244353;using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\xa0vector<Mint> fact(1, 1);vector<Mint> inv_fact(1, 1);\xa0Mint C(int n, int k) {  if (k < 0 || k > n) {    return 0;  }  k = min(k, n - k);  while ((int) fact.size() < k + 1) {    fact.push_back(fact.back() * (int) fact.size());    inv_fact.push_back(1 / fact.back());  }  Mint ret = inv_fact[k];  for (int i = 1; i <= k; i++) {    ret *= n - i + 1;  }  return ret;}\xa0int main() {  ios::sync_with_stdio(false);  cin.tie(0);  int tt;  cin >> tt;  while (tt--) {    int n, k;    cin >> n >> k;    vector<Mint> b(n);    for (int i = 0; i < n; i++) {      cin >> b[i];    }    vector<Mint> a(n);    for (int i = 0; i < n; i++) {      int j = 0;      while (i & (1 << j)) {        j += 1;      }      for (int t = 0; t < (1 << j) - 1; t++) {        int who = i - (1 << j) + 1 + t;        int vals = j - __builtin_popcount(t);        b[i] -= a[who] * C(vals + k - 1, k - 1);      }      a[i] = b[i];    }    for (int i = 0; i < n; i++) {      cout << a[i] << "" \\n""[i == n - 1];    }  }  return 0;}']","[0, 1, 0, 1, 1]",2300,It s well known that Fenwick Tree is the data structure shown in the image below and the sum of each subtree is stored at each vertex i e and Denote the depth of a vertex as Assume that Consider a vertex and one of its ancestors Let It can be easily proved by using the stars and bars method or generating functions that the coefficient of in is Obviously is satisfied for each leaf Enumerate each vertex whose value is already known just in the increasing order is fine and all its ancestors remove the part from and we can calculate the value of each vertex Time complexity is because the height of a Fenwick Tree is 
Recently Maxim has found an array of integers needed by no one He immediately come up with idea of changing it he invented positive integer and decided to add or subtract it from arbitrary array elements Formally by applying single operation Maxim chooses integer and replaces the th element of array either with or with Please note that the operation may be applied more than once to the same position Maxim is a curious minimalis thus he wants to know what is the minimum value that the product of all array elements i e can reach if Maxim would apply no more than operations to it Please help him in that ,"['#include<bits/stdc++.h>\n#define ll long long\n#define N 200005\nusing namespace std;\n\nint n,m,x;\nstruct node{\n\tll x; int y,z;\n}a[N];\nbool operator <(node u,node v){ return u.x>v.x; }\nbool cmp(node u,node v){ return u.y<v.y; }\npriority_queue<node> q;\nint read(){\n\tint x=0; char cr=getchar(); bool flag=0;\n\twhile (cr<\'0\' || cr>\'9\'){ if (cr==\'-\') flag=1; cr=getchar(); }\n\twhile (cr>=\'0\' && cr<=\'9\'){ x=x*10+cr-\'0\'; cr=getchar(); }\n\treturn (flag)?-x:x;\n}\nvoid opt(){\n\tint i;\n\tfor (i=1; i<=n; i++){\n\t\tif ((a[i].z<0) && (a[i].x!=0)) putchar(\'-\');\n\t\tprintf(""%lld "",a[i].x);\n\t}\n}\nint main(){\n\tscanf(""%d%d%d"",&n,&m,&x);\n\tint i,j,k; bool flag=0,flag2=0;\n\tfor (i=1; i<=n; i++){\n\t\ta[i].x=read(); if (a[i].x<0) flag=!flag;\n\t\t\tif (!a[i].x) flag2=1; a[i].y=i; a[i].z=((a[i].x)<0)?-1:1;\n\t}\n\tif (flag2){\n\t\tfor (i=1; i<=n; i++) if (!a[i].x){\n\t\t\tif (!flag) a[i].z=-1; break;\n\t\t}\n\t\tflag=1;\n\t}\n\tfor (i=1; i<=n; i++) a[i].x=abs(a[i].x);\n\tif (!flag){\n\t\tfor (i=2,k=1; i<=n; i++)\n\t\t\tif (a[i].x<a[k].x) k=i;\n\t\tif (a[k].x>=(ll)m*x){\n\t\t\ta[k].x-=(ll)m*x;\n\t\t\topt();return 0;\n\t\t} else{\n\t\t\t//puts(""233"");\n\t\t\tj=(a[k].x/x+1); m-=j;\n\t\t\ta[k].x-=(ll)j*x;\n\t\t\ta[k].z=-a[k].z; a[k].x=-a[k].x;\n\t\t\t//cout<<k<<\' \'<<a[k].z<<endl;\n\t\t}\n\t}\n\tfor (i=1; i<=n; i++) q.push(a[i]);\n\twhile (m--){\n\t\tnode u=q.top(); q.pop();\n\t\tu.x+=x; q.push(u);\n\t}\n\tn=0;\n\twhile (!q.empty()){ a[++n]=q.top(); q.pop(); }\n\tsort(a+1,a+n+1,cmp);\n\topt();\n\treturn 0;\n}']","[1, 1, 0, 0, 1]",2000,Main idea we act greedily trying to make the best possible answer every action each time we choose an action with minimum possible product after it Detailed explanation While we have zeroes in our array we have to get rid of them changing each of them exactly one time Also we keep the quantity of negative numbers we need it to make the product negative after changing the last zero Let be the number of zeroes in the array If then we cannot make the product negative or positive it will always be equal to so any sequence of operations will lead to a correct answer However if then we are able to come to negative product if the number of negative elements was even then we subtract from one zero and add it to all other zeroes if the number of negative elements was odd then we can just add to all zeroes If current product is still positive then we want to change the sign of exactly one element Its absolute value has to be minimal suppose we have two elements and let s prove that if we change s sign then our answer is wrong Let be the minimum number of operations required to change s sign If we perform operations with then the absolute value of won t change and absolute value of will become If on the other hand we perform operations with this may not be optimal but now we need to prove that if we change then the result will be worse then the absolute value of will become the absolute value of won t change The product becomes negative so we need to maximize the product of absolute values And then and so if we change then the product of absolute values will be less than if we change Now until we have performed operations we choose a number with minimum absolute value and enlarge it add if this number if positive subtract if negative Let s prove that the answer will be optimal Suppose that this algorithm chooses on some iteration but we can t get optimal answer if we change This means that we can t change after this iteration at all we can reorder our operations in an arbitrary way and the answer won t change Suppose we have to change instead and Let s consider the sequence of operations leading to the optimal answer when we choose and replace change of with change of and let the product of all remaining numbers the whole array excluding and after all operations be If we change the total product will be and if we change we get is the number of times we change Now so so the absolute value of total product will be greater if we change This proves that we won t come to unoptimal answer if we change Time complexity if we use a data structure similar to or to get the number with minimal absolute value Memory complexity 
You are the author of a Codeforces round and have prepared n problems you are going to set problem i having difficulty a i You will do the following process remove some possibly zero problems from the list rearrange the remaining problems in any order you wish A round is considered if and only if the absolute difference between the difficulty of any two consecutive problems is at most k less or equal than k What is the minimum number of problems you have to remove so that an arrangement of problems is balanced ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n#define dbg(a)  cerr << #a << "": "" << a << ""\\n""\n\nvoid solve () {\n\tint n, k;  cin >> n >> k;\n\tvector<int> a(n);\n\tfor (auto &ai: a) {\n\t\tcin >> ai;\n\t}\n\tsort(a.begin(), a.end());\n\tint i = 0, j = 1, ans = 1;\n\twhile (j < n) {\n\t\tif (a[j] - a[j - 1] > k) {\n\t\t\tans = max(ans, j - i);\n\t\t\ti = j;\n\t\t}\n\t\tj++;\n\t}\n\tans = max(ans, n - i);\n\n\tcout << n - ans << ""\\n"";\n}\n\nint main(){\n\tios::sync_with_stdio(0), cin.tie(0);\n\t\n\tint tc = 1;\n\tcin >> tc;\n\tfor (int t = 1; t <= tc; ++t) {\n\t  solve();\n\t}\n}']","[1, 0, 1, 0, 0]",900,Let s calculate the maximum number of problems we can take and the answer will be subtracted by that count An arrangement that always minimizes the absolute difference between adjacent pairs is the array in sorted order What we notice is that if the array is sorted we will always take a subarray all taken elements will be consecutive So the problem converts to finding the largest subarray for which It s easy to see that all the subarrays are totally different don t share any intersection of elements thus we can maintain a count variable of the current number of elements in the current subarray and iterate through array elements from left to right If we currently are at and then we just set the count to since we know a new subarray starts otherwise we just increase our count by The answer will be subtracted by the largest value that our count has achieved 
Ori and Sein have overcome many difficult challenges They finally lit the Shrouded Lantern and found Gumon Seal the key to the Forlorn Ruins When they tried to open the door to the ruins nothing happened Ori was very surprised but Sein gave the explanation quickly clever Gumon decided to make an additional defence for the door There are n lamps with Spirit Tree s light Sein knows the time of turning on and off for the i th lamp l i and r i respectively To open the door you have to choose k lamps in such a way that there will be a moment of time when they all will be turned on While Sein decides which of the k lamps to pick Ori is interested how many ways there are to pick such k lamps that the door will open It may happen that Sein may be wrong and there are no such k lamps The answer might be large so print it modulo 998 244 353 ,"['#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=1e6+5,Mod=998244353;\nint n,a[N],s1[N],s2[N],fac[N]={1,1},finv[N]={1,1},k,ans,l[N],r[N],cnt;\nint C(int n,int m){\n\tif(m>n||n<0||m<0) return 0;\n\treturn 1ll*fac[n]*finv[m]%Mod*finv[n-m]%Mod;\n}\npair<int,int>b[N];\nint main(){\n\tscanf(""%d%d"",&n,&k);\n\trep(i,2,n) fac[i]=1ll*fac[i-1]*i%Mod;\n\trep(i,2,n) finv[i]=1ll*(Mod-Mod/i)*finv[Mod%i]%Mod;\n\trep(i,1,n) finv[i]=1ll*finv[i-1]*finv[i]%Mod;\n\trep(i,1,n){\n\t\tint l,r; scanf(""%d%d"",&l,&r);\n\t\tb[i*2]=make_pair(l,i*2);\n\t\tb[i*2+1]=make_pair(r,i*2+1);\n\t\t/*s1[l]++,s1[r+1]--;\n\t\ts2[l+1]++,s2[r+1]--;*/\n\t}\n\tsort(b+2,b+2*n+1+1);\n\trep(i,2,2*n+1){\n\t\tint p=b[i].second;\n\t\tif(b[i].first!=b[i-1].first) cnt++;\n\t\tif(p&1){\n\t\t\tr[p/2]=cnt;\n\t\t}else{\n\t\t\tl[p/2]=cnt;\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ts1[l[i]]++; s1[r[i]+1]--;\n\t\ts2[l[i]+1]++; s2[r[i]+1]--;\n\t}\n\trep(i,1,cnt) s1[i]=s1[i-1]+s1[i],s2[i]=s2[i-1]+s2[i];\n\trep(i,1,cnt){\n\t\tans=(1ll*ans+C(s1[i],k)+Mod-C(s2[i],k))%Mod;\n\t}\n\tprintf(""%d\\n"",ans);\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1]",1800,In this task we need to find the number of sets of segments such that these segments intersect at least in one point Let s look at the starting point of the intersection This point will always be the beginning of a segment Let us find the number of sets of segments that their intersection begins at the point Let us denote as number of segments that pass through this point and as numbers of segments that start at this point Then all the segments must pass through and at least one segment must start at The number of sets of segments passing through is and the number of sets of segments passing through none of which starts at is From here we obtain that the required number of piece sets is By summing up all possible values we get the answer to the task It should be noted that and can be easily supported using the event method Then the total runtime will be 
On February 14 Denis decided to give Valentine to Nastya and did not come up with anything better than to draw a huge red heart on the door of the length k k ge 3 Nastya was very confused by this present so she decided to break the door throwing it on the mountains Mountains are described by a sequence of heights a 1 a 2 dots a n in order from left to right k le n It is guaranteed that neighboring heights are not equal to each other that is a i ne a i 1 for all i from 1 to n 1 Peaks of mountains on the segment l r from l to r are called indexes i such that l i r a i 1 a i and a i a i 1 It is worth noting that the boundary indexes l and r for the segment For example if n 8 and a 3 1 4 1 5 9 2 6 then the segment 1 8 has only two peaks with indexes 3 and 6 and there are no peaks on the segment 3 6 To break the door Nastya throws it to a segment l l k 1 of consecutive mountains of length k 1 le l le n k 1 When the door touches the peaks of the mountains it breaks into two parts after that these parts will continue to fall in different halves and also break into pieces when touching the peaks of the mountains and so on Formally the number of parts that the door will break into will be equal to p 1 where p is the number of peaks on the segment l l k 1 Nastya wants to break it into as many pieces as possible Help her choose such a segment of mountains l l k 1 that the number of peaks on it is maximum If there are several optimal segments Nastya wants to find one for which the value l is minimal Formally you need to choose a segment of mountains l l k 1 that has the maximum number of peaks Among all such segments you need to find the segment that has the minimum possible value l ,"['#include <bits/stdc++.h>\n\nint A[210000];\nint P[210000];\nint pre[210000];\n\nint main() {\n    int T; scanf(""%d"", &T);\n    while (T--) {\n        int N, K;\n        scanf(""%d%d"", &N, &K);\n        for (int i = 0; i < N; ++i)\n            scanf(""%d"", &A[i]);\n        for (int i = 1; i < N - 1; ++i)\n            P[i] = (A[i] > A[i - 1] && A[i] > A[i + 1]);\n        for (int i = 1; i <= N; ++i) pre[i] = pre[i - 1] + P[i - 1];\n        int maxi = 0;\n        for (int i = 0; i + K - 1 < N; ++i)\n            if (pre[maxi + K - 1] - pre[maxi + 1] < pre[i + K - 1] - pre[i + 1])\n                maxi = i;\n        printf(""%d %d\\n"", pre[maxi + K - 1] - pre[maxi + 1] + 1, maxi + 1);\n    }\n}\n']","[1, 0, 1, 0, 0]",1300,Let s make an array consisting of and such that it shows whether the position is a peak on the whole segment To do this we will go through the indices from to and if the conditions and are true then we write in a new array at position After that we calculate the prefix sum in the new array Now the number of peaks in the segment is calculated as so we find out how many peaks in the desired segment not including the boundaries of the segment It remains only to go through all from to and find the leftmost such that as much as possible 
Let s define S x to be the sum of digits of number x written in decimal system For example S 5 5 S 10 1 S 322 7 We will call an integer x if S x 1 S x In each test you will be given one integer n Your task is to calculate the number of integers x such that 1 le x le n and x is interesting ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\ntcT> int upb(V<T>& a, const T& b) { return int(ub(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n\n\tconst clock_t beg = clock();\n\t#define dbg_time() dbg((db)(clock()-beg)/CLOCKS_PER_SEC)\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nvoid solve(int tc) {\n\t// 9 -> 1\n\tints(n);\n\twhile ((n+1)%10 != 0) --n;\n\tps((n+1)/10);\n}\n\nint main() {\n\tsetIO();\n\tint TC; re(TC);\n\tFOR(i,1,TC+1) solve(i);\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 1, 0, 0, 0]",800,Let s think what properties do all interesting numbers have Well if a number does not end with we can say for sure that because the last digit will get increased What if the number ends with Then the last digit will become so no matter what happens to other digits we can say that will surely be less than So the problem asks us to count all numbers with the last digit equal to It is not hard to see that the answer is equal to This concludes the solution as we are now able to answer all testcases in resulting in total runtime 
You are given an array a of length n You are asked to process q queries of the following format given integers i and x multiply a i by x After processing each query you need to output the greatest common divisor GCD of all elements of the array a Since the answer can be too large you are asked to output it modulo 10 9 7 ,"['#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mkp make_pair\n#define vi vector<int>\n#define pii pair<int,int>\n#define FI(n) FastIO::read(n)\n#define FO(n) FastIO::write(n)\n#define ull unsigned long long\n#define mst(a,b) memset(a,b,sizeof(a))\n#define foR(i,k,j) for(int i=(k);i>=(j);i--)\n#define For(i,k,j) for(int i=(k);i<=(j);i++)\n#define Foe(i,u) for(int i=lst[u],v=e[i].v;i;i=e[i].nxt,v=e[i].v)\n#define IOS ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)\n#define Fin(s) freopen(s,""r"",stdin)\n#define Fout(s) freopen(s,""w"",stdout)\n#define file(s) Fin(s"".in""),Fout(s"".out"")\n#define INF ((1<<30)-1)\n#define int long long\nconst int P=1e9+7; //\nusing namespace std;\ntemplate<typename T>inline void ckmax(T &a,T b) {(a<b)&&(a=b);}\ntemplate<typename T>inline void ckmin(T &a,T b) {(a>b)&&(a=b);}\ninline int mul(int a,int b) {return 1ll*a*b%P;}\n//inline int add(int a,int b) {return a+b>=P?a+b-P:a+b;}\ninline int sub(int a,int b) {return a-b>=0?a-b:a-b+P;}\ninline void mulmod(int &a,int b) {a=mul(a, b);}\ninline void addmod(int &a,int b) {((a+=b)>=P)&&(a-=P);}\ninline void submod(int &a,int b) {((a-=b)<0)&&(a+=P);}\ninline void fprint(const vector<int> &f) {for(int i=0;i<f.size();i++) fprintf(stderr,""%d "",f[i]); fprintf(stderr,""\\n"");}\ninline int ksm(int a,int b) {int ans=1; for(;b;b>>=1) {if(b&1) ans=1ll*ans*a%P;a=1ll*a*a%P;}return ans;}\ninline int inv(int a) {return ksm(a,P-2);}\nnamespace FastIO {\n  const int SIZE=1<<16; char buf[SIZE],obuf[SIZE],str[64]; int bi=SIZE,bn=SIZE,opt;\n  int read(char *s) {\n    while (bn) {for (;bi<bn&&buf[bi]<=\' \';bi++);if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}\n    int sn=0;while (bn) {for (;bi<bn&&buf[bi]>\' \';bi++) s[sn++]=buf[bi];if (bi<bn) break; bn=fread(buf,1,SIZE,stdin),bi=0;}s[sn]=0;return sn;\n  }\n  bool read(int& x) {if(x)x=0;int bf=0,n=read(str); if(!n) return 0; int i=0; if (str[i]==\'-\') bf=1,i=1; for(x=0;i<n;i++) x=x*10+str[i]-\'0\'; if(bf) x=-x; return 1;}\n  void write(int x) {\n    if(!x) obuf[opt++]=\'0\'; else {if(x<0) obuf[opt++]=\'-\',x=-x;int sn=0; while(x)str[sn++]=x%10+\'0\',x/=10;for (int i=sn-1;i>=0;i--) obuf[opt++]=str[i];}\n    if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}\n  }\n  void write(char x) {obuf[opt++]=x;if (opt>=(SIZE>>1)){fwrite(obuf,1,opt,stdout); opt=0;}}\n\tvoid Fflush() {if (opt) fwrite(obuf,1,opt,stdout); opt=0;}\n};\ninline int read() {int x; FI(x); return x;}\nconst int MN=2e5+5;\nint n,Q,p[MN],tot,vis[MN];\nvector<int>d[MN];\nvoid init(int n=MN-5) {\n\tfor(int i=2;i<=n;i++) {\n\t\tif(!vis[i]) {\n\t\t\tp[++tot]=i;\n\t\t\tfor(int j=i;j<=n;j+=i) {\n\t\t\t\tvis[j]=1; d[j].pb(i);\n\t\t\t}\t\n\t\t}\n\t\t\n\t}\n}\nint a[MN];\nmap<int,int>t[MN];\npriority_queue<int,vector<int>,greater<int> >q[MN],del[MN];\nint cc[MN];\nvoid erase(int i,int x) {\n\tdel[i].push(x);\n\twhile(q[i].size()&&del[i].size()&&q[i].top()==del[i].top()) q[i].pop(),del[i].pop();\n}\n\nvoid add(int i,int x) {\n\tq[i].push(x);\n}\nsigned main() {\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(""pro.in"",""r"",stdin);\n\t\tfreopen(""pro.out"",""w"",stdout);\n\t#endif\n\tn=read(),Q=read(); init();\n\tFor(i,1,n) a[i]=read();\n\tint res=a[1]; For(i,2,n) res=__gcd(res,a[i]);\n\tFor(i,1,n) {\n\t\tfor(auto it:d[a[i]]) {\n//\t\t\tcerr<<i<<\' \'<<it<<endl;\n\t\t\tint cnt=0;\n\t\t\twhile(a[i]%it==0) a[i]/=it,cnt++;\t\n\t\t\tq[it].push(cnt); t[i][it]=cnt; cc[it]++;\n\t\t}\n\t}\n//\tcerr<<""?"";\n//\tFor(i,1,12) {\n//\t\tcerr<<q[i].size()<<endl;\t\n//\t}\n//\tFor(i,1,12) {\n//\t\tcerr<<cc[i]<<endl;\t\n//\t}\n\twhile(Q--) {\n\t\tint i=read(),x=read();\n//\t\tcerr<<""!""<<\' \'<<i<<\' \'<<x<<endl;\n\t\tfor(auto it:d[x]) {\n\t\t\tint cnt=0;\n\t\t\twhile(x%it==0) x/=it,cnt++;\t\n//\t\t\tcerr<<it<<\' \'<<cnt<<endl;\n\t\t\tif(cc[it]==n) {\n\t\t\t\tassert(q[it].size());\n\t\t\t\tmulmod(res,inv(ksm(it,q[it].top())));\t\n\t\t\t}\n\t\t\tif(t[i].count(it)) {\n//\t\t\t\tcerr<<""?""<<\' \'<<i<<\' \'<<it<<endl;\n\t\t\t\terase(it,t[i][it]);\n\t\t\t\tt[i][it]+=cnt; add(it,t[i][it]);\n\t\t\t} else {\n\t\t\t\tt[i][it]=cnt; add(it,t[i][it]); cc[it]++;\n\t\t\t}\n//\t\t\tcerr<<""?"";\n\t\t\tif(cc[it]==n) {\n//\t\t\t\tcerr<<it<<\' \'<<q[it].top()<<endl;\n\t\t\t\tmulmod(res,ksm(it,q[it].top()));\t\n\t\t\t}\n\t\t}\n\t\tprintf(""%d\\n"",res);\n\t}\n\treturn FastIO::Fflush(),0;\n}\n/*\n0. Enough array size? Enough array size? Integer overflow?\n\n1. Think TWICE, Code ONCE!\nAre there any counterexamples to your algo?\n\n2. Be careful about the BOUNDARIES!\nN=1? P=1? Something about 0?\n\n3. Do not make STUPID MISTAKES!\nTime complexity? Memory usage? Precision error?\n*/']","[0, 1, 1, 0, 1]",2100,Notice that after each query the answer doesn t become smaller and we can solve the problem for each prime divisor independently For each number let s maintain an amount of occurences for all its prime divisors you can implement it using For each prime divisor let s write to its corresponding the amount of times it is met in every of the numbers of the array at the same time we won t add null values Initially Let s understand the way a prime divisor is included in the answer If the size of its is not equal to then won t change otherwise where is a minimal number of Since is not decreasing then we can avoid calculating it all over again every time and instead recalculate it only for divisors that are being changed with that because the minimal number of is not decreasing as well we can just increase the answer using multiplication To process the query we need to find the prime factorization of for example using the Sieve of Eratosthenes and add the prime divisors to the for th element and correspondingly change the for that divisor Each query is processed in the complexity of the amount of prime divisors multiplied by the time of and operation i e 
Omkar is creating a mosaic using colored square tiles which he places in an n times n grid When the mosaic is complete each cell in the grid will have either a glaucous or sinoper tile However currently he has only placed tiles in some cells A completed mosaic will be a if and only if each tile is adjacent to exactly 2 tiles of the same color 2 tiles are adjacent if they share a side Omkar wants to fill the rest of the tiles so that the mosaic becomes a Now he is wondering is the way to do this unique and if it is what is it ,"['//an awesome problem.\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint absv(int x)\n{\n\treturn x < 0 ? -x : x;\n}\nint n, x[2005], G[2005][2005];\nchar S[2005][2005];\nbool dfs(int v, int c)\n{\n\tif(x[v] == !c) return false;\n\telse if(x[v] == c) return true;\n\tx[v] = c;\n\trep(i, n + 1) if(G[v][i] != -1 && !dfs(i, c ^ G[v][i])) return false;\n\treturn true;\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\trep(i, n) scanf(""%s"", S[i]);\n\tif(n & 1) {\n\t\tprintf(""NONE\\n""); return 0;\n\t}\n\t\n\trep(i, n + 1) rep(j, n + 1) G[i][j] = -1;\n\tfor(int i = 0; i < n; i += 2) G[i][i + 2] = G[i + 2][i] = 1;\n\trep(i, n) rep(j, n) if(S[i][j] != \'.\') {\n\t\tint val = (S[i][j] == \'S\') ^ (i & 1) ^ (j & 1);\n\t\tint d0 = absv(i - j), d1 = absv(i + j - n + 1);\n\t\tif(G[d0][n - d1] == !val) {\n\t\t\tprintf(""NONE\\n""); return 0;\n\t\t}\n\t\tG[d0][n - d1] = G[n - d1][d0] = val; \n\t}\n\t\n\trep(i, n + 1) x[i] = -1;\n\tint cnt = 0;\n\trep(i, n + 1) if(x[i] == -1) {\n\t\tcnt ++;\n\t\tif(!dfs(i, 0)) {\n\t\t\tprintf(""NONE\\n""); return 0;\n\t\t}\n\t}\n\tif(cnt >= 2) printf(""MULTIPLE\\n"");\n\telse {\n\t\trep(i, n) rep(j, n) S[i][j] = (i & 1) ^ (j & 1) ^ x[absv(i - j)] ^ x[n - absv(i + j - n + 1)] ? \'S\' : \'G\';\n\t\tprintf(""UNIQUE\\n"");\n\t\trep(i, n) printf(""%s\\n"", S[i]);\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",3500,The first main observation to make is that the possible mastapeeces don t just have square loops of the same color A counterexample to this is shown below Instead observe that in a mastapeece a The two cells adjacent to corner cells must be the same color as the corner b Any cell not on the border must be adjacent to two sinoper tiles and two glaucous tiles If we then start at two cells adjacent to some corner and keep applying b to cells on the long diagonal with the corner we find that the long diagonals starting at the adjacent cells must be identical and tiled alternately with glaucous and sinoper tiles like so From here we can show that no mastapeece exists for odd Note that the two sets of such diagonals for odd intersect in cells like so But then this forces us two have two consecutive diagonals of the same color on the untiled set of diagonals which is impossible given that we ve shown they must alternate From here if we apply b to the red diagonals we find that the yellow diagonals must alternate in a similar fashion and if we keep applying this argument we find that each diagonal where every cell is the same color in the image below must alternate between glaucous and sinoper in a similar way From here consider the following yellow diagonal We know its cells must alternate so due to parity we have that the ending cells of the diagonal must be the same color Since we know each cell must be surrounded by two of the same color this also fixes the following red cells which must also be the same color This gives that the following yellow diagonals must be identical as they must alternate repeating this kind of argument shows that a mastapeece must be symmetric about both of its main diagonals Finally note that since the yellow diagonal alternates and each cell must be adjacent to of the same color the red cells must be the same color Repeating this kind of argument gives that the cells in each pair of adjacent red cells and each pair of adjacent yellow cells must be the same color Finally applying the symmetry alternating diagonals and the pairs of same colored cells gives that in the following grid fixing a cell of one color fixes all of the cells of that color Finally due to our conditions on alternating diagonals each cell in the middle of the grid will be adjacent to two cells of the same color and due to our conditions on the pairs of cells on the diagonal that must be the same color each border cell will be adjacent to two cells of the same color In other words if we pair up the cells on the leftmost column and color each pair arbitrarily there will be exactly one mastapeece that has the column colored this way For example if we color the leftmost column like so then if we go down and color in the cells fixed by each pair in the left most column we find that the final mastapeece will look like so From here it s pretty easy to figure out how to implement the problem Some examples of what mastapeeces look like are shown below 
In the pet store on sale there are a packs of dog food b packs of cat food c packs of universal food such food is suitable for both dogs and cats Polycarp has x dogs and y cats Is it possible that he will be able to buy food for all his animals in the store Each of his dogs and each of his cats should receive one pack of suitable food for it ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\nint T,a,b,c,x,y;\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\ta = read(),b = read(),c = read(),x = read(),y = read();\n\t\tbool f1 = 0,f2 = 0;\n\t\tif (a >= x) f1 = 1;\n\t\telse if (a + c >= x) c -= x - a,f1 = 1;\n\t\tif (b >= y) f2 = 1;\n\t\telse if (b + c >= y) c -= y - b,f2 = 1;\n\t\tif (f1 && f2) puts(""YES"");\n\t\telse puts(""NO"");\n\t}\n\treturn 0;\n}']","[1, 1, 0, 0, 0]",800,Obviously the best way to buy food for every pet is to buy maximum possible food for dogs and cats then dogs and cats will not get food We will buy universal food for these dogs and cats Then the answer is if and else 
Xenia is an amateur programmer Today on the IT lesson she learned about the Hamming distance The Hamming distance between two strings and of equal length is value Record is the Iverson notation and represents the following if it is one otherwise zero Now Xenia wants to calculate the Hamming distance between two long strings and The first string is the concatenation of copies of string that is The second string is the concatenation of copies of string Help Xenia calculate the required Hamming distance given ,"['#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <memory.h>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 1000010;\n\nint ca[N][26], cb[N][26];\nchar x[N], y[N];\n\nint gcd(int a, int b) {\n  while (a > 0 && b > 0)\n    if (a > b) a %= b;\n    else b %= a;\n  return a + b;\n}\n\nint main() {\n  long long n, m;\n  cin >> n >> m;\n  scanf(""%s"", x);\n  scanf(""%s"", y);\n  int a = strlen(x);\n  int b = strlen(y);\n  int g = gcd(a, b);\n  for (int i = 0; i < g; i++)\n    for (int j = 0; j < 26; j++) ca[i][j] = cb[i][j] = 0;\n  for (int i = 0; i < a; i++) ca[i % g][x[i] - \'a\']++;\n  for (int i = 0; i < b; i++) cb[i % g][y[i] - \'a\']++;\n  long long matches = 0;\n  for (int i = 0; i < g; i++)\n    for (int j = 0; j < 26; j++) matches += (long long)ca[i][j] * cb[i][j];\n  long long total = n * a;\n  matches *= (n / (b / g));\n  cout << (total - matches) << endl;\n  return 0;\n}\n']","[0, 1, 1, 0, 0]",1900,Let s denote the length of the first string as the length of the second string as Let It s obvious that is a period of the long strings and so we can find the distance of its prefixes of length and multiply the answer by Let s fix the position in the string and think about all characters from the second string it will be compared with It it easy to conclude that it will be compared with such that where For each possible remainder of division by and for each character we can calculate the number of characters that appear in in such positions that When calculating the Hamming distance the character will be compared with exactly characters from that are equal to it all other comparisons will add one to the distance 
Bran and his older sister Arya are from the same house Bran like candies so much so Arya is going to give him some Candies At first Arya and Bran have Candies There are days at the th day Arya finds candies in a box that is given by the Many Faced God Every day she can give Bran of her candies If she don t give him the candies at the same day they are saved for her and she can give them to him later Your task is to find the minimum number of days Arya needs to give Bran candies the end of the th day Formally you need to output the minimum day index to the end of which candies will be given out the days are indexed from 1 to Print if she can t give him candies during given days ,"['#include<bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nint n;\n\nlong long k;\nlong long zap;\n\nint main()\n{\n    scanf(""%d%lld"", &n, &k);\n    for (int i=1; i<=n; i++)\n    {\n        long long x;\n        scanf(""%lld"", &x);\n        zap+=x;\n        x=min(zap, 8LL);\n        zap-=x;\n        k-=x;\n        if (k<=0)\n        {\n            printf(""%d\\n"", i);\n            return 0;\n        }\n    }\n    printf(""-1\\n"");\n    return 0;\n}\n']","[0, 0, 1, 0, 0]",900,Let be number of her candies At th day we increase by then we give Bran So we decrease from this value We will print the answer once becomes smaller or equal to Or we will print if it does n happen after days 
Let s look at the following process initially you have an empty stack and an array s of the length l You are trying to push array elements to the stack in the order s 1 s 2 s 3 dots s l Moreover if the stack is empty or the element at the top of this stack is not equal to the current element then you just push the current element to the top of the stack Otherwise you don t push the current element to the stack and moreover pop the top element of the stack If after this process the stack remains empty the array s is considered There are samples of stack exterminable arrays 1 1 2 1 1 2 1 1 2 2 1 3 3 1 2 2 3 1 3 3 1 3 3 3 3 3 3 3 5 1 2 2 1 4 4 5 Let s consider the changing of stack more details if s 5 1 2 2 1 4 4 5 the top of stack is highlighted after pushing s 1 5 the stack turn into textbf 5 after pushing s 2 1 the stack turn into 5 textbf 1 after pushing s 3 2 the stack turn into 5 1 textbf 2 after pushing s 4 2 the stack turn into 5 textbf 1 after pushing s 5 1 the stack turn into textbf 5 after pushing s 6 4 the stack turn into 5 textbf 4 after pushing s 7 4 the stack turn into textbf 5 after pushing s 8 5 the stack is empty You are given an array a 1 a 2 ldots a n You have to calculate the number of its subarrays which are stack exterminable Note that you have to answer q independent queries ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=301000;\n\nstruct node {\n\tmap<int,node*> go;\n\tint cnt;\n\tnode *p;\n}pool[N],*cur,*rt;\nint top,s[N],x,n,_;\nll ans;\n\nnode *newnode(node *f) {\n\tnode *q=cur++;\n\tq->go.clear(); q->cnt=0; q->p=f;\n\treturn q;\n}\n\nvoid solve() {\n\tscanf(""%d"",&n);\n\tcur=pool;\n\trt=newnode(0);\n\ttop=0;\n\tnode *p=rt;\n\tp->cnt++;\n\tans=0;\n\trep(i,1,n+1) {\n\t\tscanf(""%d"",&x);\n\t\tif (top==0||s[top-1]!=x) {\n\t\t\ts[top++]=x;\n\t\t\tif (!p->go.count(x)) p->go[x]=newnode(p);\n\t\t\tp=p->go[x];\n\t\t\tans+=p->cnt;\n\t\t\tp->cnt++;\n\t\t} else {\n\t\t\t--top;\n\t\t\tp=p->p;\n\t\t\tans+=p->cnt;\n\t\t\tp->cnt++;\n\t\t}\n//\t\tprintf(""%d %d %d\\n"",i,ans,p-pool);\n\t}\n\tprintf(""%lld\\n"",ans);\n}\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tsolve();\n\t}\n}\n']","[0, 0, 0, 1, 1]",2600,Let s understand how calculate the array nxt such that nxtl is equal to the minimum index r l such that subarray al r is stack exterminable If there is no such index then nxtl 1 If we calculate this array then we solve this task by simple dynamic programming Let s calculate it in order nxtn nxtn 1 nxt1 by dynamic programming At first consider simple case If ai ai 1 then nxti i 1 Otherwise we have to add the block ai 1 anxti 1 of course nxti 1 should be not equal to 1 and check that ai a1 nxti 1 If this ai a1 nxti 1 also is not true then you have to add a new block a1 nxti 1 anxt1 nxti 1 and check the condition ai a1 nxt1 nxti 1 If this condition also is not try then you have to add a new block and so on It is correct solution but it can be too slowly Let s understand that we add blocks to ai until condition ai a1 nxt is holds Let s assume that we have an array nxtX this array contains a hashMaps for example you can use map in C such that nxtXi x is is equal to the minimum index r l such that subarray al r is stack exterminable and x ar 1 Then we can easily calculate the value nxti nxtXi 1 ai 1 Remains to understand how to calculate nxtXi For this we just can make an assignment nxtXi nxtXnxti 1 And then update nxtXi anxti 1 nxti 1 But I deceived you a little We can t make an assignment nxtXi nxtXnxti 1 because it is to slow Instead that you need to swap elements nxtXi and nxtXnxti 1 this can be done using the function swap in C or Java time complexity of swap if O 1 
The flag of Berland is such rectangular field that satisfies following conditions Flag consists of three colors which correspond to letters and Flag consists of three equal in width and height stripes parralel to each other and to sides of the flag Each stripe has Each color should be used in You are given a field consisting of characters and Output without quotes if this field corresponds to correct flag of Berland Otherwise print without quotes ,"['#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, ""/STACK:1048576"")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nchar in[105][105];\nchar u[105][105];\nbool isValid(int N, int M) {\n\tif (N % 3) return false;\n\n\tchar x[4] = ""BGR"";\n\tdo {\n\t\tfor (int i = 0; i < N; i++) for (int j = 0; j < M; j++) u[i][j] = x[i / (N / 3)];\n\t\t\n\t\tint i, j;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tfor (j = 0; j < M; j++) if (in[i][j] != u[i][j]) break;\n\t\t\tif (j < M) break;\n\t\t}\n\t\tif (i >= N) return true;\n\t} while (next_permutation(x, x + 3));\n\treturn false;\n}\nint main() {\n\tint N, M, i, j;\n\tscanf(""%d %d"", &N, &M);\n\tfor (i = 0; i < N; i++) scanf(""%s"", in[i]);\n\n\tif (isValid(N, M)) return !printf(""YES\\n"");\n\tfor (i = 0; i < N; i++) for (j = 0; j < M; j++) u[j][i] = in[i][j];\n\tfor (i = 0; i < N; i++) for (j = 0; j < M; j++) in[j][i] = u[j][i];\n\tif (isValid(M, N)) return !printf(""YES\\n"");\n\treturn !printf(""NO\\n"");\n}']","[0, 0, 1, 0, 0]",1600,There are lots of ways to check correctness For example you can keep boolean array with already used colors check stripes naively and mark the color used if the stripe has single color If all the colors are used in the end then the answer is Overall complexity 
Hamed has recently found a string and suddenly became quite fond of it He spent several days trying to find all occurrences of in other strings he had Finally he became tired and started thinking about the following problem Given a string how many ways are there to extract non overlapping substrings from it such that each of them contains string as a substring More formally you need to calculate the number of ways to choose two sequences and satisfying the following requirements is a substring of string string is considered as indexed As the number of ways can be rather large print it modulo ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long)a * b % md;\n}\n\nconst int N = 500010;\n\nchar s[N], t[N];\nint f[N], value[N];\nbool into[N];\nint p[N];\nint jump[N];\n\nint main() {\n  scanf(""%s"", s + 1);\n  scanf(""%s"", t + 1);\n  int n = strlen(s + 1);\n  int m = strlen(t + 1);\n  int k = 0;\n  p[1] = 0;\n  for (int i = 2; i <= m; i++) {\n    while (k > 0 && t[i] != t[k + 1]) k = p[k];\n    if (t[i] == t[k + 1]) k++;\n    p[i] = k;\n  }\n  k = 0;\n  for (int i = 1; i <= n; i++) {\n    while (k > 0 && s[i] != t[k + 1]) k = p[k];\n    if (s[i] == t[k + 1]) k++;\n    into[i] = (k == m);\n  }\n  jump[n] = n + 1;\n  for (int i = n - 1; i >= 0; i--) {\n    jump[i] = jump[i + 1];\n    if (i + m <= n && into[i + m]) {\n      jump[i] = i + m;\n    }\n  }\n  for (int i = 0; i <= n; i++) {\n    value[i] = 0;\n    f[i] = 0;\n  }\n  f[0] = 1;\n  int sum = 0;\n  for (int i = 0; i <= n; i++) {\n    add(sum, value[i]);\n    add(f[i], sum);\n    add(f[i + 1], f[i]);\n    add(value[jump[i]], f[i]);\n  }\n  add(f[n], md - 1);\n  printf(""%d\\n"", f[n]);\n  return 0;\n}\n']","[0, 0, 0, 1, 0]",2000,We call an index good if equals To find all good indexes let s define as the length of longest prefix of which is a suffix of A good index is an index with Calculating can be done using Knuth Morris Pratt algorithm Let s define as the number of ways to choose some at least one non overlapping substrings of the prefix of with length so is a substring of each one of them and is in one the chosen substrings So it must actually be the last character of last chosen substring Then the answer will be Also let s define two additional sequence and which will help us in calculating The sequence can then be calculated in as described below If is not a good index since in each way counted in the substring containing also contains so for each of these ways removing from the substring containing it leads to a way counted in and vice versa thus these two numbers are equal If is a good index then To prove this let s consider a way of choosing substring counted in We call such a way valid The substring containing can be any of the substrings There are valid ways in which this substring is the only substring we ve chosen Number of valid ways in which substring containing starts at equals to So the total number of valid ways in which we ve chosen at least two substrings are equal to which is equal to So 
After hearing the story of Dr Zhang Wowo decides to plan his own flight around the world He already chose n checkpoints in the world map Due to the landform and the clouds he cannot fly too high or too low Formally let b i be the height of Wowo s aircraft at checkpoint i x i le b i le x i should be satisfied for all integers i between 1 and n where x i and x i are given integers The angle of Wowo s aircraft is also limited For example it cannot make a 90 degree climb Formally y i le b i b i 1 le y i should be satisfied for all integers i between 2 and n where y i and y i are given integers The final limitation is the speed of angling up or angling down An aircraft should change its angle slowly for safety concerns Formally z i le b i b i 1 b i 1 b i 2 le z i should be satisfied for all integers i between 3 and n where z i and z i are given integers Taking all these into consideration Wowo finds that the heights at checkpoints are too hard for him to choose Please help Wowo decide whether there exists a sequence of numbers b 1 ldots b n satisfying all the contraints above ,"['#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing db = long double; // or double, if TL is tight\nusing str = string; // yay python!\n\nusing pi = pair<int,int>;\nusing pl = pair<ll,ll>;\nusing pd = pair<db,db>;\n\nusing vi = vector<int>;\nusing vb = vector<bool>;\nusing vl = vector<ll>;\nusing vd = vector<db>; \nusing vs = vector<str>;\nusing vpi = vector<pi>;\nusing vpl = vector<pl>; \nusing vpd = vector<pd>;\n\n#define tcT template<class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT> using V = vector<T>; \ntcT, size_t SZ> using AR = array<T,SZ>; \ntcT> using PR = pair<T,T>;\n\n// pairs\n#define mp make_pair\n#define f first\n#define s second\n\n// vectors\n// oops size(x), rbegin(x), rend(x) need C++17\n#define sz(x) int((x).size())\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) x.rbegin(), x.rend() \n#define sor(x) sort(all(x)) \n#define rsz resize\n#define ins insert \n#define ft front()\n#define bk back()\n#define pb push_back\n#define eb emplace_back \n#define pf push_front\n#define rtn return\n\n#define lb lower_bound\n#define ub upper_bound \ntcT> int lwb(V<T>& a, const T& b) { return int(lb(all(a),b)-bg(a)); }\n\n// loops\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define rep(a) F0R(_,a)\n#define each(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5;\nconst ll INF = 1e18; // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1}; // for every grid problem!!\n// mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \nmt19937 rng(0);\ntemplate<class T> using pqg = priority_queue<T,vector<T>,greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); } // # of bits set\nconstexpr int bits(int x) { // assert(x >= 0); // make C++11 compatible until USACO updates ...\n\treturn x == 0 ? 0 : 31-__builtin_clz(x); } // floor(log2(x)) \nconstexpr int p2(int x) { return 1<<x; }\nconstexpr int msk2(int x) { return p2(x)-1; }\n\nll cdiv(ll a, ll b) { return a/b+((a^b)>0&&a%b); } // divide a by b rounded up\nll fdiv(ll a, ll b) { return a/b-((a^b)<0&&a%b); } // divide a by b rounded down\n\ntcT> bool ckmin(T& a, const T& b) {\n\treturn b < a ? a = b, 1 : 0; } // set a = min(a,b)\ntcT> bool ckmax(T& a, const T& b) {\n\treturn a < b ? a = b, 1 : 0; }\n\ntcTU> T fstTrue(T lo, T hi, U f) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo)/2;\n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\ntcTU> T lstTrue(T lo, T hi, U f) {\n\tlo --; assert(lo <= hi); // assuming f is decreasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tT mid = lo+(hi-lo+1)/2;\n\t\tf(mid) ? lo = mid : hi = mid-1;\n\t} \n\treturn lo;\n}\ntcT> void remDup(vector<T>& v) { // sort and remove duplicates\n\tsort(all(v)); v.erase(unique(all(v)),end(v)); }\ntcTU> void erase(T& t, const U& u) { // don\'t erase\n\tauto it = t.find(u); assert(it != end(t));\n\tt.erase(it); } // element that doesn\'t exist from (multi)set\n\n#define tcTUU tcT, class ...U\n\ninline namespace Helpers {\n\t//////////// is_iterable\n\t// https://stackoverflow.com/questions/13830158/check-if-a-variable-type-is-iterable\n\t// this gets used only when we can call begin() and end() on that type\n\ttcT, class = void> struct is_iterable : false_type {};\n\ttcT> struct is_iterable<T, void_t<decltype(begin(declval<T>())),\n\t                                  decltype(end(declval<T>()))\n\t                                 >\n\t                       > : true_type {};\n\ttcT> constexpr bool is_iterable_v = is_iterable<T>::value;\n\n\t//////////// is_readable\n\ttcT, class = void> struct is_readable : false_type {};\n\ttcT> struct is_readable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cin >> declval<T&>()), istream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_readable_v = is_readable<T>::value;\n\n\t//////////// is_printable\n\t// // https://nafe.es/posts/2020-02-29-is-printable/\n\ttcT, class = void> struct is_printable : false_type {};\n\ttcT> struct is_printable<T,\n\t        typename std::enable_if_t<\n\t            is_same_v<decltype(cout << declval<T>()), ostream&>\n\t        >\n\t    > : true_type {};\n\ttcT> constexpr bool is_printable_v = is_printable<T>::value;\n}\n\ninline namespace Input {\n\ttcT> constexpr bool needs_input_v = !is_readable_v<T> && is_iterable_v<T>;\n\ttcTUU> void re(T& t, U&... u);\n\ttcTU> void re(pair<T,U>& p); // pairs\n\n\t// re: read\n\ttcT> typename enable_if<is_readable_v<T>,void>::type re(T& x) { cin >> x; } // default\n\ttcT> void re(complex<T>& c) { T a,b; re(a,b); c = {a,b}; } // complex\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i); // ex. vectors, arrays\n\ttcTU> void re(pair<T,U>& p) { re(p.f,p.s); }\n\ttcT> typename enable_if<needs_input_v<T>,void>::type re(T& i) {\n\t\teach(x,i) re(x); }\n\ttcTUU> void re(T& t, U&... u) { re(t); re(u...); } // read multiple\n\n\t// rv: resize and read vectors\n\tvoid rv(size_t) {}\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u);\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u);\n\ttcTUU> void rv(size_t N, V<T>& t, U&... u) {\n\t\tt.rsz(N); re(t);\n\t\trv(N,u...); }\n\ttemplate<class...U> void rv(size_t, size_t N2, U&... u) {\n\t\trv(N2,u...); }\n\n\t// dumb shortcuts to read in ints\n\tvoid decrement() {} // subtract one from each\n\ttcTUU> void decrement(T& t, U&... u) { --t; decrement(u...); }\n\t#define ints(...) int __VA_ARGS__; re(__VA_ARGS__);\n\t#define int1(...) ints(__VA_ARGS__); decrement(__VA_ARGS__);\n}\n\ninline namespace ToString {\n\ttcT> constexpr bool needs_output_v = !is_printable_v<T> && is_iterable_v<T>;\n\n\t// ts: string representation to print\n\ttcT> typename enable_if<is_printable_v<T>,str>::type ts(T v) {\n\t\tstringstream ss; ss << fixed << setprecision(15) << v;\n\t\treturn ss.str(); } // default\n\ttcT> str bit_vec(T t) { // bit vector to string\n\t\tstr res = ""{""; F0R(i,sz(t)) res += ts(t[i]);\n\t\tres += ""}""; return res; }\n\tstr ts(V<bool> v) { return bit_vec(v); }\n\ttemplate<size_t SZ> str ts(bitset<SZ> b) { return bit_vec(b); } // bit vector\n\ttcTU> str ts(pair<T,U> p); // pairs\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v); // vectors, arrays\n\ttcTU> str ts(pair<T,U> p) { return ""(""+ts(p.f)+"", ""+ts(p.s)+"")""; }\n\ttcT> typename enable_if<is_iterable_v<T>,str>::type ts_sep(T v, str sep) {\n\t\t// convert container to string w/ separator sep\n\t\tbool fst = 1; str res = """";\n\t\tfor (const auto& x: v) {\n\t\t\tif (!fst) res += sep;\n\t\t\tfst = 0; res += ts(x);\n\t\t}\n\t\treturn res;\n\t}\n\ttcT> typename enable_if<needs_output_v<T>,str>::type ts(T v) {\n\t\treturn ""{""+ts_sep(v,"", "")+""}""; }\n\n\t// for nested DS\n\ttemplate<int, class T> typename enable_if<!needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) { return {ts(v)}; }\n\ttemplate<int lev, class T> typename enable_if<needs_output_v<T>,vs>::type \n\t  ts_lev(const T& v) {\n\t\tif (lev == 0 || !sz(v)) return {ts(v)};\n\t\tvs res;\n\t\tfor (const auto& t: v) {\n\t\t\tif (sz(res)) res.bk += "","";\n\t\t\tvs tmp = ts_lev<lev-1>(t);\n\t\t\tres.ins(end(res),all(tmp));\n\t\t}\n\t\tF0R(i,sz(res)) {\n\t\t\tstr bef = "" ""; if (i == 0) bef = ""{"";\n\t\t\tres[i] = bef+res[i];\n\t\t}\n\t\tres.bk += ""}"";\n\t\treturn res;\n\t}\n}\n\ninline namespace Output {\n\ttemplate<class T> void pr_sep(ostream& os, str, const T& t) { os << ts(t); }\n\ttemplate<class T, class... U> void pr_sep(ostream& os, str sep, const T& t, const U&... u) {\n\t\tpr_sep(os,sep,t); os << sep; pr_sep(os,sep,u...); }\n\t// print w/ no spaces\n\ttemplate<class ...T> void pr(const T&... t) { pr_sep(cout,"""",t...); } \n\t// print w/ spaces, end with newline\n\tvoid ps() { cout << ""\\n""; }\n\ttemplate<class ...T> void ps(const T&... t) { pr_sep(cout,"" "",t...); ps(); } \n\t// debug to cerr\n\ttemplate<class ...T> void dbg_out(const T&... t) {\n\t\tpr_sep(cerr,"" | "",t...); cerr << endl; }\n\tvoid loc_info(int line, str names) {\n\t\tcerr << ""Line("" << line << "") -> ["" << names << ""]: ""; }\n\ttemplate<int lev, class T> void dbgl_out(const T& t) {\n\t\tcerr << ""\\n\\n"" << ts_sep(ts_lev<lev>(t),""\\n"") << ""\\n"" << endl; }\n\t#ifdef LOCAL\n\t\t#define dbg(...) loc_info(__LINE__,#__VA_ARGS__), dbg_out(__VA_ARGS__)\n\t\t#define dbgl(lev,x) loc_info(__LINE__,#x), dbgl_out<lev>(x)\n\t#else // don\'t actually submit with this\n\t\t#define dbg(...) 0\n\t\t#define dbgl(lev,x) 0\n\t#endif\n}\n\ninline namespace FileIO {\n\tvoid setIn(str s)  { freopen(s.c_str(),""r"",stdin); }\n\tvoid setOut(str s) { freopen(s.c_str(),""w"",stdout); }\n\tvoid setIO(str s = """") {\n\t\tcin.tie(0)->sync_with_stdio(0); // unsync C / C++ I/O streams\n\t\t// cin.exceptions(cin.failbit);\n\t\t// throws exception when do smth illegal\n\t\t// ex. try to read letter into int\n\t\tif (sz(s)) setIn(s+"".in""), setOut(s+"".out""); // for old USACO\n\t}\n}\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\n// ll abs(ll x) {\n// \tif (x < 0) x *= -1;\n// \treturn x;\n// }\n\n// ll __gcd(ll a, ll b) {\n// \tif (a == 0) return b;\n// \treturn __gcd(b%a,a);\n// }\n\n// str ts(ll x) { return ts((long long)x); }\n\nstruct frac {\n\tll n,d;\n\tfrac(ll _n, ll _d) {\n\t\tn = _n, d = _d;\n\t\tll g = __gcd(n,d); n /= g, d /= g;\n\t\tif (d < 0 || (d == 0 && n == -1)) n *= -1, d *= -1;\n\t}\n\tfrac(ll _n) : frac(_n,1) {}\n\tfrac() : frac(0) {}\n\tfriend frac abs(frac F) { return frac(abs(F.n),F.d); }\n\tfriend str ts(const frac& a) { return ts(a.n)+""/""+ts(a.d); }\n \n\tfriend bool operator<(const frac& l, const frac& r) { \n\t\tassert(l.d == 1 || r.d == 1);\n\t\treturn l.n*r.d < r.n*l.d; }\n\tfriend bool operator>(const frac& l, const frac& r) { \n\t\tassert(l.d == 1 || r.d == 1);\n\t\treturn l.n*r.d > r.n*l.d; }\n\tfriend bool operator==(const frac& l, const frac& r) { return l.n == r.n && l.d == r.d; }\n\tfriend bool operator!=(const frac& l, const frac& r) { return !(l == r); }\n \n\tfrac operator-() const { return frac(-n,d); }\n\tfriend frac operator+(const frac& l, const frac& r) { return frac(l.n*r.d+r.n*l.d,l.d*r.d); }\n\tfriend frac operator-(const frac& l, const frac& r) { return frac(l.n*r.d-r.n*l.d,l.d*r.d); }\n\tfriend frac operator*(const frac& l, const frac& r) { return frac(l.n*r.n,l.d*r.d); }\n\tfriend frac operator*(const frac& l, int r) { return l*frac(r,1); }\n\tfriend frac operator*(int r, const frac& l) { return l*r; }\n\tfriend frac operator/(const frac& l, const frac& r) { return l*frac(r.d,r.n); }\n\tfriend frac operator/(const frac& l, const int& r) { return l/frac(r,1); }\n\tfriend frac operator/(const int& l, const frac& r) { return frac(l,1)/r; }\n \n\tfriend frac& operator+=(frac& l, const frac& r) { return l = l+r; }\n\tfriend frac& operator-=(frac& l, const frac& r) { return l = l-r; }\n\ttemplate<class T> friend frac& operator*=(frac& l, const T& r) { return l = l*r; }\n\ttemplate<class T> friend frac& operator/=(frac& l, const T& r) { return l = l/r; }\n};\n\n\nbool flag;\n\nnamespace mine {\n/**\n * Description: Operations with fractions\n * Source: https://martin-thoma.com/fractions-in-cpp/\n * Verification: TopCoder MinimizeAbsoluteDifferenceDiv1\n */\n\n// https://codeforces.com/blog/entry/89968\n\nstruct Tag {\n\tll c, delta_x, delta_y;\n\t// transformation:\n\t// {x,y} -> {x+c*y+delta_x,y+delta_y}\n\n\t// this + t -> {(x+c*y+delta_x)+t.c*(y+delta_y)+t.delta_x,(y+delta_y)+t.delta_y}\n\tTag with_tag(Tag t) { // OK\n\t\treturn {c+t.c,delta_x+t.c*delta_y+t.delta_x,delta_y+t.delta_y};\n\t}\n\tTag inv() { // OK\n\t\treturn {-c,c*delta_y-delta_x,-delta_y};\n\t}\n\tfriend str ts(const Tag& t) { \n\t\treturn ""{c: ""+ts(t.c)+"", delta_x:""+ts(t.delta_x)+ts("", delta_y:"")+ts(t.delta_y)+""}""; \n\t}\n};\n\nTag undo_front(Tag a, Tag result) { // OK\n\tll t_c = result.c-a.c;\n\treturn {t_c,result.delta_x-a.delta_x-t_c*a.delta_y,result.delta_y-a.delta_y};\n}\n\n// a.delta_x+t.c*a.delta_y+t.delta_x = result.delta_x\n// a.delta_y+t.delta_y = result.delta_y\n// a.c+t.c = result.c\n\n// result.c-a.c, result.delta_x-a.delta_x-(result.c-a.c)*a.delta_y, result.delta_y-a.delta_y\n\nconst Tag ID{0,0,0};\nTag tag_x_plus_y() { return {1,0,0}; }\nTag tag_z(int z) { return {0,z,z}; }\n\nint N;\n\nstruct Vertex {\n\tll x,y,k;\n\tVertex(ll _x, ll _y, ll _k) {\n\t\tassert(_k > 0);\n\t\tll g = __gcd(__gcd(abs(_x),abs(_y)),_k);\n\t\tx = _x/g;\n\t\ty = _y/g;\n\t\tk = _k/g;\n\t\t// if (!(k <= N)) dbg(""HUH"",_x,_y,_k,x,y,k);\n\t\t// assert(k <= N);\n\t\tassert(abs(x) <= (ll)1e14);\n\t\tassert(abs(y) <= (ll)1e14);\n\t}\n\tVertex(ll _x, frac _y) : Vertex(_x*_y.d,_y.n,_y.d) {}\n\tVertex(frac _x, ll _y) : Vertex(_x.n,_y*_x.d,_x.d) {}\n\tVertex(ll _x, ll _y) : Vertex(_x,_y,1) {}\n\tVertex with_tag(Tag t) { return Vertex(x+t.c*y+t.delta_x*k,y+t.delta_y*k,k); }\n\tbool operator==(const Vertex& o) { return x == o.x && y == o.y && k == o.k; }\n\tfrac get_x() const { return frac(x,k); }\n\tfrac get_y() const { return frac(y,k); }\n\tfriend str ts(const Vertex& v) { \n\t\tV<frac> fracs{v.get_x(),v.get_y()};\n\t\treturn ts(fracs);\n\t}\n};\n\nfrac slope_between (Vertex a, Vertex b) {\n\t// (a.y/a.k-b.y/b.k)/(a.x/a.k-b.x/b.k)\n\tll num = a.y*b.k-b.y*a.k;\n\tll den = a.x*b.k-b.x*a.k;\n\tfrac res = frac(num,den);\n\t// dbg(res);\n\tassert(res.n == 1 || res.n == 0);\n\treturn res;\n}\n\nbool flag;\n\nVertex isect_x(Vertex a, Vertex b, int x) {\n\tif (flag) dbg(""ISECT X"",a,b,x);\n\tVertex result2{0,0,1};\n\tfrac _slope = slope_between(a,b);\n\tif (_slope.n == 0) {\n\t\treturn Vertex(x*a.k,a.y,a.k);\n\t}\n\tll slope = _slope.d;\n\treturn Vertex(x*a.k*slope,x*a.k+a.y*slope-a.x,a.k*slope);\n}\n\nVertex isect_y(Vertex a, Vertex b, int y) {\n\tfrac _slope = slope_between(a,b); \n\tll slope = _slope.d;\n\tll x_intercept = a.x-slope*a.y; // over a.k\n\tVertex result = Vertex(slope*y*a.k+x_intercept,y*a.k,a.k);\n\treturn result;\n}\n\nvoid apply_tag(Tag& a, Tag b) {\n\ta = a.with_tag(b);\n}\n\n\nbool collinear(Vertex a, Vertex b, Vertex c) {\n\tfrac f = (b.get_y()-a.get_y())*(c.get_x()-a.get_x())-(b.get_x()-a.get_x())*(c.get_y()-a.get_y());\n\treturn f.n == 0;\n}\n\nstruct Hull {\n\tdeque<pair<Vertex,Tag>> verts;\n\t// tag should be applied to vertex and everything before it\n\tTag prod = ID;\n\tHull() {}\n\tHull(V<Vertex> _verts) { // OK\n\t\tfor (Vertex v: _verts) add_back(v);\n\t}\n\tVertex get_back() { // OK\n\t\tassert(!verts.empty());\n\t\treturn verts.bk.f.with_tag(verts.bk.s);\n\t}\n\tVertex get_front() { // OK\n\t\tassert(!verts.empty());\n\t\treturn verts.ft.f.with_tag(prod);\n\t}\n\tvoid apply_back(Tag t) { // OK\n\t\tassert(!verts.empty());\n\t\tapply_tag(verts.bk.s,t);\n\t\tapply_tag(prod,t);\n\t}\n\tvoid x_plus_y() { // OK\n\t\tapply_back(tag_x_plus_y());\n\t}\n\tvoid advance_z(int z) { // OK\n\t\tapply_back(tag_z(z));\n\t}\n\tVertex poll_front() { // OK\n\t\tVertex v = get_front();\n\t\tprod = undo_front(verts.ft.s,prod);\n\t\tverts.pop_front();\n\t\tassert(sz(verts));\n\t\treturn v;\n\t}\n\tVertex poll_back() { // OK\n\t\tVertex v = get_back();\n\t\tTag last_tag = verts.bk.s;\n\t\tverts.pop_back(); assert(sz(verts));\n\t\tapply_tag(verts.bk.s,last_tag);\n\t\treturn v;\n\t}\n\tfrac get_front_x() { return get_front().get_x(); }\n\tfrac get_front_y() { return get_front().get_y(); }\n\tfrac get_back_x() { return get_back().get_x(); }\n\tfrac get_back_y() { return get_back().get_y(); }\n\tvoid add_front(Vertex v) {\n\t\tif (!verts.empty() && v == get_front()) return;\n\t\tverts.push_front({v,prod.inv()}); prod = ID;\n\t}\n\tvoid add_back(Vertex v) {\n\t\tif (!verts.empty() && v == get_back()) return;\n\t\tverts.pb({v,ID});\n\t}\n\tvoid cut_y_lower(int yl) {\n\t\twhile (get_front_y() < yl) {\n\t\t\tVertex v = poll_front();\n\t\t\tassert(!verts.empty());\n\t\t\tif (get_front_y() > yl)\n\t\t\t\tadd_front(isect_y(v,get_front(),yl));\n\t\t}\n\t}\n\tvoid cut_y_upper(int yu) {\n\t\twhile (get_back_y() > yu) {\n\t\t\tVertex v = poll_back();\n\t\t\tassert(!verts.empty());\n\t\t\tif (get_back_y() < yu)\n\t\t\t\tadd_back(isect_y(v,get_back(),yu));\n\t\t}\n\t}\n\tvoid cut_x_lower(int xl) {\n\t\twhile (get_front_x() < xl) {\n\t\t\tVertex v = poll_front();\n\t\t\tassert(!verts.empty());\n\t\t\tif (get_front_x() > xl)\n\t\t\t\tadd_front(isect_x(v,get_front(),xl));\n\t\t}\n\t}\n\tvoid cut_x_upper(int xu) {\n\t\twhile (get_back_x() > xu) {\n\t\t\tVertex v = poll_back(); \n\t\t\tassert(!verts.empty());\n\t\t\tif (get_back_x() < xu)\n\t\t\t\tadd_back(isect_x(v,get_back(),xu));\n\t\t}\n\t}\n\tfriend str ts(const Hull& h) {\n\t\tV<Vertex> converted;\n\t\tset<int> cands;\n\t\tcands.ins(0);\n\t\tcands.ins(sz(h.verts)-1);\n\t\tfor (int i: cands) {\n\t\t\tVertex v = h.verts[i].f;\n\t\t\tif (i == 0) {\n\t\t\t\tv = v.with_tag(h.prod);\n\t\t\t} else {\n\t\t\t\tFOR(j,i,sz(h.verts)) v = v.with_tag(h.verts[j].s);\n\t\t\t}\n\t\t\tconverted.pb(v);\n\t\t\t// while (sz(converted) > 2 && collinear(converted[sz(converted)-3],converted[sz(converted)-2],converted.bk)) {\n\t\t\t// \tconverted.erase(begin(converted)+sz(converted)-2);\n\t\t\t// }\n\t\t}\n\t\t// F0R(i,sz(converted)-1) {\n\t\t// \tfrac f = slope_between(converted[i],converted[i+1]);\n\t\t// \tfrac y_intercept = converted[i].get_y()-converted[i].get_x()*f;\n\t\t// \t// if (y_intercept.d) if (f.d%y_intercept.d != 0) {\n\t\t// \t// \tdbg(""FAILED"",converted[i],converted[i+1]);\n\t\t// \t// }\n\t\t// }\n\t\treturn ts(converted);\n\t}\n};\n\nvpi X,Y,Z;\nHull lower, upper;\n// if single point, both have it\n\nbool hull_empty() {\n\treturn lower.verts.empty();\n}\n\nvoid x_plus_y() {\n\tif (hull_empty()) return;\n\tlower.x_plus_y(); upper.x_plus_y();\n}\n\nvoid advance_z(int zl, int zu) {\n\tif (hull_empty()) return;\n\tlower.advance_z(zl); upper.advance_z(zu);\n\tupper.add_front(lower.get_front());\n\tlower.add_back(upper.get_back());\n}\n\nvoid clear() {\n\tupper.verts = lower.verts = {};\n}\n\nvoid cut_y_lower(int yl) {\n\tif (hull_empty()) return;\n\tif (lower.get_back_y() < yl) return clear();\n\tupper.cut_y_lower(yl);\n\tlower.cut_y_lower(yl);\n\tlower.add_front(upper.get_front());\n}\n\nvoid cut_y_upper(int yu) {\n\tif (hull_empty()) return;\n\tif (lower.get_front_y() > yu) return clear();\n\tupper.cut_y_upper(yu);\n\tlower.cut_y_upper(yu);\n\tupper.add_back(lower.get_back());\n}\n\nvoid cut_x_lower(int xl) {\n\tif (hull_empty()) return;\n\tif (lower.get_back_x() < xl) return clear();\n\tupper.cut_x_lower(xl);\n\tlower.cut_x_lower(xl);\n\tupper.add_front(lower.get_front());\n}\n\nvoid cut_x_upper(int xu) {\n\tif (hull_empty()) return;\n\tif (lower.get_front_x() > xu) return clear();\n\tupper.cut_x_upper(xu);\n\tlower.cut_x_upper(xu);\n\tlower.add_back(upper.get_back());\n}\n\n\nvoid print_hulls() {\n\t// if (flag) {\n\tdbg(""HULLS"");\n\tdbg(lower);\n\tdbg(upper);\n\tdbg(""----"");\n\t// }\n\t// dbg(lower);\n\t// dbg(upper);\n}\n\npi rand_pair() {\n\tint a = rng()%21-10;\n\tint b = rng()%21-10;\n\tif (a > b) swap(a,b);\n\treturn {a,b};\n}\n\nint rng_int(int l, int r) { return uniform_int_distribution<int>(l,r)(rng); }\n\npi rand_around(int x) {\n\tint a = rng_int(-1e8,1e8), b = rng_int(1e8,1e8);\n\tif (a > b) swap(a,b);\n\treturn {a,b};\n\t// return {rng_int(-1e8,x),rng_int(x,1e8)};\n\t// return {rng_int(max(-(int)1e8,x-5),x),rng_int(x,min((int)1e8,x+5))};\n}\n\npair<bool,vs> solve(int tc, int N, vpi X, vpi Y, vpi Z) {\n\tdbg(tc);\n\t// N = 3; \n\n\t// if (tc == 6649) {\n\t// \tps(N);\n\t// \teach(t,X) ps(t.f,t.s);\n\t// \teach(t,Y) ps(t.f,t.s);\n\t// \teach(t,Z) ps(t.f,t.s);\n\t// \t// ps(ts_sep(X,""\\n""));\n\t// \t// ps(ts_sep(Y,""\\n""));\n\t// \t// ps(ts_sep(Z,""\\n""));\n\t// }\n\n\t// dbg(N);\n\t// dbg(X);\n\t// dbg(Y);\n\t// dbg(Z);\n\n\tVertex lower_left(X[1].f,X[1].f-X[0].s);\n\tVertex upper_left(X[1].f,X[1].f-X[0].f);\n\tVertex upper_right(X[1].s,X[1].s-X[0].f);\n\tVertex lower_right(X[1].s,X[1].s-X[0].s);\n\tupper = Hull({lower_left,upper_left,upper_right});\n\tlower = Hull({lower_left,lower_right,upper_right});\n\tcut_y_lower(Y[0].f); cut_y_upper(Y[0].s);\n\t// dbg(""SOLUTION 1"");\n\tvs rec;\n\tif (!hull_empty()) {\n\t\trec.pb(""UPPER: ""+ts(upper));\n\t\trec.pb(""LOWER: ""+ts(lower));\n\t}\n\t// ps(""UPPER"",upper);\n\t// ps(""LOWER"",lower);\n\tFOR(i,2,N) {\n\t\t// dbg(""IT"",i);\n\t\t// dbg(sz(lower.verts),sz(upper.verts));\n\t\t// assert(!hull_empty());\n\t\t// flag = tc == 6649;\n\t\t// flag = N == 100000 && tc == 2 && i == 99999;\n\t\t// if (N == 100000 && tc == 2 && i == 99999) {\n\t\t// \tps(""HULL EMPTY BEFORE"",i);\n\t\t// \tps(X[i]);\n\t\t// \tps(Y[i-1]);\n\t\t// \tps(Z[i-2]);\n\t\t// if (tc == 6649) {\n\t\t// \tdbg(""ITERATION"",i);\n\t\t// \tdbg(upper);\n\t\t// \tdbg(lower);\n\t\t// }\n\t\t// \tps(upper);\n\t\t// \tps(lower);\n\t\t// }\n\t\t// if (flag) ps(""BEFORE ITERATION"",i,X[i],Y[i-1],Z[i-2]);\n\t\t// print_hulls();\n\n\t\tx_plus_y();\n\n\t\t// if (flag) dbg(""AFTER X PLUS Y"",i);\n\t\t// print_hulls();\n\n\t\tadvance_z(Z[i-2].f,Z[i-2].s);\n\n\t\t// if (flag) dbg(""AFTER Z"",i,Z[i-2]);\n\t\t// print_hulls();\n\n\t\tcut_x_lower(X[i].f); \n\n\t\t// if (flag) \n\t\t// \tdbg(""AFTER X LOWER"",i,X[i].f);\n\t\t// print_hulls();\n\n\t\tcut_x_upper(X[i].s);\n\n\t\t// if (flag) \n\t\t// \tdbg(""AFTER X HIGHER"",i,X[i].s);\n\t\t// print_hulls();\n\n\t\tcut_y_lower(Y[i-1].f); \n\n\t\t// if (flag) \n\t\t\t// dbg(""AFTER Y LOWER"",i,Y[i-1].f);\n\t\t// print_hulls();\n\n\t\tcut_y_upper(Y[i-1].s);\n\n\t\t// dbg(""AFTER Y HIGHER"",i,Y[i-1].s);\n\t\t// print_hulls();\n\t\t// if (N == 100000 && tc == 2 && hull_empty()) {\n\t\t// \tps(""HULL EMPTY AFTER"",i);\n\t\t// }\n\t\tif (!hull_empty()) {\n\t\t\trec.pb(""UPPER: ""+ts(upper));\n\t\t\trec.pb(""LOWER: ""+ts(lower));\n\t\t}\n\t\t// ps(""UPPER"",upper);\n\t\t// ps(""LOWER"",lower);\n\t}\n\tdbg(rec);\n\t// assert(!hull_empty());\n\tif (hull_empty()) return {0,rec};\n\telse return {1,rec};\n}\n\n}\n\nnamespace model {\n\nusing LL = long long;\n\ninline char GET_CHAR(){\n    const int maxn = 131072;\n    static char buf[maxn],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n    int res(0);\n    char c = getchar();\n    while(c < \'0\') c = getchar();\n    while(c >= \'0\') {\n        res = res * 10 + (c - \'0\');\n        c = getchar();\n    }\n    return res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n    LL res(1);\n    while(n) {\n        if(n & 1) {\n            res = res * (LL)x % mod;\n        }\n        x = x * (LL) x % mod;\n        n /= 2;\n    }\n    return res;\n}\nLL gcd(LL a, LL b) { return b ? gcd(b, a % b) : a; }\n\ninline string itoa(int x, int width = 0) {\n    string res;\n    if(x == 0) res.push_back(\'0\');\n    while(x) {\n        res.push_back(\'0\' + x % 10);\n        x /= 10;\n    }\n    while((int)res.size() < width) res.push_back(\'0\');\n    reverse(res.begin(), res.end());\n    return res;\n}\nconst int _B = 131072;\nchar buf[_B];\nint _bl = 0;\ninline void flush() {\n    fwrite(buf, 1, _bl, stdout);\n    _bl = 0;\n}\n__inline void _putchar(char c) {\n    if(_bl == _B) flush();\n    buf[_bl++] = c;\n}\ninline void print(LL x, char c) {\n    static char tmp[20];\n    int l = 0;\n    if(!x) tmp[l++] = \'0\';\n    else {\n        while(x) {\n            tmp[l++] = x % 10 + \'0\';\n            x /= 10;\n        }\n    }\n    for(int i = l - 1; i >= 0; i--) _putchar(tmp[i]);\n    _putchar(c);\n}\nconst int N = 100011;\nconst int LOG = 20;\nconst int mod = 1e9 + 7;\nconst int inf = 1e9 + 7;\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nvoid no() {\n    printf(""NO\\n"");\n}\nvoid yes() {\n    printf(""YES\\n"");\n}\nconst int L = 1e9;\nstruct Frac {\n    LL x, y;\n    Frac() {\n        y = 1;\n        x = 0;\n    }\n    Frac(LL _x, LL _y) : x(_x), y(_y){\n        if(y < 0) {\n            y = -y; x = -x;\n        }\n        LL d = gcd(abs(x), y);\n        x /= d; y /= d;\n    }\n    Frac(LL a) {\n        x = a; y = 1;\n    }\n    Frac operator + (const Frac & b) const {\n        return Frac(x * b.y + y * b.x, y * b.y);\n    }\n    Frac operator - (const Frac & b) const {\n        return Frac(x * b.y - y * b.x, y * b.y);\n    }\n    Frac operator * (const Frac & b) const {\n        return Frac(x * b.x, y * b.y);\n    }\n    Frac operator / (const Frac & b) const {\n        LL dx = gcd(x, b.x);\n        LL dy = gcd(y, b.y);\n        return Frac(x / dx * (b.y / dy), (y / dy) * (b.x / dx));\n    }\n    bool operator == (const Frac & b) const {\n        return x * b.y == y * b.x;\n    }\n    bool operator != (const Frac & b) const {\n        return x * b.y != y * b.x;\n    }\n    bool operator < (const Frac & b) const {\n        return x * b.y < y * b.x;\n    }\n    bool operator > (const Frac & b) const {\n        return x * b.y > y * b.x;\n    }\n    bool operator <= (const Frac & b) const {\n        return x * b.y <= y * b.x;\n    }\n    bool operator >= (const Frac & b) const {\n        return x * b.y >= y * b.x;\n    }\n    Frac operator - () const {\n        return Frac(-x, y);\n    }\n\n    friend str ts(Frac f) {\n    \treturn ts(frac(f.x,f.y));\n    \t// return\n    \t// return ts(x)+""/""+ts(y)+c;\n    }\n};\nLL xmin[N], ymin[N], zmin[N], xmax[N], ymax[N], zmax[N];\nstruct P {\n    Frac x, y;\n    bool operator == (const P & b) const {\n        return x == b.x && y == b.y;\n    }\n    bool operator != (const P & b) const {\n        return x != b.x || y != b.y;\n    }\n    friend str ts(const P& p) {\n    \tV<Frac> v{p.x,p.y};\n    \treturn ts(v);\n    }\n    // void print(char c = \'\\n\') {\n    //     putchar(\'(\');\n    //     x.print(\',\');\n    //     y.print(\')\');\n    //     putchar(c);\n    // }\n    // void check() {\n    // }\n};\nstruct Op {\n    LL c, dx, dy;\n    //x -> x + c * y + dx, y -> y + dy\n    //x + c * y + dx - (y + dy) * c - dx + c * dy = x\n    Op() {\n        c = dx = dy = 0;\n    }\n    Op(LL z) {\n        c = 1;\n        dx = dy = z;\n    }\n    Op(const LL & c, const LL & dx, const LL & dy) : c(c), dx(dx), dy(dy) {\n    }\n    Op operator * (const Op & b) const {\n        return Op{c + b.c, dx + c * b.dy + b.dx, dy + b.dy};\n    }\n    Op inv() const {\n        return Op{-c, -dx + c * dy, -dy};\n    }\n    P operator * (const P & b) const {\n        return P{b.x + (Frac)c * b.y + dx, b.y + dy};\n    }\n    bool operator == (const Op & b) const {\n        return c == b.c && dx == b.dx && dy == b.dy;\n    }\n    void print() const {\n        printf(""op: %lld %lld %lld\\n"", c, dx, dy);\n    }\n    void check() {\n    }\n};\n\nbool collinear(P a, P b, P c) {\n\tFrac f = (b.y-a.y)*(c.x-a.x)-(b.x-a.x)*(c.y-a.y);\n\treturn f.x == 0;\n}\n\nstruct Deq {\n    deque<P> v;\n    deque<Op> op;\n    Op u;\n    bool empty() {\n        return v.empty();\n    }\n    int size() {\n        return v.size();\n    }\n    P back() {\n        return op.back() * v.back();\n    }\n    P front() {\n        return u * v.front();\n    }\n    P bac() {\n        return op.back() * op[size() - 2] * v[size() - 2];\n    }\n    P fron() {\n        return u * op.front().inv() * v[1];\n    }\n    void push_back(const P & x) {\n        v.push_back(x);\n        op.push_back(Op());\n    }\n    void push_front(const P & x) {\n        if(!v.empty()) {\n            op.push_front(u.inv());\n        }else {\n            op.push_front(Op());\n        }\n        u = Op();\n        v.push_front(x);\n    }\n    void pop_back() {\n        if(v.size() == 1) {\n            v.pop_back(); op.pop_back(); u = Op();\n        }else {\n            op[v.size() - 2] = op.back() * op[v.size() - 2];\n            v.pop_back(); op.pop_back();\n        }\n    }\n    void pop_front() {\n        if(v.size() == 1) {\n            v.pop_back(); op.pop_back(); u = Op();\n        }else {\n            u = u * op.front().inv();\n            v.pop_front();\n            op.pop_front();\n        }\n    }\n\n    void setback(const P & x) {\n        pop_back();\n        push_back(x);\n/*        if(v.size() >= 2) {\n            \n            op[v.size() - 2] = op.back() * op[v.size() - 2];\n        }else {\n            u = Op();\n        }\n        v.back() = x;\n        op.back() = Op();*/\n    }\n    void setfront(const P & x) {\n        pop_front();\n        push_front(x);\n/*        op.front() = u.inv() * op.front();\n        u = Op();\n        v.front() = x;*/\n    }\n    void apply(const Op & z) {        \n        if(!op.empty()) {\n            u = z * u;\n            op.back() = z * op.back();\n        }\n    }\n\n    friend str ts(const Deq& d) {\n\t\tV<P> converted;\n\t\tset<int> cands;\n\t\tcands.ins(0);\n\t\tcands.ins(d.op.size()-1);\n\n\t\tfor (int i: cands) {\n            P p = d.v[i];\n            if (i == 0) p = d.u*p;\n            else {\n\t            for (int j = i; j < d.op.size(); ++j) {\n\t                p = d.op[j]*p;\n\t            }\n            }\n            if (sz(converted) && converted.bk == p) continue;\n            // while (sz(converted) > 1 && collinear(converted[sz(converted)-2],converted.bk,p)) \n            // \tconverted.pop_back();\n            converted.pb(p);\n        }\n\t\treturn ts(converted);\n    }\n};\n\npair<bool,vs> solve(int N, vpi X, vpi Y, vpi Z) {\n\t// dbg(""SOLUTION 2"");\n\tn = N;\n\tFOR(i,1,n+1) {\n\t\txmin[i] = X[i-1].f;\n\t\txmax[i] = X[i-1].s;\n\t}\n\tFOR(i,2,n+1) {\n\t\tymin[i] = Y[i-2].f;\n\t\tymax[i] = Y[i-2].s;\n\t}\n\tFOR(i,3,n+1) {\n\t\tzmin[i] = Z[i-3].f;\n\t\tzmax[i] = Z[i-3].s;\n\t}\n    ymin[1] = -L;\n    ymax[1] = L;\n    zmin[2] = -L;\n    zmax[2] = L;\n\n    Deq v[2];\n    v[0].v.pb(P{xmin[1], -L});\n    v[0].v.pb(P{xmin[1], L});\n    v[0].v.pb(P{xmax[1], L});\n    v[1].v.pb(P{xmin[1], -L});\n    v[1].v.pb(P{xmax[1], -L});\n    v[1].v.pb(P{xmax[1], L});\n\n    for(int i = 0; i < 2; i++) {\n        v[i].op.resize(v[i].v.size());\n    }\n    vs rec;\n    for(int i = 2; i <= n + 1; i++) {\n        if(i == n + 1) break;\n        v[0].apply(Op(zmax[i]));\n        v[1].apply(Op(zmin[i]));\n        if(zmin[i] != zmax[i]) {\n            v[0].push_front(v[1].front());\n            v[1].push_back(v[0].back());\n        }\n\n        for(int d = 0; d < 2; d++) {\n            P t1, t2;\n            while(!v[d].empty() && (t1 = v[d].back()).y > ymax[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].bac()).y <= ymax[i]) {\n                    Frac c = (t1.x - t2.x) / (t1.y - t2.y);\n                    Frac delta = t1.x - t1.y * c;\n                    v[d].setback(P{(Frac)ymax[i] * c + delta, ymax[i]});\n                    if(d == 0) {\n                        v[d].push_back(P{L, ymax[i]});\n                    }\n                    break;\n                }else {\n                    v[d].pop_back();\n                }\n            }\n            while(!v[d].empty() && (t1 = v[d].back()).x > xmax[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].bac()).x <= xmax[i]) {\n                    Frac c = (t1.y - t2.y) / (t1.x - t2.x);\n                    Frac delta = t1.y - t1.x * c;\n                    v[d].setback(P{xmax[i], (Frac)xmax[i] * c + delta});\n                    if(d == 1) {\n                        v[d].push_back(P{xmax[i], L});   \n                    }\n                    break;\n                }else {\n                    v[d].pop_back();\n                }\n            }\n            while(!v[d].empty() && (t1 = v[d].front()).y < ymin[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].fron()).y >= ymin[i]) {\n                    Frac c = (t1.x - t2.x) / (t1.y - t2.y);\n                    Frac delta = t1.x - t1.y * c;\n                    v[d].setfront(P{(Frac)ymin[i] * c + delta, ymin[i]});\n                    if(d == 1) v[d].push_front(P{-L, ymin[i]});\n                    break;\n                }else {\n                    v[d].pop_front();\n                }\n            }\n\n            while(!v[d].empty() && (t1 = v[d].front()).x < xmin[i]) {\n                if(v[d].size() > 1 && (t2 = v[d].fron()).x >= xmin[i]) {\n                    Frac c = (t1.y - t2.y) / (t1.x - t2.x);\n                    Frac delta = t1.y - t1.x * c;\n                    v[d].setfront(P{xmin[i], (Frac)xmin[i] * c + delta});\n                    if(d == 0) v[d].push_front(P{xmin[i], -L});\n                    break;\n                }else {\n                    v[d].pop_front();\n                }\n            }\n        }\n        if(v[0].empty() || v[1].empty()) {\n        \treturn {0,rec};\n        }\n\n        P t[2];\n        for(int d = 0; d < 2; d++) {\n            t[d] = v[d].back();\n        }\n        if(t[0].x > t[1].x) t[0].x = t[1].x;\n        if(t[1].y > t[0].y) t[1].y = t[0].y;\n\n\n        /*        tmp = Op();\n                  for(int j = v[0].size() - 1; j >= 0; j--) {\n                  tmp = tmp * v[0].op[j];\n                  }\n                  if(i == 9998) {\n                  printf(""!!%d\\n"", v[0].size());\n                  printf(""%lld %lld %lld %lld \\n"", xmin[i - 1], xmax[i - 1], ymin[i - 1], ymax[i - 1]);\n                  printf(""%lld %lld %lld %lld \\n"", xmin[i], xmax[i], ymin[i], ymax[i]);\n                  printf(""%d %d\\n"", i, v[0].size());\n                  v[0].op.back().print();\n                  v[0].op[v[0].size() - 2].print();\n                  tmp.print();\n                  v[0].u.print();\n                  }*/\n\n\n        v[0].pop_back();\n\n        /*tmp = Op();\n          for(int j = v[0].size() - 1; j >= 0; j--) {\n            tmp = tmp * v[0].op[j];\n        }\n        if(i == 9998) {\n            printf(""!!%d\\n"", v[0].size());\n            printf(""%lld %lld %lld %lld \\n"", xmin[i - 1], xmax[i - 1], ymin[i - 1], ymax[i - 1]);\n            printf(""%lld %lld %lld %lld \\n"", xmin[i], xmax[i], ymin[i], ymax[i]);\n            printf(""%d %d\\n"", i, v[0].size());\n            v[0].op.back().print();\n            \n            tmp.print();\n            v[0].u.print();\n        }*/\n\n\n        v[0].push_back(t[0]);\n        v[1].setback(t[1]);\n        \n        if(t[0] != t[1]) {\n            if(t[0].x == t[1].x) {\n                v[1].push_back(v[0].back());\n            }else if(t[1].y == t[0].y) {\n                v[0].push_back(v[1].back());\n            }else {\n                v[0].push_back(P{t[1].x, t[0].y});\n                v[1].push_back(P{t[1].x, t[0].y});\n            }\n        }\n        \n        for(int d = 0; d < 2; d++) {\n            t[d] = v[d].front();\n        }\n        if(t[0].y < t[1].y) t[0].y = t[1].y;\n        if(t[1].x < t[0].x) t[1].x = t[0].x;\n        v[0].setfront(t[0]);\n        v[1].setfront(t[1]);\n        if(t[0] != t[1]) {\n            if(t[0].x == t[1].x) {\n                v[0].push_front(v[1].front());\n            }else if(t[1].y == t[0].y) {\n                v[1].push_front(v[0].front());\n            }else {\n                v[0].push_front(P{t[0].x, t[1].y});\n                v[1].push_front(P{t[0].x, t[1].y});\n            }\n        }\n        // if (flag && (i-1)%1000 == 0) {\n    \t// rec.pb(""UPPER: ""+ts(v[0]));\n    \t// rec.pb(""LOWER: ""+ts(v[1]));\n        // }\n        // v[1].print();\n        // v[0].print();\n    }\n    return {1,rec};\n}\n}\n\nint main() {\n\tsetIO();\n\n\t// while (1) {\n\n\t// }\n\n\t// Tag x{3,4,5}, y{6,7,8};\n\t// Tag z = x.with_tag(y);\n\t// dbg(z);\n\t// dbg(z.with_tag(y.inv())); // {c: 3, delta_x:4, delta_y:5}\n\t// dbg(z.with_tag(x.inv())); \n\t// dbg(undo_front(x,z)); // {c: 6, delta_x:7, delta_y:8}\n\t// exit(0);\n\n\tint TC; re(TC);\n\t// int TC = 1000000;\n\tFOR(it,1,TC+1) {\n\t\t// dbg(""GOING"",it);\n\n\t\tint N = mine::rng_int(3,10);\n\t\tre(N); \n\n\t\tvpi X(N), Y(N-1), Z(N-2);\n\t\tvi sol(N);\n\t\tF0R(i,N) sol[i] = mine::rng_int(-1e7,1e7);\n\t\t// X.rsz(N), Y.rsz(N-1), Z.rsz(N-2); \n\t\tF0R(i,N) X[i] = mine::rand_around(sol[i]);\n\t\tF0R(i,N-1) Y[i] = mine::rand_around(sol[i+1]-sol[i]);\n\t\tF0R(i,N-2) Z[i] = mine::rand_around(sol[i+2]-2*sol[i+1]+sol[i]);\n\n\t\tre(X,Y,Z);\n\n\t\tflag = it == 2 && N == 100000;\n\n\t\tauto a = mine::solve(it,N,X,Y,Z);\n\t\t// ps();\n\t\tauto b = model::solve(N,X,Y,Z);\n\t\t// assert(sz(a.s) == sz(b.s));\n\t\t// F0R(i,min(sz(a.s),sz(b.s))) if (a.s[i] != b.s[i]) {\n\t\t// \tps(""FAILED"",it,i);\n\t\t// \tps(a.s[i]);\n\t\t// \tps(b.s[i]);\n\t\t// \texit(0);\n\t\t// }\n\t\t// F0R(i,sz(a.rec))\n\t\tdbg(a);\n\t\tdbg(b);\n\n\t\t// ps();\n\n\t\t// assert(a == b);\n\t\tif (a.f) ps(""YES"");\n\t\telse ps(""NO"");\n\t}\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON\'T GET STUCK ON ONE APPROACH\n*/\n']","[0, 0, 0, 1, 0]",3500,Consider the DP idea dp i x y represests whether there exists a sequence satisfying all the constraints Constraints about are ignored Then is a region on the plane We will prove that it is convex and then show that we can efficiently transform to Initially we can construct In represents and represents The constraints are is the intersection of these half planes so it is convex Calculate by We should take the new constraints into account Let s consider the last constraint first and ignore the first two for now If point in represents since will become in since Thus to transform to we simply apply the tranformation and then move the region by the vector is a linear transformation We call the new region Now we know that is between and So we should take the union of all for Finally we add the first two constraints about and back These constraints correspond to cutting the region by vertical or horizontal half planes The answer is yes if and only if is nonempty By the process above we can prove inductively that the region is always convex For each we only add vertical and horizontal half planes These half planes will cut some original edges of the convex polygon and add some new vertical or horizontal edges to it The transformation will change an edge with slope into an edge with slope vertical edges becomes edges with slope So we can also prove inductively that for any all the edges of have slope or for some integer These edges can be written as for integral and We now know that for any the region is always convex and all edges have slope or for some integer Next we describe how to implement the process described above efficiently We maintain two deques for the vertices on the upper and lower hull of the polygon Vertical edges are included in the upper hull if they have minimum coordinate and lower hull if they have maximum coordinate To cut the polygon by vertical or horizontal half planes we simply pop some vertices at the end of the deques And possibly add some new vertices at the front or back of the deques To apply the transformation we apply it to all vertices of the convex polygon Since we apply the same operation to all vertices this can be done by tags in constant time like the tags in segment trees We will explain the precision issues later Finally to take the union of all we move the upper hull by and the lower hull by These are again transformations applied to all vertices in each deque We use tags as well The new upper hull and new lower hull are not necessarily connected If they are not we connect their first and last vertices The time complexity is assuming each arithmetic operation costs constant time 
Misha has found a binary tree with n vertices numbered from 1 to n A binary tree is an acyclic connected bidirectional graph containing n vertices and n 1 edges Each vertex has a degree at most 3 whereas the root is the vertex with the number 1 and it has a degree at most 2 Unfortunately the root got infected The following process happens n times Misha either chooses a non infected and not deleted vertex and deletes it with all edges which have an end in this vertex or just does nothing Then the infection spreads to each vertex that is connected by an edge to an already infected vertex all already infected vertices remain infected As Misha does not have much time to think please tell him what is the maximum number of vertices he can save from the infection note that deleted vertices are not counted as saved ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint T, n;\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(0);\n    cin >> T;\n    while (T--) {\n        cin >> n;\n        vector<vector<int>> adj(n + 1, vector<int>(0));\n        vector<int> siz(n + 1);\n        for (int i = 1; i < n; i++) {\n            int u, v;\n            cin >> u >> v;\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        function<void(int, int)> dfs = [&](int u, int fa) {\n            siz[u] = 1;\n            for (auto v : adj[u]) {\n                if (v == fa) continue;\n                dfs(v, u); siz[u] += siz[v];\n            }\n        };\n        function<int(int, int)> dfs2 = [&](int u, int fa) {\n            vector<pair<int, int>> s;\n            for (auto v : adj[u]) {\n                if (v == fa) continue;\n                s.emplace_back(siz[v] - 1, dfs2(v, u));\n            }\n            if (s.size() == 0) return 0;\n            if (s.size() == 1) return s[0].first;\n            return max(s[0].first + s[1].second, s[1].first + s[0].second);\n        };\n        dfs(1, 0);\n        cout << dfs2(1, 0) << endl;\n    }\n    return 0;\n}']","[0, 0, 0, 1, 0]",1600,SolutionLet be the sequence of removed vertices such that the infection cannot spread anymore If vertex was never directly connected to an infected vertex then we could have deleted its parent instead of and we would have got a better solution Hence we may assume we always delete a vertex directly connected to an infected one Now we may use some dynamic programming ideas Let be the maximum number of vertices we can save in the subtree of vertex if that vertex is infected and we use operations only in the subtree We can assume the second as the tree is binary and we have two choices save the subtree of one child by deleting it and infect the other or the other way around In each case the infection will be active in at most one subtree of some vertex If and are the children of vertex the transition is where denotes the number of vertices in the subtree of The answer to the problem is Complexity is 
There is a square grid of size n times n Some cells are colored in black all others are colored in white In one operation you can select some rectangle and color all its cells in white It costs max h w to color a rectangle of size h times w You are to make all cells white for minimum total cost ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=57;\n\nint n;\n\nchar wcz[nax];\n\nint sum[nax][nax];\n\nint dp[nax][nax][nax][nax];\n\nint licz(int a, int b, int x, int y)\n{\n\ta--;\n\tb--;\n\treturn sum[x][y]-sum[a][y]-sum[x][b]+sum[a][b];\n}\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(""%s"", wcz+1);\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tsum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+(wcz[j]==\'#\');\n\t}\n\t//~ debug() << imie(licz(1, n, 1, n));\n\tfor (int j=1; j<=n; j++)\n\t{\n\t\tfor (int i=j; i; i--)\n\t\t{\n\t\t\tfor (int b=1; b<=n; b++)\n\t\t\t{\n\t\t\t\tfor (int a=b; a; a--)\n\t\t\t\t{\n\t\t\t\t\tif (!licz(i, a, j, b))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[i][a][j][b]=max(b-a+1, j-i+1);\n\t\t\t\t\tif (b-a>j-i)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int x=a; x<b; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i][a][j][b]=min(dp[i][a][j][b], dp[i][a][j][x]+dp[i][x+1][j][b]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int x=i; x<j; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[i][a][j][b]=min(dp[i][a][j][b], dp[i][a][x][b]+dp[x+1][a][j][b]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//~ debug() << i << "" "" << a << "" "" << j << "" "" << b << ""  "" << dp[i][a][j][b];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(""%d\\n"", dp[1][1][n][n]);\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0]",2300,Let s solve the problem for rectangle Of course we can cover all rectangle with itself for cost To get something smaller than we have to leave at least one column uncovered otherwise we pay at least sum of over all rectangles which is at least This gives us an idea to use DP on rectangles to solve the problem is minimal cost to cover the rectangle It is initialized by and we have to try not to cover every column row Of course we have to check if it is all white from the beginning to do that we will precalculate 2D prefix sums Total complexity is 
Arseniy came up with another business plan to sell soda from a vending machine For this he purchased a machine with n shelves as well as k bottles where the i th bottle is characterized by the brand index b i and the cost c i You can place any number of bottles on each shelf but all bottles on the same shelf must be of the same brand Arseniy knows that all the bottles he puts on the shelves of the machine will be sold Therefore he asked you to calculate the amount he can earn ,"['#include <iostream>#include <cmath>#include <vector>#include <algorithm>#include <map>#include <set>#include <bitset>#include <queue>#define ff first#define ss secondtypedef long long ll;using namespace std;const int N = 3e5 + 10;void solve() {\tint n, k;\tcin >> n >> k;\tmap <int, int> mp;\tfor (int i = 1; i <= k; i++) {\t\tint a, b;\t\tcin >> a >> b;\t\tmp[a] += b;\t}\tvector <int> v;\tfor (auto it : mp) {\t\tv.push_back(it.second);\t\t}\tsort(v.begin(), v.end());\treverse(v.begin(), v.end());\tint ans = 0;\tfor (int i = 0; i < min(n, (int)v.size()); i++) {\t\tans += v[i];\t}\tcout << ans << ""\\n"";}int main() {\tint t;\tcin >> t;\twhile (t--) {\t\tsolve();\t}}']","[1, 0, 0, 0, 0]",800,TutorialLet s create an array brand cost of length and fill it so that brand cost i stores the cost of all bottles of brand Then sort the array by non growing and calculate the sum of its first min n k elements which will be the answer to the problem Complexity 
City X consists of vertical and horizontal infinite roads forming intersections Roads both vertical and horizontal are numbered from to and the intersections are indicated by the numbers of the roads that form them Sand roads have long been recognized out of date so the decision was made to asphalt them To do this a team of workers was hired and a schedule of work was made according to which the intersections should be asphalted Road repairs are planned for days On the th day of the team arrives at the th intersection in the list and if of the two roads that form the intersection were already asphalted they asphalt both roads Otherwise the team leaves the intersection without doing anything with the roads According to the schedule of road works tell in which days at least one road will be asphalted ,"[""#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nint a[55],b[55],n;\n \nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n*n;i++)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tif(a[x]==0&&b[y]==0)a[x]=b[y]=1,cout<<i<<' ';\n\t}\n\treturn 0;\n}\n""]","[0, 0, 1, 0, 0]",1000,To solve the problem one could just store two arrays hused j and vused j sized n and filled with false initially Then process intersections one by one from 1 to n and if for i th intersections both hused hi and vused vi are false add i to answer and set both hused hi and vused vi with true meaning that hi th horizontal and vi th vertical roads are now asphalted and skip asphalting the intersection roads otherwise 
You are given an array a consisting of n positive integers Find a subset of its elements such that their sum is i e divisible by 2 or determine that there is no such subset Both the given array and required subset may contain equal values ,"['#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    \n    int itest;\n    cin >> itest;\n    \n    while (itest--) {\n        int n;  cin >> n;\n        \n        vector<int> S0;\n        vector<int> S1;\n        \n        for(int i = 1 ; i <= n ; ++i)    {\n            int x;  cin >> x;\n            if (x & 1)  S1.push_back(i);\n            else        S0.push_back(i);\n        }\n        if (S0.size())  {\n            cout << ""1\\n"";\n            cout << S0[0] << ""\\n"";\n            continue;\n        }\n        if (S1.size() > 1)  {\n            cout << ""2\\n"";\n            cout << S1[0] << "" "" << S1[1] << ""\\n"";\n            continue;\n        }\n        cout << ""-1\\n"";\n    }\n}']","[1, 0, 1, 1, 0]",800,If there is an even element in array there is an answer consisting of only it Otherwise if there is at least two odd elements in array there is an answer consisting of this two elements Otherwise array is only one odd element and there is no answer 
Vasya has a very beautiful country garden that can be represented as an rectangular field divided into squares One beautiful day Vasya remembered that he needs to pave roads between important squares that contain buildings To pave a road he can cover some squares of his garden with concrete For each garden square we know number that represents the number of flowers that grow in the square with coordinates When a square is covered with concrete all flowers that grow in the square die Vasya wants to cover some squares with concrete so that the following conditions were fulfilled all important squares should necessarily be covered with concrete from each important square there should be a way to any other important square The way should go be paved with concrete covered squares considering that neighboring squares are squares that have a common side the total number of dead plants should be minimum As Vasya has a rather large garden he asks you to help him ,"['#include <vector>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <cassert>\n\nusing namespace std;\n\n//----------------------zjut_DD for Topcoder-------------------------------\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n#define PB push_back\n#define MP make_pair\n#define ff first\n#define ss second\n#define sz(v) (int)v.size()\n#define all(c) c.begin(),c.end() \n#define clr(buf,val) memset(buf,val,sizeof(buf))\n#define rep(i,l,r) for(int i=(l);i<(r);i++)\n#define repv(i,v)  for(int i=0;i<(int)v.size();i++)\n#define repi(it,c) for(typeof(c.begin()) it=c.begin();it!=c.end();++it)\n//------------------------------------------------------------------------\n\nstring s[110];\nconst int mod=1000000007;\n\nint n, m, k;\n\nPII pre[1<<7][220];\nint dp[1<<7][220];\n\nint val[220][220];\n\nint id[220][220];\nPII p[220];\n\nqueue<int> q;\nbool inq[1<<7][220];\n\nvoid update(int a, int b, int val, int pa, int pb){\n\tif( dp[a][b]<=val ) return;\n\tdp[a][b]=val;\n\tpre[a][b]=MP(pa, pb);\n\tif( inq[a][b]==false ){\n\t\tinq[a][b]=true;\n\t\tq.push(a);\n\t\tq.push(b);\n\t}\n}\nint dir[4][2]={0,1, 1,0, 0,-1, -1,0};\nbool ill(int i, int j){\n\treturn i>=0 && i<n && j>=0 && j<m;\n}\n\nchar mat[220][220];\nbool vst[1<<7][220];\nvoid dfs(int a, int b){\n\t\n\tif( vst[a][b] ) return;\n\tvst[a][b]=true;\n\tint x=p[b].ff, y=p[b].ss;\n\tmat[x][y]=\'X\';\n\tint pa=pre[a][b].ff, pb=pre[a][b].ss;\n\t\n\t//printf(""a=%d b=%d x=%d y=%d pa=%d pb=%d\\n"", a, b, x, y, pa, pb);\n\tif( pb<0 ) return;\n\tif( pb==b ){\n\t\tdfs(pa, pb);\n\t\tdfs(a-pa, pb);\n\t}else{\n\t\tdfs(pa, pb);\n\t}\n}\n\nint main(){\n\t//cout<<(1LL<<31)*1000000000<<endl;\n\twhile( scanf(""%d %d %d"", &n, &m, &k)!=EOF ){\n\t\tint cnt=0;\n\t\trep(i, 0, n) rep(j, 0, m){\n\t\t\tscanf(""%d"", val[i]+j);\n\t\t\tid[i][j]=cnt;\n\t\t\tp[cnt++]=MP(i, j);\n\t\t}\n\t\tclr(dp, 0x3f);\n\t\tclr(inq, false);\n\t\trep(i, 0, k){\n\t\t\tint x, y; scanf(""%d %d"", &x, &y);\n\t\t\tx--; y--;\n\t\t\tupdate(1<<i, id[x][y], val[x][y], -1, -1);\n\t\t}\n\t\twhile( !q.empty() ){\n\t\t\tint a=q.front(); q.pop();\n\t\t\tint b=q.front(); q.pop();\n\t\t\tinq[a][b]=false;\n\t\t\t//chu kou\n\t\t\trep(in, 0, 4){\n\t\t\t\tint tx=p[b].ff+dir[in][0];\n\t\t\t\tint ty=p[b].ss+dir[in][1];\n\t\t\t\tif( ill(tx, ty)==false ) continue;\n\t\t\t\tupdate(a, id[tx][ty], dp[a][b]+val[tx][ty], a, b);\n\t\t\t}\n\t\t\tint tt=(1<<k)-1 - a;\n\t\t\tfor(int s=tt;s;s=(s-1)&tt){\n\t\t\t\tupdate(a|s, b, dp[a][b]+dp[s][b]-val[ p[b].ff ][ p[b].ss ], a, b);\n\t\t\t}\n\t\t}\n\t\tint mi=1<<30;\n\t\tint b;\n\t\trep(j, 0, cnt) {\n\t\t\tif( dp[(1<<k)-1][j]<mi ){\n\t\t\t\tmi=dp[(1<<k)-1][j];\n\t\t\t\tb=j;\n\t\t\t} \n\t\t}\n\t\tprintf(""%d\\n"", mi);\n\t\tclr(vst, false);\n\t\tclr(mat, \'.\');\n\t\tdfs((1<<k)-1, b);\n\t\trep(i, 0, n) {\n\t\t\trep(j, 0, m) putchar(mat[i][j]);\n\t\t\tputs("""");\n\t\t}\n\t}\n}\n\n']","[0, 0, 0, 1, 0]",2500,The solution of this problem is based on dynamic programming the value of the minimum correct concrete cover if we consider as important elements only elements of the mask and there are additionally covered the vertex of the field There are two types of transfers First of all we can as if to cut coverage on the vertex Then you need to go through subpattern of vertex which will go to the left coverage and make an optimizing transfer Update with the value Second perhaps in the vertex in the optimal coverage mask which covers the vertex you can not make the cut separating the set of vertices In this case this vertex forms something a kind of And there a vertex exists on which we can make the cut with the whole shortest path from a vertex to belongs to the optimal coverage Let s precalculate the shortest paths between all pairs of cells Now to make this transition we should count the value of dynamics for all vertices only on the basis of the first transition Now you can make the second transition For all update the value of Let s process separately state in which exactly one bit in the mask and the vertex which corresponding to this bit is equal to In this case the answer is equal to of course Thus each solution is obtained for the 
Ithea and Chtholly want to play a game in order to determine who can use the kitchen tonight Initially Ithea puts clear sheets of paper in a line They are numbered from to from left to right This game will go on for rounds In each round Ithea will give Chtholly an integer between and and Chtholly needs to choose one of the sheets to write down this number if there is already a number before she will erase the original one and replace it with the new one Chtholly wins if at any time all the sheets are filled with a number and the numbers are in non decreasing order looking from left to right from sheet to sheet and if after rounds she still doesn t win she loses the game Chtholly really wants to win the game as she wants to cook something for Willem But she doesn t know how to win the game So Chtholly finds you and your task is to write a program to receive numbers that Ithea gives Chtholly and help her make the decision on which sheet of paper write this number ,"['#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n\n#define _CRT_SECURE_NO_WARNINGS\n# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n\n#ifdef LOCAL\n# include <opencv2/core/core.hpp>\n# include <opencv2/highgui/highgui.hpp>\n# include <opencv2/imgproc/imgproc.hpp>\n#endif\n\nusing namespace std;\n\n// Let\'s define unordered map\n# ifdef __GNUC__\n# if __cplusplus > 199711L\n# include <unordered_set>\n# include <unordered_map>\n# else\n# include <tr1/unordered_map>\n# include <tr1/unordered_set>\nusing namespace tr1;\n# endif\n# else\n# include <unordered_map>\n# include <unordered_set>\n# endif\n\n#define VA_NUM_ARGS(...) VA_NUM_ARGS_IMPL_((0,__VA_ARGS__, 6,5,4,3,2,1))\n#define VA_NUM_ARGS_IMPL_(tuple) VA_NUM_ARGS_IMPL tuple\n#define VA_NUM_ARGS_IMPL(_0,_1,_2,_3,_4,_5,_6,N,...) N\n#define macro_dispatcher(macro, ...) macro_dispatcher_(macro, VA_NUM_ARGS(__VA_ARGS__))\n#define macro_dispatcher_(macro, nargs) macro_dispatcher__(macro, nargs)\n#define macro_dispatcher__(macro, nargs) macro_dispatcher___(macro, nargs)\n#define macro_dispatcher___(macro, nargs) macro ## nargs\n#define DBN1(a)           cerr<<#a<<""=""<<(a)<<""\\n""\n#define DBN2(a,b)         cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<""\\n""\n#define DBN3(a,b,c)       cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<""\\n""\n#define DBN4(a,b,c,d)     cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<""\\n""\n#define DBN5(a,b,c,d,e)   cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<"", ""<<#e<<""=""<<(e)<<""\\n""\n#define DBN6(a,b,c,d,e,f) cerr<<#a<<""=""<<(a)<<"", ""<<#b<<""=""<<(b)<<"", ""<<#c<<""=""<<(c)<<"", ""<<#d<<""=""<<(d)<<"", ""<<#e<<""=""<<(e)<<"", ""<<#f<<""=""<<(f)<<""\\n""\n#define DBN(...) macro_dispatcher(DBN, __VA_ARGS__)(__VA_ARGS__)\n#define DA(a,n) cerr<<#a<<""=[""; printarray(a,n); cerr<<""]\\n""\n#define DAR(a,n,s) cerr<<#a<<""[""<<s<<""-""<<n-1<<""]=[""; printarray(a,n,s); cerr<<""]\\n""\n\n#ifdef _MSC_VER\n#define PREFETCH(ptr, rw, level) ((void)0)\n#else\n#define PREFETCH(ptr, rw, level) __builtin_prefetch(ptr, rw, level)\n#endif\n\n#ifdef LOCAL\n#define CURTIME() cerr << clock() * 1.0 / CLOCKS_PER_SEC << endl\n#else\n#define CURTIME()\n#endif\n\n#define mp make_pair\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef int itn;\n\ntemplate<class T1, class T2, class T3>\nstruct triple{ T1 a; T2 b; T3 c; triple() : a(T1()), b(T2()), c(T3()) {}; triple(T1 _a, T2 _b, T3 _c) :a(_a), b(_b), c(_c){} };\ntemplate<class T1, class T2, class T3>\nbool operator<(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a<t2.a;else if(t1.b!=t2.b)return t1.b<t2.b;else return t1.c<t2.c;}\ntemplate<class T1, class T2, class T3>\nbool operator>(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a>t2.a;else if(t1.b!=t2.b)return t1.b>t2.b;else return t1.c>t2.c;}\n#define tri triple<int,int,int>\n#define trll triple<ll,ll,ll>\n\n#define FI(n) for(int i=0;i<(n);++i)\n#define FJ(n) for(int j=0;j<(n);++j)\n#define FK(n) for(int k=0;k<(n);++k)\n#define FL(n) for(int l=0;l<(n);++l)\n#define FQ(n) for(int q=0;q<(n);++q)\n#define FOR(i,a,b) for(int i = (a), __e = (int) (b); i < __e; ++i)\n#define all(a) std::begin(a), std::end(a)\n#define reunique(v) v.resize(std::unique(v.begin(), v.end()) - v.begin())\n\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(1.0 * (x))\n#define pow(x, n) pow(1.0 * (x), n)\n\n#define COMPARE(obj) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b)\n#define COMPARE_BY(obj, field) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b) { return a.field < b.field; }\n\n#define checkbit(n, b) (((n) >> (b)) & 1)\n#define setbit(n, b) ((n) | (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define removebit(n, b) ((n) & ~(static_cast<std::decay_t<decltype(n)>>(1) << (b)))\n#define flipbit(n, b) ((n) ^ (static_cast<std::decay_t<decltype(n)>>(1) << (b)))\ninline int countBits(uint v){v=v-((v>>1)&0x55555555);v=(v&0x33333333)+((v>>2)&0x33333333);return((v+(v>>4)&0xF0F0F0F)*0x1010101)>>24;}\ninline int countBits(ull v){uint t=v>>32;uint p=(v & ((1ULL << 32) - 1)); return countBits(t) + countBits(p); }\ninline int countBits(ll v){return countBits((ull)v); }\ninline int countBits(int v){return countBits((uint)v); }\nunsigned int reverseBits(uint x){ x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)); x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2)); x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4)); x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8)); return((x >> 16) | (x << 16)); }\ntemplate<class T> inline int sign(T x){ return x > 0 ? 1 : x < 0 ? -1 : 0; }\ninline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); }\nconstexpr ll power(ll x, int p) { return p == 0 ? 1 : (x * power(x, p - 1)); }\ntemplate<class T1, class T2, class T3> T1 inline clamp(T1 x, const T2& a, const T3& b) { if (x < a) return a; else if (x > b) return b; else return x; }\nunsigned long long rdtsc() { unsigned long long ret = 0;\n#ifdef __clang__\n    return __builtin_readcyclecounter();\n#endif\n#ifndef _MSC_VER\n    asm volatile(""rdtsc"" : ""=A"" (ret) : :);\n#endif\n    return ret; }\n// Fast IO ********************************************************************************************************\nconst int __BS = 4096;\nstatic char __bur[__BS + 16], *__er = __bur + __BS, *__ir = __er;\ntemplate<class T = int> T readInt() {\n    auto c = [&]() { if (__ir == __er) std::fill(__bur, __bur + __BS, 0), cin.read(__bur, __BS), __ir = __bur; };\n    c(); while (*__ir && (*__ir < \'0\' || *__ir > \'9\') && *__ir != \'-\') ++__ir; c();\n    bool m = false; if (*__ir == \'-\') ++__ir, c(), m = true;\n    T r = 0; while (*__ir >= \'0\' && *__ir <= \'9\') r = r * 10 + *__ir - \'0\', ++__ir, c();\n    ++__ir; return m ? -r : r;\n}\nstatic char __buw[__BS + 20], *__iw = __buw, *__ew = __buw + __BS;\ntemplate<class T>\nvoid writeInt(T x, char endc = \'\\n\') {\n    if (x < 0) *__iw++ = \'-\', x = -x; if (x == 0) *__iw++ = \'0\';\n    char* s = __iw;\n    while (x) { T t = x / 10; char c = x - 10 * t + \'0\'; *__iw++ = c; x = t; }\n    char* f = __iw - 1; while (s < f) swap(*s, *f), ++s, --f;\n    if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw;\n    *__iw++ = endc;\n}\ntemplate<class T>\nvoid writeStr(const T& str) {\n    int i = 0; while (str[i]) { *__iw++ = str[i++]; if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw; }\n}\nstruct __FL__ { ~__FL__() { if (__iw != __buw) cout.write(__buw, __iw - __buw); } };\nstatic __FL__ __flushVar__;\n\n//STL output *****************************************************************************************************\n#define TT1 template<class T>\n#define TT1T2 template<class T1, class T2>\n#define TT1T2T3 template<class T1, class T2, class T3>\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p);\nTT1 ostream& operator << (ostream& os, const vector<T>& v);\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, const multiset<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v);\nTT1T2T3 ostream& operator << (ostream& os, const map<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const multimap<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t);\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v);\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p){ return os <<""(""<<p.first<<"", ""<< p.second<<"")""; }\nTT1 ostream& operator << (ostream& os, const vector<T>& v){       bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v) {     bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v){    bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const multiset<T1,T2>&v){bool f=1;os<<""["";for(auto& i : v) { if (!f)os << "", "";os<<i;f=0;}return os << ""]""; }\nTT1T2T3 ostream& operator << (ostream& os, const map<T1,T2,T3>& v){ bool f = 1; os << ""[""; for (auto& ii : v) { if (!f)os << "", ""; os << ""("" << ii.first << "" -> "" << ii.second << "") ""; f = 0; }return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, const multimap<T1, T2>& v){ bool f = 1; os << ""[""; for (auto& ii : v) { if (!f)os << "", ""; os << ""("" << ii.first << "" -> "" << ii.second << "") ""; f = 0; }return os << ""]""; }\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v) { bool f = 1; os << ""[""; while (!v.empty()) { auto x = v.top(); v.pop(); if (!f) os << "", ""; f = 0; os << x; } return os << ""]""; }\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t){ return os << ""("" << t.a << "", "" << t.b << "", "" << t.c << "")""; }\nTT1T2 void printarray(const T1& a, T2 sz, T2 beg = 0){ for (T2 i = beg; i<sz; i++) cout << a[i] << "" ""; cout << endl; }\n\n//STL input *****************************************************************************************************\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t);\nTT1T2 inline istream& operator >> (istream& os, pair<T1, T2>& p) { return os >> p.first >> p.second; }\nTT1 inline istream& operator >> (istream& os, vector<T>& v) {\n    if (v.size()) for (T& t : v) os >> t; else {\n        string s; T obj; while (s.empty()) {getline(os, s); if (!os) return os;}\n        stringstream ss(s); while (ss >> obj) v.push_back(obj);\n    }\n    return os;\n}\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t) { return os >> t.a >> t.b >> t.c; }\n\n//Pair magic *****************************************************************************************************\n#define PT1T2 pair<T1, T2>\nTT1T2 inline PT1T2 operator+(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first + p2.first, p1.second + p2.second); }\nTT1T2 inline PT1T2& operator+=(PT1T2 &p1 , const PT1T2 &p2) { p1.first += p2.first, p1.second += p2.second; return p1; }\nTT1T2 inline PT1T2 operator-(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first - p2.first, p1.second - p2.second); }\nTT1T2 inline PT1T2& operator-=(PT1T2 &p1 , const PT1T2 &p2) { p1.first -= p2.first, p1.second -= p2.second; return p1; }\n\n#undef TT1\n#undef TT1T2\n#undef TT1T2T3\n\n#define FREIN(FILE) freopen(FILE, ""rt"", stdin)\n#define FREOUT(FILE) freopen(FILE, ""wt"", stdout)\n#ifdef LOCAL\n#define BEGIN_PROFILE(idx, name) int profileIdx = idx; profileName[profileIdx] = name; totalTime[profileIdx] -= rdtsc() / 1e3;\n#define END_PROFILE totalTime[profileIdx] += rdtsc() / 1e3; totalCount[profileIdx]++;\n#else\n#define BEGIN_PROFILE(idx, name)\n#define END_PROFILE\n#endif\n\ntemplate<class T> inline void normmod(T &x, T m) { x %= m; if (x < 0) x += m; }\ntemplate<class T1, class T2> inline T2 summodfast(T1 x, T1 y, T2 m) { T2 res = x + y; if (res >= m) res -= m; return res; }\ntemplate<class T1, class T2, class T3> inline void addmodfast(T1 &x, T2 y, T3 m) { x += y; if (x >= m) x -= m; }\ntemplate<class T1, class T2, class T3> inline void submodfast(T1 &x, T2 y, T3 m) { x -= y; if (x < 0) x += m; }\n#if INTPTR_MAX == INT32_MAX or !defined(__SIZEOF_INT128__)\ninline ll mulmod(ll x, ll n, ll m){ ll r = 0; normmod(x, m); normmod(n, m); while (n) { if (n & 1) r += x; x += x; if (r >= m) r -= m; if (x >= m) x -= m; n /= 2; } return r; }\n#else\nusing int128 = __int128;\ninline ll mulmod(ll x, ll n, ll m){ return __int128(x) * n % m; }\n#endif\ninline ll powmod(ll x, ll n, ll m){ ll r = 1; normmod(x, m); while (n){ if (n & 1)r = (r*x) % m; x = (x*x) % m; n /= 2; }return r; }\ninline ll powmulmod(ll x, ll n, ll m) { ll res = 1; normmod(x, m); while (n){ if (n & 1)res = mulmod(res, x, m); x = mulmod(x, x, m); n /= 2; } return res; }\ntemplate<class T> inline T gcd(T a, T b) { while (b) { a %= b; T t = a; a = b; b = t; } return a; }\ninline ll lcm(ll a, ll b){ return a / gcd(a, b) * b; }\ntemplate<class T> inline T gcd(T a, T b, T c){ return gcd(gcd(a, b), c); }\nll gcdex(ll a, ll b, ll& x, ll& y) {\n    if (!a) { x = 0; y = 1; return b; }\n    ll y1; ll d = gcdex(b % a, a, y, y1); x = y1 - (b / a) * y;\n    return d;\n}\ntemplate<class T> bool isPrime(T x) { if (x <= 4 || x % 2 == 0 || x % 3 == 0) return x == 2 || x == 3;\n    for (T i = 5; i * i <= x; i += 6) if (x % i == 0 || x % (i + 2) == 0) return 0; return 1; }\nbool millerRabin(long long n) {\n    if (n <= 1000) return isPrime(n);\n    long long s = n - 1; int t = 0; while (s % 2 == 0) s /= 2, ++t;\n    for (int a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) { if (!(a %= n)) return true;\n        long long f = powmulmod(a, s, n); if (f == 1 || f == n - 1) continue;\n        for (int i = 1; i < t; ++i) if ((f = mulmod(f, f, n)) == n - 1) goto nextp;\n        return false; nextp:;\n    } return true;\n}\n\n// Useful constants\n\n//int some_primes[7] = {24443, 100271, 1000003, 1000333, 5000321, 98765431, 1000000123};\n#define T9          1000000000\n#define T18         1000000000000000000LL\n#define INF         1011111111\n#define LLINF       1000111000111000111LL\n#define mod         1000000007\n#define EPS         (double)1e-10\n#define PI          3.14159265358979323846264\n#define link        asaxlajrewqwe\n#define rank        wahayawehasdakw\n//*************************************************************************************\n\nint32_t solve();\nint32_t main(int argc, char** argv) {\n    ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef LOCAL\n    //    FREIN(""input.txt"");\n    //            FREOUT(""out.txt"");\n#endif\n    return solve();\n}\nint a[10101];\nint solve() {\n    int n, m, c;\n    cin >> n >> m >> c;\n    FI(n) {\n        a[i] = INF;\n    }\n    int b = 0, e = 0;\n    while (m--) {\n//        printarray(a, n);\n        int x;\n        cin >> x;\n        int pos;\n        if (x <= c / 2) {\n            pos = int(upper_bound(a, a + b, x) - a);\n            if (pos == b) {\n                ++b;\n            }\n        } else {\n            pos = int(lower_bound(a + n - e, a + n, x) - a - 1);\n            if (pos == n - 1 - e) {\n                ++e;\n            }\n        }\n//        DBN(b, e);\n        a[pos] = x;\n        cout << pos + 1 << endl;\n        if (b + e == n) return 0;\n    }\n    \n    return 0;\n}\n\n']","[1, 0, 0, 0, 0]",2000,As the initial sheet has already in a non decreasing order although it has no numbers what we should do is just maintain this order We use a simple method to do so find the first sheet whose number is strictly greater than the given number or it s an empty sheet and replace it with the new number For each round we either replace an existing number with a strictly smaller one or fill in an empty sheet The first case will happen at most times for each sheet and the second case will happen only once for each sheet Thus in total we will modify a sheet for at most times Thus the total rounds won t be more than To pass all the tests we only need to maintain 2 similar sequences one non decreasing from the first and one non increasing from the last which makes a total round of precisely and use binary search or brute force to complete the finding process 
You ve got a positive integer sequence All numbers in the sequence are distinct Let s fix the set of variables Initially each variable contains the value of zero Consider the following sequence consisting of operations The first operation is assigning the value of to some variable Each of the following operations is assigning to some variable the value that is equal to the sum of values that are stored in the variables and At that the value that is assigned on the th operation must equal For each operation numbers are chosen anew Your task is to find the minimum number of variables such that those variables can help you perform the described sequence of operations ,"['#pragma comment(linker, ""/STACK:256000000"")\n#include <iostream>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <ctime>\n#include <cmath>\n#include <stdio.h>\n#include <set>\n#include <map>\n#include <stack>\n#include <fstream>\n#include <deque>\n#include <list>\n#include <ctime>\n\n#define SZ(a) (int(a.size()))\n#define MEM(a, val) memset(a, val, sizeof(a))\n#define MP(a, b) make_pair(a, b)\n#define PB(a) push_back(a)\n#define ALL(a) a.begin(), a.end()\n#define REP(i, n) for(int (i) = 0; (i) < (n); ++(i))\n#define FOR(i, a, b) for(int (i) = (a); (i) <= (b); ++(i))\n#define SQR(a) ((a) * (a))\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\ntypedef long long LL;\ntypedef long double dbl;\ntypedef pair<int, int> pii ;\ntypedef vector<int> vint;\ntypedef vector<LL> vLL;\n\nvector<bool> f[25];\nconst int inf = 1000000001;\nint n;\nint a[25];\ninline int bit(int i, int mask) {\n    return (mask >> i) & 1;\n}\n\nint main()\n{\n#ifdef _DEBUG\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#else\n    //freopen(""input.txt"", ""r"", stdin);freopen(""output.txt"", ""w"", stdout);\n#endif\n    cin >> n;\n    FOR(i, 1, n)\n        cin >> a[i];\n    f[1].resize(2);\n    f[1][0] = false;\n    f[1][1] = true;\n    for (int i = 1; i < n; ++i) {\n        f[i + 1].assign(1 << (i + 1), 0);\n        for (int mask = 0; mask < (1 << i); ++mask) {\n            if (f[i][mask]) {\n                bool end = false;\n                for (int j = 0; j < i && !end; ++j) {\n                    if (bit(j, mask) == 0)\n                        continue;\n                    for (int k = j; k < i && !end; ++k) {\n                        if (bit(k, mask) == 0)\n                            continue;\n                        if (a[j + 1] + a[k + 1] == a[i + 1]) {\n                            mask += (1 << i);\n                            f[i + 1][mask] = true;\n                            for (int u = 0; u < i; ++u) {\n                                if (bit(u, mask)) {\n                                    f[i + 1][mask ^ (1 << u)] = true;\n                                }\n                            }\n                            end = true;\n                            mask -= (1 << i);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    int ans = inf;\n    for (int mask = 0; mask < (1 << n); ++mask) {\n        if (f[n][mask]) {\n            int pans = 0;\n            int t = mask;\n            while (t > 0) {\n                pans += t & 1;\n                t >>= 1;\n            }\n            ans = min(ans, pans);\n        }\n    }\n    if (ans == inf)\n        cout << -1 << endl;\n    else\n        cout << ans << endl;\n    return 0;\n}']","[0, 0, 0, 1, 0]",2200,You can notice that when we want to perform some operation we are only interested in a subset of current values of variables including zeros So let s create which is if we can perform first operations and end up with the values from Here bit in the mask corresponds to the value where array stores all numbers in and a zero and th bit is set iff the value of one of the variables is To make transition from to let s look at the operation We have to find two values in the such that their sum is Then to calculate we have to set th bit in the where is such that Also while writing new variable we can overwrite any existing variable so we have an option to disable any bit in the Now it looks like we have states and transitions from each state disabling each bit But actually if we only make transition from the complexity will be because for each there are at most masks that we can achieve since there are only distinct numbers on the current prefix plus an additional zero And The only problem left is to check if we can build some number from using numbers from This can be precomputed in let s calculate array where th bit in is set iff we can get number from mask on the next step To calculate it first for each with at most bits just calculate all possible with any straightforward approach since there are only such masks For any other mask notice that we can get iff sum of some two values equals to So we can iterate over all submasks such that they differ from in exactly one bit and update with And since has at least bits if there is a pair which sums up to this pair will be included into at least one of the submasks One can even notice that we only need any such submasks to cover every pair of bits The answer is minimum number of bits over all masks such that Code 
You are given two integers n and k An array a 1 a 2 ldots a n of length n consisting of zeroes and ones is if for integers i from 1 to n of the following conditions are satisfied at least lceil frac i k rceil of the first i elements of a are equal to 1 at least lceil frac i k rceil of the last i elements of a are equal to 1 Here lceil frac i k rceil denotes the result of division of i by k rounded up For example lceil frac 6 3 rceil 2 lceil frac 11 5 rceil lceil 2 2 rceil 3 and lceil frac 7 4 rceil lceil 1 75 rceil 2 Find the minimum possible number of ones in a good array ,"['#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int, int>\n#define ff first\n#define ss second\n#define pb push_back\nusing namespace std;\nvoid init() {\n\t\n}\nvoid solve() {\n\tint n, k;\n\tcin >> n >> k;\n\tint a[n + 1];\n\tfor (int i = 1; i <= n; i++) a[i] = 0;\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\ta[i] = a[(n + 1) - i] = (i % k == 1);\n\t}\n\tint cnt = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcnt += a[i];\n\t\tif (cnt < i / k + bool(i % k)) {\n\t\t\tif (!a[i]) {\n\t\t\t\ta[i] = 1;\n\t\t\t\tcnt++;\n\t\t\t} else throw runtime_error("""");\n\t\t}\n\t}\n\tcout << cnt << endl;\n}\nint32_t main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tinit();\n\tint t = 1;\n\tcin >> t;\n\twhile (t--) solve();\n}']","[1, 1, 1, 0, 0]",800,Let s find lower bound for answer In any good array there are at least ones among the first elements Also is always as So there are at least ones in any good array This lower bound can always be achieved by placing ones on position and on positions for all integers such that The answer to the probelm is 
The Little Elephant has two permutations and of length consisting of numbers from 1 to inclusive Let s denote the th element of the permutation as the th element of the permutation as The between permutations and is the minimum absolute value of the difference between the positions of the occurrences of some number in and in More formally it s such minimum that A number of permutation consisting from elements is a permutation Overall a permutation has cyclic shifts The Little Elephant wonders for all cyclic shifts of permutation what is the distance between the cyclic shift and permutation ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint to[101000];\nint dif[101000];\nint ans[101000];\ninline int ABS(int a){return a>0?a:-a;}\nint main(){\n    int n,i,j;\n    scanf(""%d"",&n);\n    for(i=1;i<=n;i++){\n        int a;\n        scanf(""%d"",&a);\n        to[a]=i;\n    }\n    for(i=1;i<=n;i++){\n        int a;\n        scanf(""%d"",&a);\n        dif[i]=to[a]-i;\n        ans[i]=101000;\n    }\n    ans[0]=101000;\n    set<int> XD;\n    for(i=1;i<=n;i++){\n        XD.insert(dif[i]);\n        set<int>::iterator it=XD.lower_bound(n-i);\n        if(it!=XD.end()){\n            ans[i]=min(ans[i],ABS(*it-(n-i)));\n        }\n        if(it!=XD.begin()){\n            it--;\n            ans[i]=min(ans[i],ABS(*it-(n-i)));\n        }\n    }\n    XD.clear();\n    for(i=n;i>=1;i--){\n        XD.insert(dif[i]);\n        set<int>::iterator it=XD.lower_bound(-(i-1));\n        if(it!=XD.end()){\n            ans[i-1]=min(ans[i-1],ABS(*it+(i-1)));\n        }\n        if(it!=XD.begin()){\n            it--;\n            ans[i-1]=min(ans[i-1],ABS(*it+(i-1)));\n        }\n    }\n    ans[0]=min(ans[0],ans[n]);\n    for(i=0;i<n;i++)printf(""%d\\n"",ans[i]);\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","[0, 0, 0, 0, 1]",2100,Each of the shifts can be divided into two parts the right the one that starts from occurrence 1 and the left the rest of the elements If we could keep minimal distance for each part the minimal of these numbers will be the answers for the corresponding shift Lets solve the problems of the right part the left will be almost the same Let we have some shift for example and the permutation is and is then shifted is Let we keep two sets and The first will keep all the distances from integers in current left part to the corresponding positions in for the example above it is texttt 2 4 When you come to the next shift all integers in should be decreased by 1 that is because all distances are also decreased by 1 But now some integers in set may be negative when any negative integer occures it always will be 1 you need to delete it from and put 1 to the Also after shifting to the next shifts all integers in must be increase by 1 After that for any shift the answer will be minimum from the smallest numbers in and It was very useful to use standart set in C 
Consider a conveyor belt represented using a grid consisting of n rows and m columns The cell in the i th row from the top and the j th column from the left is labelled i j Every cell except n m has a direction Right or Down assigned to it If the cell i j is assigned direction any luggage kept on that will move to the cell i j 1 Similarly if the cell i j is assigned direction any luggage kept on that will move to the cell i 1 j If at any moment the luggage moves out of the grid it is considered to be lost There is a counter at the cell n m from where all luggage is picked A conveyor belt is called if and only if any luggage reaches the counter regardless of which cell it is placed in initially More formally for every cell i j any luggage placed in this cell should eventually end up in the cell n m This may not hold initially you are however allowed to the directions of some cells to make the conveyor belt functional Please determine the minimum amount of cells you have to change Please note that it is always possible to make any conveyor belt functional by changing the directions of some set of cells ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int k_N = 100 + 3;\n\nstring s[k_N];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int t;\n    cin >> t;\n\n    while(t--){\n        int n, m;\n        cin >> n >> m;\n\n        for(int i = 0; i < n; ++i)\n            cin >> s[i];\n    \n        int ans = 0;\n        for(int i = 0; i < n - 1; ++i)\n            ans += s[i][m - 1] != \'D\';\n\n        for(int i = 0; i < m - 1; ++i)\n            ans += s[n - 1][i] != \'R\';\n\n        cout << ans << ""\\n"";\n    }\n}']","[1, 0, 1, 0, 0]",800,The answer is It s obvious that we must change all Rs in the last column and all Ds in the last row Otherwise anything placed in those cells will move out of the grid We claim that doing just this is enough to make the grid functional Indeed for any other cell any luggage placed in it will eventually reach either the last row or the last column from which it will move to the counter Time Complexity 
Alyona decided to go on a diet and went to the forest to get some apples There she unexpectedly found a magic rooted tree with root in the vertex every vertex and every edge of which has a number written on The girl noticed that some of the tree s vertices are so she decided to play with them Let s call vertex if there is a vertex in subtree of vertex such that where is the number written on vertex is the sum of the numbers written on the edges on the path from to of a tree are vertices connected to a single vertex by a single edge but the root of a tree is a if and only if the tree consists of a single vertex root Thus Alyona decided to remove some of tree leaves until there will be no any sad vertex left in the tree What is the minimum number of leaves Alyona needs to remove ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxm = 1e5+10;\nstruct self\n{\n\tint x,y,w,nxt;\n}s[maxm*2];\nint fst[maxm];\nint son[maxm];\nlong long dep[maxm];\nlong long maxdep[maxm];\nlong long sad[maxm];\nint flag[maxm];\nint m,n,x,y,w;\nint ans;\nint f[maxm];\n\nvoid dfs(int u,int fa)\n{\n\tf[u]=fa;\n\t//cout<<""dfs ""<<u<<"" fa=""<<f[u]<<endl;\n\tfor(int e=fst[u];e!=-1;e=s[e].nxt)\n\t{\n\t\tint v=s[e].y;\n\t\tif(v!=fa)\n\t\t{\n\t\t\tdep[v]=dep[u]+(long long)s[e].w;\n\t\t\tmaxdep[v]=max(maxdep[u]+(long long)s[e].w,(long long)s[e].w);\n\t\t\tmaxdep[v]=max(maxdep[v],0LL);\n\t\t\tdfs(v,u);\n\t\t}\n\t}\n}\n\nvoid remove(int u)\n{\n\tflag[u]=1;\n\tans++;\n\tfor(int e=fst[u];e!=-1;e=s[e].nxt)\n\t{\n\t\tint v=s[e].y;\n\t\tif(v!=f[u] && !flag[v])\n\t\t{\n\t\t\tremove(v);\n\t\t}\n\t}\n}\n\nvoid add(int x,int y,int w)\n{\n\tn++;s[n].x=x;s[n].y=y;s[n].w=w;\n\ts[n].nxt=fst[x];fst[x]=n;\n}\nint main()\n{\n\tscanf(""%d"",&m);\n\tmemset(fst,-1,sizeof(fst));\n\tfor(int i=1;i<=m;i++)scanf(""%I64d"",&sad[i]);\n\tfor(int i=1;i<m;i++)\n\t{\n\t\tscanf(""%d%d"",&y,&w);\n\t\tadd(i+1,y,w);\n\t\tadd(y,i+1,w);\n\t}\n\tdfs(1,1);\n\t//cout<<""ok""<<endl;\n\tfor(int i=1;i<=m;i++)\n\t\tif(sad[i]<maxdep[i] && !flag[i])\n\t\t{\n\t\t\t//cout<<""sad[""<<i<<""]=""<<sad[i]<<"" maxdep=""<<maxdep[i]<<endl;\n\t\t\tremove(i);\n\t\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0]",1600,Let s do dfs Suppose that we now stand at the vertex Let be some ancestor of vertex Then If then the vertex makes sad So you must remove the whole subtree of vertex Accordingly it is possible to maintain a minimum among in dfs where is ancestor of vertex in which we now stand And if the difference between the and that minimum is greater than then remove with the whole subtree 
Twilight Sparkle has received a new task from Princess Celestia This time she asked to decipher the ancient scroll containing important knowledge of pony origin To hide the crucial information from evil eyes pony elders cast a spell on the scroll That spell adds exactly one letter in any place to each word it is cast on To make the path to the knowledge more tangled elders chose of words in the scroll and cast a spell on them Twilight Sparkle knows that the elders admired the order in all things so the scroll original scroll contained words in She is asked to delete one letter from some of the words of the scroll to undo the spell to get some version of the original scroll Unfortunately there may be more than one way to recover the ancient scroll To not let the important knowledge slip by Twilight has to look through all variants of the original scroll and find the required one To estimate the maximum time Twilight may spend on the work she needs to know the number of variants she has to look through She asks you to find that number Since that number can be very big Twilight asks you to find it modulo 10 9 7 It may occur that princess Celestia has sent a wrong scroll so the answer may not exist A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring arr[2009];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    long long t=1;\n    //cin>>t;\n    while(t--) {\n        int n;\n        cin>>n;\n        int x=0,y=0;\n        for(int f=0;f<n;f++) {\n            cin>>arr[f];\n            x+=arr[f].size()+1;\n        }\n        long long ans=0,dp[22009]={0},mod=1e9+7;\n        for(int f=0;f<=arr[n-1].size();f++) {\n            dp[--x]=1;\n        }\n        y=x;\n        for(int f=n-2;f>=0;f--) {\n            x-=arr[f].size()+1;\n            int m=max(arr[f].size(),arr[f+1].size());\n            int m1=arr[f].size();\n            int m2=arr[f+1].size();\n            while(arr[f].size()<m)\n                arr[f]+=(\'a\'-1);\n            while(arr[f+1].size()<m)\n                arr[f+1]+=(\'a\'-1);\n            for(int f1=-1;f1<m1;f1++) {\n                bool ok[20009]={0};\n                int i=m-1;\n                if(f1==-1) {\n                    arr[f+1]+=(\'a\'-1);\n                    m++;\n                }\n                ok[m]=1;\n                for(int f2=m-1;f2>=1;f2--) {\n                    if(i==f1)\n                        i--;\n                    if(arr[f][i]<arr[f+1][f2]||arr[f][i]==arr[f+1][f2]&&(f2==m-1||ok[f2+1]))\n                        ok[f2]=1;\n                    i--;\n                }\n                bool b=0;\n                bool k=0;\n                i=0;\n                if(arr[f].substr(0,max(0,f1))+arr[f].substr(f1+1)<=arr[f+1]) {\n                    dp[x+f1+1]=(dp[x+f1+1]+dp[y])%mod;\n                    //cout<<x+f1+1<<"" ""<<y<<endl;\n                }\n                for(int f2=0;f2<m2;f2++){\n                    int x1=x+f1+1;\n                    int y1=y+f2+1;\n                    //cout<<""f2: ""<<f2<<"" x: ""<<x1<<"" y: ""<<y1<<endl;\n\n                    if(i==f1)\n                        i++;\n                    if(b) {\n                        //cout<<""1 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&f2+1==m) {\n                        //cout<<""2 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&arr[f][i]>arr[f+1][f2]&&ok[f2+1]) {\n                        //cout<<""3 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&arr[f][i]==arr[f+1][f2]&&ok[f2+1]) {\n                        //cout<<""4 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    else if(k==0&&arr[f][i]<arr[f+1][f2]&&ok[f2+1]) {\n                        //cout<<""5 ""<<x1<<"" ""<<y1<<endl;\n                        dp[x1]=(dp[x1]+dp[y1])%mod;\n                    }\n                    if(b==0&&f2>=0&&arr[f][i]>arr[f+1][f2]) {\n                        k=1;\n                        //cout<<""k""<<endl;\n                    }\n                    if(k==0&&f2>=0&&arr[f][i]<arr[f+1][f2]) {\n                        b=1;\n                        //cout<<""b""<<endl;\n                    }\n                    i++;\n                }\n            }\n            arr[f]=arr[f].substr(0,m1);\n            arr[f+1]=arr[f+1].substr(0,m2);\n            y-=arr[f].size()+1;\n        }\n        //cout<<""x: ""<<x<<endl;\n        for(int f=0;f<=arr[0].size();f++) {\n            ans=(ans+dp[f])%mod;\n        }\n        //for(int f=0;f<x;f++)\n        //    cout<<dp[f]<<"" "";\n        //cout<<endl;\n        cout<<ans<<endl;\n    }\n}\n']","[0, 0, 1, 1, 0]",2800,Let s use dynamic programming dp i j the number of ways to form the non decreasing subsequence on the strings 1 i s t the delete character in string i is j This works in O L3 where L is the total length of all strings Let s optimize this solution For each string sort all strings obtained by deleting at most one character from this string You can do it in O L2 logL for all strings Then you can use two pointers to calculate or dp To calculate the answer for the layer i we will consider strings in the sorted order and add all dp values for the smaller strings We can calculate this dp in O L2 and solve the problem in O L2 logL We can use binary search and hash to compare strings in O logL Then you can sort all the strings in O L log2L Note that you can sort the strings in O L Look at the string s For each character find the first character to the right not equal to it array nxt i Then we will store two pointers to the beginning and the end of the list Consider characters in the order from left to right If si snxt i add i to the beginning of the list to the position l and increase l by 1 otherwise add it to the end of the list to the position r and decrease r by 1 Then add s to some position in the list s will be in the list after it without the last character Then you can use the hash to make the comparisons for two pointers in O logL This sol works in O L logL and fits into TL 
Vanya walks late at night along a straight street of length lit by lanterns Consider the coordinate system with the beginning of the street corresponding to the point and its end corresponding to the point Then the th lantern is at the point The lantern lights all points of the street that are at the distance of at most from it where is some positive number common for all lanterns Vanya wonders what is the minimum light radius should the lanterns have to light the whole street ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tint l = 0, r, n;\n\tcin >> n >> r;\n\tvector<int> vec;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tvec.push_back(x);\n\t}\n\tsort(vec.begin(), vec.end());\n\t\n\tint ans = max(vec[0], r-vec.back()) * 2;\n\tfor(int i = 1 ; i < vec.size() ; i++){\n\t\tans = max(vec[i] - vec[i-1], ans);\n\t}\n\tif(ans&1){\n\t\tcout << ans / 2 << "".5000000000"" << endl;\n\t}\n\telse{\n\t\tcout << ans / 2 << "".0000000000"" << endl;\n\t}\n}']","[0, 1, 1, 0, 0]",1200,Sort lanterns in non decreasing order Then we need to find maximal distance between two neighbour lanterns let it be Also we need to consider street bounds and count distances from outside lanterns to street bounds it will be and The answer will be Time complexity Jury s solution 8924823 
For an array c of nonnegative integers MEX c denotes the smallest nonnegative integer that doesn t appear in it For example MEX 0 1 3 2 MEX 42 0 You are given integers n k and an array b 1 b 2 ldots b n Find the number of arrays a 1 a 2 ldots a n for which the following conditions hold 0 le a i le n for each i for each i from 1 to n MEX a 1 a 2 ldots a i b i le k for each i from 1 to n As this number can be very big output it modulo 998 244 353 ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n//#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t,class u>\nvoid print(const pair<t,u>&p,int suc=1){\n\tprint(p.a,2);\n\tprint(p.b,suc);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint(v[i],i==int(N)-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\n//mint107  verify \n//#define DYNAMIC_MOD\n\nstruct modinfo{uint mod,root;\n#ifdef DYNAMIC_MOD\nconstexpr modinfo(uint m,uint r):mod(m),root(r),im(0){set_mod(m);}\null im;\nconstexpr void set_mod(uint m){\n\tmod=m;\n\tim=ull(-1)/m+1;\n}\nuint product(uint a,uint b)const{\n\tull z=ull(a)*b;\n\tuint x=((unsigned __int128)z*im)>>64;\n\tuint v=uint(z)-x*mod;\n\treturn v<mod?v:v+mod;\n}\n#endif\n};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\t#ifndef DYNAMIC_MOD\n\t\tv=ull(v)*rhs.v%mod;\n\t\t#else\n\t\tv=ref.product(v,rhs.v);\n\t\t#endif\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(ll n)const{\n\t\tif(n<0)return inv().pow(-n);\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd<ll>(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n#ifndef DYNAMIC_MOD\nextern constexpr modinfo base{998244353,3};\n//extern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\n#ifdef USE_GOOD_MOD\nstatic_assert(base.mod==998244353);\n#endif\n#else\nmodinfo base(1,0);\nextern constexpr modinfo base107(1000000007,0);\nusing mint107=modular<base107>;\n#endif\nusing mint=modular<base>;\n\n#ifdef LOCAL\nconst int vmax=1010;\n#else\nconst int vmax=(1<<21)+10;\n#endif\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\n/*\nconst int vmax=110;\nmint binbuf[vmax][vmax];\nmint choose(int n,int k){\n\treturn binbuf[n-k][k];\n}\nmint binom(int a,int b){\n\treturn binbuf[a][b];\n}\nvoid initfact(){\n\tbinbuf[0][0]=1;\n\trep(i,vmax)rep(j,vmax){\n\t\tif(i)binbuf[i][j]+=binbuf[i-1][j];\n\t\tif(j)binbuf[i][j]+=binbuf[i][j-1];\n\t}\n}\n*/\n\nconst int nmax=2010;\nmint dp[2][nmax][nmax];\nint len[2][nmax];\nint cur,nx;\nvoid clear(){\n\tzero(dp[nx]);\n\tzero(len[nx]);\n}\nvoid add(int i,int j,mint v){\n\tdp[nx][i][j]+=v;\n\tchmax(len[nx][i],j+1);\n}\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tvc<pi> lr(n+1);\n\tlr[0]=pi(0,1);\n\trep(i,n){\n\t\tint b;cin>>b;\n\t\tlr[i+1]=pi(max(b-k,0),min(b+k,n)+1);\n\t}\n\trep(i,n)chmax(lr[i+1].a,lr[i].a);\n\tper(i,n)chmin(lr[i].b,lr[i+1].b);\n\trep(i,n+1)if(lr[i].a>=lr[i].b){\n\t\treturn print(0);\n\t}\n\tdmp(lr);\n\tnx=1;\n\trng(i,lr[n].a,lr[n].b)\n\t\tadd(i,1,1);\n\tswap(cur,nx);\n\tper(step,n){\n\t\tclear();\n\t\trng(i,max(lr[step+1].a,1),lr[step+1].b){\n\t\t\trep(j,len[cur][i]){\n\t\t\t\tadd(i-1,j+1,dp[cur][i][j]);\n\t\t\t}\n\t\t}\n\t\tgnr(i,lr[step].a+1,lr[step+1].b){\n\t\t\trep(j,len[nx][i]){\n\t\t\t\tadd(i-1,j,dp[nx][i][j]);\n\t\t\t\tadd(i-1,j+1,-dp[nx][i][j]);\n\t\t\t}\n\t\t}\n\t\trng(i,lr[step+1].a,lr[step+1].b){\n\t\t\trep(j,len[cur][i]){\n\t\t\t\tadd(i,j,dp[cur][i][j]*(n+1-j));\n\t\t\t}\n\t\t}\n\t\tswap(cur,nx);\n\t}\n\tmint ans=0;\n\trep(j,len[cur][0])\n\t\tans+=dp[cur][0][j];\n\tprint(ans);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 0, 1, 1, 0]",3200,Let s count the number of ways to assign first elements in a way that for each from to There are exactly distinct elements among which are bigger then Let s call them We don t care about the exact values of elements we care only about their positions and who of them is equal to who For example arrays would all be equivalent We care about the exact values of all other elements We only need to consider at most possible values of for each Now let s learn how to transition from to Let s say that now we are at state Where can we transition after assigning There are two cases doesn t change It happens when Then if is among those elements or is less than the number of elements won t change Otherwise the number of elements increases by but we don t care about its value other than it being bigger than So we need to add to and to becomes It happens only when and all numbers from to appear among those elements There are ways to choose their positions there and all of them will stop being so there will be only elements remaining So we have to add to for all valid This already gives solution as we have iterations and transitions on each of them However this TLEs So let s try to optimize our transitions We will process cases when doesn t change as before as it s only transitions So consider only transitions where changes Note that increases exactly by one in such transitions Also note that we have to multiply by when number of elements previously was and divide by when the number of elements now becomes Then let s only consider states with some fixed for now then we have transitions of sort with coefficients So to find what we have to add to we have to find sum of over all valid and to divide this sum by This is easy to do with prefix sums So the final complexity is 
Polycarp came up with a new programming language There are only two types of statements in it assign the variable named the value where is a string For example the statement assigns the variable named the value Note that is the value of a string not the name of a variable Between the variable name the operator and the string contains exactly one space each assign the variable named the concatenation of values of two variables and For example if the program consists of three statements then the variable will contain the string It is guaranteed that the program is correct and the variables and were previously defined There is exactly one space between the variable names and the and operators All variable names and strings only consist of lowercase letters of the English alphabet and do not exceed 5 characters The result of the program is the number of occurrences of string in the string that was written to the variable in the last statement Polycarp was very tired while inventing that language He asks you to implement it Your task is for given program statements calculate the number of occurrences of string in the last assigned variable ,"['#ifndef CPL_TEMPLATE\n#define CPL_TEMPLATE\n/*\n\tNormie\'s Template v2.4\n\tChanges:\n    Added include-guards to help with writing in multiple source files.\n*/\n// Standard library in one include.\n#include <bits/stdc++.h>\nusing namespace std;\n \n// ordered_set library.\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n#define ordered_set(el) tree<el,null_type,less<el>,rb_tree_tag,tree_order_statistics_node_update>\n \n// AtCoder library. (Comment out these two lines if you\'re not submitting in AtCoder.) (Or if you want to use it in other judges, run expander.py first.)\n//#include <atcoder/all>\n//using namespace atcoder;\n \n//Pragmas (Comment out these three lines if you\'re submitting in szkopul.)\n#pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""Ofast,unroll-loops,tree-vectorize"")\n#pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native"")\n \n//File I/O.\n#define FILE_IN ""cseq.inp""\n#define FILE_OUT ""cseq.out""\n#define ofile freopen(FILE_IN,""r"",stdin);freopen(FILE_OUT,""w"",stdout)\n \n//Fast I/O.\n#define fio ios::sync_with_stdio(0);cin.tie(0)\n#define nfio cin.tie(0)\n#define endl ""\\n""\n \n//Order checking.\n#define ord(a,b,c) ((a>=b)and(b>=c))\n \n//min/max redefines, so i dont have to resolve annoying compile errors.\n#define min(a,b) (((a)<(b))?(a):(b))\n#define max(a,b) (((a)>(b))?(a):(b))\n\n// Fast min/max assigns to use with AVX.\n// Requires g++ 9.2.0.\ntemplate<typename T>\n__attribute__((always_inline)) void chkmin(T& a, const T& b) {\n    a=(a<b)?a:b;\n}\n\ntemplate<typename T>\n__attribute__((always_inline)) void chkmax(T& a, const T& b) {\n    a=(a>b)?a:b;\n}\n \n//Constants.\n#define MOD (ll(998244353))\n#define MAX 300001\n#define mag 320\nconst long double PI=3.14159265358979;\n \n//Pairs and 3-pairs.\n#define p1 first\n#define p2 second.first\n#define p3 second.second\n#define fi first\n#define se second\n#define pii(element_type) pair<element_type,element_type>\n#define piii(element_type) pair<element_type,pii(element_type)>\n \n//Quick power of 2.\n#define pow2(x) (ll(1)<<x)\n \n//Short for-loops.\n#define ff(i,__,___) for(int i=__;i<=___;i++)\n#define rr(i,__,___) for(int i=__;i>=___;i--)\n \n//Typedefs.\n#define bi BigInt\ntypedef long long ll;\ntypedef long double ld;\ntypedef short sh;\n\n// Binpow and stuff\nll BOW(ll a, ll x, ll p)\n{\n\tif (!x) return 1;\n\tll res=BOW(a,x/2,p);\n\tres*=res;\n\tres%=p;\n\tif (x%2) res*=a;\n\treturn res%p;\n}\nll INV(ll a, ll p)\n{\n\treturn BOW(a,p-2,p);\n}\n//---------END-------//\n#endif\nstruct comp\n{\n    ll cnt=0,len=0;\n    string st="""",en="""";\n    comp(string s)\n    {\n        len=s.length();\n        cnt=0;\n        for (int i=0;i+4<=len;i++) if (s.substr(i,4)==""haha"") cnt++;\n        if (len<=3) st=en=s;\n        else \n        {\n            st=s.substr(0,3);\n            en=s.substr(len-3,3);\n        }\n    }\n    comp()\n    {}\n    comp operator+(comp oth)\n    {\n        if ((len<=3)and(oth.len<=3)) return comp(st+oth.st);\n        comp res;\n        res.cnt=cnt+oth.cnt;\n        res.len=len+oth.len;\n        string bruh=en+oth.st;\n        for (int i=0;i+4<=bruh.length();i++) if (bruh.substr(i,4)==""haha"") res.cnt++;\n        res.st=st;\n        int i=0;\n        while(res.st.size()<3)\n        {\n            res.st.push_back(oth.st[i]);\n            i++;\n        }\n        res.en=oth.en;\n        i=en.size()-1;\n        while(res.en.size()<3)\n        {\n            res.en.push_back(en[i]);\n            i--;\n        }\n        return res;\n    }\n};\nvector<int> vec;\nll n,m,i,j,k,t,t1,u,v,a,b;\nll res=0;\nmap<string,comp> var;\nstring sa,sb,sc,sd,se;\nint main()\n{\n\tfio;\n    cin>>t;\n    for (t1=0;t1<t;t1++)\n    {\n        cin>>n;\n        var.clear();\n        for (i=0;i<n;i++)\n        {\n            cin>>sa>>sb;\n            if (sb=="":="")\n            {\n                cin>>sc;\n                var[sa]=comp(sc);\n            }\n            else\n            {\n                cin>>sc>>sd>>se;\n                var[sa]=var[sc]+var[se];\n            }\n        }\n        cout<<var[sa].cnt<<endl;\n    }\n}\n']","[0, 0, 1, 0, 1]",2100,We can t model this process directly since the maximum string length reaches look at the second example from the statements To optimize this process you can store each row as a set of the following values Number of occurrences of in the string String length The first three characters of the string are The last three characters of the string are Then to process the second type of request and combine the two strings and into the string you need New occurrences may be added at the junction of two words However if the string length is less than then you need to handle this case carefully with your hands Similarly you need to process small strings separately 
Sofia had an array of n integers a 1 a 2 ldots a n One day she got bored with it so she decided to apply m modification operations to it Each modification operation is described by a pair of numbers langle c j d j rangle and means that the element of the array with index c j should be assigned the value d j i e perform the assignment a c j d j After applying modification operations Sofia discarded the resulting array Recently you found an array of n integers b 1 b 2 ldots b n You are interested in whether this array is Sofia s array You know the values of the original array as well as the values d 1 d 2 ldots d m The values c 1 c 2 ldots c m turned out to be lost Is there a sequence c 1 c 2 ldots c m such that the application of modification operations langle c 1 d 1 rangle langle c 2 d 2 rangle ldots langle c m d m rangle to the array a 1 a 2 ldots a n transforms it into the array b 1 b 2 ldots b n ,"['#include <bits/stdc++.h>using namespace std;\xa0int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    int t; cin >> t;    while (t--) {        int n; cin >> n;        vector<int> a(n), b(n);        set<int> bs;        for (int &x: a) cin >> x;        for (int &x: b) cin >> x, bs.insert(x);        int m; cin >> m;        map<int, int> d;        int ls = -1;        for (int i = 0; i < m; i++) {            int x; cin >> x;            ls = x;            d[x]++;        }        bool ans = bs.count(ls);        for (int i = 0; i < n; i++) {            if (b[i] != a[i]) {                if (!d[b[i]]) ans = false;                d[b[i]]--;            }        }        cout << (ans ? ""YES"" : ""NO"") << ""\\n"";    }}']","[1, 0, 0, 0, 0]",1300,First in the array the number must be present Second if we will not apply any operations to All extra operations can be applied to where they will be overwritten by the operation For all other we must apply the operation so it remains to check that the multiset of such is included in the multiset This solution can be implemented using sorting and two pointers or resulting in a time complexity of If you used or you were most likely hacked Check out this post 
Bob watches TV every day He always sets the volume of his TV to b However today he is angry to find out someone has changed the volume to a Of course Bob has a remote control that can change the volume There are six buttons 5 2 1 1 2 5 on the control which in one press can either increase or decrease the current volume by 1 2 or 5 The volume can be arbitrarily large but can never be negative In other words Bob cannot press the button if it causes the volume to be lower than 0 As Bob is so angry he wants to change the volume to b using as few button presses as possible However he forgets how to do such simple calculations so he asks you for help Write a program that given a and b finds the minimum number of presses to change the TV volume from a to b ,"['#include <bits/stdc++.h>\n\n#define ii pair<int, int>\n#define lli long long int\n#define ll pair<lli, lli>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\nint main() {\n\tint tc, a, b, c, ans;\n\tscanf(""%d"", &tc);\n\twhile (tc--) {\n\t\tscanf(""%d %d"", &a, &b);\n\t\tc = abs(a - b);\n\t\tans = c / 5;\n\t\tc %= 5;\n\t\tans += (c / 2);\n\t\tc %= 2;\n\t\tans += c;\n\t\tprintf(""%d\\n"", ans);\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",800,Notice that if at some moment we increase the volume and at some moment we decrease the volume we can remove those two actions and replace them with at most two new actions that are both increasing or decreasing for instance can be replaced with and can be replaced with nothing and and can be replaced with We can see that replacing like this will not make the volume goes below zero at any moment So we will increase the volume all the time or decrease all the time Assume that we only increase the volume It can be proved that for any set consists of only s and s and the sum of its elements is greater than or equal to it has a subset which its elements sums to This means that if we use and to increase the volume by at least we can replace some of those actions with a Hence it is optimal to increase the volume by until the gap between and is less than then the remaining job is trivial 
There is an apartment consisting of n rooms each with its light To control the lights in these rooms the owner of the apartment decided to install chips in the rooms so that each room has exactly one chip and the chips are installed at different times Specifically these times are represented by the array a 1 a 2 ldots a n where a i is the time in minutes at which a chip is installed in the i th room As soon as a chip is installed it changes the room s light status every k minutes it turns on the light for k minutes then turns it off for the next k minutes then turns it back on for the next k minutes and so on In other words the light status is changed by the chip at minute a i a i k a i 2k a i 3k ldots for the i th room What is the earliest moment when all rooms in the apartment have their lights turned on ,"['#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<""=""<<x<<""\\n"";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+"".in"").c_str(),""r"",stdin);\tfreopen((s+"".out"").c_str(),""w"",stdout);}void run(){\tint n,p;\tcin>>n>>p;\tvi v(n);\trep(i,n)cin>>v[i];\tsort(all(v));\tint mx=v.back();\tint cl=mx,cr=mx+p-1;\trep(i,n){\t\tint cx=(mx-v[i])/(p*2)*(p*2)+v[i];\t\tif(cx+p<=mx)Mx(cl,cx+p*2);\t\telse Mi(cr,cx+p-1);\t}\tif(cl<=cr)cout<<cl<<""\\n"";\telse cout<<""-1\\n"";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}']","[0, 1, 1, 0, 0]",1400,SolutionAs soon as a chip is installed it changes the light s status every minutes Let s first list the segments of the moments when a light is on if we install a chip at moment Have you seen the pattern yet Apparently each segment in the list except the first one is actually the segment before it shifted by minutes This also means that if we divide by and take the remainder at both ends of each segment all these segments become equal With that let s call the segment of the th chip Our problem is thus simplified to find the smallest integer such that appears in every segments of all chips In order to satisfy the first condition it seems if we figure out some that satisfy the second condition we may come up with Next in order for a segment to contain this inequality must be satisfied This is because a light is on only for at most minutes before it gets turned off so it must come not long before the moment Let s call the number of chips that has then in order for all lights to be on at moment the condition is This idea can be implemented using two pointer technique that traverse all from to As there can be many possible values of we only take one that produces with minimum value Be careful when handling signs in problems with modules to avoid unnecessary errors Time complexity 
You re given an array a of length 2n Is it possible to reorder it in such way so that the sum of the first n elements equal to the sum of the last n elements ,"[' #include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> mypair;\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = getchar();\n\twhile (!isdigit(c))\n\t{\n\t\tif (c == \'-\') f = -1;\n\t\tc = getchar();\n\t}\n\twhile (isdigit(c))\n\t{\n\t\tx = x * 10 + c - \'0\';\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\n\nint n, a[4000005];\n\nint main()\n{\n\tn = read(); n <<= 1;\n\tfor (int i = 1; i <= n; i ++) a[i] = read();\n\tsort(a + 1, a + 1 + n);\n\tll ans = 0, s = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tif (i <= n / 2) s += a[i];\n\t\tans += a[i];\n\t}\n\tif (s * 2ll == ans) puts(""-1"");\n\telse for (int i = 1; i <= n; i ++) printf(""%d%c"", a[i], i == n ? 10 : 32);\n\treturn 0;\n}']","[1, 0, 0, 0, 0]",1000,If all elements in the array are equal there s no solution Otherwise sort the array The sum of the second half will indeed be greater than that of the first half Another solution is to see if they already have different sums If they do print the array as it is Otherwise find any pair of different elements from different halves and swap them Code link https pastebin com FDXTuDdZ 
In Morse code an letter of English alphabet is represented as a string of some length from 1 to 4 Moreover each Morse code representation of an English letter contains only dots and dashes In this task we will represent a dot with a and a dash with a Because there are 2 1 2 2 2 3 2 4 30 strings with length 1 to 4 containing only and or not all of them correspond to one of the 26 English letters In particular each string of and or of length 4 translates into a distinct English letter except the following four strings that do not correspond to any English alphabet and You will work with a string S which is initially empty For m times either a dot or a dash will be appended to S one at a time Your task is to find and report after each of these modifications to string S the number of non empty sequences of English letters that are represented with some substring of S in Morse code Since the answers can be incredibly tremendous print them modulo 10 9 7 ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nstruct SA {\n  vector<map<char, int>> edges;\n  VI link, length;\n  int last;\n\n  SA(string s) : edges(1), link{-1}, length(1), last(0) {\n    REP (i, SZ(s)) {\n      edges.emplace_back();\n      length.PB(i + 1);\n      link.PB(0);\n      int r = SZ(edges) - 1, p = last;\n      while (p >= 0 && edges[p].find(s[i]) == edges[p].end()) {\n        edges[p][s[i]] = r;\n        p = link[p];\n      }\n      if (p != -1) {\n        int q = edges[p][s[i]];\n        if (length[p] + 1 == length[q]) {\n          link[r] = q;\n        } else {\n          edges.PB(edges[q]);\n          length.PB(length[p] + 1);\n          link.PB(link[q]);\n          int qq = SZ(edges) - 1;\n          link[q] = qq; link[r] = qq;\n          while (p >= 0 && edges[p][s[i]] == q) {\n            edges[p][s[i]] = qq;\n            p = link[p];\n          }\n        }\n      }\n      last = r;\n    }\n  }\n};\n\nconst int Mod = 1e9 + 7;\nconst int MaxN = 3005;\n\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  string s;\n  int N;\n  cin >> N;\n  for (int i = 0; i < N; ++i) { char ch; cin >> ch; s += ch; }\n  SA sa(s);\n\n  const int size = SZ(sa.edges);\n  vector<int> first_occur(size, 0);\n  vector<bool> visited(size);\n  function<void(int)> Dfs = [&](int v) {\n    visited[v] = true;\n    for (auto &edge : sa.edges[v]) {\n      if (!visited[edge.nd]) { Dfs(edge.nd); }\n      maxi(first_occur[v], first_occur[edge.nd] + 1);\n    }\n  };\n\n  Dfs(0);\n  for (int i = 0; i < size; ++i) {\n    first_occur[i] = N - first_occur[i];\n  }\n  debug(first_occur);\n\n  vector<LL> answers(N);\n\n  for (int L = 0; L < N; ++L) {\n    int pos = 0;\n    LL num_found[4] = {1, 0, 0, 0};\n\n    for (int R = L; R < N; ++R) {\n      pos = sa.edges[pos][s[R]];\n      LL n0 = 0;\n\n      if (R >= 3) {\n        const string my = s.substr(R - 3, 4);\n        if (my != ""0011"" && my != ""0101"" && my != ""1110"" && my != ""1111"") {\n          n0 += num_found[3];\n        }\n      }\n\n      n0 += num_found[0] + num_found[1] + num_found[2];\n      num_found[3] = num_found[2];\n      num_found[2] = num_found[1];\n      num_found[1] = num_found[0];\n      num_found[0] = n0 % Mod;\n\n      debug(L, R, pos, first_occur[pos], num_found[0], num_found[1], num_found[2], num_found[3]);\n      if (first_occur[pos] == R + 1) {\n        debug(L, R);\n        answers[R] = (answers[R] + num_found[0]) % Mod;\n      }\n    }\n  }\n\n  for (int i = 1; i < N; ++i) {\n    answers[i] = (answers[i - 1] + answers[i]) % Mod;\n  }\n\n  for (LL v : answers) { cout << v << ""\\n""; }\n}\n']","[0, 0, 0, 1, 1]",2400,We will be computing the answers offline instead of doing so immediately after each modification Let Now we need to find the number of English sequences that if considered backward would translate into some substring of each suffix of T Let be the number of English sequences that translate to exactly Let be sum of over all Note that can be calculated with dynamic programming for all in where denotes the longest length of an English alphabet in Morse code which is Following that we can calculate for all in The answer for the suffix is simply the sum of over all subtracted by the number of over counted English sequences The number of over counted sequences can be calculated by considering the suffix array of Namely for each two adjacent suffixes in the list we over counted them by with and denoting the corresponding indices of their longest common prefix LCP Therefore the answer for is subtracted by the sum of of the LCP between each pair of adjacent suffixes Transitioning to solve the problem for where can be done efficiently since the removal character of the string affects only one entry in the suffix list To sum up we find for all valid and in Then we sort the suffixes naively in before computing the answer in the final step in The time complexity is 
You are given two integers x and y You want to choose two greater than zero integers a and b and then apply the following operation to x a times replace x with b cdot x You want to find two positive integers a and b such that x becomes equal to y after this process If there are multiple possible pairs you can choose If there is no such pair report it For example if x 3 and y 75 you may choose a 2 and b 5 so that x becomes equal to 3 cdot 5 cdot 5 75 if x 100 and y 100 you may choose a 3 and b 1 so that x becomes equal to 100 cdot 1 cdot 1 cdot 1 100 if x 42 and y 13 there is no answer since you cannot decrease x with the given operations ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\nusing ll = long long;\nconst ll inf = 1e9;\nconst int md1 = 1e9+7;\n\n#define all(v)                      v.begin(), v.end()\n#define rall(v)                     v.rbegin(), v.rend()\n#define sz(v)                       ((int)v.size())\n\n#define forn(i,n)                   for(int i = 0; i < n; ++i)\n#define forbe(i,b,e)                for(int i = b; i < e; ++i)\n\n#define pb                          push_back\n\n#define pry                         puts(""YES"")\n#define prn                         puts(""NO"")\n#define endl                        \'\\n\'\n\n#define fst                         first\n#define scn                         second\n\nvoid solve(){\n    int x, y;\n    cin >> x >> y;\n\n    if (x > y)\n        cout << ""0 0\\n"";\n    else if (y % x)\n        cout << ""0 0\\n"";\n    else\n        cout << 1 << \' \' << y/x << endl;\n}\n\nint32_t main(){\n    #ifndef ONPC\n        ios_base::sync_with_stdio(0);cin.tie(0);\n    #else\n        freopen(""in"", ""r"", stdin);\n    #endif\n    int t = 1;\n    cin >> t;\n    while(t--)\n        solve();\n}\n']","[0, 1, 0, 0, 0]",800,The process in the statement can be rephrased as multiply by will be divisible by so if is not divisible by there is no answer Otherwise and can be used 
Sereja has two sequences and and number Sequence consists of integers Similarly sequence consists of integers As usual Sereja studies the sequences he has Today he wants to find the number of positions such that sequence can be obtained from sequence by rearranging elements Sereja needs to rush to the gym so he asked to find all the described positions of ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\nmap <int, int> mp;\n\nint bad;\nint a[200010],b[200010],c[200010];\nbool ans[200010];\n\nvoid add(int x){\n    mp[x]++;\n    int tmp = mp[x];\n    if(tmp == 1) bad++;\n    if(tmp == 0) bad--;\n}\n\nvoid erase(int x){\n    mp[x]--;\n    int tmp = mp[x];\n    if(tmp == -1) bad++;\n    if(tmp == 0) bad--;\n}\n\nvoid func(int n, int m, int offset, int step){ // b: m, c: n, find b from c\n    int i;\n    \n    if(n < m) return;\n    \n    REP(i,m) add(c[i]);\n    if(bad == 0) ans[offset] = true;\n    // cout << offset << \' \' << bad << endl;\n    \n    for(i=m;i<n;i++){\n        add(c[i]);\n        erase(c[i-m]);\n        if(bad == 0) ans[offset + step * (i-m+1)] = true;\n        // cout << offset + step * (i-m+1) << \' \' << bad << endl;\n    }\n    \n    for(i=n-m;i<n;i++) erase(c[i]);\n}\n\nint main(void){\n    int n,m,p,i,j;\n    \n    cin >> n >> m >> p;\n    REP(i,n) scanf(""%d"", &a[i]);\n    REP(i,m) scanf(""%d"", &b[i]);\n    \n    REP(i,m) erase(b[i]);\n    \n    REP(i,p){\n        int n2 = 0;\n        for(j=i;j<n;j+=p){\n            c[n2] = a[j];\n            n2++;\n        }\n        func(n2, m, i, p);\n    }\n    \n    int cnt = 0;\n    REP(i,n) if(ans[i]) cnt++;\n    cout << cnt << endl;\n    bool first = true;\n    REP(i,n) if(ans[i]){\n        if(!first) printf("" "");\n        first = false;\n        printf(""%d"", i+1);\n    }\n    \n    cout << endl;\n    \n    return 0;\n}\n']","[0, 0, 0, 0, 1]",1900,We will divide the sequence on sequences st th th element will go to the first sequence nd th th will go to the second sequence and so on Now you need to find an answer for each of them considering that This can be solved by a simple method You can go along the sequence from left to right and count the number of occurrences of each number If the number of occurrences of each number will match the number of occurrences of the same number in the second sequence then everything is OK 
You are the gym teacher in the school There are n students in the row And there are two rivalling students among them The first one is in position a the second in position b Positions are numbered from 1 to n from left to right Since they are rivals you want to maximize the distance between them If students are in positions p and s respectively then distance between them is p s You can do the following operation at most x times choose two students and swap them Calculate the maximum distance between two rivalling students after at most x swaps ,"[""#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n\n    while (T-- > 0) {\n        int N, X, A, B;\n        cin >> N >> X >> A >> B;\n        cout << min(abs(A - B) + X, N - 1) << '\\n';\n    }\n}\n""]","[1, 1, 0, 0, 0]",800,To solve the problem you need to understand two facts The answer can t be greater than If current distance between rivaling student if less then we always can increment this distance by one swap In means that answer is equal to 
You are given a tree with n vertices Your task is to find the maximum number x such that it is possible to remove exactly k edges from this tree in such a way that the size of each remaining connected component dagger is at least x dagger Two vertices v and u are in the same connected component if there exists a sequence of numbers t 1 t 2 ldots t k of arbitrary length k such that t 1 v t k u and for each i from 1 to k 1 vertices t i and t i 1 are connected by an edge ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define MP make_pair\nmt19937 rnd(time(0));\nconst int MAXN=1e5+5;\nint n,k;\nvector<int> edg[MAXN];\nint siz[MAXN],cnt=0;\nvoid dfs(int u,int fa,int x){\n\tsiz[u]=1;\n\tfor(int v:edg[u]) if(v!=fa){\n\t\tdfs(v,u,x);\n\t\tsiz[u]+=siz[v];\n\t}\n\tif(siz[u]>=x){\n\t\tcnt++;\n\t\tsiz[u]=0;\n\t}\n}\nint check(int x){\n\tcnt=0;\n\tdfs(1,0,x);\n\treturn cnt-1;\n}\nvoid solve(){\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) edg[i].clear();\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;cin>>u>>v;\n\t\tedg[u].push_back(v);\n\t\tedg[v].push_back(u);\n\t}\n\tint l=1,r=n,mid;\n\twhile(l<r){\n\t\tmid=l+r+1>>1;\n\t\tif(check(mid)>=k) l=mid;\n\t\telse r=mid-1;\n\t}\n\tcout<<l<<\'\\n\';\n}\nint main(){\n\tios::sync_with_stdio(false);\n\t// freopen(""Otomachi_Una.in"",""r"",stdin);\n\t// freopen(""Otomachi_Una.out"",""w"",stdout);\n\tint _;cin>>_;\n\twhile(_--) solve();\n\treturn 0;\n}']","[1, 0, 1, 1, 0]",1600,Let s hang the tree from an arbitrary vertex for definiteness let s hang the tree from vertex proof is given below First of all notice that if we can obtain some answer then we can also obtain the answer exactly the same way as for so we can do a binary search for To check the condition for a fixed we will use a greedy algorithm We will find the maximum number of connected components into which we can cut our tree so that each component has at least vertices We will start a dfs from vertex let s say we are currently at vertex and the number of vertices in its subtree is greater than or equal to then it is advantageous for us to remove the edge from vertex to its parent If after this process there are at least connected components then the condition is satisfied for this otherwise it is not Proof that it doesn t matter which vertex to hang the tree from We need to prove that the greedy algorithm will obtain the same number of cuts for all roots We will prove this in the order of depth first search It is also important to note that it doesn t matter in which order to run the greedy algorithm from the children Let the initial root be and we want to prove it for its child Then let s see how the greedy algorithm will act in the first case it will start from vertex and then from all its adjacent vertices except and remove some edges When we run the greedy algorithm in the second case we can reorder the vertices and first run it from all adjacent vertices except and there will be the same removals Then we will run the greedy algorithm from vertex it will perform the same removals as in the first case if we made vertex the last one So the only edge that may not coincide in these removals is If this edge did not participate in the removals the first time then the size of the remaining part of vertex so we cannot remove it now If the edge was removed in the first variant then the size of the component was and there were no vertices of subtree in it Then when running the greedy algorithm from the second vertex it will cut the edge because the size of this part became so the set of edges coincides 
You are given an undirected weighted graph with n vertices and m edges The i th edge is e i u i v i w i the distance between vertices u i and v i along the edge e i is w i 1 le w i The graph is i e for any pair of vertices there is at least one path between them consisting only of edges of the given graph A minimum spanning tree MST in case of weights is a subset of the edges of a connected weighted undirected graph that connects all the vertices together and has minimum total cost among all such subsets total cost is the sum of costs of chosen edges You can modify the given graph The only operation you can perform is the following increase the weight of some edge by 1 You increase the weight of each edge multiple possibly zero times Suppose that the initial MST cost is k Your problem is to increase weights of some edges in such a way that the cost of MST in the obtained graph remains k but MST is it means that there is only one way to choose MST in the obtained graph Your problem is to calculate the number of operations required to do it ,"['#include <bits/stdc++.h>\n\n#define fn ""test""\n#define fn1 """"\n\nusing namespace std;\n\nconst int mn = 2 * (int)(1e5) + 10;\nconst int mod = 1 * (int)(1e9) + 7;\nconst int mm = 1 * (int)(1e3) + 10;\nconst int base = 1 * (int)(1e9);\nconst bool aNs = 0;\n\nint tt, ntest = 1;\n\nvoid docfile()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    if (ifstream(fn"".inp""))\n    {\n        freopen(fn"".inp"", ""r"", stdin);\n        if (!aNs) freopen(fn"".out"", ""w"", stdout);\n\t\telse freopen (fn"".ans"", ""w"", stdout);\n    }else if (ifstream(fn1"".inp""))\n    {\n        freopen(fn1"".inp"", ""r"", stdin);\n        freopen(fn1"".out"", ""w"", stdout);\n    }\n}\n\ntemplate <typename T>\nvoid read(T& x)\n{\n    x = 0; T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) f = ch == \'-\' ? - f : f, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - \'0\', ch = getchar();\n    x *= f;\n}\n\ntemplate <typename T>\nvoid write (T a)\n{\n    if (a < 0)\n    {\n        putchar (\'-\');\n        write (-a);\n        return;\n    }\n    if (a < 10)\n    {\n        putchar (\'0\' + a);\n        return;\n    }\n    write (a / 10);\n    putchar ((char)(\'0\' + (a % 10)));\n}\n\nint h[mn];\nbool ok[mn];\nvector<pair<int, int> > e[mn];\npair<int, int> lca[mn][19];\nint n;\n\nvoid Dfs (int u, int w)\n{\n    for (auto v : e[u])\n    if (v.first != w)\n    {\n        lca[v.first][0] = {u, v.second};\n        h[v.first] = h[u] + 1;\n        Dfs (v.first, u);\n    }\n}\n\nvoid InitLca()\n{\n    for (int i = 1; i <= 17; ++ i)\n    for (int u = 1; u <= n; ++ u)\n    {\n        lca[u][i].first = lca[lca[u][i - 1].first][i - 1].first;\n        lca[u][i].second = max (lca[u][i - 1].second, lca[lca[u][i - 1].first][i - 1].second);\n    }\n}\n\nint Lca (int u, int v)\n{\n    if (h[u] < h[v]) swap (u, v);\n    int mi = INT_MIN;\n    for (int i = 17; i >= 0; -- i)\n    if (h[lca[u][i].first] >= h[v])\n    {\n        mi = max (mi, lca[u][i].second);\n        u = lca[u][i].first;\n    }\n    if (u == v) return mi;\n    for (int i = 17; i >= 0; -- i)\n    if (lca[u][i].first != lca[v][i].first)\n    {\n        mi = max (mi, lca[u][i].second);\n        mi = max (mi, lca[v][i].second);\n        u = lca[u][i].first;\n        v = lca[v][i].first;\n    }\n    mi = max (mi, lca[u][0].second);\n    mi = max (mi, lca[v][0].second);\n    return mi;\n}\n\nint u[mn], id[mn], w[mn], v[mn], fa[mn];\n\nint Fa (int n)\n{\n    return (fa[n] < 0 ? n : fa[n] = Fa (fa[n]));\n}\n\nbool Uni (int u, int v)\n{\n    u = Fa (u); v = Fa (v);\n    if (u == v) return 0;\n    if (fa[u] > fa[v]) swap (u, v);\n    fa[u] += fa[v];\n    fa[v] = u;\n    return 1;\n}\n\nvoid enter()\n{\n    int m;\n    cin >> n >> m;\n    for (int i = 1; i <= n; ++ i)\n    fa[i] = - 1;\n    for (int i = 0; i < m; ++ i)\n    {\n        cin >> u[i] >> v[i] >> w[i];\n        id[i] = i;\n    }\n    sort (id, id + m, [](int i, int j)\n         {\n              return w[i] < w[j];\n         });\n    for (int i = 0; i < m; ++ i)\n    {\n        int j = id[i];\n        if (Uni (u[j], v[j]))\n        {\n            ok[j] = 1;\n            e[u[j]].emplace_back(v[j], w[j]);\n            e[v[j]].emplace_back(u[j], w[j]);\n        }\n    }\n    h[1] = 1;\n    Dfs (1, 0);\n    InitLca();\n    int sol = 0;\n    for (int i = 0; i < m; ++ i)\n    if (!ok[i])\n    {\n        if (Lca (u[i], v[i]) == w[i]) ++ sol;\n    }\n    cout << sol;\n}\n\nvoid solve()\n{\n\n}\n\nvoid print_result()\n{\n\n}\n\nint main()\n{\n    docfile();\n    //cin>>ntest;\n    for (tt = 1; tt <= ntest; ++ tt)\n    {\n        enter();\n        solve();\n        print_result();\n    }\n}']","[1, 0, 0, 0, 0]",2100,The first and the most straight forward approach is to construct MST with any suitable algorithm build LCA with the maximum edge on a path with binary lifting technique and then we have to increase the answer for each edge such that equals to the maximum edge on a path between and in MST The second and the most pretty and easy to implement solution is the improved Kruskal algorithm Let s do Kruskal algorithm on the given edges Sort them and let s consider all edges of the same weight at once They can be divided into two classes The first class contains edges which connect nothing and the second class contains edges which can connect something Let the number of edges of current weight be edges of the current weight of the first class be and edges with of current weight of the second class be Okay we can just skip the first class because it will never increase the answer How to calculate useless edges of the second class Let s try to merge all components connected with edges of the second class Suppose we make merges Then we have to increase weights of all remaining edges by one So we add to the answer the value and go to the next weight Why is this right This is right because if the edge of the second class cannot connect anything because of the previously considered edges then the maximum on a path between endpoints of this edge equals to this edge weight So we have to increase the weight of this edge by one If we didn t do it we would be able to replace the edge connects these components with our edge And it is obvious that this edge is totally useless with the weight increased by one Time complexity is because of edges sorting 
You have long dreamed of working in a large IT company and finally got a job there You have studied all existing modern technologies for a long time and are ready to apply all your knowledge in practice But then you sit down at your desk and see a sheet of paper with the company s motto printed in large letters The company s motto contains four main principles Willi Nilli Crack Release Therefore you consider strings of length n consisting of these four Latin letters pairs of letters and in this motto are adjacent so we will call such pairs of symbols So if you are given a string s of length n and it is known that the unordered pair of symbols x y is good then you can perform one of the following operations on the string if s n x then you are allowed to replace this symbol with y if there exists 1 le i n such that s i x and s i 1 ldots s n y then you are allowed to replace the i th symbol of the string with y and all subsequent symbols with x For example the string can be replaced with one of the strings or and the string can be replaced with or A non empty sequence of operations for the string s will be called if the following two conditions are met after performing all operations the string becomes s again no string except for s will occur more than once during the operations At the same time the string s can occur exactly twice before the start of the operations and after performing all operations Now we are ready to move on to the problem statement You have a set of strings that is initially empty Then each of q queries adds another string t i to the set or removes the string t i from the set After each query you need to output the minimum and maximum size of a correct sequence of operations in which each word occurs at least once The choice of the initial string s is up to you ,"['#ifndef LOCAL\n#pragma GCC optimize (""Ofast"")\n#pragma GCC optimize (""unroll-loops"")\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> bool chmax(t&a,u b){if(a<b){a=b;return true;}else return false;}\ntemplate<class t,class u> bool chmin(t&a,u b){if(b<a){a=b;return true;}else return false;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class t>\nvoid print_single(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\ntemplate<class t,class u>\nvoid print_single(const pair<t,u>&p,int suc=1){\n\tprint_single(p.a,2);\n\tprint_single(p.b,suc);\n}\n\ntemplate<class T>\nvoid print_single(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i],i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T>\nvoid print_offset(const vector<T>&v,ll off,int suc=1){\n\trep(i,v.size())\n\t\tprint_single(v[i]+off,i==int(v.size())-1?suc:2);\n}\n\ntemplate<class T,size_t N>\nvoid print_single(const array<T,N>&v,int suc=1){\n\trep(i,N)\n\t\tprint_single(v[i],i==int(N)-1?suc:2);\n}\n\ntemplate<class T>\nvoid print(const T&t){\n\tprint_single(t);\n}\n\ntemplate<class T,class ...Args>\nvoid print(const T&t,const Args&...args){\n\tprint_single(t,2);\n\tprint(args...);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\nvoid YES(bool ex=true){\n\tcout<<""YES\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid NO(bool ex=true){\n\tcout<<""NO\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid Yes(bool ex=true){\n\tcout<<""Yes\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid No(bool ex=true){\n\tcout<<""No\\n"";\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n//#define CAPITAL\n/*\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}*/\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint topbit(ull t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint botbit(ull a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nint popcount(ull t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\null umask(int i){\n\treturn (ull(1)<<i)-1;\n}\nll minp2(ll n){\n\tif(n<=1)return 1;\n\telse return ll(1)<<(topbit(n-1)+1);\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t//#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t/*#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif*/\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\nll rand_int(ll k){ //[0,k)\n\treturn rand_int(0,k-1);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\ntemplate<class t>\nbool bis(const vc<t>&v,const t&a){\n\treturn binary_search(all(v),a);\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvc<ll> presum(const vi&a){\n\tvc<ll> s(si(a)+1);\n\trep(i,si(a))s[i+1]=s[i]+a[i];\n\treturn s;\n}\n//BIT  (CF850C)\ntemplate<class t>\nvc<t> predif(vc<t> a){\n\tgnr(i,1,si(a))a[i]-=a[i-1];\n\treturn a;\n}\ntemplate<class t>\nvvc<ll> imos(const vvc<t>&a){\n\tint n=si(a),m=si(a[0]);\n\tvvc<ll> b(n+1,vc<ll>(m+1));\n\trep(i,n)rep(j,m)\n\t\tb[i+1][j+1]=b[i+1][j]+b[i][j+1]-b[i][j]+a[i][j];\n\treturn b;\n}\n\n//verify \nvoid transvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid transvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\ttransvvc(n,m,args...);\n}\n//CF854E\nvoid rotvvc(int&n,int&m){\n\tswap(n,m);\n}\ntemplate<class t,class... Args>\nvoid rotvvc(int&n,int&m,vvc<t>&a,Args&...args){\n\tassert(si(a)==n);\n\tvvc<t> b(m,vi(n));\n\trep(i,n){\n\t\tassert(si(a[i])==m);\n\t\trep(j,m)b[m-1-j][i]=a[i][j];\n\t}\n\ta.swap(b);\n\trotvvc(n,m,args...);\n}\n\n// i  idx[i]\n//CF850C\ntemplate<class t>\nvi sortidx(const vc<t>&a){\n\tint n=si(a);\n\tvi idx(n);iota(all(idx),0);\n\tsort(all(idx),[&](int i,int j){return a[i]<a[j];});\n\treturn idx;\n}\n//vs[i]=a[idx[i]]\n// sortidx  idx \n//CF850C\ntemplate<class t>\nvc<t> a_idx(const vc<t>&a,const vi&idx){\n\tint n=si(a);\n\tassert(si(idx)==n);\n\tvc<t> vs(n);\n\trep(i,n)vs[i]=a[idx[i]];\n\treturn vs;\n}\n//CF850C\nvi invperm(const vi&p){\n\tint n=si(p);\n\tvi q(n);\n\trep(i,n)q[p[i]]=i;\n\treturn q;\n}\n\ntemplate<class t,class s=t>\ns SUM(const vc<t>&a){\n\treturn accumulate(all(a),s(0));\n}\n\ntemplate<class t>\nt MAX(const vc<t>&a){\n\treturn *max_element(all(a));\n}\n\ntemplate<class t>\nt MIN(const vc<t>&a){\n\treturn *min_element(all(a));\n}\n\ntemplate<class t,class u>\npair<t,u> operator+(const pair<t,u>&a,const pair<t,u>&b){\n\treturn mp(a.a+b.a,a.b+b.b);\n}\n\nvi vid(int n){\n\tvi res(n);iota(all(res),0);\n\treturn res;\n}\n\nstruct N{\n\tN*to[4];\n\tint cnt=0,mn[4][4],mx[4][4];\n\tN(){\n\t\trep(i,4)to[i]=0;\n\t\trep(i,4)rep(j,4)mn[i][j]=inf;\n\t\trep(i,4)rep(j,4)mx[i][j]=-inf;\n\t}\n\tint gmi(int x,int y){\n\t\treturn min(mn[x][y],mn[y][x]);\n\t}\n\tint gma(int x,int y){\n\t\treturn max(mx[x][y],mx[y][x]);\n\t}\n\tvoid upd(){\n\t\tcnt=0;\n\t\trep(i,4)cnt+=to[i]->cnt;\n\t\trep(i,4){\n\t\t\tint cs=0,mis=0,mas=0;\n\t\t\tint x=i,y=i;\n\t\t\trep(_,4){\n\t\t\t\tint z=(y+1);\n\t\t\t\tif(z==4)z=0;\n\t\t\t\t\n\t\t\t\tcs+=to[y]->cnt;\n\t\t\t\tif(cs==cnt){\n\t\t\t\t\tmn[i][y]=mis+to[y]->gmi(x,y);\n\t\t\t\t\tmx[i][y]=mas+to[y]->gma(x,y);\n\t\t\t\t}else{\n\t\t\t\t\tmn[i][y]=inf;\n\t\t\t\t\tmx[i][y]=-inf;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmis+=to[y]->gmi(x,z);\n\t\t\t\tmas+=to[y]->gma(x,z);\n\t\t\t\tchmin(mis,inf);\n\t\t\t\tchmax(mas,-inf);\n\t\t\t\tx=y;y=z;\n\t\t\t}\n\t\t}\n\t\trep(i,4)rep(j,4)chmin(mn[i][j],inf);\n\t\trep(i,4)rep(j,4)chmax(mx[i][j],-inf);\n\t}\n};\nconst int nmax=20;\nconst int qmax=100010;\nconst int smax=(nmax+1)*qmax;\nN buf[smax];\nint bufused=0;\nN* nn(){\n\treturn buf+bufused++;\n}\n\nvoid add(N*&cur,int i,const string&s){\n\t{\n\t\tN*tmp=nn();\n\t\t*tmp=*cur;\n\t\tcur=tmp;\n\t}\n\tif(i==si(s)){\n\t\tcur->cnt^=1;\n\t}else{\n\t\tint k=s[i]-\'a\';\n\t\tadd(cur->to[k],i+1,s);\n\t\tcur->upd();\n\t}\n}\n\nvoid slv(){\n\tint n,q;cin>>n>>q;\n\tN* root;\n\t{\n\t\tvc<N*> ls(n+1);\n\t\trep(i,n+1)ls[i]=nn();\n\t\trep(i,4)rep(j,4){\n\t\t\tls[n]->mn[i][j]=1;\n\t\t\tls[n]->mx[i][j]=1;\n\t\t}\n\t\tper(i,n){\n\t\t\trep(j,4)ls[i]->to[j]=ls[i+1];\n\t\t\tls[i]->upd();\n\t\t}\n\t\troot=ls[0];\n\t}\n\trep(_,q){\n\t\tadd(root,0,readString());\n\t\tint tot=root->cnt;\n\t\tint mn=inf,mx=-inf;\n\t\tN*cur=root;\n\t\trep(lv,n){\n\t\t\tassert(cur->cnt==tot);\n\t\t\t//0-1-2-3\n\t\t\t{\n\t\t\t\tint mis=0,mas=0;\n\t\t\t\trep(y,4){\n\t\t\t\t\tint x=(y+3)%4,z=(y+1)%4;\n\t\t\t\t\tmis+=cur->to[y]->gmi(x,z);\n\t\t\t\t\tmas+=cur->to[y]->gma(x,z);\n\t\t\t\t\tchmin(mis,inf);\n\t\t\t\t\tchmax(mas,-inf);\n\t\t\t\t}\n\t\t\t\tchmin(mn,mis);\n\t\t\t\tchmax(mx,mas);\n\t\t\t}\n\t\t\trep(y,4){\n\t\t\t\tint z=(y+1)%4;\n\t\t\t\tif(cur->to[y]->cnt+cur->to[z]->cnt==cur->cnt){\n\t\t\t\t\tchmin(mn,cur->to[y]->gmi(z,z)+cur->to[z]->gmi(y,y));\n\t\t\t\t\tchmax(mx,cur->to[y]->gma(z,z)+cur->to[z]->gma(y,y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool upd=false;\n\t\t\trep(y,4){\n\t\t\t\tif(cur->to[y]->cnt==cur->cnt){\n\t\t\t\t\tcur=cur->to[y];\n\t\t\t\t\tupd=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!upd)break;\n\t\t}\n\t\tif(mn<=mx)print(mn,mx);\n\t\telse print(-1);\n\t}\n\t/*{\n\t\tN* cur=root;\n\t\tcur=cur->to[0];\n\t\tdmp(cur->mx[3][1]);\n\t\tdmp(cur->mx[1][3]);\n\t\tdmp(cur->mn[3][1]);\n\t\tdmp(cur->mn[1][3]);\n\t\tdmp(cur->to[1]->mn[1][2]);\n\t\tdmp(cur->to[2]->mn[1][3]);\n\t\tdmp(cur->to[3]->mn[2][3]);\n\t}*/\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\t//int t;cin>>t;rep(_,t)\n\tslv();\n}\n']","[0, 0, 0, 1, 1]",3500,There are two ways to approach this problem Let s start with a solution that does not involve associations with known images Consider a cyclic sequence of strings that satisfies the condition of the problem Consider the longest common prefix of all the strings in this sequence It is not very interesting to us since by definition it does not change with the operations There are two cases Either the sequence of operations has a length of when we perform some action and then immediately cancel it with a second action This case is only possible if there are no more than two important strings in the set In this case the required condition can be easily checked in time Otherwise our sequence consists of more than two operations and this is much more like a cycle Let s say for example that the first non constant character in the sequence of strings initially equals Then after the first change it will be equal to either or Note that after this the first character will no longer be able to immediately turn into since the only way to do this is to cancel the operation but this is only possible in the first case Thus the first character will be required to go around the cycle This cycle can be divided into four segments based on the value of the first character of the string In each of these segments we are interested in the sequence of operations that transforms the string with the suffix into a string that matches the original in the prefix but its suffix is where and the pair of characters is good With the help of a not very complicated analysis of cases we can see that for each prefix we are interested in groups of paths that connect strings whose characters except for the suffix being considered match and these paths visit all important strings with the prefix being considered Within each group of paths we are interested in the minimum and maximum path respectively Note that these values can be easily calculated using dynamic programming We can calculate all these states in time Then we need to iterate over the length of the common prefix of all the strings and answer the query in time So far we can only calculate the states of interest to us in some galactic time But this is not entirely scary Let s say for example that when we add or remove one string from the set of important strings only states change since only the states responsible for the prefixes of the added deleted string will change To some extent this is reminiscent of a segment tree or rather a quadtree We just need to figure out how to get rid of the term in the asymptotic complexity But this is also simple Let s notice that if there are no strings with the given prefix in the set of important strings then the states responsible for this prefix will depend only on the length of the remaining suffix and all these values can be precomputed in time Thus we store a trie with strings from the queries in each node of which we store the state of the dynamic programming and in case we need the values of the dynamic programming from non existent trie nodes during recalculation we can replace them with precomputed values Time complexity The author s code is not very complicated but if you suddenly want to understand it I warn you that it uses several hacks of questionable justification For example instead of dynamic programming states only really useful ones are stored there The combinatorial structure is used to simplify the support of simultaneous maximum and minimum values and much more I think that it will be especially useful for beginners to familiarize themselves with how to simplify their lives in implementing combinatorial problems Now let s turn to the geometric interpretation of the problem Imagine a square with a size of In its corners we can draw squares with sizes of each Let s say that strings starting with the character go to the upper left square strings starting with the character go to the upper right the character corresponds to the lower right corner and the character corresponds to the lower left Then we can divide the four resulting squares into four parts each in the same way and divide the strings by corners already by the second character and so on In the end each string is associated with an integer point with coordinates from the interval We also have lines from the drawn squares which are naturally divided into vertical and horizontal segments of length each This picture is useful because it depicts a graph whose vertices correspond to the strings being considered and its edges connect pairs of strings that are obtained from each other by means of one move Thus looking at the picture much of the structure of simple cycles in the problem being considered becomes clear and obvious and with the help of such a picture it is much easier to describe the transitions in the dynamic programming and not get confused 
Ksenia has her winter exams Today she is learning combinatorics Here s one of the problems she needs to learn to solve How many distinct trees are there consisting of vertices each with the following properties the tree is marked that is the vertices of the tree are numbered from 1 to each vertex of the tree is connected with at most three other vertices and at the same moment the vertex with number 1 is connected with at most two other vertices the size of the tree s maximum matching equals Two trees are considered distinct if there are such two vertices and that in one tree they are connected by an edge and in the other tree they are not Help Ksenia solve the problem for the given and As the answer to the problem can be very huge you should output it modulo ,"['#include<stdio.h>\ntypedef long long LL;\nconst LL mod=1000000007;\nconst LL inv2=(mod+1)/2;\nLL inv[52];\nLL C[52][52];\nLL dp[52][52][2];// i nodes j matches k 0/1 root matched?\ninline void Add(LL &x,LL y){\n\tif(y>=mod) y%=mod;\n\ty*=inv2;\n\tif(y>=mod) y%=mod;\n\tx+=y;\n\tif(x>=mod) x-=mod;\n}\nint N,M;\nint main(){\n\tinv[1]=1;\n\tfor(int i=2;i<=50;++i) inv[i]=mod-mod/i*inv[mod%i]%mod;\n\tfor(int i=0;i<=50;++i){\n\t\tC[i][0]=1;\n\t\tfor(int j=1;j<=i;++j){\n\t\t\tC[i][j]=C[i-1][j]+C[i-1][j-1];\n\t\t\tif(C[i][j]>=mod) C[i][j]-=mod;\n\t\t}\n\t}\n\tdp[0][0][1]=1;\n\tdp[1][0][0]=1;\n\tfor(int i=2;i<=50;++i){\n\t\tfor(int j=0;j<i;++j){\n\t\t\tint k=i-1-j;\n\t\t\tfor(int l=0;l<=j/2;++l){\n\t\t\t\tfor(int m=0;m<=k/2;++m){\n\t\t\t\t\tfor(int ii=0;ii<2;++ii) for(int jj=0;jj<2;++jj){\n\t\t\t\t\t\tint cnt=!ii||!jj;\n\t\t\t\t\t\tAdd(dp[i][l+m+cnt][cnt],dp[j][l][ii]*dp[k][m][jj]%mod*i%mod*C[i-1][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscanf(""%d%d"",&N,&M);\n\tprintf(""%d\\n"",int((dp[N][M][0]+dp[N][M][1])*inv[N]%mod));\n\tscanf(""%d"",&N);\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0]",2600,In this problem you should count trees with some properties It can be done using dynamic programming The main idea is that the maximum mathing in tree can be found using simple dynamic vertex was this vertex used in matching So you should to count the trees tou should include in state of the dynamic values dp v 0 and In other words you should use dynamic programming number of rooted trees with vertices and values of dynamic in root and But in simple implementation this solution will get TL There are two ways to get AC The first is to opltimize code and make precalc The second is to optimize asymptotics The author s solution uses the second way To optimize solution you should mark that values and differs at most by one That is or So the first dynamic becomes Another optimization is there are not so many triples with non negative values about 250 so you can you use lazy programming to calculate this dynamic Comments that describe other solutions http codeforces com blog entry 10423comment 158177http codeforces com blog entry 10423comment 158182
Ilya is sitting in a waiting area of Metropolis airport and is bored of looking at time table that shows again and again that his plane is delayed So he took out a sheet of paper and decided to solve some problems First Ilya has drawn a grid of size and marked squares on it such that no two marked squares share the same row or the same column He calls a rectangle on a grid with sides parallel to grid sides if exactly two of its corner squares are marked There are exactly beautiful rectangles Ilya has chosen query rectangles on a grid with sides parallel to grid sides not necessarily beautiful ones and for each of those rectangles he wants to find its Beauty degree of a rectangle is the number of beautiful rectangles that share at least one square with the given one Now Ilya thinks that he might not have enough time to solve the problem till the departure of his flight You are given the description of marked cells and the query rectangles help Ilya find the beauty degree of each of the query rectangles ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int N = 200200;\nstruct Node {\n\tint L, R;\n\tint l, r;\n\tint val;\n\n\tNode() : L(-1), R(-1), l(-1), r(-1), val(0) {}\n\tNode(int _l, int _r) : L(-1), R(-1), l(_l), r(_r), val(0) {}\n};\nconst int S = (int)7e6;\nNode tree[S];\nint treeSz;\n\nint build(int l, int r) {\n\tint v = treeSz++;\n\ttree[v] = Node(l, r);\n\tif (l + 1 == r) return v;\n\tint mid = (l + r) / 2;\n\ttree[v].L = build(l, mid);\n\ttree[v].R = build(mid, r);\n\treturn v;\n}\n\nint setVal(int v, int p, int x) {\n\tif (p < tree[v].l || tree[v].r <= p) return v;\n\tint u = treeSz++;\n\ttree[u] = tree[v];\n\tif (tree[v].L == -1) {\n\t\ttree[u].val = x;\n\t\treturn u;\n\t}\n\ttree[u].L = setVal(tree[v].L, p, x);\n\ttree[u].R = setVal(tree[v].R, p, x);\n\ttree[u].val = tree[tree[u].L].val + tree[tree[u].R].val;\n\treturn u;\n}\n\nint getSum(int v, int l, int r) {\n\tif (l <= tree[v].l && tree[v].r <= r)\n\t\treturn tree[v].val;\n\tif (l >= tree[v].r || tree[v].l >= r)\n\t\treturn 0;\n\treturn getSum(tree[v].L, l, r) + getSum(tree[v].R, l, r);\n}\n\nint roots[N];\nint n, q;\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &q);\n\troots[0] = build(0, n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint p;\n\t\tscanf(""%d"", &p);\n\t\tp--;\n\t\troots[i + 1] = setVal(roots[i], p, 1);\n\t}\n\twhile(q--) {\n\t\tint x1, x2, y1, y2;\n\t\tscanf(""%d%d%d%d"", &x1, &y1, &x2, &y2);\n\t\tx1--;\n\t\ty1--;\n\t\tll ans = (ll)n * (n - 1);\n\t\tans -= (ll)x1 * (x1 - 1);\n\t\tans -= (ll)(n - x2) * (n - x2 - 1);\n\t\tans -= (ll)y1 * (y1 - 1);\n\t\tans -= (ll)(n - y2) * (n - y2 - 1);\n\t\tll cnt = getSum(roots[x1], 0, y1);\n\t\tans += cnt * (cnt - 1);\n\t\tcnt = getSum(roots[x1], y2, n);\n\t\tans += cnt * (cnt - 1);\n\t\tcnt = y1 - getSum(roots[x2], 0, y1);\n\t\tans += cnt * (cnt - 1);\n\t\tcnt = n - y2 - getSum(roots[x2], y2, n);\n\t\tans += cnt * (cnt - 1);\n\t\tprintf(""%lld\\n"", ans / 2);\n\t}\n\n\treturn 0;\n}\n']","[0, 0, 0, 0, 1]",2100,We can t iterate over all interesting rectangles Let s count number of rectangles that are not intersecting our rectangle To do it let s calculate number of rectangles to the left right up and down of rectangle in query It can be easily done in time suppose we have rectangle with corners and We have points to the left of rectangle to the right to the down etc If we have points in some area there are rectangles in that area But now we calculated twice rectangles that are simultaneously to the left and up of our rectangle left and down etc To find number of such rectangles we can iterate over all points and find points which are in these areas and find number of rectangles in area using formula The complexity is To solve the problem we need to find number of points in some areas faster It s quite easy to notice that we just have many queries of finding number of points in some subrectangle It s classical problem that can be solved with some 2d tree in solution But it can be too slow and can not fit into time limit in case of inaccurate implementation However you can notice that all queries are offline and find number of points in subrectangle in time It s fast enough to pass all tests 
Cat Noku has obtained a map of the night sky On this map he found a constellation with stars numbered from to For each the th star is located at coordinates No two stars are located at the same position In the evening Noku is going to take a look at the night sky He would like to find three distinct stars and form a triangle The triangle must have positive area In addition all other stars must lie strictly outside of this triangle He is having trouble finding the answer and would like your help Your job is to find the indices of three stars that would form a triangle that satisfies all the conditions It is guaranteed that there is no line such that all stars lie on that line It can be proven that if the previous condition is satisfied there exists a solution to this problem ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point\n{\n\tll x, y;\n\n\tPoint() : x(), y() {}\n\tPoint (ll _x, ll _y) : x(_x), y(_y) {}\n\n\tPoint operator + (const Point &a) const\n\t{\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\tPoint operator - (const Point &a) const\n\t{\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n\tll operator % (const Point &a) const\n\t{\n\t\treturn x * a.x + y * a.y;\n\t}\n\tll operator * (const Point &a) const\n\t{\n\t\treturn x * a.y - y * a.x;\n\t}\n\tll sqrLen() const\n\t{\n\t\treturn *this % *this;\n\t}\n\n\tvoid scan()\n\t{\n\t\tscanf(""%lld%lld"", &x, &y);\n\t}\n};\n\nconst int N = 100100;\nPoint a[N];\nint n;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i].scan();\n\tll L = (a[1] - a[0]).sqrLen();\n\tint v = 1;\n\tfor (int i = 2; i < n; i++)\n\t{\n\t\tll d = (a[i] - a[0]).sqrLen();\n\t\tif (d < L)\n\t\t{\n\t\t\tL = d;\n\t\t\tv = i;\n\t\t}\n\t}\n\tll S = -1;\n\tint u = -1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tll s = (a[i] - a[0]) * (a[i] - a[v]);\n\t\ts = abs(s);\n\t\tif (s == 0) continue;\n\t\tif (S == -1 || s < S)\n\t\t{\n\t\t\tS = s;\n\t\t\tu = i;\n\t\t}\n\t}\n\tprintf(""%d %d %d\\n"", 1, min(v, u) + 1, max(v, u) + 1);\n\t\n\treturn 0;\n}']","[0, 0, 1, 0, 0]",1600,There are many possible solutions to this problem The first solution is to choose any nondegenerate triangle Then for each other point if it is inside the triangle we can replace one of our three triangle points and continue We only need to make a single pass through the points We need to be a bit careful about collinear points in this case Another solution is as follows Let s choose an arbitrary point Then sort all other points by angle about this point Then we can just choose any two other points that have different angles breaking ties by distance to the chosen point or breaking ties by two adjacent angles Example code by breaking up triangles http codeforces com contest 618 submission 15669502 Example code by angles http codeforces com contest 618 submission 15669511 Comment Except for the second sample all pretests didn t have collinear points So many hacking cases are cases with collinear points 
The problem is You are given a are the positive integers whose decimal representations contain only the lucky digits 4 and 7 For example numbers are lucky and are not If we sort all lucky numbers in increasing order what s the 1 based index of Tavas is not as smart as SaDDas so he asked you to do him a favor and solve this problem so he can have his headphones back ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory.h>\nusing namespace std;\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  int k = 0;\n  int l = 0;\n  while (n) {\n    const int t = n % 10;\n    if (t == 7) {\n      k |= (1 << l);\n    }\n    n /= 10;\n    l++;\n  }\n\n  k += (1 << l) - 1;\n\n  printf(""%d\\n"", k);\n\n  return 0;\n}']","[0, 0, 1, 0, 0]",1100,Sol1 Consider has digits decimal representation of binary string is a binary string of size and its digit is 0 if and only if the digit of is Finally answer equals to Time complexity Sol2 Count the number of lucky numbers less than or equal to using bitmask assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1 Time complexity Code by PrinceOfPersia Another Code by SoroushE Another Code by Haghani Python Code by Zlobober 
You are given string s of length n consisting of s and s You build an infinite string t as a concatenation of an infinite number of strings s or t ssss dots For example if s then t Calculate the number of prefixes of t with equal to x The balance of some string q is equal to cnt 0 q cnt 1 q where cnt 0 q is the number of occurrences of in q and cnt 1 q is the number of occurrences of in q The number of such prefixes can be infinite if it is so you must say that A prefix is a string consisting of several first letters of a given string without any reorders An empty prefix is also a valid prefix For example the string abcd has 5 prefixes empty string a ab abc and abcd ,"['// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < \'0\' || c > \'9\') && c != \'-\'; c = getc()) {\n        assert(~c);\n    }\n    if (c == \'-\') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= \'0\' && c <= \'9\'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 1e5 + 5;\n\nchar s[N];\n\nvoid solve() {\n    int n, x;\n    scanf(""%d%d%s"", &n, &x, s);\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == \'0\') {\n            ++sum;\n        } else {\n            --sum;\n        }\n    }\n    int ans = 0, cur = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!sum) {\n            if (x == cur) {\n                puts(""-1"");\n                return;\n            }\n        } else if ((x - cur) % sum == 0) {\n            int l = (x - cur) / sum;\n            if (l >= 0) {\n                ++ans;\n            }\n        }\n        if (s[i] == \'0\') {\n            ++cur;\n        } else {\n            --cur;\n        }\n    }\n    printf(""%d\\n"", ans);\n}\n\nint main() {\n    int t;\n    scanf(""%d"", &t);\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n']","[0, 1, 0, 0, 0]",1700,Let s denote a prefix of length as We can note that each where and is a concatenation Then balance of prefix of length is equal to Now there two cases is equal to or not If then if exist such that then for each and answer is Otherwise for each such there will no more than one possible since there are zero or one solution to the equation The solution exists if and only if and So just precalc and for each check the equation 
Oleg came to see the maze of mirrors The maze is a n by n room in which each cell is either empty or contains a mirror connecting opposite corners of this cell Mirrors in this maze reflect light in a perfect way which causes the interesting visual effects and contributes to the loss of orientation in the maze Oleg is a person of curious nature so he decided to install n lasers facing internal of the maze on the south wall of the maze On the north wall of the maze Oleg installed n receivers also facing internal of the maze Let s number lasers and receivers from west to east with distinct integers from 1 to n Each laser sends a beam of some specific kind and receiver with number a i should receive the beam sent from laser number i Since two lasers beams can t come to the same receiver these numbers form a each of the receiver numbers occurs exactly once You came to the maze together with Oleg Help him to place the mirrors in the initially empty maze so that the maximum number of lasers beams will come to the receivers they should There are no mirrors outside the maze so if the laser beam leaves the maze it will not be able to go back ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<\'=\'<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=\',\')cerr<<*sdbg++;\n  cerr<<\'=\'<<h<<\',\'; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << ""[""; for (auto vv : V) os << vv << "",""; return os << ""]"";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << ""("" << P.st << "","" << P.nd << "")"";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nconst int MaxN = 1024;\n\nint N;\nint order[MaxN];\nint prev_order[MaxN];\nbool visited[MaxN];\n\nVI GetCycle(int x) {\n  assert(!visited[x]);\n  VI answer;\n  do {\n    visited[x] = true;\n    answer.push_back(x);\n    x = prev_order[x];\n  } while (x != answer[0]);\n  return answer;\n}\n\nvector<string> last_answer;\nvector<string> answer;\n\nvoid MoveRibbon(string &s, int from, int to) {\n  assert(from != to);\n  if (from < to) {\n    s[from] = s[to] = \'\\\\\';\n  } else {\n    s[from] = s[to] = \'/\';\n  }\n}\n\nvoid SolveFirst() {\n  auto cyc0 = GetCycle(0);\n  const int S = SZ(cyc0);\n\n  for (int i = S - 1; i > 0; --i) {\n    const int cur = cyc0[i];\n    const int nxt = cyc0[(i + 1) % S];\n    string line(N, \'.\');\n    MoveRibbon(line, cur, nxt);\n    last_answer.push_back(line);\n  }\n}\n\nvoid SolveOther(int base) {\n  if (visited[base]) { return; }\n  auto cycle = GetCycle(base);\n  const int S = SZ(cycle);\n  if (S == 1) { return; }\n\n  string first_line(N, \'.\');\n  MoveRibbon(first_line, base, 0);\n  MoveRibbon(first_line, cycle.back(), base);\n  answer.push_back(first_line);\n\n  cycle[0] = 0;\n\n  for (int d = S - 1; d > 0; --d) {\n    const int src = cycle[d - 1];\n    const int dest = cycle[d];\n    string line(N, \'.\');\n    MoveRibbon(line, src, dest);\n    answer.push_back(line);\n  }\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  int num_matching = 0;\n  for (int i = 0; i < N; ++i) {\n    cin >> order[i];\n    --order[i];\n    prev_order[order[i]] = i;\n    num_matching += order[i] == i;\n  }\n\n  if (num_matching == N) {\n    cout << N << ""\\n"";\n    for (int i = 0; i < N; ++i)\n      cout << string(N, \'.\') << ""\\n"";\n    return 0;\n  }\n\n  SolveFirst();\n  for (int fst = 1; fst < N; ++fst)\n    SolveOther(fst);\n\n  for (string s : last_answer)\n    answer.PB(s);\n\n  while ((int)answer.size() != N)\n    answer.push_back(string(N, \'.\'));\n\n  cout << N - 1 << ""\\n"";\n  for (auto &s : answer)\n    cout << s << ""\\n"";\n\n}\n\n']","[0, 1, 0, 0, 0]",3000,The answer is always if the permutation is identity lasers or otherwise Clearly we can t have more than matching lasers if the permutation is not identity Consider just the very first line with mirrors If the first mirror in this line is then we miss the laser below this mirror if the very last mirror is we miss the laser below it Otherwise there are neighbouring and and we lost two lasers now The proof of is constructive one Ignore all fixed points in permutation all that Select arbitrary cycle and select one point in it as dead We can spend operations to fix all points in this cycle But we also need to fix all other cycles We can do it in operations move arbitrary beam to the wasted laser fix all other points and move that point back But this is a bit too much lines The trick is that we can perform movement of arbitrary beam to the wasted point and the first operation of fixing in just one line if we select as the trash beam the rightmost point See the following picture for an example trash beam is the rightmost column 
You have got a shelf and want to put some books on it You are given q queries of three types id put a book having index id on the shelf to the left from the leftmost existing book id put a book having index id on the shelf to the right from the rightmost existing book id calculate the minimum number of books you need to pop from the left or from the right in such a way that the book with index id will be leftmost or rightmost You can assume that the first book you will put can have any position it does not matter and queries of type 3 are always valid it is guaranteed that the book in each such query is already placed You can also assume that you don t put the same book on the shelf twice so ids don t repeat in queries of first two types Your problem is to answer all the queries of type 3 in order they appear in the input Note that after answering the query of type 3 all the books remain on the shelf and the relative order of books does not change ,"['#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define FORD(i, a, b) for (int i = (a); i >= (b); --i)\n#define REP(i, a) for (int i = 0; i < (a); ++i)\n#define DEBUG(x) { cerr << #x << \'=\' << x << endl; }\n#define Arr(a, l, r) { cerr << #a << "" = {""; FOR(_, l, r) cerr << \' \' << a[_]; cerr << ""}\\n""; }\n#define N 1010100\n#define pp pair<int, int>\n#define endl \'\\n\'\n#define IO ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)\n#define taskname """"\n#define bit(S, i) (((S) >> (i)) & 1)\n#define all(s) s.begin(), s.end()\nusing namespace std;\n\nint a[N];\nint main() {\n    #ifdef NERO\n    freopen(""test.inp"",""r"",stdin);\n    freopen(""test.out"",""w"",stdout);\n    double stime = clock();\n    #else \n        //freopen(taskname"".inp"",""r"",stdin);\n        //freopen(taskname"".out"",""w"",stdout);\n    #endif //NERO\n    IO;\n    int q;\n    cin >> q;\n    int l = 1, r = 0;\n    REP(i, q) {\n        char type;\n        int id;\n        cin >> type >> id;\n        if (type == \'L\') {\n            l--;\n            a[id] = l;\n        }\n        if (type == \'R\') {\n            r++;\n            a[id] = r;\n        }\n        if (type == \'?\') {\n            cout << min(a[id] - l, r - a[id]) << endl;\n        }\n    }\n    #ifdef NERO\n    double etime = clock();\n    cerr << ""Execution time: "" << (etime - stime) / CLOCKS_PER_SEC * 1000 << "" ms.\\n"";\n    #endif // NERO\n}\n']","[0, 0, 1, 0, 0]",1400,Let imagine our shelf as an infinite array Let s carry the rightmost free position from the left of our shelf let it be and initially it equals to and the leftmost free position from the right of our shelf let it be and initially it equals to Also let s carry the array of length where will be equal to the position in our imaginary array of the book with a number Let s put the first book to the position Also let s save that where is the number of the first book equals to How will change and will become and will become Now let s process queries one by one If now we have the query of type with a book with a number then let s set and set The query of type can be processed similarly Now what about queries of type The answer to this query equals to where is the absolute value of 
Polycarp plays a computer game In this game the players summon armies of magical minions which then fight each other Polycarp can summon n different minions The initial power level of the i th minion is a i and when it is summoned all previously summoned minions power levels are increased by b i The minions can be summoned in any order Unfortunately Polycarp cannot have more than k minions under his control To get rid of unwanted minions after summoning them he may destroy them Each minion can be summoned and destroyed only once Polycarp s goal is to summon the strongest possible army Formally he wants to maximize the sum of power levels of all minions under his control those which are summoned and not destroyed Help Polycarp to make up a plan of actions to summon the strongest possible army ,"[""#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1012345678;\nvector<int> transform(int n, vector<int> arr, vector<int> perm) {\n\tvector<int> res(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tres[i] = arr[perm[i]];\n\t}\n\treturn res;\n}\nint main() {\n\tint Q;\n\tcin >> Q;\n\twhile (Q--) {\n\t\tint N, K;\n\t\tcin >> N >> K;\n\t\tvector<int> A(N), B(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> A[i] >> B[i];\n\t\t}\n\t\tvector<int> perm(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tperm[i] = i;\n\t\t}\n\t\tsort(perm.begin(), perm.end(), [&](int i, int j) { return B[i] < B[j]; });\n\t\tA = transform(N, A, perm);\n\t\tB = transform(N, B, perm);\n\t\tint bsum = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tbsum += B[i] * (K - 1);\n\t\t}\n\t\tvector<vector<int> > dp(N + 1, vector<int>(K, -inf));\n\t\tdp[0][0] = bsum;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\t\tif (j >= 1) {\n\t\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j - 1] + A[i] - B[i] * (K - j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint opt = -1, optval = -inf;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (dp[i][K - 1] == -inf) continue;\n\t\t\tint val = dp[i][K - 1];\n\t\t\tint mx = *max_element(A.begin() + i, A.end());\n\t\t\tval += mx;\n\t\t\tif (optval < val) {\n\t\t\t\toptval = val;\n\t\t\t\topt = i;\n\t\t\t}\n\t\t}\n\t\tvector<int> seq;\n\t\tint ptr = K - 1;\n\t\tfor (int i = opt - 1; i >= 0; --i) {\n\t\t\tif (dp[i][ptr] != dp[i + 1][ptr]) {\n\t\t\t\tseq.push_back(i);\n\t\t\t\t--ptr;\n\t\t\t}\n\t\t}\n\t\treverse(seq.begin(), seq.end());\n\t\tint last = max_element(A.begin() + opt, A.end()) - A.begin();\n\t\tvector<int> ans;\n\t\tfor (int i : seq) {\n\t\t\tans.push_back(perm[i] + 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!binary_search(seq.begin(), seq.end(), i) && i != last) {\n\t\t\t\tans.push_back(perm[i] + 1);\n\t\t\t\tans.push_back(-(perm[i] + 1));\n\t\t\t}\n\t\t}\n\t\tans.push_back(perm[last] + 1);\n\t\tcout << ans.size() << endl;\n\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\tif (i) cout << ' ';\n\t\t\tcout << ans[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}""]","[1, 0, 0, 1, 0]",2500,First of all let s try to find the best strategy to play minions All minions should be summoned if someone is not summoned summoning and deleting it won t make the answer worse the resulting number of minions should be exactly if it is less then we didn t need to delete the last deleted minion Furthermore if some minion should be deleted we can delete it just after it is summoned All these greedy ideas lead to the following structure of the answer we choose minions and summon them in some order we choose minions which will be summoned and instantly deleted we summon the remaining minion Let s analyze how these minions affect the answer The first minion has power and does not give bonus to anyone the second one has power and gives bonus to one minion and so on the th minion from the first group adds to the answer Minions from the second group buff minions each so they add to the answer and the last minion adds Let s unite the first group and the last minion then we will have two groups of minions those which are destroyed the second group and those which are not destroyed the first group From there we will have two possible ways to finish the solution there are minions and positions for them and for each pair minion position we may calculate the value this pair adds to the answer After that we should assign each monster a position in such a way that each position is chosen exactly once and the sum of values is maximized It can be done with mincost flows or Hungarian algorithm the minions from the first group should be played in non descending order of their Let s sort all minions by and write the following dynamic programming is the maximum answer if we considered first minions and of them were assigned to the first group Since the minions are sorted by whenever we add a minion to the first group it should add exactly to the answer and increase by and if a minion is added to the second group the answer is increased by 
Parsa has a humongous tree on n vertices On each vertex v he has written two integers l v and r v To make Parsa s tree look even more majestic Nima wants to assign a number a v l v le a v le r v to each vertex v such that the beauty of Parsa s tree is maximized Nima s sense of the beauty is rather bizarre He defines the beauty of the tree as the sum of a u a v over all edges u v of the tree Since Parsa s tree is too large Nima can t maximize its beauty on his own Your task is to find the possible beauty for Parsa s tree ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace std {\n\ntemplate<class Fun>\nclass y_combinator_result {\n\tFun fun_;\npublic:\n\ttemplate<class T>\n\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n\n\ttemplate<class ...Args>\n\tdecltype(auto) operator()(Args &&...args) {\n\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\n\t}\n};\n\ntemplate<class Fun>\ndecltype(auto) y_combinator(Fun &&fun) {\n\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));\n}\n\n} // namespace std\n\nusing ll = int64_t;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<vector<int> > edges(n);\n\tvector<ll> l(n), r(n);\n\tfor(int i = 0; i < n; i++) cin >> l[i] >> r[i];\n\tfor(int i = 0; i < n-1; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tedges[u].push_back(v);\n\t\tedges[v].push_back(u);\n\t}\n\tpair<ll, ll> res = y_combinator(\n\t\t[&](auto self, int v, int p) -> pair<ll, ll> {\n\t\t\tll lcost = 0;\n\t\t\tll rcost = 0;\n\t\t\tfor(int w : edges[v]){\n\t\t\t\tif(w == p) continue;\n\t\t\t\tauto [a, b] = self(w, v);\n\t\t\t\tlcost += max(abs(l[v] - l[w]) + a, abs(l[v] - r[w]) + b);\n\t\t\t\trcost += max(abs(r[v] - l[w]) + a, abs(r[v] - r[w]) + b);\n\t\t\t}\n\t\t\treturn {lcost, rcost};\n\t\t}\n\t)(0, -1);\n\tcout << max(res.first, res.second) << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","[1, 0, 0, 1, 0]",1600,The solution is based on the fact that an optimal assignment for exists such that for each vertex Proving this fact isn t hard pick any assignment for Assume is a vertex in this assignment such that Let be the number of vertices adjacent to such that Let be the number of vertices adjacent to such that Consider the following cases In this case we can decrease to and get a better result In this case we can increase to and get a better result In this case changing to or will either increase or not change the beauty of the tree Based on this fact we can use dynamic programming to find the answer Define as the maximum beauty of s subtree if is equal to Similarly define as the maximum beauty of s subtree if is equal to is calculated based on s children for each of s children such as we add s contribution to The transitions are It s clear that the answer is equal to complexity 
Nura wants to buy gadgets She has only burles for that She can buy each gadget for dollars or for pounds So each gadget is selling only for some type of currency The type of currency and the cost in that currency are not changing Nura can buy gadgets for days For each day you know the exchange rates of dollar and pound so you know the cost of conversion burles to dollars or to pounds Each day from to Nura can buy some gadgets by current exchange rate Each day she can buy any gadgets she wants but each gadget can be bought no more than once during days Help Nura to find the minimum day index when she will have gadgets Nura always pays with burles which are converted according to the exchange rate of the purchase day Nura can t buy dollars or pounds she always stores only burles Gadgets are numbered with integers from to in order of their appearing in input ,"['/*\nThe basement incinerator\nIs where they\'ll put the head\nHose the floor and clean the room\nAnywhere they bled\n\nInto boxes go the bags\nFill the space with rocks\nIn the dark of night\nHe throws them off the docks\n\nRotting in the river\nNever to be found\nUnder tons of concrete\nDeep beneath the ground\n\nFrom behind, he grabs his mouth\nThe blade goes to his neck\nBulging veins pumping blood\nHe struggles to protect\n\nIf you don\'t cut open the stomach\nThe corpse will rise and float\nThe victim is discovered dead\nRotting organs bloat\n\nThe killer chops the body\nWith a scalpel and an axe\nThe parts are then drained\nAnd put into the sacks\n\nGrab the neck, slit the throat, take the life\nHang the corpse, prepare to drain the blood\nBone saw, meat cleaver, filleting knife\nCarve the corpse, dissect him in the tub\n\nSmash the teeth, slice off scars, crush the bones\nWith a crowbar scrape off all tattoos\n\nIf you don\'t cut open the stomach\nThe corpse will rise and float\nThe victim is discovered dead\nRotting organs bloat\n\nThe killer chops the body\nWith a scalpel and an axe\nThe parts are then drained\nAnd put into the sacks\n\nChunks of a skull\nSawn in half bones\nBody is found\nKiller unknown\n*/\n\n//#pragma comment(linker, ""/STACK:16777216"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1234567891\n#define bsize 512\n\nconst int N = 210000;\n\nusing namespace std;\n\nvector < pair<long long, pair<int, int> > >v;\nint l, r;\nint cheap1, cheap2;\nint a[N], b[N];\nint tp[N];\nint c[N];\nint n, m, k, s;\n\nbool good(int l)\n{\n\tv.clear();\n\n\tcheap1 = 1;\n\tcheap2 = 1;\n\tfor (int i = 1; i <= l; i++)\n\t{\n\t\tif (a[i] < a[cheap1])\n\t\t\tcheap1 = i;\n\t\tif (b[i] < b[cheap2])\n\t\t\tcheap2 = i;\n\t}\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tif (tp[i] == 1)\n\t\t{\n\t\t\tv.push_back(make_pair(1ll * a[cheap1] * c[i], make_pair(i, cheap1)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tv.push_back(make_pair(1ll * b[cheap2] * c[i], make_pair(i, cheap2)));\n\t\t}\n\t}\n\tsort(v.begin(), v.end());\n\tlong long need = 0;\n\tfor (int i = 0; i < k; i++)\n\t\tneed += v[i].first;\n\treturn (need <= s);\n}\n\nint main(){\n\t//freopen(""beavers.in"",""r"",stdin);\n\t//freopen(""beavers.out"",""w"",stdout);\n\t//freopen(""F:/in.txt"",""r"",stdin);\n\t//freopen(""F:/output.txt"",""w"",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin >> n >> m >> k >> s;\n\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tcin >> b[i];\n\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tcin >> tp[i] >> c[i];\n\t}\n\n\tl = 1;\n\tr = n + 1;\n\twhile (l < r)\n\t{\n\t\tint mid = l + r;\n\t\tmid /= 2;\n\t\tif (good(mid))\n\t\t\tr = mid;\n\t\telse\n\t\t\tl = mid+1;\n\t}\n\n\tif (l == n + 1)\n\t{\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\n\tcout << l << endl;\n\n\tgood(l);\n\tfor (int i = 0; i < k; i++)\n\t{\n\t\tcout << v[i].second.first << "" "" << v[i].second.second << ""\\n"";\n\t}\n\n\tcin.get();\n\treturn 0;\n}']","[1, 0, 0, 0, 0]",2000,If Nura can buy gadgets in days then she can do that in days So the function of answer is monotonic So we can find the minimal day with binary search Denote the left bound of binary search and the right one We will maintain the invariant that in left bound we can t buy gadgets and in right bound we can do that Denote function equals to if we can buy gadgets in days and otherwise As usual in binary search we will choose If then we should move the right bound and the left bound in other case If binary search found the value then the answer is otherwise the answer is Before binary search we can create two arrays of gadgets which are selling for dollars and pounds and sort them Easy to see that we should buy gadgets for dollars on day when dollar costs as small as possible and when pounds costs as small as possible Let now we want to buy gadgets for dollars and gadgets for pounds Of course we will buy the least cheap of them we already sort the arrays for that Let s iterate over from to and maintain the sum of gadgets for dollars and the sum of gadgets for pounds For we can calculate the sums in For other x s we can recalculate the sums in time from the sums for by adding gadget for dollars and removing gadget for pounds Complexity 
Stalin Sort is a humorous sorting algorithm designed to eliminate elements which are out of place instead of bothering to sort them properly lending itself to an mathcal O n time complexity It goes as follows starting from the second element in the array if it is strictly smaller than the previous element ignoring those which have already been deleted then delete it Continue iterating through the array until it is sorted in non decreasing order For example the array 1 4 2 3 6 5 5 7 7 becomes 1 4 6 7 7 after a Stalin Sort We define an array as if you can sort it in order by repeatedly applying a Stalin Sort to as many times as is needed Given an array a of n integers determine the minimum number of integers which must be removed from the array to make it text An array a is a subarray of an array b if a can be obtained from b by the deletion of several possibly zero or all elements from the beginning and several possibly zero or all elements from the end ,"['#include <bits/stdc++.h>#ifdef LOCAL#define TASK ""test""#else#define TASK ""test""#endifusing namespace std;\xa0#define int long long\xa0const int N = 2005;\xa0int n;int a[N];\xa0void solve() {    cin >> n;    int res = n;    for (int i = 1; i <= n; ++i) {        cin >> a[i];    }    for (int i = 1; i <= n; ++i) {        int cnt = i - 1;        for (int j = i; j <= n; ++j) {            cnt += (a[i] < a[j]);        }        res = min(res, cnt);    }    cout << res << \'\\n\';}\xa0signed main() {    if (fopen(TASK"".inp"", ""r"")) {        freopen(TASK"".inp"", ""r"", stdin);        freopen(TASK"".out"", ""w"", stdout);    }    if (fopen(TASK"".err"", ""r"")) {        freopen(TASK"".err"", ""w"", stderr);    }    ios::sync_with_stdio(false);    cin.tie(nullptr);    int T;    cin >> T;    while (T--) {        solve();    }}']","[1, 0, 0, 0, 0]",1100,An array is vulnerable if and only if the first element is the largest To prove the forward direction we can trivially perform a single operation on the entire range which will clearly make it non increasing Now let s prove the reverse direction Consider any array in which the maximum is not the first element Note that a Stalin Sort on any subarray will never remove the first element and also will never remove the maximum So if the first is not the maximum this will always break the non increasing property Therefore we just need to find the longest subsequence in which the first element is the largest This can be done easily in consider each index being the first item in the subsequence and count all items to the right of it which are smaller or equal to it Find the maximum over all of these then subtract this from Bonus Solve this task in 
In the court of the Blue King Lelle and Flamm are having a performance match The match consists of several rounds In each round either Lelle or Flamm wins Let W L and W F denote the number of wins of Lelle and Flamm respectively The Blue King considers a match to be if and only if after every round gcd W L W F le 1 at the end of the match W L le n W F le m Note that gcd 0 x gcd x 0 x for every non negative integer x Lelle and Flamm can decide to stop the match whenever they want and the final score of the performance is l cdot W L f cdot W F Please help Lelle and Flamm coordinate their wins and losses such that the performance is and the total score of the performance is maximized ,"['#include <bits/stdc++.h>\xa0using u32 = unsigned;using i64 = long long;using u64 = unsigned long long;\xa0constexpr int N = 2E7;std::vector<int> minp, primes;\xa0void sieve(int n) {    minp.assign(n + 1, 0);    primes.clear();        for (int i = 2; i <= n; i++) {        if (minp[i] == 0) {            minp[i] = i;            primes.push_back(i);        }                for (auto p : primes) {            if (i * p > n) {                break;            }            minp[i * p] = p;            if (p == minp[i]) {                break;            }        }    }}\xa0void solve() {    int n, m, l, f;    std::cin >> n >> m >> l >> f;        int q = m;    while (q > 1 && minp[q] != q) {        q--;    }    int p = std::min(q - 1, n);    while (p > 1 && (minp[p] != p || m / p != q / p)) {        p--;    }        // std::cerr << ""p : "" << p << "", q : "" << q << ""\\n"";    std::vector vis(n - p + 1, std::vector<bool>(m - q + 1));    i64 ans = 0;    for (int i = 0; i <= n - p; i++) {        for (int j = 0; j <= m - q; j++) {            int g = std::gcd(p + i, q + j);            if (i == 0 || j == 0) {                vis[i][j] = (g == 1 && p + i <= q + j);            } else if (g == 1) {                vis[i][j] = vis[i - 1][j] || vis[i][j - 1];            }            if (vis[i][j]) {                // std::cerr << ""("" << p + i << "", "" << q + j << "")\\n"";                ans = std::max(ans, 1LL * l * (p + i) + 1LL * f * (q + j));                if (q + j <= n) {                    ans = std::max(ans, 1LL * f * (p + i) + 1LL * l * (q + j));                }            }        }    }    std::cout << ans << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        // for (int i = 0; i <= 30; i++) {    //     for (int j = 0; j <= 30; j++) {    //         std::cerr << (std::gcd(i, j) <= 1 ? ""O"" : "" "");    //     }    //     std::cerr << ""\\n"";    // }        sieve(N);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']","[0, 1, 0, 1, 0]",2600,TutorialWe view the problem as a walk on grid starting at WLOG we suppose thus only cells where would be considered Notice that when is large enough the largest prime satisfies As such all cells where will be unblocked and reachable However we ve only bounded one side of the final result We take this a step further let be the second largest prime By the same logic we assume that As such all cells where will be unblocked and reachable Thus we have constructed an area where the optimal solution must be with its dimensions bounded by and We just need to run any brute force solution dfs with memorization or dp on this area to find the result If we assume the asymptotic of prime gap is this yields a solution where the is from taking the gcd of two numbers which differ by This can also be optimized to by preprocessing gcd We added the constraints that s are pairwise distinct to avoid forcing participants to write memorizations In fact under the constraints of the problem the maximum area is and the sum of the largest areas is Time complexity 
British mathematician John Littlewood once said about Indian mathematician Srinivasa Ramanujan that every positive integer was one of his personal friends It turns out that positive integers can also be friends with each other You are given an array a of distinct positive integers Define a a i a i 1 ldots a j to be a if and only if there exists an integer m ge 2 such that a i bmod m a i 1 bmod m ldots a j bmod m where x bmod y denotes the remainder when x is divided by y Your friend Gregor wants to know the size of the largest friend group in a ,"[""// Problem: D. Integers Have Friends\n// Contest: Codeforces - Codeforces Round #736 (Div. 2)\n// URL: https://codeforces.com/contest/1549/problem/D\n// Memory Limit: 256 MB\n// Time Limit: 2000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define chkmx(a,b) ((a)=max((a),(b)))\n#define chkmn(a,b) ((a)=min((a),(b)))\nusing namespace std;\ntemplate<typename T>\ninline void read(T &x){x=0;char c=getchar();bool f=false;for(;!isdigit(c);c=getchar())f|=c=='-';for(;isdigit(c);c=getchar())x=x*10+c-'0';if(f)x=-x;}\ntemplate<typename T ,typename ...Arg>inline void read(T &x,Arg &...args){read(x);read(args...);}\ntemplate<typename T>inline void write(T x){if(x<0)putchar('-'),x=-x;if(x>=10)write(x/10);putchar(x%10+'0');}\n#define int long long\ntypedef long long ll;\nconst int N=2e5+100;\nint t,n,a[N],b[N];\nstruct SGT{\n\tint val[N<<2];\n\t#define lc (x<<1)\n\t#define rc (x<<1|1)\n\t#define mid ((l+r)>>1)\n\tvoid pushup(int x){\n\t\tval[x]=__gcd(val[lc],val[rc]);\n\t}\n\tvoid build(int x,int l,int r){\n\t\tif(l==r){\n\t\t\tval[x]=b[l];\n\t\t\treturn;;\n\t\t}\n\t\t\n\t\tbuild(lc,l,mid);\n\t\tbuild(rc,mid+1,r);\n\t\tpushup(x);\n\t}\n\tint qry(int x,int l,int r,int ql,int qr){\n\t\tif(ql<=l&&r<=qr)return val[x];\n\t\tif(qr<l||r<ql)return 0;\n\t\treturn __gcd(qry(lc,l,mid,ql,qr),qry(rc,mid+1,r,ql,qr));\n\t}\n}T;\nsigned main(){\n\tread(t);\n\twhile(t--){\n\t\tread(n);\n\t\tfor(int i=1;i<=n;i++)read(a[i]);\n\t\tfor(int i=1;i<n;i++)b[i]=abs(a[i]-a[i+1]);\n\t\tif(n==1){write(1);putchar('\\n');continue;;}\n\t\tT.build(1,1,n-1);\n\t\tint l=1,r=0,ans=1;int now=0;\n\t\tfor(;l<n;){\n\t\t\twhile(r+1<n&&__gcd(now,b[r+1])>1)\n\t\t\t\tr++,now=__gcd(now,b[r]);\n\t\t\tif(now>1)ans=max(ans,r-l+2);\n\t\t\tl++;chkmx(r,l-1);\n\t\t\tif(l<=r)now=T.qry(1,1,n-1,l,r);\n\t\t\telse now=0;\n\t\t}\n\t\twrite(ans);putchar('\\n');\n\t}\n}\n""]","[0, 1, 0, 0, 1]",1800,SolutionThe key observation is to construct the difference array of size where If a given subarray is a friend group then every difference is a multiple of some Since every element of is distinct the case when can be ignored We can now convert this into a GCD greatest common divisor problem It follows that is a friend group if and only if Indeed the value that we want is equal to this GCD To solve the problem we can use a sparse table or a segment tree to find the largest possible subarray beginning at and then max over all subarray answers to get the final answer The time complexity is The first log is for the sparse table the second is for computing GCDs Note that the de facto time complexity may be closer to due to the insights from this blog post 
Frog Gorf is traveling through Swamp kingdom Unfortunately after a poor jump he fell into a well of n meters depth Now Gorf is on the bottom of the well and has a long way up The surface of the well s walls vary in quality somewhere they are slippery but somewhere have convenient ledges In other words if Gorf is on x meters below ground level then in one jump he can go up on any integer distance from 0 to a x meters inclusive Note that Gorf can t jump down only up Unfortunately Gorf has to take a break after each jump including jump on 0 meters And after jumping up to position x meters below ground level he ll slip exactly b x meters down while resting Calculate the minimum number of jumps Gorf needs to reach ground level ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, a[300005], b[300005];\nint dp[300005], pre[300005], pv[300005];\nset<int> R;\nqueue<int> que;\nint main()\n{\n\tscanf(""%d"", &n);\n\trep1(i, n) {\n\t\tscanf(""%d"", &a[i]); a[i] = i - a[i];\n\t}\n\trep1(i, n) {\n\t\tscanf(""%d"", &b[i]); b[i] += i;\n\t}\n\t\n\trep(i, n) dp[i] = -1;\n\tdp[n] = 0;\n\tque.push(n);\n\trep(i, n) R.insert(i);\n\twhile(!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\twhile(true) {\n\t\t\tset<int>::iterator it = R.lower_bound(a[v]);\n\t\t\tif(it == R.end() || *it > v) break;\n\t\t\tif(dp[b[*it]] == -1) {\n\t\t\t\tpre[b[*it]] = v; pv[b[*it]] = *it;\n\t\t\t\tdp[b[*it]] = dp[v] + 1; que.push(b[*it]);\n\t\t\t}\n\t\t\tR.erase(it);\n\t\t}\n\t}\n\t\n\tif(dp[0] == -1) printf(""-1\\n"");\n\telse {\n\t\tprintf(""%d\\n"", dp[0]);\n\t\tvector<int> ans;\n\t\tfor(int i = 0; i != n; i = pre[i]) ans.push_back(pv[i]);\n\t\tfor(int i = (int)ans.size() - 1; i >= 0; i --) printf(""%d "", ans[i]);\n\t}\n\treturn 0;\n}']","[0, 0, 0, 1, 1]",1900,Let s denote sequence of moves as We will use minimal number of moves needed to travel from to It can be calculated with We expected calculations to use bfs style order So if there is a jump to is If there is no jump to but there is a jump to position with then is and so on What happens when we know all dp s with values from to We ll take position and all with condition Then all that has we know for sure For every we will save in minimum segment tree value So all s are just elements from a suffix with value not greater than We can iterate through all s because every of them is used only once right after we know we can use any neutral value infinity in our case Time complexity is Try to solve it in linear time 
CQXYM wants to create a connected undirected graph with n nodes and m edges and the diameter of the graph must be strictly less than k 1 Also CQXYM doesn t want a graph that contains self loops or multiple edges i e each edge connects two different vertices and between each pair of vertices there is at most one edge The diameter of a graph is the maximum distance between any two nodes The distance between two nodes is the minimum number of the edges on the path which endpoints are the two nodes CQXYM wonders whether it is possible to create such a graph ,"['#pragma GCC optimize(2)\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<map>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#define ll long long\n#define ls(_o) (_o<<1)\n#define rs(_o) ((_o<<1)|1)\n#define N 3100\n#define p 1000000007\n#define p1 998244353\n#define p2 1000000007\nusing namespace std;\nnamespace ywy{\n\tinline int get(){\n\t\tint n=0;char c;while((c=getchar())||23333){\n\t\t\tif(c>=\'0\'&&c<=\'9\')break;if(c==\'-\')goto s;\n\t\t}n=c-\'0\';while((c=getchar())||23333){\n\t\t\tif(c>=\'0\'&&c<=\'9\')n=n*10+c-\'0\';else return(n);\t\n\t\t}s:while((c=getchar())||23333){\n\t\t\tif(c>=\'0\'&&c<=\'9\')n=n*10-c+\'0\';else return(n);\t\n\t\t}\n\t}\n\tvoid ywymain(){\n\t\tint T=get(); while(T--){\n\t\t\tint n=get(),m=get(),k=get()-2;\n\t\t\tif(m<n-1||k<0){\n\t\t\t\tprintf(""NO\\n""); continue;\t\n\t\t\t}\n\t\t\tif(m>(ll)n*(ll)(n-1)/2){\n\t\t\t\tprintf(""NO\\n""); continue;\t\n\t\t\t}\n\t\t\tif(n==1){\n\t\t\t\tprintf(""YES\\n""); continue;\t\n\t\t\t}\n\t\t\tif(k==0){\n\t\t\t\tprintf(""NO\\n""); continue;\t\n\t\t\t}\n\t\t\t//<=k\n\t\t\tif(m==(ll)n*(ll)(n-1)/2){\n\t\t\t\tprintf(""YES\\n""); continue;\t\n\t\t\t}else{\n\t\t\t\tif(k<=1) printf(""NO\\n""); else printf(""YES\\n"");\t\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tywy::ywymain();\t\n}']","[1, 1, 0, 0, 0]",1200,If the graph can t be connected so the answer should be No If the graph must contaion multiedges so the answer should be No If the graph must be a complete graph The diameter of the graph is If the answer is YES otherwise the answer is NO If the graph has only one node and its diameter is If the answer is YES otherwise the answer is NO If the graph must be a tree the diameter of the tree is at least when it comes to each node has an edge with node If we can add edges on the current tree and the diameter wouldn t be more than Since the graph is not complete graph the diameter is more than the diameter is just If the answer is YES otherwise the answer is NO The time complexity is solution 
Little Petya has recently started attending a programming club Naturally he is facing the problem of choosing a programming language After long considerations he realized that Java is the best choice The main argument in favor of choosing Java was that it has a very large integer data type called BigInteger But having attended several classes of the club Petya realized that not all tasks require using the BigInteger type It turned out that in some tasks it is much easier to use small data types That s why a question arises Which integer type to use if one wants to store a positive integer Petya knows only 5 integer types 1 occupies 1 byte and allows you to store numbers from to 2 occupies 2 bytes and allows you to store numbers from to 3 occupies 4 bytes and allows you to store numbers from to 4 occupies 8 bytes and allows you to store numbers from to 5 can store any integer number but at that it is not a primitive type and operations with it are much slower For all the types given above the boundary values are included in the value range From this list Petya wants to choose the smallest type that can store a positive integer Since BigInteger works much slower Peter regards it last Help him ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <ctime>\n\nusing namespace std;\n\n#define file ""a""\n#define sqr(a) ((a)*(a))\n#define two(a) (1 << (a))\n\nstring n;\n\nvoid Load ()\n{\n    cin >> n;\n}\n\nbool operator < (const string &a, const string &b)\n{\n    if (a.size() < b.size()) return true;\n    if (b.size() < a.size()) return false;\n\n    for (int i = 0;i < a.size();i++)\n    {\n        if (a[i] < b[i]) return true;\n        if (b[i] < a[i]) return false;\n    }\n    return true;\n}\n\nvoid Solve ()\n{\n    string b = ""127"";\n    string s = ""32767"";\n    string i = ""2147483647"";\n    string l = ""9223372036854775807"";\n\n    if (n < b) cout << ""byte"";\n    else if (n < s) cout << ""short"";\n    else if (n < i) cout << ""int"";\n    else if (n < l) cout << ""long"";\n    else cout << ""BigInteger"";\n}\n\nint main ()\n{\n    //freopen (file"".in"", ""r"", stdin);\n    //freopen (file"".out"", ""w"", stdout);\n\n    Load();\n    Solve();\n\n    return 0;\n}']","[0, 0, 1, 0, 0]",1300,In this problem you should answer to 4 questions 1 Can we use type byte to store N 2 Can we use type short to store N 3 Can we use type int to store N 4 Can we use type long to store N We should check these conditions in the given order If all these conditions are wrong the answer is BigInteger The simplest way to check these conditions is to store numbers as strings and write a function to compare such strings In Java you can use type BigInteger 
Let f x c 2x 6 cdot f x 1 cdot f x 2 cdot f x 3 for x ge 4 You have given integers n f 1 f 2 f 3 and c Find f n bmod 10 9 7 ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntypedef map<int,int> mii;\n#define itr iterator\nconst int Ha=1000000007;\nconst int phi=1000000006;\nstruct matrix\n{\n\tint a[5][5];\n\tmatrix(){memset(a,0,sizeof(a));}\n}t;\ninline matrix operator*(const matrix&a,const matrix&b)\n{\n\tmatrix c;\n\tfor(int i=0;i<5;++i)\n\t\tfor(int j=0;j<5;++j)\n\t\t\tfor(int k=0;k<5;++k)\n\t\t\t\tc.a[i][j]=(c.a[i][j]+1ll*a.a[i][k]*b.a[k][j])%phi;\n\treturn c;\n}\ninline matrix fp(matrix b,long long e)\n{\n\tmatrix r;\n\tfor(int i=0;i<5;++i)r.a[i][i]=1;\n\tfor(;e;e>>=1,b=b*b)if(e&1)r=r*b;\n\treturn r;\n}\nmap<int,int>mp;\nint B=1;\nint fp(int b,int e)\n{\n\tint r=1;\n\tfor(;e;e>>=1,b=1ll*b*b%Ha)if(e&1)r=1ll*r*b%Ha;\n\treturn r;\n}\nint dlog(int x)\n{\n\tint now=1;\n\tint res;\n\tfor(int i=0;;++i)\n\t{\n\t\tint y=1ll*x*now%Ha;\n\t\tif(mp.count(y))\n\t\t{\n\t\t\tres=mp[y]-i*33333;\n\t\t\tbreak;\n\t\t}\n\t\tnow=1ll*now*B%Ha;\n\t}\n\tres=(res+phi)%phi;\n\tres=(res+phi)%phi;\n\tres=(res+phi)%phi;\n\tassert(fp(5,res)==x);\n\treturn res;\n}\nint z[5];\nint main()\n{\n\tfor(int i=0;i<33333;++i)\n\t{\n\t\tmp[B]=i;\n\t\tB=5ll*B%Ha;\n\t}\n\tlong long n;\n\tint f1,f2,f3,c;\n\tscanf(""%lld%d%d%d%d"",&n,&f1,&f2,&f3,&c);\n\tc=dlog(c);\n\tf1=dlog(f1);\n\tf2=dlog(f2);\n\tf3=dlog(f3);\n\tt.a[0][1]=1;\n\tt.a[1][2]=1;\n\tt.a[1][0]=1;\n\tt.a[0][0]=1;\n\tt.a[1][0]=1;\n\tt.a[2][0]=1;\n\tt.a[3][3]=1;\n\tt.a[3][0]=(phi-6ll*c%phi)%phi;\n\tt.a[4][0]=2ll*c%phi;\n\tt.a[3][4]=1;\n\tt.a[4][4]=1;\n\tz[0]=f3;\n\tz[1]=f2;\n\tz[2]=f1;\n\tz[3]=1;\n\tz[4]=4;\n\tt=fp(t,n-3);\n\tint res=0;\n\tfor(int i=0;i<5;++i)res=(res+1ll*z[i]*t.a[i][0])%phi;\n\tprintf(""%d\\n"",fp(5,res));\n\treturn 0;\n}']","[0, 1, 0, 1, 0]",2300,You can form the expression into this Let s occurrence for prime number For example so s occurrence is Then we can set the formula and calculate using matrix exponentiation Since all different prime numbers share same matrix we can calculate matrix only once And we have less or equal than 36 distinct prime numbers targeted because you cannot get more than distinct prime numbers by prime decomposition from numbers in range With we can calculate and we can calculate using modulo inverse Time complexity is 
The ICM ACPC World Finals is coming Unfortunately the organizers of the competition were so busy preparing tasks that totally missed an important technical point the organization of electricity supplement for all the participants workstations There are computers for participants the th of which has power equal to positive integer At the same time there are sockets available the th of which has power euqal to positive integer It is possible to connect the th computer to the th socket if and only if their powers are the same It is allowed to connect no more than one computer to one socket Thus if the powers of all computers and sockets are distinct then no computer can be connected to any of the sockets In order to fix the situation professor Puch Williams urgently ordered a wagon of adapters power splitters Each adapter has one plug and one socket with a voltage divider between them After plugging an adapter to a socket with power the power on the adapter s socket becomes equal to it means that it is equal to the socket s power divided by two with rounding up for example and Each adapter can be used only once It is possible to connect several adapters in a chain plugging the first to a socket For example if two adapters are plugged one after enother to a socket with power it becomes possible to connect one computer with power to this socket The organizers should install adapters so that it will be possible to supply with electricity the maximum number of computers at the same time If there are several possible connection configurations they want to find the one that uses the minimum number of adapters to connect computers Help organizers calculate the maximum number of connected computers and the minimum number of adapters needed for this The wagon of adapters contains enough of them to do the task It is guaranteed that it s possible to connect at least one computer ,"['#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nconst int N = 202020;\nint p[N] , s[N] , n , m;\nint b[N] , to[N] , times[N];\nmap<int,queue<int> > Mp;\n\nint main(){\n    scanf(""%d%d"",&n,&m);\n    rep(i,1,n+1) scanf(""%d"",p + i) , Mp[p[i]].push(i);\n    rep(i,1,m+1) scanf(""%d"",s + i);\n    rep(i,1,m+1) b[i] = i;\n    sort(b+1,b+m+1,[&](int x,int y){return s[x]<s[y];});\n    int cc = 0 , aa = 0;\n    rep(i,1,m+1){\n        int c = b[i] , x = s[c];\n        for(int i=0;x;i++){\n            if(Mp.count(x)){\n                queue<int>&t = Mp[x];\n                to[t.front()] = c;\n                times[c] = i;\n                cc += i;\n                aa++;\n                t.pop();\n                if(sz(t) == 0) Mp.erase(x);\n                break;\n            }\n            if(x == 1) break;\n            x = (x + 1) / 2;\n        }\n    }\n    printf(""%d %d\\n"",aa,cc);\n    rep(i,1,m+1) printf(""%d%c"",times[i],"" \\n""[i==m]);\n    rep(i,1,n+1) printf(""%d%c"",to[i],"" \\n""[i==n]);\n    return 0;\n}\n']","[1, 0, 0, 0, 0]",2100,Firstly we need to sort both arrays with computers and with sockets in non descending order also we need to sustain their indices to print the answer Then we iterate on the value until it reaches the logarithm of the maximum value in or until it reaches 31 For each value of we iterate on computers in non descending order also we maintain the index of the most suitable socket let s call this index If socket number is already used or if its power is less than current computer s requirement we increase If our current socket s power matches current computer s requirement then we connect this computer with current socket Each iteration connects the largest possible number of computers and sockets After each iteration we install adapters on all non used sockets After all iterations we print the answer Time complexity where is the maximum power of socket 
You are given n sticks of lengths a 1 a 2 ldots a n Find the maximum number of regular equal sided polygons you can construct simultaneously such that Each side of a polygon is formed by exactly one stick No stick is used in more than 1 polygon Note Sticks cannot be broken ,"['/* */#include<bits/stdc++.h>using namespace std;const int maxn=500005;int n,m,T,ans,flg;int a[maxn],tot[maxn];string s;int main(){\tscanf(""%d"",&T);\twhile(T--){\t\tans=flg=0;\t\tscanf(""%d"",&n);\t\tfor(int i=1;i<=n;i++)\t\t\tscanf(""%d"",&a[i]),tot[a[i]]++;\t\tfor(int i=1;i<=100;i++)\t\t\tans+=tot[i]/3,tot[i]=0;\t\tprintf(""%d\\n"",ans);\t}\treturn 0;}']","[1, 0, 0, 0, 0]",800,The first observation that needs to be made in this problem is that we have to greedily try to build triangles from the sticks available The number of triangles that can be created simultaneously by sticks of the same length is Hence the answer is just the sum of the count of all triangles for all stick lengths where denotes the number of sticks of length The time complexity of the problem is therefore 
Recently you have bought a snow walking robot and brought it home Suppose your home is a cell 0 0 on an infinite grid You also have the sequence of instructions of this robot It is written as the string s consisting of characters and If the robot is in the cell x y right now he can move to one of the adjacent cells depending on the current instruction If the current instruction is then the robot can move to the left to x 1 y if the current instruction is then the robot can move to the right to x 1 y if the current instruction is then the robot can move to the top to x y 1 if the current instruction is then the robot can move to the bottom to x y 1 You ve noticed the warning on the last page of the manual if the robot visits some cell 0 0 twice then it breaks So the sequence of instructions is valid if the robot starts in the cell 0 0 performs the given instructions visits no cell other than 0 0 two or more times and ends the path in the cell 0 0 Also cell 0 0 should be visited two times at the beginning and at the end if the path is empty then it is visited only once For example the following sequences of instructions are considered valid and the following are considered invalid the endpoint is not 0 0 and the cell 0 1 is visited twice The initial sequence of instructions however might be not valid You don t want your robot to break so you decided to reprogram it in the following way you will remove some possibly all or none instructions from the initial sequence of instructions then rearrange the remaining instructions as you wish and turn on your robot to move Your task is to remove as few instructions from the initial sequence as possible and rearrange the remaining ones so that the sequence is valid Report the valid sequence of the maximum length you can obtain Note that you can choose order of remaining instructions you don t need to minimize the number of swaps or any other similar metric You have to answer q independent test cases ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1E5 + 10;\n\nint n;\nchar st[N];\n\nvoid Solve() {\n    int d[4] = {0};\n    char cc[4] = {\'L\', \'R\', \'U\', \'D\'};\n    for (int i = 1; i <= n; i++) {\n        if (st[i] == \'L\') d[0]++;\n        if (st[i] == \'R\') d[1]++;\n        if (st[i] == \'U\') d[2]++;\n        if (st[i] == \'D\') d[3]++;\n    }\n    int tmp = 0;\n    int t1 = min(d[0], d[1]);\n    int t2 = min(d[2], d[3]);\n    int ans = t1 * 2 + t2 * 2;\n    for (int i = 0; i < 4; i++)\n        tmp += d[i] > 0;\n    if (!t1 && !t2) {\n        printf(""0\\n\\n"");\n    } else if (!t1 || !t2) {\n        if (t1) {\n            printf(""2\\nLR\\n"");\n        } else {\n            printf(""2\\nUD\\n"");\n        }\n    } else {\n        printf(""%d\\n"", ans);\n        for (int i = 0; i < t1; i++)\n            putchar(\'L\');\n        for (int i = 0; i < t2; i++)\n            putchar(\'U\');\n        for (int i = 0; i < t1; i++)\n            putchar(\'R\');\n        for (int i = 0; i < t2; i++)\n            putchar(\'D\');\n        putchar(\'\\n\');\n    }\n}\n\nint main() {\n    #ifdef LOCAL\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n    #endif // LOCAL\n    int TC; scanf(""%d\\n"", &TC);\n    while (TC--) {\n        scanf(""%s"", st + 1);\n        n = strlen(st + 1);\n        Solve();\n    }\n    return 0;\n}\n']","[1, 0, 1, 0, 0]",1200,Let be the number of occurrences of the character in the initial string the number of occurrences of the character and are the same things for remaining characters It is obvious that in every answer the number of equals the number of and the same for and The maximum theoretic answer we can obtain has length And We almost always can obtain this answer If there is at least one occurrence of each character then we can construct some kind of rectangular path moves right then moves up and the completing part But there are some corner cases when some characters are missing If then our answer is empty or if it is possible it is The same if Time complexity per test case 
 In Boolean logic a formula is in conjunctive normal form CNF or clausal normal form if it is a conjunction of clauses where a clause is a disjunction of literals cited from https en wikipedia org wiki Conjunctive normal form In the other words CNF is a formula of type where represents a logical AND conjunction represents a logical OR disjunction and are some boolean variables or their negations Each statement in brackets is called a and are called You are given a CNF containing variables and their negations We know that each variable occurs in at most two clauses with negation and without negation in total Your task is to determine whether this CNF is that is whether there are such values of variables where the CNF value is true If CNF is satisfiable then you also need to determine the values of the variables at which the CNF is true It is guaranteed that each variable occurs at most once in each clause ,"['#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<memory.h>\n#include<map>\n#include<set>\n#include<queue>\n#include<list>\n#include<sstream>\n#include<cstring>\n#define mp make_pair\n#define pb push_back      \n#define F first\n#define S second\n#define SS stringstream\n#define sqr(x) ((x)*(x))\n#define m0(x) memset(x,0,sizeof(x))\n#define m1(x) memset(x,63,sizeof(x))\n#define CC(x) cout << (x) << endl\n#define pw(x) (1ll<<(x))\n#define buli(x) __builtin_popcountll(x)\n#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)\n#define M 1000000007\n#define N 322000\n\n#define TASK ""1""\n\nusing namespace std;\ntypedef pair<int,int> pt;\n\nint n, k;\nvector<int> pe[N];\nvector<pair<int, int> > vs[N];\n\nvector<pair<int, int> > v[N];\n\nint ok[N], ans[N], take[N];\n\nint used[N];\n\nint match(int x) {\n\tok[x] = 1;\n\tint r = 0;\n\tfor (int i = 0; i < v[x].size(); i++) {\n\t\tif (used[v[x][i].S]) continue;\n\t\tused[v[x][i].S] = 1;\n\n\n\t\tint to = v[x][i].F;\n\t\tif (ok[to]) {\n\t\t\tr = 1;\n\t\t\ttake[v[x][i].S] = x;\n\t\t\tbreak;\n\t\t}\n\n\t\tint t = match(to);\n\t\tif (t == 1) {\n\t\t\tr = 1;\n\t\t\ttake[v[x][i].S] = x;\n\t\t\tbreak;\n\t\t}\n\t\ttake[v[x][i].S] = to;\n\t}\n\treturn r;\n}\n\nint main(){\n//\tfreopen(TASK"".in"",""r"",stdin);\t\n//\tfreopen(TASK"".out"",""w"",stdout);\n\tcin >> n >> k;\n\tfor (int i = 0; i < n; i++) {\n\t\tint kk;\n\t\tscanf(""%d"", &kk);\n\t\tpe[i].resize(kk);\n\t\tfor (int j = 0; j < kk; j++) {\n\t\t\tscanf(""%d"", &pe[i][j]);\n\n\t\t\tvs[abs(pe[i][j])].pb(mp(i, pe[i][j] / abs(pe[i][j])));\n\t\t}\t\t\t\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (vs[i].size() == 0) continue;\n\n\t\tif (vs[i].size() == 1) {\n\t\t\tans[i] = vs[i][0].S;\n\n\t\t\tok[abs(vs[i][0].F)] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (vs[i][0].S == vs[i][1].S) {\n\t\t\tans[i] = vs[i][0].S;\n\n\t\t\tok[abs(vs[i][0].F)] = 1;\n\t\t\tok[abs(vs[i][1].F)] = 1;\n\t\t} else {\n\t\t\tint x = abs(vs[i][0].F);\n\t\t\tint y = abs(vs[i][1].F);\n\n\t\t\tv[x].pb(mp(y, i));\n\t\t\tv[y].pb(mp(x, i));\n\t\t}\n\t}\n\tfor (int i = 1; i <= k; i++) take[i] = -1;\n\tfor (int i = 0; i < n; i++) if (!ok[i]) {\n\t\tint h = match(i);\n\t\tif (h == 0) {\n\t\t\tputs(""NO"");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(""YES"");\n\tfor (int i = 1; i <= k; i++) if (take[i] != -1) {\n\t\tfor (int j = 0; j < vs[i].size(); j++) if (vs[i][j].F == take[i]) {\n\t\t\tans[i] = vs[i][j].S;\n\t\t}\t\n\t}\n\tfor (int i = 1; i <= k; i++) {\n\t\tif (ans[i] == -1) ans[i] = 0;\n\t\tprintf(""%d"", ans[i]);\n\t}\n\tputs("""");\n\treturn 0;\n}\n\n\n']","[1, 0, 0, 0, 0]",2500,Firstly let s assign values to variables occurring in our fomula only with negation or only without negation After that we can throw away the disjuncts which contained them since they are already true and continue the process until it is possible To make it run in time limit one should use dfs or bfs algorithm to eliminate these variables and disjuncts So now we have only variables which have both types of occurrences in disjucnts Let s build a graph with the vertices corresponding to disjuncts and for each varible make an edge between the disjuncts that contain and Now we should choose the directions of edges in this graph in such a way that every vertex has at least one incoming edge We can notice that if some connected component of this graph is a tree the solution is not possible on each step we can take some leaf of this tree and we have to orient its only edge to it and then erase the leaf In the end we ll have only one vertex and it ll not have any incoming edges Otherwise take some cycle in the component and orient the edges between neighbouring vertices along it Then run dfs from every vertex of the cycle and orient each visited edge in the direction we went along it It is easy to easy that after this process every vertex will have at least one incoming edge So we should consider cases with the variables which values can be assigned at once than construct a graph from disjuncts and variables and find whether each connected component has a cycle If so we also should carefully construct the answer assigning the remaining variables their values looking at the directions of the edges in the graph The overall complexity is Problem author zeliboba Problem developers Kostroma zeliboba yarrr Solution codes 12873432 linear solution 12873446 12873456 matching solution 
You are given an array a consisting of n integers The array is sorted if a 1 le a 2 le dots le a n You want to make the array a sorted by applying the following operation choose an integer x then for every i in 1 n replace a i by a i x Find any value of x that will make the array sorted or report that there is no such value ,"['/*\nFeeling so sleepy\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,m,n) for (ll i=m;i<=n;i++)\n#define reb(i,m,n) for (ll i=m;i>=n;i--)\n#define rv(i,vt) for (auto i:vt)\n#define ii pair<ll,ll>\n#define vi vector<ll>\n#define F first\n#define S second\n#define pb push_back\n#define sz(v) (int)v.size()\n#define iii tuple<ll,ll,ll>\nusing namespace std;\nconst ll N=1e6+5,mod=1e9+7;\nll n,q,a[N],k,res,l[N],r[N];\nvoid elixprep(){\n    \n}\nvoid elix()\n{\n    cin>>n;\n    rep(i,1,n) cin>>a[i];\n    rep(i,2,n) if (a[i]==a[i-1]) l[i]=r[i]=-1;\n    else if (a[i]>a[i-1]){\n        ll u=a[i],v=a[i-1];\n        ll rs=v;\n        u-=v;\n        rs+=u/2;\n        l[i]=-1;\n        r[i]=rs;\n    }\n    else if (a[i]<a[i-1]){\n        ll u=a[i],v=a[i-1];\n        ll rs=u;\n        v-=u;\n        rs+=(v+1)/2;\n        l[i]=rs;\n        r[i]=-1;\n    }\n    ll L=0,R=1000000000;\n    rep(i,2,n){\n        if (l[i]!=-1) L=max(L,l[i]);\n        if (r[i]!=-1) R=min(R,r[i]);\n    }\n    if (L>R) cout<<-1;\n    else cout<<L;\n}\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    ll tests=1;\n    cin>>tests;\n    elixprep();\n    while (tests--){\n        elix();\n        cout<<endl;\n}\n    cerr << ""\\n"" << (double)clock() / CLOCKS_PER_SEC * 1000 << "" ms"";\n}\n//listen to trap music. it won\'t help']","[0, 1, 0, 0, 0]",1400,What does it actually mean for an array to be sorted That means and and so on For each pair of adajacent elements let s deduce which values put them in the correct order Any value of that puts all pairs in the correct order will be the answer Consider any and and solve the inequality If then any value of works Let be smaller than If is smaller than or equal to then the inequality becomes Thus they don t change their order and any works If is greater than or equal to then the inequality becomes Thus they always change their order and none of work If is between and then the inequality becomes Thus they only remain in the same order for any integer such that In union that tells us that all values of that work for such a pair are The similar analysis can be applied to which results in the required being for such pairs Finally how to find out if some value of passes all conditions Among all conditions of form in order for some to work it should be less than or equal to even the smallest of them Similarly among all conditions of form in order for some to work it should be greater than or equal to even the largest of them Thus take the minimum over the pairs of one type Take the maximum over the pairs of another type If two resulting values are contradictory then there is no answer Otherwise any value inside the resulting range of works Overall complexity per testcase 
You are given an integer array a 1 a 2 dots a n 0 le a i le 10 9 In one operation you can choose an integer x 0 le x le 10 18 and replace a i with lfloor frac a i x 2 rfloor lfloor y rfloor denotes rounding y down to the nearest integer for all i from 1 to n Pay attention to the fact that all elements of the array are affected on each operation Print the smallest number of operations required to make all elements of the array equal If the number of operations is less than or equal to n then print the chosen x for each operation If there are multiple answers print any of them ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    int mn = 1e9, mx = 0;\n    for (int i = 0; i < n; ++i) {\n        int a;\n        cin >> a;\n        mn = min(mn, a);\n        mx = max(mx, a);\n    }\n    vector<int> ans;\n    while (mn != mx) {\n        if (mn % 2 == mx % 2) {\n            ans.push_back(0);\n        } else if (mx % 2 == 0) {\n            ans.push_back(1);\n            ++mn;\n            ++mx;\n        } else {\n            ans.push_back(0);\n        }\n        mn /= 2;\n        mx /= 2;\n    }\n    cout << ans.size() << ""\\n"";\n    if ((int)ans.size() <= n) {\n        for (int x : ans) {\n            cout << x << "" "";\n        }\n        cout << ""\\n"";\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']","[1, 1, 0, 0, 0]",1400,Sort the array Notice how applying the operation doesn t change the order of the elements regardless of It means that it s enough to make the initial minimum and maximum equal to make all elements equal Consider the difference between the minimum and the maximum values What happens to it after an operation Let the minimum be and the maximum be Then it s The roundings are difficult to deal with so let s pretend the parities always align to even So it s Apparently the difference is just getting divided by Let s bring the parities back Notice that the rounding of the difference depends only on the parities of and You can consider all cases of parities of and to discover that it s always possible to divide the difference by rounding down and it s never possible to make it less than that One easy algorithm to achieve that is the following if the minimum is even choose otherwise choose Repeat until the minimum is equal to the maximum Overall complexity per testcase 
Several days ago you bought a new house and now you are planning to start a renovation Since winters in your region can be very cold you need to decide how to heat rooms in your house Your house has n rooms In the i th room you can install at most c i heating radiators Each radiator can have several sections but the cost of the radiator with k sections is equal to k 2 burles Since rooms can have different sizes you calculated that you need at least sum i sections in total in the i th room For each room calculate the minimum cost to install at most c i radiators with total number of sections not less than sum i ,"['#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int n;\n    scanf(""%d"", &n);\n    for (int i = 1; i <= n; i++) {\n        int c, sum;\n        scanf(""%d %d"", &c, &sum);\n        int m = sum / c;\n        printf(""%d\\n"", m * m * (c - sum % c) + (m + 1) * (m + 1) * (sum % c));\n    }\n}']","[0, 1, 0, 0, 0]",1000,Let s denote the number of sections in the th radiator as Let s prove that in the optimal answer Proof by contradiction suppose we have and in the answer let s move from to and check The answer is not optimal contradiction Finally there is the only way to take with And it s to take elements with value and elements with 
Tim is doing a test consisting of 4n questions each question has 4 options and For each option there are exactly n correct answers corresponding to that option meaning there are n questions with the answer n questions with the answer n questions with the answer and n questions with the answer For each question Tim wrote his answer on the answer sheet If he could not figure out the answer he would leave a question mark for that question You are given his answer sheet of 4n characters What is the maximum number of correct answers Tim can get ,"['#include <bits/stdc++.h>#define pb push_back#define sz(a) ((int)a.size())#define re return#define all(a) a.begin(),a.end()#define rept(i,a,b) for(int i=(a);i<(b);i++)#define rep(i,a) rept(i,0,a)#define vi vector<int>#define pii pair<int,int>#define F first#define S second#define de(x) cout<<#x<<""=""<<x<<""\\n"";#define int long long#define il inline#define db double#define ld long dbusing namespace std;const int MOD=998244353,INF=1000000000000000000;template<typename T>inline void Mx(T &a,T b){a=max(a,b);}template<typename T>inline void Mi(T &a,T b){a=min(a,b);}void FILEIO(string s){\tfreopen((s+"".in"").c_str(),""r"",stdin);\tfreopen((s+"".out"").c_str(),""w"",stdout);}void run(){\tint n;\tstring s;\tcin>>n>>s;\tint ca=0,cb=0,cc=0,cd=0;\tfor(char c:s){\t\tif(c==\'A\')ca++;\t\tif(c==\'B\')cb++;\t\tif(c==\'C\')cc++;\t\tif(c==\'D\')cd++;\t}\tcout<<min(n,ca)+min(n,cb)+min(n,cc)+min(n,cd)<<""\\n"";}signed main(){\tios::sync_with_stdio(0);\tcin.tie(0);cout.tie(0);\tint T=1;\tcin>>T;\twhile(T--)\t\trun();\tre 0;}']","[1, 0, 1, 0, 0]",800,SolutionLet s say there are problems take as the answer therefore he can only get points with the answer The same is correct for and Therefore the maximum score can be achieved is Time complexity 
A batch of n goods n an even number is brought to the store i th of which has weight a i Before selling the goods they must be packed into packages After packing the following will be done There will be frac n 2 packages each package contains exactly two goods The weight of the package that contains goods with indices i and j 1 le i j le n is a i a j With this the cost of a package of weight x is always left lfloor frac x k right rfloor burles rounded down where k a fixed and given value Pack the goods to the packages so that the revenue from their sale is maximized In other words make such frac n 2 pairs of given goods that the sum of the values left lfloor frac x i k right rfloor where x i is the weight of the package number i 1 le i le frac n 2 is For example let n 6 k 3 weights of goods a 3 2 7 1 4 8 Let s pack them into the following packages In the first package we will put the third and sixth goods Its weight will be a 3 a 6 7 8 15 The cost of the package will be left lfloor frac 15 3 right rfloor 5 burles In the second package put the first and fifth goods the weight is a 1 a 5 3 4 7 The cost of the package is left lfloor frac 7 3 right rfloor 2 burles In the third package put the second and fourth goods the weight is a 2 a 4 2 1 3 The cost of the package is left lfloor frac 3 3 right rfloor 1 burle With this packing the total cost of all packs would be 5 2 1 8 burles ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int inf = 1'000'000'001;\nconst int infll = (inf - 1) * (inf - 1) + 1;\nconst int mod = inf + 6;\nvoid solve(){\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    vector<vector<int>> sum(k);\n    vector<pair<int, int>> dq;\n    for(int i = 0;i < n;i++){\n        cin >> a[i];\n        sum[a[i] % k].push_back(a[i] / k);\n    }\n    int ans = 0;\n    int ptrl = 1;\n    for(int i = k - 1;i >= 0;i--){\n        while(ptrl < (k - i)){\n            ptrl++;\n        }\n        while(ptrl <= i && (sum[i]).size() > 0){\n            while(ptrl < k && sum[ptrl].size() == 0)ptrl++;\n            if(ptrl > i)break;\n            if(i == ptrl && (sum[i]).size() == 1){\n                ptrl++;\n                break;\n            }\n            int last = sum[i].back();\n            sum[i].pop_back();\n            int lastl = sum[ptrl].back();\n            sum[ptrl].pop_back();\n            ans += last + lastl + 1;\n        }\n        if(ptrl > i)break;\n    }\n    for(int i = 0;i < k;i++){\n        for(auto v: sum[i]){\n            ans += v;\n        }\n    }\n    cout << ans << endl;\n}\nint32_t main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n}""]","[1, 1, 0, 0, 0]",1500,Note that we do not need to consider the numbers we are only interested in the remainder of the division of by and we simply add the value to the answer We get an array where Let s sort it and greedily type index pairs such that This can be done with two pointers Then add the number of matching pairs to the answer counter This will be the answer to the problem 
Petya has a rooted tree with an integer written on each vertex The vertex 1 is the root You are to answer some questions about the tree A tree is a connected graph without cycles A rooted tree has a special vertex called the root The parent of a node v is the next vertex on the shortest path from v to the root Each question is defined by three integers v l and k To get the answer to the question you need to perform the following steps First write down the sequence of all integers written on the shortest path from the vertex v to the root including those written in the v and the root Count the number of times each integer occurs Remove all integers with less than l occurrences Replace the sequence removing all duplicates and ordering the elements by the number of occurrences in the original list in increasing order In case of a tie you can choose the order of these elements arbitrary The answer to the question is the k th number in the remaining sequence Note that the answer is not always uniquely determined because there could be several orderings Also it is possible that the length of the sequence on this step is less than k in this case the answer is 1 For example if the sequence of integers on the path from v to the root is 2 2 1 7 1 1 4 4 4 4 l 2 and k 2 then the answer is 1 Please answer all questions about the tree ,"['#pragma GCC optimize(2,3,""Ofast"")\n#pragma GCC target(""avx"",""avx2"")\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define pb push_back\n#define fir first\n#define sec second\n#define SZ(x) (int(x.size()))\ninline int read(){\n    int x=0;char ch=getchar();\n    int f=0;\n    while(!isdigit(ch))f|=ch==\'-\',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-\'0\',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar(\'-\'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+\'0\');\n}\ntemplate<typename T>void print(T x,char let){\n    print(x),putchar(let);\n}\ntemplate<typename T1,typename T2>void ckmin(T1&x,T2 y){\n    if(x>y)x=y;\n}\ntemplate<typename T1,typename T2>void ckmax(T1&x,T2 y){\n    if(x<y)x=y;\n}\n\nconst int N=1000005;\n\nstruct Info{int l,k,id;};\nvector<Info>ask[N];\n\nvector<int>adj[N];\nint n,m;\nint a[N],ans[N];\n\nset<int>who[N];\nint times[N],all;\n\nstruct fen{\n    int c[N];\n    void add(int x,int dlt){\n        if(!x)return; \n        while(x<=n){\n            c[x]+=dlt;\n            x+=x&-x;\n        }\n    }    \n    int qry(int x){\n        int ret=0;\n        while(x){\n            ret+=c[x];\n            x^=x&-x; \n        }\n        return ret;\n    }\n    int query(int rk){\n        int x=0;\n        for(int i=19;i>=0;i--){\n            if(x+(1<<i)<=n&&c[x+(1<<i)]<rk)\n                x+=(1<<i),rk-=c[x];\n        }\n        return x+1;\n    }\n}tr;\n\nvoid dfs(int u,int fa){\n    \n//    printf(""now dfs %d\\n"",u);\n    \n//    all++;\n    who[ times[a[u]] ].erase(a[u]);\n    tr.add(times[a[u]], -1);\n    times[a[u]]++;\n    who[ times[a[u]] ].insert(a[u]);\n    tr.add(times[a[u]], 1);\n    \n//    printf(""ok!\\n"");\n    \n    for (auto &it:ask[u]){\n        int qaq=tr.qry(it.l-1);\n        it.k+=qaq;\n//        printf(""id=%d,it.k=%d\\n"",it.id,it.k);\n//        printf(""all=%d\\n"",tr.qry(n));\n        if(it.k>tr.qry(n))ans[it.id]=-1;\n        else {\n            int tmp=tr.query(it.k);\n            assert(SZ(who[tmp]));\n            ans[it.id]=*who[tmp].begin();\n        }\n    }\n    \n//    printf(""ask ok!\\n"");\n    \n    for(auto v:adj[u]){\n        if(v==fa)continue;\n        dfs(v,u);\n    }\n    \n//    all--;\n    who[ times[a[u]] ].erase(a[u]);\n    tr.add(times[a[u]], -1);\n    times[a[u]]--;\n    who[ times[a[u]] ].insert(a[u]);\n    tr.add(times[a[u]], 1);\n}\nvoid solve(){\n    n=read(),m=read();\n    rep(i,1,n)adj[i].clear();\n    rep(i,1,n)ask[i].clear();\n    rep(i,1,n)a[i]=read();\n    rep(i,2,n){\n        int fa=read();\n        adj[fa].pb(i);\n    }\n    rep(i,1,m){\n        int u=read(),l=read(),k=read();\n        ask[u].pb({l,k,i});\n    }\n    dfs(1,0);\n    rep(i,1,m){\n        print(ans[i],"" \\n""[i==m]);\n    }    \n}\n\nint main(){\n    int T=read();\n    while(T--){\n        solve();\n    }\n    return 0;\n}']","[0, 0, 0, 0, 1]",2400,Let s traverse through the tree with depth first search from the root and maintain counting array cntx number of occasions of x in the sequence When dfs enters vertex v it increases cntav by 1 then it proceeds all queries correspondent to v When dfs leaves the vertex it decreases cntav by 1 Let s maintain this quantities Sorting permuation p of cnt initially 1 2 n Inverse permuation p 1 For each x 0 1 n lower bound lbx in sorted array More formally minimal i such that cntpi x When we want to increase cntx by 1 Move x in the end of block of same values in sorted array So we need to swap p 1i th and lbcntx 1 1 th positions of p Change p 1 accrodingly to the change of p Decrease lbcntx 1 by 1 Note that s the only lb value that after during this operation Increase cntx Operation of decreasing cntx by 1 can be done symmetrically Note if answer exists then one of possible answers is plbl k 1 Total complexity O n q 
Your friend Ivan asked you to help him rearrange his desktop The desktop can be represented as a rectangle matrix of size n times m consisting of characters empty cell of the desktop and an icon The desktop is called if all its icons are occupying some prefix of full columns and possibly the prefix of the next column and there are no icons outside this figure In other words some amount of first columns will be filled with icons and possibly some amount of first cells of the next after the last full column column will be also filled with icons and all the icons on the desktop belong to this figure This is pretty much the same as the real life icons arrangement In one move you can take one icon and move it to any empty cell in the desktop Ivan loves to add some icons to his desktop and remove them from it so he is asking you to answer q queries what is the number of moves required to make the desktop after adding removing one icon Note that and change the state of the desktop ,"['#include ""bits/stdc++.h""\n \nusing namespace std;\n \nusing ll = long long;\nconst ll inf = 1e9;\nconst int md1 = 1e9+7;\nconst int md2 = 1e9+9;\n \n#define all(v)                      v.begin(), v.end()\n#define rall(v)                     v.rbegin(), v.rend()\n#define sz(v)                       ((int)v.size())\n \n#define forn(i,n)                   for(int i = 0; i < n; ++i)\n#define forbe(i,b,e)                for(int i = b; i < e; ++i)\n \n#define pb                          push_back\n \n#define pry                         puts(""YES"")\n#define prn                         puts(""NO"")\n#define endl                        \'\\n\'\n \n#define fst                         first\n#define scn                         second\n \n#define c(x)                        (ll)(x-\'a\')\n \nconst int N=1005;\nchar c[N][N];\n\ntemplate<typename T>\nstruct FenwickTree2D{\n    vector<vector<T>> fen;\n    int n, m;\n    FenwickTree2D(int N, int M){\n        n = N, m = M; \n        fen.assign(n + 1, vector<T>(m + 1 , 0));\n    }\n    void modif(int x, int y, int val){\n        ++x, ++y;\n        for(int i = x;i <= n; i += i & -i){\n            for(int j = y;j <= m; j += j & -j){\n                fen[i][j] += val;\n            }\n        }\n    }\n\n    T query(int x, int y) {\n        ++x, ++y;\n        T ret = 0;\n        for(int i = x; i >= 1;i -= i & -i)\n            for(int j = y;j >= 1;j -= j & -j)\n                ret += fen[i][j];\n        return ret;\n    }\n    T query(int x1, int y1, int x2, int y2) {\n        return query(x2, y2) - query(x2, y1 - 1) - query(x1 - 1, y2) + query(x1 - 1, y1 - 1);\n    }\n};\n\nvoid solve(){\n    int n,m,q;\n    cin>>n>>m>>q;\n    FenwickTree2D<long long> st(n + 1, m + 1);\n    forn(i,n){\n        forn(j,m){\n            cin>>c[i][j];\n            if(c[i][j]==\'*\')st.modif(i,j,1);\n        }\n    }\n\n    while(q--) {\n        int x,y;\n        cin>>x>>y;\n        --x,--y;\n        if(c[x][y]==\'*\'){\n            st.modif(x,y,-1);\n            c[x][y]=\'.\';\n        }else{\n            st.modif(x,y,1);\n            c[x][y]=\'*\';\n        }\n\n        long long total = st.query(0,0,n-1,m-1);\n        long long complete = total/n;\n        long long remaining = total - complete*n;\n        long long ans = complete * n + remaining;\n        if(complete)ans-=st.query(0,0,n-1,complete-1);\n        if(remaining)ans-=st.query(0,complete,remaining-1, complete);\n        cout <<ans<<endl;\n    }\n}\n \nint32_t main(){\n    ios_base::sync_with_stdio(0);cin.tie(0);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();\n    }\n}']","[1, 0, 1, 0, 1]",1800,I ve seen a lot of data structures solutions for this problem but author s solution doesn t use them and works in Firstly let s change our matrix to a string because it will be easier to work with a string than with a matrix The order of characters will be from top to bottom from left to right i e the outer cycle by columns and the inner by rows Then let s calculate the number of icons on the desktop the number of in Then the answer will be obviously the number of dots on the prefix of of size Now let s deal with queries It can be shown that one query changes our answer by no more than Let be the position of the cell that is being changed in zero indexed Then if there are two cases If is then we have one more icon on our prefix so the answer decreases by one because we filled one empty space in the good desktop Otherwise it increases by one because this icon is outside our prefix Then let s change the corresponding character by the opposite After that we should move our right border accordingly to the new number of icons Note that this border is exclusive If becomes then we will increase the variable But before that if is then there should be an icon and it is not here yet so the answer increases Otherwise our border will decrease Then if is then the answer decreases because there was a place for an icon and now it is not needed anymore Time complexity 
Furik loves math lessons very much so he doesn t attend them unlike Rubik But now Furik wants to get a good mark for math For that Ms Ivanova his math teacher gave him a new task Furik solved the task immediately Can you You are given a set of digits your task is to find the maximum integer that you can make from these digits The made number must be divisible by without a residue It is permitted to use not all digits from the set it is forbidden to use leading zeroes Each digit is allowed to occur in the number the same number of times it occurs in the set ,"['#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\nint N;\nint D[100000];\n\nvoid output(int x1, int x2) {\n  bool nonzero = 0;\n  for (int i = 0; i < N; i++) {\n    if (i == x1 || i == x2) continue;\n    if (D[i] == 0) {\n      if (nonzero) cout << D[i];\n    }\n    else {\n      nonzero = 1;\n      cout << D[i];\n    }\n  }\n  if (!nonzero) cout << 0;\n  cout << ""\\n"";\n}\n\nint main() {\n  cin >> N;\n  for (int i = 0; i < N; i++) cin >> D[i];\n  sort(D, D+N); reverse(D, D+N);\n\n  if (D[N-1] != 0) {\n    cout << -1 << ""\\n"";\n    return 0;\n  }\n\n  int alls = 0;\n  vector<int> zero, one, two;\n  for (int i = 0; i < N; i++) {\n    alls += D[i];\n    if (D[i] % 3 == 0) zero.push_back(i);\n    if (D[i] % 3 == 1) one.push_back(i);\n    if (D[i] % 3 == 2) two.push_back(i);\n  }\n\n  bool nonzero = 0; \n  if (alls % 3 == 0) output(-1,-1);\n  else if (alls % 3 == 1) {\n    if (one.size() > 0) {\n      output(one.back(), -1);\n    }\n    else if (two.size() > 1) {\n      output(two[two.size()-2], two[two.size()-1]);\n    }\n  }\n  else if (alls % 3 == 2) {\n    if (two.size() > 0) {\n      output(two.back(), -1);\n    }\n    else if (one.size() > 1) {\n      output(one[one.size()-2], one[one.size()-1]);\n    }\n  }\n}\n']","[1, 1, 0, 0, 0]",1600,Nuber is divisible by 2 3 5 only if sum of the digits is divisible by 3 and last digit is 0 so if we havent 0 in our set answer is 1 otherwise solution exists we can return 0 as solution A further solution analysis of the cases Lets sort all didgits in nonincreasing order If sum of all digits is divisible by 3 answer is our set of digits without spaces ofcourse If modulo equals 1 we must delete minimum digit from out set with modulo after division by 3 equals 1 if we haven t such we must delete 2 minimal digits with modulo after division by 3 equals 2 If we have modulo equals 2 we have identical case Also we must remember that we cannot use leading zeros In case when we have more then one 0 and no another digit we must print only one zero 
Consider an infinite triangle made up of layers Let s number the layers starting from one from the top of the triangle from top to bottom The k th layer of the triangle contains k points numbered from left to right Each point of an infinite triangle is described by a pair of numbers r c 1 le c le r where r is the number of the layer and c is the number of the point in the layer From each point r c there are two edges to the points r 1 c and r 1 c 1 but only one of the edges is activated If r c is even then the edge to the point r 1 c is activated otherwise the edge to the point r 1 c 1 is activated Look at the picture for a better understanding From the point r 1 c 1 it is possible to reach the point r 2 c 2 if there is a path between them only from edges For example in the picture above there is a path from 1 1 to 3 2 but there is no path from 2 1 to 1 1 Initially you are at the point 1 1 For each turn you can Replace activated edge for point r c That is if the edge to the point r 1 c is activated then the edge to the point r 1 c 1 becomes activated otherwise if the edge to the point r 1 c 1 then the edge to the point r 1 c becomes activated This action increases the cost of the path by 1 Move from the current point to another by following the activated edge This action the cost of the path You are given a sequence of n points of an infinite triangle r 1 c 1 r 2 c 2 ldots r n c n Find the minimum cost path from 1 1 passing through all n points in order ,"['#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\npair <int,int> a[200005];\nint main(int argc, char** argv) {\n\tint T;\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=1;i<=n;i++) cin >> a[i].first;\n\t\tfor(int i=1;i<=n;i++) cin >> a[i].second;\n\t\tsort(a+1,a+n+1);\n\t\tint ans=0;\n\t\ta[0]={1,1};\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif((a[i+1].second-a[i].second)==(a[i+1].first-a[i].first))\n\t\t\t{\n\t\t\t\tif(a[i].first+a[i].second&1) ans+=0;\n\t\t\t\telse ans+=a[i+1].second-a[i].second;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint lst=a[i].first-a[i].second,nxt=a[i+1].first-a[i+1].second;\n\t\t\t\tif(lst%2==0) ++lst;\n\t\t\t\tif(nxt%2==0) ++nxt;\n\t\t\t\tans+=(nxt-lst)/2;\n\t\t\t}\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",2000,Since all edges are directed downward there is only one way to visit all points is to visit the points in ascending order of the layer number Let s sort the points in order of increasing layer It is easy to see that the cost of the entire path is equal to the sum of the cost of paths between adjacent points Let s learn how to calculate the cost of a path between two points and If then if is even then the cost is otherwise the cost is Otherwise move the point to and find the cost of the path with different criteria for the activation of the edges If is even then the cost is Otherwise the cost is 
Slavic is preparing a present for a friend s birthday He has an array a of n digits and the present will be the product of all these digits Because Slavic is a good kid who wants to make the biggest product possible he wants to add 1 to exactly one of his digits What is the maximum product Slavic can make ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define vec vector\n#define read(x) for (auto &zu: (x)) cin >> zu;\n#define F first\n#define S second\n#define pb push_back\n#define eb emplace_back\n#define print(x, sep) {for(auto &zu: (x))cout << zu << (sep);cout << ""\\n"";}\n#define len(x) (long long)((x).size())\n#define magic ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr)\n#define sep << "" "" <<\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing str = string;\nusing pii = pair<int, int>;\nusing ld = long double;\n\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n\nostream &operator <<(ostream &os, pii a){\n    return os << a.F sep a.S;\n}\n\nll inf = 1e18;\n\nvoid fa(bool ok){ cout << (ok ? ""YES"": ""NO"") << ""\\n""; }\n\n\nvoid solve(){\n    int n; cin >> n;\n    vi a(n); read(a);\n    int mn = *min_element(all(a));\n    for(auto &i: a){\n        if(i == mn){\n            i++;\n            break;\n        }\n    }\n    int ans = 1;\n    for(auto &i: a)ans *= i;\n    cout << ans << ""\\n"";\n}\n\nsigned main(){\n    magic;\n    int t = 1;\n    cin >> t;\n    while (t--){\n        solve();\n    }\n    return 0;\n\n}\n']","[1, 1, 0, 0, 0]",800,Just brute force all possibilties for the digit to increase and check the product each time The complexity is per testcase You can make it faster if you notice that it s always optimal to increase the smallest digit why but it wasn t necessary to pass 
This competition consists of two part swimming and then running People will immediately start running meters after they finished swimming exactly meters A winner is a such person that nobody else finishes running before him her there may be more than one winner Before the match starts Tavas knows that there are competitors registered for the match Also he knows that th person s swimming speed is meters per second and his her running speed is meters per second Unfortunately he doesn t know the values of and but he knows that they are real numbers greater than As a cheerleader Tavas wants to know who to cheer up So he wants to know all people that might win We consider a competitor might win if and only if there are some values of and such that with these values s he will be a winner Tavas isn t really familiar with programming so he asked you to help him ,"['#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<string>\n#include<queue>\n#include<map>\ntypedef long long ll;\n#define mo 1000000007\nvoid gn(int &x){\n    char c;while((c=getchar())<\'0\'||c>\'9\');x=c-\'0\';\n    while((c=getchar())>=\'0\'&&c<=\'9\')x=x*10+c-\'0\';\n}\nint qp(int a,ll b){\n    int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;\n}\nusing namespace std;\nint n;\nstruct ren{\n    int id,k,b;\n}a[222222];\nint cmp(const ren &x,const ren&y){\n    if(x.k==y.k)return x.b>y.b;\n    return x.k<y.k;\n}\nint ok[222222]={0};\nint stk[222222],top;\n\n\n#define b1 (a[stk[top-1]].b)\n#define b2 (a[stk[top]].b)\n#define b3 (a[i].b)\n#define k1 (a[stk[top-1]].k)\n#define k2 (a[stk[top]].k)\n#define k3 (a[i].k)\nint main()\n{\n    scanf(""%d"",&n);\n    for (int i=1;i<=n;i++)scanf(""%d%d"",&a[i].k,&a[i].b),a[i].id=i;\n    sort(a+1,a+1+n,cmp);\n    top=0;\n    for (int i=1;i<=n;i++){\n        if(i>1 && a[i].k==a[i-1].k)continue;\n        while(top>=2 && 1ll*(b1*b2-b1*b3)*(k2*k3-k1*k3)<1ll*(b1*b3-b2*b3)*(k1*k3-k1*k2))top--;\n        stk[++top]=i;\n    }\n    for (int i=1;i<=top;i++)ok[a[stk[i]].id]=1;\n    for (int i=1;i<top;i++){\n        if(a[stk[i]].b<=a[stk[i+1]].b)ok[a[stk[i]].id]=0;\n        else break;\n    }\n    for (int i=2;i<=n;i++){\n        if(a[i].k==a[i-1].k && a[i].b==a[i-1].b && ok[a[i-1].id])ok[a[i].id]=1;\n    }\n    for (int i=1;i<=n;i++){\n        if(ok[i])printf(""%d "",i);\n    }\n    putchar(\'\\n\');\n    return 0;\n}\n\n\n\n']","[0, 1, 0, 0, 0]",2600,For each competitor put the point in the Cartesian plane So the time a competitor finishes the match is Determine their convex hull with maximum number of points i e it doesn t matter to have radians angle Let be the leftmost point on this convex hull if there are more than one choose the one with minimum component Similarly let be the point with minimum component on this convex hull if there are more than one consider the leftmost Proof is the scalar product that is smaller if the point is farther in the direction of It s obvious that the farthest points in some direction among the given set lie on a convex hull can get any value that is vector in first quadrant So we need the points on the convex hull that we actually calculate also we know that the points on the right or top of the convex hull are not in the answer because they re always losers It s easy to see that the answer is the points on the path from to on the convex hull bottom left arc i e the bottom left part of the convex hull Time complexity In this problem we recommend you to use integers How Look at the code below Code by PrinceOfPersia In this code function CROSS returns it s from order of so there won t be any overflows In double version you should have a very small epsilon Code of double version by PrinceOfPersia Another Code With Lower Envelope of Lines by Haghani Java Code by Zlobober 
There are n digital panels placed in a straight line Each panel can show any digit from 0 to 9 Initially all panels show 0 Every second the digit shown by each panel increases by 1 In other words at the end of every second a panel that showed 9 would now show 0 a panel that showed 0 would now show 1 a panel that showed 1 would now show 2 and so on When a panel is paused the digit displayed on the panel does not change in the subsequent seconds You must pause exactly one of these panels at any second you wish Then the panels adjacent to it get paused one second later the panels adjacent to those get paused 2 seconds later and so on In other words if you pause panel x panel y for all valid y would be paused exactly x y seconds later For example suppose there are 4 panels and the 3 rd panel is paused when the digit 9 is on it The panel 1 pauses 2 seconds later so it has the digit 1 the panel 2 pauses 1 second later so it has the digit 0 the panel 4 pauses 1 second later so it has the digit 0 The resulting 4 digit number is 1090 Once all panels have been paused you write the digits displayed on them from left to right to form an n digit number it can consist of leading zeros What is the largest possible number you can get Initially all panels show 0 ,"['// author: xay5421\n// created: Fri Jan  8 23:35:46 2021\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nint T,n;\nint main(){\n\tscanf(""%d"",&T);\n\twhile(T--){\n\t\tscanf(""%d"",&n);\n\t\tint x=9;\n\t\trep(i,1,n){\n\t\t\tif(i==3)x=9;\n\t\t\tprintf(""%d"",x);\n\t\t\tif(i<3)x=x-1;\n\t\t\telse x=x+1;\n\t\t\tif(x<0)x=9;\n\t\t\tif(x>9)x=0;\n\t\t}\n\t\tputs("""");\n\t}\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0]",900,If there is only one panel then pause it when digit appears on it You cannot do any better than that Otherwise it is always optimal to pause the second panel from left when the digit appears on it This would give an answer of the form You can verify that this is the largest number that can be achieved 
A conspiracy of ancient sages who decided to redirect rivers for their own convenience has put the world on the brink But before implementing their grand plan they decided to carefully think through their strategy that s what sages do There are n countries each with exactly k regions For the j th region of the i th country they calculated the value a i j which reflects the amount of water in it The sages intend to create channels between the j th region of the i th country and the j th region of the i 1 th country for all 1 leq i leq n 1 and for all 1 leq j leq k Since all n countries are on a large slope water flows towards the country with the highest number According to the sages predictions after the channel system is created the new value of the j th region of the i th country will be b i j a 1 j a 2 j a i j where denotes the bitwise OR operation After the redistribution of water the sages aim to choose the most suitable country for living so they will send you q queries for consideration Each query will contain m requirements Each requirement contains three parameters the region number r the sign o either or and the value c If o then in the r th region of the country you choose the new value must be strictly less than the limit c and if o it must be strictly greater In other words the chosen country i must satisfy all m requirements If in the current requirement o then it must hold that b i r c and if o then b i r c In response to each query you should output a single integer the number of the suitable country If there are multiple such countries output the smallest one If no such country exists output 1 ,"['#include <iostream>#include <cmath>#include <vector>#include <algorithm>#include <map>#include <set>#include <bitset>#include <queue>#define ff first#define ss secondtypedef long long ll;using namespace std;void solve() {\tint n, k, q;\tcin >> n >> k >> q;\tvector<vector<int>> a(n + 1);\tfor (auto &it : a) {\t\tit.resize(k + 1);\t}\tfor (int i = 1; i <= n; i++) {\t\tfor (int j = 1; j <= k; j++) {\t\t\tcin >> a[i][j];\t\t\ta[i][j] |= a[i - 1][j];\t\t}\t}\twhile (q--) {\t\tint u;\t\tcin >> u;\t\tint cur_l = 1, cur_r = n;\t\tbool ch = true;\t\twhile (u--) {\t\t\tint r;\t\t\tchar o;\t\t\tint c;\t\t\tcin >> r >> o >> c;\t\t\tif (o == \'>\' && ch) {\t\t\t\tint lll = cur_l, rrr = cur_r, ans = -1;\t\t\t\twhile (lll <= rrr) {\t\t\t\t\tint mid = (lll + rrr) / 2;\t\t\t\t\tif (a[mid][r] > c) {\t\t\t\t\t\tans = mid;\t\t\t\t\t\trrr = mid - 1;\t\t\t\t\t}\t\t\t\t\telse lll = mid + 1;\t\t\t\t}\t\t\t\tif (ans == -1) {\t\t\t\t\tch = false;\t\t\t\t}\t\t\t\telse cur_l = ans;\t\t\t}\t\t\telse if (ch) {\t\t\t\tint lll = cur_l, rrr = cur_r, ans = -1;\t\t\t\twhile (lll <= rrr) {\t\t\t\t\tint mid = (lll + rrr) / 2;\t\t\t\t\tif (a[mid][r] < c) {\t\t\t\t\t\tans = mid;\t\t\t\t\t\tlll = mid + 1;\t\t\t\t\t}\t\t\t\t\telse rrr = mid - 1;\t\t\t\t}\t\t\t\tif (ans == -1) {\t\t\t\t\tch = false;\t\t\t\t}\t\t\t\telse cur_r = ans;\t\t\t}\t\t\t\t}\t\tif (ch) cout << cur_l << ""\\n"";\t\telse cout << -1 << ""\\n"";\t}}int main() {\tint t = 1;\twhile (t--) {\t\tsolve();\t}}']","[1, 0, 0, 0, 1]",1600,TutorialAfter computing the values of for all countries and regions we can notice that for a fixed region the values of increase as the index increases This is because the bitwise or operation cannot decrease a number but only increase or leave it unchanged Hence we can use binary search to quickly find the country that matches the given conditions For each query and for each requirement if we search for the first country where this will be the first country that does not satisfy the condition If sign we look for the first country where In both cases we can use standard binary search to find the index If the checks leave at least one country that satisfies all the requirements we choose the country with the lowest number Complexity counting values processing each query using binary search total 
 You are given a permutation p 1 p 2 ldots p n of integers from 1 to n Let s define the weight of the permutation q 1 q 2 ldots q n of integers from 1 to n as q 1 p q 2 q 2 p q 3 ldots q n 1 p q n q n p q 1 You want your permutation to be as lightweight as possible Among the permutations q with the smallest possible weight find the lexicographically smallest Permutation a 1 a 2 ldots a n is lexicographically smaller than permutation b 1 b 2 ldots b n if there exists some 1 le i le n such that a j b j for all 1 le j i and a i b i ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    DSU(int n) : f(n), siz(n, 1) { std::iota(f.begin(), f.end(), 0); }\n    int leader(int x) {\n        while (x != f[x]) x = f[x] = f[f[x]];\n        return x;\n    }\n    bool same(int x, int y) { return leader(x) == leader(y); }\n    bool merge(int x, int y) {\n        x = leader(x);\n        y = leader(y);\n        if (x == y) return false;\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    int size(int x) { return siz[leader(x)]; }\n};\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> p(n), h(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> p[i];\n        p[i]--;\n        h[p[i]] = i;\n    }\n    \n    DSU dsu(n);\n    std::vector<bool> vis(n);\n    for (int i = 0; i < n; i++) {\n        if (vis[i]) {\n            continue;\n        }\n        for (int j = i; !vis[j]; j = p[j]) {\n            vis[j] = true;\n            dsu.merge(j, i);\n        }\n    }\n    // for (int i = 0; i + 1 < n; i++) {\n    //     if (!dsu.same(i, i + 1)) {\n    //         int x = h[i];\n    //         int y = h[i + 1];\n    //         std::swap(p[x], p[y]);\n    //         std::swap(h[i], h[i + 1]);\n    //         dsu.merge(i, i + 1);\n    //     }\n    // }\n    \n    std::vector<int> ans(n, -1);\n    \n    auto check = [&]() {\n        DSU g = dsu;\n        \n        std::vector<bool> need(n - 1);\n        for (int i = 0; i < n; i++) {\n            if (ans[i] != -1) {\n                int x = p[ans[i]];\n                if (x < i) {\n                    for (int j = x; j < i; j++) {\n                        need[j] = true;\n                    }\n                } else {\n                    for (int j = i; j < x; j++) {\n                        need[j] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (need[i] && !g.merge(i, i + 1)) {\n                return false;\n            }\n        }\n        \n        std::vector<int> dir(n - 2, -1);\n        std::vector<bool> cant(n - 1);\n        \n        auto work = [&](int x, int d) {\n            if (dir[x] >= 0 && dir[x] != d) {\n                dir[x] = 0;\n            } else {\n                dir[x] = d;\n            }\n        };\n        \n        for (int i = 0; i < n; i++) {\n            if (ans[i] != -1) {\n                int x = p[ans[i]];\n                if (x < i) {\n                    for (int j = x; j + 1 < i; j++) {\n                        work(j, 1);\n                    }\n                    if (x > 0) {\n                        work(x - 1, 2);\n                    }\n                    if (i + 1 < n) {\n                        work(i - 1, 2);\n                    }\n                } else if (x > i) {\n                    for (int j = x - 1; j > i; j--) {\n                        work(j - 1, 2);\n                    }\n                    if (x + 1 < n) {\n                        work(x - 1, 1);\n                    }\n                    if (i > 0) {\n                        work(i - 1, 1);\n                    }\n                } else {\n                    if (x + 1 < n) {\n                        cant[x] = true;\n                    }\n                    if (x > 0) {\n                        cant[x - 1] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int i = 0; i + 2 < n; i++) {\n            if (need[i] && need[i + 1] && dir[i] == 0) {\n                return false;\n            }\n        }\n        for (int i = 0; i + 1 < n; i++) {\n            if (need[i] && cant[i]) {\n                return false;\n            }\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (need[i]) {\n                continue;\n            }\n            if (cant[i]) {\n                continue;\n            }\n            if (i > 0 && dir[i - 1] == 0) {\n                continue;\n            }\n            if (i < n - 2 && dir[i] == 0) {\n                continue;\n            }\n            g.merge(i, i + 1);\n        }\n        for (int i = 0; i < n; i++) {\n            if (!g.same(0, i)) {\n                return false;\n            }\n        }\n        \n        return true;\n    };\n    \n    std::vector<bool> cyc(n);\n    int cnt = 0;\n    for (int i = 0; ; i = ans[i]) {\n        std::cout << i + 1;\n        cyc[i] = true;\n        cnt++;\n        \n        ans[i] = 0;\n        while ((cnt < n && cyc[ans[i]]) || !check()) {\n            ans[i]++;\n        }\n        \n        if (ans[i] == 0) {\n            std::cout << ""\\n"";\n            return;\n        } else {\n            std::cout << "" "";\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[1, 0, 0, 0, 0]",3500,We will start by proving that the weight is at least where is the number of cycles and understanding the structure of optimal permutations in the process Again consider splitting of into cycles where a cycle is an array such that for Let s say there are of such cycles Now consider a graph on nodes and draw an edge from to for each from to there may be self loops and multi edges here Each node has one incoming and outgoing edge so the entire graph is split into several cycles Consider any such cycle where all are distinct Its contribution to the answer is We will show that This value is at least Wlog is the smallest among and is the largest with Then It s only when the numbers on the cycle are some consecutive numbers and are increasing on the path from the smallest number to the largest and decreasing on the way back It s just the case when all the inequalities in the expression above become equalities Now assign each cycle of a number from to and consider the graph on nodes draw an edge between the nodes corresponding to the cycles where and belong As and are in the same cycle for each we get that every two consecutive edges we draw share a node As we will draw an edge from every cycle the graph is connected Each edge in corresponds to an edge in edge between and in corresponds to an edge in between the nodes corresponding to the cycles where and belong Now consider any spanning tree in graph Clearly any cycle of length in can contain at most edges from it if it contained edges from it we would have a cycle in So the total sum of over all cycles in is at least and therefore the total contribution to the weight is at least Now let s give a characterization of all permutations which have the weight It turns out that they are in correspondence with graphs on nodes which satisfy the following conditions Each node has one incoming and one outgoing edge and therefore graph is split into cycles In if a cycle has length then it consists of consecutive integers where numbers go up from the smallest number to the largest and down on the way backThe sum of over all cycles is precisely If we draw an edge between two cycles of if an element of the first cycle is connected to the element of the second cycle in this graph on nodes is connected Each such graph is a corresponding graph of some optimal permutation The proof is left for the reader as an exercise Now how to solve our problem Let s build element by element The weights of all cyclic shifts of the same permutation are the same so we start with Now the only subproblem we have to be able to solve is to check if the current prefix of length is a prefix of some permutation with weight So we have to check if our current edges can be a subset of some graph satisfying all the conditions above Denote these edges If edge has consider segment and call it segment If edge has consider segment and call it segment If call node We can show that the following criteria are sufficient No two right segments intersect internally No two left segments intersect internally No right left segment contains a loop node Consider a graph on nodes corresponding to the cycles of For each if is contained in some segment draw an edge between the corresponding cycles in which are Then this graph can t have a cycle has to be a forest Consider a graph on nodes corresponding to the cycles of For each unless or are loop nodes or is the right end of two segments or is the left end of two segments draw an edge between the corresponding cycles in which are Then this graph must be connected These conditions may sound complicated but they are very simple implications of the conditions on above The proof that if these conditions are satisfied then edges form a subset of some valid is left to the reader as an exercise too tutorial is already too long sorry Total complexity is as we can do up checks and each check takes time 
Given an array a of length n consisting of integers Then the following operation is sequentially applied to it q times Choose indices l and r 1 le l le r le n and an integer x Add x to all elements of the array a in the segment l r More formally assign a i a i x for all l le i le r Let b j be the array a obtained after applying the first j operations 0 le j le q Note that b 0 is the array a before applying any operations You need to find the lexicographically minimum dagger array among all arrays b j dagger An array x is lexicographically smaller than array y if there is an index i such that x i y i and x j y j for all j i In other words for the first index i where the arrays differ x i y i ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class Info, class Tag>\nstruct LazySegmentTree {\n    int n;\n    std::vector<Info> info;\n    std::vector<Tag> tag;\n    LazySegmentTree() : n(0) {}\n    LazySegmentTree(int n_, Info v_ = Info()) {\n        init(n_, v_);\n    }\n    template<class T>\n    LazySegmentTree(std::vector<T> init_) {\n        init(init_);\n    }\n    void init(int n_, Info v_ = Info()) {\n        init(std::vector(n_, v_));\n    }\n    template<class T>\n    void init(std::vector<T> init_) {\n        n = init_.size();\n        info.assign(4 << std::__lg(n), Info());\n        tag.assign(4 << std::__lg(n), Tag());\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init_[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = info[2 * p] + info[2 * p + 1];\n    }\n    void apply(int p, const Tag &v) {\n        info[p].apply(v);\n        tag[p].apply(v);\n    }\n    void push(int p) {\n        apply(2 * p, tag[p]);\n        apply(2 * p + 1, tag[p]);\n        tag[p] = Tag();\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        push(p);\n        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n    void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {\n        if (l >= y || r <= x) {\n            return;\n        }\n        if (l >= x && r <= y) {\n            apply(p, v);\n            return;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        rangeApply(2 * p, l, m, x, y, v);\n        rangeApply(2 * p + 1, m, r, x, y, v);\n        pull(p);\n    }\n    void rangeApply(int l, int r, const Tag &v) {\n        return rangeApply(1, 0, n, l, r, v);\n    }\n    template<class F>\n    int findFirst(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        int res = findFirst(2 * p, l, m, x, y, pred);\n        if (res == -1) {\n            res = findFirst(2 * p + 1, m, r, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findFirst(int l, int r, F pred) {\n        return findFirst(1, 0, n, l, r, pred);\n    }\n    template<class F>\n    int findLast(int p, int l, int r, int x, int y, F pred) {\n        if (l >= y || r <= x || !pred(info[p])) {\n            return -1;\n        }\n        if (r - l == 1) {\n            return l;\n        }\n        int m = (l + r) / 2;\n        push(p);\n        int res = findLast(2 * p + 1, m, r, x, y, pred);\n        if (res == -1) {\n            res = findLast(2 * p, l, m, x, y, pred);\n        }\n        return res;\n    }\n    template<class F>\n    int findLast(int l, int r, F pred) {\n        return findLast(1, 0, n, l, r, pred);\n    }\n};\n\nconstexpr i64 inf = 1E18;\nstruct Tag {\n    i64 add = 0;\n    void apply(const Tag &t) {\n        add += t.add;\n    }\n};\nstruct Info {\n    i64 min = inf;\n    i64 max = -inf;\n    void apply(const Tag &t) {\n        min += t.add;\n        max += t.add;\n    }\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    return {std::min(a.min, b.min), std::max(a.max, b.max)};\n}\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int q;\n    std::cin >> q;\n    \n    std::vector<std::vector<std::pair<int, int>>> add(n);\n    for (int i = 1; i <= q; i++) {\n        int l, r, x;\n        std::cin >> l >> r >> x;\n        l--;\n        add[l].emplace_back(i, x);\n        if (r < n) {\n            add[r].emplace_back(i, -x);\n        }\n    }\n    \n    LazySegmentTree<Info, Tag> seg(q + 1, Info{0, 0});\n    for (int i = 0; i < n; i++) {\n        for (auto [l, x] : add[i]) {\n            seg.rangeApply(l, q + 1, {x});\n        }\n        i64 v = seg.rangeQuery(0, q + 1).min;\n        std::cout << v + a[i] << "" \\n""[i == n - 1];\n        while (true) {\n            int j = seg.findFirst(0, q + 1,\n                [&](const Info &info) {\n                    return info.max > v;\n                });\n            if (j == -1) {\n                break;\n            }\n            seg.modify(j, {});\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[1, 0, 0, 0, 1]",2400,Let be a difference array of an array i e for all Note that minimizing an array is equivalent to minimizing its difference array Let s see how the difference array changes when asked adding the number on the segment only 2 elements are updated in it is added to the th index and is subtracted from the th index Let s learn how to compare difference arrays after the th and th queries Let s consider an auxiliary array which is a union of changes in the difference array for all queries with numbers from to inclusive Consider in this auxiliary array the minimum non zero element by index Note that if it is negative then the difference array after the th query will be smaller than after the th one and if it is positive then it will be larger Let s go through the queries and maintain the number of the minimum difference array Let the current minimum difference array after request be number Since changes to the difference array occur only in two indexes we can maintain them in a dictionary containing changes to the difference array by index When we want to process the next request we update the values in the dictionary using two keys After the change you need to check the sign of the minimum non zero element by index If it is negative then this means that the current request has updated the minimum and we clear the dictionary so that we can now store changes relative to this request in it If it is positive then we leave the dictionary the same and continue to change it in subsequent queries As a result using the found index of the minimum difference array we restore the array itself 
Little Petya loves counting He wants to count the number of ways to paint a rectangular checkered board of size rows columns in colors Besides the coloring should have the following property for any vertical line that passes along the grid lines and divides the board in two non empty parts the number of distinct colors in both these parts should be the same Help Petya to count these colorings ,"[""// Authored by dolphinigle\n// CodeForces 83\n// 3 Sep 2011\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n\n#define FORN(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define DEBUG(x) cout << '>' << #x << ':' << x << '\\n';\n\n#define REP(X,Y,Z) for (int (X) = (Y);(X) < (Z);++(X))\n#define RESET(Z,Y) memset(Z,Y,sizeof(Z))\n\n#define SZ(Z) ((int)Z.size())\n#define ALL(W) W.begin(), W.end()\n#define PB push_back\n\n#define MP make_pair\n#define A first\n#define B second\n\n#define INF 1023123123\n#define EPS 1e-11\n\n#define MX(Z,Y) Z = max((Z),(Y))\n#define MN(X,Y) X = min((X),(Y))\n\n#define FORIT(X,Y) for(typeof((Y).begin()) X = (Y).begin();X!=(Y).end();X++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\n\n//(number**exponent) % ivalue;\nll Power(ll number,ll exponent,ll ivalue) {\n\tll ret = 1;\n\tll multiplier = number;\n\twhile (exponent > 0LL) {\n\t\tif (exponent % 2LL) {\n      ret = (ret * multiplier) % ivalue;\n    }\n\t\texponent /= 2LL;\n\t\tmultiplier = (multiplier * multiplier) % ivalue;\n  }\n\treturn ret;\n}\n\n//works if modulo >= 2\nll MultiplicativeInverse(ll number, ll ivalue) {\n\treturn Power(number, ivalue - 2LL, ivalue);\n}\n\nll FastCombination(ll from, ll pick, ll ivalue, bool reset = false) {\n  static vector<ll> fact, rfact;\n  if (reset) fact = rfact = vector<ll>(0);\n  if (SZ(fact) == 0LL) {\n    fact.PB(1LL);\n    rfact.PB(1LL);\n  }\n  if (pick > from) return 0LL;\n  ll table_size = max(from, max(pick, from-pick));\n  while (SZ(fact) <= table_size) {\n    fact.PB((fact.back() * (ll)SZ(fact)) % ivalue);\n    rfact.PB(MultiplicativeInverse(fact.back(), ivalue));\n  }\n\tll jahja = (fact[from] * rfact[pick]) % ivalue;\n  return (jahja * rfact[from-pick]) % ivalue;\n}\n// O(max(from, pick)).\n// Assumes that ivalue will always be the same. To reset, use the\n// reset flag.\n\nvector<ll> Factorial(ll number, ll ivalue) {\n  vector<ll> factorial;\n  factorial.PB(1LL);\n  for (int i = 1; i <= number; ++i) {\n    factorial.PB((factorial.back() * (ll)i) % ivalue);\n  }\n  return factorial;\n}\n// vector<ll> fact = Factorial(4, 20);\n// fact[3] == 6 % 20 == 6\n// fact[4] == 24 % 20 == 4\n\nll modu = 1000000007LL;\n\nll dp[1050][1050]; // rows, distinct colors\n\n\n\nint main() {\n\n  int row, col, colors;\n  cin >> row >> col >> colors;\n  if (col == 1) {\n    cout << Power(colors, row, modu) << endl;\n    return 0;\n  }\n\n  FORN(i, 1050) FORN(j, 1050) dp[i][j] = 0LL;\n  dp[0][0] = 1LL;\n  for (int i = 0; i < 1040; ++i) for (int j = 0; j < 1040; ++j) {\n    if (dp[i][j] == 0LL) continue;\n    // reuse\n    dp[i+1][j] = (dp[i+1][j] + ((dp[i][j] * (ll)j) % modu)) % modu;\n    // new\n    dp[i+1][j+1] = (dp[i+1][j+1] + dp[i][j]) % modu;\n  }\n\n  if (col == 2) {\n    ll ret = 0LL;\n    ll mult = 1LL;\n    for (ll i = 1; i <= min(row, colors); ++i) {\n      mult *= (ll)(colors - i + 1);\n      mult %= modu;\n      ll sol = mult * dp[row][i];\n      sol %= modu;\n      sol *= sol;\n      sol %= modu;\n      ret += sol;\n      ret %= modu;\n    }\n    cout << ret << endl;\n    return 0;\n  }\n\n  vector<ll> fact = Factorial(1050, modu);\n\n  ll midtot = row * (col-2);\n\n  vector<ll> pangkat1000;\n  FORN(i, 1050) {\n    pangkat1000.push_back(Power(i, midtot, modu));\n  }\n\n  ll ret = 0;\n  for (ll total = 1; total <= min(row, colors); ++total) {\n    for (ll equal = 1; equal <= total; ++equal) {\n      ll distinct = total - equal;\n      if (distinct + distinct + equal > colors) continue;\n      ll sol = 1LL;\n      // ambil yg distinct, distinct, sama equal\n      sol *= FastCombination(colors, distinct, modu);\n      sol %= modu;\n      sol *= FastCombination(colors-distinct, distinct, modu);\n      sol %= modu;\n      sol *= FastCombination(colors-distinct-distinct, equal, modu);\n      sol %= modu;\n      // urutan buat yg kiri sama kanan\n      sol *= fact[distinct + equal];\n      sol %= modu;\n      sol *= fact[distinct + equal];\n      sol %= modu;\n      sol *= dp[row][distinct + equal];\n      sol %= modu;\n      sol *= dp[row][distinct + equal];\n      sol %= modu;\n      // yg tengah2\n      sol *= pangkat1000[equal];\n      sol %= modu;\n      ret += sol;\n      ret %= modu;\n    }\n  }\n  cout << ret << endl;\n\n  return 0;\n}\n""]","[0, 0, 0, 1, 0]",2300,One can notice that if m 1 then the answer is kn because all colorings are possible Now we ll assume that m 1 Let s look on the first column of the board i e the vertical cut will be made right next to the first column Suppose there are x distinct colors in this column Then in the rest of the board there are also x colors If we move the vertical line by one unit to the right the number of different colors to the left of it will not decrease and the number of colors to the right of it won t increase It means that the number of different colors in both parts of the board will be also x We can repeat this process until the line reaches the rightmost column which means that the number of distinct colors in it is also x It is easy to see that we can only use colors which belong to the intersection of sets of colors in the leftmost and rightmost columns in the rest of the board Let s iterate over all values of x and y where x is the number of colors in the leftmost column and y is the number of elements in intersection of sets of colors in the rightmost and leftmost columns It is easy to see that x is limited by the number of rows in the board and y can t be greater than x Let s find the answer for all such pairs of x and y and at the end we ll add them up together Suppose x and y are fixed We first need to choose 2x y colors from the given k colors which we will use which means that the answer for will be multiplied by C k 2x y After that we ll choose x y unique colors which will be used in the first column which means that the answer will be also multiplied by C 2x y x y Then we ll choose x y colors for the rightmost column and multiply the answer by C x x y Now all we need to know is how many ways of coloring n cells into x colors are there We ll use a dynamic programming approach to solve this sub problem Let d i j be the number of ways to color a rectangle of unit width and length i into colors numerated from 1 to j with the following restriction if a b then the first appearence of color a in the rectangle will be before the first appearence of color b Then we can calculate this function using the following recurrence d i j j d i 1 j d i 1 j 1 After we finish calculating d i j we need to multiply the answer by d n x 2 to color the first and the last columns Now we need to notice that we can reorder all colors in the first and the last columns in arbitrary way which means that the answer should be multiplied by x 2 Finally we need to multiply the answer by yn m 2 which correspond to coloring the rest of our board 
Wojtek has just won a maths competition in Byteland The prize is admirable a great book called Card Tricks for Everyone Great he thought I can finally use this old dusted deck of cards that s always been lying unused on my desk The first chapter of the book is How to Shuffle k Cards in Any Order You Want It s basically a list of n intricate methods of shuffling the deck of k cards in a deterministic way Specifically the i th recipe can be described as a permutation P i 1 P i 2 dots P i k of integers from 1 to k If we enumerate the cards in the deck from 1 to k from top to bottom then P i j indicates the number of the j th card from the top of the deck after the shuffle The day is short and Wojtek wants to learn only some of the tricks today He will pick two integers l r 1 le l le r le n and he will memorize each trick from the l th to the r th inclusive He will then take a sorted deck of k cards and repeatedly apply random memorized tricks until he gets bored He still likes maths so he started wondering how many different decks can he have after he stops shuffling it Wojtek still didn t choose the integers l and r but he is still curious Therefore he defined f l r as the number of different decks he can get if he memorizes all the tricks between the l th and the r th inclusive What is the value of sum l 1 n sum r l n f l r ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nconst int K = 5;\nconst int M = 122;\nconst int S = 10100;\nint n, k, m;\nint pp[M][K];\nint t[M][M];\nint toId[S];\nint a[N];\nbool g[M];\nint q[M];\nint topQ;\nvector<int> b[N];\nvector<int> cur;\n\nvoid precalc() {\n\tfor (int i = 0; i < k; i++)\n\t\tpp[0][i] = i;\n\tm = 1;\n\twhile(true) {\n\t\tfor (int i = 0; i < k; i++)\n\t\t\tpp[m][i] = pp[m - 1][i];\n\t\tif (!next_permutation(pp[m], pp[m] + k)) break;\n\t\tm++;\n\t}\n\tfor (int i = 0; i < S; i++)\n\t\ttoId[i] = -1;\n\tfor (int i = 0; i < m; i++) {\n\t\tint id = 0;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tid = id * k + pp[i][j];\n\t\t}\n\t\ttoId[id] = i;\n\t}\n\tint qq[K];\n\tfor (int v = 0; v < m; v++)\n\t\tfor (int u = 0; u < m; u++) {\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tqq[i] = pp[v][pp[u][i]];\n\t\t\tint id = 0;\n\t\t\tfor (int i = 0; i < k; i++)\n\t\t\t\tid = id * k + qq[i];\n\t\t\tid = toId[id];\n\t\t\tif (id == -1) throw;\n\t\t\tt[v][u] = id;\n\t\t}\n}\n\nbool tryAdd(int id) {\n\tif (g[id]) return false;\n\tcur.push_back(id);\n\tfor (int i = 0; i < m; i++)\n\t\tg[i] = 0;\n\tg[0] = 1;\n\ttopQ = 0;\n\tq[topQ++] = 0;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = q[i];\n\t\tfor (int x : cur) {\n\t\t\tint u = t[v][x];\n\t\t\tif (!g[u]) {\n\t\t\t\tg[u] = 1;\n\t\t\t\tq[topQ++] = u;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &k);\n\tprecalc();\n\tfor (int i = 0; i < n; i++) {\n\t\tint id = 0;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tscanf(""%d"", &x);\n\t\t\tx--;\n\t\t\tid = id * k + x;\n\t\t}\n\t\tid = toId[id];\n\t\tif (id == -1) throw;\n\t\ta[i] = id;\n\t}\n\n\tll ans = 0;\n\tfor (int v = n - 1; v >= 0; v--) {\n\t\tcur.clear();\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tg[i] = 0;\n\t\tg[0] = 1;\n\t\tint curSz = 1;\n\t\tint lst = v;\n\t\tif (tryAdd(a[v])) {\n\t\t\tb[v].push_back(v);\n\t\t\tans += curSz * (v - lst);\n\t\t\tcurSz = topQ;\n\t\t\tlst = v;\n//\t\t\teprintf(""%d\\n"", curSz);\n\t\t}\n\t\tfor (int u : b[v + 1]) {\n\t\t\tif (tryAdd(a[u])) {\n\t\t\t\tb[v].push_back(u);\n\t\t\t\tans += curSz * (u - lst);\n\t\t\t\tcurSz = topQ;\n\t\t\t\tlst = u;\n//\t\t\t\teprintf(""%d\\n"", curSz);\n\t\t\t}\n\t\t}\n\t\tans += curSz * (n - lst);\n\t}\n\tprintf(""%lld\\n"", ans);\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0]",2700,Let s first enumerate all permutations by integers from to Now we can memoize all possible compositions of two permutations in an array This will allow us to compose any two permutations in constant time Let and be the left and right ends of any interval We ll compute the sum in the problem statement for each separately Set some Notice that if there are multiple occurrences of the same permutation before only the latest occurrence is important for us any earlier occurrences won t help us create any new decks Therefore for each of possible permutations we can maintain its latest occurrence before We can also maintain a sorted list of such latest occurrences among all the permutations from the latest to the earliest This creates intervals of value where the number of possible decks can t change Now we only need to be able to maintain the set of decks permutations we can generate using the tricks we already know Initially we can generate only one deck with the cards in sorted order When learning a new trick one of two things can happen If a single application of the new trick generates a deck we can already create using previous tricks this trick gives us nothing we can simply simulate this new trick by a sequence of old tricks If this trick creates a brand new deck of cards we need to recalculate the set of achievable permutations We maintain a set of these are the tricks that have increased the number of decks we can generate Now each deck in the new set of decks can be created using this repeatedly applying the generators from this set We can use BFS DFS to compute the new decks This is obviously a correct algorithm but why does it work fast enough If you know some abstract algebra then you can notice that what we re computing here is a chain of subgroups in a symmetric group a group of all permutations of elements By Lagrange s theorem if a group is a subgroup of a finite group then is a multiple of Therefore each new set of achievable decks is at least twice as large as the previous one It means that The set of generators is always at most as large as The time needed to compute all the subgroups can be bounded by times the sizes of all subgroups in the chain As the sizes are growing exponentially large the sum of sizes is at most Therefore all the additions take at most time The time complexity of the intended solution was therefore The solution can be sped up significantly by computing all possible sets of achievable decks i e all subgroups of for there are only of them Some preprocessing will then allow us to add a single element to the subgroup in constant time This was however not necessary to get AC 
Aleksey has n friends He is also on a vacation right now so he has m days to play this new viral cooperative game But since it s cooperative Aleksey will need one teammate in each of these m days On each of these days some friends will be available for playing and all others will not On each day Aleksey must choose one of his available friends to offer him playing the game and they of course always agree However if any of them happens to be chosen strictly more than left lceil dfrac m 2 right rceil times then all other friends are offended Of course Aleksey doesn t want to offend anyone Help him to choose teammates so that nobody is chosen strictly more than left lceil dfrac m 2 right rceil times ,"['#include <bits/stdc++.h>\n\nint main() {\n\tusing namespace std;\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N, M; cin >> N >> M;\n\n\t\tvector<vector<int>> F(M);\n\t\tfor (auto& v : F) {\n\t\t\tint k; cin >> k;\n\t\t\tv.resize(k);\n\t\t\tfor (auto& a : v) cin >> a;\n\t\t}\n\n\t\tvector<int> cnt(N+1);\n\t\tvector<int> C(M);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tC[i] = F[i][0];\n\t\t\tcnt[C[i]]++;\n\t\t}\n\n\t\tfor (int v = 1; v <= N; v++) {\n\t\t\tif (cnt[v] > (M+1)/2) {\n\t\t\t\tfor (int i = 0; cnt[v] > (M+1)/2 && i < M; i++) {\n\t\t\t\t\tif (C[i] == v && int(F[i].size()) > 1) {\n\t\t\t\t\t\tcnt[C[i]]--;\n\t\t\t\t\t\tC[i] = F[i][1];\n\t\t\t\t\t\tcnt[C[i]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt[v] > (M+1)/2) {\n\t\t\t\t\tcout << ""NO"" << \'\\n\';\n\t\t\t\t\tgoto finished;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ""YES"" << \'\\n\';\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcout << C[i] << "" \\n""[i+1==M];\n\t\t}\n\nfinished:;\n\t}\n\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0]",1600,First for each day we select an arbitrary friend from the list With this choice at most one friend will play more than m2 times Let s call him f We want to fix schedule such that f will play exactly m2 times To do this we go through all the days and if f is assigned on a certain day and someone else can play this day then we assign anyone except f for that day We will make such replacements while f plays more than m2 times There is only one case when this is not possible if f is the only friend who can play in more than m2 days 
In the last war of PMP he defeated all his opponents and advanced to the final round But after the end of semi final round evil attacked him from behind and killed him God bless him Before his death PMP signed a contract with the bus rapid transit BRT that improves public transportations by optimizing time of travel estimation You should help PMP finish his last contract Each BRT line is straight line that passes intersecting on its ways At each intersection there is traffic light that periodically cycles between green and red It starts illuminating green at time zero During the green phase which lasts for seconds traffic is allowed to proceed After the green phase the light changes to red and remains in this color for seconds During the red phase traffic is prohibited from proceeding If a vehicle reaches the intersection exactly at a time when the light changes to red it should stop but the vehicle is clear to proceed if the light has just changed to green All traffic lights have the same timing and are synchronized In other words the period of red and green phase is the same for all of traffic lights and they all start illuminating green at time zero The BRT Company has calculated the time that a bus requires to pass each road segment A road segment is the distance between two consecutive traffic lights or between a traffic light and source or destination station More precisely BRT specialists provide positive integers the time in seconds that a bus needs to traverse th road segment in the path from source to destination The value denotes the time that a bus needs to pass the distance between source and the first intersection The value denotes the time between the last intersection and destination In one day buses leave the source station The th bus starts from source at time in seconds Decision makers of BRT Company want to know what time a bus gets to destination The bus is considered as point A bus will always move if it can The buses do not interfere with each other ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<string>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n;\nint q;\nlong long g,r;\nlong long gr;\nlong long li[101000];\nlong long sl[101000];\nlong long qu[101000];\nlong long ans[101000];\nlong long dp[101000];\nlong long ev[201000];\ninline long long mod(long long a,long long b){\n    a%=b;\n    if(a<0)a+=b;\n    return a;\n}\nlong long tre[1010000];\ninline void down(int np){\n    if(tre[np]!=-1){\n        tre[np*2]=tre[np*2+1]=tre[np];\n        tre[np]=-1;\n    }\n}\ninline void add(int np,int l,int r,int x,int y,int c){\n//    printf(""add %d %d %d %d %d %d\\n"",np,l,r,x,y,c);\n    if(x==y)return;\n    if(l==x&&r==y){\n        tre[np]=c;\n        return;\n    }\n    down(np);\n    int m=(l+r)/2;\n    if(x<=m&&y>=m){\n        add(np*2,l,m,x,m,c);\n        add(np*2+1,m,r,m,y,c);\n    }else if(x>=m){\n        add(np*2+1,m,r,x,y,c);\n    }else{\n        add(np*2,l,m,x,y,c);\n    }\n}\ninline int que(int np,int l,int r,int x){\n    if(tre[np]!=-1)return tre[np];\n    if(r==l+1)return tre[np];\n    down(np);\n    int m=(l+r)/2;\n    if(x>=m)return que(np*2+1,m,r,x);\n    else return que(np*2,l,m,x);\n}\nint evc;\ninline int lshua(int x){\n    return upper_bound(ev,ev+evc,x)-ev-1;\n}\ninline void build(){\n    int i;\n    memset(tre,-1,sizeof(tre));\n    evc=0;\n    ev[evc++]=0;\n    for(i=0;i<n;i++){\n        ev[evc++]=mod(g-sl[i],gr);\n        ev[evc++]=mod(g+r-sl[i],gr);\n    }\n    sort(ev,ev+evc);\n    evc=unique(ev,ev+evc)-ev;\n    //printf(""evc=%d\\n"",evc);\n    //for(i=0;i<evc;i++)printf(""%d "",ev[i]);puts("""");\n    dp[n]=0;\n    for(i=n-1;i>=0;i--){\n        long long sp=mod(0-sl[i],gr);\n        int k=que(1,0,evc,lshua(sp));\n        if(k==-1)dp[i]=sl[n]-sl[i];\n        else{\n            long long qq=sl[k]-sl[i];\n            qq=(qq/gr+1)*gr;\n            qq+=dp[k];\n            dp[i]=qq;\n        }\n        //printf(""dp[%d]=%d\\n"",i,dp[i]);\n        long long e1=mod(g-sl[i],gr);\n        long long e2=mod(g+r-sl[i],gr);\n        int ee1=lshua(e1);\n        int ee2=lshua(e2);\n        if(ee1<ee2)add(1,0,evc,ee1,ee2,i);\n        else{\n            add(1,0,evc,ee1,evc,i);\n            add(1,0,evc,0,ee2,i);\n        }\n    }\n}\ninline void solve(){\n    int i;\n    build();\n    for(i=0;i<q;i++){\n        long long qq=qu[i];\n        long long rr=qq/gr;\n        qq%=gr;\n        int qqq=lshua(qq);\n        int k=que(1,0,evc,qqq);\n        //printf(""qq=%I64d qqq=%d k=%d\\n"",qq,qqq,k);\n        if(k==-1)ans[i]=qu[i]+sl[n];\n        else{\n            qq+=sl[k];\n            qq=(qq/gr+1)*gr;\n            qq+=dp[k];\n            ans[i]=qq+rr*gr;\n        }\n    }\n}\nint main(){\n    int i;\n    scanf(""%d%I64d%I64d"",&n,&g,&r);\n    gr=g+r;\n    for(i=0;i<=n;i++){\n        scanf(""%I64d"",&li[i]);\n        sl[i]=li[i];\n        if(i)sl[i]+=sl[i-1];\n    }\n    scanf(""%d"",&q);\n    for(i=0;i<q;i++)scanf(""%I64d"",&qu[i]);\n    solve();\n    for(i=0;i<q;i++)printf(""%I64d\\n"",ans[i]);\n}\n\n']","[0, 0, 0, 0, 1]",2800,We define ti as follows assume a bus starts moving from i th intersection exactly at the time when the light changes to green The time it takes for the bus to get the final station is ti We call the times when a green interval begins t0 so every g r seconds t0 occurs once If a bus gets to i th intersection during the red phase it should wait and then start moving at t0 So considering the fact that all lights are synchronized and length of segments are fixed if we have ti for i th intersection we can compute the time for the bus to get final station Clearly tn is the length of the last segments For computing ti we should find the smallest j such that if a bus starts at t0 from i th intersection it gets to j th intersection during the red phase So we have ti tj d i j w where d i j is the distance between i th and j th intersections and w is the time that the bus should wait behind the red light at j th intersection The later value can be computed easily The only problem that remains is to find j for i th intersection So we start iterating over i for n 1 th intersection backwards and we compute ti for all intersections Assume p g r and ta d i j p Now if the bus starts from i th intersection at time t0 and we have ta g in this case we are in red phase at j th intersection Actually ta should be in interval g g r Here we can use segment trees That is for all intersections from i 1 to n we store some values in the tree that helps us find the smallest j But we should note the value of ta depends on d i j which changes as i changes Thus we cannot use ta in the tree Instead we define si the be the distance of i th intersection to the destination So we have d i j si sj and we use the value of sj with storing sj p in the segment tree as the key and the value would be j itself In other words for each intersection we store the key value pair sj p j in the tree According to what we said so far to be in the red phase at j th intersection we should have ta d i j p si sj p g g r sj p g si p g r si p As we stored sj p in the tree we can retrieve the smallest j in the above interval with a query in the segment tree This way we can compute ti for all intersections Answering to each query in the problem can be solve in exactly the same way So the overall complexity would be O n q logn 
There are some rabbits in Singapore Zoo To feed them Zookeeper bought n carrots with lengths a 1 a 2 a 3 ldots a n However rabbits are very fertile and multiply very quickly Zookeeper now has k rabbits and does not have enough carrots to feed all of them To solve this problem Zookeeper decided to cut the carrots into k pieces For some reason all resulting carrot lengths must be positive integers Big carrots are very difficult for rabbits to handle and eat so the time needed to eat a carrot of size x is x 2 Help Zookeeper split his carrots while minimizing the sum of time taken for rabbits to eat the carrots ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll inf=1e18;\n\nint n, k;\n\nll tab[nax];\n\nll kwa(ll v)\n{\n\treturn v*v;\n}\n\nll koszt(int v, ll cz)\n{\n\tif (cz>tab[v])\n\t\treturn inf;\n\tll dz=tab[v]/cz;\n\tll resz=tab[v]%cz;\n\treturn kwa(dz+1)*resz+kwa(dz)*(cz-resz);\n}\n\nll tu[nax];\n\nint main()\n{\n\tscanf(""%d%d"", &n, &k);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ttu[i]=1;\n\t\tscanf(""%lld"", &tab[i]);\n\t}\n\tpriority_queue<pair<ll,int>>kol;\n\tfor (int i=1; i<=n; i++)\n\t\tkol.push({koszt(i, 1)-koszt(i, 2), i});\n\tfor (int h=n+1; h<=k; h++)\n\t{\n\t\tint v=kol.top().second;\n\t\tkol.pop();\n\t\ttu[v]++;\n\t\tkol.push({koszt(v, tu[v])-koszt(v, tu[v]+1), v});\n\t}\n\tll wyn=0;\n\tfor (int i=1; i<=n; i++)\n\t\twyn+=koszt(i, tu[i]);\n\tprintf(""%lld\\n"", wyn);\n\treturn 0;\n}\n']","[1, 1, 0, 0, 1]",2200,Let us define as the sum of time needed when we have a single carrot of length and it is split into pieces More detailsIn an optimal cutting for a single carrot we will only cut it into pieces of length and for some Such cutting is optimal as suppose we have pieces of length and and Then it is better to replace those pieces of carrots with length and since To calculate we need to find such that and minimizing Clearly and Thus calculating can be done in We can use the following greedy algorithm We consider making zero cuts at first We will make cuts one by one When deciding where to make each cut consider for all the carrots which carrot gives us the largest decrease in cost when we add an extra cut If a carrot of length currently is in pieces then the decrease in cost by making one extra cut is The important observation here is that ProofConsider Since the length is even and we have an even number of pieces we know that the will be one cut down the middle and each half will have pieces As such This is because there even number of length pieces and an even number of length pieces hence the left half and the right half are the same Also since is describing cutting a carrot of length first into carrots of length and cutting it into and pieces respectively The inequality must hold because this is a way to cut a carrot of length into pieces Since we have and We have Rearranging terms gives In other words the more cuts we make to a carrot there is a diminishing returns in the decrease in cost per cut As such For any carrot we don t need to think about making the th cut before making the th cut Hence all we need to do is choose carrot with the largest decrease in cost and add one extra cut for that Which carrot has the largest decrease in cost can be maintained with a priority queue Hence we get a time complexity of Bonus solve this problem for 
You are given a permutation p consisting of n integers 1 2 dots n a permutation is an array where each element from 1 to n occurs exactly once Let s call an array a if the following undirected graph is bipartite the graph consists of n vertices two vertices i and j are connected by an edge if i j and a i a j Your task is to find a array of integers a of size n such that a i p i or a i p i or report that no such array exists If there are multiple answers print any of them ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << \'(\' << p.first << "", "" << p.second << \')\'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << \'{\'; string sep; for (const T &x : v) os << sep << x, sep = "", ""; return os << \'}\'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << \' \' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << ""("" << #__VA_ARGS__ << ""):"", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T_vector>\nvoid output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {\n    if (start < 0) start = 0;\n    if (end < 0) end = int(v.size());\n\n    for (int i = start; i < end; i++)\n        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? \' \' : \'\\n\');\n}\n\n\nconst int INF = int(1e9) + 5;\n\nstruct state {\n    int high = -INF, low = -INF;\n    int previous = -1, a = 0;\n\n    bool operator<(const state &other) const {\n        if (high != other.high)\n            return high < other.high;\n\n        return low < other.low;\n    }\n\n    pair<state, bool> add(int from, int x) {\n        if (x < low)\n            return {state(), false};\n\n        state sum = *this;\n        sum.previous = from;\n        sum.a = x;\n\n        if (x > high)\n            sum.high = x;\n        else\n            sum.low = x;\n\n        return {sum, true};\n    }\n};\n\nvoid run_case() {\n    int N;\n    cin >> N;\n    vector<int> P(N);\n\n    for (auto &p : P)\n        cin >> p;\n\n    vector<vector<state>> dp(N + 1);\n    dp[0] = {state()};\n\n    for (int i = 0; i < N; i++) {\n        for (int x : {-P[i], P[i]})\n            for (int j = 0; j < int(dp[i].size()); j++) {\n                state s = dp[i][j];\n                pair<state, bool> result = s.add(j, x);\n\n                if (result.second)\n                    dp[i + 1].push_back(result.first);\n            }\n\n        sort(dp[i + 1].begin(), dp[i + 1].end());\n        vector<state> filtered;\n\n        for (state s : dp[i + 1]) {\n            bool bad = false;\n\n            for (state f : filtered)\n                if (f.low <= s.low && f.high <= s.high)\n                    bad = true;\n\n            if (!bad)\n                filtered.push_back(s);\n        }\n\n        dp[i + 1] = filtered;\n    }\n\n    if (dp.back().empty()) {\n        cout << ""NO"" << \'\\n\';\n        return;\n    }\n\n    cout << ""YES"" << \'\\n\';\n    vector<int> A(N);\n    int index = 0;\n\n    for (int i = N - 1; i >= 0; i--) {\n        state s = dp[i + 1][index];\n        A[i] = s.a;\n        index = s.previous;\n    }\n\n    output_vector(A);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n']","[1, 0, 0, 1, 0]",2800,To begin with let s understand that an array is bipartite if and only if there is no decreasing subsequence of length in the array Now we can write dynamic programming is there an array of length such that is the maximum last element of a decreasing subsequence of length and is the maximum last element of a subsequence of length Note that Let s consider all possible transitions from the state if we are trying to put the number on the th position where if then the new state will be if then the new state will be if then such a transition is not valid because a decreasing subsequence of length is formed in the array With a naive implementation such dynamic programming works in We can note that for fixed values of and and it is enough for us to store only the minimum available value of So we can write dynamic programming which is defined similarly to the above but now instead of being Boolean stores the minimum value of or infinity if the state is not valid We have speeded up our solution to but it is still too slow To speed up the solution even more we have to look at the transitions in dynamics and notice that for a fixed either or is always equal to So we can rewrite our dynamic programming in the following form Here the flag says which of the numbers and is equal to and the flag is responsible for the sign of and the minimum value of or is stored in the value itself depending on Thus we got a solution with a linear running time In fact this solution can be simplified if we see the following relation the number we use on position is not less than and not greater than This allows us to get rid of one of the states in our dynamic programming altogether so we get an easier solution This optimization wasn t required to get AC but the code becomes shorter 
You are given a multiset of integers You should select exactly of them in a such way that the difference between any two of them is divisible by or tell that it is impossible Numbers can be repeated in the original multiset and in the multiset of selected numbers but number of occurrences of any number in multiset of selected numbers should not exceed the number of its occurrences in the original multiset ,"['#include <bits/stdc++.h>\n\n#define ll long long\nusing namespace std;\n\n\n\nint main() {\n#ifdef __APPLE__\n    freopen(""input.txt"", ""r"", stdin);\n    freopen(""output.txt"", ""w"", stdout);\n#endif\n\n    int n, k, m;\n    scanf(""%d %d %d"", &n, &k, &m);\n    vector<int> a(n);\n    map<int, vector<int>> q;\n    for (int i = 0; i < n; ++i) {\n        scanf(""%d"", &a[i]);\n        q[a[i] % m].push_back(a[i]);\n    }\n    for (auto it : q) {\n        if (it.second.size() >= k) {\n            printf(""Yes\\n"");\n            for (int i = 0; i < k; ++i)\n                printf(""%d "", it.second[i]);\n            return 0;\n        }\n    }\n    printf(""No"");\n\n    return 0;\n}\n']","[0, 1, 1, 0, 0]",1300,If is divisible by then and have same reminder when divided by Let s divide number to groups by reminder by modulo and if there is a group with size at least print numbers from it 
There is a grid consisting of 2 rows and m columns The rows are numbered from 1 to 2 from top to bottom The columns are numbered from 1 to m from left to right The robot starts in a cell 1 1 In one second it can perform either of two actions move into a cell adjacent by a side up right down or left remain in the same cell The robot is not allowed to move outside the grid Initially all cells except for the cell 1 1 are locked Each cell i j contains a value a i j the moment that this cell gets unlocked The robot can only move into a cell i j if at least a i j seconds have passed before the move The robot should visit all cells cell 1 1 is considered entered at the start It can finish in any cell What is the fastest the robot can achieve that ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[2][N];\nint b[2][N];\nint c[2][N];\n\nvoid solve() {\n\tscanf(""%d"", &n);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(""%d"", &a[i][j]);\n\t\t\tif (i + j > 0) a[i][j]++;\n\t\t}\n\tb[0][n] = b[1][n] = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tb[k][i] = max(max(a[k ^ 1][i], a[k][i] + 2 * (n - i) - 1), b[k][i + 1] + 1);\n\t\t}\n\t}\n\tint ans = (int)1e9 + (int)1e8;\n\tint cur = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k = i & 1;\n\t\tans = min(ans, max(cur, b[k][i]));\n\t\tcur = max(cur, a[k][i] + 2 * (n - i) - 1);\n\t\tcur = max(cur, a[k ^ 1][i] + 2 * (n - i) - 2);\n\t}\n\tprintf(""%d\\n"", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n']","[1, 0, 1, 1, 1]",2000,Let s first consider the possible paths across the grid that visit all cells You can immediately think of two of them The first one is go right to the wall turn into the other row and return Let s call it a hook The second one is go down go right go up go right and so on Let s call it a snake Turns out these two are basically the two extremes of all paths You can start with a snake and turn into a hook when you wish You can see that once you move right twice in a row you can only continue with a hook And as long as you didn t move right twice you are just doing a snake Let s fix some path across the grid What will its minimum time be Calculate it iteratively If you want to enter the next cell and it s still locked wait until it isn t So there are some seconds of waiting possibly zero before each cell However why not instead do the following Let s calculate the sum of waiting time required and wait for that amount of seconds before starting to move All cells will be visited at the same time as before or even later Thus they will surely be unlocked if they were in the original plan So the goal is to calculate the minimum amount of time required to wait in the start then add the movement time to it Once again the path is fixed Let the th cell of the path be If you start after waiting for seconds then you reach the th cell at time is indexed Thus the th cell should have If all cells satisfy this condition then the path can be done after waiting for seconds at the start Let s rewrite it into So the condition tells us that should be greater or equal than this value for all cells In other words should be greater or equal than the maximum of the values over all cells Study the formula Imagine we have some path with a known length and want to append a cell to it That s pretty simple Just update the maximum with the value with the corresponding cell and increase the length What if we wanted to prepend a cell to it Turns out it s not that hard as well Every cell in the path gets its value increased by From the formula you can see that this actually decreases the value of each cell by So the maximum decreases by as well The only thing left is to update the maximum with the value of the new first cell Well and increase the length again Finally let s learn how to choose the best path We can iterate over the length of the snake part The hook part is determined uniquely It s easy to maintain the maximum on the snake Just append the new cell to the path How to glue up the hook part to that Well actually realize that the formula allows us to glue up two paths into one Let path have length and maximum and path have length and maximum To make path start after path we just decrease its maximum by The resulting path has length and maximum Let s look closer into what the hooks look like They start in some column traverse all the way right then left up to the same column If the snake part took both cells in its last column then that s it Otherwise the hook has to take the final cell in the last column column If we manage to precalculate something for hooks that start in some column and end in column then we will be able to use that Appending the final cell is not a hard task since we know its index in the path Let be the waiting time required for a hook that starts in cell and ends in a cell as if the path started with the hook cell is the first one can be calculated from Prepend it with a cell and append it with a cell The only thing left is to find the best answer I found the most convenient to start with a snake of length only cell and progress it two steps at the time update the answer progress the snake to the other cell of the current column update the answer progress the snake into the next column Overall complexity per testcase 
You are given two arrays a and b of length n You can perform the following operation some possibly zero times choose l and r such that 1 leq l leq r leq n let x max a l a l 1 ldots a r for all l leq i leq r set a i x Determine if you can make array a equal to array b ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nint T, n, a[N], b[N];\nint st[19][N];\n\ninline int ask(int l, int r) {\n\tint k = __lg(r - l + 1);\n\treturn max(st[k][l], st[k][r - (1 << k) + 1]);\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> T;\n\twhile (T--) {\n\t\tcin >> n;\n\t\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\t\tfor (int i = 1; i <= n; ++i) cin >> b[i];\n\t\tbool gg = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (b[i] < a[i]) {\n\t\t\t\tgg = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (gg) {\n\t\t\tcout << ""NO\\n"";\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) st[0][i] = a[i];\n\t\tfor (int i = 1; (1 << i) <= n; ++i)\n\t\t\tfor (int j = 1; j + (1 << i) - 1 <= n; ++j)\n\t\t\t\tst[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);\n\t\tfor (int i = 1, j = 1; i <= n; ++i) {\n\t\t\twhile (j <= n && (a[j] != b[i] || (j < i && ask(j, i) > b[i]))) ++j;\n\t\t\tif (j > n || (j >= i && ask(i, j) > b[i])) {\n\t\t\t\tgg = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gg) cout << ""NO\\n"";\n\t\telse cout << ""YES\\n"";\n\t}\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",1600,If for any then it is clearly impossible In order for to become must be contained by an interval that also contains a where Note that if there is a triple where then it is never optimal to apply the operation on interval since applying the operation on interval will be sufficient Thus for we only need to consider the closest to the right or left of Lets find the necessary conditions for us to apply an operation on the interval First of all for Second for all Turns out these conditions are also sufficient since we can apply these operations in increasing order of without them interfering with each other If we check for every there exists an interval or that satisfies the necessary conditions then there will exist a sequence of operations to transform into Checking for the conditions can be done with brute force for D1 or using monotonic stacks or segment trees for D2 
For an array b 1 b 2 ldots b m for some i 1 i m element b i is said to be a local minimum if b i b i 1 and b i b i 1 Element b 1 is said to be a local minimum if b 1 b 2 Element b m is said to be a local minimum if b m b m 1 For an array b 1 b 2 ldots b m for some i 1 i m element b i is said to be a local maximum if b i b i 1 and b i b i 1 Element b 1 is said to be a local maximum if b 1 b 2 Element b m is said to be a local maximum if b m b m 1 Let x be an array of distinct elements We define two operations on it 1 delete all elements from x that are local minima 2 delete all elements from x that are local maxima Define f x as follows Repeat operations 1 2 1 2 ldots in that order until you get only one element left in the array Return that element For example take an array 1 3 2 We will first do type 1 operation and get 1 2 Then we will perform type 2 operation and get 2 Therefore f 1 3 2 2 You are given a permutation dagger a of size n and q queries Each query consists of two integers l and r such that 1 le l le r le n The query asks you to compute f a l a l 1 ldots a r dagger A permutation of length n is an array of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation n 3 but there is 4 in the array ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <vector>\n#define N 101000\n#define VI vector<int>\ntemplate<typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == \'-\') flag = true; c = getchar(); }\n\twhile (isdigit(c)) x = x * 10 + (c ^ 48), c = getchar();\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nint n, q;\ninline int bf(VI &ve, int ptr) {\n\tVI vec[21];\n\tvec[ptr] = ve;\n\twhile (vec[ptr].size() > 1) {\n\t\tfor (unsigned int i = 0; i < vec[ptr].size(); ++i) {\n\t\t\tbool flag;\n\t\t\tif (!(ptr & 1)) {\n\t\t\t\tflag = i == 0 ? true : vec[ptr][i - 1] > vec[ptr][i];\n\t\t\t\tflag &= i == (vec[ptr].size() - 1) ? true : vec[ptr][i + 1] > vec[ptr][i];\n\t\t\t} else {\n\t\t\t\tflag = i == 0 ? true : vec[ptr][i - 1] < vec[ptr][i];\n\t\t\t\tflag &= i == (vec[ptr].size() - 1) ? true : vec[ptr][i + 1] < vec[ptr][i];\n\t\t\t}\n\t\t\tif (flag)\tvec[ptr+1].push_back(vec[ptr][i]);\n\t\t}\n\t\t++ptr;\n\t}\n\treturn vec[ptr][0];\n}\nint h[N];\nVI vec[21];\nint vtot;\nvoid init() {\n\tint ptr = 0;\n\twhile (vec[ptr].size() > 1) {\n\t\tfor (unsigned int i = 0; i < vec[ptr].size(); ++i) {\n\t\t\tbool flag;\n\t\t\tif (!(ptr & 1)) {\n\t\t\t\tflag = i == 0 ? true : h[vec[ptr][i - 1]] > h[vec[ptr][i]];\n\t\t\t\tflag &= i == (vec[ptr].size() - 1) ? true : h[vec[ptr][i + 1]] > h[vec[ptr][i]];\n\t\t\t} else {\n\t\t\t\tflag = i == 0 ? true : h[vec[ptr][i - 1]] < h[vec[ptr][i]];\n\t\t\t\tflag &= i == (vec[ptr].size() - 1) ? true : h[vec[ptr][i + 1]] < h[vec[ptr][i]];\n\t\t\t}\n\t\t\tif (flag)\tvec[ptr+1].push_back(vec[ptr][i]);\n\t\t}\n\t\t++ptr;\n\t}\n\tvtot = ptr;\n}\nint query(int l, int r) {\n\tconst int up = 6;\n\tif (r - l <= up) {\n\t\tVI ve;\n\t\tfor (int i = l; i <= r; ++i) ve.push_back(h[i]);\n\t\treturn bf(ve, 0);\n\t}\n\tint a = h[l], b = h[r];\n\tint nl = l, nr = r - 2;\n\tint ptr = 0;\n\twhile (1) {\n\t\tbool flag1 = ptr & 1 ? a > h[vec[ptr][nl]] : a < h[vec[ptr][nl]];\n\t\tbool flag;\n\t\tif (ptr & 1) {\n\t\t\tflag = h[vec[ptr][nl]] > a;\n\t\t\tflag &= h[vec[ptr][nl]] > h[vec[ptr][nl+1]];\n\t\t} else {\n\t\t\tflag = h[vec[ptr][nl]] < a;\n\t\t\tflag &= h[vec[ptr][nl]] < h[vec[ptr][nl+1]];\n\t\t}\n\t\tif (flag1) a = a;\n\t\telse if (flag) a = h[vec[ptr][nl]];\n\t\telse a = -1;\n\n\t\tflag1 = ptr & 1 ? b > h[vec[ptr][nr]] : b < h[vec[ptr][nr]];\n\t\tif (ptr & 1) {\n\t\t\tflag = h[vec[ptr][nr]] > b;\n\t\t\tflag &= h[vec[ptr][nr]] > h[vec[ptr][nr-1]];\n\t\t} else {\n\t\t\tflag = h[vec[ptr][nr]] < b;\n\t\t\tflag &= h[vec[ptr][nr]] < h[vec[ptr][nr-1]];\n\t\t}\n\t\tif (flag1) b = b;\n\t\telse if (flag) b = h[vec[ptr][nr]];\n\t\telse b = -1;\n\n\t\tint idl = lower_bound(vec[ptr+1].begin(), vec[ptr+1].end(), vec[ptr][nl]+1) - vec[ptr+1].begin();\n\t\tint idr = upper_bound(vec[ptr+1].begin(), vec[ptr+1].end(), vec[ptr][nr]-1) - vec[ptr+1].begin() - 1;\n\n\t\tif (idr - idl <= up) {\n\t\t\tVI ve;\n\t\t\tif (~a) ve.push_back(a);\n\t\t\tfor (int i = idl; i <= idr; ++i) ve.push_back(h[vec[ptr+1][i]]);\n\t\t\tif (~b) ve.push_back(b);\n\t\t\treturn bf(ve, ptr+1);\n\t\t}\n\t\tif (a == -1) a = h[vec[ptr+1][idl]], ++idl;\n\t\tif (b == -1) b = h[vec[ptr+1][idr]], --idr;\n\t\t++ptr;\n\t\tnl = idl, nr = idr;\n\t}\n\tputs(""???"");\n\texit(-1);\n\treturn -1;\n}\nint main() {\n\tread(n), read(q);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(h[i]);\n\t\tvec[0].push_back(i);\n\t}\n\tvtot = 1;\n\tinit();\n\n\tfor (int i = 1; i <= q; ++i) {\n\t\tint l, r; read(l), read(r);\n\t\tint res = query(l, r);\n\t\tprintf(""%d\\n"", res);\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 1]",2800,SolutionRead the hints Now we will precompute and store the array after each operation on the entire permutation We will call those array layers We can now solve queries in If a query involves a small number of elements we can just brute force it Otherwise we do the following Now let s define our queries a bit differently We are given some array which will be a subarray of some layer and values and We will get array by appending to the start of and appending to the end of We are interested in the value of It is easy to see that all queries involving or more elements can be converted into the modified query If is small we can just brute force it Otherwise we can transform it into a query on the next layer in constant time or in Now the first thing to notice is that all elements in that are neither first nor last will be deleted only if they were deleted when we performed operations on the whole permutation That means that they will represent some interval on the next layer let s call it That interval can be found either with binary search or in with precomputation It holds that is around half of Now notice that among and the first element of there has to be at least one deletion The same goes for the last element of and So now we have transformed the query onto the next level in or As we will do at most such transformations the complexity of a single query is either or depending on the way we find the next interval both of which should be fast enough to pass Total time complexity or Total memory complexity 
You are given three integers a b and c such that of these two equations is true a b c a b c Output if the first equation is true and otherwise ,"['#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int t;\n    cin >> t;\n    for (int i = 0; i < t; i++)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        if (a + b == c) cout << ""+\\n"";\n        else cout << ""-\\n"";\n    }\n}\n']","[0, 0, 1, 0, 0]",800,You need to implement what is given in the statement for example you can use an if statement to output if and otherwise 
There are cities in Bearland numbered through Cities are arranged in one long row The distance between cities and is equal to Limak is a police officer He lives in a city His job is to catch criminals It s hard because he doesn t know in which cities criminals are Though he knows that there is criminal in each city Limak is going to use a BCD Bear Criminal Detector The BCD will tell Limak how many criminals there are for every distance from a city After that Limak can catch a criminal in each city for which he that there must be a criminal You know in which cities criminals are Count the number of criminals Limak will catch after he uses the BCD ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << ""="" << x << endl\n#define rep(i,a,b) for(int i=a;i<b;++i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nint a , n , x[110] , o[110];\nint main(){\n    cin >> n >> a;\n    rep(i,1,n+1) cin >> x[i];\n    int ans = 0;\n    for(int i=a,j=a;i>=1||j<=n;--i,++j){\n        bool ok = true;\n        if(i >= 1 && !x[i]) ok = false;\n        if(j <= n && !x[j]) ok = false;\n        if(ok){\n            if(i >= 1) o[i] = true;\n            if(j <= n) o[j] = true;\n        }\n    }\n    rep(i,1,n+1) ans += o[i];\n    cout << ans << endl;\n    return 0;\n}\n']","[0, 0, 1, 0, 0]",1000,Limak can t catch a criminal only if there are two cities at the same distance and only one of them contains a criminal You should iterate over the distance and for each distance check if and are both in range and if only one of them has code1 
After the big birthday party Katie still wanted Shiro to have some more fun Later she came up with a game called Of course she invited her best friends Kuro and Shiro to play with her The three friends are very smart so they passed all the challenges very quickly and finally reached the destination But the treasure can only belong to one cat so they started to think of something which can determine who is worthy of the treasure Instantly Kuro came up with some ribbons A random colorful ribbon is given to each of the cats Each color of the ribbon can be represented as an uppercase or lowercase Latin letter Let s call a consecutive subsequence of colors that appears in the ribbon a The of a ribbon is defined as the maximum number of times one of its subribbon appears in the ribbon The more the subribbon appears the more beautiful is the ribbon For example the ribbon has the beauty of 7 because its subribbon appears 7 times and the ribbon has the beauty of 2 because its subribbon appears twice The rules are simple The game will have n turns Every turn each of the cats must change strictly color at one position in his her ribbon to an arbitrary color which is from the unchanged one For example a ribbon can be changed into in one turn The one having the most beautiful ribbon after n turns wins the treasure Could you find out who is going to be the winner if they all play optimally ,"['#include <bits/stdc++.h>\n#define FOR(i,s,e) for(int i=(s);i<=(e);i++)\n#define FORD(i,s,e) for(int i=(s);i>=(e);i--)\n#define ALL(k) (k).begin(),(k).end()\n#define e1 first\n#define e2 second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<int> VI;\nconst bool print=false;\n\nconst int N=3e5+7;\n\nLL n;\n\nchar text[N];\nLL res[N];\n\nconst string out[]={""Kuro"", ""Shiro"", ""Katie""};\n\nint main()\n{\n\tscanf(""%lld"", &n);\n\tFOR(i,0,2){\n\t\tscanf(""%s"", text);\n\t\tint k=strlen(text);\n\t\tmap<char,int>mymap;\n\t\tFOR(j,0,k-1)\n\t\t\tmymap[text[j]]++;\n\t\tLL m=n;\n\t\tvector<pair<LL,char>>mywek;\n\t\tfor (auto j : mymap)\n\t\t\tmywek.pb({j.second, j.first});\n\t\tbool tmp=false;\n\t\twhile(m){\n\t\t\tsort(ALL(mywek));\n\t\t\treverse(ALL(mywek));\n\t\t\tif (!mywek.back().first){\n\t\t\t\tmywek.pop_back();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((int)mywek.size()==1){\n\t\t\t\tif (m==1 && !tmp)\n\t\t\t\t\tmywek[0].first=max(mywek[0].first-1, 1LL);\n\t\t\t\tm=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLL x=min(m, mywek[1].first);\n\t\t\tm-=x;\n\t\t\tmywek[1].first-=x;\n\t\t\tmywek[0].first+=x;\n\t\t\ttmp=true;\n\t\t}\n\t\tfor (auto j : mywek)\n\t\t\tres[i]=max(res[i], j.first);\n\t}\n\tn=-1;\n\tFOR(i,0,2)\n\t\tn=max(n,res[i]);\n\tset<string>myset;\n\tFOR(i,0,2)\n\t\tif(res[i]==n)\n\t\t\tmyset.insert(out[i]);\n\tif(myset.size()==1)\n\t\tcout << (*myset.begin()) << endl;\n\telse\n\t\tcout << ""Draw"" << endl;\n    return 0;\n}\n']","[1, 0, 0, 0, 0]",1800,SolutionWe all knew that the substrings with length appear at most in the string So to make a string as beautiful as possible we will choose the letter that firstly appears at most in the string and replace all the other letters with the chosen letter There is some cases If is less than or equal to the number of remaining letters just add to the beauty If is even after replacing all letters with the chosen we can choose an arbitrary letter replace it with some other letter return it back and repeat the work till reach Otherwise we will not replace all the other letters Instead we will replace the letters until there is letter left now is even then replace that one with another letter different from our chosen letter After that replace that letter with our chosen letter Now is even again we repeat the work discussed above In conclusion let s call our string our chosen letter and its number of occurrences in the string then our answer is Be careful with Time complexity where is the total length of the three strings 
You are given two arrays a 1 a 2 dots a n and b 1 b 2 dots b m Array b is sorted in ascending order b i b i 1 for each i from 1 to m 1 You have to divide the array a into m consecutive subarrays so that for each i from 1 to m the minimum on the i th subarray is equal to b i Note that each element belongs to exactly one subarray and they are formed in such a way the first several elements of a compose the first subarray the next several elements of a compose the second subarray and so on For example if a 12 10 20 20 25 30 and b 10 20 30 then there are two good partitions of array a 12 10 20 20 25 30 12 10 20 20 25 30 You have to calculate the number of ways to divide the array a Since the number can be pretty large print it modulo ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, ""MOD must be positive"");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> a(n), b(m);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\tfor(int i = 0; i < m; i++) cin >> b[i];\n\tfor(int i = n-1; i > 0; i--) a[i-1] = min(a[i-1], a[i]);\n\tif(a[0] != b[0]){\n\t\tcout << 0 << \'\\n\';\n\t\treturn 0;\n\t}\n\tmap<int,int> where;\n\tfor(int i = 0; i < m; i++){\n\t\twhere[b[i]] = i;\n\t}\n\tvector<num> dp(m);\n\tdp[0] = 1;\n\tfor(int r : a){\n\t\tif(!where.count(r)) continue;\n\t\tr = where[r];\n\t\tif(r == 0) continue;\n\t\tdp[r] += dp[r-1];\n\t}\n\tcout << dp.back() << \'\\n\';\n}']","[0, 0, 0, 1, 0]",2100,At first let s reverse arrays and Now array is sorted in descending order Now let s find minimum index such that If there is no such index or if then the answer is because minimum on any prefix of array will never be equal to Otherwise let s find the minimum index such that If there is no such index or if then the answer is Also let s find the minimum index such that it can t be greater than The first subarray starts in position and ends in any position because if it ends in position or further then the minimum in the first subarray is greater than So there are ways to split subarrays and A similar approach can be used to calculate the number of ways to split the second and third subarrays and so on After all you have to check that minimum in the last subarray is equal to otherwise the answer is 
Roma is playing a new expansion for his favorite game World of Darkraft He made a new character and is going for his first grind Roma has a choice to buy of n different weapons and of m different armor sets Weapon i has attack modifier a i and is worth ca i coins and armor set j has defense modifier b j and is worth cb j coins After choosing his equipment Roma can proceed to defeat some monsters There are p monsters he can try to defeat Monster k has defense x k attack y k and possesses z k coins Roma can defeat a monster if his weapon s attack modifier is larger than the monster s defense and his armor set s defense modifier is larger than the monster s attack That is a monster k can be defeated with a weapon i and an armor set j if a i x k and b j y k After defeating the monster Roma takes all the coins from them During the grind Roma can defeat as many monsters as he likes Monsters do not respawn thus each monster can be defeated at most one Thanks to Roma s excessive donations we can assume that he has an infinite amount of in game currency and can afford any of the weapons and armor sets Still he wants to maximize the profit of the grind The profit is defined as the total coins obtained from all defeated monsters minus the cost of his equipment Note that Roma purchase a weapon and an armor set even if he can not cover their cost with obtained coins Help Roma find the maximum profit of the grind ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst ll inf = 2e12;\nstruct Node {\n\tNode *l = 0, *r = 0;\n\tint lo, hi;\n\tll mset = inf, madd = 0, val = -inf;\n\tNode(int lo,int hi):lo(lo),hi(hi){} // Large interval of -inf\n\tNode(vector<ll>& v, int lo, int hi) : lo(lo), hi(hi) {\n\t\tif (lo + 1 < hi) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(v, lo, mid); r = new Node(v, mid, hi);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t\telse val = v[lo];\n\t}\n\tll query(int L, int R) {\n\t\tif (R <= lo || hi <= L) return -inf;\n\t\tif (L <= lo && hi <= R) return val;\n\t\tpush();\n\t\treturn max(l->query(L, R), r->query(L, R));\n\t}\n\tvoid set(int L, int R, ll x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) mset = val = x, madd = 0;\n\t\telse {\n\t\t\tpush(), l->set(L, R, x), r->set(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid add(int L, int R, ll x) {\n\t\tif (R <= lo || hi <= L) return;\n\t\tif (L <= lo && hi <= R) {\n\t\t\tif (mset != inf) mset += x;\n\t\t\telse madd += x;\n\t\t\tval += x;\n\t\t}\n\t\telse {\n\t\t\tpush(), l->add(L, R, x), r->add(L, R, x);\n\t\t\tval = max(l->val, r->val);\n\t\t}\n\t}\n\tvoid push() {\n\t\tif (!l) {\n\t\t\tint mid = lo + (hi - lo)/2;\n\t\t\tl = new Node(lo, mid); r = new Node(mid, hi);\n\t\t}\n\t\tif (mset != inf)\n\t\t\tl->set(lo,hi,mset), r->set(lo,hi,mset), mset = inf;\n\t\telse if (madd)\n\t\t\tl->add(lo,hi,madd), r->add(lo,hi,madd), madd = 0;\n\t}\n};\n\nconst int MAXN = 1.1e6;\nvector<pair<int,ll> > monsters[MAXN];\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tvector<ll> wcost(MAXN, -inf);\n\n\tvector<ll> bcost(MAXN, -inf);\n\tint n, m, p;\n\tcin >> n >> m >> p;\n\tfor(int i = 0; i < n; i++){\n\t\tint a;\n\t\tll c;\n\t\tcin >> a >> c;\n\t\ta--;\n\t\twcost[a] = max(wcost[a], -c);\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tint b;\n\t\tll c;\n\t\tcin >> b >> c;\n\t\tb--;\n\t\tbcost[b] = max(bcost[b], -c);\n\t}\n\tNode segtree(wcost, 0, MAXN);\n\tfor(int i = 0; i < p; i++){\n\t\tint x, y;\n\t\tll z;\n\t\tcin >> x >> y >> z;\n\t\tmonsters[y].push_back({x, z});\n\t}\n\tll best = -inf;\n\tfor(int i = 0; i < MAXN; i++){\n\t\tfor(pair<int,ll> a : monsters[i]){\n\t\t\tsegtree.add(a.first, MAXN, a.second);\n\t\t}\n\t\tll cost = segtree.query(0, MAXN);\n\t\tcost += ll(bcost[i]);\n\t\tbest = max(best, cost);\n\t}\n\tcout << best << '\\n';\n}""]","[0, 0, 0, 0, 1]",2000,Let be the set of monsters which may be defeated with a weapon having attack Then the profit we get if we use weapon with attack and armor with defense is We will iterate on weapons in non descending order of their attack values and maintain For each armor option maintain the value of If armor sets are sorted by their defense value adding a new monster into adds some value on the suffix of So we can maintain the values of in a segment tree So the solution is Build a segment tree on values of where all armors are sorted by Iterate on weapons and monsters in sorted order sort by in non descending order For each new weapon we should add all monsters which were not added yet we can maintain a pointer on the last added monster to find them quickly Adding a monster means adding on suffix of After that for the current weapon we may try as the answer 
You wrote down all integers from 0 to 10 n 1 padding them with leading zeroes so their lengths are exactly n For example if n 3 then you wrote out A block in an integer x is a consecutive segment of equal digits that cannot be extended to the left or to the right For example in the integer 00027734000 there are three blocks of length 1 one block of length 2 and two blocks of length 3 For all integers i from 1 to n count the number of blocks of length i among the written down integers Since these integers may be too large print them modulo 998244353 ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\nll pw[201000];\nint main() {\n\tscanf(""%d"",&n);\n\tpw[0]=1;\n\tfor (int i=1;i<=n;i++) pw[i]=pw[i-1]*10%mod;\n\tfor (int i=1;i<=n;i++) {\n\t\tif (i==n) { puts(""10""); continue; }\n\t\tint d=0;\n\t\tif (i<=n-2) d=(d+10*(n-i-1)*9*9*pw[n-i-2])%mod;\n\t\td=(d+2*10*9*pw[n-i-1])%mod;\n\t\tprintf(""%d "",d);\n\t}\n}']","[0, 1, 0, 1, 0]",1800,Presume that we want to calculate the number of blocks of length len Let s divide this blocks into two types blocks which first element is a first element of integer or blocks which last element is a last element of integer for example blocks 111 and 0 in integer 11173220 other blocks At first let s calculate the number of blocks of first type We can choose 2 positions of this block at the start of end of the integer Now we can choose 10 digit for this block After that we can chose 9 digits of adjacent block if these blocks contain the same digit then we length of blocks which we want calculate greater than len so we have only 9 variations of digit in adjacent block Finally the can chose the remaining digit 10 n len 1 ways So the total number of block of first type is 2 cdot 10 cdot 9 cdot 10 n len 1 Now let s calculate the number of blocks of second type We can choose n len 1 positions of this block all position except the start and end of integer Now we can choose 10 digit for this block After that we can chose 9 2 digits of adjacent block 9 for block to the left and 9 for block to the right Finally the can chose the remaining digit 10 n len 2 ways So the total number of block of second type is n len 1 cdot 10 cdot 9 2 cdot 10 n len 2 That s almost all We have one corner case If len n then we number of blocks is always 10 
Gennady is one of the best child dentists in Berland Today children got an appointment with him they lined up in front of his office All children love to cry loudly at the reception at the dentist We enumerate the children with integers from to in the order they go in the line Every child is associated with the value of his The children take turns one after another to come into the office each time the child that is the first in the line goes to the doctor While Gennady treats the teeth of the th child the child is crying with the volume of At that the of the first child in the line is reduced by the amount of the second one by value and so on The children in the queue after the th child almost do not hear the crying so their remains unchanged If at any point in time the of the th child is less than zero he begins to cry with the volume of and leaves the line running towards the exit without going to the doctor s office At this the of all the children after the th one in the line is reduced by the amount of All these events occur immediately one after the other in some order Some cries may lead to other cries causing a chain reaction Once in the hallway it is quiet the child who is first in the line goes into the doctor s office Help Gennady the Dentist to determine the numbers of kids whose teeth he will cure Print their numbers in the chronological order ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nconst int N = 4040;\nint n;\nint m;\nint v[N], d[N], p[N];\nint ans[N];\nbool used[N];\nint q[N];\nint topQ;\n\nint main()\n{\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; i++)\n        scanf(""%d%d%d"", &v[i], &d[i], &p[i]);\n    int k = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (used[i]) continue;\n        ans[m++] = i + 1;\n        int r = v[i];\n        for (int j = i + 1; j < n && r > 0; j++)\n        {\n            if (used[j]) continue;\n            p[j] -= r;\n            if (p[j] < 0)\n            {\n                used[j] = 1;\n                q[topQ++] = j;\n            }\n            r--;\n        }\n        while(k < topQ)\n        {\n            int v = q[k++];\n            for (int j = v + 1; j < n; j++)\n            {\n                if (used[j]) continue;\n                p[j] -= d[v];\n                if (p[j] < 0)\n                {\n                    used[j] = 1;\n                    q[topQ++] = j;\n                }\n            }\n        }\n    }\n    printf(""%d\\n"", m);\n    for (int i = 0; i < m; i++)\n        printf(""%d "", ans[i]);\n\n    return 0;\n}']","[0, 0, 1, 0, 0]",1800, Let s store for each child his current confidence value and a boolean indicating whether child had left the queue or visited the dentist office or not Then one could easily process children one by one considering only children who still are in the queue using boolean array and changing stored values Such solution has complexity and requires author s attention much especially the case with possible confidence value overflowing Of course there are much faster solutions not required in our case 
Fox Ciel is going to publish a paper on FOCS Foxes Operated Computer Systems pronounce Fox She heard a rumor the authors list on the paper is always sorted in the order After checking some examples she found out that sometimes it wasn t true On some papers authors names weren t sorted in order in normal sense But it was always true that after some modification of the order of letters in alphabet the order of authors becomes She wants to know if there exists an order of letters in Latin alphabet such that the names on the paper she is submitting are following in the order If so you should find out any such order order is defined in following way When we compare and first we find the leftmost position with differing characters If there is no such position i e is a prefix of or vice versa the shortest string is less Otherwise we compare characters and according to their order in alphabet ,"['#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T>\nbool uin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool uax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvi e[30];\nint vis[30];\n\nvi ord;\n\nbool dfs(int v) {\n    if (vis[v] == 2) return true;\n    if (vis[v] == 1) return false;\n    vis[v] = 1;\n    for (int u: e[v]) {\n        if (!dfs(u)) return false;\n    }\n    vis[v] = 2;\n    ord.pb(v);\n    return true;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(""input.txt"", ""rt"", stdin);\n#endif\n\n    int N;\n    cin >> N;\n    vector<string> a(N);\n    forn(i, N) cin >> a[i];\n    bool ok = true;\n    forn(i, N - 1) {\n        int j = 0;\n        while (j < a[i].size() && j < a[i + 1].size() && a[i + 1][j] == a[i][j]) ++j;\n        if (j == a[i + 1].size() && j < a[i].size()) ok = false;\n        else if (j < a[i].size() && j < a[i + 1].size()) {\n            e[a[i][j] - \'a\'].pb(a[i + 1][j] - \'a\');\n//            cerr << a[i][j] << \' \' << a[i + 1][j] << \'\\n\';\n        }\n    }\n    forn(i, 26) ok &= dfs(i);\n    if (!ok) cout << ""Impossible\\n"";\n    else {\n        reverse(all(ord));\n        forn(i, 26) cout << (char)(\'a\' + ord[i]);\n        cout << \'\\n\';\n    }\n\n#ifdef LOCAL_DEFINE\n    cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n#endif\n    return 0;\n}\n']","[1, 0, 0, 0, 0]",1600,Let s first think about what can tell us suppose and Then we know that if and only if by the definition So we can transform the conditions into the order of letters Then the question become do we have a permutation that satisfy those conditions It is actually the classic topological order question One trick in this task is that if we have something like then there is no solution This is not covered in pretests 
The board has got a painted tree graph consisting of nodes Let us remind you that a non directed graph is called a tree if it is connected and doesn t contain any cycles Each node of the graph is painted black or white in such a manner that there aren t two nodes of the same color connected by an edge Each edge contains its value written on it as a non negative integer A bad boy Vasya came up to the board and wrote number near each node the sum of values of all edges that are incident to this node Then Vasya removed the edges and their values from the board Your task is to restore the original tree by the node colors and numbers ,"['#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <initializer_list>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\n#ifndef ONLINE_JUDGE\n#define DEBUG\n#endif\n\n#define oo 0x3F3F3F3F\n#ifdef DEBUG\n#define cvar(x) cerr << ""<"" << #x << "": "" << x << "">""\n#define evar(x) cvar (x) << endl\ntemplate<class T> void DISP(const char *s, T x, int n) {cerr << ""["" << s << "": ""; for (int i = 0; i < n; ++i) cerr << x[i] << "" ""; cerr << ""]"" << endl;}\n#define disp(x,n) DISP(#x "" to "" #n, x, n)\n#else\n#define cvar(...) ({})\n#define evar(...) ({})\n#define disp(...) ({})\n#endif\n#define fst first\n#define snd second\n#define PB push_back\n#define SZ(x) (int)((x).size())\n#define ALL(x) (x).begin(), (x).end()\n\ntypedef unsigned int uint;\ntypedef long long int64;\ntypedef unsigned long long uint64;\ntypedef long double real;\n\nint64 pow(int64 b, int64 e, int64 m) { int64 t = 1; for (; e; e >>= 1, b = b * b % m) e & 1 ? t = t * b % m : 0; return t; }\ntemplate<class T> inline bool chkmin(T &a, T b) {return a > b ? a = b, true : false;}\ntemplate<class T> inline bool chkmax(T &a, T b) {return a < b ? a = b, true : false;}\ntemplate<class T> inline T sqr(T x) {return x * x;}\ntemplate <typename T> T gcd(T x, T y) {for (T t; x; t = x, x = y % x, y = t); return y; }\n\ntemplate<class edge> struct Graph\n{\n  vector<vector<edge> > adj;\n  Graph(int n) {adj.clear (); adj.resize (n + 5);}\n  Graph() {adj.clear (); }\n  void resize(int n) {adj.resize (n + 5); }\n  void add(int s, edge e){adj[s].push_back (e);}\n  void del(int s, edge e) {adj[s].erase (find (iter (adj[s]), e)); }\n  vector<edge>& operator [](int t) {return adj[t];}\n};\n\nset<pair<int, int>, greater<pair<int, int>>> W, B;\n\nint main ()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""D.in"" , ""r"", stdin);\n\tfreopen(""D.out"", ""w"", stdout);\n#endif\n\tios_base::sync_with_stdio (false);\n\n\tint n;\n\t\n\tcin >> n;\n\tfor (int i = 1, c, s; i <= n; ++i) {\n\t\tcin >> c >> s;\n\t\tif (c == 0) W.insert(make_pair(s, i));\n\t\telse B.insert(make_pair(s, i));\n\t}\n\tvector<pair<pair<int, int>, int>> ans;\n\n\tpair<int, int> disX, disY;\n\tfor (; !W.empty() && !B.empty(); ) {\n\t\tpair<int, int> x = *W.begin(), y = *B.begin();\n\t\tW.erase(x), B.erase(y);\n\t\t\n\t\tint v = min(x.fst, y.fst);\n\t\tans.push_back(make_pair(make_pair(x.snd, y.snd), v));\n\t\tx.fst -= v, y.fst -= v;\n\t\tif (y.fst || (!x.fst && !y.fst && SZ(W) > SZ(B)))\n\t\t\tB.insert(y), disY = y;\n\t\telse\n\t\t\tW.insert(x), disX = x;\n\t}\n\tfor (auto x : ans)\n\t\tcout << x.fst.fst << "" "" << x.fst.snd << "" "" << x.snd << endl;\n\n\treturn 0; \n}\n']","[1, 0, 0, 0, 0]",2100,The problem can be solved constructively maintaining the following invariant rule the sum of the white vertices equals to the sum of the black vertices The tree is a bipartite graph so we build bipartite graph with no cycles which will satisfy the conditions of the problem Parts of graph will be black and white vertices On each step we will choose vertex with minimum sum from white and black vertices Then find any vertex of opposite color and add edge with weight and subtract from sum of sum of that is After each step one vertex is deleted That s why there will be no cycles in constructed graph When we delete last vertex of one of colors all other vertices can be joined in any correct way with edges of weight 
Kirill has two integer arrays a 1 a 2 ldots a n and b 1 b 2 ldots b n of length n He defines the of the array b as sum i 1 n a i b i Here x denotes the absolute value of x Kirill can perform the following operation select two indices i and j 1 leq i j leq n and swap the values of b i and b j Help him find the maximum possible absolute beauty of the array b after performing swap ,"['/**\n                                                                                   .@@\n                                                                                  .@@@@\n                                                     :--:::::::-----==:           %%@@@%\n                                             :*++*+==--========----------:-==:    @%@@@@.\n                                        .:. ..-=+=+*+==---=----------------------:*@%@@@@         .:..\n                                    .::::-----==+++====+***#+----=------:--------:-=%%@@@#+%@@@@@@@@@@@@@@@@@@@@@@@\n                :+%@@@@@@@@@@@@@@%::::=*=+++++=++==*%*=-:=*#+##=-----------------:::-@%@@@@@@@@@@@@@@@@@@@@@@@@@@@*\n             %%%%%%%%%%%%@@@@@@= .:=%@@@@@%#+=+++%@@@%+-==--++-=*=-------------:-----:*@@@@@@@@@@@@@@@@@@@@@@@@@@%\n             .@%%%%%%%%%@@@@%-  .-+%@@@%@%%%####%#*#%%%%==----+=:-++-::------=----:::-:=@@@@@@@@@@@@@@@@@@@@@@@@%\n               %%%%%%%%@%@@+  .::*%@@@@%#**#####******+*%+===---+=..:==---------:---::::-@@@@@@@@@@@@@@@@@@@@@@@\n                %%%@%@%@@@:  .:.%%%%%#=+*+*+*#*+=+***+*#+##=--=-:-+.   ==--------::::--::-@@@@@@@@@@@@@@@@@@@@@\n                .#%%%@%@%   . -@%%%*==+*++++**+++=+*++=++=+#--=----=:    +---:-::::::::--:-%@@@@@@@@@@@@@@@@@@=\n                 :@%%%@=   . =%%%#---======+=========++=====*+--=-=--=.    --::::::::::::--=@@@@@@@@@@@@@@@@@@@:\n                  @%@#   .  -%%*+---========-:===++======-==-==--=-----:     :-::::::::::::-=@@@@@@@@@@@@@@@@@@@=\n                  @#.   .  .#*=+.-=-==-==-=-::===+=-==-=--=--==+=:------=     .-:::::::-:--:--#@@@@@@@@@@@@@@@@@@#\n                 -         #+=-.:----=------.:-=-*===----==--==-+=-:::-::-:     :-::::::::::::==+@@@@@@@@@@@@@@@@@@\n                     .    -==:..-=--==--:--:.-===+====----=====--=--::::::--      ::::::::::--:=%*=*@@@@@@@@@@@@@@@@.\n                .+: .    .==-. :----==-::--:.---==-===---:------:----::::::-+       -:::------=--+#+#@@@@@@@@@@@@@@@@.\n              .  . -    ::--. .::---:-:.-=-: :--==--==:=--:-::::::--=-:::-:::*.      :::-==-==--:--**@@@@@@@%@@@@@@@@@=\n                :.:     :::.. .--:::::: --::.:-:---:--:--:::::::::--:==:::::::+.       -:-=-=------:*+@@@@@@@@+ #@@@@@@\n               #-.     -::.. .=+:::::-:.--:-:.::::::::::+:::::::::::::=-:::::::=.       :=-=---------=%@@@@@@@@@  :@@@@\n             =@-.     :=..   -=::::-:=.:::::-.::::::::::%.::::::::::::-=:::::::-+-        *%+=-------::%@@@@@@@@@:   :.\n            #@*.      +-..  :-:::::::-..::::::.:::::::::%:-==:..::::::--+:::-:-====        :*%*+--------@@@@@@@@@@@\n          .@@#       :=:   .::::::::-:.::::::-.::::::.::#.:-=-.:..::-.::-+:-=--===-=         -#++*+===-:#@@@@@@@@@@@@\n         *@@*.    .  --.  .:::::::::-..::::.:::.::..:..-+:: :.......=-.::==--==-====-         .**++++++=*@@@@@@@@@@@@@@:\n       =@@@==.   .: .=-.  ::::::.:::= .::::...::.-.....+::.  - :....:*::--==--=======-          -*++=+=++@@@@@@@@@@@@@@@@@@%-\n     +@@@@::- . .:- :=-. .::::::.::=- .::......=.=.....+ :.  :  ... - -:-==+---==-=--*: .        .*++++=+%@@@@@@@@@@@@@@@\n   :@@@@%.=.. : :--.-=:..:.::.:....-  ......... --:   ::.:.  .  :::.-  ----=#+====-==-*.           :*++=++@@@@@@@@@@@@@.\n     +*#-- :.:: :-::==..::.:..:...:: .:....... . ::   :. :.      -::. ..:#=-=+-==-===-=+.+       ..  -+=++%#=-+=%@@@@#\n        . ...::.--::==: ::........-:..=-   :  .   .   . .:.      :-*-    .:=-+====-==--=-+#       :.   +++++==+++++*@@*\n          :.::.::-.-==-.=-:...--.: :.::-.  :            .:    :+--:.     ::.==+===---=-=+--%.      +@@=. :=*+++++++*++*\n          .::::::::==---=-:.. =- .  ..: :..:  .:...  :  -. .+.   -*=:.+@@@@@@@@*====---=+*:**. .    =@@**%+:-+*%*++***+=\n       . ...::::::-+=--+-=:--.+:.    ..  :.-.:::::. .:  :.*.  :-:+#@@%#++=%:-@##+===-==-=+--==+ ..   .###*+++**#@%#+*+++*=\n       ..::::::::.*+--:=-----:=:-....::=:--=:....:..=. :.    ..+@@@*+==---#-=@*+*====-===+:-=*@% ::    *#*+*#+*++#%%%%##*+++-\n       .::.:::::::%=--:-------: .     : -:-+#+-....= ..:     -*#::%+-:=+---:+**-+==-===-=-+-=@@@@ -#    =***#%#+*+#%==*+\n      :.:::::::::-+=:---=-----. .      :. ::=..:..:   .       :   -=--:..:--+#-:-+=======-%==#@@@@:.@=   :#***%%#*+=#-==\n      :-::-::::.:--*:---=-=---: . ..-+*#%#=-+:...:.                :+-....-+=::::#=======-*%-+@@@%@@-%%-  .#++*%%#*+#*+-\n    . =-:::=:::::-:+.:--=-=--:- .=**+-:::+++%-..:.   .               ::..--:....:=#-=====-#@+=@@@%*%@%%@%-  -*+#%:*%++*=\n      =:::---:------::-:==-=--+.      ....:  :.:.                     .   ......::*=-====-*@#-%@@%#*%%%%%%@*. +**- .*#**=\n     +:::. :---=--=:=:-:==-==-:@.    .....:. ..:.                       ...::...--:*=====-+@@-*@%%*##%%*###+#*= +-  ::-:**\n     ::-:   .:---.#:=.:-==-==-:%%    ....  ..:  :                              :=  ==-+==-*@@=*@%#**#%#****##*++**- .:     .\n    .--      .:--:=:=-.-==-==-:%@+   ....   .:                                ::   :=--===#@@**%%**#*##***++**+=+*- ::\n   :.         :----=.- -=-====-%@@:   ...   .      .                         .     :---==-@@@#%%%#*#*******+++***+# :\n .             -:--: .:-+--==-:%@@@                                              . #%:-===@@@#%##*##**+++#*+*+*+****-\n                ::-:  *:%==----*+%@%   .                                        . #@%--+=*@%@%%##**#**+++%#*==+*++*+=\n                -=:-. #:+#+---:#%++%#.                      . .:. .:+          ..#@@@--**%%%%%###*+#++*++*--+*==+++-+.\n                . =:: -==%@--=-=%**%%+                 =@+ .....:.:.:.         .*:@@%--%%@%%%####**#++*+++--:   .+*-==\n                   :---+**%%---:@**%%#+     .      :@%%%::.:::::..:.:         .-::%%%-:@%%%%%###**#*+++=*+-::    :==:-=\n               .    :=-+*##*#:-:**+*%**@:           =@#*:.::::::::::        .:...:@%%-+%%%%%###**+%*==+=%=:-.    ..    :.\n               .     +*=+**%**-:=***##*+%%.        . .*%.:::::::::..       :. ....@%%=%%%#*#####+#%+===+:-:-.    .\n                     .+-++**#+** +*-*++++%%%.    ..     --:.::.:::       =: .    .%%#+%%####*+@*++%+=-+. .:-\n                      --++=**#*+*-++==+++%%%#@+..         .:::.        :=.  .    .%%%#*#*##*#+#=++#===:  .-\n               .    . =-=+****+**+#:+==++#%%#%%%@%=. ..              :-:       .  %#%###%*##.:*+==#++-    :\n                    .  :-=+=++***++#-:+++*++*#%%%%@@%=.. ..       :---.           #@@%@@@@=  :=  .+-+-\n                .    . :.-===++**+==*+::+#++++*#%%%%%%%%-.     .*=:-:.            *%%%##*==+**#*+==*+=\n                     :  -::====++*=+=+*==*=-=#**##%#%%%%%*+-:%#--:-. ..           .%#*=-==-*#*++==++-=#*:\n                     :*::**=====+**==+=++*##*+++**##%%%%%%. :::.:. ..             .:=--===+@#*+++=+*+=-=+=*#=\n                     #-=+==*=-++++#++==-++++*++++*#%%%%%%=-  .:.... .            .  -=--=+@#*#%@@%+==+=====+*+\n                   ..*++==+**+:=*++%++++#++++++*+**#%%%%#-=. .:........              .@-=+++#%%@@%@=======++*@+\n                .+-.-+*==*++#+-:=++*%+=**++++++*++**%%%%--=-.::..........            .: ==++*%@@%@+========+*#@@+\n               -:--.=-*+*+++++=:.:-+*#+++*****=+*##%+#%==---::...........           :    .+%@@@%@#+======++*#%%@@#%=\n              +::-:==--=*==**=#=:::-+#**+*+**++**%=.-++-:::--... ..  ....          :.     ..-@@@*++====++++*#%@@@%*=+.\n              =---.=--:*+=+#*+=:-:--=++=**+++++*#+:=-.--:.:::..........           +        ..*%-+=-====+++*###@@@#+=+#*\n              =----==-*+===@%:..-=---++##=+++***#-. .:=::...:..........         :=          :*:==-=====+++*%#%@@*++++##@*\n             .+=-=*=+#*---==%:.:-=%+#+-:--+++*+*%:..  -::.............         :.          .--==-=======+*#*%@%+++==+##@#%+\n             -:=##*+=-::-===+:.--+*#---::+*++++#+ ....-  .:.........  ..   . :+. .         =============+**#*++++===*%%#%###.\n             :--*#@*+-::::-==-:-=#=.---:-+*==+#-......-:  ..........        :.            +============+*##**++====*%%%#**+=+\n            .:---%=@*+-::--:-:.-*=:=:--=#++*@%-... . .-:.... ......       .:.           .=-===========+**+++===-===*#***+++=-:\n            ..:-==+*#+*=:-::--.=+=::-=+*+%@+#@%.... ..-:.  .........     .-            .+============++========--===++**++==--\n             .:----++%**-::  .+=+=++++++*%#+@@@%......-:.  .            =. .          .+-===-===-==++==--===------==+++====--:\n              ..:--=*#%*+=   .=%##-:-+++*##+@@@@@.... -:.  .         ..-             -+==-======++*=======------==++======+*#*\n               .::=-=#+#-  .::=#-:-:=++=+##*@@@@@@.. .::.  .         -:      .     .=+==-==+-==++=:=---=----========+**+=----:=\n                .::--=+#=.:::-*=:::::++=+*#*%.#@@@@:..::.   .   .  .+           .=#*++++*+=====--=-=---=--=+**##*+=====-------:-\n                 ..::-=*+::::=:.::::--===**+*. -@@@@:.::  ...  .  -.. .  .  .-%@@@*+*#*#*+====--=-:----*##*+==--==---======----:\n                   ..:-:+:-:--:::--:::-+#*+++:   @@@@+:-  ..  .  +. ..   -@@@@@@@*@%*###*======*+-=-=%#=-=======-====-=======-:-+\n                     ..:=::::::::::-:**++=-++.   .@@@@#= . .   :+    :#@@@@@@@@@%##%%%%#+++==#@%%@=**+==========-------=====-=+==\n                       .  .:::::::--+==----+#++.  .@@@@@ .. ..:::+#%@%@@@@@@@#@%%%%%%@%*=+#@@@%@#%@=============------=====++++=+\n                          ....  ..::=-:----+*=+**=++@@@@@:.-*@@%%%%%@@@@*:. .@@%%@%%@%**%@@@@@##@@*========--------=====+++*#*+==\n                           .    ...::=:--==++=+++=+++%@@@@@@@%%@%@@#-      :%#%%%%@%#@@@@@@@%#@*@@+--===-----------======*##**=--\n                                ...:.--:--=*+===++=++=#@@@@@%%%#*++=.     :%%%@@%%@@@@@@@@+@@#+*@@+===-----------====+++*##**+=-:\n                                ....:+=:-==#++===+++===%@@%#*+==+++++++*##@@@%@@@@@@@@@**%##+=-%@#=-------------====+++*##*++=-:.\n                                 ..:-+#===+#  .-:=+=*+*+#*+==+++++++++**%@@@@@@@@@@@*-@@#+=+==+@@=--------------===+++*##*+=-:.\n                                  ..:=%+==+%       =#*-##*#+=%+++=++*+#%@@@@@@@@@@:%@#*=+=-+=#@@+-=-------------====+*#*++=-:.\n                                     .=*===*      .--#:..-#@@-.   .:=**@@@@@@@@*@@@%+%+@@=--#@%=--:----------------=+++==-:.\n                                       =::--         :*-##==-.        -@@@@@@@@@@@@@@@@@@@@@%+=::::::::::::::::::--====-:..\n                                           ...        *%=-.....       %@@@@@@@@@@@@@@@@@@@@@*-::..:.............:::--:..      .-:\n                                                  ::  ==.   .....    +@%@@@@@@@@@@@@@@@@@@@@*.:. . ...          .... .     =@*-:\n                                                      ::..:---::... :#*#@@@@@@@@@%%@@@@@@@@@@+ .                  :*    ##+%+:\n                                                             ...::::*-:::@@@@@@%##%%%%@@@@@@@#                   -+. *+ =  -:\n                                                                   ..  .#@@%%%%##*+*#%@@@%%%=                    . :     ::\n                                                                        @@@%%%######%%%%#####%=                =        #\n                                                                          @@@@@%@@%%%###*##*-                 . .     =\n                                                                          :@@%%%%###******+=-                 .\n                                                                            *@###***+**+++:\n                                                                               -*- =*++*:\n\n\n                                         Credit for the pic: J5-daigada from deviantart\n*/\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <limits>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    int l = 0, r = 1e9 + 10;\n    long long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        cin >> b[i];\n        l = max(l, min(a[i], b[i]));\n        r = min(r, max(a[i], b[i]));\n        ans += abs(a[i] - b[i]);\n    }\n    if (l > r) {\n        ans += 2 * (l - r);\n    }\n    cout << ans << ""\\n"";\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int uwu = 1;\n    cin >> uwu;\n    while (uwu--) {\n        solve();\n    }\n    return 0;\n}\n']","[1, 1, 0, 0, 0]",1900,SolutionThe pair represents some interval and is its length Let us try to maximize the sum of the intervals lengths We present three cases of what a swap does to two arbitrary intervals Notice how the sum of the lengths increases only in the first case We want the distance between the first interval s right endpoint and the second interval s left endpoint to be as large as possible So we choose integers and such that and is maximized We add twice the value if it is positive to the original absolute beauty If the value is or negative we simply do nothing To quickly find the maximum of over all and we find the maximum of and the minimum of Subtracting the two extremum values produces the desired result 
Dmitry has n segments of different colors on the coordinate axis Ox Each segment is characterized by three integers l i r i and c i 1 le l i le r i le 10 9 1 le c i le n where l i and r i are are the coordinates of the ends of the i th segment and c i is its color Dmitry likes to find the minimum distances between segments However he considers pairs of segments of the same color uninteresting Therefore he wants to know for each segment the distance from this segment to the nearest colored segment The distance between two segments is the minimum of the distances between a point of the first segment and a point of the second segment In particular if the segments intersect then the distance between them is equal to 0 For example Dmitry has 5 segments The first segment intersects with the second and these are segments of different colors so the answers for them are equal to 0 For the 3 rd segment the nearest segment of a different color is the 2 nd segment the distance to which is equal to 2 For the 4 th segment the nearest segment of a different color is the 5 th segment the distance to which is equal to 1 The 5 th segment lies inside the 2 nd segment and these are segments of different colors so the answers for them are equal to 0 ,"['#include <bits/stdc++.h>\n#define dprintf(...) //printf(__VA_ARGS__)\nusing namespace std;\ntypedef long long LL;\n\nstruct Seg {\n  int l, r, c, idx;\n\n  bool operator<(const Seg& other) const {\n    if (l != other.l) return l < other.l;\n    if (r != other.r) return r < other.r;\n    return idx < other.idx;\n  }\n\n  int dist(const Seg& other) const {\n    if (l <= other.l && other.l <= r) return 0;\n    if (l <= other.r && other.r <= r) return 0;\n\n    if (other.l <= l && l <= other.r) return 0;\n    if (other.l <= r && r <= other.r) return 0;\n\n    if (r < other.l)       // [l,r] [ol,or]\n      return other.l - r;\n    else                   // [ol,or] [l,r]\n      return l - other.r;\n  }\n};\n\nstruct SegSet {\n  map<int, Seg> mp;  // l=>r\n\n  int dist(const Seg& seg) {\n    auto it = mp.lower_bound(seg.l);\n    if (it != mp.begin()) it--;\n    if (it != mp.begin()) it--;\n    int ans = INT_MAX;\n    for (int k = 0; k < 5 && it != mp.end(); it++, k++) {\n      ans = min(ans, seg.dist(it->second));\n    }\n    return ans;\n  }\n\n  void add(Seg seg) {\n    auto it = mp.lower_bound(seg.l);\n    if (it != mp.begin()) it--;\n\n    while (it != mp.end() && it->second.r < seg.l)\n      it++;\n\n    while (it != mp.end() && seg.dist(it->second) == 0) {\n      seg.l = min(seg.l, it->second.l);\n      seg.r = max(seg.r, it->second.r);\n      auto it2 = it; ++it2;\n      mp.erase(it);\n      it = it2;\n    }\n\n    mp[seg.l] = seg;\n  }\n\n  void print() {\n    for (auto [k, seg] : mp)\n      dprintf(""[%d,%d] "", seg.l, seg.r, seg.c);\n    dprintf(""\\n"");\n  }\n};\n\n\nvoid solve() {\n  int N; cin >> N;\n\n  vector<Seg> segs(N);\n  for (int i = 0; i < N; i++) {\n    cin >> segs[i].l >> segs[i].r >> segs[i].c;\n    segs[i].idx = i;    \n  }\n\n  map<int, vector<Seg>> segs_by_color;\n  for (int i = 0; i < segs.size(); i++) {\n    segs_by_color[segs[i].c].push_back(segs[i]);\n  }\n\n  vector<int> colors;\n  for (auto& [color, color_segs] : segs_by_color) {\n    colors.push_back(color);\n  }\n\n  vector<int> ans(N, INT_MAX);\n\n  for (int dir = 0; dir < 2; dir++) {\n    SegSet segset;\n    dprintf(""dir=%d\\n"", dir);\n\n    if (dir == 1) reverse(colors.begin(), colors.end());\n\n    for (int i = 0; i < colors.size(); i++) {\n      auto& color_segs = segs_by_color[colors[i]];\n      dprintf("" color=%d "", colors[i]);\n\n      for (auto& seg : color_segs) {\n        int ss_dist = segset.dist(seg);\n        ans[seg.idx] = min(ans[seg.idx], ss_dist);\n      }\n\n      for (auto seg : color_segs) {\n        dprintf(""add[%d,%d] "", seg.l, seg.r);\n        segset.add(seg);\n      }\n      dprintf("" => "");\n      //segset.print();\n    }\n  }\n\n  for (int i = 0; i < ans.size(); i++) printf(i ? "" %d"" : ""%d"", ans[i]);\n  printf(""\\n"");\n  dprintf(""\\n"");\n}\n\nint main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n\n  int T; cin >> T;\n  for (int cs = 1; cs <= T; cs++) {\n    solve();\n  }\n}\n']","[0, 1, 0, 0, 1]",2000,Let s go through the segments times in non decreasing coordinates of the left end and then in non increasing coordinates of the right end To walk a second time just multiply the coordinates of the left and right borders by and then swap them and walk from left to right Going through the segments in non decreasing coordinates of the left end you need to find for each segment a segment that starts not to the right of the current one and ends as far to the right as possible If the coordinate of its right end is not less than the coordinate of the left end of the current segment then it intersects with it otherwise the distance between them is equal to the distance between the coordinate of the left end of the current segment and the maximum coordinate of the right end of the segment starting to the left of ours Note that it is enough for us to store no more than segments for each color we will store the maximum right coordinate of the segment of this color which has already been considered If we store the colors with the largest right coordinates then one of them is definitely not equal to the current one When considering a segment we add it to the list and if the size of the list becomes then we leave of optimal elements 
William has an array of n integers a 1 a 2 dots a n In one move he can swap two neighboring items Two items a i and a j are considered neighboring if the condition i j 1 is satisfied William wants you to calculate the minimal number of swaps he would need to perform to make it so that the array does not contain two neighboring items with the same parity ,"['//Awwawa! Dis cold yis ratten buy Pikachu!\n#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define vi vector<int>\n#define pi pair<int, int>\n#define mod 998244353\ntemplate<typename T> bool chkmin(T &a, T b){return (b < a) ? a = b, 1 : 0;}\ntemplate<typename T> bool chkmax(T &a, T b){return (b > a) ? a = b, 1 : 0;}\nll ksm(ll a, ll b) {if (b == 0) return 1; ll ns = ksm(a, b >> 1); ns = ns * ns % mod; if (b & 1) ns = ns * a % mod; return ns;}\nusing namespace std;\nconst int maxn = 200005;\nint a[maxn];\nint n;\nint main() {\n    int t;\n    cin >> t;\n    while (t--) {\n        scanf(""%d"", &n);\n        int cnt[2] = {0, 0};\n        for (int i = 1; i <= n; i++)\n            scanf(""%d"", &a[i]), a[i] %= 2, cnt[a[i]] += 1;\n        ll ans = 1e18;\n        for (int tp = 0; tp < 2; tp++) {\n            if (cnt[tp] != (n + 1) / 2) continue;\n            // tp : first\n            int g[2] = {0, 0};\n            ll na = 0;\n            for (int i = 1; i <= n; i++) {\n                g[a[i]] += 1;\n                if (a[i] == tp) {\n                    int cr = g[tp] - 1;\n                    na += abs(cr - g[tp ^ 1]);\n                }\n            }\n            chkmin(ans, na);\n        }\n        if (ans > 1e12) ans = -1;\n        printf(""%lld\\n"", ans);\n    }\n    return (0-0); //<3\n}']","[0, 0, 1, 0, 0]",1300,Note that if the condition is satisfied where is the number of odd numbers and is the number of even numbers then it is impossible to get the required array Now note that it is enough to consider two cases and choose the minimum answer from these cases The first element will be an odd number The first element will be an even number Now we will describe the general solution Suppose we are now at position and we must put an element with parity on it Then we need to find the first element with opposite parity where After we have done this it is enough to swap and and add to the answer To quickly search for a suitable element it is enough to use two pointers which will point to the current available even and odd numbers 
You are given a graph K n with n vertices each pair of vertices u neq v in K n have both directed edges u v and v u there are no self loops You should find such a cycle in K n that visits every directed edge exactly once allowing for revisiting vertices We can write such cycle as a list of n n 1 1 vertices v 1 v 2 v 3 dots v n n 1 1 v n n 1 v n n 1 1 v 1 a visiting order where each v i v i 1 occurs exactly once Find the such cycle It s not hard to prove that the cycle always exists Since the answer can be too large print its l r segment in other words v l v l 1 dots v r ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=101000;\nint _,n;\nll l,r,s[N];\n\nint calc(ll x) {\n\tif (x>s[n-1]) return 1;\n\tauto a=lower_bound(s+1,s+n,x)-s;\n\tint b=x-s[a-1];\n\tif (b%2==1) return a;\n\telse return b/2+a;\n}\n\nint main() {\n\tfor (scanf(""%d"",&_);_;_--) {\n\t\tscanf(""%d%lld%lld"",&n,&l,&r);\n\t\trep(i,1,n+1) s[i]=s[i-1]+2*(n-i);\n\t\tfor (ll i=l;i<=r;i++)\n\t\t \tprintf(""%d "",calc(i));\n\t\tputs("""");\n\t}\n}\n']","[1, 0, 1, 0, 0]",1800,The solution of the problem can be found clearly in constructive way An example for 1 2 1 3 1 4 1 5 2 3 2 4 2 5 3 4 3 5 4 5 1 where brackets mean that we call here some recursive function Since on each level of recursion we have only elements and there levels then the generation of the certificate is quite easy if on the currect level of recursion we can skip the whole part let s just skip it Otherwise let s build this part Anyway the built part of the cycle will have only length so the whole algorithm has complexity The answer is lexicographically minimum by the construction since on each level of recursion there is no way to build lexicographically smaller sequence 
You are given an array a of n integers You are allowed to perform the following operation on it as many times as you want 0 or more times Choose 2 indices i j where 1 le i j le n and replace a k for all i leq k leq j with a i a j Print the maximum sum of all the elements of the final array that you can obtain in such a way ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ls u<<1\n#define rs u<<1|1\n#define mm(x) memset(x,0,sizeof(x))\nusing namespace std;\nint read()\n{\n  int a=0;int f=0;char p=getchar();\n  while(!isdigit(p)){f|=p==\'-\';p=getchar();}\n  while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=getchar();}\n  return f?-a:a;\n}\nconst int INF=998244353;\nconst int P=998244353;\nconst int N=1e6+5;\nint T;\nint n,m;\nint val[N];\nvoid solve()\n{\n  n=read(); int pa=0; int pb=0; ll ans=0; ll sx=0;  ll sy=0;\n  for(int i=1;i<=n;++i) val[i]=read();\n  for(int i=1;i<=n;++i) if(!pa||val[i]<val[pa]) pa=i;\n  for(int i=1;i<=n;++i) if(!pa||val[i]>val[pb]) pb=i;\n  for(int i=1;i<=n;++i) ans+=val[i];\n  if(n==1)\n  {\n    printf(""%lld\\n"",ans);\n    return ;\n  }\n  if(n==2)\n  {\n    ans=max(ans,(ll)abs(val[1]-val[2])*2);\n    printf(""%lld\\n"",ans);\n    return ;\n  }\n  if(n==3)\n  {\n    if(val[1]>val[3]) swap(val[1],val[3]);\n    ans=max(ans,(ll)val[3]*3);\n    ans=max(ans,(ll)abs(val[2]-val[1])*3);\n    printf(""%lld\\n"",ans);\n    return ;\n  }\n  if(n>=4)\n  {\n    ans=(ll)val[pb]*n;\n    printf(""%lld\\n"",ans);\n    return ;\n  }\n}\nint main()\n{\n  T=read();\n  while(T--)  solve();\n  return 0;\n}']","[1, 0, 0, 0, 0]",2000,SolutionLet s first consider the case for The key observation to make here is that we can make all the elements of a subarray zero by applying the operation on range twice Then let s assume the maximum element of the array is at an index We can apply the operation on the range and turn all its elements into Using the above information we can see that to achieve the final array with maximum sum we need to make all the elements in it equal to the maximum element in the array Regardless of the given array this can be achieved by making the last two elements n 1 n zero Then applying the operation on subarray to make all its elements equal to Then making the first two elements 1 2 zero and applying the operation on the whole array making all the elements equal to Thus the maximum sum for the final array will always be In case or we can operate on the left side first to reach the same solution For the maximum final sum would be For when the maximum element is present at index or we can make all the elements of the array into When the maximum element is at index we have the following options Case 1 We can apply the operation on 1 2 then we can convert all the elements of the array into Case 2 We can apply the operation on 2 3 then we can convert all the elements of the array into Case 3 We can apply the operation on 1 3 making all the elements in the array This is redundant since either case 1 or case 2 will give a larger sum as Now considering case 1 if the maximum sum possible would be the current sum of the array see sample 1 and 3 Therefore no operations are required Similar case for case 2 So the maximum possible sum for will be To avoid doing this casework for we can see that there are only 3 possible operations 1 2 2 3 1 3 We will be required to perform operations 1 2 and 2 3 at most two times So we can brute force all possible combinations of operations 1 2 1 2 2 3 2 3 1 3 to find the maximum sum 
Initially you have a coin with value n You can perform the following operation any number of times possibly zero transform one coin with value x where x is x 3 into two coins with value lfloor frac x 4 rfloor What is the maximum number of coins you can have after performing this operation any number of times ,"['#include <bits/stdc++.h>#define ALL(x) begin(x), end(x)using namespace std;void file() {  freopen(""1.in"", ""r"", stdin);  freopen(""1.out"", ""w"", stdout);}using ll = long long;\xa0map<ll, ll> mp;\xa0ll Dfs(ll x) {  if(x <= 3) return 1;  if(mp.count(x)) return mp[x];  return mp[x] = 2 * Dfs(x / 4);}\xa0void Solve() {  ll n;  cin >> n;  cout << Dfs(n) << ""\\n"";}\xa0int main() {  // file();  ios::sync_with_stdio(0), cin.tie(0);  int T;  cin >> T;  while(T--) Solve();  return 0;}']","[0, 1, 0, 0, 0]",800,Let s try to solve this problem naively obviously while we have at least one coin with value we should transform it since it increases the number of coins we get We can simulate this process but the number of transformations we get might be really large so we need to speed this up Let s make it faster the following way instead of transforming just one coin we will transform all coins at once So after one operation we will have coins with value after two operations we will have coins with value each and so on This can be implemented using a simple while loop while the value of our coins is greater than we divide it by and double the number of coins This solution works in It is also possible to derive a formula for the answer the number of times we need to divide a number by so it becomes less than is and the number of coins we will get is to the power of that expression However you must be very careful with this approach because it can have severe precision issues due to the fact that standard logarithm functions work with floating point numbers so they are imprecise You should use some way to calculate without floating point calculations for example iterating or binary searching on the power of you need to divide the number by so that it becomes less than 
Hongcow is learning to spell One day his teacher gives him a word that he needs to learn to spell Being a dutiful student he immediately learns how to spell the word Hongcow has decided to try to make new words from this one He starts by taking the word he just learned how to spell and moves the last character of the word to the beginning of the word He calls this a He can apply cyclic shift many times For example consecutively applying cyclic shift operation to the word abracadabra Hongcow will get words aabracadabr raabracadab and so on Hongcow is now wondering how many distinct words he can generate by doing the cyclic shift arbitrarily many times The initial string is also counted ,"['#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n#define FOR(i,n) for(int i=0;i<(n);++i)\n#define FORU(i,j,k) for(int i=(j);i<=(k);++i)\n#define FORD(i,j,k) for(int i=(j);i>=(k);--i)\n\nusing namespace std;\n\nusing lli = long long int;\nusing pll = pair<lli, lli>;\n\nconst long long int oo = 1000*1000*1000;\n\nstruct Coord\n{\n\tint x, y;\n\tCoord(int x = 0, int y = 0) : x(x), y(y) {}\n\tCoord operator + (const Coord& droite) const\n\t{\n\t\treturn Coord(x + droite.x, y + droite.y);\n\t}\n};\n\n\nint main()\n{\n\tchar buf[100];\n\tscanf("" %s"", buf);\n\tstring s = buf;\n\tint r = 1;\n\tFORU(i, 1, (int)s.size()-1)\n\t{\n\t\tbool same = true;\n\t\tFOR(j, (int)s.size())\n\t\t\tsame &= s[j] == s[(i+j)%s.size()];\n\t\tif(same)\n\t\t\tbreak;\n\t\t++r;\n\t}\n\tprintf(""%d\\n"", r);\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0]",900,We only need to consider at most s cyclic shifts since s cyclic shifts returns us back to the original string So we can put these all in a set and return the size of the set code 
Monocarp had an array a consisting of integers Initially Monocarp performed three types of queries to this array choose an integer and append it Each time Monocarp performed a query of this type he wrote out a character remove from the array Each time Monocarp performed a query of this type he wrote out a character Monocarp never performed this query on an empty array check if the array is sorted in non descending order i e a 1 le a 2 le dots le a k where k is the number of elements in the array currently If the array was sorted by the time Monocarp was performing that query he wrote out a character Otherwise he wrote out a character You are given a sequence s of q characters and or These are the characters that were written out by Monocarp given in the exact order he wrote them out You have to check if this sequence is consistent i e it was possible for Monocarp to perform the queries so that the sequence of characters he wrote out is exactly s ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(""YES\\n"");\n\telse\n\t\tprintf(""NO\\n"");\n}\n\nint n;\nint g;\nchar wcz[nax];\n\nint ok;\n\nint dfs(int v)//czy dluzsza byla posortowana\n{\n\tint ret=(v<=1);\n\tint nope=0;\n\twhile(1)\n\t{\n\t\tif (g>n)\n\t\t{\n\t\t\tif (ret && nope)\n\t\t\t\tok=0;\n\t\t\treturn ret;\n\t\t}\n\t\tchar c=wcz[g];\n\t\tg++;\n\t\tif (c==\'+\')\n\t\t{\n\t\t\tint wez=dfs(v+1);\n\t\t\tif (wez)\n\t\t\t\tret|=wez;\n\t\t}\n\t\tif (c==\'-\')\n\t\t{\n\t\t\tif (ret && nope)\n\t\t\t\tok=0;\n\t\t\treturn ret;\n\t\t}\n\t\tif (c==\'1\')\n\t\t{\n\t\t\tret=1;\n\t\t}\n\t\tif (c==\'0\')\n\t\t{\n\t\t\tnope=1;\n\t\t}\n\t}\n}\n\nvoid test()\n{\n\tscanf(""%s"", wcz+1);\n\tn=strlen(wcz+1);\n\tok=1;\n\tg=1;\n\tdfs(0);\n\tans(ok);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[0, 0, 1, 0, 1]",1600,First of all let s analyze which situations cause the answer to be There are two types if the number of elements in the array is currently less than the array is definitely sorted So if we get a and the number of elements is or the answer is if the array is sorted but some prefix of it maybe coinciding with the whole array is not sorted this is also a These are the only two situations that cause a We can prove that if none of this occurs the answer is using the following construction every time there is a query we will add to the array every time there is a query and the current array is sorted we will change the last element of the array to and assume we added instead of in the query it was added That way we can ensure that the array stays sorted as long as possible The only cases when this construction doesn t work are we try to change an element to but there is no such element the array is empty or the array stays sorted after the change we change the first element This is exactly when a query appears and the current number of elements is less than we change an element to and it makes the current array non sorted but it has to be sorted due to a query of type affecting it This is exactly when we have a sorted array with a non sorted prefix Okay now we have to check these two conditions somehow The first one is quite easy just keep track of the number of elements in the array every time you process increase it every time you process decrease it every time you process check the number of elements The second condition is tricky There are many approaches on how to handle it I will describe two of them We are interested in a situation when a sorted array has an unsorted prefix Suppose there is a state of our array when this happens In case when this array has multiple prefixes for which we know that they are sorted which one should we choose It should be the longest sorted prefix because we want an unsorted prefix to be shorter or have the same length And among all non sorted prefixes we are interested in the shortest one for the same reason So let s go over the queries and keep track of the shortest non sorted prefix and the longest sorted prefix of our array Let s analyze how our queries affect these two values when we append a new element query of type we no longer know that the current array is sorted but its longest sorted prefix stays the same and its shortest non sorted prefix also stays the same So we don t need to update these values when we delete the last element query of type the length of the sorted prefix might change If it was equal to the number of elements before the query it should decrease by because the last element on that prefix was deleted and the prefix no longer exists As for the length of the shortest unsorted prefix if it was equal to the number of elements in the array before the query it should be set to because maybe the last element of the array made the array unsorted and we don t know anything about the prefixes before it when we process a query of type or we should update the shortest non sorted prefix or the longest sorted prefix accordingly After each query we can just check that the longest sorted prefix is shorter than the shortest non sorted prefix or one of them doesn t exist Let s visualize all states of the array using a rooted tree Every moment of time after a query corresponds to some vertex in this tree and one vertex is a parent of another vertex if the array in the state represented by is the same as the array represented by but without the last element For example if the string of queries is the tree looks like this the labels on the vertices correspond to the number of queries after which the array is in that state This tree can be constructed from the query string as follows Start with the root vertex which represents the state when the array is empty Every time you get a query you need to go down the tree because if you go down the tree to an existing vertex it means that the states will coincide and the arrays in these two states are not necessarily similar If you get a query you go up the tree so you either maintain the current path in the tree in a stack or store a parent for each vertex to know where to go when you go up Okay now what about queries of type and Every time we process such a query we mark the current vertex to remember that it has a or a in it For example you can store two boolean arrays that give you the information whether a vertex is marked with and whether a vertex is marked with So how does this tree help us in solving the problem Recall what we re trying to check we want to find out if a sorted array has a non sorted prefix In terms of our tree it means that To check that in you can for example run a series of DFS traversals from all vertices marked with and make sure that you don t visit any vertices marked with Or you could do it in a single DFS as the model solution does which for each vertex in the tree computes if it has a vertex marked with in its subtree 
You are given two arrays a and b of n positive integers each You can apply the following operation to them any number of times Select an index i 1 leq i leq n and swap a i with b i i e a i becomes b i and vice versa Find the possible value of max a 1 a 2 ldots a n cdot max b 1 b 2 ldots b n you can get after applying such operation any number of times possibly zero ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int max_n = 1e2 + 5;\n\nint a[max_n], b[max_n];\n\nvoid solve_tc(){\n\tint n; \n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 1; i <= n; i++){\n\t\tcin >> b[i];\n\t}\n\t\n\tint max_a = 0, max_b = 0;\n\tfor (int i = 1; i <= n; i++){\n\t\tif (a[i] > b[i]){\n\t\t\tswap(a[i], b[i]);\n\t\t}\n\t\tmax_a = max(max_a, a[i]);\n\t\tmax_b = max(max_b, b[i]);\n\t}\n\t\n\tcout << max_a * max_b << ""\\n"";\n}\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tint tests; \n\tcin >> tests;\n\twhile (tests--){\n\t\tsolve_tc();\n\t}\n}']","[1, 0, 0, 0, 0]",800,SolutionLet The answer will always be where is the maximum of the array that does not contain Since is fixed the problem can be reduced to minimize that is minimize the maximum of the array that does not contain the global maximum WLOG assume that the global maximum will be in the array we can swap elements at each index such that ending with for all It can be shown that the maximum of array is minimized in this way Time complexity Code 
Bizon the Champion isn t just attentive he also is very hardworking Bizon the Champion decided to paint his old fence his favorite color orange The fence is represented as vertical planks put in a row Adjacent planks have no gap between them The planks are numbered from the left to the right starting from one the th plank has the width of meter and the height of meters Bizon the Champion bought a brush in the shop the brush s width is meter He can make vertical and horizontal strokes with the brush During a stroke the brush s full surface must touch the fence at all the time see the samples for the better understanding What minimum number of strokes should Bizon the Champion do to fully paint the fence Note that you are allowed to paint the same area of the fence multiple times ,"['#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#define int64 long long\n#define N 5010\n#define For(i,x,y) for (i=x;i<=y;i++)\nusing namespace std;\nint i,j,k,n,m,an;\nint a[N];\ninline int64 work(int l,int r,int cen) {\n\tint i,last=l,mi=a[l];\n\tint64 s=r-l+1,sum;\n\tFor(i,l,r) mi=min(mi,a[i]);\n\tsum=mi-cen;\n\tFor(i,l,r) if (a[i]==mi) {\n\t\tif (last<i) sum+=work(last,i-1,mi);\n\t\tlast=i+1;\n\t}\n\tif (last<=r) sum+=work(last,r,mi);\n\treturn min(s,sum);\n}\nint main() {\n\tscanf(""%d"",&n);\n\tFor(i,1,n) scanf(""%d"",&a[i]);\n\tan=work(1,n,0);\n\tprintf(""%I64d\\n"",an);\n\treturn 0;\n}\n']","[1, 0, 0, 1, 0]",1900,To solve this problem we need to understand some little things First every horizontally stroke must be as widely as possible Second under every horizontally stroke should be only horizontally strokes So if bottom of fence painted by horizontally stroke then number of this strokes must at least These strokes maybe divides fence into some unpainted disconnected parts For all of these parts we need to sum they answers Now its clearly that solution is recursive It takes segment and height of painted bottom But we must not forget about situation when all planks painted with vertically strokes In this case answer must be limited by length of segment With given constrains of we can find minimum on segment by looking all the elements from segment Complexity in this case will be But if we use for example segment tree we can achieve complexity 
 You are given a string s and a string t both consisting only of lowercase Latin letters It is guaranteed that t can be obtained from s by removing some possibly zero number of characters not necessary contiguous from s without changing order of remaining characters in other words it is guaranteed that t is a subsequence of s For example the strings and are subsequences of the string But the strings are not subsequences of the string You want to remove some substring contiguous subsequence from s of such that after removing this substring t will remain a subsequence of s If you want to remove the substring s l r then the string s will be transformed to s 1 s 2 dots s l 1 s r 1 s r 2 dots s s 1 s s where s is the length of s Your task is to find the maximum possible length of the substring you can remove so that t is still a subsequence of s ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n\tstring s, t;\n\tcin >> s >> t;\n\tint j = 0;\n\tvector<int> f(t.size() + 1, s.size());\n\tf[0] = -1;\n\tfor (int i = 0; i < s.size(); ++i) {\n\t\tif (j < t.size() && s[i] == t[j]) {\n\t\t\tf[++j] = i;\n\t\t}\n\t}\n\tj = 0;\n\tint ans = 0;\n\tfor (int i = s.size() - 1; i >= 0; --i) {\n\t\tans = max(ans, i - f[t.size() - j]);\n\t\tif (j < t.size() && s[i] == t[t.size() - j - 1]) ++j;\n\t}\n\tcout << ans << endl;\n}']","[1, 0, 1, 0, 0]",1600,In this problem we can just iterate over all possible substrings and try to remove each of them After removing the substring we can check if remains the subsequence of in linear time Let we remove the substring Let s maintain a pointer the initial value of the pointer is and iterate over all possible from to If and let s increase by one If after all iterations then let s update the answer with the length of the current substring 
You are a rebel leader and you are planning to start a revolution in your country But the evil Government found out about your plans and set your punishment in the form of correctional labor You must paint a fence which consists of 10 100 planks in two colors in the following way suppose planks are numbered from left to right from 0 if the index of the plank is divisible by r such planks have indices 0 r 2r and so on then you must paint it red if the index of the plank is divisible by b such planks have indices 0 b 2b and so on then you must paint it blue if the index is divisible both by r and b to paint the plank otherwise you don t need to paint the plank at all and it is forbidden to spent paint on it Furthermore the Government added one additional restriction to make your punishment worse Let s list all planks of the fence in ascending order if there are k consecutive planks with the same color in this list then the Government will state that you failed the labor and execute you immediately If you don t paint the fence according to the four aforementioned conditions you will also be executed The question is will you be able to accomplish the labor the time is not important or the execution is unavoidable and you need to escape at all costs ,"['#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int t;\n    scanf(""%d"", &t);\n    for (int tc = 1; tc <= t; tc++) {\n        int a, b, k;\n        scanf(""%d %d %d"", &a, &b, &k);\n        int g = __gcd(a, b);\n        a /= g;\n        b /= g;\n        if (a > b) swap(a, b);\n        if ((b - 1 + a - 1) / a >= k) printf(""REBEL\\n"");\n        else printf(""OBEY\\n"");\n    }\n}']","[1, 1, 0, 0, 0]",1700,At first suppose that if not swap them Let s look at the case where We can be sure that there will be a situation where the th plank is painted in blue and plank is painted in red It s true because it s equivalent to the solution of equation And all we need to check that interval contains less than red planks Or in formulas The situation with is almost the same if we look only at positions which are divisible by in other words we can just divide on and on and check the same condition 
Aquamoon has a Rubik s Square which can be seen as an n times n matrix the elements of the matrix constitute a permutation of numbers 1 ldots n 2 Aquamoon can perform two operations on the matrix Row shift i e shift an entire row of the matrix several positions at least 1 and at most n 1 to the right The elements that come out of the right border of the matrix are moved to the beginning of the row For example shifting a row begin pmatrix a b c end pmatrix by 2 positions would result in begin pmatrix b c a end pmatrix Column shift i e shift an entire column of the matrix several positions at least 1 and at most n 1 downwards The elements that come out of the lower border of the matrix are moved to the beginning of the column For example shifting a column begin pmatrix a b c end pmatrix by 2 positions would result in begin pmatrix b c a end pmatrix The rows are numbered from 1 to n from top to bottom the columns are numbered from 1 to n from left to right The cell at the intersection of the x th row and the y th column is denoted as x y Aquamoon can perform several possibly zero operations but she has to obey the following restrictions each row and each column can be shifted at most once each integer of the matrix can be moved at most twice the offsets of any two integers moved twice cannot be the same Formally if integers a and b have been moved twice assuming a has changed its position from x 1 y 1 to x 2 y 2 and b has changed its position from x 3 y 3 to x 4 y 4 then x 2 x 1 not equiv x 4 x 3 pmod n or y 2 y 1 not equiv y 4 y 3 pmod n Aquamoon wonders in how many ways she can transform the Rubik s Square from the given initial state to a given target state Two ways are considered different if the sequences of applied operations are different Since the answer can be very large print the result modulo 998 244 353 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=507;\nconst int vax=nax*nax;\nconst ll mod=998244353;\n\nint n;\nint a[nax][nax];\nint b[nax][nax];\n\npii ga[vax];\npii gb[vax];\n\nvoid ans(ll v)\n{\n\tv%=mod;\n\tv+=mod;\n\tv%=mod;\n\tprintf(""%lld\\n"", v);\n}\n\nint juzr[nax];\nint juzk[nax];\n\nll wyn;\nll sil[nax];\n\nint czyr(int v)\n{\n\tint kto=a[v][0];\n\tint chce=gb[kto].second;\n\tif (!chce)\n\t\treturn 0;\n\tfor (int i=1; i<n; i++)\n\t\tif (gb[a[v][i]].second!=(i+chce)%n)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint czyk(int v)\n{\n\tint kto=a[0][v];\n\tint chce=gb[kto].first;\n\tif (!chce)\n\t\treturn 0;\n\tfor (int i=1; i<n; i++)\n\t\tif (gb[a[i][v]].first!=(i+chce)%n)\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint pom[nax];\n\nvoid szift_row(int v)\n{\n\tint kto=a[v][0];\n\tint ile=gb[kto].second;\n\tfor (int i=0; i<n; i++)\n\t\tpom[(i+ile)%n]=a[v][i];\n\tfor (int i=0; i<n; i++)\n\t\ta[v][i]=pom[i];\n}\n\nvoid szift_kol(int v)\n{\n\tint kto=a[0][v];\n\tint ile=gb[kto].first;\n\tfor (int i=0; i<n; i++)\n\t\tpom[(i+ile)%n]=a[i][v];\n\tfor (int i=0; i<n; i++)\n\t\ta[i][v]=pom[i];\n}\n\nvoid test()\n{\n\tscanf(""%d"", &n);\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<n; j++)\n\t\t{\n\t\t\tscanf(""%d"", &a[i][j]);\n\t\t\ta[i][j]--;\n\t\t\tga[a[i][j]]={i, j};\n\t\t}\n\t}\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<n; j++)\n\t\t{\n\t\t\tscanf(""%d"", &b[i][j]);\n\t\t\tb[i][j]--;\n\t\t\tgb[b[i][j]]={i, j};\n\t\t}\n\t}\n\t{\n\t\tvector<pii> ruchy;\n\t\tfor (int i=0; i<n*n; i++)\n\t\t{\n\t\t\tpii r={ga[i].first-gb[i].first, ga[i].second-gb[i].second};\n\t\t\tr.first+=n;\n\t\t\tr.second+=n;\n\t\t\tr.first%=n;\n\t\t\tr.second%=n;\n\t\t\tif (r.first && r.second)\n\t\t\t\truchy.push_back(r);\n\t\t}\n\t\tsort(ruchy.begin(), ruchy.end());\n\t\tfor (int i=1; i<(int)ruchy.size(); i++)\n\t\t{\n\t\t\tif (ruchy[i]==ruchy[i-1])\n\t\t\t{\n\t\t\t\tans(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0; i<n; i++)\n\t\tjuzr[i]=juzk[i]=0;\n\twyn=1;\n\twhile(1)\n\t{\n\t\tvi rzo, kol;\n\t\tfor (int i=0; i<n; i++)\n\t\t\tif (!juzr[i] && czyr(i))\n\t\t\t\trzo.push_back(i);\n\t\tfor (int i=0; i<n && rzo.empty(); i++)\n\t\t\tif (!juzk[i] && czyk(i))\n\t\t\t\tkol.push_back(i);\n\t\tif (rzo.empty() && kol.empty())\n\t\t\tbreak;\n\t\tdebug() << imie(rzo) << imie(kol);\n\t\tif (!rzo.empty())\n\t\t{\n\t\t\twyn=(wyn*sil[rzo.size()])%mod;\n\t\t\tfor (int i : rzo)\n\t\t\t{\n\t\t\t\tszift_row(i);\n\t\t\t\tjuzr[i]=1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\twyn=(wyn*sil[kol.size()])%mod;\n\t\t\tfor (int i : kol)\n\t\t\t{\n\t\t\t\tjuzk[i]=1;\n\t\t\t\tszift_kol(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tfor (int j=0; j<n; j++)\n\t\t{\n\t\t\tif (a[i][j]!=b[i][j])\n\t\t\t{\n\t\t\t\tans(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tans(wyn);\n}\n\nint main()\n{\n\tsil[0]=1;\n\tfor (int i=1; i<nax; i++)\n\t\tsil[i]=sil[i-1]*i%mod;\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0]",3100,TutorialWe can use the following method to solve this problem For each row and each column check if it is available If there are both available rows and available columns there is no solution If no rows or columns are available the matrix is already equal to the target one or there is no solution If there are only available rows or available columns their order doesn t matter so if there choices the answer should be multiplied by Apply all available operations and check again Total complexity or if maintaining row column offsets in each row column 
Jzzhu is the president of country A There are cities numbered from to in his country City is the capital of A Also there are roads connecting the cities One can go from city to and vise versa using the th road the length of this road is Finally there are train routes in the country One can use the th train route to go from capital of the country to city and vise versa the length of this route is Jzzhu doesn t want to waste the money of the country so he is going to close some of the train routes Please tell Jzzhu the maximum number of the train routes which can be closed under the following condition the length of the shortest path from every city to the capital mustn t change ,"['#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n#define MOD 1000000009\n#define ADD(X, Y) ((X) = ((X) + (Y)) % MOD)\n\ntypedef long long i64;\n\nint N, M, K;\nvector<int> to[100000], dist[100000];\nbool vis[100000];\n\nint main()\n{\n\tscanf(""%d%d%d"", &N, &M, &K);\n\n\tfor (int i = 0; i < M; i++) {\n\t\tint u, v, x;\n\t\tscanf(""%d%d%d"", &u, &v, &x);\n\n\t\t--u; --v;\n\n\t\tto[u].push_back(v);\n\t\tdist[u].push_back(x);\n\t\tto[v].push_back(u);\n\t\tdist[v].push_back(x);\n\t}\n\n\tfor (int i = 0; i < N; i++) vis[i] = false;\n\n\tpriority_queue<pair<i64, int> > Q;\n\tQ.push(make_pair((i64)0, 0));\n\t\n\tfor (int i = 0; i < K; i++) {\n\t\tint s, y;\n\t\tscanf(""%d%d"", &s, &y);\n\n\t\t--s;\n\n\t\tQ.push(make_pair(-(i64)y, s - N));\n\t}\n\n\tint ret = 0;\n\n\twhile(!Q.empty()) {\n\t\tpair<i64, int> tmp = Q.top(); Q.pop();\n\n\t\tif (tmp.second < 0) {\n\t\t\ttmp.second += N;\n\n\t\t\tif(vis[tmp.second]) ++ret;\n\t\t}\n\n\t\tif(vis[tmp.second]) continue;\n\t\tvis[tmp.second] = true;\n\n\t\tint p = tmp.second;\n\n\t\tfor(int i=0;i<to[p].size();i++) Q.push(make_pair(tmp.first - dist[p][i], to[p][i]));\n\t}\n\n\tprintf(""%d\\n"", ret);\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",2000,We consider a train route as an undirected deletable edge Let be the shortest path between and We add all of the edges weighted where into a new directed graph A deletable edge can be deleted only if it isn t in the new graph or the in degree of in the new graph is more than because the connectivity of the new graph won t be changed after deleting these edges Notice that you should subtract one from the in degree of after you delete an edge 
The legendary Simurgh a mythical bird is responsible for keeping watch over vast lands and for this purpose she has enlisted n vigilant warriors Each warrior is alert during a specific time segment l i r i where l i is the start time included and r i is the end time included both positive integers One of Simurgh s trusted advisors Zal is concerned that if multiple warriors are stationed at the same time and all wear the same color the distinction between them might be lost causing confusion in the watch To prevent this whenever multiple warriors are on guard at the same moment there must be at least one color which is worn by exactly one warrior So the task is to determine the minimum number of colors required and assign a color c i to each warrior s segment l i r i such that for every real time t contained in at least one segment there exists one color which belongs to exactly one segment containing t ,"['#include<bits/stdc++.h>#define L(i, j, k) for(int i = (j); i <= (k); ++i)#define R(i, j, k) for(int i = (j); i >= (k); --i)#define ll long long #define sz(a) ((int) (a).size())#define pb emplace_back#define me(a, x) memset(a, x, sizeof(a))#define vi vector<int>#define ull unsigned long long#define i128 __int128using namespace std;const int N = 1e6 + 7, mod = 998244353;struct mint {\tint x;\tinline mint(int o = 0) { x = o; }\tinline mint & operator = (int o) { return x = o, *this; }\tinline mint & operator += (mint o) { return (x += o.x) >= mod && (x -= mod), *this; }\tinline mint & operator -= (mint o) { return (x -= o.x) < 0 && (x += mod), *this; }\tinline mint & operator *= (mint o) { return x = (ll) x * o.x % mod, *this; }\tinline mint & operator ^= (int b) {\t\tmint w = *this;\t\tmint ret(1);\t\tfor(; b; b >>= 1, w *= w) if(b & 1) ret *= w;\t\treturn x = ret.x, *this;\t}\tinline mint & operator /= (mint o) { return *this *= (o ^= (mod - 2)); }\tfriend inline mint operator + (mint a, mint b) { return a += b; }\tfriend inline mint operator - (mint a, mint b) { return a -= b; }\tfriend inline mint operator * (mint a, mint b) { return a *= b; }\tfriend inline mint operator / (mint a, mint b) { return a /= b; }\tfriend inline mint operator ^ (mint a, int b) { return a ^= b; }};inline mint qpow(mint x, int y = mod - 2) { return x ^ y; }mint fac[N], ifac[N], inv[N];void init(int x) {\tfac[0] = ifac[0] = inv[1] = 1;\tL(i, 2, x) inv[i] = (mod - mod / i) * inv[mod % i];\tL(i, 1, x) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * inv[i];} mint C(int x, int y) {\treturn x < y || y < 0 ? 0 : fac[x] * ifac[y] * ifac[x - y];}inline mint sgn(int x) {\treturn (x & 1) ? mod - 1 : 1;}int n;struct inter {\tint l, r, id;\tinter() {\xa0\t}} it[N];int l[N], r[N];int ans[N];int tak[N];int arr[N], atot;vi to[N], bak[N];int cov[N];int ncov[N];bool check_1() {\tL(i, 1, atot) ncov[i] = 0;\tL(i, 1, n) {\t\t++ncov[l[i]];\t\t--ncov[r[i] + 1];\t}\tL(i, 1, atot) ncov[i] += ncov[i - 1];\tL(i, 1, atot) if(ncov[i] > 1) return 0;\tcout << ""1\\n"";\tL(i, 1, n) cout << 1 << \' \';\tcout << \'\\n\';\treturn 1;}int p1[N], p2[N];bool check_2() {\tint vl[2] = {0, 0}, vr[2] = {0, 0}, cur = 0;\tL(i, 1, atot) {\t\tsort(to[i].begin(), to[i].end(), [&] (int x, int y) {\t\t\treturn r[x] > r[y];\t\t});\t\tfor(auto j : to[i]) {\t\t\t// cout << j << "" : "" << l[i] << "" "" << r[i] << "", "" << vl[0] << \' \' << vr[0] << "", "" << vl[1] << \' \' << vr[1] << endl;\t\t\tint winl = vl[0] < i;\t\t\tint winr = vl[1] < i;\t\t\tif(vr[0] < i) {\t\t\t\tans[j] = 0;\t\t\t} else if(vr[1] < i) {\t\t\t\tans[j] = 1;\t\t\t} else if(winl && winr) {\t\t\t\tif(vr[0] < vr[1]) {\t\t\t\t\tans[j] = 0;\t\t\t\t} else {\t\t\t\t\tans[j] = 1;\t\t\t\t}\t\t\t} else if(winl) {\t\t\t\tans[j] = 1;\t\t\t} else {\t\t\t\tans[j] = 0;\t\t\t}\t\t\tvl[ans[j]] = max(vl[ans[j]], min(vr[ans[j]], r[j]));\t\t\tvr[ans[j]] = max(vr[ans[j]], r[j]);\t\t}\t}\tL(i, 0, atot + 1) p1[i] = p2[i] = 0;\tL(o, 0, 1) {\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i] + 1] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p1[i] = 1;\xa0\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i]] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p2[i] = 1;\t}\tL(i, 1, atot) if(!p1[i]) return 0;\tL(i, 1, atot - 1) if(!p2[i] && cov[i]) return 0; \tcout << ""2\\n"";\tL(i, 1, n) cout << ans[i] + 1 << \' \';\tcout << \'\\n\';\treturn 1;}mt19937 rng;int rad(int l, int r) {\treturn rng() % (r - l + 1) + l;}void Main() {\t// n = 10;\t// L(i, 1, n) {\t// \tit[i].l = rng() % 10 + 1;\t// \tit[i].r = rng() % 10 + 1;\t// \tif(it[i].l > it[i].r) {\t// \t\tswap(it[i].l, it[i].r);\t// \t}\t// }\tcin >> n;\tL(i, 1, n) cin >> it[i].l >> it[i].r;\t\tatot = 0;\tL(i, 1, n) it[i].id = i;\tL(i, 1, n) arr[++atot] = it[i].l, arr[++atot] = it[i].r;\tsort(arr + 1, arr + atot + 1);\tatot = unique(arr + 1, arr + atot + 1) - arr - 1;\tL(i, 1, n) \t\tit[i].l = lower_bound(arr + 1, arr + atot + 1, it[i].l) - arr, \t\tit[i].r = lower_bound(arr + 1, arr + atot + 1, it[i].r) - arr;\tL(i, 0, atot + 1) cov[i] = 0, to[i].clear(), bak[i].clear();\tL(i, 1, n)\t\tl[i] = it[i].l, r[i] = it[i].r, to[l[i]].pb(i), bak[r[i]].pb(i);\tL(i, 1, n) cov[l[i]] += 1, cov[r[i]] -= 1;\tL(i, 1, atot) cov[i] += cov[i - 1];\tif(check_1()) {\t\treturn;\t}\tif(check_2()) {\t\treturn;\t}\tcout << ""3\\n"";\tvi vp;\tL(i, 1, atot) {\t\tsort(to[i].begin(), to[i].end(), [&] (int x, int y) {\t\t\treturn r[x] > r[y];\t\t});\t\tfor(auto j : to[i]) {\t\t\tif(!sz(vp) || r[j] > r[vp.back()]) {\t\t\t\twhile(sz(vp) > 1 && r[vp[sz(vp) - 2]] >= l[j]) {\t\t\t\t\tvp.pop_back();\t\t\t\t}\t\t\t\tvp.pb(j);\t\t\t}\t\t}\t}\t// cout<<""SZ=""<<sz(vp)<<endl;\tL(i, 1, n) ans[i] = 3;\tL(i, 0, sz(vp) - 1) {\t\tans[vp[i]] = 1 + (i & 1);\t}\tL(i, 1, n) cout << ans[i] << \' \';\tcout << \'\\n\';\tL(o, 1, 3) {\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i] + 1] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p1[i] = 1;\xa0\t\tL(i, 1, atot) ncov[i] = 0;\t\tL(i, 1, n) if(ans[i] == o) ncov[l[i]] += 1, ncov[r[i]] -= 1;\t\tL(i, 1, atot) ncov[i] += ncov[i - 1];\t\tL(i, 1, atot) if(ncov[i] == 1) p2[i] = 1;\t}\t// for(auto u : vp) {\t// \tcout << l[u] << \' \' << r[u] << endl;\t// }\tL(i, 1, atot) if(!p1[i]) assert(false);\tL(i, 1, atot - 1) if(!p2[i] && cov[i]) assert(false);}int main() {\tios :: sync_with_stdio(false);\tcin.tie(0); cout.tie(0);\tinit(1e6);\tint t; cin >> t; while(t--) Main();\treturn 0;}']","[1, 0, 1, 0, 0]",3500,Solution It is easy to check if the solution can be achieved with only one color For any time point there must be at most one interval containing since if multiple intervals contain they must be colored differently A simple strategy is to solve the problem using three colors First we color some intervals with colors 1 and 2 then color others with color 3 For each step we find the leftmost point that has not been colored yet and color the segment that contains this point We always choose the interval with the largest endpoint that contains the current point By coloring the intervals alternately with colors 1 and 2 we ensure that all points are covered by exactly one of these colors Now we check if we can color the intervals with just two colors using a greedy algorithm We iterate over the intervals sorted by start increasingly and then by end decreasingly At each point we keep track of the number of colors used in previous intervals that are not yet closed Let this number be and suppose we are currently at interval We color the current interval based on the value of If color interval with color 1 If color interval with the opposite color of the current used color If color interval with the opposite color of the interval with the greatest endpoint among the currently open intervals If it is impossible to assign a unique color between overlapping intervals at any point it can be shown that coloring the intervals using only 2 colors is impossible Solving G1 using G2 It s sufficient to check the integer points and half points e g 1 5 2 5 to verify whether the coloring is valid Why To handle this we can multiply all the given points by two effectively converting the problem into one in which only integer points exist After this transformation we solve the problem in the integer system of G2 where the intervals and coloring rules are defined using integer boundaries Note A brief explanation of why this greedy algorithm works can be found here 
Polycarp has invited n friends to celebrate the New Year During the celebration he decided to take a group photo of all his friends Each friend can stand or lie on the side Each friend is characterized by two values h i their height and w i their width On the photo the i th friend will occupy a rectangle h i times w i if they are standing or w i times h i if they are lying on the side The j th friend can be placed in front of the i th friend on the photo if his rectangle is lower and narrower than the rectangle of the i th friend Formally of the following conditions must be fulfilled h j h i w j w i both friends are standing or both are lying w j h i h j w i one of the friends is standing and the other is lying For example if n 3 h 3 5 3 and w 4 4 3 then the first friend can be placed in front of the second w 1 h 2 and h 1 w 2 one of the them is standing and the other one is lying the third friend can be placed in front of the second h 3 h 2 and w 3 w 2 both friends are standing or both are lying In other cases the person in the foreground will overlap the person in the background Help Polycarp for each i find any j such that the j th friend can be located in front of the i th friend i e at least one of the conditions above is fulfilled Please note that you do not need to find the arrangement of all people for a group photo You just need to find for each friend i any other friend j who can be located in front of him Think about it as you need to solve n separate independent subproblems ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N_MAX = 200002;\n\nint t;\n\nint n;\n\nint a[N_MAX], b[N_MAX];\n\nvector <int> v;\n\nmap <int, int> mp;\n\npair <int, int> BIT[2 * N_MAX];\n\nvoid update (int pos, int val, int x)\n{\n    for(int i = pos; i <= 2 * n; i += i & -i)\n        BIT[i] = min(BIT[i], make_pair(val, x));\n}\n\npair <int, int> query (int pos)\n{\n    pair <int, int> ans = make_pair(INT_MAX, 0);\n    for(int i = pos; i >= 1; i -= i & -i)\n        ans = min(ans, BIT[i]);\n    return ans;\n}\n\npair <int, int> ans1[N_MAX], ans2[N_MAX];\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while(t--)\n    {\n        cin >> n;\n        v.clear();\n        mp.clear();\n        for(int i = 1; i <= n; i++)\n        {\n            cin >> a[i] >> b[i];\n            v.push_back(a[i]);\n            v.push_back(b[i]);\n            ans1[i] = ans2[i] = make_pair(INT_MAX, 0);\n        }\n        sort(v.begin(), v.end());\n        int curr = 0;\n        for(int i = 0; i < (int)v.size(); i++)\n        {\n            if(i == 0 || v[i] > v[i - 1])\n                curr++;\n            mp[v[i]] = curr;\n        }\n        for(int i = 1; i <= n; i++)\n        {\n            a[i] = mp[a[i]];\n            b[i] = mp[b[i]];\n        }\n        for(int i = 1; i <= 2 * n; i++)\n            BIT[i] = make_pair(INT_MAX, 0);\n        for(int i = 1; i <= n; i++)\n        {\n            ans1[i] = min(ans1[i], query(a[i]));\n            ans2[i] = min(ans2[i], query(b[i]));\n            update(a[i] + 1, b[i], i);\n        }\n        for(int i = 1; i <= 2 * n; i++)\n            BIT[i] = make_pair(INT_MAX, 0);\n        for(int i = n; i >= 1; i--)\n        {\n            ans1[i] = min(ans1[i], query(a[i]));\n            ans2[i] = min(ans2[i], query(b[i]));\n            update(a[i] + 1, b[i], i);\n        }\n        for(int i = 1; i <= n; i++)\n        {\n            if(ans1[i].first < b[i])\n                cout << ans1[i].second << "" "";\n            else if(ans2[i].first < a[i])\n                cout << ans2[i].second << "" "";\n            else\n                cout << ""-1 "";\n        }\n        cout << ""\\n"";\n    }\n    return 0;\n}\n']","[0, 0, 0, 1, 1]",1700,Let s sort all people by their height in descending order Now let s go through all the people and look for the position of the person in the sorted array the height of which is strictly less than ours for example by binary search Obviously only those people who are in the sorted array later than the found person can stand in front of us all of them have a height strictly less than ours Among all these people it is more profitable for us to take a person with minimum width In order to find such a person quickly we can find a person with the minimum width for each suffix of the sorted array To handle a situation where a person is lying down we need to swap the width and height and repeat the algorithm above 
You are given a binary string dagger s of length n A binary string p of the same length n is called if for every i 1 leq i leq n there exist indices l and r such that 1 leq l leq i leq r leq n s i is a mode ddagger of the string p lp l 1 ldots p r You are given another binary string t of length n Find the minimum Hamming distance S between t and any string g dagger A binary string is a string that only consists of characters mathtt 0 and mathtt 1 ddagger Character c is a mode of string p of length m if the number of occurrences of c in p is at least lceil frac m 2 rceil For example mathtt 0 is a mode of mathtt 010 mathtt 1 is not a mode of mathtt 010 and both mathtt 0 and mathtt 1 are modes of mathtt 011010 S The Hamming distance of strings a and b of length m is the number of indices i such that 1 leq i leq m and a i neq b i ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;  // or double, if TL is tight\nusing str = string;      // yay python!\n\n// pairs\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\nusing pd = pair<db, db>;\n#define mp make_pair\n#define f first\n#define s second\n\n#define tcT template <class T\n#define tcTU tcT, class U\n// ^ lol this makes everything look weird but I\'ll try it\ntcT > using V = vector<T>;\ntcT, size_t SZ > using AR = array<T, SZ>;\nusing vi = V<int>;\nusing vb = V<bool>;\nusing vl = V<ll>;\nusing vd = V<db>;\nusing vs = V<str>;\nusing vpi = V<pi>;\nusing vpl = V<pl>;\nusing vpd = V<pd>;\n\n// vectors\n#define sz(x) int(size(x))\n#define bg(x) begin(x)\n#define all(x) bg(x), end(x)\n#define rall(x) rbegin(x), rend(x)\n#define sor(x) sort(all(x))\n#define rsz resize\n#define ins insert\n#define pb push_back\n#define eb emplace_back\n#define ft front()\n#define bk back()\n\n#define lb lower_bound\n#define ub upper_bound\ntcT > int lwb(const V<T> &a, const T &b) { return int(lb(all(a), b) - bg(a)); }\ntcT > int upb(const V<T> &a, const T &b) { return int(ub(all(a), b) - bg(a)); }\n\n// loops\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define F0R(i, a) FOR(i, 0, a)\n#define ROF(i, a, b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i, a) ROF(i, 0, a)\n#define rep(a) F0R(_, a)\n#define each(a, x) for (auto &a : x)\n\nconst int MOD = 998244353;  // 1e9+7;\nconst int MX = (int)2e5 + 5;\nconst ll BIG = 1e18;  // not too close to LLONG_MAX\nconst db PI = acos((db)-1);\nconst int dx[4]{1, 0, -1, 0}, dy[4]{0, 1, 0, -1};  // for every grid problem!!\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n\n// bitwise ops\n// also see https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\nconstexpr int pct(int x) { return __builtin_popcount(x); }  // # of bits set\nconstexpr int bits(int x) {  // assert(x >= 0); // make C++11 compatible until\n\t                         // USACO updates ...\n\treturn x == 0 ? 0 : 31 - __builtin_clz(x);\n}  // floor(log2(x))\nconstexpr int p2(int x) { return 1 << x; }\nconstexpr int msk2(int x) { return p2(x) - 1; }\n\nll cdiv(ll a, ll b) {\n\treturn a / b + ((a ^ b) > 0 && a % b);\n}  // divide a by b rounded up\nll fdiv(ll a, ll b) {\n\treturn a / b - ((a ^ b) < 0 && a % b);\n}  // divide a by b rounded down\n\ntcT > bool ckmin(T &a, const T &b) {\n\treturn b < a ? a = b, 1 : 0;\n}  // set a = min(a,b)\ntcT > bool ckmax(T &a, const T &b) {\n\treturn a < b ? a = b, 1 : 0;\n}  // set a = max(a,b)\n\ntcTU > T fstTrue(T lo, T hi, U f) {\n\t++hi;\n\tassert(lo <= hi);  // assuming f is increasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo) / 2;\n\t\tf(mid) ? hi = mid : lo = mid + 1;\n\t}\n\treturn lo;\n}\ntcTU > T lstTrue(T lo, T hi, U f) {\n\t--lo;\n\tassert(lo <= hi);  // assuming f is decreasing\n\twhile (lo < hi) {  // find first index such that f is true\n\t\tT mid = lo + (hi - lo + 1) / 2;\n\t\tf(mid) ? lo = mid : hi = mid - 1;\n\t}\n\treturn lo;\n}\ntcT > void remDup(vector<T> &v) {  // sort and remove duplicates\n\tsort(all(v));\n\tv.erase(unique(all(v)), end(v));\n}\ntcTU > void safeErase(T &t, const U &u) {\n\tauto it = t.find(u);\n\tassert(it != end(t));\n\tt.erase(it);\n}\n\ninline namespace IO {\n#define SFINAE(x, ...)                                                         \\\n\ttemplate <class, class = void> struct x : std::false_type {};              \\\n\ttemplate <class T> struct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}\n\nSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));\nSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));\nSFINAE(IsTuple, typename std::tuple_size<T>::type);\nSFINAE(Iterable, decltype(std::begin(std::declval<T>())));\n\ntemplate <auto &is> struct Reader {\n\ttemplate <class T> void Impl(T &t) {\n\t\tif constexpr (DefaultI<T>::value) is >> t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tfor (auto &x : t) Impl(x);\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for read"");\n\t}\n\ttemplate <class... Ts> void read(Ts &...ts) { ((Impl(ts)), ...); }\n};\n\ntemplate <class... Ts> void re(Ts &...ts) { Reader<cin>{}.read(ts...); }\n#define def(t, args...)                                                        \\\n\tt args;                                                                    \\\n\tre(args);\n\ntemplate <auto &os, bool debug, bool print_nd> struct Writer {\n\tstring comma() const { return debug ? "","" : """"; }\n\ttemplate <class T> constexpr char Space(const T &) const {\n\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? \'\\n\'\n\t\t                                                             : \' \';\n\t}\n\ttemplate <class T> void Impl(T const &t) const {\n\t\tif constexpr (DefaultO<T>::value) os << t;\n\t\telse if constexpr (Iterable<T>::value) {\n\t\t\tif (debug) os << \'{\';\n\t\t\tint i = 0;\n\t\t\tfor (auto &&x : t)\n\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));\n\t\t\tif (debug) os << \'}\';\n\t\t} else if constexpr (IsTuple<T>::value) {\n\t\t\tif (debug) os << \'(\';\n\t\t\tstd::apply(\n\t\t\t    [this](auto const &...args) {\n\t\t\t\t    int i = 0;\n\t\t\t\t    (((i++) ? (os << comma() << "" "", Impl(args)) : Impl(args)),\n\t\t\t\t     ...);\n\t\t\t    },\n\t\t\t    t);\n\t\t\tif (debug) os << \')\';\n\t\t} else static_assert(IsTuple<T>::value, ""No matching type for print"");\n\t}\n\ttemplate <class T> void ImplWrapper(T const &t) const {\n\t\tif (debug) os << ""\\033[0;31m"";\n\t\tImpl(t);\n\t\tif (debug) os << ""\\033[0m"";\n\t}\n\ttemplate <class... Ts> void print(Ts const &...ts) const {\n\t\t((Impl(ts)), ...);\n\t}\n\ttemplate <class F, class... Ts>\n\tvoid print_with_sep(const std::string &sep, F const &f,\n\t                    Ts const &...ts) const {\n\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << \'\\n\';\n\t}\n\tvoid print_with_sep(const std::string &) const { os << \'\\n\'; }\n};\n\ntemplate <class... Ts> void pr(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print(ts...);\n}\ntemplate <class... Ts> void ps(Ts const &...ts) {\n\tWriter<cout, false, true>{}.print_with_sep("" "", ts...);\n}\n}  // namespace IO\n\ninline namespace Debug {\ntemplate <typename... Args> void err(Args... args) {\n\tWriter<cerr, true, false>{}.print_with_sep("" | "", args...);\n}\ntemplate <typename... Args> void errn(Args... args) {\n\tWriter<cerr, true, true>{}.print_with_sep("" | "", args...);\n}\n\nvoid err_prefix(str func, int line, string args) {\n\tcerr << ""\\033[0;31m\\u001b[1mDEBUG\\033[0m""\n\t     << "" | ""\n\t     << ""\\u001b[34m"" << func << ""\\033[0m""\n\t     << "":""\n\t     << ""\\u001b[34m"" << line << ""\\033[0m""\n\t     << "" - ""\n\t     << ""["" << args << ""] = "";\n}\n\n#ifdef LOCAL\n#define dbg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)\n#define dbgn(args...) err_prefix(__FUNCTION__, __LINE__, #args), errn(args)\n#else\n#define dbg(...)\n#define dbgn(args...)\n#endif\n\nconst auto beg_time = std::chrono::high_resolution_clock::now();\n// https://stackoverflow.com/questions/47980498/accurate-c-c-clock-on-a-multi-core-processor-with-auto-overclock?noredirect=1&lq=1\ndouble time_elapsed() {\n\treturn chrono::duration<double>(std::chrono::high_resolution_clock::now() -\n\t                                beg_time)\n\t    .count();\n}\n}  // namespace Debug\n\ninline namespace FileIO {\nvoid setIn(str s) { freopen(s.c_str(), ""r"", stdin); }\nvoid setOut(str s) { freopen(s.c_str(), ""w"", stdout); }\nvoid setIO(str s = """") {\n\tcin.tie(0)->sync_with_stdio(0);  // unsync C / C++ I/O streams\n\tcout << fixed << setprecision(12);\n\t// cin.exceptions(cin.failbit);\n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) setIn(s + "".in""), setOut(s + "".out"");  // for old USACO\n}\n}  // namespace FileIO\n\n// make sure to intialize ALL GLOBAL VARS between tcs!\n\nint sgn(char c) { return c == \'1\' ? 1 : -1; }\n\nvoid solve(int tc) {\n\tdef(int, N);\n\tstr S, T;\n\tre(S, T);\n\t// assume end with at least as many ones as zeros\n\t// only 0s might be unsat\n\tif (count(all(T), \'0\') > count(all(T), \'1\')) {\n\t\teach(c, S) c ^= \'0\' ^ \'1\';\n\t\teach(c, T) c ^= \'0\' ^ \'1\';\n\t}\n\tV<vi> dp(N + 1);\n\tF0R(i, N + 1) dp[i].rsz(i + 1, N);\n\tdp.at(0).at(0) = 0;\n\tvi cum{0};\n\tfor (char c : T) cum.pb(cum.bk + sgn(c));\n\tassert(cum.bk >= 0);\n\tV<vi> balance(N + 1, vi(N + 1));\n\t// dbg(""BEGIN BALANCE"");\n\tFOR(r, 1, N + 1) F0R(num_change, N + 1) {\n\t\tif (num_change == 0 || T.at(r - 1) == \'0\') {\n\t\t\tbalance.at(r).at(num_change) =\n\t\t\t    max(balance.at(r - 1).at(num_change) - sgn(T.at(r - 1)), 0);\n\t\t} else {  // change 1 to 0\n\t\t\tbalance.at(r).at(num_change) =\n\t\t\t    balance.at(r - 1).at(num_change - 1) + 1;\n\t\t}\n\t}\n\t// dbg(""END BALANCE"");\n\tF0R(i, N) F0R(j, i + 1) {\n\t\t// dbg(i, j, dp.at(i).at(j));\n\t\tif (T.at(i) == \'0\') {\n\t\t\tckmin(dp.at(i + 1).at(j + 1), dp.at(i).at(j));\n\t\t\tcontinue;\n\t\t}\n\t\tckmin(dp.at(i + 1).at(j + 1),\n\t\t      dp.at(i).at(j) + 1);  // use 0\n\t\tif (j || S.at(i) == \'1\') {  // use 1\n\t\t\tckmin(dp.at(i + 1).at(max(j - 1, 0)), dp.at(i).at(j));\n\t\t} else {\n\t\t\t// use 1 but return to same place eventually\n\t\t\tfor (int r = i + 2; r <= N; r += 2)\n\t\t\t\tif (cum.at(r) >= cum.at(i)) {\n\t\t\t\t\tint num_change = (cum.at(r) - cum.at(i)) / 2;\n\t\t\t\t\tckmin(dp.at(r).at(balance.at(r).at(num_change)),\n\t\t\t\t\t      dp.at(i).at(j) + num_change);\n\t\t\t\t}\n\t\t}\n\t}\n\tps(*min_element(all(dp.bk)));\n}\n\nint main() {\n\tsetIO();\n\tint TC;\n\tre(TC);\n\tFOR(i, 1, TC + 1) solve(i);\n}\n\n/* stuff you should look for\n * int overflow, array bounds\n * special cases (n=1?)\n * do smth instead of nothing and stay organized\n * WRITE STUFF DOWN\n * DON\'T GET STUCK ON ONE APPROACH\n */\n']","[0, 0, 0, 1, 0]",3500,SolutionPlease read hints and if you haven t as they contain some claims and definitions Note that when we find some sum we add when we get and subtract when we get Suppose we have found values for the first indices and we want to find for Now we need to perform the transitions Let us try to have a solution first which we can optimise after making some observations Take some We will iterate over to here is the maximum suffix sum of substring and use to find optimal values for for some So we need to do some flips to substring as and are already friends So we only care to make all indices nice So there are two possibilities either occurs in substring or not If does not occur we can perform the transition without making any flips Assume occurs in substring So firstly find the sum say of substring Now if we do some flips to substring will change accordingly We will do a minimum number of flips such that Note that we are talking here about updated So we can find the minimum number say of flips which will be where So we know how many flips to make But which ones to flip Here is one more claim We should only flip the last of substring So this is a sufficient condition as we can certainly say that will be friend of now So we know the required number of flips which is We need to find one more thing what would be the maximum suffix sum if we flip the last characters of We can precompute But we have an issue now We know that what we performed is sufficient But is it necessary What if we did not need to flip cost characters of It might be possible that we could have done less number of flips and still made all indices nice The reasoning behind this is we made sure that but what if it was not needed Like it is possible that total sum is negative but all indices such that are satisfied So here we can use exchange arguments and conclude that all cases will be covered if we check for all pairs of Now we need to optimise this to Notice that when we do the flips there will be a suffix possibly empty when of containing only s Suppose we are at index and need to find for We can iterate over all assume that all the characters in substring are s and find the values Maximum suffix sum will be So we can find the smallest index such that the sum of the elements in substring is greater than or equal to if we make all the characters in substring Notice that we already have the new suffix maximum and we know the too which is equal to the number of s in the original substring So our transition will be where So our final complexity will be as we can perform the transition in if we precompute the needed things 
Initially you have a single pile with n gold nuggets In an operation you can do the following Take any pile and split it into two piles so that one of the resulting piles has exactly twice as many gold nuggets as the other All piles should have an integer number of nuggets Can you make a pile with m gold nuggets using zero or more operations ,"['#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#define bit(i, x) (x >> i & 1)\n#define _unique(x) (x).resize(unique((x).begin(), (x).end()) - (x).begin());\n#define all(x) (x).begin(), (x).end()\n#define rep(i, l, r) for(int i = l; i <= r; i++)\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate<class T> using ordered_set =tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;\nconst int N = 3e5 + 3;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint rnd(int l,int r) {\n    return l+rng()%(r-l+1);\n}\ntemplate<typename T> void cmax(T &a, T b) {a = max(a, b);}\n\n#define fi first\n#define se second\n\nint n, m;\n\nvoid solve() {\n    cin >> n >> m;\n    queue<int> q;\n    q.push(n);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        if (u == m) {\n            cout << ""YES\\n"";\n            return;\n        }\n        if (u % 3 == 0) {\n            q.push(u / 3);\n            q.push(2*(u / 3));\n        }\n    }\n    cout << ""NO\\n"";\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(NULL); cin.tie(nullptr); cout.tie(nullptr);\n\n//    freopen(""testing.txt"", ""r"", stdin);\n//    freopen(""outputing.txt"", ""w"", stdout);\n    #define task """"\n//    freopen(task"".inp"", ""r"", stdin);\n//    freopen(task"".out"", ""w"", stdout);\n//    #define Kawaii\n    #ifdef Kawaii\n        auto starttime = chrono::high_resolution_clock::now();\n    #endif\n\n    int t; cin >> t;\n    while (t--) solve();\n\n\n\n\n\n\n\n    #ifdef Kawaii\n        auto endtime = chrono::high_resolution_clock::now();\n        auto duration = chrono::duration_cast<chrono::milliseconds>(endtime - starttime).count();\n        cout << ""\\n====="" << ""\\nUsed: "" << duration << "" ms\\n"";\n    #endif\n\n    return 0 ^ 0;\n}\n// Okina Matara sitting in a wheelchair\n']","[0, 0, 1, 1, 0]",1000,We can solve this problem recursively Let the current pile have gold nuggets If then we can make a pile with exactly gold nuggets by not doing any operations If is not a multiple of then it is not possible to make a move because after a move we split into and so for some integer meaning has to be a multiple of Finally if is a multiple of then we can split the pile into two piles with and gold nuggets and we can recursively check if we can make a pile with exactly gold nuggets See the implementation for more details By the Master Theorem the time complexity is Most compilers and languages optimize the recursion enough for this to pass comfortably The model solution in C runs in 15 milliseconds 
Recently on the course of algorithms and data structures Valeriy learned how to use a deque He built a deque filled with n elements The i th element is a i i 1 2 ldots n He gradually takes the first two leftmost elements from the deque let s call them A and B respectively and then does the following if A B he writes A to the beginning and writes B to the end of the deque otherwise he writes to the beginning B and A writes to the end of the deque We call this sequence of actions an operation For example if deque was 2 3 4 5 1 on the operation he will write B 3 to the beginning and A 2 to the end so he will get 3 4 5 1 2 The teacher of the course seeing Valeriy who was passionate about his work approached him and gave him q queries Each query consists of the singular number m j j 1 2 ldots q It is required for each query to answer which two elements he will pull out on the m j th operation Note that and for each query the numbers A and B should be is a data structure representing a list of elements where insertion of new elements or deletion of existing elements can be made from both sides ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, q;\n\ndeque <int> kol;\n\nvector <pii> ans;\n\nvoid wyp(pii v)\n{\n\tprintf(""%d %d\\n"", v.first, v.second);\n}\n\nint main()\n{\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x;\n\t\tscanf(""%d"", &x);\n\t\tkol.push_back(x);\n\t}\n\tfor (int i=1; i<=3*n+7; i++)\n\t{\n\t\tint a=kol.front();\n\t\tkol.pop_front();\n\t\tint b=kol.front();\n\t\tkol.pop_front();\n\t\tans.push_back({a, b});\n\t\tif (b>a)\n\t\t\tswap(a, b);\n\t\tkol.push_front(a);\n\t\tkol.push_back(b);\n\t}\n\twhile(q--)\n\t{\n\t\tll x;\n\t\tscanf(""%lld"", &x);\n\t\tx--;\n\t\tif (x<=2*n)\n\t\t{\n\t\t\twyp(ans[x]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx-=n;\n\t\t\tx%=(n-1);\n\t\t\tx+=n;\n\t\t\twyp(ans[x]);\n\t\t}\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 1]",1500,It can be noted that if the deque has the largest element of the deque in the first position then during the next operations it will remain in the first position and the second one will be written to the end each time that is all the elements of the deque starting from the second will move cyclically left Let s go over the deque and find the largest element by value We will perform the operation described in the statements until the maximum position is in the first position and save the elements in the first and second positions by the operation number In order to pre calculate all pairs until the moment when the maximum position is found it is enough to make no more than one pass through the deque since in the worst case the maximum element can be located at the end of the deque Denote as the position of the maximum element Then if simply return a pair of numbers from the pre calculated array otherwise is equal to the maximum element and is equal to the deque element with the index in indexing since we performed the operations until the moment when the maximum position is in the first position this maximum element is now recorded in the first position 
Bear Limak thinks of some hidden number an integer from interval Your task is to say if the hidden number is prime or composite Integer is called prime if it has exactly two distinct divisors and If integer is not prime it s called composite You can ask up to queries about divisors of the hidden number In each query you should print an integer from interval The system will answer if your integer is a divisor of the hidden number Otherwise the answer will be For example if the hidden number is then the system will answer only if you print or When you are done asking queries print or and terminate your program You will get the verdict if you ask more than queries or if you print an integer not from the range Also you will get the verdict if the printed answer isn t correct You will get the verdict if you don t print anything but you should or if you forget about flushing the output more info below ,"['#include<stdio.h>\nint d[20]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,4,9,25,49};\nint res[20], c;\nint main(){\n    int i;\n    char p[5];\n    for(i=0;i<19;i++){\n        printf(""%d\\n"",d[i]);\n        fflush(stdout);\n        scanf(""%s"",p);\n        if(p[0]==\'y\')res[i] = 1;\n        else res[i] = 0;\n    }\n    if(res[15]||res[16]||res[17]||res[18]){\n        printf(""composite\\n"");\n        fflush(stdout);\n        return 0;\n    }\n    for(i=0;i<19;i++){\n        c += res[i];\n    }\n    if(c<=1){\n        printf(""prime\\n"");\n        fflush(stdout);\n        return 0;\n    }\n    else{\n        printf(""composite\\n"");\n        fflush(stdout);\n        return 0;\n    }\n}\n']","[0, 1, 0, 0, 0]",1400,If a number is composite then it s either divisible by for some prime or divisible by two distinct primes and To check the first condition it s enough to check all possible so numbers If at least one gives yes then the hidden number if composite If there are two distinct prime divisors and then both of them are at most otherwise the hidden number would be bigger than because for and we would get So it s enough to check primes up to there are of them and check if at least two of them are divisors code1 
People like to be fit That s why many of them are ready to wake up at dawn go to the stadium and run In this problem your task is to help a company design a new stadium The city of N has a shabby old stadium Many people like it and every morning thousands of people come out to this stadium to run The stadium can be represented as a circle its length is exactly meters with a marked start line However there can t be simultaneous start in the morning so exactly at 7 each runner goes to his favorite spot on the stadium and starts running from there Note that not everybody runs in the same manner as everybody else Some people run in the clockwise direction some of them run in the counter clockwise direction It mostly depends on the runner s mood in the morning so you can assume that each running direction is equiprobable for each runner in any fixed morning The stadium is tiny and is in need of major repair for right now there only is one running track You can t get too playful on a single track that s why all runners keep the same running speed exactly 1 meter per a time unit Nevertheless the runners that choose different directions bump into each other as they meet The company wants to design a new stadium but they first need to know how bad the old one is For that they need the expectation of the number of bumpings by time units after the running has begun Help the company count the required expectation Note that each runner chooses a direction equiprobably independently from the others and then all runners start running simultaneously at 7 a m Assume that each runner runs for time units without stopping Consider the runners to bump at a certain moment if at that moment they found themselves at the same point in the stadium A pair of runners can bump more than once ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n\nusing namespace std;\n\ntypedef unsigned uint;\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << "" ""; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(""%d"", &x); return x; }\n\nint N;\nInt L, T;\nInt A[2000010];\n\nint main() {\n\tint i, j;\n\t\n\tfor (; ~scanf(""%d"", &N); ) {\n\t\tL = in();\n\t\tT = in();\n\t\tfor (i = 0; i < N; ++i) {\n\t\t\tA[i] = in();\n\t\t}\n\t\tsort(A, A + N);\n\t\tfor (i = N; i <= N * 2; ++i) {\n\t\t\tA[i] = A[i - N] + L;\n\t\t}\n\t\tInt q = (T * 2) / L;\n\t\tInt r = (T * 2) % L;\n\t\tInt cnt = 0;\n\t\tfor (j = 0, i = 0; i < N; ++i) {\n\t\t\tfor (; A[j] - A[i] <= r; ++j);\n\t\t\tcnt += j - i - 1;\n\t\t}\n\t\tdouble ans = 0;\n\t\tans += 0.25 * ((double)N * (N - 1) * q + cnt);\n\t\tprintf(""%.10f\\n"", ans);\n\t}\n\t\n\treturn 0;\n}\n\n']","[0, 1, 0, 0, 0]",2000,We were asked to find the expected value of meetings between the runners How to do that As the first step expected value is lineal so we can split the initial problems into the different ones find the expected value of meetings between the fixed pair of runners We will solve these problems To do that we need to make some observations Let x be the distance between the two runners and they run face to face for infinite amount of time probability of that obviously equals to 0 5 0 5 0 25 Then the first meeting will happen at time the next one the next and so on Let us assume that every run ran for l time units Then if two runners meet they meet exactly two times The probability of the meeting equals to 0 5 because in two cases they run in the same direction and in two cases in the different ones We will build our solution based on these two observations As the first step let us represent t as t k l p where 0 p l Then each runner will run k full laps What does that mean Because we have pairs of runners then in those k laps each pair will have 2k meetings with probability equals to 0 5 So we need to add to the answer Now we need to take into account p seconds of running Let us assume that the distance between two runners is x and they run towards each other Then they will meet if or x 2t They will meet once more if ir x 2t l They cannot meet more than twice because p l Let us fix one of the runners then using binary search we can find all other runners at distance no more than x from the fixed one Let us choose x as x 2t and then the number of runners at the distance no more than x stands for the number of runners which meet with the fixed one at least once If x 2t l we will find the number of runners which meet with the fixed one exactly two times Multiplying these numbers by 0 25 probability of the meeting and add it to the answer The complexity of this solution is We can reduce it using two pointers method 
Anton likes to play chess Also he likes to do programming That is why he decided to write the program that plays chess However he finds the game on to board to too simple he uses an infinite one instead The first task he faced is to check whether the king is in check Anton doesn t know how to implement this so he asks you to help Consider that an infinite chess board contains one white king and the number of black pieces There are only rooks bishops and queens as the other pieces are not supported yet The white king is said to be in check if at least one black piece can reach the cell with the king in one move Help Anton and write the program that for the given position determines whether the white king is in check Remainder on how do chess pieces move Bishop moves any number of cells diagonally but it can t leap over the occupied cells Rook moves any number of cells horizontally or vertically but it also can t leap over the occupied cells Queen is able to move any number of cells horizontally vertically or diagonally but it also can t leap ,"['#include <iostream>\n#include <fstream>\n#include <list>\n#include <stack>\n#include <deque>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <ctime>\n#include <iterator>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\n#define f first\n#define s second\n#define pb push_back\n#define mp make_pair\n\nconst int maxn = 100500;\nconst int inf = 2e9;\nconst double eps = 1e-8;\nconst int base = 1073676287;\n\npair < int, int > Hl, Hr, Vh, Vd, MainD1, MainD2, SecD1, SecD2;\n\nvoid updateH( int x, int y, int x0, int y0, char type ) {\n\tif ( y < y0 ) {\n\t\tif ( !Hl.f || Hl.s < y )\n\t\t\tHl = mp( type, y );\n\t\treturn;\n\t}\n\tif ( !Hr.f || Hr.s > y )\n\t\tHr = mp( type, y );\n}\n\nvoid updateV( int x, int y, int x0, int y0, char type ) {\n\tif ( x < x0 ) {\n\t\tif ( !Vh.f || Vh.s < x )\n\t\t\tVh = mp( type, x );\n\t\treturn;\n\t}\n\tif ( !Vd.f || Vd.s > x )\n\t\tVd = mp( type, x );\n}\n\nvoid updateMainD( int x, int y, int x0, int y0, char type ) {\n\tint delta = abs( x - x0 );\n\tif ( x < x0 ) {\n\t\tif ( !MainD1.f || MainD1.s > delta )\n\t\t\tMainD1 = mp( type, delta );\n\t\treturn;\n\t}\n\tif ( !MainD2.f || MainD2.s > delta )\n\t\tMainD2 = mp( type, delta );\n}\n\nvoid updateSecD( int x, int y, int x0, int y0, char type ) {\n\tint delta = abs( x - x0 );\n\tif ( x < x0 ) {\n\t\tif ( !SecD1.f || SecD1.s > delta )\n\t\t\tSecD1 = mp( type, delta );\n\t\treturn;\n\t}\n\tif ( !SecD2.f || SecD2.s > delta )\n\t\tSecD2 = mp( type, delta );\n}\n\nint main()\n{\n    srand( time( 0 ) );\n    // freopen( ""input.txt"", ""r"", stdin );\n    // freopen( ""output.txt"", ""w"", stdout );\n    // ios_base::sync_with_stdio(false);\n    int n;\n    int x0, y0;\n    scanf ( ""%d%d%d\\n"", &n, &x0, &y0 );\n    for ( int j = 0; j < n; j++ ) {\n    \tint x, y;\n    \tchar type;\n    \tscanf ( ""%c %d %d\\n"", &type, &x, &y );\n    \tif ( x == x0 )\n    \t\tupdateH( x, y, x0, y0, type );\n    \tif ( y == y0 )\n    \t\tupdateV( x, y, x0, y0, type );\n    \tint delta1 = x - x0;\n    \tint delta2 = y - y0;\n    \tif ( delta1 == delta2 )\n    \t\tupdateMainD( x, y, x0, y0, type );\n    \tif ( delta1 == -delta2 )\n    \t\tupdateSecD( x, y, x0, y0, type );\n    }\n    if ( Hl.f == \'R\' || Hl.f == \'Q\' ) {\n    \tputs( ""YES"" );\n    \treturn 0;\n    }\n    if ( Hr.f == \'R\' || Hr.f == \'Q\' ) {\n    \tputs( ""YES"" );\n    \treturn 0;\n    }\n    if ( Vh.f == \'R\' || Vh.f == \'Q\' ) {\n    \tputs( ""YES"" );\n    \treturn 0;\n    }\n    if ( Vd.f == \'R\' || Vd.f == \'Q\' ) {\n    \tputs( ""YES"" );\n    \treturn 0;\n    }\n\n    if ( MainD1.f == \'B\' || MainD1.f == \'Q\' ) {\n    \tputs( ""YES"" );\n    \treturn 0;\n    }\n    if ( MainD2.f == \'B\' || MainD2.f == \'Q\' ) {\n    \tputs( ""YES"" );\n    \treturn 0;\n    }\n    if ( SecD1.f == \'B\' || SecD1.f == \'Q\' ) {\n    \tputs( ""YES"" );\n    \treturn 0;\n    }\n    if ( SecD2.f == \'B\' || SecD2.f == \'Q\' ) {\n    \tputs( ""YES"" );\n    \treturn 0;\n    }\n    puts( ""NO"" );\n    return 0;\n}\n']","[0, 0, 1, 0, 0]",1700,Let s observe that the king can attack only pieces that lay in eight directions up down left right vertically and horizontally and also up left up right down left and down right diagonally from the cell where the king stands Also we can observe that from all the pieces that lay in the eight directions only the nearest one to the king can attack it the rest of the pieces must leap over the nearest one but it s impossible So we ll keep for all the eight directions the nearest piece to the king and then we ll check if one of the nearest pieces can attack the king don t forget that bishops can attack only diagonally rooks vertically and horizontally queens in all the directions Time complexity is 
Princess Twilight went to Celestia and Luna s old castle to research the chest from the Elements of Harmony A sequence of positive integers is harmony if and only if for every two elements of the sequence their greatest common divisor equals 1 According to an ancient book the key of the chest is a harmony sequence which minimizes the following expression You are given sequence help Princess Twilight to find the key ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXV 62\n#define INF 0x3FFFFFFF\n\nint N;\nint A[110];\nint M[MAXV];\nint low;\nvector<int> P;\n\nint memo[110][1 << 10][10];\n\nint solve(int x, int m) {\n  if(__builtin_popcount((m >> low) + 1) != 1) return INF;\n  if(x == N) return 0;\n\n  int& ref = memo[x][m & ((1 << low) - 1)][__builtin_popcount(m >> low)];\n  if(ref != -1) return ref;\n\n  ref = INF;\n  for(int i = 1; i < MAXV; i++) {\n    if((M[i] & m) == 0) {\n      ref = min(ref, abs(A[x] - i) + solve(x + 1, m | M[i]));\n    }\n  }\n  return ref;\n}\n\nvoid recover(int x, int m) {\n  if(x == N) return;\n\n  int val = solve(x, m);\n  for(int i = 1; i < MAXV; i++) {\n    if((M[i] & m) == 0) {\n      if(abs(A[x] - i) + solve(x + 1, m | M[i]) == val) {\n        if(x) cout << ' ';\n        cout << i;\n        recover(x + 1, m | M[i]);\n        break;\n      }\n    }\n  }\n}\n\nint main() {\n  for(int p = 2; p < MAXV; p++) {\n    bool isp = true;\n    for(int i = 2; i < p && isp; i++) {\n      isp = p % i != 0;\n    }\n    if(isp) {\n      P.push_back(p);\n      if(p <= 30) low++;\n    }\n  }\n\n  for(int i = 1; i < MAXV; i++) {\n    M[i] = 0;\n    for(int j = 0; j < P.size(); j++) {\n      if(i % P[j] == 0) {\n        M[i] |= 1 << j;\n      }\n    }\n  }\n\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> A[i];\n  }\n\n  memset(memo, -1, sizeof(memo));\n  recover(0, 0);\n  cout << endl;\n  return 0;\n}\n""]","[0, 0, 0, 1, 0]",2000,You are given sequence ai find a pairwise coprime sequence bi which minimizes Analysis Since 1 1 1 is a pairwise coprime sequence the maximum element of bi can never greater then 2mx 1 Here mx is the maximum elements in ai So what we need consider is the first a few prime factors It is not hard to use bitmask dp to solve this Here dp i s means the first i items of the sequence and the prime factor have already existed And fact k means the prime factor set of number k 
 Summer vacation has started so Alice and Bob want to play and joy but Their mom doesn t think so She says that they have to read some amount of books before all entertainments Alice and Bob will read each book to end this exercise faster There are n books in the family library The i th book is described by three integers t i the amount of time Alice and Bob need to spend to read it a i equals 1 if Alice likes the i th book and 0 if not and b i equals 1 if Bob likes the i th book and 0 if not So they need to choose some books from the given n books in such a way that Alice likes k books from the chosen set and Bob likes k books from the chosen set the total reading time of these books is they are children and want to play and joy as soon a possible The set they choose is for both Alice an Bob it s shared between them and they read all books so the total reading time is the sum of t i over all books that are in the chosen set Your task is to help them and find any suitable set of books or determine that it is impossible to find such a set ,"['#include <bits/stdc++.h>\n#define IO_OP std::ios::sync_with_stdio(0); std::cin.tie(0);\n#define F first\n#define S second\n#define V vector\n#define PB push_back\n#define MP make_pair\n#define EB emplace_back\n#define ALL(v) (v).begin(), (v).end()\n#define debug(x) cerr << #x << "" is "" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef V<int> vi;\n\nconst int INF = 1e9 + 7;\n\nsigned main()\n{\n\tIO_OP;\n\t\n\tint n, k;\n\tcin >> n >> k;\n\tvi x, y, z;\n\tfor(int i = 0; i < n; i++) {\n\t\tint t, a, b;\n\t\tcin >> t >> a >> b;\n\t\tif(a == 0 && b == 0) continue;\n\t\tif(a == 1 && b == 1) z.PB(t);\n\t\telse if(a == 1) x.PB(t);\n\t\telse y.PB(t);\n\t}\n\tsort(ALL(x)), sort(ALL(y)), sort(ALL(z));\n\tfor(int i = 1; i < x.size(); i++) x[i] += x[i - 1];\n\tfor(int i = 1; i < y.size(); i++) y[i] += y[i - 1];\n\tfor(int i = 1; i < z.size(); i++) z[i] += z[i - 1];\n\tint ans = INT_MAX;\n\tfor(int i = 0; i <= z.size(); i++) {\n\t\tint cur = 0;\n\t\tif(i) cur += z[i - 1];\n\t\tint rem = k - i;\n\t\trem--;\n\t\tif(rem < 0) {\n\t\t\tans = min(ans, cur);\n\t\t\tcontinue;\n\t\t}\n\t\tif(rem >= x.size() || rem >= y.size()) continue;\n\t\tcur += x[rem] + y[rem];\n\t\tans = min(ans, cur);\n\t}\n\tif(ans == INT_MAX) ans = -1;\n\tcout << ans << endl;\n\n}\n\n\n\n']","[1, 0, 0, 0, 1]",1600,Let s divide all books into four groups both Alice and Bob doesn t like these books only Alice likes these books only Bob likes these books both ALice and Bob like these books Obviously group is useless now So how to solve the problem Let s iterate over the number of books we take from group Let it be Then we obviously need to take exactly books from groups and Among all books in these three groups we have to choose the cheapest ones To calculate sum of times in each group fast enought we can sort each group independently and implement prefix sums on these arrays If is less than zero or greater than the size of or group for each possible then the answer is And don t forget that the answer can be up to Time complexity 
Vasya has recently found out what a digital root of a number is and he decided to share his knowledge with you Let s assume that is the sum of digits of number for example Then the digital root of number equals to if if For example Vasya is afraid of large numbers so the numbers he works with are at most For all such numbers he has proved that Now Vasya wants to quickly find numbers with the given digital root The problem is he hasn t learned how to do that and he asked you to help him You task is given numbers and find the number consisting of exactly digits the leading zeroes are not allowed with digital root equal to or else state that such number does not exist ,"['#include <iostream>\n#include <cstdio>\n#include <string.h>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tint k,d;\n\tcin >> k >> d;\n\tif (k>1 && d==0) {cout << ""No solution""; return 0;}\n\tcout << d;\n\tfor(int i=0; i<k-1; i++) cout << ""0"";\n\tcin >> k;\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0]",1100,If the there is the only number with so if the answer is otherwise If then one of correct numbers is Time complexity for the output 
You are given string consisting of lowercase English letters only Find its lexicographically largest palindromic subsequence We ll call a non empty string a of string where is the length of string For example strings and are subsequences of string String is than string if either and or there exists such number that and Characters in the strings are compared according to their ASCII codes For example string is lexicographically larger than string and string is lexicographically larger than string String is a if it matches string In other words a string is a palindrome if it reads the same way from left to right and from right to left For example palindromic strings are and ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#ifndef LEEWINGS_DEBUG\n#define LEEWINGS_DEBUG 0\n#endif\n\n#define debug(x) if (LEEWINGS_DEBUG) cerr << #x << "" = "" << (x) << endl\n\n#define debug_line(a, n) do {                                                \\\n    if (LEEWINGS_DEBUG) {                                                             \\\n        cerr << #a << ""["" << #n << ""]:"" << endl;                             \\\n        for (int i = 0; i < (n); i++) cerr << (a)[i] << "" "";                 \\\n        cerr << endl;                                                        \\\n    }                                                                        \\\n} while (0)\n\n#define debug_mat(a, n, m) do {                                              \\\n    if (LEEWINGS_DEBUG) {                                                             \\\n        cerr << #a << ""["" << #n << ""]["" << #m ""]:"" << endl;                  \\\n        for (int i = 0; i < (n); i++) {                                      \\\n            for (int j = 0; j < (m); j++) cerr << (a)[i][j] << "" "";          \\\n            cerr << endl;                                                    \\\n        }                                                                    \\\n    }                                                                        \\\n} while(0)\n\ntypedef pair<int, int> pii;\ntypedef vector<int>::const_iterator vci;\ntypedef map<int, int>::const_iterator mci;\n\nconst int INF = 0x3f3f3f3f;\nconst long long LLINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = 1.0/0.0f;\nconst double pi = acos(-1.0);\nconst double eps = 1e-8;\nconst int MOD = 1000000007;\n\ninline int LC(int x) { return x << 1; }\ninline int RC(int x) { return (x << 1) | 1; }\ninline bool eq0(double x) { return fabs(x) < eps; }\ninline bool eq(double x, double y) { return fabs(x - y) < eps; }\ninline bool ls(double x, double y) { return x + eps < y; }\ninline bool gr(double x, double y) { return x - eps > y; }\ninline bool greq(double x, double y) { return x + eps >= y; }\ninline bool lseq(double x, double y) { return x - eps <= y; }\ninline double fmax(double x, double y) { return gr(x, y) ? x : y; }\ninline double fmin(double x, double y) { return ls(x, y) ? x : y; }\n\ntemplate<class T> inline T sqr(T x) { return x * x; }\n\nint main()\n{\n    string s;\n    cin >> s;\n    char c = *max_element(s.begin(), s.end());\n    int cnt = count(s.begin(), s.end(), c);\n    while (cnt--) cout << c;\n    cout << endl;\n\n    return 0;\n}\n\n']","[1, 0, 1, 0, 0]",800,It s assumed that this problem can be solved just looking at the samples and without reading the statement itself Let s find the letter in the given string which comes last in the alphabet denote this letter by z If this letter occurs p times in the given string then the answer is string a consisting of letter z repeated p times Why is it so Using the definition of lexicographical comparison and the fact that z is the largest letter in the string it s easy to understand that if some other subsequence b of the given string is lexicographically larger than a then string b should be longer than a and moreover a should be a prefix of b that is b should start with a But string b must be a palindrome therefore its last letter must be z In this case string b must contain more occurrences of letter z than the original string s does which is impossible as b is a subsequence of s Besides that the constraint on the length of the string was very low so the problem could be solved using brute force For every subsequence of the given string it s necessary to check whether it s a palindrome and from all palindromic subsequences of s the lexicographically largest should be chosen as the answer The complexity of such a solution is O 2n n where n is the length of the string unlike the solution above with complexity O n 
Every decimal number has a base k equivalent The individual digits of a base k number are called k its Let s define the k itwise XOR of two k its a and b as a b bmod k The k itwise XOR of two base k numbers is equal to the new number formed by taking the k itwise XOR of their corresponding k its The k itwise XOR of two decimal numbers a and b is denoted by a oplus k b and is equal to the decimal representation of the k itwise XOR of the base k representations of a and b All further numbers used in the statement below are in decimal unless specified When k 2 it is always true in this version the k itwise XOR is the same as the bitwise XOR You have hacked the criminal database of Rockport Police Department RPD also known as the Rap Sheet But in order to access it you require a password You don t know it but you are quite sure that it lies between 0 and n 1 inclusive So you have decided to guess it Luckily you can try at most n times without being blocked by the system But the system is adaptive Each time you make an incorrect guess it changes the password Specifically if the password before the guess was x and you guess a different number y then the system changes the password to a number z such that x oplus k z y Guess the password and break into the system ,"['// Problem: D1. RPD and Rap Sheet (Easy Version)\n// Contest: Codeforces - Codeforces Round #730 (Div. 2)\n// URL: https://codeforces.com/contest/1543/problem/D1\n// Memory Limit: 256 MB\n// Time Limit: 5000 ms\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')w=-1;ch=getchar();}\n   while(ch>=\'0\'&&ch<=\'9\') s=s*10+ch-\'0\',ch=getchar();\n   return s*w;\n}\nconst int p=998244353;\nint qp(int x,int y)\n{\n\tint res=1;\n\tfor(int t=x; y; y>>=1,t=t*t%p) if(y&1) res=res*t%p;\n\treturn res;\n}\nsigned main()\n{\n\tfor(int T=read();T--;)\n\t{\n\t\tint n=read(),k=read();\n\t\tint s=0;\n\t\tfor(int i=0; i<n; ++i)\n\t\t{\n\t\t\tprintf(""%lld\\n"",i^s);\n\t\t\tfflush(stdout);\n\t\t\ts=i;\n\t\t\tif(read()==1) break;\n\t\t\t//i0ixor s\n\t\t}\n\t}\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",1700,In this version of the problem So the itwise XOR is the same as Bitwise XOR In case of incorrect guess the system changes password to such that Taking XOR with on both sides because we know that Since the original password is less than and we have queries we need to find a way to make queries such that if the original password was then the th query will be equal to the current password There are many different approaches I will describe two of them Method 1Let denote the th query Then for Let s see why this works Claim If the original password was after queries the current password will be ProofLet s prove this by induction Base Condition After st query the password becomes Induction Hypothesis Let the password after th query be Inductive step The th query will be If this is not equal to the current password the password will change to Hence proved by induction Now notice that after queries the password will become And our th query will be which is the same as the current password So the problem will be solved after queries Since the problem will be solved in at most queries Method 2 Idea by KAN Again let denote the th query Then Let s see why this works Claim If the original password was after queries the current password will be ProofLet s prove this by induction Base Condition The first query is After st query the password becomes Induction Hypothesis Let the password after th query be Inductive step The th query will be So the password after th query will be Hence proved by induction Now notice that after queries the password will become And our th query will be which is the same as the current password So the problem will be solved after queries Since the problem will be solved in at most queries But we are not done yet We can t afford to calculate the value of each query naively in because this will time out To handle this we need to maintain a prefix XOR whose value will be after queries For the th query find and update Time Complexity or depending upon the implementation 
The gym leaders were fascinated by the evolutions which took place at Felicity camp So they were curious to know about the secret behind evolving Pokemon The organizers of the camp gave the gym leaders a PokeBlock a sequence of ingredients Each ingredient can be of type or Now the organizers told the gym leaders that to evolve a Pokemon of type they need to make a valid set of cuts on the PokeBlock to get smaller blocks Suppose the given PokeBlock sequence is You have a choice of making cuts at places i e Before between and between and between and and after The choices of making cuts are as follows where a denotes a possible cut Consider a sequence of cuts Now each pair of consecutive cuts will contain a binary string between them formed from the ingredient types The ingredients before the first cut and after the last cut are wasted which is to say they are not considered So there will be exactly such binary substrings Every substring can be read as a binary number Let be the maximum number out of the obtained numbers If all the obtained numbers are positive and the set of the obtained numbers contains all integers from to then this set of cuts is said to be a valid set of cuts For example suppose the given PokeBlock sequence is and we made cuts in the following way So the binary substrings obtained are and which correspond to the numbers and respectively Here as it is the maximum value among the obtained numbers And all the obtained numbers are positive and we have obtained all integers from to Hence this set of cuts is a valid set of cuts A Pokemon of type will evolve only if the PokeBlock is cut using a valid set of cuts There can be many valid sets of the same size Two valid sets of cuts are considered different if there is a cut in one set which is not there in the other set Let denote the number of valid sets of cuts Find the value of Since the value of can be very large output modulo ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\nconst int NUM = 20;\nconst int N = (1 << NUM) + 10;\nconst int LEN = 79;\n\nint f[LEN][N];\nchar s[LEN];\n\nint main() {\n  int len;\n  scanf(""%d"", &len);\n  scanf(""%s"", s);\n  for (int i = 0; i < len; i++) {\n    f[i][0] = 1;\n    for (int t = 0; t < (1 << NUM); t++) {\n      if (f[i][t] == 0) {\n        continue;\n      }\n      int x = 0;\n      for (int j = i; j < len; j++) {\n        x = x * 2 + s[j] - \'0\';\n        if (x > NUM) {\n          break;\n        }\n        if (x > 0) {\n          add(f[j + 1][t | (1 << (x - 1))], f[i][t]);\n        }\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i <= len; i++) {\n    int r = 1;\n    while (r < (1 << NUM)) {\n      add(ans, f[i][r]);\n      r = r * 2 + 1;\n    }\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","[0, 0, 0, 1, 0]",2200,Main idea DP with Bitmask This problem can be solved using Dynamic Programming with bitmask The important thing to note here is that the set of distinct numbers formed will be a maximum of 20 numbers i e from 1 to 20 else it won t fit 75 bits 1 1 bits 2 2 bits 4 3 bits 8 4 bits 5 5 bits 74 bits So we can use a bitmask to denote a set of numbers that are included in a set of cuts Let s see a Top Down approach to solve it Lets define the function f i mask as f i mask denotes the number of sets of valid cuts that can be obtained from the state i mask The state formation is defined below Let M be the maximum number among the numbers in mask mask denotes a set of numbers that have been generated using some number of cuts all of them before bi Out of these cuts the last cut has been placed just before bi Now first we check if the set of cuts obtained from mask is valid or not in order for a mask to be valid mask 2X 1 where X denotes number of set bits in the mask and increment the answer accordingly if the mask is valid And then we also have the option of adding another cut We can add the next cut just before bx provided the number formed by bi bi 1 bx 1 20 Set the corresponding bit for this number formed to 1 in the mask to obtain newMask and recursively find f x newMask 
Timur initially had a binary string dagger s possibly of length 0 He performed the following operation several possibly zero times Add texttt 0 to one end of the string and texttt 1 to the other end of the string For example starting from the string texttt 1011 you can obtain either color red texttt 0 texttt 1011 color red texttt 1 or color red texttt 1 texttt 1011 color red texttt 0 You are given Timur s final string What is the length of the possible string he could have started with dagger A binary string is a string possibly the empty string whose characters are either texttt 0 or texttt 1 ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int               long long\n#define pb                push_back\n#define ppb               pop_back\n#define all(x)            (x).begin(),(x).end()\n#define uniq(v)           (v).erase(unique(all(v)),(v).end())\n#define sz(x)             (int)((x).size())\n#define f                 first\n#define s                 second\n#define pii               pair<int,int>\n#define rep(i,a,b)        for(int i = a; i < b; i++)\n#define repd(i,a,b)       for(int i = a; i >= b; i--)\n#define mem1(a)           memset(a, -1, sizeof(a))\n#define ppc               __builtin_popcount\n#define ppcll             __builtin_popcountll\n#define ll                long long\n#define ld                long double\n\ntemplate<typename T,typename U>istream& operator>>(istream& in,pair<T,U> &a){in>>a.f>>a.s;return in;}\ntemplate<typename T,typename U>ostream& operator<<(ostream& out,pair<T,U> a){out<<\'(\'<<a.f<<"", ""<<a.s<<\')\';return out;}\ntemplate<typename T>ostream& operator<<(ostream&cout,vector<T>const&v){cout<<""["";rep(i,0,sz(v)){if(i)cout<<"", "";cout<<v[i];}return cout<<""]"";}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n      cout << name << "" : "" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n      const char* comma = strchr(names + 1, \',\'); cout.write(names, comma - names) << "" : "" << arg1 << "" | ""; __f(comma + 1, args...);\n}\n#else\n#define dbg(...)\n#endif\n\nconst ld pi = 3.14159265358979323846;\nconst char nl = \'\\n\';\nconst long long INF=1e18;\nconst int32_t M=1e9+7;\nconst int32_t MM=998244353;\n\nconst int N=1e6+5;      \nll n, m, q, k, l, r, x, y, z, a[N], b[N], c[N];\nstring s,t;\n\n\n\nvoid KSBR(){\n      cin >> n >> s;\n      int l = 0, r = n-1;\n      while(l < r) {\n            int x = s[l] - \'0\', y = s[r] - \'0\';\n            if(x + y == 1) l++, r--;\n            else break;\n      }\n      cout << r - l + 1 << nl;\n} \nsigned main(){\n      ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n      #ifdef SIEVE\n            sieve();\n      #endif\n      #ifdef NCR\n            init();\n      #endif\n      int t=1, tc = 1;\n      cin>>t;\n      while(t--) {\n            //cout << ""Case "" << ""#"" << tc++ << "": "";\n            KSBR();\n      }\n}']","[0, 0, 1, 0, 0]",800,Let s perform the process in reverse we will remove the first and last character of the string if these two characters are different We should do this as long as possible since we need to find the shortest initial string So the algorithm is straightfoward keep track of the left and right characters and if they are different remove both Otherwise output the length of the current string or output if the string became empty There are a few ways to implement this For example you can keep two pointers one at the beginning of the string and one at the end say and and check if If it s true then we increment and decrement Otherwise we output We stop when Alternatively you can use deque to simulate the operations directly The time complexity is 
Polycarp plays a well known computer game we won t mention its name In this game he can craft tools of two types shovels and swords To craft a shovel Polycarp spends two sticks and one diamond to craft a sword Polycarp spends two diamonds and one stick Each tool can be sold for exactly one emerald How many emeralds can Polycarp earn if he has a sticks and b diamonds ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tlong long a, b;\n\tcin >> a >> b;\n\tlong long ans = (a + b) / 3;\n\tans = min(ans, min(a, b));\n\tcout << ans << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","[1, 1, 0, 0, 0]",1100,There are three constraints on the number of emeralds the number of emeralds can t be greater than the number of emeralds can t be greater than the number of emeralds can t be greater than So the answer is 
The whole delivery market of Berland is controlled by two rival companies BerEx and BerPS They both provide fast and reliable delivery services across all the cities of Berland The map of Berland can be represented as an graph The cities are vertices and the roads are edges between them Each pair of cities has no more than one road between them Each road connects different cities BerEx and BerPS are so competitive that for each pair of cities v u they have set up their paths from v to u in such a way that It is guaranteed that it was possible Now Berland government decided to cut down the road maintenance cost by abandoning some roads Obviously they want to maintain as little roads as possible However they don t want to break the entire delivery system So BerEx and BerPS should still be able to have their paths between every pair of cities non intersecting What is the minimal number of roads Berland government can maintain ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int INF = 100100;\nconst int N = 15;\nconst int M = (1 << 14) + 7;\nbool g[N][N];\nint n, m;\nint edgesToMask[N][M];\nvector<int> pathInMask[M][N][N];\nint dp[M];\nint par[M][3];\n\nint main()\n{\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tscanf(""%d%d"", &n, &m);\n\twhile(m--) {\n\t\tint v, u;\n\t\tscanf(""%d%d"", &v, &u);\n\t\tv--;u--;\n\t\tg[v][u] = g[u][v] = 1;\n\t}\n\tfor (int v = 0; v < n; v++)\n\t\tfor (int mask = 0; mask < (1 << n); mask++)\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (((mask >> u) & 1) == 0) continue;\n\t\t\t\tif (g[v][u])\n\t\t\t\t\tedgesToMask[v][mask]++;\n\t\t\t}\n\tfor (int v = 0; v < n; v++)\n\t\tpathInMask[1 << v][v][v].push_back(v);\n\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t//cerr << mask << endl;\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tfor (int u = 0; u < n; u++) {\n\t\t\t\tif (pathInMask[mask][v][u].empty()) continue;\n\t\t\t\tfor (int w = 0; w < n; w++) {\n\t\t\t\t\tif ((mask >> w) & 1) continue;\n\t\t\t\t\tif (!g[u][w]) continue;\n\t\t\t\t\tint nmask = mask | (1 << w);\n\t\t\t\t\tif (!pathInMask[nmask][v][w].empty()) continue;\n\t\t\t\t\tpathInMask[nmask][v][w] = pathInMask[mask][v][u];\n\t\t\t\t\tpathInMask[nmask][v][w].push_back(w);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\tfor (int mask = 0; mask < (1 << n); mask++)\n\t\tdp[mask] = INF;\n\tdp[1] = 0;\n\tfor (int mask = 0; mask < (1 << n); mask++) {\n\t\t//cerr << mask << endl;\n\t\tif (dp[mask] == INF) continue;\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif ((mask >> v) & 1) continue;\n\t\t\tif (edgesToMask[v][mask] >= 2) {\n\t\t\t\tint nmask = mask | (1 << v);\n\t\t\t\tif (dp[nmask] > dp[mask] + 2) {\n\t\t\t\t\tdp[nmask] = dp[mask] + 2;\n\t\t\t\t\tpar[nmask][0] = mask;\n\t\t\t\t\tpar[nmask][1] = par[nmask][2] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (edgesToMask[v][mask] == 0) continue;\n\t\t\tfor (int u = v + 1; u < n; u++) {\n\t\t\t\tif ((mask >> u) & 1) continue;\n\t\t\t\tif (edgesToMask[u][mask] == 0) continue;\n\t\t\t\tint all = ((1 << n) - 1) ^ mask ^ (1 << v) ^ (1 << u);\n\t\t\t\tfor (int smask = all;; smask = (smask - 1) & all) {\n\t\t\t\t\tint nmask = smask | (1 << v) | (1 << u);\n\t\t\t\t\tif (!pathInMask[nmask][v][u].empty()) {\n\t\t\t\t\t\tint w = dp[mask] + (int)pathInMask[nmask][v][u].size() + 1;\n\t\t\t\t\t\tif (w < dp[mask | nmask]) {\n\t\t\t\t\t\t\tdp[mask | nmask] = w;\n\t\t\t\t\t\t\tpar[mask | nmask][0] = mask;\n\t\t\t\t\t\t\tpar[mask | nmask][1] = v;\n\t\t\t\t\t\t\tpar[mask | nmask][2] = u;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (smask == 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(""%d\\n"", dp[(1 << n) - 1]);\n//\tfflush(stdout);\n\tint mask = (1 << n) - 1;\n\twhile(mask > 1) {\n\t\t//cerr << mask << endl;\n\t\t//return 0;\n\t\tint nmask = par[mask][0];\n\t\tint v = par[mask][1];\n\t\tint u = par[mask][2];\n\t\tif (v == u) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int z = 0; cnt < 2 && z < n; z++) {\n\t\t\t\tif (((nmask >> z) & 1) == 0) continue;\n\t\t\t\tif (!g[v][z]) continue;\n\t\t\t\tcnt++;\n\t\t\t\tprintf(""%d %d\\n"", v + 1, z + 1);\n\t\t\t}\n\t\t\tif (cnt != 2) throw;\n\t\t} else {\n\t\t\tfor (int z = 0; z < n; z++) {\n\t\t\t\tif (((nmask >> z) & 1) == 0) continue;\n\t\t\t\tif (!g[v][z]) continue;\n\t\t\t\tprintf(""%d %d\\n"", v + 1, z + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int z = 0; z < n; z++) {\n\t\t\t\tif (((nmask >> z) & 1) == 0) continue;\n\t\t\t\tif (!g[u][z]) continue;\n\t\t\t\tprintf(""%d %d\\n"", u + 1, z + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvector<int> z = pathInMask[mask ^ nmask][v][u];\n\t\t\tfor (int i = 0; i < (int)z.size() - 1; i++) {\n\t\t\t\tprintf(""%d %d\\n"", z[i] + 1, z[i + 1] + 1);\n\t\t\t}\n\t\t}\n\t\tmask = nmask;\n\t}\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0]",2800,Let s use dynamic programming to solve this problem We will start with a single biconnected component consisting of vertex and connect other vertices to it So the state of our dynamic programming will be a of vertices that are in the same biconnected component with How can we extend a biconnected component in such a way that some other vertices are added into it but it is still biconnected We will add a path possibly cyclic that starts in some vertex belonging to the goes through some vertices and ends in some vertex belonging to the possibly If for every triple we precalculate some path that starts in goes through vertices from and ends in and does not contain neither nor then we can solve the problem in there will be states for every state we will iterate on two vertices and belonging to the and the number of possible pairs of non intersecting masks and is The only thing that s left is precalculating the paths for triples That can be done with auxiliary dynamic programming which will denote whether such a path exists For every edge of the original graph is true and we can go from to some state where will contain all vertices from and vertex and we should ensure that there is an edge in the graph and the didn t contain vertex earlier We should also somehow be able to restore the paths from this dp and we also should be careful not to choose the same edge twice for example if we start a path by edge we should not use the same edge to return to both these things can be done for example by storing next to last vertex in the path 
Bash has set out on a journey to become the greatest Pokemon master To get his first Pokemon he went to Professor Zulu s Lab Since Bash is Professor Zulu s favourite student Zulu allows him to take as many Pokemon from his lab as he pleases But Zulu warns him that a group of Pokemon with strengths tend to fight among each other if see notes for definition Bash being smart does not want his Pokemon to fight among each other However he also wants to maximize the number of Pokemon he takes from the lab Can you help Bash find out the maximum number of Pokemon he can take A Pokemon cannot fight with itself ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1234567;\n\nint cnt[N];\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  for (int i = 0; i < n; i++) {\n    int foo;\n    scanf(""%d"", &foo);\n    cnt[foo]++;\n  }\n  int ans = 1;\n  for (int i = 2; i < N; i++) {\n    int cur = 0;\n    for (int j = i; j < N; j += i) {\n      cur += cnt[j];\n    }\n    ans = max(ans, cur);\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","[1, 1, 0, 0, 0]",1400,Main idea Square root factorization and keeping count of prime factors The problem can be simplified to finding a group of Pokemons such that their strengths have a common factor other that 1 We can do this by marking just the prime factors and the answer will be the maximum count of a prime factor occurring some number of times The prime numbers of each number can be found out using pre computed sieve or square root factorization Corner Cases Since a Pokemon cannot fight with itself as mentioned in the note the minimum answer is 1 Thus even in cases where every subset of the input has gcd equal to 1 the answer will be 1 
Ohana Matsumae is trying to clean a room which is divided up into an by grid of squares Each square is initially either clean or dirty Ohana can sweep her broom over columns of the grid Her broom is very strange if she sweeps over a clean square it will become dirty and if she sweeps over a dirty square it will become clean She wants to sweep some columns of the room to maximize the number of rows that are completely clean It is not allowed to sweep over the part of the column Ohana can only sweep the whole column Return the maximum number of rows that she can make completely clean ,"['#pragma comment (linker, ""/STACK:1000000000"")\n\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <set>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nconst int maxn = 110;\n\nstring s[maxn];\n\nmap <string, int> m;\n\nint main() {\n\tint n;\n\n\tscanf(""%d"", &n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> s[i];\n\t\tm[s[i]]++;\n\t}\n\n\tmap <string, int>::iterator  it;\n\n\tint ans = 0;\n\n\tfor (it = m.begin(); it != m.end(); it++) {\n\t\tans = max(ans, it->second);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",1200,For each row there is only one set of columns we can sweep so it becomes completely clean So there are only configurations of sweeping columns to look at Checking a configuration takes time to count the number of rows that are completely clean There are configurations in all so this takes time total Alternatively another way of solving this problem is finding the maximum number of rows that are all the same Example code http codeforces com contest 554 submission 11767576 
Kuriyama Mirai has killed many monsters and got many namely stones She numbers the stones from to The cost of the th stone is Kuriyama Mirai wants to know something about these stones so she will ask you two kinds of questions She will tell you two numbers and and you should tell her Let be the cost of the th cheapest stone the cost that will be on the th place if we arrange all the stone costs in non decreasing order This time she will tell you two numbers and and you should tell her For every question you should give the correct answer or Kuriyama Mirai will say fuyukai desu and then become unhappy ,"['#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define LLF ""%I64d""\n\nconst int MAX_SIZE = 100000;\n\nint n, data[MAX_SIZE + 10];\nLL a[MAX_SIZE + 10], b[MAX_SIZE + 10];\n\n\nint main(){\n\tscanf(""%d"", &n);\n\tfor(int i = 1; i <= n; i ++)\n\t\tscanf(""%d"", data + i);\n\tfor(int i = 1; i <= n; i ++)\n\t\ta[i] = a[i - 1] + data[i];\n\tsort(data + 1, data + n + 1);\n\tfor(int i = 1; i <= n; i ++)\n\t\tb[i] = b[i - 1] + data[i];\n\tint m;\n\tscanf(""%d"", &m);\n\twhile(m --){\n\t\tint t, l, r;\n\t\tscanf(""%d%d%d"", &t, &l, &r);\n\t\tif(t == 1)\n\t\t\tprintf(LLF ""\\n"", a[r] - a[l - 1]);\n\t\telse\n\t\t\tprintf(LLF ""\\n"", b[r] - b[l - 1]);\n\t}\n\n\treturn 0;\n}\n\n\n\n']","[0, 0, 1, 1, 0]",1200,Sort sequence to obtain sequence Sorting can be done in using quicksort Now we are interested in the sum of a interval of a given sequence This can be done by calculating the prefix sum of the sequence beforehand That is let The sum of numbers in the interval would then be We can deal with sequence likewise Preprocessing takes time and answering a query is only The total complexity would be Solution 6713020 
Archeologists have found a secret pass in the dungeon of one of the pyramids of Cycleland To enter the treasury they have to open an unusual lock on the door The lock consists of words each consisting of some hieroglyphs The wall near the lock has a round switch Each rotation of this switch changes the hieroglyphs according to some rules The instruction nearby says that the door will open only if words written on the lock would be sorted in the definition of lexicographical comparison in given in notes section The rule that changes hieroglyphs is the following One clockwise rotation of the round switch replaces each hieroglyph with the next hieroglyph in alphabet i e hieroglyph is replaced with hieroglyph and hieroglyph is replaced with hieroglyph Help archeologist determine how many clockwise rotations they should perform in order to open the door or determine that this is impossible i e no cyclic shift of the alphabet will make the sequence of words sorted lexicographically ,"['#include <bits/stdc++.h>\n\nusing namespace std;\nconst double pi=acos(-1.0);\nconst double eps=1e-9;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define re return\n#define vi vector <int> \n#define pii pair <int,int>\n#define pll pair <long long , long long>\ntypedef long long ll;\n\nconst int N=(int)5e5+5;\nconst int C=(int)1e6+5;\n\nint n,c,l[N],a,b,t[C];\nvector <int> v[N];\nbool good[N];\n\nint main()\n{\n\tios:: sync_with_stdio(false);\n\tcin >> n >> c;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin >> l[i];\n\t\tfor(int j=0;j<l[i];j++)\n\t\t{\n\t\t\tcin >> a;\n\t\t\ta--;\n\t\t\tv[i].pb(a);\n\t\t}\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(l[i+1]>=l[i])continue;\n\t\tbool ok=false;\n\t\tfor(int j=0;j<l[i+1];j++)\n\t\t\tif(v[i][j]!=v[i+1][j])\n\t\t\t{\n\t\t\t\tok=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(!ok)\n\t\t{\n\t\t\tcout << -1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t//cout << ""Hi"";\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(l[i]>l[i+1])continue;\n\t\tbool ok=true;\n\t\tfor(int j=0;j<l[i];j++)\n\t\t\tif(v[i][j]!=v[i+1][j])\n\t\t\t{\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(ok)good[i]=true;\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(good[i])continue;\n\t\tfor(int j=0;j<min(l[i],l[i+1]);j++)\n\t\t\tif(v[i][j]!=v[i+1][j])\n\t\t\t{\n\t\t\t\ta=v[i][j];\n\t\t\t\tb=v[i+1][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(a<b)\n\t\t{\n\t\t\tt[c-b]++;\n\t\t\tt[c-a]--;\n\t\t} else\n\t\t{\n\t\t\tt[0]++;\n\t\t\tt[c-a]--;\n\t\t\tt[c-b]++;\n\t\t\tt[c]--;\n\t\t}\n\t}\n\tint cur=0;\n\tfor(int i=0;i<c;i++)\n\t{\n\t\tcur+=t[i];\n\t\tif(cur==0)\n\t\t{\n\t\t\tcout << i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << -1;\n\treturn 0;\n}']","[1, 0, 0, 0, 1]",2200,Problem author olympiad jury developer Flyrise Denote as the number of alphabet cyclic shifts we will perform Our goal is to formulate the statement of lexicographical order in terms of Note that may be considered as an integer between and i e as a residue modulo Let s also consider all characters as values between as we may subtract 1 from the value of each character Consider two consecutive words in the given list There are two possibilities corresponding two cases in the definition of lexicographical order The first case is when there exists such a position that these words differ in this position and coincide before this position Suppose that first word has value of on this position and second word has the value of Then these words will follow in lexicographical order if and only if It s easy to see that if we consider all residues modulo as a circle then this inequality defines an arc of possible s on this circle So this pair of contiguous words produces the following statement belongs to some arc on the circle The second case is when there is no such a position i e one word is a prefix of another If the first word is a prefix of second one then these words always follow in lexicographical order irrespective to the choice of In the other case second word is a proper prefix of the first word we can t do anything with these to words since they will never follow in a lexicographical order so we should print Now we have to find a point on the circle belonging to the given set of arcs Suppose we have arcs Consider a line segment from to instead of a circle each arc will transform to either one or two its subsegments Now we have to find out if there exists a point covered by exactly segments It may be done in different ways for example you may add 1 on each of this segment by using some data structure or you may add to the left endpoint of each segment and to the point after the right endpoint of each segment and consider prefix sums an off line way to handle range addition queries Or you may write down all endpoints of all segments sort them by a coordinate and iterate over them from left to right keeping the number of open segments If at some moment you have exactly open segments then the answer is YES 
Nastya received a gift on New Year a magic wardrobe It is magic because in the end of each month the number of dresses in it doubles i e the number of dresses becomes twice as large as it is in the beginning of the month Unfortunately right after the doubling the wardrobe eats one of the dresses if any with the probability It happens every month except the last one in the year Nastya owns dresses now so she became interested in the expected number of dresses she will have in one year Nastya lives in Byteland so the year lasts for months Nastya is really busy so she wants you to solve this problem You are the programmer after all Also you should find the answer modulo because it is easy to see that it is always integer ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<int m>\nstruct modint {\n\n\tunsigned x;\n\n\tmodint() : x(0) {}\n\n\tmodint(long long arg) {\n\t\targ %= m;\n\t\tif (arg < 0) {\n\t\t\tx = arg + m;\n\t\t} else {\n\t\t\tx = arg;\n\t\t}\n\t}\t\n\n\tmodint& operator+= (const modint& other) {\n\t\tx += other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator*= (const modint& other) {\n\t\tx = (x * 1ll * other.x) % m;\n\t\treturn *this;\n\t}\n\n\tmodint& operator-= (const modint& other) {\n\t\tx += m - other.x;\n\t\tif (x >= m) {\n\t\t\tx -= m;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator+ (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp += other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator- (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp -= other;\n\t\treturn tmp;\n\t}\n\n\tmodint operator* (const modint& other) const {\n\t\tmodint tmp = *this;\n\t\ttmp *= other;\n\t\treturn tmp;\n\t}\n\n\texplicit operator int () const {\n\t\treturn x;\n\t}\n\n\tmodint& operator++ () {\n\t\t++x;\n\t\tif (x == m) {\n\t\t\tx = 0;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint& operator-- () {\n\t\tif (x == 0) {\n\t\t\tx = m-1;\n\t\t} else {\n\t\t\t--x;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tmodint operator++ (int) {\n\t\tmodint tmp = *this;\n\t\t++*this;\n\t\treturn tmp;\n\t}\n\n\tmodint operator-- (int) {\n\t\tmodint tmp = *this;\n\t\t--*this;\n\t\treturn tmp;\n\t}\n\n\tbool operator== (const modint& other) const {\n\t\treturn x == other.x;\n\t}\n\n\tbool operator!= (const modint& other) const {\n\t\treturn x != other.x;\n\t}\n\n\ttemplate<class T>\n\tmodint operator^ (T arg) const {\n\t\tif (arg == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (arg == 1) {\n\t\t\treturn x;\n\t\t}\n\t\tauto t = *this ^ (arg >> 1);\n\t\tt *= t;\n\t\tif (arg & 1) {\n\t\t\tt *= *this;\n\t\t}\n\t\treturn t;\n\t}\n\n\tmodint inv() const {\n\t\treturn *this ^ (m-2);\n\t}\n};\n\nconst int MOD = 1\'000\'000\'007;\ntypedef modint<MOD> mint;\n\ntypedef long long ll;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcout.tie(nullptr);\n\tcerr.tie(nullptr);\n\n\tll x, k;\n\tcin >> x >> k;\n\n\tif (x == 0)\n\t\treturn cout << ""0\\n"", 0;\n\n\tmint z = x;\n\tz *= mint(2) ^ (k+1);\n\tz -= mint(2) ^ k;\n\tz += 1;\n\n\tcout << (int)z << \'\\n\';\n}']","[0, 1, 0, 0, 0]",1600,Let s present we have initially dresses What does occur in the first month Initially the number of dresses is multiplied by 2 that is becomes Then with probability the wardrobe eats a dress that is expected value of the number of dresses becomes The same way after the second month expected value becomes It s easy to notice that after th month if expected value equals Eventually it will be only doubled as the wardrobe doesn t eat a dress in the last month that is will be equal Thus answer of the problem is Expressing it with we get Thus we need to calculate degree of 2 right up to Complexity of the soltion is Let s notice that the case we need to calculate separately because wardrobe can t eat a dress when it doesn t exist If it s easy to proof that the number of dresses is never negative that is the formula works 
You are given a string s consisting of lowercase Latin letters In one operation you can select several one or more positions in it such that no two selected positions are adjacent to each other Then you remove the letters on the selected positions from the string The resulting parts are concatenated without changing their order What is the smallest number of operations required to make all the letters in s the same ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=300005,INF=1<<30;\n\nint main(){\n    \n    std::ifstream in(""text.txt"");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        string S;cin>>S;\n        int ans=INF;\n        for(char c=\'a\';c<=\'z\';c++){\n            int ma=0;\n            int i=0;\n            while(i<si(S)){\n                if(S[i]==c) i++;\n                else{\n                    int j=i;\n                    while(j<si(S)&&S[j]!=c) j++;\n                    \n                    for(int t=1;;t++){\n                        if((1<<t)>j-i){\n                            chmax(ma,t);\n                            break;\n                        }\n                    }\n                    \n                    i=j;\n                }\n            }\n            \n            chmin(ans,ma);\n        }\n        \n        cout<<ans<<""\\n"";\n    }\n}\n']","[0, 1, 1, 0, 0]",1300,The resulting string looks like a single letter repeated a number of times That sounds too vague Let s fix the exact letter that will be left Since the size of the alphabet is only we can afford that The letters now separate into letters and other letters And all other letters can be treated as indistinguishable from each other Let s make letter into a binary and any other letter into a binary Our goal is to remove all zeros from the string with the given operations First notice that it doesn t help you to removes ones If some operation contains both ones and zeros then taking ones out of it doesn t make any zeros in it adjacent At the same time these ones can only help you separate adjacent zeros later Thus we have some blocks of zeros separated by the blocks of ones We want to remove only zeros Notice how these blocks can be solved completely independently of each other If you solve block in operations block in operations block in operations then you can solve the entire string in operations Since the blocks are separated by the blocks of ones you can combine the first operations for all blocks into one big operation and so on The only thing left is to calculate the number of operations for a single block Let it have length Basically in one operation you can decrease its length to You can see that the longer the block the greater answer it has So you can find the longest block first then calculate the answer for it You can either use this iterative formula or notice that it s a logarithm of in base and calculate that however you want To find the lengths of the blocks of zeros you can use two pointers Overall complexity per testcase This problem can also be solved in on an arbitrarily large alphabet Basically when you fix a letter you can tell the lengths of the blocks of other letters by looking at the occurrences of the letter For occurrences the lengths of the blocks are So we can calculate the answer for a letter in The total of that for all letters is 
You are given n strings a 1 a 2 ldots a n all of them have the same length m The strings consist of lowercase English letters Find any string s of length m such that each of the given n strings differs from s in at most one position Formally for each given string a i there is no more than one position j such that a i j ne s j Note that the desired string s may be equal to one of the given strings a i or it may differ from all the given strings For example if you have the strings and then the answer to the problem might be the string which differs from the first only by the last character and from the second only by the first ,"['#include<bits/stdc++.h>\nusing namespace std ;\n#define drep( i, s, t ) for( register int i = (t); i >= (s); -- i )\n#define rep( i, s, t ) for( register int i = (s); i <= (t); ++ i )\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define re register\nint gi() {\n\tchar cc = getchar() ; int cn = 0, flus = 1 ;\n\twhile( cc < \'0\' || cc > \'9\' ) {  if( cc == \'-\' ) flus = - flus ; cc = getchar() ; }\n\twhile( cc >= \'0\' && cc <= \'9\' )  cn = cn * 10 + cc - \'0\', cc = getchar() ;\n\treturn cn * flus ;\n}\n#define maxn 205\nint n, a[maxn] , m ; \nchar c[maxn][maxn] ;\nint check( int i ) {\n\tchar now = c[1][i];\n\trep( x, 1, 26) {\n\t\tc[1][i] = x + \'a\' - 1 ;\n\t\tint f = 0 ;\n\t\trep( j, 2, n) {\n\t\t\tint pax = 0;\n\t\t\trep( k, 1, m ) {\n\t\t\t\tif( c[1][k] != c[j][k] ) ++ pax;\n\t\t\t}\n\t\t\tif(pax >= 2) { f = 1; break; }\n\t\t}\n\t\tif(f == 0) {\n\t\t\trep(j, 1, i - 1) printf( ""%c"", c[1][j] ) ;\n\t\t\tprintf(""%c"", x + \'a\' - 1);\n\t\t\trep(j, i + 1, m) printf(""%c"", c[1][j] ) ;\n\t\t\tputs("""") ;\n\t\t\tc[1][i] = now;\n\t\t\treturn 1;\n\t\t}\n\t} \n\tc[1][i] = now;\n\treturn 0;\n} \nvoid solve() {\n\tn = gi(), m = gi() ;\n\trep( i, 1, n ) scanf( ""%s"", c[i] + 1 );\n\trep( i, 1, m ) {\n\t\tif( check(i) ) return;\n\t}\n\tputs(""-1"");\n}\nsigned main() {\n\tint T = gi() ;\n\twhile( T -- ) {\n\t\tsolve() ;\n\t}\n\treturn 0 ;\n} ']","[0, 0, 0, 1, 0]",1700,Consider all strings that differ from the first one in no more than one position this is either the first string or the first string with one character changed We will go through all such strings and see if they can be the answer To do this go through all the strings and calculate the number of positions where they differ 
On Codeforces the Recent Actions field shows the last n posts with recent actions Initially there are posts 1 2 ldots n in the field this is in order from top to down Also there are infinitely many posts not in the field numbered with integers n 1 n 2 ldots When recent action happens in the post p If it is in the Recent Actions field it moves from its position to the top position Otherwise it is added to the top position and the post on the down position is removed from the Recent Actions field You know that the next m recent actions will happen in the posts p 1 p 2 ldots p m n 1 leq p i leq n m in the moments of time 1 2 ldots m that recent actions only happen with posts with numbers geq n 1 For each post i 1 leq i leq n find the first time it will be removed from the Recent Actions field or say that it won t be removed ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::vector<int> p(m);\n    std::vector<int> cnt(m);\n    std::vector<int> ans(n, -1);\n    int x = n - 1;\n    for (int i = 0; i < m; i++) {\n        std::cin >> p[i];\n        p[i]--;\n        if (cnt[p[i] - n]++ == 0) {\n            if (x >= 0) {\n                ans[x] = i + 1;\n            }\n            x--;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << "" \\n""[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n']","[1, 1, 1, 0, 1]",800,Note that posts will be removed in the order The post will be removed at the first time when there are at least different numbers among So let s calculate the number of different numbers among for each using boolean array of length iterating from to Using them we can calculate the answer Time complexity 
Vlad decided to compose a melody on his guitar Let s represent the melody as a sequence of notes corresponding to the characters a b c d e f and g However Vlad is not very experienced in playing the guitar and can only record notes at a time Vlad wants to obtain the melody s and to do this he can merge the recorded melodies together In this case the last sound of the first melody must match the first sound of the second melody For example if Vlad recorded the melodies and he can merge them together and obtain the melody and then merge the result with to get Help Vlad determine the number of melodies consisting of two notes that he needs to record in order to obtain the melody s ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    std::string s;\n    std::cin >> s;\n    std::map<std::string, int> cnt;\n    for (int i = 1; i < n; i++) {\n        std::string t;\n        t += s[i - 1];\n        t += s[i];\n        ++cnt[t];\n    }\n    std::cout << (int) cnt.size() << ""\\n"";\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n \n    int t = 1;\n    std::cin >> t;\n \n    while (t--) {\n        solve();\n    }\n}']","[0, 0, 1, 0, 0]",800,Let s construct the melody sequentially In the first step we can record the notes and In the next step we need to record and because there must be a common symbol when gluing and so on That is we need to have recorded melodies for all We only need to count how many different ones among them because we don t need to record one melody twice 
A magic number is a number formed by concatenation of numbers and We can use each of these numbers any number of times Therefore and are magic numbers but and are not You re given a number Determine if it is a magic number or not ,"['#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<fstream>\n#include<map>\n#include<ctime>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<vector>\n#include<bitset>\n#include<functional>\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define REP(i,l,r) for((i)=(l);(i)<=(r);++(i))\n#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))\nusing namespace std;\n\ntypedef long long LL;\ntypedef double ld;\n\nint n;\nint f[100];\nstring a;\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(""input.txt"",""r"",stdin);freopen(""output.txt"",""w"",stdout);\n#endif\n\tcin>>a;\n\tint i;\n\tf[0]=1;\n\tREP2(i,0,a.size())\n\t{\n\t\tf[i+1]=f[i] && a[i]==\'1\';\n\t\tif(i)\n\t\t\tf[i+1]=f[i+1] || ( f[i-1] && a[i-1]==\'1\' && a[i]==\'4\' );\n\t\tif(i>1)\n\t\t\tf[i+1]=f[i+1] || ( f[i-2] && a[i-2]==\'1\' && a[i-1]==\'4\' && a[i]==\'4\' );\n\t}\n\tif(f[a.size()])\n\t\tcout<<""YES""<<endl;\n\telse cout<<""NO""<<endl;\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",900,Although the input number is very small solving the problem for arbitrary length numbers using strings is easier It s easy to prove that a number meeting the following conditions is magical Here is a sample implementation in C 
William has an array of non negative numbers a 1 a 2 dots a n He wants you to find out how many segments l le r pass the check The check is performed in the following manner The minimum and maximum numbers are found on the segment of the array starting at l and ending at r The check is considered to be passed if the binary representation of the minimum and maximum numbers have the same number of bits equal to 1 ,"['/**\n *    author:  tourist\n *    created: 28.11.2021 18:07:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return \'""\' + s + \'""\';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? ""true"" : ""false"");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = ""{"";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = """";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>(\'0\' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = ""{"";\n  for (const auto &x : v) {\n    if (!first) {\n      res += "", "";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += ""}"";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return ""("" + to_string(p.first) + "", "" + to_string(p.second) + "")"";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "")"";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return ""("" + to_string(get<0>(p)) + "", "" + to_string(get<1>(p)) + "", "" + to_string(get<2>(p)) + "", "" + to_string(get<3>(p)) + "")"";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << "" "" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << ""["" << #__VA_ARGS__ << ""]:"", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nstatic struct FastInput {\n  static constexpr int BUF_SIZE = 1 << 20;\n  char buf[BUF_SIZE];\n  size_t chars_read = 0;\n  size_t buf_pos = 0;\n  FILE *in = stdin;\n  char cur = 0;\n\n  inline char get_char() {\n    if (buf_pos >= chars_read) {\n      chars_read = fread(buf, 1, BUF_SIZE, in);\n      buf_pos = 0;\n      buf[0] = (chars_read == 0 ? -1 : buf[0]);\n    }\n    return cur = buf[buf_pos++];\n  }\n \n  inline void tie(int) {}\n\n  inline explicit operator bool() {\n    return cur != -1;\n  }\n\n  inline static bool is_blank(char c) {\n    return c <= \' \';\n  }\n\n  inline bool skip_blanks() {\n    while (is_blank(cur) && cur != -1) {\n      get_char();\n    }\n    return cur != -1;\n  }\n \n  inline FastInput& operator>>(char& c) {\n    skip_blanks();\n    c = cur;\n    return *this;\n  }\n  \n  inline FastInput& operator>>(string& s) {\n    if (skip_blanks()) {\n      s.clear();\n      do {\n        s += cur;\n      } while (!is_blank(get_char()));\n    }\n    return *this;\n  }\n \n  template <typename T>\n  inline FastInput& read_integer(T& n) {\n    // unsafe, doesn\'t check that characters are actually digits\n    n = 0;\n    if (skip_blanks()) {\n      int sign = +1;\n      if (cur == \'-\') {\n        sign = -1;\n        get_char();\n      }\n      do {\n        n += n + (n << 3) + cur - \'0\';\n      } while (!is_blank(get_char()));\n      n *= sign;\n    }\n    return *this;\n  }\n\n  template <typename T>\n  inline typename enable_if<is_integral<T>::value, FastInput&>::type operator>>(T& n) {\n    return read_integer(n);\n  }\n  \n  #if !defined(_WIN32) || defined(_WIN64)\n  inline FastInput& operator>>(__int128& n) {\n    return read_integer(n);\n  }\n  #endif\n\n  template <typename T>\n  inline typename enable_if<is_floating_point<T>::value, FastInput&>::type operator>>(T& n) {\n    // not sure if really fast, for compatibility only\n    n = 0;\n    if (skip_blanks()) {\n      string s;\n      (*this) >> s;\n      sscanf(s.c_str(), ""%lf"", &n);\n    }\n    return *this;\n  }\n} fast_input;\n\n#define cin fast_input\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> pc(n);\n  for (int i = 0; i < n; i++) {\n    pc[i] = __builtin_popcountll(a[i]);\n  }\n  const int M = 62;\n  vector<vector<tuple<int, int, int>>> segs_min(M);\n  vector<vector<tuple<int, int, int>>> segs_max(M);\n  vector<int> st_min(1, -1);\n  vector<int> st_max(1, -1);\n  auto CountOne = [&](const vector<tuple<int, int, int>>& v, int up) {\n    auto it = lower_bound(v.begin(), v.end(), make_tuple(up + 1, -1, -1));\n    int res = (it == v.begin() ? 0 : get<2>(*prev(it)));\n    if (it != v.end() && up >= get<1>(*it)) {\n      res += up - get<1>(*it) + 1;\n    }\n    return res;\n  };\n  auto Count = [&](const vector<tuple<int, int, int>>& v, int L, int R) {\n    return CountOne(v, R) - CountOne(v, L - 1);\n  };\n  int cc = 0;\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    while (st_min.size() > 1 && a[st_min.back()] > a[i]) {\n      cc -= Count(segs_max[pc[st_min.back()]], st_min[st_min.size() - 2] + 1, st_min.back());\n      segs_min[pc[st_min.back()]].pop_back();\n      st_min.pop_back();\n    }\n    cc += Count(segs_max[pc[i]], st_min.back() + 1, i);\n    segs_min[pc[i]].emplace_back(i, st_min.back() + 1, (i - st_min.back()) + (segs_min[pc[i]].empty() ? 0 : get<2>(segs_min[pc[i]].back())));\n    st_min.push_back(i);\n\n    while (st_max.size() > 1 && a[st_max.back()] < a[i]) {\n      cc -= Count(segs_min[pc[st_max.back()]], st_max[st_max.size() - 2] + 1, st_max.back());\n      segs_max[pc[st_max.back()]].pop_back();\n      st_max.pop_back();\n    }\n    cc += Count(segs_min[pc[i]], st_max.back() + 1, i);\n    segs_max[pc[i]].emplace_back(i, st_max.back() + 1, (i - st_max.back()) + (segs_max[pc[i]].empty() ? 0 : get<2>(segs_max[pc[i]].back())));\n    st_max.push_back(i);\n\n    ans += cc;\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","[0, 0, 0, 0, 1]",2800,We will use Divide Conquer algorithm Let be the answer to the problem on the subsegment Let s notice that if then otherwise where and equals to the number of subsegments passing the check which have left bound ranged from to inclusively and right bound ranged from to inclusively Let s see how to calculate Let be equal to maximum on the subsegment and be equal to minimum on the subsegment Let s suppose that the maximal value of the chosen segment is in the left half the case when the maximal value is in the right half is similar to this one Now let s iterate over the left bound of the segment maintaining a maximal value of numbers in the left half in other words a maximal value on the segment If we iterate over possible s in descending order it is possible to maintain a pointer at all possible right bounds in the right half notice that we want to maintain the greatest such that Now that we know the maximum we know the number of bits equal to that binary representations of maximum and minimum contain It s only left to find the number of right bounds such that has the same number of bits equal to as For every prefix of the right half let s calculate the minimum on it in other words for every such that Notice that we can maintain an array which for every stores the number of right bounds for which the binary representation of prefix minimum has exactly bits equal to The only case left unconsidered is when the minimum is in the left half Let s notice that if we iterate over s in descending order we don t increase the minimum in the left half which means that we can create a pointer for it in the right half maintaining such minimal that It turns out that segments have maximum and minimum in the left half and we know how to find those segments and we just need to check if the binary representations of maximum and minimum of such segments have equal numbers of bits equal to In all other cases we want to calculate the number of right bounds on the segment for which the prefix minimum has the same number of bits equal to as It can be done if we maintain the array for the subsegment If we initially calculate the number of bits equal to for every number then we will get a solution in 
 A permutation of length n is an array of n integers such that every integer from 1 to n appears in it exactly once An element y of permutation p is reachable from element x if x y or p x y or p p x y and so on The of a permutation p is defined as follows firstly we have a permutation p all elements of which are and an empty list l Then we do the following while there is at least one element in p we find the leftmost such element list all elements that are reachable from it mark all of these elements then cyclically shift the list of those elements so that the maximum appears at the first position and add this list of l After all elements are marked l is the result of this decomposition For example if we want to build a decomposition of p 5 4 2 3 1 7 8 6 we do the following initially p 5 4 2 3 1 7 8 6 bold elements are marked l the leftmost unmarked element is 5 5 and 1 are reachable from it so the list we want to shift is 5 1 there is no need to shift it since maximum is already the first element p textbf 5 4 2 3 textbf 1 7 8 6 l 5 1 the leftmost unmarked element is 4 the list of reachable elements is 4 2 3 the maximum is already the first element so there s no need to shift it p textbf 5 textbf 4 textbf 2 textbf 3 textbf 1 7 8 6 l 5 1 4 2 3 the leftmost unmarked element is 7 the list of reachable elements is 7 8 6 we have to shift it so it becomes 8 6 7 p textbf 5 textbf 4 textbf 2 textbf 3 textbf 1 textbf 7 textbf 8 textbf 6 l 5 1 4 2 3 8 6 7 all elements are marked so 5 1 4 2 3 8 6 7 is the result The of a permutation is defined as follows we build the decomposition of this permutation then we sort all lists in decomposition in ascending order of the first elements we don t swap the elements in these lists only the lists themselves then we concatenate the lists into one list which becomes a new permutation For example the of p 5 4 2 3 1 7 8 6 is built as follows the decomposition is 5 1 4 2 3 8 6 7 after sorting the decomposition it becomes 4 2 3 5 1 8 6 7 4 2 3 5 1 8 6 7 is the result of the transformation We call a permutation if the result of its transformation is the same as the permutation itself For example 4 3 1 2 8 5 6 7 is a good permutation and 5 4 2 3 1 7 8 6 is bad since the result of transformation is 4 2 3 5 1 8 6 7 Your task is the following given n and k find the k th lexicographically good permutation of length n ,"['#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n \nconst int N =50;\nint dsu[N];\n \nint get(int v) {\n  if (v == dsu[v]) {\n    return v;\n  } else {\n    return dsu[v] = get(dsu[v]);\n  }\n}\n \nvoid uni(int u, int v) {\n  dsu[get(u)] = get(v);\n}\n \nint main() {\n#ifdef iq\n  freopen(""a.in"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  auto solve = [&] () {\n    int n;\n    ll k;\n    cin >> n >> k;\n    vector <ll> fact(n + 1);\n    fact[0] = 1;\n    ll lim = k + (ll) (1e18);\n    auto mul = [&] (ll a, ll b) {\n      if (a * (long double) b <= lim)\n        return a * b;\n      else\n        return lim;\n    };\n    for (int i = 1; i <= n; i++) {\n      fact[i] = mul(fact[i - 1], i);\n    }\n    vector <ll> decomps(n + 1);\n    vector <ll> values(n + 1);\n    for (int i = 1; i <= n; i++) {\n      if (i == 1) {\n        values[i] = 1;\n      } else {\n        values[i] = fact[i - 2];\n      }\n    }\n    decomps[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 0; j < i; j++) {\n        decomps[i] += mul(decomps[j], values[i - j]);\n        decomps[i] = min(decomps[i], lim);\n      }\n    }\n    k--;\n    if (decomps[n] <= k) {\n      cout << -1 << \'\\n\';\n      return;\n    }\n    auto gen_cyclic = [&] (int len, ll id, int shift) {\n      for (int i = 0; i < len; i++) {\n        dsu[i] = i;\n      }\n      set <int> q;\n      int pths = len - 1;\n      vector <int> ans;\n      for (int i = 0; i < len; i++) {\n        if (i == 0) {\n          q.insert(len - 1);\n          uni(i, len - 1);\n          ans.push_back(len - 1);\n        } else {\n          for (int j = 0; j < len; j++) {\n            if (!q.count(j) && (get(i) != get(j) || i == len - 1)) {\n              int go = pths;\n              if (values[go] <= id) {\n                id -= values[go];\n              } else {\n                pths--;\n                ans.push_back(j);\n                q.insert(j);\n                uni(i, j);\n                break;\n              }\n            }\n          }\n        }\n      }\n      for (int x : ans) {\n        cout << shift + x + 1 << \' \';\n      }\n    };\n    int x = 0;\n    while (x < n) {\n      for (int len = 1; len <= n - x; len++) {\n        ll value = mul(values[len], decomps[n - x - len]);\n        if (value <= k) {\n          k -= value;\n        } else {\n          ll go = k / decomps[n - x - len];\n          gen_cyclic(len, go, x);\n          k %= decomps[n - x - len];\n          x += len;\n          break;\n        }\n      }\n    }\n    cout << \'\\n\';\n  };\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n']","[0, 0, 0, 1, 0]",2700,Let s calculate the number of permutations of length which have a maximum at the position and consist of exactly one cycle Each good permutation can be divided into such blocks so we ll need this value later It is easy to notice that Let s calculate the following dynamic programming the number of good permutations consisting of elements To calculate let s iterate over the maximum element of the first block it determines the length of this block Now let s use the standard method of lexicographic recovery We will iterate over which element to put next it immediately determines the size of the new block and all the elements in it If the number of permutations starting with such block is at least then you need to restore this block entirely and reduce the task to the one without this block Otherwise you need to subtract the number of permutations starting on such block from and proceed to the next option for the block We will also use lexicographic recovery to restore the block You must carefully maintain the current block so that it consists of exactly one cycle To do this you can use DSU or explicitly check for a cycle 
A tennis tournament with participants is running The participants are playing by an olympic system so the winners move on and the losers drop out The tournament takes place in the following way below is the number of the participants of the current round let be the maximal power of the number such that participants compete in the current round and a half of them passes to the next round the other participants pass to the next round directly when only one participant remains the tournament finishes Each match requires bottles of water for each participant and one bottle for the judge Besides towels are given to each participant for the whole tournament Find the number of bottles and towels needed for the tournament Note that it s a tennis tournament so in each match two participants compete one of them will win and the other will lose ,"['#ifdef __GNUC__\n#pragma GCC target(""sse4,avx"")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n  int n, b, p;\n  in >> n >> b >> p;\n  out << (2 * b + 1) * (n - 1) << "" "" << n * p << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}']","[0, 1, 1, 0, 0]",1000,The problem was suggested by unprost Here you can simply model the process Or you can note that after each match some player drops out In total players will drop out So the first answer is Obviously the second answer is solution 1 solution 2 Complexity or depends on the realization 
Phoenix has a string s consisting of lowercase Latin letters He wants to distribute all the letters of his string into k strings a 1 a 2 dots a k such that every letter of s goes to exactly one of the strings a i The strings a i need to be substrings of s Phoenix can distribute letters of s and rearrange the letters within each string a i however he wants For example if s and k 2 Phoenix may distribute the letters of his string in many ways such as and and and and But these ways are invalid and and and empty string a i should be non empty Phoenix wants to distribute the letters of his string s into k strings a 1 a 2 dots a k to the lexicographically maximum string among them i e minimize max a 1 a 2 dots a k Help him find the optimal distribution and print the minimal possible value of max a 1 a 2 dots a k String x is lexicographically less than string y if either x is a prefix of y and x ne y or there exists an index i 1 le i le min x y such that x i y i and for every j 1 le j i x j y j Here x denotes the length of the string x ,"['#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=100010;\nint t,k,n,a[MAXN];\nchar c[MAXN];\nint divc (int a,int b) {\n\tif (a%b==0) {return a/b;}\n\telse {return a/b+1;}\n}\nint main () {\n\tscanf(""%d"",&t);\n\tfor (int ii=1;ii<=t;ii++) {\n\t\tscanf(""%d%d"",&n,&k);\n\t\tscanf(""%s"",c+1);\n\t\tfor (int i=1;i<=n;i++) {a[i]=c[i]-\'a\'+1;}\n\t\tsort(a+1,a+n+1);\n\t\tif (a[1]==a[k]) {\n\t\t\tint flg=0;\n\t\t\tfor (int j=k+1;j<=n;j++) {if (a[j]!=a[k+1]) {flg=1;break;}}\n\t\t\tif (!flg) {\n\t\t\t\tprintf(""%c"",a[k]+\'a\'-1);\n\t\t\t\tfor (int j=1;j<=divc((n-k),k);j++) {printf(""%c"",a[k+1]+\'a\'-1);}\n\t\t\t\tprintf(""\\n"");\n\t\t\t} else {\n\t\t\t\tfor (int j=k;j<=n;j++) {printf(""%c"",a[j]+\'a\'-1);}\n\t\t\t\tprintf(""\\n"");\n\t\t\t}\n\t\t} else {\n\t\t\tprintf(""%c\\n"",a[k]+\'a\'-1);\n\t\t}\n\t}\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",1600,We first try to assign one letter to each string Let s denote the smallest letter in as If there exists at least occurrences of in we will assign as the first letter of each string Otherwise the minimal solution is the th smallest letter in For example if and the rd smallest letter is and that will be the answer Otherwise we consider the letters that are left in If they are all the same letter or there are no letters left because we split the remaining letters as evenly as possible among If not we will show that it is optimal to sort the remaining letters in and append them to arbitrary For example let s suppose after assigning a letter to each that the remaining letters in are We want to assign the s as late as possible so any string that receives a should have some number of s before It makes sense in fact that the string that receives a should receive the s because if not it will be lexicographically larger It can then be shown that all remaining larger letters should be sorted and added to the same string to minimize the answer Time complexity for each test case for sorting 
You are given a coordinate plane and three integers X Y and K Find two line segments AB and CD such that the coordinates of points A B C and D are integers 0 le A x B x C x D x le X and 0 le A y B y C y D y le Y the length of segment AB is at least K the length of segment CD is at least K segments AB and CD are if you draw lines that contain AB and CD they will cross at a right angle Note that it s necessary for segments to intersect Segments are perpendicular as long as the lines they induce are perpendicular ,"[""#include <bits/stdc++.h>using namespace std;\xa0void solve(){\tint X, Y, K;\tcin >> X >> Y >> K;\tint B = min(X, Y);\tcout << 0 << ' ' << 0 << ' ' << B << ' ' << B << '\\n';\tcout << B << ' ' << 0 << ' ' << 0 << ' ' << B << '\\n';}\xa0int main(){\tios_base::sync_with_stdio(false), cin.tie(nullptr);\tint T;\tcin >> T;\twhile(T--) solve();}""]","[1, 1, 0, 0, 0]",900,Let s look at all segments with a fixed angle between them and the X axis Let s take the shortest one with integer coordinates and length at least as Let s say that a bounding box of has width and height It s easy to see that a bounding box of segment will have width at least and height at least since the shortest segment will be just the segment rotated at ninety degrees So in order to fit both segments and both and should be at most But if both and then what is the longest segment that can fit in such a bounding box The answer is to set then the length In such a way we found out that must not exceed but if then we can always take the following two segments and where They are perpendicular fit in the allowed rectangle and have length exactly 
Two soldiers are playing a game At the beginning first of them chooses a positive integer and gives it to the second soldier Then the second one tries to make maximum possible number of rounds Each round consists of choosing a positive integer such that is divisible by and replacing with When becomes equal to and there is no more possible valid moves the game is over and the score of the second soldier is equal to the number of rounds he performed To make the game more interesting first soldier chooses of form for some positive integer and Here by we denote the of that is defined as a product of all positive integers not large than What is the maximum possible score of the second soldier ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,n) for(int i=1;i<=n;i++)\nint n;\nint a[1000005],b[1000005];\nvector<int> x[5000005];\nint c[5000005];\nlong long r[5000005];\nint main(){\n    cin >> n; rep2(i,n) scanf(""%d%d"",&a[i],&b[i]);\n    for(int i=2;i<=5000000;i++){\n    \tif(c[i]) continue; c[i] = 1;\n    \tfor(int j=2;i*j<=5000000;j++){\n    \t\tint x = j*i;\n    \t\twhile(x%i==0){\n    \t\t\tx/=i;\n    \t\t\tc[i*j]++;\n    \t\t}\n    \t}\n    }\n    for(int i=2;i<=5000000;i++) r[i] = r[i-1]+c[i];\n    rep2(i,n) printf(""%lld\\n"",r[a[i]]-r[b[i]]);\n}']","[0, 1, 0, 1, 0]",1700,Firstly we have to note that second soldier should choose only prime numbers If he choose a composite number x that is equal to p q he can choose first p then q and get better score So our task is to find a number of prime factors in factorization of n Now we have to note that factorization of number a b is this same as factorization of numbers b 1 b 2 a 1 a Let s count number of prime factor in factorization of every number from 2 to 5000000 First we use Sieve of Eratosthenes to find a prime diviser of each of these numbers Then we can calculate a number of prime factors in factorization of a using the formula primefactors a primefactors a primediviser a 1 When we know all these numbers we can use a prefix sums and then answer for sum on interval 
Mole is hungry again He found one ant colony consisting of ants ordered in a row Each ant has a strength In order to make his dinner more interesting Mole organizes a version of Hunger Games for the ants He chooses two numbers and and each pair of ants with indices between and inclusively will fight When two ants and fight ant gets one battle point only if divides also ant gets one battle point only if divides After all fights have been finished Mole makes the ranking An ant with battle points obtained is going to be freed only if or in other words only if it took a point in every fight it participated After that Mole eats the rest of the ants Note that there can be many ants freed or even none In order to choose the best sequence Mole gives you segments and asks for each of them how many ants is he going to eat if those ants fight ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int kMaxN = 100000;\nconst int kInf = 0x3f3f3f3f;\nint n, seq[kMaxN];\n\nstruct Info {\n    int g, m, c;\n    Info() {}\n    Info(int _g, int _m, int _c) : g(_g), m(_m), c(_c) {}\n};\n\nint gcd(int a, int b) {\n    return (b ? gcd(b, a % b) : a);\n}\n\nInfo operator+(const Info &a, const Info &b) {\n    Info c;\n    c.g = gcd(a.g, b.g);\n    if (a.m != b.m) {\n        if (a.m < b.m) {\n            c.m = a.m;\n            c.c = a.c;\n        } else {\n            c.m = b.m;\n            c.c = b.c;\n        }\n    } else {\n        c.m = a.m;\n        c.c = a.c + b.c;\n    }\n    return c;\n}\n\nstruct Node {\n    Info acc;\n    Node *son[2];\n    void update() {\n        acc = son[0]->acc + son[1]->acc;\n    }\n} nodes[kMaxN * 2 - 1], *nodeIdx = nodes, *root = NULL;\n\nNode *build(int l, int r) {\n    Node *res = nodeIdx ++;\n    if (l + 1 == r) {\n        res->acc = Info(seq[l], seq[l], 1);\n    } else {\n        int mid = (l + r) >> 1;\n        res->son[0] = build(l, mid);\n        res->son[1] = build(mid, r);\n        res->update();\n    }\n    return res;\n}\n\nInfo askOnRange(int l, int r, Node *pos, int pL, int pR) {\n    if (l >= pR || r <= pL) {\n        return Info(0, kInf, 1);\n    } else if (l <= pL && r >= pR) {\n        return pos->acc;\n    } else {\n        int mid = (pL + pR) >> 1;\n        return askOnRange(l, r, pos->son[0], pL, mid) + askOnRange(l, r, pos->son[1], mid, pR);\n    }\n}\n\nint main() {\n    scanf(""%d"", &n);\n    for (int i = 0; i < n; ++ i) scanf(""%d"", &seq[i]);\n    root = build(0, n);\n    int m;\n    scanf(""%d"", &m);\n    for (int l, r; m --; ) {\n        scanf(""%d%d"", &l, &r);\n        -- l;\n        Info acc = askOnRange(l, r, root, 0, n);\n        if (acc.g == acc.m) {\n            printf(""%d\\n"", r - l - acc.c);\n        } else {\n            printf(""%d\\n"", r - l);\n        }\n    }\n    return 0;\n}\n']","[0, 1, 0, 0, 1]",2100,For each subsequence we must find how many queens we have A value is queen only if is the GCD of Also we must notice that the GCD of can be only the minimum value from So for each query we search in a data structure a segment tree or a RMQ the minimum value and the GCD of and if these two values are equal then we output the answer where is the number of values in the subsequence equal to the GCD and the minimum value The complexity of this solution is where is the maximum value of 
You got a job as a marketer in a pet shop and your current task is to boost sales of cat food One of the strategies is to sell cans of food in packs with discounts Suppose you decided to sell packs with a cans in a pack with a discount and some customer wants to buy x cans of cat food Then he follows a greedy strategy he buys left lfloor frac x a right rfloor packs with a discount then he wants to buy the remaining x bmod a cans one by one But customers are greedy in general so if the customer wants to buy x bmod a cans one by one and it happens that x bmod a ge frac a 2 he decides to buy the whole pack of a cans instead of buying x bmod a cans It makes you as a marketer happy since the customer bought more than he wanted initially You know that each of the customers that come to your shop can buy any number of cans from l to r inclusive Can you choose such size of pack a that each customer buys more cans than they wanted initially ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--) {\n\t\tll x, y;\n\t\tscanf(""%lld%lld"", &x, &y);\n\t\tif (2 * x > y) {\n\t\t\tprintf(""YES\\n"");\n\t\t} else {\n\t\t\tprintf(""NO\\n"");\n\t\t}\n\t}\n\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0]",800,Note that if then exists such that and obviously a customer who wants to buy cans won t buy more than he wants That s why and we can rephrase our task as finding such that The longer the segment is the better and the maximum we can take is As a result we need to check that 
One day decided to play around with arrays and came up with the following problem You are given an array a which consists of n positive integers The array is numerated 1 through n You execute the following procedure You create a new array b which consists of 2n integers where for each 1 le i le n the condition b 2i 1 b 2i a i holds For example for the array a 6 8 2 you can create b 2 4 4 4 1 1 You merge consecutive equal numbers in b For example b 2 4 4 4 1 1 becomes b 2 4 1 Find and print value of b size of b which can be achieved at the end of the procedure It can be shown that under the given constraints there is at least one way to construct b ,"[""/**\n *    author:  tourist\n *    created: 27.09.2020 18:32:17       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    const int inf = (int) 1.01e9;\n    long long L = 1;\n    long long R = inf;\n    set<long long> s;\n    long long sign = 1;\n    long long delta = 0;\n    int ans = 0;\n    for (int x : a) {\n      if (x % 2 == 1) {\n        swap(L, R);\n        L = max(x - L, 1LL);\n        R = min(x - R, x - 1LL);\n        sign *= -1;\n        delta *= -1;\n        delta += x;\n        while (!s.empty()) {\n          long long val = (*s.begin()) * sign + delta;\n          if (val < 1 || val >= x) {\n            s.erase(s.begin());\n          } else {\n            break;\n          }\n        }\n        while (!s.empty()) {\n          auto it = prev(s.end());\n          long long val = (*it) * sign + delta;\n          if (val < 1 || val >= x) {\n            s.erase(it);\n          } else {\n            break;\n          }\n        }\n        if (s.empty() && L > R) {\n          sign = 1;\n          delta = 0;\n          L = 1;\n          R = x - 1;\n        } else {\n          ans += 1;\n        }\n      } else {\n        swap(L, R);\n        L = max(x - L, 1LL);\n        R = min(x - R, x - 1LL);\n        sign *= -1;\n        delta *= -1;\n        delta += x;\n        if ((L <= x / 2 && x / 2 <= R) || s.find((x / 2 - delta) * sign) != s.end()) {\n          ans += 2;\n          s.clear();\n          sign = 1;\n          delta = 0;\n          L = x / 2;\n          R = x / 2;\n        } else {\n          while (!s.empty()) {\n            long long val = (*s.begin()) * sign + delta;\n            if (val < 1 || val >= x) {\n              s.erase(s.begin());\n            } else {\n              break;\n            }\n          }\n          while (!s.empty()) {\n            auto it = prev(s.end());\n            long long val = (*it) * sign + delta;\n            if (val < 1 || val >= x) {\n              s.erase(it);\n            } else {\n              break;\n            }\n          }\n          s.insert((x / 2 - delta) * sign);\n          ans += 1;\n        }\n      }\n    }\n    cout << 2 * n + 1 - ans << '\\n';\n  }\n  return 0;\n}\n""]","[1, 0, 0, 1, 1]",3200,Note that minimizing is the same as maximizing the number of consecutive equal pairs We will focus on the second version Let s forget about constraints and consider the most naive solution with dynamic programming will store the answer if we have already considered and our last element is equal to Let s get rid of our dimension and keep our table by layers Suppose that our current th layer is called next layer is called and is called After carefully analyzing our transitions we have the following observations for any since we always have a transition from our maximum since we can add at most two pairs The case may occur only if is even Moreover will be the only maximum element For some suffix upto we always have a transition from to If is even instead of calculating separately we can calculate it as usual and increase its value by at the end Using everything said above we could replace our naive with the following A variable called the value of minimum of our current layer A set called it keeps all indices such that A variable called it is equal to or depending on the parity of and the value of Basically we want to be able to Erase some elements from the prefix suffix of our set Check if some number is in our set Add a segment of values into out set Rotate all elements in our set by a pivot That is a number should turn into We can efficiently process all queries by maintaining as a simple set of non intersecting segments The rotation operation can be done as follows Suppose we had an integer at the beginning We rotate everything by a pivot becomes We rotate everything by a pivot becomes Following the logic We can just maintain the sign of and a global pivot which is the combination of all our rotation operations Time complexity Space complexity 
Polar bears Menshykov and Uslada from the zoo of St Petersburg and elephant Horace from the zoo of Kiev decided to build a house of cards For that they ve already found a hefty deck of playing cards Let s describe the house they want to make The house consists of some non zero number of floors Each floor consists of a non zero number of rooms and the ceiling A room is two cards that are leaned towards each other The rooms are made in a row each two adjoining rooms share a ceiling made by another card Each floor besides for the lowest one should contain less rooms than the floor below Please note that the house may end by the floor with more than one room and in this case they also must be covered by the ceiling Also the number of rooms on the adjoining floors doesn t have to differ by one the difference may be more While bears are practicing to put cards Horace tries to figure out how many floors their house should consist of The height of the house is the number of floors in it It is possible that you can make a lot of different houses of different heights out of cards It seems that the elephant cannot solve this problem and he asks you to count the number of the distinct heights of the houses that they can make using cards ,"['#include <vector>\n#include <list>\n#include <queue>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <tr1/unordered_set>\n#include <tr1/unordered_map>\n\nusing namespace std;\nusing namespace tr1;\n\nconst int maxn=2e6+5;\n\nlong long n,sum;\n\nint main(){\n    cin>>n;\n    sum=0;\n    int ans=0;\n    for(int i=1;i<maxn;i++){\n        sum+=3LL*i-1;\n        if(sum>n)break;\n        if((n-sum)%3==0)ans++;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n']","[1, 1, 0, 0, 0]",1700,Card house This problem required some maths but just a little bit So in order to start here let s first observe that the number of cards you need to use for a complete floor with rooms equals to Then if you have floors with rooms on the th floor then the total number of cards would be where is the total number of the rooms in the card house This already gives you an important property if you divide on 3 then the remainder of this division should be 0 This means that if you have found some minimum value of floors somehow and you found maximum possible number of floors in the house then within that interval only every third number will be a part of the solution the rest of the numbers will give a non zero remainder in the equation above Now let s think what is the highest house we can build using cards In order to build the highest possible house obviously you need to put as few cards on each floor as you can But we have a restriction that every floor should have less rooms than the floor below This gives us the following strategy to maximize the height of the house we put 1 room on the top floor then 2 rooms on the floor below then 3 rooms on the next floor etc In total then the number of cards we will need equals to This is minimum number of cards we need in order to build a house with floors This gives us a way to calculate the maximum height of the house we can build using cards we just need to find maximum which gives Mathematicians would probably solve the quadratic inequation programmers have two options Check all possible until you hit that upper bound Since grows quadratically with then you will need to check only up to numbers This gives time complexity and fits nicely in the given time limit The second approach would be a binary search Using binary search to find maximum number of the floors would give you time complexity This was the intended originally solution but it was decided to lower the constraints in order to allow sqrt solutions as well Now that you know the maximum number of the floors in the house you might need to correct it a bit because of that remainder thing we discussed above this might make your maximum height one or two floors lower Looking again at the remainder discussion on top we can see that starting from here only every third number will be valid for an answer Now you can either count them brutally back to solution or you can simply calculate them using this formulae integer division That seems to be it just don t forget to use longs all the time in this problem Author s solution 7977863 Authors solution 7977888 
As you probably know Anton goes to school One of the school subjects that Anton studies is Bracketology On the Bracketology lessons students usually learn different sequences that consist of round brackets characters and without quotes On the last lesson Anton learned about the regular simple bracket sequences RSBS A bracket sequence of length is an RSBS if the following conditions are met It is not empty that is The length of the sequence is even First charactes of the sequence are equal to Last charactes of the sequence are equal to For example the sequence is an RSBS but the sequences and are not RSBS Elena Ivanovna Anton s teacher gave him the following task as a homework Given a bracket sequence Find the number of its distinct subsequences such that they are RSBS Note that a subsequence of is a string that can be obtained from by deleting some of its elements Two subsequences are considered distinct if distinct sets of positions are deleted Because the answer can be very big and Anton s teacher doesn t like big numbers she asks Anton to find the answer modulo Anton thought of this task for a very long time but he still doesn t know how to solve it Help Anton to solve this task and write a program that finds the answer for it ,"['#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long LL;\nconst LL md=1000000007LL;\nconst int MX=400111;\nLL fac[MX],facinv[MX],inv[MX];\ninline LL C(LL x,LL y){\n\treturn fac[x]*facinv[y]%md*facinv[x-y]%md;\n}\nvoid ini(){\n\tfac[0]=1LL,facinv[0]=1LL;\n\tinv[1]=1LL;\n\tfor(LL i=2;i<=400000;i++)inv[i]=(md-md/i)*inv[md%i]%md;\n\tfor(LL i=1;i<=400000;i++)fac[i]=fac[i-1]*i%md;\n\tfor(LL i=1;i<=400000;i++)facinv[i]=facinv[i-1]*inv[i]%md;\n}\nchar s[MX];\nint n;LL lc,rc;\nint main(){\n\tini();\n\tscanf(""%s"",s);\n\tn=strlen(s);\n\tfor(int i=0;i<n;i++)if(s[i]==\'(\')lc++;else rc++;\n\tLL tx=0LL,ty=rc,ans=0LL;\n\tfor(LL i=0;i<n;i++){\n\t\tif(!ty)break;\n\t\tif(s[i]==\'(\'){\n\t\t\ttx++;ans=(ans+C(tx+ty-1,ty-1))%md;\n\t\t}else ty--;\n\t}\n\tprintf(""%lld\\n"",ans);\n\treturn 0;\n}\n']","[0, 1, 0, 1, 0]",2300,At first let s simplify the problem let our string consists of characters begins with characters and ends with characters How to find the number of RSBS in such string Let s prove that this number is equal to It s easy to observe that this formula also means the number of ways to match the string with the sequence of zeros and ones of the same length which contains exactly ones Now prove that for every such sequence of zeros and ones we can find an RSBS subsequence How can we do it Let s consider it on the example of the following string Let s include to our subsequence all the opening brackets that match zeros and all the closing brackets that match ones In our example we include brackets number and so we get the subsequence which is an RSBS Why every sequence we got in this way is an RSBS Let the number of ones that match closing brackets is equal to So ones match opening brackets because we have ones as we remember and therefore zeros match opening brackets So the number of opening brackets is equal to the number of closing brackets in our subsequence Also opening brackets appear earlier than closing brackers So such subsequence is always an RSBS and the statement above is proved Now we must understand how to solve the entire problem Let s iterate over an opening bracket that is the last opening bracket in our subsequence Now observe that only opening brackets may come before this bracket and only closing brackets may come after this bracket The rest of the brackets will definitely not appear in the subsequence Let s count the number of opening brackets before the iterated one incluing the iterated one let this number is equal to and also the number of closing brackets after the iterated one let this number is equal to To calculate these numbers we can precalc them for all the positions in using prefix sums Now we have reduced our problem to the already solved because we have opening brackets and then closing brackets But we also have an additional condition we must necessarily take the last opening bracket So the answer is equal to not because on the position with the last opening bracket we must put a zero So we must put ones on positions instead of positions Time complexity is logarithm is to divide by modulo that is necessary to calculate the number of combinations 
Jellyfish has n green apple pieces Each green apple piece weighs 1 text kg Jellyfish wants to divide these green apple pieces among m people Jellyfish has a magic knife Each time Jellyfish can choose one piece of green apple and divide it into two smaller pieces with each piece having half the weight of the original piece Jellyfish wants to know the minimum number of operations needed such that she can divide the green apple pieces such that the total weight of apple pieces received by each person is the same ,"['#include<iostream>\nusing namespace std;\ntypedef long long ll;\nconst int P = 0x3f3f3f3f;\nint _gcd(int a, int b) { if (a < b)swap(a, b); while (b)a %= b, swap(a, b); return a; }\nvoid solve()\n{\n    int n, m; ll ans = 0, bas = 1;\n    cin >> n >> m; n %= m; if (!n) { cout << ""0\\n""; return; }\n    int g = _gcd(n, m), sp = m / g; while (!(sp & 1))sp >>= 1;\n    if (sp != 1) { cout << ""-1\\n""; return; }\n    while (n)g = _gcd(n, m), n /= g, m /= g, bas *= g, ans += bas * (m - 1), n--;\n    cout << ans << ""\\n"";\n}\nint main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    int t = 1; cin >> t;\n    while (t--)solve();\n}']","[1, 1, 0, 0, 0]",1400,TutorialFirstly if we can make the problem transform by giving each person an apple at a time until there are not enough apples We can calculate the mass of apples that each person ends up with as Since it s cut in half every time if is not an integral power of there s no solution Since the number of apple pieces is added to exactly for each cut So we just need to minimize the final number of apple pieces As the problem is transformed is less than and is an integral power of So we can uniquely find a set of positive integers satisfying And this method can be proven to be optimal if we find another multiset satisfying for every element that appears twice or more We can make the answer better by removing two at a time from and adding one to By repeating this process eventually will become We can use to get the answer is Time complexity per test case Memory complexity per test case 
A R C Markland N is a tall building with n floors numbered from 1 to n Between each two adjacent floors in the building there is a staircase connecting them It s lunchtime for our sensei Colin ConneR Neumann Jr and he s planning for a location to enjoy his meal ConneR s office is at floor s of the building On each floor including floor s of course there is a restaurant offering meals However due to renovations being in progress k of the restaurants are currently closed and as a result ConneR can t enjoy his lunch there CooneR wants to reach a restaurant as quickly as possible to save time What is the minimum number of staircases he needs to walk to reach a closest currently open restaurant Please answer him quickly and you might earn his praise and even enjoy the lunch with him in the elegant Neumanns way ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(void) {\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    int ntest;\n    cin >> ntest;\n    while (ntest--) {\n        int n, s, k, x;\n        cin >> n >> s >> k;\n        set <int> ss;\n        for (int i = 1; i <= k; ++i) cin >> x, ss.insert(x);\n        int ans = 0;\n        while (true) {\n            if (s + ans <= n && ss.find(s + ans) == ss.end()) break;\n            if (s - ans >= 1 && ss.find(s - ans) == ss.end()) break;\n            ++ans;\n        }\n        cout << ans << '\\n';\n    }\n    return 0;\n}\n""]","[0, 0, 1, 0, 0]",1100,Since there s only closed restaurants in the worst case we ll only have to walk for staircases only one such case would be and all the restaurants from floor to are closed Therefore a brute force solution is possible try out every distance from to For each determine if either or is within range and not being in the closed list The check of an element being a list or not can be done easily by a built in function in most programming languages for C it would be the function with linear time complexity Of course one would love to check with but for this problem it s an overkill Time complexity 
As a human she can erase history of its entirety As a she can create history out of nothingness Keine has the ability to manipulate history The history of Gensokyo is a string s To fix the chaos caused by Yukari she needs to do the following operations n times for the i th time She chooses a t 2i 1 of s She replaces t 2i 1 with a string t 2i Note that the lengths of strings t 2i 1 and t 2i can be different Note that if t 2i 1 occurs more than once in s of them will be replaced For example let s t 2i 1 and t 2i After the operation s becomes or After n operations Keine got the final string and an operation sequence t of length 2n Just as Keine thinks she has finished Yukari appears again and shuffles the order of t Worse still Keine forgets the initial history Help Keine find the initial history of Gensokyo Recall that a substring is a sequence of consecutive characters of the string For example for string its substrings are and some others But the following strings are not its substring You cannot make hacks in this problem ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nconstexpr int inf = 1e18;\nconstexpr int maxn = 2e5 + 5;\nconstexpr int mod = 998244353;\n\ninline void solve()\n{\n  int n; cin >> n; // the number of operations\n  vector<int> cnt(26);\n  vector<string> s(n * 2 + 1);\n  for (int i = 0; i < n * 2 + 1; i ++)\n  {\n    cin >> s[i];\n    for (char ch : s[i])\n      cnt[ch - 'a'] ^= 1;\n  }\n  for (int i = 0; i < 26; i ++)\n    if (cnt[i])\n      cout << char(i + 'a') << '\\n';\n}\n\nsigned main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int T; cin >> T;\n  while (T --)\n  solve();\n  return 0;\n}""]","[1, 0, 0, 0, 0]",1700,SolutionLet be the unshuffled operation sequence Consider a single letter that has ever appeared in there are letters There are two possible situations is in the initial string No matter is replaced or not will appear in the input data exactly once in replaced strings or in the final string is not in the initial string No matter is replaced or not will appear in the input data exactly twice So the answer is the only letter appearing odd times in the input data The time complexity is 
One day Petya came across an interval of numbers Let be the number of lucky digits of number Find the minimum such that ,"['#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<40)\n\nint lucky(ll x){\n    int ans = 0;\n    while(x > 0){\n        if(x%10 == 4 || x%10 == 7) ans++;\n        x /= 10;\n    }\n    return ans;\n}\n\nmap <pair <ll, int>, int> mp1;\n\nll func1(ll low, int x){\n    int i;\n    ll ans = INF;\n    \n    if(x < 0) return INF;\n    \n    pair <ll, int> st = make_pair(low,x);\n    if(mp1.find(st) != mp1.end()) return mp1[st];\n    \n    if(low <= 3){\n        if(x == 0) return low;\n        ans = 0;\n        REP(i,x) ans = ans * 10 + 4;\n        return mp1[st] = ans;\n    }\n    \n    REP(i,10){\n        if(i < low%10){\n            ll tmp = func1(low/10+1,x-lucky(i));\n            ans = min(ans,tmp*10+i);\n        } else {\n            ll tmp = func1(low/10,x-lucky(i));\n            ans = min(ans,tmp*10+i);\n        }\n    }\n    \n    return mp1[st] = ans;\n}\n\nll func2(ll low, int x, int y){\n    int i;\n    ll ans = INF;\n    \n    if(x < 0 || y < 0) return INF;\n    \n    REP(i,9) if(y - x == lucky(i+1) - lucky(i)){\n        if(i < low%10){\n            ll tmp = func1(low/10+1,x-lucky(i));\n            ans = min(ans,tmp*10+i);\n        } else {\n            ll tmp = func1(low/10,x-lucky(i));\n            ans = min(ans,tmp*10+i);\n        }\n    }\n    \n    return ans;\n}\n\nll func3(ll low, int x, int y){\n    ll ans = INF;\n    \n    int i;\n    for(i=0;;i++){\n        ll tmp = func2(low,x,y);\n        int j;\n        REP(j,i) tmp = min(tmp * 10 + 9, INF);\n        ans = min(ans,tmp);\n        \n        if(low == 0) return ans;\n        low /= 10;\n    }\n}\n\nll func(ll low, ll high){\n    if(high/10 - low/10 >= 2){\n        ll tmp = func(low/10,high/10);\n        return tmp * 10 + low % 10;\n    }\n    \n    ll ans = INF;\n    \n    int i,j,k;\n    \n    REP(i,10){\n        j = i + (int)(high - low);\n        if(j >= 20) continue;\n        \n        int x = lucky(low) - lucky(i);\n        int y = 0;\n        if(j >= 10) y = lucky(high) - lucky(j-10);\n        \n        bool failed = false;\n        for(k=i;k<=j;k++){\n            int tmp1 = lucky(low+k-i);\n            int tmp2 = ((k >= 10) ? (y + lucky(k-10)) : (x + lucky(k)));\n            if(tmp1 != tmp2){\n                failed = true;\n                break;\n            }\n        }\n        if(failed) continue;\n        \n        ll small = (low - i + 10) / 10;\n        if(j >= 10){\n            ll tmp = func3(small,x,y);\n            ans = min(ans,tmp*10+i);\n        } else {\n            ll tmp = func1(small,x);\n            ans = min(ans,tmp*10+i);\n        }\n    }\n    \n    return ans;\n}\n\nint main(void){\n    ll a,d;\n    cin >> a >> d;\n    ll ans = func(a,a+d-1);\n    cout << ans << endl;\n    return 0;\n}\n']","[0, 1, 0, 0, 0]",2700,That is only onw variation of solution there are diffrent other which uses same thinking With constraints for a and b to 107 problem can be solved using KMP algorithm consider a string F 1 F 2 F 3 F 4 F 3 107 We need to find first occurrence after index a of string F a F a 1 F a 2 F a l 1 Complexity of that algorithm is O a l obviously that fails on time and memory Lets try to optimize this algorithm using some facts from Lucky numbers theory Split all number interval on block with sizes 100 0 99 100 199 and so on Introduce a concept class of block Class number of a block equals to F i 100 where i any number from that block There are 8 different block classes There are at most 6 consecutive blocks with same class All that can be seen using brute force Note 1 if l 1000 then Proof consider a string F 100 k F 100 k 1 F 100 k 99 Number of different that strings is equal to number of different classes For example for first class that string looks like this 00001001000000100100000010010000001001001111211211000010010000001001001111211211 00001001000000100100 for second 11112112111111211211111121121111112112112222322322111121121111112112112222322322 11112112111111211211 and so on According to the structure of that strings different block by classes can t intersect there ll be no match Hence any sequence of of consecutive blocks which contain at least two blocks of different classes will match only with the same sequence so shift will be multiple of 100 Since there is no more than 6 consecutive blocks with the same classes if l 1000 then obviously this interval will contain at least two blocks with different classes So problem with l 1000 can be solved using KMP with complexity O a l C where C equals 100 let function that do that is named Solve l r Now we need to solve problem for l 1000 At first let a is minimal number that F a F a F a 1 F a 1 F a l 1 F a l 1 a 100 a 100 that can be done using brute force Then result is the minimum of next numbers r Solve a a l 1 Minimum r for which r r 1000 r a F r F a F r 1 F a 1 F r l 1 F a l 1 Minimum a for which a a a a 1000 and F a F a F a 1 F a 1 F a l 1 F a l 1 That solves the problem of some non 100 multiple shifts but that may be a doubt Consider input interval is in just one block with class C Then probably it is better to go to block with class C 1 for example 397 1 400 1 Actually second point solves that problem because if block with class C 1 is before C and only in that case we will choose C 1 then next block after current have class C 1 To proof this we can use this note which can be proofed using brute forces Note 2 if there is two consecutive block then absolute difference between they classes is not more then 1 Hence if after block C in which input interval is goes block with class C 1 then we will go to block C before C 1 otherwise we will choose it C or C 1 Thus problems solves by accurate analysis all moments Complexity of solution is O A L 100 my solution works 1 5 sec and use 250 mega bytes of memory There are also solution which decompose of blocks with sizes depentding on l that one work faster 
You are given an array a 1 a 2 ldots a n You need to perform q queries of the following two types for every i l le i le r multiply a i by x print varphi prod limits i l r a i taken modulo 10 9 7 where varphi denotes Euler s totient function The Euler s totient function of a positive integer n denoted as varphi n is the number of integers x 1 le x le n such that gcd n x 1 ,"[""#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 400500;\nconst int MOD = 1000000007;\nconst int MAXK = 301;\n\nint t[4 * MAXN];\nint pu[4 * MAXN];\nll mask[4 * MAXN];\nll pumask[4 * MAXN];\n\nint num[MAXN];\n\nint mul(int x, int y) {\n  return (1LL * x * y) % MOD;\n}\n\nint binpow(int x, int n) {\n  int res = 1;\n  for (; n > 0; n /= 2) {\n    if (n & 1) res = mul(res, x);\n    x = mul(x, x);\n  }\n  return res;\n}\n\nll msk[MAXK];\n\nvoid apply(int v, int x, ll msk, int len) {\n  t[v] = mul(t[v], binpow(x, len));\n  pu[v] = mul(pu[v], x);\n  mask[v] |= msk;\n  pumask[v] |= msk;\n}\n\nvoid push(int v, int len) {\n  if (pu[v] == 1 && pumask[v] == 0) {\n    return;\n  }\n  apply(v + v, pu[v], pumask[v], (len + 1) / 2);\n  apply(v + v + 1, pu[v], pumask[v], len / 2);\n  pu[v] = 1;\n  pumask[v] = 0;\n}\n\nvoid update(int v, int l, int r, int x, int tl, int tr) {\n  if (l <= tl && tr <= r) {\n    apply(v, x, msk[x], tr - tl + 1);\n    return;\n  }\n  push(v, tr - tl + 1);\n  int tm = (tl + tr) / 2;\n  if (l <= tm) {\n    update(v + v, l, r, x, tl, tm);\n  }\n  if (r > tm) {\n    update(v + v + 1, l, r, x, tm + 1, tr);\n  }\n  t[v] = mul(t[v + v], t[v + v + 1]);\n  mask[v] = mask[v + v] | mask[v + v + 1];\n}\n\npair<int, ll> get(int v, int l, int r, int tl, int tr) {\n  if (l <= tl && tr <= r) {\n    return pair<int, ll>{t[v], mask[v]};\n  }\n  push(v, tr - tl + 1);\n  int tm = (tl + tr) / 2;\n  if (r <= tm) {\n    return get(v + v, l, r, tl, tm);\n  }\n  if (l > tm) {\n    return get(v + v + 1, l, r, tm + 1, tr);\n  }\n  auto a = get(v + v, l, r, tl, tm);\n  auto b = get(v + v + 1, l, r, tm + 1, tr);\n  return pair<int, ll>{mul(a.first, b.first), a.second | b.second};\n}\n\nint inv[MAXK];\nint pr[MAXK];\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  memset(num , -1, sizeof num);\n  int cnt = 0;\n  for (int i = 2; i <= 300; ++i) {\n    bool ok = true;\n    for (int j = 2; j * j <= i; ++j) {\n      if (i % j == 0) ok = false;\n    }\n    if (!ok) {\n      continue;\n    }\n    num[i] = cnt;\n    pr[cnt++] = i;\n  }\n\n  for (int i = 1; i <= 300; ++i) {\n    for (int j = 2; j <= i; ++j) if (num[j] != -1 && i % j == 0) {\n      msk[i] |= 1LL << num[j];\n    }\n  }\n\n  inv[0] = inv[1] = 1;\n  for (int i = 2; i <= 300; ++i) {\n    inv[i] = mul(inv[MOD % i], MOD - MOD / i);\n  }\n\n  int n, q;\n  cin >> n >> q;\n  for (int i = 0; i < 4 * n; ++i) {\n    t[i] = 1;\n    pu[i] = 1;\n    mask[i] = 0;\n    pumask[i] = 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    int x;\n    cin >> x;\n    update(1, i, i, x, 0, n - 1);\n  }\n\n  for (int i = 0; i < q; ++i) {\n    string s;\n    cin >> s;\n    if (s[0] == 'M') {\n      int l, r, x;\n      cin >> l >> r >> x;\n      --l; --r;\n      update(1, l, r, x, 0, n - 1);\n    } else {\n      int l, r;\n      cin >> l >> r;\n      --l, --r;\n      auto res = get(1, l, r, 0, n - 1);\n      int ans = res.first;\n      for (int j = 0; j < 62; ++j) {\n        if (res.second >> j & 1) {\n          ans = mul(ans, pr[j] - 1);\n          ans = mul(ans, inv[pr[j]]);\n        }\n      }\n      cout << ans << '\\n';\n    }\n  }\n  return 0;\n}""]","[0, 1, 0, 0, 1]",2400,TutorialThere s a few fundamentals about Euler s totient we need to know and provided is a prime number and is a positive integer You can easily prove these equations through the definition of the function itself Euler s totient is a multiplicative function is considered a multiplicative function when means Keep in mind that we can rewrite as of following Let s denote as the set of prime factors of Thus the answer for each query will simply be So for each query we ll need to know the product of the elements and which primes are included in that product There are a few ways to work around with it One of the most effective way is as following Create a product segment tree to maintain the segment products Since only depends on the appearance or non appearance of the primes and the constraints guaranteed us to have at most prime factors we can use bitmasks and an or sum segment tree to maintain this part Also the bitmasks and range products can be maintained in a sqrt decomposition fashion please refer to GreenGrape s solution making each query s complexity to be somewhat around Still this complexity is quite high and surpassed time limit on a pretty thin margin Complexity for initializing segment trees Complexity for each update query Complexity for each return query 
You are given a program you want to execute as a set of tasks organized in a dependency graph The dependency graph is a directed acyclic graph each task can depend on results of one or several other tasks and there are no directed circular dependencies between tasks A task can only be executed if all tasks it depends on have already completed Some of the tasks in the graph can only be executed on a coprocessor and the rest can only be executed on the main processor In one coprocessor call you can send it a set of tasks which can only be executed on it For each task of the set all tasks on which it depends must be either already completed or be included in the set The main processor starts the program execution and gets the results of tasks executed on the coprocessor automatically Find the minimal number of coprocessor calls which are necessary to execute the given program ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace program\n{\n\tconst int MAXN = 100000;\n\tint n, m, tot, Deg[MAXN + 10], E[MAXN + 10];\n\tvector<int> R[MAXN + 10];\n\tqueue<int> Q0, Q1;\n\n\tvoid work()\n\t{\n\t\ttot = 0;\n\t\tscanf(""%d%d"", &n, &m);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tscanf(""%d"", &E[i]);\n\t\tmemset(Deg, 0, sizeof(int) * n);\n\t\twhile(m--)\n\t\t{\n\t\t\tint u, v;\n\t\t\tscanf(""%d%d"", &u, &v);\n\t\t\tR[v].push_back(u);\n\t\t\tDeg[u]++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(!Deg[i])\n\t\t\t{\n\t\t\t\tif(!E[i])\n\t\t\t\t\tQ0.push(i);\n\t\t\t\telse\n\t\t\t\t\tQ1.push(i);\n\t\t\t}\n\t\twhile(!Q0.empty() || !Q1.empty())\n\t\t{\n\t\t\tint f = 0;\n\t\t\twhile(!Q0.empty())\n\t\t\t{\n\t\t\t\tint u = Q0.front();\n\t\t\t\tQ0.pop();\n\t\t\t\tfor(vector<int>::iterator p = R[u].begin(); p != R[u].end(); p++)\n\t\t\t\t{\n\t\t\t\t\tint v = *p;\n\t\t\t\t\tif(!--Deg[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!E[v])\n\t\t\t\t\t\t\tQ0.push(v);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tQ1.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!Q1.empty())\n\t\t\t{\n\t\t\t\tf = 1;\n\t\t\t\tint u = Q1.front();\n\t\t\t\tQ1.pop();\n\t\t\t\tfor(vector<int>::iterator p = R[u].begin(); p != R[u].end(); p++)\n\t\t\t\t{\n\t\t\t\t\tint v = *p;\n\t\t\t\t\tif(!--Deg[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!E[v])\n\t\t\t\t\t\t\tQ0.push(v);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tQ1.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttot += f;\n\t\t}\n\t\tprintf(""%d\\n"", tot);\n\t}\n}\n\nint main()\n{\n\tprogram::work();\n\treturn 0;\n}']","[1, 0, 0, 1, 0]",1900,We want to minimize the number of communications between main processor and the coprocessor Thus we need to always act greedily while there are tasks that can be executed on the main processor right away execute them then switch to the coprocessor and execute all tasks that can be executed there then switch back to the main processor and so on This can be done using breadth first search To run reasonably fast this solution has to be implemented carefully instead of searching for available tasks at each step we want to maintain two queues of available tasks for main processor and coprocessor and add a task to a corresponding queue once all tasks it depends on has been executed Alternatively we can define as the lowest number of coprocessor calls required to execute th task and derive a recurrent formula for If is a task and are its dependencies then clearly for each because must be executed after Moreover if is executed on the main processor and on the coprocessor then executing will require an additional coprocessor call Therefore where if is executed on the coprocessor and on the main processor otherwise Now all can be calculated by recursive traversal of the dependency graph or traversing the tasks in topological order The answer to the problem is 
You are given n sticks numbered from 1 to n The length of the i th stick is a i You need to answer q queries In each query you are given two integers l and r 1 le l r le n r l 1 ge 6 Determine whether it is possible to choose 6 sticks from the sticks numbered l to r to form 2 triangles text text A triangle with side lengths a b and c is called non degenerate if a b c b a c and c a b ,"['/** *    author:  tourist *    created: 28.07.2024 10:54:17**/#include <bits/stdc++.h>\xa0using namespace std;\xa0#ifdef LOCAL#include ""algo/debug.h""#else#define debug(...) 42#endif\xa0int main() {  ios::sync_with_stdio(false);  cin.tie(nullptr);  int n, q;  cin >> n >> q;  vector<int> a(n);  for (int i = 0; i < n; i++) {    cin >> a[i];  }  while (q--) {    int l, r;    cin >> l >> r;    --l;    if (r - l > 200) {      cout << ""YES"" << \'\\n\';      continue;    }    vector<int> b(a.begin() + l, a.begin() + r);    sort(b.begin(), b.end());    int sz = int(b.size());    int L = -1, R = -1;    for (int i = 0; i < sz - 2; i++) {      if (b[i] + b[i + 1] > b[i + 2]) {        if (L == -1) L = i;        R = i;      }    }    if (R - L >= 3) {      cout << ""YES"" << \'\\n\';      continue;    }    bool found = false;    int mn = int(2e9);    for (int i = sz - 4; i >= 2; i--) {      mn = min(mn, b[i + 3] - b[i + 2]);      int me = b[i + 1] - b[i];      if ((b[i - 1] > me && b[i - 2] > mn) || (b[i - 1] > mn && b[i - 2] > me)) {        found = true;        break;      }    }    if (!found) {      for (int i = sz - 4; i >= 2; i--) {        int me = b[i + 2] - b[i];        mn = b[i + 3] - b[i + 1];        if ((b[i - 1] > me && b[i - 2] > mn) || (b[i - 1] > mn && b[i - 2] > me)) {          found = true;          break;        }        me = b[i + 3] - b[i];        mn = b[i + 2] - b[i + 1];        if ((b[i - 1] > me && b[i - 2] > mn) || (b[i - 1] > mn && b[i - 2] > me)) {          found = true;          break;        }      }    }    cout << (found ? ""YES"" : ""NO"") << \'\\n\';  }  return 0;}']","[1, 1, 1, 0, 0]",2200,If there are at least 45 sticks it is guaranteed to form a triangle Proof For any sequence of stick lengths that cannot form a triangle we can replace it with the Fibonacci sequence By replacing the sticks in increasing order the sequence will remain incapable of forming a triangle This implies that the Fibonacci sequence is one of the longest sequences that cannot form a triangle The 45 th Fibonacci number exceeds 109 Therefore having at least 45 sticks ensures that it is possible to form a triangle If there are at least 48 sticks it is guaranteed to form two triangles Proof We can first form the first triangle and remove those sticks The remaining number of sticks is still at least 45 which is sufficient to form the second triangle Therefore only for intervals with fewer than 48 sticks we need to check whether it is possible to form two triangles First we sort the sticks within the interval Then we use the following algorithm to find two triangles Algorithm 1 Enumerate all possible sets of 6 consecutive sticks and check if they can form two triangles Algorithm 2 Identify all possible sets of 3 consecutive sticks that can form a triangle and check if there exist two disjoint sets among them If neither algorithm can find two triangles then it is impossible to form two triangles within the given interval Proof Consider an interval where Algorithm 1 cannot find two triangles Suppose it is indeed possible to form two triangles the six sticks must be non consecutive For any unselected sticks between the chosen sticks if there exists a stick to its left and a stick to its right that belongs to the same triangle we can replace the leftmost stick of this triangle with the unselected stick Continuing this process either the six sticks will become consecutive or the left side will form one triangle and the right side will form another which can be detected by Algorithm 2 
JATC loves Banh mi a Vietnamese food His affection for Banh mi is so much that he always has it for breakfast This morning as usual he buys a Banh mi and decides to enjoy it in a special way First he splits the Banh mi into n parts places them on a row and numbers them from 1 through n For each part i he defines the of the part as x i in 0 1 JATC s going to eat those parts one by one At each step he chooses arbitrary remaining part and eats it Suppose that part is the i th part then his of the Banh mi will increase by x i and the deliciousness of all the remaining parts will also increase by x i The initial enjoyment of JATC is equal to 0 For example suppose the deliciousness of 3 parts are 0 1 0 If JATC eats the second part then his enjoyment will become 1 and the deliciousness of remaining parts will become 1 1 Next if he eats the first part then his enjoyment will become 2 and the remaining parts will become 2 After eating the last part JATC s enjoyment will become 4 However JATC doesn t want to eat all the parts but to save some for later He gives you q queries each of them consisting of two integers l i and r i For each query you have to let him know what is the maximum enjoyment he can get if he eats all the parts with indices in the range l i r i in some order All the queries are independent of each other Since the answer to the query could be very large print it modulo 10 9 7 ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll mod = 1000000007;\n\nint a[100006];\nint pre[100006];\n\nll ppow(ll a,ll n) {\n\tll ret=1,now=a;\n\twhile (n) {\n\t\tif (n&1) {\n\t\t\tret = (ret*now)%mod;\n\t\t}\n\t\tnow = (now*now)%mod;\n\t\tn >>=1;\n\t}\n\treturn ret;\n}\n\nint main () {\n\tios::sync_with_stdio(0); cin.tie(0);\n\tint n,q;\n\tcin >> n >> q;\n\tstring s;\n\tcin >> s;\n\tfor (int i=1;i<=n;++i) {\n\t\tchar c = s[i-1];\n\t\tif (c == '0') a[i] = 0;\n\t\telse a[i] = 1;\n\t\tpre[i] = pre[i-1] + a[i];\n\t}\n\twhile (q--) {\n\t\tint l,r;\n\t\tcin >> l >> r;\n\t\tlong long _1 = pre[r] - pre[l-1],len = r-l+1;\n\t\tcout << ( (ppow(2,_1)-1) + (ppow(2,_1)-1)*(ppow(2,len-_1)-1) )%mod << endl;\n\t}\n}\n""]","[1, 1, 1, 0, 0]",1600,For each part that we choose we need to calculate how many times that element is added to our score You can see that the first element that we choose is added times in our score the second element is added times and so on Therefore we just need to choose all the first and then all the remaining parts The final score is where is the number of and is the number of Complexity 
You are given four integer values a b c and m Check if there exists a string that contains a letters b letters c letters no other letters exactly m pairs of adjacent equal letters exactly m such positions i that the i th letter is equal to the i 1 th one ,"['/**\n *    author:  tourist\n *    created: 20.09.2021 17:36:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int a, b, c, m;\n    cin >> a >> b >> c >> m;\n    int other = a + b + c - max(a, max(b, c));\n    int L = a + b + c - 1 - 2 * other;\n    int R = a - 1 + b - 1 + c - 1;\n    cout << (L <= m && m <= R ? ""YES"" : ""NO"") << \'\\n\';\n  }\n  return 0;\n}\n']","[1, 1, 0, 0, 0]",1100,Let s start with a simple assumption For some fixed values the values of that the answers exist for make up a range So there s the smallest possible number of adjacent equal pairs one can construct and the largest one everything in between exists as well The largest number is simple put all A s then all B s then all C s So this value is The smallest number is trickier Let s instead investigate when it s equal to WLOG assume Imagine the following construction There are letters C which separate blocks of letters A and B There are if you consider the ones to the sides of all letters C but we want the smallest value so we shouldn t consider them such blocks thus it s possible that each block contains no more than one letter A and no more than one letter B So letters A and B will never produce adjacent pairs If there are empty blocks then there are adjacent letters C So the condition to still have no empty blocks is to have at least letters A and B in total If then any extra letter C can only be put adjacent to another letter C thus producing an extra pair at least one extra pair but since we are examining the lower bound we can always do exactly one That means that the lower bound is Now for the proof of the fact that every value in between is also achievable Since we have a construction for let s try modifying it Let s reduce the test to the following way While decrease the count of the letter that appears the most by and decrease by Now build the string for with the reduced values After that put the letters back placing them next to the last occurrence of the same letter there is at least one occurrence of each letter the proof is trivial That increases by and the count of this letter by Thus we ll return to the initial test Overall complexity per testcase 
Given a sequence a 1 a 2 ldots a n find the minimum number of elements to remove from the sequence such that after the removal the sum of every 2 consecutive elements is even ,"['#include <bits/stdc++.h>\n\n#define eb emplace_back\n#define ep emplace\n#define fi first\n#define se second\n#define in read<int>()\n#define lin read<ll>()\n#define rep(i, x, y) for(int i = (x); i <= (y); i++)\n#define per(i, x, y) for(int i = (x); i >= (y); i--)\n\nusing namespace std;\n\nusing ll = long long;\nusing db = double;\nusing pii = pair < int, int >;\nusing vec = vector < int >;\nusing veg = vector < pii >;\n\ntemplate < typename T > T read() {\n\tT x = 0; bool f = 0; char ch = getchar();\n\twhile(!isdigit(ch)) f |= ch == \'-\', ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -x : x;\n}\n\ntemplate < typename T > void chkmax(T &x, const T &y) { x = x > y ? x : y; }\ntemplate < typename T > void chkmin(T &x, const T &y) { x = x < y ? x : y; }\n\nconst int N = 1e6 + 10;\n\nint n, cnt[2];\n\nvoid solve() {\n\tn = in; cnt[0] = cnt[1] = 0;\n\trep(i, 1, n) cnt[in % 2]++;\n\tcout << n - max(cnt[0], cnt[1]) << endl;\n}\n\nint main() {\n#ifdef YJR_2333_TEST\n\tfreopen(""1.in"", ""r"", stdin);\n#endif\n\tfor(int T = in; T; T--) solve(); return 0;\n}\n']","[1, 1, 0, 0, 0]",800,The sum of an odd integer and an even integer is an odd integer So you can t have both even and odd elements in the array for the sum of every two consecutive elements to be even Hence the final array should only contain or elements Hence we will remove either all odd elements or all even elements whichever takes lesser number of operations Therefore the answer is 
There is the following puzzle popular among nuclear physicists A reactor contains a set of atoms of some chemical elements We shall understand the phrase atomic number as the number of this atom s element in the periodic table of the chemical elements You are allowed to take any two different atoms and fuse a new one from them That results in a new atom whose number is equal to the sum of the numbers of original atoms The fusion operation can be performed several times The aim is getting a new pregiven set of atoms The puzzle s difficulty is that it is only allowed to fuse two atoms into one it is not allowed to split an atom into several atoms You are suggested to try to solve the puzzle ,"['#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <map>\nusing namespace std;\n\npair< int, int > dp[20][131073];\nmap< string, int > atom;\nint sum[131073];\n\nmain(){\n\tatom[""H""] = 1;\n\tatom[""He""] = 2;\n\tatom[""Li""] = 3;\n\tatom[""Be""] = 4;\n\tatom[""B""] = 5;\n\tatom[""C""] = 6;\n\tatom[""N""] = 7;\n\tatom[""O""] = 8;\n\tatom[""F""] = 9;\n\tatom[""Ne""] = 10;\n\tatom[""Na""] = 11;\n\tatom[""Mg""] = 12;\n\tatom[""Al""] = 13;\n\tatom[""Si""] = 14;\n\tatom[""P""] = 15;\n\tatom[""S""] = 16;\n\tatom[""Cl""] = 17;\n\tatom[""Ar""] = 18;\n\tatom[""K""] = 19;\n\tatom[""Ca""] = 20;\n\tatom[""Sc""] = 21;\n\tatom[""Ti""] = 22;\n\tatom[""V""] = 23;\n\tatom[""Cr""] = 24;\n\tatom[""Mn""] = 25;\n\tatom[""Fe""] = 26;\n\tatom[""Co""] = 27;\n\tatom[""Ni""] = 28;\n\tatom[""Cu""] = 29;\n\tatom[""Zn""] = 30;\n\tatom[""Ga""] = 31;\n\tatom[""Ge""] = 32;\n\tatom[""As""] = 33;\n\tatom[""Se""] = 34;\n\tatom[""Br""] = 35;\n\tatom[""Kr""] = 36;\n\tatom[""Rb""] = 37;\n\tatom[""Sr""] = 38;\n\tatom[""Y""] = 39;\n\tatom[""Zr""] = 40;\n\tatom[""Nb""] = 41;\n\tatom[""Mo""] = 42;\n\tatom[""Tc""] = 43;\n\tatom[""Ru""] = 44;\n\tatom[""Rh""] = 45;\n\tatom[""Pd""] = 46;\n\tatom[""Ag""] = 47;\n\tatom[""Cd""] = 48;\n\tatom[""In""] = 49;\n\tatom[""Sn""] = 50;\n\tatom[""Sb""] = 51;\n\tatom[""Te""] = 52;\n\tatom[""I""] = 53;\n\tatom[""Xe""] = 54;\n\tatom[""Cs""] = 55;\n\tatom[""Ba""] = 56;\n\tatom[""Lu""] = 71;\n\tatom[""Hf""] = 72;\n\tatom[""Ta""] = 73;\n\tatom[""W""] = 74;\n\tatom[""Re""] = 75;\n\tatom[""Os""] = 76;\n\tatom[""Ir""] = 77;\n\tatom[""Pt""] = 78;\n\tatom[""Au""] = 79;\n\tatom[""Hg""] = 80;\n\tatom[""Tl""] = 81;\n\tatom[""Pb""] = 82;\n\tatom[""Bi""] = 83;\n\tatom[""Po""] = 84;\n\tatom[""At""] = 85;\n\tatom[""Rn""] = 86;\n\tatom[""Fr""] = 87;\n\tatom[""Ra""] = 88;\n\tatom[""Lr""] = 103;\n\tatom[""Rf""] = 104;\n\tatom[""Db""] = 105;\n\tatom[""Sg""] = 106;\n\tatom[""Bh""] = 107;\n\tatom[""Hs""] = 108;\n\tatom[""Mt""] = 109;\n\tatom[""Ds""] = 110;\n\tatom[""Rg""] = 111;\n\tatom[""Cn""] = 112;\n\tatom[""Uut""] = 113;\n\tatom[""Uuq""] = 114;\n\tatom[""Uup""] = 115;\n\tatom[""Uuh""] = 116;\n\tatom[""Uus""] = 117;\n\tatom[""Uuo""] = 118;\n\tatom[""La""] = 57;\n\tatom[""Ce""] = 58;\n\tatom[""Pr""] = 59;\n\tatom[""Nd""] = 60;\n\tatom[""Pm""] = 61;\n\tatom[""Sm""] = 62;\n\tatom[""Eu""] = 63;\n\tatom[""Gd""] = 64;\n\tatom[""Tb""] = 65;\n\tatom[""Dy""] = 66;\n\tatom[""Ho""] = 67;\n\tatom[""Er""] = 68;\n\tatom[""Tm""] = 69;\n\tatom[""Yb""] = 70;\n\tatom[""Ac""] = 89;\n\tatom[""Th""] = 90;\n\tatom[""Pa""] = 91;\n\tatom[""U""] = 92;\n\tatom[""Np""] = 93;\n\tatom[""Pu""] = 94;\n\tatom[""Am""] = 95;\n\tatom[""Cm""] = 96;\n\tatom[""Bk""] = 97;\n\tatom[""Cf""] = 98;\n\tatom[""Es""] = 99;\n\tatom[""Fm""] = 100;\n\tatom[""Md""] = 101;\n\tatom[""No""] = 102;\n\t\n\tint out, left;\n\tint i, j, n, m;\n\tint s, a[20];\n\tstring readin;\n\tstring b[20], c[20];\n\t\n\tscanf ( ""%d %d"", &n, &m );\n\tfor ( i = 0; i < n; i ++ ){\n\t\tcin >> readin;\n\t\tb[i] = readin;\n\t\ta[i] = atom[ readin ];\n\t}\n\tsum[0] = 0;\n\tfor ( i = 0; i < n; i ++ ){\n\t\ts = ( 1 << i );\n\t\tfor ( j = 0; j < s; j ++ )\n\t\t\tsum[ s + j ] = sum[j] + a[i];\n\t}\n\t\n\tmemset ( dp, 0, sizeof ( dp ) );\n\tdp[m][0] = make_pair( 1, 0 );\n\tfor ( i = 0; i < m; i ++ ){\n\t\tcin >> readin;\n\t\tc[i] = readin;\n\t\ta[i] = atom[ readin ];\n\t}\n\twhile( m -- )\n\t\tfor ( i = ( 1 << n ) - 1; i >= 0; i -- )\n\t\t\tif ( dp[ m + 1 ][i].first == 1 ){\n\t\t\t\ts = ( 1 << n ) - 1 - i;\n\t\t\t\tfor ( j = s; j > 0; j = ( j - 1 ) & s )\n\t\t\t\t\tif ( sum[j] == a[m] )\n\t\t\t\t\t\tdp[m][ i + j ] = make_pair( 1, j );\n\t\t\t}\n\tm = 0;\n\tif ( dp[0][ ( 1 << n ) - 1 ].first == 1 ){\n\t\tprintf( ""YES\\n"" );\n\t\tleft = ( 1 << n ) - 1;\n\t\twhile( left ){\n\t\t\tout = dp[m][left].second;\n\t\t\tfor ( i = 0; i < n; i ++ )\n\t\t\t\tif ( out & ( 1 << i ) ){\n\t\t\t\t\tprintf( ""%s"", b[i].c_str() );\n\t\t\t\t\tout -= ( 1 << i );\n\t\t\t\t\tif ( out )\n\t\t\t\t\t\tprintf( ""+"");\n\t\t\t\t}\n\t\t\tprintf( ""->%s\\n"", c[m].c_str() );\n\t\t\tleft -= dp[m][left].second;\n\t\t\tm ++;\n\t\t}\n\t}\n\telse\n\t\tprintf( ""NO\\n"" );\n\treturn 0;\n}\n']","[0, 0, 0, 1, 0]",2200,At first you can use some search engine for find periodic table in some printable form Next use copy paste one or several times and format it by deleting all excess It is mechanical work for no more than 5 minutes Also some parser may be written Note than author s solution does not mean write 100 symbols by hand from a picture Next build some functions which transform symbols into numbers and vice versa So we have some set of numbers We need summarize some from them and get some another set of numbers We will use dymanic programming over subsets Compute the first dp dp1 mask sum For each subset calculate sum of numbers of all atoms in this subset It can be done in O 2nn Now compute the second dp dp2 mask length The length is a length of some prefix of result sequence of atoms which can be obtained by subset mask If length 1 it means that it is impossible to get any prefix from this subset The second dp we can calculate in O 3n Iterate over all masks and if dp2 mask 1 iterate all its subsets of remained atoms invert mask and get all its submasks If some subset has sum of numbers which equals number of dp2 1 th atom from result set recalculate dp2 mask XOR submask dp2 mask 1 At end if dp2 2n 1 k there are solution 
You are given an array of integers a 1 a 2 ldots a n as well as a binary string dagger s consisting of n characters Augustin is a big fan of data structures Therefore he asked you to implement a data structure that can answer q queries There are two types of queries 1 l r 1 le l le r le n replace each character s i for l le i le r with its opposite That is replace all texttt 0 with texttt 1 and all texttt 1 with texttt 0 2 g g in 0 1 calculate the value of the bitwise XOR of the numbers a i for all indices i such that s i g Note that the operatorname XOR of an empty set of numbers is considered to be equal to 0 Please help Augustin to answer all the queries For example if n 4 a 1 2 3 6 s texttt 1001 consider the following series of queries 2 0 we are interested in the indices i for which s i tt 0 since s tt 1001 these are the indices 2 and 3 so the answer to the query will be a 2 oplus a 3 2 oplus 3 1 1 1 3 we need to replace the characters s 1 s 2 s 3 with their opposites so before the query s tt 1001 and after the query s tt 0111 2 1 we are interested in the indices i for which s i tt 1 since s tt 0111 these are the indices 2 3 and 4 so the answer to the query will be a 2 oplus a 3 oplus a 4 2 oplus 3 oplus 6 7 1 2 4 s tt 0111 to s tt 0000 2 1 s tt 0000 there are no indices with s i tt 1 so since the operatorname XOR of an empty set of numbers is considered to be equal to 0 the answer to this query is 0 dagger A binary string is a string containing only characters texttt 0 or texttt 1 ,"[""#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define vll vector<ll>\n#define vvll vector<vll>\n\n#define pll pair<ll,ll>\n\nstruct SEG {\n    vector<pll> arr;\n    vector<bool> tswap;\n\n    void make(ll n) {\n        arr.resize(4*n);\n        tswap.resize(4*n);\n    }\n\n    void pull(ll v) {\n        arr[v] = arr[v*2];\n        arr[v].first ^= arr[v*2+1].first;\n        arr[v].second ^= arr[v*2+1].second;\n    }\n\n    void dswap(ll v) {\n        tswap[v] = !tswap[v];\n        swap(arr[v].first, arr[v].second);\n    }\n\n    void push(ll v) {\n        if (tswap[v]) {\n            dswap(v*2);\n            dswap(v*2+1);\n            tswap[v] = 0;\n        }\n    }\n\n    void set(ll v, ll tl, ll tr, ll ind, pll val) {\n        if (tl == tr) {\n            arr[v] = val;\n            return;\n        }\n        ll tm = (tl + tr) / 2;\n        if (ind <= tm)\n            set(v*2, tl, tm, ind, val);\n        else set(v*2+1, tm+1, tr, ind, val);\n        pull(v);\n    }\n\n    void rswap(ll v, ll tl, ll tr, ll l, ll r) {\n        if (l > r) return;\n        if (tl == l && tr == r) {\n            dswap(v);\n            return;\n        }\n        push(v);\n        ll tm = (tl + tr) / 2;\n        rswap(v*2, tl, tm, l, min(r, tm));\n        rswap(v*2+1, tm+1, tr, max(l,tm+1), r);\n        pull(v);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--) {\n        ll n;\n        cin >> n;\n        SEG seg;\n        seg.make(n);\n        for (ll i = 0; i < n; i++) {\n            ll v;\n            cin >> v;\n            seg.set(1, 0, n-1, i, {v, 0});\n        }\n        for (ll i = 0; i < n; i++) {\n            char c;\n            cin >> c;\n            if (c == '1') seg.rswap(1, 0, n-1, i, i);\n        }\n        ll q;\n        cin >> q;\n        while (q--) {\n            ll t;\n            cin >> t;\n            if (t == 1) {\n                ll l, r;\n                cin >> l >> r;\n                seg.rswap(1, 0, n-1, l-1, r-1);\n            } else {\n                ll g;\n                cin >> g;\n                if (g == 0) {\n                    cout << seg.arr[1].first << ' ';\n                } else {\n                    cout << seg.arr[1].second << ' ';\n                }\n            }\n        }\n        cout << '\\n';\n    }\n}""]","[0, 0, 0, 1, 1]",1500,Of course this problem has solutions that use data structures For example you can use a segment tree with range updates to solve it in time or you can use a square root decomposition to solve it in time However of course we do not expect participants in Div3 to have knowledge of these advanced data structures so there is a simpler solution We will store 2 variables which represent the XOR of all numbers from group and group respectively When answering a query of type 2 we will simply output either or Now we need to understand how to update and after receiving a query of type 1 Let s first solve a simplified version suppose that in type 1 queries only a single character of the string is inverted i e in all type 1 queries Let s see how and change after this query If was and became then the number will be removed from group So we need to invert XOR from Since XOR is its own inverse operation we can do this with And in we need to add the number since now And we can do this with The same thing happens if was This is the key observation when we invert and change in the same way regardless of whether this inversion was from to or from to Therefore to update and after a query of type 1 with parameters we need to do this and the same for To quickly find the XOR value on a subsegment of the array we can use a prefix XOR array If then 
You ve got an array consisting of integers The array elements are indexed from 1 to Let s determine a two step operation like that First we build by the array an array of partial sums consisting of elements Element number of array equals The operation means that we take the remainder of the division of number by number Then we write the contents of the array to the array Element number of the array becomes the th element of the array You task is to find array after exactly described operations are applied ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nint c[2010];\nconst int mod=(int)1e9+7;\ninline int add(int a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n    return a;\n}\ninline int mul(int a,int b){\n    return ((long long)a*(long long)b)%mod;\n}\nint in[2010];\ninline int rev(long long a,long long b){\n    if(a==1)return 1;\n    return (((1-rev(b%a,a)*b)/a)%b+b)%b;\n}\nint out[2010];\nint main(){\n    int n,k,i,j;\n    scanf(""%d%d"",&n,&k);\n    for(i=0;i<n;i++)scanf(""%d"",&in[i]);\n    if(k==0){\n        for(i=0;i<n;i++)out[i]=in[i];\n    }else{\n        k--;\n        c[0]=1;\n        for(i=1;i<n;i++){\n            c[i]=mul(mul(c[i-1],add(k,i)),rev(i,mod));\n        }\n        for(i=0;i<n;i++){\n            out[i]=0;\n            for(j=0;j<=i;j++)out[i]=add(out[i],mul(in[j],c[i-j]));\n        }\n    }\n    for(i=0;i<n;i++){\n        printf(""%d%c"",out[i],(i==n-1?\'\\n\':\' \'));\n    }\n\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","[0, 1, 0, 0, 0]",1900,You were given an array a in this problem You could replace a by the array of its partial sums by one step You had to find the array after k such steps All the calculations were modulo P 109 7 Write partial sums in following way where Bi j 1 if i j and Bi j 0 if i j for each 1 i j n We can represent a and s as vector columns therefore one step corresponds to multiplying matrix B and vector column a Then the array a after k steps is equal to Bka We can raise a matrix to a power for It is not bad but not fast enough We can notice that i e the elements of the matrix Bk on diagonals parallel to the main are the equal It is easy to prove this fact using mathematical induction You may prove it by yourself Then we can determine the matrix by an array of numbers equal to the elements of the first column The elements of the first column of the product BkBl are equal It is a straight consequence of formula of matrix product The computing of one element requires O n time there are n elements therefore we can multiply matri s in O n2 time Then we can solve the problem in time and this solution fits the consrtaints This problem can be solved faster We can assure that Let this formula be correct for some k Prove that it is correct for k 1 either Using the formula of product we get Using the formula Cnk n k n k we can obtain so we can find all the coefficients b if we can divide modulo P Therefore it is significant that P is prime Inverse x modulo P is equal to according to the Fermat little theorem Therefore we get O n2 solution 
You re given an array a of length n You can perform the following operations on it choose an index i 1 le i le n an integer x 0 le x le 10 6 and replace a j with a j x for all 1 le j le i which means add x to all the elements in the prefix ending at i choose an index i 1 le i le n an integer x 1 le x le 10 6 and replace a j with a j ,"['#include <bits/stdc++.h>\nusing namespace std;\n\n#define _ << "" _ "" <<\n#define TRACE(x) cout << #x << "" = "" << x << endl\n\ntypedef long long ll;\n\n\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    ll n, a[2010];\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n\n    cout << n + 1 << ""\\n"";\n\n    for (int i = n - 1; i >= 0; i--) {\n        ll b = (ll)i - a[i] % n + n;\n        cout << ""1 "" << i + 1 << "" "" << b << ""\\n"";\n        for (int j = 0; j < i; j++) a[j] += b;\n    }\n\n    cout << ""2 "" << n << "" "" << n;\n\n    return 0;\n}\n\n']","[1, 1, 0, 0, 0]",1400,First solution n adds and 1 mod First let s make ai x n i for some x Then let s mod the whole array with n making ai i If the add update changed one index we can just add i n ai n to index i The problem is if we make ai x n i then update an index j i ai will be ruined Just start from the back of the array 
Mehrdad wants to invite some Hoses to the palace for a dancing party Each Hos has some weight and some beauty Also each Hos may have some friends Hoses are divided in some friendship groups Two Hoses and are in the same friendship group if and only if there is a sequence of Hoses such that and are friends for each and and Arpa allowed to use the amphitheater of palace to Mehrdad for this party Arpa s amphitheater can hold at most weight on it Mehrdad is so greedy that he wants to invite some Hoses such that sum of their weights is not greater than and sum of their beauties is as large as possible Along with that from each friendship group he can either invite all Hoses or no more than one Otherwise some Hoses will be hurt Find for Mehrdad the maximum possible total beauty of Hoses he can invite so that no one gets hurt and the total weight doesn t exceed ,"['#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=1010;\nint n,m,v,w[N],b[N],f[N],u,vv;\nint dp[N],pd[N];\nint find(int x) { return f[x]==x?x:f[x]=find(f[x]); }\nint main() {\n\tscanf(""%d%d%d"",&n,&m,&v);\n\trep(i,1,n+1) scanf(""%d"",w+i);\n\trep(i,1,n+1) scanf(""%d"",b+i);\n\trep(i,1,n+1) f[i]=i;\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&vv);\n\t\tf[find(u)]=find(vv);\n\t}\n\trep(i,1,n+1) if (find(i)==i) {\n\t\tVI itm; int sw=0,sb=0;\n\t\trep(j,1,n+1) if (find(j)==i) itm.pb(j),sw+=w[j],sb+=b[j];\n\t\trep(j,0,v+1) pd[j]=dp[j];\n\t\tfor (auto p:itm) {\n//\t\t\tprintf(""%d %d\\n"",w[p],b[p]);\n\t\t\trep(j,w[p],v+1) dp[j]=max(dp[j],pd[j-w[p]]+b[p]);\n\t\t}\n\t\trep(j,sw,v+1) dp[j]=max(dp[j],pd[j-sw]+sb);\n//\t\tprintf(""%d %d\\n"",sw,sb);\n//\t\tputs("""");\n//\t\tprintf(""%d\\n"",i);\n\t}\n\tprintf(""%d\\n"",dp[v]);\n}\n']","[0, 0, 0, 1, 0]",1600,It s a simple knapsack problem Let s solve this version of knapsack problem first we have sets of items each item has value and weight find the maximum value we can earn if we can choose at most one item from each set and the sum of the chosen items must be less than or equal to Let be the max value we can earn if the sum of weights of chosen items is less than or equal to Now iterate on sets one by one and update as follows for each item and for each weight Run dfs and find groups at first The problem is same with above problem each group is some set in above problem just add the whole group as an item to the set that related to this group Time complexity 
You are given a tree consisting of n vertices There is an integer written on each vertex the i th vertex has integer a i written on it You have to process q queries The i th query consists of three integers x i y i and k i For this query you have to answer if it is possible to choose a set of vertices v 1 v 2 dots v m possibly empty such that every vertex v j is on the simple path between x i and y i endpoints can be used as well a v 1 oplus a v 2 oplus dots oplus a v m k i where oplus denotes the bitwise XOR operator ,"['#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <forward_list>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <optional>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\nusing lint = long long;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate <typename T> bool chmax(T &m, const T q) { return m < q ? (m = q, true) : false; }\ntemplate <typename T> bool chmin(T &m, const T q) { return m > q ? (m = q, true) : false; }\nconst std::vector<std::pair<int, int>> grid_dxs{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nint floor_lg(long long x) { return x <= 0 ? -1 : 63 - __builtin_clzll(x); }\ntemplate <class T1, class T2> T1 floor_div(T1 num, T2 den) { return (num > 0 ? num / den : -((-num + den - 1) / den)); }\ntemplate <class T1, class T2> std::pair<T1, T2> operator+(const std::pair<T1, T2> &l, const std::pair<T1, T2> &r) { return std::make_pair(l.first + r.first, l.second + r.second); }\ntemplate <class T1, class T2> std::pair<T1, T2> operator-(const std::pair<T1, T2> &l, const std::pair<T1, T2> &r) { return std::make_pair(l.first - r.first, l.second - r.second); }\ntemplate <class T> std::vector<T> sort_unique(std::vector<T> vec) { sort(vec.begin(), vec.end()), vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec; }\ntemplate <class T> int arglb(const std::vector<T> &v, const T &x) { return std::distance(v.begin(), std::lower_bound(v.begin(), v.end(), x)); }\ntemplate <class T> int argub(const std::vector<T> &v, const T &x) { return std::distance(v.begin(), std::upper_bound(v.begin(), v.end(), x)); }\ntemplate <class IStream, class T> IStream &operator>>(IStream &is, std::vector<T> &vec) { for (auto &v : vec) is >> v; return is; }\n\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::vector<T> &vec);\ntemplate <class OStream, class T, size_t sz> OStream &operator<<(OStream &os, const std::array<T, sz> &arr);\ntemplate <class OStream, class T, class TH> OStream &operator<<(OStream &os, const std::unordered_set<T, TH> &vec);\ntemplate <class OStream, class T, class U> OStream &operator<<(OStream &os, const pair<T, U> &pa);\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::deque<T> &vec);\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::set<T> &vec);\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::multiset<T> &vec);\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::unordered_multiset<T> &vec);\ntemplate <class OStream, class T, class U> OStream &operator<<(OStream &os, const std::pair<T, U> &pa);\ntemplate <class OStream, class TK, class TV> OStream &operator<<(OStream &os, const std::map<TK, TV> &mp);\ntemplate <class OStream, class TK, class TV, class TH> OStream &operator<<(OStream &os, const std::unordered_map<TK, TV, TH> &mp);\ntemplate <class OStream, class... T> OStream &operator<<(OStream &os, const std::tuple<T...> &tpl);\n\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::vector<T> &vec) { os << \'[\'; for (auto v : vec) os << v << \',\'; os << \']\'; return os; }\ntemplate <class OStream, class T, size_t sz> OStream &operator<<(OStream &os, const std::array<T, sz> &arr) { os << \'[\'; for (auto v : arr) os << v << \',\'; os << \']\'; return os; }\ntemplate <class... T> std::istream &operator>>(std::istream &is, std::tuple<T...> &tpl) { std::apply([&is](auto &&... args) { ((is >> args), ...);}, tpl); return is; }\ntemplate <class OStream, class... T> OStream &operator<<(OStream &os, const std::tuple<T...> &tpl) { os << \'(\'; std::apply([&os](auto &&... args) { ((os << args << \',\'), ...);}, tpl); return os << \')\'; }\ntemplate <class OStream, class T, class TH> OStream &operator<<(OStream &os, const std::unordered_set<T, TH> &vec) { os << \'{\'; for (auto v : vec) os << v << \',\'; os << \'}\'; return os; }\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::deque<T> &vec) { os << ""deq[""; for (auto v : vec) os << v << \',\'; os << \']\'; return os; }\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::set<T> &vec) { os << \'{\'; for (auto v : vec) os << v << \',\'; os << \'}\'; return os; }\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::multiset<T> &vec) { os << \'{\'; for (auto v : vec) os << v << \',\'; os << \'}\'; return os; }\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::unordered_multiset<T> &vec) { os << \'{\'; for (auto v : vec) os << v << \',\'; os << \'}\'; return os; }\ntemplate <class OStream, class T, class U> OStream &operator<<(OStream &os, const std::pair<T, U> &pa) { return os << \'(\' << pa.first << \',\' << pa.second << \')\'; }\ntemplate <class OStream, class TK, class TV> OStream &operator<<(OStream &os, const std::map<TK, TV> &mp) { os << \'{\'; for (auto v : mp) os << v.first << ""=>"" << v.second << \',\'; os << \'}\'; return os; }\ntemplate <class OStream, class TK, class TV, class TH> OStream &operator<<(OStream &os, const std::unordered_map<TK, TV, TH> &mp) { os << \'{\'; for (auto v : mp) os << v.first << ""=>"" << v.second << \',\'; os << \'}\'; return os; }\n#ifdef HITONANODE_LOCAL\nconst string COLOR_RESET = ""\\033[0m"", BRIGHT_GREEN = ""\\033[1;32m"", BRIGHT_RED = ""\\033[1;31m"", BRIGHT_CYAN = ""\\033[1;36m"", NORMAL_CROSSED = ""\\033[0;9;37m"", RED_BACKGROUND = ""\\033[1;41m"", NORMAL_FAINT = ""\\033[0;2m"";\n#define dbg(x) std::cerr << BRIGHT_CYAN << #x << COLOR_RESET << "" = "" << (x) << NORMAL_FAINT << "" (L"" << __LINE__ << "") "" << __FILE__ << COLOR_RESET << std::endl\n#define dbgif(cond, x) ((cond) ? std::cerr << BRIGHT_CYAN << #x << COLOR_RESET << "" = "" << (x) << NORMAL_FAINT << "" (L"" << __LINE__ << "") "" << __FILE__ << COLOR_RESET << std::endl : std::cerr)\n#else\n#define dbg(x) ((void)0)\n#define dbgif(cond, x) ((void)0)\n#endif\n\n#include <algorithm>\n#include <cassert>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <vector>\n\n// Heavy-Light Decomposition of trees\n// Based on http://beet-aizu.hatenablog.com/entry/2017/12/12/235950\nstruct HeavyLightDecomposition {\n    int V;\n    int k;\n    int nb_heavy_path;\n    std::vector<std::vector<int>> e;\n    std::vector<int> par;         // par[i] = parent of vertex i (Default: -1)\n    std::vector<int> depth;       // depth[i] = distance between root and vertex i\n    std::vector<int> subtree_sz;  // subtree_sz[i] = size of subtree whose root is i\n    std::vector<int> heavy_child; // heavy_child[i] = child of vertex i on heavy path (Default: -1)\n    std::vector<int> tree_id;     // tree_id[i] = id of tree vertex i belongs to\n    std::vector<int> aligned_id,\n        aligned_id_inv;    // aligned_id[i] =  aligned id for vertex i (consecutive on heavy edges)\n    std::vector<int> head; // head[i] = id of vertex on heavy path of vertex i, nearest to root\n    std::vector<int> head_ids;      // consist of head vertex id\'s\n    std::vector<int> heavy_path_id; // heavy_path_id[i] = heavy_path_id for vertex [i]\n\n    HeavyLightDecomposition(int sz = 0)\n        : V(sz), k(0), nb_heavy_path(0), e(sz), par(sz), depth(sz), subtree_sz(sz), heavy_child(sz),\n          tree_id(sz, -1), aligned_id(sz), aligned_id_inv(sz), head(sz), heavy_path_id(sz, -1) {}\n    void add_edge(int u, int v) {\n        e[u].emplace_back(v);\n        e[v].emplace_back(u);\n    }\n\n    void _build_dfs(int root) {\n        std::stack<std::pair<int, int>> st;\n        par[root] = -1;\n        depth[root] = 0;\n        st.emplace(root, 0);\n        while (!st.empty()) {\n            int now = st.top().first;\n            int &i = st.top().second;\n            if (i < (int)e[now].size()) {\n                int nxt = e[now][i++];\n                if (nxt == par[now]) continue;\n                par[nxt] = now;\n                depth[nxt] = depth[now] + 1;\n                st.emplace(nxt, 0);\n            } else {\n                st.pop();\n                int max_sub_sz = 0;\n                subtree_sz[now] = 1;\n                heavy_child[now] = -1;\n                for (auto nxt : e[now]) {\n                    if (nxt == par[now]) continue;\n                    subtree_sz[now] += subtree_sz[nxt];\n                    if (max_sub_sz < subtree_sz[nxt])\n                        max_sub_sz = subtree_sz[nxt], heavy_child[now] = nxt;\n                }\n            }\n        }\n    }\n\n    void _build_bfs(int root, int tree_id_now) {\n        std::queue<int> q({root});\n        while (!q.empty()) {\n            int h = q.front();\n            q.pop();\n            head_ids.emplace_back(h);\n            for (int now = h; now != -1; now = heavy_child[now]) {\n                tree_id[now] = tree_id_now;\n                aligned_id[now] = k++;\n                aligned_id_inv[aligned_id[now]] = now;\n                heavy_path_id[now] = nb_heavy_path;\n                head[now] = h;\n                for (int nxt : e[now])\n                    if (nxt != par[now] and nxt != heavy_child[now]) q.push(nxt);\n            }\n            nb_heavy_path++;\n        }\n    }\n\n    void build(std::vector<int> roots = {0}) {\n        int tree_id_now = 0;\n        for (auto r : roots) _build_dfs(r), _build_bfs(r, tree_id_now++);\n    }\n\n    template <class T> std::vector<T> segtree_rearrange(const std::vector<T> &data) const {\n        assert(int(data.size()) == V);\n        std::vector<T> ret;\n        ret.reserve(V);\n        for (int i = 0; i < V; i++) ret.emplace_back(data[aligned_id_inv[i]]);\n        return ret;\n    }\n\n    // query for vertices on path [u, v] (INCLUSIVE)\n    void\n    for_each_vertex(int u, int v, const std::function<void(int ancestor, int descendant)> &f) const {\n        while (true) {\n            if (aligned_id[u] > aligned_id[v]) std::swap(u, v);\n            f(std::max(aligned_id[head[v]], aligned_id[u]), aligned_id[v]);\n            if (head[u] == head[v]) break;\n            v = par[head[v]];\n        }\n    }\n\n    void for_each_vertex_noncommutative(\n        int from, int to, const std::function<void(int ancestor, int descendant)> &fup,\n        const std::function<void(int ancestor, int descendant)> &fdown) const {\n        int u = from, v = to;\n        const int lca = lowest_common_ancestor(u, v), dlca = depth[lca];\n        while (u >= 0 and depth[u] > dlca) {\n            const int p = (depth[head[u]] > dlca ? head[u] : lca);\n            fup(aligned_id[p] + (p == lca), aligned_id[u]), u = par[p];\n        }\n        static std::vector<std::pair<int, int>> lrs;\n        int sz = 0;\n        while (v >= 0 and depth[v] >= dlca) {\n            const int p = (depth[head[v]] >= dlca ? head[v] : lca);\n            if (int(lrs.size()) == sz) lrs.emplace_back(0, 0);\n            lrs.at(sz++) = {p, v}, v = par.at(p);\n        }\n        while (sz--) fdown(aligned_id[lrs.at(sz).first], aligned_id[lrs.at(sz).second]);\n    }\n\n    // query for edges on path [u, v]\n    void for_each_edge(int u, int v, const std::function<void(int, int)> &f) const {\n        while (true) {\n            if (aligned_id[u] > aligned_id[v]) std::swap(u, v);\n            if (head[u] != head[v]) {\n                f(aligned_id[head[v]], aligned_id[v]);\n                v = par[head[v]];\n            } else {\n                if (u != v) f(aligned_id[u] + 1, aligned_id[v]);\n                break;\n            }\n        }\n    }\n\n    // lowest_common_ancestor: O(log V)\n    int lowest_common_ancestor(int u, int v) const {\n        assert(tree_id[u] == tree_id[v] and tree_id[u] >= 0);\n        while (true) {\n            if (aligned_id[u] > aligned_id[v]) std::swap(u, v);\n            if (head[u] == head[v]) return u;\n            v = par[head[v]];\n        }\n    }\n\n    int distance(int u, int v) const {\n        assert(tree_id[u] == tree_id[v] and tree_id[u] >= 0);\n        return depth[u] + depth[v] - 2 * depth[lowest_common_ancestor(u, v)];\n    }\n\n    // Level ancestor, O(log V)\n    // if k-th parent is out of range, return -1\n    int kth_parent(int v, int k) const {\n        if (k < 0) return -1;\n        while (v >= 0) {\n            int h = head.at(v), len = depth.at(v) - depth.at(h);\n            if (k <= len) return aligned_id_inv.at(aligned_id.at(v) - k);\n            k -= len + 1, v = par.at(h);\n        }\n        return -1;\n    }\n\n    // Jump on tree, O(log V)\n    int s_to_t_by_k_steps(int s, int t, int k) const {\n        if (k < 0) return -1;\n        if (k == 0) return s;\n        int lca = lowest_common_ancestor(s, t);\n        if (k <= depth.at(s) - depth.at(lca)) return kth_parent(s, k);\n        return kth_parent(t, depth.at(s) + depth.at(t) - depth.at(lca) * 2 - k);\n    }\n};\n\n// Static sequence sparse table\n// Complexity: O(NlogN) for precalculation, O(1) per query\ntemplate <class S, S (*op)(S, S), S (*e)()> struct sparse_table {\n    int N, lgN;\n    std::vector<std::vector<S>> d;\n    std::vector<int> lgx_table;\n    sparse_table() {}\n    sparse_table(const std::vector<S> &sequence) : N(sequence.size()) {\n        lgx_table.resize(N + 1);\n        for (int i = 2; i < N + 1; ++i) lgx_table[i] = lgx_table[i >> 1] + 1;\n        lgN = lgx_table[N] + 1;\n        d.assign(lgN, std::vector<S>(N, e()));\n        d[0] = sequence;\n        for (int h = 1; h < lgN; ++h) {\n            for (int i = 0; i + (1 << h) <= N; ++i) {\n                d[h][i] = op(d[h - 1][i], d[h - 1][i + (1 << (h - 1))]);\n            }\n        }\n    }\n    S prod(int l, int r) const { // [l, r), 0-indexed\n        assert(l >= 0 and r <= N);\n        if (l >= r) return e();\n        int h = lgx_table[r - l];\n        return op(d[h][l], d[h][r - (1 << h)]);\n    }\n};\n\nconstexpr int D = 20;\n\nusing S = vector<int>;\n\nS op(S l, S r) {\n    for (int x : r) {\n        if ((int)l.size() == D) break;\n        for (int y : l) chmin(x, y ^ x);\n        if (x) l.push_back(x);\n    }\n    return l;\n}\n\nS e() { return {}; }\n\nint main() {\n\n    int N;\n    cin >> N;\n    vector<int> A(N);\n    cin >> A;\n\n    HeavyLightDecomposition hld(N);\n\n    REP(e, N - 1) {\n        int u, v;\n        cin >> u >> v;\n        --u, --v;\n        hld.add_edge(u, v);\n    }\n\n    hld.build();\n\n    vector<S> init;\n    for (int x : A) init.push_back(vector<int>{x});\n    dbg(init);\n    init = hld.segtree_rearrange(init);\n    sparse_table<S, op, e> st(init);\n\n    int Q;\n    cin >> Q;\n    while (Q--) {\n        int x, y, k;\n        cin >> x >> y >> k;\n        --x, --y;\n\n        S base;\n        hld.for_each_vertex(x, y, [&](int l, int r) { base = op(base, st.prod(l, r + 1)); });\n\n        for (int b : base) chmin(k, k ^ b);\n        cout << (k ? ""NO"" : ""YES"") << \'\\n\';\n    }\n}\n']","[0, 1, 1, 0, 1]",2400,This problem requires working with XOR bases so let s have a primer on them Suppose you want to solve the following problem given a set of integers and another integer check whether it is possible to choose several maybe zero integers from the set such that their XOR is It can be solved with Gauss elimination method for systems of linear equations but there are easier and faster methods and we will describe one of them For the given set of integers let s build an XOR base An XOR base of a set of integers is another set of integers such that every integer that can be expressed as the XOR of some integers from the set can also be expressed as the XOR of some integers from and vice versa every integer in is non redundant i e if you remove any integer from the first property is no longer met For example one of the XOR bases for is is also an XOR base of but is not since for example can be deleted Note that an XOR base is not necessarily a subset of the original set For example for is a valid XOR base Due to the laws of linear algebra an XOR base of size supports integers i e integers can be expressed using XOR of some numbers from the base This means that since in our problem the integers are limited to bits the maximum size of an XOR base we need is Now let s talk about how we build store and maintain the XOR base We will use an array of integers initially filled with zeroes an array of all zeroes represents an empty XOR base Let s call this array If some integer in this array is non zero it has to meet the following constraints the th bit is set to in the th bit is set to in every integer such that This is kinda similar to how the Gauss elimination method transforms a matrix representing the system of linear equations it leaves only one row with non zero value in the first column and puts it as the first row then in the next non zero column it leaves only one row with non zero value except for maybe the first row and puts it as the second row and so on Okay we need to process two types of queries for XOR bases add an integer and change the XOR base accordingly if needed check that some integer is supported i e can be represented by the XOR base For both of those queries we will use a special reduction process In the model solution it is the function that takes an array representing the XOR base and an integer and tries to eliminate bits set to from In this reduction process we iterate on bits from or the highest bit the number can have set to to and every time the bit we re considering is set to we try to make it by XORing with It can be easily seen that due to the properties of XOR base XORing with is the only way to do it if we XOR with any other number such that it won t affect the th bit and if we XOR it with such that it sets the th bit to and we have already ensured that it should be If transforms to then is supported by the XOR base otherwise it is not And if we want to try adding to the base we can simply reduce find the highest non zero bit in the resulting integer let it be and assign to it is guaranteed that was zero since otherwise we would have eliminated the th bit So that s how we can work with XOR bases and process every query to them in where is the number of bits in each integer Now let s go back to the original problem Basically for every query we have to build a XOR base on some path in the tree We can root the tree and then use LCA to split this path into two vertical paths get XOR bases from those two paths and merge them in But how do we get an XOR base on a vertical path in something like To do this for each vertex let s consider the following process We go from to the root maintain the XOR base of the integers we met and every time we add something to the XOR base we mark the current vertex as interesting for Our goal is to build a list of interesting vertices for in order from to the root Since the size of each XOR base is up to the size of each such list is also up to so we can get the XOR base for a vertical path by simply iterating on that interesting list for the lower endpoint of the path Okay the last part of the problem we have to solve is how to build these lists for all vertices in reasonable time The key insight here is that if is the parent of then the list for will be very similar to the list for if is not supported by the XOR base of the list for then the list for is simply the list for with the vertex added otherwise eliminates one of the vertices from the list for We can find which one by building the XOR base for and the list of we need to add first and then the values from all vertices in the list of in order from bottom to top and when an interesting vertex for adds nothing to the XOR base it means that it is exactly the vertex we need to eliminate Combining all of these we can get a solution that works in for preprocessing and in to answer each query 
Vasya has found a piece of paper with a coordinate system written on it There are distinct squares drawn in this coordinate system Let s number the squares with integers from 1 to It turned out that points with coordinates and are the opposite corners of the th square Vasya wants to find such integer point with integer coordinates of the plane that belongs to exactly drawn squares We ll say that a point belongs to a square if the point is located either inside the square or on its boundary Help Vasya find a point that would meet the described limits ,"['#include <cstdio>\n#include <algorithm>\n\nint aa[100], n, k;\n\nint main() {\n    scanf(""%d%d"", &n, &k);\n    for(int i=0; i<n; i++) scanf(""%d"", aa+i);\n    std::sort(aa, aa+n);\n    aa[n] = aa[n-1]+1;\n    int i;\n    for(i=0; i<n; i++) {\n        if(aa[i] == aa[i+1]) continue;\n        if(i == n-k) {\n            printf(""%d %d\\n"", aa[i], aa[i]);\n            break;\n        }\n    }\n    if(i == n) puts(""-1"");\n    return 0;\n}\n']","[1, 0, 1, 0, 0]",900,If then the answer doesn t exist Otherwise let s sort the squares by descending of their sizes Now you can print any point that belongs to the th square and doesn t belong to the th square One of the possible answers is 
One day two students Grisha and Diana found themselves in the university chemistry lab In the lab the students found test tubes with mercury numbered from to and decided to conduct an experiment The experiment consists of steps On each step one of the following actions occurs Diana pours all the contents from tube number and then pours there exactly liters of mercury Let s consider all the ways to add liters of water into the tubes for each way let s count the volume water and mercury in the tube with maximum amount of liquid finally let s find the minimum among counted maximums That is the number the students want to count At that the students don t actually pour the mercury They perform calculations without changing the contents of the tubes Unfortunately the calculations proved to be too complex and the students asked you to help them Help them conduct the described experiment ,"['#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nstruct node{int ch[2],v,fix,sz;ll su;}t[1000005];int ndtot=0;\nvoid pu(int x){\n    t[x].su=t[t[x].ch[0]].su+t[t[x].ch[1]].su+t[x].v;\n    t[x].sz=t[t[x].ch[0]].sz+t[t[x].ch[1]].sz+1;\n}\nint root=0;\nvoid rot(int &x,int f){\n    int y=t[x].ch[!f];\n    t[x].ch[!f]=t[y].ch[f];\n    t[y].ch[f]=x;\n    pu(x);pu(y);\n    x=y;\n}\nvoid ins(int &x,int v){\n    if(x==0){\n        x=++ndtot;\n        t[x].ch[0]=t[x].ch[1]=0;\n        t[x].sz=1;\n        t[x].fix=rand();\n        t[x].v=t[x].su=v;\n    }else{\n        int f=v>=t[x].v;\n        ins(t[x].ch[f],v);\n        pu(x);\n        if(t[t[x].ch[f]].fix<t[x].fix)rot(x,!f);\n    }\n}\nvoid del(int &x){\n    if(!t[x].ch[0] && !t[x].ch[1])x=0;\n    else{\n        int f=!t[x].ch[0] || t[x].ch[1]&&t[t[x].ch[1]].fix<t[t[x].ch[0]].fix;\n        rot(x,!f);\n        del(t[x].ch[!f]);\n        pu(x);\n    }\n}\nvoid del_num(int &x,int v){\n    if(t[x].v==v)del(x);\n    else{\n        int f=v>=t[x].v;\n        del_num(t[x].ch[f],v);\n        pu(x);\n    }\n}\nint n;\nint cur[100005];\ndb queryans(db v){\n    int p=root,q;\n    ll presum=0;int presz=0;\n    while(p){\n        ll su=presum+t[t[p].ch[0]].su+t[p].v;\n        int sz=presz+t[t[p].ch[0]].sz+1;\n        if(v>=1ll*t[p].v*sz-su){\n            presum=su;\n            presz=sz;\n            p=t[p].ch[1];\n        }else p=t[p].ch[0];\n    }\n    return 1.0*(presum+v)/presz;\n}\nint main()\n{\n    t[0]=(node){{0,0},0,0,0,0};\n    int que;\n    scanf(""%d%d"",&n,&que);\n    for (int i=1;i<=n;i++)scanf(""%d"",&cur[i]);\n    for (int i=1;i<=n;i++)ins(root,cur[i]);\n    while(que--){\n        int opt;scanf(""%d"",&opt);\n        if(opt==1){\n            int x,y;scanf(""%d%d"",&x,&y);\n            del_num(root,cur[x]);\n            ins(root,cur[x]=y);\n        }else{\n            ll v;scanf(""%I64d"",&v);\n            printf(""%.5lf\\n"",queryans(v));\n        }\n    }\n    return 0;\n}\n']","[0, 0, 0, 0, 1]",2200,First of all let s understand the statement We have tubes At the beginning of each of them there are a few amount of mercury is poured We want be able to perform two types of queries Well actually now turn to the solution Use binary search to find an answer in particular will sort out the amount of mercury in a tubes let it equals to such that in the tubes with smaller volume of the liquid can be poured all liters of water and the maximum liquid level does not exceed Let the number of tubes with the amount of mercury less than is equal Now the problem is reduced to learning how to count the total amount of water that we can to pour into each of least tubes such that the level of the liquid in each of them is equal Let the total amount of mercury in the tubes which exactly have liters mercury and number of tubes which the volume of mercury is equal Then and the total maximum amount of the water which can be poured If then obviously this space is not enough for pour all the water otherwise quite enough and so the answer will be no more than When we found the smallest we can say that the answer is equal To quickly find for and and perform queries of the first type you can use the Fenwick tree 6676668 
You are given a sequence a 1 a 2 dots a n consisting of n non zero integers i e a i ne 0 You have to calculate two following values the number of pairs of indices l r l le r such that a l cdot a l 1 dots a r 1 cdot a r is negative the number of pairs of indices l r l le r such that a l cdot a l 1 dots a r 1 cdot a r is positive ,"['#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nint n,S[1000005];\nint main(){\n\t/*scanf(""%d%d%d%d%d"",&a1,&a2,&k1,&k2,&n);\n\tint low=a1*(k1-1)+a2*(k2-1);\n\tprintf(""%d "",max(n-low,0));\n\tif (k1>k2) swap(k1,k2),swap(a1,a2);\n\tint T1=min(n/k1,a1); a1-=k1; n-=T1*k1;\n\tprintf(""%d"",T1+n/k2);*/\n\tscanf(""%d"",&n);\n\tS[0]=1;\n\tFor(i,1,n){\n\t\tint x;\n\t\tscanf(""%d"",&x);\n\t\tif (x<0) S[i]=S[i-1]^1;\n\t\telse S[i]=S[i-1];\n\t}\n\tint s0=0,s1=0;\n\tFor(i,0,n)\n\t\tif (S[i]==0) ++s0;\n\t\telse ++s1;\n\tprintf(""%lld %lld\\n"",1ll*s0*s1,1ll*n*(n+1)/2-1ll*s0*s1);\n}']","[0, 0, 1, 1, 0]",1400,At first let s calculate the value of the number of subsegments with positive product We should iterate through the array and store the number of negative elements Also we should store and the number of elements such that there is an even number of negative elements before them or an odd number of negative elements before them If for the current element is even we should increase by one else we should increase by one Then if the current element is negative we should increase by one Then we should add the number of subsegments ending in the current element and having positive product to If is even then any subsegment ending in the current element and containing even number of negative elements should begin in a position where was even too so we should add to If is odd we should add to we use similar reasoning The number of segments having negative product can be calculated for example by subtracting from the total number of subsegments which is 
Recently you have received two integer numbers x and y You forgot them but you remembered a list containing all divisors of x including 1 and x and all divisors of y including 1 and y If d is a divisor of both numbers x and y at the same time there are two occurrences of d in the list For example if x 4 and y 6 then the given list can be any permutation of the list 1 2 4 1 2 3 6 Some of the possible lists are 1 1 2 4 6 3 2 4 6 1 1 2 3 2 or 1 6 3 2 4 1 2 Your problem is to restore suitable integer numbers x and y that would yield the same list of divisors possibly in different order It is guaranteed that the answer exists i e the given list of divisors corresponds to some integers x and y ,"['#include <bits/stdc++.h>\n\n#define fn ""test""\n#define fn1 """"\n\nusing namespace std;\n\nconst int mn = 1 * (int)(1e5) + 10;\nconst int mod = 1 * (int)(1e9) + 7;\nconst int mm = 1 * (int)(1e3) + 10;\nconst int base = 1 * (int)(1e9);\nconst bool aNs = 0;\n\nint tt, ntest = 1;\n\nvoid docfile()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    if (ifstream(fn"".inp""))\n    {\n        freopen(fn"".inp"", ""r"", stdin);\n        if (!aNs) freopen(fn"".out"", ""w"", stdout);\n\t\telse freopen (fn"".ans"", ""w"", stdout);\n    }else if (ifstream(fn1"".inp""))\n    {\n        freopen(fn1"".inp"", ""r"", stdin);\n        freopen(fn1"".out"", ""w"", stdout);\n    }\n}\n\ntemplate <typename T>\nvoid read(T& x)\n{\n    x = 0; T f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) f = ch == \'-\' ? - f : f, ch = getchar();\n    while (isdigit(ch)) x = x * 10 + ch - \'0\', ch = getchar();\n    x *= f;\n}\n\ntemplate <typename T>\nvoid write (T a)\n{\n    if (a < 0)\n    {\n        putchar (\'-\');\n        write (-a);\n        return;\n    }\n    if (a < 10)\n    {\n        putchar (\'0\' + a);\n        return;\n    }\n    write (a / 10);\n    putchar ((char)(\'0\' + (a % 10)));\n}\n\nbool ok[mn];\n\nvoid enter()\n{\n    int n;\n    cin >> n;\n    vector<int> a (n + 3);\n    map<int, int> mu;\n    int ma = 0, ma1 = 0;\n    for (int i = 1; i <= n; ++ i)\n    {\n        cin >> a[i];\n        ma = max (ma, a[i]);\n    }\n    int l = ma;\n    for (int i = 1; i <= n; ++ i)\n    {\n        if (ma % a[i] == 0 && !ok[a[i]])\n        {\n            ok[a[i]] = 1;\n            // ma /= a[i];\n        }\n        else ma1 = max (ma1, a[i]);\n    }\n    cout << l << "" "" << ma1;\n}\n\nvoid solve()\n{\n\n}\n\nvoid print_result()\n{\n\n}\n\nint main()\n{\n    docfile();\n    //cin>>ntest;\n    for (tt = 1; tt <= ntest; ++ tt)\n    {\n        enter();\n        solve();\n        print_result();\n    }\n}']","[1, 1, 0, 0, 0]",1100,Let s take a look on the maximum element of the given array Suddenly this number is or the order doesn t matter Okay what would we do if we know and merged list of divisors of and Let s remove all divisors of and see what we got The maximum element in the remaining array is So the problem is solved 
Amr is a young coder who likes music a lot He always wanted to learn how to play music but he was busy coding so he got an idea Amr has instruments it takes days to learn th instrument Being busy Amr dedicated days to learn how to play the maximum possible number of instruments Amr asked for your help to distribute his free days between instruments so that he can achieve his goal ,"['#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint use[110], a[110];\n\nint main() {\n\n    int n, K;\n    scanf(""%d%d"", &n, &K);\n    for (int i = 0; i < n; i ++) {\n        scanf(""%d"", &a[i]);\n    }\n    vector<int> sol;\n    while (true) {\n        int id = -1;\n        for (int i = 0; i < n; i ++) {\n            if (!use[i] && (id == -1 || a[i] < a[id])) {\n                id = i;\n            }\n        }\n        if (id != -1 && a[id] <= K) {\n            K -= a[id];\n        } else {\n            id = -1;\n        }\n        if (id == -1) {\n            break;\n        }\n        use[id] = 1;\n        sol.push_back(id + 1);\n    }\n    printf(""%d\\n"", sol.size());\n    for (auto x : sol) {\n        printf(""%d "", x);\n    }\n    puts("""");\n    return 0;\n}']","[1, 0, 1, 0, 0]",1000,Problem We have to split the number into maximum number of elements of such that their sum is less than or equal to Hint To maximize the answer we have to split the number into the smallest numbers possible Solution So and since the limits are small we can pick up the smallest element of the array and subtract it from and we keep doing this times or until the smallest number is larger than Another solution is to sort the array in non decreasing order and go on the same way Time complexity or Implementation 9529124 
We have an old building with columns in a row These columns support the ceiling These columns are located in points with coordinates The leftmost and the rightmost columns are special we will call them the other columns are For each column we know its durability Let s consider an ordinary column with coordinate Let s assume that the coordinate of the closest to it column to the left bearing or ordinary is and the coordinate of the closest to it column to the right also bearing or ordinary is In this task let s assume that this column supports the segment of the ceiling from point to point here both fractions are considered as real division If the length of the segment of the ceiling supported by the column exceeds then the column cannot support it and it crashes after a while and after that the load is being redistributeed between the neighbouring columns according to the same principle Thus ordinary columns will be crashing for some time until the process stops at some state One can prove that the set of the remaining columns doesn t depend on the order in which columns crash If there are only two bearing columns left in the end then we assume that the whole construction crashes under the weight of the roof But if at least one ordinary column stays in addition to the bearing ones then the building doesn t crash To make the building stronger we can add one extra ordinary column of arbitrary durability at any not necessarily integer point If point is already occupied by an ordinary column it is replaced by a new one Your task is to find out what minimal durability can the added column have so that the building doesn t crash ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define INF (1ll<<60)\n\nint N; // 0 and N are strong\nll X;\nll x[100010],r[100010],l[100010];\nll d[100010];\nbool broken[100010];\n\nint sz;\nint id[100010];\n\nll func(void){\n    int i,j;\n    \n    r[0] = l[N] = X;\n//  for(i=0;i<=N;i++) cout << x[i] << \' \' << l[i] << \' \' << r[i] << endl;\n    \n    for(i=1;i<N;i++){\n        if(x[i] + r[i] >= X) return 0;\n        if(x[i] - l[i] <= 0) return 0;\n    }\n    \n    ll ans = INF;\n//  REP(i,N+1) REP(j,N+1) if(i < j && x[i] + r[i] >= x[j] - l[j]) ans = min(ans, x[j] - x[i]);\n\n    sz = 0;\n\n    for(j=1;j<=N;j++){\n        i = j - 1;\n        if(r[i] != 0){\n            while(1){\n                if(sz == 0) break;\n                int p = id[sz-1];\n                if(x[p] + r[p] > x[i] + r[i]) break;\n                sz--;\n            }\n            id[sz] = i;\n            sz++;\n        }\n        \n        if(l[j] != 0){\n            int low = 0, high = sz;\n            while(high - low > 1){\n                int mid = (low + high) / 2;\n                int p = id[mid];\n                if(x[p] + r[p] >= x[j] - l[j]) low = mid; else high = mid;\n            }\n            int q = id[low];\n            ans = min(ans, x[j] - x[q]);\n        }\n    }\n    \n    return ans;\n}\n\nint st[100010];\n\nvoid calc_r(void){\n    int i;\n    \n    sz = 1;\n    st[0] = 0;\n    \n    for(i=1;i<N;i++){\n        while(1){\n            if(sz < 2) break;\n            int p = st[sz-2], q = st[sz-1];\n            if(2 * d[q] >= x[i] - x[p]) break;\n            sz--;\n        }\n        r[i] = 2 * d[i] - (x[i] - x[st[sz-1]]);\n        if(r[i] <= 0) r[i] = 0;\n        st[sz] = i;\n        sz++;\n    }\n}\n\nvoid calc_l(void){\n    int i;\n    \n    sz = 1;\n    st[0] = N;\n    \n    for(i=N-1;i>=1;i--){\n        while(1){\n            if(sz < 2) break;\n            int p = st[sz-2], q = st[sz-1];\n            if(2 * d[q] >= x[p] - x[i]) break;\n            sz--;\n        }\n        l[i] = 2 * d[i] - (x[st[sz-1]] - x[i]);\n        if(l[i] <= 0) l[i] = 0;\n        st[sz] = i;\n        sz++;\n    }\n}\n\nint main(void){\n    int i;\n    \n    cin >> N;\n    REP(i,N+2){\n        int tmp;\n        scanf(""%d"", &tmp);\n        x[i] = tmp;\n    }\n    for(i=1;i<=N;i++){\n        int tmp;\n        scanf(""%d"", &tmp);\n        d[i] = tmp;\n    }\n    N++;\n    X = x[N];\n    \n    calc_r();\n    calc_l();\n    \n    ll ans = func();\n    printf(""%.9f\\n"", ans / 2.0);\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 1]",3000,First observation column crashes only if distance between its neighbours is greater than 2di so it doesn t matter where exactly is this column The only important thing is how far are left and right neighbour of it For every column C let s calculate does there exist subset of columns on the left that everything is stable between C and leftmost bearing column If answer is yes then how close can be left neighbour of C Then we will know how far the right neighbour can be We will use dynamic programming Slow approach For every previous column let s check if it can be neighbours with C The closest column fulfilling this condition is best left neighbour of C Faster approach Let s denote far i as the biggest possible coordinate where right neighbour of column i can be In our dp we need an extra stack with possible candidates for being left neighbour of new column In this stack columns are sorted in ascending order by index and coordinate and in descending order by far i For every new column we must remove from the top of stack columns which have too low far i Then last column on stack is the best left neighbour and we can calculate value far for current column It is O n algorithm Some columns can t be connected with leftmost bearing column and for them we have far i 0 If there exists column with far i not less than coordinate of rightmost bearing column then we don t have to add new column and answer is 0 Ok Now let s run the same dp from right to the left Some columns are connected with leftmost bearing column some other columns with righmost one And we will want to place new column somewhere between them Brute force solution is to check every pair of columns and to say we want these two columns to be neighbours of added column With values far i calculated in dp we check if we can have such a situation and we eventually consider result to be half of a distance between these two columns How to make this last part faster We must create two stacks with best candidates for neighbours of new column One stack with columns connected to the leftmost column one with the ones connected to the rightmost one On these stacks we can find answer with two pointers technique 
Polycarp takes part in a math show He is given tasks each consists of subtasks numbered through It takes him minutes to solve the th subtask of any task Thus time required to solve a subtask depends only on its index but not on the task itself Polycarp can solve subtasks in any order By solving subtask of arbitrary problem he earns one point Thus the number of points for task is equal to the number of solved subtasks in it Moreover if Polycarp solves the task solves all of its subtasks he recieves one extra point Thus total number of points he recieves for the complete solution of the task is Polycarp has minutes of time What is the maximum number of points he can earn ,"['#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define N 55\nconst LL inf = 10000000000000000LL;\nLL n , k , M , dp[ N * N ] , t[ N ];\nint main(){\n  cin >> n >> k >> M;\n  for( int i = 0 ; i < k ; i ++ )\n    cin >> t[ i ];\n  sort( t , t + k );\n  for( int i = 1 ; i < k ; i ++ )\n    t[ i ] += t[ i - 1 ];\n  for( int i = 1 ; i <= n * ( k + 1 ) ; i ++ )\n    dp[ i ] = inf;\n  for( int _ = 0 ; _ < n ; _ ++ ){\n    for( int i = n * ( k + 1 ) ; i >= 0 ; i -- ){\n      if( dp[ i ] == inf ) continue;\n      for( int solved = 1 ; solved <= k ; solved ++ ){\n        LL tdp = dp[ i ] + t[ solved - 1 ];\n        int ii = i + solved + (solved == k);\n        dp[ ii ] = min( dp[ ii ] , tdp );\n      }\n    }\n  }\n  int ans = 0;\n  for( int i = 1 ; i <= n * ( k + 1 ) ; i ++ )\n    if( dp[ i ] <= M )\n      ans = i;\n  cout << ans << endl;\n}\n']","[1, 0, 0, 0, 0]",1800,Constraints tell us that we can avoid making any weird assumptions for any greedy solutions You can easily count the answer for some fixed amount of tasks completed Just sort all left subtasks but the longest to solve in each uncompleted task and take the easiest till the time is over Now you can iterate from to tasks completed and take maximum over all options Overall complexity 
On a plane are points with integer coordinates between and The distance between the two points with numbers and is said to be the following value the distance calculated by such formula is called We call a hamiltonian path to be some permutation of numbers from to We say that the length of this path is value Find some hamiltonian path with a length of no more than Note that you do not have to minimize the path length ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 1000010\nint n;\nint x[MAX],y[MAX];\nvector<int> t[1001][1001];\nvoid dod(int a,int b){\n  R(i,SZ(t[a][b])){\n    printf(""%d "",t[a][b][i]+1);\n  }\n}\nmain(){\n  make(n);\n  R(i,n){\n    int x,y;\n    make(x);if(!x)x++;\n    make(y);if(!y)y++;\n    t[(x-1)/1000][(y-1)/1000].PB(i);\n  }\n  R(i,1000){\n    if(i&1){\n      R(j,1000)\n        dod(i,j);\n    }else{\n      FD(j,1000)\n        dod(i,j);\n    }\n  }\n  puts("""");\n}\n']","[1, 0, 0, 0, 0]",2100,Let s split rectangle 106 106 by vertical lines into 1000 rectangles 103 106 Let s number them from left to right We re going to pass through points rectangle by rectangle Inside the rectangle we re going to pass the points in increasing order of y coordinate if the number of rectangle is even and in decreasing if it s odd Let s calculate the maximum length of such a way The coordinates are independent By y coordinate we re passing 1000 rectangles from 0 to 106 109 in total By x coordinate we re spending 1000 to get to the next point of current rectangle and 2000 to get to next rectangle That means 2 109 2000000 in total which perfectly fits 
We all know that GukiZ often plays with arrays Now he is thinking about this problem how many arrays of length with non negative elements then meet the following condition Here operation means bitwise AND in it is equivalent to in it is equivalent to operation means bitwise OR in it is equivalent to in it is equivalent to Because the answer can be quite large calculate it modulo This time GukiZ hasn t come up with solution and needs you to help him ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nconst int S = 4;\nconst int OP[S][S] = {\n\t{ 1, 0, 1, 0 },\n\t{ 0, 1, 0, 1 },\n\t{ 1, 0, 0, 1 },\n\t{ 0, 1, 0, 1 }\n} ;\n\ntypedef long long LL;\n\nLL MOD;\nstruct Matrix {\n\tLL a[S][S];\n\n\tMatrix() { memset(a, 0, sizeof a); }\n\tvoid Unit(LL x = 1) {\n\t\tfor (int i = 0; i < S; ++i) {\n\t\t\tfor (int j = 0; j < S; ++j) {\n\t\t\t\ta[i][j] = 0;\n\t\t\t}\n\t\t\ta[i][i] = x % MOD;\n\t\t}\n\t}\n\tvoid ToOP() {\n\t\tfor (int i = 0; i < S; ++i) {\n\t\t\tfor (int j = 0; j < S; ++j) {\n\t\t\t\ta[i][j] = OP[i][j] % MOD;\n\t\t\t}\n\t\t}\n\t}\n} ;\n\nMatrix operator * (const Matrix &a, const Matrix &b) {\n\tMatrix s;\n\n\tfor (int i = 0; i < S; ++i) {\n\t\tfor (int k = 0; k < S; ++k) {\n\t\t\tif (a.a[i][k] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int j = 0; j < S; ++j) {\n\t\t\t\ts.a[i][j] += a.a[i][k] * b.a[k][j];\n\t\t\t\ts.a[i][j] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn s;\n}\n\nMatrix operator ^ (Matrix a, LL p) {\n\tMatrix s;\n\n\ts.Unit();\n\twhile (p > 0) {\n\t\tif (p & 1) {\n\t\t\ts = s * a;\n\t\t}\n\t\ta = a * a;\n\t\tp >>= 1;\n\t}\n\n\treturn s;\n}\n\nint main() {\n\tLL n, k, l, m;\n\n\twhile (cin >> n >> k >> l >> m) {\n\t\tMOD = m;\n\t\tif (n == 1) {\n\t\t\tcout << (1 % MOD) << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tMatrix base, op;\n\t\tLL a0, a1;\n\n\t\tbase.a[0][0] = base.a[0][2] = 1 % MOD;\n\t\top.ToOP();\n\t\tbase = base * (op ^ (n - 1));\n\n\t\ta0 = (base.a[0][0] + base.a[0][2]) % MOD;\n\t\ta1 = (base.a[0][1] + base.a[0][3]) % MOD;\n\t\t//cout << a0 << ' ' << a1 << endl;\n\n\t\tLL answer = 1 % MOD;\n\n\t\tfor (int i = 0; i < l; ++i) {\n\t\t\tif (k & 1) {\n\t\t\t\tanswer *= a1;\n\t\t\t} else {\n\t\t\t\tanswer *= a0;\n\t\t\t}\n\t\t\tanswer %= MOD;\n\t\t\tk >>= 1;\n\t\t}\n\t\tif (k) {\n\t\t\tcout << 0 << endl;\n\t\t} else {\n\t\t\tcout << answer << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n""]","[0, 1, 1, 0, 0]",2100,Here is my code 11604669 I m getting WA on 10th test case 1000000001 1000000002 37 1000000007 Output 187032448 Answer 472514342 Can someone give me an idea where I m wrong Thanks in advance 
Petya has a rectangular Board of size n times m Initially k chips are placed on the board i th chip is located in the cell at the intersection of sx i th row and sy i th column In one action Petya can move to the left right down or up by 1 cell If the chip was in the x y cell then after the operation left its coordinates will be x y 1 right its coordinates will be x y 1 down its coordinates will be x 1 y up its coordinates will be x 1 y If the chip is located by the wall of the board and the action chosen by Petya moves it towards the wall then the chip remains in its current position For each chip Petya chose the position which it should visit Note that it s not necessary for a chip to end up in this position Since Petya does not have a lot of free time he is ready to do no more than 2nm actions You have to find out what actions Petya should do so that each chip visits the position that Petya selected for it at least once Or determine that it is not possible to do this in 2nm actions ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n,m;\nstring ans;\nint main() {\n\tscanf(""%d%d"",&n,&m);\n\trep(i,0,m-1) ans.pb(\'L\');\n\trep(i,0,n-1) ans.pb(\'U\');\n\trep(i,0,n) {\n\t\tif (i%2==0) {\n\t\t\trep(j,0,m-1) ans.pb(\'R\');\n\t\t} else {\n\t\t\trep(j,0,m-1) ans.pb(\'L\');\n\t\t}\n\t\tif (i!=n-1) ans.pb(\'D\');\n\t}\n\tprintf(""%d\\n"",SZ(ans));\n\tprintf(""%s\\n"",ans.c_str());\n}\n']","[0, 0, 1, 0, 0]",1600,Note that 2nm is a fairly large number of operations Therefore we can first collect all the chips in one cell and then go around the entire board Let s calculate the required number of operations First let s collect all the chips in the 1 1 cell To do this let s do n 1 operations U so that all the chips are in the first row then do m 1 operations L After such operations wherever the chip is initially located it will end up in the 1 1 cell After that we need to go around the entire board Let s do it in such a way that the rows with odd numbers are be bypassed from left to right and the even ones from right to left We also need n 1 operations D to move from one row to the next one In total we got n 1 m 1 n m 1 n 1 nm n m 3 operations which is completely suitable for us 
Tenten runs a weapon shop for ninjas Today she is willing to sell n shurikens which cost 1 2 n ryo local currency During a day Tenten will place the shurikens onto the showcase which is empty at the beginning of the day Her job is fairly simple sometimes Tenten places another shuriken from the available shurikens on the showcase and sometimes a ninja comes in and buys a shuriken from the showcase Since ninjas are thrifty they always buy the shuriken from the showcase Tenten keeps a record for all events and she ends up with a list of the following types of records means that she placed another shuriken on the showcase means that the shuriken of price x was bought Today was a lucky day and all shurikens were bought Now Tenten wonders if her list is consistent and what could be a possible order of placing the shurikens on the showcase Help her to find this out ,"['/**\n *    author:  tourist\n *    created: 25.10.2020 14:11:57       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> op(2 * n);\n  vector<int> st;\n  for (int i = 0; i < 2 * n; i++) {\n    string s;\n    cin >> s;\n    if (s == ""+"") {\n      st.push_back(i);\n    } else {\n      if (st.empty()) {\n        cout << ""NO"" << \'\\n\';\n        return 0;\n      }\n      cin >> op[i];\n      op[st.back()] = -op[i];\n      st.pop_back();\n    }\n  }\n  set<int> s;\n  for (int i = 0; i < 2 * n; i++) {\n    if (op[i] < 0) {\n      s.insert(-op[i]);\n    } else {\n      if (s.empty() || *s.begin() != op[i]) {\n        cout << ""NO"" << \'\\n\';\n        return 0;\n      }\n      s.erase(s.begin());\n    }\n  }\n  cout << ""YES"" << \'\\n\';\n  for (int i = 0; i < 2 * n; i++) {\n    if (op[i] < 0) {\n      cout << -op[i] << "" "";\n    }\n  }\n  cout << \'\\n\';\n  return 0;\n}\n']","[1, 0, 1, 0, 1]",1700,Let s note that if a shuriken of price x is being bought right now then the only information we obtain about all the remaining shurikens is that they are of prices x It s also clear that if we consider two shurikens on the showcase then the one which was placed earlier has the stronger constraints as written above Now consider all events that can happen when the shuriken of price x is bought If for all shurikens that are currently on the showcase we know that they must have prices x then the answer is negative Otherwise for all shurikens that had a lower bound of something less than x we increase it to x and remove any one of them because we cannot remove any other shuriken and these are indistinguishable However since we know that the last placed shuriken has the weakest constraint we can just remove the last placed shuriken each time and check the consistency in the end This verification can be done using any min heap The final time complexity is O n logn 
Sehr Sus is an infinite hexagonal grid as pictured below controlled by MennaFadali ZerooCool and Hosssam They love equilateral triangles and want to create n equilateral triangles on the grid by adding some straight lines The triangles must all be empty from the inside in other words no straight line or hexagon edge should pass through any of the triangles You are allowed to add straight lines parallel to the edges of the hexagons Given n what is the minimum number of lines you need to add to create at least n equilateral triangles as described ,"['#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int cal(int x)\n{\n\tint a=x/3,b=x/3,c=x/3;\n\tif(a+b+c<x) ++a;\n\tif(a+b+c<x) ++b;\n\tif(a+b+c<x) ++c;\n\treturn (a*b+b*c+c*a)*2;\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tint n;\n\t\tcin >> n;\n\t\tint x=0,y=0,z=0,flag=0;\n\t\tint l=0,r=1e5,ans=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(cal(mid)>=n) ans=mid,r=mid-1;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tcout << ans << ""\\n"";\n\t}\n\treturn 0;\n}']","[1, 1, 1, 0, 0]",1700,We can notice that there are different slopes in which we can draw a line and we can also notice that drawing the lines exactly on the edges of the hexagons will result in the creation of equilateral triangles at each intersection of lines so we can say that Now we only need to find a way to draw the lines such that it maximizes the number of intersections The best way to do that is to keep the number of lines on all slopes as close as possible the proof will be explained at the bottom One way to do so is to add the lines once at each slope then repeat Let s say that slopes are numbered and so we will add the lines as follows and so on The increase in the intersection will be the number of lines in the other two slopes added together It will be as follows If we separate that into groups of 3 we will get The sum of the groups is To get the sum of the first groups it will be So to get the number of intersections using lines we will first find the number of complete groups which is and then loop over the last group to find the total number of intersections Now that we have a way to find the number of equilateral triangles created by lines we can find the number of lines needed to get equilateral triangles by using binary search that the best way to maximize the number of intersections is to keep the number of lines on all slopes as close as possible Imagine a case in which the difference between the lines in two slops is more than lines now we can see that if we moved one line from the larger group to the smaller we will obtain more intersections because after moving the intersections with the rd line will be the same and will not be affected and the intersection between the slopes will decrease by the size of the smaller group and increased by the size of the larger group minus so overall the intersections will increase by at least so that proves that we can t have any difference more than and the groups must be as close as possible 
Gildong is developing a game consisting of n stages numbered from 1 to n The player starts the game from the 1 st stage and should beat the stages in increasing order of the stage number The player wins the game after beating the n th stage There is at most one checkpoint on each stage and there is always a checkpoint on the 1 st stage At the beginning of the game only the checkpoint on the 1 st stage is activated and all other checkpoints are deactivated When the player gets to the i th stage that has a checkpoint that checkpoint is activated For each try of a stage the player can either beat the stage or fail the stage If they beat the i th stage the player is moved to the i 1 st stage If they fail the i th stage the player is moved to the most recent checkpoint they activated and they have to beat the stages after that checkpoint again For example assume that n 4 and the checkpoints are on the 1 st and 3 rd stages The player starts at the 1 st stage If they fail on the 1 st stage they need to retry the 1 st stage because the checkpoint on the 1 st stage is the most recent checkpoint they activated If the player beats the 1 st stage they re moved to the 2 nd stage If they fail it they re sent back to the 1 st stage again If they beat both the 1 st stage and the 2 nd stage they get to the 3 rd stage and the checkpoint on the 3 rd stage is activated Now whenever they fail on the 3 rd stage or the 4 th stage after beating the 3 rd stage they re sent back to the 3 rd stage If they beat both the 3 rd stage and the 4 th stage they win the game Gildong is going to build the stages to have equal difficulty He wants you to find any series of stages and checkpoints using at most 2000 stages where the expected number of tries over all stages is exactly k for a player whose probability of beating each stage is exactly cfrac 1 2 ,"['#include <bits/stdc++.h>\n#define F(i,j,k) for(int i=(j);i<=(k);++i)\n#define D(i,j,k) for(int i=(j);i>=(k);--i)\n#define rep(it,s) for(__typeof(s.begin()) it=s.begin();it!=s.end();++it)\n#define Rep(a,s) for(auto a:s)\n#define PB push_back\n#define MP make_pair\n#define FF first\n#define SS second\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\ntemplate<class Type>ll quick_pow(Type x,Type y,Type Mod){\n    ll res=1;\n    while(y){\n        if(y&1)res=res*x%Mod;\n        x=x*x%Mod,y>>=1;\n    }\n    return res;\n}\ntemplate<class Type>ll inv(Type x,Type Mod){return quick_pow(x,Mod-2,Mod);}\nnamespace IO{\n    template <class T>\n    inline void read(T &x){\n        x=0;int f=1;char ch=getchar();\n        while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n        while(ch<=\'9\'&&ch>=\'0\')x=x*10+ch-\'0\',ch=getchar();\n        x*=f;\n    }\n};\nusing namespace IO;\nvector<int>ans;\nint _;\nll n;\nll f[100];\nint main(){\n    #ifndef ONLINE_JUDGE\n        freopen(""in.txt"",""r"",stdin);\n        freopen(""out.txt"",""w"",stdout);\n    #endif\n    read(_);\n    f[1]=2;\n    F(i,2,59)f[i]=f[i-1]*2+2;\n\twhile(_--){\n\t\tread(n);\n\t\tif(n&1){\n\t\t\tcout<<-1<<\'\\n\';\n\t\t\tcontinue;\n\t\t}\n\t\tans.clear();\n\t\tD(i,59,1){\n\t\t\twhile(n>=f[i]){\n\t\t\t\tn-=f[i];\n\t\t\t\tans.PB(1);\n\t\t\t\tF(j,1,i-1)ans.PB(0);\n\t\t\t}\n\t\t}\n\t\tcout<<ans.size()<<\'\\n\';\n\t\tRep(y,ans)cout<<y<<\' \';\n\t\tcout<<\'\\n\';\n\t}\n    return 0;\n}']","[1, 1, 0, 0, 0]",1900,As already explained in the notes and is quite obvious the expected number of tries to beat stage with a checkpoint where stage also has a checkpoint or is the end of the game is What if stage doesn t have a checkpoint and stage has a checkpoint We can think of it like this It takes tries in expectation to get to stage and the player needs to add one more try trying times in total But this also has a probability of to succeed so the expected number of tries to actually get to stage is multiplied by making it in total This can be extended indefinitely Let s say is the expected number of tries to beat consecutive stages with only one checkpoint at the beginning If we extend it to consecutive stages it takes tries If this is not intuitive we can always use Monte Carlo method to simulate how many tries each takes The general term for this sequence is and it is introduced in OEIS A000918 with a similar example As each checkpoint makes the stages after that checkpoint independent of the previous stages we can just add up appropriate s to make it equal to Using means we append the stages in form where the number of s is As every term of the sequence is even the answer is if is odd Otherwise we can show that there always exists an answer for all even There are two simple strategies to make it with at most stages The first strategy is to greedily take the greatest where is the remaining number then append and subtract it from This works because either can be exactly or we can use once and repeat the process with The worst case for this strategy is to use all of and another which sums up to total of stages Another strategy is to use and if bit indexed is Since there can be at most bits the worst case for this strategy is still far less than Time complexity 
First Aoi came up with the following idea for the competitive programming problem Yuzu is a girl who collecting candies Originally she has x candies There are also n enemies numbered with integers from 1 to n Enemy i has a i candies Yuzu is going to determine a permutation P A permutation is an array consisting of n distinct integers from 1 to n in arbitrary order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation 2 appears twice in the array and 1 3 4 is also not a permutation because n 3 but there is the number 4 in the array After that she will do n duels with the enemies with the following rules If Yuzu has number of candies than enemy P i she wins the duel and Otherwise she loses the duel and gets nothing The candy which Yuzu gets will be used in the next duels Yuzu wants to How many valid permutations P exist This problem was easy and wasn t interesting for Akari who is a friend of Aoi And Akari made the following problem from the above idea Let s define f x as the number of valid permutations for the integer x You are given n a and p le n Let s call a positive integer x if the value f x is divisible by p Find good integers x Your task is to solve this problem made by Akari ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 2005;\nint n, p, cnt, maxi, a[Maxn], Ans[Maxn];\nint main()\n{\n\tscanf(""%d%d"", &n, &p);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(""%d"", &a[i]), maxi = max(maxi, a[i]);\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = 1; i <= maxi; i++)\n\t{\n\t\tint pnt = 1;\n\t\tlong long ans = 1;\n\t\tfor (int j = 1; j <= n; j++)\n\t\t{\n\t\t\twhile (pnt <= n && a[pnt] - j + 1 <= i) pnt++;\n\t\t\t(ans *= pnt - j) %= p;\n\t\t}\n\t\tif (ans) Ans[++cnt] = i;\n\t}\n\tprintf(""%d\\n"", cnt);\n\tfor (int i = 1; i <= cnt; i++)\n\t\tprintf(""%d "", Ans[i]);\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",1900,Let s define Yuzu should have at least candies initially to win all duels then for This is divisible by And if Yuzu have equal or more than candies initially any permutation will be valid then for This is divisible by too because Then in this subtask you should find whether each are divisible by for in You can find the value of by following simulation First let the number of enemies they have strictly less than candies Then do the following steps for the number of enemies they have exactly candies Now is a prime Then Whether is divisible by is Whether was multiplied to as at least once This can be simulated in time for each Total complexity 
Vasya has two arrays A and B of lengths n and m respectively He can perform the following operation arbitrary number of times possibly zero he takes some consecutive subsegment of the array and replaces it with a single element equal to the sum of all elements on this subsegment For example from the array 1 10 100 1000 10000 Vasya can obtain array 1 1110 10000 and from array 1 2 3 Vasya can obtain array 6 Two arrays A and B are considered equal if and only if they have the same length and for each valid i A i B i Vasya wants to perform some of these operations on array A some on array B in such a way that arrays A and B become equal Moreover the lengths of the resulting arrays should be maximal possible Help Vasya to determine the maximum length of the arrays that he can achieve or output that it is impossible to make arrays A and B equal ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nconst int N=303030;\nvoid build(){\n\n}\nLL n, a[N];\nLL m, b[N];\nvoid init(){\n  n=getint();\n  for(int i=0; i<n; i++) a[i]=getint();\n  m=getint();\n  for(int i=0; i<m; i++) b[i]=getint();\n}\nvoid solve(){\n  int ii=0, jj=0, ans=0;\n  LL si=0, sj=0;\n  while(ii<n or jj<m){\n    while(si==0 or (si != sj)){\n      if(si == 0 or si<sj){\n        if(ii >= n) break;\n        si+=a[ii++];\n        continue;\n      }\n      if(jj >= m) break;\n      sj+=b[jj++];\n    }\n    if(si==0 or (si != sj)){\n      puts(""-1"");\n      exit(0);\n    }\n    ans++;\n    si=sj=0;\n    if(ii == n and jj == m) break;\n  }\n  printf(""%d\\n"", ans);\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n']","[1, 0, 0, 0, 0]",1600,Let s prove that next greedy solution works each step we will find prefixes of minimal length of arrays such that its sums are equal and we will cut them forming next block If we will get valid partition in result so it is an optimal solution otherwise there is no solution Since length of prefix proportional to its sum so prefixes are minimal since its sums are minimal Let s prove this algorithm let optimal solution have alternative partition Since our solution cuts minimal possible prefixes so at some step optimal solution cuts prefix with greater sum and greater length But this prefixes in optimal solutions contain smaller prefixes found by greedy solution so it can be divided on two parts contradiction So we can keep prefixes and increase one which have smaller sum Result complexity is 
After the reunion dinner Little Tommy plays a game with the family Here is a concise introduction to this game There is a sequence of non negative integers in the beginning It is ruled that each integer in this sequence should be non negative You can select two integers in this sequence and and then decrease them by their minimum i e the cost of this operation is equal to We call such operation as a The game immediately ends when there are no two consecutive positive integers Your task is to end the game so that the total cost of your operations is as small as possible Obviously every game ends after at most descensions Please share your solution of this game with the lowest cost ,"['#include <iostream>#include <cstdio>#include <cstdlib>#include <algorithm>#include <cmath>#include <vector>#include <set>#include <map>#include <unordered_set>#include <unordered_map>#include <queue>#include <ctime>#include <cassert>#include <complex>#include <string>#include <cstring>using namespace std;\xa0#ifdef LOCAL\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)#else\t#define eprintf(...) 42#endif\xa0typedef long long ll;typedef pair<int, int> pii;#define mp make_pair\xa0const ll INF = (ll)1e16;const int N = 900300;const int K = 40;int n;ll a[N];ll sum[N];ll dp[N][2];int par[N][2][3];int intPoint[N];int m;vector<int> ans;\xa0ll getCost(int L, int R, int f1, int f2) {\tint len = R - L;\tif (len == 1) {\t\tif (a[L] == 0) return 0;\t\tif (f1 == 0 || f2 == 0) return -1;\t\treturn a[L];\t}\tif (len == 2) {\t\tif (a[L] == a[L + 1]) return 0;\t\tif (a[L] < a[L + 1]) {\t\t\tif (f2 == 0) return -1;\t\t\treturn abs(a[L + 1] - a[L]);\t\t} else {\t\t\tif (f1 == 0) return -1;\t\t\treturn abs(a[L + 1] - a[L]);\t\t}\t}\tif (f1 == 0 && a[L] > a[L + 1]) return -1;\tif (f2 == 0 && a[R - 1] > a[R - 2]) return -1;\tll cost = abs(sum[R] - sum[L]);\tif (len == 3) {\t\tif (a[L] + a[L + 2] <= a[L + 1]) return cost;\t\tif (f1 == 1 && f2 == 1) return cost;\t\tif (f1 == 0 && f2 == 0) return -1;\t\treturn cost;\t}\treturn cost;}\xa0void restoreAns(int L, int R, int f1, int f2) {\t//eprintf(""restore %d %d %d %d\\n"", L, R, f1, f2);\tint len = R - L;\tif (len == 1) {\t\treturn;\t}\tif (len == 2) {\t\tif (a[L] == 0 || a[L + 1] == 0) return;\t\tans.push_back(L);\t\treturn;\t}\tif (f1 == 0 && a[L] != 0 && a[L + 1] != 0) {\t\tll x = min(a[L], a[L + 1]);\t\tans.push_back(L);\t\ta[L] -= x;\t\ta[L + 1] -= x;\t}\tif (f2 == 0 && a[R - 1] != 0 && a[R - 2] != 0) {\t\tll x = min(a[R - 1], a[R - 2]);\t\tans.push_back(R - 2);\t\ta[R - 2] -= x;\t\ta[R - 1] -= x;\t}\tfor (int i = L; i < R - 1; i++) {\t\tif (a[i] != 0 && a[i + 1] != 0) {\t\t\tll x = min(a[i], a[i + 1]);\t\t\tans.push_back(i);\t\t\ta[i] -= x;\t\t\ta[i + 1] -= x;\t\t}\t}}\tint main(){//\tfreopen(""input.txt"", ""r"", stdin);//\tfreopen(""output.txt"", ""w"", stdout);\xa0\tscanf(""%d"", &n);\tfor (int i = 0; i < n; i++) {\t\tscanf(""%lld"", &a[i]);\t\tsum[i + 1] = sum[i];\t\tif (i % 2 == 0)\t\t\tsum[i + 1] += a[i];\t\telse\t\t\tsum[i + 1] -= a[i];\t}\tfor (int i = 0; i <= n; i++) {\t\tif (i < 5 || i > n - 5) {\t\t\tintPoint[m++] = i;\t\t\tcontinue;\t\t}\t\tif (a[i - 1] <= a[i - 2] || a[i] <= a[i + 1])\t\t\tintPoint[m++] = i;\t}\tfor (int i = 0; i <= m; i++)\t\tdp[i][0] = dp[i][1] = -INF;\tdp[0][0] = 0;\tdp[0][1] = 0;\tfor (int i = 0; i < m; i++)\t\tfor (int f1 = 0; f1 < 2; f1++) {\t\t\tif (dp[i][f1] < 0) continue;\t\t\tfor (int j = i + 1; j < min(m, i + K); j++) {\t\t\t\tfor (int f2 = 0; f2 < 2 - f1; f2++)\t\t\t\t\tfor (int f3 = 0; f3 < 2; f3++) {\t\t\t\t\t\tll cost = getCost(intPoint[i], intPoint[j], f2, f3);\t\t\t\t\t\tif (cost == -1) continue;\t\t\t\t\t\tif (dp[i][f1] + cost > dp[j][f3]) {\t\t\t\t\t\t\tdp[j][f3] = dp[i][f1] + cost;\t\t\t\t\t\t\tpar[j][f3][0] = i;\t\t\t\t\t\t\tpar[j][f3][1] = f1;\t\t\t\t\t\t\tpar[j][f3][2] = f2;\t\t\t\t\t\t}\t\t\t\t\t}\t\t\t}\t\t}\tint x = m - 1;\tint f = 0;\tif (dp[x][1] > dp[x][0])\t\tf = 1;\twhile(x > 0) {\t\trestoreAns(intPoint[par[x][f][0]], intPoint[x], par[x][f][2], f);\t\tint nx = par[x][f][0];\t\tf = par[x][f][1];\t\tx = nx;\t}\tprintf(""%d\\n"", (int)ans.size());\tfor (int y : ans)\t\tprintf(""%d\\n"", 1 + y);\xa0\treturn 0;}']","[0, 0, 0, 1, 0]",3200,Noticing that there are no two consecutive positive integers after the game ends the final sequence can be divided into some intervals which consist only zero elements such that the gap between every two adjacent intervals is at most one element may positive Let s try to solve a general version of this problem first In this version we don t need to decrease two consecutive positive integers by their minimum We can decrease any two consecutive integers by many times even if integers are negative and our task is to eliminate all two consecutive positive integers such that the cost as small as possible We can prove by contradiction or adjustment that there are no negative elements in the best solution for the general version because the original elements are non negative Furthermore the cost of the best solution for the general version is less or equal to that of the best solution for the original version Let s consider the cost for the general version to make such an interval i e become all non positive Before concluding the formula you may assume Let We can construct a series of operations to make them become non positive such that the cost can be represented as Let s call the cost of such an interval as Similarly we know the actual minimal cost is less or equal to If the length of an interval is greater than there is an observation that which implies any interval whose length is greater than can be replaced by the cases of length and We can easily prove that is the actual minimal cost in the cases of length and In addition if we get any of the best solutions for the general version we can construct a series of operations which is valid both in the general version and the original version So we can conclude that the cost of the best solution for the general version is greater or equal to that for the original version With one conclusion we mentioned above we know that the minimal costs for the original version and the general version are equivalent Denote as the minimum cost the first elements have used if the th element is going to be the right endpoint of such an interval It s easy to compute in After picking up all the intervals for the best solution construction can be implemented by greedy For example utilize the descensions at the inner of intervals first and then make use of the descensions at the edge of intervals Please note that there may be at most one element that belongs to no interval at the head or the tail of the final sequence Also the descensions should operate on integers 
You are given three integers x y and n Your task is to construct an array a consisting of n integers which satisfies the following conditions a 1 x a n y a is increasing i e a 1 a 2 ldots a n if we denote b i a i 1 a i for 1 leq i leq n 1 then b is decreasing i e b 1 b 2 ldots b n 1 If there is no such array a print a single integer 1 ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvoid nope()\n{\n\tprintf(""-1\\n"");\n}\n\nint tab[nax];\n\nvoid test()\n{\n\tint x, y, n;\n\tscanf(""%d%d%d"", &x, &y, &n);\n\tif (y<=x)\n\t{\n\t\tnope();\n\t\treturn;\n\t}\n\ttab[n]=y;\n\tfor (int i=n-1; i; i--)\n\t{\n\t\ttab[i]=tab[i+1]-(n-i);\n\t}\n\tif (tab[1]<x)\n\t{\n\t\tnope();\n\t\treturn;\n\t}\n\ttab[1]=x;\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(""%d "", tab[i]);\n\tprintf(""\\n"");\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[1, 1, 1, 0, 0]",800,TutorialWe use the following greedy construction For all set If we ve found a solution otherwise there is no solution Proof Assume there s a solution which includes an index such that We can make for all where After several processes like this we get a solution the same as greedy construction gives This leads to a contradiction 
Pasha loves to send strictly positive integers to his friends Pasha cares about security therefore when he wants to send an integer n he encrypts it in the following way he picks three integers a b and c such that l leq a b c leq r and then he computes the encrypted value m n cdot a b c Unfortunately an adversary intercepted the values l r and m Is it possible to recover the original values of a b and c from this information More formally you are asked to find values of a b and c such that a b and c are integers l leq a b c leq r there exists a strictly positive integer n such that n cdot a b c m ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n\nsigned main() {\n\tint t;\n\tcin >> t;\n\n\tfor(int x = 0; x < t; x++) {\n\t\tint l, r, m;\n\t\tcin >> l >> r >> m;\n\n\t\tbool ok = false;\n\t\tfor(int a = l; a <= r; a++) {\n\t\t\tfor(int n = max(1LL, (m + l - r) / a); n * a + l - r <= m; n++) {\n\t\t\t\tint diff = m - n * a;\n\n\t\t\t\tint b, c;\n\n\t\t\t\tc = r;\n\t\t\t\tb = diff + c;\n\t\t\t\tif(l <= b && b <= r && l <= c && c <= r) {\n\t\t\t\t\tcout << a << "" "" << b << "" "" << c << ""\\n"";\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tb = r;\n\t\t\t\tc = b - diff;\n\t\t\t\tif(l <= b && b <= r && l <= c && c <= r) {\n\t\t\t\t\tcout << a << "" "" << b << "" "" << c << ""\\n"";\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",1500,The task is to solve equation in integers where is some natural number and Note that the expression can take any value from and only these values Indeed if then if we denote we get A similar statement is true for So since it was necessary to solve the equation this is equivalent to solving the equation where Let s fix some arbitrary Then we find the maximum for which this will be equal to Let s check whether it is true that and If this is the case then restore and as indicated above This solution iterates over all possible values of and checks if such can be used in answer if the manner described above Thus this solution has complexity 
In this problem we will deal with binary strings Each character of a binary string is either a or a We will also deal with substrings recall that a substring is a contiguous subsequence of a string We denote the substring of string s starting from the l th character and ending with the r th character as s l dots r The characters of each string are numbered from 1 We can perform several operations on the strings we consider Each operation is to choose a substring of our string and replace it with another string There are two possible types of operations replace with or replace with For example if we apply exactly one operation to the string it can be transformed into or Binary string a is considered from binary string b if there exists a sequence s 1 s 2 s k such that s 1 a s k b and for every i in 1 k 1 s i can be transformed into s i 1 using exactly one operation Note that k can be equal to 1 i e You are given a string t and q queries to it Each query consists of three integers l 1 l 2 and len To answer each query you have to determine whether t l 1 dots l 1 len 1 is reachable from t l 2 dots l 2 len 1 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, ""MOD must be positive"");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<998244353>;\n\nnum A;\nnum B;\nnum C;\n\nint n;\nstring s;\n\nstruct info {\n\tint lc, rc;\n\tnum x, y;\n};\n\ninfo combine(info a, info b){\n\tif(a.lc == -1 && b.lc == -1){\n\t\treturn {-1, a.rc ^ b.rc, 0, 0};\n\t} else if(a.lc == -1){\n\t\treturn {a.rc ^ b.lc, b.rc, b.x, b.y};\n\t} else if(b.lc == -1){\n\t\treturn {a.lc, a.rc ^ b.rc, a.x, a.y};\n\t} else {\n\t\treturn {a.lc, b.rc, a.x + a.y * (((a.rc ^ b.lc) ? B : C) + A * b.x), a.y * b.y * A};\n\t}\n}\n\nstruct node {\n\tnode *l, *r;\n\tinfo a;\n};\n\nnode* build(int lx, int rx){\n\tnode* x = new node();\n\tif(lx == rx){\n\t\tx->l = x->r = nullptr;\n\t\tif(s[lx] == \'0\'){\n\t\t\tx->a = {0, 0, 0, 1};\n\t\t} else {\n\t\t\tx->a = {-1, 1, 0, 0};\n\t\t}\n\t} else {\n\t\tx->l = build(lx, (lx + rx) / 2);\n\t\tx->r = build((lx + rx) / 2 + 1, rx);\n\t\tx->a = combine(x->l->a, x->r->a);\n\t}\n\treturn x;\n}\n\ninfo query(node* v, int lx, int rx, int qlx, int qrx){\n\tif(rx < qlx || qrx < lx) return {-1, 0, 0, 0};\n\tif(qlx <= lx && rx <= qrx) return v->a;\n\treturn combine(query(v->l, lx, (lx + rx)/2, qlx, qrx), query(v->r, (lx+rx)/2 + 1, rx, qlx, qrx));\n}\n\nbool equal(info a, info b){\n\tif(a.lc == -1 && b.lc == -1) return true;\n\treturn (a.lc == b.lc) && (a.rc == b.rc) && (a.x == b.x) && (a.y == b.y);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tA = rng();\n\tB = rng();\n\tC = rng();\n\tcin >> n >> s;\n\tnode* segtree = build(0, n-1);\n\tint q;\n\tcin >> q;\n\tfor(int i = 0; i < q; i++){\n\t\tint a, b, l;\n\t\tcin >> a >> b >> l;\n\t\ta--; b--;\n\t\tbool ans = equal(query(segtree, 0, n-1, a, a+l-1), query(segtree, 0, n-1, b, b+l-1));\n\t\tcout << (ans ? ""YES"" : ""NO"") << \'\\n\';\n\t}\n}']","[0, 0, 0, 0, 1]",2500,How to determine if two strings can be transformed into each other Obviously the number of ones in both strings should be the same Also the following invariant holds if all pairs of consecutive ones are deleted the positions of remaining ones are not affected by any operations We can prove that these conditions are sufficient if we move all pairs of ones to the end of the string the strings are the same if the positions of ones are the same and the number of characters is the same moving all pairs of ones to the end of the string is almost the same as deleting them One of the possible solutions is the following build a segment tree where each vertex should maintain the number of deleted pairs of ones the hash of positions of the remaining ones the characters at the ends of the corresponding segment we need these to delete pairs of consecutive ones if they appear as a result of merging the segments When merging a pair of vertices we check if we have to delete a pair of consecutive ones and rebuild the hash for the new vertex There are lots of other approaches including a deterministic one which uses suffix structures 
You are given a list of n integers You can perform the following operation you choose an element x from the list erase x from the list and subtract the value of x from all the remaining elements Thus in one operation the length of the list is decreased by exactly 1 Given an integer k k 0 find if there is some sequence of n 1 operations such that after applying the operations the only remaining element of the list is equal to k ,"['#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::set s(a.begin(), a.end());\n    for (int i = 0; i < n; i++) {\n        if (s.count(a[i] + k)) {\n            std::cout << ""YES\\n"";\n            \n            return;\n        }\n    }\n    \n    std::cout << ""NO\\n"";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}']","[1, 1, 0, 0, 1]",1100,Note that after deleting element all numbers in the set are of the form since the previous substractions are cancelled Therefore the final element will be the difference between the last element and the previous element which was erased So we just need to check if is the difference of two elements in the set which can be done by sorting and using the double pointer technique in time 
Leha and Noora decided to go on a trip in the Baltic States As you know from the previous problem Leha has lost his car on the parking of the restaurant Unfortunately requests to the watchman didn t helped hacker find the car so friends decided to go hitchhiking In total they intended to visit towns However it turned out that sights in th town are open for visitors only on days from to What to do Leha proposed to choose for each town a day when they will visit this town i e any integer in interval After that Noora choses some subsequence of towns which friends are going to visit that at first they are strictly increasing i e is for all integers from to but also the dates of the friends visits are strictly increasing i e is true for all integers from to Please help Leha and Noora in choosing such for each town and such subsequence of towns so that friends can visit maximal number of towns You may assume that Leha and Noora can start the trip any day ,"['//PRZEMYSL ASSERTY\n\n//SPRAWDZ CORNER CASE\'Y, MINIMALNE I MAKSYMALNE WEJCIE I WYJCIE\n\n//MODULO = 1\n\n//while (clock()<=69*CLOCKS_PER_SEC)\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nconst int inf=1000*1000*1007;\n\nstruct node\n{\n\tint id;\n\tint roz;\n\tint prior;\n\tnode * lew;\n\tnode * pra;\n\tnode * oj;\n\t\n\tlong long narz;\n\tlong long war;\n\t\n\tnode(int idid)\n\t{\n\t\tprior=rand();\n\t\tlew=NULL;\n\t\tpra=NULL;\n\t\toj=NULL;\n\t\troz=1;\n\t\tid=idid;\n\t\tnarz=0;\n\t\twar=inf;\n\t}\n\tnode()\n\t{\n\t\tprior=rand();\n\t\tlew=NULL;\n\t\tpra=NULL;\n\t\toj=NULL;\n\t\troz=1;\n\t\tnarz=0;\n\t\twar=inf;\n\t}\n};\ninline void update(node * v)\n{\n\tif (v==NULL)\n\t\treturn;\n\tv->roz=1;\n\tv->war+=v->narz;\n\tif (v->lew!=NULL)\n\t{\n\t\tv->lew->narz+=v->narz;\n\t\tv->roz+=v->lew->roz;\n\t}\n\tif (v->pra!=NULL)\n\t{\n\t\tv->pra->narz+=v->narz;\n\t\tv->roz+=v->pra->roz;\n\t}\n\tv->narz=0;\n\t//tutaj dodajemy wszystkie operacje zwizane z funkcjami m.in. drzewa przedziaowego, tzn. lazy propagation itp.\n}\nnode * merge(node * v, node * u)\n{\n\tif (v==NULL)\n\t\treturn u;\n\tif (u==NULL)\n\t\treturn v;\n\tif ((v->prior)>=(u->prior))\n\t{\n\t\tupdate(v);//czasem mona usun\n\t\tv->pra=merge(v->pra, u);\n\t\tif (v->pra!=NULL)\n\t\t\tv->pra->oj=v;\n\t\tupdate(v);\n\t\treturn v;\n\t}\n\telse\n\t{\n\t\tupdate(u);//czasem mona usun\n\t\tu->lew=merge(v, u->lew);\n\t\tif (u->lew!=NULL)\n\t\t\tu->lew->oj=u;\n\t\tupdate(u);\n\t\treturn u;\n\t}\n}\npair <node *, node *> split(node * v, const function <bool(node*)> &is_left)//is_left ma stwierdza, czy dany wierzchoek powinien by w lewej czci\n{\n\tif (v==NULL)\n\t\treturn make_pair(v, v);\n\tpair <node *, node *> ret;\n\tupdate(v);//czasem mona usun\n\tv->oj=NULL;\n\tif (is_left(v))\n\t{\n\t\tret=split(v->pra, is_left);\n\t\tv->pra=ret.first;\n\t\tif (v->pra!=NULL)\n\t\t\tv->pra->oj=v;\n\t\tret.first=v;\n\t}\n\telse\n\t{\n\t\tret=split(v->lew, is_left);\n\t\tv->lew=ret.second;\n\t\tif (v->lew!=NULL)\n\t\t\tv->lew->oj=v;\n\t\tret.second=v;\n\t}\n\tupdate(v);\n\treturn ret;\n}\nint gl_help;\nfunction <bool(node*)> cut_v(int v)//ucnina v pierwszych elementow\n{\n\tgl_help=v;\n\treturn [](node* u)->bool\n\t{\n\t\tint pom=1;\n\t\tif (u->lew!=NULL)\n\t\t\tpom+=u->lew->roz;\n\t\tif (pom>gl_help)\n\t\t\treturn false;\n\t\tgl_help-=pom;\n\t\treturn true;\n\t};\n}\nfunction <bool(node*)> cut_cos(int v)//ucnina v pierwszych elementow - kuamstfo\n{\n\tgl_help=v;\n\treturn [](node* u)->bool\n\t{\n\t\tupdate(u);\n\t\treturn u->war<gl_help;\n\t};\n}\n\nint n;\n\nnode *korz=NULL;\n\nint main()\n{\n\tkorz=new node();\n\tkorz->war=0;\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=n+3; i++)\n\t{\n\t\tnode *tu=new node;\n\t\tkorz=merge(korz, tu);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tauto jed=split(korz, cut_cos(l));\n\t\tauto dwa=split(jed.second, cut_cos(r));\n\t\tauto trz=split(dwa.second, cut_v(1));\n\t\ttrz.first->narz=0;\n\t\ttrz.first->war=l;\n\t\tif (dwa.first!=NULL)\n\t\t\tdwa.first->narz++;\n\t\tkorz=merge(jed.first, merge(trz.first, merge(dwa.first, trz.second)));\n\t}\n\tauto jed=split(korz, cut_cos(inf-1));\n\tprintf(""%d\\n"", jed.first->roz-1);\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1]",2900,Let minimal number that can be last in strictly increasing subsequence with length Iterate through prefixes of intervals and maintain this dp Obviously this dp is strictly increasing What happens when we add new interval In the rightmost position such that we can make a transion Since the rightmost position than this i e Let the rightmost position such that the for each we can make a transition But since than so this Thinking from the facts above we can solve this task maintaining dp in cartesian tree treap Let s find and split interval from to Add to every number in this tree Delete t node And merge everything adding one more node with key 
Vasya is developing his own programming language VPL Vasya Programming Language Right now he is busy making the system of exceptions He thinks that the system of exceptions must function like that The exceptions are processed by try catch blocks There are two operators that work with the blocks The operator It opens a new try catch block The operator It closes the try catch block that was started last and haven t yet been closed This block can be activated only via exception of type exception type When we activate this block the screen displays the message If at the given moment there is no open try catch block then we can t use the operator The exceptions can occur in the program in only one case when we use the operator The operator creates the exception of the given type Let s suggest that as a result of using some operator the program created an exception of type In this case a try catch block is activated such that this block s operator was described in the program earlier than the used operator Also this block s operator was given an exception type as a parameter and this block s operator is described later that the used operator If there are several such try catch blocks then the system activates the block whose operator occurs earlier than others If no try catch block was activated then the screen displays message To test the system Vasya wrote a program that contains only and operators one line contains no more than one operator the whole program contains exactly one operator Your task is given a program in VPL determine what message will be displayed on the screen ,"['#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <cstddef>\n#include <algorithm>\n#include <utility>\n#include <iterator>\n#include <numeric>\n#include <list>\n#include <complex>\n#include <cstdio>\n#include <climits>\n#include <iostream>\n#include <fstream>\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef pair<int, int> pii;\n\n#define RA(x) (x).begin(), (x).end()\n#define FE(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); i++)\n#define SZ(x) ((int) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << ""Failed to open \'"" << argv[1] << ""\'"" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << ""Failed to open \'"" << argv[2] << ""\'"" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n\n    int N;\n    cin >> N >> ws;\n\n    stack<int> es;\n    int th = -1;\n    string tp;\n    for (int i = 0; i < N; i++)\n    {\n        string line;\n        getline(cin, line);\n        replace(RA(line), \'(\', \' \');\n        replace(RA(line), \')\', \' \');\n        replace(RA(line), \',\', \' \');\n        istringstream toks(line);\n\n        string cmd;\n        toks >> cmd;\n        if (cmd == ""try"")\n        {\n            es.push(i);\n        }\n        else if (cmd == ""throw"")\n        {\n            toks >> tp;\n            th = i;\n        }\n        else if (cmd == ""catch"")\n        {\n            string t;\n            toks >> t;\n            if (t == tp && es.top() < th)\n            {\n                string msg;\n                getline(toks, msg);\n                msg.erase(0, msg.find(\'""\') + 1);\n                msg.erase(msg.find(\'""\'), msg.size());\n                cout << msg << \'\\n\';\n                return 0;\n            }\n            es.pop();\n        }\n    }\n    cout << ""Unhandled Exception\\n"";\n\n    return 0;\n}\n']","[0, 0, 1, 0, 0]",1800,In this problem you was to implement what was writen in the statement In my solution I did the following Erase all spaces from the text except spaces in messages in try catch blocks Then when we get word try we put number of the new try catch block in stack When we get word throw we remember it s type and current state of stack that is what try catch blocks are opened For example put these number in set When we get word catch if it s type equals to type of operator throw and the number of current try catch block is in your set then write the answer now else erase this try catch block from stack If there was no suitable try catch block write Unhandled Exception 
Monocarp is playing a computer game He s going to kill n monsters the i th of them has h i health Monocarp s character has two spells either of which he can cast an arbitrary number of times possibly zero and in an arbitrary order choose exactly two alive monsters and decrease their health by 1 choose a single monster and kill it When a monster s health becomes 0 it dies What s the minimum number of spell casts Monocarp should perform in order to kill all monsters ,"['#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<\'0\'||ch>\'9\')\n\t{\n\t\tif(ch==\'-\')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>=\'0\'&&ch<=\'9\')\n\t{\n\t\tn=n*10+ch-\'0\';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint a[500005];\nsigned main()\n{\n\tint t,n,sl;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tsl=0;\n\t\tfor(int i=1;i<=n;i++)a[i]=read(),sl+=(a[i]==1);\n\t\tprintf(""%d\\n"",n-sl/2);\n\t}\n\treturn 0;\n}']","[1, 0, 0, 0, 0]",800,The first spell looks pretty weak compared to the second spell Feels like you almost always replace one with another Let s show that you can totally avoid casting the spell of the first type twice or more on one monster Let the two first spell casts be and for some monsters and You can replace them by a cast of the second spell on and a cast of the first spell on That would deal even more damage to and the same amount to and The number of casts doesn t change Thus it only makes sense to use the first spell on monsters with health Calculate the number of them kill the full pairs of them with the first spell and use the second spell on the remaining monsters Overall complexity per testcase 
def myred1 color red underline bf 1 def myblue1 color blue overline bf 1 def RED myred Red def BLUE myblue Blue You are given a sequence of n non negative integers a 1 a 2 ldots a n Initially all the elements of the sequence are unpainted You can paint each number RED or BLUE but not both or For a color c text Count c is the number of elements in the sequence painted with that color and text Sum c is the sum of the elements in the sequence painted with that color For example if the given sequence is 2 8 6 3 1 and it is painted this way myblue 2 8 myred 6 myblue 3 1 where 6 is painted red 2 and 3 are painted blue 1 and 8 are unpainted then text Sum RED 6 text Sum BLUE 2 3 5 text Count RED 1 and text Count BLUE 2 Determine if it is possible to paint the sequence so that text Sum RED text Sum BLUE and text Count RED text Count BLUE ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int t;\n    for (cin >> t; t; t -= 1) {\n        int n;\n        cin >> n;\n        vector<LL> a(n);\n        for (LL& x : a) cin >> x;\n        ranges::sort(a);\n        LL s = 0;\n        for (int i = 0; i < (n - 1) / 2; i += 1)\n            s += a[n - i - 1];\n        for (int i = 0; i < (n - 1) / 2 + 1; i += 1)\n            s -= a[i];\n        cout << (s > 0 ? ""YES\\n"" : ""NO\\n"");\n    }\n    return 0;\n}']","[1, 0, 0, 0, 0]",800,Suppose If a solution exists then there is one with because if there are more than numbers painted blue we can remove some of them until we have exactly numbers and the sum of these numbers will be smaller As we want to hold the optimal way to paint the numbers is to paint the largest numbers red and the smallest numbers blue So to solve the problem it is enough to sort the sequence iterate over the value of and for each of them compute the sum of the largest numbers the sum of the smallest numbers and compare them This can be done efficiently by computing the sum of every prefix and suffix of the sorted sequence in linear time This way we can make a constant number of operations for each Intended complexity 
A bitstring is a string consisting only of the characters and A bitstring is called k if every substring of size k of this bitstring has an equal amount of and characters frac k 2 of each You are given an integer k and a string s which is composed only of characters and You need to determine whether you can make a k balanced bitstring by replacing every characters in s with either or A string a is a substring of a string b if a can be obtained from b by deletion of several possibly zero or all characters from the beginning and several possibly zero or all characters from the end ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<"" ""<<#x<<"" ""<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<""{""<<p.a<<"",""<<p.b<<""}"";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<""{"";\n\tfor(auto e:v)os<<e<<"","";\n\treturn os<<""}"";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<"" "";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<"","";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<""{"";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<""}"";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<""\\n"";\n\tif(suc==2)\n\t\tcout<<"" "";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\npi readpi(int off=0){\n\tint a,b;cin>>a>>b;\n\treturn pi(a+off,b+off);\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""YES""<<""\\n"";\n\t#else\n\tcout<<""Yes""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""NO""<<""\\n"";\n\t#else\n\tcout<<""No""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""POSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Possible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<""IMPOSSIBLE""<<""\\n"";\n\t#else\n\tcout<<""Impossible""<<""\\n"";\n\t#endif\n\tif(ex)exit(0);\n\t#ifdef LOCAL\n\tcout.flush();\n\t#endif\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nvvc<int> readGraph(int n,int m){\n\tvvc<int> g(n);\n\trep(i,m){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\t//sc.read(a,b);\n\t\ta--;b--;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\treturn g;\n}\n\nvvc<int> readTree(int n){\n\treturn readGraph(n,n-1);\n}\n\nvoid slv(){\n\tint n,k;cin>>n>>k;\n\tstring s;cin>>s;\n\tvc<char> det(k,\'?\');\n\trep(i,n){\n\t\tif(s[i]!=\'?\'){\n\t\t\tint j=i%k;\n\t\t\tif(det[j]==\'?\'||det[j]==s[i]){\n\t\t\t\tdet[j]=s[i];\n\t\t\t}else{\n\t\t\t\treturn no(0);\n\t\t\t}\n\t\t}\n\t}\n\tint cnt[2]{};\n\trep(i,k)if(det[i]!=\'?\')\n\t\tcnt[det[i]-\'0\']++;\n\tif(max(cnt[0],cnt[1])<=k/2)yes(0);\n\telse no(0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint t;cin>>t;rep(_,t)slv();\n}\n']","[0, 0, 1, 0, 0]",1500,You were given a bracket sequence s consisting of brackets of two kinds You were to find regular bracket sequence that was a substring of s and contains as many braces as possible We will try to determine corresponding closing bracket for every opening one Formally let a bracket on the i th position be opening then the closing bracket on the position j is corresponding to it if and only if a substring si sj is the shortest regular bracket sequence that begins from the i th position In common case there can be brackets with no corresponding ones We scan the sting s and put positions with the opening brackets into a stack Let us proceed the i th position If si is an opening bracket we simply put i on the top of the stack Otherwise we have to clean the stack if the stack is empty or the bracket on the top does not correspond to the current one But if the bracket on the top is ok we just remove the top of the stack and remember that the bracket on position i is corresponding to the bracket removed from the top So we find all the correspondings for all the brackets Then we can split s into blocks Let block be a segment l r such that the bracket on the r th position is corresponding for the bracket on the i th and there is no couple of corresponding brackets on positions x and y such that and l r x y It is easy to understand that the blocks do not intersect and the split is unique We can join the consequent blocks into the regular bracket sequences We should join as many blocks as possible in order to get the maximal number of braces We get several substrings that are regular bracket sequences after we join all the consecutive blocks The answer is the substring that has the largest amount of braces The complexity is O s 
For a given positive integer denote its rounding as the minimum positive integer such that ends with or more zeros in base and is divisible by For example rounding of is is the minimum integer such that it ends with or more zeros and is divisible by Write a program that will perform the rounding of ,"['#include <bits/stdc++.h>\nusing namespace std;\n// pulkit kapoor\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <cassert>\nusing namespace std; \n#define DEBUG(numx) cout << \'>\' << #numx << \':\' << numx << endl;\n#define REP(idx1,num1) for(int idx1=0;idx1<(num1);idx1++)\n#define FOR(idx1,num1,bin) for(int idx1=(num1);idx1<=(bin);idx1++)\n#define FORD(idx1,num1,bin) for(int idx1=(num1);idx1>=(bin);idx1--)\ninline bool EQ(double num1, double bin) { return fabs(num1-bin) < 1e-9; }\nconst int INF = 1<<29;\ntypedef long long ll;\ninline int two(int num1) { return 1 << num1; }\ninline int test(int num1, int bin) { return (num1>>bin)&1; }\ninline void set_bit(int & num1, int bin) { num1 |= two(bin); }\ninline void unset_bit(int & num1, int bin) { num1 &= ~two(bin); }\ninline int last_bit(int num1) { return num1 & (-num1); }\ninline int ones(int num1) { int res = 0; while(num1 && ++res) num1-=num1&(-num1); return res; }\ntemplate<class T> void chmax(T & num1, const T & bin) { num1 = max(num1, bin); }\ntemplate<class T> void chmin(T & num1, const T & bin) { num1 = min(num1, bin); }\n#define SZ(num1) (int)(num1.size())\n#define SET(num1,bin) memset(num1,bin,sizeof(num1))\n#define LET(numx,num1) __typeof(num1) numx(num1)\n#define TR(vecc,it) for( LET(it,vecc.begin()) ; it != vecc.end() ; it++)\n#define repi(idx1,num1) for(int idx1=0; idx1<(int)num1;idx1++)\n#define si(num1) scanf(""%d"",&num1)\n#define sll(num1) scanf(""%lld"",&num1)\n#define DRT()  int test; cin>>test; while(test--)\n#define io ios_base::sync_with_stdio(false);cin.tie(NULL);\n#define ll long long\n#define TRACE\n \n//FILE *fin = freopen(""in"",""r"",stdin);\n//FILE *fout = freopen(""out"",""s2numx"",stdout);\n \n \n#ifdef TRACE\n#define trace1(numx)                cerr << #numx << "": "" << numx << endl;\n#define trace2(numx, to)             cerr << #numx << "": "" << numx << "" | "" << #to << "": "" << to << endl;\n#define trace3(numx, to, nn3)          cerr << #numx << "": "" << numx << "" | "" << #to << "": "" << to << "" | "" << #nn3 << "": "" << nn3 << endl;\n#define trace4(num1, bin, ch, d)       cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << endl;\n#define trace5(num1, bin, ch, d, e)    cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << "" | "" << #e << "": "" << e << endl;\n#define trace6(num1, bin, ch, d, e, det) cerr << #num1 << "": "" << num1 << "" | "" << #bin << "": "" << bin << "" | "" << #ch << "": "" << ch << "" | "" << #d << "": "" << d << "" | "" << #e << "": "" << e << "" | "" << #det << "": "" << det << endl;\n \n#else\n \n#define trace1(numx)\n#define trace2(numx, to)\n#define trace3(numx, to, nn3)\n#define trace4(num1, bin, ch, d)\n#define trace5(num1, bin, ch, d, e)\n#define trace6(num1, bin, ch, d, e, det)\n \n#endif\n #define ll long long\n#define pi(numx) printf(""%d\\num1"",numx)\n#define F first\n#define pb push_back\n#define mp make_pair\n#define cp int testCases;cin >> testCases; for(int test = 1 ; test <= testCases; test++)\ntypedef pair<int,int> PII;\ntypedef pair<ll,ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<PII> VPII;\n#define mdd 1000000007\n\n\nint main() {\n\tll num1,num2;\n\tcin >> num1 >> num2;\n\tll kent1 = 1LL;\n\tfor (int i = 1 ; i <= num2 ; i++)\n\t\tkent1 *= 10LL;\n\tll result = __gcd(kent1,num1);\n\tcout << kent1 / result * num1 << endl;\n\treturn 0;\n}\n ']","[0, 1, 0, 0, 0]",1100,Notice that the number x ends with k or more zeros if the maximal power of 2 that is a divisor of x is at least k and the maximal power of 5 that is a divisor of x is at least k Let s calculate the maximal powers of 2 and 5 that are divisors of n If any of the powers is less than k then multiply the number by appropriate number of 2 and 5 The answer is also LCM n 10k 
You are given an n times m grid Each grid cell is filled with a unique integer from 1 to nm so that each integer appears exactly once In one operation you can choose an arbitrary cycle of the grid and move all integers along that cycle one space over Here a cycle is any sequence that satisfies the following conditions There are at least four squares Each square appears at most once Every pair of adjacent squares and also the first and last squares share an edge For example if we had the following grid We can choose an arbitrary cycle like this one To get the following grid In this particular case the chosen cycle can be represented as the sequence 1 2 3 6 5 8 7 4 the numbers are in the direction that we want to rotate them in Find any sequence of operations to sort the grid so that the array created by concatenating the rows from the highest to the lowest is sorted look at the first picture above Note you do not need to minimize number of operations or sum of cycle lengths The only constraint is that the sum of all cycles lengths must not be greater than 10 5 We can show that an answer always exists under the given constraints Output any valid sequence of moves that will sort the grid ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=107;\n\nint n, m;\n\nint tab[nax][nax];\nint musz[nax][nax];\n\nvector <vi> wyn;\n\npii fast[nax*nax];\n\ninline pii gdz(const int &v)\n{\n\treturn fast[v];\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tif (tab[i][j]==v)\n\t\t\t\treturn {i, j};\n\tassert(0);\n}\n\ninline int &war(const pii &v)\n{\n\treturn tab[v.first][v.second];\n}\n\nvoid zrob(const vi &wek)\n{\n\tvector <pii> poz(wek.size());\n\t//~ for (int i : wek)\n\t\t//~ poz.push_back(gdz(i));\n\tfor (int i=0; i<(int)wek.size(); i++)\n\t\tpoz[i]=gdz(wek[i]);\n\t//~ debug() << poz;\n\tfor (int i=(int)poz.size()-1; i>0; i--)\n\t{\n\t\tpii a=poz[i];\n\t\tpii b=poz[i-1];\n\t\tswap(tab[a.first][a.second], tab[b.first][b.second]);\n\t\tswap(fast[tab[a.first][a.second]], fast[tab[b.first][b.second]]);\n\t\t\n\t\t//~ swap(war(poz[i]), war(poz[i-1]));\n\t\t//~ swap(fast[war(poz[i])], fast[war(poz[i-1])]);\n\t}\n\twyn.push_back(wek);\n}\n\nvoid cofnij()\n{\n\tassert(!wyn.empty());\n\tvi wez=wyn.back();\n\treverse(wez.begin(), wez.end());\n\tzrob(wez);\n\twyn.pop_back();\n\twyn.pop_back();\n}\n\nvi daj_kwa(pii v)\n{\n\tvi ret;\n\tret.push_back(tab[v.first][v.second]);\n\tret.push_back(tab[v.first][v.second+1]);\n\tret.push_back(tab[v.first+1][v.second+1]);\n\tret.push_back(tab[v.first+1][v.second]);\n\treturn ret;\n}\n\nvi daj_kwa2(pii v)\n{\n\tvi ret=daj_kwa(v);\n\treverse(ret.begin(), ret.end());\n\treturn ret;\n}\n\nint chce[nax*nax];\n\nvi los(int a, int b)\n{\n\t//~ if (rand()&1)\n\t//~ {\n\t\tif (rand()&1)\n\t\t\treturn daj_kwa({a+(rand()&1), b+(rand()&1)});\n\t\telse\n\t\t\treturn daj_kwa2({a+(rand()&1), b+(rand()&1)});\n\t//~ }\n}\n\nvoid solve(int a, int b, int lim)\n{\n\twhile(1)\n\t{\n\t\tfor (int h=0; h<lim/4; h++)\n\t\t{\n\t\t\tint czy=1;\n\t\t\tfor (int i=0; i<3 && czy; i++)\n\t\t\t\tfor (int j=0; j<3 && czy; j++)\n\t\t\t\t\tif (chce[musz[a+i][b+j]] && musz[a+i][b+j]!=tab[a+i][b+j])\n\t\t\t\t\t\tczy=0;\n\t\t\tif (czy)\n\t\t\t\treturn;\n\t\t\tzrob(los(a, b));\n\t\t}\n\t\t\n\t\t\n\t\tfor (int i=0; i<lim/4; i++)\n\t\t\tcofnij();\n\t}\n}\n\nint przelicz()\n{\n\tint ret=0;\n\tfor (vi i : wyn)\n\t\tret+=i.size();\n\treturn ret;\n}\n\nbool mniej(pii a, pii b)\n{\n\treturn a.second>b.second;\n}\n\nconst int magic=1200;\n\nint main()\n{\n\tscanf(""%d%d"", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=m; j++)\n\t\t{\n\t\t\tmusz[i][j]=m*(i-1)+j;\n\t\t\tscanf(""%d"", &tab[i][j]);\n\t\t\tfast[tab[i][j]]={i, j};\n\t\t}\n\t}\n\tint pn=n;\n\twhile(pn>3)\n\t{\n\t\t//~ debug() << ""a"";\n\t\tfor (int i=m; i>1; i--)\n\t\t{\n\t\t\tint tutaj=musz[pn][i];\n\t\t\twhile(gdz(tutaj)!=make_pair(pn, i))\n\t\t\t{\n\t\t\t\tpii x=gdz(tutaj);\n\t\t\t\tif (x.second!=i)\n\t\t\t\t{\n\t\t\t\t\tif (x.second<i)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (x.first<pn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa(x));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa2({x.first-1, x.second}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (x.first<pn-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa2({x.first, x.second-1}));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tzrob(daj_kwa({x.first-1, x.second-1}));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzrob(daj_kwa({x.first, x.second-1}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint tutaj=musz[pn][1];\n\t\twhile(gdz(tutaj).first<pn-1)\n\t\t{\n\t\t\tpii x=gdz(tutaj);\n\t\t\tif (x.second>1)\n\t\t\t{\n\t\t\t\tzrob(daj_kwa({x.first, x.second-1}));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tzrob(daj_kwa2(x));\n\t\t\t}\n\t\t}\n\t\twhile(gdz(tutaj).second>3)\n\t\t{\n\t\t\tpii x=gdz(tutaj);\n\t\t\tzrob(daj_kwa({x.first-1, x.second-1}));\n\t\t}\n\t\t\n\t\tchce[musz[pn][1]]=chce[musz[pn][2]]=chce[musz[pn][3]]=1;\n\t\tsolve(pn-2, 1, magic);\n\t\tpn--;\n\t}\n\t\n\tint pm=m;\n\twhile(pm>3)\n\t{\n\t\tvector <pii> poz;\n\t\tfor (int i=1; i<=3; i++)\n\t\t\tpoz.push_back(gdz(musz[i][pm]));\n\t\tsort(poz.begin(), poz.end(), mniej);\n\t\tint czy=0;\n\t\tfor (int i=0; i<3; i++)\n\t\t{\n\t\t\tif (poz[i].second>=pm-i)\n\t\t\t\tcontinue;\n\t\t\tczy=1;\n\t\t\tpii x=poz[i];\n\t\t\tif (x.first==1)\n\t\t\t\tzrob(daj_kwa(x));\n\t\t\telse\n\t\t\t\tzrob(daj_kwa2({x.first-1, x.second}));\n\t\t\tbreak;\n\t\t}\n\t\tif (czy)\n\t\t\tcontinue;\n\t\t\n\t\tchce[musz[1][pm]]=chce[musz[2][pm]]=chce[musz[3][pm]]=1;\n\t\tsolve(1, pm-2, magic);\n\t\tpm--;\n\t}\n\tint resz=99*1000-przelicz();\n\tfor (int i=1; i<=3; i++)\n\t\tfor (int j=1; j<=3; j++)\n\t\t\tchce[musz[i][j]]=1;\n\tsolve(1, 1, resz);\n\t\n\t//~ for (int i=1; i<=n; i++)\n\t\t//~ debug() << range(tab[i]+1, tab[i]+1+m);\n\t\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tassert(musz[i][j]==tab[i][j]);\n\tdebug() << imie(przelicz());\n\t\n\t//~ return 0;\n\tprintf(""%d\\n"", (int)wyn.size());\n\tfor (vi i : wyn)\n\t{\n\t\tprintf(""%d"", (int)i.size());\n\t\tfor (int j : i)\n\t\t\tprintf("" %d"", j);\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 0]",3100,The solution is more of a coding one than an algorithmic one There are many different approaches and it s important to be careful in how it is implemented I ll explain one of the implementations First we can always move a particular block left up down or right with an appropriate 2x2 square around it Let s code some functions that let us do that for each direction Next is to make sure that these moves don t mess up previous block spaces as we move blocks to the correct place We can almost place blocks correctly in their spaces one by one in row major order but there are some special cases We can do all blocks except the last two rows which we ll handle separately in paragraph below For each row we can correctly place all blocks except the last one The last one requires a bit more careful work but is easy to handle if we have at least two free rows For the last two rows we can fill it in column by column from left to right This is a similar startegy to fitting in the last column of the previous rows We can almost do this except for the last 2x2 square For the last 2x2 square we can use the following sequence of moves to swap two blocks 123456413526421563213456Thus we can shift the last block into the right position then do at most three swaps using the above sequence of moves to fix the remaining blocks The number of moves for this strategy can be computed and estimated to be about 50k in the worst case 
Vasya and Kolya play a game with a string using the following rules Initially Kolya creates a string consisting of small English letters and uniformly at random chooses an integer from a segment He tells Vasya this string and then shifts it letters to the left i e creates a new string Vasya does not know the integer nor the string but he wants to guess the integer To do this he asks Kolya to tell him the first letter of the new string and then after he sees it open one more letter on some position which Vasya can choose Vasya understands that he can t guarantee that he will win but he wants to know the probability of winning if he plays optimally He wants you to compute this probability Note that Vasya wants to know the value of uniquely it means that if there are at least two cyclic shifts of that fit the information Vasya knowns Vasya loses Of course at any moment of the game Vasya wants to maximize the probability of his win ,"['#include <bits/stdc++.h>\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing namespace std;\n\nconst int MAXN = 5001;\n\nvector<int> p[MAXN];\n\nint main() {\n#ifdef BZ\n    freopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cout.setf(ios::fixed); cout.precision(20); cout.tie(nullptr); cin.tie(nullptr);\n    string s;\n    cin >> s;\n    int n = s.length();\n    string t = s + s;\n\n    for (int i = 0; i < n; ++i) {\n        p[s[i] - \'a\'].push_back(i);\n    }\n\n    int ans = 0;\n\n    for (int i = 0; i < 26; ++i) {\n        int mx = 0;\n\n        for (int j = 0; j < n; ++j) {\n            vector<int> cn(26, 0);\n            for (int x : p[i]) {\n                ++cn[t[x + j] - \'a\'];\n            }\n\n            int cur = 0;\n            for (int y : cn) {\n                cur += (y == 1);\n            }\n\n            mx = max(mx, cur);\n        }\n\n        ans += mx;\n    }\n\n    cout << ld(ans) / n << ""\\n"";\n}']","[0, 0, 1, 0, 0]",1600,Let s consider all possible c1 that will be first in t Then let s consider all possible numbers of second letter that Vasya will ask about this will be d If pair of letters c1 c2 occurs only once at d distance than if c2 opens second time Vasya will be able to determine shift Solution Let s loop through all letters at d distance from all c1 letters and for each symbol c2 we will calculate number of such letters This can be done in O cnt c1 where cnt c1 is number of letters c1 in initial string Now if we fix such d after opening c1 that maximizes number of unique pairs we will name it p c1 c2 at d distance this will be optimal d and conditional probability of victory in situation of fixed c1 equals p cnt c1 Now we only need to sum up conditional probabilities for different c1 Probability of c1 equals cnt c1 n thus answer is 
ChthollyNotaSeniorious gives DataStructures a number axis with m distinct segments on it Let f l r be the number of ways to choose an even number of segments such that the union of them is exactly l r and g l r be the number of ways to choose an odd number of segments such that the union of them is exactly l r ChthollyNotaSeniorious asked DataStructures q questions In each query ChthollyNotaSeniorious will give DataStructures two numbers l r and now he wishes that you can help him find the value f l r g l r modulo 998 244 353 so that he wouldn t let her down ,"['#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nconst int LOG = 18;\nint n, m;\npii a[N];\npii b[N];\nint cntBad[N];\nint par[N][LOG];\nint h[N];\n\nint up(int v, int dh) {\n\tfor (int k = 0; k < LOG; k++)\n\t\tif ((dh >> k) & 1)\n\t\t\tv = par[v][k];\n\treturn v;\n}\nint LCA(int v, int u) {\n\tif (h[v] > h[u]) swap(v, u);\n\tu = up(u, h[u] - h[v]);\n\tif (v == u) return v;\n\tfor (int k = LOG - 1; k >= 0; k--) {\n\t\tif (par[v][k] != par[u][k]) {\n\t\t\tv = par[v][k];\n\t\t\tu = par[u][k];\n\t\t}\n\t}\n\treturn par[v][0];\n}\nbool isPar(int v, int u) {\n\treturn h[v] <= h[u] && up(u, h[u] - h[v]) == v;\n}\n\nint solve(int l, int r) {\n\tint v = lower_bound(a, a + n, mp(l, -1)) - a;\n\tif (v == n || a[v].first != l) return 0;\n\tint u = lower_bound(b, b + n, mp(r, -1)) - b;\n\tif (u == n || b[u].first != r) return 0;\n\teprintf(""go %d %d\\n"", v, u);\n\tif (cntBad[v] != cntBad[u]) return 0;\n\tif (u < v) return 0;\n\tif (v == u) return -1;\n\tif (LCA(v, v + 1) <= u) return 0;\n\tif (isPar(u, v)) return -1;\n\tif (isPar(u, v + 1)) return 1;\n\treturn 0;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\n\tint q;\n\tscanf(""%d%d"", &n, &q);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(""%d%d"", &a[i].first, &a[i].second);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (m > 0 && a[i].first == b[m - 1].first) continue;\n\t\twhile(m > 0 && a[i].second <= b[m - 1].second) m--;\n\t\tb[m++] = a[i];\n\t}\n\tn = m;\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = b[i];\n\tfor (int i = 0; i < n; i++)\n\t\teprintf(""(%d %d)\\n"", a[i].first, a[i].second);\n\tfor (int i = 1; i < n; i++) {\n\t\tassert(a[i - 1].first < a[i].first);\n\t\tassert(a[i - 1].second < a[i].second);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tb[i] = mp(a[i].second, a[i].first);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tcntBad[i] = cntBad[i - 1];\n\t\tif (a[i].first > a[i - 1].second) cntBad[i]++;\n\t}\n\tfor (int i = 0; i <= n; i++)\n\t\tfor (int k = 0; k < LOG; k++)\n\t\t\tpar[i][k] = n;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = lower_bound(a, a + n, mp(a[i].second + 1, -1)) - a;\n\t\tif (v == n) continue;\n\t\tif (cntBad[v] != cntBad[i]) continue;\n\t\teprintf(""par[%d] = %d\\n"", i, v);\n\t\tpar[i][0] = v;\n\t}\n\tfor (int i = n - 1; i >= 0; i--)\n\t\th[i] = h[par[i][0]] + 1;\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int v = 0; v < n; v++)\n\t\t\tpar[v][k + 1] = par[par[v][k]][k];\n\twhile(q--) {\n\t\tint l, r;\n\t\tscanf(""%d%d"", &l, &r);\n\t\tint ans = solve(l, r);\n\t\tif (ans < 0) ans += 998244353;\n\t\tprintf(""%d\\n"", ans);\n\t}\n\n\treturn 0;\n}\n']","[0, 0, 0, 1, 1]",3200,SolutionThis picture shows what the segments eventually are like For we can find the lowest such that and construct a tree by linking such and Then the LCA of and will be where the answer becomes 0 So we can get the answer of quickly by simply finding the LCA of two segments the segment starting with if no segment starts with the answer is and the first segment whose is greater than if it do not intersect with the previous segment the answer is And find the segment ending with If it is on the path of the two segments the answer will be Else the answer will be 
You have n students under your control and you have to compose consisting of some subset of your students Each student had his own skill the i th student skill is denoted by an integer a i different students can have the same skills So about the teams Firstly these two teams should have the same size Two more constraints The first team should consist of students with skills i e all skills in the first team are unique The second team should consist of students with skills i e all skills in the second team are equal Note that it is permissible that some student of the first team has the same skill as a student of the second team Consider some examples skills are given 1 2 3 4 4 is not a good pair of teams because sizes should be the same 1 1 2 3 3 3 is not a good pair of teams because the first team should not contain students with the same skills 1 2 3 3 4 4 is not a good pair of teams because the second team should contain students with the same skills 1 2 3 3 3 3 is a good pair of teams 5 6 is a good pair of teams Your task is to find the maximum possible size x for which it is possible to compose a valid pair of teams where each team size is x skills in the first team needed to be unique skills in the second team should be the same between them A student cannot be part of more than one team You have to answer t independent test cases ,"['#include<bits/stdc++.h>\n#define IOS ios_base::sync_with_stdio(false),cin.tie(NULL)\n#define fi first\n#define se second\n#define  all(d) d.begin(),d.end()\n#define allr(d) d.rbegin(),d.rend()\n#define For(i,d,c) for(int i = d;i <= c;++i)\nstd::mt19937 rgn(std::chrono::steady_clock::now().time_since_epoch().count());\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace io\n{\n\ttemplate<typename T> inline void read(T&a){\n\t\tint c = getchar(),sign = 0;\n\t\ta = 0;\n\t\twhile(c < \'0\' || c >\'9\') sign += (c == \'-\'),c = getchar();\n\t\twhile (c >=\'0\' && c <=\'9\') a = (a << 1) + (a << 3) + c-48,c = getchar();\n\t\tif (sign&1) a = -a;\n\t}\n\ttemplate<typename T,typename... _T>\n\tinline void read(T&a,_T& ...argc)\n\t{\n\t\tread(a);read(argc...);\n\t}\n\ttemplate<typename T>\n\tinline void Write(T a)\n\t{\n\t\tif (a > 9) Write(a/10);\n\t\tputchar(a % 10 + \'0\');\n\t}\n\ttemplate<typename T>\n\tinline void write(T a,char ch = \' \')\n\t{\n\t\tif (a < 0) putchar(\'-\'),a = -a;\n\t\tWrite(a);\n\t\tputchar(ch);\n\t}\n\ttemplate<typename T> inline void Min(T&a,T b){if (a > b) a = b;}\n\ttemplate<typename T> inline void Max(T&a,T b){if (a < b) a = b;}\n\ttemplate<typename T,typename... _T> inline void Min(T&a,T b,_T ...c){Min(a,b);Min(a,c...);}\n\ttemplate<typename T,typename... _T> inline void Max(T&a,T b,_T ...c){Max(a,b);Max(a,c...);}\n}\nusing namespace io;\nconst int maxn= 1e6 + 3;\nconst int N = 4e5 + 3;\nconst int mod= 1e9 + 7 ;\nint n,m,q;\nint dem[N],id[N],chot[N],a[N],b[N];\nint k,h;\nll t[N + 3];\nstring  s;\nbool kt[N];\nmap<long long,int> maps;\nvector<int> edge[N];\nmap<int,int> ::iterator it;\ntemplate<typename T>\nvoid answer(T x) {cout << x;exit(0);}\nvoid putstring(string x,char ch = \' \') {for (char c:x) putchar(c);putchar(ch);}\n\nint main() {\n\tIOS;\n\tcin >> q;\n\twhile (q--) {\n\t\tcin >> n;\n\t\tvector<int> a(n + 1);\n\t\tfor (int i = 0;i < n;i++) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\ta[x]++;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 1;i <= n;i++) if (a[i] > 0) ++cnt;\n\t\tint can = *max_element(a.begin(),a.end());\n\t\tif (cnt > can) cout << can <<""\\n"";\n\t\telse {\n\t\t\tif (can > cnt) cout << cnt <<""\\n"";\n\t\t\telse cout << cnt-1 <<""\\n"";\n\t\t}\n\t}\n}\n\n/*********************************************************************************************************************************************************************************************************\n *ti;.                               .:,:i:          .:,;itt;:      GLDEEGEEEEEEEEEEEEEEEEEEDEEEEEEEEEEE#W#WEKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKKKKKKG.     .::.      f:,...,ijLGDDDDDDDDEEEEEE *\n *ti;.                               .:,:i:            :,;;iti,    :fDDEEEEEEEEEEEEEEEKEEEEDEEEEEEEEEEEW##WEEEKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWWKKKKKKEG     .::.       .f,::,ijLGDDDDDDDDEEEEEE *\n *ti;.                               .:,:i:             .,,;iti;.  LDDEEEEEEEEEEKEEEEWEEEDDEEEEEEEEEEE#WWWEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWWWWWKKKKKEDj    .::.        .:L;;ijfGDDDDDDDDDEEEEE *\n *ti;.                               .:,:i:              .:,;;iii:LLDEEEEEEEEEEEKEEEEEEEEDEEEEEEEEEEEW#WWEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKWWKWWWWWWWWWWWWWWKKKKKKKEL    .::.         .:;LijLGGDDDDDDDDEEEEE *\n *ti;.                               .:,:;:                :,;;ittfDEEEEEEEEEEEEEEEEKEEEGEEEEEEEEEEEKWWWEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWWWWKKKKKKKELj   .::.          :,;jffGGDDDDDDDDDEEEE *\n *ti;.                               .:,:i:                 .,;;tGGDEEEEEEEEEEEKEEEKEEEDEEEEEEEEEEEEWWWEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWKWWWWWWKKKKKKKEEL   .::.          .:;itDGGDDDDDDDDDEEEE *\n *ti;.                               .:::;:                   :;ifDEEEEEEEEEEEEKEEEKEEEEEEEEEEEEEEEWWWEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WWWKKKKKKKKEEf   .::.           :,itfGEDDDDDDDDDDDEE *\n *ti;.                               .:::;:                    :GGEEEEEEEEEEEKEKEEKEEEEEEEEEEEEEEEEWWEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKKEEDG  .::.           .,;jfLGKDLDDDDDDEEDD *\n *ti;.                               .:::;:                     fDEEEEEEKKKKKKKKKEKEEEEEEEEEEEEEEE#WEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#KKKKKKKKKKEEf .:::.           .,;tfLGDEDDDDDDDDEEE *\n *ti;.                                :::;:                    fDEEEEEEKKKKKKKKKKWKEEEEEEEEEEEEEEEWKEEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKKKEEft :::.           .,;tfLGDDDKDDDDDDDDD *\n *ti;.                                .::;:                    fDEEEEEEKKKKKKKWKKKKKEEEEEEEEEEEEE#WEEWEEEEEDEEDEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKKKEEGG :,:.           .,;tfLGGDDDKDDDDDDDD *\n *ti;.                                .:.;:                   tGDEEEEKKKKKKKKKKKKKKKKKEEEEEEEEEEEWEEKWEEEEEEEDEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKKKKKEEDf :::.           .,;tfLGGDDDDEDDDDDDD *\n *ti;.                                .::;:                   fDEEEEEKKKKKKKKKKKWKKKKKKKKEEEEEEEWWEEWEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKW##KKKKKKKEEEft.::.           .,;tfLGGDDDDDDEDDDDD *\n *ti;.                                .:.;:                  tGDEEEKKKKKKKKKKKKKKKKKKKKKKEKEEEEE#EEWWEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKW#WKKKKKKEEEGD:::.           .,;tfLGGDDDDDDDEDDDD *\n *ti;.                                .:.,.                  LDEEEEKKKKKKKKKKWKWKKKKKKKKKKKKEEEKWEKW#EEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKW##KKKKKKEEEEf,,:.           .,;tfLGGDDDDDDDDEDDD *\n *ti;.                               ..:.,.                 LGDEEEEKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEEW#WEEEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEKEKKKKKKKKKKKKKKKK##KKKKKEEEEEfi;,.           .,;tfLGGDDDDDDDDDKDD *\n *tt;.                                .:.,:                 jDEEEEKKKKKKKKKKWWKKKKKKKKKKKKKKKKKWKE#WWEEEEEEEEEEEEEEWEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKKKKKKWWKKKKEEEEDfG;,:           .,;tfLGGDDDDDDDDDDKD *\n *tii,.                               .:.,.                tGDEEEEKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKKWWWKEEEEEEEEEEEEEKEEEEEEEEEEEEEEEEEEEEEEEEEEEEEKKKKKKKKKKKW#KKKKEEEEDGGi;,.          .,;tfLGGDDDDDDDDDDDE *\n *ti;;,:.                             .:.,:                fDEEEEKKKKKKKKKKKWKKKKKKKKKKKKKKKKKWEK#WWKEEEEEEEEEEEEDEEEEEEEEEEEEEEGEEEEEEEEEEEEEEEEEEEKKKKKKKWWKKEEEEEEDDf;;;,.         .,;tfLGGDDDDDDDDDDDD *\n *tii;,,:..                           ...,.               ;LEEEEEKKKKKKWKKKKWKKKKKKKKKKKKKKKKKEKKW#WEEEEEEEEEEEEEjEEEEEEEEEKEEEEGEEEEEEEEEKEEEEEEEEEEEEEEEEE#WKEEEEEEDDf;;;;,:        .,itfLGGDDDDDDDDDDDD *\n *ti;,,,,,:.                          ...,.               LDEEEEKKKKKKKKKKKWWWKKKKKKKKKKKKKKKWKK#W#WEEEEEEEEEEEDDLEEEEEEEEEWEEEEDEEEEEEEEEKEEEEEEEEEEEEEEEEEWWEEEEEEEDDfj,,,,,:.      .,itfGGGDDDDDDDDDDDD *\n *tii,,,,::::.                        ...,:              .fDEEEEKKKKKKWKKKKWWWKKKKKKKKKKKKKKKEKKW#WWEEEEEEEEEEEKiKEEKEEEEEEWEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEEWWEEEEEEEDDLD:::,,,:.     .,ijfGGGDDDDDDDDDDDD *\n *ti;:::::::::..                      .:.,:              LDEEEEKKKKKKKWKKKKWWKKKKKKKKKKKKKKKKtKKWWWWKEEEEEEEEEDiiDEEEEEEEEWWEEEEEEDEEEEEEEEEEEEEEEEEEEEEEEEEEWKEEEEEDDDGL:. .:,,,:    .,ijLGGGDDDDDDDDDDDD *\n *tt;. .::::::::..                    ...,:             :fDEEEKKKKKKKKKKKKWW#KKKKKKKKKKKKKKKKfKKWWWWKEEEEEEEEDti,DEKEEEEEEWWEEEDEEEEEEEEEKEEEEEEEEEEEEEDEEEEE#WEEEEEGGDGf:.  .:,;,:.  .,ijLGGDDDDDDDDDDDDD *\n *tt;.   .:::::::..                   ...,:             GDEEEKKKKKKKKWKKKKWWWKKKWKKKKKKKWWWKDEKLWWWWKKEEEEEEDEi,LDEEEEEEEEWWEEEEEEEEEEEEEEEEEEEEEEEEEDEDEEEEEW#EEEEDDDDGf,.    :,,,:...,ijLGGGDDDDDDDDDDDD *\n *tt;.    .....::::..                 ...,:             fDEEEKKKKKKKKWKKKKWWWWKKKWKKKKKKKKKKfWKiWWW#KKEEEEEEEi;.EDfEEEDEEiWWEEEEEEEEEEEEDGKEEEEEEEEEEDEEEEEEEWWEEEEDDDGGLi.     .,;,:::,ijLGGGDDDDDDDDDDDD *\n *tt;.      ....:::::.                ...,.            iDEEEEKKKKKKKKWKKWKWWWWWKKWWWKKKKKKKKtWKt#WWWKKEEEEEDji..DDKDDEDEGiWKEEEEEEEEEEDDEjEEEEEEEEEEEDEEEEEEEKWKEEDDDDGGff.      .:,;,,;ijLGGGDDDDDDDDDDDD *\n *tt;.        ....::::..              .:.,:           .LDEEEKKKKKKKKKKKKWWWWKWWWWWWWWWWKKKKWtKKiDWWWKKKEEEEKi:..DEDDDDDDiiWKEEEEEEEEEEDDEijDEEEEEKEEEEEEEEEEEEWWEEGDDDGGLG.       .:,;;iijLGGGDDDDDDDDDDDD *\n *tt;.          .....:::..            ...,.           .fEEEEKKKKKKKKWKKKKWWWWWWWWWWWWWWKWKKKiKDiLWWWWKEEEEEi,..fD:DDDDDti;WEEEEEEEEEEKDDi:iDDEEEEWEEEEEEEEEEEE#WEEGDDDDGGG.         :,iitjLGGGDDDDDDDDDDDD *\n *tti.            .....:::..          ...,.           GDEEEKKKKKKKKKWKKKWWW#WWWWWWWWWWWKWKKjiEjitWWWKKWEEEDi...DDLDDDDji;;WEEEEEEEEEEEDEj.iDDEEEEWEEEEEEEEEEEEWWEEDDDDDDGf.          .,;tjfLGGDDDDDDDDDDDD *\n *tti.              ....::::..        ...,.           fEEEKKKKKKKKKKKKKKKW#WWWWWWWWWWWWWWWWtiEiiiWWWKKEWKEi....D.EDDDEi;.fWEEEEEEEEEEDDfL.;EDDEEEWEEEEEEEEEEEEWWEEEDDDDDGf.           :;ijfLGGDDDDDDDDDDDD *\n *tti.                ....::::..      ...,.          LDEEEKKKKKKKKKKKKKKWWWWWWWWWWWWWWWW####WKiiiWWWKKKEEK,...:E:DDDEii..GWEEEEEEEEDWDDiL.,KDDEEEWEEEEEEEEEEEEWWKEEDDDDDGf:           .,itfLGGDDDDDDDDDDDD *\n *tti.                 .....:::..     ...,.          fDEEEKKKKKKKKKWKKKKWWWWWWWWWWWWW########WLiiWWWKKKEEjD...G,DDDDi;...EWEEEEEEEEDKDEii..LDDEEEWEEEEEEEEEEEEWWWEEDDDDDGfi           .,;tfLGGGDDDDDDDDDDD *\n *tti.                   .....:::..   ...,.         iGEEEKKKKKKKKKKWKKKKWWWWWWWWWWWW###########KiWWWKKEEE,.D..D.DDDii:...KKEEEEEEEEEDDj:...tEDEEEWEEEEEEEEEEEEWWWEEEDDDDDLL           .,;tjLLGGDDDDDDDDDDD *\n *tti.                     ....::::......:.         LEEEKKKKKKKKKKWWKKKWWW#KWWWWWWWW#####W####W##KWWKKEEL..:D.jjDDi;,....KKEEEEEEEDfDDi...:iKDEEEWKEEEEEEEEEEEWWWEEEEDDDDLG           .,;tjLLGGDDDDDDDDDDD *\n *tti.                        ...::::::..,.        :GEEEKKKKKKKKKKKKWWWWW##WWWWWWWWW##WKWK#W#W####WWKEEK.....G.DDti,.....KKEEEEEEDWGDf.,...iKDEEEWWEEEEEEEEEEEW#WEEEEEDDDGL           .,;tjLLGGDDDDDDDDDDD *\n *tti.                         ....::::::,.        GDEEKKKKKKKKKKKKKWWWW###WWWWWWWWWW#WWWK###W#####WKEKK.....jDDL;;......KKEEEEEEEEEDi.f...;KDEEEWWEEEEEEEEEEEWWWWEEEEEDDGf           .,;tjLLGGDDDDDDDDDDD *\n *tti.                           ....:::,,.       .LEEEKKKKKWKKKKKWWWWWW###WWWWWWWWWW#WWKW#WW##W#WWWKEKD:....:DD:;......;KEEEEEEEKiDD..f...,KKEEEWWEEEEEEEEEEEWWWWEEEEEDDDf           .:;tjLLGGGDDDDDDDDDD *\n *tti.                             ...::,,,:.     GDEEKKKKKKKKKKKKWWWWWWW#WWWWWWWWWWW#KjKWWWWWWWWWWWWEK.j,..;fD.;.......fKEEEEEDKG:Di..,....DKEEEWWEEEEEEKEKKKWWWWEEEEEEDDf           .:;tjLLGGDDDDDDDDDDD *\n *jti.                              ...::,,,,:.  .fEEEKKKKKWKKKKKKWWWWWWW#WWWWWWWWWWK#KKKWWWWWWWWWWWWWK..f:.:G.,:.......EKEEEEEKK;:E:.......fKEEEWWKEKEKKKKKKKW#WWEEEEEEDDf:          .,;tfLLGGDDDDDDDDDDD *\n *tti.                               ...:,,,;;,: iDEEKKKKKWKKKKKKKWWWWWWW#WWWWWWWWWWK#WDKWWKKWWWWWWWWWE..;G:G..,........KKEEEEEKi.Gi..:.....tKEEKWWWKKKKKKKKKKW##WKEEEEEEDfi          .,;tfLLGGGDDDDDDDDDD *\n *tti.                               ....::,,;;;,LEEKKKKKKWKKKKKWWWWWWW###WWWWWWWWWWKWWDKWEEEWKKWWWWWKKj.:LG..;.........EKEEEEKG;.G...;.....;KKEKWWWKKKKKKKKKKW##WWKEEEEEDfL          .,;tfLGGGDDDDDDDDDDD *\n *jti.                                ...::::,;ijDEEKKKKKWKKKKKKWKWWWWW##WWWWWWWWWWWKK#KKGDGDWEEWKKWKKGE,.i;.:.........:EKEEEKE;.:L...j.....,KWEKWWWKKKKKKKKKK####WKKEEEEDLG          .,;tfLGGGGDDDDDDDDDD *\n *jti.                                ...:...,,;GEEKKKKKWWKKKKKWWWWWWWW###WWWWWWWWWKKKWWKiLGGEDEDEKGKKiEG..;...........jKEEEKK;:.G....,.....:KKEWWWWKKKKKKKWKK####WKKKKEEEGL          .,;tfLGGGGDDDDDDDDDD *\n *jti.                                ...:.  .:,GEEKKKKKWKKKKKWWWWWWWW####WWWWWWWWWKKKWWKii;fDLGDK: EEi:E:.............EKEEKK;;..L...........KKKWWWWKKKKKKKWKK####WKKKWKEEDf          .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    ,EEKKKKKWWKKKKKWWWWWWWWW###WWWWWWWWKKKKfWWLt;i,. fi  EG..D:.............EKEKK;;..t....:.......KWKWWWWKKKKKKKWKK####WKKKWEEEDf:.        .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    GEEKKKKKWKKKKKWWWWWWWWW####WWWWWWWKKKKKt;KKEfff     .;t.................KKKKi;:..GtGGfG.......KWWWWWWKKKKKKKWKK###WWWKKKKEEEf,,:       .,;tfGGGGDDDDDDDDDDD *\n *jti.                                ...:.    GEKKKKKWWKKKKKWWWWWWWWWW##WWWWWWWKKKKKKt;EiKKKK,   ...t................jEKKG;;..,.....,LGi....KWWWWWWKKKKKKWKKKW####WKKKKKEEL,,,:.     .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.  .GEEKKKKKWKKKKKWWWWWWWWWW###WWWWWWWKKKKKKtiE::tGG........................EEEj;;...,.........:D..DKWWWWWWKKKKK#KKW###W#WKKKKKEEfj:,,,:.   .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.   DEKKKKKWWKKKKKWWWWWWWWW####WWWWWWWKKKKKKiiE:::.::.......................EEi;;...j.....f......:iDKWWWWWWKKKKK#WW######WKKKKKEELG :,,,,:. .,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:.  fEEKKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKK;tE::..........................DD;.;,.::......;........EWWWWWWWKKKKW#WW#####WWKKKWKKELG  .:,,,:::,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:. .DEKEKKKWWKKKKWWWWWWWWWWW###WWWWWWWWKKKKKE,iD::..........................D..,;.,;tLffi...........DWDWWWW#KKKWWWWW#####W#KKKWKEEGL    .:,;,,,;tfGGGDDDDDDDDDDDD *\n *jti.                                ...:. ;EEKKKKWWKKKKKWWWWWW#WWWW####WWWWWWKKKKKEL:iD:..........................j ..;..;;:.....i,........DKtWWWWWKKWWWWWW#####WWWKKKEKEDf     .:,;;;itfGGGDDDDDDDDDDDD *\n *jti.                                ...:. DEKKKKKWWKKKKWWWWWWW#WWWW####WWWWWWKKKKKEj:iG...............................:....................GKiWWWWWKKWW#WWW######WWKKKKKEEf       .,;iitfGGGDDDDDDDDDDDD *\n *jti.                                ...:.:EKKKKKWWKKKKKWWWWWWW#WWW#####WWWWWKWKKKKEi:if:.................................iEKEKKKKKKDj......DKiWWWWWKWK##WW#######WWKKK:KEEL        .:;itfGGGDDDDDDDDDDDD *\n *jji.                                ...:,DEEKKKWWWKWKKWWWWWWWWWWWW#####WWWWWWWKKKKEi:it..................................j.  KKKKKKKKKKKf..DKiWWWWWKWW##WW#######WWKKK,KEEf         .,;tfGGGDDDDDDDDDDDD *\n *jji.                                ..L:iDEEKKKWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKKi.i;..................................  . KKKWWWWWWWWK..DGiWWWWWKK##WWW#####W#WWKKKjEKEL,        .:;tfGGGDDDDDDDDDDDD *\n *jji.                               .f:::EEEKKKWWWKKKKKWWWWWWWWWWWW#####WWWWWKWKKKKK;.i,.................................::  KKEKWWWWWWfWK..EiiWWWWWKWW#WW##########KKKD,KELj        .:;tfGGDDDDDDDDDDDDD *\n *jji.                             .t::::,DEEKKKWWKKKKWWWWWWWWW#WWWW#####WWWWKKWKKKEK;.i:.................................GDDEEEKKKWWWWWtWWD.E;iWWWWWW###WW#########WWKKK.EEDG        .:;tfGGGDDDDDDDDDDDD *\n *jji.                          . j..::::EKEKKKWWWKKKKWWWWWWWWW#WWW######WWWWKKWKKKEK;.t:.................................ELLEDDEEEWWWWEtWK,.KiiWWWWWW###W##########WWKKK:EEEG     .;tjfLLGDDDDDDDDDDDDDDD *\n *jji.                          i.::::::,EEEKKWWWKKKKKWWWWWWWWW#WWW#####WWWWWKWKKKKEE,.t..................................DfiEGDDDEEKKKttKWG.KiiWWWWW##WWW##########WWKKK:fEEL  ,fGGGDDDDDDDDEEEDDDDDDDDDD *\n *jji.                        .;:..:::::DEEEKKWWWKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKED,.t..................................ifjDDGGEGDKK.ttKKE.DiWWWWW###WW##########WWWKKK:.KELiLGGGGDDDDDDDDDDDDEEEDDDDDDD *\n *jji.                       i.:.::::::,KEEKKWWWKKKKKKWWWWWWWWW#WWWW####WWWWWWWKKKKEL:.j..................................GGf,;ifLLED .iiKKi:fWWWWWW##W#W##########WWWKKK:.KKLGGDDDDDDDDDDDDDDDDEDDEEDDDDD *\n *jji.                     .j:.::::::::EEEKKKWWWKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKf:.f..................................:EEfftf .,. ;iE,..jWWWWWWW###W############WWKKK,:KKGDDDDDDDDDDDDDDDDDDDDDDDEDDDD *\n *jji.                    .:.::::::::,,EEEKKWWWKKKKKKKWWWWWWWW##WWW#####WWWWWWWKKKKKt..G....................................EEELL;   .j....tKWWWWWWW################WWWKKtfGKGEDDDDDDDDDDDDDDDDDDDDDDDEEDD *\n *jji.                   :...:::::::,,jEEKKWWWWKKKKKKWWWWWWWWW##KWW#####KWWWWWWKKKKEi..D....................................:jEEE.........;KKWWWWWWWW#WW##W##########WWKKDLGKEKDDDDDDDDDDDDDDDDDDDDDDDDDED *\n *jji.                  i:.::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWW##WWW#####WWWWWWWKKKKKi..D......................................:::::......,KKKWWWWWWWWW#####W########WWWKKKGGKKEGGGGGGGGDDDDDDDDDDDDDDDDDDE *\n *jji.                 i..:::::::::,,tEEKKWWWWKKKKKWWWWWWWWWWW##WW######WWWWWWWKKKKKi..D......................................::::......:EKKKWWWWWWWWWWW##WW########W#WKKWGGKKGGGGGGGGGGGGGGGDDDDDDDDDDDDD *\n *jji.                .:::::::::::,,,EEEKKWWWWKKKKKWWWWWWWWWWW##WW#####WWWWWWWWKKKKKi..D....................................:::::::::..tELii;KWWWWWWWWWW##WW######WWWWWWKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGDG *\n *jjt.                :.::::::::,,,,fEEKKWWWWKKKKKKWWWWWWWWWW###WW####WWWWWWW#WKKKKKi..D....................................:::::::.:.,;;;;;;,KKWWWWWWWWW#WW########WWWKKWGGGKGGGGGGGGGGGGGGGGGGGGGGGGGGGG *\n *jji.               ;.::::::::,,,,;EEEKWWWWWKKKKKWWWWWWWWWWWW##WW###WKWWWWWK#WKKKKKi..G......................................:::::::,;;;;:...KKKWWWWWWWWWKWW#######WWWWKKGLGKDGGGGGGLLGGGGGGGGGGGGGGGGGGG *\n *jjt.              f.:::::::::,,,,fEEKKWWWWWKKKKKWWWWWWWWWWW###WW##WKKWWWWWW#WKKKKK;.jt........i.............................:::::::;j;;....:E.KKKWWWWWWWKWW#####W#WWWWKKLLGWEEGGGGGLGGGGGGGGGGGGGGGGGGGG *\n *jjt.             ...:::::::,,,,,;DEEKWWWWWKKKKKWWWWWWWWWWWW####WWWKKKWWWWWWWWKKKKK;.E;.........t.............................:::::ii;;.....D...KKWWWWWWWKWW#####WWEWWWKKGGGEKKGGGGGLGGGGGGGGGGGGGLGGGGGG *\n *fji.             ;.:::::::,,,,,;LEEKKWWWWWKKKKKWWWWWWWWWWWW####KWKKKKWWWWWWWWKKKKKi.D;..........j.............................:::tt;,.....:.....KKWWWWWWKWWWW##WWWGWWWKKGGGGKEGGGGGGGGGGGGGGGGGGGLLGGGGL *\n *fji.            t::::::::,,,,,,;EEEKWWWWWKKKKKKKWWWWWWWWWWW##WKWKKKKKWWWWWWWWKKKKKi:D;............j...........................::LL;,.............KKWWWWWKWWWWWWWWWGWWWKKGGGGKGGGGGGGGGGGGGGGGGGGGLLGGGGL *\n *fjt:            .:::::::,,,,,,,DEEKWWWWWWKKKKKKKWWWWWWWWWWWWKKWKKKKKKWWWWK#WWKKKKWitE;........... ............................:G;;:...............KKKWWKKWWWWWWWWWGWWWKKGGGGWGGGGGGGGGGGGGGGGGGGGGGGGGGL *\n *fjji;:.       .f:::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWWKKKKKKKKKKKWWKWWWWWKKKKWGKD;........................................L;;..................DKKWKKWWWWWWWWWGWWWKKDGGGKDGGGGGGGGGGGGGGGGGGGGGGGGGG *\n *fjjtii;,:.     :::::::,,,,,,,;EEEKWWWWWWKKKKKKWWWWWWWWWWKKKKKKKKKKKKWWWWWW#WWKKKKWiEj;......................................:i,;....,...............;KKEKWWWWWWWWWGKWWKKDDGGDEGGGDGGGGGDGGGGGGGGGGGGGGGG *\n *fjtiiiii;;:.  j::::::,,,,,,,;;EEEKWWWWW#KKKKKWWWWWWWWWKKKKKKWKKKKKKKWWWWWWWWWKKKKWtEL;:....................................;;;:...,;j................:KEEWWWWWWWWWDDWWKKDDDDDKDDDDDDDDDDDDDDDGGGGGGGGGGG *\n *fjti;;iiii;;,:::::::,,,,,,,,;EEEKWWWWWWWKKKKWWWWWWWWKKKKKKKWKKKKKKKWWWWWWW#W#KKKKWEEii;...................................f;:....,;L...................EEKWWWWWWWWDDWWKKDDDDDKEDDDDDDDDDDDDDDDDDDDDDGGGG *\n *fjt,,,;;;;ii;f::::::,,,,,,,;;EEKWWWWWWWKKKKKWWWKWWKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWKEij;:...............................:G;,.....,;f....................:tKKWWWWWWWDDWWKKDDDDDKKDDDDDDDDDDDDDDDDDDDDDDDDD *\n *jjt. ..:,;;;;,::::,,,,,,,,;;GEEWWWWWWWWKKKKWKKWKKKKKKKKKKKKKKKKKKKKWWWWWWW#W#KKKKWEDi;j;............................,Li;L;;;..,;;f........................KKKKWWWKDDWWKKDDDGDKKGGGGGGGGDGDDDDDDDDDDDDDDD *\n *fjt.    .:,,,:::::,,,,,,,;;;EEKWWWWWWWKKKKKKWKKKKKKKKKKKKKKKKKKKKKWKKKWKW##W#KKKKWEti;;G;........................tEEEL;;;;;;;;;;L..........................DKKKKKEDDWWKEDGftiLE;;;;itjLGGGGGGDDDDDDDDDDD *\n *fjt.       .j::::,,,,,,,;;;DEEWWWWWWWWKKKKWKKKKKKKKKKKKKKKKKKKKKKKWKKWWWK##W#KKKKKEii;;;L;...................iDEEEEEEKKi;j;;;;jD.....:......................,KKKKDGGEKKE:::::;E::::::::::,tLGGDDDDDDDDDD *\n *fjt.       .;:::,,,,,,,;;;;EEKWWWWWWWWKWKKKKKKKKKKKKKKKWKKKKKKKKKKWKKWWWW#WW#KKKKKKii;;;;f;.............:tDEEEEEKKKKKKKKEti;;;L...............................EEKf;:iKKE::::::E::::::::::::::ifDDDDDDDDD *\n *fjt:        :::,,,,,,,,;;;DEEWWWWWWWWWEKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####KKKKKEiii;;;;f,.........iDEEEEKKKKKKKKKKKKKKKf;iG......i..........................fK::::KKE::::::E::::::::::::::::,tGGDDDDD *\n *fjt:       t:::,,,,,,;;;;iDEKWWWWWWKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKWWWW####WKKKKLiii;;;;;L,....,Li;EDEEEEKKKKKKKKKKKKKKKKiG......;:...........................:i:::KKE:::::,E,::::::::::::::::::iGDDDD *\n *jjt.       f::,,,,,,,;;;;GEEWWWWKEEKEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKWWWWW###WWKKKKiii;;;;;;;G,;L;;iiEEEEEEEKKKKKKKKKKKKKWWKE......;t.........:....................j::KEE:,::,,D,,::::,,,,,,:::::::::tDDD *\n *fjt:.      ,::,,,,,,,;;;;EEWWKEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKWWKKWWWWW#W#KKKKKKiiiiii;;;;;i;;iiiEEKEEKKWKKKKKKKWKKKKKWWWGi;...;t......,;;;;,....................:,EEE,,,,,,D,,,,,,,,,,,,,,,,::,::::tG *\n *fjt:.     ,::,,,,,,,;;;;DEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWW#W#KKKKKKiiiii;;i;;;;;iiiKKKEKKKKWWKWWWWWWKKKKWWWWW;;;:;L.....;;;;;;;;;....................,KEE,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,; *\n *fjt:.     f:,,,,,,,;;;;jEDEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWW#W##KKKKKKiiiiiiii;i;;iiiEKKKKKKKKWKWWWWWWWWKKKWWWWWKi;;i.....,jEEfGi;;;;;...................EED,,,,,,E,,,,,,,,,,,,,,,,,,,,,,,,, *\n *fjt:.    .f::,,,,,,;;jEEDEEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWKWWWWW###KKKKKLiiiiiiiiiiiiiiEEKKKKKKKKWWWWWWWWWWWWKWWWWWWGi;i;,..;jDDDKEGi;;;;;;:................EED,,,,,,D,,,,,,,,,,,,,,,,,,,,,,,,, *\n *fjt:.  .. ;::,,,,,;;EDDEEEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWKKW#WW####KWKKKiiiiiiiiiiiiijKKKKKKKKKKWWWWWWWWWWWWWWWWWWWWWt;i;;;;i;DDDDDDGi;;;;;;;;:.............EDf;,,,;,G;;;;;;;;;;;;;;;,,,,,,,,,, *\n *fjt:......:,,,,,,;LDDDEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKWWWWKWWWW####KKKKKiiiiiiiiiiijKEKKWKKKKKKKWWWWWWWWWWWWWWWWWWWWWWiLiii;i;DEEEEDDE;i;;;;;;;;;:..........EDi,;;;;;L;;;;;;;;;;;;;;;;;;,,,,,,, *\n *fjt:......:,,,,,;EDDDEEKEEEEEEEEEKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKWWWWKKWWW##W#KWKKWEiiiiiijGKKKKKWWKKKKKKKKWWWWWWWWWWWWWWWWWWWWWWKi;iiiiDDEEEEEEDEi;;;;;;;;;;;;;,:.....ED;;;;;;;j;;;;;;;;;;;;;;;;;;;;;;;,, *\n *fjt:.....t,,,,,;DDDDEEEKEEEEEEEEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWKKKWWWW##WKWKKWKiiiKKKKKKKKKWWKKKKKKKKWWWWWWWWWWWWWWW#WWWWWWWWWiiiiifLEEEEEEEEDi;i;;;;;;;;;;;;.....DD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n *fjt:.....G,,,,,GDDDEEEEEEEEEEEEKKKKKKKKKKKKKKKKWKKKKKKKKKKKKKKKWWWKKKWWW###WKWKKWKitKKKKKKKKKWKKKKKKKKKKWWWWWWWWWWWWWW###WWWWWWWWEiiiiiiiEEEEEEEEDGiiii;;;;;;;;;.....GD;;;;;;;i;;;;;;;;;;;;;;;;;;;;;;;;; *\n *fjt:.....L,,,,;GDDDEEEEEEEEEEKEKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKWWWWWDGWWW###KKWWKWKKKKKKKKKKKKKKKKKKKKKKKWWWWWWWWWWWWW####WWWWWWWWWiiiiiiiiEEEEEEEEEEDi;i;;;;;;;;.....Lj;;;;;;i;iiiiii;;;;;;ii;;;;;;;;;;; *\n ***********************************************************************************************************************************************************************************************************/\n']","[1, 0, 1, 0, 0]",1100,Let the number of students with the skill is and the number of different skills is Then the size of the first team can not exceed and the size of the second team can not exceed So the answer is not greater than the minimum of these two values Moreover let s take a look at the skill with a maximum value of Then there are two cases all students with this skill go to the second team then the sizes of teams are at most and correspondingly Otherwise at least one student with this skill goes to the first team and the sizes are at most and correspondingly So the answer is Time complexity 
Have you ever played Hanabi If not then you ve got to try it out This problem deals with a simplified version of the game Overall the game has 25 types of cards 5 distinct colors and 5 distinct values Borya is holding cards The game is somewhat complicated by the fact that everybody sees Borya s cards except for Borya himself Borya knows which cards he has but he knows nothing about the order they lie in Note that Borya can have multiple identical cards and for each of the 25 types of cards he knows exactly how many cards of this type he has The aim of the other players is to achieve the state when Borya knows the color and number value of each of his cards For that other players can give him hints The hints can be of two types color hints and value hints A color hint goes like that a player names some color and points at all the cards of this color Similarly goes the value hint A player names some value and points at all the cards that contain the value Determine what minimum number of hints the other players should make for Borya to be certain about each card s color and value ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int N = 12345;\n\nint c[N], num[N];\nchar card[N];\nint mask[N];\n\nvector < pair <int, int> > p;\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  p.resize(n);\n  for (int i = 0; i < n; i++) {\n    scanf(""%s"", card);\n    c[i] = -1;\n    num[i] = 0;\n    if (card[0] == \'R\') c[i] = 0;\n    if (card[0] == \'G\') c[i] = 1;\n    if (card[0] == \'B\') c[i] = 2;\n    if (card[0] == \'Y\') c[i] = 3;\n    if (card[0] == \'W\') c[i] = 4;\n    num[i] = card[1] - \'1\';\n    p[i] = make_pair(c[i], num[i]);\n  }\n  sort(p.begin(), p.end());\n  p.resize(unique(p.begin(), p.end()) - p.begin());\n  n = p.size();\n  for (int i = 0; i < n; i++) {\n    c[i] = p[i].first;\n    num[i] = p[i].second;\n  }\n  int ans = 42;\n  for (int tn = 0; tn < (1 << 5); tn++) {\n    for (int tc = 0; tc < (1 << 5); tc++) {\n      vector <int> hints;\n      for (int i = 0; i < 5; i++) {\n        if (tn & (1 << i)) {\n          hints.push_back(i);\n        }\n      }\n      for (int i = 0; i < 5; i++) {\n        if (tc & (1 << i)) {\n          hints.push_back(~i);\n        }\n      }\n      int cnt = hints.size();\n      for (int i = 0; i < n; i++) {\n        mask[i] = 0;\n        for (int j = 0; j < cnt; j++) {\n          if (hints[j] >= 0) {\n            if (num[i] == hints[j]) {\n              mask[i] |= (1 << j);\n            }\n          } else {\n            if (c[i] == ~hints[j]) {\n              mask[i] |= (1 << j);\n            }\n          }\n        }\n      }\n      sort(mask, mask + n);\n      bool ok = true;\n      for (int i = 0; i < n - 1; i++) {\n        if (mask[i] == mask[i + 1]) {\n          ok = false;\n          break;\n        }\n      }\n      if (ok) {\n        if (cnt < ans) {\n          ans = cnt;\n        }\n      }\n    }\n  }\n  printf(""%d\\n"", ans);\n  return 0;\n}\n']","[0, 0, 1, 0, 0]",1700,It s obvious that the order of hints doesn t metter There are 10 types of hints so we can try all vartiants of what other players should do Now we need to check if Boris can describe all of his cards He can do it iff he can distinguish all pairs of different cards He can do it if somebody told at least one distinction It can be a hint about color of one of cards if they don t have same one or it can be hint about value of some card 
Calculate the minimum number of characters you need to change in the string so that it contains at least different letters or print that it is impossible String consists only of lowercase Latin letters and it is allowed to change characters only to lowercase Latin letters too ,"['#include<cstdio>\n#include<cstring>\nint l, cnt[128], c,k;\nchar s[1001];\nint main() {\n    scanf(""%s%d"", s, &k);\n    int i = 0;\n    for (; s[i]; i++) if (!cnt[s[i]]++) c++;\n    if (i < k) puts(""impossible"");\n    else printf(""%d\\n"", k>c?k - c:0);\n    return 0;\n}']","[1, 0, 1, 0, 0]",1000,One could note what in case we should always print Overwise the finding value is equal where is a number of different letters in the original string It is correct because if condition is satisfied and we shouldn t do anything so the answer is zero If we could change duplicated letters to a different letters initially weren t contained in Solution complexity is 
Diamond Miner is a game that is similar to Gold Miner but there are n miners instead of 1 in this game The mining area can be described as a plane The n miners can be regarded as n points There are n diamond mines in the mining area We can regard them as n points For some reason point 0 0 Every miner should mine one diamond mine Every miner has a hook which can be used to mine a diamond mine If a miner at the point a b uses his hook to mine a diamond mine at the point c d he will spend sqrt a c 2 b d 2 energy to mine it the distance between these points The miners can t move or help each other The object of this game is to minimize that miners spend Can you find this minimum ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC target (""avx2"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvll raz, dwa;\n\nvoid test()\n{\n\traz.clear();\n\tdwa.clear();\n\tscanf(""%d"", &n);\n\tfor (int i=1; i<=2*n; i++)\n\t{\n\t\tll a, b;\n\t\tscanf(""%lld%lld"", &a, &b);\n\t\tif (!a)\n\t\t\traz.push_back(abs(b));\n\t\telse\n\t\t\tdwa.push_back(abs(a));\n\t}\n\tsort(raz.begin(), raz.end());\n\tsort(dwa.begin(), dwa.end());\n\t//~ reverse(dwa.begin(), dwa.end());\n\tdouble wyn=0;\n\tfor (int i=0; i<n; i++)\n\t\twyn+=sqrt((double)(raz[i]*raz[i]+dwa[i]*dwa[i]));\n\tprintf(""%.11lf\\n"", wyn);\n}\n\nint main()\n{\n\tint t;\n\tscanf(""%d"", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n']","[1, 1, 0, 0, 0]",1200,First you can turn a point to while not changing the answer After this operation all points can be described as or In a triangle if the length of the edges are it is obvious that So if you connect all match pairs with a segment and there are two segments intersecting each other you must be able to change the matching ways to make the answer smaller For example if you match with with the answer will be if you match with and with the answer will be So in the best solution there won t be two segments intersecting each other Sort all the points on the x axis and on the y axis then match the points in ascending order of or you can get the minimum The time complexity is for each test case 
There s a chessboard of size n times n m rooks are placed on it in such a way that no two rooks occupy the same cell no two rooks attack each other A rook attacks all cells that are in its row or column Is it possible to move rook you can choose which one to move into a different cell so that no two rooks still attack each other A rook can move into any cell in its row or column if no other rook stands on its path ,"['//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl \'\\n\'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << "" "" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<""Yes""<<endl;else cout<<""No""<<endl;}\nvoid ans2(bool x){if(x) cout<<""YES""<<endl;else cout<<""NO""<<endl;}\nvoid ans3(bool x){if(x) cout<<""Yay!""<<endl;else cout<<"":(""<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv="" ""){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv="" ""){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<"" "";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<"" "";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<"" "";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<""[""<<z.first<<""]=""<<z.second<<"","";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << "" "" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << "" "";cout<<""|""; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\n\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll t;cin>>t;\n  while(t--){\n    ll n,m;cin>>n>>m;\n    rep(i,0,m){\n      ll x,y;cin>>x>>y;\n    }\n    ans2(n>m);\n  }\n  return 0;\n}']","[1, 0, 1, 0, 0]",800,First note that is always less than or equal to If there were at least rooks on the board at least two of them would share a row or a column by pigeonhole principle If then there is always at least one free row and at least one free column You can move any rook into that row or column Otherwise all rows and columns are taken so any move will make two rooks share a row or a column which is prohibited Thus if then it s Otherwise it s Overall complexity per testcase Alternatively you could check every rook and every possible move Overall complexity per testcase 
Suppose we partition the elements of an array b into any number k of non empty multisets S 1 S 2 ldots S k where k is an arbitrary positive integer Define the of b as the maximum value of operatorname MEX S 1 text operatorname MEX S 2 ldots operatorname MEX S k over all possible partitions of b for any integer k Envy is given an array a of size n Since he knows that calculating the of a is too easy for you he instead asks you to calculate the sum of of all 2 n 1 non empty subsequences of a text Since this answer may be large please output it modulo 998 244 353 text operatorname MEX of a collection of integers c 1 c 2 ldots c k is defined as the smallest non negative integer x that does not occur in the collection c For example operatorname MEX 0 1 2 2 3 and operatorname MEX 1 2 2 0 text A sequence x is a subsequence of a sequence y if x can be obtained from y by deleting several possibly zero or all elements ,"['#include ""bits/stdc++.h""using namespace std;\xa0using ll = long long;using vi = vector<int>;\xa0#define endl \'\\n\'#define pb emplace_back#define sz(x) (int)(x).size()#define all(x) (x).begin(), (x).end()#define make_unique(x) sort(all(x)), x.resize(unique(all(x)) - begin(x))#define debug(x) cerr << ""["" << __LINE__ << ""] ""#x"" = "" << (x) << endl\xa0template<class T>constexpr T power(T a, ll b) {    T res = 1;    for (; b; b /= 2, a *= a) {        if (b % 2) {            res *= a;        }    }    return res;} constexpr ll mul(ll a, ll b, ll p) {    ll res = a * b - ll(1.L * a * b / p) * p;    res %= p;    if (res < 0) {        res += p;    }    return res;}template<ll P>struct MLong {    ll x;    constexpr MLong() : x{} {}    constexpr MLong(ll x) : x{norm(x % getMod())} {}        static ll Mod;    constexpr static ll getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(ll Mod_) {        Mod = Mod_;    }    constexpr ll norm(ll x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr ll val() const {        return x;    }    explicit constexpr operator ll() const {        return x;    }    constexpr MLong operator-() const {        MLong res;        res.x = norm(getMod() - x);        return res;    }    constexpr MLong inv() const {        assert(x != 0);        return power(*this, getMod() - 2);    }    constexpr MLong &operator*=(MLong rhs) & {        x = mul(x, rhs.x, getMod());        return *this;    }    constexpr MLong &operator+=(MLong rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MLong &operator-=(MLong rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MLong &operator/=(MLong rhs) & {        return *this *= rhs.inv();    }    friend constexpr MLong operator*(MLong lhs, MLong rhs) {        MLong res = lhs;        res *= rhs;        return res;    }    friend constexpr MLong operator+(MLong lhs, MLong rhs) {        MLong res = lhs;        res += rhs;        return res;    }    friend constexpr MLong operator-(MLong lhs, MLong rhs) {        MLong res = lhs;        res -= rhs;        return res;    }    friend constexpr MLong operator/(MLong lhs, MLong rhs) {        MLong res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {        ll v;        is >> v;        a = MLong(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {        return os << a.val();    }    friend constexpr bool operator==(MLong lhs, MLong rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MLong lhs, MLong rhs) {        return lhs.val() != rhs.val();    }}; template<>ll MLong<0ll>::Mod = 1; template<int P>struct MInt {    int x;    constexpr MInt() : x{} {}    constexpr MInt(ll x) : x{norm(x % getMod())} {}        static int Mod;    constexpr static int getMod() {        if (P > 0) {            return P;        } else {            return Mod;        }    }    constexpr static void setMod(int Mod_) {        Mod = Mod_;    }    constexpr int norm(int x) const {        if (x < 0) {            x += getMod();        }        if (x >= getMod()) {            x -= getMod();        }        return x;    }    constexpr int val() const {        return x;    }    explicit constexpr operator int() const {        return x;    }    constexpr MInt operator-() const {        MInt res;        res.x = norm(getMod() - x);        return res;    }    constexpr MInt inv() const {        assert(x != 0);        return power(*this, getMod() - 2);    }    constexpr MInt &operator*=(MInt rhs) & {        x = 1ll * x * rhs.x % getMod();        return *this;    }    constexpr MInt &operator+=(MInt rhs) & {        x = norm(x + rhs.x);        return *this;    }    constexpr MInt &operator-=(MInt rhs) & {        x = norm(x - rhs.x);        return *this;    }    constexpr MInt &operator/=(MInt rhs) & {        return *this *= rhs.inv();    }    friend constexpr MInt operator*(MInt lhs, MInt rhs) {        MInt res = lhs;        res *= rhs;        return res;    }    friend constexpr MInt operator+(MInt lhs, MInt rhs) {        MInt res = lhs;        res += rhs;        return res;    }    friend constexpr MInt operator-(MInt lhs, MInt rhs) {        MInt res = lhs;        res -= rhs;        return res;    }    friend constexpr MInt operator/(MInt lhs, MInt rhs) {        MInt res = lhs;        res /= rhs;        return res;    }    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {        ll v;        is >> v;        a = MInt(v);        return is;    }    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {        return os << a.val();    }    friend constexpr bool operator==(MInt lhs, MInt rhs) {        return lhs.val() == rhs.val();    }    friend constexpr bool operator!=(MInt lhs, MInt rhs) {        return lhs.val() != rhs.val();    }}; template<>int MInt<0>::Mod = 1; template<int V, int P>constexpr MInt<P> CInv = MInt<P>(V).inv(); constexpr int P = 998244353;using Z = MInt<P>; struct Comb {    int n;    std::vector<Z> _fac;    std::vector<Z> _invfac;    std::vector<Z> _inv;        Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}    Comb(int n) : Comb() {        init(n);    }        void init(int m) {        if (m <= n) return;        _fac.resize(m + 1);        _invfac.resize(m + 1);        _inv.resize(m + 1);                for (int i = n + 1; i <= m; i++) {            _fac[i] = _fac[i - 1] * i;        }        _invfac[m] = _fac[m].inv();        for (int i = m; i > n; i--) {            _invfac[i - 1] = _invfac[i] * i;            _inv[i] = _invfac[i] * _fac[i - 1];        }        n = m;    }        Z fac(int m) {        if (m > n) init(2 * m);        return _fac[m];    }    Z invfac(int m) {        if (m > n) init(2 * m);        return _invfac[m];    }    Z inv(int m) {        if (m > n) init(2 * m);        return _inv[m];    }    Z binom(int n, int m) {        if (n < m || m < 0) return 0;        return fac(n) * invfac(m) * invfac(n - m);    }} comb; using u64 = unsigned long long;std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());\xa0void solve() {\tint n; cin >> n;\tvi a(n), cnt(n);\tfor (int i = 0; i < n; i ++) {\t\tcin >> a[i];\t\tcnt[a[i]] ++;\t}\tvector<vector<Z>> dp(n);\tint tot = n;\tvector<Z> pw(n + 1);\tpw[0] = 1;\tZ ans = 0;\tfor (int i = 1; i <= n; i ++) pw[i] = pw[i - 1] * 2;\tfor (int i = 0; i < n; i ++) {\t\tdp[i].resize(cnt[i] + 1);\t\tfor (int j = 1; j <= cnt[i]; j ++) dp[i][j] = comb.binom(cnt[i], j);\t\tif (i) {\t\t\tZ sum = 0;\t\t\tfor (int j = cnt[i]; j; j --) {\t\t\t\tZ tp = 0;\t\t\t\tif (j <= cnt[i - 1]) tp += dp[i][j] * dp[i - 1][j] + sum * (dp[i - 1][j] - (j<cnt[i-1]?dp[i-1][j+1] : 0));\t\t\t\tsum += dp[i][j];\t\t\t\tdp[i][j] = tp;\t\t\t}\t\t}\t\ttot -= cnt[i];\t\tfor (int j = 1; j <= cnt[i]; j ++) {\t\t\tans += pw[tot] * j * dp[i][j];\t\t}\t\tfor (int j = cnt[i] - 1; j > 0; j --) dp[i][j] += dp[i][j + 1];\t}\tcout << ans << endl;}\xa0int main() {#ifndef ONLINE_JUDGE\tfreopen(""in.txt"", ""r"", stdin);//\tfreopen(""out.txt"", ""w"", stdout);#endif\xa0\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\xa0\tint tc = 1;\tcin >> tc;\twhile (tc --) solve();\xa0\treturn 0;}']","[1, 1, 1, 1, 1]",2200,Problem Credits Proof by QED cry satyam343 Analysis cry Solution Observation The score of is equivalent to where stores the frequency of integer in Intuition We can greedily construct the arrays by repeating this step Select the minimum such that and and construct the array This is optimal because every element we add will increase the MEX by which will increase the score by If we add the MEX will not increase Also when we add an element we cannot increase the score by more than Adding less than elements cannot increase MEX for future arrays From this observation we can see that only the frequency array of matters From now on let s denote the frequency of in as We can find the sum over all subsequences using dynamic programming Let s denote as the number of subsequences containing only the first integers and Initially To transition we need to consider two cases In the first case let s assume The number of subsequences that can be created is That is all the subsequences from previous length such that it is possible for to be the new minimum multiplied by the number of subsequences where In the second case let s assume The number of subsequences that can be created is That is all subsequences containing at least elements of multiplied by all previous subsequences with minimum already equal to The total score is over the length of the prefix and prefix minimum We can speed up the calculations for both cases using suffix sums however this still yields an algorithm However is bounded to the interval for each Since the sum of is the total number of secondary states is This becomes just a constant factor so the total complexity is 
You are given two integers x and y A sequence a of length n is called if a 1 x and for all 1 i le n the value of a i is either a i 1 y or a i 1 bmod y Here x bmod y denotes the remainder from dividing x by y Determine if there exists a modular sequence of length n with the sum of its elements equal to S and if it exists find any such sequence ,"['#include<bits/stdc++.h>\n\nint main() {\n        std::cin.tie(nullptr)->sync_with_stdio(false);\n\n        int t;\n        std::cin >> t;\n        while (t--) {\n                int n, x, y, s;\n                std::cin >> n >> x >> y >> s;\n                long long st = x / y;\n                if (s < 1ll * (x % y) * n) {\n                        std::cout << ""NO\\n"";\n                        continue;\n                }\n                s -= (x % y) * n;\n                std::vector<int> dp(s + 1, 1e9);\n                std::vector<int> par(s + 1, -1);\n                dp[0] = 0;\n                for (int i = 0; i <= s; ++i) {\n                        for (int j = 1; i + j * (j - 1) / 2 * y <= s; ++j) {\n                                int k = i + j * (j - 1) / 2 * y;\n                                if (dp[k] > dp[i] + j) {\n                                        dp[k] = dp[i] + j;\n                                        par[k] = j;\n                                }\n                        }\n                }\n                bool ok = false;\n                for (int d = 1; (2 * st + d - 1) * d / 2 * y <= s; ++d) {\n                        if (d + dp[s - (2 * st + d - 1) * d / 2 * y] <= n) {\n                                std::cout << ""YES\\n"";\n                                std::vector<int> ans(n, x % y);\n                                int ptr = 0;\n                                for (int i = 0; i < d; ++i, ++ptr) ans[ptr] += (st + i) * y;\n                                int u = s - (2 * st + d - 1) * d / 2 * y;\n                                while (u != 0) {\n                                        int k = par[u];\n                                        u -= k * (k - 1) / 2 * y;\n                                        for (int i = 0; i < k; ++i, ++ptr) ans[ptr] += i * y;\n                                }\n                                for (auto i : ans) std::cout << i << \' \';\n                                std::cout << \'\\n\';\n                                ok = true;\n                                break;\n                        }\n                }\n                if (!ok) std::cout << ""NO\\n"";\n        }\n}']","[1, 1, 0, 1, 0]",2300,SolutionLet s see what the answer will look like first there will be a prefix of the form and then there will be some number of blocks of the form We can subtract the number from all the elements of the sequence and then divide all the elements by all the elements will be divisible by since they initially had a remainder of Let Then our sequence will start with and then there will be blocks of the form Let s calculate these values the minimum length of a sequence of blocks of the form with a sum of This value can be calculated for all numbers from to using dynamic programming If we have processed all values from to then for we have calculated the minimum length and we can update the value of for a total of values not exceeding In this same we can store through which values we were recalculated for the restoration of the answer Now we can iterate over the length of the first block of the form Then we know the sum of the remaining blocks and using the precalculated we can determine whether the desired sequence can be formed or not 
You can t possibly imagine how cold our friends are this winter in Nvodsk Two of them play the following game to warm up initially a piece of paper has an integer During a move a player should write any integer number that is a divisor of the last written number Then he should run this number of circles around the hotel Let us remind you that a number s divisor is called if it is different from one and from the divided number itself The first person who as he continues to lie in his warm bed under three blankets while the other one keeps running Determine which player wins considering that both players play optimally If the first player wins print any winning first move ,"['#pragma comment (linker, ""/STACK:200000000"")\n#define _SECURE_SCL 0\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <stack>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int INF = (int) 1E9;\nconst int64 INF64 = (int64) 1E18;\nconst double EPS = 1E-9;\nconst double PI = acos((double)0) * 2;\n\n#define forn(i,n)  for (int i=0; i<int(n); ++i)\n#define ford(i,n)  for (int i=int(n)-1; i>=0; --i)\n#define fore(i,l,n)  for (int i=int(l); i<int(n); ++i)\n#define all(a)  a.begin(), a.end()\n#define fs  first\n#define sc  second\n#define pb  push_back\n#define mp  make_pair\n\n\nint64 n;\n\n\nbool read() {\n\treturn !! (cin >> n);\n}\n\n\nint64 mindiv (int64 n) {\n\tfor (int64 i=2; i*i<=n; ++i)\n\t\tif (n % i == 0)\n\t\t\treturn i;\n\treturn -1;\n}\n\nvoid solve() {\n\tint64 p = mindiv (n);\n\n\tif (p == -1) {\n\t\tcout << ""1\\n0\\n"";\n\t\treturn;\n\t}\n\n\tint64 q = mindiv (n / p);\n\tif (q != -1) {\n\t\tcout << ""1\\n"" << p*q << \'\\n\';\n\t\treturn;\n\t}\n\n\tcout << ""2\\n"";\n}\n\n\nint main() {\n#ifdef SU2_PROJ\n\tfreopen (""input.txt"", ""rt"", stdin);\n\tfreopen (""output.txt"", ""wt"", stdout);\n\twhile (read())\n\t\tsolve();\n#else\n\tif (!read())  throw;\n\tsolve();\n#endif\n}']","[0, 1, 0, 0, 0]",1400,if is prime or than it s victory We loose if or where and are prime It is quite obvious that it is always possible to move in bad position in any other case That means all other numbers grants us the victory We only have to check if has a divisor of the loose type We can easily do it in time 
You are given a rooted tree consisting of n vertices Vertices are numbered from 1 to n Any vertex can be the root of a tree A is a connected undirected graph without cycles A is a tree with a selected vertex which is called the The tree is specified by an array of parents p containing n numbers p i is a parent of the vertex with the index i The of a vertex u is a vertex that is the next vertex on the shortest path from u to the root For example on the simple path from 5 to 3 the root the next vertex would be 1 so the parent of 5 is 1 The root has no parent so for it the value of p i is i the root is the only vertex for which p i i Find such a set of paths that each vertex belongs to exactly one path each path can contain one or more vertices in each path each next vertex is a son of the current vertex that is paths always lead down from parent to son number of paths is For example if n 5 and p 3 1 3 3 1 then the tree can be divided into three paths 3 rightarrow 1 rightarrow 5 path of 3 vertices 4 path of 1 vertices 2 path of 1 vertices ,"['#include <cmath>\n#include <cstdio>\n#include <string>\n#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\ninline int read(){\n\tint t = 0,f = 1;\n\tregister char c = getchar();\n\twhile (c < 48 || c > 57) f = (c == \'-\') ? (-1) : (f),c = getchar();\n\twhile (c >= 48 && c <= 57) t = (t << 1) + (t << 3) + (c ^ 48),c = getchar();\n\treturn f * t;\n}\n\ninline int reads(char* s){\n\tint t = 0;\n\tregister char c = getchar();\n\twhile (c != \'1\' && c != \'0\' && c != \'?\') c = getchar();\n\twhile (c == \'1\' || c == \'0\' || c == \'?\') s[++t] = c,c = getchar();\n\treturn t;\n}\n\nconst int N = 2e5;\nint T,rt,n,ans,etot,stop,fa[N + 1],indeg[N + 1],head[N + 1],stk[N + 1];\n\nstruct Edge{\n\tint u,v,next;\n}e[(N << 1) + 1];\n\nvoid adde(int u,int v) {e[++etot] = (Edge){u,v,head[u]},head[u] = etot;}\n\nvoid dfs(int now,int f){\n\tstk[++stop] = now;\n\tif (!indeg[now]){\n\t\tprintf(""%d\\n"",stop);\n\t\tfor (int i = 1;i <= stop;i++) printf(""%d "",stk[i]);\n\t\tputchar(\'\\n\');\n\t\tstop = 0;\n\t\treturn ;\n\t}\n\tfor (int i = head[now];i;i = e[i].next){\n\t\tif (e[i].v == f) continue;\n\t\tdfs(e[i].v,now);\n\t}\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(""in.in"",""r"",stdin);\n\tfreopen(""out.out"",""w"",stdout);\n\t#endif\n\tT = read();\n\twhile (T--){\n\t\tn = read();\n\t\tans = stop = etot = 0;\n\t\tfor (int i = 1;i <= n;i++) indeg[i] = 0,fa[i] = 0,head[i] = 0;\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tfa[i] = read();\n\t\t\tif (fa[i] != i) ++indeg[fa[i]],adde(i,fa[i]),adde(fa[i],i);\n\t\t\telse rt = i;\n\t\t}\n\t\tfor (int i = 1;i <= n;i++){\n\t\t\tif (!indeg[i]) ++ans;\n\t\t}\n\t\tprintf(""%d\\n"",ans);\n\t\tdfs(rt,0);\n\t\tputchar(\'\\n\');\n\t}\n\treturn 0;\n}']","[0, 0, 1, 0, 0]",1300,Let s find a set of leaves of a given tree From each leaf we will climb up the tree until we meet a vertex already visited Having met such a vertex start a new path from the next leaf The sequence of vertices in the found paths must be deduced in reverse order because the paths must go from bottom to top It also follows from this solution that the number of paths will always be equal to the number of leaves in the tree 
According to a legend the Hanoi Temple holds a permutation of integers from 1 to n There are n stones of distinct colors lying in one line in front of the temple Monks can perform the following operation on stones choose a position i 1 le i le n and cyclically shift stones at positions i p i p p i That is a stone from position i will move to position p i a stone from position p i will move to position p p i and so on a stone from position j such that p j i will move to position i Each day the monks must obtain a new arrangement of stones using an arbitrary number of these operations When all possible arrangements will have been obtained the world will end You are wondering what if some elements of the permutation could be swapped just before the beginning How many days would the world last You want to get a permutation that will allow the world to last as long as possible using the minimum number of exchanges of two elements of the permutation Two arrangements of stones are considered different if there exists a position i such that the colors of the stones on that position are different in these arrangements ,"['#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 1000005;\nconst ll MOD = 1000000007;\n\nint T,n,tot;\nint p[MAXN];\nint c[MAXN];\n\nbool vis[MAXN];\nmap<int,int> f[MAXN][3];\n\nint solve(int c3,int c2)\n{\n\tint res = 1e9;\n\tfor (int i = 0;i <= n;i++)\n\t\tfor (int j = 0;j <= 2;j++)\n\t\t\tf[i][j].clear();\n\tf[0][0][0] = -1e9;\n\tfor (int i = 0;i <= tot;i++)\n\t\tfor (int j = 0;j <= c2;j++)\n\t\t{\n\t\t\tfor (map<int,int>::iterator it = f[i][j].begin();it != f[i][j].end();it++)\n\t\t\t{\n\t\t\t\tint k = it->first,V = it->second;\n\t\t\t\tif (i == tot)\n\t\t\t\t{\n\t\t\t\t\tif (c2 - j == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k >= 0)\n\t\t\t\t\t\t\tres = min(res,V + k / 3 * 2);\n\t\t\t\t\t\tif (k < 0)\n\t\t\t\t\t\t\tres = min(res,V - k);\n\t\t\t\t\t}\n\t\t\t\t\tif (c2 - j == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k >= 2)\n\t\t\t\t\t\t\tres = min(res,V + (k - 2) / 3 * 2 + 1);\n\t\t\t\t\t\tif (k <= -1)\n\t\t\t\t\t\t\tres = min(res,V + (-k - 1));\n\t\t\t\t\t}\n\t\t\t\t\tif (c2 - j == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k == 1)\n\t\t\t\t\t\t\tres = min(res,V + 1);\n\t\t\t\t\t\tif (k >= 4)\n\t\t\t\t\t\t\tres = min(res,V + (k - 4) / 3 * 2 + 2);\n\t\t\t\t\t\tif (k <= -2)\n\t\t\t\t\t\t\tres = min(res,V + (-k - 2));\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int l = 0;j + l <= c2;l++)\n\t\t\t\t\tif (l * 2 <= c[i + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tint t = (c[i + 1] - l * 2) / 3,el = (c[i + 1] - l * 2) % 3;\n\t\t\t\t\t\tint tim = (l + t + (bool)el - (l == 2) - 1);\n\t\t\t\t\t\tif (!el)\n\t\t\t\t\t\t\tf[i + 1][j + l][k] = min(f[i + 1][j + l][k],V + tim);\n\t\t\t\t\t\tif (el == 1)\n\t\t\t\t\t\t\tf[i + 1][j + l][k + 1] = min(f[i + 1][j + l][k + 1],V + tim + (k < 0));\n\t\t\t\t\t\tif (el == 2)\n\t\t\t\t\t\t\tf[i + 1][j + l][k - 1] = min(f[i + 1][j + l][k - 1],V + tim + (k > 0));\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\treturn res + 1e9;\n}\n\nint main()\n{\n\tscanf(""%d"",&T);\n\twhile (T--)\n\t{\n\t\tscanf(""%d"",&n);\n\t\tfor (int i = 1;i <= n;i++)\n\t\t{\n\t\t\tscanf(""%d"",&p[i]);\n\t\t\tvis[i] = 0;\n\t\t}\n\t\ttot = 0;\n\t\tfor (int i = 1;i <= n;i++)\n\t\t{\n\t\t\tint u = i,len = 0;\n\t\t\tif (vis[u])\n\t\t\t\tcontinue;\n\t\t\twhile (!vis[u])\n\t\t\t{\n\t\t\t\tvis[u] = 1;\n\t\t\t\tu = p[u];\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tc[++tot] = len;\n\t\t}\n\t\tll ans = 1;\n\t\tint ans2 = 0;\n\t\tfor (int i = 0;i <= 2;i++)\n\t\t\tif ((n - i * 2) % 3 == 0)\n\t\t\t{\n\t\t\t\tint t = (n - i * 2) / 3;\n\t\t\t\tfor (int j = 1;j <= t;j++)\n\t\t\t\t\t(ans *= 3) %= MOD;\n\t\t\t\tfor (int j = 1;j <= i;j++)\n\t\t\t\t\t(ans *= 2) %= MOD;\n\t\t\t\tans2 = solve(t,i);\n\t\t\t}\n\t\tprintf(""%lld %d\\n"",ans,ans2);\n\t}\n\treturn 0;\n}']","[1, 1, 1, 0, 0]",3000,The problem boils down to getting an array consisting of threes and a remainder 2 or 2 2 or 4 using split and merge operations It helps to think that all merge operations are done before split operations To solve the problem you can brute which elements of the array the remainder is subtracted from then the rest of the operations are done greedily Bonus Given k We need to get an array consisting of k using these operations Assume that the sum of the array elements is divisible by k This can be represented as minimum cover of the hypergraph by edges with weights number of vertices 1 sum of elements k 1 Is there a polynomial solution k is a parameter 
You are given a string consisting of small english letters In one move you can replace any character of this string to the next character in alphabetical order will be replaced with will be replaced with etc You cannot replace letter with any other letter Your target is to make some number of moves not necessary minimal to get string english alphabet as a subsequence Subsequence of the string is the string that is obtained by deleting characters at some positions You need to print the string that will be obtained from the given string and will be contain english alphabet as a subsequence or say that it is impossible ,"['// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored ""-Wunused-result""\n#pragma GCC diagnostic ignored ""-Wunused-function""\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(""%d"", &x); }\nvoid _R(int64_t &x) { scanf(""%"" SCNd64, &x); }\nvoid _R(double &x) { scanf(""%lf"", &x); }\nvoid _R(char &x) { scanf("" %c"", &x); }\nvoid _R(char *x) { scanf(""%s"", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(""%d"", x); }\nvoid _W(const int64_t &x) { printf(""%"" PRId64, x); }\nvoid _W(const double &x) { printf(""%.16f"", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(""%s"", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(\' \'); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? \' \' : \'\\n\'); W(tail...); }\n\n#ifdef SHIK\n#include ""dump.hpp""\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\nconst int N=1e5+10;\nchar s[N];\nvoid main() {\n    R(s);\n    int n=strlen(s);\n    char c=\'a\';\n    REP(i,n) {\n        if ( c>\'z\' || s[i]>c ) continue;\n        s[i]=c++;\n    }\n    if ( c>\'z\' ) W(s);\n    else W(-1);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n']","[1, 0, 0, 0, 0]",1300,The problem can be solved by the next greedy algorithm At first we need to store the last character of the alphabet we haven t obtained for example in variable initially it will be equal to Then we will just iterate over all characters of the string from left to right and if the current character of the string is not greater than we just replace it to and increase by 1 If in any moment will be greater than we got the answer And if after iterating over the string will be not greater than the answer is 1 
Polycarp is very fond of playing the game Minesweeper Recently he found a similar game and there are such rules There are mines on the field for each the coordinates of its location are known x i y i Each mine has a lifetime in seconds after which it will explode After the explosion the mine also detonates all mines vertically and horizontally at a distance of k two perpendicular lines As a result we get an explosion on the field in the form of a plus symbol Thus one explosion can cause new explosions and so on Also Polycarp can detonate anyone mine every second starting from zero seconds After that a chain reaction of explosions also takes place Mines explode and also detonate other mines according to the rules described above Polycarp wants to set a new record and asks you to help him calculate in what minimum number of seconds all mines can be detonated ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nifstream fin(""AAtest.in.txt"");\nstruct miin{\n    ll ul,x,y,all,aeg;\n};\nll t,n,k;\nmiin v[200005];\nvector<ll> p,u;\n\nbool boo(ll e,ll p){\n    if(v[e].x!=v[p].x) return v[e].x<v[p].x;\n    return v[e].y<v[p].y;\n}\n\nvoid uhenda(ll l,ll r){\n    while(v[l].ul!=l) l=v[l].ul;\n    while(v[r].ul!=r) r=v[r].ul;\n    if(l!=r) if(v[l].all<v[r].all) v[l].ul=r,v[r].aeg=min(v[r].aeg,v[l].aeg);\n    else v[r].ul=l,v[l].all=max(v[l].all,v[r].all+1),v[l].aeg=min(v[l].aeg,v[r].aeg);\n}\n\nvoid tee(){\n    sort(p.begin(),p.end(),boo);\n    ll l,r;\n    l=0; r=0;\n    while(l<p.size()){\n        while(r<p.size() && v[p[r]].x==v[p[l]].x && v[p[r]].y<=v[p[l]].y+k){\n            uhenda(p[l],p[r]);\n            r++;\n        }\n        l++;\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cerr.tie(0);\n    cin>>t;\n    while(t--){\n        cin>>n>>k;\n        p.resize(0);\n        for(int i=0; i<n; i++) cin>>v[i].x>>v[i].y>>v[i].aeg,v[i].ul=i,p.push_back(i),v[i].all=0;\n        tee();\n        for(int i=0; i<n; i++) swap(v[i].x,v[i].y);\n        tee();\n        u.resize(0);\n        for(int i=0; i<n; i++) if(v[i].ul==i) u.push_back(v[i].aeg);\n        sort(u.begin(),u.end());\n        ll z=0,se=0;\n        while(z<u.size()){\n            u.pop_back();\n            while(z<u.size() && u[z]<=se) z++;\n            se++;\n        }\n        cout<<se-1<<""\\n"";\n    }\n}\n']","[1, 0, 0, 0, 0]",2000,Our first task is to separate mines into components We will store in the hashmap at the coordinate all the coordinates where there is a mine Let s do the same with the hashmap Thus going through the available arrays in and we connect adjacent elements into one component if also with As a result we have components where if you detonate one mine in the s component then all the mines belonging to this component will also explode Further we find a mine with a minimum timer in each component Finding the minimum for each component we store it conditionally in the array Now we know at what minimum time some component will explode if it is left unaffected To answer it remains to find in the sorted array such a minimum index that is min And the general asymptotic behavior is 
DZY owns islands near his home numbered from to He loves building bridges to connect the islands Every bridge he builds takes one day s time to walk across DZY has a strange rule of building the bridges For every pair of islands he has built different bridges connecting them where means is divisible by These bridges are bidirectional Also DZY has built some bridges connecting his home with the islands Specifically there are different bridges from his home to the th island These are one way bridges so after he leaves his home he will never come back DZY decides to go to the islands for sightseeing At first he is at home He chooses and walks across one of the bridges connecting with his home and arrives at some island After that he will spend day s on the islands Each day he can choose to stay and rest or to walk to another island across the bridge It is allowed to stay at an island for more than one day It s also allowed to cross one bridge more than once Suppose that right after the th day DZY stands at the th island Let be the number of ways for DZY to reach the th island after th day Your task is to calculate for each modulo ,"['#include <stdio.h>\n#include <memory.h>\ntypedef __int64 ll;\n#define mod 1051131\n#define M 26\n#define N 1+(1<<25)\n\nint n,m;\nll t;\nint a[M],b[M],c[M];\nint y[N], f[N], x[N];\n\n\nvoid mul(int a[M],int b[M],int c[M]) {\n\tint i,j,k;\n\tc[0]=(ll)a[0]*b[0]%mod;\n\tfor(i=1;i<=n;i++) c[0]=(c[0]+(((ll)a[i]*b[i])%mod)*(1<<(n-i)))%mod;\n\tfor(k=1;k<=n;k++) {\n\t\tc[k]=(ll)a[0]*b[k]%mod;\n\t\tfor(i=1;i<k;i++) c[k]=(c[k]+(((ll)a[i]*b[i])%mod)*(1<<(n-i)))%mod;\n\t\tfor(i=k+1;i<=n;i++) c[k]=(c[k]+(((ll)a[i]*b[k])%mod)*(1<<(n-i)))%mod;\n\t\tfor(i=k+1;i<=n;i++) c[k]=(c[k]+(((ll)a[k]*b[i])%mod)*(1<<(n-i)))%mod;\n\t\tc[k]=(c[k]+(ll)a[k]*b[0])%mod;\n\t}\n}\n\nvoid mypow(ll p) {\n\tif(p==1) return;\n\tint d[M];\n\tmemcpy(d,a,sizeof(a));\n\tmypow(p/2);\n\tmul(a,a,b);\n\tif(p&1) {\n\t\tmemcpy(c,b,sizeof(b));\n\t\tmul(d,c,b);\n\t}\n\tmemcpy(a,b,sizeof(b));\n}\n\nint main(){\n\t//freopen(""E2.in"", ""r"", stdin);\n\tint i,j,k;\n\tscanf(""%d %I64d %d"",&n,&t,&m);\n\tfor(i=0;i<m;i++) scanf(""%d"",&x[i]);\n\tfor(i=m;i<(1<<n);i++) x[i]=(x[i-m]*101+10007)%mod;\n\ta[0]=1;\n\tfor(i=1;i<=n;i++) a[i]=(1<<(i-1))%mod;\n\tmypow(t);\n\n\tint ans=0;\n\tint nn=n*4/5+1;\n\n\tfor(i=0; i<(1<<n); i++)f[i]=x[i];\n\tfor(i=n-1; i>=0; i--){\n\t\tint u=1<<i;\n\t\tif(i<nn){\n\t\t\tfor(k=0; k<(1<<nn); k++){\n\t\t\t\ty[k] = (y[k]+(ll)a[i+1]*f[u])%mod;\n\t\t\t\tu--;\n\t\t\t\tif(u==-1)u=(1<<(i+1))-1;\n\t\t\t}\n\t\t}\n\t\tfor(k=0; k<(1<<i); k++){\n\t\t\tf[k]=(f[k]+f[k+(1<<i)]);\n\t\t\tif(f[k]>=mod)f[k]-=mod;\n\t\t}\n\t}\n\n\tfor(k=(1<<nn); k<(1<<n); k++){\n\t\ty[k]=y[k-(1<<nn)];\n\t}\n\tfor(i=0; i<(1<<n); i++)f[i]=x[i];\n\tfor(i=n-1; i>=nn; i--){\n\t\tint u=1<<i;\n\t\tfor(k=0; k<(1<<n); k++){\n\t\t\ty[k] = (y[k]+(ll)a[i+1]*f[u])%mod;\n\t\t\tu--;\n\t\t\tif(u==-1)u=(1<<(i+1))-1;\n\t\t}\n\t\tfor(k=0; k<(1<<i); k++){\n\t\t\tf[k]=(f[k]+f[k+(1<<i)]);\n\t\t\tif(f[k]>=mod)f[k]-=mod;\n\t\t}\n\t}\n\tfor(k=0; k<(1<<n); k++)y[k]=(y[k]+(ll)a[0]*x[((1<<n)-k)&((1<<n)-1)])%mod, ans^=y[k];\n\tprintf(""%d\\n"", ans);\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0]",3100,Let For convenience we use indices here instead of so we define Obviously this problem requires matrix multiplication We define row vector and matrix where The answer is row vector Since can be up to we need a more efficient way to calculate Let denote the matrix when For example Define then we can easily find that where denotes the identity matrix For an matrix and a constant we can prove by induction that Let be two vectors then we have This result seems useful Suppose we want to find where we have so we just need to find which is a self similar problem By recursion it can be solved in time 
Alice and Bob are playing a game with strings There will be t rounds in the game In each round there will be a string s consisting of lowercase English letters Alice moves first and both the players take alternate turns More formally if there was a string s s 1s 2 ldots s k the player can choose a substring s ls l 1 ldots s r 1 s r with length of corresponding parity and remove it After that the string will become s s 1 ldots s l 1 s r 1 ldots s k After the string becomes empty the round ends and each player calculates his her score for this round The score of a player is the sum of values of all characters removed by him her The value of texttt a is 1 the value of texttt b is 2 the value of texttt c is 3 ldots and the value of texttt z is 26 The player with higher score wins the round For each round determine the winner and the difference between winner s and loser s scores Assume that both players play optimally to maximize their score It can be proved that a draw is impossible ,"['#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=(l);i<=(r);i++)\n#define per(i,l,r) for(int i=(l);i>=(r);i--)\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define mset(s,t) memset(s,t,sizeof(s))\n#define mcpy(s,t) memcpy(s,t,sizeof(t))\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define eb emplace_back\n#define fir first\n#define sec second\n\ntemplate<class T1,class T2>bool ckmax(T1 &a,T2 b){if(a<b)return a=b,1;else return 0;}\ntemplate<class T1,class T2>bool ckmin(T1 &a,T2 b){if(a>b)return a=b,1;else return 0;}\n\ninline int read(){\n    int x=0,f=0;char ch=getchar();\n    while(!isdigit(ch))f|=ch==\'-\',ch=getchar();\n    while(isdigit(ch))x=10*x+ch-\'0\',ch=getchar();\n    return f?-x:x;\n}\ntemplate<typename T>void print(T x){\n    if(x<0)putchar(\'-\'),x=-x;\n    if(x>=10)print(x/10);\n    putchar(x%10+\'0\');\n}\ntemplate<typename T>void print(T x,char ch){\n    print(x),putchar(ch);\n}\n\nvoid solve(){\n    string a;\n    cin>>a;\n    if(SZ(a)%2==0){\n        int ans=0;\n        for(int i=0;i<SZ(a);i++)ans+=a[i]-\'a\'+1;\n        printf(""Alice %d\\n"",ans);\n    }else{\n        int k1=0,k2=0;\n        for(int i=0;i<SZ(a)-1;i++)k1+=a[i]-\'a\'+1;\n        k1-=a[SZ(a)-1]-\'a\'+1;\n        for(int i=1;i<SZ(a);i++)k2+=a[i]-\'a\'+1;\n        k2-=a[0]-\'a\'+1;\n        if(k1<k2)swap(k1,k2);\n        if(k1>0)printf(""Alice %d\\n"",k1);\n        else printf(""Bob %d\\n"",-k1);\n    }\n}\n\nint main(){\n    int T=read();\n    while(T--)solve();\n    return 0;\n}']","[1, 0, 0, 0, 0]",800,TutorialThe problem can be solved greedily Let be the length of the given string If the is even it is always optimal for Alice to remove the whole string If the is odd it is always optimal for Alice to remove either or based on which gives the higher score and then Bob can remove the remaining character or respectively This is optimal because if Alice chooses to remove a substring of even length such that then Bob can remove the remaining characters one of which will always be either or thus increasing Bob s score and decreasing Alice s score 
A championship is held in Berland in which n players participate The player with the number i has a i a i ge 1 tokens The championship consists of n 1 games which are played according to the following rules in each game two random players with non zero tokens are selected the player with more tokens is considered the winner of the game in case of a tie the winner is chosen randomly the winning player takes all of the loser s tokens The last player with non zero tokens is the winner of the championship All random decisions that are made during the championship are made equally probable and independently For example if n 4 a 1 2 4 3 then one of the options for the game there could be other options is during the first game the first and fourth players were selected The fourth player has more tokens so he takes the first player s tokens Now a 0 2 4 4 during the second game the fourth and third players were selected They have the same number of tokens but in a random way the third player is the winner Now a 0 2 8 0 during the third game the second and third players were selected The third player has more tokens so he takes the second player s tokens Now a 0 0 10 0 the third player is declared the winner of the championship Championship winners will receive personalized prizes Therefore the judges want to know in advance which players have a chance of winning i e have a non zero probability of winning the championship You have been asked to find all such players ,"[""#include<iostream>\n#include<string>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nvector<pair<int, int>> v;\nvector<int> ans;\n\nint main()\n{\n\tint t;\n\tint n;\n\tint x;\n\tint i;\n\tint s;\n\tlong long sum;\n\n\tcin >> t;\n\twhile (t--)\n\t{\n\t\tv.clear();\n\n\t\tcin >> n;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tcin >> x;\n\t\t\tv.push_back(make_pair(x, i + 1));\n\t\t}\n\n\t\tsort(v.begin(), v.end());\n\n\t\tif (v[0].first == v[n - 1].first)\n\t\t{\n\t\t\tcout << n << '\\n';\n\t\t\tfor (i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tcout << i << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tans.clear();\n\t\tsum = 0;\n\t\ts = 0;\n\t\tfor (i = 0; i < n; i++)\n\t\t{\n\t\t\tif (sum < v[i].first)\n\t\t\t{\n\t\t\t\ts = i;\n\t\t\t}\n\n\t\t\tsum += v[i].first;\n\t\t}\n\n\t\tfor (i = s; i < n; i++)\n\t\t{\n\t\t\tans.push_back(v[i].second);\n\t\t}\n\n\t\tsort(ans.begin(), ans.end());\n\n\t\tcout << ans.size() << '\\n';\n\t\tfor (i = 0; i < ans.size(); i++)\n\t\t{\n\t\t\tcout << ans[i] << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n}""]","[1, 0, 0, 0, 1]",1400,How can a player be checked if he can win the championship Obviously he must participate in all the games otherwise we will increase the number of tokens of the opponents So you can sort out all the people and play greedily with the weakest ones Such a check will work in linear time after sorting so we got a solution for The simplest solution to this problem is binary search for the answer We will sort all the players by the number of tokens they have Let s prove that if player can win then player can also win the numbers are dealt after sorting If the player was able to win then based on the strategy above he was able to defeat all the players on the prefix The player can also defeat all these players since he has at least as many tokens Now both players have to defeat all opponents with numbers and the number of chips both players have is equal to the sum of the first numbers in the array So if the player has a strategy then the player can use the same strategy Hence the answer to the problem is sorted suffix of the input array You can find this suffix using binary search and linear time checking Bonus this problem also has a fully linear after sorting solution 
Santa Claus is the first who came to the Christmas Olympiad and he is going to be the first to take his place at a desk In the classroom there are lanes of desks each and there are two working places at each of the desks The lanes are numbered from to from the left to the right the desks in a lane are numbered from to starting from the blackboard Note that the lanes go perpendicularly to the blackboard not along it see picture The organizers numbered all the working places from to The places are numbered by lanes i e all the places of the first lane go first then all the places of the second lane and so on in a lane the places are numbered starting from the nearest to the blackboard i e from the first desk in the lane at each desk the place on the left is numbered before the place on the right Santa Clause knows that his place has number Help him to determine at which lane at which desk he should sit and whether his place is on the left or on the right ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define fo(i,a,b) for(int i=(a);i<(b);i++)\n#define MOD 1000000007\n#define MP make_pair\n#define PB push_back\ntypedef long long ll;\n\nint N, M, K;\n\nint main () {\n\tscanf(""%d %d %d"", &N, &M, &K);\n\tint R = (K-1) / (2*M) + 1;\n\tint C = (((K-1) % (2*M))/2) + 1;\n\tprintf(""%d %d %c\\n"", R, C, (K&1) ? \'L\' : \'R\');\n\treturn 0;\n}\n']","[0, 1, 0, 0, 0]",800,It can be easily seen that the side on which Santa should sit depends only on the parity of k while the number of desk and the number of lane depend only on a value We can see that in such numeration the number of lane equals while the number of desk equals 
Homer has two friends Alice and Bob Both of them are string fans One day Alice and Bob decide to play a game on a string s s 1 s 2 dots s n of length n consisting of lowercase English letters They move in turns alternatively and In a move a player choose an index i 1 leq i leq n that has not been chosen before and change s i to any other lowercase English letter c that c neq s i When all indices have been chosen the game ends The goal of Alice is to make the final string lexicographically as small as possible while the goal of Bob is to make the final string lexicographically as large as possible Both of them are game experts so they always play games optimally Homer is not a game expert so he wonders what the final string will be A string a is lexicographically smaller than a string b if and only if one of the following holds a is a prefix of b but a ne b in the first position where a and b differ the string a has a letter that appears earlier in the alphabet than the corresponding letter in b ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fast_IO ios::sync_with_stdio(false);\n#define DEBUG fprintf(stderr,""Running on Line %d in Function %s\\n"",__LINE__,__FUNCTION__)\n//mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\n#define fir first\n#define sec second\n#define mod 998244353\n#define ll long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f3f\ninline int read()\n{\n\tchar ch=getchar(); int nega=1; while(!isdigit(ch)) {if(ch==\'-\') nega=-1; ch=getchar();}\n\tint ans=0; while(isdigit(ch)) {ans=ans*10+ch-48;ch=getchar();}\n\tif(nega==-1) return -ans;\n\treturn ans;\n}\ntypedef pair<int,int> pii;\nvoid print(vector<int> x){for(int i=0;i<(int)x.size();i++) printf(""%d%c"",x[i],"" \\n""[i==(int)x.size()-1]);}\nvoid work()\n{\n\tstring s; cin>>s;\n\tfor(int i=0;i<(int)s.length();i++)\n\t{\n\t\tif(i&1)\n\t\t{\n\t\t\tif(s[i]==\'z\') s[i]=\'y\';\n\t\t\telse s[i]=\'z\';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(s[i]==\'a\') s[i]=\'b\';\n\t\t\telse s[i]=\'a\';\n\t\t}\n\t}\n\tcout<<s<<endl;\n}\nsigned main()\n{\n\tint T=read(); while(T--) work();\n\treturn 0;\n}\n\n\n']","[1, 0, 0, 0, 0]",800,After some observations we can see that the players should always choose the most significant letter to change because it coordinates the lexicographical order of the final string most Therefore Alice will choose all odd indices while Bob will choose all even indices and then Alice will change all letters she choose to the smallest possible letters while Bob will change all letters he choose to the largest possible letters That is Alice will change letters to a if the original letter is not a and to b otherwise Bob will change letters to z if the original letter is not z and to y otherwise The time complexity is O n 
Today Osama gave Fadi an integer X and Fadi was wondering about the minimum possible value of max a b such that LCM a b equals X Both a and b should be positive integers LCM a b is the smallest positive integer that is divisible by both a and b For example LCM 6 8 24 LCM 4 12 12 LCM 2 3 6 Of course Fadi immediately knew the answer Can you be just like Fadi and find any such pair ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int> vector<T> create(size_t n){ return vector<T>(n); }\ntemplate<typename T, typename... Args> auto create(size_t n, Args... args){ return vector<decltype(create<T>(args...))>(n, create<T>(args...)); }\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tlong long x; cin >> x;\n\tvector<long long> all;\n\tfor(long long i = 2; i * i <= x; i++){\n\t\tif(x % i == 0){\n\t\t\tlong long cup = 1;\n\t\t\twhile(x % i == 0) x /= i, cup *= i;\n\t\t\tall.push_back(cup);\n\t\t}\n\t}\n\tif(x != 1) all.push_back(x);\n\tint len = all.size();\n\tlong long ans = 1ll<<60, A, B;\n\tfor(int i = 0; i < 1<<len; i++){\n\t\tlong long a = 1, b = 1;\n\t\tfor(int j = 0; j < len; j++){\n\t\t\tif((i>>j)&1) a *= all[j];\n\t\t\telse b *= all[j];\n\t\t}\n\t\tif(ans > max(a, b)) A = a, B = b;\n\t\tans = min(ans, max(a, b));\n\t}\n\tcout << A << ' ' << B << endl;\n\treturn 0;\n}\n""]","[0, 1, 0, 0, 0]",1400,There will always be a solution where and are coprime To see why let s prime factorize and If they share a prime factor we can omit all its occurrences from one of them precisely from the one that has fewer occurrences of that prime without affecting their Now let s prime factorize Since there will be at most distinct primes we can distribute them between and with a bruteforce For an easier implementation you can loop over all divisors of check if equals and minimize the answer with the pair Time complexity 
Bessie is out grazing on the farm which consists of n fields connected by m bidirectional roads She is currently at field 1 and will return to her home at field n at the end of the day The Cowfederation of Barns has ordered Farmer John to install one extra bidirectional road The farm has k special fields and he has decided to install the road between two different special fields He may add the road between two special fields that already had a road directly connecting them After the road is added Bessie will return home on the shortest path from field 1 to field n Since Bessie needs more exercise Farmer John must the length of this shortest path Help him ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n \nconst int N=201000;\nint q[N],vis[N],d1[N],d2[N];\nint n,m,k,spe[N],u,v;\nVI e[N];\n \nvoid bfs(int s,int *d) {\n\trep(i,1,n+1) vis[i]=0,d[i]=n+1;\n\tint t=0;\n\tvis[s]=1; d[s]=0;\n\tq[t++]=s;\n\trep(i,0,t) {\n\t\tint u=q[i];\n\t\tfor (auto v:e[u]) if (d[v]>d[u]+1) {\n\t\t\td[v]=d[u]+1;\n\t\t\tq[t++]=v;\n\t\t}\n\t}\n}\n \nint main() {\n\tscanf(""%d%d%d"",&n,&m,&k);\n\trep(i,0,k) scanf(""%d"",spe+i);\n\trep(i,0,m) {\n\t\tscanf(""%d%d"",&u,&v);\n\t\te[u].pb(v); e[v].pb(u);\n\t}\n\tbfs(1,d1);\n\tbfs(n,d2);\n\tsort(spe,spe+k,[&](int a,int b) {\n\t\treturn d1[a]-d2[a]<d1[b]-d2[b];\n\t});\n\tint ans=0;\n\trep(i,1,k) {\n\t\tans=max(ans,d1[spe[i-1]]+d2[spe[i]]+1);\n\t\t//assert(d1[spe[i-1]]+d2[spe[i]]+1<=d2[spe[i-1]]+d1[spe[i]]+1);\n\t}\n\tans=min(ans,d1[n]);\n\tprintf(""%d\\n"",ans);\n}']","[1, 0, 0, 0, 1]",1900,There are a few solutions that involve breadth first search BFS and sorting this is just one of them First let s use BFS to find the distance from fields and to each special field For a special field let denote the distance to node and denote the distance to We want to choose two fields and to maximize Without loss of generality suppose Now we want to maximize subject to This can be done by sorting by and iterating over while keeping a suffix maximum array of to compute Remember that an upper bound of the answer is the distance between field and Time Complexity 
Sereja is interested in intervals of numbers so he has prepared a problem about intervals for you An interval of numbers is a pair of integers Interval belongs to interval if the following condition is met Sereja wants to write out a sequence of intervals on a piece of paper At that no interval in the sequence can belong to some other interval of the sequence Also Sereja loves number very much and he wants some at least one interval in the sequence to have Sereja wonders how many distinct ways to write such intervals are there Help Sereja and find the required number of ways modulo Two ways are considered distinct if there is such that the th intervals in two corresponding sequences are not equal ,"['#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n\ntypedef long long ll;\n#define MOD 1000000007\n\nint N,M,X;\nint dp[2][320][320];\n\nint main(void){\n    int i,j,x;\n    \n    cin >> N >> M >> X;\n    X--;\n    \n    if(N > M){\n        cout << 0 << endl;\n        return 0;\n    }\n    \n    dp[0][0][0] = 1;\n    \n    REP(x,M){\n        int cur = x%2, next = (x+1)%2;\n        \n        REP(i,N+1) REP(j,N+1) dp[next][i][j] = 0;\n        \n        REP(i,N+1) REP(j,N+1) if(dp[cur][i][j] != 0){\n            if(x != X) dp[next][i][j] = (dp[next][i][j] + dp[cur][i][j]) % MOD;\n            if(x != X && i >= j+1) dp[next][i][j+1] = (dp[next][i][j+1] + dp[cur][i][j]) % MOD;\n            dp[next][i+1][j] = (dp[next][i+1][j] + dp[cur][i][j]) % MOD;\n            dp[next][i+1][j+1] = (dp[next][i+1][j+1] + dp[cur][i][j]) % MOD;\n        }\n    }\n    \n    ll ans = dp[M%2][N][N];\n    REP(i,N) ans = ans * (i+1) % MOD;\n    cout << ans << endl;\n    \n    return 0;\n}\n']","[0, 0, 0, 1, 0]",2700,We assume that the intervals are sorted and in the end we will multiply the answer by We can do so as all segments are different Consider two cases and It would seem that you need to write different dynamics for them but not difficult to show that in the first case the answer is always The second case is the following dynamics how many numbers we have considered only in this interval will be present number Also we will need an additional dynamic how many numbers are considered how many segments are already closed and does not belong to any segment There will be transfers since every number we can not begin and end with more than one segment Now we should add to our solution it is quite simple just add another parameter in our dynamics if we had such a element in the beginning of some interval or not With out dynamics it is not difficult 
Gorilla and Noobish Monk found three numbers n m and k m k They decided to construct a permutation dagger of length n For the permutation Noobish Monk came up with the following function g i is the sum of all the numbers in the permutation on a prefix of length i that are not greater than m Similarly Gorilla came up with the function f where f i is the sum of all the numbers in the permutation on a prefix of length i that are not less than k A prefix of length i is a subarray consisting of the first i elements of the original array For example if n 5 m 2 k 5 and the permutation is 5 3 4 1 2 then f 1 5 because 5 ge 5 g 1 0 because 5 2 f 2 5 because 3 5 g 2 0 because 3 2 f 3 5 because 4 5 g 3 0 because 4 2 f 4 5 because 1 5 g 4 1 because 1 le 2 f 5 5 because 2 5 g 5 1 2 3 because 2 le 2 Help them find a permutation for which the value of left sum i 1 n f i sum i 1 n g i right is maximized dagger A permutation of length n is an array consisting of n distinct integers from 1 to n in any order For example 2 3 1 5 4 is a permutation but 1 2 2 is not a permutation as 2 appears twice in the array and 1 3 4 is also not a permutation as n 3 but 4 appears in the array ,"[""#include <bits/stdc++.h>\xa0using namespace std;\xa0#define int long long#define inf 0x3F3F3F3F3F3F3F3F\xa0const int MXN = 2e5 + 5;\xa0mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\xa0void _(){\tint n, m, k;\tcin >> n >> m >> k;\tfor (int i = n; i >= k; i--) cout << i << ' ';\tfor (int i = m + 1; i < k; i++) cout << i << ' ';\tfor (int i = 1; i <= m; i++) cout << i << ' ';\tcout << '\\n';\t}\xa0signed main(){\tios_base::sync_with_stdio(0);\tcin.tie(0);\tint t;\tcin >> t;\twhile (t--)\t{\t\t_();\t}}""]","[0, 1, 0, 0, 0]",900,TutorialLet be some permutation Let s look at the contribution of the number to the sum If it is less than the contribution is otherwise the contribution is Similarly let s look at the contribution of to the sum If it is greater than the contribution is otherwise it is Since each number gives a contribution greater than in at most one sum Therefore it is advantageous to place numbers not less than at the beginning and numbers not greater than at the end Also numbers not less than should be in descending order to maximize the sum of Similarly numbers not greater than should be in ascending order to minimize the sum of For example you can construct such a permutation It is easy to see that cannot be greater for any other permutation and cannot be less for any other permutation so our answer is optimal Solution complexity 
You are given an array Some element of this array is a iff it is strictly less than both of its neighbours that is and Also the element can be called iff it is strictly greater than its neighbours that is and Since and have only one neighbour each they are neither local minima nor local maxima An element is called a iff it is either local maximum or local minimum Your task is to calculate the number of local extrema in the given array ,"['// eddy1021\n#pragma GCC optimize(""O3"")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<\'0\'||_tc>\'9\')&&_tc!=\'-\' ) _tc=getchar();\n  if( _tc == \'-\' ) _tc=getchar() , _tmp = -1;\n  while(_tc>=\'0\'&&_tc<=\'9\') _x*=10,_x+=(_tc-\'0\'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nvoid build(){\n\n}\n#define N 1021\nint n , a[ N ];\nvoid init(){\n  n = getint();\n  for( int i = 0 ; i < n ; i ++ )\n    a[ i ] = getint();\n}\nvoid solve(){\n  int ans = 0;\n  for( int i = 1 ; i + 1 < n ; i ++ )\n    ans += ( a[ i - 1 ] < a[ i ] and a[ i ] > a[ i + 1 ] ) or\n           ( a[ i - 1 ] > a[ i ] and a[ i ] < a[ i + 1 ] );\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n']","[0, 0, 1, 0, 0]",800,Iterate over indices from to and check if at least one of given local extremum conditions holds Overall complexity 
Mikhail walks on a 2D plane He can go either up or right You are given a sequence of Mikhail s moves He thinks that this sequence is too long and he wants to make it as short as possible In the given sequence moving up is described by character and moving right is described by character Mikhail can replace any pair of consecutive moves or with a diagonal move described as character After that he can go on and do some other replacements until there is no pair of consecutive moves or left Your problem is to print the minimum possible length of the sequence of moves after the replacements ,"['#include<bits/stdc++.h>\n#define MN 105\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<\'0\'||ch>\'9\'){if(ch==\'-\')f=-1;ch=getchar();}\n    while(ch>=\'0\'&&ch<=\'9\'){x=x*10+ch-\'0\';ch=getchar();}\n    return x*f;\n}\nchar c[MN],s;\nint n,ans;\nint main()\n{\n\tregister int i;\n\tn=read();\n\tscanf(""%s"",c+1);\n\ts=0;\n\tfor (i=1;i<=n;++i)\n\t\tif (c[i]!=s)\n\t\t\tif (s) s=0; else s=c[i],++ans;\n\t\telse ++ans; \n\tprintf(""%d"",ans);\n\treturn 0;\t\n}']","[0, 0, 1, 0, 0]",800,Let s iterate over all characters of the string from left to right excluding last character Suppose is a position of the current element of the string If increase answer by and increase by else just increase by 
Cirno is playing a war simulator game with n towers numbered from 1 to n and n bots numbered from 1 to n The i th tower is initially occupied by the i th bot for 1 le i le n Before the game Cirno first chooses a permutation p p 1 p 2 ldots p n of length n A permutation of length n is an array of length n where each integer between 1 and n appears exactly once After that she can choose a sequence a a 1 a 2 ldots a n 1 le a i le n and a i ne i for all 1 le i le n The game has n rounds of attacks In the i th round if the p i th bot is still in the game it will begin its attack and as the result the a p i th tower becomes occupied by the p i th bot the bot that previously occupied the a p i th tower will no longer occupy it If the p i th bot is not in the game nothing will happen in this round After each round if a bot doesn t occupy any towers it will be eliminated and leave the game Please note that no tower can be occupied by more than one bot but one bot can occupy more than one tower during the game At the end of the game Cirno will record the result as a sequence b b 1 b 2 ldots b n where b i is the number of the bot that occupies the i th tower at the end of the game However as a mathematics master she wants you to solve the following counting problem instead of playing games Count the number of different pairs of sequences a and b that we can get from all possible choices of sequence a and permutation p Since this number may be large output it modulo M ,"['/**\n *    author:  tourist\n *    created: 31.07.2022 18:10:18       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include ""algo/debug.h""\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      ""divl %4; \\n\\t""\n      : ""=a"" (d), ""=d"" (m)\n      : ""d"" (xh), ""a"" (xl), ""r"" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\nvector<Mint> fact;\nvector<Mint> inv_fact;\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n >> md;\n  fact = inv_fact = {1};\n  C(2 * n + 1, 0);\n  Mint ans = 0;\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; 2 * j <= i; j++) {\n      Mint dp = fact[i] * C(i - j - 1, j - 1) * inv_fact[j];\n      int ones = n - i;\n      Mint add = dp * C(n, i) * power(Mint(n - 1), j) * power(Mint(n - j - ones), ones);\n      ans += add;\n    }\n  }\n  cout << ans << \'\\n\';\n  return 0;\n}\n']","[0, 1, 0, 1, 0]",3200,Consider calculate the number of possible sequences for a fixed sequence We can find that if that means is occupied by finally so we have i If that means for all that is occupied before it begins its attack As a result we must have The sequences which satisfies the above conditions is also possible to match a valid The attacking order can be arranged easily Now for how to count we can build a graph according to the information given by We can see that the graph will in the form of some chains Also we can find that for a graph which consists of some chains we can find the unique which satisfies the graph Then some positions of array is also fixed except the top of each chain As for how to decide the these is the top of some chain we need to divide into two situations one is the chain s length is greater than we can see that this can take any number between and except The other one is the chain s length is one so cannot be any bottom of each chain Then we can easily calculate the number of arrays by product the possible number of values of each In conclusion we can enumerate the number of chains and the number of chains with length then use combination number to calculate Time complexity is 
Given an array a 1 a 2 dots a n you need to handle a total of q updates and queries of two types 1 l r for each index i with l leq i leq r update the value of a i to the sum of the digits of a i 2 x output a x ,"['#include ""bits/stdc++.h""\nusing namespace std;\n#define int               long long\n#define pb                push_back\n#define ppb               pop_back\n#define all(x)            (x).begin(),(x).end()\n#define uniq(v)           (v).erase(unique(all(v)),(v).end())\n#define sz(x)             (int)((x).size())\n#define f                 first\n#define s                 second\n#define pii               pair<int,int>\n#define rep(i,a,b)        for(int i = a; i < b; i++)\n#define repd(i,a,b)       for(int i = a; i >= b; i--)\n#define mem1(a)           memset(a, -1, sizeof(a))\n#define ppc               __builtin_popcount\n#define ppcll             __builtin_popcountll\n#define ll                long long\n#define ld                long double\n\ntemplate<typename T,typename U>istream& operator>>(istream& in,pair<T,U> &a){in>>a.f>>a.s;return in;}\ntemplate<typename T,typename U>ostream& operator<<(ostream& out,pair<T,U> a){out<<\'(\'<<a.f<<"", ""<<a.s<<\')\';return out;}\ntemplate<typename T>ostream& operator<<(ostream&cout,vector<T>const&v){cout<<""["";rep(i,0,sz(v)){if(i)cout<<"", "";cout<<v[i];}return cout<<""]"";}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\n\n#ifndef ONLINE_JUDGE\n#define dbg(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1) {\n      cout << name << "" : "" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args) {\n      const char* comma = strchr(names + 1, \',\'); cout.write(names, comma - names) << "" : "" << arg1 << "" | ""; __f(comma + 1, args...);\n}\n#else\n#define dbg(...)\n#endif\n\nconst ld pi = 3.14159265358979323846;\nconst char nl = \'\\n\';\nconst long long INF=1e18;\nconst int32_t M=1e9+7;\nconst int32_t MM=998244353;\n\nconst int N=1e6+5;      \nll n, m, q, k, l, r, x, y, z, a[N], b[N], c[N];\nstring s,t;\n\nconst int32_t maxn = N;\ntemplate <typename Node, typename Update>\nstruct segtree {\n      bool built = false, lazy[4 * maxn];\n      Node t[4 * maxn], zero = Node();\n      Update upds[4 * maxn], noop = Update();\n      int32_t tl[4 * maxn], tr[4 * maxn];\n      inline void push(int32_t v) {\n            if(!lazy[v]) return;\n            apply(2*v, upds[v]);\n            apply(2*v + 1, upds[v]);\n            lazy[v] = 0;\n            upds[v] = noop;\n      }\n      inline void apply(int32_t v, Update& upd) {\n            upd.apply(t[v], tl[v], tr[v]);\n            if(tl[v] != tr[v]) {\n                  lazy[v] = 1;\n                  upds[v].combine(upd, tl[v], tr[v]);\n            }\n      }\n      template <typename T> \n      void build(T& a, int32_t v, int32_t l, int32_t r) {\n            tl[v] = l;\n            tr[v] = r;\n            if(l == r){\n                  t[v] = a[l];\n                  return;\n            }\n            int32_t m = (l + r) / 2;\n            build(a, 2*v, l, m);\n            build(a, 2*v + 1, m+1, r);\n            t[v].merge(t[2*v], t[2*v + 1]);\n      }\n      Node query(int32_t v, int l, int r) {\n            if(tr[v] < l || tl[v] > r) return zero;\n            if(l <= tl[v] && tr[v] <= r) return t[v];\n            push(v);\n            Node a = query(2*v, l, r), b = query(2*v + 1, l, r), ans;\n            ans.merge(a, b);\n            return ans;\n      }\n      void rupd(int32_t v, int l, int r, Update& upd){\n            if(tr[v] < l || tl[v] > r) return;\n            if(l <= tl[v] && tr[v] <= r) {\n                  apply(v, upd);\n                  return;\n            }\n            push(v);\n            rupd(2*v, l, r, upd);\n            rupd(2*v + 1, l, r, upd);\n            t[v].merge(t[2*v], t[2*v + 1]);\n      }\n      \n      int len = maxn;\n      void clear() {\n            fill(t, t + 4*len, zero);\n            fill(upds, upds + 4*len, noop);\n            fill(lazy, lazy + 4*len, false);\n            built = false;\n      }\n      template <typename T>\n      void build(T& a) {\n            build(a, 1, 0, len-1);\n            built = true;\n      }\n      Node query(int l, int r) { \n            if(!built) build(t);\n            return query(1, l, r); \n      }\n      void rupd(int l, int r, Update upd) { \n            if(!built) build(t); \n            rupd(1, l, r, upd); \n      }\n};\n \nstruct node{\n      int v = 0;\n      node() {}\n      node(int val){\n            v = val;\n      }\n      void merge(node& l, node& r) {\n            v = l.v + r.v;\n      }\n};\nstruct update{\n      int v = 0;\n      update() {}\n      update(int val){\n            v = val;\n      }\n      void combine(update& o, int tl, int tr){\n            v += o.v;\n      }\n      void apply(node& x, int tl, int tr){\n            x.v += v * (tr - tl + 1);\n      }\n};\nsegtree<node, update> st;\n\nvoid KSBR(){\n      cin >> n >> q;\n      rep(i,0,n) cin >> a[i];\n      st.len = n + 5;\n      st.clear();\n      while(q--){\n            int t; cin >> t;\n            if(t == 1) {\n                  int l, r;\n                  cin >> l >> r; --l, --r;\n                  st.rupd(l, r, 1);\n            } else {\n                  int x;\n                  cin >> x;\n                  --x;\n                  int val = a[x], steps = st.query(x,x).v;\n                  while(steps--) {\n                        int sum = 0;\n                        for(char c : to_string(val)) sum += c - \'0\';\n                        val = sum;\n                        if(val <= 9) break;\n                  }\n                  cout << val << nl;\n            }\n      }\n} \nsigned main(){\n      ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n      #ifdef SIEVE\n            sieve();\n      #endif\n      #ifdef NCR\n            init();\n      #endif\n      int t=1, tc = 1;\n      cin>>t;\n      while(t--) {\n            //cout << ""Case "" << ""#"" << tc++ << "": "";\n            KSBR();\n      }\n}     ']","[0, 0, 0, 0, 1]",1500,Let denote the sum of the digits of The key observation is the following after the operation is applied to index thrice it won t change after any further operations The proof is provided at the bottom of the editorial So we only need to update if it s been updated at most times so far otherwise we can ignore it This allows us to do the following solution store the current active indices that is indices that have been updated times in a sorted list for example in C Then search for the smallest active index at least since the list is sorted we can do it in Afterwards update that index replace with remove it if it s no longer active and binary search for the next largest active index in the sorted list until we pass just output Although it looks like we take time for each update we actually only ever update each element of the array at most times so we will do no more than binary searches Therefore the time complexity is amortized To show this note that initially The maximum possible value of the sum of the digits of is achieved when So Now considering the numbers from to the one with maximum sum of digits is with Hence Finally considering the numbers from to the one with maximum sum of digits is so That is after three operations becomes a single digit Any further operations and it won t change any more 
In the heart of an ancient kingdom grows the legendary Tree of Life the only one of its kind and the source of magical power for the entire world The tree consists of n nodes Each node of this tree is a magical source connected to other such sources through magical channels edges In total there are n 1 channels in the tree with the i th channel connecting nodes v i and u i Moreover there exists a unique simple path through the channels between any two nodes in the tree However the magical energy flowing through these channels must be balanced otherwise the power of the Tree of Life may disrupt the natural order and cause catastrophic consequences The sages of the kingdom discovered that when two magical channels converge at a single node a dangerous magical resonance vibration occurs between them To protect the Tree of Life and maintain its balance it is necessary to select several paths and perform special rituals along them A path is a sequence of distinct nodes v 1 v 2 ldots v k where each pair of adjacent nodes v i and v i 1 is connected by a channel When the sages perform a ritual along such a path the resonance vibration between the channels v i v i 1 and v i 1 v i 2 is blocked for each 1 leq i leq k 2 The sages task is to select the minimum number of paths and perform rituals along them to block all resonance vibrations This means that for every pair of channels emanating from a single node there must exist selected path that contains of these channels Help the sages find the minimum number of such paths so that the magical balance of the Tree of Life is preserved and its power continues to nourish the entire world ,"['#include <bits/stdc++.h>\xa0using i64 = long long;\xa0void solve() {    int n;    std::cin >> n;        std::vector<std::vector<int>> adj(n);    for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--;        v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        i64 ans = 0;    for (int i = 0; i < n; i++) {        i64 d = adj[i].size();        ans += d * (d - 1) / 2;    }    std::vector<i64> f(n), g(n);    auto dfs = [&](this auto &&self, int x, int p) -> void {        i64 d = adj[x].size();                i64 max = 0;        for (auto y : adj[x]) {            if (y == p) {                continue;            }            self(y, x);                        i64 t = std::min(d - 1, f[y]);            f[y] -= t;            ans -= t;                        t = d - 1 - t;            i64 v = std::min(t, 2 * g[y]);            ans -= v;                        g[y] -= v / 2;            if (v % 2 == 1) {                g[y]--;                f[y]++;            }                        g[x] += g[y];            f[x] += f[y];            max = std::max(max, f[y]);        }                if (max * 2 > f[x]) {            i64 v = g[x];            for (auto y : adj[x]) {                if (y == p) {                    continue;                }                if (f[y] == max) {                    v -= g[y];                    break;                }            }            g[x] += f[x] - max;            f[x] = max * 2 - f[x];            v = std::min(v, f[x] / 2);            f[x] -= 2 * v;            g[x] += v;        } else {            g[x] += f[x] / 2;            f[x] %= 2;        }                f[x] += d - 1;    };    dfs(0, -1);        ans -= g[0];        std::cout << ans << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }\xa0    return 0;}']","[1, 0, 0, 1, 0]",3300,This problem has several solutions that are similar to varying degrees We will describe one of them We will apply the following greedy approach We will construct the answer by combining the answers for the subtrees To do this we will perform a depth first traversal and when exiting a vertex we return a triplet where is the minimum number of paths needed to cover all pairs of adjacent edges in the subtree considering the edge upwards is the number of edges upwards and is the number of paths that are connected at some vertex of the subtree but can be separated into two paths upwards without violating the coverage Then if we are at vertex and receive from child the triplet we need to increase to at least to satisfy the coverage Next we will effectively reduce it by implying that we have satisfied all such pairs Meanwhile we will sum and and subtract from when connecting We first increase using and then simply by adding new paths After this we have remaining excess paths leading to which we might be able to combine to reduce the answer This is represented by the set If we can combine all pairs leaving at most path upwards in adding these paths to Otherwise we increase all using until is satisfied Finally we return if the condition is met and while and are the sums that may have changed during the process Don t forget to account for the paths that merged at The root needs to be handled separately as there are no paths upwards there To prove this solution one can consider the minimum number of paths needed to cover subtree if paths go upwards It is not hard to notice that the triplet in the greedy solution describes all optimal states of the dynamic programming P S Strict proofs are left as an exercise for the reader 
One day Vasya came up to the blackboard and wrote out distinct integers from to in some order in a circle Then he drew arcs to join the pairs of integers that are either each other s immediate neighbors in the circle or there is number such that and are immediate neighbors and and are immediate neighbors As you can easily deduce in the end Vasya drew arcs For example if the numbers are written in the circle in the order in the clockwise direction then the arcs will join pairs of integers and Much time has passed ever since the numbers we wiped off the blackboard long ago but recently Vasya has found a piece of paper with written pairs of integers that were joined with the arcs on the board Vasya asks you to find the order of numbers in the circle by these pairs ,"['#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define MN 100100\n\nstd::vector<int> ee[MN], ans;\nint n, ls[10];\nbool app[MN];\n\ninline bool nei(int a, int b) {\n    for(int i=0; i<4; i++)\n        if(ee[a][i] == b) return true;\n    return false;\n}\n\nint main() {\n    scanf(""%d"", &n);\n    for(int i=0; i<n+n; i++) {\n        int a, b;\n        scanf(""%d%d"", &a, &b);\n        if(a == b) {\n            puts(""-1"");\n            return 0;\n        }\n        ee[a].push_back(b);\n        ee[b].push_back(a);\n    }\n    for(int i=1; i<=n; i++) {\n        if(ee[i].size() != 4) {\n            puts(""-1"");\n            return 0;\n        }\n    }\n\n    // QQ!!\n\n    if(n <= 10) {\n        int ar[30] = {};\n        for(int i=0; i<n; i++) ar[i] = i+1;\n        do {\n            ar[n] = ar[0];\n            ar[n+1] = ar[1];\n            \n            bool ok = true;\n\n            for(int i=0; i<n; i++) {\n                if(!nei(ar[i], ar[i+1]) || !nei(ar[i], ar[i+2])) {\n                    ok = false;\n                    break;\n                }\n            }\n\n            if(ok) {\n                for(int i=0; i<n; i++)\n                    printf(""%d%c"", ar[i], i==n-1 ? \'\\n\' : \' \');\n                return 0;\n            }\n        } while( std::next_permutation( ar, ar+n ) );\n        \n        puts(""-1"");\n        return 0;\n    }\n\n\n    int st = 1, pre = -1;\n    while(!app[st]) {\n        app[st] = true;\n        ans.push_back(st);\n        int nxt = st;\n        for(int i=0; i<4; i++) {\n            int cnt = 0;\n            for(int j=0; j<4; j++)\n                if(nei(ee[st][i], ee[st][j])) cnt ++;\n            if(cnt == 2 && ee[st][i] != pre) {\n                nxt = ee[st][i];\n                break;\n            }\n        }\n        if(nxt == st) {\n            puts(""-1"");\n            return 0;\n        }\n        pre = st;\n        st = nxt;\n    }\n    if((int)ans.size() < n) {\n        puts(""-1"");\n        return 0;\n    }\n    ans.push_back(ans[0]);\n    ans.push_back(ans[1]);\n    for(int i=0; i<n; i++) {\n        if(!nei(ans[i], ans[i+1]) || !nei(ans[i], ans[i+2])) {\n            puts(""-1"");\n            return 0;\n        }\n    }\n    for(int i=0; i<n; i++)\n        printf(""%d%c"", ans[i], i==n-1 ? \'\\n\' : \' \');\n    return 0;\n}\n']","[0, 0, 1, 0, 0]",2000,First of all we have to check that each number occurs in the input exactly 4 times If it s not true then the answer definitely doesn t exist Otherwise let s try to restore the circle As cyclic shift of circle doesn t matter let to be the first number As the second and the third number must be connected to each other and to there are only few possibilities So let s try them all And when we know first three numbers the rest of the circle could be easily and unambiguously restored in Just find a number which is not included in the circle yet and is connected to the last two numbers of the circle Add this number to the resulting circle as new last number and repeat the procedure while possible If we succeeded to add all the numbers to the circle than the resulting circle is the answer 
A robot cleaner is placed on the floor of a rectangle room surrounded by walls The floor consists of n rows and m columns The rows of the floor are numbered from 1 to n from top to bottom and columns of the floor are numbered from 1 to m from left to right The cell on the intersection of the r th row and the c th column is denoted as r c The initial position of the robot is r b c b In one second the robot moves by dr rows and dc columns that is after one second the robot moves from the cell r c to r dr c dc Initially dr 1 dc 1 If there is a vertical wall the left or the right walls in the movement direction dc is before the movement so the new value of dc is dc And if there is a horizontal wall the upper or lower walls dr is before the movement so the new value of dr is dr Each second including the moment before the robot starts moving the robot cleans every cell lying in the same row the same column as its position There is only one dirty cell at r d c d The job of the robot is to clean that dirty cell After a lot of testings in problem A the robot is now broken It cleans the floor as described above but at each second the cleaning operation is performed with probability frac p 100 only and not performed with probability 1 frac p 100 The cleaning or not cleaning outcomes are independent each second Given the floor size n and m the robot s initial position r b c b and the dirty cell s position r d c d find the for the robot to do its job It can be shown that the answer can be expressed as an irreducible fraction frac x y where x and y are integers and y not equiv 0 pmod 10 9 7 Output the integer equal to x cdot y 1 bmod 10 9 7 In other words output such an integer a that 0 le a 10 9 7 and a cdot y equiv x pmod 10 9 7 ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\nint mpow(int x, int y) {\n\tint ret = 1;\n\twhile (y) {\n\t\tif (y & 1) ret = 1ll * ret * x % mod;\n\t\ty >>= 1; x = 1ll * x * x % mod;\n\t}\n\treturn ret;\n}\n\nint norm(int x) {\n\treturn x >= mod ? x - mod : x;\n}\n\nint reduce(int x) {\n\treturn x < 0 ? x + mod : x;\n}\n\nconst int d[2] = {-1, 1};\n\nint vis[100005][2][2];\n\nstruct state {\n\tint x, y, dx, dy;\n\tstate(int x_ = 0, int y_ = 0, int dx_ = 0, int dy_ = 0) : x(x_), y(y_), dx(dx_), dy(dy_) {}\n};\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint n, m, x, y, a, b, p;\n\t\tcin >> n >> m >> x >> y >> a >> b >> p;\n\t\tauto s = [&](int x, int y) { return (x - 1) * m + y; };\n\t\tp = 1ll * p * mpow(100, mod - 2) % mod; p = reduce(1 - p);\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tvector<state> seq;\n\t\tstate now = state(x, y, 1, 1);\n\t\tint pos = 0;\n\t\twhile (1) {\n\t\t\tseq.push_back(now);\n\t\t\tif (vis[s(now.x, now.y)][now.dx][now.dy]) {\n\t\t\t\tpos = vis[s(now.x, now.y)][now.dx][now.dy];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvis[s(now.x, now.y)][now.dx][now.dy] = (int)seq.size();\n\t\t\tif (now.x + d[now.dx] < 1 || now.x + d[now.dx] > n) now.dx ^= 1;\n\t\t\tif (now.y + d[now.dy] < 1 || now.y + d[now.dy] > m) now.dy ^= 1;\n\t\t\tnow.x += d[now.dx]; now.y += d[now.dy];\n\t\t}\n\t\t--pos;\n\t\tint ca = 1, cb = 0;\n\t\t// for (int i = 0; i < (int)seq.size(); i++) cout << seq[i].x << "" "" << seq[i].y << endl;\n\t\tfor (int i = (int)seq.size() - 2; i >= pos; i--) {\n\t\t\tif (seq[i].x == a || seq[i].y == b) {\n\t\t\t\tca = 1ll * p * ca % mod, cb = 1ll * p * cb % mod;\n\t\t\t\tcb = norm(cb + p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcb = (cb + 1) % mod;\n\t\t}\n\t\tint ans = 1ll * cb * mpow(reduce(1 - ca), mod - 2) % mod;\n\t\tfor (int i = pos - 1; i >= 0; i--) {\n\t\t\tif (seq[i].x == a || seq[i].y == b) {\n\t\t\t\tans = 1ll * ans * p % mod;\n\t\t\t\tans = norm(ans + p);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = (ans + 1) % mod;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}']","[0, 1, 1, 0, 0]",2300,In order to see how my solution actually works let s solve this problem the math way You can skip to the In general part if you don t really care about these concrete examples First of all let be the probability of that is the probability that the robot will not be able to clean So Let s revisit the first example again In this example the robot has 2 states when it was at position and when it was at Let be the answer for this problem when the robot started at and be the answer for this problem when the robot started at Let s consider the first state If the robot can clean it spends seconds to clean the dirty cell Otherwise it will spend seconds Therefore we have an equation Similarly we also have the an equation since these two states are symetrical Subtituding into we haveBy substituting in we can find the value of Let s consider the other example In this example the robot has 4 states when it is at when it is at but going to the right when it is at and when it is at but going to the left Let the answer for these states be and Similar to the previous example we can write down the equations Substituting these equations back to back we can have the following equation And again if we substitute in the answer can be found easily In general the path that the robot takes will form a cycle containing the initial position If we call the answer to the problem at the initial position the equation we need to solve will have the following form where is the number of states in the cycle and is some coefficient if at the th state in the cycle we have an opportunity to clean the dirty cell and otherwise The equation can easily be solved by expanding the brackets from the innermost to the outermost by going through the cycle in the reverse order After the expansion the equation will be a very simple linear equation with the form and the solution will be To construct the equation we can first find the cycle by either DFS or BFS and go through the cycle in the reverse order for expansion Or we can do the reverse simulation maintaining the coefficient and right away And even better we can just forget about the cycle and iterate exactly times not though since will always be the multiple of the cycle length The time complexity of this solution is 
Although Inzane successfully found his beloved bone Zane his owner has yet to return To search for Zane he would need a lot of money of which he sadly has none To deal with the problem he has decided to hack the banks There are banks numbered from to There are also wires connecting the banks All banks are initially Each bank also has its initial strength bank has initial strength Let us define some keywords before we proceed Bank and bank are if and only if there exists a wire directly connecting them Bank and bank are if and only if there exists an bank such that bank and bank are and bank and bank are When a bank is hacked it becomes and no longer and other banks that are or to it have their strengths increased by To start his plan Inzane will choose a bank to hack first Indeed the strength of such bank must not exceed the strength of his computer After this he will repeatedly choose some bank to hack next until all the banks are hacked but he can continue to hack bank if and only if all these conditions are met Bank is That is bank is not hacked yet Bank is to some bank The strength of bank is less than or equal to the strength of Inzane s computer Determine the minimum strength of the computer Inzane needs to hack all the banks ,"['#include <bits/stdc++.h>\nusing namespace std;\nvector<int> a[300020];\nint b[300020];\nint c1[300020], cnt1;\nint c2[300020], cnt2;\nint n, x, y;\nint main() {\n\tscanf(""%d"", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(""%d"", &b[i]);\n\t}\n\tint ans = b[1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tans = max(ans, b[i]);\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tscanf(""%d%d"", &x, &y);\n\t\ta[x].push_back(y);\n\t\ta[y].push_back(x);\n\t}\n\tint shabi = -1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (ans == b[i]) {\n\t\t\tc1[i]++;\n\t\t\tfor (int j: a[i]) {\n\t\t\t\tc1[j]++;\n\t\t\t}\n\t\t\tcnt1++;\n\t\t\tshabi = i;\n\t\t}\n\t\tif (ans == b[i] + 1) {\n\t\t\tc2[i]++;\n\t\t\tfor (int j: a[i]) {\n\t\t\t\tc2[j]++;\n\t\t\t}\n\t\t\tcnt2++;\n\t\t}\n\t}\n\tint m1 = 0;\n\tint m2 = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tm1 = max(m1, c1[i]);\n\t\tm2 = max(m2, c2[i]);\n\t}\n\tif (cnt1 == 1 && c2[shabi] == cnt2) {\n\t\tprintf(""%d\\n"", ans);\n\t} else if (m1 == cnt1) {\n\t\tprintf(""%d\\n"", ans + 1);\n\t} else {\n\t\tprintf(""%d\\n"", ans + 2);\n\t}\n\treturn 0;\n}']","[0, 0, 0, 1, 1]",1900,First note that the input graph is a tree Let be the greatest value of that is Observe that the answer can be or only Why It is because each bank s strength can be increased at most twice once by a neighboring bank and once by a semi neighboring bank So the strength required to hack bank is at most regardless of the sequence of banks you choose to hack Now suppose is the first bank we would hack first We would need a computer with strength at least to hack it Let the neighboring banks of be We would need a computer with strength at least to hack those banks And for each bank not yet hacked we can hack them with a computer with strength at least For simplicity add to all the banks strengths Let s maintain a map data structure to keep track of number of times some value of strength occurs Again suppose we would start by hacking bank Now we would need a computer with strength at least to hack it For the neighboring banks it would be For other banks it would be For a fixed bank you can iterate through its neighboring banks and update the map data structure accordingly Keep track of the maximum value that occurs and update the answer We can simply iterate through banks to start with and get the final answer But wait Won t it work in or something like that No Let s analyze the runtime carefully You can skip this if you know why This is for beginners Suppose we choose bank to start with We have to iterate through its neighboring banks The number of the banks neighboring to is equal to the degree of bank We would need operations for bank By iterating through all possible from to we will perform operations You can see that if there are edges in a graph the degrees of all nodes sum to Trees have edges so Therefore we need to perform only operations However each operation involves the map data structure so the overall runtime is Be aware that the use of hash map could bring the runtime to Looking more closely we can also keep track of the occurrences of only and and no other values So although not required to get AC we can get rid of the map data structure and therefore eliminate the logarithmic factor The official solution provided here runs in 
Last week Hamed learned about a new type of equations in his math class called Modular Equations Lets define modulo as the remainder of division of by and denote it by A Modular Equation as Hamed s teacher described is an equation of the form in which and are two non negative integers and is a variable We call a positive integer for which a of our equation Hamed didn t pay much attention to the class since he was watching a movie He only managed to understand the definitions of these equations Now he wants to write his math exercises but since he has no idea how to do that he asked you for help He has told you all he knows about Modular Equations and asked you to write a program which given two numbers and determines how many answers the Modular Equation has ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\nint a,b,ans=0;\nint main()\n{\n    scanf(""%d%d"",&a,&b);\n    if(a==b)\n    {\n        printf(""infinity\\n"");\n        return 0;\n    }\n    a-=b;\n    //The answer is bigger than b\n    for(int i=1;i*i<=a;i++) if(!(a%i))\n    {\n        if(i*i==a) ans+=(i>b);\n        else ans+=(i>b)+(a/i>b);\n    }\n    printf(""%d\\n"",ans);\n    return 0;\n}\n']","[0, 1, 0, 0, 0]",1600,If a b then there is no answer since If a b then x can be any integer larger than a so there are infinite number of answers to the equation The only remaining case is when a b Suppose x is an answer to our equation Then x a b Also since then b x These conditions are necessary and sufficient as well So the answer is number of divisors of a b which are strictly greater than b which can be solved in 
Pupils Alice and Ibragim are best friends It s Ibragim s birthday soon so Alice decided to gift him a new puzzle The puzzle can be represented as a matrix with 2 rows and n columns every element of which is either 0 or 1 In one move you can swap two values in neighboring cells More formally let s number rows 1 to 2 from top to bottom and columns 1 to n from left to right Also let s denote a cell in row x and column y as x y We consider cells x 1 y 1 and x 2 y 2 neighboring if x 1 x 2 y 1 y 2 1 Alice doesn t like the way in which the cells are currently arranged so she came up with her own arrangement with which she wants to gift the puzzle to Ibragim Since you are her smartest friend she asked you to help her find the minimal possible number of operations in which she can get the desired arrangement Find this number or determine that it s not possible to get the new arrangement ,"['/*\n\n_/      _/       _/_/_/      _/      _/    _/           _/_/_/_/_/\n _/    _/      _/      _/     _/    _/     _/           _/\n  _/  _/      _/               _/  _/      _/           _/\n   _/_/       _/                 _/        _/           _/_/_/_/\n  _/  _/      _/                 _/        _/           _/\n _/    _/      _/      _/        _/        _/           _/\n_/      _/       _/_/_/          _/        _/_/_/_/_/   _/_/_/_/_/\n\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n#define ru(i, l, r) for (int i = (l); i <= (r); i++)\n#define rd(i, r, l) for (int i = (r); i >= (l); i--)\n#define mid ((l + r) >> 1)\n#define maxn 200005\nusing namespace std;\ninline int read()\n{\n\tint x = 0, w = 0; char ch = getchar();\n\twhile(!isdigit(ch)) {w |= ch == \'-\'; ch = getchar();}\n\twhile(isdigit(ch)) {x = x * 10 + ch - \'0\'; ch = getchar();}\n\treturn w ? -x : x;\n}\nint n, a[2][maxn];\nint main()\n{\n\tn = read();\n\tru(i, 0, 1) ru(j, 1, n) a[i][j] += read();\n\tru(i, 0, 1) ru(j, 1, n) a[i][j] -= read();\n\tint cnt[2] = {0, 0}; ll ans = 0;\n\tru(i, 1, n)\n\t{\n\t\tans += abs(cnt[0] + cnt[1]);\n\t\tru(j, 0, 1) cnt[j] += a[j][i];\n\t\tif((ll)cnt[0] * cnt[1] < 0)\n\t\t{\n\t\t\tans += min(abs(cnt[0]), abs(cnt[1]));\n\t\t\tif(abs(cnt[0]) > abs(cnt[1]))\n\t\t\t{\n\t\t\t\tcnt[0] += cnt[1];\n\t\t\t\tcnt[1] = 0;\n\t\t\t}\n\t\t\telse cnt[1] += cnt[0], cnt[0] = 0;\n\t\t}\n\t}\n\tif(cnt[0] != 0 || cnt[1] != 0) printf(""-1"");\n\telse printf(""%lld\\n"", ans);\n\treturn 0;\n}\n']","[1, 0, 0, 1, 0]",2600,We are asked to find a minimum cost perfect matching between s in the matrices where the cost between and is Notice that the answer exists only if the number of s is equal in both matrices Consider that this is the case Notice that every either stays in its original row or changes it in a single operation For simplicity let s assume that all operations of that kind are performed in the beginning Let s denote as the difference between the th prefix sum in th row of the matrices If the final row for each is fixed then the answer is equal to where in the number of s that changed its row Now let s look at what happens when we change the row of a For simplicity let s assume that it was in a cell Then after the swap we have to increment by decrement all by and increment all by Now let s solve the following problem we are given and and in one operation we can increment some suffix by and decrement the same suffix in the other array by The goal is to minimize Notice that the following greedy algorithm works iterate through columns from left to right and while and have different signs decrement the suffix of one that s greater and increment suffix of one that s lower Now let s prove that this algorithm minimizes the target sum For this consider some optimal sequence of operations It doesn t matter in which order operations are performed so let s assume they are performed from left to right and are accumulated in a single element for the same suffix If the sequences differ denote as the first such position Note that before that all and are the same in both our answer and the optimal one Suppose that in the optimal answer we incremented th suffix of by and decremented th suffix of by Then the target sum will increase by Consider the following cases and or and By triangle inequality which means that those operations could be performed on the st suffix and that wouldn t increase the answer and Here if which means that those operations could be performed on the st suffix and that wouldn t increase the answer Now if We can assume that otherwise we will perform an operation on values with the same sign which we already shown can be done later on Then Greedy algorithm suggests doing exactly operations Note that if we perform operations on suffix and operations on suffix we will add to the answer and get the same state as the optimal answer This means that we can do operations and not increase the answer and This case can be analyzed in the same way What we showed here is that we can always extend the matching prefix with the optimal answer which means that the greedy algorithm produces the same answer Let s come back to the original problem Described greedy algorithm finds a lower bound on the answer Let s show that it is always possible to achieve it when the operations are allowed only for moving s between rows and the number of s in each row at the end should be the same For this note that we can perform operations on s from the second matrix if we reverse their order and append to the end of the sequence for the first matrix Now note that if on some prefix and have the same sign but on prefix the signs differ there has to be at least a single in column and we can perform the operation suggested by the greedy algorithm Finally if the answer exists it is true that and if and have the same sign at the end this means that they are both which means that the constructed answer is correct This solution works in time 
You are given an integer array a 1 a 2 ldots a n The array b is called to be a of a if it is possible to remove some elements from a to get b Array b 1 b 2 ldots b k is called to be if it is not empty and for every i 1 le i le k b i is divisible by i Find the number of good subsequences in a modulo 10 9 7 Two subsequences are considered different if index sets of numbers included in them are different That is the values of the elements do not matter in the comparison of subsequences In particular the array a has exactly 2 n 1 different subsequences excluding an empty subsequence ,"['#include <bits/stdc++.h>\n#define eb emplace_back\n#define INF (0x3f3f3f3f)\n#define INFLL (0x3f3f3f3f3f3f3f3fll)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, ll> pil;\ntypedef pair<ll, int> pli;\n\nconst ll MOD = 1e9 + 7;\n\nll D[1000005];\nll N, Ans;\n\nint main()\n{\n\tll i, j, a;\n\t\n\tscanf(""%lld"", &N);\n\t\n\tD[0] = 1;\n\t\n\tfor(ll i = 1; i <= N; i ++){\n\t\tscanf(""%lld"", &a);\n\t\t\n\t\tll j;\n\t\t\n\t\tfor(j = 1; j * j <= a; j ++){\n\t\t\tif(a % j == 0){\n\t\t\t\tD[a / j] = (D[a / j] + D[a / j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(j --; j >= 1; j --){\n\t\t\tif(j * j == a) continue;\n\t\t\tif(a % j == 0){\n\t\t\t\tD[j] = (D[j] + D[j - 1]) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(ll i = 1; i <= (ll) 1e6; i ++){\n\t\tAns = (Ans + D[i]) % MOD;\n\t}\n\t\n\tcout << Ans << endl;\n\treturn 0;\n}']","[0, 1, 1, 1, 1]",1700,Let s introduce the following dynamic programming approach where indicates the number of ways to select a good subsequence of size from elements Our final answer will be Now maintaining a 2 D dp will exceed memory limit however notice that is calculated only on the basis of hence mainitaining a 1 D dp will work Also now is updated if and only if is a divisor of We can find divisors of a number in Overall Complexity Here indicates maximum number of divisors possible and indicates maximum value of possible Also we can use sieve to compute divisors of each number and achieve complexity of 
The Berland language consists of words having Moreover Any combination of two different Berland letters which by the way are the same as the lowercase letters of Latin alphabet is a correct word in Berland language The Berland dictionary contains all words of this language The words are listed in a way they are usually ordered in dictionaries Formally word a comes earlier than word b in the dictionary if one of the following conditions hold the first letter of a is less than the first letter of b the first letters of a and b are the same and the second letter of a is less than the second letter of b So the dictionary looks like that Word 1 Word 2 Word 25 Word 26 Word 27 Word 649 Word 650 You are given a word s from the Berland language Your task is to find its index in the dictionary ,"['#include ""bits/stdc++.h""\n\nusing namespace std;\n\nusing ll = long long;\nconst ll inf = 1e9;\nconst int md1 = 1e9+7;\n\n#define all(v)                      v.begin(), v.end()\n#define rall(v)                     v.rbegin(), v.rend()\n#define sz(v)                       ((int)v.size())\n\n#define forn(i,n)                   for(int i = 0; i < n; ++i)\n#define forbe(i,b,e)                for(int i = b; i < e; ++i)\n\n#define pb                          push_back\n\n#define pry                         puts(""YES"")\n#define prn                         puts(""NO"")\n#define endl                        \'\\n\'\n\n#define fst                         first\n#define scn                         second\n\nvoid solve(){\n    string s;\n    cin >> s;\n\n    cout << 1+ ( s[0] - \'a\' ) * 25 + s[1] - \'a\' - (s[1] > s[0]) << endl;\n}\n\nint32_t main(){\n    #ifndef ONPC\n        ios_base::sync_with_stdio(0);cin.tie(0);\n    #else\n        freopen(""in"", ""r"", stdin);\n    #endif\n    int t = 1;\n    cin >> t;\n    while(t--)\n        solve();\n}\n']","[0, 1, 0, 0, 0]",800,There are many different ways to solve this problem generate all Berland words with two for loops and store them in an array then for each test case go through the array of words to find the exact word you need generate all Berland words with two for loops and store them in a dictionary like data structure in C in Python etc using words as keys and their numbers as values This allows to search for the index of the given word quickly for each test case run two for loops to iterate over the words count the number of words we skipped and stop at the word from the test case try to invent some formulas that allow counting the number of words before the given one 
Recenlty Luba got a credit card and started to use it Let s consider consecutive days Luba uses the card In the of th day a transaction occurs If then bourles are deposited to Luba s account If then bourles are withdrawn And if then the amount of money on Luba s account is checked In the of any of days Luba can go to the bank and deposit any integer amount of burles to her account But there is a limitation the amount of money on the account can never exceed Luba must not exceed this limit and also she wants that the days when the amount of money on her account is non negative It takes a lot of time to go to the bank so Luba wants to know the minimum number of days she needs to deposit some money to her account if it is possible to meet all the requirements Help her ,"['#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << ""\\n""; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(""%d"", &x);\n\treturn x;\n}\n\nint main() {\n\tint n = nxt(), d = nxt();\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\ta[i] = nxt();\n\t}\n\n\tint ans = 0;\n\tint cur = 0;\n\tint balance = 0;\n\tvector<int> lows(n), rigs(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tbalance += a[i];\n\t\tif (a[i] == 0) {\n\t\t\tlows[i] = -balance;\n\t\t}\n\t\trigs[i] = d - balance;\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tlows[i] = max(lows[i], lows[i - 1]);\n\t}\n\tfor (int i = n - 2; i >= 0; --i) {\n\t\trigs[i] = min(rigs[i], rigs[i + 1]);\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (lows[i] > rigs[i]) {\n\t\t\tputs(""-1"");\n\t\t\treturn 0;\n\t\t}\n\t\tif (cur < lows[i]) {\n\t\t\tcur = rigs[i];\n\t\t\t++ans;\n\t\t}\n\t}\n\n\tprintf(""%d\\n"", ans);\n\n\treturn 0;\n}\n']","[1, 0, 1, 1, 1]",1900,The following greedy solution works Firstly deposite money only on days with Secondly every time the balance is negative to the day with refill it to maximal possible value such that it won t go over later Days with can only lead to invalid state by going over card limit We can only add money to the balance Adding zero money in those days won t make invalid states if all were valid previously Finally if it s possible to get valid state in every day then it s possible to get it by refilling the same day the check happens For example you can make balance in those days Then you will never have negative balance there Though it s not the most optimal way Let be some value you deposite in some day with to pass all conditions till the next day with I state that function of number of game s moves dependancy on is monotonious Let s check it for some fixed Define minimum balance you will get on any suffix from now as Obviously taking will make it If it goes negative then you will need an extra move to finish the game Thus taking maximal will lead to the lowest score possible And last but not least realization part What will be the maximum possible value to deposite Actually it s such a value that optimal game after this will lead to maximum balance of in some day Thus you want to check what will be the maximum balance if you add zero money and take as Obviously if it s negative then output Naively this still works on per day and lead to overall Notice that by depositing you increase maximums on each suffix for now by So you can calculate it as you will do nothing and add sum of your s to get actual value You store prefix sum of up to in Then take maximum on suffix for every is the maxumum for from to I hope I made it clear enough DOverall comlpexity 
A thief made his way to a shop As usual he has his lucky knapsack with him The knapsack can contain objects There are kinds of products in the shop and an infinite number of products of each kind The cost of one product of kind is The thief is greedy so he will take exactly products it s possible for some kinds to take several products of that kind Find all the possible total costs of products the thief can nick into his knapsack ,"['#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nint n, k;\nint dp[1000010];\nvector<int> vv;\n\nint main() {\n\tcin >> n >> k;\n\tint mn = 10000;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a;\n\t\tcin >> a;\n\t\tmn = min(mn, a);\n\t\tvv.push_back(a);\n\t}\n\tfor (int i = 0; i < (int)vv.size(); ++i)\n\t\tvv[i] -= mn;\n\tsort(vv.begin(), vv.end());\n\tvv.resize(unique(vv.begin(), vv.end()) - vv.begin());\n\tint mx = k * vv.back();\n\tfor (int j = 0; j <= mx; ++j)\n\t\tdp[j] = k + 1;\n\tdp[0] = 0;\n\tfor (int i = 0; i < (int)vv.size(); ++i) {\n\t\tint x = vv[i];\n\t\tif (x == 0)\n\t\t\tcontinue;\n\t\tfor (int j = 0; j <= mx - x; ++j)\n\t\t\tdp[j + x] = min(dp[j + x], dp[j] + 1);\n\t}\n\tfor (int i = 0; i <= mx; ++i)\n\t\tif (dp[i] <= k)\n\t\t\tprintf(""%d "", mn * k + i);\n\treturn 0;\n}\n\n\n']","[0, 1, 0, 1, 0]",2400,The problem was suggested by Alexey Chesnokov CleRIC Let then it is the standard problem which can be solved by FFT Fast Fourier Transform The solution is the following consider the polynomial which the th coefficient equals to one if and only if there is the number in the given array Let s multiply that polynomial by itself and find for which the coefficient in square not equals to Those values will be in the answer Easy to modificate the solution for the arbitrary We should simply calculate the th degree of the polynomial The complexity will be where is the maximal sum We can improve that solution Instead of calculating the th degree of the polynomial we can calculate the th degree of the DFT of the polynomial The only problem is the large values of the th degrees We can t use FFT with complex numbers because of the precision problems But we can do that with NTT Number theoretic transform But that solution also has a problem It can happen that some coefficients became equals to zero modulo but actually they are not equal to zero To get round that problem we can choose two three random modules and get the complexity The main author solution has the complexity FFT with complex numbers the second solution has the same complexity but uses NTT and the third solution has the improved complexity but it was already hacked by halyavin solution complex FFT by me solution NTT by me solution improved NTT by me solution by CleRIC P S To get faster solution you should each time multiply the polynomials of the required degree but not of the degree Complexity or depending the bravery of the coder UPD It turns out that the first approach also has complexity See below the comment of halyavin 
An array a 1 dots a n of length n is initially all blank There are n updates where one entry of a is updated to some number such that a becomes a permutation of 1 2 dots n after all the updates After each update find the number of ways modulo 998 244 353 to fill in the remaining blank entries of a so that a becomes a permutation of 1 2 dots n and all cycle lengths in a are multiples of 3 A permutation of 1 2 dots n is an array of length n consisting of n distinct integers from 1 to n in arbitrary order A in a permutation a is a sequence of pairwise distinct integers i 1 dots i k such that i 2 a i 1 i 3 a i 2 dots i k a i k 1 i 1 a i k The length of this cycle is the number k which is a multiple of 3 if and only if k equiv 0 pmod 3 ,"['#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cassert>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(((long long)(n))-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();++itr)\n#define pb push_back\n#define mk make_pair\n#define rdst(st,len){static char ss[len];scanf("" %s"",ss);(st)=ss;}\n#define spln(i,n) (i==n?\'\\n\':\' \')\n#define fac_init(n){fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,n){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}}\nusing namespace std;\ntypedef long long i64;\ntypedef long double f80;\ntypedef unsigned int u32;\ntypedef unsigned long long u64;\n//typedef __int128 i128;\n//typedef unsigned __int128 u128;\n#ifndef ONLINE_JUDGE\n\tFILE *___=freopen(""1.in"",""r"",stdin);\n#endif\ninline void read(int &x)\n{\n\tchar c;int f=1;\n\twhile(!isdigit(c=getchar()))if(c==\'-\')f=-1;\n\tx=(c&15);while(isdigit(c=getchar()))x=(x<<1)+(x<<3)+(c&15);\n\tx*=f;\n}\n//------------------polynomial begin------------------\nconst int maxn=1048576;\nconst int mod=998244353,_k=119,_b=23,_g=3;\ninline void inc(int &x,int y){x+=y;if (x>=mod) x-=mod;}\ninline void dec(int &x,int y){x-=y;if (x<0) x+=mod;}\ninline int qp(int x,int y){int z=1;while(y){if(y&1)z=1ll*z*x%mod;y>>=1;x=1ll*x*x%mod;}return z;}\nnamespace polynomial\n{\n    namespace basic\n    {\n        int fac[maxn+5],inv[maxn+5],fi[maxn+5],lg[maxn+5],pw[maxn+5],w[maxn+5],iw[maxn+5];\n        bool tag=0;\n        inline void init()\n        {\n            tag=1;int i;fz(i,2,maxn) lg[i]=lg[i>>1]+1;pw[0]=1;fz1(i,lg[maxn]) pw[i]=pw[i-1]*2; \n            fac[0]=fac[1]=inv[1]=fi[0]=fi[1]=1;fz(i,2,maxn){\n                fac[i]=1ll*fac[i-1]*i%mod;inv[i]=(mod-mod/i)*1ll*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;\n            }\n            w[0]=1;w[1]=qp(_g,(mod-1)/maxn);fz(i,2,maxn) w[i]=1ll*w[i-1]*w[1]%mod;\n            iw[maxn]=qp(w[maxn],mod-2);fd0k(i,maxn) iw[i]=1ll*iw[i+1]*w[1]%mod;\n            if (iw[0]!=1){puts(""wrong iw!!!!!!!!!!!!!!!!!"");exit(-1);}\n        }\n        int rev[maxn+5],a[maxn+5],b[maxn+5];\n        inline int getrev(int x)\n        {\n            if (!tag) init();int i,s=1;while (s<x) s*=2;rev[0]=0;fz1(i,s-1) rev[i]=((rev[i>>1]>>1)|((i&1)<<(lg[s]-1)));return s;\n        }\n        inline void ntt(int *a,int n,int *w)\n        {\n            if (!tag) init();int i,j,k;\n            fz0k(i,n) if (rev[i]<i) swap(a[i],a[rev[i]]);\n            for (i=1;i<n;i<<=1){int ys=maxn/i/2;\n                for (j=0;j<n;j+=i+i){\n                    int *t=w;\n                    fz0k(k,i){\n                        int x=a[j+k],y=1ll*a[j+k+i]*(*t)%mod;\n                        a[j+k]=x+y;if (a[j+k]>=mod) a[j+k]-=mod;\n                        a[j+k+i]=x-y;if (a[j+k+i]<0) a[j+k+i]+=mod;\n                        t+=ys;\n                    }\n                }\n            }\n        }\n        inline vector<int> mul(const vector<int> &aa,const vector<int> &bb) //aa*bb\n        {\n            vector<int> ans;long long br=1ll*aa.size()*bb.size(),ft=1ll*(aa.size()+bb.size())*lg[aa.size()+bb.size()]*10+100;\n            if (br<ft){\n                while (ans.size()+1<aa.size()+bb.size()) ans.push_back(0);\n                int i,j;fz0k(i,aa.size()) fz0k(j,bb.size()) inc(ans[i+j],1ll*aa[i]*bb[j]%mod);\n            }\n            else{\n                int len=getrev(aa.size()+bb.size()),i;\n                fz0k(i,len) a[i]=b[i]=0;\n                fz0k(i,aa.size()) a[i]=aa[i];\n                fz0k(i,bb.size()) b[i]=bb[i];\n                ntt(a,len,w);ntt(b,len,w);\n                fz0k(i,len) a[i]=1ll*a[i]*b[i]%mod;\n                ntt(a,len,iw);int inv=qp(len,mod-2);\n                fz0k(i,len) ans.push_back(1ll*a[i]*inv%mod);\n            }\n            while (!ans.empty()&&!ans.back()) ans.pop_back();\n            return ans;\n        }\n        inline vector<int> mul2(const vector<int> &aa,const vector<int> &bb) //aa^2*bb\n        {\n            int len=getrev(aa.size()+aa.size()+bb.size()),i;\n            fz0k(i,len) a[i]=b[i]=0;fz0k(i,aa.size()) a[i]=aa[i];fz0k(i,bb.size()) b[i]=bb[i];\n            ntt(a,len,w);ntt(b,len,w);fz0k(i,len) a[i]=1ll*a[i]*b[i]%mod*a[i]%mod;ntt(a,len,iw);\n            vector<int> ans;int inv=qp(len,mod-2);fz0k(i,len) ans.push_back(1ll*a[i]*inv%mod);while (!ans.empty()&&!ans.back()) ans.pop_back();\n            return ans;\n        }\n    };\n    struct poly\n    {\n        vector<int> v;\n        inline void clear(){v.clear();}\n        inline int size(){return v.size();}\n        inline bool empty(){return v.empty();}\n        inline int back(){return v.back();}\n        inline void pop_back(){v.pop_back();}\n        inline void push_back(int x){v.push_back(x);}\n        inline void read(int n){clear();while (n--){int x;scanf(""%d"",&x);v.push_back(x);}}\n        inline void print(){ff(v,it) printf(""%d "",*it);puts("""");} \n        inline void print(int n){int i;for(i=0;i<n;i++)if(i<v.size())printf(""%d "",v[i]);else printf(""0 "");puts("""");}\n        inline poly operator+(const poly &x)const{vector<int> s;int i;for (i=0;i<x.v.size()||i<v.size();i++){int t=0;if(i<v.size())inc(t,v[i]);if(i<x.v.size())inc(t,x.v[i]);s.push_back(t);}return(poly){s};}\n        inline poly operator-(const poly &x)const{vector<int> s;int i;for (i=0;i<x.v.size()||i<v.size();i++){int t=0;if(i<v.size())inc(t,v[i]);if(i<x.v.size())dec(t,x.v[i]);s.push_back(t);}return(poly){s};}\n        inline poly operator*(const int &x)const{vector<int> s;int i;for (i=0;i<v.size();i++)s.push_back(1ll*x*v[i]%mod);return(poly){s};}\n        inline poly operator*(const poly &x)const{return (poly){basic::mul(v,x.v)};}\n        inline void mul_x(){int i;v.push_back(0);fd1(i,v.size()-1)v[i]=v[i-1];v[0]=0;} // this*=x\n        inline void divi_x(){int i;fz0k(i,((int)v.size())-1)v[i]=v[i+1];v.pop_back();} // this/=x\n        inline void derivation(){int i;fz0k(i,((int)v.size())-1)v[i]=1ll*v[i+1]*(i+1)%mod;v.pop_back();} // this=this\n        inline void integral(){int i;v.push_back(0);fd1(i,v.size()-1)v[i]=1ll*v[i-1]*basic::inv[i]%mod;v[0]=0;} // this=this \n        inline void size_down(int x){while (v.size()>x)v.pop_back();}\n        inline void size_up(int x){while (v.size()<x)v.push_back(0);}\n        inline void resize(int x){size_down(x);size_up(x);}\n        inline int &operator[](const int &x){if (v.size()<=x)size_up(x+1);return v[x];}\n    };\n    inline poly derivation(poly a){a.derivation();return a;}\n    inline poly integral(poly a){a.integral();return a;}\n    inline poly mul_x(poly a){a.mul_x();return a;}\n    inline poly divi_x(poly a){a.divi_x();return a;}\n    inline poly poly_inv(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){fprintf(stderr,""wrong poly_inv(0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"");return a;}\n    \tpoly ta,tb;ta.push_back(a[0]);tb.push_back(qp(a[0],mod-2));int i,j;\n    \tfor (i=1;i<n;i<<=1){\n    \t\tfor (j=i;j<(i<<1)&&j<n;j++){\n    \t\t\tta.push_back(a[j]);\n    \t\t}\n    \t\ttb=tb*2-((poly){basic::mul2(tb.v,ta.v)});\n    \t\ttb.size_down(min((i<<1),n));\n    \t}\n    \treturn tb;\n    }\n    inline poly poly_ln(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){fprintf(stderr,""wrong poly_ln(0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"");return a;}\n    \tif (a[0]!=1){\n    \t\tfprintf(stderr,""bad template poly_ln a[0]!=1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"");return a;\n    \t}\n    \ta=integral(derivation(a)*poly_inv(a,n));a.size_down(n);\n    \treturn a;\n    }\n    inline poly poly_exp(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){a.push_back(1);return a;}\n    \tif (a[0]!=0){\n    \t\tfprintf(stderr,""bad template poly_exp a[0]!=0 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"");return a;\n    \t}\n    \tpoly ta,tb,uit;uit.push_back(1);ta.push_back(a[0]);tb.push_back(1);int i,j;\n    \tfor (i=1;i<n;i<<=1){\n    \t\tfor (j=i;j<n&&j<(i<<1);j++){\n    \t\t\tta.push_back(a[j]);\n    \t\t}\n    \t\ttb=tb*(uit-poly_ln(tb,(i<<1))+ta);\n    \t\ttb.size_down(min((i<<1),n));\n    \t}\n    \treturn tb;\n    }\n    inline poly poly_sqrt(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){return a;}\n    \tpoly ta,tb;ta.push_back(a[0]);\n    \tif (a[0]==1){\n    \t\ttb.push_back(1);\n    \t}\n    \telse{\n    \t\tfprintf(stderr,""bad template in poly_sqrt a[0]!=1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"");return a;\n    \t}\n    \tint i,inv2=qp(2,mod-2),j;for (i=1;i<n;i<<=1){\n    \t\tfor (j=i;j<(i<<1)&&j<n;j++) ta.push_back(a[j]);\n    \t\ttb=(tb+(ta*poly_inv(tb,(i<<1))))*inv2;\n    \t\ttb.size_down(min((i<<1),n));\n    \t}\n    \tif (tb[0]>mod-tb[0]) tb=tb*(mod-1); \n    \treturn tb;\n    }\n    inline poly poly_pow(poly a,int n,int k) // a^k mod (x^n) \n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a.empty()){return a;}\n    \tint k0=0;while (k0<a.size()&&a.v[k0]==0) k0++;int i;\n    \tpoly b;for (i=k0;i<a.size();i++) b.v.push_back(a.v[i]);\n    \tint t=b.v[0];b=b*(qp(t,mod-2));t=qp(t,k);\n    \tk0=min(1ll*k0*k,1ll*n);b=poly_exp(poly_ln(b,n)*k,n)*t;\n    \ta.clear();while (k0--) a.v.push_back(0);\n    \tint idx=0;while (a.v.size()<n) a.v.push_back(b[idx++]);\n    \treturn a;\n    }\n    inline poly operator/(poly a,poly b)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \twhile (!b.empty()&&!b.back()) b.pop_back();\n    \tif (b.empty()){fprintf(stderr,""wrong poly_div(a,0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"");exit(-1);}\n    \treverse(a.v.begin(),a.v.end());reverse(b.v.begin(),b.v.end());\n    \tint n=a.size(),m=b.size(),k=n-m+1;if (k<=0){poly ans;ans.push_back(0);return ans;}\n    \ta.size_down(k);b.size_down(k);a=a*poly_inv(b,k);a.size_down(k);\n    \treverse(a.v.begin(),a.v.end());return a;\n    }\n    inline poly operator%(poly a,poly b)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \twhile (!b.empty()&&!b.back()) b.pop_back();\n    \tif (b.empty()){fprintf(stderr,""wrong poly_mod(a,0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"");exit(-1);}\n    \tint m=b.size();a=a-a/b*b;\n        a.size_down(m-1);return a;\n    }\n    inline void poly_divmod(poly a,poly b,poly &s1,poly &s2) // a/b=s1......s2\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();s1.clear();\n    \twhile (!b.empty()&&!b.back()) b.pop_back();s2.clear();\n    \tif (b.empty()){fprintf(stderr,""wrong poly_divmod(a,0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"");exit(-1);}\n    \tpoly c=a,d=b;reverse(a.v.begin(),a.v.end());reverse(b.v.begin(),b.v.end());\n    \tint n=a.size(),m=b.size(),k=n-m+1;if (k<0){s1.push_back(0);s2=a;return;}\n    \ta.size_down(k);b.size_down(k);s1=a*poly_inv(b,k);s1.size_down(k);\n    \treverse(s1.v.begin(),s1.v.end());s2=c-s1*d;\n        s2.size_down(m-1);\n    }\n    inline int poly_fuhe_inv(poly a,int n)\n    {\n    \twhile (!a.empty()&&!a.back()) a.pop_back();\n    \tif (a[0]!=0){fprintf(stderr,""wrong poly_fuhe_inv(0) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"");exit(-1);}\n    \tint i;for (i=0;i+1<a.size();i++) a[i]=a[i+1];a.pop_back();\n    \tif (!basic::tag) basic::init();return 1ll*(poly_pow(poly_inv(a,n),n,n)[n-1])*basic::inv[n]%mod;\n    }\n};using namespace polynomial;\n//------------------polynomial end------------------\nusing basic::fac;\nusing basic::inv;\nusing basic::fi;\nint binom(int x,int y)\n{\n\treturn 1ll*fac[x]*fi[y]%mod*fi[x-y]%mod;\n}\nint n,m,i,j,fa[300005],sz[300005],c[3],f[3005][3005];\nint ans1[300005],ans2[300005];\nint fnd(int x){if(fa[x]==x)return x;return fa[x]=fnd(fa[x]);}\nvoid init_f()\n{\n\tint n=10;\n\tf[0][0]=1;int i,j,k;\n\tfz1(k,n)fd0g(i,k*3/2){\n\t\tj=k-i;\n\t\tif(!i){\n\t\t\tif(i) f[k][i]=(f[k][i]+1ll*i*f[k-1][i-1]%mod*(k*3-i-1))%mod;\n\t\t\tf[k][i]=(f[k][i]+1ll*(k*3-i-i-1)*f[k][i+1])%mod;\n\t\t}\n\t\telse{\n\t\t\tif(i>1) f[k][i]=(f[k][i]+1ll*(i-1)*f[k-1][i-2])%mod;\n\t\t\tif(i)f[k][i]=(f[k][i]+1ll*(k*3-i-i)*f[k-1][i-1]%mod*(k*3-i-1))%mod;\n\t\t}\n\t}\n/*\tfz0g(k,n){\n\t\tfz0g(i,k*3/2){\n\t\t\tprintf(""%10d"",f[k][i]);\n\t\t}\n\t\tputs("""");\n\t}*/\n}\nstruct ii\n{\n\tint k,i,id;\n};\nvector<ii> vq;\nvoid solve(int id)\n{\n\tif((c[2]+c[2]+c[1])/3<=2){\n\t\tans1[id]=f[(c[2]+c[2]+c[1])/3][c[2]];\n\t}\n\telse{\n\t\tvq.push_back((ii){(c[2]+c[2]+c[1])/3,c[2],id});\n\t}\n\tans2[id]=1ll*fac[c[1]+c[2]+c[0]]%mod*fi[c[1]+c[2]]%mod;\n}\nint pk,pi;\nint v1,v2;\nint v3,v4;\nint calc1(int k,int i,int v1,int v2)\n{\n\tint ans=0;\n\tans=(ans+1ll*(i-1)*v1)%mod;\n\tans=(ans+1ll*(k*3-i-i)*v2%mod*(k*3-i-1))%mod;\n\treturn ans;\n}\nint calc1r(int k,int i,int v1,int ans)\n{\n\tans=(ans-1ll*(i-1)*v1)%mod;ans=(ans+mod)%mod;\n\treturn 1ll*ans*qp((k*3-i-i),mod-2)%mod*qp(k*3-i-1,mod-2)%mod;\n}\nint calc1l(int k,int i,int v2,int ans)\n{\n\tans=(ans-1ll*(k*3-i-i)*v2%mod*(k*3-i-1))%mod;ans=(ans+mod)%mod;\n\tint v1=1ll*ans*qp(i-1,mod-2)%mod;\n\treturn v1;\n}\nint calc2(int k,int i,int v1,int v2)\n{\n\tint ans=0;\n\tans=(ans+1ll*i*v1%mod*(k*3-i-1))%mod;\n\tans=(ans+1ll*(k*3-i-i-1)*v2)%mod;\n\treturn ans;\n}\nint calc2r(int k,int i,int v1,int ans)\n{\n\tans=(ans-1ll*i*v1%mod*(k*3-i-1))%mod;ans=(ans+mod)%mod;\n\tint v2=1ll*qp(k*3-i-i-1,mod-2)*ans%mod;\n\treturn v2;\n}\nint main()\n{\n\tbasic::init();\n\tread(n);fz1(i,n)fa[i]=i,sz[i]=1;c[1]=n;\n\tinit_f();\n\tint _;bool flg=0;fz1(_,n){\n\t\tint x,y;read(x);read(y);x=fnd(x);y=fnd(y);\n\t\tif(x!=y){\n\t\t\tc[sz[x]%3]--;c[sz[y]%3]--;\n\t\t\tsz[y]+=sz[x];fa[x]=y;\n\t\t\tc[sz[y]%3]++;\n\t\t}\n\t\telse{\n\t\t\tif(sz[x]%3==0) c[0]--;\n\t\t\telse break;\n\t\t}\n\t\tsolve(_);\n\t}\n\treverse(vq.begin(),vq.end());\n\tfor(i=0;i+1<vq.size();i++)assert(vq[i].k<=vq[i+1].k);\n\tpk=2;pi=0;\n\tv1=f[pk][pi];v2=f[pk][pi+1];\n\tv3=f[pk+1][pi];v4=f[pk+1][pi+1];\n\tff(vq,it){\n\t\tfor(;;){\n\t\t\tif(pk==it->k&&pi==it->i){ans1[it->id]=v1;break;}\n\t\t\tif(pk==it->k&&pi+1==it->i){ans1[it->id]=v2;break;}\n\t\t\tif(pk+1==it->k&&pi==it->i){ans1[it->id]=v3;break;}\n\t\t\tif(pk+1==it->k&&pi+1==it->i){ans1[it->id]=v4;break;}\n\t\t\tif(pk<it->k){\n\t\t\t\tint dr=calc1(pk+2,pi+2,v3,v4);\n\t\t\t\tint nv4=calc2(pk+2,pi+1,v3,dr);\n\t\t\t\tint l=calc1l(pk+2,pi+1,v3,nv4);\n\t\t\t\tint nv3=calc2(pk+2,pi,l,nv4);\n\t\t\t\tv1=v3;v2=v4;v3=nv3;v4=nv4;\n\t\t\t\tpk++;continue;\n\t\t\t}\n\t\t\tif(pi<it->i){\n\t\t\t\tint dr=calc1(pk+2,pi+2,v3,v4);\n\t\t\t\tint nv1=calc1(pk+1,pi+2,v1,v2);\n\t\t\t\tint nv2=calc2r(pk+1,pi+2,v2,nv1);\n\t\t\t\tint nv4=calc1(pk+2,pi+3,v4,nv1);\n\t\t\t\tv1=v2;\n\t\t\t\tv2=calc1r(pk+1,pi+3,v2,nv2);\n\t\t\t\tv3=v4;v4=nv1;\n\t\t\t\tpi++;continue;\n\t\t\t}\n\t\t\tif(pi>it->i){\n\t\t\t\tint dr=calc1(pk+2,pi+2,v3,v4);\n\t\t\t\tint nv4=calc2(pk+2,pi+1,v3,dr);\n\t\t\t\tint nv3=calc1l(pk+2,pi+1,v3,nv4);\n\t\t\t\tint nv1=calc1l(pk+1,pi+1,v1,v4);\n\t\t\t\tv2=v1;v4=v3;v1=nv1;v3=nv3;\n\t\t\t\tpi--;continue;\n\t\t\t}\n\t\t}\n\t}\n\tfz1(i,n) printf(""%lld\\n"",1ll*ans1[i]*ans2[i]%mod);\n\treturn 0;\n}']","[0, 1, 0, 1, 1]",3400,The partially formed permutation is composed of several paths and cycles and only the length of each path cycle modulo matters We can use a DSU to track the number of paths cycles of each length If at any point a cycle whose length is not is formed the answer is Thus the problem reduces to the following Given s s and s how many ways are there to build a permutation on these objects so that each cycle sums to a multiple of Let be the answer to this problem Note that for as there are ways to choose the next object of any and after merging this with its next object there are ways to build a permutation on the remaining objects Repeatedly applying this recurrence gives so we can eliminate the parameter and multiply the answer by a factorial and inverse factorial in the end Now let We have not one but two recurrence relations satisfies when consider the next object of any when consider the next object of any The key idea now is that because we have two equations relating the four values given any two of these values we can solve for the other two For example if we know and we can calculate Also note that the queried pairs can be visualized as a walk in the plane where each pair does not differ from the previous pair by much By using these recurrences carefully it is possible to calculate for all queries while calculating only values of The details can be tricky The author s solution does the following First reverse the order of the updates possibly adding dummy updates if a cycle whose length is not is created early Then we need to find for a sequence of pairs where and is one of or for all We loop through in order maintaining two values and at all times Whenever we need a transition of the form we use the recurrence to solve for the new value of then use the recurrence to find the new value of The transition is similar For transitions do both of the previous types of transitions once The time complexity of the main part of the problem is The overall time complexity is dominated by the DSU operations Remark 1 Since s and s behave symmetrically Remark 2 The exponential generating function for is 
Those days many boys use beautiful girls photos as avatars in forums So it is pretty hard to tell the gender of a user at the first glance Last year our hero went to a forum and had a nice chat with a beauty he thought so After that they talked very often and eventually they became a couple in the network But yesterday he came to see her in the real world and found out she is actually a very strong man Our hero is very sad and he is too tired to love again now So he came up with a way to recognize users genders by their user names This is his method if the number of distinct characters in one s user name is odd then he is a male otherwise she is a female You are given the string that denotes the user name please help our hero to determine the gender of this user by his method ,"['#include<stdio.h>\n#include<string.h>\n\nchar c[100005];\nint n,m;\n\nint main()\n{\n\tint i,j,a;\n\tn=0;\n\tm=0;\n\tscanf(""%s"",c);\n\tn=strlen(c);\n\tfor(i=0;i<n;i++)\n\t{\n\t\ta=0;\n\t\tfor(j=0;j<i;j++)\n\t\t{\n\t\t\tif(c[i]==c[j])\n\t\t\t\ta++;\n\t\t}\n\t\tif(a==0)\n\t\t\tm++;\n\t}\n\tif(m%2==0)\n\t\tprintf(""CHAT WITH HER!"");\n\telse\n\t\tprintf(""IGNORE HIM!"");\n\treturn 0;\n}']","[0, 0, 1, 0, 0]",800,It is a very simple problem just count how many distinct chars in the input and output the correct answer 
Leonid wants to become a glass carver the person who creates beautiful artworks by cutting the glass He already has a rectangular mm mm sheet of glass a diamond glass cutter and lots of enthusiasm What he lacks is understanding of what to carve and how In order not to waste time he decided to practice the technique of carving To do this he makes vertical and horizontal cuts through the entire sheet This process results in making smaller rectangular fragments of glass Leonid does not move the newly made glass fragments In particular a cut divides each fragment of glass that it goes through into smaller fragments After each cut Leonid tries to determine what area the largest of the currently available glass fragments has Since there appear more and more fragments this question takes him more and more time and distracts him from the fascinating process Leonid offers to divide the labor he will cut glass and you will calculate the area of the maximum fragment after each cut Do you agree ,"['#include <bits/stdc++.h>\n#define REP(a,b) for(int a=0; a<(b); ++a)\n#define FWD(a,b,c) for(int a=(b); a<(c); ++a)\n#define FWDS(a,b,c,d) for(int a=(b); a<(c); a+=d)\n#define BCK(a,b,c) for(int a=(b); a>(c); --a)\n#define ALL(a) (a).begin(), (a).end()\n#define SIZE(a) ((int)(a).size())\n#define VAR(x) #x "": "" << x << "" ""\n#define popcount __builtin_popcount\n#define popcountll __builtin_popcountll\n#define gcd __gcd\n#define x first\n#define y second\n#define st first\n#define nd second\n#define pb push_back\n\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &out, const vector<T> &v){ out << ""{""; for(const T &a : v) out << a << "", ""; out << ""}""; return out; }\ntemplate<typename S, typename T> ostream& operator<<(ostream &out, const pair<S,T> &p){ out << ""("" << p.st << "", "" << p.nd << "")""; return out; }\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double K;\ntypedef vector<int> VI;\n\nconst int dx[] = {0,0,-1,1}; //1,1,-1,1};\nconst int dy[] = {-1,1,0,0}; //1,-1,1,-1};\n\nint w, h, n;\nset<int> W, H;\nmultiset<int> MW, MH;\nchar buff[5];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tscanf(""%d %d %d"", &w, &h, &n);\n\tW.insert(0);\n\tW.insert(w);\n\tH.insert(0);\n\tH.insert(h);\n\tMW.insert(w);\n\tMH.insert(h);\n\tFWD(i,0,n){\n\t\tint a, b, c;\n\t\tscanf(""%s %d"", buff, &c);\n\t\tif(buff[0] != \'V\') swap(W, H), swap(MW, MH);\n\t\tW.insert(c);\n\t\ta = *(--W.find(c));\n\t\tb = *(++W.find(c));\n\t\tMW.erase(MW.find(b-a));\n\t\tMW.insert(b-c);\n\t\tMW.insert(c-a);\n\t\tif(buff[0] != \'V\') swap(W, H), swap(MW, MH);\n\t\tcout << ((LL)(*(--MW.end()))) * *(--MH.end()) << endl;\n\t}\n\treturn 0;\n}\n\n']","[0, 0, 1, 0, 1]",1500,Obviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std set or some logarithmic data structure This solution works in But there is also a nice linear solution if we answer all queries in reverse order Suppose segments are not cutting but merging In this case we may keep the horizontal and vertical cut lines in double linked lists and track the current maximum that can only increase and become equal to the newly merged segment each time This solution works in One may think that this task is about graph theory but it after some investigation and several equivalent changes in task statement it can be reduced to the well known greedy problem Initially you have that points may lie together in a set if they are not too close i e This is obviously equivalent to the following condition Let s consider interval of radius with center in point and call this interval to be the interval of point i Then the statement actually says that no two such intervals should be intersecting This task is well known and can be solved greedily after sorting segments in ascending order of right endpoint It s easy to prove that this solution is correct Among all ways to choose first segments the best way is the one that minimizes x coordinate of the right endpoint of the last segment since it restricts us in the least possible way Problem legend asks you to add minimum number of edges to the given connected undirected graph possibly with loops and duplicating edges and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even First idea is that the resulting graph before we choose the direction but after we added some edges will contain Euler circuit since all degrees are even That s almost what we need if we have an Euler circuit that contains even number of edges we may direct them like following a b c d e It s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree so the resulting degrees will be even But if the Euler circuit is odd meaning that there is odd number of edges in the graph we must add some extra edge to the graph before we continue the easiest way is to add a loop from vertex 0 to itself since it doesn t affect the Euler tour but now tour length is even so everything is ok Now we should think how to add edges optimally It s easy to see that the optimal way is to first fix all odd degrees of vertices i e combine all odd vertices by pairs and put an edge in each pair and then possibly add an extra loop as described above The last part is to actually find an Euler circuit and to print the answer There were issues with this task Intended constraints were actually and the intended solution was using Fast Fourier Transformation that leads to running time But unfortunately the statement contained wrong constraints so we reduced input size during the tour Nevertheless we will add the harder version of this task and you will be able to submit it shortly Key idea is to reduce this task to a polynomial multiplication Let s solve the task in following manner For each position i of the S for each character c from ATGC we will calculate match c i that is equal to the number of c characters that have matching symbol in S if we put string T in position i Then the criteria for us to have an occurrence at position i is that match A i match T i match G i match C i T that means exactly that each character from T being put at position i has a corresponding character in S Now let s find out how to calculate match c i Let s keep only c characters and not c characters in both strings and denote them by 1 and 0 respectively Let s also spread each 1 in string S by the distance k to the left and to the right For example k 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111 and for the character C it will be 0111001110 This bitvector can be calculated in by putting two events 1 and 1 in string S in positions and for each in original string S and then sweeping from left to right over the string S and processing those events Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S In constraints this can be done by using bitsets in Nevertheless this task can be seen as calculation of polynomials S and reversed T product We will keep this as an exercise for those who decide to submit the harder version of this task Let s draw a bounding box that contains all intersection points Let s fix a triangle and consider three angles shown on the picture Calculate area of intersection of those area with the bounding box and call this area to be the area of an angle Then it s easy to see that those three angles are complement to the triangle itself in the bounding box i e triangle area is bounding box area minus three angle areas This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane how much times does it appear in total answer if we sum all values like over all triples of lines Actually the angle is considered as many times as many lines there are that intersect both sides of its right adjacent angle So our task is reduced to calculate for each angle on plane how much lines intersect its sides i e its rays This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right Key idea is that the exact of four angles formed by the pair of lines that is crossed by some third line c can be determined by two numbers its polar angle alpha and its crossing with a coordinate x Further details are shown on the picture below There is also a nice short solution from enot110 here 
People do many crazy things to stand out in a crowd Some of them dance some learn by heart rules of Russian language some try to become an outstanding competitive programmers while others collect funny math objects Alis is among these collectors Right now she wants to get one of special tables In case you forget the table is called special if the following three conditions are satisfied every integer from to appears in the table exactly once in each row numbers are situated in increasing order the sum of numbers in the th column is maximum possible Your goal is to help Alice and find at least one special table of size Both rows and columns are numbered from to with rows numbered from top to bottom and columns numbered from left to right ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nconst int inf = 1001001001;\n\nint n,k,a[1111][1111],q,ans;\n\nint main()\n{\n    //freopen(""input.txt"", ""r"", stdin);\n    //freopen(""output.txt"", ""w"", stdout);\n    ios_base::sync_with_stdio(0);\n\n    cin >> n >> k;\n    for (int i=1; i<=n; i++){\n        for (int j=1; j<k; j++){\n            q++;\n            a[i][j]=q;\n        }\n    }\n    for (int i=1; i<=n; i++){\n        for (int j=k; j<=n; j++){\n            q++;\n            if (j==k) ans+=q;\n            a[i][j]=q;\n        }\n    }\n    cout << ans << endl;\n    for (int i=1; i<=n; i++){\n        for (int j=1; j<=n; j++){\n            cout << a[i][j] << \' \';\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n']","[0, 0, 1, 0, 0]",1300,Lets fill our table row by row greedily We want to have maximal possible number on k th place in the first row After it we need at least numbers greater than ours so its maximum value is If we select it then we are fixing all numbers after column in the first row from to On the first lets put smallest possible numbers If we do the same thing in the second row then in the beginning it will have numbers from to and from th position maximum possible values from to And so on we will fill all rows With careful implementation we don t need to store whole matrix and we need only memory Our algorithm works in time 
You have a permutation an array a a 1 a 2 ldots a n of distinct integers from 1 to n The length of the permutation n is odd You need to sort the permutation in increasing order In one step you can choose any prefix of the permutation with an odd length and reverse it Formally if a a 1 a 2 ldots a n you can choose any odd integer p between 1 and n inclusive and set a to a p a p 1 ldots a 1 a p 1 a p 2 ldots a n Find a way to sort a using no more than frac 5n 2 reversals of the above kind or determine that such a way doesn t exist The number of reversals doesn t have to be minimized ,"[""#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<int> a(n);\n\tfor(int& x : a){\n\t\tcin >> x;\n\t\tx--;\n\t}\n\tvector<int> res;\n\twhile(n > 1){\n\t\tint x = n-2;\n\t\tint y = n-1;\n\t\tint lx = 0;\n\t\tint ly = 0;\n\t\tauto set_val = [&](){\n\t\t\tlx = 0;\n\t\t\tly = 0;\n\t\t\twhile(a[lx] != x) lx++;\n\t\t\twhile(a[ly] != y) ly++;\n\t\t};\n\t\tset_val();\n\t\tif(((x - lx) & 1) || ((y - ly) & 1)){\n\t\t\tcout << -1 << '\\n';\n\t\t\treturn;\n\t\t}\n\t\tres.push_back(ly + 1);\n\t\treverse(a.begin(), a.begin() + ly + 1);\n\t\tset_val();\n\t\tres.push_back(lx);\n\t\treverse(a.begin(), a.begin() + lx);\n\t\tset_val();\n\t\tres.push_back(lx + 2);\n\t\treverse(a.begin(), a.begin() + lx + 2);\n\t\tset_val();\n\t\tres.push_back(3);\n\t\treverse(a.begin(), a.begin() + 3);\n\t\tres.push_back(n);\n\t\treverse(a.begin(), a.begin() + n);\n\t\tn -= 2;\n\t}\n\tcout << res.size() << '\\n';\n\tfor(int r : res){\n\t\tcout << r << ' ';\n\t}\n\tcout << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}""]","[1, 0, 0, 0, 0]",2000,First of all consider what happens when we reverse a prefix of odd length Elements to don t move at all and for each from to moves to Note that and have the same parity therefore no element can ever change the parity of its position In the final sorted permutation we need to have for all that is the parity of each element s position must match the parity of its value This leads to the following necessary condition for each If for any this doesn t hold the permutation can not be sorted It turns out this condition is also sufficient Let s devise a procedure to sort a permutation of odd length If and we don t have to touch and ever again and we can proceed to sorting a permutation of length Can we actually move and to their final positions with a simple sequence of steps Indeed we can Here is one way to do this in exactly steps Let note that is odd Reverse a prefix of length to move to position Let note that is even Reverse a prefix of length to move to position Reverse a prefix of length to move to position and to position Reverse a prefix of length to move to position stays at position Reverse a prefix of length to move to position and to position as desired We can use this procedure times to first move and to their final positions then and and so on This solution requires exactly steps 
You are given an array of integers a of length n You can apply the following operation any number of times maybe zero First choose an integer k such that 1 le k le n and pay k 1 coins Then choose k indices such that 1 le i 1 i 2 ldots i k le n Then for each x from 1 to k increase a i x by 1 Find the minimum number of coins needed to make a non decreasing That is a 1 le a 2 le ldots le a n ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)//~ #pragma comment(linker, ""/stack:200000000"")#pragma GCC optimize(""O3"")//~ #pragma GCC target (""avx2"")//~ #pragma GCC optimize(""Ofast"")//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")//~ #pragma GCC optimize(""unroll-loops"")#include <bits/stdc++.h>#include <ext/pb_ds/assoc_container.hpp>#include <ext/pb_ds/tree_policy.hpp>\xa0using namespace __gnu_pbds;using namespace std;\xa0template <typename T>using ordered_set =    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\xa0#define sim template < class c#define ris return * this#define dor > debug & operator <<#define eni(x) sim > typename \\  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {sim > struct rge { c b, e; };sim > rge<c> range(c i, c j) { return rge<c>{i, j}; }sim > auto dud(c* x) -> decltype(cerr << *x, 0);sim > char dud(...);struct debug {#ifdef LOCAL~debug() { cerr << endl; }eni(!=) cerr << boolalpha << i; ris; }eni(==) ris << range(begin(i), end(i)); }sim, class b dor(pair < b, c > d) {  ris << ""("" << d.first << "", "" << d.second << "")"";}sim dor(rge<c> d) {  *this << ""["";  for (auto it = d.b; it != d.e; ++it)    *this << "", "" + 2 * (it == d.b) << *it;  ris << ""]"";}#elsesim dor(const c&) { ris; }#endif};#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\xa0#define shandom_ruffle random_shuffle\xa0using ll=long long;using pii=pair<int,int>;using pll=pair<ll,ll>;using vi=vector<int>;using vll=vector<ll>;const int nax=1000*1007;\xa0int n;ll tab[nax];ll chce[nax];\xa0void test(){\tscanf(""%d"", &n);\tfor (int i=1; i<=n; i++)\t\tscanf(""%lld"", &tab[i]);\tfor (int i=1; i<=n; i++)\t\tchce[i]=max(tab[i], chce[i-1]);\tll wyn=0;\tll naj=0;\tfor (int i=1; i<=n; i++)\t{\t\twyn+=chce[i]-tab[i];\t\tnaj=max(naj, chce[i]-tab[i]);\t}\t//~ debug() << range(chce+1, chce+1+n);\tprintf(""%lld\\n"", wyn+naj);}\xa0int main(){\tint t;\tscanf(""%d"", &t);\twhile(t--)\t\ttest();\treturn 0;}']","[1, 0, 0, 0, 0]",1000,Suppose that after all of the operations the value at index has been increased by Notice that our cost can be factored into two parts is responsible for how many elements we choose and is responsible for how many operations we apply Since we have to apply at least operations and over all operations we select a total of elements we have to pay at least coins This bound is also achievable if on the th operation numbered from to we select all indices with Suppose the resulting array is sorted Then must hold for all Using we get for all If we define we get This gives the lower bounds and Setting achieves them so the answer to our problem is coins Complexity Note it s possible to simulate the process on the values of described above in 
You have a square chessboard of size n times n Rows are numbered from top to bottom with numbers from 1 to n and columns from left to right with numbers from 1 to n So each cell is denoted with pair of integers x y 1 le x y le n where x is a row number and y is a column number You have to perform q queries of three types Put a new rook in cell x y Remove a rook from cell x y It s guaranteed that the rook was put in this cell before Check if each cell of x 1 y 1 x 2 y 2 of the board is attacked by at least one rook is a set of cells x y such that for each cell two conditions are satisfied x 1 le x le x 2 and y 1 le y le y 2 Recall that cell a b is attacked by a rook placed in cell c d if either a c or b d In particular the cell containing a rook is attacked by this rook ,"['#include<algorithm>\n#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<map>\n#define lc(x) (x<<1)\n#define rc(x) (x<<1|1)\n#define mid (l+r>>1)\nusing namespace std;\nconst int maxn=500005,maxt=maxn<<2;\nint n,m,T,ans;\nint t[maxn][2],mn[maxt][2];\nvoid update(int l,int r,int now,int p,int v,int tp){\n\tif(l==r){\n\t\tmn[now][tp]+=v;\n\t\treturn ;\n\t}\n\tif(p<=mid)\n\t\tupdate(l,mid,lc(now),p,v,tp);\n\telse update(mid+1,r,rc(now),p,v,tp);\n\tmn[now][tp]=min(mn[lc(now)][tp],mn[rc(now)][tp]);\n}\nint query(int l,int r,int now,int L,int R,int tp){\n\tif(L<=l&&r<=R)\n\t\treturn mn[now][tp];\n\tint res=2;\n\tif(L<=mid)\n\t\tres=min(res,query(l,mid,lc(now),L,R,tp));\n\tif(mid<R)\n\t\tres=min(res,query(mid+1,r,rc(now),L,R,tp));\n\treturn res;\n}\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\twhile(m--){\n\t\tint t,x,y,a,b;\n\t\tscanf(""%d%d%d"",&t,&x,&y);\n\t\tif(t==1)\n\t\t\tupdate(1,n,1,x,1,0),update(1,n,1,y,1,1);\n\t\tif(t==2)\n\t\t\tupdate(1,n,1,x,-1,0),update(1,n,1,y,-1,1);\n\t\tif(t==3){\n\t\t\tscanf(""%d%d"",&a,&b);\n\t\t\tif(query(1,n,1,x,a,0)||query(1,n,1,y,b,1))\n\t\t\t\tputs(""Yes"");\n\t\t\telse puts(""No"");\n\t\t}\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 1]",1400,Consider some subrectangle Note that each its cell is attacked by some rook if and only if there is at least one rook in each row or in each column Now we will solve the problem using this criterium Let s create a set where we will store indices of rows in which there are rooks Similarly we will store indices of columns in which there are rooks in a set If we have to answer the query of the third type we have to check if there is at least one in the set such that or there is at least one in the set such that If we will store these two sets sorted we can perform this type of query in using binary search Now we re going to answer queries of the first and the second types Let s store for each row and column how many rooks are there in this row or column When we add a new rook we should increment this counters for the corresponding row and column and remove the row from set and the column from set When we remove a rook we should decrement counters for its row and column and if there is no more rooks in the row or in the column we should add their indices to or Time complexity 
Vasya likes taking part in Codeforces contests When a round is over Vasya follows all submissions in the system testing tab There are n solutions the i th of them should be tested on a i tests testing one solution on one test takes 1 second The solutions are judged in the order from 1 to n There are k testing processes which test solutions simultaneously Each of them can test at most one solution at a time At any time moment t when some testing process is not judging any solution it takes the first solution from the queue and tests it on each test in increasing order of the test ids Let this solution have id i then it is being tested on the first test from time moment t till time moment t 1 then on the second test till time moment t 2 and so on This solution is fully tested at time moment t a i and after that the testing process immediately starts testing another solution Consider some time moment let there be exactly m fully tested solutions by this moment There is a caption System testing d ,"['#include <bits/stdc++.h>                                                                                                                                                                                                                                                                                            \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nusing namespace std;\n\nint n, k;\nint a[100001];\n\nint cur[100001];\nint last[100001];\n\nint used[100001];\n\nint sz;\n\nint main(){\n    #ifdef DIAS\n        freopen(""input.txt"", ""r"", stdin);\n        //freopen(""output.txt"", ""w"", stdout);\n    #elif NAME \n    \tfreopen(fn"".in"", ""r"", stdin);\n    \tfreopen(fn"".out"", ""w"", stdout);\n    #endif\n    cin >> n >> k;\n    for(int i = 1; i <= n; i++){\n    \tcin >> a[i];\n    }\n    for(int i = 1; i <= k; i++){\n    \tcur[i] = -1;\n    \tlast[i] = -1;\n    }\n    int cnt = 0, ans = 0;\n   \tfor(int i = 0; i <= 150 * n; i++){\n   \t\t\n \t  \tfor(int j = 1; j <= k; j++){\n\t\t\tif(last[j] == i){\n\t\t\t\tcur[j] = -1;\n\t\t\t\tlast[j] = -1;\n\t\t\t\tused[j] = 0;\n\t\t\t\tcnt ++;\n\t\t\t}          \t\n\t\t}\n\n   \t\tfor(int j = 1; j <= k; j++){\n   \t\t\tif(cur[j] == -1 && sz < n){\n   \t\t\t\tcur[j] = ++sz;\n   \t\t\t\tlast[j] = i + a[sz]; \n   \t\t\t}\n\t\t}\n        \n\n\t\tlong double y = 100.0 * cnt / n + 0.5;\n\t\tint x = y;\n\n\t\t\n\t\tfor(int j = 1; j <= k; j++){\n\t\t\tif(cur[j] != -1 && a[cur[j]] - (last[j] - i) + 1 == x && !used[j]){\n\t\t\t\tused[j] = 1;\n\t\t\t\tans ++;\n\t\t\t}\n\t\t}\n\n   \t}\n   \tcout << ans;\n}\n']","[0, 0, 1, 0, 0]",1600,Let s determine for each solution when it begins being tested It can be done for example by the following algorithm let s store for each testing process the time when it becomes free to test something initially all these numbers are zeroes then iterate over all solutions in the queue and for each of them we pick a process with minimal time say that it s the time when this solution begins being tested and then update the time when this process stops testing After we determined this we can easily know for each moment the number of solutions which are completely tested before this moment and then for each test of each solution just check the required condition of being interesting on this test 
Yaroslav calls an array of integers if it meets the following conditions at that An array of integers is called if it meets the following conditions The elements in it do not decrease If the inequalities and hold If we can rearrange its elements and get at least one and at most distinct good arrays Yaroslav has three integers He needs to count the number of distinct great arrays Help Yaroslav As the answer may be rather large print the remainder after dividing it by Two arrays are considered distinct if there is a position in which they have distinct numbers ,"['#define _CRT_SECURE_NO_DEPRECATE\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#include <iostream>\n#include <iterator>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <ctime>\n#include <cstring>\n#include <functional>\n#include <bitset>\n#pragma comment(linker, ""/STACK:66777216"")\nusing namespace std;\n#define pb push_back\n#define ppb pop_back\n#define pi 3.1415926535897932384626433832795028841971\n#define mp make_pair\n#define x first\n#define y second\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define INF 1000000000\n#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)\n#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)\n#define all(c) (c).begin(), (c).end()\n#define SORT(c) sort(all(c))\n#define rep(i,n) FOR(i,1,(n))\n#define rept(i,n) FOR(i,0,(n)-1)\n#define L(s) (int)((s).size())\n#define C(a) memset((a),0,sizeof(a))\n#define VI vector <int>\n#define ll long long\n#define MOD 1000000007\n\ninline void add(int &a, int b) {\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\n\nconst int mod = 65536;\nconst int N = 100002;\nstruct hmap {\n    pair<int, string> key[N + 1];\n    unsigned ll ck[N + 1];\n    int val[N + 1], nx[N + 1], last[mod], hc;\n    hmap() {\n        reset();\n    }\n    inline void reset() {\n        memset(last, -1, sizeof(last));\n        hc = 0;\n    }\n    inline unsigned ll gh(const pair<int, string> &k) {\n        unsigned ll h = 1;\n        h = (h * 1000000009) ^ (k.x + 101);\n        rept(i, L(k.y)) {\n            h = (h * 10000019) ^ (k.y[i] + 2);\n        }\n        return h;\n    }\n    inline int &add(const pair<int, string> &k) {\n        unsigned ll h = gh(k);\n        int th = h & (mod - 1);\n        for (int w = last[th]; w >= 0; w = nx[w]) {\n            if (ck[w] == h) return val[w];\n        }\n        key[hc] = k; ck[hc] = h; val[hc] = 0; nx[hc] = last[th]; last[th] = hc++;\n        return val[hc - 1];\n    }\n};\n\nint a,b,c,d,n,m,k;\nhmap dp[2];\n//map<pair<int, string>, int> cur, nx;\nchar now[52], tmp[52];\nint ce[102][102];\ninline void decode(string s, char *a) {\n    memset(a, 0, 52 * sizeof(char));\n    rept(i, min(51, L(s))) {\n        a[i] = s[i] - 1;\n    }\n}\ninline void code(char *a, string &s) {\n    int last = 0;\n    rept(i, 51) {\n        if (a[i]) last = i;\n    }\n    s.resize(last + 1);\n    rept(i, last + 1) {\n        s[i] = a[i] + 1;\n    }\n}\nint main() {\n    //freopen(""input.txt"",""r"",stdin);\n    //freopen(""output.txt"",""w"",stdout);\n\n    rept(i, 101) {\n        ce[i][0] = ce[i][i] = 1;\n        rep(j, i - 1) {\n            ce[i][j] = ce[i - 1][j - 1] + ce[i - 1][j];\n            if (ce[i][j] > 101) ce[i][j] = 101;\n        }\n    }\n\n    scanf(""%d%d%d"", &n, &m, &k);\n    int cur = 1, nx = 0;\n    rep(i, 50) {\n        C(now);\n        now[i] = 1;\n        string s;\n        code(now, s);\n        int &t = dp[nx].add(mp(n - i, s));\n        t  = 1;\n    }\n\n    int ans = 0;\n    int ms = 0;\n    FOR(i, 2, m) {\n        swap(cur, nx);\n        ms = max(ms, dp[cur].hc);\n        dp[nx].reset();\n        rept(it, dp[cur].hc) {\n            int cd = dp[cur].val[it];\n            if (!cd) continue;\n            decode(dp[cur].key[it].y, now);\n            int can = dp[cur].key[it].x, last = 0;\n            rept(j, 51) {\n                if (now[j]) last = j;\n            }\n            rep(cadd, can) {\n\t\t\t\tif (cadd > 50) break;\n                C(tmp);\n                rep(fr, last) {\n                    if (!now[fr]) continue;\n                    if (cadd < fr) break;\n                    int ways = now[fr];\n                    ways *= ce[cadd - 1][fr - 1];\n                    if (ways > k) ways = k + 1;\n                    if (cadd - fr == 0) {\n                        if (ways <= k && ways) {\n                            ans = (ans + (ll)cd * (m - i + 1)) % MOD;\n                        }\n                        continue;\n                    }\n                    tmp[cadd - fr] += ways;\n                    if (tmp[cadd - fr] > k) tmp[cadd - fr] = k + 1;\n                }\n                int ns = can - cadd;\n                rep(j, last) {\n                    if (j > ns) {\n                        tmp[j] = 0;\n                    }\n                    if (tmp[j] > k) {\n                        FOR(z, j, last) tmp[z] = 0;\n                        ns = min(ns, j - 1);\n                        break;\n                    }\n                }\n                if (!ns) continue;\n                string h;\n                code(tmp, h);\n                \n                int &t = dp[nx].add(mp(ns, h));\n                add(t, cd);\n            }\n        }\n    }\n    printf(""%d\\n"", ans);\n}\n']","[0, 0, 0, 1, 0]",2800,We will build the needed arrays sequentially adding numbers Let s look at what states we need First it is obvious that you need to keep the number of ways to build an array of already added numbers secondly you need to know the total amount of added numbers Now let s look at what happens when we add a new number that is greater than all of the previous in a certain amount It is clear that the added numbers should stand between the numbers 1 to less In this case if we put two new numbers in a row between them should stand more since we already have placed less It is obvious that you need to cover all the previous numbers among which must stand newly added Thus we have another state the number of integers between which we should put the new ones Thus we have the dynamics of the four parameters dp all ways lastnumber counttoadd Transfer It is clear that you need to add at least counttoadd numbers but how will this affect the number of ways to arrange the numbers It s simple Suppose we added number x then the number of ways to be multiplied by the value of Q x counttoadd counttoadd where Q x y the number of ways to assign the same x balls in y different boxes Q x y C x y 1 y 1 where C x y binomial coefficient 
Lena is a programmer She got a task to solve at work There is an empty set of pairs of integers and queries to process Each query is one of three types Add a pair to the set Remove a pair added in the query number All queries are numbered with integers from to For a given integer find the maximal value over all pairs from the set Help Lena to process the queries ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cassert>\n#include <set>\nusing namespace std;\ntypedef long long LL;\nconst int N = 300005;\nstruct Point {\n    int x , y;\n    Point (int _x = 0 , int _y = 0) {\n        x = _x;\n        y = _y;\n    }\n    Point operator - (const Point& R) const {\n        return Point(x - R.x , y - R.y);\n    }\n    LL operator ^ (const Point& R) const {\n        return (LL)x * R.y - (LL)y * R.x;\n    }\n    LL operator % (const Point& R) const {\n        return (LL)x * R.x + (LL)y * R.y;\n    }\n    bool operator < (const Point &R) const {\n        if (x != R.x)\n            return x < R.x;\n        return y < R.y;\n    }\n};\nint n , m , p;\nPoint W[N] , K[N];\nmap<Point , int> Hash;\nLL res[N] , ans[N];\nint a[N];\n\nbool cmpP(const int &A , const int &B) {\n    return W[A] < W[B];\n}\nbool cmpQ(const int &A , const int &B) {\n    return (LL)K[A].x * K[B].y < (LL)K[B].x * K[A].y;\n}\nvoid update(vector<int>& P , vector<int>& Q) {\n    if (P.empty() || Q.empty())\n        return;\n    sort(P.begin() , P.end() , cmpP);\n    vector<int> A , B;\n    for (int i = 0 ; i < Q.size() ; ++ i)\n        if (K[Q[i]].y >= 0) {\n            A.push_back(Q[i]);\n        } else {\n            B.push_back(Q[i]);\n        }\n    sort(A.begin() , A.end() , cmpQ);\n    sort(B.begin() , B.end() , cmpQ);\n    vector<Point> s(P.size() + 1);\n    int t = 0;\n    for (int i = 0 ; i < P.size() ; ++ i) {\n        Point D = W[P[i]];\n        while (t > 1 && ((D - s[t - 2]) ^ (s[t - 1] - s[t - 2])) <= 0)\n            -- t;\n        s[t ++] = D;\n    }\n    for (int i = 0 , j = 0 ; i < A.size() ; ++ i) {\n        while (j + 1 < t && (K[A[i]] % s[j + 1]) >= (K[A[i]] % s[j]))\n            ++ j;\n        res[A[i]] = max(res[A[i]] , K[A[i]] % s[j]);\n    }\n\n    t = 0;\n    for (int i = 0 ; i < P.size() ; ++ i) {\n        Point D = W[P[i]];\n        while (t > 1 && ((D - s[t - 2]) ^ (s[t - 1] - s[t - 2])) >= 0)\n            -- t;\n        s[t ++] = D;\n    }\n    reverse(A.begin() , A.end());\n    reverse(B.begin() , B.end());\n    for (int i = 0 , j = 0 ; i < B.size() ; ++ i) {\n        while (j + 1 < t && (K[B[i]] % s[j + 1]) >= (K[B[i]] % s[j]))\n            ++ j;\n        res[B[i]] = max(res[B[i]] , K[B[i]] % s[j]);\n    }\n}\nint del[N];\nvoid divide(const vector<int> &A) {\n    if (A.size() <= 1)\n        return;\n    vector<int> P , Q;\n    int r = A.size() , mid = r / 2;\n    for (int i = 0 ; i < mid ; ++ i)\n        P.push_back(A[i]);\n    divide(P);\n    P.clear();\n    for (int i = 0 ; i < r ; ++ i)\n        if (A[i] > 0 && (A[i] & 1))\n            del[A[i] >> 1] = 1;\n    for (int i = 0 ; i < mid ; ++ i)\n        if (A[i] > 0 && (~A[i] & 1)) {\n            if (!del[A[i] >> 1])\n                P.push_back(A[i] >> 1);\n            else\n                del[A[i] >> 1] = 2;\n        }\n    for (int i = mid ; i < r ; ++ i)\n        if (A[i] < 0)\n            Q.push_back(-A[i]);\n    update(P , Q);\n    Q.clear();\n    int c1 = 0 , c2 = 0;\n    for (int i = r - 1 ; i >= mid ; -- i) {\n        if (A[i] > 0 && (A[i] & 1) && del[A[i] >> 1] == 2) {\n            Q.push_back(A[i] ^ 1);\n            ++ c1;\n        } else if (A[i] < 0) {\n            Q.push_back(A[i]);\n            ++ c2;\n        }\n    }\n    for (int i = 0 ; i < r ; ++ i)\n        if (A[i] > 0 && (A[i] & 1))\n            del[A[i] >> 1] = 0;\n    if (c1 && c2)\n        divide(Q);\n    P.clear();\n    for (int i = mid ; i < r ; ++ i)\n        P.push_back(A[i]);\n    divide(P);\n}\nint iid[N];\nvoid work() {\n    scanf(""%d"" , &n);\n    vector<int> A;\n    for (int i = 0; i < n ; ++ i) {\n        Point S;\n        scanf(""%d"" , &a[i]);\n        if (a[i] == 3) {\n            scanf(""%d"" , &S.x);\n            S.y = 1;\n            ++ m;\n            res[m] = -1LL << 60;\n            K[m] = S;\n            a[i] = -m;\n        } else {\n            if (a[i] == 1) {\n                scanf(""%d%d"" , &S.x , &S.y);\n                W[++ p] = S;\n                iid[i] = p;\n                //Hash[S] = p;\n                a[i] = p << 1;\n            } else {\n                int j;\n                scanf(""%d"" , &j);\n                a[i] = iid[j - 1] << 1 | 1;\n                //Hash.erase(S);\n            }\n        }\n        A.push_back(a[i]);\n    }\n    divide(A);\n    for (int i = 1 ; i <= m ; ++ i) {\n        if (res[i] == -1LL << 60) {\n            puts(""EMPTY SET"");\n        } else {\n            printf(""%lld\\n"" , res[i]);\n        }\n    }\n}\n\nint main() {\n    work();\n    return 0;\n}']","[0, 0, 0, 0, 1]",2500,The problem was suggested by AmirMohammad Dehghan PrinceOfPersia Let s interpret the problem geometrically the pairs from the set are the lines and the problem to find to topmost intersection of the vertical line with the lines from the set Let s split the queries to blocks Consider the lines added before the current block and that will not deleted in the current block Let s build the lower envelope by that lines Now to calculate the answer to the query we should get maximum over the lines from the envelope and the lines from the block before the current query that is not deleted yet There are no more than lines from the block so we can iterate over them Let s find the answers from the envelope for all queries of the third type from the block at once we should sort them and iterate over envelope using two pointers technique C solution 
The text gcdSum of a positive integer is the gcd of that integer with its sum of digits Formally text gcdSum x gcd x text sum of digits of x for a positive integer x gcd a b denotes the greatest common divisor of a and b the largest integer d such that both integers a and b are divisible by d For example text gcdSum 762 gcd 762 7 6 2 gcd 762 15 3 Given an integer n find the smallest integer x ge n such that text gcdSum x 1 ,"['#include<bits/stdc++.h>\n#define re register\n#define int long long \nusing namespace std;\ninline int read(){\n\tre int t=0;re char v=getchar();\n\twhile(v<\'0\')v=getchar();\n\twhile(v>=\'0\')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nconst int M=998244353;\ninline void add(re int &x,re int y){(x+=y)>=M?x-=M:x;}\ninline int ksm(re int x,re int y){\n\tre int s=1;\n\twhile(y){\n\t\tif(y&1)s=1ll*s*x%M;\n\t\tx=1ll*x*x%M,y>>=1;\n\t}\n\treturn s;\n}\nstruct edge{int to,next;}e[2000002];\nint t,n,m,a[1000002],ans,cnt,head[1000002],b[1000002];\ninline int gcd(re int x,re int y){return y?gcd(y,x%y):x;}\ninline bool check(re int x){\n\tre int y=x,s=0;\n\twhile(x)s+=x%10,x/=10;\n\tif(gcd(y,s)>1)return 1;\n\treturn 0;\n}\nsigned main(){\n\tt=read();\n\twhile(t--){\n\t\tn=read();\n\t\twhile(!check(n))++n;\n\t\tprintf(""%lld\\n"",n);\n\t}\n}\n']","[0, 1, 0, 0, 0]",800,Therefore for the input n we can simply check which one of n n 1 and n 2 has its gcd sum 1 and print the lowest of them 
Consider a grid in which some cells are empty and some cells are filled Call a cell in this grid if starting at that cell you can exit the grid by moving up and left through only empty cells This includes the cell itself so all filled in cells are not exitable Note that you can exit the grid from any leftmost empty cell cell in the first column by going left and from any topmost empty cell cell in the first row by going up Let s call a grid if given only which cells are exitable we can exactly determine which cells are filled in and which aren t You are given a grid a of dimensions n times m i e a grid with n rows and m columns You need to answer q queries 1 leq q leq 2 cdot 10 5 Each query gives two integers x 1 x 2 1 leq x 1 leq x 2 leq m and asks whether the subgrid of a consisting of the columns x 1 x 1 1 ldots x 2 1 x 2 is determinable ,"['#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, m, q;\nstring S[1000005];\nint dat[1000005];\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n\tcin >> n >> m;\n\trep(i, n) cin >> S[i];\n\t\n\trep1(i, n - 1) rep1(j, m - 1) dat[j] += S[i - 1][j] == \'X\' && S[i][j - 1] == \'X\';\n\trep1(i, m - 1) dat[i] += dat[i - 1];\n\t\n\tcin >> q;\n\trep(i, q) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tif(dat[l - 1] == dat[r - 1]) printf(""YES\\n"");\n\t\telse printf(""NO\\n"");\n\t}\n\treturn 0;\n}']","[1, 0, 1, 1, 0]",1700,First notice that in a determinable grid for any cell it can t be that both the cell above it and the cell to its left are filled If that were the case then the cell wouldn t be exitable regardless of whether it was filled or not and so we couldn t determine whether it was filled Now notice that in any grid with the above property namely that from each cell you can move either up or to the left into an empty cell or both every empty cell must be exitable just keep moving either up or to the left whichever is possible until you exit the grid It follows that for any grid satisfying that property given only which cells are exitable starting from the outermost cells you will be able to determine that the nonexitable cells are filled which implies that the next cells satisfy the property which further implies that the nonexitable ones there are filled and so on This allows you to determine the entire grid since the exitable cells are obviously empty Therefore a grid being determinable is equivalent to all of its cells having an empty cell immediately above and or to the left of it You can check this for arbitrary subgrids by precomputing two dimensional prefix sums of the cells that violate this property then checking whether the sum for a given subgrid is This solution is The actual problem only asked for subgrids that contained every row which allows for a somewhat simpler implementation 
Let s call a positive integer if it has only one non zero digit For example 5000 4 1 10 200 are extremely round integers 42 13 666 77 101 are not You are given an integer n You have to calculate the number of extremely round integers x such that 1 le x le n ,['#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n;\n    cin >> n;\n    int ans = 0;\n    for (int j = 1; j <= 9; j++){\n      int x = j;\n      while (x <= n){\n        ans++;\n        x *= 10;\n      }\n    }\n    cout << ans << endl;\n  }\n}'],"[0, 0, 1, 0, 0]",800,There are many ways to solve this problem The most naive one iterating through all numbers from to in each test case and checking if they are extremely round fails since it is but you can optimize it by noticing that extremely round numbers are rare So for example we can iterate through all numbers from to once remember which ones are extremely round store them into an array and while answering the test case only check the numbers from the array we have created There is also a solution in per test case with a formula try to invent it yourself 
Given an array a of length n Let s construct a square matrix b of size n times n in which the i th row contains the array a cyclically shifted to the right by i 1 For example for the array a 3 4 5 the obtained matrix isb begin bmatrix 3 4 5 5 3 4 4 5 3 end bmatrix Let s construct the following graph The graph contains n 2 vertices each of which corresponds to one of the elements of the matrix Let s denote the vertex corresponding to the element b i j as i j We will draw an edge between vertices i 1 j 1 and i 2 j 2 if i 1 i 2 j 1 j 2 le k and gcd b i 1 j 1 b i 2 j 2 1 where gcd x y denotes the greatest common divisor of integers x and y Your task is to calculate the number of connected components dagger in the obtained graph dagger A connected component of a graph is a set of vertices in which any vertex is reachable from any other via edges and adding any other vertex to the set violates this rule ,"['#include<bits/stdc++.h>using namespace std;#define ll long long#define MP make_pairmt19937 rnd(time(0));const int MAXN=2e6+5;int n,k,m,a[MAXN],fa[MAXN];int p[MAXN],pr[MAXN],lst[MAXN];bool vis[MAXN];inline int find(int x){\twhile(x^fa[x]) x=fa[x]=fa[fa[x]];\treturn x;}void init(){\tfor(int i=2;i<MAXN;i++){\t\tif(!vis[i]) p[i]=i,pr[++m]=i;\t\tfor(int j=1;j<=m&&pr[j]*i<MAXN;j++){\t\t\tp[pr[j]*i]=pr[j];\t\t\tvis[pr[j]*i]=true;\t\t\tif(i%pr[j]==0) break;\t\t}\t}}void solve(){\tcin>>n>>k;\tll ans=0;\tfor(int i=1;i<=n;i++){\t\tcin>>a[i];\t\tif(a[i]==1) ans+=n-2+(i==1);\t}\treverse(a+1,a+n+1);\tfor(int i=1;i<n;i++) a[n+i]=a[i];\tn=2*n-1;\tfor(int i=1;i<=n;i++) fa[i]=i;\tvector<int> ini;\tfor(int i=1;i<=n;i++){\t\twhile(a[i]>1){\t\t\tint x=p[a[i]];a[i]/=x;ini.push_back(x);\t\t\tif(lst[x]&&i-lst[x]<=k) fa[find(i)]=find(lst[x]);\t\t\tlst[x]=i;\t\t}\t}\tfor(int i=1;i<=n;i++) if(find(i)==i) ans++;\tcout<<ans<<\'\\n\';\tfor(int i:ini) lst[i]=0;}int main(){\tios::sync_with_stdio(false);\t// freopen(""Otomachi_Una.in"",""r"",stdin);\t// freopen(""Otomachi_Una.out"",""w"",stdout);\tinit();\tint _;cin>>_;\twhile(_--) solve();\treturn 0;}']","[0, 0, 0, 0, 1]",2400,Notice that since we have cyclic shifts to the right and the diagonals parallel to the main one will be in the same connected component except for the case with ones Diagonals consisting of ones will be counted separately and forgotten After that we can solve the problem for the one dimensional case where each element is a representative of its diagonal By definition if the GCD of some pair of elements is greater than then this means that they are both divisible by some prime number Let s find all the elements of the array diagonals that are divisible by each prime number Let the indices of the current prime number be We will draw edges between and if It is claimed that the connected components in such a graph will coincide with the connected components if we draw edges between all valid pairs Indeed if there is an edge between two elements in the complete graph this means that the distance between them is not greater than and we can reach them in the new graph either by one edge or through elements that are divisible by the same prime number Using the sieve of Eratosthenes we can quickly factorize all numbers into prime divisors after which the number of connected components in the graph can be calculated using DSU or DFS The time complexity of this solution is 
Vasya and Petya are playing a simple game Vasya thought of number between and and Petya tries to guess the number Petya can ask questions like Is the unknown number divisible by number The game is played by the following rules first Petya asks the questions that interest him also he can ask no questions and then Vasya responds to each question with a yes or a no After receiving all the answers Petya should determine the number that Vasya thought of Unfortunately Petya is not familiar with the number theory Help him find the minimum number of questions he should ask to make a guaranteed guess of Vasya s number and the numbers he should ask the questions about ,"['#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> PI;\ntypedef long long LL;\ntypedef double D;\n#define FI first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define R(I,N) for(int I=0;I<N;I++)\n#define F(I,A,B) for(int I=A;I<B;I++)\n#define FD(I,N) for(int I=N-1;I>=0;I--)\n#define make(A) scanf(""%d"",&A)\n#define make2(A,B) scanf(""%d%d"",&A,&B)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define db if(1)printf\ntemplate<typename C> void MA(C& a,C b){if(a<b)a=b;}\ntemplate<typename C> void MI(C& a,C b){if(a>b)a=b;}\n#define MAX 1001\nint n;\nbool cz[MAX];\nvector<int> wyn;\nmain(){\n  make(n);\n  F(i,2,n+1){\n    if(cz[i])continue;\n    for(int j=1;j*i <= n;j++)\n      cz[i*j] = 1;\n    int ak = i;\n    while(ak <= n){\n      wyn.PB(ak);\n      ak *= i;\n    }\n  }\n  printf(""%d\\n"",wyn.size());\n  R(i,SZ(wyn))\n    printf(""%d "",wyn[i]);\n  puts("""");\n}\n']","[0, 1, 0, 0, 0]",1500,If Petya didn t ask pk where p is prime and k 1 he would not be able to distinguish pk 1 and pk That means he should ask all the numbers pk It s easy to prove that this sequence actually guesses all the numbers from 1 to n The complexity is O N1 5 or O NloglogN depending on primality test 
A batch of Christmas trees has arrived at the largest store in Berland n customers have already come to the store wanting to buy them Before the sales begin the store needs to determine the price for one tree the price is the same for all customers To do this the store has some information about each customer For the i th customer two integers a i and b i are known which define their behavior if the price of the product is at most a i the customer will buy a tree and leave a positive review otherwise if the price of the product is at most b i the customer will buy a tree but leave a negative review otherwise the customer will not buy a tree at all Your task is to calculate the maximum possible earnings for the store given that it can receive no more than k negative reviews ,"['#include <bits/stdc++.h>#define ll long longusing namespace std;\xa0int main(){    ios::sync_with_stdio(false);    cin.tie(nullptr);\xa0    int t;    cin >> t;\xa0    while(t--){        ll n, k;        cin >> n >> k;\xa0        vector<ll> a(n), b(n);\xa0        for(int i = 0; i < n; i++){            cin >> a[i];        }                for(int i = 0; i < n; i++){            cin >> b[i];        }\xa0        sort(a.begin(), a.end());        sort(b.begin(), b.end());\xa0        vector<ll> arr;        arr.reserve(4 * n);\xa0        for(int i = 0; i < n; i++){            arr.push_back(a[i]);            arr.push_back(a[i] + 1);            arr.push_back(b[i]);            arr.push_back(b[i] + 1);        }\xa0        sort(arr.begin(), arr.end());        arr.erase(unique(arr.begin(), arr.end()), arr.end());\xa0        ll ans = 0;\xa0        for(auto &p : arr){            if(p <= 0) continue;\xa0            int lba = int(lower_bound(a.begin(), a.end(), p) - a.begin());            int lbb = int(lower_bound(b.begin(), b.end(), p) - b.begin());\xa0            ll ncnt = (ll)lba - lbb;            if(ncnt <= k){                ll bs = n - lbb;                ll rv = p * bs;                ans = max(ans, rv);            }        }\xa0        cout << ans << ""\\n"";    }\xa0    return 0;}']","[1, 0, 0, 0, 1]",1600,First let s design a solution in We can solve the problem in if we iterate on the price we use and for every price calculate the number of trees bought and the number of negative reviews However we don t need to check every possible price from to let s instead check every integer in the union of and or check every and then check every Why is it always optimal Suppose some integer price which is not present in the union of and is optimal Then if we use instead of the status of each customer will be the same but we will get more money for each tree we sell So it is enough to check the elements of and the elements of as possible prices This works in we need to speed it up I will explain two different methods that allow to check every price faster Shortly we process all possible prices in ascending order and when we go from one price to the next we update the customers which no longer want to buy a tree with a new price and the customers which will leave a negative review if the price is increased One of the ways to implement it is as follows For every customer create two events of the type when price exceeds the customer will leave a negative review and when price exceeds the customer will no longer buy a tree and leave a negative review These events can be implemented as pairs of integers and Then we can sort the events and process them from left to right in sorted order maintaining the number of trees and negative reviews When we process the event with price the change it makes will come into effect only when the price exceeds so we Furthermore all events with the same price value should be processed at the same time so if there are multiple events with the same price value you don t update the answer after processing only several of them All of this is a bit complicated to implement that s why I would like to show you anFor every price we need to calculate two values the number of trees bought i e the number of customers such that the number of negative reviews i e the number of customers such that The first one can be calculated in with binary search if we sort the array The second one is a bit trickier Let s calculate it as follows take the number of trees bought and then subtract the number of trees bought without a negative review which is the number of customers such that If we sort both arrays and this value can also be processed in with binary search So we spend time to check one possible price and the number of different prices we have to check is up to so this solution works in 
You have been given a matrix a of size n by m containing a permutation of integers from 1 to n cdot m A permutation of n integers is an array containing all numbers from 1 to n exactly once For example the arrays 1 2 1 3 5 4 3 2 1 are permutations while the arrays 1 1 100 1 2 4 5 are not A matrix contains a permutation if when all its elements are written out the resulting array is a permutation Matrices 1 2 3 4 1 1 5 3 2 6 4 contain permutations while matrices 2 1 1 2 2 1 2 100 200 do not You can perform one of the following two actions in one operation choose columns c and d 1 le c d le m c ne d and swap these columns choose rows c and d 1 le c d le n c ne d and swap these rows You can perform any number of operations You are given the original matrix a and the matrix b Your task is to determine whether it is possible to transform matrix a into matrix b using the given operations ,"['#include <bits/stdc++.h>using namespace std;\xa0int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    int t; cin >> t;    while (t--) {        int n, m; cin >> n >> m;        vector a(n, vector<int>(m)), b(n, vector<int>(m));        for (auto &v: a) for (int &x: v) cin >> x;        for (auto &v: b) for (int &x: v) cin >> x;        map<int, int> ai, aj;        map<int, vector<int>> imp, jmp;        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                int x = a[i][j];                ai[x] = i, aj[x] = j;            }        }        for (int i = 0; i < n; i++) {            for (int j = 0; j < m; j++) {                int x = b[i][j];                imp[ai[x]].push_back(i), jmp[aj[x]].push_back(j);            }        }        bool ans = true;        for (auto [_, v]: imp) {            sort(v.begin(), v.end());            ans &= (v.front() == v.back());        }        for (auto [_, v]: jmp) {            sort(v.begin(), v.end());            ans &= (v.front() == v.back());        }        cout << (ans ? ""YES"" : ""NO"") << ""\\n"";    }}']","[1, 1, 1, 0, 1]",1600,For each element you can calculate its positions in both matrices You can see that the rearrangement of rows does not affect the column positions of the elements being rearranged Similarly column rearrangement does not affect row positions Since the permutation of rows affects the entire rows for all elements that have the same position row in the original matrix the position row in the resulting matrix must also match Similarly the columns must match In order to check the coincidence of rows and columns let s count 4 arrays the positions of rows and columns in the original and received matrices Then you need to check that for all with the same row value in the original matrix the row values in the resulting matrix are the same Similarly the values of the columns should be the same 
You are given an array a 1 a 2 dots a n where all a i are integers and greater than 0 In one operation you can choose two different indices i and j 1 le i j le n If gcd a i a j is equal to the minimum element of the a you can swap a i and a j gcd x y denotes the greatest common divisor GCD of integers x and y Now you d like to make a non decreasing using the operation any number of times possibly zero Determine if you can do this An array a is non decreasing if and only if a 1 le a 2 le ldots le a n ,"['#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nint main() {\n\tios::sync_with_stdio(0); cin.tie(0);\n\n\tint t;\n\tcin >> t;\n\twhile(t--) {\n\t\tint n, mn=1e9;\n\t\tcin >> n;\n\t\tvi a(n);\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tcin >> a[i];\n\t\t\tmn=min(mn, a[i]);\n\t\t}\n\t\tvi b=a;\n\t\tsort(all(b));\n\t\tbool sorted=true;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tsorted = sorted && (a[i] % mn>0 ? a[i]==b[i] : true);\n\t\t}\n\t\tif(sorted) {\n\t\t\tcout << ""YES\\n"";\n\t\t} else {\n\t\t\tcout << ""NO\\n"";\n\t\t}\n\t}\n\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",1300,Let s define the minimum element of as We can find the position of the elements which is not divisible by cannot be changed because these elements don t have as factor But we can rearrange elements divisible by whatever we want in the following way Let s suppose and there is two elements in which are all different Swap swap and swap Then only and are swapped from the initial state Repeat this process So we can rearrange elements divisible by in non descending order After that if whole array is non descending the answer is otherwise Time complexity 
Airports often use moving walkways to help you walking big distances faster Each such walkway has some speed that effectively increases your speed You can stand on such a walkway and let it move you or you could also walk and then your effective speed is your walking speed plus walkway s speed Limak wants to get from point 0 to point L on a straight line There are n disjoint walkways in between The i th walkway is described by two integers x i and y i and a real value s i The i th walkway starts at x i ends at y i and has speed s i Every walkway is located inside the segment 0 L and no two walkways have positive intersection However they can touch by endpoints Limak needs to decide how to distribute his energy For example it might make more sense to stand somewhere or to walk slowly to then have a lot of energy to walk faster Limak s initial energy is 0 and it must never drop below that value At any moment he can walk with any speed v in the interval 0 2 and it will cost him v energy per second but he continuously recovers energy with speed of 1 energy per second So when he walks with speed v his energy increases by 1 v Note that negative value would mean losing energy In particular he can walk with speed 1 and this won t change his energy at all while walking with speed 0 77 effectively gives him 0 23 energy per second Limak can choose his speed arbitrarily any real value in interval 0 2 at every moment of time including the moments when he is located on non integer positions Everything is continuous non discrete What is the fastest time Limak can get from 0 to L ,"['#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\ntypedef long double db;\nconst int N=401000;\nint n,m,L;\ndb l[N],r[N],len[N],sp[N],f[N],cs[N],ct[N];\nint ord[N];\nstruct node {\n\tdb fg,s;\n}nd[4*N];\nvoid upd(int p) {\n\tnd[p].s=min(nd[p+p].s,nd[p+p+1].s);\n}\nvoid setf(int p,db v) {\n\tnd[p].fg+=v;\n\tnd[p].s-=v;\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tif (l==r) {\n\t\tnd[p].s=f[l];\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nvoid push(int p) {\n\tif (nd[p].fg>0) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\ndb query(int p,int l,int r,int tl,int tr) {\n\tif (tl==l&&tr==r) return nd[p].s;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) return query(p+p,l,md,tl,tr);\n\t\telse if (tl>md) return query(p+p+1,md+1,r,tl,tr);\n\t\telse return min(query(p+p,l,md,tl,md),query(p+p+1,md+1,r,md+1,tr));\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,db v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n\nint main() {\n\tscanf(""%d%d"",&n,&L);\n\tint px=0;\n\tauto add=[&](int x,int y,db s) {\n\t\tlen[m]=y-x;\n\t\tsp[m]=s;\n\t\t++m;\n\t};\n\trep(i,0,n) {\n\t\tint x,y;\n\t\tdouble s;\n\t\tscanf(""%d%d%lf"",&x,&y,&s);\n\t\tif (x>px) add(px,x,1);\n\t\tadd(x,y,s+1);\n\t\tpx=y;\n\t}\n\tif (px<L) add(px,L,1);\n\tdb ans=0,sr=0;\n\trep(i,0,m) {\n\t\tif (sp[i]==1) r[i]=len[i]; else r[i]=len[i]/(sp[i]-1)*sp[i];\n\t\tl[i]=len[i]/(sp[i]+1)*sp[i];\n\t\tct[i]=1/sp[i];\n\t\tcs[i]=r[i]-l[i];\n\t\tsr+=r[i]-len[i];\n\t\tf[i]=sr;\n\t\tans+=ct[i]*r[i];\n\t\tord[i]=i;\n\t\t//printf(""%d %.10Lf %.10Lf %.10Lf %.10Lf %.10Lf\\n"",i,l[i],r[i],ct[i],cs[i],f[i]);\n\t}\n\tbuild(1,0,m-1);\n\tsort(ord,ord+m,[&](int a,int b) {\n\t\treturn ct[a]>ct[b];\n\t});\n\trep(i,0,m) {\n\t\tint x=ord[i];\n\t\tdb val=min(query(1,0,m-1,x,m-1),cs[x]);\n\t\t//printf(""gg %d %.10Lf\\n"",x,val);\n\t\tr[x]-=val;\n\t\tans-=val*ct[x];\n\t\tmodify(1,0,m-1,x,m-1,val);\n\t}\n\t//rep(i,0,m) printf(""%.10Lf\\n"",r[i]);\n\tprintf(""%.10f\\n"",(double)ans);\n}\n']","[1, 1, 0, 0, 1]",3300,Some minor tips Everything is a walkway When there is no walkway it is a walkway of speed 0 You can increase all speeds by 1 and assume that you own speed is in 1 1 Energy is an entity which is speed time which is distance Also if you spend x energy per segment of len l and speed v it is not important how exactly you will distribute it over the walking process In any way you will walk by feet l x meters in time l x v So it turns out it s better to distribute more energy to low speeded walkways because the denominator is smaller Assume that you by default save up all energy on any non feet path for feet path it s always optimal to walk with speed 1 0 after speeds hack so now save up s Build an energy graphic where the Ox axis will correspond to the point you are in not time It will be a piecewise linear function so it is enough to store it s value only in points corresponding to points between walkways Iterate over walkways in the order of speed and try to steal as much energy as possible to the current walkway What are the limits of stealing energy there is a restriction based on l and v if you take too much energy you wouldn t be able to fully walk it up the graphic must still be able above 0 at all points The latter condition is just a suffix minima on a segment tree 
There are n blocks arranged in a row and numbered from left to right starting from one Each block is either black or white You may perform the following operation zero or more times choose two blocks and invert their colors white block becomes black and vice versa You want to find a sequence of operations such that they make all the blocks having the same color You to minimize the number of operations but it should not exceed 3 cdot n If it is impossible to find such a sequence of operations you need to report it ,"[""#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int N = 202;\n\nint n, a[N], cnt[2];\nstring s;\nvector<int> vec;\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcin >> n >> s;\n\tfor (int i = 0; i < n; i++)\n\t\tcnt[a[i] = (s[i] == 'W')]++;\n\tif (cnt[0] % 2 && cnt[1] % 2) {\n\t\tcout << -1;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n - 1; i++)\n\t\tif (a[i] != a[i - 1]) {\n\t\t\tvec.push_back(i);\n\t\t\ta[i] ^= 1;\n\t\t\ta[i + 1] ^= 1;\n\t\t}\n\tfor (int i = n - 2; i; i--)\n\t\tif (a[i] != a[i + 1]) {\n\t\t\tvec.push_back(i - 1);\n\t\t\ta[i] ^= 1;\n\t\t\ta[i - 1] ^= 1;\n\t\t}\n\n\tcout << vec.size() << '\\n';\n\tfor (int x: vec)\n\t\tcout << ++x << ' ';\n}\n""]","[1, 1, 0, 0, 0]",1300,Suppose we want to make all blocks white if we want to make them black the following algorithm still works with a few changes The first block has to be white so if it is black we have to invert the pair once otherwise we should not invert it at all inverting twice is the same as not inverting at all Then consider the second block We need to invert it once if it is black but if we invert the pair then the first block becomes black So we can t invert the pair and we have to invert the pair or don t invert anything if the second block is white now And so on for the th block we cannot invert the pair since it will affect the color of the previous block So we don t have much choice in our algorithm After that we arrive at the last block If it is white we are done with no more than actions If it is black run the same algorithm but we have to paint everything black now If it fails again then there is no answer 
Duff is mad at her friends That s why she sometimes makes Malek to take candy from one of her friends for no reason She has friends Her th friend s name is their names are not necessarily unique times she asks Malek to take candy from her friends She s angry but also she acts with rules When she wants to ask Malek to take candy from one of her friends like she chooses two numbers and and tells Malek to take exactly candies from him her where is the number of occurrences of string in Malek is not able to calculate how many candies to take in each request from Duff That s why she asked for your help Please tell him how many candies to take in each request ,"['#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <cctype>\n#include <cassert>\n#define rep(i, a, n) for(int i = a; i < n; ++ i)\n#define rev_rep(i, a, n) for(int i = (int) n - 1; i >= a; -- i)\n#define clr(a, h) memset(a, (h), sizeof(a))\n#define transfer(a, h) memcpy(a, (h), sizeof (a))\n#define foreach(e, x) for(__typeof(x.begin()) e = x.begin(); e != x.end(); ++ e)\n#define all(x) x.begin(), x.end()\n#define SZ(x) (int(x.size()))\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define de(x) cerr << #x << ""="" << x << endl\n#define two(x) (1 << (x))\n#define twoL(x) (1ll << (x))\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int ,int> PII;\ntypedef pair< int , PII> pii;\n\nconst int INF = ~0U>>1;\nconst int Mod = int(1e9) + 7;\n\ninline void addMod(int &x, int y) {\n\tx += y;\n\tif (x >= Mod) x -= Mod;\n}\n\ninline int powMod(int a, int x) {\n    int ret = 1;\n    for (; x; x >>= 1, a = 1ll * a * a % Mod)\n        if (x & 1) ret = 1ll * ret * a % Mod;\n    return ret; \n}\n\nconst int N=201000;\n\nint tot,rk[N*4],sa[N];\npair<PII,int> pos[N];\nchar s[N];\nint p[N];\nvoid init() {\n\tfor (int i=1;i<=tot;i++) rk[i]=p[i];\n\tfor (int j=0;j<19;j++) {\n\t\tfor (int i=1;i<=tot;i++)\n\t\t\tpos[i]=mp(mp(rk[i],rk[i+two(j)]),i);\n\t\tsort(pos+1,pos+tot+1);\n\t\tint cnt=0;\n\t\tfor (int i=1;i<=tot;i++) {\n\t\t\trk[pos[i].se]=cnt;\n\t\t\tcnt+=(pos[i].fi!=pos[i+1].fi);\n\t\t}\n\t\tif (cnt==tot) break;\n\t}\n\tfor (int i=1;i<=tot;i++) rk[i]++;\n\tfor (int i=1;i<=tot;i++) sa[rk[i]]=i;\n}\nint query(int l,int r,int c,int len) {\n\t++r; --l;\n\twhile (l+1<r) {\n\t\tint md=(l+r)>>1;\n\t\tif (p[sa[md]+len-1]>=c) r=md; else l=md;\n\t}\n\treturn r;\n}\n\nint n,q,l[N],r[N],c[N],ocr[N],sl[N],sr[N];\nint bigv[N],bigid[N],bigcnt;\nll ret[N],ans[N];\nvector<PII> ql[N],qr[N];\nvector<pair<PII,int> > Qr[N];\n\nvoid modify(int x,int s) { for (;x<=tot;x+=x&-x) c[x]+=s;}\nint query(int x) { int s=0; for (;x;x-=x&-x) s+=c[x]; return s;}\n\nconst int R=200;\nint main() {\n//\tfreopen(""in"",""r"",stdin);\n\tscanf(""%d%d"",&n,&q);\n\trep(i,1,n+1) {\n\t\tscanf(""%s"",s);\n\t\tint len=strlen(s);\n\t\tl[i]=tot+1;\n\t\trep(j,0,len)\n\t\t\tp[++tot]=s[j]-\'a\'+1;\n\t\tp[++tot]=29+i;\n\t\tr[i]=tot;\n\t\tif (len>R) {\n\t\t\tbigid[i]=++bigcnt;\n\t\t\tbigv[bigcnt]=i;\n\t\t}\n\t}\n\tinit();\n\trep(i,1,n+1) {\n\t\tint pl=1,pr=tot;\n\t\trep(j,l[i],r[i]) {\n\t\t\tint ql=query(pl,pr,p[j],j-l[i]+1);\n\t\t\tint qr=query(pl,pr,p[j]+1,j-l[i]+1)-1;\n\t\t\tpl=ql;\n\t\t\tpr=qr;\n\t\t}\n\t\tsl[i]=pl,sr[i]=pr;\n\t}\n\n\trep(i,1,q+1) {\n\t\tint l,r,k;\n\t\tscanf(""%d%d%d"",&l,&r,&k);\n\t\tif (bigid[k]) {\n\t\t\tQr[k].pb(mp(mp(l,r),i));\n\t\t} else {\n\t\t\tqr[r].pb(mp(k,i));\n\t\t\tqr[l-1].pb(mp(k,-i));\n\t\t}\n\t}\n\trep(i,1,bigcnt+1) {\n\t\tint v=bigv[i];\n\t\tfor (int j=1;j<=tot;j++) ocr[j]=0;\n\t\tfor (int j=l[v];j<r[v];j++) {\n\t\t\tocr[rk[j]]++;\n\t\t}\n\t\tfor (int j=1;j<=tot;j++) ocr[j]+=ocr[j-1];\n\t\tfor (int j=1;j<=n;j++) {\n\t\t\tret[j]=ret[j-1]+ocr[sr[j]]-ocr[sl[j]-1];\n\t\t}\n\t\tfor (auto que:Qr[v]) {\n\t\t\tint l=que.fi.fi,r=que.fi.se,id=que.se;\n\t\t\tans[id]=ret[r]-ret[l-1];\n\t\t}\n\t}\n\trep(i,1,n+1) {\n\t\tmodify(sl[i],1);\n\t\tmodify(sr[i]+1,-1);\n\t\tfor (auto p:qr[i]) {\n\t\t\tint id=p.se,w=1,v=p.fi;\n\t\t\tif (id<0) w=-1,id*=-1;\n\t\t\trep(j,l[v],r[v]) {\n\t\t\t\tans[id]+=w*query(rk[j]);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,q+1) printf(""%lld\\n"",ans[i]);\n}']","[0, 0, 0, 0, 1]",3000,Use Aho Corasick Assume first of all we build the trie of our strings function t If t v c 1 it means that there is an edge in the trie outgoing from vertex v written c on it So for building Aho Corasick consider f v the vertex we go into in case of failure t v c 1 i e the deepest vertex u that v u and the path from root to u is a suffix of path from root to v No we can build an automaton Aho Corasick function g For each i do this in the automaton cur root for c in s i cur g cur c And then push i in q cur q is a vector also we do this for cur root end cur push i end is also a vector consisting of the indices of strings ending in vertex cur state cur in automaton last i cur last i is the final state we get to from searching string s i in automaton g Assume cnt v i is the number of occurrences of number i in q v Also denote Build another tree In this tree for each i that is not root of the trie let par i f i the vertex we go in the trie in case of failure and call it C Tree So now problem is on a tree Operations are Each query gives numbers l r k and you have to find the number 
Dima and Inna are doing so great At the moment Inna is sitting on the magic lawn playing with a pink pony Dima wanted to play too He brought an chessboard a very tasty candy and two numbers and Dima put the chessboard in front of Inna and placed the candy in position on the board The boy said he would give the candy if it reaches one of the corner cells of the board He s got one more condition There can only be actions of the following types move the candy from position on the board to position move the candy from position on the board to position move the candy from position on the board to position move the candy from position on the board to position Naturally Dima doesn t allow to move the candy beyond the chessboard borders Inna and the pony started shifting the candy around the board They wonder what is the minimum number of allowed actions that they need to perform to move the candy from the initial position to one of the chessboard corners Help them cope with the task ,"['#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nint n, m, x, y, a, b , ans;\n\nint dist(int xx, int yy) {\n    if (xx % a != x % a || yy % b != y % b) return 1000000000;\n    int res = abs(xx - x) / a + abs(yy - y) / b;\n    return res % 2 ? 1000000000 : max(abs(xx - x) / a, abs(yy - y) / b);\n}\n\n\nint main() {\n    cin >> n >> m >> x >> y >> a >> b;\n\n    if (x == 1 && y == 1 || x == 1 && y == m || x == n && y == 1 || x == n && y == m) {\n        cout << ""0\\n"";\n        return 0;\n    }\n\n    if (x + a > n && x - a < 1 || y + b > m && y - b < 1) {\n        cout << ""Poor Inna and pony!\\n"";\n        return 0;\n    }\n    int ans = min(min(dist(1, 1), dist(1, m)), min(dist(n, 1), dist(n, m)));\n    if (ans == 1000000000) cout << ""Poor Inna and pony!\\n"";\n    else cout << ans << ""\\n"";\n\n    return 0;\n}\n']","[1, 0, 1, 0, 0]",2000,Lets find a solution for shifting a candy from the position into position On each step we shift increase or decrease by and by It is not difficult to understand that if is not divisible by and is divisible by answer doesn t exist We should also note that and Should be both even or odd as shifting is performed at a time for both values We should also look up for a corner case when step dropes us out from the board Now we can determine the way from to as Lets calculate it for all corners and choose minimum or determine that the answer doesn t exist 
Once upon a time Mike and Mike decided to come up with an outstanding problem for some stage of ROI rare olympiad in informatics One of them came up with a problem prototype but another stole the idea and proposed that problem for another stage of the same olympiad Since then the first Mike has been waiting for an opportunity to propose the original idea for some other contest Mike waited until this moment You are given an array a of n integers You are also given q queries of two types Replace i th element in the array with integer x Replace each element in the array with integer x After performing each query you have to calculate the sum of all elements in the array ,"['#include<algorithm>\n#include<iostream>\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\nconst int maxn=500005;\nint n,m,T,stp;\nint a[maxn],vis[maxn];\nlong long ans;\nint main(){\n\tscanf(""%d%d"",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(""%d"",&a[i]),ans+=a[i];\n\tint lst=0;\n\twhile(m--){\n\t\tint t,x,y;\n\t\tscanf(""%d%d"",&t,&x);\n\t\tif(t==1){\n\t\t\tscanf(""%d"",&y);\n\t\t\tif(vis[x]!=stp)\n\t\t\t\tans+=y-lst;\n\t\t\telse ans+=y-a[x];\n\t\t\tvis[x]=stp,a[x]=y;\n\t\t}\n\t\tif(t==2)\n\t\t\tstp++,ans=1ll*x*n,lst=x;\n\t\tprintf(""%lld\\n"",ans);\n\t}\n\treturn 0;\n}\n']","[0, 0, 1, 0, 1]",1200,As we want to perform queries fast we will store some variables current sum of all elements in the array index of the last query of the second type and its value For each element of the array we will also store index of the last query of the first type that changed this element and its value Now let s answer the queries If we are going to perform a query of the first type we have to know what the number equals now If then now and otherwise Now let s subtract from the sum change and and add the new value to the sum If we are going to perform a query of the second type we have to update values and The new sum of all elements of the array is Time complexity 
 You are given a positive integer number n You really love so you want to find the smallest greater than or equal to n The positive integer is called if it can be represented as a sum of powers of 3 i e no duplicates of powers of 3 are allowed For example 30 is a 30 3 3 3 1 1 is a 1 3 0 12 is a 12 3 2 3 1 but 2 is a you can t represent it as a sum of distinct powers of 3 2 3 0 3 0 19 is a you can t represent it as a sum of distinct powers of 3 for example the representations 19 3 2 3 2 3 0 3 2 3 1 3 1 3 1 3 0 are invalid 20 is also a you can t represent it as a sum of distinct powers of 3 for example the representation 20 3 2 3 2 3 0 3 0 is invalid Note that there exist other representations of 19 and 20 as sums of powers of 3 but none of them consists of powers of 3 For the given positive integer n find such smallest m n le m that m is a You have to answer q independent queries ,"['#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ninline int read(){\n\tregister int res=0, c;\n\twhile(c=getchar(), c<\'0\'||c>\'9\');\n\tdo{\n\t\tres=(res*10)+(c^48);\n\t} while(c=getchar(), c>=\'0\'&&c<=\'9\');\n\treturn res;\n}\nint s[51];\nvoid to3(long long x){\n\tlong long t=0;\n\twhile(x){\n\t\ts[t++]=x%3;\n\t\tx/=3;\n\t}\n}\nlong long tox(){\n\tlong long t=1, ans=0;\n\tfor(int i=0;; i++){\n\t\tans+=t*s[i];\n\t\tif(3.0l*t>2e18)break;\n\t\tt*=3;\n\t}\n\treturn ans;\n}\nint main() {\n\tint T=read();\n\twhile(T--){\n\t\tmemset(s, 0, sizeof s);\n\t\tlong long N;\n\t\tscanf(""%lld"", &N);\n\t\tto3(N);\n\t\tfor(int i=50; i>=0; i--){\n\t\t\tif(s[i]==2){\n\t\t\t\tfor(int j=i+1;; j++){\n\t\t\t\t\tif(s[j]==0){\n\t\t\t\t\t\ts[j]=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ts[j]=0;\n\t\t\t\t}\n\t\t\t\ts[i]=0;\n\t\t\t\tfor(int j=i-1; j>=0; j--)s[j]=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<tox()<<endl;\n\t}\n\treturn 0;\n}\n']","[1, 0, 1, 0, 0]",1300,As you can see from the example the maximum answer doesn t exceed So we can run some precalculation before all queries which will find all less than The number is if it has no in the ternary numeral system When you read the next query you can increase until you find some precalculated Time complexity is You also can implement the solution which doesn t use any precalculations and just increase each time in each query and checks if the number is inside this loop Then time complexity will be 
Little Timofey likes integers a lot Unfortunately he is very young and can t work with very big integers so he does all the operations modulo his favorite prime Also Timofey likes to look for arithmetical progressions everywhere One of his birthday presents was a sequence of integers Timofey wants to know whether he can rearrange the elements of the sequence so that is will be an arithmetical progression modulo or not Arithmetical progression modulo of length with first element and difference is sequence of integers each taken modulo ,"['// saratov 2013-2014 I Wuhongxun\'s code\n\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--) \n#define Rep(i,a) for(int i = 0; i < a; i++)\n#define pb(a) push_back(a)\n#define mp(a,b) make_pair(a,b)\n#define ab(x) ((x) < 0 ? -(x) : (x))\nusing namespace std;\ntypedef long long LL;\ntypedef map<int, int>::iterator mit;\ntypedef set<int>::iterator sit;\nconst int N = 1000010;\nint a[N], b[N], G, md, c[N], cl; int m, tot = 0;\nbool vis[N];\n#define nxt(x) (x == n ? 1 : x + 1)\n#define pre(x) (x == 1 ? n : x - 1)\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nvoid work(int n) {\n\ttot++; if (tot > 60) { printf(""-1\\n""); return; }\n\tif (m == n) {\n\t\tprintf(""%d %d\\n"",md,G >= G * m ? 1 : G);\n\t} else if (m - 1 == n) {\n\t\trep(i,1,n) if (a[i] != i - 1) { printf(""%d %d\\n"",a[i] * G + md,G); return; }\n\t} else if (n <= 1000) {\n\t\tif (n == 1) { printf(""%d %d\\n"", a[1], 1); return; }\n\t\trep(i,2,n) {\n\t\t\tint d = a[i] - a[1]; if (gcd(d, m) != 1) continue;\n\t\t\tint cnt = 0, j = 1; bool haveans = true;\n\t\t\trep(k,1,n) {\n\t\t\t\tint x = (a[k] + d) % m, t = j; j = nxt(j);\n\t\t\t\twhile (j != t && a[j] != x) j = nxt(j);\n\t\t\t\tif (j == t) { cnt++; if (cnt == 2) { haveans = false; break; }}\n\t\t\t}\n\t\t\tif (haveans) {\n\t\t\t\tint j = n;  n = cl; d *= G, m *= G;\n\t\t\t\tdep(k,n,1) {\n\t\t\t\t\tint x = (c[k] - d + m) % m, t = j; j = pre(j);\n\t\t\t\t\twhile (j != t && c[j] != x) j = pre(j);\n\t\t\t\t\tif (j == t) { printf(""%d %d\\n"",c[k],d); return; }\n\t\t\t\t}\n\t\t\t\tprintf(""%d %d\\n"",c[1],d); return;\n\t\t\t}\n\t\t}\n\t\tprintf(""-1\\n"");\n\t} else {\n\t\tbool flag = true;\n\t\twhile (flag) {\n\t\t\trep(i,1,n) vis[i] = false;\n\t\t\tint x = rand() % n + 1; vis[x] = true; int j = pre(x), k = nxt(x);\n\t\t\tfor(;j != k; j = pre(j)) {\n\t\t\t\twhile (k != j && (a[k] + m - a[x]) % m < (a[x] + m - a[j]) % m) k = nxt(k);\n\t\t\t\tif ((a[j] + a[k]) % m == 2 * a[x] % m) vis[j] = vis[k] = true;\n\t\t\t\tif (k == j) break;\n\t\t\t} \n\t\t\tint l = 0; rep(i,1,n) if (!vis[i]) b[++l] = a[i];\n\t\t\tflag = l < 2; if (!flag) { n = l; rep(i,1,n) a[i] = b[i]; } \n\t\t}\n\t\twork(n);\n\t}\n}\n\nvoid init(int n) {\n\tint g = gcd(m, a[1] + m - a[n]); rep(i,1,n - 1) g = gcd(g, a[i + 1] - a[i]);\n\tG = g, md = a[1] % g;\n\tm /= g; rep(i,1,n) a[i] /= g;\n}\n\nint main() {\n\tsrand(233); int n; scanf(""%d%d"",&m,&n); cl = n;\n\trep(i,1,n) scanf(""%d"",&a[i]);\n\tsort(a+1,a+n+1);\n\trep(i,1,n) c[i] = a[i];\n\tinit(n); work(n);\n\treturn 0;\n}']","[0, 1, 1, 0, 0]",2600,First let s think about the case when In this editorial we say that an outcoming sequence is Assume is the difference of some two elements and of Let s say that was on th place in the sequence and was on th place Then On the other hand we have that is less then so must be difference of exactly pairs of elements of We can count this value in time using binary search or in time using a hashtable Then we know the value of After that we calculate the value is prime so we can use Fermat s little theorem and then we know the difference of the sequence Then we just take any element of and look on values and also on If we can get all of the numbers in in this way then we know the first element of the sequence Otherwise the answer is NO If we just solve the problem for the complement of in and then add to the first element value If we had a correct sequence in then we must have a correct sequence in its complement with the same difference as long as is coprime with the difference the complement is just set of numbers Author s solution http pastebin com jTdcUpFM 
Kuro has just learned about permutations and he is really excited to create a new permutation type He has chosen n distinct positive integers and put all of them in a set S Now he defines a magical permutation to be A permutation of integers from 0 to 2 x 1 where x is a non negative integer The bitwise xor of any two consecutive elements in the permutation is an element in S Since Kuro is really excited about magical permutations he wants to create the longest magical permutation possible In other words he wants to find the largest non negative integer x such that there is a magical permutation of integers from 0 to 2 x 1 Since he is a newbie in the subject he wants you to help him find this value of x and also the magical permutation for that x ,"['#include <cstdio>\n\nint buk[1 << 18 | 7], A[1 << 18 | 7];\nint B[18], D[18], C;\n\ninline void Ins(int x) {\n\tint y = x;\n\tfor (int i = 17; ~i; --i) if (x >> i & 1) {\n\t\tif (!B[i]) { B[i] = x, D[i] = y, ++C; break; }\n\t\tx ^= B[i];\n\t}\n}\n\nvoid Solve(int *A, int j) {\n\tif (!j) return ;\n\t--j;\n\tA[1 << j] = D[j];\n\tSolve(A, j);\n\tSolve(A + (1 << j), j);\n}\n\nint main() {\n\tint N; scanf(""%d"", &N);\n\twhile (N--) {\n\t\tint x; scanf(""%d"", &x);\n\t\tbuk[x] = 1;\n\t}\n\tfor (int i = 18; i >= 1; --i) {\n\t\tfor (int j = 0; j < i; ++j) B[j] = 0;\n\t\tC = 0;\n\t\tfor (int k = 0; k < 1 << i; ++k) if (buk[k]) Ins(k);\n\t\tif (C == i) {\n\t\t\tprintf(""%d\\n"", i);\n\t\t\tSolve(A, i);\n\t\t\tint x = 0;\n\t\t\tfor (int k = 0; k < 1 << i; ++k) printf(""%d "", x ^= A[k]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(""0\\n0 "");\n\treturn 0;\n}']","[0, 1, 0, 0, 1]",2400,The idea here is iterate and check if it is possible to create a magical permutation for the current we are iterating through An observation to be made is that if it is possible to create a magical permutation from to then it must be possible to express each integer from to as the xor value of elements in one subset of This is because is represented as the xor value of the empty subset of Because of that every element to the left of in is also the xor value of one subset of and so is every element to the right of in Because of that we first check that if we can create every integer from to using only the xor values of every subset of This is possible by creating a basis for integers from to integers such that each integer from to is the xor value of a subset of these integers from using Gaussian elimination Now if it is possible to create such a basis for integers from to using only elements of is it possible to create a magic permutation then Recall that each integer from to corresponds to the xor value of a subset of the basis or in other words corresponds to a bitmask of the basis We can also narrow down the original condition such that the xor value of any two consecutive elements belongs to the basis or in other words the corresponding bitmask of any two consecutive elements in the magical permutation differs by exactly 1 bit The problem now becomes creating a permutation of integers from to such that any two consecutive elements in this permutation differs by 1 bit and then convert this permutation to a magical permutation using the created basis It turns out that we can always do this using Gray codes although DFS works just as well It also turns out that the basis for integers from to does not exceed we can sort and create the basis along with checking the aforementioned condition Complexity if Gray codes are used or is DFS is used instead where denotes the maximum value of elements in 
Sereja owns a restaurant for people The restaurant hall has a coat rack with hooks Each restaurant visitor can use a hook to hang his clothes on it Using the th hook costs rubles Only one person can hang clothes on one hook Tonight Sereja expects guests in the restaurant Naturally each guest wants to hang his clothes on an available hook with minimum price if there are multiple such hooks he chooses any of them However if the moment a guest arrives the rack has no available hooks Sereja must pay a ruble fine to the guest Help Sereja find out the profit in rubles possibly negative that he will get tonight You can assume that before the guests arrive all hooks on the rack are available all guests come at different time nobody besides the guests is visiting Sereja s restaurant tonight ,"['/*\n * Package: StandardCodeLibrary.Core\n * */\n//std;\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <vector>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\nusing namespace std;\n\n//;\n#define lp for(;;)\n#define repf(i,a,b) for (int i=(a);i<(b);++i)\n#define ft(i,a,b) for (int i=(a);i<=(b);++i)\n#define fdt(i,a,b) for (int i=(a);i>=(b);--i)\n#define rrepf(i,a,b) fdt(i,(a)-1,b)\n#define rep(i,n) repf(i,0,n)\n#define rrep(i,n) rrepf(i,n,0)\n#define for_nonempty_subsets(subset,set) for (int subset=set;subset;subset=(subset-1)&(set))\n#define for_in_charset(i,charset) for (cstr i=(charset);*i;i++)\n#define whl while\n#define rtn return\n#define fl(x,y) memset((x),char(y),sizeof(x))\n#define clr(x) fl(x,char(0))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\n#define sf scanf\n#define pf printf\n#define vec vector\n#define pr pair\n#define que queue\n#define prq priority_queue\n#define itr iterator\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\n#define ins insert\n#define ers erase\n#define lb lower_bound\n#define ub upper_bound\n#define rnk order_of_key\n#define sel find_by_order\n#define sz(x) (int((x).size()))\n#define all(x) (x).begin(),(x).end()\n#define srt(x) sort(all(x))\n#define uniq(x) srt(x),(x).erase(unique(all(x)),(x).end())\n#define rev(x) reverse(all(x))\n#define shf(x) random_shuffle(all(x))\n#define nxtp(x) next_permutation(all(x))\n\n//;\n#ifndef DEBUG\n#define prt(x) (cerr)\n#define asrtWA(s) do if(!(s))exit(0);whl(0)\n#define asrtTLE(s) do if(!(s))whl(1);whl(0)\n#define asrtMLE(s) do if(!(s))whl(new int);whl(0)\n#define asrtOLE(s) do if(!(s))whl(1)puts(""OLE"");whl(0)\n#define asrtRE(s) do if(!(s))*(int*)0=0;whl(0)\n#define runtime() (cerr)\n#define input(in) freopen(in,""r"",stdin)\n#define output(out) freopen(out,""w"",stdout)\n#else\n#define prt(x) cerr<<""""<<__LINE__<<""\\t: ""<<#x""\\t=""<<(x)<<endl\n#define asrtWA(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtTLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtMLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtOLE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define asrtRE(s) do if(!(s))cerr<<""assert(""#s"")""<<endl;whl(0)\n#define runtime() cerr<<""Used: ""<<db(clock())/CLOCKS_PER_SEC<<""s""<<endl\n#define input(in)\n#define output(out)\n#endif\n\n//;\ntypedef long long int lli;\ntypedef double db;\ntypedef const char* cstr;\ntypedef string str;\ntypedef vec<int> vi;\ntypedef vec<vi> vvi;\ntypedef vec<lli> vl;\ntypedef vec<vl> vvl;\ntypedef vec<bool> vb;\ntypedef vec<vb> vvb;\ntypedef vec<char> vc;\ntypedef vec<vc> vvc;\ntypedef vec<str> vs;\ntypedef pr<int,int> pii;\ntypedef pr<lli,lli> pll;\ntypedef pr<db,db> pdd;\ntypedef vec<pii> vpii;\ntypedef vec<pll> vpll;\ntypedef vec<pdd> vpdd;\ntypedef map<int,int> mii;\ntypedef map<str,int> msi;\ntypedef map<char,int> mci;\ntypedef set<int> si;\ntypedef set<str> ss;\ntypedef que<int> qi;\n\n//:int;lli;db;;;;;\nint oo=(~0u)>>1;\nlli ooll=(~0ull)>>1;\ndb inf=1e+10;\ndb eps=1e-10;\ndb gam=0.5772156649015328606;\ndb pi=acos(-1.0);\nint dx[]={1,0,-1,0,1,-1,-1,1,0};\nint dy[]={0,1,0,-1,1,1,-1,-1,0};\nint MOD=1000000007;\n\n//:;;;;;;\ntemplate<typename type>inline bool cmax(type& a,const type& b){rtn a<b?a=b,true:false;}\ntemplate<typename type>inline bool cmin(type& a,const type& b){rtn b<a?a=b,true:false;}\ntemplate<typename type>inline type sqr(const type& x){rtn x*x;}\ntemplate<typename type>inline type mod(const type& x){rtn x%MOD;}\ninline int sgn(const db& x){rtn (x>+eps)-(x<-eps);}\ninline int dbcmp(const db& a,const db& b){rtn sgn(a-b);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& x){rtn mp(-x.x,-x.y);}\ntemplate<typename type>inline pr<type,type> operator+(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x+b.x,a.y+b.y);}\ntemplate<typename type>inline pr<type,type> operator-(const pr<type,type>& a,const pr<type,type>& b){rtn mp(a.x-b.x,a.y-b.y);}\ntemplate<typename type>inline pr<type,type> operator*(const pr<type,type>& a,const type& b){rtn mp(a.x*b,a.y*b);}\ntemplate<typename type>inline pr<type,type> operator/(const pr<type,type>& a,const type& b){rtn mp(a.x/b,a.y/b);}\ntemplate<typename type>inline pr<type,type>& operator-=(pr<type,type>& a,const pr<type,type>& b){rtn a=a-b;}\ntemplate<typename type>inline pr<type,type>& operator+=(pr<type,type>& a,const pr<type,type>& b){rtn a=a+b;}\ntemplate<typename type>inline pr<type,type>& operator*=(pr<type,type>& a,const type& b){rtn a=a*b;}\ntemplate<typename type>inline pr<type,type>& operator/=(pr<type,type>& a,const type& b){rtn a=a/b;}\ntemplate<typename type>inline type cross(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.y-a.y*b.x;}\ntemplate<typename type>inline type dot(const pr<type,type>& a,const pr<type,type>& b){rtn a.x*b.x+a.y*b.y;}\ntemplate<typename type>inline type gcd(type a,type b){if(b)whl((a%=b)&&(b%=a));rtn a+b;}\ntemplate<typename type>inline type lcm(type a,type b){rtn a*b/gcd(a,b);}\ninline lli bin_pow(lli x,lli y){lli z=1;whl(y){if(y&1)z=mod(z*x);x=mod(sqr(x)),y>>=1;}rtn z;}\ntemplate<typename istream,typename first_type,typename second_type>inline istream& operator>>(istream& cin,pr<first_type,second_type>& x){rtn cin>>x.x>>x.y;}\ntemplate<typename ostream,typename first_type,typename second_type>inline ostream& operator<<(ostream& cout,const pr<first_type,second_type>& x){rtn cout<<x.x<<"" ""<<x.y;}\ntemplate<typename istream,typename type>inline istream& operator>>(istream& cin,vec<type>& x){rep(i,sz(x))cin>>x[i];rtn cin;}\ntemplate<typename ostream,typename type>inline ostream& operator<<(ostream& cout,const vec<type>& x){rep(i,sz(x))cout<<x[i]<<(i+1==sz(x)?"""":"" "");rtn cout;}\ninline ostream& pdb(int prcs,db x){rtn cout<<setprecision(prcs)<<fixed<<(sgn(x)?(x):0);}\ntemplate<typename type>inline void bit_inc(vec<type>& st,int x,type inc){whl(x<sz(st))st[x]+=inc,x|=x+1;}\ntemplate<typename type>inline type bit_sum(const vec<type>& st,int x){type s=0;whl(x>=0)s+=st[x],x=(x&(x+1))-1;rtn s;}\ntemplate<typename type>inline type bit_kth(const vec<type>& st,int k){int x=0,y=0,z=0;whl((1<<(++y))<=sz(st));rrep(i,y){if((x+=1<<i)>sz(st)||z+st[x-1]>k)x-=1<<i;else z+=st[x-1];}rtn x;}\ninline void make_set(vi& st){rep(i,sz(st))st[i]=i;}\ninline int find_set(vi& st,int x){int y=x,z;whl(y!=st[y])y=st[y];whl(x!=st[x])z=st[x],st[x]=y,x=z;rtn y;}\ninline bool union_set(vi& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?st[a]=b,true:false;}\ninline void make_set(vpii& st){rep(i,sz(st))st[i]=mp(i,1);}\ninline int find_set(vpii& st,int x){int y=x,z;whl(y!=st[y].x)y=st[y].x;whl(x!=st[x].x)z=st[x].x,st[x].x=y,x=z;rtn y;}\ninline bool union_set(vpii& st,int a,int b){a=find_set(st,a),b=find_set(st,b);rtn a!=b?(st[a].y>st[b].y?st[a].x=b,st[a].y+=st[b].y:st[b].x=a,st[b].y+=st[a].y),true:false;}\ntemplate<typename type>inline void merge(type& a,type& b){if(sz(a)<sz(b))swap(a,b);whl(sz(b))a.ins(*b.begin()),b.ers(b.begin());}\n\n//;\nstruct Initializer{\n#ifndef DEBUG\nInitializer(){ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);}\n#else\n~Initializer(){runtime();}\n#endif\n}initializer;\n\n//;\n#define for_each(e,s) for (__typeof__((s).begin()) e=(s).begin();e!=(s).end();++e)\n#include <ext/rope>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\ntypedef __gnu_cxx::rope<char> rope;\ntemplate<typename key,typename value>class ext_map:public __gnu_pbds::tree<key,value,less<key>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>{};\n#define ctz __builtin_ctz\n#define clz __builtin_clz\n#define bc __builtin_popcount\n\nint main()\n{\n\tlli n,d;\n\tcin>>n>>d;\n\tvl a(n);\n\tcin>>a;\n\tsrt(a);\n\tlli m;\n\tcin>>m;\n\tlli ans=0;\n\trep(i,min(n,m)) ans+=a[i];\n\tans-=max(0ll,m-n)*d;\n\tcout<<ans<<endl;\n}\n']","[0, 0, 1, 0, 0]",1000,Each time we will go through the array and look for the minimal element which is not yet marked If we find an item we add it to the answer and mark it otherwise we will subtract the penlty from answer 
There are n heroes in a videogame Each hero has some health value h and initial armor value a Let the current value of armor be a mathit cur initially equal to a When x points of damage are inflicted on a hero the following happens if x a mathit cur then x gets subtracted from a mathit cur otherwise 1 gets subtracted from h and a mathit cur gets assigned back to a In the start of the game you choose the value x an integer strictly greater than 0 arbitrarily large Then you keep attacking all heroes in rounds in one round you inflict x points of damage to all alive heroes A hero dies when his health becomes 0 The game ends when all heroes are dead The last hero to die earns the number of points equal to the number of rounds he was the only hero alive The other heroes get 0 points In particular if the last round ends with multiple heroes dying then every hero gets 0 points The game is played for every possible x from 1 to infinity The points are reset between the games What s the maximum number of points each hero has had ,"['#include ""bits/stdc++.h""\n#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << \'\\\'\' << x << \'\\\'\';}\nvoid __print(const char *x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(const string &x) {cerr << \'\\""\' << x << \'\\""\';}\nvoid __print(bool x) {cerr << (x ? ""true"" : ""false"");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << \'{\'; __print(x.first); cerr << "", ""; __print(x.second); cerr << \'}\';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << \'{\'; for (auto &i: x) cerr << (f++ ? "", "" : """"), __print(i); cerr << ""}"";}\nvoid _print() {cerr << ""]\\n"";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << "", ""; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << ""\\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cerr << ""\\e[39m"" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = \'\\n\';\nconst int MX = 200011; \n\nvoid solve() {\n\n    ll H[MX][2], val[MX]; \n    int pos[MX];\n    F0R(i, MX) {\n        F0R(j, 2) {\n            H[i][j] = 0;\n        }\n        val[i] = 0; pos[i] = -1;\n    }\n    int N; cin >> N;\n    ll ans[N]; F0R(i, N) ans[i] = 0;\n    int inH[N], inA[N];\n    F0R(i, N) cin >> inH[i];\n    F0R(i, N) cin >> inA[i];\n    ll cb = 0, csb = 0;\n    int pb = 0;\n    F0R(i, N) {\n        if (inH[i] > H[inA[i]][0]) {\n            H[inA[i]][1] = H[inA[i]][0];\n            H[inA[i]][0] = inH[i];\n            pos[inA[i]] = i;\n            val[inA[i]] = inH[i];\n        } else if (inH[i] > H[inA[i]][1]) {\n            H[inA[i]][1] = inH[i];\n        }\n        pb = inH[i];\n    }\n    FOR(i, 1, MX) {\n        if (val[i] > cb) {\n            csb = cb;\n            cb = val[i];\n            pb = i;\n        } else if (val[i] > csb) {\n            csb = val[i];\n        }\n    }\n    ckmax(ans[pos[pb]], cb - max(csb, H[pb][1]));\n    FORd(i, 1, MX) {\n        int lo = 1;\n        for (int j = 0; j * i < MX; j++) {\n            for (int k = max(j * i + 1, lo); k <= j * (i+1) && k < MX; k++) {\n                ckmax(lo, k);\n                val[k] = ((k + i - 1) / i) * H[k][0];\n                if (val[k] > cb) {\n                    if (pb != k) csb = cb;\n                    cb = val[k];\n                    pb = k;\n                } else if (val[k] > csb && pb != k) {\n                    csb = val[k];\n                }\n            }\n        }\n        ckmax(ans[pos[pb]], cb - max(csb, ((pb + i - 1) / i) * H[pb][1]));\n            //dbg(i, pb, pos[pb], val[pb], cb, csb);\n        \n    }\n\n    F0R(i, N) {\n        cout << ans[i] << "" "";\n    }\n    cout << nl;\n\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n']","[0, 0, 0, 0, 1]",2800,For each we can easily tell how many rounds each hero will last That is equal to The last hero to die is the one with the maximum of this value And the number of rounds he will be the only hero alive is determined by the second maximum Also notice that all that are greater or equal to the maximum of behave the same In one round all heroes just lose one point of health Thus it only makes sense to calculate the answer for all from to The problem currently is the following for each from to find the index and the value of the maximum and the value of the second maximum of Let s group all heroes by the value of The values of for the heroes in the group form a segment from to From each group we only care about the maximum and the second maximum over Thus if we can extract the maximum and the second maximum in the solution will be because of the harmonic series iterating over then over First for each find the maximum and the second maximum of To query the maximum on a segment we can use a sparse table Apparently we can modify it to query the second maximum as well Store a tuple of value of maximum index of maximum value of the second maximum To merge two segments we compare if the indices of the maximums are the same They can possibly be the same because we often query intersecting segments in the sparse table If they are the second maximum is the largest of the respective second maximums If they aren t let the first node has a large or equal value of maximum Then the second maximum is the larger of the second maximum of the first node and the maximum of the second node Overall complexity time and memory per testcase 
Vasiliy has a car and he wants to get from home to the post office The distance which he needs to pass equals to kilometers Vasiliy s car is not new it breaks after driven every kilometers and Vasiliy needs seconds to repair it After repairing his car Vasiliy can drive again but after kilometers it will break again and so on In the beginning of the trip the car is just from repair station To drive one kilometer on car Vasiliy spends seconds to walk one kilometer on foot he needs seconds Your task is to find minimal time after which Vasiliy will be able to reach the post office Consider that in every moment of time Vasiliy can left his car and start to go on foot ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll D,K,A,B,T;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>D>>K>>A>>B>>T;\n\tif(A*K+T>=B*K) {\n\t\tcout<<min(D,K)*A + max(0LL,D-K)*B << endl;\n\t}\n\telse {\n\t\tll mi=1LL<<60;\n\t\tfor(x=0;x<=min(D,K);x++) {\n\t\t\tll mv=D-x;\n\t\t\tll fix=max(0LL,(mv+K-1)/K-1);\n\t\t\tmi=min(mi,x*B + A*(D-x) + fix*T);\n\t\t}\n\t\tcout<<mi<<endl;\n\t}\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n""]","[0, 1, 0, 0, 0]",1900,To solve this problem we need to analyze some cases If then Vasiliy can ride car all road without breaking so the answer is If i e it is better to do not repair the car Vasiliy must ride car the first kilometers and then walks on foot so the answer is The only case left when it is better to ride car through all road until kilometers left Now we need to understand what better repair the car and ride or do not repair the car and walk on foot Let so Vasiliy necessarily must repair the car times Then the answer equals to 
Karel is a salesman in a car dealership The dealership has n different models of cars There are a i cars of the i th model Karel is an excellent salesperson and can convince customers to buy up to x cars of Karel s choice as long as the cars are from different models Determine the minimum number of customers Karel has to bring in to sell all the cars ,"['#line 1 ""library/Template/template.hpp""#include <bits/stdc++.h>using namespace std;\xa0#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); i++)#define rrep(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)#define ALL(v) (v).begin(), (v).end()#define UNIQUE(v) sort(ALL(v)), (v).erase(unique(ALL(v)), (v).end())#define SZ(v) (int)v.size()#define MIN(v) *min_element(ALL(v))#define MAX(v) *max_element(ALL(v))#define LB(v, x) int(lower_bound(ALL(v), (x)) - (v).begin())#define UB(v, x) int(upper_bound(ALL(v), (x)) - (v).begin())\xa0using uint = unsigned int;using ll = long long int;using ull = unsigned long long;using i128 = __int128_t;using u128 = __uint128_t;const int inf = 0x3fffffff;const ll INF = 0x1fffffffffffffff;\xa0template <typename T> inline bool chmax(T &a, T b) {    if (a < b) {        a = b;        return 1;    }    return 0;}template <typename T> inline bool chmin(T &a, T b) {    if (a > b) {        a = b;        return 1;    }    return 0;}template <typename T, typename U> T ceil(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? (x + y - 1) / y : x / y);}template <typename T, typename U> T floor(T x, U y) {    assert(y != 0);    if (y < 0)        x = -x, y = -y;    return (x > 0 ? x / y : (x - y + 1) / y);}template <typename T> int popcnt(T x) {    return __builtin_popcountll(x);}template <typename T> int topbit(T x) {    return (x == 0 ? -1 : 63 - __builtin_clzll(x));}template <typename T> int lowbit(T x) {    return (x == 0 ? -1 : __builtin_ctzll(x));}\xa0template <class T, class U>ostream &operator<<(ostream &os, const pair<T, U> &p) {    os << ""P("" << p.first << "", "" << p.second << "")"";    return os;}template <typename T> ostream &operator<<(ostream &os, const vector<T> &vec) {    os << ""{"";    for (int i = 0; i < vec.size(); i++) {        os << vec[i] << (i + 1 == vec.size() ? """" : "", "");    }    os << ""}"";    return os;}template <typename T, typename U>ostream &operator<<(ostream &os, const map<T, U> &map_var) {    os << ""{"";    for (auto itr = map_var.begin(); itr != map_var.end(); itr++) {        os << ""("" << itr->first << "", "" << itr->second << "")"";        itr++;        if (itr != map_var.end())            os << "", "";        itr--;    }    os << ""}"";    return os;}template <typename T> ostream &operator<<(ostream &os, const set<T> &set_var) {    os << ""{"";    for (auto itr = set_var.begin(); itr != set_var.end(); itr++) {        os << *itr;        ++itr;        if (itr != set_var.end())            os << "", "";        itr--;    }    os << ""}"";    return os;}#ifdef LOCAL#define show(...) _show(0, #__VA_ARGS__, __VA_ARGS__)#else#define show(...) true#endiftemplate <typename T> void _show(int i, T name) {    cerr << \'\\n\';}template <typename T1, typename T2, typename... T3>void _show(int i, const T1 &a, const T2 &b, const T3 &...c) {    for (; a[i] != \',\' && a[i] != \'\\0\'; i++)        cerr << a[i];    cerr << "":"" << b << "" "";    _show(i + 1, a, c...);}#line 2 ""library/Utility/fastio.hpp""#include <unistd.h>namespace fastio {static constexpr uint32_t SZ = 1 << 17;char ibuf[SZ];char obuf[SZ];char out[100];// pointer of ibuf, obuf\xa0uint32_t pil = 0, pir = 0, por = 0;\xa0struct Pre {    char num[10000][4];    constexpr Pre() : num() {        for (int i = 0; i < 10000; i++) {            int n = i;            for (int j = 3; j >= 0; j--) {                num[i][j] = n % 10 | \'0\';                n /= 10;            }        }    }} constexpr pre;\xa0inline void load() {    memmove(ibuf, ibuf + pil, pir - pil);    pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);    pil = 0;    if (pir < SZ)        ibuf[pir++] = \'\\n\';}\xa0inline void flush() {    fwrite(obuf, 1, por, stdout);    por = 0;}\xa0void rd(char &c) {    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));}\xa0void rd(string &x) {    x.clear();    char c;    do {        if (pil + 1 > pir)            load();        c = ibuf[pil++];    } while (isspace(c));    do {        x += c;        if (pil == pir)            load();        c = ibuf[pil++];    } while (!isspace(c));}\xa0template <typename T> void rd_real(T &x) {    string s;    rd(s);    x = stod(s);}\xa0template <typename T> void rd_integer(T &x) {    if (pil + 100 > pir)        load();    char c;    do        c = ibuf[pil++];    while (c < \'-\');    bool minus = 0;    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (c == \'-\') {            minus = 1, c = ibuf[pil++];        }    }    x = 0;    while (\'0\' <= c) {        x = x * 10 + (c & 15), c = ibuf[pil++];    }    if constexpr (is_signed<T>::value || is_same_v<T, i128>) {        if (minus)            x = -x;    }}\xa0void rd(int &x) {    rd_integer(x);}void rd(ll &x) {    rd_integer(x);}void rd(i128 &x) {    rd_integer(x);}void rd(uint &x) {    rd_integer(x);}void rd(ull &x) {    rd_integer(x);}void rd(u128 &x) {    rd_integer(x);}void rd(double &x) {    rd_real(x);}void rd(long double &x) {    rd_real(x);}\xa0template <class T, class U> void rd(pair<T, U> &p) {    return rd(p.first), rd(p.second);}template <size_t N = 0, typename T> void rd_tuple(T &t) {    if constexpr (N < std::tuple_size<T>::value) {        auto &x = std::get<N>(t);        rd(x);        rd_tuple<N + 1>(t);    }}template <class... T> void rd(tuple<T...> &tpl) {    rd_tuple(tpl);}\xa0template <size_t N = 0, typename T> void rd(array<T, N> &x) {    for (auto &d : x)        rd(d);}template <class T> void rd(vector<T> &x) {    for (auto &d : x)        rd(d);}\xa0void read() {}template <class H, class... T> void read(H &h, T &...t) {    rd(h), read(t...);}\xa0void wt(const char c) {    if (por == SZ)        flush();    obuf[por++] = c;}void wt(const string s) {    for (char c : s)        wt(c);}void wt(const char *s) {    size_t len = strlen(s);    for (size_t i = 0; i < len; i++)        wt(s[i]);}\xa0template <typename T> void wt_integer(T x) {    if (por > SZ - 100)        flush();    if (x < 0) {        obuf[por++] = \'-\', x = -x;    }    int outi;    for (outi = 96; x >= 10000; outi -= 4) {        memcpy(out + outi, pre.num[x % 10000], 4);        x /= 10000;    }    if (x >= 1000) {        memcpy(obuf + por, pre.num[x], 4);        por += 4;    } else if (x >= 100) {        memcpy(obuf + por, pre.num[x] + 1, 3);        por += 3;    } else if (x >= 10) {        int q = (x * 103) >> 10;        obuf[por] = q | \'0\';        obuf[por + 1] = (x - q * 10) | \'0\';        por += 2;    } else        obuf[por++] = x | \'0\';    memcpy(obuf + por, out + outi + 4, 96 - outi);    por += 96 - outi;}\xa0template <typename T> void wt_real(T x) {    ostringstream oss;    oss << fixed << setprecision(15) << double(x);    string s = oss.str();    wt(s);}\xa0void wt(int x) {    wt_integer(x);}void wt(ll x) {    wt_integer(x);}void wt(i128 x) {    wt_integer(x);}void wt(uint x) {    wt_integer(x);}void wt(ull x) {    wt_integer(x);}void wt(u128 x) {    wt_integer(x);}void wt(double x) {    wt_real(x);}void wt(long double x) {    wt_real(x);}\xa0template <class T, class U> void wt(const pair<T, U> val) {    wt(val.first);    wt(\' \');    wt(val.second);}template <size_t N = 0, typename T> void wt_tuple(const T t) {    if constexpr (N < std::tuple_size<T>::value) {        if constexpr (N > 0) {            wt(\' \');        }        const auto x = std::get<N>(t);        wt(x);        wt_tuple<N + 1>(t);    }}template <class... T> void wt(tuple<T...> tpl) {    wt_tuple(tpl);}template <class T, size_t S> void wt(const array<T, S> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(\' \');        wt(val[i]);    }}template <class T> void wt(const vector<T> val) {    auto n = val.size();    for (size_t i = 0; i < n; i++) {        if (i)            wt(\' \');        wt(val[i]);    }}\xa0void print() {    wt(\'\\n\');}template <class Head, class... Tail> void print(Head &&head, Tail &&...tail) {    wt(head);    if (sizeof...(Tail))        wt(\' \');    print(forward<Tail>(tail)...);}void __attribute__((destructor)) _d() {    flush();}} // namespace fastio\xa0using fastio::flush;using fastio::print;using fastio::read;\xa0inline void first(bool i = true) {    print(i ? ""first"" : ""second"");}inline void Alice(bool i = true) {    print(i ? ""Alice"" : ""Bob"");}inline void Takahashi(bool i = true) {    print(i ? ""Takahashi"" : ""Aoki"");}inline void yes(bool i = true) {    print(i ? ""yes"" : ""no"");}inline void Yes(bool i = true) {    print(i ? ""Yes"" : ""No"");}inline void No() {    print(""No"");}inline void YES(bool i = true) {    print(i ? ""YES"" : ""NO"");}inline void NO() {    print(""NO"");}inline void Yay(bool i = true) {    print(i ? ""Yay!"" : "":("");}inline void Possible(bool i = true) {    print(i ? ""Possible"" : ""Impossible"");}inline void POSSIBLE(bool i = true) {    print(i ? ""POSSIBLE"" : ""IMPOSSIBLE"");}\xa0/** * @brief Fast IO */#line 3 ""sol.cpp""\xa0void solve(int _rot) {    // write(""Case #""+to_string(_rot)+"": "");    int n, x;    read(n, x);    vector<ll> a(n);    read(a);\xa0    ll sum = 0;    rep(i, 0, n) sum += a[i];    ll ret = max(MAX(a), ceil(sum, x));    print(ret);}\xa0int main() {    int t;    read(t);    rep(rot, 0, t) solve(rot + 1);    return 0;}']","[1, 1, 0, 0, 0]",1300,Step 1Since no customer can buy more than one car from the same model the minimum number of clients we need is determined by the model with the most cars Therefore we need at least clients because even if a customer buys cars from other models they cannot exceed this limit for any single model 
You are given an grid some of its nodes are black the others are white Moreover it s not an ordinary grid each unit square of the grid has painted diagonals The figure below is an example of such grid of size Four nodes of this grid are black the other nodes are white Your task is to count the number of such triangles on the given grid that the corners match the white nodes and the area is positive all sides go along the grid lines horizontal vertical or diagonal no side contains black nodes ,"['#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nchar s[410][410];\nint sumu[410][410], suml[410][410], sumha[410][410], sumxi[410][410];\nint px[10], py[10];\n\nint cal(int x1, int y1, int x2, int y2) {\n    if (x1 == x2) {\n        return abs(suml[x1][y1] - suml[x2][y2]);\n    } else if (y1 == y2) {\n        return abs(sumu[x1][y1] - sumu[x2][y2]);\n    } else if ((x2 - x1) * (y2 - y1) > 0) {\n        return abs(sumha[x1][y1] - sumha[x2][y2]);\n    } else {\n        return abs(sumxi[x1][y1] - sumxi[x2][y2]);\n    }\n}\n\nbool ck(int x, int y) {\n    if (x < 0 || x >= n || y < 0 || y >= m) return false;\n    if (s[x][y] != \'0\') return false;\n    px[2] = x; py[2] = y;\n    for (int i = 0; i < 3; i++) {\n        for (int j = i + 1; j < 3; j++) {\n            if (cal(px[i], py[i], px[j], py[j]) != 0) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    scanf(""%d%d"", &n, &m);\n    for (int i = 0; i < n; i++) {\n        scanf(""%s"", s[i]);\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            sumu[i][j] = s[i][j] - \'0\';\n            if (i > 0) sumu[i][j] += sumu[i - 1][j];\n\n            suml[i][j] = s[i][j] - \'0\';\n            if (j > 0) suml[i][j] += suml[i][j - 1];\n\n            sumha[i][j] = s[i][j] - \'0\';\n            if (i > 0 && j > 0) sumha[i][j] += sumha[i - 1][j - 1];\n\n            sumxi[i][j] = s[i][j] - \'0\';\n            if (i > 0 && j + 1 < m) sumxi[i][j] += sumxi[i - 1][j + 1];\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = j + 1; k < m; k++) {\n                int id1 = s[i][j] - \'0\';\n                int id2 = s[i][k] - \'0\';\n                if (id1 || id2) continue;\n                px[0] = i; py[0] = j;\n                px[1] = i; py[1] = k;\n                if ((k - j) % 2 == 0) {\n                    int tx1 = i - (k - j) / 2, ty1 = j + (k - j) / 2;\n                    int tx2 = tx1 + (k - j), ty2 = ty1;\n\n                    if (ck(tx1, ty1)) ans++;\n                    if (ck(tx2, ty2)) ans++;\n                }\n                if (ck(i - (k - j), j)) ans++;\n                if (ck(i + (k - j), j)) ans++;\n                if (ck(i - (k - j), k)) ans++;\n                if (ck(i + (k - j), k)) ans++;\n                //printf(""%d %d %d\\n"", j, k, ans);\n            }\n        }\n        //printf(""ans = %d\\n"", ans);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                int id1 = s[j][i] - \'0\', id2 = s[k][i] - \'0\';\n                px[0] = j; py[0] = i;\n                px[1] = k; py[1] = i;\n                if (id1 || id2) continue;\n                if ((k - j) % 2 == 0) {\n                    int tx1 = i - (k - j) / 2, ty1 = j + (k - j) / 2;\n                    int tx2 = tx1 + (k - j), ty2 = ty1;\n\n                    if (ck(ty1, tx1)) ans++;\n                    if (ck(ty2, tx2)) ans++;\n                }\n            }\n        }\n    }\n    printf(""%d\\n"", ans);\n    return 0;\n}\n']","[1, 0, 0, 1, 0]",2000,Values and are not so large so the solution with complexity should pass It means that you should consider all triangles and check all conditions in To make this check you should precalc arrays of partial sums on all diagonals rows and columns After that you could check that there is no black nodes on the side using one sum query Some hints about this problem and the implementation 
One day Sasha visited the farmer 2D and his famous magnetic farm On this farm the crop grows due to the influence of a special magnetic field Maintaining of the magnetic field is provided by n machines and the power of the i th machine is a i This year 2D decided to cultivate a new culture but what exactly he didn t say For the successful growth of the new culture it is necessary to slightly change the powers of the machines 2D can choose an arbitrary integer x then choose one machine and reduce the power of its machine by x times and at the same time increase the power of one another machine by x times powers of all the machines must stay Note that he may not do that if he wants More formally 2D can choose two such indices i and j and one integer x such that x is a divisor of a i and change powers as following a i frac a i x a j a j cdot xSasha is very curious that s why he wants to calculate the total power the farmer can reach There are too many machines and Sasha can t cope with computations help him ,"['#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint n, a[50000];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin >> n;\n    for (int i = 0; i < n; i++) cin >> a[i];\n    sort(a, a+n);\n\n    int sum = 0;\n    for (int i = 0; i < n; i++) sum += a[i];\n\n    int sol = sum;\n    for (int i = 1; i < n; i++) {\n        for (int d = 2; d <= a[i]; d++) {\n            if(a[i] % d != 0) continue;\n            sol = min(sol, sum-a[0]-a[i] + d*a[0] + a[i]/d);\n        }\n    }\n    cout << sol << endl;\n    return 0;\n}\n']","[1, 0, 0, 0, 0]",1300,First notice that if we divide some number by then to get the minimal sum it is optimal to multiply by the smallest number in the array So now precalculate the sum of the initial array and the minimal then you can check all possible for every and choose the best variant So the complexity is 
Today s morning was exceptionally snowy Meshanya decided to go outside and noticed a huge snowball rolling down the mountain Luckily there are two stones on that mountain Initially snowball is at height h and it has weight w Each second the following sequence of events happens snowball s weights increases by i where i is the current height of snowball then snowball hits the stone if it s present at the current height then snowball moves one meter down If the snowball reaches height zero it stops There are exactly two stones on the mountain First stone has weight u 1 and is located at height d 1 the second one u 2 and d 2 respectively When the snowball hits either of two stones it loses weight equal to the weight of that stone If after this snowball has negative weight then its weight becomes zero but the snowball continues moving as before Find the weight of the snowball when it stops moving that is it reaches height 0 ,"['#include <bits/stdc++.h>\n#define endl \'\\n\'\n\n//#pragma GCC optimize (""O3"")\n//#pragma GCC target (""sse4"")\n\n#define SZ(x) ((int)x.size())\n#define ALL(V) V.begin(), V.end()\n#define L_B lower_bound\n#define U_B upper_bound\n#define pb push_back\n\nusing namespace std;\ntemplate<class T, class T2> inline int chkmax(T &x, const T2 &y) { return x < y ? x = y, 1 : 0; }\ntemplate<class T, class T2> inline int chkmin(T &x, const T2 &y) { return x > y ? x = y, 1 : 0; }\nconst int MAXN = (1 << 20);\n\nint w, h;\nint d1, d2, u1, u2;\n\nvoid read()\n{\n\tcin >> w >> h;\n\tcin >> u1 >> d1;\n\tcin >> u2 >> d2;\n}\n\nvoid solve()\n{\n\twhile(h)\n\t{\n\t\tw += h;\n\t\tif(h == d1) w -= u1, chkmax(w, 0); \n\t\tif(h == d2) w -= u2, chkmax(w, 0); \n\t\th--;\n\t}\n\n\tcout << w << endl;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tread();\n\tsolve();\n\treturn 0;\n}\n\n']","[0, 0, 1, 0, 0]",800,This problem can be solved in many ways we will tell you one of them Let s just iterate through all the heights of from to Inside the loop we have to add to the weight of snowball and then check whether there is a stone at this height If there is then you need to check whether weight of snowball is more than weight of the stone If more then subtract the weight of the stone from weight of snowball if not then assign the weight of snowball value 0 Code ism OK tutorial 
Alice and Bob are playing a game on n piles of stones On each player s turn they select a positive integer k that is at most the size of the smallest pile and remove k stones from nonempty pile at once The first player who is unable to make a move because all piles are empty loses Given that Alice goes first who will win the game if both players play optimally ,"['#include <bits/stdc++.h>\xa0using i64 = long long;\xa0void solve() {    int n;    std::cin >> n;        std::vector<int> a(n + 1);    for (int i = 1; i <= n; i++) {        std::cin >> a[i];    }    std::sort(a.begin(), a.end());        int win = 0;    for (int i = n; i >= 1; i--) {        int v = a[i] - a[i - 1];        if (v > 0) {            if (win == 0) {                win = 1;            } else if (v == 1) {                win = 0;            }        }    }        std::cout << (win ? ""Alice"" : ""Bob"") << ""\\n"";}\xa0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}']","[1, 1, 0, 0, 0]",1400,If the smallest pile is of size then Alice must choose in her first move Therefore we can imagine subtracting from all piles and determining who wins given that Bob goes first We can repeat this process switching the first player back and forth until there is no longer a pile of size At this point we are in one of two states If there are no piles remaining the first player loses because they cannot make any moves Otherwise the smallest pile is of size We can show that the first player will always win To do this consider what happens if the first player chooses If this would create a losing state for the next player then the first player can choose and win Otherwise the state reached by choosing is a winning state for the next player to move So the first player can choose forcing the second player to choose The first player will now be in the winning state and can proceed to win the game To implement this solution we only need to keep track of the largest pile size and the smallest positive integer that is not a pile size essentially the MEX of the pile sizes excluding If then Alice and Bob will be forced to choose until the end of the game so the parity of determines the winner Otherwise they will eventually reach a state with minimum pile size at least so the parity of determines the winner Complexity or depending on implementation 
Haha try to solve this SelectorUnlimited antontrygubO oYour friends Alice and Bob practice fortune telling Fortune telling is performed as follows There is a well known array a of n non negative integers indexed from 1 to n The tellee starts with some non negative number d and performs one of the two operations for each i 1 2 ldots n The possible operations are replace their current number d with d a i replace their current number d with d oplus a i hereinafter oplus denotes the bitwise XOR operation Notice that the chosen operation may be different for different i and for different tellees One time Alice decided to start with d x and Bob started with d x 3 Each of them performed fortune telling and got a particular number in the end Notice that the friends chose operations independently of each other that is they could apply different operations for the same i You learnt that either Alice or Bob ended up with number y in the end but you don t know whose of the two it was Given the numbers Alice and Bob started with and y find out who Alice or Bob could get the number y after performing the operations It is guaranteed that on the jury tests of your friends could have actually gotten that number You cannot make hacks in this problem ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define reg register\nconst int maxn=10005;\nchar buffer[maxn],*S,*T;\ninline char Get_Char(){\n    if(S==T){\n        T=(S=buffer)+fread(buffer,1,maxn,stdin);\n        if(S==T)return EOF;\n    }\n    return *S++;\n}\n\ninline int read(){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)return -re;\n    return re;\n}\n\ninline void read(int&x){\n    reg char c;\n    reg int re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\ninline void read(ll&x){\n    reg char c;\n    reg ll re=0,f=0;\n    for(c=Get_Char();c<\'0\' or c>\'9\';c=Get_Char())if(c==\'-\')f=1;\n    for(;c>=\'0\' and c<=\'9\';)re=(re<<1)+(re<<3)+(c-\'0\'),c=Get_Char();\n    if(f)x=-re;\n    else x=re;\n}\nconst int mxn=1e5+5;\nll a[mxn];\nll x,y,n,p[33],q[33],lp[33],lq[33];\ninline void solve(){\n\tmemset(p,0,sizeof(p));\n\tmemset(q,0,sizeof(q));\n\tcin>>n>>x>>y;\n\tx%=32,y%=32;\n\tll c=x,d=x+3;\n\td%=32;\n\tp[c]=1,q[d]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tcin>>a[x];\n\t\tmemset(lp,0,sizeof(lp));\n\t\tmemset(lq,0,sizeof(lq));\n\t\tfor(int j=0;j<32;++j){\n\t\t\tif(p[j]==1){\n\t\t\t\tlp[(j+a[x])%32]=1;\n\t\t\t\tlp[(j^a[x])%32]=1;\n\t\t\t}\n\t\t\tif(q[j]==1){\n\t\t\t\tlq[(j+a[x])%32]=1;\n\t\t\t\tlq[(j^a[x])%32]=1;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<32;++j)p[j]=lp[j],q[j]=lq[j];\n\t}\n\tif(p[y]==1)cout<<""Alice\\n"";\n\telse cout<<""Bob\\n"";\n}\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0),cout.tie(0);\n\tint T=1;\n\tcin>>T;\n\tfor(;T--;)solve();\n\treturn 0;\n}']","[0, 1, 0, 0, 0]",1400,Notice that the operations and have the same effect on the parity it is inverted if the second argument of the operation is odd and stays the same otherwise By induction we conclude that if we apply the operations to some even number and to some odd number the resulting numbers will also be of different parity Therefore we can determine whether the parity of the input is the same as the parity of the output or the opposite if the sum of is even then the parity does not change otherwise it does Thus we can find out the parity of the original number from the parity of the result and this is enough to solve the problem because the numbers and have different parity 
You are given a tree of n vertices numbered from 1 to n A tree is a connected undirected graph without cycles For each i 1 2 ldots n let w i be the weight of the i th vertex A vertex is called if its weight is equal to the sum of the weights of all its neighbors Initially the weights of all nodes are unassigned Assign positive integer weights to each vertex of the tree such that the number of good vertices in the tree is maximized If there are multiple ways to do it you have to find one that minimizes the sum of weights of all vertices in the tree ,"['#include<bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int n;\n    cin >> n;\n    if (n == 2) {\n        cout << ""2 2\\n1 1"";\n        return 0;\n    }\n    vector<vector<int>> G(n + 1);\n    for (int i = 1, u, v; i < n; i += 1) {\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    vector<pair<int, int>> f(n + 1), g(n + 1);\n    function<void(int, int)> DFS = [&](int u, int p) {\n        for (int v : G[u])\n            if (v != p) {\n                DFS(v, u);\n                auto pr = min(f[v], g[v]);\n                g[u].first += pr.first;\n                g[u].second += pr.second;\n                f[u].first += g[v].first;\n                f[u].second += g[v].second;\n            }\n        f[u].first -= 1;\n        f[u].second += G[u].size() - 1;\n    };\n    DFS(1, 0);\n    auto pr = min(f[1], g[1]);\n    cout << -pr.first << "" "" << pr.second + n << ""\\n"";\n    vector<int> ans(n + 1, 1);\n    function<void(int, int, int)> DFS2 = [&](int u, int p, int cf) {\n        if (cf) ans[u] = G[u].size();\n        for (int v : G[u])\n            if (v != p) {\n                if (cf) DFS2(v, u, 0);\n                else DFS2(v, u, f[v] < g[v]);\n            }\n        f[u].first -= 1;\n        f[u].second += G[u].size() - 1;\n    };\n    DFS2(1, 0, f[1] < g[1]);\n    for (int i = 1; i <= n; i += 1) cout << ans[i] << "" "";\n    return 0;\n}']","[0, 0, 1, 1, 0]",2000,If we can assign and and there is no way to get a better answer because all vertices are good and the sum of weights cannot be smaller because the weights have to be positive If two vertices sharing an edge cannot be both good To prove this we are going to analyze two cases If the two vertices have distinct weights then the one with a smaller weight cannot be good because the one with a larger weight is its neighbor Otherwise if both vertices have the same weight then none of them can have another neighbor as that would increase the sum of their neighbors by at least So the only way this could happen is if but we are assuming that Thus the set of good vertices must be an independent set We will see that for each independent set of vertices in the tree there is an assignment of weights where all the vertices from this set are good We can assign a weight of to each vertex that is not in the set and assign its degree to each vertex in the set Because all neighbors of a vertex in the set are not in the set then all of them have a weight of and this vertex is good Therefore the maximum number of good vertices is the same as the maximum size of an independent set in this tree For a fixed independent set of the maximum size the construction above leads to a configuration with the minimum sum of weights This is because all vertices must have a weight of at least and the vertices in the set must have a weight of at least its degree So to solve the problem it is enough to root the tree in an arbitrary vertex and solve a tree dp Let s call to the pair where is the maximum number of good vertices in the subtree of vertex assuming that is good if or that it is not good if and is the minimum sum of weights for that value The values of can be computed with a dp using the values of in the children of node If then for each child you must sum If for each child you can choose the best answer between and The answer to the problem will be the best between and To construct the assignment of weights you can do it recursively considering for each vertex if it has to be good or not in order to keep the current value of the answer In case both options making it good or not work you have to choose to not make it good as you do not know if its father was good or not Intended complexity 
Mishka is a little polar bear As known little bears loves spending their free time playing dice for chocolates Once in a wonderful sunny morning walking around blocks of ice Mishka met her friend Chris and they started playing the game Rules of the game are very simple at first number of rounds is defined In every round each of the players throws a cubical dice with distinct numbers from to written on its faces Player whose value after throwing the dice is greater wins the round In case if player dice values are equal no one of them is a winner In average player who won most of the rounds is the winner of the game In case if two players won the same number of rounds the result of the game is draw Mishka is still very little and can t count wins and losses so she asked you to watch their game and determine its result Please help her ,"['#include<bits/stdc++.h>\nusing namespace std;\n#define FZ(n) memset((n),0,sizeof(n))\n#define FMO(n) memset((n),-1,sizeof(n))\n#define MC(n,m) memcpy((n),(m),sizeof(n))\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define ALL(x) begin(x),end(x)\n#define IOS do { ios_base::sync_with_stdio(0);cin.tie(0); } while (0)\n#define SZ(x) ((int)(x).size())\n#ifndef OFFLINE\n    #define ONLINE_JUDGE\n#endif\n#ifdef ONLINE_JUDGE\n#define FILEIO(name) \\\n    do { \\\n        freopen(name"".in"", ""r"", stdin); \\\n        freopen(name"".out"", ""w"", stdout); \\\n    } while (0)\n#else\n    #define FILEIO(name) do { } while(0)\n#endif\n\n#define _TOKEN_CAT2(x, y) x ## y\n#define _TOKEN_CAT(x, y) _TOKEN_CAT2(x, y)\n#define _MACRO_OVERL3(_1, _2, _3, _N, ...) _N\n#define _RANGE1(a) int _TOKEN_CAT(_t, __LINE__)=0; _TOKEN_CAT(_t, __LINE__)<(a); (_TOKEN_CAT(_t, __LINE__))++\n#define _RANGE2(i, a) int (i)=0; (i)<(a); (i)++\n#define _RANGE3(i, a, b) int (i)=(a); (i)!=(b); (i)+=((b)>(a)?1:-1)\n#define loop(...) for (_MACRO_OVERL3(__VA_ARGS__, _RANGE3, _RANGE2, _RANGE1)(__VA_ARGS__))\n\n#ifdef OFFLINE\ntemplate<typename T>\nvoid _dump(const char* s, T&& head) { \n    cerr << s << "" = "" << head << "" <<"" << endl; \n}\n\ntemplate<typename T, typename... Args>\nvoid _dump(const char* s, T&& head, Args&&... tail) {\n    int c = 0;\n    while (*s!=\',\' || c!=0) {\n        if (*s==\'(\' || *s==\'[\' || *s==\'{\' || *s==\'<\') c++;\n        if (*s==\')\' || *s==\']\' || *s==\'}\' || *s==\'>\') c--;\n        cerr << *s++;\n    }\n    cerr << "" = "" << head << "", "";\n    _dump(s+1, tail...);\n}\n\n#define dump(...) do { \\\n    cerr << ""\\033[32m>> "" << __LINE__ << "": "" << __PRETTY_FUNCTION__ << endl; \\\n    cout << ""   ""; \\\n    _dump(#__VA_ARGS__, __VA_ARGS__); \\\n    cout << ""\\033[0m""; \\\n} while (0)\n#else\n#define dump(...) \n#endif\n\n#define au auto\ntemplate<class T>\nusing vec = vector<T>;\n\ntemplate<typename Iter>\nostream& _IterOutput_(ostream &o, Iter b, Iter e, const string ss="""", const string se="""") {\n    o << ss;\n    for (auto it=b; it!=e; it++) o << (it==b ? """" : "", "") << *it;\n    return o << se;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const pair<T1, T2> &pair) {\n    return o << ""("" << pair.F << "", "" << pair.S << "")"";\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const vector<T> &vec) {\n    return _IterOutput_(o, ALL(vec), ""["", ""]"");\n}\n\ntemplate<typename T>\nostream& operator << (ostream &o, const set<T> &st) {\n    return _IterOutput_(o, ALL(st), ""{"", ""}"");\n}\n\ntemplate<typename T, size_t N>\nostream& operator << (ostream &o, const array<T, N> &arr) {\n    return _IterOutput_(o, ALL(arr), ""|"", ""|"");\n}\n\ntemplate<typename T1, typename T2>\nostream& operator << (ostream &o, const map<T1, T2> &mp) {\n    o << ""{"";\n    for (auto it=mp.begin(); it!=mp.end(); it++) {\n        o << (it==mp.begin()?"""":"", "") << it->F << "":"" << it->S;\n    }\n    o << ""}"";\n    return o;\n}\n\nvoid lucky_test() {\n    srand(time(NULL));\n    long long a = rand(), b = rand();\n    if ((a * 32768 + b) % 100000 == 0) {\n        cout << ""Not lucky"" << endl;\n        exit(0);\n    }\n}\n\nint32_t main() {\n    IOS;\n    lucky_test();\n\n    int N;\n    cin >> N;\n    int a = 0, b = 0;\n    for (int i=0; i<N; i++) {\n        int x, y;\n        cin>>x>>y;\n        if (x>y) a++;\n        else if (x<y) b++;\n    }\n\n\n    cout << (a == b ? ""Friendship is magic!^^"" :\n             a > b ? ""Mishka"" : ""Chris"") << endl;\n    return 0;\n}\n\n']","[0, 0, 1, 0, 0]",800,In this problem you had to do use the following algo If Mishka wins Chris in the current round then increase variable by 1 Otherwise if Chris wins Mishka increase variable After that you had to compare this values and print the answer 
Let a and b be some non negative integers Let s define of a and b as following write down the numbers one under another and align them by their least significant digit add them up digit by digit and concatenate the respective sums together Assume that both numbers have an infinite number of leading zeros For example let s take a look at a of numbers 3248 and 908 You are given a string c consisting of n digits from 0 to 9 You are also given m updates of form x d replace the digit at the x th position of c with a digit d Note that string c might have leading zeros at any point of time After each update print the number of pairs a b such that both a and b are non negative integers and the result of a of a and b is equal to c Note that the numbers of pairs can be quite large so print them modulo 998244353 ,"['#pragma GCC optimize (""O3"")\n#pragma GCC target (""sse4"")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = \'\\n\';\nconst int MX = 500011; //check the limits, dummy\n \nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\nmi oneVal[MX];\nvoid precomp() {\n    oneVal[0] = 1;\n    oneVal[1] = 2;\n    FOR(i, 2, MX) {\n        oneVal[i] = 8 * oneVal[i-2] + 2 * oneVal[i-1];\n    }\n}\n\ninline mi val(int ones, int lst) {\n    mi res = (lst + 1) * oneVal[ones];\n    if (ones > 0) res += (9 - lst) * oneVal[ones-1];\n    return res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    set<pi> blocks;\n    int ls = 0;\n    mi ans = 1;\n    precomp();\n    F0R(i, N) {\n        if (S[i] != \'1\' || i == N-1) {\n            blocks.ins({ls, i});\n            ans *= val(i - ls, S[i] - \'0\');\n            ls = i+1;\n        }\n    }\n\n    F0R(i, M) {\n        int X, D; cin >> X; X--; cin >> D;\n\n        auto it = blocks.ub({X, N+1});\n        it--;\n        pi block = *it;\n        if (D == 1) {\n            if (X == block.s) {\n                ans *= inv(val(block.s - block.f, S[block.s] - \'0\'));\n                pi newBlock = block;\n                it++;\n                if (it != blocks.end()) {\n                    pi block2 = *it;\n                    newBlock.s = block2.s;\n                    ans *= inv(val(block2.s - block2.f, S[block2.s] - \'0\'));\n                    blocks.erase(block2);\n                }\n                blocks.erase(block);\n                blocks.ins(newBlock);\n                S[X] = \'0\' + D;\n                ans *= val(newBlock.s - newBlock.f, S[newBlock.s]-\'0\');\n            }\n        } else {\n            ans *= inv(val(block.s - block.f, S[block.s] - \'0\'));\n            blocks.erase(block);\n            pi nb1 = {block.f, X};\n            blocks.ins(nb1);\n            ans *= val(X-block.f, D);\n            if (X != block.s) {\n                pi nb2 = {X+1, block.s};\n                blocks.ins(nb2);\n                ans *= val(block.s-X-1, S[block.s] - \'0\');\n            }\n        }\n\n        S[X] = \'0\' + D;\n        cout << ans << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n']","[0, 0, 0, 1, 1]",2600,Let s solve the task as if there are no updates This can be done with a pretty straightforward dp is the number of pairs such that the result of the strange addition of and is the prefix of of length From each state you can add a single digit to and to at the same time You can either go to and multiply the answer by the number of pairs of digits than sum up to Or go to and multiply the answer by the number of pairs of digits than sum up to Note that no pair of digits can sum up to a three digit value so it makes no sense to go further Let s optimize this dp with some data structure Segment tree will work well Let the node store the number of ways to split the segment into blocks of size or so that both the leftmost character and the rightmost character are not taken into any block the leftmost character is taken into some block and the rightmost character is not taken into any block the leftmost character is not taken into any block and the rightmost character is taken into some block both the leftmost and the rightmost characters are taken into some blocks This structure makes the merge pretty manageable You should glue up the segments in such a way that all the middle characters are taken into some block either in separate blocks in their own segments or into the same block of length The answer will be in the root of the tree in a value such that both characters are taken The update in the segment tree will still work in Overall complexity 
There is a pool of length l where n swimmers plan to swim People start swimming at the same time at the time moment 0 but you can assume that they take different lanes so they don t interfere with each other Each person swims along the following route they start at point 0 and swim to point l with constant speed which is equal to v i units per second for the i th swimmer After reaching the point l the swimmer instantly in negligible time turns back and starts swimming to the point 0 with the same constant speed After returning to the point 0 the swimmer starts swimming to the point l and so on Let s say that some moment of time is a if there are swimmers that are in the same point of the pool at that moment of time that point may be 0 or l as well as any other real point inside the pool The pool will be open for t seconds You have to calculate the number of meeting moments while the pool is open Since the answer may be very large print it modulo 10 9 7 ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\ntypedef long long ll;\nconst int p=998244353;\nint po(int a,int b) {if(b==0) return 1; if(b==1) return a; if(b%2==0) {int u=po(a,b/2);return (u*1LL*u)%p;} else {int u=po(a,b-1);return (a*1LL*u)%p;}}\nint inv(int x) {return po(x,p-2);}\ntemplate<int M, int K, int G> struct Fft {\n  // 1, 1/4, 1/8, 3/8, 1/16, 5/16, 3/16, 7/16, ...\n  int g[1 << (K - 1)];\n  Fft() : g() { //if tl constexpr...\n    static_assert(K >= 2, ""Fft: K >= 2 must hold"");\n    g[0] = 1;\n    g[1 << (K - 2)] = G;\n    for (int l = 1 << (K - 2); l >= 2; l >>= 1) {\n      g[l >> 1] = (static_cast<long long>(g[l]) * g[l]) % M;\n    }\n    assert((static_cast<long long>(g[1]) * g[1]) % M == M - 1);\n    for (int l = 2; l <= 1 << (K - 2); l <<= 1) {\n      for (int i = 1; i < l; ++i) {\n        g[l + i] = (static_cast<long long>(g[l]) * g[i]) % M;\n      }\n    }\n  }\n  void fft(vector<int> &x) const {\n    const int n = x.size();\n    assert(!(n & (n - 1)) && n <= 1 << K);\n    for (int h = __builtin_ctz(n); h--; ) {\n      const int l = 1 << h;\n      for (int i = 0; i < n >> 1 >> h; ++i) {\n        for (int j = i << 1 << h; j < ((i << 1) + 1) << h; ++j) {\n          const int t = (static_cast<long long>(g[i]) * x[j | l]) % M;\n          if ((x[j | l] = x[j] - t) < 0) x[j | l] += M;\n          if ((x[j] += t) >= M) x[j] -= M;\n        }\n      }\n    }\n    for (int i = 0, j = 0; i < n; ++i) {\n      if (i < j) std::swap(x[i], x[j]);\n      for (int l = n; (l >>= 1) && !((j ^= l) & l); ) {}\n    }\n  }\n  vector<int> convolution(const vector<int> &a, const vector<int> &b) const {\n    if(a.empty() || b.empty()) return {};\n    const int na = a.size(), nb = b.size();\n    int n, invN = 1;\n    for (n = 1; n < na + nb - 1; n <<= 1) invN = ((invN & 1) ? (invN + M) : invN) >> 1;\n    vector<int> x(n, 0), y(n, 0);\n    std::copy(a.begin(), a.end(), x.begin());\n    std::copy(b.begin(), b.end(), y.begin());\n    fft(x);\n    fft(y);\n    for (int i = 0; i < n; ++i) x[i] = (((static_cast<long long>(x[i]) * y[i]) % M) * invN) % M;\n    std::reverse(x.begin() + 1, x.end());\n    fft(x);\n    x.resize(na + nb - 1);\n    return x;\n  }\n};\nFft<998244353,23,31> muls;\nvector<int> form(vector<int> v,int n)\n{\n    while(v.size()<n) v.push_back(0);\n    while(v.size()>n) v.pop_back();\n    return v;\n}\nvector<int> operator *(vector<int> v1,vector<int> v2)\n{\n    return muls.convolution(v1,v2);\n}\nvector<int> operator +(vector<int> v1,vector<int> v2)\n{\n    while(v2.size()<v1.size()) v2.push_back(0); while(v1.size()<v2.size()) v1.push_back(0);\n    for(int i=0;i<v1.size();++i) {v1[i]+=v2[i];if(v1[i]>=p) v1[i]-=p; else if(v1[i]<0) v1[i]+=p;}\n    return v1;\n}\nvector<int> operator -(vector<int> v1,vector<int> v2)\n{\n    int sz=max(v1.size(),v2.size());while(v1.size()<sz) v1.push_back(0); while(v2.size()<sz) v2.push_back(0);\n    for(int i=0;i<sz;++i) {v1[i]-=v2[i];if(v1[i]<0) v1[i]+=p; else if(v1[i]>=p) v1[i]-=p;} return v1;\n}\nvector<int> trmi(vector<int> v)\n{\n    for(int i=1;i<v.size();i+=2) {if(v[i]>0) v[i]=p-v[i]; else v[i]=(-v[i]);}\n    return v;\n}\nvector<int> deriv(vector<int> v)\n{\n    if(v.empty()) return{};\n    vector<int> ans(v.size()-1);\n    for(int i=1;i<v.size();++i) ans[i-1]=(v[i]*1LL*i)%p;\n    return ans;\n}\nvector<int> integ(vector<int> v)\n{\n    vector<int> ans(v.size()+1);ans[0]=0;\n    for(int i=1;i<v.size();++i) ans[i-1]=(v[i]*1LL*i)%p;\n    return ans;\n}\nvector<int> mul(vector<vector<int> > v)\n{\n    if(v.size()==1) return v[0];\n    vector<vector<int> > v1,v2;for(int i=0;i<v.size()/2;++i) v1.push_back(v[i]); for(int i=v.size()/2;i<v.size();++i) v2.push_back(v[i]);\n    return muls.convolution(mul(v1),mul(v2));\n}\nvector<int> inv1(vector<int> v,int n)\n{\n    assert(v[0]!=0);\n    int sz=1;v=form(v,n);vector<int> a={inv(v[0])};\n    while(sz<n)\n    {\n        vector<int> vsz;for(int i=0;i<min(n,2*sz);++i) vsz.push_back(v[i]);\n        vector<int> b=((vector<int>) {1})-muls.convolution(a,vsz);\n        for(int i=0;i<sz;++i) assert(b[i]==0);\n        b.erase(b.begin(),b.begin()+sz);\n        vector<int> c=muls.convolution(b,a);\n        for(int i=0;i<sz;++i) a.push_back(c[i]);\n        sz*=2;\n    }\n    return form(a,n);\n}\nvector<int> inv(vector<int> v,int n)\n{\n    v=form(v,n);assert(v[0]!=0);if(v.size()==1) {return {inv(v[0])};} vector<int> v1=trmi(v);\n    vector<int> a=v1*v;a=form(a,2*n);\n    vector<int> b((n+1)/2);for(int i=0;i<b.size();++i) b[i]=a[2*i];\n    vector<int> ans1=inv(b,b.size());vector<int> ans2(n);for(int i=0;i<n;++i) {if(i%2==0) ans2[i]=ans1[i/2]; else ans2[i]=0;}\n    return form(v1*ans2,n);\n}\nvector<int> operator/(vector<int> a,vector<int> b)\n{\n    while(!a.empty() && a.back()==0) a.pop_back(); while(!b.empty() && b.back()==0) b.pop_back();\n    int n=a.size();int m=b.size();if(n<m) return {};\n    reverse(a.begin(),a.end());reverse(b.begin(),b.end());vector<int> ans=a*inv(b,n-m+1);while(ans.size()>n-m+1) ans.pop_back();\n    reverse(ans.begin(),ans.end());while(!ans.empty() && ans.back()==0) ans.pop_back();return ans;\n}\nvector<int> operator%(vector<int> a,vector <int> b)\n{\n    vector<int> ans=a-b*(a/b);while(!ans.empty() && ans.back()==0) ans.pop_back(); return ans;\n}\nconst int mod=1e9+7;\nconst int maxn=4e5+5;\nint o=maxn/2;\nbool ok[maxn];\nint answ[maxn];\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int l,t1;cin>>l>>t1;\n    int n;\n    cin>>n;\n    vector<int> a(maxn);\n    for(int i=0;i<n;++i)\n    {\n        int v;cin>>v;a[v]=1;\n    }\n    vector<int> a1=a*a;\n    for(int i=0;i<maxn;++i)\n    {\n        int h=a1[i];if(i%2==0 && a[i/2]) h--;\n        if(h) {ok[i]=true;}\n    }\n    vector<int> b=a;\n    reverse(b.begin(),b.begin()+o);\n    vector<int> a2=a*b;\n    for(int i=0;i<o;++i)\n    {\n        if(a2[i])\n        {\n            ok[o-i-1]=true;\n        }\n    }\n    //for(int j=0;j<10;++j) cout<<ok[j]<<\' \'; cout<<endl;\n    for(int g=1;g<maxn;++g)\n    {\n        answ[g]=(t1*g)/(2*l);\n    }\n    int res=0;\n    for(int g=1;g<maxn;++g)\n    {\n        bool ok1=false;\n        for(int k=g;k<maxn;k+=g)\n        {\n            if(ok[k]) ok1=true;\n            if(k!=g) answ[k]-=answ[g];\n        }\n        //if(ok1) cout<<g<<"" g ""<<answ[g]<<"" answ[g] ""<<endl;\n        if(ok1) {res+=answ[g];res%=mod;}\n    }\n    cout<<(res%mod+mod)%mod;\n    return 0;\n}\n']","[0, 1, 0, 1, 0]",2800,Firstly note that there are two different situations when some two swimmers meet they either move in the same direction or in opposite directions Suppose swimmers and meet while moving in the same direction We can write some easy system of equation and get that they will meet each seconds Analogically if they meet while moving in the opposite directions they will meet each seconds Let s create array that will contain all possible values exactly once If then values and we can calculate all of them using FFT fast multiplication two times for sums and for differences Okay we got all possible how to calculate the answer For a fixed value meeting moments are for all in segment is the upper bound and can be calculated as We found that for each there are exactly meeting points but since in one meeting moment more than two swimmers may meet we need to calculate each value exactly once Note that iff And we can rephrase our task as following calculate the number of unique fractions where The key idea here is to calculate only irreducible fractions Suppose we have fractions Let s add to the answer only irreducible fractions among them we will discuss how to do it later For any other fraction and is a divisor of If we fix some divisor of there will be exactly fractions with Moreover numerators will also form a segment So instead of calculating them now we will just pass that task to In total we iterate in decreasing order add only the number of irreducible fractions to the answer Then iterate over all divisors of and update value for with value How to calculate the number of irreducible fractions with With M bius function of course since for each divisor of there are exactly fractions where by Both passing calculations and M bius inversion works in And since we iterate over all the total complexity is Both FFT and next part works in so the total complexity is P S If you note that if then is always equal to then you can not only simplify the part with passing down calculations but get rid of M bius inversion at all replacing it with Sieve like two for s iterations 
A film festival is coming up in the city N The festival will last for exactly days and each day will have a premiere of exactly one film Each film has a genre an integer from 1 to On the th day the festival will show a movie of genre We know that a movie of each of genres occurs in the festival programme at least once In other words each integer from 1 to occurs in the sequence at least once Valentine is a movie critic He wants to watch some movies of the festival and then describe his impressions on his site As any creative person Valentine is very susceptive After he watched the movie of a certain genre Valentine forms the he preserves until he watches the next movie If the genre of the next movie is the same it does not change Valentine s mood If the genres are different Valentine s mood changes according to the new genre and Valentine has a Valentine can t watch all movies so he decided to exclude from his to watch list movies of one of the genres In other words Valentine is going to choose exactly one of the genres and will skip all the movies of this genre He is sure to visit other movies Valentine wants to choose such genre that the total number of after movie stresses after all movies of genre are excluded were minimum ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <sstream>\nusing namespace std;\n\n#define PB push_back\n#define MP make_pair\n\n#define FOR(it,a) for (__typeof((a).begin()) it=(a).begin();it!=(a).end();++it)\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n\nconst double pi     =   acos(-1.0);\nconst double eps    =   1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\n\ninline int sign(double x)\n{\n    if (x<-eps) return -1;\n    return x>eps;\n}\n\nstruct Tpoint\n{\n    double x,y;\n    Tpoint(){}\n    Tpoint(double x,double y):x(x),y(y){}\n    inline double norm(){return sqrt(x*x+y*y);}\n    inline void rotate(double ang)\n    {\n        double co=cos(ang),si=sin(ang);\n        double tx=x,ty=y;\n        x=tx*co-ty*si;\n        y=tx*si+ty*co;\n    }\n};\n\ninline Tpoint operator +(const Tpoint &a,const Tpoint &b){return Tpoint(a.x+b.x,a.y+b.y);}\ninline Tpoint operator -(const Tpoint &a,const Tpoint &b){return Tpoint(a.x-b.x,a.y-b.y);}\ninline Tpoint operator *(const Tpoint &a,const double &b){return Tpoint(a.x*b,a.y*b);}\ninline Tpoint operator /(const Tpoint &a,const double &b){return Tpoint(a.x/b,a.y/b);}\ninline double det(const Tpoint &a,const Tpoint &b){return a.x*b.y-a.y*b.x;}\ninline double dot(const Tpoint &a,const Tpoint &b){return a.x*b.x+a.y*b.y;}\n//================================\n\nconst int maxn  =   100005;\n\nint delta[maxn];\n\nint main()\n{\n    int n,k;\n    scanf(""%d%d"",&n,&k);\n    VI a;\n    for (int i=0,x;i<n;++i){\n        scanf(""%d"",&x);\n        if (a.size()==0 || x!=a.back()){\n            a.PB(x);\n        }\n    }\n    \n    int basic=(int)a.size()-1;\n    if (a.size()>1){\n        ++delta[a[0]];\n        ++delta[a[a.size()-1]];\n    }\n    for (int i=1;i+1<a.size();++i){\n        if (a[i-1]==a[i+1]){\n            delta[a[i]]+=2;\n        }else{\n            delta[a[i]]+=1;\n        }\n    }\n    int ans=1000000000,choice=0;\n    for (int i=1;i<=k;++i){\n        if (ans>basic-delta[i]){\n            ans=basic-delta[i];\n            choice=i;\n        }\n    }\n    printf(""%d\\n"",choice);\n    \n    return 0;\n}\n']","[1, 0, 0, 0, 0]",1600,Now you should iterate over all maximal be inclusion segments and find improvement for every of them After that you should group all segments by genre and calculate sum of improvements inside every group Answer will be number of genre of group that has maximal total improvement if there are many of them you should chose minimal number of genre You can implement this solution in in Authors are MikeMirzayanov Gerald Ripatti 
Vladislav has a binary square grid of n times n cells A triangle or a square is drawn on the grid with symbols texttt 1 As he is too busy being cool he asks you to tell him which shape is drawn on the grid A is a shape consisting of k k 1 consecutive rows where the i th row has 2 cdot i 1 consecutive characters texttt 1 and the central s are located in one column An upside down triangle is also considered a valid triangle but not rotated by 90 degrees A is a shape consisting of k k 1 consecutive rows where the i th row has k consecutive characters texttt 1 which are positioned at an equal distance from the left edge of the grid For the given grid determine the type of shape that is drawn on it ,"['#include<bits/stdc++.h>\nusing namespace std;\nchar g[15][15];\n\nvoid solve()\n{\n\tint n;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tcin>>g[i][j];\n\t\t}\n\t}\n\tint sx=110,sy=110,ex=0,ey=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(g[i][j]==\'1\')\n\t\t\t{\n\t\t\t\tsx=min(sx,i);\n\t\t\t\tsy=min(sy,j);\n\t\t\t\tex=max(ex,i);\n\t\t\t\tey=max(ey,j);\n\t\t\t}\n\t\t}\n\t}\n//\tcout<<sx<<"" ""<<ex<<"" ""<<sy<<"" ""<<ey;\n\tfor(int i=sx;i<=ex;i++)\n\t{\n\t\tfor(int j=sy;j<=ey;j++)\n\t\t{\n\t\t\tif(g[i][j]==\'0\')\n\t\t\t{\n\t\t\t\tcout<<""TRIANGLE\\n"";\n\t\t\t\treturn ;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<""SQUARE\\n"";\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);\n\tint t;\n\tcin>>t;\n\twhile(t--)\n\t{\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}']","[0, 0, 1, 0, 0]",800,Let s draw some examples on paper and notice a pattern What we notice is that in the case of a triangle there is a row with exactly one but not a square So this is what we need to check Iterate through all rows and check if there is a row with exactly one If it was the case for at least one then the answer is and otherwise Check if any square has sum If it does then we must be at one of the sloped sides of a triangle so the answer is If there is no such square the answer is Why does it work 
Happy PMP is freshman and he is learning about algorithmic problems He enjoys playing algorithmic games a lot One of the seniors gave Happy PMP a nice game He is given two permutations of numbers through and is asked to convert the first one to the second In one move he can remove the last number from the permutation of numbers and inserts it back in an arbitrary position He can either insert last number between any two consecutive numbers or he can place it at the beginning of the permutation Happy PMP has an algorithm that solves the problem But it is not fast enough He wants to know the minimum number of moves to convert the first permutation to the second ,"['#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<string>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint a[201000],b[201000];\nint c[201000];\nint main(){\n    int n,i,j;\n    scanf(""%d"",&n);\n    for(i=1;i<=n;i++){\n        scanf(""%d"",&a[i]);\n\n    }\n    for(i=1;i<=n;i++){\n        scanf(""%d"",&b[i]);\n        c[b[i]]=i;\n    }\n    for(i=1;i<=n;i++)a[i]=c[a[i]];\n    a[0]=0;\n    for(i=1;i<=n;i++)if(a[i]<a[i-1])break;\n    printf(""%d\\n"",n+1-i);\n}\n\n']","[1, 0, 0, 0, 0]",1500,It is easy to see that if we replace each number in the first permutation with position of that number in the second permutation the problem reduces to sorting the first permutation Each time we take a number from the end of array we can postpone its insertion until we know the most suitable position for insertion Note that it is not good to insert a number and take it again as we could make a better decision first time we took the number So as long as the remainder of the array is not in increasing order we should take more numbers from the end But as soon as you have an increasing subsequence you can insert the numbers you have taken to make the array sorted Therefore to solve the problem we find the largest i such the numbers from 1 to i are in increasing order The answer would be n i 
There was an electronic store heist last night All keyboards which were in the store yesterday were numbered in ascending order from some integer number x For example if x 4 and there were 3 keyboards in the store then the devices had indices 4 5 and 6 and if x 10 and there were 7 of them then the keyboards had indices 10 11 12 13 14 15 and 16 After the heist only n keyboards remain and they have indices a 1 a 2 dots a n Calculate the minimum possible number of keyboards that have been stolen The staff remember neither x nor the number of keyboards in the store before the heist ,"['#include<bits/stdc++.h>\nusing namespace std;\nint a[100009];\nmain(){\n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        cin >> a[i];\n    }\n    sort(a, a+n);\n    cout << (a[n-1] - a[0] + 1)-n << endl;\n\n}\n']","[1, 0, 1, 0, 0]",800,Let the minimal number from the given numbers and the maximal So we consider that and were minimal and maximal keyboard numbers before the heist All given numbers are distinct so the answer is initial number of the keyboards is minus the remaining number of keyboards 
New Year is coming Vasya has prepared a New Year s verse and wants to recite it in front of Santa Claus Vasya s verse contains n parts It takes a i seconds to recite the i th part Vasya can t change the order of parts in the verse firstly he recites the part which takes a 1 seconds secondly the part which takes a 2 seconds and so on After reciting the verse Vasya will get the number of presents equal to the number of parts he fully recited Vasya can skip at most one part of the verse while reciting it if he skips more than one part then Santa will definitely notice it Santa will listen to Vasya s verse for no more than s seconds For example if s 10 a 100 9 1 1 and Vasya skips the first part of verse then he gets two presents Note that it is possible to recite the whole verse if there is enough time Determine which part Vasya needs to skip to obtain the maximum possible number of gifts If Vasya shouldn t skip anything print If there are multiple answers print any of them You have to process t test cases ,"['#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nint main() {\n#ifdef iq\n  freopen(""a.in"", ""r"", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  auto solve = [&] () {\n    int n, s;\n    cin >> n >> s;\n    vector <int> a(n);\n    vector <ll> pref(n);\n    ll t = 0;\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n      t += a[i];\n      pref[i] = t;\n    }\n    int ans = -1;\n    int pos = -1;\n    for (int skip = 0; skip <= n; skip++) {\n      auto cost = [&] (int i) {\n        if (skip <= i) {\n          return pref[i] - a[skip];\n        } else {\n          return pref[i];\n        }\n      };\n      int l = -1, r = n;\n      while (l < r - 1) {\n        int m = (l + r) / 2;\n        if (cost(m) <= s) {\n          l = m;\n        } else {\n          r = m;\n        }\n      }\n      int was = ans;\n      ans = max(ans, l + 1 - (skip <= l));\n      if (ans != was) pos = skip;\n    }\n    if (pos == n) {\n      cout << 0 << \'\\n\';\n    } else {\n      cout << pos + 1 << \'\\n\';\n    }\n  };\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n']","[0, 0, 1, 0, 0]",1300,If then answer is Otherwise let s find we minimum index such that It s useless to skip a part because Vasya just has not time to recite previous part it s change nothing So he has to skip a part And among such parts it s beneficial to skip part with maximum value of 
A string is called if it does not contain any characters other than and A bracket sequence is called shortly RBS if it is possible to obtain correct arithmetic expression by inserting characters and into this sequence For example and are RBS and and are not We can see that each opening bracket in RBS is paired with some closing bracket and using this fact we can define of the RBS as maximum number of bracket pairs such that the 2 nd pair lies inside the 1 st one the 3 rd one inside the 2 nd one and so on For example nesting depth of is 0 is 1 and is 3 Now you are given RBS s of even length n You should color each bracket of s into one of two colors red or blue Bracket sequence r consisting only of red brackets should be RBS and bracket sequence consisting only of blue brackets b should be RBS Any of them can be empty You are not allowed to reorder characters in s r or b No brackets can be left uncolored Among all possible variants you should choose one that of r s and b s nesting depth If there are multiple solutions you can print any of them ,"['//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, ""/stack:200000000"")\n#pragma GCC optimize(""O3"")\n//~ #pragma GCC optimize(""Ofast"")\n//~ #pragma GCC target(""sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native"")\n//~ #pragma GCC optimize(""unroll-loops"")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << ""("" << d.first << "", "" << d.second << "")"";\n}\nsim dor(rge<c> d) {\n  *this << ""["";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << "", "" + 2 * (it == d.b) << *it;\n  ris << ""]"";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) "" ["" << #__VA_ARGS__ "": "" << (__VA_ARGS__) << ""] ""\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nchar wcz[nax];\n\nint b;\n\nint main()\n{\n\tscanf(""%d"", &n);\n\tscanf(""%s"", wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (wcz[i]==\'(\')\n\t\t{\n\t\t\tb++;\n\t\t\tprintf(""%d"", (b&1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(""%d"", (b&1));\n\t\t\tb--;\n\t\t}\n\t}\n\tprintf(""\\n"");\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",1500,Let be nested depth of RBS There is an interesting fact that From the other side we can always reach equation using some approaches Let s look at prefix of length of string Let be number of opening bracket in the prefix number of closing brackets Then we can define balance of the th prefix of as The author s approach is next Let s define of pair of brackets matched in natural way as where is position of opening bracket of this pair Then we will color in red all pairs with even level and in blue with odd level Proof of It can be shown that and exists such that After any coloring of we can define number of opening closing red blue brackets of th prefix of as and respectively Since and then Finally 
Little C loves number very much He loves all things about it Now he has a positive integer n He wants to split n into 3 positive integers a b c such that a b c n and none of the 3 integers is a multiple of 3 Help him to find a solution ,"[""#include <bits/stdc++.h>\nusing namespace std;int n;\nint main()\n{\n\tcin>>n;if(n%3==0) cout<<1<<' '<<1<<' '<<n-2<<endl;else cout<<1<<' '<<2<<' '<<n-3<<endl;\n}""]","[0, 1, 0, 0, 0]",800,This problem is set by Little C at first and it s a problem about Tic Tac Toe for D2B But after discussion with the coordinator we thought it s just a implement problem and not so interesting So I came up with a new problem as you saw Solution If n 2 is not a multiple of 3 a 1 b 1 c n 2 is OK Otherwise a 1 b 2 c n 3 is OK 
As Famil Door s birthday is coming some of his friends like Gabi decided to buy a present for him His friends are going to buy a string consisted of round brackets since Famil Door loves string of brackets of length more than any other strings The sequence of round brackets is called if and only if the total number of opening brackets is equal to the total number of closing brackets for any prefix of the sequence the number of opening brackets is greater or equal than the number of closing brackets Gabi bought a string of length and want to complete it to obtain a valid sequence of brackets of length He is going to pick some strings and consisting of round brackets and merge them in a string that is add the string at the beginning of the string and string at the end of the string Now he wonders how many of strings and exists such that the string is a valid sequence of round brackets As this number may be pretty large he wants to calculate it modulo ,"['#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define pb push_back\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define pii pair < int, int >\n#define pll pair < ll, ll >\n#define all(s) s.begin(), s.end()\n#define sz(s) (int) s.size()\n#define vi vector < int >\n\nconst int inf = (int)1e9;\nconst int mod = (int) 1e9 + 7;\n\nint n, m;\nstring s;\nvector < int > g;\nint dp[4000][4000];\n\n\nvoid add(int &v, int u){\n\tv += u;\n\tif(v >= mod) v -= mod;\n}\n\n\nint main () {\n    #ifdef LOCAL\n    freopen (""a.in"", ""r"", stdin);\n    freopen (""a.out"", ""w"", stdout);\n    #endif\n    cin>> n >> m;\n    cin >> s;\n    int x = 0;\n    for(int i = 0; i < m; i++){\n    \tif(s[i] == \'(\'){\n    \t\tg.pb(1);\n    \t}\n    \telse{\n    \t\tif(g.size() > 0){\n    \t\t\tg.pop_back();\n    \t\t}\n    \t\telse {\n    \t\t\tx++;\n    \t\t}\n    \t}\n    }\n    int y = (int) g.size();\n    if(x+y + m > n){\n    \tcout << 0 << endl;\n    \treturn 0;\n    }\n    dp[0][0] = 1;\n    for(int i = 0; i < 3000; i++){\n    \tfor(int j = 0; j <= i; j++){\n    \t\tif(j > 0) add(dp[i+1][j-1], dp[i][j]);\n    \t\tadd(dp[i+1][j+1], dp[i][j]);\n    \t}\n    }\n    int tt = n - m;\n    int ans = 0;\n    for(int len = 0; len <= tt; len++){\n    \tint t = tt - len;\n    \tfor(int j = x; j <= len && j - x + y <= t; j++){\n    \t\tadd(ans, dp[len][j] * 1ll * dp[t][j - x + y] % mod);\n    \t}\n    }\n    cout << ans << endl;\n    \n    \n\n\n    #ifdef LOCAL\n    cerr << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\\n"";\n    #endif\n    return 0;\n}\n\n\n']","[0, 0, 0, 1, 0]",2000,This problem can be solved with dynamic programming Calculate How many sequences of brackets of length has balance and intermediate balance never goes below zero They form a prefix of a valid sequence of brackets For the given sequence of length calculate the resulting balance and the minimum balance Try the length of the sequence added at the beginning and its balance If then add to the answer Time complexity C Solution 
Let s define a multiplication operation between a string a and a positive integer x a cdot x is the string that is a result of writing x copies of a one after another For example cdot 2 cdot 5 A string a is divisible by another string b if there exists an integer x such that b cdot x a For example is divisible by but is not divisible by or LCM of two strings s and t defined as LCM s t is the shortest non empty string that is divisible by both s and t You are given two strings s and t Find LCM s t or report that it does not exist It can be shown that if LCM s t exists it is unique ,"['#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        std::string a, b;\n        std::cin >> a >> b;\n        int d = std::gcd(a.length(), b.length());\n        std::string a1, b1;\n        for (int i = 0; i < int(b.length()) / d; i++) {\n            a1 += a;\n        }\n        for (int i = 0; i < int(a.length()) / d; i++) {\n            b1 += b;\n        }\n        if (a1 == b1) {\n            std::cout << a1 << ""\\n"";\n        } else {\n            std::cout << ""-1\\n"";\n        }\n    }\n    return 0;\n}']","[0, 1, 0, 0, 0]",1000,We should notice that if some string is a multiple of string then is a multiple of This fact leads us to the conclusion that should be a common multiple of and Since we want to minimize the length of the string then its length is So we have to check that copies of the string equal to copies of the string If such strings are equal print them otherwise there is no solution 
Petya is having a party soon and he has decided to invite his n friends He wants to make invitations in the form of origami For each invitation he needs red sheets green sheets and blue sheets The store sells an infinite number of notebooks of each color but each notebook consists of only color with k sheets That is each notebook contains k sheets of either red green or blue Find the minimum number of notebooks that Petya needs to buy to invite all n of his friends ,"['#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\ntypedef long long LL;\n\nint main(){\n  int n, k;\n  scanf(""%d%d"", &n, &k);\n  printf(""%d\\n"", (n * 2 + k - 1) / k + (n * 5 + k - 1) / k + (n * 8 + k - 1) / k);\n  return 0;\n}']","[0, 1, 0, 0, 0]",800,Let s calculate how many notebooks we need for each color separately and the answer obviously will be their sum We need red sheets green sheets and blue sheets So we need notebooks with red sheets and notebooks with of green sheets and blue sheets respectively 
Market stalls now have the long awaited game The Colder Scrools V Nvodsk The game turned out to be difficult as hell and most students can t complete the last quest We don t go to Nvodsk That threatened winter exams The rector already started to wonder whether he should postpone the winter exams till April in fact he wanted to complete the quest himself But all of a sudden a stranger appeared at the door of his office Good afternoon My name is Chuck and I solve any problems he said And here they are sitting side by side but still they can t complete the mission The thing is to kill the final boss one should prove one s perfect skills in the art of managing letters One should be a real magician to do that And can you imagine what happens when magicians start competing But let s put it more formally you are given a string and a set of integers You are allowed to choose any substring that is a palindrome and delete it At that we receive some number of points equal to where is the length of the deleted palindrome For some 1 which means that deleting palindrome strings of such length is After a substring is deleted the remaining part shifts together that is at no moment of time the string has gaps The process is repeated while the string has at least one palindrome substring that can be deleted All gained points are summed up Determine what maximum number of points can be earned Oh said Chuck raising from the chair I used to love deleting palindromes just like you but one day I took an arrow in the Knee ,"['#pragma comment (linker, ""/STACK:200000000"")\n#define _SECURE_SCL 0\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <stack>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int INF = (int) 1E8;\nconst int64 INF64 = (int64) 1E18;\nconst double EPS = 1E-9;\nconst double PI = acos((double)0) * 2;\n\n#define forn(i,n)  for (int i=0; i<int(n); ++i)\n#define ford(i,n)  for (int i=int(n)-1; i>=0; --i)\n#define fore(i,l,n)  for (int i=int(l); i<int(n); ++i)\n#define all(a)  a.begin(), a.end()\n#define fs  first\n#define sc  second\n#define pb  push_back\n#define mp  make_pair\n\n\nconst int MAXN = 160;\n\n\nint n, cost[MAXN];\nstring s;\n\n\nbool read() {\n\tif (! (cin >> n))\n\t\treturn false;\n\tforn(i,n) {\n\t\tcin >> cost[i+1];\n\t\tif (cost[i+1] == -1)\n\t\t\tcost[i+1] = -INF;\n\t}\n\tcin >> s;\n\treturn true;\n}\n\n\nint d[MAXN][MAXN][MAXN];\nbool u[MAXN][MAXN][MAXN];\n\nint get_d (int l, int r, int len) {\n\tif (l > r)  return cost[len];\n\tif (l == r)  return max (cost[len] + cost[1], cost[len+1]);\n\n\tint & my = d[l][r][len];\n\tbool & myu = u[l][r][len];\n\tif (myu)  return my;\n\tmyu = true;\n\tmy = -INF;\n\n\tif (len != 0)\n\t\tmy = max (my, cost[len] + get_d (l, r, 0));\n\tfore(i,l,r)\n\t\tmy = max (my, get_d (l, i, 0) + get_d (i+1, r, len));\n\tfore(i,l+1,r+1)\n\t\tmy = max (my, get_d (i, r, 0) + get_d (l, i-1, len));\n\tfore(i,l,r+1)\n\t\tmy = max (my, get_d (l, i-1, 0) + cost[len+1] + get_d (i+1, r, 0));\n\n\tif (s[l] == s[r])\n\t\tmy = max (my, get_d (l+1, r-1, len+2));\n\n\treturn my;\n}\n\nint d2[MAXN];\n\nvoid solve() {\n\tmemset (u, 0, sizeof u);\n\tint x = get_d (0, n-1, 0);\n\tforn(i,n) {\n\t\td2[i] = i ? d2[i-1] : 0;\n\t\tforn(j,i+1)\n\t\t\td2[i] = max (d2[i], get_d (j, i, 0) + (j ? d2[j-1] : 0));\n\t}\n\n\tcout << d2[n-1] << endl;\n}\n\n\nint main() {\n#ifdef SU2_PROJ\n\tfreopen (""input.txt"", ""rt"", stdin);\n\tfreopen (""output.txt"", ""wt"", stdout);\n\twhile (read())\n\t\tsolve();\n#else\n\tif (!read())  throw;\n\tsolve();\n#endif\n}']","[0, 0, 0, 1, 0]",2600,In this problem you have to use dynamic programming For our convenience we will calulate three type of values best result player can achieve on the segment best result player can achieve on the segment from if he fully destroys it best result player can achieve on the segment from and remain the palindrome of length and only it Now solution Let s look which move will be the last This will be removing the palindrome of length and What is the best result we can achieve Either we will destroy all subtring from to either there exists a letter which we did not touch That means that all our moves lies fully to the left or fully to the rigth to that position So or for some two special cases which is easy to solve without any dynamic In other case let s take a look on the left most position It either will lie in the result string or not If not then let s find the first position which does Denote it as Everything what lies to the left need to be fully deleted So the answer is for Similarly for the right most letters If it does not lies in the result string we remove everything to the right and our result is for The last option both left most and rigth most letters lies in the result string It is possible only if So our result is only if 
Ali is Hamed s little brother and tomorrow is his birthday Hamed wants his brother to earn his gift so he gave him a hard programming problem and told him if he can successfully solve it he ll get him a brand new laptop Ali is not yet a very talented programmer like Hamed and although he usually doesn t cheat but this time is an exception It s about a brand new laptop So he decided to secretly seek help from you Please solve this problem for Ali An vertex weighted rooted tree is given Vertex number is a root of the tree We define as the sum of edges weights on the shortest path between vertices and Specifically we define Also let s define for each vertex as a set containing all vertices such that Function is then defined using the following formula The goal is to calculate for each of the given pair of vertices As the answer can be rather large it s enough to print it modulo ,"['#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <memory.h>\n#include <cassert>\n\nusing namespace std;\n\nconst int md = 1000000007;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) {\n    a -= md;\n  }\n}\n\ninline int mul(int a, int b) {\n  return (long long)a * b % md;\n}\n\nconst int N = 400010;\n\nvector < pair <int, int> > g[N];\nint cnt[N], sum[N], sumsq[N];\nint tin[N], tout[N], TIME = 0;\nint depth[N];\nint pv[N];\nconst int LOG = 20;\nint pr[N][LOG];\n\nvoid dfs(int v, int pr) {\n  tin[v] = ++TIME;\n  int sz = g[v].size();\n  cnt[v] = 1;\n  sum[v] = 0;\n  sumsq[v] = 0;\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (u == pr) {\n      continue;\n    }\n    pv[u] = v;\n    int len = g[v][j].second;\n    depth[u] = depth[v];\n    add(depth[u], len);\n    dfs(u, v);\n    add(cnt[v], cnt[u]);\n    add(sum[v], sum[u]);\n    add(sum[v], mul(cnt[u], len));\n    add(sumsq[v], sumsq[u]);\n    add(sumsq[v], mul(cnt[u], mul(len, len)));\n    add(sumsq[v], mul(mul(2, len), sum[u]));\n  }\n  tout[v] = ++TIME;\n}\n\nbool anc(int x, int y) {\n  return (tin[x] <= tin[y] && tout[y] <= tout[x]);\n}\n\nint lca(int x, int y) {\n  if (anc(x, y)) return x;\n  for (int j = LOG - 1; j >= 0; j--)\n    if (!anc(pr[x][j], y)) x = pr[x][j];\n  return pv[x];\n}\n\nint ups[N];\nint up[N];\nint n;\n\nvoid get_up(int v, int pr) {\n  int sz = g[v].size();\n  for (int j = 0; j < sz; j++) {\n    int u = g[v][j].first;\n    if (u == pr) {\n      continue;\n    }\n    int len = g[v][j].second;\n    int no_s = sum[v];\n    add(no_s, md - sum[u]);\n    add(no_s, md - mul(cnt[u], len));\n    add(no_s, ups[v]);\n    int no_sq = sumsq[v];\n    add(no_sq, md - sumsq[u]);\n    add(no_sq, md - mul(cnt[u], mul(len, len)));\n    add(no_sq, md - mul(mul(2, len), sum[u]));\n    up[u] = up[v];\n    add(up[u], no_sq);\n    add(up[u], mul(n - cnt[u], mul(len, len)));\n    add(up[u], mul(mul(2, len), no_s));\n    ups[u] = ups[v];\n    int no_sss = sum[v];\n    add(no_sss, md - sum[u]);\n    add(no_sss, md - mul(cnt[u], len));\n    add(ups[u], no_sss);\n    add(ups[u], mul(n - cnt[u], len));\n    get_up(u, v);\n  }\n}\n\nint res[N];\n\nint main() {\n  scanf(""%d"", &n);\n  for (int i = 0; i < n; i++) {\n    g[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int foo, bar, len;\n    scanf(""%d %d %d"", &foo, &bar, &len);\n    foo--; bar--;\n    g[foo].push_back(make_pair(bar, len));\n    g[bar].push_back(make_pair(foo, len));\n  }\n  depth[0] = 0;\n  dfs(0, -1);\n  for (int i = 0; i < n; i++) pr[i][0] = pv[i];\n  for (int j = 1; j < LOG; j++)\n    for (int i = 0; i < n; i++) pr[i][j] = pr[pr[i][j - 1]][j - 1];\n  ups[0] = 0;\n  up[0] = 0;\n  get_up(0, -1);\n  for (int i = 0; i < n; i++) {\n    res[i] = sumsq[i];\n    add(res[i], up[i]);\n  }\n  int tt;\n  scanf(""%d"", &tt);\n  while (tt--) {\n    int u, v;\n    scanf(""%d %d"", &u, &v);\n    u--; v--;\n    if (!anc(v, u)) {\n      int len = depth[v];\n      add(len, depth[u]);\n      int z = lca(v, u);\n      add(len, md - mul(2, depth[z]));\n      int good = sumsq[v];\n      add(good, mul(cnt[v], mul(len, len)));\n      add(good, mul(mul(2, len), sum[v]));\n      good = mul(good, 2);\n      add(good, md - res[u]);\n      printf(""%d\\n"", good);\n    } else {\n      int len = depth[u];\n      add(len, md - depth[v]);\n      int good = up[v];\n      add(good, mul(n - cnt[v], mul(len, len)));\n      add(good, mul(mul(2, len), ups[v]));\n      good = (res[u] - good + md) % md;\n      good = mul(good, 2);\n      add(good, md - res[u]);\n      printf(""%d\\n"", good);\n    }\n  }\n  return 0;\n}\n']","[0, 0, 0, 1, 1]",2700,We solve this problem by answering queries offline We ll first store in each vertex number of vertices such as for which we must calculate starting from the root We ll keep two arrays and Suppose we re at vertex right now then equals and equal Having these two arrays when moving from vertex to a child with an edge with weight one can note that for all s inside subtree of decreases by and all other s gets increased by Knowing this fact one can also update array as well To calculate it s enough to be able to calculate sum of s for all inside subtree of Handling each of these operations is a well known problem and is possible using a segment tree Overall complexity is There is an online solution using dynamic programming as well 
There were n types of swords in the theater basement which had been used during the plays Moreover there were x swords of each type y people have broken into the theater basement and each of them has taken exactly z swords of some Note that different people might have taken different types of swords Note that the values x y and z are unknown for you The next morning the director of the theater discovers the loss He counts all swords exactly a i swords of the i th type are left untouched The director has no clue about the initial number of swords of each type in the basement the number of people who have broken into the basement and how many swords each of them have taken For example if n 3 a 3 12 6 then one of the possible situations is x 12 y 5 and z 3 Then the first three people took swords of the first type and the other two people took swords of the third type Note that you don t know values x y and z beforehand but know values of n and a Thus he seeks for your help Determine the number of people y which could have broken into the theater basement and the number of swords z each of them has taken ,"['#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 2e5 + 10;\nint a[N];\n\nint gcd(int A, int B) {\n  return B ? gcd(B, A % B) : A;\n}\n\nint main() {\n  int n;\n  scanf(""%d"", &n);\n  ll sum = 0;\n  int maxn = 0;\n  for(int i = 1; i <= n; ++i) {  \n    scanf(""%d"", &a[i]);\n    sum += a[i];\n    maxn = max(maxn, a[i]);\n  }\n  int pos = 0;\n  for(int i = 1; i <= n; ++i) {\n    pos = gcd(pos, maxn - a[i]);\n  }\n  printf(""%lld %d\\n"", (1ll * maxn * n - sum) / pos, pos);\n  return 0;\n}']","[0, 1, 0, 0, 0]",1300,Firstly let s notice that for the fixed value of our problem is reduced to the following we are given numbers We need to choose such values that And among all such values we need to choose values in a way to minimize And the sum of is Of course for the fixed value the minimum sum of can be only one Let s start with It is obvious that if the maximum value in the array is the value equals for Assume that each from to has some divisor Then if we multiply by and divide each by the answer will only become better How to calculate this value of fast We can see that this value equals to And it can be proven that this value of is always optimal and we can easily determine for such Time complexity 
The Little Elephant is playing with the Cartesian coordinates system Most of all he likes playing with integer points The Little Elephant defines an integer point as a pair of integers such that and Thus the Little Elephant knows only distinct integer points The Little Elephant wants to paint a triangle with vertexes at integer points the triangle s area must be a positive integer For that he needs to find the number of groups of three points that form such triangle At that the order of points in a group matters that is the group of three points isn t equal to the group Help the Little Elephant to find the number of groups of three integer points that form a nondegenerate triangle with integer area ,"['// @author peter50216\n// #includes {{{\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<assert.h>\n#include<stdarg.h>\n#include<time.h>\n#include<limits.h>\n#include<ctype.h>\n#include<string>\n#include<map>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n// }}}\n\nconst int mod=1000000007;\nint cnt[2][2];\nint ch[3][2];\ninline bool ver(){\n    int r=(ch[0][0]+ch[1][0]+ch[2][0])*(ch[0][1]+ch[1][1]+ch[2][1]);\n    for(int i=0;i<3;i++)r+=ch[i][0]*ch[i][1];\n    return r%2==0;\n}\ninline int add(int a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n    return a;\n}\ninline int dfs(int np){\n    if(np==3){\n        if(ver())return 1;\n        return 0;\n    }\n    long long ret=0;\n    for(ch[np][0]=0;ch[np][0]<=1;ch[np][0]++){  \n        for(ch[np][1]=0;ch[np][1]<=1;ch[np][1]++){\n            int a=ch[np][0],b=ch[np][1];\n            if(cnt[a][b]==0)continue;\n            long long k=cnt[a][b];\n            cnt[a][b]--;\n            ret=(ret+dfs(np+1)*k)%mod;\n            cnt[a][b]++;\n        }\n    }\n    return ret;\n}\nint gcds[4010][4010];\nint cc[4010][4010];\ninline int gcd(int a,int b){if(b)while((a%=b)&&(b%=a));return a+b;}\ninline int solve(int w,int h){\n    cnt[0][0]=((w/2+1ll)*(h/2+1ll))%mod;\n    cnt[0][1]=((w/2+1ll)*((h+1ll)/2))%mod;\n    cnt[1][0]=(((w+1ll)/2)*(h/2+1ll))%mod;\n    cnt[1][1]=(((w+1ll)/2)*((h+1ll)/2))%mod;\n    int ans=dfs(0);\n    for(int i=1;i<=4000;i++){\n        gcds[i][0]=i;\n        for(int j=1;j<=4000;j++){\n            gcds[i][j]=gcds[i][j-1]+gcd(i,j);\n        }\n    }\n    for(int i=0;i<=4000;i++){\n        cc[i][0]=0;\n        for(int j=1;j<=4000;j++){\n            cc[i][j]=add(cc[i][j-1],gcds[j][i]-i-1);\n        }\n    }\n    int s=0;\n    for(int i=0;i<=w;i++){\n        for(int j=0;j<=h;j++){\n            s=add(s,cc[h-j][w-i]);\n            s=add(s,cc[w-i][j]);\n        }\n    }\n    s=(s*6ll)%mod;\n    ans-=s;\n    if(ans<0)ans+=mod;\n    return ans;\n}\nint main(){\n    int w,h;\n    scanf(""%d%d"",&w,&h);\n    printf(""%d\\n"",solve(w,h));\n}\n// vim: fdm=marker:commentstring=\\ \\""\\ %s:nowrap:autoread\n\n']","[0, 1, 0, 0, 0]",2500,Let iterate all possible points that as we consider must be the first point Let it be Let the second and the third points be and Then the doubled area is We need this number to be even and nonzero For first we will find the number of groups of points that are even after that just subtract the number of groups with area equal to zero For the first subproblem we need to rewrite our formula It is equal to Since we know and and we just need to check parity we can try all possible values of parity of and let it be and respectively And check whether they will form a after multiplications and taking modulo If it froms a then add to the answer value where is equal to the number of integers between and inclusve that modulo are equal is the same but in range Now we need to subtract bad groups the ones that has the area equal to zero This means that they will either form a dot or a segment If it is segment we can just iterate and instead of all 4 coordinates Then the number of such segments on the plane will be Also for counting the number of triples of points on the segment you need to find the number of integer coordinates on the segment It is well know problem and the answer is This gives us with some simple optimizations and solution 
Farmer John is hosting a tennis tournament with his cows Each cow has a skill level and no two cows having the same skill level Every cow plays every other cow exactly once in the tournament and each cow beats every cow with skill level lower than its own However Farmer John thinks the tournament will be demoralizing for the weakest cows who lose most or all of their matches so he wants to flip some of the results In particular at different instances he will take two integers and flip all the results between cows with skill level between and inclusive That is for any pair he will change the result of the match on the final scoreboard so if won the match the scoreboard will now display that won the match and vice versa It is possible that Farmer John will change the result of a match multiple times It is not guaranteed that and are equal to some cow s skill level Farmer John wants to determine how balanced he made the tournament results look In particular he wants to count the number of triples of cows for which the final leaderboard shows that cow beats cow cow beats cow and cow beats cow Help him determine this number Note that two triples are considered different if they do not contain the same set of cows i e if there is a cow in one triple that is not in the other ,"['#pragma comment(linker, ""/STACK:512000000"")\n#define _CRT_SECURE_NO_DEPRECATE\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <list>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <queue>\nusing namespace std;\ntemplate<class T> inline T sqr(T x) { return x * x; }\ntemplate<class T> inline string tostr(const T & x) { stringstream ss; ss << x; return ss.str(); }\ntypedef long long lng;\ntypedef unsigned long long ulng;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef long double ld;\ntypedef pair<int, int> PII;\ntypedef pair<PII, int> PIII;\ntypedef pair<lng, lng> PLL;\ntypedef pair<lng, int> PLI;\ntypedef pair<ld, ld> PDD;\n#define left asdleft\n#define right asdright\n#define link asdlink\n#define unlink asdunlink\n#define next asdnext\n#define prev asdprev\n#define y0 asdy0\n#define y1 asdy1\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define clr(ar,val) memset(ar, val, sizeof(ar))\n#define istr stringstream\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define X first\n#define Y second\nconst double EPS = 1e-6;\nconst int INF = 1000*1000*1000;\nconst char CINF = 102;\nconst lng LINF = INF * 1ll * INF;\nconst ld PI = 3.1415926535897932384626433832795;\n\nint tree[1100000];\nint add[1100000];\n\nvoid flip(int l,int r,int a,int b,int k){\n\tif(r<=a || l>=b)\n\t\treturn;\n\tif(l<=a && r>=b){\n\t\ttree[k]=b-a-tree[k];\n\t\tadd[k]^=1;\n\t\treturn;\n\t}\n\tint c=(a+b)/2;\n\tflip(l,r,a,c,k*2+1);\n\tflip(l,r,c,b,k*2+2);\n\ttree[k]=tree[k*2+1]+tree[k*2+2];\n\tif(add[k])\n\t\ttree[k]=b-a-tree[k];\n}\n\nint getsum(int l,int r,int a,int b,int k){\n\tl=max(l,a);\n\tr=min(r,b);\n\tif(r<=l)\n\t\treturn 0;\n\tif(l==a && r==b)\n\t\treturn tree[k];\n\tint c=(a+b)/2;\n\tint t=getsum(l,r,a,c,k*2+1)+getsum(l,r,c,b,k*2+2);\n\tif(add[k])\n\t\tt=r-l-t;\n\treturn t;\n}\n\nvector<int> qu1[110000];\nvector<int> qu2[110000];\n\nint main() {\n#ifdef __ASD__\n\tfreopen(""input.txt"", ""r"", stdin); freopen(""output.txt"", ""w"", stdout);\n#endif\n\n\tios_base::sync_with_stdio(false);\n\t\n\tint n,k;\n\tcin>>n>>k;\n\tvector<PII> qus(k);\n\tvector<int> vals(n);\n\tforn(i,n){\n\t\tcin>>vals[i];\n\t}\n\tsort(all(vals));\n\tforn(i,k){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta=lower_bound(all(vals),a)-vals.begin();\n\t\tb=upper_bound(all(vals),b)-vals.begin();\n\t\tqu1[a].pb(b);\n\t\tqu2[b].pb(a);\n\t}\n\t\n\tlng res=1LL*n*(n-1)*(n-2)/6;\n\tforn(i,n){\n\t\tforv(j,qu1[i]){\n\t\t\tflip(i,qu1[i][j],0,n,0);\n\t\t}\n\t\tforv(j,qu2[i]){\n\t\t\tflip(qu2[i][j],i,0,n,0);\n\t\t}\n\t\tint t1=getsum(i+1,n,0,n,0);\n\t\tint t2=getsum(0,i,0,n,0);\n\t\tint s=(n-i-1)-t1+t2;\n\t\tlng t=1LL*s*(s-1)/2;\n\t\t//cout<<s<<\' \'<<t<<endl;\n\t\tres-=t;\n\t}\n\t\n\tcout<<res;\n\n\treturn 0;\n}\n']","[0, 1, 0, 0, 1]",2800,Here is a full solution to Codeforces 174 div 1 E I find this problem beautiful The first thing to note is that if you interpret the problem as a graph you can compute the answer if you have the degrees i e number of wins of every cow Call three cows unbalanced if the is one cow that beats the other two Note that every three cows is either unbalanced or balanced there are no other configurations of three cows Thus So to count the number of balanced it suffices to count the number of unbalanced But it is easy to show that so So now we have reduced the problem to computing the number of wins for each cow If we do this the dumb way this is O MN 2 still way too slow Sort the skill levels of the cows the order of the si doesn t actually matter s1 is lowest skill Now consider an n n grid where the ith row and jth column of the grid is a 1 if the match between cow i and cow j is flipped The grid is initially all zeros and Farmer John s query simply flips a rectangle of the form a b a b and the outdegree wins of cow i is just Number of 1 s in range 1 i 1 Number of 0 s in range i 1 N Number of 1 s in range 1 i 1 N i Number of 1 s in range i 1 N We can process these queries and compute outdegrees using a sweep line with a seg tree on the interval 1 N The seg tree needs to handle queries of the form Flip all numbers 0 1 1 0 in a range a b Query number of 1 s in a range a b 
Masha has n types of tiles of size 2 times 2 Each cell of the tile contains one integer Masha has an of tiles of each type Masha decides to construct the square of size m times m consisting of the given tiles This square also has to be a and each cell of this square has to be covered with exactly one tile cell and also sides of tiles should be parallel to the sides of the square All placed tiles cannot intersect with each other Also each tile should lie inside the square See the picture in Notes section for better understanding Symmetric with respect to the main diagonal matrix is such a square s that for each pair i j the condition s i j s j i holds I e it is true that the element written in the i row and j th column equals to the element written in the j th row and i th column Your task is to determine if Masha can construct a square of size m times m which is a symmetric matrix and consists of tiles she has Masha can use any number of tiles of each type she has to construct the square Note that she rotate tiles she can only place them in the orientation they have in the input You have to answer t independent test cases ,"['#include<bits/stdc++.h>\nusing namespace std ;\n\n#define ll long long \n#define pb push_back\n#define mem0(a) memset(a,0,sizeof(a))\n#define mem1(a) memset(a,-1,sizeof(a))\n#define memf(a) memset(a,false,sizeof(a))\n#define all(v) v.begin(),v.end()\n#define sz(a) (ll)a.size()\n#define F first\n#define S second\n#define INF 2000000000000000000\n#define endl ""\\n""\n#define _time_ 1.0 * clock() / CLOCKS_PER_SEC\n#define popcount(x) __builtin_popcountll(x)\n#define pll pair<ll,ll> \n#define ld long double\n\nconst int M=1000000007;\nconst int MM=998244353;\nconst long double PI = acos(-1);\n\nll power(ll b,ll e,ll m)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b%m,e/2,m)%m;\n    return power(b*b%m,e/2,m);\n}\nll power( ll b, ll e)\n{\n    if(e==0) return 1;\n    if(e&1) return b*power(b*b,e/2);\n    return power(b*b,e/2);\n}\ntemplate<typename T, typename U> static inline void amin(T &x, U y){ if(y<x) x=y; }\ntemplate<typename T, typename U> static inline void amax(T &x, U y){ if(x<y) x=y; }\ntemplate<typename T, typename U> ostream& operator<<(ostream &os, const pair<T, U> &p)\n{ \n    return os<<\'(\'<<p.F<< "",""<<p.S<<\')\'; \n}\n\nint _runtimeTerror_()\n{\n    ll n,m;\n    cin>>n>>m;\n    bool f = false;\n    for(int i=1;i<=n;++i)\n    {\n        int a,b,c,d;\n        cin>>a>>b>>c>>d;\n        if(b==c)\n            f = true;\n    }\n    if(m%2!=0 || !f)\n    {\n        cout<<""NO\\n"";\n    }\n    else\n        cout<<""YES\\n"";\n    return 0;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n    #ifdef runSieve\n        sieve();\n    #endif\n    #ifdef NCR\n        initialize();\n    #endif\n    int TESTS=1;\n    cin>>TESTS;\n    while(TESTS--)\n        _runtimeTerror_();\n    return 0;\n}']","[0, 0, 1, 0, 0]",900,Firstly if is odd then the answer is by obvious reasons Otherwise we can notice that the top left and the bottom right values of the tile do not matter since we can place tiles symmetrically So we only need to check that there is some tile that its top right value equals its bottom left value because this is how we get main diagonal symmetry 
Autumn came late to the kingdom of Far Far Away The harvest was exuberant and it is now time to get ready for the winter As most people celebrate the Harvest festival Simon the Caretaker tries to solve a very non trivial task of how to find place for the agricultural equipment in the warehouse He s got problems with some particularly large piece of equipment which is of course turboplows The problem is that when a turboplow is stored it takes up not some simply rectangular space It takes up a T shaped space like on one of the four pictures below here character stands for the space occupied by the turboplow and character stands for the free space Simon faced a quite natural challenge placing in the given cells warehouse the maximum number of turboplows As one stores the turboplows he can rotate them in any manner so that they take up the space like on one of the four pictures above However two turboplows cannot overlap that is they cannot share the same cell in the warehouse Simon feels that he alone cannot find the optimal way of positioning the plugs in the warehouse that would maximize their quantity Can you help him ,"['#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <queue>\n#include <memory.h>\n#include <stack>\n#define mp make_pair\n#define pb push_back                     \n#define setval(a,v) memset(a,v,sizeof(a))\n\n#if ( _WIN32 || __WIN32__ )\n    #define LLD ""%I64d""\n#else\n    #define LLD ""%lld""\n#endif\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\nchar s[10][10];\nchar bs[10][10];\n\nint ans;\n\nint start = clock();\n\nconst int dx[4][5] = {{0,1,2,1,1},{0,1,2,2,2},{1,1,0,1,2},{0,0,1,2,0}};\nconst int dy[4][5] = {{0,0,0,1,2},{1,1,0,1,2},{0,1,2,2,2},{0,1,1,1,2}};\nint n,m;\n\nbool q,q1;\n\nvoid dfs(int x,int y,int cur){\n    if (cur == ans){\n      memcpy(bs,s,sizeof(bs));\n      q = q1 = true;\n      return;\n    }\n    if (x >= n-2){\n        if (clock() - start > 2.7*CLOCKS_PER_SEC)\n           q = true, q1 = false; \n        return;\n    }\n    if (y >= m-2){\n        dfs(x+1,0,cur);\n        return;\n    }\n    if (((m-y+1)+(n-x)*m)/5 + cur <= ans)\n        return;\n    if ((m-y-1)+(n-x-2)*m+cur <= ans)\n        return;\n    for (int i = 0; i < 4; i++){\n        bool ok = !q;\n        for (int j = 0; j < 5; j++)\n            ok &= s[x+dx[i][j]][y+dy[i][j]] == 0;\n        if (ok){\n            for (int j = 0; j < 5; j++)\n                s[x+dx[i][j]][y+dy[i][j]] = \'A\'+cur;\n            dfs(x,y+1,cur+1);\n            for (int j = 0; j < 5; j++)\n                s[x+dx[i][j]][y+dy[i][j]] = 0;\n        }\n    }\n    if (!q)\n        dfs(x,y+1,cur);\n}\n\n\nint main()\n{\n  #ifdef LOCAL\n    freopen(""input.txt"",""r"",stdin);\n    freopen(""output.txt"",""w"",stdout);\n  #endif\n\n  scanf(""%d %d"",&n,&m);\n  if (n > 2 && m > 2){\n      for (ans = 0; ; ans++){\n        cerr << ans << endl;\n        q = q1= false;\n        dfs(0,0,0);\n        if (!q1){\n            ans--;\n            break;\n        }\n      }\n  }\n  printf(""%d\\n"",ans);\n  for (int i = 0; i < n; i++,printf(""\\n""))\n    for (int j = 0; j < m; j++)\n        if (bs[i][j] == 0)\n            printf(""."");\n        else\n            printf(""%c"",bs[i][j]); \n  return 0;\n}']","[0, 0, 0, 1, 0]",2300,This is technical problem one may use several approaches to solve it Additional complexity is to restore the answer after you got it 1 Dynamic programming on the broken profile I ll not explain the approach here in detail you can find explanation of it on the Internet or even on Codeforces Worth to point out care should be taken of your code memory usage 2 Search with memorization one jury solution uses logic like DP with usual not broken profile move by rows or by columns try all possible T placements such that upper cell of T s is in the given row and run the same search procedure for the next raw passing the state of the two last filled rows of the board to it For the given board state save the answer recursive function returned max number of T s one may place on the not yet filled part of the board and use it in the future as the answer for the given state This requires only O n 2 2 m of memory and works about 2 sec on maxtest 9 x 9 3 Branch and bound Another jury solution recursively tries all possible tilings of the board with T s If on some step it occured that number of T s on the board plus number of T s one can theoretically place on the remaining part of the board doesn t exceed existing best answer trim this node Such solution is the easiest to code and it works only 0 5 sec on maxtest however it is not obvious from the very beginning 4 Precalc not to write a lot of code applying DP or search with memorization and not to deal with possible time memory limits some participants did the right thing using the third approach just precalculated answers for large or for all possible inputs 
Denis bought a mysterious item and it was Random permutation generator Denis could not believed his luck When he arrived home he began to study how his generator works and learned the algorithm The process of generating a permutation consists of n steps At the i th step a place is chosen for the number i 1 leq i leq n The position for the number i is defined as follows For all j from 1 to n we calculate r j the minimum index such that j leq r j leq n and the position r j is not yet occupied in the permutation If there are no such positions then we assume that the value of r j is not defined For all t from 1 to n we calculate count t the number of positions 1 leq j leq n such that r j is defined and r j t Consider the positions that are still not occupied by permutation and among those we consider the positions for which the value in the count array is maximum The generator selects one of these positions for the number i The generator can choose position Let s have a look at the operation of the algorithm in the following example Let n 5 and the algorithm has already arranged the numbers 1 2 3 in the permutation Consider how the generator will choose a position for the number 4 The values of r will be r 3 3 3 4 times where times means an indefinite value Then the count values will be count 0 0 3 1 0 There are only two unoccupied positions in the permutation 3 and 4 The value in the count array for position 3 is 3 for position 4 it is 1 The maximum value is reached only for position 3 so the algorithm will uniquely select this position for number 4 Satisfied with his purchase Denis went home For several days without a break he generated permutations He believes that he can come up with random permutations no worse than a generator After that he wrote out the first permutation that came to mind p 1 p 2 ldots p n and decided to find out if it could be obtained as a result of the generator Unfortunately this task was too difficult for him and he asked you for help It is necessary to define whether the written permutation could be obtained using the described algorithm if the generator always selects the position Denis needs ,"['#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tint T; cin >> T;\n\twhile (T--) {\n\t\tint N; cin >> N;\n\t\tvector<int> P(N);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> P[i]; P[i]--;\n\t\t}\n\t\tbool good = true;\n\t\tint curMin = N;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (P[i] < curMin) {\n\t\t\t\tcurMin = P[i];\n\t\t\t} else if (P[i] == P[i-1]+1) {\n\t\t\t\t// still good\n\t\t\t} else {\n\t\t\t\tgood = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (good ? ""Yes"" : ""No"") << \'\\n\';\n\t}\n\n\treturn 0;\n}\n']","[1, 0, 1, 0, 1]",1500,Consider the initial moment of time Note that the array is r 1 2 n count 1 1 1 So the generator will choose a random position from the entire array let it be the position i1 In the next step r 1 2 i1 1 i1 1 i 2 n count 1 1 0 2 1 1 That is now there is only one maximum and it is reached at the position i1 1 Thus we will fill in the entire suffix starting at position i1 a 1 i1 After this this procedure will be repeated for some i2 1 i2 i1 and the array will become a i1 1 i1 i2 1 i1 That is we need to check that the array consists of several ascending sequences 
BerOilGasDiamondBank has branches in cities at that is an even number The bank management wants to publish a calendar with the names of all those cities written in two columns the calendar should consist of exactly lines of strictly equal length each of which contains exactly two names and exactly one separator character between them The name of every city should be used in the calendar exactly once For historical reasons the symbol is used as the separator of words in the calendar The BerOilGasDiamondBank management wants to show that all its branches are equally important to it that s why the order of their appearance in the calendar should be following if we glue concatinate all the calendar lines from top to bottom to make a single line then the lexicographically minimal line is obtained No separator character will be used to separate calendar lines For example if the lines are bertown berville newberville bera then the resulting line is bertown bervillenewberville bera In some sense one has to find the lexicographically minimal calendar where the comparison of calendars happens line by line Help BerOilGasDiamondBank and construct the required calendar ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define MM(a , x) memset(a , x , sizeof(a))\n#define sqr(x) ((x) * (x))\n#define abs(x) ((x > 0) ? (x) : -(x))\n#define REP(i , n) for ((i) = 0; (i) < (n); ++(i))\n#define FOR(i , a , b) for ((i) = (a); (i) <= (b); ++(i))\n#define FORD(i , a , b) for ((i) = (a); (i) >= (b); --(i))\ntypedef long long LL;\n\nint n , m , tot , l , r;\nstring ans , data[10008];\nchar sep;\nint cnt[18];\nvector<int> index[18];\nbool vis[10008];\n\ninline bool cmp(const string &a , const string &b)\n{\n\tint i , j , k , l1 , l2;\n\tl1 = a.length(); l2 = b.length();\n\tREP (i , min(l1 , l2))\n\t{\n\t\tif (a[i] != b[i]) return a[i] < b[i];\n\t}\n\tif (l1 == l2) return 0;\n\tif (l1 < l2)\n\t{\n\t\tif (sep <= b[l1]) return 1; else return 0;\n\t}\n\telse\n\t{\n\t\tif (sep >= a[l2]) return 1; else return 0;\n\t}\n}\n\nvoid init()\n{\n\tcin >> n;\n\tint i;\n\tFOR (i , 1 , n) cin >> data[i];\n\tcin >> sep;\n}\n\nvoid work()\n{\n\tsort(data + 1 , data + n + 1 , cmp);\n\tint i , j , k , tp;\n\tl = 11; r = 0;\n\tFOR (i , 1 , n)\n\t{\n\t\tk = data[i].length();\n\t\tl = min(l , k);\n\t\tr = max(r , k);\n\t\tindex[k].push_back(i);\n\t}\n\tm = l + r;\n\tMM(vis , 0);\n\tFOR (i , 1 , n)\n\t{\n\t\tif (vis[i]) continue;\n\t\tk = data[i].length();\n\t\tans.clear();\n\t\tans += data[i];\n\t\tcnt[k]++;\n\t\tans.push_back(sep);\n\t\tj = index[m - k][cnt[m - k]++];\n\t\tans += data[j];\n\t\tvis[i] = vis[j] = 1;\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tinit();\n\twork();\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",2000,We know that all lines of calendar should have equal length so we can find this length It s just where suml summary length of all strings Now let take a look at string which will be the first one in our calendar Obliviously it s profitably to take string with maximal s d where s is our string and d is character from input Such string is unique otherwise we have two equal strings in input as d is not contained in any string Of cause you should remember that if you fix the first string in a line you fix length of the second one it s required to have at least one such Great now we know the first string in our calendar Now let s determine the second one We know it s length so we need just to take minimal string with such length We know one line let s do similary with the second line and so on 
You are given an integer array a 1 a 2 dots a n 1 le a i le n Find the number of subarrays of a whose operatorname XOR has an even number of divisors In other words find all pairs of indices i j i le j such that a i oplus a i 1 oplus dots oplus a j has an even number of divisors For example numbers 2 3 5 or 6 have an even number of divisors while 1 and 4 odd Consider that 0 has an odd number of divisors in this task Here operatorname XOR or oplus denotes the bitwise XOR operation Okay let s stop Just print the actual answer ,"['//114514min\n//ACM \n#include ""bits/stdc++.h""\nusing namespace std;\ntemplate<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }\ntemplate<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<\' \'<<a.second; }\ntemplate<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<\'\\n\'; return cout; }\ntemplate<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<\' \'<<a[i]; return cout; }\ntemplate<typename typC,typename typD> bool cmin(typC &x,const typD &y) { if (x>y) { x=y; return 1; } return 0; }\ntemplate<typename typC,typename typD> bool cmax(typC &x,const typD &y) { if (x<y) { x=y; return 1; } return 0; }\ntemplate<typename typC> vector<typC> range(typC l,typC r,typC step=1) { assert(step>0); int n=(r-l+step-1)/step,i; vector<typC> res(n); for (i=0; i<n; i++) res[i]=l+step*i; return res; }\n#if !defined(ONLINE_JUDGE)&&defined(LOCAL)\n#include ""my_header\\debug.h""\n#else\n#define dbg(...) ;\n#define dbgn(...) ;\n#endif\ntypedef unsigned int ui;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\n// template<typename T1,typename T2> void inc(T1 &x,const T2 &y) { if ((x+=y)>=p) x-=p; }\n// template<typename T1,typename T2> void dec(T1 &x,const T2 &y) { if ((x+=p-y)>=p) x-=p; }\nconst int N=1e6+5;\nint main()\n{\n\tios::sync_with_stdio(0); cin.tie(0);\n\tcout<<fixed<<setprecision(15);\n\tint T; cin>>T;\n\twhile (T--)\n\t{\n\t\tint n,m,i,j;\n\t\tcin>>n;\n\t\tvector<int> cnt(2*n+5);\n\t\tvector<int> a(n);\n\t\tvector<int> b;\n\t\tfor (i=0; i*i<cnt.size(); i++) b.push_back(i*i);\n\t\tcin>>a;\n\t\t++cnt[0];\n\t\tint cur=0;\n\t\tll ans=n*(n+1ll)/2;\n\t\t// dbg(ans);\n\t\tfor (int x:a)\n\t\t{\n\t\t\tcur^=x;\n\t\t\t// dbg(cur);\n\t\t\tfor (int y:b) if ((cur^y)<cnt.size()) ans-=cnt[cur^y];\n\t\t\t++cnt[cur];\n\t\t\t// dbg(ans);\n\t\t}\n\t\tcout<<ans<<\'\\n\';\n\t}\n}\n']","[0, 1, 0, 0, 0]",1700,Let s calculate the number of subarrays whose sum has an odd number of divisors and subtract them from total no of subarrays Note A number has an odd number of divisors only if it is a perfect square So we have to calculate number of subarray having sum a perfect square For the given constraints for elements in the array the maximum possible sum of any subarray will be less than so the number of possible elements with odd divisors Number of subarrays with a given sum can be calculated in Therefore calculate the same for each perfect square less than and add all these to get the number of subarrays whose sum has an odd number of divisors Subtract from total number of subarrays to get the required answer Time complexity 
A magic island Geraldion where Gerald lives has its own currency system It uses banknotes of several values But the problem is the system is not perfect and sometimes it happens that Geraldionians cannot express a certain sum of money with any set of banknotes Of course they can use any number of banknotes of each value Such sum is called Gerald wondered what is the minimum sum ,['#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    int res = 1;\n    while(N) {\n        int v;\n        cin >> v;\n        if(v == 1) res = -1;\n        N--;\n    }\n    cout << res << endl;\n    return 0;\n}\n'],"[0, 0, 1, 0, 0]",1000,If there is a banlnot of value 1 then one can to express every sum of money Otherwise one can t to express 1 and it is minimum unfortunate sum 
Vova has won n trophies in different competitions Each trophy is either golden or silver The trophies are arranged in a row The of the arrangement is the length of the longest subsegment consisting of golden trophies Vova wants to swap two trophies not necessarily adjacent ones to make the arrangement as beautiful as possible that means to maximize the length of the longest such subsegment Help Vova Tell him the maximum possible beauty of the arrangement if he is allowed to do at most one swap ,"['/*\nWe sail through endless skies\nStars shine like eyes\nThe black night sighs\nThe Moon in silver dreams\nFalls down in beams\nLight of the night\nThe Earth a purple blaze\nOf sapphire haze\nIn orbit always\n\nWhile down below the trees\nBathed in cool breeze\nSilver starlight breaks\nDawn from night\nAnd so we pass on by\nThe crimson eye\nOf great god Mars\nAs we travel the universe\n*/\n\n#pragma GCC optimize(""O3"")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define prev asdgSHJsfgsdfhdsh\n#define hash asdgasdgasdgdfrywewery\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bsize 512\n\n#define ldouble long double\nusing namespace std;\n\n#define bs 1000000007\n\nconst int N = 200031;\n\nint n;\nstring st;\nint ar[N];\nint cnt;\nint ans;\nint L[N],R[N];\n\nint main(){\n//\tfreopen(""apache.in"",""r"",stdin);\n//\tfreopen(""apache.out"",""w"",stdout);\n//\tfreopen(""input.txt"", ""r"", stdin);\n//\tfreopen(""output.txt"", ""w"", stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\n\tcin>>n;\n\tcin>>st;\n\tfor (int i=1;i<=n;i++){\n\t\tar[i]=(st[i-1]==\'G\');\n\t\tcnt+=ar[i];\n\t}\n\n\tfor (int i=1;i<=n;i++){\n\t\tL[i]=L[i-1]+1;\n\t\tif (ar[i]==0)\n\t\t\tL[i]=0;\n\t}\n\n\tfor (int i=n;i>=1;--i){\n\t\tR[i]=R[i+1]+1;\n\t\tif (ar[i]==0)\n\t\t\tR[i]=0;\n\t}\n\n\tfor (int i=1;i<=n;i++){\n\t\tans=max(ans,L[i]);\n\t\tans=max(ans,L[i-1]+R[i+1]+1);\n\t}\n\tans=min(ans,cnt);\n\tcout<<ans<<endl;\n\n//\tcin.get(); cin.get();\n\treturn 0;\n}\n']","[1, 0, 0, 0, 0]",1600,Let be the maximal segment of gold cups that begins in the cup Let be the maximum segment of gold cups that ends in the cup Also let the total number of gold cups be Note that it makes no sense to change the cups of the same color Then let s consider the silver cup which will change with the gold cup let its number be Then if then we will update the answer with the value and otherwise with the value This will not work if all the cups are golden In this case the answer is 
Vasya is an administrator of a public page of organization Mouse and keyboard and his everyday duty is to publish news from the world of competitive programming For each news he also creates a list of hashtags to make searching for a particular topic more comfortable For the purpose of this problem we define hashtag as a string consisting of lowercase English letters and exactly one symbol located at the beginning of the string The of the hashtag is defined as the number of symbols in it the symbol The head administrator of the page told Vasya that hashtags should go in lexicographical order take a look at the notes section for the definition Vasya is lazy so he doesn t want to actually change the order of hashtags in already published news Instead he decided to delete some suffixes consecutive characters at the end of the string of some of the hashtags He is allowed to delete any number of characters even the whole string except for the symbol Vasya wants to pick such a way to delete suffixes that the total number of deleted symbols is possible If there are several optimal solutions he is fine with any of them ,"['#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll;\n#define rep(i, a, b) for (int i = a; i <= b; ++ i)\nusing namespace std;\nint n, l[500005]; string s[500005];\nvoid solve(int x, int y) {\n\tint len = min(l[x], l[y]);\n\trep(i, 0, len - 1) {\n\t\tif (s[x][i] < s[y][i]) return ;\n\t\tif (s[x][i] > s[y][i]) {\n\t\t\tl[x] = i;\n\t\t\treturn ;\n\t\t}\n\t}\n\tif (l[x] <= l[y]) return; else l[x] = len;\n}\nint main() {\n\tscanf(""%d"", &n);\n\trep(i, 1, n) cin >> s[i], l[i] = s[i].length();\n\tfor (int i = n; i > 1; -- i) solve(i - 1, i);\n\trep(i, 1, n) {\n\t\trep(j, 0, l[i] - 1) printf(""%c"", s[i][j]);\n\t\tprintf(""\\n"");\n\t}\n\treturn 0;\n}']","[1, 0, 1, 0, 0]",1800,It is possible to solve this problem in many ways One of them was to iterate over all strings in reversed order and to try to leave the longest possible prefix of each string greedily without breaking the statement Let s prove this solution formally Note that the set of possible lengths of some string in a correct answer forms a segment between and some critical length Indeed if there exists a correct answer with string having a length of then there also exists an answer with th string having a length of since it is possible to leave only the first symbol of all previous strings and make the answer correct Let s express through Reduce the length of st string to and consider two options First may be lexicographically not greater than and in this case we may obviously let be equal to Otherwise can t be larger than where deontes the length of the longest common prefix of two strings if we keep longer it will be larger than any possible prefix of At the same time if we reduce up to it will be correct So we may let be equal to Note that due to the way we defined if we just reduce any string up to its maximum possible length it will also be a correct answer So it is also a correct answer to the original problem 
You have n barrels lined up in a row numbered from left to right from one Initially the i th barrel contains a i liters of water You can pour water from one barrel to another In one act of pouring you can choose two different barrels x and y the x th barrel shouldn t be empty and pour any possible amount of water from barrel x to barrel y possibly all water You may assume that barrels have infinite capacity so you can pour any amount of water in each of them Calculate the maximum possible difference between the maximum and the minimum amount of water in the barrels if you can pour water k times Some examples if you have four barrels each containing 5 liters of water and k 1 you may pour 5 liters from the second barrel into the fourth so the amounts of water in the barrels are 5 0 5 10 and the difference between the maximum and the minimum is 10 if all barrels are empty you can t make any operation so the difference between the maximum and the minimum amount is still 0 ,"['#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(""wzpakking"")\n#define y1 ysghysgsygsh\nusing namespace std;\nint n,k,a[200005];\nvoid solve(){\n\tscanf(""%d%d"",&n,&k);\n\tFor(i,1,n) scanf(""%d"",&a[i]);\n\tsort(a+1,a+n+1);\n\tll s1=0;\n\tFor(i,n-k,n) s1+=a[i];\n\tcout<<s1<<endl;\n}\nint main(){\n\tint T;\n\tscanf(""%d"",&T);\n\twhile (T--) solve();\n}']","[1, 0, 1, 0, 0]",800,A greedy strategy always works take largest barrels choose one barrel among them and pour all water from those barrels to the chosen barrel That way we make the minimum amount equal to it s quite obvious that we can t do anything better here and the maximum amount as large as possible so the difference between them will be as large as possible 
You are given two integers x and y Output two integers the minimum of x and y followed by the maximum of x and y ,"['#include <iostream>#include <set>#include <map>#include <vector>#include <algorithm>#include <cmath>using namespace std;typedef long long ll;const int N = 5e5 + 10;//int a[N];void solve() {\tint x, y;\tcin >> x >> y;\tcout << min(x, y) << "" "" << max(x, y) << ""\\n"";}int main() {\tint t = 1;\tcin >> t;\twhile (t--) {\t\tsolve();\t} }']","[0, 0, 1, 0, 0]",800,You can use for example an if statement or some inbuilt and function available in most languages like Python or C 
Rudolph invented the game of tic tac toe for three players It has classic rules except for the third player who plays with pluses Rudolf has a 3 times 3 field the result of the completed game Each field cell contains either a cross or a nought or a plus sign or nothing The game is won by the player who makes a horizontal vertical or diagonal row of 3 s of their symbols Rudolph wants to find the result of the game Either exactly one of the three players won or it ended in a draw It is guaranteed that multiple players cannot win at the same time ,"['#include<bits/stdc++.h>\nusing namespace std;\nbool is(vector<string> vc,char ch)\n{\n    for(int i=0; i<3; ++i)\n    if (vc[i][0] == ch&&vc[i][1] == ch && vc[i][2] == ch)\n            return true;\nfor (int j = 0; j < 3; j++)\n        if (vc[0][j] == ch && vc[1][j] == ch && vc[2][j] == ch)\n            return true;\n  if (vc[0][0] == ch && vc[1][1] == ch && vc[2][2] == ch)\n        return true;\n\n    if (vc[0][2] == ch && vc[1][1] == ch && vc[2][0] == ch)\n        return true;\n\n    return false;\n}\n\nvoid solve()\n{\n   vector<string> vc(3);\n   for(int i=0; i<3; ++i)\n    cin>>vc[i];\n    if(is(vc, \'X\'))\n        cout<<""X\\n"";\n   else if (is(vc, \'O\'))\n        cout<<""O\\n"";\n else if (is(vc, \'+\'))\n        cout<<""+\\n"";\nelse\n   cout<<""DRAW\\n"";\n}\n\nint main()\n{\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        solve();\n    }\n}\n']","[0, 0, 1, 0, 0]",800,To solve this problem it is enough to check the equality of elements on each row column and diagonal of three elements If all three elements are equal and are not then the value of these elements is the answer Note that a row of does not give you answer Statement does not say that the players have equal amount of moves which means that one player can have several winning rows 
Recently Vlad has been carried away by spanning trees so his friends without hesitation gave him a connected weighted undirected graph of n vertices and m edges for his birthday Vlad defined the of a spanning tree as the bitwise OR of all its weights and now he is interested in what is the minimum possible that can be achieved by choosing a certain spanning tree A spanning tree is a connected subgraph of a given graph that does not contain cycles In other words you want to keep n 1 edges so that the graph remains connected and the bitwise OR weights of the edges are as small as possible You have to find the minimum bitwise OR itself ,"[""#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class...Args>\nvoid debug(Args... args) {\n    auto tmp = {(cout << args << ' ', 0)...};\n    cout << endl;\n}\nusing ll = long long;\nusing ull = unsigned long long;\nconst int N = 2e5 + 10;\nconst int mod = 998244353;\nstruct edge {\n    int u, v, w;\n};\nedge e[N];\nint f[N];\nint F(int x) {\n    return x == f[x] ? x : f[x] = F(f[x]);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int T;\n    cin >> T;\n    while (T--) {\n        int n, m;\n        cin >> n >> m;\n        for (int i = 1; i <= m; ++i) {\n            cin >> e[i].u >> e[i].v >> e[i].w;\n        }\n        int ans = (1ll << 30) - 1;\n        for (int i = 29; i >= 0; --i) {\n            iota(f + 1, f + 1 + n, 1);\n            ans ^= (1 << i);\n            for (int j = 1; j <= m; ++j) {\n                if ((e[j].w & ans) == e[j].w) {\n                    f[F(e[j].u)] = F(e[j].v);\n                }\n            }\n            bool ok = true;\n            int f1 = F(1);\n            for (int j = 2; j <= n; ++j) {\n                if (f1 != F(j)) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (!ok) {\n                ans ^= (1 << i);\n            }\n        }\n        cout << ans << '\\n';\n    }\n}""]","[1, 0, 0, 0, 0]",1900,We need to minimize the result of the bitwise operation so for convenience we represent the answer as a mask Firstly let s assume that this mask is composed entirely of ones Let s go from the most significant bit to the least significant one and try to reduce the answer To understand whether it is possible to remove the th bit remove it and check if the graph in which all the weights are submasks of the current answer is connected for this you can use depth first search or a disjoint sets union If the graph is connected then the bit can obviously be thrown out and if not it cannot and must be returned 
