{
    "link": "https://codeforces.com//contest/888/problem/F",
    "problemId": "133219",
    "problem_idx": "F",
    "shortId": "888F",
    "contest_number": "888",
    "problem_submissions": {
        "G": [
            32172042,
            32168632,
            32168909,
            32170476,
            32167506,
            32171976,
            32173035,
            241155169,
            241155102,
            235169005,
            32169597,
            32173708,
            32168771,
            32171814,
            32171370,
            32172912,
            32165432,
            32167149,
            32169268,
            32171477,
            32172225,
            32173216
        ],
        "F": [
            32171987,
            32170278,
            32172159,
            32171197,
            32170478,
            32168014,
            32169190,
            32170622,
            32174858,
            32168606,
            32173283,
            32170912,
            32174868,
            32169893,
            32169158
        ],
        "E": [
            32163719,
            32165466,
            32165072,
            32165480,
            32166182,
            32169561,
            32165622,
            32166940,
            32164948,
            32166592,
            32167933,
            32165907,
            32166704,
            32171701,
            32166673,
            32165423,
            32165438,
            32166167,
            32165797
        ],
        "D": [
            32162976,
            32163974,
            32163652,
            32163977,
            32164153,
            32164359,
            32163516,
            32164004,
            32163586,
            32165640,
            32166333,
            32164675,
            32169307,
            32172406,
            32165201,
            94891011,
            32164182,
            32164378,
            32165173,
            32164264
        ],
        "C": [
            32161993,
            32162950,
            32162732,
            32162517,
            32162876,
            32163006,
            32164421,
            32165163,
            32162702,
            32164873,
            32163434,
            32163145,
            32168574,
            32172811,
            32163766,
            32162891,
            32163365,
            32163387,
            32163154
        ],
        "B": [
            32161291,
            32161464,
            32161908,
            32161485,
            32162020,
            32161911,
            32162011,
            32161731,
            32161722,
            32164340,
            32162169,
            32161577,
            32167466,
            32173057,
            32162454,
            32161287,
            32162576,
            32162145,
            32162125
        ],
        "A": [
            32160859,
            32160877,
            32161303,
            32160939,
            32161211,
            32161025,
            32161283,
            32160935,
            32160863,
            32164003,
            32161065,
            32160871,
            32166966,
            32173329,
            32161342,
            32161916,
            32160867,
            32161042,
            32161000
        ]
    },
    "name": "F. Connecting Vertices",
    "statement": "There are points marked on the plane. The points are situated in such a\r\nway that they form a regular polygon (marked points are its vertices,\r\nand they are numbered in counter-clockwise order). You can draw\r\nsegments, each connecting any two marked points, in such a way that all\r\npoints have to be connected with each other (directly or indirectly).But\r\nthere are some restrictions. Firstly, some pairs of points cannot be\r\nconnected directly and have to be connected undirectly. Secondly, the\r\nsegments you draw must not intersect in any point apart from the marked\r\npoints (that is, if any two segments intersect and their intersection is\r\nnot a marked point, then the picture you have drawn is invalid).How many\r\nways are there to connect all vertices with segments? Two ways are\r\nconsidered different iff there exist some pair of points such that a\r\nsegment is drawn between them in the first way of connection, but it is\r\nnot drawn between these points in the second one. Since the answer might\r\nbe large, output it modulo .\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\nvoid sleep( double sec = 1021 ){\n  clock_t s = clock();\n  while( clock() - s < CLOCKS_PER_SEC * sec );\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 514\nvoid build(){\n\n}\nint n , a[ N ][ N ];\nvoid init(){\n  n = getint();\n  for( int i = 0 ; i < n ; i ++ )\n    for( int j = 0 ; j < n ; j ++ )\n      a[ i ][ j ] = getint();\n}\nint dp[ N ][ N ][ 2 ];\nbool g[ N ][ N ][ 2 ];\nint dp2[ N ][ N ];\nbool g2[ N ][ N ];\nint DP( int l , int r , int bt );\nint DP2( int l , int r ){\n  l %= n; r %= n;\n  if( ( l + 1 ) % n == r ) return 1;\n  if( l == r ) return 1;\n  if( g2[ l ][ r ] ) return dp2[ l ][ r ];\n  int ret = 0;\n  ret = add( DP( r , l + 1 , 0 ) ,\n             DP( r + n - 1 , l , 0 ) );\n  for( int i = l + 1 ; ( i + 1 ) % n != r ; i ++ )\n    ret = add( ret , \n               mul( DP( i , l , 0 ) ,\n                    DP( r , i + 1 , 0 ) ) );\n  g2[ l ][ r ] = true;\n  return dp2[ l ][ r ] = ret;\n}\nint DP( int l , int r , int bt ){\n  l %= n; r %= n;\n  if( l == r ) return 1;\n  if( g[ l ][ r ][ bt ] ) return dp[ l ][ r ][ bt ];\n  int ret = 0;\n  if( bt == 0 ){\n    for( int i = r ; ; i ++ ){\n      if( i % n == l ) break;\n      if( !a[ l % n ][ i % n ] ) continue;\n      ret = add( ret ,\n                 mul( DP( i , r , 0 ) ,\n                      DP( l , i , 1 ) ) );\n    }\n  }else{\n    ret = DP( l + n - 1 , r , 0 );\n    for( int i = r + 1 ; ; i ++ ){\n      if( i % n == l ) break;\n      if( !a[ l % n ][ i % n ] ) continue;\n      ret = add( ret ,\n                 mul( DP( l , i , 1 ) ,\n                      DP2( r , i ) ) );\n    }\n  }\n  g[ l ][ r ][ bt ] = true;\n  //printf( \"%d %d %d : %d\\n\" , l , r , bt , ret );\n  return dp[ l ][ r ][ bt ] = ret;\n}\nvoid solve(){\n  printf( \"%d\\n\" , DP( 0 , 1 , 0 ) );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Connecting Vertices.json",
    "editorial_link": "https://codeforces.com//blog/entry/55701",
    "editorial": "We can use dynamic programming to solve this problem, but we need to\r\nchoose the states we maintain very carefully.One of the approaches might\r\nbe: the number of ways to connect the vertices between and to vertices\r\nor if and are already connected (so there is no possibility to connect\r\nany vertex between and to some vertex outside).What values should we\r\naccess if we, for example, try to connect -th vertex to some vertex ? To\r\nget everything connected, we then have to connect vertices from interval\r\nto these two, and vertices from to , or and connections to from the\r\nsecond interval are difficult to handle. We need to somehow get rid of\r\nthem, and the solution is to . And vice versa, if we connect something\r\nto , then we choose the index of vertex to be connected with\r\ndirectly.But thatâs not all we have to handle. Suppose we have four\r\nvertices, and is already connected to . One of the possibilities to\r\nfinish it is to connect to and to , but if we process current dynamic\r\nprogramming as it is, we will count it twice (if we choose to connect to\r\nfirstly, or if we connect to ). To get rid of this problem, we will use\r\na flag that will denote whether we can connect anything to vertex , and\r\nif we choose to pick the first connection from , then we donât connect\r\nanything to .So the solution is: the number of ways to connect the\r\nvertices from interval to and , and denotes if we can connect anything\r\nto .How to calculate it: If , then (there is nothing left to connect);\r\nOtherwise set ; If , then iterate on vertex we connect to and add ;\r\nIterate on vertex we connect to and add . The answer is (if vertices are\r\n-indexed). Vertex is actually vertex , so donât forget to update the\r\nmatrix for it.\r\n",
    "hint": []
}