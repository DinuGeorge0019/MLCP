{
    "link": "https://codeforces.com//contest/1948/problem/G",
    "problemId": "2532319",
    "problem_idx": "G",
    "shortId": "1948G",
    "contest_number": "1948",
    "problem_submissions": {
        "G": [
            251472376,
            251497915,
            251480984,
            251480163,
            251489959,
            251467292,
            251485648,
            251500573,
            251486197,
            251512722,
            251521639,
            251480657,
            251509802,
            251528428,
            251520218,
            251515719,
            251959006,
            251871508,
            251537711,
            251535946,
            251529016,
            251516034,
            251533510,
            251533892
        ],
        "E": [
            251455000,
            251464649,
            251452268,
            251480095,
            251460808,
            251464897,
            251506007,
            251480198,
            251478117,
            251501414,
            251479798,
            251486494,
            251498878,
            251484347,
            251486715,
            251474115,
            251485874,
            251484195,
            251499420
        ],
        "F": [
            251446403,
            251454570,
            251464038,
            251471618,
            251471081,
            251484983,
            251475462,
            251495125,
            251493237,
            251458734,
            251522756,
            251503819,
            251513774,
            251502504,
            251506031,
            251513492,
            251502955,
            251521827,
            251479729
        ],
        "D": [
            251428147,
            251500203,
            251431497,
            251439266,
            251434727,
            251440547,
            251446816,
            251446867,
            251456743,
            251442045,
            251470051,
            251447446,
            251460726,
            251467120,
            251467499,
            251465257,
            251451922,
            251465519,
            251467189,
            251458845
        ],
        "C": [
            251425049,
            251426495,
            251431074,
            251427750,
            251427491,
            251433261,
            251437529,
            251439503,
            251431968,
            251453203,
            251439755,
            251452383,
            251446018,
            251457382,
            251439370,
            251471934,
            251459502,
            251461525,
            251447180
        ],
        "B": [
            251421706,
            251420680,
            251422950,
            251421537,
            251420205,
            251424082,
            251426365,
            251440040,
            251423639,
            251430207,
            251430125,
            251435004,
            251430108,
            251439531,
            251427186,
            251441008,
            251448490,
            251446251,
            251436268
        ],
        "A": [
            251419288,
            251417353,
            251417664,
            251417432,
            251417471,
            251418376,
            251419094,
            251418141,
            251417555,
            251419693,
            251424986,
            251423459,
            251419168,
            251420360,
            251418645,
            251426543,
            251449327,
            251430256,
            251427243
        ]
    },
    "name": "G. MST with Matching",
    "statement": "You are given an undirected connected graph on n vertices. Each edge of\r\nthis graph has a weight; the weight of the edge connecting vertices i\r\nand j is w_{i,j} (or w_{i,j} = 0 if there is no edge between i and j).\r\nAll weights are positive integers.You are also given a positive integer\r\nc.You have to build a spanning tree of this graph; i. e. choose exactly\r\n(n-1) edges of this graph in such a way that every vertex can be reached\r\nfrom every other vertex by traversing some of the chosen edges. The cost\r\nof the spanning tree is the sum of two values: the sum of weights of all\r\nchosen edges; the maximum matching in the spanning tree (i. e. the\r\nmaximum size of a set of edges such that they all belong to the chosen\r\nspanning tree, and no vertex has more than one incident edge in this\r\nset), multiplied by the given integer c. Find any spanning tree with the\r\nminimum cost. Since the graph is connected, there exists at least one\r\nspanning tree.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 15.03.2024 11:00:45\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, c;\n  cin >> n >> c;\n  vector<vector<int>> w(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> w[i][j];\n    }\n  }\n  vector<array<int, 3>> edges;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (w[i][j] > 0) {\n        edges.push_back({w[i][j], i, j});\n      }\n    }\n  }\n  sort(edges.begin(), edges.end());\n  int ans = int(2e9);\n  for (int t = 0; t < (1 << n); t++) {\n    dsu d(n);\n    int cnt = 0;\n    int cost = 0;\n    for (auto& [x, i, j] : edges) {\n      if ((t & (1 << i)) && (t & (1 << j))) {\n        continue;\n      }\n      if (d.unite(i, j)) {\n        cnt += 1;\n        cost += x;\n      }\n    }\n    if (cnt == n - 1) {\n      ans = min(ans, cost + c * (n - __builtin_popcount(t)));\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dsu",
        "graph matchings",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. MST with Matching.json",
    "editorial_link": "https://codeforces.com//blog/entry/127182",
    "editorial": "The key to solving this problem is applying K nig\u00e2\u0080\u0099s theorem: in a\r\nbipartite graph, the size of the maximum matching is equal to the size\r\nof the minimum vertex cover. At the first glance it shouldn\u00e2\u0080\u0099t work here,\r\nbecause our graph is not bipartite; however, when we leave only the\r\nedges belonging to the spanning tree we chose, it becomes bipartite. So\r\ninstead of adding c to the cost of the tree for each edge in its maximum\r\nmatching, we can add c to the cost of the tree for each vertex in its\r\nminimum vertex cover.This allows us to try iterating on that vertex\r\ncover. Let\u00e2\u0080\u0099s fix a set of vertices S, say that this is the minimum\r\nvertex cover, and the second part of the cost is equal to c\r\ncdot |S|. How to build a minimum-cost spanning tree which has S as its\r\nminimum vertex cover? Well, that\u00e2\u0080\u0099s not really easy to do; but instead,\r\nwe can build a minimum-cost spanning tree which has S as (not\r\nnecessarily minimum). The fact that there might be some other vertex\r\ncover of smaller size for the tree doesn\u00e2\u0080\u0099t really matter, because we can\r\ngenerate this tree again using a smaller set of vertices as its vertex\r\ncover.So, how do we build a minimum spanning tree such that S is its\r\nvertex cover? This is actually easy: we forbid all edges such that none\r\nof their endpoints are in S (because they can\u00e2\u0080\u0099t be covered), and use any\r\nregular MST algorithm on all edges we have not forbidden. If we use\r\nPrim\u00e2\u0080\u0099s algorithm, we get a solution in O(2^n\r\ncdot n^2), which is fast enough to pass the time limit. Kruskal\u00e2\u0080\u0099s\r\nalgorithm with DSU might be a bit slower, but can also get accepted.\r\n"
}