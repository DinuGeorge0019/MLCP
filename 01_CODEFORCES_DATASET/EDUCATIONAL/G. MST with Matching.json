{"link": "https://codeforces.com//contest/1948/problem/G", "problemId": "2532319", "problem_idx": "G", "shortId": "1948G", "contest_number": "1948", "problem_submissions": {"G": [251472376, 251497915, 251480984, 251480163, 251489959, 251467292, 251485648, 251500573, 251486197, 251512722, 251521639, 251480657, 251509802, 251528428, 251520218, 251515719, 251959006, 251871508, 251537711, 251535946, 251529016, 251516034, 251533510, 251533892], "E": [251455000, 251464649, 251452268, 251480095, 251460808, 251464897, 251506007, 251480198, 251478117, 251501414, 251479798, 251486494, 251498878, 251484347, 251486715, 251474115, 251485874, 251484195, 251499420], "F": [251446403, 251454570, 251464038, 251471618, 251471081, 251484983, 251475462, 251495125, 251493237, 251458734, 251522756, 251503819, 251513774, 251502504, 251506031, 251513492, 251502955, 251521827, 251479729], "D": [251428147, 251500203, 251431497, 251439266, 251434727, 251440547, 251446816, 251446867, 251456743, 251442045, 251470051, 251447446, 251460726, 251467120, 251467499, 251465257, 251451922, 251465519, 251467189, 251458845], "C": [251425049, 251426495, 251431074, 251427750, 251427491, 251433261, 251437529, 251439503, 251431968, 251453203, 251439755, 251452383, 251446018, 251457382, 251439370, 251471934, 251459502, 251461525, 251447180], "B": [251421706, 251420680, 251422950, 251421537, 251420205, 251424082, 251426365, 251440040, 251423639, 251430207, 251430125, 251435004, 251430108, 251439531, 251427186, 251441008, 251448490, 251446251, 251436268], "A": [251419288, 251417353, 251417664, 251417432, 251417471, 251418376, 251419094, 251418141, 251417555, 251419693, 251424986, 251423459, 251419168, 251420360, 251418645, 251426543, 251449327, 251430256, 251427243]}, "name": "G. MST with Matching", "statement": "You are given an undirected connected graph on n vertices. Each edge of\r\nthis graph has a weight; the weight of the edge connecting vertices i\r\nand j is w_{i,j} (or w_{i,j} = 0 if there is no edge between i and j).\r\nAll weights are positive integers.You are also given a positive integer\r\nc.You have to build a spanning tree of this graph; i. e. choose exactly\r\n(n-1) edges of this graph in such a way that every vertex can be reached\r\nfrom every other vertex by traversing some of the chosen edges. The cost\r\nof the spanning tree is the sum of two values: the sum of weights of all\r\nchosen edges; the maximum matching in the spanning tree (i. e. the\r\nmaximum size of a set of edges such that they all belong to the chosen\r\nspanning tree, and no vertex has more than one incident edge in this\r\nset), multiplied by the given integer c. Find any spanning tree with the\r\nminimum cost. Since the graph is connected, there exists at least one\r\nspanning tree.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 15.03.2024 11:00:45\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nclass dsu {\n public:\n  vector<int> p;\n  int n;\n\n  dsu(int _n) : n(_n) {\n    p.resize(n);\n    iota(p.begin(), p.end(), 0);\n  }\n\n  inline int get(int x) {\n    return (x == p[x] ? x : (p[x] = get(p[x])));\n  }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n      p[x] = y;\n      return true;\n    }\n    return false;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, c;\n  cin >> n >> c;\n  vector<vector<int>> w(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      cin >> w[i][j];\n    }\n  }\n  vector<array<int, 3>> edges;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (w[i][j] > 0) {\n        edges.push_back({w[i][j], i, j});\n      }\n    }\n  }\n  sort(edges.begin(), edges.end());\n  int ans = int(2e9);\n  for (int t = 0; t < (1 << n); t++) {\n    dsu d(n);\n    int cnt = 0;\n    int cost = 0;\n    for (auto& [x, i, j] : edges) {\n      if ((t & (1 << i)) && (t & (1 << j))) {\n        continue;\n      }\n      if (d.unite(i, j)) {\n        cnt += 1;\n        cost += x;\n      }\n    }\n    if (cnt == n - 1) {\n      ans = min(ans, cost + c * (n - __builtin_popcount(t)));\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "dsu", "graph matchings", "trees"], "dificulty": "3100", "interactive": false}