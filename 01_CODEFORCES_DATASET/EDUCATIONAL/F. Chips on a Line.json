{
    "link": "https://codeforces.com//contest/1997/problem/F",
    "problemId": "2784499",
    "problem_idx": "F",
    "shortId": "1997F",
    "contest_number": "1997",
    "problem_submissions": {
        "F": [
            273554813,
            273562336,
            273555588,
            273558521,
            273558184,
            273555359,
            273562297,
            273565830,
            273546283,
            273544285,
            273566836,
            273566119,
            273585907,
            273568802,
            273555309,
            273574760,
            273588700,
            273578615,
            273575242,
            273588906
        ],
        "E": [
            273537014,
            273527320,
            273531772,
            273535164,
            273526322,
            273540324,
            273541553,
            273544138,
            273572699,
            273564384,
            273777832,
            273550008,
            273548972,
            273536881,
            273554636,
            273544552,
            273556209,
            273544842,
            273546282,
            273666737,
            273666189,
            273553954,
            273545375
        ],
        "D": [
            273513568,
            273513144,
            273513742,
            273512836,
            273510170,
            273516169,
            273515679,
            273515838,
            273510617,
            273513446,
            273517815,
            273525464,
            273518352,
            273521955,
            273529234,
            273520142,
            273512102,
            273520565,
            273515266,
            273520749
        ],
        "C": [
            273496813,
            273497815,
            273498571,
            273503315,
            273497876,
            273499195,
            273500860,
            273502791,
            273499347,
            273496485,
            273508798,
            273507268,
            273509198,
            273511156,
            273522873,
            273509562,
            273503505,
            273507797,
            273508832,
            273510628
        ],
        "B": [
            273490300,
            273489109,
            273490092,
            273494428,
            273492341,
            273491848,
            273492911,
            273494262,
            273492523,
            273491731,
            273501850,
            273497360,
            273496735,
            273504535,
            273502692,
            273496964,
            273493065,
            273497766,
            273504790,
            273497879
        ],
        "A": [
            273486630,
            273485994,
            273491236,
            273487968,
            273486132,
            273486581,
            273486579,
            273487757,
            273487599,
            273486090,
            273488578,
            273489964,
            273488719,
            273489029,
            273504662,
            273489452,
            273486034,
            273487994,
            273500770,
            273488432
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132154",
    "editorial": "The operations described in the statement are kinda similar to the\r\nidentities for Fibonacci numbers, so maybe the solution will be\r\nconnected to them.Let\u00e2\u0080\u0099s assign each chip placement a weight: if chips\r\nare placed in points (repeating if multiple chips are in the same\r\nposition), the weight of this placement is , where is the -th Fibonacci\r\nnumber (; ).We can show that two placements can be transformed into each\r\nother if and only if their weights are identical. First of all, the\r\noperations described in the statement don\u00e2\u0080\u0099t change the weight, so two\r\nplacements with different weights cannot be transformed into each other.\r\nTo show how to transform two placements with identical weight into each\r\nother, let\u00e2\u0080\u0099s bring them into \"canonical\" form as follows: while there is\r\na chip with coordinate , convert it into two chips with coordinates and\r\n; if all remaining chips are in points and , move all chips from to .\r\nAfter performing this sequence of actions, we will transform a placement\r\nof chips into the form \"all chips are in point , and the number of these\r\nchips is equal to the weight of the placement\". And since all operations\r\nwe apply are invertible (for every operation, there is an operation\r\nwhich \"rolls it back\"), we can transform any placement to any other\r\nplacement with the same weight through this \"canonical form\".So, instead\r\nof counting the placements, let\u00e2\u0080\u0099s group them according to their weights\r\nand work with them. For every possible weight of a placement (which is\r\nan integer from to ), we need to answer two questions: Is it true that\r\nthe minimum cost of a placement of this weight is exactly ? How many\r\nplacements with this weight are there? The former is simple: this is\r\njust checking that the minimum number of Fibonacci numbers used to\r\nrepresent an integer is equal to . We can precalculate this minimum\r\nnumber of Fibonacci numbers to represent each integer with a simple\r\ndynamic programming.The latter is a bit more tricky: we need to count\r\nthe number of ways to represent the given number as a sum of exactly\r\nFibonacci numbers from to , where the order of these Fibonacci numbers\r\ndoes not matter. There are different ways to calculate it, the model\r\nsolution uses a dynamic programming which uses time and memory.Let be\r\nthe number of ways to partition the integer into Fibonacci numbers.\r\nInitially, we will consider the situation when we can\u00e2\u0080\u0099t use any\r\nFibonacci numbers, so and everything else is . And then we will \"add\"\r\nFibonacci numbers one by one, so first we will update our dynamic\r\nprogramming in such a way that we can only use ; then, only and/or ; and\r\nso on.Let\u00e2\u0080\u0099s show how to \"update\" our dynamic programming when we can use\r\na new number in partitions. The simple way to do this is as follows: for\r\nevery , iterate on the number of new elements we will use, and get a\r\npartition of integer into numbers. However, that is too slow.Instead,\r\nlet\u00e2\u0080\u0099s iterate on the states of our dynamic programming in ascending\r\norder of , and in each state, add at most one element to the partition\r\n(so, increase by ). At the first glance, it only allows us to use one\r\nelement equal to ; however, when we consider the state we updated, it\r\nwill already store both the partitions which didn\u00e2\u0080\u0099t use elements equal\r\nto , and the partitions which used at least one element equal to (which\r\ncame from the state ); and by transitioning from to , we will \"expand\"\r\nall these partitions.If the previous paragraph is a bit unclear to you,\r\nyou can try viewing it as a three-state dynamic programming of the form\r\n\"let be the number of partitions of into Fibonacci numbers from to \",\r\nwhere we dropped the third state of our dynamic programming in favor of\r\nmaintaining only one layer and being more memory efficient.\r\n",
    "name": "F. Chips on a Line",
    "statement": "You have n chips, and you are going to place all of them in one of x\r\npoints, numbered from 1 to x. There can be multiple chips in each\r\npoint.After placing the chips, you can perform the following four\r\noperations (in any order, any number of times): choose a chip in point i\r\nge 3, remove it and place two chips: one in i-1, one in i-2; choose two\r\nchips in adjacent points i and i+1, remove them and place a new chip in\r\ni+2; choose a chip in point 1 and move it to 2; choose a chip in point 2\r\nand move it to 1. Note that the coordinates of the chips you place\r\nduring the operations cannot be less than 1, but can be greater than\r\nx.Denote the of chip placement as the number of chips which can be\r\npresent on the line after you perform these operations, starting from\r\nthe placement you\u2019ve chosen.For example, the of placing two chips in\r\npoints 3 and one chip in point 5 is 2, because you can reduce the number\r\nof chips to 2 as follows: choose a chip in point 3, remove it, place a\r\nchip in 1 and another chip in 2; choose the chips in points 2 and 3,\r\nremove them and place a chip in 4; choose the chips in points 4 and 5,\r\nremove them and place a chip in 6. You are given three integers n, x and\r\nm. Calculate the number of placements of exactly n chips in points from\r\n1 to x having cost equal to m, and print it modulo 998244353. Two\r\nplacements are considered different if the number of chips in some point\r\ndiffers between these placements.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>//#define int li#define f first#define s second\u00a0using namespace std;using li = long long;using ld = long double;const int MOD = 998244353;const int N = 1005;\u00a0int dp[N][55 * N];\u00a0int add(int x, int y){    x += y;\u00a0    return (x >= MOD ? x - MOD : x);}\u00a0int mul(int x, int y){    return x * 1ll * y % MOD;}\u00a0int32_t main(){    ios_base::sync_with_stdio(0);    cin.tie(0);\u00a0    int n, x, m;    cin >> n >> x >> m;\u00a0    vector <int> F = {1, 1, 2, 3, 5, 8, 13, 21, 34, 55};\u00a0    dp[0][0] = 1;\u00a0    for(int i = 0; i < x; i++)    {        for(int k = 0; k < n; k++)            for(int s = F[i] * k; s >= k; s--)                if(dp[k][s])                    dp[k + 1][s + F[i]] = add(dp[k + 1][s + F[i]], dp[k][s]);    }\u00a0    while(F.back() < 1e6)        F.push_back(F.back() + F[F.size() - 2]);\u00a0    int ans = 0;\u00a0    for(int i = 0; i <= 55 * n; i++)    {        int cur = i, c = 0;\u00a0        for(int j = F.size() - 1; j >= 0; j--)            if(cur >= F[j])            {                cur -= F[j];                c++;            }\u00a0        if(c == m)            ans = add(ans, dp[n][i]);    }\u00a0    cout << ans;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Chips on a Line.json"
}