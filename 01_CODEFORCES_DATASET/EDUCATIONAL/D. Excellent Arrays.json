{
    "link": "https://codeforces.com//contest/1550/problem/D",
    "problemId": "1045984",
    "problem_idx": "D",
    "shortId": "1550D",
    "contest_number": "1550",
    "problem_submissions": {
        "F": [
            122483395,
            122494928,
            122494758,
            122498831,
            122495349,
            122507186,
            122504855,
            122499174,
            122495286,
            122505655,
            122503411,
            122504082,
            122506733,
            122503920,
            122507265,
            122505173,
            122514546,
            122521422,
            122608494,
            122664141
        ],
        "E": [
            122476565,
            122473503,
            122481437,
            122485433,
            122484524,
            122485212,
            122477724,
            122500057,
            122485157,
            122486711,
            122488337,
            122498290,
            122489523,
            122484119,
            122495271,
            122476181,
            122481232,
            122481328,
            122483526,
            122494342
        ],
        "D": [
            122471547,
            122486544,
            122474791,
            122475055,
            122481071,
            122477408,
            122494393,
            122479516,
            122495901,
            122496325,
            122494541,
            122483595,
            122476325,
            122488807,
            122472450,
            122476646,
            122472723,
            122476521,
            122472515
        ],
        "C": [
            122458749,
            122460413,
            122460329,
            122460157,
            122463960,
            122460682,
            122465581,
            122460735,
            122465109,
            122500532,
            122457985,
            122461570,
            122463484,
            122466793,
            122463616,
            122461328,
            122473999,
            122456442,
            122457482,
            122463020,
            122460109,
            122461048
        ],
        "B": [
            122454763,
            122454362,
            122455252,
            122454378,
            122452343,
            122454794,
            122458968,
            122500982,
            122454363,
            122455298,
            122455088,
            122454989,
            122455874,
            122454863,
            122466413,
            122453075,
            122454714,
            122455929,
            122454807,
            122453314
        ],
        "A": [
            122451771,
            122451821,
            122451970,
            122451770,
            122451715,
            122451928,
            122452304,
            122501407,
            122451789,
            122452298,
            122451870,
            122452153,
            122452203,
            122451998,
            122462780,
            122451777,
            122452058,
            122452234,
            122451766,
            122451752
        ]
    },
    "name": "D. Excellent Arrays",
    "statement": "Let\u2019s call an integer array a_1, a_2,\r\ndots, a_n if a_i\r\nneq i for each i.Let F(a) be the number of pairs (i, j) (1\r\nle i < j\r\nle n) such that a_i + a_j = i + j.Let\u2019s say that an array a_1, a_2,\r\ndots, a_n is if: a is ; l\r\nle a_i\r\nle r for each i; F(a) is the maximum possible among all arrays of size\r\nn. Given n, l and r, calculate the number of arrays modulo 10^9 + 7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nconstexpr int P = 1000000007;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, int b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, l, r;\n        std::cin >> n >> l >> r;\n        l--;\n        r--;\n        \n        std::vector<Z> fac(n + 1), invfac(n + 1);\n        fac[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = fac[i - 1] * i;\n        }\n        invfac[n] = fac[n].inv();\n        for (int i = n; i > 0; i--) {\n            invfac[i - 1] = invfac[i] * i;\n        }\n        \n        auto binom = [&](int n, int m) {\n            if (m < 0 || n < m) {\n                return Z(0);\n            }\n            \n            return fac[n] * invfac[m] * invfac[n - m];\n        };\n        \n        int e = std::min(-l, r - (n - 1));\n        \n        Z ans = binom(n, n / 2) * (1 + n % 2) * e;\n        \n        for (int x = e + 1; ; x++) {\n            int a = std::min(n, n - (l + x));\n            int b = std::min(n, r - x + 1);\n            if (a < 0 || b < 0) {\n                break;\n            }\n            \n            ans += binom(a + b - n, n / 2 - (n - b));\n            if (n % 2 == 1) {\n                ans += binom(a + b - n, n / 2 - (n - a));\n            }\n        }\n        \n        std::cout << ans.val() << \"\\n\";\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "constructive algorithms",
        "implementation",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Excellent Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/92864",
    "editorial": "Firstly, let\u00e2\u0080\u0099s learn the structure of good array with maximum . Suppose,\r\n, then . In other words, we can group by and pairs will appear only\r\ninside each group. It\u00e2\u0080\u0099s easy to prove that if the group has size then\r\nit\u00e2\u0080\u0099s optimal to split it in half: one with and other with . Then the\r\nnumber of pairs inside the group will be equal to .It\u00e2\u0080\u0099s also not hard to\r\nprove that in this case it\u00e2\u0080\u0099s optimal to place all elements inside one\r\ngroup. In other words, it\u00e2\u0080\u0099s optimal to make a half of all elements as\r\nand the other half as for some integer . Then .To achieve maximum the\r\nexcellent array should also have this structure. Let . For a fixed if is\r\neven then we should choose exactly positions to set as , but if is odd,\r\nwe can choose either or positions.Let\u00e2\u0080\u0099s analyze what happens with\r\ndifferent . Obviously, . While both and are in the segment for any . In\r\nthis case we can choose any as , so there are exactly ways for even and\r\nways for odd .When then for (where ) there is only one choice to set .\r\nAnalogically, for (where ) there is only choice to set .What remains is\r\nelements without restrictions, so there are ways to choose for even or\r\nways for odd .Note that it\u00e2\u0080\u0099s convenient to say that if or , so we don\u00e2\u0080\u0099t\r\nneed extra checks.Lastly, note that we can process all with one formula\r\nand there are only of with non-zero number of ways to choose, so we can\r\niterate over all such straightforwardly.The total complexity is because\r\nof precomputation of factorials and inverse factorials to calculate .\r\n"
}