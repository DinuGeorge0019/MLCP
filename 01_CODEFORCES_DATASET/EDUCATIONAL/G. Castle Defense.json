{
    "link": "https://codeforces.com//contest/954/problem/G",
    "problemId": "167344",
    "problem_idx": "G",
    "shortId": "954G",
    "contest_number": "954",
    "problem_submissions": {
        "I": [
            36483613,
            36489921,
            36491468,
            36492587,
            36489151,
            36505182,
            36498444,
            36489158,
            36493599,
            36495253,
            36493983,
            36523197,
            36517457,
            36494315,
            36517490
        ],
        "E": [
            36478770,
            36477321,
            36476296,
            36476332,
            36477191,
            36479277,
            36478407,
            36484072,
            36476637,
            36483722,
            36476830,
            36479359,
            36479273,
            36481624,
            36479515,
            36473956,
            36477339,
            36477449,
            36476422,
            36481260
        ],
        "D": [
            36478485,
            36475307,
            36474083,
            36478258,
            36474970,
            36476455,
            36476263,
            36472023,
            36474824,
            36478016,
            36474200,
            36476982,
            36476891,
            36474372,
            36477175,
            36479984,
            36487971,
            36474275,
            36474076,
            36475466
        ],
        "C": [
            36476002,
            36474037,
            36473020,
            36474296,
            36473832,
            36473968,
            36474218,
            36474540,
            36483525,
            36476724,
            36472809,
            36474171,
            36499291,
            36473004,
            36474442,
            36477242,
            36486700,
            36473123,
            36472782,
            36473808
        ],
        "G": [
            36475037,
            36479869,
            36479819,
            36482297,
            36479701,
            36481399,
            36480184,
            36480325,
            36481161,
            36480550,
            36485383,
            36482231,
            36482668,
            36492299,
            36483624,
            36487406,
            36490213,
            36485274,
            36478330,
            36479287
        ],
        "F": [
            36474930,
            36486416,
            36483404,
            36528491,
            36484207,
            36482822,
            36485630,
            36483061,
            36477477,
            36481839,
            36487500,
            36482960,
            36488051,
            36485000,
            36479677,
            36489393,
            36482816,
            36484976,
            36483377,
            36483862,
            36487177
        ],
        "H": [
            36473564,
            36483628,
            36486927,
            36487388,
            36497291,
            36492759,
            36492641,
            36496336,
            36493059,
            36491960,
            36490810,
            36488245,
            36487713,
            36489798,
            36483087
        ],
        "B": [
            36472231,
            36471541,
            36471094,
            36471718,
            36471325,
            36471918,
            36470816,
            36471290,
            36470543,
            36472680,
            36470969,
            36471052,
            36470688,
            36471049,
            36472812,
            36475352,
            36471581,
            36471121,
            36470814,
            36470886
        ],
        "A": [
            36470941,
            36470615,
            36469920,
            36470743,
            36470038,
            36470789,
            36469978,
            36470246,
            36469943,
            36471510,
            36470178,
            36469918,
            36469982,
            36470334,
            36471516,
            36475017,
            36470944,
            36470503,
            36470133,
            36470029
        ]
    },
    "name": "G. Castle Defense",
    "statement": "Today you are going to lead a group of elven archers to defend the\r\ncastle that is attacked by an army of angry orcs. Three sides of the\r\ncastle are protected by impassable mountains and the remaining side is\r\noccupied by a long wall that is split into sections. At this moment\r\nthere are exactly archers located at the -th section of this wall. You\r\nknow that archer who stands at section can shoot orcs that attack\r\nsection located at distance not exceeding , that is all such sections\r\nthat . In particular, means that archers are only capable of shooting at\r\norcs who attack section .Denote as of section the total number of\r\narchers who can shoot at the orcs attacking this section. of the defense\r\nplan is the minimum value of defense level of individual wall\r\nsection.There is a little time left till the attack so you can\u2019t\r\nredistribute archers that are already located at the wall. However,\r\nthere is a reserve of archers that you can distribute among wall\r\nsections in arbitrary way. You would like to achieve maximum possible\r\nreliability of the defence plan.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define ll long long\n#define MN 500000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,a[MN+5],r;ll K,s[MN+5];\nll Solve(ll mn)\n{\n\tll sum=0,now=0;\n\tfor(int i=1;i<=n;++i) s[i]=a[i];\n\tfor(int i=1;i<=r;++i) now+=s[i];\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tnow+=i+r>n?0:s[i+r];\n\t\tnow-=i-r-1<1?0:s[i-r-1];\n\t\tif(now<mn) \n\t\t\ts[min(n,i+r)]+=mn-now,\n\t\t\tsum=min(sum+mn-now,(ll)2e18),now=mn;\n\t}\n\treturn sum;\n}\nint main()\n{\n\tn=read();r=read();cin>>K;\n\tfor(int i=1;i<=n;++i) a[i]=read();\n\tll l=0,r=2e18,mid,res;\n\twhile(l<=r)\n\t{\n\t\tmid=l+r>>1;\n\t\tif(Solve(mid)<=K) res=mid,l=mid+1;\n\t\telse r=mid-1;\t\n\t}\n\tcout<<res;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Castle Defense.json",
    "editorial_link": "https://codeforces.com//blog/entry/58519",
    "editorial": "Firstly, if we may obtain reliability at least , then we may obtain\r\nreliability not less than with the same number of archers. So we may use\r\nbinary search and check whether we may obtain reliability at least .How\r\ncan we check it? Let\u00e2\u0080\u0099s find the leftmost section such that its defense\r\nlevel is less than . Let its index be . We obviously have to add some\r\narchers controlling this section, and since every section to the left of\r\nit is already controlled, the best option where to add archers is the\r\nsection with index . After we added enough archers, we move to next\r\nsection such that its defense level is less than and do the same. If we\r\nrun out of archers without protecting all the sections, then it\u00e2\u0080\u0099s\r\nimpossible to obtain reliability .To do checking in , we may use prefix\r\nsums or \"sliding window\" technique.\r\n"
}