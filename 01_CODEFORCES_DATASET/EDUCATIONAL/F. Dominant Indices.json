{"link": "https://codeforces.com//contest/1009/problem/F", "problemId": "197477", "problem_idx": "F", "shortId": "1009F", "contest_number": "1009", "problem_submissions": {"G": [40337017, 40344482, 40347659, 40342765, 40351012, 40613683, 40336492, 40349213, 40337741], "F": [40331912, 40335351, 40341055, 40326271, 40366871, 40337375, 40339584, 40331599, 40331423, 40337104, 40342347, 40336825, 40337577, 40334076, 40332995, 40334905, 40339639, 40341762, 40345859, 40345507, 40341669, 215690952, 215684676, 40336272, 40345346], "E": [40327402, 40339630, 40336328, 40335000, 40366869, 40332457, 40330418, 40333066, 40332727, 40332923, 40329479, 40339436, 40340189, 40333738, 40334590, 40335721, 40337167, 40331924, 40330467], "D": [40325966, 40326952, 40331312, 40347184, 40366860, 40326579, 40327728, 40326152, 40329257, 40328869, 40325869, 40330346, 40329823, 40330464, 40331724, 40328012, 40330977, 40330658, 40330073, 40327251], "C": [40324839, 40325628, 40328878, 40346059, 40366849, 40327763, 40326299, 40327852, 40327509, 40385547, 40328019, 40326916, 40328453, 40326671, 40327638, 40328508, 40329011, 40325946], "B": [40323467, 40323826, 40325417, 40344599, 40366836, 40324010, 40324378, 40323119, 40326571, 40324725, 40327206, 40325617, 40324071, 40326443, 40324733, 40324875, 40325110, 40325691, 40324074], "A": [40321909, 40321902, 40322488, 40343655, 40366827, 40321806, 40321963, 40321789, 40324683, 40322352, 40321812, 40321837, 40321964, 40321833, 40321918, 40322455, 40322763, 40322030, 40322345]}, "name": "F. Dominant Indices", "statement": "You are given a rooted undirected tree consisting of n vertices. Vertex\r\n1 is the root.Let\u2019s denote a of vertex x as an infinite sequence [d_{x,\r\n0}, d_{x, 1}, d_{x, 2},\r\ndots], where d_{x, i} is the number of vertices y such that both\r\nconditions hold: x is an ancestor of y; the simple path from x to y\r\ntraverses exactly i edges. The of a of vertex x (or, shortly, the of\r\nvertex x) is an index j such that: for every k < j, d_{x, k} < d_{x, j};\r\nfor every k > j, d_{x, k}\r\nle d_{x, j}. For every vertex in the tree calculate its .\r\n", "solutions": ["//nie, 3 cze 2018, 13:38:19 CEST\n//Konrad Paluszek, University of Warsaw (former XIV LO Staszic)\n# include <bits/stdc++.h>\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst bool local = \n#ifdef LOCAL\ntrue;\n#else\nfalse;\n#endif\n#define f first\n#define s second\n#define FOR(i, b, e) for (int i = (b); i <= (int)(e); ++i)\n#define FORD(i, b, e) for (int i = (b); i >= (int)(e); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define bvt(s, f) int s(int x){return f(x);}int s(UI x){return f(x);}int s(LL x){return f##ll(x);}int s(ULL x){return f##ll(x);}\n#define FORBITS(i,m)  for(decltype(m)lP6N4Slr=(m),i=lP6N4Slr?ctz(lP6N4Slr):0;lP6N4Slr;lP6N4Slr^=((decltype(m))1<<i),i=ctz(lP6N4Slr))\n#define FORDBITS(i,m) for(decltype(m)_6Im=(m),i=_6Im?8*sizeof(m)-clz(_6Im)-1:0;_6Im;_6Im^=((decltype(m))1<<i),i=8*sizeof(m)-clz(_6Im)-1)\n#define SUBS(i, mask) for(decltype(mask)i = (mask),NFR9xNQCJZTrYQ=1;NFR9xNQCJZTrYQ;NFR9xNQCJZTrYQ=i,i=(i-1)&(mask))\n#define PB push_back\n#define MP make_pair\n#define MT(a, b, c) MP(MP(a, b), c)\n#define MQ(a, b, c, d) MP(MP(a, b), MP(c, d))\n#define tri(a, b, c) pair <pair <a, b>, c>\n#define quadr(a, b, c, d) pair <pair <a, b>, pair <c, d> >\n#define EB emplace_back\n# define jvx(...)\n# define fkz(...) __VA_ARGS__ jvx()\n# define cxo(...) __VA_ARGS__\n#define uuu_id() uuu\nusing LL=long long;using PII=pair<int,int>;using VI=vector<int>;using SI=set<int>;\nusing MII=map<int,int>;using UMII=unordered_map<int, int>;using LD=long double;using TII=\npair<PII,int>;using QII=pair<PII,PII>;using UI=unsigned int;using ULL=unsigned long long;\n#define uuu(prev, t) using S##t=set<t>; using V##t=vector<t>; using M##t=map<t,t>;\\\n\tusing MI##t=map<int,t>;using US##t=unordered_set<t>; prev(S##t) prev(V##t)\n#define uuu_() uuu\n#define ymd(t) \n#define ymd2(t) fkz(uuu_)()(ymd, t)\n#define ymd3(t) cxo(cxo(cxo(fkz(uuu_)()(ymd2, t))))\n#define ymd4(t) using P##t = pair<t,t>; using T##t=tri(t,t,t); using Q##t=quadr(t,t,t,t); \\\n\tymd3(P##t) ymd3(T##t) ymd3(Q##t) ymd3(t)\nymd4(LL) ymd4(LD) ymd3(PII) ymd3(TII) ymd3(QII) ymd4(VI) ymd4(SI) ymd4(UI) ymd4(ULL)\nbvt(popc,__builtin_popcount)bvt(ctz,__builtin_ctz)bvt(clz,__builtin_clz)bvt(bit_parity,__builtin_parity)\n#define siz(r) ((int)r.size())\n#define ALL(r) r.begin(), r.end()\n#define sim template <class T\n#define ros return o\nsim,class N>bool mini(T&o,N h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(T&o,N h){if(o<h)ros=h,1;return 0;}\n#define oor >ostream &operator<<(ostream &o,\n#define urs(r) typename pta<typename remove_reference<decltype(r)>::type>::t\n#define bnt ;}sim> struct\nsim,class N oor pair<T,N>u){ros<<\"<\"<<u.f<<\", \"<<u.s<<\">\" bnt pta{using t=T;};sim,int N>struct pta<T[N]>{using t=T*;};\nsim,typename=typename enable_if<!is_same<T,string>::value,urs(T().end())>::type oor\nT u){int c=0;o<<\"{\";for(auto e:u)o<<\", \"+2*!c++<<e;ros<<\"}\";}\nint mpow(int b, int e) {int o = 1; while (e) {if (e & 1)o = o * 1ll * b % MOD;b = b * 1ll * b % MOD;e /= 2;}ros;}\nvoid dor(){cerr<<dec<<\"\\033[0m\"<<endl;}sim,class...N>void dor(T x,N...y){cerr<<boolalpha<<x<<\"; \";dor(y...);} const bool deb =\n#define acv(N,O) sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(N o, T x) {ros O N(x);} \\\n  sim> typename enable_if<is_arithmetic<T>::value, N>::type operator O(T o, N x) {return N(o) O x;} \\\n  sim> typename enable_if<is_arithmetic<T>::value || is_same<T,N>::value, N&>::type operator O##=(N &o, T x) {ros = o O N(x);}\n#ifdef DEB\ntrue;\n#define debug(c...)cerr<<\"\\033[1;\"<<30+__LINE__%8<<\"m[\"<<__FUNCTION__<<\"#\"<<__LINE__<<\"] \\033[\"<<30+(__LINE__/8+__LINE__*3)%8<<\"m\",::dor(c)\n#define rcu m);}g(+) g(-) g(*) g(/) g(%) g(<<) g(>>) g(^) g(|) g(&) g(>=) g(<=) g(>) g(<) g(!=) g(==)\n#define zub(h,t,n...) class N> auto operator h(n u)->nep<urs(t)> {return ngy(t,\nsim>string bte(T u){stringstream o;o<<u;ros.str()bnt nep;sim>T yyo(nep<T>);sim>nep<T>ngy(T v,string c,int m=0);sim>T yyo(T o){ros bnt\nnep{T v;string c;int m; nep<T>mask(){return ngy(v,c,1);}\n#define g(o) template<zub(o, v o u, N) \"(\" + bte(*this) + \") \" #o \" (\" + bte(u) + \")\", m);}\ntemplate<zub([],v[yyo(u)],N)c+\"[\"+bte(u)+\"]\",rcu};sim>nep<T>ngy(T v,string c,int m){return nep<T>{v,c,m};}\nsim>T yyo(nep<T> o){ros.v;}sim>int uhn(T){return 0;}sim>int uhn(nep<T>o){ros.m;}\n#define ccy(c, y) sim> class enable_if<c is_arithmetic<T>::value,string>::type ema(T u){return bte(y);}\nccy(,bitset<8*sizeof(T)>(u))ccy(!,u)sim,class N> string ema(pair<T,N> o) {return \"<\" + ema(o.f) + \", \" + ema(o.s) + \">\";}\n#define g(o) sim, zub(o, yyo(p) o u.v, T p, nep<N>) \"(\" + bte(p) + \") \" #o \" (\" + bte(u) + \")\", uhn(p) + u.m);}\nsim>string bte(nep<T>o){ros.c+\" = \"+(o.m?ema(o.v):bte(o.v));}sim oor nep<T>m){ros<<bte(rcu sim>nep<T>ngy(nep<T>o,string c=\"\",int m=0){ros;}\n#undef g\n#define imie(a...) ngy(a, #a)\n#define imask(a...) ngy(a, #a, 1)\n#define range(u, g, c) ngy(list<urs(u[0])>(&u[yyo(g)], &u[yyo(c)] + 1), #u \"[\" + bte(g) + \"...\" + bte(c) + \"]\")\n#define arr(a, i) imie(a)[imie(i)]\n#define arr2(a, i, j) imie(a)[imie(i)][imie(j)]\n#define arr3(a, i, j, k) imie(a)[imie(i)][imie(j)][imie(k)]\n#define arr4(a, i, j, k, q) imie(a)[imie(i)][imie(j)][imie(k)][imie(q)]\nvector <stringstream> lif;struct prux {prux() {lif.EB();}~prux() {lif.pop_back();}};\n#define mark_stack(c...) udz(__LINE__,c)\n#define udz(a,b...) erf(a, b)\n#define erf(l,c...) prux _4IJ1MYUxZy2p_Q##l;lif.back()<<\"\\033[1;\"<<30+l%8<<\"m[\"<<__FUNCTION__<<\\\n  \"#\"<<l<<\"] \\033[\"<<30+(l/8+l*3)%8<<\"m\";siw(c)\nvoid siw(){};sim, class...N> void siw(T x, N...y) {lif.back() << x << \"; \";siw(y...);}\n#define print_stack() cerr << \"STACK_TRACE_FROM:\" << __FUNCTION__ << \"#\" << __LINE__<<endl,nfl()\n#define ckx(o) template<zub(o, o yyo(u), nep<N>) #o \"(\" + bte(u) + \")\", u.m);}\nsim> struct tqaz{T a;int u,d,l,r;};sim> tqaz<T> zaqt(T a,int u,int d,int l,int r){return tqaz<T>{a,u,d,l,r};}\n#define matr(a,u,d,l,r) ngy(zaqt(a,yyo(u),yyo(d),yyo(l),yyo(r)), #a\"[\"+bte(u)+\"...\"+bte(d)+\"][\"+bte(l)+\"...\"+bte(r)+\"]\")\n#define avc(f) sim>string f(tqaz<T> x){vector<vector<string>> t;FOR(i,x.u,x.d){t.EB();FOR(j,x.l,x.r)t.back().PB(f(x.a[i][j]));}\\\nstringstream o;VI M;FOR(j,x.l,x.r){int m=0;FOR(i,x.u,x.d)maxi(m, siz(t[i-x.u][j-x.l]));M.PB(m);}FOR(i,x.u,x.d){o<<\"\\n\\t[\"<<i<<\"] \";\\\nFOR(j,x.l,x.r){REP(_, M[j-x.l]-siz(t[i-x.u][j-x.l]))o<<\" \";o<<t[i-x.u][j-x.l]<<((j+1)%5?\", \":\"; \");}}ros.str() + \"\\n\";}\nvoid nfl() {for (auto &s : lif)cerr << \"  \" << s.str() << \"\\033[m\" << endl;} ckx(+) ckx(-) ckx(!) ckx(~) avc(bte) avc(ema)\nstruct zet_p {int o;LD v;zet_p(LL x=0):o(x%MOD),v(x){} zet_p(LL x, LD y):o(x%MOD),v(y){} int get(){ros>=0?o:o+MOD;}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o,v+a.v);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o,v-a.v);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o,v*a.v);}\n  zet_p operator/(zet_p a) {assert(a.o != 0); return zet_p(o*1ll*mpow(a.o, MOD-2),v/a.v);}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nostream&operator<<(ostream &o, zet_p u) {ros<<\"[\"<<u.o<<\" @ \"<<u.v<<\"]\";}using frac_mod = zet_p;\n#else\nfalse;\nstruct zet_p {int o;int get(){ros>=0?o:o+MOD;}zet_p(LL x=0):o(x%MOD){}zet_p(int x):o(x%MOD){}\n  zet_p operator+(zet_p a) {return zet_p(o+a.o);}\n  zet_p operator-(zet_p a) {return zet_p(o-a.o);}\n  zet_p operator*(zet_p a) {return zet_p(o*1ll*a.o);}\n  zet_p operator/(zet_p a) {return zet_p(o*1ll*mpow(a.o, MOD - 2));}\n  bool operator==(zet_p a) {return (o-a.o)%MOD == 0;}};\nstruct frac_mod {int o,m;int get(){return (o*1ll*mpow(m,MOD-2)%MOD+MOD)%MOD;}frac_mod(int x=0):o(x%MOD),m(1){}frac_mod(LL x):o(x%MOD),m(1){}\n  frac_mod(LL a,LL b):o(a),m(b){}\n  frac_mod operator+(frac_mod a){return frac_mod(o*1ll*a.m+m*1ll*a.o,m*a.m);}\n  frac_mod operator-(frac_mod a){return frac_mod(o*1ll*a.m-m*1ll*a.o,m*a.m);}\n  frac_mod operator*(frac_mod a){return frac_mod(o*1ll*a.o,m*1ll*a.m);}\n  frac_mod operator/(frac_mod a){return frac_mod(o*1ll*a.m,m*1ll*a.o);}\n  bool operator==(frac_mod a) {return (o * 1ll * a.m - m * 1ll * a.o) % MOD == 0;}};\nacv(frac_mod, +) acv(frac_mod, -) acv(frac_mod, *) acv(frac_mod, /)\n#define debug(...)\n#define mark_stack(...)\n#define print_stack(...)\n#endif\nacv(zet_p, +) acv(zet_p, -) acv(zet_p, *) acv(zet_p, /)\n#define nok(o,c,r,l...) auto operator o(c p, r y)-> decltype(MP(l)) {return MP(l);}\n#define pcg(o) sim, class S, class N, class H> nok(o, pair<S u T>, pair<H u N>, p.f o y.f, p.s o y.s)\\\nsim,class S,class N,class=typename enable_if<!is_base_of<ios_base,typename remove_reference<T>::type>::value>::type>nok\\\n(o,T,pair<S u N>, p o y.f, p o y.s) sim, class S, class N> nok(o, pair<S u N>, T, p.f o y, p.s o y)\n#define clp(r) pcg(r) sim, class S, class N, class H> \\\n\tpair <T,S> & operator r##=(pair <T,S> &p, pair<N,H> y) {p.f r##= y.f; p.s r##= y.s; return p;}\\\n\tsim, class S, class N> pair <T,S> &operator r##=(pair<T,S> &p, N y) {p.f r##= y; p.s r##= y; return p;}\n#define u ,\n#define syd(o) sim, class N> auto operator o(pair<T,N> e) -> decltype(MP(o e.f, o e.s)) {return MP(o e.f, o e.s);}\nclp(+) clp(-) clp(*) clp(/) clp(%) clp(^) clp(|) clp(>>) clp(<<) clp(&) pcg(&&) pcg(||) syd(-) syd(+) syd(~) syd(!)\n#undef u\nsim> int dud(T &, T&);sim> char dud(T x, ...);\n#define muf(c...) {\\\n\tsim, class N> static T c get1(pair <T, N> c o){ros.f;}\\\n\tsim, class N> static N c get2(pair <T, N> c o){ros.s;}\\\n\tsim, class N, class S> static T c get1(tri(T, N, S) c o){ros.f.f;}\\\n\tsim, class N, class S> static N c get2(tri(T, N, S) c o){ros.f.s;}\\\n\tsim, class N, class S> static S c get3(tri(T, N, S) c o){ros.s;}\\\n\tsim, class N, class S, class H> static S c get3(quadr(T, N, S, H) c o){ros.s.f;}\\\n\tsim, class N, class S, class H> static H c get4(quadr(T, N, S, H) c o){ros.s.s;}\\\n};\ntemplate <class X> struct qul muf()\ntemplate <> struct qul <int> muf(&)\n#define get1(o) qul<decltype(dud(o, o))>::get1(o)\n#define get2(o) qul<decltype(dud(o, o))>::get2(o)\n#define get3(o) qul<decltype(dud(o, o))>::get3(o)\n#define get4(o) qul<decltype(dud(o, o))>::get4(o)\nsim, class N> using gyv = T;\nnamespace std {sim, class N> struct hash<pair<T,N>>{size_t operator()(const pair<T,N>&u)const {\n      return hash<T>()(u.f) * 440624741ULL ^ hash<N>()(u.s);}};\n  sim> struct hash<gyv<T, decltype(((T*)0)->end())>> {size_t operator()(const T& u) const {size_t o = 505347433;\nfor (auto e : u)o = hash<urs(e)>()(e) ^ o * 277953755ULL;ros;}};}\n\nconst int MN = 1e6 + 44;\nvoid PdAYB7V() {\n\tprint_stack();\n\tdebug(imie(MN) * 1ll * imie(MOD), \"make sure it is right!!!!\");\n\tdebug(\"make sure m, n aren't misused\");\n\tdebug(\"long longs!!!!!!!!!!!!!!!!!!!\");\n\tdebug(\"run with m, n = 1\");\n\tdebug(\"make sure bounds on values aren't misused\");\n\tdebug(\"Check time/memory limit\");\n\twhile (getchar() != EOF);\n\texit(0);\n}\n#define list list__us6eKL\nVI graf[MN];\nVI list[MN];\nint ans[MN];\nPII maxx[MN];\nvoid dfs(int x, int y = -1) {\n\tPII longest = MP(0, 0);\n\tfor (int v : graf[x])\n\t\tif (v != y) {\n\t\t\tdfs(v, x);\n\t\t\tmaxi(longest, MP((int)list[v].size(), v));\n\t\t}\n\tif (longest == MP(0, 0)) {\n\t\tlist[x] = {1};\n\t\tans[x] = 0;\n\t\tmaxx[x] = MP(1, 0);\n\t}\n\telse {\n\t\tswap(list[x], list[longest.s]);\n\t\tmaxx[x] = maxx[longest.s];\n\t\tfor (auto v : graf[x])\n\t\t\tif (v != y && v != longest.s) {\n\t\t\t\tdebug(imie(x), arr(list, v));\n\t\t\t\tREP(i, siz(list[v])) {\n\t\t\t\t\tlist[x][i + siz(list[x]) - siz(list[v])] += list[v][i];\n\t\t\t\tmaxi(maxx[x], MP(list[x][i + siz(list[x]) - siz(list[v])], i + siz(list[x]) - siz(list[v]) ));\n\t\t\t\t}\n\t\t\t}\n\t\tmaxi(maxx[x], MP(1, (int)list[x].size()));\n\t\tlist[x].PB(1);\n\t\tans[x] = list[x].size() - 1 - maxx[x].s;\n\t}\n\tdebug(arr(list, x), arr(maxx, x), arr(ans, x));\n}\nint main() {\n\t#ifdef DEB\n\tatexit(PdAYB7V);\n\t#endif\n\tint n;\n\tscanf(\"%d\", &n);\n\tREP(i, n - 1) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].PB(b);\n\t\tgraf[b].PB(a);\n\t}\n\tdfs(1);\n\tFOR(i, 1, n)\n\t\tprintf(\"%d\\n\", ans[i]);\n}\n\n\n"], "input": "", "output": "", "tags": ["data structures", "dsu", "trees"], "dificulty": "2300", "interactive": false}