{"link": "https://codeforces.com//contest/1535/problem/D", "problemId": "1005285", "problem_idx": "D", "shortId": "1535D", "contest_number": "1535", "problem_submissions": {"F": [118419611, 118426010, 118430867, 118426204, 118431979, 118430548, 118427577, 118427147, 118426507, 118434537, 118439125, 118438429, 118430864, 118436547, 118434959, 118453422, 118456471, 118456451, 118456355, 118456131, 118456058, 118456048, 118455909, 118455542, 118455503, 118455485], "E": [118400147, 118402299, 118394572, 118405499, 118401297, 118401883, 118414866, 118411914, 118414294, 118416129, 118415333, 118407183, 118406610, 118405332, 118409528, 118409895, 118409924, 118411325, 118411281, 118410495], "D": [118386781, 118389062, 118387245, 118390389, 118390997, 118394077, 118396153, 118398368, 118392634, 118407760, 118505002, 118402523, 118396763, 118398598, 118397636, 118397134, 118395495, 118396828, 118399622, 118398243, 118400710, 118402452], "C": [118378877, 118377465, 118375938, 118430752, 118379578, 118379282, 118380197, 118383333, 118382719, 118391368, 118391117, 118384601, 118383707, 118399476, 118384199, 118383290, 118382649, 118384396, 118382126, 118382935, 118380453, 118382432], "B": [118372987, 118446923, 118371985, 118371638, 118369895, 118374146, 118373752, 118371435, 118372857, 118372165, 118379497, 118375234, 118373646, 118372652, 118378295, 118372318, 118372891, 118372700, 118376055, 118373052, 118370572], "A": [118369280, 118369165, 118369096, 118369133, 118369295, 118369220, 118369112, 118369384, 118369143, 118369677, 118369872, 118369144, 118369236, 118370094, 118369134, 118369278, 118369451, 118369228, 118369772, 118369174]}, "name": "D. Playoff Tournament", "statement": "2^k teams participate in a playoff tournament. The tournament consists\r\nof 2^k - 1 games. They are held as follows: first of all, the teams are\r\nsplit into pairs: team 1 plays against team 2, team 3 plays against team\r\n4 (exactly in this order), and so on (so, 2^{k-1} games are played in\r\nthat phase). When a team loses a game, it is eliminated, and each game\r\nresults in elimination of one team (there are no ties). After that, only\r\n2^{k-1} teams remain. If only one team remains, it is declared the\r\nchampion; otherwise, 2^{k-2} games are played: in the first one of them,\r\nthe winner of the game \"1 vs 2\" plays against the winner of the game \"3\r\nvs 4\", then the winner of the game \"5 vs 6\" plays against the winner of\r\nthe game \"7 vs 8\", and so on. This process repeats until only one team\r\nremains.For example, this picture describes the chronological order of\r\ngames with k = 3: Let the string s consisting of 2^k - 1 characters\r\ndescribe the results of the games in chronological order as follows: if\r\ns_i is , then the team with lower index wins the i-th game; if s_i is ,\r\nthen the team with greater index wins the i-th game; if s_i is , then\r\nthe result of the i-th game is unknown (any team could win this game).\r\nLet f(s) be the number of of the tournament described by the string s. A\r\nteam i is a of the tournament if it is possible to replace every with\r\neither or in such a way that team i is the champion.You are given the\r\ninitial state of the string s. You have to process q queries of the\r\nfollowing form: p c replace s_p with character c, and print f(s) as the\r\nresult of the query.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int k;\n  cin >> k;\n  string s;\n  cin >> s;\n  reverse(s.begin(), s.end());\n  int n = (1 << k) * 2 - 1;\n  vector<int> dp(n, 0);\n  for (int i = 0; i < (1 << k); i++){\n    dp[(1 << k) - 1 + i] = 1;\n  }\n  for (int i = (1 << k) - 2; i >= 0; i--){\n    if (s[i] == '1' || s[i] == '?'){\n      dp[i] += dp[i * 2 + 1];\n    }\n    if (s[i] == '0' || s[i] == '?'){\n      dp[i] += dp[i * 2 + 2];\n    }\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++){\n    int p;\n    char c;\n    cin >> p >> c;\n    p = (1 << k) - 1 - p;\n    s[p] = c;\n    dp[p] = 0;\n    if (s[p] == '1' || s[p] == '?'){\n      dp[p] += dp[p * 2 + 1];\n    }\n    if (s[p] == '0' || s[p] == '?'){\n      dp[p] += dp[p * 2 + 2];\n    }\n    while (p > 0){\n      p = (p - 1) / 2;\n      dp[p] = 0;\n      if (s[p] == '1' || s[p] == '?'){\n        dp[p] += dp[p * 2 + 1];\n      }\n      if (s[p] == '0' || s[p] == '?'){\n        dp[p] += dp[p * 2 + 2];\n      }\n    }\n    cout << dp[0] << \"\\n\";\n  }\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "dp", "implementation", "trees"], "dificulty": "1800", "interactive": false}