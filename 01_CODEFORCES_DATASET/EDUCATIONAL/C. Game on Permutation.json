{
    "link": "https://codeforces.com//contest/1860/problem/C",
    "problemId": "2169699",
    "problem_idx": "C",
    "shortId": "1860C",
    "contest_number": "1860",
    "problem_submissions": {
        "F": [
            219298549,
            219320447,
            219349019,
            219323121,
            219334429,
            219337442,
            219335056,
            219339341,
            219339231,
            219349246,
            219345811,
            219439688,
            219439045,
            219356857,
            219353864,
            219402976,
            219353456,
            219351823
        ],
        "E": [
            219277150,
            219281408,
            219287269,
            219300383,
            219293770,
            219301781,
            219289069,
            219306188,
            219288291,
            219288789,
            219301050,
            219298191,
            219305638,
            219306388,
            219300992,
            219313680,
            219301529,
            219309490,
            219305863,
            219309540,
            219307800
        ],
        "D": [
            219271388,
            219273923,
            219270716,
            219286342,
            219405254,
            219345669,
            219344552,
            219277413,
            219284438,
            219280247,
            219290826,
            219278202,
            219277998,
            219274616,
            219275328,
            219282484,
            219281832,
            219279471,
            219288325,
            219282155,
            219284217,
            219287012,
            219287888
        ],
        "C": [
            219264168,
            219264568,
            219266116,
            219265339,
            219269044,
            219276912,
            219269876,
            219279690,
            219266598,
            219268637,
            219263040,
            219261658,
            219264629,
            219267625,
            219267964,
            219267177,
            219271968,
            219274243,
            219264405,
            219273316
        ],
        "B": [
            219260635,
            219258799,
            219260447,
            219259349,
            219260950,
            219267717,
            219262012,
            219271581,
            219260726,
            219261008,
            219259442,
            219257734,
            219259759,
            219262401,
            219260169,
            219259084,
            219263649,
            219264522,
            219272480,
            219264690
        ],
        "A": [
            219257237,
            219257029,
            219257674,
            219257720,
            219257171,
            219258923,
            219257078,
            219260398,
            219257258,
            219257446,
            219257236,
            219256961,
            219257126,
            219257819,
            219257229,
            219257120,
            219257449,
            219257142,
            219257016,
            219258968
        ]
    },
    "name": "C. Game on Permutation",
    "statement": "Alice and Bob are playing a game. They have a permutation p of size n (a\r\npermutation of size n is an array of size n where each element from 1 to\r\nn occurs exactly once). They also have a chip, which can be placed on\r\nany element of the permutation.Alice and Bob make alternating moves:\r\nAlice makes the first move, then Bob makes the second move, then Alice\r\nmakes the third move, and so on. During the first move, Alice chooses\r\nany element of the permutation and places the chip on that element.\r\nDuring each of the next moves, the current player move the chip to any\r\nelement that is simultaneously to the left and strictly less than the\r\ncurrent element (i. e. if the chip is on the i-th element, it can be\r\nmoved to the j-th element if j < i and p_j < p_i). If a player cannot\r\nmake a move (it is impossible to move the chip according to the rules of\r\nthe game), that player the game.Let’s say that the i-th element of the\r\npermutation is if the following condition holds: if Alice places the\r\nchip on the i-th element during her first move, she can win the game no\r\nmatter how Bob plays (i. e. she has a winning strategy). You have to\r\ncalculate the number of lucky elements in the permutation.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> p[i];\n        p[i]--;\n    }\n    \n    int minlose = n;\n    int min = n;\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int win = 0;\n        if (p[i] < min) {\n            min = p[i];\n            win = 1;\n        } else {\n            win = (minlose < p[i]);\n        }\n        if (!win) {\n            ans += 1;\n            minlose = std::min(minlose, p[i]);\n        }\n    }\n    \n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "games",
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Game on Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/119504",
    "editorial": "For each position , letâs determine its : whether this position is\r\nwinning or losing for . Since a player can only move a chip into a\r\nposition with smaller index, we can determine the statuses of positions\r\nin the order from to . You can treat it as dynamic programming.If there\r\nis no such that and , then this position is a losing one, because the\r\nother player cannot make a move, which means they win (and the player\r\nwho placed the chip in that position loses). Otherwise, the other player\r\ncan make a move. And we already know whether the player wins if they\r\nplace a chip for all previous positions. If there exists a position\r\nwhere a move can be made and is a winning position, then is a losing one\r\n(because our opponent will move there). Otherwise, is a winning\r\nposition. Thus, we have a solution with a time complexity of , for each\r\nposition , we need to iterate through all possible transitions .However,\r\nwe can notice that we are only interested in two simple properties to\r\ndetermine the status of each position: whether a move can be made from\r\nthe current position, and whether a move can be made into a winning\r\nposition. The first property can be easily checked if we maintain the\r\nminimum element up to the current position , letâs call it . And for the\r\nsecond property, it is sufficient to maintain the minimum element among\r\nwinning positions, letâs call it . Then, position is winning if and .\r\nThus, the time complexity of the solution is .\r\n",
    "hint": []
}