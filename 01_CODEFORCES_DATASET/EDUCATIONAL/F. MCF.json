{"link": "https://codeforces.com//contest/1766/problem/F", "problemId": "1690151", "problem_idx": "F", "shortId": "1766F", "contest_number": "1766", "problem_submissions": {"E": [184982392, 184982173, 184938042, 184950686, 184932260, 184939673, 184936898, 184934396, 184948204, 184935811, 184943315, 184989151, 184947057, 184952057, 184938439, 184967483, 187916344, 184948513, 184933180, 184935854, 184939624, 184943840, 184943132, 184940980], "F": [184949728, 184939667, 184976950, 184964579, 184958474, 184962483, 184966185, 184957638, 184969067, 185089664, 185089530, 184977947, 184997639, 184973757, 184966070, 184960435, 184974697, 184966631, 184990205, 184997420], "D": [184914984, 184986868, 184986781, 184917638, 184915781, 184923898, 184923871, 184918405, 184919375, 184923813, 184918585, 184915933, 184925192, 184969262, 184952734, 184970967, 184919304, 184918923, 184922752, 184918317, 184920694, 184924980], "C": [184909482, 184913973, 184911632, 184918401, 184916364, 185395845, 184914719, 184914076, 184920058, 184913612, 184913225, 184921601, 184918048, 184950984, 184973944, 184914889, 184913008, 184914015, 184915845, 184914942, 184915187], "B": [184907198, 184909422, 184907991, 184909353, 184910422, 184907995, 184908723, 184907965, 184908129, 184908832, 184911921, 184911885, 184949263, 184977162, 184909079, 184908305, 184909027, 184908934, 184911337, 184910448], "A": [184906447, 184906808, 184906511, 184906536, 184906567, 184906521, 184906485, 184906494, 184906490, 184992052, 184907067, 184906532, 184906851, 184947991, 184978729, 184906583, 184906564, 184906598, 184906512, 184906683, 184906543]}, "name": "F. MCF", "statement": "You are given a graph consisting of n vertices and m directed arcs. The\r\ni-th arc goes from the vertex x_i to the vertex y_i, has capacity c_i\r\nand weight w_i. No arc goes into the vertex 1, and no arc goes from the\r\nvertex n. There are no cycles of negative weight in the graph (it is\r\nimpossible to travel from any vertex to itself in such a way that the\r\ntotal weight of all arcs you go through is negative).You have to assign\r\neach arc a flow (an integer between 0 and its capacity, inclusive). For\r\nevery vertex , the total flow on the arcs going to this vertex must be\r\nequal to the total flow on the arcs going from that vertex. Let the flow\r\non the i-th arc be f_i, then the cost of the flow is equal to\r\nsum\r\nlimits_{i = 1}^{m} f_i w_i. You have to find a flow which the\r\ncost.Sounds classical, right? Well, we have some additional constraints\r\non the flow on every edge: if c_i is even, f_i must be even; if c_i is\r\nodd, f_i must be odd. Can you solve this problem?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 10000000;\ntemplate <typename Cap, typename Cost>\nstruct primal_dual{\n\tstruct edge{\n\t\tint to, rev, id;\n\t\tCap cap;\n\t\tCost cost;\n\t\tedge(int to, int rev, int id, Cap cap, Cost cost): to(to), rev(rev), id(id), cap(cap), cost(cost){\n\t\t}\n\t};\n\tint N, M;\n\tvector<vector<edge>> G;\n\tprimal_dual(){\n\t}\n\tprimal_dual(int N): N(N), M(0), G(N){\n\t}\n\tvoid add_edge(int from, int to, Cap cap, Cost cost){\n\t\tint id1 = G[from].size();\n\t\tint id2 = G[to].size();\n\t\tG[from].push_back(edge(to, id2, M, cap, cost));\n\t\tG[to].push_back(edge(from, id1, ~M, 0, - cost));\n\t\tM++;\n\t}\n\tpair<Cap, Cost> min_cost_flow(int s, int t, Cap F){\n\t\tCap flow = 0;\n\t\tCost cost = 0;\n\t\tvector<Cost> h(N, 0);\n\t\twhile (flow < F){\n\t\t\tvector<Cap> m(N, INF);\n\t\t\tvector<Cost> d(N, INF);\n\t\t\tvector<int> pv(N, -1);\n\t\t\tvector<int> pe(N, -1);\n\t\t\tvector<bool> used(N, false);\n\t\t\tpriority_queue<pair<Cost, int>, vector<pair<Cost, int>>, greater<pair<Cost, int>>> pq;\n\t\t\tpq.push(make_pair(0, s));\n\t\t\td[s] = 0;\n\t\t\twhile (!pq.empty()){\n\t\t\t\tint v = pq.top().second;\n\t\t\t\tpq.pop();\n\t\t\t\tif (!used[v]){\n\t\t\t\t\tused[v] = true;\n\t\t\t\t\tif (v == t){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint cnt = G[v].size();\n\t\t\t\t\tfor (int i = 0; i < cnt; i++){\n\t\t\t\t\t\tint w = G[v][i].to;\n\t\t\t\t\t\tif (!used[w] && G[v][i].cap > 0){\n\t\t\t\t\t\t\tCost tmp = G[v][i].cost - h[w] + h[v];\n\t\t\t\t\t\t\tif (d[w] > d[v] + tmp){\n\t\t\t\t\t\t\t\td[w] = d[v] + tmp;\n\t\t\t\t\t\t\t\tm[w] = min(m[v], G[v][i].cap);\n\t\t\t\t\t\t\t\tpv[w] = v;\n\t\t\t\t\t\t\t\tpe[w] = i;\n\t\t\t\t\t\t\t\tpq.push(make_pair(d[w], w));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!used[t]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\tif (used[i]){\n\t\t\t\t\th[i] -= d[t] - d[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tCap c = min(m[t], F - flow);\n\t\t\tfor (int i = t; i != s; i = pv[i]){\n\t\t\t\tG[pv[i]][pe[i]].cap -= c;\n\t\t\t\tG[i][G[pv[i]][pe[i]].rev].cap += c;\n\t\t\t}\n\t\t\tflow += c;\n\t\t\tcost += c * (- h[s]);\n\t\t}\n\t\treturn make_pair(flow, cost);\n\t}\n};\nint main(){\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(m), y(m), c(m), w(m);\n  for (int i = 0; i < m; i++){\n    cin >> x[i] >> y[i] >> c[i] >> w[i];\n    x[i]--;\n    y[i]--;\n  }\n  vector<int> b(n, 0);\n  primal_dual<int, int> G(n + 2);\n  for (int i = 0; i < m; i++){\n    if (c[i] % 2 == 1){\n      b[x[i]]--;\n      b[y[i]]++;\n    }\n    int c2 = c[i] / 2 * 2;\n    if (w[i] >= 0){\n      G.add_edge(x[i], y[i], c2, w[i]);\n    } else {\n      b[x[i]] -= c2;\n      b[y[i]] += c2;\n      G.add_edge(y[i], x[i], c2, -w[i]);\n    }\n  }\n  G.add_edge(n - 1, 0, INF, 0);\n  bool ok = true;\n  for (int i = 1; i < n - 1; i++){\n    if (b[i] % 2 != 0){\n      ok = false;\n    }\n  }\n  if (!ok){\n    cout << \"Impossible\" << endl;\n  } else {\n    if (b[0] % 2 != 0){\n      b[0]++;\n      b[n - 1]--;\n    }\n    int sum = 0;\n    for (int i = 0; i < n; i++){\n      if (b[i] > 0){\n        G.add_edge(n, i, b[i], 0);\n        sum += b[i];\n      }\n      if (b[i] < 0){\n        G.add_edge(i, n + 1, -b[i], 0);\n      }\n    }\n    pair<int, int> res = G.min_cost_flow(n, n + 1, INF);\n    if (res.first != sum){\n      cout << \"Impossible\" << endl;\n    } else {\n      vector<int> ans(m);\n      for (int i = 0; i < n; i++){\n        for (primal_dual<int, int>::edge e : G.G[i]){\n          if (0 <= e.id && e.id < m){\n            if (w[e.id] >= 0){\n              ans[e.id] = c[e.id] - e.cap;\n            } else {\n              ans[e.id] = c[e.id] % 2 + e.cap;\n            }\n          }\n        }\n      }\n      cout << \"Possible\" << endl;\n      for (int i = 0; i < m; i++){\n        cout << ans[i];\n        if (i < m - 1){\n          cout << ' ';\n        }\n      }\n      cout << endl;\n    }\n  }\n}"], "input": "", "output": "", "tags": ["flows"], "dificulty": "2800", "interactive": false}