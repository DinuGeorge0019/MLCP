{"link": "https://codeforces.com//contest/1463/problem/D", "problemId": "836004", "problem_idx": "D", "shortId": "1463D", "contest_number": "1463", "problem_submissions": {"F": [101559554, 101581978, 101567286, 101577708, 101580696, 101680102, 101680098, 101605801, 101605564, 101602968, 101602931, 101594909, 101594099, 102434679, 101661639, 101713126, 101711433, 101812801], "E": [101543691, 101541624, 101550722, 101542275, 101561956, 101542640, 101551028, 101551947, 101553418, 101552115, 101553474, 101556641, 101557969, 101556648, 101554530, 101557890, 101556692, 101561428, 101553035], "D": [101533227, 101528710, 101537667, 101530458, 101531312, 101543635, 101536909, 101536759, 101540131, 101537456, 101542046, 101537094, 101540598, 101539288, 101544433, 101525965, 101526650, 101536306, 101544222], "C": [101526320, 101520150, 101529141, 101525986, 101523000, 101525367, 101530714, 101526273, 102544695, 101524853, 101531194, 101530250, 101529215, 101530504, 101529471, 101533604, 101540078, 101541782, 101523573, 101536896], "B": [101518923, 101515147, 101518366, 101516293, 101513263, 101522496, 101520454, 101515435, 101517061, 101515098, 101516483, 101522667, 101516542, 101515577, 101515224, 101517780, 101517682, 101515176, 101521789], "A": [101515277, 101512560, 101513602, 101512825, 101512593, 101512667, 101513802, 101512900, 101514221, 101512986, 101513229, 101513515, 101512759, 101512530, 101512877, 101514648, 101514992, 101512816, 101514556]}, "name": "D. Pairs", "statement": "You have 2n integers 1, 2,\r\ndots, 2n. You have to redistribute these 2n elements into n pairs. After\r\nthat, you choose x pairs and take minimum elements from them, and from\r\nthe other n - x pairs, you take maximum elements.Your goal is to obtain\r\nthe set of numbers\r\n{b_1, b_2,\r\ndots, b_n\r\n} as the result of taking elements from the pairs.What is the number of\r\ndifferent x-s (0\r\nle x\r\nle n) such that it\u2019s possible to obtain the set b if for each x you can\r\nchoose how to distribute numbers into pairs and from which x pairs\r\nchoose minimum elements?\r\n", "solutions": ["#pragma GCC optimize(\"Ofast\")\n#pragma GCC target (\"sse4\")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nvoid solve() {\n\tint n; cin >> n;\n\tvector<int> b(n);\n\trep(i, n) {\n\t\tcin >> b[i]; b[i]--;\n\t}\n\tvector<bool> exi(2 * n);\n\trep(i, n)exi[b[i]] = true;\n\t//[0,2n)\n\tauto canl = [&](int num)->bool {\n\t\tif (num == 0)return true;\n\t\tint sup = b[num - 1];\n\t\tint c = 0;\n\t\tper(i, 2 * n) {\n\t\t\tif (exi[i]) {\n\t\t\t\tif (i <= sup) {\n\t\t\t\t\tif (c == 0)return false;\n\t\t\t\t\tc--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tauto canr = [&](int num)->bool {\n\t\tif (num == 0)return true;\n\t\tint inf = b[n - num];\n\t\tint c = 0;\n\t\trep(i, 2 * n) {\n\t\t\tif (exi[i]) {\n\t\t\t\tif (i >= inf) {\n\t\t\t\t\tif (c == 0)return false;\n\t\t\t\t\tc--;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tint l1 = -1, r1 = n + 1;\n\twhile (r1 - l1 > 1) {\n\t\tint m = (l1 + r1) / 2;\n\t\tif (canl(m)) {\n\t\t\tl1 = m;\n\t\t}\n\t\telse {\n\t\t\tr1 = m;\n\t\t}\n\t}\n\tint l2 = -1, r2 = n + 1;\n\twhile (r2 - l2 > 1) {\n\t\tint m = (l2 + r2) / 2;\n\t\tif (canr(m)) {\n\t\t\tl2 = m;\n\t\t}\n\t\telse {\n\t\t\tr2 = m;\n\t\t}\n\t}\n\t//cout << l1 << \" \" << l2 << \"\\n\";\n\tint ans = l1-(n - l2)+ 1; if (ans < 0)ans = 0;\n\tcout << ans << \"\\n\";\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["binary search", "constructive algorithms", "greedy", "two pointers"], "dificulty": "1900", "interactive": false}