{
    "link": "https://codeforces.com//contest/1651/problem/C",
    "problemId": "1324098",
    "problem_idx": "C",
    "shortId": "1651C",
    "contest_number": "1651",
    "problem_submissions": {
        "C": [
            149173723,
            149105792,
            149117381,
            149152549,
            149106514,
            149108421,
            149108464,
            149108635,
            149109429,
            149110791,
            149109777,
            149108515,
            149109773,
            149111699,
            149114619,
            149106949,
            149113559,
            149129766
        ],
        "F": [
            149161364,
            149158834,
            149161121,
            149123303,
            149175934,
            149179491,
            191725924,
            149575413
        ],
        "E": [
            149139170,
            149130164,
            149147455,
            149137360,
            149140976,
            149145909,
            149141908,
            149139460,
            149147248,
            149148678,
            149156290,
            149148881,
            149154274,
            149143485,
            149163314,
            149138047,
            149159145
        ],
        "D": [
            149127559,
            149163309,
            149150118,
            149115060,
            149119439,
            149116468,
            149116651,
            149118386,
            149120734,
            149121740,
            149119776,
            149192081,
            149191968,
            149191879,
            149191841,
            149191815,
            149191600,
            149191163,
            149191124,
            149128435,
            149129157,
            149129578,
            149116059,
            149145989,
            149116064
        ],
        "B": [
            149098208,
            149096317,
            149154308,
            149094973,
            149099387,
            149095439,
            149099190,
            149096388,
            149097486,
            149098725,
            149098039,
            149097903,
            149102336,
            149093030,
            149096020,
            149099865,
            149101390
        ],
        "A": [
            149092351,
            149091868,
            149155144,
            149091621,
            149091628,
            149091655,
            149091686,
            149091765,
            149091751,
            149092326,
            149091819,
            149092231,
            149094932,
            149091603,
            149091630,
            149091669,
            149092684
        ]
    },
    "name": "C. Fault-tolerant Network",
    "statement": "There is a classroom with two rows of computers. There are n computers\r\nin each row and each computer has its own grade. Computers in the first\r\nrow has grades a_1, a_2,\r\ndots, a_n and in the second row b_1, b_2,\r\ndots, b_n.Initially, all pairs of computers in each row are connected by\r\nwire (pairs (i, i + 1) for all 1\r\nle i < n), so two rows form two independent computer networks.Your task\r\nis to combine them in one common network by connecting one or more pairs\r\nof computers from rows. Connecting the i-th computer from the first row\r\nand the j-th computer from the second row costs |a_i - b_j|.You can\r\nconnect one computer to several other computers, but you need to provide\r\nat least a basic fault tolerance: you need to connect computers in such\r\na way that the network stays connected, despite one of its computer\r\nfailing. In other words, if one computer is broken (no matter which\r\none), the network won\u2019t split in two or more parts.That is the minimum\r\ntotal cost to make a fault-tolerant network?\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    vl A(N); F0R(i, N) cin >> A[i];\n    vl B(N); F0R(i, N) cin >> B[i];\n    ll ans = min(abs(A[0] - B[0]) + abs(A[N-1] - B[N-1]), abs(A[0] - B[N-1]) + abs(A[N-1] - B[0]));\n\n    ll cost[4]; F0R(i, 4) cost[i] = 1e12;\n    F0R(i, N) {\n        ckmin(cost[0], abs(A[0] - B[i]));\n        ckmin(cost[1], abs(A[N-1] - B[i]));\n        ckmin(cost[2], abs(A[i] - B[0]));\n        ckmin(cost[3], abs(A[i] - B[N-1]));\n    }\n\n    ckmin(ans, abs(A[0] - B[0]) + cost[1] + cost[3]);\n    ckmin(ans, abs(A[0] - B[N-1]) + cost[1] + cost[2]);\n    ckmin(ans, abs(A[N-1] - B[0]) + cost[0] + cost[3]);\n    ckmin(ans, abs(A[N-1] - B[N-1]) + cost[0] + cost[2]);\n\n    ckmin(ans, cost[0] + cost[1] + cost[2] + cost[3]);\n\n    cout << ans << nl;\n    \n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Fault-tolerant Network.json",
    "editorial_link": "https://codeforces.com//blog/entry/100796",
    "editorial": "There is a criterion when the given network becomes fault-tolerant: the\r\nnetwork becomes fault-tolerant if and only if each of corner computers\r\n(let\u00e2\u0080\u0099s name them , , and ) is connected to the other row.From the one\r\nside: if, WLOG, is not connected to other row then if is broken loses\r\nconnection to the other network (since is connected only with ).From the\r\nother side: suppose, WLOG, is broken, then the row is falling in at most\r\ntwo parts: and . But since both and are connected to row and is still\r\nconnected, then the resulting network is still connected.Now the\r\nquestion is: how to connect all corner computers? Because sometimes it\u00e2\u0080\u0099s\r\noptimal not to connect corners directly. One of the approaches is\r\ndescribed below.Let\u00e2\u0080\u0099s look at . Essentially, there are three ways to\r\nconnect it to row : to , or (where is with minimum possible ). The same\r\napplies to .So, let\u00e2\u0080\u0099s just iterate over all these variants. For each of\r\nthese variants, if we didn\u00e2\u0080\u0099t cover then we should also add one more\r\nconnection between and ; if we didn\u00e2\u0080\u0099t cover then we should also add one\r\nmore connection between and ; As a result, we choose the best variant.\r\n"
}