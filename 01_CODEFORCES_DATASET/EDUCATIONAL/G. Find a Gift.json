{
    "link": "https://codeforces.com//contest/1354/problem/G",
    "problemId": "623450",
    "problem_idx": "G",
    "shortId": "1354G",
    "contest_number": "1354",
    "problem_submissions": {
        "G": [
            80502712,
            80500640,
            80479424,
            80521575,
            80514570,
            80507519,
            80516727,
            80506952,
            80522749,
            80517834
        ],
        "F": [
            80492752,
            80491818,
            80486741,
            80486733,
            80498606,
            80506559,
            80492000,
            80506147,
            80493453,
            80507365,
            80500930,
            80492368,
            80502196,
            80506705,
            80501348,
            80502603,
            80507003,
            80504378,
            80500666,
            80509209
        ],
        "E": [
            80478361,
            80481693,
            80494073,
            80473313,
            80489080,
            80489590,
            80500698,
            80489890,
            80484400,
            80477593,
            80478451,
            80492063,
            80495115,
            80483322,
            80494477,
            80486894,
            80494427,
            80491606,
            80488314
        ],
        "D": [
            80469519,
            80470691,
            80498555,
            80467168,
            80480497,
            80478286,
            80477445,
            80477111,
            80466399,
            80471019,
            80473056,
            80471601,
            80482362,
            80488495,
            80473238,
            80482948,
            80466995,
            80486731,
            80484796,
            80475358
        ],
        "C2": [
            80463522,
            80484245,
            80502970,
            80478908,
            80472069,
            80468985,
            80468689,
            80472664,
            80476619,
            80476720,
            80489656,
            80477361,
            80476069,
            80503667,
            80473397,
            80472911,
            80489616,
            80481827,
            80482549,
            80500296
        ],
        "C1": [
            80463378,
            80464968,
            80501505,
            80478534,
            80468463,
            80462050,
            80463990,
            80463377,
            80459508,
            80460645,
            80463967,
            80465199,
            80472341,
            80461193,
            80463170,
            80458830,
            80475032,
            80470173,
            80520837,
            80468845,
            80464138
        ],
        "B": [
            80454412,
            80455734,
            80504343,
            80456075,
            80456469,
            80457930,
            80459404,
            80456913,
            80454847,
            80456739,
            80454406,
            80455296,
            80457195,
            80455557,
            80457336,
            80455902,
            80456106,
            80460925,
            80455491,
            80455115
        ],
        "A": [
            80454037,
            80454106,
            80505746,
            80454365,
            80454427,
            80454271,
            80454716,
            80454697,
            80454135,
            80454424,
            80455156,
            80454027,
            80454887,
            80454126,
            80454558,
            80454452,
            80454285,
            80456834,
            80476438,
            80454206
        ]
    },
    "name": "G. Find a Gift",
    "statement": "There are n gift boxes in a row, numbered from 1 to n from left to\r\nright. It\u2019s known that exactly k of them contain valuable gifts other\r\nboxes contain just lucky stones. All boxes look the same and differ only\r\nin weight. All than boxes with valuable items. But valuable gifts may be\r\ndifferent, so the boxes with valuable items may have different\r\nweights.You can ask no more than 50 queries (printing an answer doesn\u2019t\r\ncount). By each query you can compare total weights of two\r\nnon-intersecting subsets of boxes a_1, a_2,\r\ndots, a_{k_a} and b_1, b_2,\r\ndots, b_{k_b}. In return you\u2019ll get one of four results: , if subset\r\na_1, a_2,\r\ndots, a_{k_a} is strictly ; , if subset b_1, b_2,\r\ndots, b_{k_b} is strictly ; , if subsets have equal total weights; , if\r\nthe query is incorrect or the limit of queries is exceeded. Using such\r\nqueries (or, maybe, intuition) find the box with a valuable gift with .\r\n",
    "solutions": [
        "#include <random>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nmt19937 mt(2005171937);\nint rand_rng(int l, int r) {\n\tuniform_int_distribution<int> p(l, r - 1);\n\treturn p(mt);\n}\nvector<int> choose(int N, int K) {\n\tvector<bool> used(N, false);\n\tvector<int> seq;\n\tfor (int i = 0; i < K; ++i) {\n\t\tint p = -1;\n\t\twhile (p == -1 || used[p]) {\n\t\t\tp = rand_rng(0, N);\n\t\t}\n\t\tused[p] = true;\n\t\tseq.push_back(p);\n\t}\n\tsort(seq.begin(), seq.end());\n\treturn seq;\n}\nbool debug = false;\nvector<int> hidden;\nint min_index;\nvoid gen_array(int N, int K) {\n\tvector<int> g = choose(N, K);\n\thidden.resize(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (binary_search(g.begin(), g.end(), i)) {\n\t\t\thidden[i] = rand_rng(1, 100);\n\t\t}\n\t\telse {\n\t\t\thidden[i] = 100;\n\t\t}\n\t}\n\tmin_index = g[0];\n}\nstring ask(vector<int> a, vector<int> b) {\n\tcout << \"? \" << a.size() << ' ' << b.size() << endl;\n\tfor (int i = 0; i < a.size(); ++i) {\n\t\tif (i) cout << ' ';\n\t\tcout << a[i] + 1;\n\t}\n\tcout << endl;\n\tfor (int i = 0; i < b.size(); ++i) {\n\t\tif (i) cout << ' ';\n\t\tcout << b[i] + 1;\n\t}\n\tcout << endl;\n\tstring res;\n\tif (!debug) {\n\t\tcin >> res;\n\t}\n\telse {\n\t\tint sa = 0, sb = 0;\n\t\tfor (int i : a) sa += hidden[i];\n\t\tfor (int i : b) sb += hidden[i];\n\t\tif (sa > sb) res = \"FIRST\";\n\t\tif (sa < sb) res = \"SECOND\";\n\t\tif (sa == sb) res = \"EQUAL\";\n\t}\n\treturn res;\n}\nvoid answer(int x) {\n\tcout << \"! \" << x + 1 << endl;\n\tif (debug) {\n\t\tassert(x == min_index);\n\t}\n}\nint main() {\n\tint Q;\n\tcin >> Q;\n\twhile (Q--) {\n\t\tint N, K;\n\t\tif (!debug) {\n\t\t\tcin >> N >> K;\n\t\t}\n\t\telse {\n\t\t\tN = 4, K = 1;\n\t\t\tgen_array(N, K);\n\t\t}\n\t\tif (N <= 4) {\n\t\t\tint curmax = 0;\n\t\t\tfor (int i = 1; i < N; ++i) {\n\t\t\t\tstring res = ask({ curmax }, { i });\n\t\t\t\tif (res == \"SECOND\") curmax = i;\n\t\t\t}\n\t\t\tint ans = -1;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (i != curmax) {\n\t\t\t\t\tstring res = ask({ curmax }, { i });\n\t\t\t\t\tif (res == \"FIRST\") {\n\t\t\t\t\t\tans = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tanswer(ans);\n\t\t}\n\t\telse {\n\t\t\t// step #1. find one stone (fail probability <= (1/2)^threshold)\n\t\t\tconst int threshold = 23;\n\t\t\tvector<int> g = choose(N - 2, min(N - 2, threshold));\n\t\t\tfor (int i = 0; i < g.size(); ++i) {\n\t\t\t\tg[i] += 2;\n\t\t\t}\n\t\t\tint stone = g[0];\n\t\t\tfor (int i = 1; i < g.size(); ++i) {\n\t\t\t\tstring res = ask({ stone }, { g[i] });\n\t\t\t\tif (res == \"SECOND\") {\n\t\t\t\t\tstone = g[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tstring resp0 = ask({ stone }, { 0 });\n\t\t\tstring resp1 = ask({ stone }, { 1 });\n\t\t\tif (resp0 == \"FIRST\") {\n\t\t\t\tanswer(0);\n\t\t\t}\n\t\t\telse if (resp1 == \"FIRST\") {\n\t\t\t\tanswer(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint t = 2;\n\t\t\t\twhile (t * 2 <= N) {\n\t\t\t\t\tvector<int> lc(t), rc(t);\n\t\t\t\t\tfor (int i = 0; i < t; ++i) {\n\t\t\t\t\t\tlc[i] = i;\n\t\t\t\t\t\trc[i] = i + t;\n\t\t\t\t\t}\n\t\t\t\t\tstring res = ask(lc, rc);\n\t\t\t\t\tif (res != \"EQUAL\") {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tt *= 2;\n\t\t\t\t}\n\t\t\t\tint lp = t, rp = min(2 * t, N);\n\t\t\t\twhile (rp - lp > 1) {\n\t\t\t\t\tint m = (lp + rp) >> 1;\n\t\t\t\t\tvector<int> lc(m - t), rc(m - t);\n\t\t\t\t\tfor (int i = 0; i < m - t; ++i) {\n\t\t\t\t\t\tlc[i] = i;\n\t\t\t\t\t\trc[i] = i + t;\n\t\t\t\t\t}\n\t\t\t\t\tstring res = ask(lc, rc);\n\t\t\t\t\tif (res != \"EQUAL\") {\n\t\t\t\t\t\trp = m;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlp = m;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tanswer(lp);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "interactive",
        "probabilities"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Find a Gift.json",
    "editorial_link": "https://codeforces.com//blog/entry/77593",
    "editorial": "The solution consists of several steps. Let\u00e2\u0080\u0099s find out \"does the first\r\nbox contain stone or valuable gift\" using random. Let\u00e2\u0080\u0099s make queries to\r\ncompare the weight of the first box with the weight of another random\r\nbox. If the first box is lighter than we found an answer, otherwise the\r\nprobability of the first box having stones is at least . Let\u00e2\u0080\u0099s compare\r\nthe weights of the first box and the second one. If they are equal then\r\nlet\u00e2\u0080\u0099s compare the weights of boxes and . If they are equal then let\u00e2\u0080\u0099s\r\ncompare the boxes and and so on. In other words, let\u00e2\u0080\u0099s find the minimum\r\nsuch that contains only boxes with stones but contain at least one box\r\nwith a valuable gift. It\u00e2\u0080\u0099s easy to see that we\u00e2\u0080\u0099d spend no more than\r\nqueries. We have segment with only stones and with at least one gift.\r\nLet\u00e2\u0080\u0099s just binary search the leftmost gift in the segment using boxes\r\nfrom as reference: if we need to know \"does segment of boxes have at\r\nleast one gift\", let\u00e2\u0080\u0099s just compare it with segment which have only\r\nstones. if is lighter then it has, otherwise doesn\u00e2\u0080\u0099t have. This part\r\nalso requires no more than queries.\r\n"
}