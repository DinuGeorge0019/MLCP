{
    "link": "https://codeforces.com//contest/911/problem/E",
    "problemId": "142499",
    "problem_idx": "E",
    "shortId": "911E",
    "contest_number": "911",
    "problem_submissions": {
        "F": [
            33730338,
            33736236,
            33729501,
            33733851,
            33737431,
            33736160,
            33727192,
            33731600,
            33738270,
            33731121,
            33731406,
            33727367,
            33728276,
            33726638,
            33731778,
            33732737,
            33730029,
            33731049,
            33829722,
            33829713,
            33734856
        ],
        "G": [
            33728994,
            33728318,
            33736310,
            33730624,
            33734693,
            33730072,
            33735518,
            33736927,
            33973095,
            33726198,
            33734145,
            33725486,
            33916145,
            33742312,
            33742380,
            33759087,
            33796642,
            33796567,
            76805271,
            33829935,
            33829896,
            33829810,
            33829610
        ],
        "E": [
            33722163,
            33722735,
            33725907,
            33726299,
            33730629,
            33721023,
            33733522,
            33726343,
            33733907,
            33718645,
            33736707,
            33723912,
            33723633,
            33723315,
            33722403,
            33726466,
            33724328,
            33722719,
            33725898
        ],
        "D": [
            33717830,
            33719177,
            33731193,
            33727114,
            33724269,
            33733276,
            33731713,
            33720741,
            33735525,
            33736390,
            33733900,
            33719447,
            33718488,
            33721217,
            33717781,
            33719325,
            33720612,
            33717555,
            33721885
        ],
        "C": [
            33716749,
            33717557,
            33718909,
            33717327,
            33726728,
            33731930,
            33730836,
            33718913,
            33730374,
            33721277,
            33735066,
            33717357,
            33719578,
            33716462,
            33717823,
            33718307,
            33715178,
            33719484
        ],
        "B": [
            33714368,
            33718005,
            33715412,
            33715624,
            33717403,
            33729431,
            33715928,
            33715342,
            33736651,
            33732506,
            33715356,
            33714796,
            33715837,
            33713865,
            33715844,
            33716072,
            33718139,
            33716208
        ],
        "A": [
            33713428,
            33714079,
            33713974,
            33713612,
            33713484,
            33713403,
            33728723,
            33713514,
            33713445,
            33735048,
            33731862,
            33714094,
            33713551,
            33713430,
            33713412,
            33713709,
            33713489,
            33714231,
            33713552
        ]
    },
    "name": "E. Stack Sorting",
    "statement": "Let’s suppose you have an array , a stack (initially empty) and an array\r\n(also initially empty).You may perform the following operations until\r\nboth and are empty: Take the first element of , push it into and remove\r\nit from (if is not empty); Take the top element from , append it to the\r\nend of array and remove it from (if is not empty). You can perform these\r\noperations in arbitrary order.If there exists a way to perform the\r\noperations such that array is sorted in non-descending order in the end,\r\nthen array is called .For example, is , because will be sorted if we\r\nperform the following operations: Remove from and push it into ; Remove\r\nfrom and push it into ; Remove from and append it to the end of ; Remove\r\nfrom and push it into ; Remove from and append it to the end of ; Remove\r\nfrom and append it to the end of . After all these operations , so is .\r\nis not .You are given first elements of some permutation of size (recall\r\nthat a permutation of size is an array of size where each integer from\r\nto occurs exactly once). You have to restore the remaining elements of\r\nthis permutation so it is . If there are multiple answers, choose the\r\nanswer such that is lexicographically maximal (an array is\r\nlexicographically greater than an array iff there exists some integer\r\nsuch that for every , and ). .Print the lexicographically maximal\r\npermutation you can obtain.If there exists no answer then output .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic void no()\n{\n    cout << \"-1\\n\";\n    exit(0);\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N, K;\n    cin >> N >> K;\n    vi a(N);\n    int out = 0;\n    set<int> miss;\n    for (int i = 0; i < N; i++)\n        miss.insert(i);\n    for (int i = 0; i < K; i++)\n    {\n        cin >> a[i];\n        a[i]--;\n        miss.erase(a[i]);\n    }\n    stack<int> s;\n    for (int i = 0; i < K; i++)\n    {\n        while (!s.empty() && s.top() < a[i])\n        {\n            if (s.top() != out)\n                no();\n            s.pop();\n            out++;\n        }\n        s.push(a[i]);\n    }\n\n    for (int i = K; i < N; i++)\n    {\n        while (!s.empty() && s.top() == out)\n        {\n            s.pop();\n            out++;\n        }\n        int limit = s.empty() ? INT_MAX / 2 : s.top();\n        auto it = prev(miss.lower_bound(limit));\n        s.push(*it);\n        a[i] = *it;\n        miss.erase(it);\n    }\n\n    for (int i = 0; i < N; i++)\n        cout << a[i] + 1 << ' ';\n    cout << '\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Stack Sorting.json",
    "editorial_link": "https://codeforces.com/blog/entry/56771",
    "editorial": "Letâs denote as some stack-sortable array which contains all integers\r\nfrom to (inclusive).We can see that if the first element of is , then ,\r\nwhere by we mean concatenation of arrays. Itâs easy to prove this fact:\r\nif the first element is , then we have to store it in the stack until we\r\nhave processed all elements less than , so in no element that is greater\r\nthan can precede any element less than .This way we can represent the\r\nprefix we are given. For example, if , and prefix is , then we can\r\nrewrite the permutation we have to obtain as:.So the unknown suffix is a\r\ncontatenation of some stack-sortable arrays. Itâs easy to see that if an\r\narray is sorted in non-increasing order, then it is stack-sortable. So\r\nwe can replace each block with an array .If during rewriting the given\r\nprefix we obtain some impossible situation (for example, when and given\r\nprefix is , we have and canât be the beginning of ), then answer is .\r\n",
    "hint": []
}