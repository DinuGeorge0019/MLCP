{
    "link": "https://codeforces.com//contest/863/problem/D",
    "problemId": "123494",
    "problem_idx": "D",
    "shortId": "863D",
    "contest_number": "863",
    "problem_submissions": {
        "F": [
            30585747,
            30587406,
            30587581,
            30586987,
            30589318,
            30588386,
            30614835,
            30589226,
            30587748,
            30588069,
            30589138,
            30588637,
            30589602,
            30588953,
            30587113,
            30590006,
            30591128,
            30589525,
            30591328
        ],
        "E": [
            30584826,
            30584892,
            30586722,
            30586370,
            30585856,
            30586447,
            30586390,
            30586258,
            30587809,
            30586316,
            30587721,
            30587855,
            30587775,
            30588242,
            30587782,
            30587403,
            30589806
        ],
        "D": [
            30584161,
            30582889,
            30583896,
            30584983,
            30584514,
            30599512,
            30585431,
            30584907,
            30584911,
            30586408,
            30585496,
            30586610,
            30586374,
            30584958,
            30587183,
            30584596,
            30585231,
            30587520
        ],
        "C": [
            30583486,
            30584324,
            30585366,
            30584169,
            30583738,
            30584504,
            30584405,
            30584037,
            30585386,
            30584778,
            30585657,
            30585045,
            30584141,
            30586261,
            30586674,
            30591722,
            30586154
        ],
        "B": [
            30581979,
            30583463,
            30582674,
            30582188,
            30582199,
            30582158,
            30582064,
            30582238,
            30582609,
            30582456,
            30582868,
            30582784,
            30582689,
            30582852,
            30583217,
            30606326,
            30582212,
            30582335
        ],
        "A": [
            30581619,
            30581704,
            30581695,
            30581653,
            30581650,
            30786677,
            30581665,
            30581657,
            30581629,
            30581763,
            30581628,
            30581791,
            30581663,
            30581713,
            30581800,
            30581819,
            30581630,
            30581694
        ],
        "G": [
            57430904,
            30596090
        ]
    },
    "name": "D. Yet Another Array Queries Problem",
    "statement": "You are given an array of size , and queries to it. There are queries of\r\ntwo types: perform a cyclic shift of the segment to the right. That is,\r\nfor every such that new value of becomes equal to old value of , and new\r\nvalue of becomes equal to old value of ; reverse the segment . There are\r\nimportant indices in the array , , ..., . For each such that you have to\r\noutput the number that will have index in the array after all queries\r\nare performed.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if (y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if (x < y) x = y; }\n\nint main() {\n\tint n; int q;\n\twhile (~scanf(\"%d%d\", &n, &q)) {\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tvector<int> a(n);\n\t\tfor (int i = 0; i < n; ++ i)\n\t\t\tscanf(\"%d\", &a[i]);\n\t\tstruct Query {\n\t\t\tint ty, l, r;\n\t\t};\n\t\tvector<Query> queries(q);\n\t\tfor (int ii = 0; ii < q; ++ ii) {\n\t\t\tint ty;\n\t\t\tscanf(\"%d\", &ty);\n\t\t\tint l; int r;\n\t\t\tscanf(\"%d%d\", &l, &r), -- l;\n\t\t\tqueries[ii] = { ty, l, r };\n\t\t}\n\t\tvector<int> b(m);\n\t\tfor (int i = 0; i < m; ++ i)\n\t\t\tscanf(\"%d\", &b[i]), -- b[i];\n\t\tvector<int> ans;\n\t\tfor (int i : b) {\n\t\t\tfor (int qi = q - 1; qi >= 0; -- qi) {\n\t\t\t\tconst auto &t = queries[qi];\n\t\t\t\tif (t.l <= i && i < t.r) {\n\t\t\t\t\tif (t.ty == 1) {\n\t\t\t\t\t\ti = i == t.l ? t.r - 1 : i - 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti = t.r - 1 - i + t.l;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans.push_back(a[i]);\n\t\t}\n\t\tfor (int i = 0; i < (int)ans.size(); ++ i) {\n\t\t\tif (i != 0) putchar(' ');\n\t\t\tprintf(\"%d\", ans[i]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Yet Another Array Queries Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/54708",
    "editorial": "One can guess from the constraits that complexity of the algorithm\r\nshould be either or . And there is a solution with the second one.Letâs\r\ntry to solve the reversed problem answer what position will some number\r\nbe at after all the queries. Check the impact of some query on position\r\n. Let the query be on some segment . If is outside this segment then you\r\ncan skip it. Otherwise reverse will swap and , shift will swap and (if\r\nthen it will be instead of ).This task can be translated to the given\r\none just by reversing the query list. Overall complexity: .Obviously,\r\nyou can also solve it with Cartesian tree online in .\r\n",
    "hint": []
}