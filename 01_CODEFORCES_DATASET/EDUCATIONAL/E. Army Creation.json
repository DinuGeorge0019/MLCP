{
    "link": "https://codeforces.com//contest/813/problem/E",
    "problemId": "108592",
    "problem_idx": "E",
    "shortId": "813E",
    "contest_number": "813",
    "problem_submissions": {
        "F": [
            27592959,
            27592462,
            27595859,
            27593693,
            27589826,
            27597032,
            27592495,
            27594242,
            27592969,
            27592265,
            27592101,
            27593647,
            27593448,
            27607698,
            27607690,
            27597005
        ],
        "D": [
            27591413,
            27596376,
            27595878,
            27592392,
            27596101,
            27595104,
            27676236,
            27675210,
            27591510,
            27603640,
            27593900,
            27624567,
            27624550,
            27624539,
            27628580,
            27593089,
            27592322,
            28282372,
            28281379
        ],
        "E": [
            27590671,
            27593775,
            27594164,
            27598623,
            27590165,
            27587725,
            27590977,
            27593884,
            27590632,
            27590190,
            27593976,
            27593899,
            27591757,
            27595354,
            27602821,
            27589094,
            27596364,
            27590212,
            27590714,
            27590708
        ],
        "C": [
            27586798,
            27589288,
            27588038,
            27588205,
            27585642,
            27587654,
            27587622,
            27598220,
            27588200,
            27597496,
            27586750,
            27587670,
            27588183,
            27589351,
            27598034,
            27587880,
            27588758,
            27588420,
            27587303,
            27587398,
            27597722,
            27588272
        ],
        "B": [
            27587426,
            27586981,
            27586763,
            27590844,
            27586387,
            27587082,
            27586616,
            27585981,
            27586358,
            27586732,
            27588430,
            27586365,
            27587378,
            27586643,
            27586207,
            27586121
        ],
        "A": [
            27586386,
            27585541,
            27587254,
            27590210,
            27585562,
            27585639,
            27585557,
            27585471,
            27585490,
            27585606,
            27586831,
            27585625,
            27586127,
            27585762,
            27585515,
            27585489,
            27585475
        ]
    },
    "name": "E. Army Creation",
    "statement": "As you might remember from our previous rounds, Vova really likes\r\ncomputer games. Now he is playing a strategy game known as Rage of\r\nEmpires.In the game Vova can hire different warriors; th warrior has the\r\ntype . Vova wants to create a army hiring some subset of warriors. An\r\narmy is called if for each type of warrior present in the game there are\r\nnot more than warriors of this type in the army. Of course, Vova wants\r\nhis army to be as large as possible.To make things more complicated,\r\nVova has to consider different plans of creating his army. th plan\r\nallows him to hire only warriors whose numbers are not less than and not\r\ngreater than .Help Vova to determine the largest size of a army for each\r\nplan.\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nstruct Nd{\n  Nd *tl , *tr;\n  int sum;\n  Nd(){\n    tl = tr = NULL;\n    sum = 0;\n  }\n};\nNd* copy( Nd* t ){\n  Nd* ret = new Nd();\n  if( t ){\n    ret->tl = t->tl;\n    ret->tr = t->tr;\n    ret->sum = t->sum;\n  }\n  return ret;\n}\nint Sum( Nd* t ){\n  return t ? t->sum : 0;\n}\n#define mid ((l+r)>>1)\nvoid modify( Nd* t , int l , int r , int p , int dlt ){\n  if( l == r ){\n    t->sum += dlt;\n    return;\n  }\n  if( p <= mid ){\n    t->tl = copy( t->tl );\n    modify( t->tl , l , mid , p , dlt );\n  }else{\n    t->tr = copy( t->tr );\n    modify( t->tr , mid + 1 , r , p , dlt );\n  }\n  t->sum = Sum( t->tl ) + Sum( t->tr );\n}\nint query( Nd* t , int l , int r , int ql , int qr ){\n  if( !t or r < ql or l > qr ) return 0;\n  if( ql <= l and r <= qr ) return t->sum;\n  return query( t->tl , l , mid , ql , qr ) +\n         query( t->tr , mid + 1 , r , ql , qr );\n}\nvoid build(){\n\n}\n#define N 101021\nint n , k;\nqueue<int> q[ N ];\nNd* root[ N ];\nvoid init(){\n  n = getint();\n  k = getint();\n  for( int i = 1 ; i <= n ; i ++ ){\n    int ai = getint();\n    root[ i ] = copy( root[ i - 1 ] );\n    modify( root[ i ] , 1 , n , i , +1 );\n    q[ ai ].push( i );\n    if( (int)q[ ai ].size() > k ){\n      modify( root[ i ] , 1 , n , q[ ai ].front() , -1 );\n      q[ ai ].pop();\n    }\n  }\n}\nvoid solve(){\n  int last = 0;\n  int qq = getint(); while( qq -- ){\n    int ql = ( getint() + last ) % n + 1;\n    int qr = ( getint() + last ) % n + 1;\n    if( ql > qr ) swap( ql , qr );\n    last = query( root[ qr ] , 1 , n , ql , qr );\n    printf( \"%d\\n\" , last );\n  }\n}\nint main(){\n  build();\n  //__ = getint(); \n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Army Creation.json",
    "editorial_link": "https://codeforces.com//blog/entry/52410",
    "editorial": "Every time we process a plan, letâs count only the first warriors of\r\nsome type.When will the warrior on position be counted? Of course, he\r\nhas to be present in the plan, so . But also he has to be among first\r\nwarriors of his type in this plan.Letâs denote a function : is the\r\nposition of previous warrior of the same type before warrior (that is,\r\nthe greatest such that and ). If thereâs no any, then ; if . It is easy\r\nto prove that the warrior will be among first warriors in some plan iff\r\nand .So we can make a new array : . Then we build a segment tree on this\r\narray. The node of the segment tree will store all values of from the\r\nsegment corresponding to this node (in sorted order). Then to get answer\r\nto the plan, we have to count the number of elements on segment that are\r\nless than .Complexity is , or if you use fractional cascading technique.\r\n",
    "hint": []
}