{
    "link": "https://codeforces.com//contest/1202/problem/E",
    "problemId": "385666",
    "problem_idx": "E",
    "shortId": "1202E",
    "contest_number": "1202",
    "problem_submissions": {
        "F": [
            58450924,
            58449423,
            58454352,
            58459803,
            58448615,
            58683759,
            58544660,
            58632018,
            58460608,
            58677253,
            59095272
        ],
        "E": [
            58446577,
            59548224,
            58440455,
            58449286,
            58475576,
            58455191,
            58455332,
            58449043,
            58451450,
            58448860,
            58450378,
            58451427,
            58451624,
            58451536,
            58451835,
            58443909,
            58451432,
            58452032,
            58454174,
            58451009,
            58452592,
            58451940
        ],
        "D": [
            58444092,
            58442549,
            58443962,
            58475546,
            58444450,
            58440999,
            58440440,
            58443368,
            58445508,
            58445716,
            58445057,
            58441174,
            58445333,
            58445907,
            58446487,
            58445052,
            58442732,
            58442650,
            58444867,
            58447384,
            58446089
        ],
        "C": [
            58441598,
            58452310,
            58442367,
            58475556,
            58442473,
            58439618,
            58446484,
            58442135,
            58443668,
            58443427,
            58442755,
            58446380,
            58443036,
            58443982,
            58455139,
            58441929,
            58447606,
            58446719,
            58443811,
            58445636,
            58448227
        ],
        "B": [
            58439444,
            58444513,
            58438813,
            58475511,
            58439503,
            58438262,
            58439422,
            58439559,
            58440663,
            58440425,
            58439072,
            58440288,
            58439823,
            58440365,
            58439836,
            58438293,
            58440655,
            58440555,
            58440058,
            58442143,
            58438995
        ],
        "A": [
            58438253,
            58437660,
            58437723,
            58475481,
            58437816,
            58437640,
            58437730,
            58437581,
            58437903,
            58437729,
            58437803,
            58437783,
            58437814,
            58438010,
            58438207,
            58437638,
            58439242,
            58437860,
            58437712,
            58437966,
            58440352
        ]
    },
    "name": "E. You Are Given Some Strings...",
    "statement": "You are given a string t and n strings s_1, s_2,\r\ndots, s_n. All strings consist of lowercase Latin letters.Let f(t, s) be\r\nthe number of occurences of string s in string t. For example, f(’\r\ntext{aaabacaa}’, ’\r\ntext{aa}’) = 3, and f(’\r\ntext{ababa}’, ’\r\ntext{aba}’) = 2.Calculate the value of\r\nsum\r\nlimits_{i=1}^{n}\r\nsum\r\nlimits_{j=1}^{n} f(t, s_i + s_j), where s + t is the concatenation of\r\nstrings s and t. Note that if there are two pairs i_1, j_1 and i_2, j_2\r\nsuch that s_{i_1} + s_{j_1} = s_{i_2} + s_{j_2}, you should include both\r\nf(t, s_{i_1} + s_{j_1}) and f(t, s_{i_2} + s_{j_2}) in answer.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=201010,CHAR=26;\n#define CONVERT(c) (c)-'a'\nclass AhoCora{\npublic:\n\tstruct Node{\n\t\tint ch[CHAR];\n\t\tint dic,link;\n\t}nd[N];\n\tint Q[N]; int qs,qe;\n\tint size;\n\tint createNode(){\n\t\tint ret=size++;\n\t\tfor(int i=0;i<CHAR;i++){\n\t\t\tnd[ret].ch[i]=-1;\n\t\t}\n\t\tnd[ret].dic=0;\n\t\treturn ret;\n\t}\n\tvoid init(){\n\t\tsize=0;\n\t\tcreateNode();\n\t}\n\ttemplate<typename A>\n\tvoid add(A str,int sz){\n\t\tint cur=0;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tint c=CONVERT(str[i]);\n\t\t\tif(nd[cur].ch[c]==-1){\n\t\t\t\tint nnd=createNode();\n\t\t\t\tnd[cur].ch[c]=nnd;\n\t\t\t}\n\t\t\tcur=nd[cur].ch[c];\n\t\t}\n\t\tnd[cur].dic++;\n\t}\n\tinline int next(int u,int c){\n\t\twhile(u&&nd[u].ch[c]<0)\n\t\t\tu=nd[u].link;\n\t\tif(nd[u].ch[c]<0)return 0;\n\t\telse return nd[u].ch[c];\n\t}\n\tvoid computelink(){\n\t\tqs=qe=0;\n\t\tnd[0].link=0;\n\t\tfor(int x,i=0;i<CHAR;i++){\n\t\t\tif((x=nd[0].ch[i])>=0){\n\t\t\t\tQ[qe++]=x;\n\t\t\t\tnd[x].link=0;\n\t\t\t}\n\t\t}\n\t\twhile(qs<qe){\n\t\t\tint u=Q[qs++];\n\t\t\tnd[u].dic+=nd[nd[u].link].dic;\n\t\t\tfor(int v,i=0;i<CHAR;i++){\n\t\t\t\tif((v=nd[u].ch[i])>=0){\n\t\t\t\t\tQ[qe++]=v;\n\t\t\t\t\tint m=nd[u].link;\n\t\t\t\t\tint L=nd[v].link=next(m,i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}c1,c2;\n\nchar b[201010],c[201010];\nint d[201010],e[201010];\nint main(){\n\tscanf(\"%s\",b);\n\tint n;scanf(\"%d\",&n);\n\tc1.init();c2.init();\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",c);\n\t\tint m=strlen(c);\n\t\tc1.add(c,m);\n\t\treverse(c,c+m);\n\t\tc2.add(c,m);\n\t}\n\tc1.computelink();\n\tc2.computelink();\n\tn=strlen(b);\n\tint cur=0;\n\tfor(int i=0;i<n;i++){\n\t\tcur=c1.next(cur,b[i]-'a');\n\t\td[i]=c1.nd[cur].dic;\n\t}\n\tcur=0;\n\tfor(int i=n;i--;){\n\t\tcur=c2.next(cur,b[i]-'a');\n\t\te[i]=c2.nd[cur].dic;\n\t}\n\t\n\tlong long ans=0;\n\tfor(int i=0;i<n-1;i++){\n\t\tans+=1LL*d[i]*e[i+1];\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. You Are Given Some Strings....json",
    "editorial_link": "https://codeforces.com/blog/entry/68972",
    "editorial": "Letâs look at any occurrence of arbitrary pair . There is exactly one\r\nspecial split position, where the ends and starts. So, instead of\r\ncounting occurrences for each pair, we can iterate over the position of\r\nsplit and count the number of pairs. This transformation is convenient,\r\nsince any , which ends in split position can be paired with any which\r\nstarts here. So, all we need is to calculate for each suffix the number\r\nof strings , which starts here, and for each prefix the number of\r\nstrings , which ends here. But calculating the prefixes can be\r\ntransformed to calculating suffixes by reversing both and all .Now we\r\nneed, for each position , calculate the number of strings which occur\r\nfrom . It can be done by Aho-Corasick, Suffix Array, Suffix Automaton,\r\nSuffix Tree, but do we really need them since constrains are pretty low?\r\nThe answer is NO. We can use sqrt-heuristic!Letâs divide all in two\r\ngroups: short and long. The is short if . There are no more than long\r\nstrings and, for each such string, we can find all its occurrences with\r\nz-function (or prefix-function). It will cost as .What to do with short\r\nstrings? Letâs add them to trie! The trie will have vertices, but only\r\ndepth. So we can, for each , move down through the trie, while counting\r\nthe occurrences, using only substring. It will cost us .So, if we choose\r\nwe can acquire complexity, using only basic string structures.\r\n",
    "hint": []
}