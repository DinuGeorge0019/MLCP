{
    "link": "https://codeforces.com//contest/628/problem/E",
    "problemId": "48827",
    "problem_idx": "E",
    "shortId": "628E",
    "contest_number": "628",
    "problem_submissions": {
        "F": [
            16211421,
            16211567,
            16211169,
            16208042,
            16208527,
            16211299,
            16220786,
            16205726,
            16251882,
            16212235,
            16209081,
            16210918,
            16211253
        ],
        "E": [
            16209151,
            16209513,
            16209798,
            16210303,
            16210389,
            16210209,
            16207914,
            16208921,
            16208930,
            16210016,
            16208755,
            16210104,
            16210071,
            16211325,
            16211040,
            16210904,
            16210538,
            16209234,
            16210698,
            16210531,
            16214256
        ],
        "D": [
            16206627,
            16206845,
            16206086,
            16207092,
            16208100,
            16205719,
            16205288,
            16206076,
            16260286,
            16206980,
            16206584,
            16206673,
            16206619,
            16207592,
            16206640,
            16380499,
            16206826,
            16207654
        ],
        "C": [
            16204024,
            16203998,
            16203984,
            16204943,
            16204160,
            16203580,
            16204456,
            16203644,
            16203472,
            16204820,
            16204285,
            16204239,
            16203927,
            16204552,
            16204730,
            16203693,
            16204713,
            16204672
        ],
        "B": [
            16203509,
            16203431,
            16203495,
            16204395,
            16203326,
            16203172,
            16204023,
            16203232,
            16203233,
            16204126,
            16203462,
            16203612,
            16203325,
            16203859,
            16203731,
            16203308,
            16203766,
            16203989
        ],
        "A": [
            16203031,
            16203135,
            16203205,
            16203772,
            16203048,
            16203023,
            16203022,
            16203045,
            16203001,
            16203771,
            16203077,
            16203193,
            16203044,
            16203133,
            16203132,
            16203092,
            16203204,
            16203389
        ]
    },
    "name": "E. Zbazi in Zeydabad",
    "statement": "A tourist wants to visit country Zeydabad for Zbazi (a local game in\r\nZeydabad).The country Zeydabad is a rectangular table consisting of rows\r\nand columns. Each cell on the country is either or .The tourist knows\r\nthis country is named Zeydabad because there are lots of \u201d\"s in the\r\ncountry. A \u201d\" is a square which anti-diagonal is completely filled with\r\nand its upper and lower rows are also completely filled with . All other\r\ncells of a square can be arbitrary. Note that a \u201d\" can consist of only\r\none cell (see the examples).So he wants to count the number of \u201d\"s in\r\nthe country (a necessary skill for Zbazi).Now your task is to help\r\ntourist with counting number of \u201d\"s.As input/output can reach huge size\r\nit is recommended to use fast input/output methods: for example, prefer\r\nto use instead of in C++, prefer to use instead of in .\r\n",
    "solutions": [
        "#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n#include <queue>\n\ntemplate<class T>\nstruct BinTree1 {\n  size_t size;\n  std::vector<T> t;\n\n  BinTree1(size_t N) :\n      size(N),\n      t(2 * N) { }\n\n  BinTree1(const std::vector<T>& other) :\n      size(other.size()),\n      t(2 * other.size()) {\n    std::copy(other.begin(), other.end(), t.begin() + size);\n    for (size_t i = size; i-- > 1;) {\n      t[i] = combine(t[2 * i], t[2 * i + 1]);\n    }\n  }\n\n  T get(size_t p) {\n    return t[p + size];\n  }\n\n  void modify(size_t p, T value) {\n    p += size;\n    t[p] = value;\n    while (p > 1) {\n      p = p / 2;\n      t[p] = combine(t[2 * p], t[2 * p + 1]);\n    }\n  }\n\n  T query(size_t l, size_t r) {\n    l += size;\n    r += size;\n    T left = init();\n    T right = init();\n    while (l < r) {\n      if (l & 1) {\n        left = combine(left, t[l]);\n        l++;\n      }\n      if (r & 1) {\n        r--;\n        right = combine(t[r], right);\n      }\n      l = l / 2;\n      r = r / 2;\n    }\n    return combine(left, right);\n  }\n\n private:\n  T combine(T left, T right) {\n    return left + right;\n  }\n\n  T init() {\n    return T();\n  }\n};\n\nusing EndPoint = std::pair<int, int>;\n\nstruct Solution {\n  int n, m;\n  std::vector<std::string> data;\n  std::vector<std::vector<int>> as;\n  std::vector<std::vector<int>> bs;\n  void run(std::istream& in, std::ostream& out) {\n    in >> n >> m;\n    data.resize(n);\n    for (int i = 0; i < n; i++) {\n      in >> data[i];\n    }\n    as.assign(n, std::vector<int>(m, 0));\n    bs.assign(n, std::vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n      int last = 0;\n      for (int j = 0; j <= m; j++) {\n        if (data[i][j] == '.' || j == m) {\n          for (int k = last; k < j; k++) {\n            as[i][k] = j - k - 1;\n            bs[i][k] = k - last;\n          }\n          last = j + 1;\n        }\n      }\n    }\n    int64_t res = 0;\n    for (int diag = 0; diag <= n + m - 2; diag++) {\n      BinTree1<int> tree(m);\n      std::priority_queue<EndPoint, std::vector<EndPoint>, std::greater<EndPoint>> endPoints;\n      for (int i = 0; i < m && i <= diag; i++) {\n        int j = diag - i;\n        if (j >= n) continue;\n        if (data[j][i] == '.') {\n          while (!endPoints.empty()) {\n            EndPoint p = endPoints.top();\n            tree.modify(p.second, 0);\n            endPoints.pop();\n          }\n          continue;\n        }\n        endPoints.emplace(i + as[j][i], i);\n        tree.modify(i, 1);\n        res += tree.query(std::max(0, i - bs[j][i]), i + 1);\n        while (!endPoints.empty() && endPoints.top().first == i) {\n          tree.modify(endPoints.top().second, 0);\n          endPoints.pop();\n        }\n      }\n    }\n    out << res << std::endl;\n  }\n};\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  Solution().run(std::cin, std::cout);\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Zbazi in Zeydabad.json",
    "editorial_link": "https://codeforces.com//blog/entry/43203",
    "editorial": "The problem was suggested by Ali Ahmadi Kuzey. Let\u00e2\u0080\u0099s precalculate the\r\nvalues the maximal number of letters \u00e2\u0080\u0099z\u00e2\u0080\u0099 to the left, to the right and\r\nto the left-down from the position . It\u00e2\u0080\u0099s easy to do in time. Let\u00e2\u0080\u0099s fix\r\nsome cell . Consider the value . It\u00e2\u0080\u0099s the maximum size of the square\r\nwith upper right ceil in . But the number of z-patterns can be less than\r\n. Consider some cell diagonally down-left from on the distance no more\r\nthan . The cells and forms z-pattern if . Let\u00e2\u0080\u0099s maintain some data\r\nstructure for each antidiagonal (it can be described by formula ) that\r\ncan increment in a point and take the sum on a segment (Fenwick tree\r\nwill be the best choice for that). Let\u00e2\u0080\u0099s iterate over columns from the\r\nright to the left and process the events: we have some cell for which .\r\nIn that case we should increment the position in the tree number by one.\r\nNow we should iterate over the cells in the current column and add to\r\nthe answer the value of the sum on the segment from to in the tree\r\nnumber . ++ solution Complexity: .\r\n"
}