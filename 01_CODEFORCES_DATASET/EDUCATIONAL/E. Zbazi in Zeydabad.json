{"link": "https://codeforces.com//contest/628/problem/E", "problemId": "48827", "problem_idx": "E", "shortId": "628E", "contest_number": "628", "problem_submissions": {"F": [16211421, 16211567, 16211169, 16208042, 16208527, 16211299, 16220786, 16205726, 16251882, 16212235, 16209081, 16210918, 16211253], "E": [16209151, 16209513, 16209798, 16210303, 16210389, 16210209, 16207914, 16208921, 16208930, 16210016, 16208755, 16210104, 16210071, 16211325, 16211040, 16210904, 16210538, 16209234, 16210698, 16210531, 16214256], "D": [16206627, 16206845, 16206086, 16207092, 16208100, 16205719, 16205288, 16206076, 16260286, 16206980, 16206584, 16206673, 16206619, 16207592, 16206640, 16380499, 16206826, 16207654], "C": [16204024, 16203998, 16203984, 16204943, 16204160, 16203580, 16204456, 16203644, 16203472, 16204820, 16204285, 16204239, 16203927, 16204552, 16204730, 16203693, 16204713, 16204672], "B": [16203509, 16203431, 16203495, 16204395, 16203326, 16203172, 16204023, 16203232, 16203233, 16204126, 16203462, 16203612, 16203325, 16203859, 16203731, 16203308, 16203766, 16203989], "A": [16203031, 16203135, 16203205, 16203772, 16203048, 16203023, 16203022, 16203045, 16203001, 16203771, 16203077, 16203193, 16203044, 16203133, 16203132, 16203092, 16203204, 16203389]}, "name": "E. Zbazi in Zeydabad", "statement": "A tourist wants to visit country Zeydabad for Zbazi (a local game in\r\nZeydabad).The country Zeydabad is a rectangular table consisting of rows\r\nand columns. Each cell on the country is either or .The tourist knows\r\nthis country is named Zeydabad because there are lots of \u201d\"s in the\r\ncountry. A \u201d\" is a square which anti-diagonal is completely filled with\r\nand its upper and lower rows are also completely filled with . All other\r\ncells of a square can be arbitrary. Note that a \u201d\" can consist of only\r\none cell (see the examples).So he wants to count the number of \u201d\"s in\r\nthe country (a necessary skill for Zbazi).Now your task is to help\r\ntourist with counting number of \u201d\"s.As input/output can reach huge size\r\nit is recommended to use fast input/output methods: for example, prefer\r\nto use instead of in C++, prefer to use instead of in .\r\n", "solutions": ["#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n#include <queue>\n\ntemplate<class T>\nstruct BinTree1 {\n  size_t size;\n  std::vector<T> t;\n\n  BinTree1(size_t N) :\n      size(N),\n      t(2 * N) { }\n\n  BinTree1(const std::vector<T>& other) :\n      size(other.size()),\n      t(2 * other.size()) {\n    std::copy(other.begin(), other.end(), t.begin() + size);\n    for (size_t i = size; i-- > 1;) {\n      t[i] = combine(t[2 * i], t[2 * i + 1]);\n    }\n  }\n\n  T get(size_t p) {\n    return t[p + size];\n  }\n\n  void modify(size_t p, T value) {\n    p += size;\n    t[p] = value;\n    while (p > 1) {\n      p = p / 2;\n      t[p] = combine(t[2 * p], t[2 * p + 1]);\n    }\n  }\n\n  T query(size_t l, size_t r) {\n    l += size;\n    r += size;\n    T left = init();\n    T right = init();\n    while (l < r) {\n      if (l & 1) {\n        left = combine(left, t[l]);\n        l++;\n      }\n      if (r & 1) {\n        r--;\n        right = combine(t[r], right);\n      }\n      l = l / 2;\n      r = r / 2;\n    }\n    return combine(left, right);\n  }\n\n private:\n  T combine(T left, T right) {\n    return left + right;\n  }\n\n  T init() {\n    return T();\n  }\n};\n\nusing EndPoint = std::pair<int, int>;\n\nstruct Solution {\n  int n, m;\n  std::vector<std::string> data;\n  std::vector<std::vector<int>> as;\n  std::vector<std::vector<int>> bs;\n  void run(std::istream& in, std::ostream& out) {\n    in >> n >> m;\n    data.resize(n);\n    for (int i = 0; i < n; i++) {\n      in >> data[i];\n    }\n    as.assign(n, std::vector<int>(m, 0));\n    bs.assign(n, std::vector<int>(m, 0));\n    for (int i = 0; i < n; i++) {\n      int last = 0;\n      for (int j = 0; j <= m; j++) {\n        if (data[i][j] == '.' || j == m) {\n          for (int k = last; k < j; k++) {\n            as[i][k] = j - k - 1;\n            bs[i][k] = k - last;\n          }\n          last = j + 1;\n        }\n      }\n    }\n    int64_t res = 0;\n    for (int diag = 0; diag <= n + m - 2; diag++) {\n      BinTree1<int> tree(m);\n      std::priority_queue<EndPoint, std::vector<EndPoint>, std::greater<EndPoint>> endPoints;\n      for (int i = 0; i < m && i <= diag; i++) {\n        int j = diag - i;\n        if (j >= n) continue;\n        if (data[j][i] == '.') {\n          while (!endPoints.empty()) {\n            EndPoint p = endPoints.top();\n            tree.modify(p.second, 0);\n            endPoints.pop();\n          }\n          continue;\n        }\n        endPoints.emplace(i + as[j][i], i);\n        tree.modify(i, 1);\n        res += tree.query(std::max(0, i - bs[j][i]), i + 1);\n        while (!endPoints.empty() && endPoints.top().first == i) {\n          tree.modify(endPoints.top().second, 0);\n          endPoints.pop();\n        }\n      }\n    }\n    out << res << std::endl;\n  }\n};\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  Solution().run(std::cin, std::cout);\n  return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "implementation"], "dificulty": "2300", "interactive": false}