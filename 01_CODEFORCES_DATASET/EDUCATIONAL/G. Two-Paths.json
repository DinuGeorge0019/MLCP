{
    "link": "https://codeforces.com//contest/1000/problem/G",
    "problemId": "193660",
    "problem_idx": "G",
    "shortId": "1000G",
    "contest_number": "1000",
    "problem_submissions": {
        "G": [
            39718562,
            39719543,
            39731044,
            39745353
        ],
        "E": [
            39714455,
            39714380,
            39711396,
            39717344,
            39715216,
            39714198,
            39717274,
            39714849,
            39716315,
            39710033,
            39719087,
            39714919,
            39717269,
            39719314,
            39715149,
            39718067,
            39717227,
            39715819,
            39716698,
            39714956
        ],
        "F": [
            39713460,
            39707084,
            39730558,
            39730512,
            39730296,
            39730270,
            39730256,
            39730239,
            39730221,
            39730211,
            39730154,
            39730127,
            39730113,
            39730102,
            39730087,
            39730070,
            39730054,
            39730038,
            39730029,
            39715353,
            39714587,
            39718375,
            39717776,
            39709495,
            39717288,
            39718275,
            39707695,
            39714904,
            39719561,
            39715859,
            39716309,
            41303353,
            41303333,
            39722296,
            39721263,
            39713335,
            39715356,
            39718313,
            39720559,
            39710578
        ],
        "D": [
            39712036,
            39711284,
            39709815,
            39710348,
            39711331,
            39711469,
            39714291,
            39712438,
            39711322,
            39711986,
            39710186,
            39711296,
            39710596,
            39711080,
            39713011,
            39710269,
            39712921,
            39714356,
            39714670,
            39711775
        ],
        "C": [
            39709789,
            39708273,
            39708437,
            39708497,
            39707490,
            39709711,
            39711470,
            39710285,
            39709663,
            39712657,
            39707054,
            39709385,
            39707981,
            39708400,
            39708339,
            39708579,
            39711654,
            39712280,
            39711950,
            39712277
        ],
        "B": [
            39708786,
            39709741,
            39707292,
            39706954,
            39708573,
            39707999,
            39708997,
            39708329,
            39708450,
            39715462,
            39712282,
            39720742,
            39715883,
            39713342,
            39706846,
            39709837,
            39709912,
            39706999,
            39710604,
            39710245,
            39709682,
            39713043
        ],
        "A": [
            39706953,
            39704546,
            39704256,
            39704278,
            39704401,
            39705070,
            39705301,
            39704306,
            39704491,
            39713520,
            39705360,
            39704298,
            39704641,
            39704487,
            39704983,
            39705096,
            39704429,
            39704776,
            39705211,
            39713228
        ]
    },
    "name": "G. Two-Paths",
    "statement": "You are given a weighted tree (undirected connected graph with no\r\ncycles, loops or multiple edges) with n vertices. The edge\r\n{u_j, v_j\r\n} has weight w_j. Also each vertex i has its own value a_i assigned to\r\nit.Let\u2019s call a path starting in vertex u and ending in vertex v, where\r\neach edge can appear no more than twice (regardless of direction), a .\r\nVertices can appear in the 2-path multiple times (even start and end\r\nvertices).For some 2-path p profit\r\ntext{Pr}(p) =\r\nsum\r\nlimits_{v\r\nin\r\ntext{distinct vertices in } p}{a_v} -\r\nsum\r\nlimits_{e\r\nin\r\ntext{distinct edges in } p}{k_e\r\ncdot w_e}, where k_e is the number of times edge e appears in p. That\r\nis, vertices are counted once, but edges are counted the number of times\r\nthey appear in p.You are about to answer m queries. Each query is a pair\r\nof vertices (qu, qv). For each query find 2-path p from qu to qv with\r\nmaximal profit\r\ntext{Pr}(p).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, \"r\", stdin );\n#define fout(s) freopen( s, \"w\", stdout );\n\nconst long long N = 300300;\nconst long long Q = 2e18;\nconst long long mod = 998244353;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint tim;\nint dip[N];\nint tin[N];\nint tout[N];\nlong long s[N];\nlong long A[N];\nlong long B[N];\nlong long a[N];\nlong long e[N];\nlong long d[N];\nlong long u[N];\nlong long f[N];\nlong long er[N];\nint up[N][20];\nvector < int > v[N];\n\nvoid dfs(int x, int p)\n{\n        tin[x] = ++tim;\n        up[x][0] = p;\n        for(int i = 1; i < 20; i++){\n                up[x][i] = up[up[x][i - 1]][i - 1];\n        }\n        d[x] = a[x];\n        for(int h: v[x]){\n                int y = A[h] ^ B[h] ^ x;\n                if(y == p){\n                        continue;\n                }\n                dip[y] = dip[x] + 1;\n                s[y] = s[x] - e[h];\n                dfs(y, x);\n                d[x] += max(0ll, d[y] - e[h] - e[h]);\n        }\n        for(int h: v[x]){\n                int y = A[h] ^ B[h] ^ x;\n                if(y == p){\n                        continue;\n                }\n                f[y] = d[x] - max(0ll, d[y] - e[h] - e[h]);\n                er[y] = max(0ll, d[y] - e[h] - e[h]);\n        }\n        tout[x] = ++tim;\n}\n\nvoid go(int x, int p)\n{\n        for(int h: v[x]){\n                int y = A[h] ^ B[h] ^ x;\n                if(y == p){\n                        continue;\n                }\n                u[y] = max(0ll, u[x] + f[y] - e[h] - e[h]);\n                f[y] += f[x];\n                go(y, x);\n        }\n}\n\nbool is(int x, int y)\n{\n        return tin[x] <= tin[y] && tout[x] >= tout[y];\n}\n\nint lca(int x, int y)\n{\n        if(is(x, y)){\n             return x;\n        }\n        if(is(y, x)){\n                return y;\n        }\n        for(int i = 19; i >= 0; i--){\n                if(!is(up[x][i], y)){\n                        x = up[x][i];\n                }\n        }\n        return up[x][0];\n}\n\nint go_up(int x, int g)\n{\n        for(int i = 19; i >= 0; i--){\n                if(g >= (1 << i)){\n                        g -= (1 << i);\n                        x = up[x][i];\n                }\n        }\n        return x;\n}\n\nlong long get(int x, int y)\n{\n        long long profit = 0;\n        int p = lca(x, y);\n        profit += d[p];\n        if(x != p){\n                int g = go_up(x, dip[x] - dip[p] - 1);\n                profit += f[x] - f[g];\n                profit += d[x] - er[g];\n        }\n        if(y != p){\n                int g = go_up(y, dip[y] - dip[p] - 1);\n                profit += f[y] - f[g];\n                profit += d[y] - er[g];\n        }\n        profit += s[x] + s[y] - s[p] - s[p];\n        profit += u[p];\n        return profit;\n}\n\nvoid solve()\n{\n        int q;\n        cin >> n >> q;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n        }\n        for(int i = 1; i < n; i++){\n                cin >> A[i] >> B[i] >> e[i];\n                v[A[i]].push_back(i);\n                v[B[i]].push_back(i);\n        }\n        dfs(1, 1);\n        go(1, 1);\n        for(int i = 1; i <= q; i++){\n                int x, y;\n                cin >> x >> y;\n                cout << get(x, y) << \"\\n\";\n        }\n}\n\nbool mtest = false; int main()\n{\n        //fin(\"input.txt\");\n        //fout(\"output.txt\");\n        //fin(\"island.in\");\n        //fout(\"island.out\");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Two-Paths.json",
    "editorial_link": "https://codeforces.com/blog/entry/60288",
    "editorial": "Let\u00e2\u0080\u0099s solve this task in several steps.Step 1. Calculate for each\r\nvertex.Let be maximal profit of some 2-path starting at and finishing at\r\n. If vertex is a root of the tree, then equivalent to , where maximal\r\nprofit of 2-path , when we can go only in subtree of . The can be\r\ncalculated with next approach: .To calculate we can use next technique.\r\nLet\u00e2\u0080\u0099s manage next invariant: when processing vertex all its neighbours\r\n(even parent) will hold as if its parent. Then . After that, we can\r\nproceed with each child of , but before moving to it we must change\r\nvalue since we must keep invariant true. To keep it true, it\u00e2\u0080\u0099s enough to\r\nset . Also let\u00e2\u0080\u0099s memorize value as .Step 2. Processing queries.Let\r\nsimple path be . If then answer is . Otherwise, each edge on this simple\r\npath must be used exactly once. But, while travelling from to using this\r\nsimple path, at each vertex we can go somewhere and return to the only\r\ncondition is not use edges from simple path. And we can do it using\r\nprecalculated values and . So, if we want to find max profit of 2-path\r\nwith prohibited edges , , so we can use value .Finally, to process\r\nqueries, let\u00e2\u0080\u0099s find , divide it on two queries , . Now we can handle all\r\nqueries offline, travelling on tree in dfs order. Let\u00e2\u0080\u0099s manage some data\r\nstructure on current path from current vertex to the root (this DS can\r\nbe based on array of depths). Then, when we come to vertex , just add\r\nvalue to DS in position (and erase it before exit). Each query becomes a\r\nquery of sum to some subsegment in DS (don\u00e2\u0080\u0099t forget carefully handle\r\nvalue in lca). And, before moving from to , you need subtract from\r\ncurrent value of (here you can at once subtract weight of edge ). Don\u00e2\u0080\u0099t\r\nforget to return each change in DS, when it needed.As we can see, DS is\r\njust a BIT with sum on segment and change in position.Result complexity\r\nis . Fast IO are welcome.\r\n"
}