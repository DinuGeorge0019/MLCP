{
    "link": "https://codeforces.com//contest/1783/problem/G",
    "problemId": "1728816",
    "problem_idx": "G",
    "shortId": "1783G",
    "contest_number": "1783",
    "problem_submissions": {
        "G": [
            188483896,
            188470188,
            188490778,
            188491718,
            188493113,
            188527457,
            188526933,
            188518837,
            188481313
        ],
        "F": [
            188457991,
            188459741,
            188468922,
            188473664,
            188468205,
            188471208,
            188461540,
            188473366,
            188477664,
            188473046,
            188489629,
            188473873,
            188484171,
            188480546,
            188485471,
            188484623,
            188483301,
            188466307,
            188469985,
            188485060
        ],
        "E": [
            188452364,
            188453897,
            188463917,
            188466624,
            188459377,
            188459968,
            188455446,
            188466225,
            188471180,
            188466814,
            188462880,
            188467584,
            188467423,
            188462700,
            188463311,
            188503353,
            188474118,
            188475092,
            188461623,
            188502886,
            188463602,
            188475668
        ],
        "D": [
            188448529,
            188449082,
            188455318,
            188454045,
            188455437,
            188454808,
            188471673,
            188459878,
            188455664,
            188459984,
            188457996,
            188455008,
            188460084,
            188450967,
            188459128,
            188456144,
            188459103,
            188459237,
            188463185
        ],
        "C": [
            188443311,
            188439911,
            188447553,
            188445874,
            188449689,
            188446252,
            188448135,
            188452418,
            188447924,
            188450344,
            188449627,
            188448578,
            188449959,
            188467122,
            188452277,
            188450824,
            188449810,
            188450396,
            188451763,
            188456895
        ],
        "B": [
            188434637,
            188433902,
            188440591,
            188436845,
            188440180,
            188437731,
            188434593,
            188440675,
            188439917,
            188436694,
            188436264,
            188437707,
            188438645,
            188437659,
            188440538,
            188439980,
            188442461,
            188440519,
            188465336,
            188436451
        ],
        "A": [
            188432373,
            188432255,
            188432618,
            188432523,
            188433063,
            188432771,
            188432273,
            188433871,
            188432631,
            188433273,
            188432881,
            188432854,
            188433005,
            188432822,
            188435678,
            188432922,
            188432552,
            188432977,
            188432291,
            188432577
        ]
    },
    "name": "G. Weighed Tree Radius",
    "statement": "You are given a tree of n vertices and n - 1 edges. The i-th vertex has\r\nan initial weight a_i.Let the d_v(u) from vertex v to vertex u be the\r\nnumber of edges on the path from v to u. Note that d_v(u) = d_u(v) and\r\nd_v(v) = 0.Let the distance w_v(u) from v to u be w_v(u) = d_v(u) + a_u.\r\nNote that w_v(v) = a_v and w_v(u)\r\nneq w_u(v) if a_u\r\nneq a_v.Analogically to usual distance, let’s define the e(v) of vertex\r\nv as the greatest weighted distance from v to any other vertex\r\n(including v itself), or e(v) =\r\nmax\r\nlimits_{1\r\nle u\r\nle n}{w_v(u)}.Finally, let’s define the r of the tree as the minimum\r\neccentricity of any vertex, or r =\r\nmin\r\nlimits_{1\r\nle v\r\nle n}{e(v)}.You need to perform m queries of the following form: v_j x_j\r\nassign a_{v_j} = x_j. After performing each query, print the radius r of\r\nthe current tree.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\ntemplate<class Info,\n    class Merge = std::plus<Info>>\nstruct SegmentTree {\n    const int n;\n    const Merge merge;\n    std::vector<Info> info;\n    SegmentTree(int n) : n(n), merge(Merge()), info(4 << std::__lg(n)) {}\n    SegmentTree(std::vector<Info> init) : SegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = merge(info[2 * p], info[2 * p + 1]);\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y));\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n};\n\nconstexpr int inf = 1E9;\n\nstruct Info {\n    std::array<int, 2> sid;\n    int mid;\n    std::array<int, 2> l;\n    std::array<int, 2> r;\n    std::array<int, 3> ans;\n    \n    Info() : sid{-inf, -1}, mid{-inf}, l{-inf, -1}, r{-inf, -1}, ans{-inf, -1, -1} {}\n    Info(int x, int a, int id) : sid{x + a, id}, mid{-2 * x}, l{-x + a, id}, r{-x + a, id}, ans{0, id, id} {}\n};\n\nInfo operator+(const Info &a, const Info &b) {\n    Info c;\n    c.sid = std::max(a.sid, b.sid);\n    c.mid = std::max(a.mid, b.mid);\n    c.l = std::max({a.l, b.l, std::array{a.sid[0] + b.mid, a.sid[1]}});\n    c.r = std::max({a.r, b.r, std::array{b.sid[0] + a.mid, b.sid[1]}});\n    c.ans = std::max({a.ans, b.ans, std::array{a.l[0] + b.sid[0], a.l[1], b.sid[1]}, std::array{a.sid[0] + b.r[0], a.sid[1], b.r[1]}});\n    return c;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<std::vector<int>> adj(n);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        std::cin >> u >> v;\n        u--, v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    std::vector<int> euler, teul(n), dep(n), parent(n, -1);\n    int tm = 0;\n    \n    auto dfs = [&](auto dfs, int x) -> void {\n        euler.push_back(x);\n        teul[x] = tm++;\n        for (auto y : adj[x]) {\n            if (y == parent[x]) continue;\n            parent[y] = x;\n            dep[y] = dep[x] + 1;\n            dfs(dfs, y);\n            euler.push_back(x);\n            tm++;\n        }\n    };\n    dfs(dfs, 0);\n    \n    std::vector<Info> ini(2 * n - 1);\n    for (int i = 0; i < 2 * n - 1; i++) {\n        int x = euler[i];\n        if (i == teul[x]) {\n            ini[i] = Info(dep[x], a[x], x);\n        } else {\n            ini[i] = Info(dep[x], 0, x);\n        }\n    }\n    SegmentTree<Info> seg(ini);\n    \n    int m;\n    std::cin >> m;\n    \n    while (m--) {\n        int x, y;\n        std::cin >> x >> y;\n        x--;\n        a[x] = y;\n        seg.modify(teul[x], Info(dep[x], a[x], x));\n        \n        auto [d, u, v] = seg.info[1].ans;\n        \n        if (dep[u] + a[u] < dep[v] + a[v]) std::swap(u, v);\n        \n        int ans = std::max({a[u], a[v], (d + 1) / 2});\n        std::cout << ans << \"\\n\";\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "implementation",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Weighed Tree Radius.json",
    "editorial_link": "https://codeforces.com//blog/entry/111194",
    "editorial": "Firstly, letâs define the weight of path as . On contrary to weighted\r\ndistances, and also .Now, letâs define the diameter of a tree as path\r\nwith maximum . Itâs okay if diameter may be explicit case . The useful\r\npart of such definition is next: our diameter still holds most\r\nproperties of the usual diameter. Letâs look at two of them: There is a\r\nvertex on diameter path with and . Itâs easy to prove after noting the\r\nfact that and (otherwise, you could choose diameter or ). For any vertex\r\neccentricity . In other words, either or has the maximum distance from .\r\n(You can also prove it by contradiction). It also means that . The two\r\nproperties above give us an easy way to calculate the radius: just\r\nmaintain diameter , and the answer is a half of it.Now letâs look how\r\nthe diameter changes when we change the weight . If itâs quite easy. The\r\nonly paths that change weights are the paths ending at . Denote such\r\npath as and note that either or . In other words, there will be only\r\nthree candidates for a new diameter: path with ; path with ; path with .\r\nThe only thing you need to calculate fast enough is the two distances\r\nand . And since , your task is to calculate .Finally, how to handle\r\ndecreasing âs? Letâs get rid of them using DCP (dynamic connectivity\r\nproblem) technique. Keep track of each value : each possible value for\r\nsome vertex will be \"active\" on some segment of queries . Since there\r\nare only queries, there will be exactly such segments for all vertices\r\nin total.Now, all queries becomes \"assign on some segment of queries \".\r\nNote that in that case, the previous value of was , so you are dealing\r\nwith only \"increasing value\" queries.Finally, to handle all range\r\nqueries efficiently, you build a Segment Tree on queries, set all\r\nqueries and then traverse your Segment Tree while maintaining the\r\ncurrent diameter in order to calculate answers for all queries.Each of\r\nqueries transforms in queries to segment tree vertices, and preforming\r\neach query asks you to calculate two times.If you use the usual binary\r\nlifting, then your complexity becomes what is okay. But if you use\r\nSparse Table on Euler tour, you can take in and your complexity will be\r\n.\r\n",
    "hint": []
}