{
    "link": "https://codeforces.com//contest/920/problem/D",
    "problemId": "152864",
    "problem_idx": "D",
    "shortId": "920D",
    "contest_number": "920",
    "problem_submissions": {
        "G": [
            34852743,
            34853590,
            34854300,
            34853934,
            34856261,
            34853609,
            34857997,
            34854137,
            34863997,
            34863325,
            34845932,
            35124212,
            35123972,
            34865228,
            34854370,
            34856832,
            34844552,
            34869557,
            34855295,
            34853458,
            34855692,
            34852849,
            34855311,
            34861027,
            34859762
        ],
        "F": [
            34850786,
            34848482,
            34849125,
            34847410,
            34850587,
            34855922,
            34851634,
            34865588,
            34861253,
            34849345,
            35122442,
            34861362,
            34851005,
            34852570,
            34847838,
            34850627,
            34847445,
            34849654,
            34849272,
            34857704,
            34855104,
            34855630
        ],
        "E": [
            34849129,
            34851685,
            34845896,
            34844151,
            34856145,
            34852326,
            34847420,
            34858206,
            34852441,
            35117849,
            34858048,
            34856421,
            64420065,
            59900329,
            59900252,
            34850422,
            34851876,
            34846457,
            34850665,
            34846959,
            34846751,
            34850722,
            34850540,
            34853490
        ],
        "D": [
            34846246,
            34857983,
            34865210,
            34864920,
            34863172,
            34865887,
            34863373,
            34855083,
            34863045,
            34852180,
            34864800,
            34865039,
            34861962,
            34930637,
            34904017,
            34882639,
            34870887,
            34935056,
            34932865
        ],
        "C": [
            34843334,
            34845308,
            34844415,
            34853136,
            34845188,
            34848715,
            34849757,
            34845177,
            34857782,
            35115887,
            35115738,
            35114927,
            34846351,
            34860924,
            34843957,
            34863534,
            34843082,
            34844466,
            34843157,
            34844360,
            34846666,
            34847453,
            34846518
        ],
        "B": [
            34842856,
            34846490,
            34843649,
            34849908,
            34843576,
            34845185,
            34844678,
            34844108,
            34855655,
            35114208,
            34844457,
            34859635,
            34842933,
            34867088,
            34844653,
            34842667,
            34842611,
            34843316,
            34845332,
            34845365,
            34845176
        ],
        "A": [
            34842470,
            34844425,
            34842543,
            34843209,
            34842761,
            34843665,
            34842482,
            34842652,
            34854235,
            35113527,
            34842534,
            34843074,
            34842510,
            34864789,
            34842605,
            34842461,
            34842474,
            34849846,
            34842901,
            34843015,
            34842733
        ]
    },
    "name": "D. Tanks",
    "statement": "Petya sometimes has to water his field. To water the field, Petya needs\r\na tank with exactly ml of water.Petya has got tanks, -th of them\r\ninitially containing ml of water. The tanks are really large, any of\r\nthem can contain any amount of water (no matter how large this amount\r\nis).Also Petya has got a scoop that can contain up to ml of water\r\n(initially the scoop is empty). This scoop can be used to get some water\r\nfrom some tank, and after that pour it all into some tank (it is\r\nimpossible to get water from multiple tanks without pouring it, or leave\r\nsome water in the scoop when pouring it). When Petya tries to get some\r\nwater from a tank, he gets water, where is the current volume of water\r\nin the tank.Is it possible to obtain a tank with exactly ml of water\r\nusing these operations? If it is possible, print a sequence of\r\noperations that allows to do it. If there are multiple ways to obtain\r\nneeded amount of water in some tank, print any of them.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nbool dp[5050][5050];\nbool prv[5050][5050];\nint in[5050];\nint main() {\n\tint N, K, V, i, j;\n\tscanf(\"%d %d %d\", &N, &K, &V);\n\tfor (i = 1; i <= N; i++) scanf(\"%d\", &in[i]);\n\n\tint s = 0;\n\tfor (i = 1; i <= N; i++) s += in[i];\n\tif (s < V) return !printf(\"NO\\n\");\n\n\tdp[0][0] = true;\n\tfor (i = 1; i <= N; i++) {\n\t\tint x = in[i] % K;\n\t\tfor (j = 0; j < K; j++) {\n\t\t\tif (!dp[i - 1][j]) continue;\n\t\t\tdp[i][j] = true;\n\t\t\tprv[i][j] = false;\n\n\t\t\tdp[i][(j + x) % K] = true;\n\t\t\tprv[i][(j + x) % K] = true;\n\t\t}\n\t}\n\n\tif (!dp[N][V%K]) return !printf(\"NO\\n\");\n\n\tvector <int> Vl[2];\n\tint v = V%K;\n\tfor (i = N; i >= 1; i--) {\n\t\tint x = in[i] % K;\n\t\tif (prv[i][v]) {\n\t\t\tVl[1].push_back(i);\n\t\t\tv = (v - x + K) % K;\n\t\t}\n\t\telse Vl[0].push_back(i);\n\t}\n\tsort(all(Vl[0]));\n\tsort(all(Vl[1]));\n\n\tprintf(\"YES\\n\");\n\tif (!Vl[0].empty()) {\n\t\tfor (i = 1; i < Vl[0].size(); i++) printf(\"%d %d %d\\n\", 100000, Vl[0][i], Vl[0][0]);\n\t}\n\tif (!Vl[1].empty()) {\n\t\tfor (i = 1; i < Vl[1].size(); i++) printf(\"%d %d %d\\n\", 100000, Vl[1][i], Vl[1][0]);\n\t}\n\n\ts = 0;\n\tfor (auto it : Vl[1]) s += in[it];\n\n\tint p0, p1;\n\tif (Vl[0].empty()) p0 = Vl[1][1], p1 = Vl[1][0];\n\telse if (Vl[1].empty()) p0 = Vl[0][0], p1 = Vl[0][1];\n\telse p0 = Vl[0][0], p1 = Vl[1][0];\n\n\tif (s > V) printf(\"%d %d %d\\n\", (s - V) / K, p1, p0);\n\tif (s < V) printf(\"%d %d %d\\n\", (V - s) / K, p0, p1);\n\treturn 0;\n}\n//*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Tanks.json",
    "editorial_link": "https://codeforces.com/blog/entry/57516",
    "editorial": "Eliminate the obvious corner case when we don\u00e2\u0080\u0099t have enough water ().\r\nNow we don\u00e2\u0080\u0099t consider it in editorial.Let\u00e2\u0080\u0099s fix some set of tanks , and\r\nlet be (the total amount of water in the set). If ( and have the same\r\nremainders modulo ), then we can transfer all water from to one tank ,\r\ntransfer all water from to another tank , and then using some number of\r\noperations transfer required amount of water from to (or from to ). So\r\nwe have a solution when we have some set of tanks such that .What if we\r\ndon\u00e2\u0080\u0099t have such set? In this case it is impossible to solve the problem\r\nsince we cannot obtain a tank with water such that (and, obviously, we\r\ncannot obtain a tank with exactly water).To find this set , we may use\r\nsome sort of knapsack dynamic programming.\r\n"
}