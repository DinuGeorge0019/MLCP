{
    "link": "https://codeforces.com//contest/846/problem/E",
    "problemId": "121001",
    "problem_idx": "E",
    "shortId": "846E",
    "contest_number": "846",
    "problem_submissions": {
        "F": [
            30108156,
            30107162,
            30106647,
            30108328,
            30107786,
            30107476,
            30108023,
            30105549,
            30105678,
            30108397,
            30109633,
            30109280,
            30109385,
            30107975,
            30110238,
            30108732,
            30108760,
            30110164
        ],
        "E": [
            30107342,
            30108640,
            30109160,
            30110715,
            30110194,
            30109970,
            30108774,
            30110412,
            30109505,
            30110880,
            30108739,
            30110755,
            30111630,
            30111870,
            30111911,
            30111723,
            30113425,
            30111880
        ],
        "D": [
            30105892,
            30106073,
            30106673,
            30106266,
            30106933,
            30108722,
            30106872,
            30105786,
            30108926,
            30106473,
            30106803,
            30107029,
            30107512,
            30108104,
            30109714,
            30108207,
            30110001,
            30111074,
            30108770
        ],
        "C": [
            30105238,
            30104755,
            30105662,
            30105293,
            30106309,
            30106223,
            30104825,
            30107791,
            30105043,
            30105080,
            30106115,
            30105906,
            30106686,
            30106808,
            30107246,
            30107701,
            30107036,
            30107208
        ],
        "B": [
            30103719,
            30103777,
            30104242,
            30103580,
            30104340,
            30105094,
            30103843,
            30104470,
            30103928,
            30103957,
            30104536,
            30104441,
            30104836,
            30104758,
            30104309,
            30105851,
            30104847,
            30105774
        ],
        "A": [
            30103161,
            30103232,
            30103250,
            30103170,
            30103456,
            30103369,
            30103168,
            30103235,
            30103196,
            30103253,
            30103176,
            30103313,
            30103584,
            30103300,
            30103249,
            30104174,
            30103638,
            30104542
        ]
    },
    "name": "E. Chemistry in Berland",
    "statement": "Igor is a post-graduate student of chemistry faculty in Berland State\r\nUniversity (BerSU). He needs to conduct a complicated experiment to\r\nwrite his thesis, but laboratory of BerSU doesn’t contain all the\r\nmaterials required for this experiment.Fortunately, chemical laws allow\r\nmaterial transformations (yes, chemistry in Berland differs from ours).\r\nBut the rules of transformation are a bit strange.Berland chemists are\r\naware of materials, numbered in the order they were discovered. Each\r\nmaterial can be transformed into some other material (or vice versa).\r\nFormally, for each there exist two numbers and that denote a possible\r\ntransformation: kilograms of material can be transformed into kilogram\r\nof material , and kilogram of material can be transformed into kilogram\r\nof material . Chemical processing equipment in BerSU allows only such\r\ntransformation that the amount of resulting material is .For each ()\r\nIgor knows that the experiment requires kilograms of material , and the\r\nlaboratory contains kilograms of this material. Is it possible to\r\nconduct an experiment after transforming some materials (or none)?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define N 101010\ntypedef long long LL;\nLL n , d[ N ] , p[ N ];\nvector< pair<LL,LL> > v[ N ];\nconst LL inf = 100000000000000000LL;\nvoid DP( int now ){\n  for( auto e : v[ now ] ){\n    LL son = e.first;\n    LL ki = e.second;\n    DP( son );\n    if( d[ son ] >= 0 )\n      d[ now ] += d[ son ];\n    else{\n      LL nd = -d[ son ];\n      if( nd >= inf / ki ){\n        puts( \"NO\" );\n        exit(0);\n      }\n      d[ now ] -= nd * ki;\n      if( d[ now ] < -inf ){\n        puts( \"NO\" );\n        exit(0);\n      }\n    }\n  }\n}\nint main(){\n  scanf( \"%lld\" , &n );\n  for( LL i = 1 , x ; i <= n ; i ++ ){\n    scanf( \"%lld\" , &x );\n    d[ i ] += x;\n  }\n  for( LL i = 1 , x ; i <= n ; i ++ ){\n    scanf( \"%lld\" , &x );\n    d[ i ] -= x;\n  }\n  for( LL i = 2 , x ; i <= n ; i ++ ){\n    scanf( \"%lld%lld\" , &p[ i ] , &x );\n    v[ p[ i ] ].push_back( { i , x } );\n  }\n  DP( 1 );\n  puts( d[ 1 ] >= 0 ? \"YES\" : \"NO\" );\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "greedy",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Chemistry in Berland.json",
    "editorial_link": "https://codeforces.com//blog/entry/54357",
    "editorial": "Since , then the transformation graph is a tree. Letâs solve the problem\r\nrecursively.Suppose that material is a leaf in the tree (there is no\r\nsuch that ). Then if we donât have enough material , we have to\r\ntransform some of material into . Letâs transform the amount required to\r\nset current amount of material to ; if we donât have the required amount\r\nof material , then this amount will temporarily be negative. And if we\r\nhave more material than we need to conduct the experiment, then we will\r\ntransform it to . The same algorithm can be applied to any non-root\r\nnode, but we first need to do this for all its children. This algorithm\r\nis optimal because each time we take the minimum possible amount from\r\nthe parent.After this the root will be the only node such that is not\r\nnecessarily equal to current amount of material . Since we solved the\r\nproblem for all other materials and did it optimally, now the answer is\r\nYES iff current amount of material is not less than .This must be\r\nimplemented carefully. Since the total amount of materials never\r\nincreases, then if some materialâs current amount is less than, for\r\nexample, , then the answer is already NO. Also overflows in\r\nmultiplication must be avoided; to do this, we can firstly check if the\r\nresult of multiplication is not too big by multiplying values as real\r\nnumbers.\r\n",
    "hint": []
}