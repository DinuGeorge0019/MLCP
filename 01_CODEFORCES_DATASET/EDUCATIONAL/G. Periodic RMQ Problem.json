{"link": "https://codeforces.com//contest/803/problem/G", "problemId": "104512", "problem_idx": "G", "shortId": "803G", "contest_number": "803", "problem_submissions": {"G": [26726035, 26727236, 26728097, 26728472, 26729664, 26728547, 26729890, 26729652, 26730512, 26730113, 26730878, 26731530, 26730264, 26729609, 26731875, 26731225, 26730998, 26731497, 85623556, 85623400, 85623203, 85610564, 26730604, 26731476, 26739085], "F": [26724381, 26725200, 26724999, 26724225, 26725048, 26726085, 26726135, 26725801, 26725931, 26726156, 26724237, 26725565, 26725769, 26725975, 26725077, 26727341, 219766415, 219762164, 86051599, 85608329, 85608294, 26727055, 26729462, 26724972, 26728098], "E": [26723728, 26723918, 26725958, 26726239, 26725998, 26724505, 26727035, 26727052, 26723853, 26725311, 26727501, 26726914, 26727667, 26727932, 26726295, 26728308, 219762036, 98250927, 85613733, 85609978, 26729021, 26728273, 26726912, 26725646], "D": [26722977, 26723233, 26723695, 26725081, 26724545, 26723805, 26724818, 26724584, 26727766, 26724054, 26726588, 26724927, 26726822, 26728941, 26727298, 26726013, 219765850, 219765028, 219764202, 219763496, 219763057, 219762723, 219441244, 219440803, 85611079, 85608311, 26727687, 26726965, 26728216, 26724323], "C": [26722334, 26722568, 26722532, 26722824, 26723265, 26722578, 26723153, 26723401, 26722404, 26722763, 26723297, 26723217, 26723235, 26723982, 26723346, 26723675, 242139836, 219765419, 219763158, 219763096, 219761007, 219442588, 146711212, 145821319, 145799672, 145735366, 145734989, 145733450, 98410618, 86049796, 85608695, 85608222, 26725413, 26725578, 26723041, 26729567, 26723237], "B": [26721944, 26722045, 26721880, 26722109, 26722081, 26722066, 26721973, 26722263, 26721992, 26722120, 26722619, 26722232, 26722292, 26722323, 26722429, 26722715, 219763640, 219440626, 219440279, 219439802, 219439698, 219439657, 219439387, 145736466, 145734257, 145732182, 145731921, 145731518, 145731457, 98408561, 86048023, 85606269, 85605951, 26723519, 26722908, 26722174, 26722306], "A": [26721819, 26721835, 26721801, 26721879, 26721871, 26721890, 26722559, 26722009, 26721857, 26721866, 26722146, 26721862, 26721911, 26721970, 26722141, 26722309, 219764352, 219763598, 219760906, 219439616, 145819775, 145737562, 145734009, 145733505, 145732992, 145731371, 98408337, 85608245, 85608205, 26725229, 26724294, 26721926, 26721904]}, "name": "G. Periodic RMQ Problem", "statement": "You are given an array consisting of positive integers and queries to\r\nthis array. There are two types of queries: for each index such that set\r\n. find the minimum among such that . We decided that this problem is too\r\neasy. So the array is given in a compressed form: there is an array\r\nconsisting of elements and a number in the input, and before all queries\r\nis equal to the concatenation of arrays (so the size of is ).\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst int INF = (int)1e9 + 5;\n\nstruct Node\n{\n    int l, r;\n    int val;\n    int toPush;\n\n    Node() : l(), r(), val(INF), toPush(-1) {}\n    Node(int _l, int _r) : l(_l), r(_r), val(INF), toPush(-1) {}\n};\n\nconst int N = 1 << 18;\nNode tree[2 * N];\nint a[N];\nint n, k, m;\nint q[N][4];\nint xs[N];\nint xsSz;\n\nvoid build()\n{\n    for (int i = 0; i < N; i++)\n        tree[N + i] = Node(i, i + 1);\n    for (int i = N - 1; i > 0; i--)\n        tree[i] = Node(tree[2 * i].l, tree[2 * i + 1].r);\n    return;\n}\n\nvoid push(int v)\n{\n    if (v >= N) throw;\n    if (tree[v].toPush == -1) return;\n    for (int u = 2 * v; u < 2 * v + 2; u++)\n    {\n        tree[u].val = tree[v].toPush;\n        tree[u].toPush = tree[v].toPush;\n    }\n    tree[v].toPush = -1;\n    return;\n}\nvoid update(int v)\n{\n    if (v >= N) throw;\n    tree[v].val = min(tree[2 * v].val, tree[2 * v + 1].val);\n    return;\n}\n\nvoid setOnSegm(int v, int l, int r, int x)\n{\n    if (l <= tree[v].l && tree[v].r <= r)\n    {\n        tree[v].val = tree[v].toPush = x;\n        return;\n    }\n    if (l >= tree[v].r || tree[v].l >= r) return;\n    push(v);\n    setOnSegm(2 * v, l, r, x);\n    setOnSegm(2 * v + 1, l, r, x);\n    update(v);\n    return;\n}\n\nint getMin(int v, int l, int r)\n{\n    if (l <= tree[v].l && tree[v].r <= r)\n        return tree[v].val;\n    if (l >= tree[v].r || tree[v].l >= r)\n        return INF;\n    push(v);\n    return min(getMin(2 * v, l, r), getMin(2 * v + 1, l, r));\n}\n\nint getCyclicMin(int l, int r)\n{\n    if (r - l >= n)\n        return getMin(1, 0, n);\n    l %= n;\n    r %= n;\n    if (l < r)\n        return getMin(1, l, r);\n    else\n        return min(getMin(1, l, n), getMin(1, 0, r));\n}\n\nvoid read()\n{\n    scanf(\"%d%d\", &n, &k);\n    for (int i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);\n    build();\n    for (int i = 0; i < n; i++)\n        setOnSegm(1, i, i + 1, a[i]);\n    scanf(\"%d\", &m);\n    xsSz = 0;\n    xs[xsSz++] = 0;\n    xs[xsSz++] = n * k;\n    for (int i = 0; i < m; i++)\n    {\n        scanf(\"%d%d%d\", &q[i][0], &q[i][1], &q[i][2]);\n        if (q[i][0] == 1)\n            scanf(\"%d\", &q[i][3]);\n        q[i][1]--;\n        xs[xsSz++] = q[i][1];\n        xs[xsSz++] = q[i][2];\n    }\n    sort(xs, xs + xsSz);\n    xsSz = unique(xs, xs + xsSz) - xs;\n    for (int i = 0; i < m; i++)\n        for (int j = 1; j < 3; j++)\n            q[i][j] = lower_bound(xs, xs + xsSz, q[i][j]) - xs;\n    for (int i = 0; i < xsSz - 1; i++)\n        a[i] = getCyclicMin(xs[i], xs[i + 1]);\n    build();\n    n = xsSz - 1;\n    for (int i = 0; i < n; i++)\n        setOnSegm(1, i, i + 1, a[i]);\n    return;\n}\n\nint main()\n{\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    read();\n    for (int i = 0; i < m; i++)\n    {\n        if (q[i][0] == 1)\n            setOnSegm(1, q[i][1], q[i][2], q[i][3]);\n        else\n            printf(\"%d\\n\", getMin(1, q[i][1], q[i][2]));\n    }\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2300", "interactive": false}