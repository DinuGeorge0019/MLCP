{
    "link": "https://codeforces.com//contest/1511/problem/G",
    "problemId": "955218",
    "problem_idx": "G",
    "shortId": "1511G",
    "contest_number": "1511",
    "problem_submissions": {
        "F": [
            112840077,
            112828537,
            112827087,
            113002746,
            112851650,
            112835176,
            112837815,
            112833990,
            112833873,
            112824360,
            112844580,
            112864617,
            112862363,
            112847364,
            112866931,
            112854217,
            112847572,
            112854389,
            112862579,
            112845350
        ],
        "G": [
            112827572,
            112849564,
            114661033,
            114660887,
            114660767,
            114660706,
            114660307,
            114660076,
            114659999,
            114659915,
            112892560,
            112862384,
            112862341,
            112862288,
            112850067,
            112846404,
            112853880,
            112853846,
            112850825,
            112896875,
            112847874,
            113122868,
            112859368,
            112858002,
            112857690,
            112970481,
            112947065,
            112923272,
            112913505,
            113005183,
            112847551,
            112853638,
            112855715
        ],
        "E": [
            112819190,
            112811502,
            112809874,
            112818379,
            112809749,
            112819391,
            112816521,
            112812422,
            112824024,
            112811228,
            112816399,
            112821852,
            112825588,
            112822496,
            112814072,
            112820021,
            112829060,
            112824596
        ],
        "D": [
            112810190,
            112804690,
            112802519,
            112810990,
            112813483,
            112807233,
            112809814,
            112797395,
            112806426,
            112804268,
            112810141,
            112805389,
            112810319,
            112811043,
            112802328,
            112810501,
            112810922,
            112816639
        ],
        "C": [
            112798920,
            112798787,
            112796760,
            112804959,
            112800997,
            112799737,
            112805004,
            112792842,
            112799549,
            112797984,
            112795724,
            112796489,
            112801048,
            112802109,
            112797807,
            112801283,
            112801426,
            112804850
        ],
        "B": [
            112794609,
            112794368,
            112790815,
            112794707,
            112794954,
            112796065,
            112801022,
            112788437,
            112794356,
            112792946,
            112790545,
            112792316,
            112798211,
            112798547,
            112790397,
            112797545,
            112796307,
            112796695
        ],
        "A": [
            112787944,
            112786809,
            112787014,
            112786892,
            112787663,
            112788591,
            112791727,
            112786823,
            112788650,
            112788073,
            112786815,
            112787413,
            112786972,
            112791493,
            112787338,
            112792315,
            112786886,
            112787405
        ]
    },
    "name": "G. Chips on a Board",
    "statement": "Alice and Bob have a rectangular board consisting of n rows and m\r\ncolumns. Alice and Bob play the following game. They choose two integers\r\nl and r such that 1\r\nle l\r\nle r\r\nle m and cut the board in such a way that only the part of it between\r\ncolumn l and column r (inclusive) remains. So, all columns to the left\r\nof column l and all columns to the right of column r no longer belong to\r\nthe board.After cutting the board, they move chips on the remaining part\r\nof the board (the part from column l to column r). They make alternating\r\nmoves, and the player which cannot make a move loses the game. The first\r\nmove is made by Alice, the second by Bob, the third by Alice, and so on.\r\nDuring their move, the player must choose one of the chips from the\r\nboard and move it any positive number of cells to the left (so, if the\r\nchip was in column i, it can move to any column j < i, and the chips in\r\nthe leftmost column cannot be chosen).Alice and Bob have q pairs of\r\nnumbers L_i and R_i. For each such pair, they want to determine who will\r\nbe the winner of the game if l = L_i and r = R_i. Note that these games\r\nshould be considered independently (they don\u2019t affect the state of the\r\nboard for the next games), and both Alice and Bob play optimally.\r\n",
    "solutions": [
        "#ifdef ONLINE_JUDGE\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#define NDEBUG\n#endif\n\n#include <bits/stdc++.h>\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n = scan();\n  int m = scan();\n  vector<int> a(n);\n  for (auto&& e : a) e = scan() - 1;\n  sort(ALL(a));\n  for (int q = scan(); q--;) {\n    int lo = scan() - 1;\n    int hi = scan() - 1;\n    int l = lower_bound(ALL(a), lo) - begin(a);\n    int r = upper_bound(ALL(a), hi) - begin(a);\n    int x = 0;\n    for (int i : Rep(l, r)) x ^= a[i] - lo;\n    cout << \"AB\"[x == 0];\n  }\n  cout << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "data structures",
        "dp",
        "games",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Chips on a Board.json",
    "editorial_link": "https://codeforces.com//blog/entry/89634",
    "editorial": "The model solution is , where , but it seems that there are faster ones.\r\nI\u00e2\u0080\u0099ll explain the model solution nevertheless.It\u00e2\u0080\u0099s easy to see (using\r\nsimple Nim theory) that the answer for a query is iff the xor of for all\r\nchips such that is equal to . Let\u00e2\u0080\u0099s calculate this xor for every query.\r\nThis number contains at most bits, and we will process these bits\r\ndifferently: we will choose some number and use one solution to\r\ncalculate lowest bits, and another solution to compute highest bits. One\r\nidea is common in both solutions: we split each query into two queries a\r\nquery can be represented as a combination of two queries and , where is\r\nthe xor of all numbers such that . After converting the queries, for\r\nevery , store each query of the form in some sort of vector (or any\r\nother data structure). We will use an approach similar to sweep line:\r\niterate on and solve the queries for the current . These ideas will be\r\nused both for the solution calculating lowest bits and for the solution\r\ncalculating highest bits.How to find lowest bits in each query? Iterate\r\non from to and maintain the number of occurrences of each number we met\r\nso far. Then, at a moment we want to calculate , simply iterate on all\r\nof the values of and process each value in (if the number of occurrences\r\nof some value is odd, update the current answer to the query by xoring\r\nthe number with , otherwise just skip it). And since we are interested\r\nonly in lowest bits, for each , we need only the remainder , so the\r\nnumber of different values is . Thus, this part of the solution runs in\r\n.Okay, what about highest bits in each query? We can see that, for every\r\nnumber , the highest bits of don\u00e2\u0080\u0099t change too often when we iterate on :\r\nthere will be about segments where the highest bits of have different\r\nvalues. We can build a data structure that allows use to process two\r\nqueries: xor all numbers on a segment with some value and get the value\r\nin some position (Fenwick trees and segment trees can do it). Then, we\r\nagain iterate on from to . When we want to process a number , we find\r\nthe segments where the highest bits of have the same value and perform\r\nupdates on these segments in our data structure. When we process a query\r\nof the form , we simply get the value in the position from our data\r\nstructure. This part of the solution works in .By choosing optimally, we\r\ncan combine these two parts into a solution with complexity of .\r\n"
}