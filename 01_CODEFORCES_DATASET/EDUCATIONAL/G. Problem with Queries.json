{
    "link": "https://codeforces.com//contest/2043/problem/G",
    "problemId": "3103852",
    "problem_idx": "G",
    "shortId": "2043G",
    "contest_number": "2043",
    "problem_submissions": {
        "G": [
            298276621,
            298458376,
            298455954,
            298459741,
            298498128,
            298494225,
            298493989,
            298368643,
            298368617
        ],
        "F": [
            298243973,
            298258053,
            298242817,
            298260253,
            298257085,
            298250612,
            298241233,
            298252743,
            298266622,
            298254223,
            298258269,
            298270540,
            298270292,
            298270970,
            298272964,
            298350526,
            298284182,
            298276985,
            298272819,
            298283274,
            298421391,
            298417038,
            298257904
        ],
        "E": [
            298230325,
            298236565,
            298229495,
            298226934,
            298227308,
            298237122,
            298220698,
            298238215,
            298226770,
            298234499,
            298239196,
            298230091,
            298228297,
            298244169,
            298310355,
            298234798,
            298238168,
            298247710,
            298242187,
            298286367
        ],
        "D": [
            298219869,
            298216982,
            298222571,
            298218218,
            298213410,
            298224781,
            298213619,
            298219577,
            298216318,
            298221470,
            298226089,
            298219311,
            298219518,
            298230143,
            298226137,
            298226579,
            298229601,
            298224236,
            298231826
        ],
        "C": [
            298215825,
            298213305,
            298214855,
            298212674,
            298210052,
            298218770,
            298246686,
            298216835,
            298211668,
            298217178,
            298218473,
            298215699,
            298214498,
            298219482,
            298220559,
            298222653,
            298215672,
            298216539,
            298220531
        ],
        "B": [
            298205974,
            298203999,
            298204560,
            298204165,
            298201534,
            298206623,
            298209665,
            298205595,
            298204637,
            298205310,
            298207112,
            298207961,
            298204179,
            298210111,
            298210081,
            298211372,
            298204136,
            298203902,
            298209938
        ],
        "A": [
            298200061,
            298199218,
            298199258,
            298199378,
            298199175,
            298200132,
            298199984,
            298200407,
            298199812,
            298205860,
            298199259,
            298199630,
            298199502,
            298199251,
            298211149,
            298199244,
            298199260,
            298199390,
            298200087
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137801",
    "editorial": "First, letâs reformulate the problem. Instead of counting the number of\r\npairs of distinct elements in a segment, we will count the number of\r\npairs of identical elements and subtract it from the total number of\r\npairs. To solve this problem, we will use square root decomposition on\r\nthe array.Letâs divide the original array into blocks of size and learn\r\nhow to answer queries that satisfy the following conditions: this means\r\nthat the left boundary of the query coincides with the beginning of some\r\nblock of the square root decomposition; this means that the right\r\nboundary of the query coincides with the last element of some block of\r\nthe square root decomposition. Due to this restriction on the problem,\r\nwe can utilize certain properties that will be necessary for our\r\nsolution: The order of elements within a block does not matter; we can\r\ntreat each block of our square root decomposition as an unordered\r\nmultiset; Changing the value of an element in terms of a multiset can be\r\nreformulated as removing the old value and adding the new value. In\r\ngeneral, the modified queries can be rewritten in the following format:\r\nadd an element with value to the block . remove an element with value\r\nfrom the block . count the number of pairs of positions , where and .\r\nLetâs assume we have an array , which stores the answer to the third\r\ntype of query for all possible segments of blocks , where is the number\r\nof blocks in the square root decomposition of our array. Initially, we\r\nfill the array with zeros and then add all elements using the\r\noperation.Letâs observe how the first type of query modifies this array;\r\nthe second type of query is considered similarly. When an element with\r\nvalue is added to the block , it affects all elements of the array such\r\nthat .For a specific element of the array , its value increases by the\r\nnumber of occurrences of the element in the segment . This happens\r\nbecause the added element can form a pair with all existing elements\r\nequal to the specified value that belong to this segment. Formally, this\r\ncan be described as , where is a function that returns the number of\r\noccurrences of the element in the blocks . The function can be\r\nmaintained by storing an array , where for each element , it will store\r\nhow many times it appears in the segment of blocks .When adding an\r\nelement, the number of values that need to be recalculated will be about\r\n. If we can do this in , we can achieve a solution in , taking .\r\nUnfortunately, it is practically impossible to fit this within time\r\nlimits, so letâs try to improve the solution. Returning to the\r\ndescription of how to modify an arbitrary element of the array , letâs\r\nrewrite and transform the formula: into . The second term in this\r\nexpression does not use the right boundary , and the third term does not\r\nuse the left boundary . Suppose we want to add the second term to the\r\nrelevant elements ; we can iterate over the left boundary and add for\r\nall right boundaries where .To perform such additions in , we will use\r\nsomething like a difference array: we will create an array , where for a\r\nfixed left boundary, we will store how the suffix of right boundaries\r\nwill change. When iterating over the left boundary , for the suffix of\r\nright boundaries , we need to add the same amount ; but we will handle\r\nthis addition on the suffix in one position of the array .Then, to\r\naccount for these additions in the third type of queries , we will need\r\nto take the sum of the elements of the array .The third term from the\r\nsum is processed similarly: we will iterate over the right boundary and\r\nform an array , where the additions will be on the prefix.Thus, each\r\nmodification query will be executed in . A query of the third type\r\nrequires us to iterate over one of the fixed boundaries and find the\r\nsum, which will require operations. By choosing , each of these queries\r\ncan be executed in .Returning to the original problem, letâs describe\r\nhow to find the answer to a query whose boundaries do not coincide with\r\nthe boundaries of the blocks: First, find the answer for the problem we\r\nlearned to solve above for the largest segment of blocks that is\r\ncompletely contained within the query; Now, we need to add the\r\ncontribution of elements from the blocks that are not fully included in\r\nthe query. Each of these elements can form a pair with all elements in\r\nour block segment, so we will need to take the number of occurrences of\r\nthis element from the array. Additionally, these elements can form pairs\r\nwith each other; to handle this, we can maintain an array of size ,\r\nwhere for each value, we keep track of the number of additional elements\r\nwith that value. When processing some additional element , we will add\r\nthe count of these elements from the array to the answer and increase\r\nthis count by ; at the end of processing the query for all additional\r\nelements, we will reset their count back to .Thus, we have obtained a\r\nsolution in .\r\n",
    "name": "G. Problem with Queries",
    "statement": "You are given an array a, consisting of n integers. Your task is to\r\nprocess q queries of two types: 1 p x set the value of the element at\r\nindex p equal to x; 2 l r count the number of pairs of indices (i, j)\r\nsuch that l\r\nle i < j\r\nle r and a_i\r\nne a_j. Note that the queries in this task are ; each subsequent query\r\ncan only be decoded after calculating the answer to the preceding query\r\nof the second type.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ALL(x) begin(x), end(x)using namespace std;void file() {  freopen(\"1.in\", \"r\", stdin);  freopen(\"1.out\", \"w\", stdout);}using ll = long long; const int kN = 1e5 + 5;const int kB = 350, kC = kN / kB + 5;int n, q;array<int, kN> a, buc, bel;array<array<int, kC>, kN> cnt; struct BIT {  array<ll, kC> tr;  BIT() { tr.fill(0); }  void Update(int x, ll v) {    for(; x < kC; x += (x & -x)) tr[x] += v;  }  ll Query(int x) {    ll ans = 0;    for(; x; x -= (x & -x)) ans += tr[x];    return ans;  }};array<BIT, kC> val; void Build() {  for(int b = 1, l = 1, r = kB; l <= n; b++, l += kB, r += kB) {    r = min(r, n);    ll sum = 0;    for(int i = l; i <= r; i++) sum += buc[a[i]]++;    val[b].Update(b, sum);    for(int bb = b + 1, p = l + kB, q = r + kB; p <= n; bb++, p += kB, q += kB) {      q = min(q, n), sum = 0;      for(int i = p; i <= q; i++) sum += buc[a[i]];      val[b].Update(bb, sum);    }    buc.fill(0);  }  for(int b = 1, l = 1, r = kB; l <= n; b++, l += kB, r += kB) {    r = min(r, n);    for(int i = l; i <= r; i++) buc[a[i]]++;    for(int i = 1; i <= n; i++) cnt[i][b] = buc[i];  }  buc.fill(0);} void Modify(int x, int v, int coef) {  int b = bel[x];  for(int i = b; i <= bel[n]; i++) cnt[v][i] += coef;  for(int i = b + 1; i <= bel[n]; i++) {    val[b].Update(i, coef * (cnt[v][i] - cnt[v][i - 1]));  }  for(int i = 1; i < b; i++) {    val[i].Update(b, coef * (cnt[v][i] - cnt[v][i - 1]));  }} void Rebuild(int b) {  val[b].Update(b, -val[b].Query(b));  int l = (b - 1) * kB + 1, r = min(b * kB, n);  ll sum = 0;  for(int i = l; i <= r; i++) sum += buc[a[i]]++;  val[b].Update(b, sum);  for(int i = l; i <= r; i++) buc[a[i]]--;} void Update(int x, int nw) {  Modify(x, a[x], -1), Modify(x, a[x] = nw, 1);  Rebuild(bel[x]);} ll Brute(int l, int r) {  ll ans = 0;  for(int i = l; i <= r; i++) ans += buc[a[i]]++;  for(int i = l; i <= r; i++) buc[a[i]]--;  return ans;} int Get(int b, int x) {  int c = 0;  for(int i = 1; i <= min(n, b * kB); i++) {    c += (a[i] == x);  }  return c;} ll Query(int l, int r) {  int bl = bel[l], br = bel[r];  if(bl == br) return Brute(l, r);  ll ans = 0;  for(int i = bl + 1; i < br; i++) ans += val[i].Query(br - 1);  for(int i = l; i <= bl * kB; i++) {    ans += buc[a[i]]++ + (cnt[a[i]][br - 1] - cnt[a[i]][bl]);  }  for(int i = (br - 1) * kB + 1; i <= r; i++) {    ans += buc[a[i]]++ + (cnt[a[i]][br - 1] - cnt[a[i]][bl]);  }  for(int i = l; i <= bl * kB; i++) buc[a[i]]--;  for(int i = (br - 1) * kB + 1; i <= r; i++) buc[a[i]]--;  return ans;} int main() {  // file();  ios::sync_with_stdio(0), cin.tie(0);  cin >> n;  for(int i = 1; i <= n; i++) cin >> a[i];  for(int i = 1; i <= n; i++) bel[i] = (i - 1) / kB + 1;  Build();  cin >> q;  for(ll lst = 0, op, x, y; q--; ) {    cin >> op >> x >> y;    x = (x + lst) % n + 1, y = (y + lst) % n + 1;    if((op == 2) && (x > y)) swap(x, y);    if(op == 1) Update(x, y);    else {      ll ans = Query(x, y), len = y - x + 1;      cout << (lst = len * (len - 1) / 2 - ans) << \" \";    }  }  cout << \"\\n\";  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Problem with Queries.json",
    "hint": []
}