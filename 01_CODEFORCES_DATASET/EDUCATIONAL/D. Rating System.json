{
    "link": "https://codeforces.com//contest/1845/problem/D",
    "problemId": "1986291",
    "problem_idx": "D",
    "shortId": "1845D",
    "contest_number": "1845",
    "problem_submissions": {
        "F": [
            211475859,
            211492939,
            211497555,
            211490825,
            211491595,
            211499186,
            211501170,
            211510297,
            211505215,
            211508507,
            211523706,
            211508142,
            211526813,
            211526845,
            211523227,
            211522513,
            211521610,
            211527973
        ],
        "E": [
            211462563,
            211461492,
            211471272,
            211472249,
            211480189,
            211485085,
            211477384,
            211480631,
            211479180,
            211479798,
            211487222,
            211476273,
            211646872,
            211490174,
            211488484,
            211525957,
            211524499,
            211523817,
            211482860,
            211491352,
            211488220,
            211483247,
            211483585,
            211488962,
            211482756,
            211497978
        ],
        "B": [
            211453598,
            211442082,
            211444910,
            211443511,
            211441772,
            211442686,
            211445493,
            211443115,
            211444001,
            211449977,
            211446525,
            211444666,
            211443749,
            211447761,
            211449897,
            211443106,
            211444760,
            211445575,
            211449630,
            211442921
        ],
        "D": [
            211450415,
            211448543,
            211458729,
            211462418,
            211460113,
            211454656,
            211463763,
            211469130,
            211470306,
            211471906,
            211459492,
            211645284,
            211472007,
            211475281,
            211467877,
            211468462,
            211468425,
            211461450,
            211463088,
            211470068,
            211462856
        ],
        "C": [
            211443935,
            211445016,
            211453965,
            211452711,
            211452512,
            211450213,
            211454682,
            211448771,
            211452473,
            211462596,
            211453195,
            211455269,
            211452431,
            211458111,
            211462223,
            211458912,
            211452900,
            211451834,
            211462935,
            211452522
        ],
        "A": [
            211441020,
            211441082,
            211441390,
            211441217,
            211441011,
            211441288,
            211441347,
            211441228,
            211442540,
            211441983,
            211441400,
            211441604,
            211441498,
            211442268,
            211443714,
            211441364,
            211441612,
            211441912,
            211442694,
            211441281
        ]
    },
    "name": "D. Rating System",
    "statement": "You are developing a rating system for an online game. Every time a\r\nplayer participates in a match, the player’s rating changes depending on\r\nthe results.Initially, the player’s rating is 0. There are n matches;\r\nafter the i-th match, the rating change is equal to a_i (the rating\r\nincreases by a_i if a_i is positive, or decreases by |a_i| if it’s\r\nnegative. There are no zeros in the sequence a).The system has an\r\nadditional rule: for a fixed integer k, if a player’s rating has reached\r\nthe value k, it will never fall below it. Formally, if a player’s rating\r\nat least k, and a rating change would make it less than k, then the\r\nrating will decrease .Your task is to determine the value k in such a\r\nway that the player’s rating after all n matches is the maximum possible\r\n(among all integer values of k). If there are multiple possible answers,\r\nyou can print any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int t;cin>>t;\n    while(t--)\n    {\n        int n;cin>>n;int a[n];\n        for(int i=0;i<n;++i) cin>>a[i];\n        int pr[n+1]={0};\n        for(int i=0;i<n;++i) pr[i+1]=pr[i]+a[i];\n        int ma[n+1]={0};\n        ma[n]=0;for(int i=n-1;i>=0;--i) {ma[i]=max(ma[i+1],pr[n]-pr[i]);}\n        int res=0;int k=0;\n        for(int i=0;i<n;++i)\n        {\n            int ans=pr[i]+ma[i];\n            if(ans>res)\n            {\n                res=ans;k=pr[i];\n            }\n        }\n        cout<<k<<'\\n';\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "dsu",
        "greedy",
        "math",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Rating System.json",
    "editorial_link": "https://codeforces.com//blog/entry/117791",
    "editorial": "Letâs fix some and look at the first and the last moment when the rating\r\nshould fall below , but doesnât. After such moments, the rating is equal\r\nto . So we can \"delete\" all changes (array elements) between those\r\nmoments. And the remaining changes (to the left from the first moment\r\nand to the right from the last moment) can be considered without any\r\nadditional constraints (the value of doesnât affect those changes).Using\r\nthis fact, we can see that the total rating is not greater than the sum\r\nof the whole array minus some continuous segment. So the maximum\r\npossible final rating doesnât exceed the sum of the array minus the\r\nminimum sum segment (this segment can be empty, if all elements are\r\npositive). In fact, there is always such that provides such rating. Let\r\nthe minimum sum segment be , then is equal to the prefix sum from -st to\r\n-th positions of the array. The only remaining question is: why the\r\nrating after -th match is equal to ? It canât fall below (since the\r\nrating is at least already); and if it is greater than , then there is a\r\npositive suffix of the segment , so we can remove it, and the sum of the\r\nsegment would decrease. Which means the segment is not minimum sum\r\nsegment, which contradicts the previous statement. So the rating after\r\n-th match is equal to .\r\n",
    "hint": []
}