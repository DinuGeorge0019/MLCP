{
    "link": "https://codeforces.com//contest/2042/problem/C",
    "problemId": "3063461",
    "problem_idx": "C",
    "shortId": "2042C",
    "contest_number": "2042",
    "problem_submissions": {
        "E": [
            294423774,
            294419934,
            294425145,
            294427314,
            294461391,
            294454616,
            294469820,
            294456785,
            294473828,
            294432050,
            294452832,
            294430074,
            294720157,
            294431481,
            294468510,
            294470387,
            294430159
        ],
        "F": [
            294412520,
            294425551,
            294432280,
            294452436,
            294434993,
            294433145,
            294446063,
            294428799,
            294413717,
            294412873,
            294411042,
            294425120,
            294428614,
            294424117,
            294468671,
            294445770,
            294425722,
            294433551,
            294468661,
            294431992,
            294436625
        ],
        "D": [
            294403997,
            294407353,
            294409781,
            294414370,
            294407554,
            294410319,
            294417815,
            294419253,
            294437550,
            294410412,
            294413967,
            294418349,
            294411907,
            294402733,
            294411823,
            294409744,
            294417262,
            294417181,
            294415900
        ],
        "C": [
            294397589,
            294400380,
            294403833,
            294401565,
            294414063,
            294405958,
            294407677,
            294415266,
            294453518,
            294402202,
            294397037,
            294403746,
            294403563,
            294397148,
            294404737,
            294399098,
            294402722,
            294400450,
            294396822
        ],
        "B": [
            294394491,
            294397696,
            294398701,
            294393052,
            294393883,
            294395178,
            294398939,
            294412364,
            294455866,
            294393748,
            294393435,
            294395970,
            294392768,
            294392321,
            294399650,
            294391444,
            294395529,
            294395407,
            294392933
        ],
        "A": [
            294390734,
            294395467,
            294390153,
            294389939,
            294390115,
            294390408,
            294402923,
            294412466,
            294454482,
            294389870,
            294390174,
            294391619,
            294390031,
            294390265,
            294390266,
            294389845,
            294389856,
            294390624,
            294389907
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136886",
    "editorial": "Firstly, if several segments are equal, then the answer for all of them\r\nis zero. Now let\u00e2\u0080\u0099s move to the problem where all segments are\r\ndistinct.User is a predictor for user iff . Also, a track is strongly\r\nrecommended if it is in all predictor segments, i. e. the track belongs\r\nto the intersection of all predictors. Since the segment also belongs to\r\n, then the tracks we need to find form two intervals and .Let\u00e2\u0080\u0099s focus on\r\nfinding interval . Since the right border of the intersection is the\r\nminimum among right borders, then our task is to find the minimum among\r\n-s such that while .Let\u00e2\u0080\u0099s do it in the following way: let\u00e2\u0080\u0099s sort all\r\nsegments by in increasing order; in case of equal -s, sort them by in\r\norder. If we process segments in the given order, then by the moment we\r\nprocess the -th segment, all its predictors will be already\r\nprocessed.Let\u00e2\u0080\u0099s keep -s of all processed segments so far in an \"ordered\r\nset\" (, for example). Suppose we process segment . Since the right\r\nborders of all predictors are already in and their , then finding the\r\nminimum among them is equivalent to just taking . Then we can add to the\r\nanswer for the -th segment.In order to calculate intervals we can just\r\nreflect all segments and solve the same problem.The complexity of the\r\nsolution is .\r\n",
    "name": "C. Competitive Fishing",
    "statement": "Alice and Bob participate in a fishing contest! In total, they caught n\r\nfishes, numbered from 1 to n (the bigger the fish, the greater its\r\nindex). Some of these fishes were caught by Alice, others by Bob.Their\r\nperformance will be evaluated as follows. First, an integer m will be\r\nchosen, and all fish will be split into m groups. The first group should\r\ncontain several (at least one) smallest fishes, the second group several\r\n(at least one) next smallest fishes, and so on. Each fish should belong\r\nto exactly one group, and each group should be a contiguous subsegment\r\nof fishes. Note that the groups are numbered in exactly that order; for\r\nexample, the fishes from the second group cannot be smaller than the\r\nfishes from the first group, since the first group contains the smallest\r\nfishes.Then, each fish will be assigned a value according to its group\r\nindex: each fish in the first group gets value equal to 0, each fish in\r\nthe second group gets value equal to 1, and so on. So, each fish in the\r\ni-th group gets value equal to (i-1).The score of each contestant is\r\nsimply the total value of all fishes that contestant caught.You want\r\nBob\u2019s score to exceed Alice\u2019s score by k points. What is the minimum\r\nnumber of groups (m) you have to split the fishes into? If it is\r\nimpossible, you should report that.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"using namespace std;#define all(x) x.begin(),x.end()template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << \" \" << p.second; }template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { string sep; for (const T &x : v) os << sep << x, sep = \" \"; return os; }#ifdef LOCAL#include \"debug.h\"#else#define debug(...) 42#define ASSERT(...) 42#endiftypedef long long ll;typedef vector<int> vi;typedef vector<vi> vvi;typedef pair<int,int> pi;const int oo = 1e9;\u00a0void solve() {    int n,k; cin >> n >> k;    string s; cin >> s;    vi gain;    int bal=0;    for(int i=n-1;i>0;--i) {        bal+=s[i]=='1'?1:-1;        if(bal>0) gain.push_back(bal);    }    int off=0;    sort(all(gain));    int ans=0;    while(!gain.empty() and off<k) {        ans++;        off+=gain.back();        gain.pop_back();    }    if(off<k) cout << \"-1\\n\";    else cout << ans+1 << '\\n';}\u00a0int main() {    ios_base::sync_with_stdio(false);    cin.tie(NULL);    int t; cin >> t;    while(t--) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Competitive Fishing.json"
}