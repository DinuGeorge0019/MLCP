{
    "link": "https://codeforces.com//contest/845/problem/D",
    "problemId": "119174",
    "problem_idx": "D",
    "shortId": "845D",
    "contest_number": "845",
    "problem_submissions": {
        "F": [
            29662191,
            29658691,
            29662577,
            29662557,
            29659271,
            29663949,
            29653306,
            29665823,
            29656869,
            29668298
        ],
        "E": [
            29659390,
            29664188,
            29664063,
            29663215,
            29663046,
            29661461,
            29660552,
            29653793,
            29658574,
            29655087,
            29668158,
            29670073,
            29664054,
            35903704,
            29673169,
            29656703
        ],
        "G": [
            29653058,
            29648925,
            29654997,
            29656636,
            29656923,
            29653301,
            29656155,
            29657485,
            29658552,
            29655006,
            29655066,
            29653896,
            29654510,
            29655977,
            29654363,
            29657005,
            29659307
        ],
        "D": [
            29651798,
            29653616,
            29652569,
            29653638,
            29650642,
            29655985,
            29652243,
            29654023,
            29657108,
            29650588,
            29651844,
            29650739,
            29653419,
            29656251,
            29652823,
            29652595,
            29655002,
            29652809,
            29650646
        ],
        "C": [
            29648829,
            29651383,
            29648358,
            29648061,
            29648669,
            29648794,
            29648303,
            29648671,
            29648937,
            29648455,
            29648984,
            29648127,
            29648921,
            29649045,
            29649074,
            29650613,
            29649296,
            29649747,
            29649146
        ],
        "B": [
            29648130,
            29650436,
            29648956,
            29647280,
            29647747,
            29647255,
            29647572,
            29647971,
            29647530,
            29648013,
            29647504,
            29647868,
            29647800,
            29648160,
            29648934,
            29648366,
            29648191,
            29646728
        ],
        "A": [
            29647342,
            29649692,
            29646643,
            29646523,
            29646782,
            29646497,
            29646493,
            29646476,
            29646501,
            29647201,
            29646463,
            29646669,
            29646500,
            29646893,
            29647910,
            29647098,
            29646857,
            29647624
        ]
    },
    "name": "D. Driving Test",
    "statement": "Polycarp has just attempted to pass the driving test. He ran over the\r\nstraight road with the signs of four types. speed limit: this sign comes\r\nwith a positive integer number maximal speed of the car after the sign\r\n(cancel the action of the previous sign of this type); overtake is\r\nallowed: this sign means that after some car meets it, it can overtake\r\nany other car; no speed limit: this sign cancels speed limit if any (car\r\ncan move with arbitrary speed after this sign); no overtake allowed:\r\nsome car can\u2019t overtake any other car after this sign. Polycarp goes\r\npast the signs consequentially, each new sign cancels the action of all\r\nthe previous signs of it\u2019s kind (speed limit/overtake). It is possible\r\nthat two or more \"no overtake allowed\" signs go one after another with\r\nzero \"overtake is allowed\" signs between them. It works with \"no speed\r\nlimit\" and \"overtake is allowed\" signs as well.In the beginning of the\r\nride overtake is allowed and there is no speed limit.You are given the\r\nsequence of events in chronological order events which happened to\r\nPolycarp during the ride. There are events of following types: Polycarp\r\nchanges the speed of his car to specified (this event comes with a\r\npositive integer number); Polycarp\u2019s car overtakes the other car;\r\nPolycarp\u2019s car goes past the \"speed limit\" sign (this sign comes with a\r\npositive integer); Polycarp\u2019s car goes past the \"overtake is allowed\"\r\nsign; Polycarp\u2019s car goes past the \"no speed limit\"; Polycarp\u2019s car goes\r\npast the \"no overtake allowed\"; It is guaranteed that the first event in\r\nchronological order is the event of type (Polycarp changed the speed of\r\nhis car to specified).After the exam Polycarp can justify his rule\r\nviolations by telling the driving instructor that he just didn\u2019t notice\r\nsome of the signs. What is the minimal number of signs Polycarp should\r\nsay he didn\u2019t notice, so that he would make no rule violations from his\r\npoint of view?\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<set>\nusing namespace std;\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    int now=0,ovt=0,cnt=0;\n    vector<int> spd;\n    for(int i=1;i<=n;i++)\n    {\n        int t,s;\n        scanf(\"%d\",&t);\n        if(t==1)\n        {\n            scanf(\"%d\",&s);\n            now=s;\n            while(!spd.empty() && now>spd.back())\n                spd.pop_back(),cnt++;\n        }\n        if(t==2)cnt+=ovt,ovt=0;\n        if(t==3)\n        {\n            scanf(\"%d\",&s);\n            spd.push_back(s);\n            while(!spd.empty() && now>spd.back())\n                spd.pop_back(),cnt++;\n        }\n        if(t==4)ovt=0;\n        if(t==5)spd.clear();\n        if(t==6)ovt++;\n    }\n    return 0*printf(\"%d\\n\",cnt);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Driving Test.json",
    "editorial_link": "https://codeforces.com//blog/entry/53986",
    "editorial": "Let\u00e2\u0080\u0099s notice that you should never say that you didn\u00e2\u0080\u0099t notice signs \"no\r\nspeed limit\" and \"overtake is allowed\". Also if you drive with speed ,\r\nyou don\u00e2\u0080\u0099t want to remove signs \"speed limit\" with number greater or\r\nequal to .Thus, greedy solution will work. Process all the events in\r\nchronological order. We should maintain stack of signs \"speed limit\" and\r\namount of signs \"no overtake allowed\". If we meet sign \"speed limit\", we\r\npush its limit to stack, sign \"no overtake allowed\" increase , \"no speed\r\nlimit\" clear stack, \"overtake is allowed\" assign to zero. After every\r\nevent we should check if our speed is fine. While value of sign on the\r\ntop of the stack is less than current speed, pop it and increase answer.\r\nIf we overtake someone, we add to answer and assign to zero.Overall\r\ncomplexity: .\r\n"
}