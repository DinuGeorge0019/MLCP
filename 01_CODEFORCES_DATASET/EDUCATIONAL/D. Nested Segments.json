{
    "link": "https://codeforces.com//contest/652/problem/D",
    "problemId": "52871",
    "problem_idx": "D",
    "shortId": "652D",
    "contest_number": "652",
    "problem_submissions": {
        "F": [
            16928285,
            16930373,
            16931256,
            16970841,
            16961705,
            16935106,
            156953099,
            16939325,
            17157478,
            16976822,
            16929598
        ],
        "E": [
            16926440,
            16927126,
            16928485,
            16928041,
            16928079,
            16927963,
            16929010,
            16928885,
            16928945,
            16929000,
            16929278,
            16926493,
            16928821,
            16929439,
            16928127,
            16930840,
            16929731,
            16930544,
            16929622
        ],
        "D": [
            16923853,
            16925192,
            16926960,
            16924196,
            16924625,
            16925554,
            16925730,
            16924207,
            16926093,
            16926313,
            16925298,
            16926004,
            16926568,
            16924529,
            16926045,
            16925170,
            16925998,
            16927190,
            16926470
        ],
        "C": [
            16923132,
            16923717,
            16926036,
            16923304,
            16924095,
            16924304,
            16924230,
            16925378,
            16924383,
            16924805,
            16924428,
            16924018,
            16924971,
            16925484,
            16923795,
            16923653,
            16924997,
            16925262,
            16925278
        ],
        "B": [
            16922478,
            16922741,
            16925620,
            16922710,
            16922792,
            16922869,
            16923264,
            16922610,
            16922818,
            16923450,
            16923095,
            16923418,
            16923515,
            16923547,
            16922822,
            16922672,
            16922783,
            16923327,
            16924223
        ],
        "A": [
            16922372,
            16922446,
            16922797,
            16922454,
            16922532,
            16922643,
            16922693,
            16922430,
            16922460,
            16923027,
            16922810,
            16922924,
            16922740,
            16923101,
            16922457,
            16922433,
            16923996,
            16922614,
            16923536
        ]
    },
    "name": "D. Nested Segments",
    "statement": "You are given segments on a line. There are no ends of some segments\r\nthat coincide. For each segment find the number of segments it contains.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nstruct sg{\n  in l,r,id;\n  sg(in a=0, in b=0, in c=0){\n    l=a;\n    r=b;\n    id=c;\n  }\n  bool operator<(const sg cp)const{\n    if(l==cp.l)\n      assert(id==cp.id);\n    return l<cp.l;\n  }\n};\nstruct fenw{\n  VI fw;\n  in n;\n  void ini(in pn){\n    n=pn;\n    fw.clear();\n    fw.resize(n,0);\n  }\n  void ad(in l, in x){\n    while(l<n){\n      fw[l]+=x;\n      l|=(l+1);\n    }\n  }\n  in sm(in l){\n    in r=0;\n    while(l>=0){\n      r+=fw[l];\n      l&=(l+1);\n      --l;\n    }\n    return r;\n  }\n};\nfenw mtr;\nvector<sg> sgs;\nVI vls;\nmap<in,in> dcd;\nVI res;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n;\n  cin>>n;\n  sgs.resize(n);\n  forn(i,n){\n    cin>>sgs[i].l>>sgs[i].r;\n    vls.PB(sgs[i].l);\n    vls.PB(sgs[i].r);\n    sgs[i].id=i;\n  }\n  sort(all(vls));\n  forv(i,vls)\n    dcd[vls[i]]=i;\n  forv(i,sgs){\n    sgs[i].l=dcd[sgs[i].l];\n    sgs[i].r=dcd[sgs[i].r];\n  }\n  sort(all(sgs));\n  mtr.ini(sz(dcd)+3);\n  res.resize(n);\n  for(in i=sz(sgs)-1;i>=0;--i){\n    res[sgs[i].id]=mtr.sm(sgs[i].r);\n    mtr.ad(sgs[i].r,1);\n  }\n  forv(i,res)\n    cout<<res[i]<<\"\\n\";\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Nested Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/43986",
    "editorial": "The problem was suggested by Alexey Dergunov dalex. This problem is a\r\nstandard two-dimensional problem that can be solved with one-dimensional\r\ndata structure. In the same way a lot of other problems can be solved\r\n(for example the of finding the maximal weighted chain of points so that\r\nboth coordinates of each point are greater than the coordinates of the\r\npredecessing point). Rewrite the problem formally: for each we should\r\ncount the number of indices so that the following conditions are hold:\r\nand . Let\u00e2\u0080\u0099s sort all segments by the left ends from right to left and\r\nmaintain some data structure (Fenwick tree will be the best choice) with\r\nthe right ends of the processed segments. To calculate the answer for\r\nthe current segment we should simple take the prefix sum for the right\r\nend of the current segment. So the condition is hold by sorting and\r\niterating over the segments from the right to the left (the first\r\ndimension of the problem). The condition is hold by taking the prefix\r\nsum in data structure (the second dimension). C++ solution\r\n"
}