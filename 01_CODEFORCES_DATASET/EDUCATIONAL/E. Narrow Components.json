{
    "link": "https://codeforces.com//contest/1661/problem/E",
    "problemId": "1361831",
    "problem_idx": "E",
    "shortId": "1661E",
    "contest_number": "1661",
    "problem_submissions": {
        "F": [
            153187553,
            153195355,
            153198079,
            153192699,
            153208735,
            153197140,
            153204834,
            153209679,
            153216895,
            153192345,
            153209985,
            153215287,
            153214260,
            153206784,
            153181924,
            153187391,
            153499691
        ],
        "E": [
            153181602,
            153183458,
            153186252,
            153186023,
            153206034,
            153195940,
            153194023,
            153206147,
            153218775,
            153197839,
            153195670,
            153202578,
            153201319,
            153198707,
            153201518,
            153192938,
            153189205,
            153195957,
            153196511
        ],
        "D": [
            153174390,
            153174537,
            153175638,
            153174007,
            153176690,
            153176745,
            153185907,
            153182627,
            153178744,
            153172686,
            153190154,
            153190396,
            153190106,
            153210872,
            153207891,
            153175462,
            153176825,
            153177570,
            153175676
        ],
        "C": [
            153170138,
            153167530,
            153168248,
            153169048,
            153170259,
            153170541,
            153168119,
            153170774,
            153172726,
            153194437,
            153178130,
            153175287,
            153185061,
            153205419,
            153246548,
            153215381,
            153166182,
            153169099,
            153168642,
            153167758
        ],
        "B": [
            153162156,
            153162580,
            153161952,
            153162200,
            153164678,
            153162918,
            153163800,
            153162935,
            153167883,
            153164440,
            153162927,
            153168126,
            153181318,
            153200885,
            153216655,
            153161628,
            153165270,
            153163647,
            153161926
        ],
        "A": [
            153160994,
            153160951,
            153163491,
            153160922,
            153160942,
            153161262,
            153161508,
            153160985,
            153162410,
            153161094,
            153160862,
            153162511,
            153178823,
            153198439,
            153217630,
            153160910,
            153162727,
            153160959,
            153160858
        ]
    },
    "name": "E. Narrow Components",
    "statement": "You are given a matrix a, consisting of 3 rows and n columns. Each cell\r\nof the matrix is either free or taken.A free cell y is reachable from a\r\nfree cell x if at least one of these conditions hold: x and y share a\r\nside; there exists a free cell z such that z is reachable from x and y\r\nis reachable from z. A connected component is a set of free cells of the\r\nmatrix such that all cells in it are reachable from one another, but\r\nadding any other free cell to the set violates this rule.You are asked q\r\nqueries about the matrix. Each query is the following: l r count the\r\nnumber of connected components of the matrix, consisting of columns from\r\nl to r of the matrix a, inclusive. Print the answers to all queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n;\n  cin >> n;\n  vector<string> a(3);\n  for (int i = 0; i < 3; i++){\n    cin >> a[i];\n  }\n  vector<int> c1(n + 1, 0);\n  for (int i = 0; i < n; i++){\n    c1[i + 1] = c1[i];\n    for (int j = 0; j < 3; j++){\n      if (a[j][i] == '1'){\n        c1[i + 1]++;\n        if (j > 0){\n          if (a[j - 1][i] == '1'){\n            c1[i + 1]--;\n          }\n        }\n      }\n    }\n  }\n  vector<int> c2(n, 0);\n  for (int i = 0; i < n - 1; i++){\n    c2[i + 1] = c2[i];\n    for (int j = 0; j < 3; j++){\n      if (a[j][i] == '1' && a[j][i + 1] == '1'){\n        c2[i + 1]++;\n        if (j > 0){\n          if (a[j - 1][i] == '1' && a[j - 1][i + 1] == '1'){\n            c2[i + 1]--;\n          }\n        }\n      }\n    }\n  }\n  vector<int> p;\n  for (int i = 0; i < n; i++){\n    if (a[0][i] == '1' && a[1][i] == '1' && a[2][i] == '1'){\n      p.push_back(i);\n    }\n  }\n  int cnt = p.size();\n  vector<int> L, R;\n  for (int i = 0; i < cnt - 1; i++){\n    if (p[i + 1] - p[i] >= 2){\n      bool ok = true;\n      for (int j = p[i] + 1; j < p[i + 1]; j++){\n        if (!(a[0][j] == '1' && a[1][j] == '0' && a[2][j] == '1')){\n          ok = false;\n        }\n      }\n      if (ok){\n        L.push_back(p[i]);\n        R.push_back(p[i + 1]);\n      }\n    }\n  }\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++){\n    int l, r;\n    cin >> l >> r;\n    l--;\n    int ans1 = c1[r] - c1[l];\n    int ans2 = c2[r - 1] - c2[l];\n    int p1 = lower_bound(L.begin(), L.end(), l) - L.begin();\n    int p2 = lower_bound(R.begin(), R.end(), r) - R.begin();\n    int ans3 = max(p2 - p1, 0);\n    cout << ans1 - ans2 + ans3 << \"\\n\";\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "dsu",
        "math",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Narrow Components.json",
    "editorial_link": "https://codeforces.com//blog/entry/101790",
    "editorial": "Consider the naive approach to the problem.Cut off the columns directly\r\nand count the connected components. There are two main solutions to this\r\nproblem: either DFS (or BFS) or DSU. I personally found the DSU method\r\neasier to adjust to the full problem.So, to count connected components\r\nwith DSU, you should do the following. Initialize the structure without\r\nedges: every free cell is its own connected component. Then add edges\r\none by one. Each edge connects two cells either vertically or\r\nhorizontally. When an edge connects different components, they merge,\r\nand the number of components decreases by one.Thus, the number of\r\ncomponents on a range of columns is the number of free cells on it minus\r\nthe number of meaningful edges on it (the ones that will merge\r\ncomponents if the algorithm is performed only on these columns the\r\nspanning forest edges).Let\u00e2\u0080\u0099s try to adjust this algorithm to the full\r\nproblem. It would be great if we could just calculate the spanning\r\nforest of the entire matrix, and then print the number of free cells\r\nminus the number of its edges on the segment. Unfortunately, it\u00e2\u0080\u0099s not as\r\neasy as that. For components that lie fully in the segment, it works.\r\nHowever, if a component is split by a border of a segment, it can both\r\nstay connected or fall apart. If we determine its outcome, we can fix\r\nthe answer.There are probably a lot of ways to adjust for that, but I\u00e2\u0080\u0099ll\r\ntell you the one I found the neatest to code. Let\u00e2\u0080\u0099s add the edges into\r\nDSU in the following order. Go column by column left to right. First add\r\nall vertical edges in any order, then all horizontal edges to the\r\nprevious column in any order.If you start this algorithm at the first\r\ncolumn, you will be able to answer all queries with . Since the\r\nalgorithm adds columns iteratively, the spanning forest it\u00e2\u0080\u0099s building is\r\ncorrect after every column. So the answer for each query is indeed the\r\nnumber of cells minus the number of edges on the range.Let\u00e2\u0080\u0099s investigate\r\nthe difference between starting at the first column and an arbitrary\r\ncolumn .Look at the column . If it contains or free cells or that are\r\nadjacent, then the cells are always in the same component, regardless of\r\nwhat has been before column . If there are no free cells, nothing to the\r\nleft matters, too. This tells us that the spanning forest that the first\r\nalgorithm has built, is correct for any queries that start in this .The\r\nonly non-trivial case is when only rows and of the -th column contain a\r\nfree cell. Then we can\u00e2\u0080\u0099t tell if the algorithm is correct or not,\r\nbecause these two cells can be in the same component already or not.\r\nLet\u00e2\u0080\u0099s call this a \"\" column.Imagine you started processing from the\r\nleftmost column of the query, left to right to the rightmost column. Our\r\nprevious observations tell us that once we encounter a column that is\r\nnot a \"\", the algorithm onwards will be correct. Until then, we only\r\nhave some \"\" columns to deal with.We can add the part from the first\r\nnon-\"\" column onwards to the answer (the number of cells minus the\r\nnumber of edges). And then handle the prefix with some easy casework: if\r\nthe leftmost column is not \"\", then add nothing; if all columns in the\r\nquery are \"\", then the answer is ; if the first non-\"\" column is \"\",\r\nthen add nothing (since the \"\"s get merged into the component of this\r\ncolumn); if the first non-\"\" column is \"\" or \"\", then add components\r\n(since neither row nor row is merged anywhere); otherwise, add\r\ncomponent. The number of free cells and edges on a segment can be\r\nprecalculated with some prefix sums. The closest non-\"\" column can also\r\nbe precalculated with a linear algorithm.Overall complexity: .\r\n"
}