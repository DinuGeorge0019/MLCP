{
    "link": "https://codeforces.com//contest/808/problem/D",
    "problemId": "106400",
    "problem_idx": "D",
    "shortId": "808D",
    "contest_number": "808",
    "problem_submissions": {
        "E": [
            27137197,
            27134808,
            27134054,
            27132549,
            27131870,
            27132812,
            27138350,
            27133736,
            27131963,
            27140761,
            27135118,
            27134983,
            27132973,
            27138881,
            27134671,
            27261177,
            27134231
        ],
        "G": [
            27135167,
            27130618,
            27132801,
            27169611,
            27134965,
            27137204,
            27160747,
            27136267,
            27135740,
            27136906,
            27138137,
            27159188,
            27140353,
            27136012,
            27136390,
            27133992,
            27143226,
            27141294
        ],
        "F": [
            27133833,
            27138112,
            27177906,
            27136765,
            27164228,
            27142537,
            27133888,
            27166317,
            27145346,
            27277981,
            27273337,
            27267183,
            27141042,
            27133326,
            27139365,
            27141028,
            27139853,
            27137233,
            27203781,
            27164790,
            27139352
        ],
        "D": [
            27128503,
            27127219,
            27129431,
            27127572,
            27126819,
            27126652,
            27126413,
            27131013,
            27128036,
            27144856,
            27149028,
            27130439,
            27159164,
            27158696,
            27130609,
            27129280,
            31052395,
            27170361,
            27127426,
            27204067
        ],
        "C": [
            27127241,
            27126114,
            27126407,
            27126117,
            27125155,
            27125545,
            27125616,
            27128374,
            27126308,
            27126044,
            27126773,
            27128917,
            27129043,
            27127777,
            27126008,
            27126821,
            27129336
        ],
        "B": [
            27125488,
            27124939,
            27125624,
            27125294,
            27125238,
            27124591,
            27125024,
            27127379,
            27125310,
            27124893,
            27125455,
            27127633,
            27127827,
            27131416,
            27125036,
            27126129,
            27163815,
            27127143
        ],
        "A": [
            27124684,
            27124405,
            27124596,
            27124469,
            27124323,
            27124317,
            27124491,
            27126511,
            27124424,
            27124395,
            27124442,
            27124926,
            27125033,
            27130660,
            27124528,
            27124407,
            27163707,
            27124848
        ]
    },
    "name": "D. Array Division",
    "statement": "Vasya has an array consisting of positive integer numbers. Vasya wants\r\nto divide this array into two non-empty consecutive parts (the prefix\r\nand the suffix) so that the sum of all elements in the first part equals\r\nto the sum of elements in the second part. It is not always possible, so\r\nVasya will move some element before dividing the array (Vasya will erase\r\nsome element and insert it into an arbitrary position).Can Vasya divide\r\nthe array after choosing the right element to move and its new position?\r\n",
    "solutions": [
        "#include<cstdio>\n#include<set>\ntypedef long long i64;\ni64 s[100007];\nint n,a[100007];\nstd::multiset<int>s1,s2;\nint main(){\n\tscanf(\"%d\",&n);\n\tif(n==1)return puts(\"NO\"),0;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",a+i);\n\t\ts[i]=a[i]+s[i-1];\n\t\ts2.insert(a[i]);\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\ti64 v=s[i]*2-s[n];\n\t\tif(!v)return puts(\"YES\"),0;\n\t\ts1.insert(a[i]);\n\t\ts2.erase(s2.find(a[i]));\n\t\tif(v>0&&v%2==0&&v<=2000000000&&s1.find(v/2)!=s1.end())return puts(\"YES\"),0;\n\t\tif(v<0&&v%2==0&&v>=-2000000000&&s2.find(-v/2)!=s2.end())return puts(\"YES\"),0;\n\t}\n\treturn puts(\"NO\"),0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Array Division.json",
    "editorial_link": "https://codeforces.com//blog/entry/52010",
    "editorial": "Suppose we want to move an element from the prefix to the suffix (if we\r\nneed to move an element from the suffix to the prefix, we can just\r\nreverse the array and do the same thing).Suppose the resulting prefix\r\nwill contain elements. Then we need to check that the prefix with\r\nelements contains an element such that the sum of this prefix without\r\nthis element is equal to the half of the sum of the whole array (and\r\nthen we can move this element to the suffix).To check all the prefixes,\r\nwe can scan the array from left to right while maintaining the set of\r\nelements on the prefix and the sum of these elements.\r\n"
}