{
    "link": "https://codeforces.com//contest/1923/problem/D",
    "problemId": "2492667",
    "problem_idx": "D",
    "shortId": "1923D",
    "contest_number": "1923",
    "problem_submissions": {
        "F": [
            247927445,
            247926735,
            247941699,
            247942342,
            247957925,
            247930359,
            247950515,
            247952641,
            247961910,
            247957616,
            247954803,
            247957462,
            247965318,
            247958101,
            247966724,
            247961269,
            247975649,
            247970780
        ],
        "E": [
            247910260,
            247907637,
            247944549,
            247918053,
            247922522,
            247916787,
            247955209,
            247923339,
            247906437,
            247924189,
            247923801,
            247924733,
            247919146,
            247919411,
            247915457,
            248010348,
            247930116,
            247913617,
            247921891,
            247928453
        ],
        "D": [
            247906663,
            247903362,
            247909256,
            247913572,
            247912411,
            247905740,
            247917150,
            247917832,
            247911096,
            247917233,
            247917212,
            247913338,
            247913589,
            247931525,
            247913875,
            247917151,
            247917274,
            247912599
        ],
        "C": [
            247899621,
            247896441,
            247899387,
            247904054,
            247903940,
            247899293,
            247903341,
            247912953,
            247900198,
            247901509,
            247906201,
            247902190,
            247904629,
            247901902,
            247905627,
            247901567,
            247905304,
            247903364
        ],
        "B": [
            247895420,
            247893401,
            247895016,
            247899339,
            247899002,
            247894634,
            247896319,
            247907358,
            247897312,
            247896352,
            247897008,
            247896401,
            247900980,
            247897119,
            247897848,
            247898814,
            247898339,
            247898930
        ],
        "A": [
            247893064,
            247892642,
            247892787,
            247894650,
            247893381,
            247892909,
            247892866,
            247905142,
            247893155,
            247893038,
            247892799,
            247892722,
            247896270,
            247892907,
            247893359,
            247893598,
            247893062,
            247896053
        ]
    },
    "name": "D. Slimes",
    "statement": "There are n slimes placed in a line. The slimes are numbered from 1 to n\r\nin order from left to right. The size of the i-th slime is a_i.Every\r\nsecond, the following happens: slime eats one of its neighbors and\r\nincreases its size by the eaten neighbor\u2019s size. A slime can eat its\r\nneighbor only if it is strictly bigger than this neighbor. If there is\r\nno slime which is strictly bigger than one of its neighbors, the process\r\nends.For example, suppose n = 5, a = [2, 2, 3, 1, 4]. The process can go\r\nas follows: first, the 3-rd slime eats the 2-nd slime. The size of the\r\n3-rd slime becomes 5, the 2-nd slime is eaten. then, the 3-rd slime eats\r\nthe 1-st slime (they are neighbors since the 2-nd slime is already\r\neaten). The size of the 3-rd slime becomes 7, the 1-st slime is eaten.\r\nthen, the 5-th slime eats the 4-th slime. The size of the 5-th slime\r\nbecomes 5, the 4-th slime is eaten. then, the 3-rd slime eats the 5-th\r\nslime (they are neighbors since the 4-th slime is already eaten). The\r\nsize of the 3-rd slime becomes 12, the 5-th slime is eaten. For each\r\nslime, calculate the minimum number of seconds it takes for this slime\r\nto be eaten by another slime (among all possible ways the process can\r\ngo), or report that it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    auto work = [&]() {\n        std::vector<i64> s(n + 1);\n        for (int i = 0; i < n; i++) {\n            s[i + 1] = s[i] + a[i];\n        }\n        \n        std::vector<int> ans(n, n + 1);\n        for (int i = 0, k = 1; i < n - 1; i++) {\n            while (k < n && a[i + 1] == a[k]) {\n                k++;\n            }\n            \n            int r = *std::ranges::partition_point(std::ranges::iota_view(i + 2, n + 1),\n                [&](int v) {\n                    return s[v] - s[i + 1] <= a[i];\n                });\n            r = std::max(r, k + 1);\n            if (r <= n) {\n                ans[i] = r - (i + 1);\n            }\n            if (a[i + 1] > a[i]) {\n                ans[i] = 1;\n            }\n        }\n        return ans;\n    };\n    \n    auto ans1 = work();\n    std::reverse(a.begin(), a.end());\n    auto ans2 = work();\n    for (int i = 0; i < n; i++) {\n        int res = std::min(ans1[i], ans2[n - 1 - i]);\n        if (res > n) {\n            res = -1;\n        }\n        std::cout << res << \" \\n\"[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Slimes.json",
    "editorial_link": "https://codeforces.com//blog/entry/126339",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem independently for each slime (denote it as\r\n).After any number of seconds, the size of each slime is equal to the\r\nsum of some subarray. In order to eat the -th slime, the \"eater\" should\r\nbe its neighbor. So the eater size is equal to the sum of subarray for\r\nsome or ] for some . It remains to understand which can be the answer.\r\nFirst of all, the sum of subarray should be strictly greater than . And\r\nalso, there should be a sequence of operations that can combine the\r\nselected segment of slimes into one slime. Such a sequence exists in two\r\ncases: the length of subarray is ; there are at least two distinct\r\nvalues in subarray. It is not difficult to prove that these are the only\r\nconditions. If the length is , then the subarray is already just only\r\none slime. If all the slimes have the same size, then none of the\r\nneighboring pairs can be combined, which means that it is impossible to\r\ncombine all slimes into one. If there are at least two distinct values,\r\nthere exist a pair of adjacent slimes of the form (maximum, not\r\nmaximum). After combining such a pair, the result is the only maximum of\r\nthe subarray, which means that it can eat all the other slimes in the\r\nsubarray.It remains to understand how to find such that satisfies the\r\naforementioned conditions and is as close to as possible (because the\r\nnumber of required operations is ) faster than iterating over all values\r\nof . We can notice that, if the subarray is good, then the subarray is\r\nalso good. This leads us to the fact that we can use binary search. It\r\nis enough to pre-calculate two arrays: an array of prefix sums that used\r\nto find the sum of the subarray and an array , where is the position of\r\nthe nearest element that different to to determine whether there are two\r\ndifferent elements.So we can find the answer for one slime in . And the\r\ntotal running time is .\r\n"
}