{"link": "https://codeforces.com//contest/1923/problem/D", "problemId": "2492667", "problem_idx": "D", "shortId": "1923D", "contest_number": "1923", "problem_submissions": {"F": [247927445, 247926735, 247941699, 247942342, 247957925, 247930359, 247950515, 247952641, 247961910, 247957616, 247954803, 247957462, 247965318, 247958101, 247966724, 247961269, 247975649, 247970780], "E": [247910260, 247907637, 247944549, 247918053, 247922522, 247916787, 247955209, 247923339, 247906437, 247924189, 247923801, 247924733, 247919146, 247919411, 247915457, 248010348, 247930116, 247913617, 247921891, 247928453], "D": [247906663, 247903362, 247909256, 247913572, 247912411, 247905740, 247917150, 247917832, 247911096, 247917233, 247917212, 247913338, 247913589, 247931525, 247913875, 247917151, 247917274, 247912599], "C": [247899621, 247896441, 247899387, 247904054, 247903940, 247899293, 247903341, 247912953, 247900198, 247901509, 247906201, 247902190, 247904629, 247901902, 247905627, 247901567, 247905304, 247903364], "B": [247895420, 247893401, 247895016, 247899339, 247899002, 247894634, 247896319, 247907358, 247897312, 247896352, 247897008, 247896401, 247900980, 247897119, 247897848, 247898814, 247898339, 247898930], "A": [247893064, 247892642, 247892787, 247894650, 247893381, 247892909, 247892866, 247905142, 247893155, 247893038, 247892799, 247892722, 247896270, 247892907, 247893359, 247893598, 247893062, 247896053]}, "name": "D. Slimes", "statement": "There are n slimes placed in a line. The slimes are numbered from 1 to n\r\nin order from left to right. The size of the i-th slime is a_i.Every\r\nsecond, the following happens: slime eats one of its neighbors and\r\nincreases its size by the eaten neighbor\u2019s size. A slime can eat its\r\nneighbor only if it is strictly bigger than this neighbor. If there is\r\nno slime which is strictly bigger than one of its neighbors, the process\r\nends.For example, suppose n = 5, a = [2, 2, 3, 1, 4]. The process can go\r\nas follows: first, the 3-rd slime eats the 2-nd slime. The size of the\r\n3-rd slime becomes 5, the 2-nd slime is eaten. then, the 3-rd slime eats\r\nthe 1-st slime (they are neighbors since the 2-nd slime is already\r\neaten). The size of the 3-rd slime becomes 7, the 1-st slime is eaten.\r\nthen, the 5-th slime eats the 4-th slime. The size of the 5-th slime\r\nbecomes 5, the 4-th slime is eaten. then, the 3-rd slime eats the 5-th\r\nslime (they are neighbors since the 4-th slime is already eaten). The\r\nsize of the 3-rd slime becomes 12, the 5-th slime is eaten. For each\r\nslime, calculate the minimum number of seconds it takes for this slime\r\nto be eaten by another slime (among all possible ways the process can\r\ngo), or report that it is impossible.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    auto work = [&]() {\n        std::vector<i64> s(n + 1);\n        for (int i = 0; i < n; i++) {\n            s[i + 1] = s[i] + a[i];\n        }\n        \n        std::vector<int> ans(n, n + 1);\n        for (int i = 0, k = 1; i < n - 1; i++) {\n            while (k < n && a[i + 1] == a[k]) {\n                k++;\n            }\n            \n            int r = *std::ranges::partition_point(std::ranges::iota_view(i + 2, n + 1),\n                [&](int v) {\n                    return s[v] - s[i + 1] <= a[i];\n                });\n            r = std::max(r, k + 1);\n            if (r <= n) {\n                ans[i] = r - (i + 1);\n            }\n            if (a[i + 1] > a[i]) {\n                ans[i] = 1;\n            }\n        }\n        return ans;\n    };\n    \n    auto ans1 = work();\n    std::reverse(a.begin(), a.end());\n    auto ans2 = work();\n    for (int i = 0; i < n; i++) {\n        int res = std::min(ans1[i], ans2[n - 1 - i]);\n        if (res > n) {\n            res = -1;\n        }\n        std::cout << res << \" \\n\"[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "constructive algorithms", "data structures", "greedy", "two pointers"], "dificulty": "1800", "interactive": false}