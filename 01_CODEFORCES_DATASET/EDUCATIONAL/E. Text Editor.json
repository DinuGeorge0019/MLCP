{
    "link": "https://codeforces.com//contest/1701/problem/E",
    "problemId": "1455053",
    "problem_idx": "E",
    "shortId": "1701E",
    "contest_number": "1701",
    "problem_submissions": {
        "F": [
            163251511,
            163268194,
            163257685,
            163252572,
            163254045,
            163268305,
            163279907,
            163277017,
            163279770,
            163277875,
            163278549,
            163242709,
            163276457,
            163283113,
            163287382,
            163289836,
            163287332,
            163286601,
            163290833,
            163270658
        ],
        "E": [
            163244868,
            163259890,
            163266161,
            163272812,
            163264648,
            163275442,
            163258821,
            163268518,
            163268841,
            163260671,
            163264743,
            163281368,
            163267683,
            163251911,
            163266438,
            163264157,
            163269030,
            163266798,
            163269366,
            163285662
        ],
        "D": [
            163228805,
            163243794,
            163241985,
            163230350,
            163241043,
            163238273,
            163235471,
            163239458,
            163247152,
            163243702,
            163253899,
            163251145,
            163245848,
            163241441,
            163251457,
            163249655,
            163254700,
            163255033,
            163238314,
            163253263
        ],
        "C": [
            163221033,
            163229733,
            163226787,
            163222248,
            163228927,
            163224161,
            163224146,
            163230155,
            163230384,
            163234091,
            163239295,
            163237663,
            163233141,
            163239841,
            163244784,
            163239399,
            163238796,
            163229460,
            163228482,
            163229332
        ],
        "B": [
            163216526,
            163223020,
            163218771,
            163216500,
            163222790,
            163218690,
            163217320,
            163219287,
            163222344,
            163220198,
            163229802,
            163224763,
            163220303,
            163218845,
            163218374,
            163222260,
            163227662,
            163222420,
            163219736,
            163217995
        ],
        "A": [
            163216029,
            163216466,
            163216829,
            163216062,
            163216261,
            163216352,
            163216058,
            163216701,
            163216924,
            163216152,
            163225075,
            163216629,
            163216398,
            163216381,
            163216162,
            163216559,
            163221320,
            163216621,
            163217196,
            163216126
        ]
    },
    "name": "E. Text Editor",
    "statement": "You wanted to write a text t consisting of m lowercase Latin letters.\r\nBut instead, you have written a text s consisting of n lowercase Latin\r\nletters, and now you want to fix it by obtaining the text t from the\r\ntext s.Initially, the cursor of your text editor is at the end of the\r\ntext s (after its last character). In one move, you can do one of the\r\nfollowing actions: press the \"left\" button, so the cursor is moved to\r\nthe left by one position (or does nothing if it is pointing at the\r\nbeginning of the text, i. e. before its first character); press the\r\n\"right\" button, so the cursor is moved to the right by one position (or\r\ndoes nothing if it is pointing at the end of the text, i. e. after its\r\nlast character); press the \"home\" button, so the cursor is moved to the\r\nbeginning of the text (before the first character of the text); press\r\nthe \"end\" button, so the cursor is moved to the end of the text (after\r\nthe last character of the text); press the \"backspace\" button, so the\r\ncharacter before the cursor is removed from the text (if there is no\r\nsuch character, nothing happens). Your task is to calculate the minimum\r\nnumber of moves required to obtain the text t from the text s using the\r\ngiven set of actions, or determine it is impossible to obtain the text t\r\nfrom the text s.You have to answer T independent test cases.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 08.07.2022 18:52:09       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    string s;\n    string t;\n    cin >> s >> t;\n    int ptr = 0;\n    int pref = 0;\n    for (int i = 0; i < n; i++) {\n      if (ptr < m && s[i] == t[ptr]) {\n        if (i == ptr) {\n          pref += 1;\n        }\n        ptr += 1;\n      }\n    }\n    if (ptr < m) {\n      cout << -1 << '\\n';\n      continue;\n    }\n    int ans = n - pref;\n    const int inf = (int) 1e9;\n    vector<int> d0(m + 1, inf);\n    vector<int> d1(m + 1, inf);\n    vector<int> d2(m + 1, inf);\n    d0[0] = d1[0] = d2[0] = 0;\n    for (char c : s) {\n      vector<int> f0(m + 1, inf);\n      vector<int> f1(m + 1, inf);\n      vector<int> f2(m + 1, inf);\n      for (int i = 0; i <= m; i++) {\n        f0[i] = min(f0[i], d0[i] + 2);\n        f2[i] = min(f2[i], d2[i] + 1);\n        if (i < m && c == t[i]) {\n          f0[i + 1] = min(f0[i + 1], d0[i] + 1);\n          f1[i + 1] = min(f1[i + 1], d1[i]);\n          f2[i + 1] = min(f2[i + 1], d2[i] + 1);\n        }\n      }\n      for (int i = 0; i <= m; i++) {\n        f1[i] = min(f1[i], f0[i]);\n        f2[i] = min(f2[i], f1[i]);\n      }\n      swap(d0, f0);\n      swap(d1, f1);\n      swap(d2, f2);\n    }\n    ans = min(ans, d2[m] + 1);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "strings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Text Editor.json",
    "editorial_link": "https://codeforces.com//blog/entry/104671",
    "editorial": "Of course, there is no need to press \"home\" more than once (and no need\r\nto press \"end\" at all), because suppose we did something on suffix, then\r\npressed \"home\", did something on prefix and then pressed \"end\" and\r\ncontinue doing something on suffix. Then we can merge these two\r\nsequences of moves on suffix and press \"home\" after we did anything we\r\nwanted on suffix, and the answer will not get worse.Now, letâs iterate\r\nover the position at which we will press \"home\" (in range from to ). In\r\nother words, we iterate over the position till which we press only\r\n\"left\" and \"backspace\" to fix the suffix. So now we have the string and\r\nwe want to get some suffix of from this string, but we actually donât\r\nknow which suffix of we want. So letâs iterate over the length of this\r\nsuffix in a range from to . Now we have the string and the string and we\r\nhave to check if we can obtain this suffix of from this suffix of . This\r\npart can be precalculated in greedily (we just can store for each suffix\r\nof the rightmost position in in which this suffix is obtainable). If we\r\ncan obtain the current suffix, then we obviously can say the number of\r\nmoves to do that it is and actually do not depend on the suffix length\r\n(because if we meet the character we need, we just press \"left\" and move\r\nto the next character, otherwise we press \"backspace\" and move to the\r\nnext character deleting the one we donât need).After that, we press\r\n\"home\" and now we have to check if we can obtain from . This part can\r\nalso be precalculated greedily in like the part with rightmost positions\r\nfor suffixes. But the minimum number of moves required to obtain the\r\nprefix is tricky. Actually, if we consider these prefixes from right to\r\nleft, we want to match as many characters from the beginning as\r\npossible. In other words, if we reverse and , we want to find their\r\nlongest common prefix, and this will be the number of characters we\r\ndonât want to touch at all (and if it is the longest common prefix, it\r\nmeans that the next character is bad, and we want to remove it anyway,\r\nso the length of LCP of these two reversed prefixes is the only thing\r\naffecting the number of moves on the prefix). This part can be\r\nprecalculated in with simple dynamic programming (using memory) or with\r\nz-function in time and memory we just need to build a z-function on a\r\nstring , where is the concatenation of strings and is the reverse\r\noperation. The required value of the z-function for the fixed values and\r\nwill be in the position . And the answer for the prefix will be (this is\r\nthe number of extra characters on the prefix we have to delete) plus\r\nplus because we have to press \"home\". But there is a corner case. If the\r\nprefix is empty, then we donât need to do all of this and the answer for\r\nprefix will be .Complexity: time and memory.\r\n",
    "hint": []
}