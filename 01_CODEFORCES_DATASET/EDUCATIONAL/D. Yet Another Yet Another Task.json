{
    "link": "https://codeforces.com//contest/1359/problem/D",
    "problemId": "634675",
    "problem_idx": "D",
    "shortId": "1359D",
    "contest_number": "1359",
    "problem_submissions": {
        "C": [
            81997007,
            81727058,
            81734733,
            81730835,
            81740916,
            81747939,
            81729612,
            81737303,
            81737447,
            81741656,
            81752868,
            81776094,
            81761832,
            81724495,
            81746226,
            81738450,
            81730327,
            81729715,
            81731437,
            81744227,
            81733481
        ],
        "F": [
            81812419,
            81764295,
            81854273,
            81854109,
            81853958,
            81778328,
            81787414,
            81786228,
            81796920,
            81794151,
            81788283,
            81787937,
            81784721,
            81790808,
            81789636,
            81804129,
            81796060,
            81778353,
            81798275,
            105524321,
            105524094,
            105524008,
            81799361,
            81796754,
            81795964,
            81808154,
            81868467,
            205746151,
            205745147,
            140844519
        ],
        "D": [
            81739116,
            81744503,
            81735878,
            81749048,
            81740279,
            81749196,
            81744086,
            81743897,
            81754255,
            81762454,
            81758312,
            81744429,
            81728105,
            81726622,
            81721526,
            81737234,
            81738327,
            81737186,
            81731810,
            81739976
        ],
        "E": [
            81734306,
            81750721,
            81743059,
            81759597,
            81729601,
            81756849,
            81752573,
            81749938,
            81761248,
            81768636,
            81784969,
            81729272,
            81731972,
            81733967,
            81747782,
            81743404,
            81743235,
            81742828,
            81736556,
            81742484
        ],
        "B": [
            81716705,
            81725433,
            81718596,
            81720832,
            81719267,
            81716337,
            81719010,
            81727250,
            81721619,
            81746513,
            81720940,
            81767813,
            81716284,
            81717634,
            81717996,
            81719942,
            81719713,
            81719807,
            81718363,
            81718512
        ],
        "A": [
            81715063,
            81720474,
            81715122,
            81715707,
            81715255,
            81715098,
            81715727,
            81721547,
            81715498,
            81744191,
            81715755,
            81770964,
            81715068,
            81715226,
            81715093,
            81715532,
            81715578,
            81715424,
            81715396,
            81715264
        ]
    },
    "name": "D. Yet Another Yet Another Task",
    "statement": "Alice and Bob are playing yet another card game. This time the rules are\r\nthe following. There are n cards lying in a row in front of them. The\r\ni-th card has value a_i. First, Alice chooses a non-empty consecutive\r\nsegment of cards [l; r] (l\r\nle r). After that Bob removes a single card j from that segment (l\r\nle j\r\nle r). The score of the game is the total value of the remaining cards\r\non the segment (a_l + a_{l + 1} +\r\ndots + a_{j - 1} + a_{j + 1} +\r\ndots + a_{r - 1} + a_r). In particular, if Alice chooses a segment with\r\njust one element, then the score after Bob removes the only card is\r\n0.Alice wants to make the score as big as possible. Bob takes such a\r\ncard that the score is as small as possible.What segment should Alice\r\nchoose so that the score is maximum possible? Output the maximum score.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 1e5 + 10;\nint a[maxN];\nint n;\nint pref[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    int best = 0;\n    vector < pair < int, int > > all;\n\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        pref[i] = pref[i - 1] + a[i];\n        for (auto& it : all) {\n            it.first = max(it.first, a[i]);\n        }\n        all.emplace_back(a[i], pref[i - 1]);\n        sort(all.begin(), all.end());\n        map < int, int > mp;\n        for (auto& it : all) {\n            if (!mp.count(it.first)) mp[it.first] = it.second;\n            else mp[it.first] = min(mp[it.first], it.second);\n        }\n        all.clear();\n        for (auto& it : mp) {\n            all.emplace_back(it);\n            best = max(best, pref[i] - it.second - it.first);\n        }\n    }\n    cout << best;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "implementation",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Yet Another Yet Another Task.json",
    "editorial_link": "https://codeforces.com//blog/entry/78116",
    "editorial": "Alice wants to choose such a segment that is maximum possible. There is\r\na well-known problem where you have to find a segment with maximum .\r\nThat problem is solved with Kadane algorithm. Let\u00e2\u0080\u0099s learn how to reduce\r\nour problem to that one.Notice that the values in the array are\r\nunusually small. Let\u00e2\u0080\u0099s iterate over the maximum value on segment. Let be\r\nthe current value. If we make all such that equal to , then it will\r\nnever be optimal to take them in a segment. Find the maximum sum\r\nsubarray in that modified array and update the answer with its .Notice\r\nthat you can ignore the fact if there is a value exactly equal to on the\r\nmaximum sum segment. If there isn\u00e2\u0080\u0099t then you\u00e2\u0080\u0099ll update the answer with a\r\nsmaller value than the actual one. Let the actual maximum on the maximum\r\nsum segment be some . You can see that for any value between and the\r\nmaximum sum segment will always be that chosen one. Thus, when you reach\r\n, you\u00e2\u0080\u0099ll update the answer with the correct value.Overall complexity: .\r\n"
}