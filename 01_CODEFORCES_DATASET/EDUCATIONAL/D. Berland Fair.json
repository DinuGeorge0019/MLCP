{
    "link": "https://codeforces.com//contest/1073/problem/D",
    "problemId": "243299",
    "problem_idx": "D",
    "shortId": "1073D",
    "contest_number": "1073",
    "problem_submissions": {
        "G": [
            44873257,
            44854949,
            44872747,
            44857777,
            44904113,
            44992378,
            44992266,
            44905426,
            44884903,
            44945894,
            44917741
        ],
        "F": [
            44867029,
            44865010,
            44864483,
            44871287,
            44872814,
            44868847,
            44879071,
            44874774,
            44882300,
            44882274,
            44882259,
            44904164,
            45084744,
            45695799,
            44888299
        ],
        "E": [
            44859477,
            44871290,
            44861403,
            44863217,
            44864294,
            44859185,
            44863995,
            44861353,
            44862909,
            44862761,
            44864156,
            44861997,
            44866321,
            44865560,
            44864610,
            44864622,
            44866506,
            44866536,
            44864718,
            44867428
        ],
        "D": [
            44857129,
            44872779,
            44856075,
            44857988,
            44858337,
            44861164,
            44866799,
            44854399,
            44858649,
            44887677,
            44857825,
            44863255,
            44857894,
            44856716,
            44859464,
            44857349,
            44858547,
            44860520,
            44859062,
            44858058
        ],
        "C": [
            44852935,
            44867793,
            44850047,
            44853493,
            44853830,
            44872109,
            44870370,
            44851223,
            44852821,
            44887759,
            44853381,
            44855264,
            44855099,
            44853761,
            44855656,
            44859785,
            44852765,
            44856270,
            44855283,
            44855046
        ],
        "B": [
            44847780,
            44861886,
            44847247,
            44849026,
            44846682,
            44849066,
            44868560,
            44847702,
            44847526,
            44848456,
            44847355,
            44849516,
            44847583,
            44849338,
            44847283,
            44847620,
            44847641,
            44850429,
            44848272
        ],
        "A": [
            44846309,
            44861253,
            44846364,
            44847286,
            44846147,
            44847332,
            44867659,
            44846213,
            44846204,
            44846510,
            44846224,
            44846724,
            44846207,
            44847114,
            44846296,
            44846271,
            44846181,
            44848595,
            44846401
        ]
    },
    "name": "D. Berland Fair",
    "statement": "XXI Berland Annual Fair is coming really soon! Traditionally fair\r\nconsists of n booths, arranged in a circle. The booths are numbered 1\r\nthrough n clockwise with n being adjacent to 1. The i-th booths sells\r\nsome candies for the price of a_i burles per item. Each booth has an\r\nunlimited supply of candies.Polycarp has decided to spend at most T\r\nburles at the fair. However, he has some plan in mind for his path\r\nacross the booths: at first, he visits booth number 1; if he has enough\r\nburles to buy candy from the current booth, then he buys it immediately;\r\nthen he proceeds to the next booth in the clockwise order (regardless of\r\nif he bought a candy or not). Polycarp’s money is finite, thus the\r\nprocess will end once he can no longer buy candy at any booth.Calculate\r\nthe number of candies Polycarp will buy.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct BIT {\n  vector<long long> dat;\n\n  BIT(int n) : dat(n + 1) {}\n\n  void update(int k, long long v) {\n    for (int i = k + 1; i < dat.size(); i += i & -i) {\n      dat[i] += v;\n    }\n  }\n  \n  long long query(int k) {\n    long long ans = 0;\n    for (int i = k; i > 0; i -= i & -i) {\n      ans += dat[i];\n    }\n    return ans;\n  }\n\n  long long query(int l, int r) {\n    return query(r) - query(l);\n  }\n};\n\nint main() {\n  int n;\n  long long T;\n  cin >> n >> T;\n  BIT bit0(n * 2);\n  BIT bit1(n * 2);\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n    bit0.update(i, 1);\n    bit0.update(i + n, 1);\n    bit1.update(i, a[i]);\n    bit1.update(i + n, a[i]);\n  }\n  int k = 0;\n  long long ans = 0;\n  int left = n;\n  while (left > 0) {\n    long long s = bit1.query(k, k + n);\n    if (s > T) {\n      int l = k;\n      int r = k + n;\n      while (r - l > 1) {\n        int m = (l + r) / 2;\n        if (bit1.query(k, m) <= T) {\n          l = m;\n        } else {\n          r = m;\n        }\n      }\n      ans += bit0.query(k, l);\n      T -= bit1.query(k, l);\n      k = l % n;\n      bit0.update(k, -1);\n      bit0.update(k + n, -1);\n      bit1.update(k, -a[k]);\n      bit1.update(k + n, -a[k]);\n      left--;\n    } else {\n      ans += (T / s) * bit0.query(k, k + n);\n      T %= s;\n    }\n  }\n  cout << ans << endl;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "greedy"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Berland Fair.json",
    "editorial_link": "https://codeforces.com/blog/entry/62742",
    "editorial": "Letâs code the following process. Go one circle across the booths,\r\ncalculate the total cost of sweets bought and the number of sweets\r\nbought. Now you can decrease you money down to and add to answer. It\r\nrepresents that you went maximum number of such circles. The later\r\ncircles will have smaller cost. Letâs continue this process until\r\nbecomes smaller than the minimum priced sweet.The number of operations\r\nmade is . Let be the amount of money before some operation, be the total\r\ncost of sweets bought on that operation and . is actually smaller than\r\n(thatâs how modulo works) and smaller than (thatâs also how modulo\r\nworks). And these inequalities imply that . That leads to about steps to\r\nreach the minimal price.Overall complexity: .\r\n",
    "hint": []
}