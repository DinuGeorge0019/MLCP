{
    "link": "https://codeforces.com//contest/1251/problem/F",
    "problemId": "449550",
    "problem_idx": "F",
    "shortId": "1251F",
    "contest_number": "1251",
    "problem_submissions": {
        "D": [
            63400316,
            63400298,
            63400254,
            63400203,
            63400050,
            63399984,
            63399855,
            63312403,
            63311940,
            63318990,
            63314573,
            63427346,
            63313882,
            63324960,
            63323872,
            63313008,
            63319425,
            63312837,
            63313209,
            63313402,
            63313713,
            63313403,
            64630107,
            63316214,
            63315539,
            63310152,
            63317232,
            63314816
        ],
        "E2": [
            63399693,
            63399662,
            63399248,
            63399098,
            63398546,
            63365832,
            63365269,
            63364770,
            63338273,
            63317755,
            63314968,
            63314711,
            63319868,
            63427473,
            63323675,
            63322799,
            63317013,
            63330304,
            63326912,
            63315944,
            63319041,
            63319971,
            63319185,
            63322016,
            64630154,
            63319603,
            63323442,
            63321804,
            63320973
        ],
        "F": [
            63396794,
            63395657,
            63340397,
            63340247,
            63322387,
            63331974,
            63347502,
            63345880,
            63325885,
            63328608,
            63427571,
            63333465,
            63330239,
            63311325,
            63320807,
            63332225,
            63349152,
            63349006,
            63348927,
            63346482,
            63354827,
            63555798,
            63396546,
            63361055,
            63321261,
            63339709
        ],
        "C": [
            63339509,
            63309630,
            63308770,
            63309154,
            63311219,
            63425373,
            63310517,
            63308226,
            63320102,
            63309048,
            63314299,
            63306755,
            63309969,
            63308377,
            63311623,
            63309667,
            64630061,
            63312827,
            63308776,
            63307614,
            63311843,
            63311519
        ],
        "E1": [
            63317840,
            63315090,
            63315149,
            63319942,
            63427459,
            63323582,
            63322914,
            63316888,
            63330357,
            63326985,
            63315977,
            63318948,
            63319867,
            63319014,
            63322137,
            64630159,
            63319793,
            63323604,
            63329086,
            63321906,
            63320849
        ],
        "B": [
            63308319,
            63306252,
            63306938,
            63308521,
            63425306,
            63309307,
            63306115,
            63321613,
            63306650,
            63307802,
            63305211,
            63307273,
            63305885,
            63310074,
            63307855,
            64630021,
            63308550,
            63306496,
            63305718,
            63309015,
            63308105
        ],
        "A": [
            63304668,
            63304379,
            63304115,
            63305872,
            63425273,
            63304642,
            63304137,
            63319299,
            63304384,
            63304697,
            63304218,
            63304454,
            63304321,
            63307231,
            63304364,
            64629970,
            63304438,
            63304343,
            63304369,
            63305312,
            63306229
        ]
    },
    "name": "F. Red-White Fence",
    "statement": "Polycarp wants to build a fence near his house. He has n white boards\r\nand k red boards he can use to build it. Each board is characterised by\r\nits length, which is an integer.A good fence should consist of red board\r\nand several (possibly zero) white boards. The red board should be the\r\nlongest one in the fence (every white board used in the fence should be\r\nstrictly shorter), and the sequence of lengths of boards should be\r\nascending before the red board and descending after it. Formally, if m\r\nboards are used, and their lengths are l_1, l_2, ..., l_m in the order\r\nthey are placed in the fence, from left to right (letâ€™s call this array\r\n[l_1, l_2,\r\ndots, l_m] ), the following conditions should hold: there should be\r\nexactly one red board in the fence (let its index be j); for every i\r\nin [1, j - 1] l_i < l_{i + 1}; for every i\r\nin [j, m - 1] l_i > l_{i + 1}. When Polycarp will build his fence, he\r\nwill place all boards from left to right on the same height of 0,\r\nwithout any gaps, so these boards compose a polygon: Polycarp is\r\ninterested in fences of some special perimeters. He has q integers he\r\nreally likes (these integers are Q_1, Q_2, ..., Q_q), and for every such\r\ninteger Q_i, he wants to calculate the number of different fences with\r\nperimeter Q_i he can build (two fences are considered different if their\r\nare different). Can you help him calculate these values?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <limits>\n#include <vector>\nusing namespace std;\n\nnamespace IO {\n    const int BUFFER_SIZE = 1 << 15;\n\n    char input_buffer[BUFFER_SIZE];\n    int input_pos = 0, input_len = 0;\n\n    char output_buffer[BUFFER_SIZE];\n    int output_pos = 0;\n\n    char number_buffer[100];\n    uint8_t lookup[100];\n\n    void _update_input_buffer() {\n        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);\n        input_pos = 0;\n\n        if (input_len == 0)\n            input_buffer[0] = EOF;\n    }\n\n    inline char next_char(bool advance = true) {\n        if (input_pos >= input_len)\n            _update_input_buffer();\n\n        return input_buffer[advance ? input_pos++ : input_pos];\n    }\n\n    template<typename T>\n    inline void read_int(T &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == '-')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - '0');\n        } while (isdigit(next_char(false)));\n\n        if (negative)\n            number = -number;\n    }\n\n    template<typename T, typename... Args>\n    inline void read_int(T &number, Args &... args) {\n        read_int(number);\n        read_int(args...);\n    }\n\n    void _flush_output() {\n        fwrite(output_buffer, sizeof(char), output_pos, stdout);\n        output_pos = 0;\n    }\n\n    inline void write_char(char c) {\n        if (output_pos == BUFFER_SIZE)\n            _flush_output();\n\n        output_buffer[output_pos++] = c;\n    }\n\n    template<typename T>\n    inline void write_int(T number, char after = '\\0') {\n        if (number < 0) {\n            write_char('-');\n            number = -number;\n        }\n\n        int length = 0;\n\n        while (number >= 10) {\n            uint8_t lookup_value = lookup[number % 100];\n            number /= 100;\n            number_buffer[length++] = (lookup_value & 15) + '0';\n            number_buffer[length++] = (lookup_value >> 4) + '0';\n        }\n\n        if (number != 0 || length == 0)\n            write_char(number + '0');\n\n        for (int i = length - 1; i >= 0; i--)\n            write_char(number_buffer[i]);\n\n        if (after)\n            write_char(after);\n    }\n\n    void init() {\n        // Make sure _flush_output() is called at the end of the program.\n        bool exit_success = atexit(_flush_output) == 0;\n        assert(exit_success);\n\n        for (int i = 0; i < 100; i++)\n            lookup[i] = (i / 10 << 4) + i % 10;\n    }\n}\n\nconst int MOD = 998244353;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0)\n            v = v % MOD + MOD;\n\n        if (v >= MOD)\n            v %= MOD;\n\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\nvector<mod_int> inv, factorial, inv_factorial;\n\nvoid prepare_factorials(int maximum) {\n    inv.assign(maximum + 1, 1);\n\n    // Make sure MOD is prime, which is necessary for the inverse algorithm below.\n    for (int p = 2; p * p <= MOD; p++)\n        assert(MOD % p != 0);\n\n    for (int i = 2; i <= maximum; i++)\n        inv[i] = inv[MOD % i] * (MOD - MOD / i);\n\n    factorial.resize(maximum + 1);\n    inv_factorial.resize(maximum + 1);\n    factorial[0] = inv_factorial[0] = 1;\n\n    for (int i = 1; i <= maximum; i++) {\n        factorial[i] = i * factorial[i - 1];\n        inv_factorial[i] = inv[i] * inv_factorial[i - 1];\n    }\n}\n\nmod_int choose(long long n, long long r) {\n    if (r < 0 || r > n)\n        return 0;\n\n    return factorial[n] * inv_factorial[r] * inv_factorial[n - r];\n}\n\nmod_int inv_choose(long long n, long long r) {\n    assert(0 <= r && r <= n);\n    return inv_factorial[n] * factorial[r] * factorial[n - r];\n}\n\nmod_int permute(long long n, long long k) {\n    if (k < 0 || k > n)\n        return 0;\n\n    return factorial[n] * inv_factorial[n - k];\n}\n\nmod_int inv_permute(long long n, long long k) {\n    assert(0 <= k && k <= n);\n    return inv_factorial[n] * factorial[n - k];\n}\n\nnamespace NTT {\n    vector<mod_int> roots = {0, 1};\n    vector<int> bit_reverse;\n    int max_size = -1;\n    mod_int root;\n\n    bool is_power_of_two(int n) {\n        return (n & (n - 1)) == 0;\n    }\n\n    int round_up_power_two(int n) {\n        assert(n > 0);\n\n        while (n & (n - 1))\n            n = (n | (n - 1)) + 1;\n\n        return n;\n    }\n\n    // Given n (a power of two), finds k such that n == 1 << k.\n    int get_length(int n) {\n        assert(is_power_of_two(n));\n        return __builtin_ctz(n);\n    }\n\n    // Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n    // This makes even-odd div-conquer much easier.\n    void bit_reorder(int n, vector<mod_int> &values) {\n        if ((int) bit_reverse.size() != n) {\n            bit_reverse.assign(n, 0);\n            int length = get_length(n);\n\n            for (int i = 0; i < n; i++)\n                bit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n        }\n\n        for (int i = 0; i < n; i++)\n            if (i < bit_reverse[i])\n                swap(values[i], values[bit_reverse[i]]);\n    }\n\n    void find_root() {\n        int order = MOD - 1;\n        max_size = 1;\n\n        while (order % 2 == 0) {\n            order /= 2;\n            max_size *= 2;\n        }\n\n        root = 2;\n\n        // Find a max_size-th primitive root of MOD.\n        while (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n            root++;\n    }\n\n    void prepare_roots(int n) {\n        if (max_size < 0)\n            find_root();\n\n        assert(n <= max_size);\n\n        if ((int) roots.size() >= n)\n            return;\n\n        int length = get_length(roots.size());\n        roots.resize(n);\n\n        // The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n        // the first half of the n-th primitive roots of MOD.\n        while (1 << length < n) {\n            // z is a 2^(length + 1)-th primitive root of MOD.\n            mod_int z = root.pow(max_size >> (length + 1));\n\n            for (int i = 1 << (length - 1); i < 1 << length; i++) {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = roots[i] * z;\n            }\n\n            length++;\n        }\n    }\n\n    void fft_iterative(int N, vector<mod_int> &values) {\n        assert(is_power_of_two(N));\n        prepare_roots(N);\n        bit_reorder(N, values);\n\n        for (int n = 1; n < N; n *= 2)\n            for (int start = 0; start < N; start += 2 * n)\n                for (int i = 0; i < n; i++) {\n                    mod_int even = values[start + i];\n                    mod_int odd = values[start + n + i] * roots[n + i];\n                    values[start + n + i] = even - odd;\n                    values[start + i] = even + odd;\n                }\n    }\n\n    const int FFT_CUTOFF = 150;\n\n    vector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n        int n = left.size();\n        int m = right.size();\n\n        // Brute force when either n or m is small enough.\n        if (min(n, m) < FFT_CUTOFF) {\n            const uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n            vector<uint64_t> result(n + m - 1);\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++) {\n                    result[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\n                    if (result[i + j] > ULL_BOUND)\n                        result[i + j] %= MOD;\n                }\n\n            for (uint64_t &x : result)\n                if (x >= MOD)\n                    x %= MOD;\n\n            return vector<mod_int>(result.begin(), result.end());\n        }\n\n        int N = round_up_power_two(n + m - 1);\n        left.resize(N);\n        right.resize(N);\n\n        bool equal = left == right;\n        fft_iterative(N, left);\n\n        if (equal)\n            right = left;\n        else\n            fft_iterative(N, right);\n\n        mod_int inv_N = mod_int(N).inv();\n\n        for (int i = 0; i < N; i++)\n            left[i] *= right[i] * inv_N;\n\n        reverse(left.begin() + 1, left.end());\n        fft_iterative(N, left);\n        left.resize(n + m - 1);\n        return left;\n    }\n\n    vector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n        assert(exponent >= 0);\n        vector<mod_int> result = {1};\n\n        if (exponent == 0)\n            return result;\n\n        for (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n            result = mod_multiply(result, result);\n\n            if (exponent >> k & 1)\n                result = mod_multiply(result, v);\n        }\n\n        return result;\n    }\n}\n\n\nvoid add(vector<mod_int> &answers, const vector<mod_int> &product, size_t offset) {\n    answers.resize(max(answers.size(), product.size() + offset), 0);\n\n    for (size_t i = 0; i < product.size(); i++)\n        answers[offset + i] += product[i];\n}\n\nint main() {\n    IO::init();\n\n    int N, K;\n    IO::read_int(N, K);\n    prepare_factorials(N);\n    vector<int> A(N), B(K);\n\n    for (auto &a : A)\n        IO::read_int(a);\n\n    for (auto &b : B)\n        IO::read_int(b);\n\n    sort(A.begin(), A.end());\n    sort(B.begin(), B.end());\n    vector<mod_int> single_poly, double_poly;\n    vector<mod_int> answers, product = {1};\n\n    for (int k = 0, current = 0; k < K; k++) {\n        int single_count = 0, double_count = 0;\n\n        while (current < N && A[current] < B[k]) {\n            int end = current;\n\n            while (end < N && A[current] == A[end])\n                end++;\n\n            if (end - current == 1)\n                single_count++;\n            else\n                double_count += 2;\n\n            current = end;\n        }\n\n        single_poly.resize(single_count + 1);\n        double_poly.resize(double_count + 1);\n        mod_int pow2 = 1;\n\n        for (int i = 0; i <= single_count; i++) {\n            single_poly[i] = choose(single_count, i) * pow2;\n            pow2 += pow2;\n        }\n\n        for (int i = 0; i <= double_count; i++)\n            double_poly[i] = choose(double_count, i);\n\n        product = NTT::mod_multiply(product, NTT::mod_multiply(single_poly, double_poly));\n        add(answers, product, B[k] + 1);\n    }\n\n    int Q;\n    IO::read_int(Q);\n\n    for (int q = 0; q < Q; q++) {\n        int perimeter;\n        IO::read_int(perimeter);\n        int goal = perimeter / 2;\n        mod_int answer = goal < (int) answers.size() ? answers[goal] : 0;\n        IO::write_int((int) answer, '\\n');\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "fft"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Red-White Fence.json",
    "editorial_link": "https://codeforces.com//blog/entry/70860",
    "editorial": "LetÃ¢Â€Â™s analyze how the perimeter of the fence can be calculated, if we\r\nknow its array of lengths. Suppose there are boards in the fence. The\r\nperimeter of the fence can be composed of the three following values:\r\nthe lower border of the fence (with length ); horizontal segments in the\r\nupper border of the fence (with total length ); vertical segment of the\r\nborder. The total length of all vertical segments before the red board\r\n(including its left border) is . The total length of all vertical\r\nsegments after the red board (including its right border) is too. So,\r\nthe perimeter of the fence is , where is the number of boards used in\r\nconstructing the fence, and is the length of the red board.So, for\r\nexample, if we want to create a fence that contains a red board with\r\nlength and has perimeter , it should contain exactly white boards. Now\r\nletÃ¢Â€Â™s solve the problem as follows: iterate on the length of the red\r\nboard that will be used, and for each calculate the number of ways to\r\nconstruct a fence with a red board of length and exactly white boards\r\n(which are shorter than ).Suppose all white boards shorter than have\r\ndistinct lengths. Then for each board, there are three options: not\r\nplace it at all, place it in the left part (to the left of the red\r\nboard) or place it in the right part. So, if there are different white\r\nboards shorter than , the number of ways to build a fence with white\r\nboards is .Okay, now letÃ¢Â€Â™s consider the opposite situation: there is no\r\nunique white board; that is, for each length, we have either boards or\r\nat least boards. Suppose the number of different lengths is . For each\r\nlength, we can choose whether we place a board of such length in the\r\nleft side and in the right side. So, the number of ways to build a fence\r\nwith white boards is .And now letÃ¢Â€Â™s consider the general case. Divide\r\nall boards into two categories: \"unique\" and \"non-unique\". If we want to\r\nbuild a fence with exactly white boards, there are ways to do it. Since\r\nwe should calculate these values for many different values of , we have\r\nto use FFT: we should form two polynomials and , and then multiply them.\r\nSince the modulo is special, itÃ¢Â€Â™s better to use NTT.\r\n",
    "hint": []
}