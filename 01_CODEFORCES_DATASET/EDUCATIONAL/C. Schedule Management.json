{
    "link": "https://codeforces.com//contest/1701/problem/C",
    "problemId": "1455051",
    "problem_idx": "C",
    "shortId": "1701C",
    "contest_number": "1701",
    "problem_submissions": {
        "F": [
            163251511,
            163268194,
            163257685,
            163252572,
            163254045,
            163268305,
            163279907,
            163277017,
            163279770,
            163277875,
            163278549,
            163242709,
            163276457,
            163283113,
            163287382,
            163289836,
            163287332,
            163286601,
            163290833,
            163270658
        ],
        "E": [
            163244868,
            163259890,
            163266161,
            163272812,
            163264648,
            163275442,
            163258821,
            163268518,
            163268841,
            163260671,
            163264743,
            163281368,
            163267683,
            163251911,
            163266438,
            163264157,
            163269030,
            163266798,
            163269366,
            163285662
        ],
        "D": [
            163228805,
            163243794,
            163241985,
            163230350,
            163241043,
            163238273,
            163235471,
            163239458,
            163247152,
            163243702,
            163253899,
            163251145,
            163245848,
            163241441,
            163251457,
            163249655,
            163254700,
            163255033,
            163238314,
            163253263
        ],
        "C": [
            163221033,
            163229733,
            163226787,
            163222248,
            163228927,
            163224161,
            163224146,
            163230155,
            163230384,
            163234091,
            163239295,
            163237663,
            163233141,
            163239841,
            163244784,
            163239399,
            163238796,
            163229460,
            163228482,
            163229332
        ],
        "B": [
            163216526,
            163223020,
            163218771,
            163216500,
            163222790,
            163218690,
            163217320,
            163219287,
            163222344,
            163220198,
            163229802,
            163224763,
            163220303,
            163218845,
            163218374,
            163222260,
            163227662,
            163222420,
            163219736,
            163217995
        ],
        "A": [
            163216029,
            163216466,
            163216829,
            163216062,
            163216261,
            163216352,
            163216058,
            163216701,
            163216924,
            163216152,
            163225075,
            163216629,
            163216398,
            163216381,
            163216162,
            163216559,
            163221320,
            163216621,
            163217196,
            163216126
        ]
    },
    "name": "C. Schedule Management",
    "statement": "There are n workers and m tasks. The workers are numbered from 1 to n.\r\nEach task i has a value a_i the index of worker who is proficient in\r\nthis task.Every task should have a worker assigned to it. If a worker is\r\nproficient in the task, they complete it in 1 hour. Otherwise, it takes\r\nthem 2 hours.The workers work in parallel, independently of each other.\r\nEach worker can only work on one task at once.Assign the workers to all\r\ntasks in such a way that the tasks are completed as early as possible.\r\nThe work starts at time 0. What\u2019s the minimum time all tasks can be\r\ncompleted by?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 08.07.2022 18:37:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(m);\n    for (int i = 0; i < m; i++) {\n      cin >> a[i];\n      --a[i];\n    }\n    vector<int> cnt(n);\n    for (int i = 0; i < m; i++) {\n      cnt[a[i]] += 1;\n    }\n    int low = 0, high = 2 * (m + n + 10);\n    while (low < high) {\n      int mid = (low + high) >> 1;\n      long long extra = 0;\n      long long need = 0;\n      for (int i = 0; i < n; i++) {\n        if (cnt[i] <= mid) {\n          extra += (mid - cnt[i]) / 2;\n        } else {\n          need += cnt[i] - mid;\n        }\n      }\n      if (extra >= need) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    }\n    cout << low << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "implementation",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Schedule Management.json",
    "editorial_link": "https://codeforces.com//blog/entry/104671",
    "editorial": "The statement should instantly scream binary search at you. Clearly, if\r\nyou can assign the workers in such a way that the tasks are completed by\r\ntime , you can complete them all by or more as well.How to check if the\r\ntasks can be completed by some time ? What that means is that all\r\nworkers have hours to work on some tasks. If all tasks took hours to\r\ncomplete, then each of them could complete of them. Thus, together they\r\nwould be able to complete tasks.How to incorporate the -hour tasks into\r\nthat? Well, we can redistribute the tasks in such a way that each worker\r\nfirst completes the tasks they are proficient in, then some other tasks\r\nif they have more time.So the general idea is the following. Let each\r\nworker complete -hour tasks, where is the number of tasks the -th worker\r\nis proficient in. Then remember how many -hour tasks they can complete,\r\nwhich is . Finally, remember how many tasks that they are proficient in\r\nthey didn\u00e2\u0080\u0099t have time to complete, which is . If the sum of the number\r\nof incomplete tasks doesn\u00e2\u0080\u0099t exceed the sum of the number of tasks they\r\nhave time to complete, then everything can be completed in time .Worst\r\ncase, it can take up to hours to complete everything if you assign all\r\ntasks to a single worker, and they are not proficient in any of\r\nthem.Overall complexity: per testcase.\r\n"
}