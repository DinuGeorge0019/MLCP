{
    "link": "https://codeforces.com//contest/1380/problem/C",
    "problemId": "670985",
    "problem_idx": "C",
    "shortId": "1380C",
    "contest_number": "1380",
    "problem_submissions": {
        "F": [
            86713166,
            86683254,
            86680631,
            86680966,
            86687165,
            86684140,
            86669350,
            86688621,
            86687283,
            86673002,
            86689951,
            86691835,
            86685205,
            86710315,
            86689156,
            86687400,
            86687045,
            86687896,
            86690019
        ],
        "G": [
            86677566,
            86685201,
            86688237,
            86689481,
            86686718,
            86691383,
            86690954,
            86692142,
            86694360,
            86693986,
            86693332,
            86693299,
            86700820,
            86693764,
            86685196,
            86684314
        ],
        "E": [
            86675522,
            86675407,
            86673302,
            86676691,
            86680473,
            86684037,
            86681297,
            86679620,
            86685647,
            86685220,
            86686544,
            86674567,
            86678512,
            86684412,
            86683830,
            86676323,
            86680714,
            86681696,
            86690990
        ],
        "D": [
            86667662,
            86670333,
            86669219,
            86673424,
            86678569,
            86680592,
            86676914,
            86676735,
            86681998,
            86680522,
            86687871,
            86670447,
            86672345,
            86680156,
            86679073,
            86689461,
            86721905,
            86687223
        ],
        "C": [
            86667582,
            86670259,
            86669101,
            86667895,
            86670203,
            86672224,
            86667959,
            86672685,
            86676101,
            86675384,
            86675814,
            86668973,
            86672498,
            86672045,
            86670655,
            86667252,
            86668731,
            86674537,
            86668780
        ],
        "B": [
            86667335,
            86670187,
            86671042,
            86667790,
            86672794,
            86670893,
            86667752,
            86671215,
            86673431,
            86671665,
            86674484,
            86670341,
            86660822,
            86669327,
            86673817,
            86667069,
            86673326,
            86672657,
            86668683
        ],
        "A": [
            86667075,
            86670143,
            86668605,
            86667568,
            86667937,
            86657614,
            86657741,
            86669480,
            86673357,
            86672922,
            86672973,
            86668720,
            86672438,
            86659787,
            86671597,
            86666992,
            86671323,
            86669608,
            86668545
        ]
    },
    "name": "C. Create The Teams",
    "statement": "There are n programmers that you want to split into several non-empty\r\nteams. The skill of the i-th programmer is a_i. You want to assemble the\r\nmaximum number of teams from them. There is a restriction for each team:\r\nthe number of programmers in the team multiplied by the minimum skill\r\namong all programmers in the team must be at least x.Each programmer\r\nshould belong to at most one team. Some programmers may be left without\r\na team.Calculate the maximum number of teams that you can assemble.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        int N; ll K; cin >> N >> K;\n        vl A(N); F0R(i, N) cin >> A[i];\n        sort(all(A)); reverse(all(A));\n\n        int cnt = 0;\n        ll ans = 0;\n        F0R(i, N) {\n            ll X = (K + A[i] - 1) / A[i];\n            X--;\n            if (cnt >= X) {\n                cnt -= X; ans++;\n            } else {\n                cnt++;\n            }\n        }\n        cout << ans << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Create The Teams.json",
    "editorial_link": "https://codeforces.com//blog/entry/80054",
    "editorial": "At first, notice that if only programmers are taken, then the same or\r\neven better answer can be achieved if strongest programmers are\r\ntaken.Now let\u00e2\u0080\u0099s sort the programmers in a non-increasing order and\r\nchoose some assignment into the teams. For each team only the rightmost\r\ntaken programmer of that team matters (the sorted sequence implies that\r\nthe rightmost is the weakest).Take a look at the team with the strongest\r\nweakest member. If the number of programmers in it is less than the\r\nposition of the weakest member, then you can safely rearrange the\r\nprogrammers before him in such a way that none of parameters of later\r\nteams change and the weakest member in the first one only becomes\r\nstronger. After that you can get rid of the first team (as it takes\r\nexactly the prefix of all the programmers) and proceed to fix the later\r\nteams.Thus, we can see that there is an optimal solution such that each\r\nteam is a segment and all the teams together take some prefix of the\r\nprogrammers. So we can finally run a greedy solution that takes\r\nprogrammers from left to right and increases the answer if the\r\nconditions for the latest team hold.Overall complexity: .\r\n"
}