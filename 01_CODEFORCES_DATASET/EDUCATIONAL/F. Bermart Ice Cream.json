{
    "link": "https://codeforces.com//contest/2026/problem/F",
    "problemId": "2985133",
    "problem_idx": "F",
    "shortId": "2026F",
    "contest_number": "2026",
    "problem_submissions": {
        "F": [
            288561266,
            289460762,
            288610204,
            288597833,
            288597166,
            288569834,
            288622486,
            288654341,
            288862318,
            289435066
        ],
        "E": [
            288532750,
            288648436,
            289460758,
            288538098,
            288522785,
            288536060,
            288547433,
            288544648,
            288565205,
            288561153,
            288562514,
            288560885,
            288560234,
            288562220,
            288569450,
            288563732,
            288565049,
            288562236,
            288561108,
            288565165,
            288569967
        ],
        "C": [
            288529378,
            288523247,
            288587507,
            288523790,
            288525729,
            288530332,
            288531829,
            288528175,
            288530132,
            288533395,
            288532265,
            288535389,
            288532312,
            288535104,
            288538148,
            288539384,
            288557011,
            288540483,
            288538281
        ],
        "D": [
            288525443,
            288532543,
            288578032,
            288532129,
            288536966,
            288541005,
            288544765,
            288551300,
            288551604,
            288547887,
            288547345,
            288554913,
            288553450,
            288546930,
            288552551,
            288553665,
            288542913,
            288552909,
            288551588
        ],
        "B": [
            288512906,
            288512626,
            288591954,
            288514323,
            288515612,
            288518687,
            288518565,
            288516062,
            288516991,
            288516923,
            288523730,
            288523890,
            288520786,
            288521682,
            288521503,
            288524297,
            288520697,
            288521668,
            288521796
        ],
        "A": [
            288510200,
            288515667,
            288594432,
            288510659,
            288510501,
            288510904,
            288511010,
            288517929,
            288511642,
            288510491,
            288516233,
            288511665,
            288510831,
            288512187,
            288514794,
            288512225,
            288511936,
            288512066,
            288512165
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135680",
    "editorial": "Let\u00e2\u0080\u0099s try to solve the problem without queries of type . This leads to a\r\ndata structure where elements are added to the end and removed from the\r\nbeginning. In other words, a queue. The query is a dynamic programming\r\nproblem of the \"knapsack\" type.To implement a knapsack on a queue, we\r\ncan use the technique of implementing a queue with two stacks. This is\r\ncommonly referred to as a \"queue with minimum\", as it is usually used to\r\nmaintain the minimum. You can read more about it on cp-algorithms. We\r\nreplace the operation of taking the minimum with the operation of adding\r\na new item to the knapsack in , where is the maximum price in the\r\nqueries. This gives us a solution with a time complexity of .Now, let\u00e2\u0080\u0099s\r\nreturn to the original problem. A type operation essentially adds the\r\nnecessity to make the data structure persistent. However, this is only\r\ntrue if we need to respond to queries in the order they are given. In\r\nthis problem, this is not the case we can try to transition to an\r\n\"offline\" solution.Let\u00e2\u0080\u0099s build a version tree of our persistent\r\nstructure. For each query of type , , or , create a new version. The\r\nedge between versions will store information about the type of change: a\r\nsimple copy, an addition of an element, or a deletion of an element.\r\nQueries of type will be stored in a list for each vertex to which they\r\nare addressed.We will perform a depth-first traversal of the version\r\ntree. During the transition along an edge, we need to be able to do the\r\nfollowing. If the transition is of the \"add element\" type, we need to\r\nadd the element to the end, then process the subtree of the vertex,\r\nanswer the queries for that vertex, and upon exiting, remove the element\r\nfrom the end. For a transition of the \"remove element\" type, we need to\r\nremove the element from the beginning and then add an element to the\r\nbeginning. Thus, a structure of the \"deque\" type is sufficient. It turns\r\nout that a deque that maintains a minimum also exists. You can read\r\nabout it in a blog by k1r1t0.Overall complexity: , where is the maximum\r\nprice in the queries.\r\n",
    "name": "F. Bermart Ice Cream",
    "statement": "In the Bermart chain of stores, a variety of ice cream is sold. Each\r\ntype of ice cream has two parameters: price and tastiness.Initially,\r\nthere is one store numbered 1, which sells nothing. You have to process\r\nq queries of the following types: 1\u00a0x a new store opens, that sells the\r\nsame types of ice cream as store x. It receives the minimum available\r\npositive index. The order of the types of ice cream in the new store is\r\nthe same as in store x. 2\u00a0x\u00a0p\u00a0t a type of ice cream with price p and\r\ntastiness t becomes available in store x. 3\u00a0x a type of ice cream that\r\nwas available the longest (appeared the earliest) in store x is removed.\r\n4\u00a0x\u00a0p for store x, find the maximum total tastiness of a subset of types\r\nof ice cream that are sold there, such that the total price does not\r\nexceed p (each type can be used in the subset no more than once).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std;\u00a0namespace std {\u00a0template<class Fun>class y_combinator_result {\tFun fun_;public:\ttemplate<class T>\texplicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\u00a0\ttemplate<class ...Args>\tdecltype(auto) operator()(Args &&...args) {\t\treturn fun_(std::ref(*this), std::forward<Args>(args)...);\t}};\u00a0template<class Fun>decltype(auto) y_combinator(Fun &&fun) {\treturn y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));}\u00a0} // namespace std\u00a0namespace ecnerwala {\u00a0using std::swap;\u00a0struct level_ancestor {\tint N;\tstd::vector<int> preorder;\tstd::vector<int> idx;\tstd::vector<std::pair<int, int>> heavyPar; // heavy parent, distance\tlevel_ancestor() : N(0) {}\u00a0\tlevel_ancestor(const std::vector<int>& par) : N(int(par.size())), preorder(N), idx(N), heavyPar(N) {\t\tstd::vector<std::vector<int>> ch(N);\t\tfor (int i = 0; i < N; i++) {\t\t\tif (par[i] != -1) ch[par[i]].push_back(i);\t\t}\t\tstd::vector<int> sz(N);\t\tint nxt_idx = 0;\t\tfor (int i = 0; i < N; i++) {\t\t\tif (par[i] == -1) {\t\t\t\tstd::y_combinator([&](auto self, int cur) -> void {\t\t\t\t\tsz[cur] = 1;\t\t\t\t\tfor (int nxt : ch[cur]) {\t\t\t\t\t\tself(nxt);\t\t\t\t\t\tsz[cur] += sz[nxt];\t\t\t\t\t}\t\t\t\t\tif (!ch[cur].empty()) {\t\t\t\t\t\tauto mit = max_element(ch[cur].begin(), ch[cur].end(), [&](int a, int b) { return sz[a] < sz[b]; });\t\t\t\t\t\tswap(*ch[cur].begin(), *mit);\t\t\t\t\t}\t\t\t\t})(i);\t\t\t\tstd::y_combinator([&](auto self, int cur, int isRoot = true) -> void {\t\t\t\t\tpreorder[idx[cur] = nxt_idx++] = cur;\t\t\t\t\tif (isRoot) {\t\t\t\t\t\theavyPar[idx[cur]] = {par[cur] == -1 ? -1 : idx[par[cur]], 1};\t\t\t\t\t} else {\t\t\t\t\t\tassert(idx[par[cur]] == idx[cur]-1);\t\t\t\t\t\theavyPar[idx[cur]] = heavyPar[idx[cur]-1];\t\t\t\t\t\theavyPar[idx[cur]].second++;\t\t\t\t\t}\t\t\t\t\tbool chRoot = false;\t\t\t\t\tfor (int nxt : ch[cur]) {\t\t\t\t\t\tself(nxt, chRoot);\t\t\t\t\t\tchRoot = true;\t\t\t\t\t}\t\t\t\t})(i);\t\t\t}\t\t}\t}\u00a0\tint get_ancestor(int a, int k) const {\t\tassert(k >= 0);\t\ta = idx[a];\t\twhile (a != -1 && k) {\t\t\tif (k >= heavyPar[a].second) {\t\t\t\tk -= heavyPar[a].second;\t\t\t\tassert(heavyPar[a].first <= a - heavyPar[a].second);\t\t\t\ta = heavyPar[a].first;\t\t\t} else {\t\t\t\ta -= k;\t\t\t\tk = 0;\t\t\t}\t\t}\t\tif (a == -1) return -1;\t\telse return preorder[a];\t}\u00a0\tint lca(int a, int b) const {\t\ta = idx[a], b = idx[b];\t\twhile (true) {\t\t\tif (a > b) swap(a, b);\t\t\tassert(a <= b);\t\t\tif (a > b - heavyPar[b].second) {\t\t\t\treturn preorder[a];\t\t\t}\t\t\tb = heavyPar[b].first;\t\t\tif (b == -1) return -1;\t\t}\t}\u00a0\tint dist(int a, int b) const {\t\ta = idx[a], b = idx[b];\t\tint res = 0;\t\twhile (true) {\t\t\tif (a > b) swap(a, b);\t\t\tassert(a <= b);\t\t\tif (a > b - heavyPar[b].second) {\t\t\t\tres += b - a;\t\t\t\tbreak;\t\t\t}\t\t\tres += heavyPar[b].second;\t\t\tb = heavyPar[b].first;\t\t\tif (b == -1) return -1;\t\t}\t\treturn res;\t}};\u00a0} // namespace ecnerwala\u00a0const int INF = 1e9;const int MAXW = 2000;\u00a0void solve(){\tint Q;\tcin >> Q;\tvector<int> par = {-1};\tvector<pair<int,int> > vtx_item = {{0, 0}}; // or undefined?\tvector<int> shop_count = {0};\tvector<int> shop_vtx = {0};\u00a0\tvector<tuple<int,int,int> > queries;\twhile(Q--){\t\tint type;\t\tcin >> type;\t\tif(type == 1){\t\t\tint x; cin >> x; x--;\t\t\tshop_count.push_back(shop_count[x]);\t\t\tshop_vtx.push_back(shop_vtx[x]);\t\t} else if(type == 3){\t\t\tint x; cin >> x; x--;\t\t\tshop_count[x]--;\t\t} else if(type == 2){\t\t\tint x; cin >> x; x--;\t\t\tint p, t;\t\t\tcin >> p >> t;\t\t\tint cur = (int)par.size();\t\t\tpar.push_back(shop_vtx[x]);\t\t\tvtx_item.push_back({p, t});\t\t\tshop_vtx[x] = cur;\t\t\tshop_count[x]++;\t\t} else if(type == 4){\t\t\tint x; cin >> x; x--;\t\t\tint p; cin >> p;\t\t\tqueries.push_back({shop_vtx[x], shop_count[x], p});\t\t} else assert(false);\t}\tint N = (int)par.size();\tvector<vector<tuple<int, int, int> > > edges(N);\tfor(int i = 1; i < N; i++){\t\tint v = i;\t\tint w = par[i];\t\tauto [p, t] = vtx_item[i];\t\tedges[v].push_back({w, p, t});\t\tedges[w].push_back({v, p, t});\t}\tecnerwala::level_ancestor lca(par);\u00a0\tvector<tuple<int, int, int> > real_queries;\tfor(auto [v, c, p] : queries){\t\tint w = lca.get_ancestor(v, c);\t\treal_queries.push_back({v, w, p});\t}\tvector<int> active(N, 1);\tvector<int> sz(N, 1);\tauto get_centroid = [&](int st) -> int {\t\tassert(active[st]);\t\ty_combinator([&](auto self, int v, int p) -> void {\t\t\tsz[v] = 1;\t\t\tfor(auto [w, _, __] : edges[v]){\t\t\t\tif(w == p) continue;\t\t\t\tif(!active[w]) continue;\t\t\t\tself(w, v);\t\t\t\tsz[v] += sz[w];\t\t\t}\t\t})(st, -1);\t\tint tsz = sz[st];\t\tint centroid = -1;\t\ty_combinator([&](auto self, int v, int p) -> void {\t\t\tif(sz[v] * 2 >= tsz) centroid = v;\t\t\tfor(auto [w, _, __] : edges[v]){\t\t\t\tif(w == p) continue;\t\t\t\tif(!active[w]) continue;\t\t\t\tself(w, v);\t\t\t}\t\t})(st, -1);\t\tassert(centroid != -1);\t\treturn centroid;\t};\tvector<int> all_queries;\tfor(int i = 0; i < (int)real_queries.size(); i++){\t\tall_queries.push_back(i);\t}\tvector<vector<int> > dp(N);\u00a0\tvector<int> qans(all_queries.size(), -1);\u00a0\tvector<int> which_subtree(N, -1);\ty_combinator([&](auto self, int v, vector<int> qids) -> void {\t\tv = get_centroid(v);\t\tmap<int, vector<int> > child_queries;\t\twhich_subtree[v] = v;\t\tdp[v] = vector<int>(MAXW+1, -INF);\t\tdp[v][0] = 0;\t\ty_combinator([&](auto self2, int cv, int cp) -> void {\t\t\tfor(auto [cw, p, t] : edges[cv]){\t\t\t\tif(cw == cp) continue;\t\t\t\tif(!active[cw]) continue;\u00a0\t\t\t\tvector<int> ndp = dp[cv];\t\t\t\tfor(int i = MAXW-p; i >= 0; i--){\t\t\t\t\tndp[i+p] = max(ndp[i+p], dp[cv][i] + t);\t\t\t\t}\t\t\t\tdp[cw] = ndp;\t\t\t\twhich_subtree[cw] = which_subtree[cv] == v ? cw : which_subtree[cv];\t\t\t\tself2(cw, cv);\t\t\t}\t\t})(v, -1);\t\tfor(int qid : qids){\t\t\tauto [qa, qb, qp] = real_queries[qid];\t\t\tif(qa == v || qb == v || which_subtree[qa] != which_subtree[qb]){\t\t\t\t// answer now\t\t\t\tint ans = 0;\t\t\t\tint lmax = 0;\t\t\t\tfor(int p = qp; p >= 0; p--){\t\t\t\t\tlmax = max(lmax, dp[qa][qp-p]);\t\t\t\t\tans = max(ans, lmax + dp[qb][p]);\t\t\t\t}\t\t\t\tqans[qid] = ans;\t\t\t} else {\t\t\t\tchild_queries[which_subtree[qa]].push_back(qid);\t\t\t}\t\t}\u00a0\t\t// auto is_desc = [&](int a, int b) -> bool {\t\t// \treturn lca.get_ancestor(a, lca.dist(a, b)) == b;\t\t// };\t\t// for(int qid : qids){\t\t// \tauto [qa, qb, qp] = real_queries[qid];\t\t// \tint l = lca.lca(qa, qb);\t\t// \tif(l == v){\t\t// \t\tqueries_here.push_back(qid);\t\t// \t} else if(is_desc(l, v)){\t\t// \t\tint d = lca.dist(l, v) - 1;\t\t// \t\tint w = lca.get_ancestor(l, d);\t\t// \t\tchild_queries[w].push_back(qid);\t\t// \t} else if(is_desc(v, l) && (is_desc(v, qa) || is_desc(v, qb))){\t\t// \t\tqueries_here.push_back(qid);\t\t// \t} else {\t\t// \t\tchild_queries[par[v]].push_back(qid);\t\t// \t}\t\t// }\u00a0\t\tactive[v] = 0;\t\tfor(auto [w, p, t] : edges[v]){\t\t\tif(!active[w]) continue;\t\t\tself(w, child_queries[w]);\t\t}\t})(0, all_queries);\tfor(int i = 0; i < (int)all_queries.size(); i++){\t\tcout << qans[i] << '\\n';\t}}\u00a0int main(){\tios_base::sync_with_stdio(false), cin.tie(nullptr);\tsolve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dp",
        "implementation",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Bermart Ice Cream.json"
}