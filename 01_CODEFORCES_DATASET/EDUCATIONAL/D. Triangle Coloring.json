{"link": "https://codeforces.com//contest/1795/problem/D", "problemId": "1785700", "problem_idx": "D", "shortId": "1795D", "contest_number": "1795", "problem_submissions": {"G": [193868249, 193922126, 193880640, 193880242, 193879883, 193877939, 193892319, 193909416, 193909281, 193909039, 193908855, 193907982, 193907256, 193907116, 193905885, 193905428, 193895936, 193894919, 193900585, 193900447, 193900331, 193900021, 193895212, 193901119, 193897399, 194065980, 193895350, 193897364, 193910352, 193909678, 193877594, 193901310, 193900708, 193909774, 193909664, 193908826, 193902609, 193895098, 193898582, 193887169, 193989778, 193903191, 193906575, 193901677], "E": [193858484, 193864061, 193860485, 193866472, 193870118, 193881494, 193869535, 193877440, 194065966, 193867450, 193873381, 193864290, 193872060, 193880762, 193876051, 193901176, 193882421, 193899122, 193881276, 193885055], "F": [193849592, 193871412, 193870619, 193880295, 193883585, 193866256, 193887756, 193901053, 193899102, 193887184, 194065972, 193879792, 193887970, 193889897, 193889600, 193879424, 193886027, 193888430, 193890811, 193880065, 193894847, 193891841], "D": [193842483, 193853701, 193849666, 193849500, 193854093, 193850355, 193858853, 193853243, 194065953, 193855818, 193855956, 193852941, 193856134, 193845600, 193859844, 193851729, 193849114, 193866588, 193860778, 193855517], "C": [193840570, 193847474, 193846113, 193844888, 193847932, 193844693, 193851549, 193846559, 194065943, 193849210, 193849704, 193847867, 193849903, 193858596, 193851945, 193847688, 193845368, 193860332, 193855373, 193849162], "B": [193839119, 193839637, 193839480, 193839407, 193839832, 193839202, 193842405, 193840503, 194065925, 193843321, 193841514, 193841857, 193840539, 193848293, 193839850, 193839356, 193839529, 193847088, 193842717, 193840388], "A": [193838910, 193838985, 193838946, 193838908, 193839007, 193838901, 193840204, 193839189, 194065914, 193839222, 193839386, 193882631, 193839087, 193843666, 193841139, 193839086, 193838960, 193838928, 193845036, 193840156, 193838911]}, "name": "D. Triangle Coloring", "statement": "You are given an undirected graph consisting of n vertices and n edges,\r\nwhere n is divisible by 6. Each edge has a weight, which is a positive\r\n(greater than zero) integer.The graph has the following structure: it is\r\nsplit into\r\nfrac{n}{3} triples of vertices, the first triple consisting of vertices\r\n1, 2, 3, the second triple consisting of vertices 4, 5, 6, and so on.\r\nEvery pair of vertices from the same triple is connected by an edge.\r\nThere are no edges between vertices from different triples.You have to\r\npaint the vertices of this graph into two colors, red and blue. Each\r\nvertex should have exactly one color, there should be exactly\r\nfrac{n}{2} red vertices and\r\nfrac{n}{2} blue vertices. The coloring is called valid if it meets these\r\nconstraints.The weight of the coloring is the sum of weights of edges\r\nconnecting two vertices with different colors.Let W be the maximum\r\npossible weight of a valid coloring. Calculate the number of valid\r\ncolorings with weight W, and print it modulo 998244353.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 16.02.2023 18:41:25       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  Mint ans = 1;\n  for (int i = 0; i < n; i += 3) {\n    vector<int> a(3);\n    for (int j = 0; j < 3; j++) {\n      cin >> a[j];\n    }\n    sort(a.begin(), a.end());\n    if (a[0] < a[1]) {\n      ans *= 1;\n    }\n    if (a[0] == a[1] && a[1] < a[2]) {\n      ans *= 2;\n    }\n    if (a[0] == a[1] && a[1] == a[2]) {\n      ans *= 3;\n    }\n  }\n  for (int i = n / 6 + 1; i <= n / 3; i++) {\n    ans *= i;\n  }\n  for (int i = 1; i <= n / 6; i++) {\n    ans /= i;\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "math"], "dificulty": "1600", "interactive": false}