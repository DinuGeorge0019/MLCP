{
    "link": "https://codeforces.com//contest/1651/problem/E",
    "problemId": "1324100",
    "problem_idx": "E",
    "shortId": "1651E",
    "contest_number": "1651",
    "problem_submissions": {
        "C": [
            149173723,
            149105792,
            149117381,
            149152549,
            149106514,
            149108421,
            149108464,
            149108635,
            149109429,
            149110791,
            149109777,
            149108515,
            149109773,
            149111699,
            149114619,
            149106949,
            149113559,
            149129766
        ],
        "F": [
            149161364,
            149158834,
            149161121,
            149123303,
            149175934,
            149179491,
            191725924,
            149575413
        ],
        "E": [
            149139170,
            149130164,
            149147455,
            149137360,
            149140976,
            149145909,
            149141908,
            149139460,
            149147248,
            149148678,
            149156290,
            149148881,
            149154274,
            149143485,
            149163314,
            149138047,
            149159145
        ],
        "D": [
            149127559,
            149163309,
            149150118,
            149115060,
            149119439,
            149116468,
            149116651,
            149118386,
            149120734,
            149121740,
            149119776,
            149192081,
            149191968,
            149191879,
            149191841,
            149191815,
            149191600,
            149191163,
            149191124,
            149128435,
            149129157,
            149129578,
            149116059,
            149145989,
            149116064
        ],
        "B": [
            149098208,
            149096317,
            149154308,
            149094973,
            149099387,
            149095439,
            149099190,
            149096388,
            149097486,
            149098725,
            149098039,
            149097903,
            149102336,
            149093030,
            149096020,
            149099865,
            149101390
        ],
        "A": [
            149092351,
            149091868,
            149155144,
            149091621,
            149091628,
            149091655,
            149091686,
            149091765,
            149091751,
            149092326,
            149091819,
            149092231,
            149094932,
            149091603,
            149091630,
            149091669,
            149092684
        ]
    },
    "name": "E. Sum of Matchings",
    "statement": "Let\u2019s denote the size of the maximum matching in a graph G as\r\nmathit{MM}(G).You are given a bipartite graph. The vertices of the first\r\npart are numbered from 1 to n, the vertices of the second part are\r\nnumbered from n+1 to 2n. .For a tuple of four integers (l, r, L, R),\r\nwhere 1\r\nle l\r\nle r\r\nle n and n+1\r\nle L\r\nle R\r\nle 2n, let\u2019s define G\u2019(l, r, L, R) as the graph which consists of all\r\nvertices of the given graph that are included in the segment [l, r] or\r\nin the segment [L, R], and all edges of the given graph such that each\r\nof their endpoints belongs to one of these segments. In other words, to\r\nobtain G\u2019(l, r, L, R) from the original graph, you have to remove all\r\nvertices i such that i\r\nnotin [l, r] and i\r\nnotin [L, R], and all edges incident to these vertices.Calculate the sum\r\nof\r\nmathit{MM}(G(l, r, L, R)) over all tuples of integers (l, r, L, R)\r\nhaving 1\r\nle l\r\nle r\r\nle n and n+1\r\nle L\r\nle R\r\nle 2n.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    vector<vi> G(N*2);\n    F0R(i, N*2) {\n        int X, Y; cin >> X >> Y; X--; Y--;\n        G[X].pb(Y); G[Y].pb(X);\n    }\n\n    bool vis[2*N]; F0R(i, 2*N) vis[i] = false;\n    vector<vi> cyc;\n    F0R(i, N) {\n        if (vis[i]) continue;\n        int v = i;\n        vi cur; cur.pb(v);\n        vis[v] = true;\n        v = G[v][0];\n        while (v != i) {\n            cur.pb(v);\n            vis[v] = true;\n            if (G[v][0] == cur[sz(cur) - 2]) {\n                v = G[v][1];\n            } else v = G[v][0];\n        }\n        cyc.pb(cur);\n    }\n    //dbg(cyc);\n\n    ll ans = 0;\n    trav(c, cyc) {\n        int K = sz(c);\n        F0R(i, K) {\n            int hx = -1, lx = MX, hy = -1, ly = MX;\n            F0R(d, K) {\n                int j = i + d;\n                if (d == K-1 && i != 0) break;\n                int p = j%K;\n                if (c[p] < N) {\n                    ckmax(hx, c[p]);\n                    ckmin(lx, c[p]);\n                } else {\n                    ckmax(hy, c[p] - N);\n                    ckmin(ly, c[p] - N);\n                }\n                int blx = -1, bhx = N, bhy = N, bly = -1;\n                vi pos = {(j+1)%K, (i+K-1)%K};\n                if (d != K-1) {\n                    trav(b, pos) {\n                        int a = c[b];\n                        if (a < N) {\n                            if (lx < a && a < hx) goto done;\n                            if (lx > a) ckmax(blx, a);\n                            if (a > hx) ckmin(bhx, a);\n                        } else {\n                            a -= N;\n                            if (ly < a && a < hy) goto done;\n                            if (ly > a) ckmax(bly, a);\n                            if (a > hy) ckmin(bhy, a);\n                        }\n                    }\n                }\n                /*if (i == 0 && j == 1) {\n                    dbg(lx, hx, ly, hy, blx, bhx, bly, bhy, pos);\n                }*/\n                if (d > 0 && blx < lx && bhx > hx && bly < ly && bhy > hy) {\n                    ans += ((ll) d+1)/2 * (lx-blx) * (bhx - hx) * (ly - bly) * (bhy - hy);\n                }\n\n                done:\n                ;\n            }\n        }\n    }\n    cout << ans << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "dfs and similar",
        "graph matchings",
        "greedy",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Sum of Matchings.json",
    "editorial_link": "https://codeforces.com//blog/entry/100796",
    "editorial": "Instead of counting the edges belonging to the maximum matching, it is\r\neasier to count the vertices. So, we will calculate the total number of\r\nvertices saturated by the maximum matching over all possible tuples ,\r\nand then divide the answer by . Furthermore, it\u00e2\u0080\u0099s easier to calculate\r\nthe number of unsaturated vertices than the number of saturated\r\nvertices, so we can subtract it from the total number of vertices in all\r\ngraphs we consider and obtain the answer.Let\u00e2\u0080\u0099s analyze how to calculate\r\nthe total number of unsaturated vertices. Each graph is a subgraph of\r\nthe given graph, so it is still bipartite, and the degree of each vertex\r\nis still not greater than . A bipartite graph where the degree of each\r\nvertex is at most can be represented as a set of cycles and paths, and\r\nthe maximum matching over each of these cycles/paths can be considered\r\nindependently. Each cycle has an even number of vertices (since\r\notherwise the graph would not be bipartite), so we can saturate all\r\nvertices on a cycle with the matching. For a path, the number of\r\nunsaturated vertices depends on its length: if the number of vertices in\r\na path is even, we can match all vertices on it; otherwise, one vertex\r\nwill be unsaturated. So the problem reduces to counting paths with odd\r\nnumber of vertices in all possible graphs .Every path with an odd number\r\nof vertices has a center (the vertex which is exactly in the middle of\r\nthe path). Let\u00e2\u0080\u0099s iterate on the center of the path and its length, and\r\ncalculate the number of times this path occurs in all graphs we\r\nconsider. Suppose the center of the path is the vertex , and the number\r\nof vertices in it is . Then, for this path to exist, two conditions must\r\nhold: every vertex such that the distance from to is not greater than\r\nshould be present in the graph; every vertex such that the distance from\r\nto is should be excluded from the graph. It means that, for each of the\r\ntwo parts of the graph, there are several vertices that should be\r\npresent in the graph, and zero or two vertices that should be excluded\r\nfrom the graph. It\u00e2\u0080\u0099s easy to see that among the vertices we have to\r\ninclude, we are only interested in the minimum one and the maximum one\r\n(all vertices between them will be included as well if these two are\r\nincluded). So, we need to implement some kind of function that allows us\r\nto calculate the number of segments that cover the minimum and the\r\nmaximum vertex we need, and don\u00e2\u0080\u0099t cover any of the vertices that we have\r\nto exclude this can be easily done in . Note that the segments should be\r\nconsidered independently for both parts of the graph.Overall, for each\r\nvertex we have to consider at most different lengths of odd paths with\r\nthe center in this vertex. The minimum/maximum indices of vertices in\r\nboth parts we have to include in the graph can be maintained while we\r\nincrease the length of the path, so the whole solution works in .\r\n"
}