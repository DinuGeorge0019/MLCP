{
    "link": "https://codeforces.com//contest/1849/problem/D",
    "problemId": "2121801",
    "problem_idx": "D",
    "shortId": "1849D",
    "contest_number": "1849",
    "problem_submissions": {
        "F": [
            215983324,
            215952856,
            215937825,
            216386632,
            215955686,
            215953676,
            215963177,
            215957010,
            215951070,
            215964780,
            216982954,
            215957194,
            215972632,
            215944919,
            215944313,
            215955103,
            215959952,
            215969003,
            215980309,
            215974158,
            215944399,
            215979671,
            215977278
        ],
        "E": [
            215924453,
            215947662,
            216386610,
            215933511,
            215933733,
            215934077,
            215914493,
            215965756,
            215977352,
            215941711,
            233941264,
            215936437,
            215935391,
            215977463,
            215969180,
            215945577,
            215912738,
            215939893,
            215950899,
            215934318,
            215964596,
            215959218,
            215957991,
            215955934
        ],
        "D": [
            215901738,
            215911695,
            216386594,
            215909113,
            215918034,
            215916358,
            215933169,
            215909241,
            215922975,
            234220985,
            215915496,
            215918649,
            215921028,
            215919624,
            215925910,
            215965913,
            215944986,
            215923778,
            215918733,
            215917075,
            215927258,
            215909167,
            215930917
        ],
        "C": [
            215896251,
            215894479,
            216386570,
            215900243,
            215896179,
            215907225,
            215897874,
            215899171,
            215913186,
            216103314,
            215910665,
            215904112,
            215906218,
            215893558,
            215913416,
            215898003,
            215913451,
            215905641,
            215906717,
            215916261,
            215893733,
            215907522
        ],
        "B": [
            215891011,
            215887978,
            215890857,
            215886817,
            215889862,
            215890551,
            215889747,
            215890405,
            216103286,
            215904981,
            215895899,
            215891636,
            215886438,
            215894588,
            215888040,
            215888730,
            215892001,
            215891534,
            215895784,
            215887055,
            215895512
        ],
        "A": [
            215887103,
            215884849,
            215885125,
            215884783,
            215885307,
            215885029,
            215884781,
            215885053,
            216103329,
            215902406,
            215889192,
            215885764,
            215884723,
            215885605,
            215884732,
            215884795,
            215885200,
            215885812,
            215885953,
            215884704,
            215884853
        ]
    },
    "name": "D. Array Painting",
    "statement": "You are given an array of n integers, where each integer is either 0, 1,\r\nor 2. Initially, each element of the array is blue.Your goal is to paint\r\neach element of the array red. In order to do so, you can perform\r\noperations of two types: pay one coin to choose a blue element and paint\r\nit red; choose a red element which is not equal to 0 and a blue element\r\nto it, decrease the chosen red element by 1, and paint the chosen blue\r\nelement red. What is the minimum number of coins you have to spend to\r\nachieve your goal?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> r(n);\n    std::iota(r.begin(), r.end(), 0);\n    \n    std::vector<int> lst(n, 0), nxt(n, n - 1);\n    for (int i = 0; i < n - 1; i++) {\n        lst[i + 1] = a[i] == 0 ? i : lst[i];\n    }\n    for (int i = n - 1; i > 0; i--) {\n        nxt[i - 1] = a[i] == 0 ? i : nxt[i];\n    }\n    for (int i = 0; i < n; i++) {\n        if (a[i] == 1) {\n            r[lst[i]] = std::max(r[lst[i]], i);\n            r[i] = std::max(r[i], nxt[i]);\n        } else if (a[i] == 2) {\n            r[lst[i]] = std::max(r[lst[i]], nxt[i]);\n        }\n    }\n    \n    for (int i = 1; i < n; i++) {\n        r[i] = std::max(r[i], r[i - 1]);\n    }\n    \n    int ans = 0;\n    for (int i = 0; i < n; i = r[i] + 1) {\n        ans++;\n    }\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Array Painting.json",
    "editorial_link": "https://codeforces.com//blog/entry/118752",
    "editorial": "Suppose we used a second operation as follows: we decreased a red\r\nelement , and painted another element red. Let\u00e2\u0080\u0099s then say that is the of\r\n.Furthermore, let\u00e2\u0080\u0099s say that the element the element if one of the two\r\nconditions applies: is the parent of ; controls the parent of . Now,\r\nsuppose we used coins to paint some elements red. For each of those\r\nelements, there exists a segment of red elements which it controls. So,\r\nthe problem can actually be reformulated as follows: we want to split\r\nthe given array into the minimum number of segments so that each segment\r\ncan be painted using one coin. Let\u00e2\u0080\u0099s call a segment of the array if it\r\ncan be painted using only one coin.To continue with our solution, we\r\nneed the following property: if a segment is , then its every subsegment\r\nis also good. This is kinda intuitive, but if you are interested in a\r\nformal proof, you can read the following paragraph.Since if a segment is\r\ngood, its every subsegment is also good, we can use the following greedy\r\napproach to solve the problem: start with the segment which contains\r\nonly the first element of the array, and expand it to the right until it\r\nbecomes bad. When the segment is no longer good, we need to start a new\r\nsegment, which we will again expand to the right until it becomes bad,\r\nand so on. Then each element of the array will be considered only once.\r\nIf we design a way to determine if the segment is still good when we add\r\na new element to it in , our solution will work in .All that\u00e2\u0080\u0099s left is\r\nto analyze how to check if the segment is good. There are multiple ways\r\nto do this. The way used in the model solution employs the following\r\nideas: there cannot be any zeroes in the middle of the segment, since if\r\nwe start painting red from the left of that zero, we cannot reach the\r\nelements to the right of that zero, and vice versa; if there are no\r\nzeroes in the middle, and at least one of the endpoints is not zero, the\r\nsegment is good because we can just start from that endpoint and expand\r\nto the other endpoint; if there are no zeroes in the middle, and there\r\nis at least one element equal to , we can start by painting that element\r\nred and expand to the left and to the right of it until we arrive at the\r\nborders of the segment; and if there are zeroes at both endpoints, but\r\nall other elements are \u00e2\u0080\u0099s, it\u00e2\u0080\u0099s easy to see that paining the whole\r\nsegment using only one coin is impossible: the sum of elements on the\r\nsegment is , where is the length of the segment, but we need to paint at\r\nleast elements red without spending coins. All of these ideas allow us\r\nto verify that the segment is good using just a couple\r\nif-statements.Solution complexity: .\r\n"
}