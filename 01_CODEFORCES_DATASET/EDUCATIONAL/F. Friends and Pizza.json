{
    "link": "https://codeforces.com//contest/2070/problem/F",
    "problemId": "3233355",
    "problem_idx": "F",
    "shortId": "2070F",
    "contest_number": "2070",
    "problem_submissions": {
        "F": [
            308138412,
            308139598,
            308140261,
            308135086,
            308908838,
            308908402,
            308148058,
            308132721,
            308156502,
            308160384,
            308171018,
            308167755,
            308165459,
            308169840,
            308157047,
            308169763,
            308168481,
            308160062,
            308168693,
            308165415,
            308163695,
            308171178,
            308169858,
            308170143,
            308112373,
            308154384
        ],
        "E": [
            308118136,
            308123977,
            308115696,
            308119993,
            308121221,
            308160669,
            308139138,
            308136015,
            308135014,
            308127816,
            308146323,
            308144103,
            308131271,
            308145219,
            308126468,
            308144951,
            308131787,
            308146433,
            308129269,
            308170336
        ],
        "D": [
            308106225,
            308103599,
            308103669,
            308108885,
            308112445,
            308106317,
            308115443,
            308108990,
            308111970,
            308115191,
            308111541,
            308110510,
            308111609,
            308122150,
            308114708,
            308128882,
            308117643,
            308118502,
            308133018,
            308115402
        ],
        "C": [
            308100859,
            308098324,
            308098879,
            308109896,
            308106577,
            308101095,
            308107090,
            308102322,
            308104592,
            308108143,
            308104331,
            308111140,
            308106216,
            308114471,
            308109710,
            308123284,
            308111358,
            308110052,
            308140320,
            308124878
        ],
        "B": [
            308096187,
            308093094,
            308093408,
            308096114,
            308095735,
            308094203,
            308101217,
            308098141,
            308098911,
            308093342,
            308098262,
            308097763,
            308099852,
            308108770,
            308099377,
            308099819,
            308097452,
            308104146,
            308143559,
            308098413
        ],
        "A": [
            308091489,
            308091216,
            308091213,
            308091721,
            308091212,
            308091326,
            308095453,
            308091596,
            308092398,
            308091301,
            308091697,
            308091411,
            308091275,
            308091454,
            308091384,
            308091843,
            308091304,
            308091461,
            308145036,
            308091695
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140146",
    "editorial": "Before solving this problem, I highly recommend that you learn Sum over\r\nSubsets Dynamic Programming (aka SOS DP), if you don’t know it yet. For\r\nexample, you can use this CF blog, it has a great explanation of SOS DP:\r\nhttps://codeforces.com/blog/entry/45223First, we will somewhat change\r\nthe problem. The original problem wants us to consider all pairs of\r\nfriends where ; but instead, we will consider all pairs of friends where\r\n(so, can be greater than and can even be equal to ). After solving this\r\nmodified version, we can \"subtract\" all pairs where (since there are\r\nonly of them) and divide all the answers by to get rid of the pairs\r\nwhere (they are symmetrical to , so they yield the same answer). From\r\nnow on, we consider only the version where we need to count all pairs of\r\nfriends.For every friend, we can transform the string into a bit mask\r\nwhich shows what pizzas that friend likes. Then, checking if the friends\r\nquarrel and which pizzas they will eat can be done by bit operations on\r\ntheir masks: if the bitwise AND of their masks and the mask of odd-size\r\npizzas is non-zero, there is at least one odd-size pizza they both like,\r\nso they will quarrel; and the mask of pizzas they will eat is just the\r\nbitwise OR of their masks.So, if for each mask, we want to calculate the\r\nnumber of pairs of friends which don’t quarrel and result in exactly\r\nthat mask being eaten, we can run the following code:Or, if for each\r\nmask, we calculate as the number of friends having that mask, we can\r\nrewrite it as follows:Let’s first consider two special instances of this\r\nproblem, and then we’ll combine their solutions to solve the general\r\ncase.Then our mask of add pizzas is , so friends will never quarrel. In\r\nthis case, we can rewrite the \"naive\" code as follows:This is an OR\r\nconvolution of the sequence with itself, and it can be calculated much\r\nfaster than . When dealing with regular convolutions, a fast way to\r\ncalculate them is the following one: Transform the sequences using FFT\r\nor NTT. Multiply the corresponding elements of the transformed\r\nsequences. Perform the inverse transformation. OR convolution can be\r\ndone in the same way, but instead of FFT or NTT, we will use SOS DP. So,\r\nan OR convolution of two sequences and looks like that:Why does SOS DP\r\ndo the trick? means that is the sum of over all and that are submasks of\r\n. For some pairs , their bitwise OR is exactly ; but for others, their\r\nbitwise OR is a submask of . So, actually, is the sum over submasks of\r\nthe sequence we need to obtain, so by applying inverse SOS DP (the\r\ntransformation which returns the sequence by its sums over submasks), we\r\nget exactly what we need..Okay, the instance when all pizzas have even\r\nsize is done. Next, we haveThe \"naive\" code would look like\r\nthat:Unfortunately, this is much trickier. This is called Fast Subset\r\nConvolution, and to do it faster, we have to add another dimension to\r\nour sequence. Now suppose we want to get the FSC of sequences and , and\r\nthe resulting sequence is named .If the bitwise OR of and is , and the\r\nbitwise AND of and is , then (the number of bits set to in is equal to .\r\nSo, the value of can be represented as the sum of over all such that the\r\nbitwise OR of and is , and .Let’s transform our given sequences of\r\nlength into two-dimensional matrices of size . Let be if , or if .\r\nSimilarly, we denote based on .Okay, now let’s try to make it so that,\r\nin the resulting convolution, the product ends up in the cell , where\r\ndenotes bitwise OR. To do this, let’s evaluate the -th row of as the\r\nfollowing sum: . The OR Convolution will make sure that, for every pair\r\nof , ends up in some cell of the form , and to verify that their bitwise\r\nAND is , we can check that . So, the resulting value of we want to get\r\nis equal to .This Fast Subset Convolution can be done in if you apply\r\nSOS DP to every row of and to get matrices with sums over submasks in\r\neach row (let’s call them and ), calculate , and then apply Inverse SOS\r\nDP to each row of to get the matrix .Okay, now back to the original\r\nproblem.We need to make a convolution for which some bits (represending\r\neven-sized pizzas) work as in OR Convolution, but other bits\r\n(representing odd-sized pizzas) work as in Fast Subset Convolution. The\r\nkey idea is that we can modify Fast Subset Convolution so that it tracks\r\nonly the number of bits representing odd-sized pizzas. So, let’s define\r\nas the number of bits representing odd-sized pizzas in . So, when we\r\ntransform the given sequences and to the matrices and , we set to if ,\r\nor if . And our matrices will have size , where is the number of\r\nodd-sized pizzas. Note that, in our problem, the sequences and are the\r\nsame, so the matrix is actually the same as .Similarly, to get the\r\nsequence from the matrix , we set .This modification of Fast Subset\r\nConvolution works in . Since , we get a solution working in (the summand\r\ncomes from processing the friends and converting them into masks).\r\n",
    "name": "F. Friends and Pizza",
    "statement": "Monocarp has n pizzas, the i-th pizza consists of a_i slices. Pizzas are\r\ndenoted by uppercase Latin letters from to the n-th letter of the Latin\r\nalphabet.Monocarp also has m friends, and he wants to invite of them to\r\neat pizza. For each friend, Monocarp knows which pizzas that friend\r\nlikes.After the friends arrive at Monocarp’s house, for each pizza, the\r\nfollowing happens: if the pizza is not liked by any of the two invited\r\nfriends, Monocarp eats it; if the pizza is liked by exactly one of the\r\ntwo invited friends, that friend eats it; and if the pizza is liked by\r\nboth friends, they try to split it. If it consists of an even number of\r\nslices, they both eat exactly half of the slices. But if the pizza\r\nconsists of an odd number of slices, they start quarrelling, trying to\r\ndecide who will eat an extra slice and Monocarp doesn’t like that. For\r\neach k from 0 to\r\nsum a_i, calculate the number of ways to choose to invite so that the\r\nfriends don’t quarrel, and Monocarp eats exactly k slices.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "divide and conquer",
        "dp",
        "fft"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Friends and Pizza.json"
}