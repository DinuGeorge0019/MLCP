{
    "link": "https://codeforces.com//contest/954/problem/C",
    "problemId": "167340",
    "problem_idx": "C",
    "shortId": "954C",
    "contest_number": "954",
    "problem_submissions": {
        "I": [
            36483613,
            36489921,
            36491468,
            36492587,
            36489151,
            36505182,
            36498444,
            36489158,
            36493599,
            36495253,
            36493983,
            36523197,
            36517457,
            36494315,
            36517490
        ],
        "E": [
            36478770,
            36477321,
            36476296,
            36476332,
            36477191,
            36479277,
            36478407,
            36484072,
            36476637,
            36483722,
            36476830,
            36479359,
            36479273,
            36481624,
            36479515,
            36473956,
            36477339,
            36477449,
            36476422,
            36481260
        ],
        "D": [
            36478485,
            36475307,
            36474083,
            36478258,
            36474970,
            36476455,
            36476263,
            36472023,
            36474824,
            36478016,
            36474200,
            36476982,
            36476891,
            36474372,
            36477175,
            36479984,
            36487971,
            36474275,
            36474076,
            36475466
        ],
        "C": [
            36476002,
            36474037,
            36473020,
            36474296,
            36473832,
            36473968,
            36474218,
            36474540,
            36483525,
            36476724,
            36472809,
            36474171,
            36499291,
            36473004,
            36474442,
            36477242,
            36486700,
            36473123,
            36472782,
            36473808
        ],
        "G": [
            36475037,
            36479869,
            36479819,
            36482297,
            36479701,
            36481399,
            36480184,
            36480325,
            36481161,
            36480550,
            36485383,
            36482231,
            36482668,
            36492299,
            36483624,
            36487406,
            36490213,
            36485274,
            36478330,
            36479287
        ],
        "F": [
            36474930,
            36486416,
            36483404,
            36528491,
            36484207,
            36482822,
            36485630,
            36483061,
            36477477,
            36481839,
            36487500,
            36482960,
            36488051,
            36485000,
            36479677,
            36489393,
            36482816,
            36484976,
            36483377,
            36483862,
            36487177
        ],
        "H": [
            36473564,
            36483628,
            36486927,
            36487388,
            36497291,
            36492759,
            36492641,
            36496336,
            36493059,
            36491960,
            36490810,
            36488245,
            36487713,
            36489798,
            36483087
        ],
        "B": [
            36472231,
            36471541,
            36471094,
            36471718,
            36471325,
            36471918,
            36470816,
            36471290,
            36470543,
            36472680,
            36470969,
            36471052,
            36470688,
            36471049,
            36472812,
            36475352,
            36471581,
            36471121,
            36470814,
            36470886
        ],
        "A": [
            36470941,
            36470615,
            36469920,
            36470743,
            36470038,
            36470789,
            36469978,
            36470246,
            36469943,
            36471510,
            36470178,
            36469918,
            36469982,
            36470334,
            36471516,
            36475017,
            36470944,
            36470503,
            36470133,
            36470029
        ]
    },
    "name": "C. Matrix Walk",
    "statement": "There is a matrix of size filled with integers. For every , . Obviously,\r\nevery integer from occurs exactly once in this matrix. You have\r\ntraversed some path in this matrix. Your path can be described as a\r\nsequence of visited cells , , ..., denoting that you started in the cell\r\ncontaining the number , then moved to the cell with the number , and so\r\non.From the cell located in -th line and -th column (we denote this cell\r\nas ) you can move into one of the following cells: only if ; only if ;\r\nonly if ; only if .Notice that making a move requires you to go to an\r\nadjacent cell. It is not allowed to stay in the same cell. You don\u2019t\r\nknow and exactly, but you have to find any possible values for these\r\nnumbers such that you could start in the cell containing the integer ,\r\nthen move to the cell containing (in one step), then move to the cell\r\ncontaining (also in one step) and so on. Can you choose and so that they\r\ndon\u2019t contradict with your sequence of moves?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define MN 200005\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,M,mx,a[MN];\nint main()\n{\n\tregister int i,x,y;\n\tn=read();\n\tfor (i=1;i<=n;++i) mx=max(mx,a[i]=read());\n\tfor (i=2;i<=n;++i)\n\t\tif ((y=abs(a[i]-a[i-1]))>1)\n\t\t\tif (M) {if (M!=y) return 0*printf(\"NO\");}\n\t\t\telse M=y;\n\t\telse if (y==0) return 0*printf(\"NO\");\n\tif (!M) return 0*printf(\"YES\\n1 %d\",mx);\n\tfor (i=2;i<=n;++i)\n\t\tif (abs(a[i]-a[i-1])==1)\n\t\t\tif (min(a[i],a[i-1])%M==0) return 0*printf(\"NO\");\n\tputs(\"YES\");\n\tprintf(\"%d %d\",(mx-1)/M+1,M);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Matrix Walk.json",
    "editorial_link": "https://codeforces.com//blog/entry/58519",
    "editorial": "You can notice that moves of kind and are changing value to and . Thus,\r\nyou can determine by checking adjacent nodes in the path. The answer is\r\nif there are one or zero distinct values of differences not counting\r\ndifference of .You can also set to arbitrary big value, it doesn\u00e2\u0080\u0099t\r\nreally matter until you can fit all values. will work just fine.Finally,\r\nknowing and , simulate the process and check that all moves are\r\nvalid.Overall complexity: .\r\n"
}