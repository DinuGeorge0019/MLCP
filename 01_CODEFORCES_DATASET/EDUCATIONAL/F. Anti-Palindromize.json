{"link": "https://codeforces.com//contest/884/problem/F", "problemId": "130892", "problem_idx": "F", "shortId": "884F", "contest_number": "884", "problem_submissions": {"F": [31808128, 31809259, 31810428, 31811126, 31807028, 31810125, 31808407, 31808014, 31873745, 31808068, 31810481, 70767801, 36469296, 36469289, 31909919, 31809387, 31822510, 31808175, 31811034], "E": [31805401, 31807388, 31807565, 31808478, 31804019, 31805975, 31805687, 31805755, 31841462, 31810079, 31810699, 31810217, 31811063, 31809732, 31810149], "D": [31802703, 31804699, 31804124, 31804641, 31808138, 31803343, 31802113, 31801774, 31802510, 31803536, 31804976, 31801949, 31805944, 31805607, 31803821, 31809103, 31803969, 31818412, 31806095], "C": [31800883, 31800607, 31802838, 31802069, 31799616, 31802362, 31800429, 31800236, 31800839, 31801291, 31801670, 31800496, 31801796, 31802338, 31801055, 31801861, 31801455, 31800685, 31802138], "B": [31799211, 31799036, 31801939, 31801321, 31801497, 31798756, 31799168, 31799265, 31799895, 31799341, 31799382, 31800133, 31800205, 31799009, 31800238, 31799378, 31799257, 31800274], "A": [31798352, 31798382, 31801358, 31800677, 31801116, 31798306, 31798460, 31798672, 31798979, 31798397, 31798744, 31798807, 31798611, 31798307, 31798790, 31798478, 31798275, 31799367]}, "name": "F. Anti-Palindromize", "statement": "A string of length is called iff is even, and for each () .Ivan has a\r\nstring consisting of lowercase Latin letters; is even. He wants to form\r\nsome string that will be an permutation of . Also Ivan has denoted the\r\nof index as , and the of as the sum of among all indices such that .Help\r\nIvan to determine maximum possible of he can get.\r\n", "solutions": ["#include <iterator>\n#include <map>\n#include <functional>\n#include <cstdio>\n#include <array>\n#include <utility>\n#include <vector>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nchar S[1234];\nint B[5678];\n\nint main()\n{\n    int N;\n    RD(N, S);\n    RDV(B, B + N);\n\n    int sum = 0;\n    for(int i: RG(N))\n        sum += B[i];\n\n    vector<int> cad[2];\n    for(int i: RG(N / 2))\n        cad[S[i] == S[N - 1 - i]].push_back(i);\n    \n    int k = cad[1].size();\n    \n    int alc[26] = {};\n    for(int idx: cad[1])\n        alc[S[idx] - 'a']++;\n    int check = -1;\n    for(int i: RG(26))\n        if(alc[i] > k / 2)\n            check = i;\n\n    for(int idx: cad[1])\n        sum -= min(B[idx], B[N - 1 - idx]);\n\n    if(check == -1)\n    {\n        WTL(sum);\n        return 0;\n    }\n \n    vector<int> cc;\n    for(int idx: cad[0])\n        if(S[idx] - 'a' != check && S[N - 1 - idx] - 'a' != check)\n            cc.push_back(min(B[idx], B[N - 1 - idx]));\n    sort(cc.begin(), cc.end());\n    for(int i: RG(2 * alc[check] - k))\n        sum -= cc[i];\n    WTL(sum);\n\n\n}\n\n\n\n\n"], "input": "", "output": "", "tags": ["flows", "graphs", "greedy"], "dificulty": "2500", "interactive": false}