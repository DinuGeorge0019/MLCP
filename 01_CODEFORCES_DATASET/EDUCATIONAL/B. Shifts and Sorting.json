{
    "link": "https://codeforces.com//contest/1969/problem/B",
    "problemId": "2619518",
    "problem_idx": "B",
    "shortId": "1969B",
    "contest_number": "1969",
    "problem_submissions": {
        "F": [
            258740971,
            258740820,
            258746132,
            258746716,
            258755183,
            258754014,
            258764616,
            258761581,
            258761069,
            258757448,
            258733006,
            258743321,
            258792091,
            258769461
        ],
        "E": [
            258725328,
            258720683,
            258724478,
            258731693,
            258756331,
            258755767,
            258736057,
            258804715,
            258733183,
            258735874,
            258730875,
            258757457,
            258749091,
            258722655,
            258724259,
            258731836,
            258735531,
            258733424,
            258733392,
            258730397,
            258733010,
            258733415,
            258736757
        ],
        "D": [
            258715496,
            258711950,
            258717455,
            258715807,
            258715309,
            258717478,
            258718891,
            258722961,
            258744444,
            258753841,
            258715868,
            258714258,
            258718192,
            258717839,
            258720978,
            258721300,
            258722241,
            258769261,
            258723656,
            258722483,
            258717125
        ],
        "C": [
            258709519,
            258714184,
            258710089,
            258708902,
            258709129,
            258711287,
            258711586,
            258731391,
            258739788,
            258758308,
            258709210,
            258714988,
            258712692,
            258710594,
            258712746,
            258713533,
            258716060,
            258713283,
            258715693,
            258710630
        ],
        "B": [
            258705054,
            258704158,
            258705135,
            258705001,
            258705619,
            258707939,
            258707446,
            258706758,
            258736445,
            258759399,
            258704770,
            258705679,
            258707425,
            258706710,
            258706746,
            258707793,
            258708419,
            258705968,
            258708957,
            258706188
        ],
        "A": [
            258703665,
            258703553,
            258703758,
            258703560,
            258703556,
            258703637,
            258704655,
            258703660,
            258734943,
            258760234,
            258703586,
            258703687,
            258704850,
            258703730,
            258703995,
            258703579,
            258704091,
            258703811,
            258704619,
            258703722
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129022",
    "editorial": "Let\u00e2\u0080\u0099s look at the operation as the following: you choose , erase the\r\nelement at position and then insert it before the element at position .\r\nWe can also interpret the cost of such operation as the following: you\r\npay for the element at position you \"teleport\" to the left and for each\r\nelement you teleport through (element inside segment ).Now let\u00e2\u0080\u0099s look at\r\ntwo indices where and . Since at the end, all zeroes should be before\r\nones, you have to move to the left of . But the only thing that moves to\r\nthe left is element , so you have to make at least one operation ending\r\nat .What does it mean? It means: for every that has at least one , you\r\nhave to pay at least for teleporting it to the left; for every , if\r\nthere are -s , you have to pay at least , since each zero should be\r\nteleported through this . The thoughts above gave us the lower bound on\r\nthe answer, and it\u00e2\u0080\u0099s not hard to come up with some constructive\r\nalgorithms that will give us exactly that cost.To calculate the lower\r\nbound, you just need to maintain some info while iterating from left to\r\nright: for example, the number of -s and -s to the left of the current\r\nposition and the total number of -s in . It\u00e2\u0080\u0099s enough to check: is there\r\nany to the left of the current position, and how many -s are to the\r\nright.Instead of calculating the lower bound itself, you can also\r\nimplement one of the algorithms that reach that lower bound, and it may\r\nbe even a little easier.\r\n",
    "name": "B. Shifts and Sorting",
    "statement": "Let\u2019s define a of some string s as a transformation from s_1 s_2\r\ndots s_{n-1} s_{n} into s_{n} s_1 s_2\r\ndots s_{n-1}. In other words, you take one last character s_n and place\r\nit before the first character while moving all other characters to the\r\nright.You are given a binary string s (a string consisting of only -s\r\nand/or -s).In one operation, you can choose any substring s_l s_{l+1}\r\ndots s_r (1\r\nle l < r\r\nle |s|) and cyclically shift it. The of such operation is equal to r -\r\nl + 1 (or the length of the chosen substring).You can perform the given\r\noperation any number of times. What is the minimum cost to make s sorted\r\nin non-descending order?\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"#pragma GCC optimize (\"O3\")#pragma GCC target (\"sse4\") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd;\u00a0template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert\u00a0template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\u00a0void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << '\\'' << x << '\\'';}void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}void __print(bool x) {cerr << (x ? \"true\" : \"false\");}\u00a0template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}template<typename T>void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}void _print() {cerr << \"]\\n\";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;#else#define dbg(x...)#endif\u00a0\u00a0const int MOD = 1000000007;const char nl = '\\n';const int MX = 100001; \u00a0void solve() {    string S; cin >> S;    ll ans = 0;    ll cnt = 0;    F0R(i, sz(S)) {        if (S[i] == '1') {            cnt++;        } else {            if (cnt > 0) {                ans += cnt+1;            }        }    }    cout << ans << nl;\u00a0} int main() {    ios_base::sync_with_stdio(0); cin.tie(0);\u00a0    int T = 1;    cin >> T;    while(T--) {        solve();    }\u00a0\treturn 0;}\u00a0\u00a0"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Shifts and Sorting.json"
}