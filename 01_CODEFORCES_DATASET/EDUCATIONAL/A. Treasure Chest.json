{
    "link": "https://codeforces.com//contest/1895/problem/A",
    "problemId": "2305455",
    "problem_idx": "A",
    "shortId": "1895A",
    "contest_number": "1895",
    "problem_submissions": {
        "F": [
            231327821,
            231171975,
            231177341,
            231177139,
            231181247,
            231175451,
            231179505,
            231178754,
            231171033,
            231178007,
            231174701,
            231183326,
            231187269,
            231180010,
            231181283,
            231185538,
            231191457,
            231188914,
            231183055,
            231180065,
            231188744
        ],
        "E": [
            231166411,
            231162837,
            231168539,
            231171744,
            231170279,
            231169982,
            231169182,
            231183134,
            231173048,
            231168317,
            231174671,
            231173323,
            231173438,
            231175391,
            231175133,
            231176680,
            231179383,
            231171479,
            231175722,
            231195510
        ],
        "D": [
            231152062,
            231147559,
            231156462,
            231152946,
            231160742,
            231157174,
            231157872,
            231159102,
            231163758,
            231163699,
            231163345,
            231153744,
            231159964,
            231158155,
            231162193,
            231160798,
            231161526,
            231144729,
            231162242,
            231164715,
            231182588,
            231152194
        ],
        "C": [
            231148538,
            231143114,
            231150605,
            231147252,
            231154149,
            231154615,
            231153991,
            231151789,
            231144066,
            231169078,
            231151364,
            231154661,
            231154195,
            231153927,
            231153798,
            231162003,
            231153879,
            231145977,
            231148366,
            231148040
        ],
        "B": [
            231139170,
            231136290,
            231139512,
            231137580,
            231137719,
            231135569,
            231140209,
            231138699,
            231136948,
            231136771,
            231139306,
            231136791,
            231139010,
            231138206,
            231140302,
            231137608,
            231140161,
            231139339,
            231137240,
            231137323
        ],
        "A": [
            231135878,
            231135554,
            231135956,
            231135743,
            231135841,
            231137384,
            231140495,
            231135913,
            231135720,
            231135699,
            231136135,
            231135592,
            231135620,
            231135621,
            231136784,
            231135521,
            231136631,
            231135611,
            231135732,
            231135594
        ],
        "G": [
            231214354,
            231210500,
            231273875,
            231214703,
            231213900,
            231213313
        ]
    },
    "name": "A. Treasure Chest",
    "statement": "Monocarp has found a treasure map. The map represents the treasure\r\nlocation as an OX axis. Monocarp is at 0, the treasure chest is at x,\r\nthe key to the chest is at y.Obviously, Monocarp wants to open the\r\nchest. He can perform the following actions: go 1 to the left or 1 to\r\nthe right (spending 1 second); pick the key or the chest up if he is in\r\nthe same point as that object (spending 0 seconds); put the chest down\r\nin his current point (spending 0 seconds); open the chest if he\u2019s in the\r\nsame point as the chest and has picked the key up (spending 0 seconds).\r\nMonocarp can carry the chest, but the chest is pretty heavy. He knows\r\nthat he can carry it for at most k seconds in total (putting it down and\r\npicking it back up doesn\u2019t reset his stamina).What\u2019s the smallest time\r\nrequired for Monocarp to open the chest?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?\"YES\\n\":\"Yes\\n\"); else cout<<(upp?\"NO\\n\":\"No\\n\");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<'{';for(int i=0;i<(int)p.size();i++){if(i){cout<<\",\";}cout<<'\"'<<p[i]<<'\"';}cout<<\"}\\n\";}\nelse{if(ty==1){cout<<p.size()<<\"\\n\";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<\" \";cout<<p[i];}cout<<\"\\n\";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n    int X,Y,K;\n\tcin>>X>>Y>>K;\n\tif(Y<X) cout<<X<<\"\\n\";\n\telse cout<<Y+max(0,Y-X-K)<<\"\\n\";\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Treasure Chest.json",
    "editorial_link": "https://codeforces.com//blog/entry/122034",
    "editorial": "Let\u00e2\u0080\u0099s consider two cases:If , then the answer is , because we need to\r\nreach the chest and we can take the key on the way.If , then the optimal\r\noption would be to bring the chest directly to the key. However, this is\r\nnot always possible due to the value of . If , then we can do it and the\r\nanswer is . Otherwise, the answer is , where is the time we carried the\r\nchest, and is the time to return from the key to the chest back. From\r\nhere, we can see that this value is minimum when . Thus, the answer is .\r\n"
}