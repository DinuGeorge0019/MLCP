{
    "link": "https://codeforces.com//contest/1709/problem/E",
    "problemId": "1473248",
    "problem_idx": "E",
    "shortId": "1709E",
    "contest_number": "1709",
    "problem_submissions": {
        "F": [
            165168347,
            165171155,
            165167911,
            165174463,
            165176163,
            165160774,
            165168485,
            165153508,
            165190349,
            165187538,
            165182010,
            165187878,
            165188862,
            165199087,
            165192962,
            165196109,
            165191946,
            165144458,
            165186818,
            165193512,
            165203160
        ],
        "E": [
            165159365,
            165161441,
            165158406,
            165162017,
            165168742,
            165174634,
            165187067,
            165172843,
            165175285,
            165185776,
            165171787,
            165176500,
            165174638,
            165175948,
            165172273,
            165158835,
            165190131,
            165153154,
            165197774,
            165181829,
            165178900
        ],
        "D": [
            165150554,
            165148981,
            165152094,
            165156213,
            165151693,
            165153019,
            165151289,
            165162605,
            165149121,
            165155132,
            165160454,
            165159258,
            165152293,
            165165679,
            165219278,
            165218001,
            165217824,
            165217721,
            165217510,
            165217230,
            165156286,
            165159148,
            165160000,
            165161618,
            165152984
        ],
        "C": [
            165144629,
            165143580,
            165141216,
            165150836,
            165145746,
            165145999,
            165145473,
            165163144,
            165144208,
            165149116,
            165150518,
            165148291,
            165145172,
            165171500,
            165146230,
            165166415,
            165151667,
            165148193,
            165146642
        ],
        "B": [
            165139451,
            165137999,
            165136858,
            165138643,
            165140562,
            165138703,
            165137403,
            165156435,
            165139221,
            165142115,
            165142999,
            165139377,
            165138165,
            165141728,
            165137879,
            165168796,
            165142050,
            165141198,
            165138920
        ],
        "A": [
            165135387,
            165134436,
            165133952,
            165134310,
            165134821,
            165133959,
            165133957,
            165138163,
            165134268,
            165134365,
            165134868,
            165134280,
            165133923,
            165136754,
            165134369,
            165170607,
            165135087,
            165136295,
            165134364
        ]
    },
    "name": "E. XOR Tree",
    "statement": "You are given a tree consisting of n vertices. A number is written on\r\neach vertex; the number on vertex i is equal to a_i.Recall that a simple\r\npath is a path that visits each vertex at most once. Let the of the path\r\nbe the bitwise XOR of the values written on vertices it consists of.\r\nLet\u2019s say that a tree is if no simple path has weight 0.You can apply\r\nthe following operation any number of times (possibly, zero): select a\r\nvertex of the tree and replace the value written on it with an arbitrary\r\npositive integer. What is the minimum number of times you have to apply\r\nthis operation in order to make the tree ?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nvector<int> g[N];\nint a[N];\nint ANS;\nset<int> setik[N];\nint id[N];\nint X[N];\n\nvoid dfs(int v, int par) {\n\tint big = -1;\n\tfor (int u : g[v]) if (u != par) {\n\t\tdfs(u, v);\n\t\tif (big == -1 || (int)setik[id[big]].size() < (int)setik[id[u]].size())\n\t\t\tbig = u;\n\t}\n\tif (big == -1) {\n\t\tid[v] = v;\n\t\tX[v] = 0;\n\t\tsetik[v].insert(a[v]);\n\t\treturn;\n\t}\n\tid[v] = id[big];\n\tbool bad = false;\n\tX[id[v]] ^= a[v];\n\tif (setik[id[v]].count(X[id[v]])) bad = true;\n\tsetik[id[v]].insert(X[id[v]] ^ a[v]);\n\tfor (int u : g[v]) if (u != par && u != big) {\n\t\tfor (int z : setik[id[u]]) {\n\t\t\tint w = z ^ X[id[u]] ^ X[id[v]];\n\t\t\tif (setik[id[v]].count(w)) bad = true;\n\t\t}\n\t\tfor (int z : setik[id[u]]) {\n\t\t\tint w = z ^ X[id[u]] ^ X[id[v]] ^ a[v];\n\t\t\tsetik[id[v]].insert(w);\n\t\t}\n\t}\n\tif (bad) {\n\t\tANS++;\n\t\tsetik[id[v]].clear();\n\t}\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tdfs(0, -1);\n\tprintf(\"%d\\n\", ANS);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "dfs and similar",
        "dsu",
        "greedy",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. XOR Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/105164",
    "editorial": "To begin with, we note that there are no restrictions on the values that\r\ncan be written on the vertices, so we can use numbers of the form for\r\nthe -th replacement. Then, if we replaced the value of a vertex, then no\r\npath passing through this vertex has weight .Let\u00e2\u0080\u0099s root the tree at the\r\nvertex number . We can use a greedy approach: consider some vertex such\r\nthat it is the LCA for two vertices and , the path between which has XOR\r\nequal to . Among such vertices , pick one with the maximum distance from\r\nthe root. We need to change at least one vertex on the path . It turns\r\nout that changing the vertex is always no worse than changing any other\r\nvertex on this path, because all the remaining bad paths that pass\r\nthrough the vertex also pass through the vertex (that\u00e2\u0080\u0099s why we have\r\nchosen the deepest LCA). This means that in order to solve the problem,\r\nit is necessary to quickly find the deepest LCA of some bad path.For the\r\nconvenience of solving the problem, let\u00e2\u0080\u0099s denote the XOR on the path as\r\n, where is XOR on the path from the root to the vertex . For all\r\nvertices , let\u00e2\u0080\u0099s maintain a set of values , such that belongs to the\r\nsubtree of . Let\u00e2\u0080\u0099s use the small-to-large method to obtain such sets.\r\nAlso, during the union of sets, we can check if there is a bad path in\r\nthis subtree, i. e. if two values in the sets we merge have the same XOR\r\nas the value written on the current vertex (because that\u00e2\u0080\u0099s when the XOR\r\non path is ). If such a path exists, then we have to change the value of\r\nthe vertex and mark that the vertices of this subtree cannot be the ends\r\nof a bad path anymore that means we just clear the set instead of\r\npulling it up the tree.This solution works in .\r\n"
}