{
    "link": "https://codeforces.com//contest/620/problem/D",
    "problemId": "45930",
    "problem_idx": "D",
    "shortId": "620D",
    "contest_number": "620",
    "problem_submissions": {
        "F": [
            15476784,
            15481381,
            15483385,
            15501760,
            15483713,
            15483332,
            15483269,
            15486457,
            110737274,
            15560294,
            15483002
        ],
        "D": [
            15476004,
            15475486,
            15475046,
            15475660,
            15478283,
            15474921,
            15479173,
            15478662,
            15478888,
            15480075,
            15479882,
            15476142,
            15479569,
            15476517,
            15477414,
            15476987,
            15477430,
            15481310
        ],
        "E": [
            15473382,
            15477169,
            15483815,
            15476430,
            15478101,
            15474547,
            15477143,
            15476019,
            15475341,
            15476219,
            15475959,
            15477453,
            15479247,
            15477250,
            15479114,
            15481223,
            15479051,
            15484874,
            15484860,
            15484177,
            15484110,
            15484033,
            15483969,
            15483912,
            15483838,
            15483788,
            15478778,
            15477351
        ],
        "C": [
            15470876,
            15472964,
            15471929,
            15471592,
            15471646,
            15471528,
            15473335,
            15473233,
            15472403,
            15472416,
            15473511,
            15471829,
            15473844,
            15472579,
            15473548,
            15472833,
            15472615,
            15472479,
            15473711
        ],
        "B": [
            15470277,
            15471380,
            15470857,
            15470699,
            15470633,
            15470596,
            15471005,
            15471139,
            15470850,
            15471115,
            15471308,
            15470718,
            15472406,
            15471044,
            15470836,
            15471243,
            15471685,
            15471223
        ],
        "A": [
            15470173,
            15470408,
            15470256,
            15470217,
            15470181,
            15470174,
            15470315,
            15470332,
            15470383,
            15470351,
            15470502,
            15470184,
            15471568,
            15470376,
            15470236,
            15470211,
            15470178,
            15470460
        ]
    },
    "name": "D. Professor GukiZ and Two Arrays",
    "statement": "Professor GukiZ has two arrays of integers, and . Professor wants to\r\nmake the sum of the elements in the array as close as possible to the\r\nsum of the elements in the array . So he wants to minimize the value .In\r\none operation professor can swap some element from the array and some\r\nelement from the array . For example if the array is and the array is\r\nprofessor can swap the element from the array and the element from the\r\narray and get the new array and the new array .Professor doesn\u2019t want to\r\nmake more than two swaps. Find the minimal value and some sequence of no\r\nmore than two swaps that will lead to the such value . Professor makes\r\nswaps one by one, each new swap he makes with the new arrays and .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long ans;\nint a1 = -1, a2 = -1, a3 = -1, a4 = -1;\n\nvoid test(long long value, int b1, int b2, int b3, int b4) {\n  if (abs(value) < ans) {\n    ans = abs(value);\n    a1 = b1;\n    a2 = b2;\n    a3 = b3;\n    a4 = b4;\n  }\n}\n\nconst int N = 4444;\n\npair <int, int> a[N], b[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i].first);\n    a[i].second = i + 1;\n  }\n  int m;\n  scanf(\"%d\", &m);\n  for (int j = 0; j < m; j++) {\n    scanf(\"%d\", &b[j].first);\n    b[j].second = j + 1;\n  }\n  long long sa = 0;\n  for (int i = 0; i < n; i++) {\n    sa += a[i].first;\n  }\n  long long sb = 0;\n  for (int j = 0; j < m; j++) {\n    sb += b[j].first;\n  }\n  sort(a, a + n);\n  sort(b, b + m);\n  long long diff = sb - sa;\n  ans = abs(diff);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      test(diff + 2 * (a[i].first - 0LL - b[j].first), a[i].second, b[j].second, -1, -1);\n    }\n  }\n  vector < pair < int, pair <int, int> > > as, bs;\n  for (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n      as.push_back(make_pair(a[i].first + a[j].first, make_pair(a[i].second, a[j].second)));\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    for (int j = i + 1; j < m; j++) {\n      bs.push_back(make_pair(b[i].first + b[j].first, make_pair(b[i].second, b[j].second)));\n    }\n  }\n  sort(as.begin(), as.end());\n  sort(bs.begin(), bs.end());\n  int nn = as.size();\n  int mm = bs.size();\n  int j = 0;\n  for (int i = 0; i < nn; i++) {\n    while (j < mm && diff + 2 * (as[i].first - 0LL - bs[j].first) > 0) {\n      j++;\n    }\n    if (j < mm) {\n      test(diff + 2 * (as[i].first - 0LL - bs[j].first), as[i].second.first, bs[j].second.first, as[i].second.second, bs[j].second.second);\n    }\n    if (j - 1 >= 0) {\n      j--;\n      test(diff + 2 * (as[i].first - 0LL - bs[j].first), as[i].second.first, bs[j].second.first, as[i].second.second, bs[j].second.second);\n      j++;\n    }\n  }\n  cout << ans << endl;\n  if (a1 == -1) {\n    cout << 0 << endl;\n    return 0;\n  }\n  if (a3 == -1) {\n    cout << 1 << endl;\n    cout << a1 << \" \" << a2 << endl;\n    return 0;\n  }\n  cout << 2 << endl;\n  cout << a1 << \" \" << a2 << endl;\n  cout << a3 << \" \" << a4 << endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "two pointers"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Professor GukiZ and Two Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/22936",
    "editorial": "We can process the cases of zero or one swap in time. Consider the case\r\nwith two swaps. Note we can assume that two swaps will lead to move two\r\nelements from to and vice versa (in other case it is similar to the case\r\nwith one swap). Let\u00e2\u0080\u0099s iterate over all the pairs of the values in and\r\nstore them in some data structure (in C++ we can user map). Now let\u00e2\u0080\u0099s\r\niterate over all the pairs and find in out data structure the value\r\nclosest to the value and update the answer by the value . Required sum\r\nwe can find using binary search by data structure (*map* in C++ has\r\nlower_bound function). C++ solution : .\r\n"
}