{
    "link": "https://codeforces.com//contest/1613/problem/B",
    "problemId": "1209362",
    "problem_idx": "B",
    "shortId": "1613B",
    "contest_number": "1613",
    "problem_submissions": {
        "F": [
            137662460,
            137680102,
            137669930,
            137680388,
            137676481,
            137689054,
            137677544,
            137670783,
            137684225,
            137683109,
            137695659,
            137689822,
            137678272,
            137672898,
            137688331,
            137700851,
            137691450,
            137776678,
            137775393,
            137689226,
            137689675,
            137703031
        ],
        "E": [
            137655072,
            137656585,
            137663380,
            137661012,
            137661380,
            137660230,
            137663524,
            137662766,
            137664563,
            137669185,
            137669422,
            137670709,
            137669302,
            137681566,
            137674305,
            137665393,
            137678462,
            137670584,
            137679435,
            137664635
        ],
        "D": [
            137646881,
            137645109,
            137652424,
            137648321,
            137652518,
            137652740,
            137657211,
            137653818,
            137651858,
            137656413,
            137653916,
            137656694,
            137657143,
            137657455,
            137659528,
            137655936,
            137665693,
            137656041,
            137646478,
            137655272
        ],
        "C": [
            137634971,
            137635045,
            137641150,
            137632004,
            137642031,
            137634798,
            137639433,
            137636954,
            137638798,
            137636121,
            137638972,
            137644414,
            137635322,
            137642182,
            137647281,
            137639264,
            137643162,
            137637445,
            137634607,
            137639818
        ],
        "B": [
            137631052,
            137629986,
            137635688,
            137629262,
            137630431,
            137630193,
            137632384,
            137630955,
            137634981,
            137632132,
            137632097,
            137637773,
            137629234,
            137636896,
            137636754,
            137634314,
            137635536,
            137633727,
            137630130,
            137635595
        ],
        "A": [
            137628660,
            137628698,
            137630882,
            137628467,
            137628655,
            137628608,
            137630089,
            137628835,
            137631891,
            137629156,
            137628914,
            137629328,
            137628519,
            137632470,
            137630776,
            137629772,
            137629039,
            137628924,
            137628505,
            137630736
        ]
    },
    "name": "B. Absent Remainder",
    "statement": "You are given a sequence a_1, a_2,\r\ndots, a_n consisting of n pairwise distinct positive integers.Find\r\nleft\r\nlfloor\r\nfrac n 2\r\nright\r\nrfloor different pairs of integers x and y such that: x\r\nneq y; x and y appear in a; x mod y doesn’t appear in a. Note that some\r\nx or y can belong to multiple pairs.\r\nlfloor x\r\nrfloor denotes the floor function the largest integer less than or equal\r\nto x. x mod y denotes the remainder from dividing x by y.If there are\r\nmultiple solutions, print any of them. It can be shown that at least one\r\nsolution always exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt();\n\tvector<int> a(n);\n\tgenerate(all(a), nxt);\n\tsort(all(a));\n\tfor (int i = 0; i < n / 2; ++i) {\n\t\tcout << a[i + 1] << \" \" << a[0] << \"\\n\";\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Absent Remainder.json",
    "editorial_link": "https://codeforces.com//blog/entry/97467",
    "editorial": "There is one important observation: .Thus, you can obtain at least pair\r\nby choosing as the minimum number in the sequence and as anything else.\r\nfor any positive .Overall complexity: per testcase.\r\n",
    "hint": []
}