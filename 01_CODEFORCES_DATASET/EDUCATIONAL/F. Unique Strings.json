{
    "link": "https://codeforces.com//contest/1954/problem/F",
    "problemId": "2586696",
    "problem_idx": "F",
    "shortId": "1954F",
    "contest_number": "1954",
    "problem_submissions": {
        "F": [
            256316895,
            256329295,
            256334035,
            256332306,
            256344392,
            256332853,
            256328005,
            256347592,
            256335011,
            256352109,
            256350995,
            258635003,
            256340118,
            256372395,
            256325447,
            256325322,
            256346283,
            256316023,
            256323588,
            256320924
        ],
        "E": [
            256282413,
            256358889,
            256358516,
            256282751,
            256340120,
            256301294,
            256294589,
            256283411,
            256294052,
            256306491,
            256303451,
            256299550,
            256302258,
            256354417,
            256293685,
            256303935,
            256308643,
            256372754,
            256335764,
            256333289,
            256297901,
            256327707,
            256340547,
            256345064,
            256288665
        ],
        "D": [
            256268895,
            256269992,
            256269812,
            256286958,
            256273436,
            256278229,
            256282928,
            256272144,
            256284841,
            256280990,
            256279861,
            256284063,
            256273990,
            256301346,
            256280827,
            256332605,
            256335916,
            256339422,
            256279104
        ],
        "C": [
            256263031,
            256263009,
            256264769,
            256265286,
            256267161,
            256271687,
            256272827,
            256264797,
            256276178,
            256267220,
            256271392,
            256275794,
            256262221,
            256288253,
            256273238,
            256334487,
            256333463,
            256330248,
            256269277
        ],
        "B": [
            256260210,
            256260093,
            256260556,
            256262624,
            256263445,
            256260047,
            256260173,
            256261053,
            256267415,
            256261634,
            256268733,
            256270204,
            256275934,
            256283332,
            256344932,
            256336999,
            256331860,
            256328039,
            256266244
        ],
        "A": [
            256256940,
            256256909,
            256256942,
            256256970,
            256256990,
            256256907,
            256256875,
            256257032,
            256259999,
            256257112,
            256257788,
            256257203,
            256259580,
            256256932,
            256338388,
            256326736,
            256328175,
            256257406
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128421",
    "editorial": "Whatâs common in all strings we can get: each string has no more than\r\nones and at least consecutive ones.So letâs loosen up our constraints a\r\nlittle and just calculate the number of strings with no more than ones\r\nand at least consecutive ones, i. e. this block of ones can be anywhere,\r\ncan even start at the end and continue at the beginning. Letâs name such\r\nstrings as .Note that the number of unique good strings is exactly equal\r\nto the answer of the initial task, since we can shift each good string\r\nand make it start from the block of ones.How to calculate the number of\r\ngood strings? Using Burnsideâs lemma! Since the group of transformations\r\nis just a group of cyclic shifts, we can calculate the answer as\r\nfollowing where is the number of , or the number of strings that wonât\r\nchange after a cyclical shift by characters.Note that if the string\r\ndoesnât change while shifting by characters, then it means that for all\r\n. Further investigation reveals that all characters will be split into\r\nexactly groups and each group will contain exactly equal characters.It\r\nmeans that if then since in both cases weâll get exactly the same group\r\ndivision. So, we can rewrite the answer as following: where is the\r\nnumber of cyclic shifts with and can be easily counted.So, itâs time to\r\ncalculate for some divisor of . Itâs not hard to see that if then the\r\nfirst characters of will uniquely define the whole string . So itâs\r\nenough to work with only a prefix of length , remembering that each\r\ncharacter will be copied times.Remember that a good string is a string\r\nwith at most ones, and since each character will be copied times, we can\r\nplace at most ones in our prefix (or at least zeroes).Also, since a good\r\nstring has consecutive ones, our prefix should also have consecutive\r\nones, including the case where the ones go \"cyclically\" starting at the\r\nend of the prefix. In case if then the whole prefix should consist of\r\nones, and itâs either possible (if ) or impossible (if ).In case we need\r\nto calculate the number of good prefixes that can be described as \"the\r\ncyclic strings of length that has no more than ones and contains\r\nconsecutive ones\". Instead of good prefixes, letâs calculate bad\r\nprefixes and subtract them from all possible prefixes. prefixes are just\r\nstrings with at most ones and there are such strings. prefixes are\r\ncyclic strings with at most ones, where all blocks of ones have length\r\nless than . In order to calculate bad prefixes, letâs precalc the\r\nfollowing dp: is the number of strings of length with where all blocks\r\nof ones have length less than and the last character of the string is\r\n.Why did we use the number of zeroes in the state, and why did we add\r\nthe last zero in ? Because it will help us to calculate dp fast. . Now,\r\nif we have value , we can add a block of ones () and zero to the end of\r\nthe string and update the value in . Note that we are updating a segment\r\nof row from to with value we can do it in . So, we can precalc the whole\r\ndp in time.Now, itâs time to calculate the number of bad strings: if we\r\niterate over the length of the prefix of ones, length of the suffix of\r\nones and the number of zeroes in between, weâll get where is the number\r\nof ones on prefix, is the number of ones on suffix, and is the number of\r\nzeroes in the \"middle part\". Since each bad string will look like \"(\r\nones) (middle part ending at ) ( ones)\", you can place in the middle\r\npart at least zeroes and at most zeroes.If we play a little with the\r\nsum, we can simplify it in the following way: where is the sum of dp on\r\nthe row from to , and you can take it in if you precalc prefix sums of\r\ndp. prefixes are just and since can be calculated in , the total\r\ncomplexity of is .The resulting complexity is that looks like just .\r\n",
    "name": "F. Unique Strings",
    "statement": "Let’s say that two strings a and b are if you can get the string b by\r\ncyclically shifting string a. For example, the strings and are equal,\r\nwhile and are not.You are given a binary string s of length n. Its first\r\nc characters are -s, and its last n - c characters are -s.In one\r\noperation, you can replace one with .Calculate the number of unique\r\nstrings you can get using no more than k operations. Since the answer\r\nmay be too large, print it modulo 10^9 + 7.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std; #define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size()) using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128; using pii=pair<int,int>;using pll=pair<ll,ll>; template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>; using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>; #define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__))) template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>; // https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s))) template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);} template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());} template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;} template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << ' ' << p.second;} #ifdef i_am_noob#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}#else#define bug(...) 777771449#endif template<typename T> void print(vector<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(T && x) {cout << x << \"\\n\";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);} template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;} vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;} vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);} template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};} template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f; template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;} template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;} #define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())   #include <utility> namespace atcoder { namespace internal { // @param m `1 <= m`// @return x mod mconstexpr long long safe_mod(long long x, long long m) {    x %= m;    if (x < 0) x += m;    return x;} // Fast modular multiplication by barrett reduction// Reference: https://en.wikipedia.org/wiki/Barrett_reduction// NOTE: reconsider after Ice Lakestruct barrett {    unsigned int _m;    unsigned long long im;     // @param m `1 <= m < 2^31`    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}     // @return m    unsigned int umod() const { return _m; }     // @param a `0 <= a < m`    // @param b `0 <= b < m`    // @return `a * b % m`    unsigned int mul(unsigned int a, unsigned int b) const {        // [1] m = 1        // a = b = im = 0, so okay         // [2] m >= 2        // im = ceil(2^64 / m)        // -> im * m = 2^64 + r (0 <= r < m)        // let z = a*b = c*m + d (0 <= c, d < m)        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2        // ((ab * im) >> 64) == c or c + 1        unsigned long long z = a;        z *= b;#ifdef _MSC_VER        unsigned long long x;        _umul128(z, im, &x);#else        unsigned long long x =            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);#endif        unsigned int v = (unsigned int)(z - x * _m);        if (_m <= v) v += _m;        return v;    }}; // @param n `0 <= n`// @param m `1 <= m`// @return `(x ** n) % m`constexpr long long pow_mod_constexpr(long long x, long long n, int m) {    if (m == 1) return 0;    unsigned int _m = (unsigned int)(m);    unsigned long long r = 1;    unsigned long long y = safe_mod(x, m);    while (n) {        if (n & 1) r = (r * y) % _m;        y = (y * y) % _m;        n >>= 1;    }    return r;} // Reference:// M. Forisek and J. Jancina,// Fast Primality Testing for Integers That Fit into a Machine Word// @param n `0 <= n`constexpr bool is_prime_constexpr(int n) {    if (n <= 1) return false;    if (n == 2 || n == 7 || n == 61) return true;    if (n % 2 == 0) return false;    long long d = n - 1;    while (d % 2 == 0) d /= 2;    constexpr long long bases[3] = {2, 7, 61};    for (long long a : bases) {        long long t = d;        long long y = pow_mod_constexpr(a, t, n);        while (t != n - 1 && y != 1 && y != n - 1) {            y = y * y % n;            t <<= 1;        }        if (y != n - 1 && t % 2 == 0) {            return false;        }    }    return true;}template <int n> constexpr bool is_prime = is_prime_constexpr(n); // @param b `1 <= b`// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/gconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {    a = safe_mod(a, b);    if (a == 0) return {b, 0};     // Contracts:    // [1] s - m0 * a = 0 (mod b)    // [2] t - m1 * a = 0 (mod b)    // [3] s * |m1| + t * |m0| <= b    long long s = b, t = a;    long long m0 = 0, m1 = 1;     while (t) {        long long u = s / t;        s -= t * u;        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b         // [3]:        // (s - t * u) * |m1| + t * |m0 - m1 * u|        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)        // = s * |m1| + t * |m0| <= b         auto tmp = s;        s = t;        t = tmp;        tmp = m0;        m0 = m1;        m1 = tmp;    }    // by [3]: |m0| <= b/g    // by g != b: |m0| < b/g    if (m0 < 0) m0 += b / s;    return {s, m0};} // Compile time primitive root// @param m must be prime// @return primitive root (and minimum in now)constexpr int primitive_root_constexpr(int m) {    if (m == 2) return 1;    if (m == 167772161) return 3;    if (m == 469762049) return 3;    if (m == 754974721) return 11;    if (m == 998244353) return 3;    int divs[20] = {};    divs[0] = 2;    int cnt = 1;    int x = (m - 1) / 2;    while (x % 2 == 0) x /= 2;    for (int i = 3; (long long)(i)*i <= x; i += 2) {        if (x % i == 0) {            divs[cnt++] = i;            while (x % i == 0) {                x /= i;            }        }    }    if (x > 1) {        divs[cnt++] = x;    }    for (int g = 2;; g++) {        bool ok = true;        for (int i = 0; i < cnt; i++) {            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {                ok = false;                break;            }        }        if (ok) return g;    }}template <int m> constexpr int primitive_root = primitive_root_constexpr(m); }  // namespace internal }  // namespace atcoder  #include <cassert>#include <numeric>#include <type_traits> namespace atcoder { namespace internal { #ifndef _MSC_VERtemplate <class T>using is_signed_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value ||                                  std::is_same<T, __int128>::value,                              std::true_type,                              std::false_type>::type; template <class T>using is_unsigned_int128 =    typename std::conditional<std::is_same<T, __uint128_t>::value ||                                  std::is_same<T, unsigned __int128>::value,                              std::true_type,                              std::false_type>::type; template <class T>using make_unsigned_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value,                              __uint128_t,                              unsigned __int128>; template <class T>using is_integral = typename std::conditional<std::is_integral<T>::value ||                                                  is_signed_int128<T>::value ||                                                  is_unsigned_int128<T>::value,                                              std::true_type,                                              std::false_type>::type; template <class T>using is_signed_int = typename std::conditional<(is_integral<T>::value &&                                                 std::is_signed<T>::value) ||                                                    is_signed_int128<T>::value,                                                std::true_type,                                                std::false_type>::type; template <class T>using is_unsigned_int =    typename std::conditional<(is_integral<T>::value &&                               std::is_unsigned<T>::value) ||                                  is_unsigned_int128<T>::value,                              std::true_type,                              std::false_type>::type; template <class T>using to_unsigned = typename std::conditional<    is_signed_int128<T>::value,    make_unsigned_int128<T>,    typename std::conditional<std::is_signed<T>::value,                              std::make_unsigned<T>,                              std::common_type<T>>::type>::type; #else template <class T> using is_integral = typename std::is_integral<T>; template <class T>using is_signed_int =    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,                              std::true_type,                              std::false_type>::type; template <class T>using is_unsigned_int =    typename std::conditional<is_integral<T>::value &&                                  std::is_unsigned<T>::value,                              std::true_type,                              std::false_type>::type; template <class T>using to_unsigned = typename std::conditional<is_signed_int<T>::value,                                              std::make_unsigned<T>,                                              std::common_type<T>>::type; #endif template <class T>using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>; template <class T>using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>; template <class T> using to_unsigned_t = typename to_unsigned<T>::type; }  // namespace internal }  // namespace atcoder #include <cassert>#include <numeric>#include <type_traits> #ifdef _MSC_VER#include <intrin.h>#endif namespace atcoder { namespace internal { struct modint_base {};struct static_modint_base : modint_base {}; template <class T> using is_modint = std::is_base_of<modint_base, T>;template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>; }  // namespace internal template <int m, std::enable_if_t<(1 <= m)>* = nullptr>struct static_modint : internal::static_modint_base {    using mint = static_modint;   public:    static constexpr int mod() { return m; }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }     static_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    static_modint(T v) {        long long x = (long long)(v % (long long)(umod()));        if (x < 0) x += umod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    static_modint(T v) {        _v = (unsigned int)(v % umod());    }    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }     unsigned int val() const { return _v; }     mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }     mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v -= rhs._v;        if (_v >= umod()) _v += umod();        return *this;    }    mint& operator*=(const mint& rhs) {        unsigned long long z = _v;        z *= rhs._v;        _v = (unsigned int)(z % umod());        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }     mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }     mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        if (prime) {            assert(_v);            return pow(umod() - 2);        } else {            auto eg = internal::inv_gcd(_v, m);            assert(eg.first == 1);            return eg.second;        }    }     friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }   private:    unsigned int _v;    static constexpr unsigned int umod() { return m; }    static constexpr bool prime = internal::is_prime<m>;}; template <int id> struct dynamic_modint : internal::modint_base {    using mint = dynamic_modint;   public:    static int mod() { return (int)(bt.umod()); }    static void set_mod(int m) {        assert(1 <= m);        bt = internal::barrett(m);    }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }     dynamic_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    dynamic_modint(T v) {        long long x = (long long)(v % (long long)(mod()));        if (x < 0) x += mod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    dynamic_modint(T v) {        _v = (unsigned int)(v % mod());    }    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }     unsigned int val() const { return _v; }     mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }     mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v += mod() - rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator*=(const mint& rhs) {        _v = bt.mul(_v, rhs._v);        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }     mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }     mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        auto eg = internal::inv_gcd(_v, mod());        assert(eg.first == 1);        return eg.second;    }     friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }   private:    unsigned int _v;    static internal::barrett bt;    static unsigned int umod() { return bt.umod(); }};template <int id> internal::barrett dynamic_modint<id>::bt = 998244353; using modint998244353 = static_modint<998244353>;using modint1000000007 = static_modint<1000000007>;using modint = dynamic_modint<-1>; namespace internal { template <class T>using is_static_modint = std::is_base_of<internal::static_modint_base, T>; template <class T>using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>; template <class> struct is_dynamic_modint : public std::false_type {};template <int id>struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {}; template <class T>using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>; }  // namespace internal }  // namespace atcoder using namespace atcoder; //using mint=modint998244353;using mint=modint1000000007; template<int mod>struct nCr{    vector<static_modint<mod>> fac,inv,ifac;    void calc(int n){        fac.resize(n+1),inv.resize(n+1),ifac.resize(n+1);        fac[0]=inv[1]=ifac[0]=1;        for(int i=1; i<=n; ++i) fac[i]=fac[i-1]*static_modint<mod>::raw(i);        for(int i=2; i<=n; ++i) inv[i]=inv[mod%i]*static_modint<mod>::raw(mod-mod/i);        for(int i=1; i<=n; ++i) ifac[i]=ifac[i-1]*inv[i];    }    static_modint<mod> C(int n, int m){        if(m<0||m>n) return 0;        return fac[n]*ifac[m]*ifac[n-m];    }}; nCr<1000000007> de; void ahcorz(){    int n,c,k; cin >> n >> c >> k;    de.calc(n+1);    vv(mint,dp,n+1,n+1);    dp[1][1]=1;    rep(i,2,n+1) rep(j,2,n+1){        dp[i][j]=dp[i][j-1]+dp[i-1][j-1];        if(j-1-c>=1) dp[i][j]-=dp[i-1][j-1-c];    }    per(i,n,0) rep(j,1,n+1) dp[i][j]+=dp[i+1][j];    vc<mint> dp2(n+1);    rep(m,1,n+1) if(n%m==0){        rep(m+1) if(i*(n/m)<=c+k) dp2[m]+=de.C(m,i);        rep(i,1,m+1) if(m+1-i<=c) dp2[m]-=(m+1-i)*dp[iceil(n-c-k,n/m)][i];        bug(m,dp2[m].val());    }    rep(m,1,n+1) if(n%m==0){        rep(i,1,m) if(m%i==0) dp2[m]-=dp2[i];    }    mint res;    rep(m,1,n+1) res+=dp2[m]/m;    print(res.val());} signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Unique Strings.json",
    "hint": []
}