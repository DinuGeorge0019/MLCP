{
    "link": "https://codeforces.com//contest/1473/problem/A",
    "problemId": "864969",
    "problem_idx": "A",
    "shortId": "1473A",
    "contest_number": "1473",
    "problem_submissions": {
        "G": [
            104324184,
            104387693,
            104338182,
            104349212,
            104348798,
            104346480,
            104390780,
            104390610,
            104390495,
            104389764,
            104383982,
            104383801,
            104346655,
            104341001,
            104315264,
            104352224,
            104352185,
            104375589,
            104397435,
            104397194,
            104376606,
            104352690,
            104352754,
            104352534,
            104398919,
            104398235,
            104330024
        ],
        "F": [
            104316672,
            104314197,
            104321921,
            104322437,
            104324528,
            104322986,
            104314395,
            104317108,
            104322022,
            104311306,
            136810058,
            104327481,
            104330457,
            104324027,
            104334280,
            104334405,
            104340043,
            104329360,
            104332558
        ],
        "E": [
            104307026,
            104303673,
            104306129,
            104311187,
            104320601,
            104327879,
            104304639,
            104302012,
            104310767,
            104318435,
            104314089,
            104313021,
            104316783,
            104313523,
            104318767,
            104312111,
            104314876,
            104327257,
            104303395
        ],
        "D": [
            104300616,
            104298125,
            104298419,
            104305187,
            104310558,
            104332950,
            104295784,
            104297395,
            104304904,
            104298645,
            104306694,
            104301645,
            104305953,
            104307851,
            104307522,
            104307146,
            104309694,
            104303434,
            104321617
        ],
        "C": [
            104297127,
            104291328,
            104310275,
            104297010,
            104300137,
            104335806,
            104289962,
            104291239,
            104299846,
            104320575,
            104299422,
            104297141,
            104307584,
            104296827,
            104299646,
            104301166,
            104302797,
            104297015,
            104316440
        ],
        "B": [
            104289189,
            104283439,
            104284166,
            104288050,
            104287625,
            104337404,
            104283726,
            104283807,
            104286751,
            104285766,
            104285844,
            104292438,
            104285398,
            104287974,
            104288404,
            104287047,
            104293072,
            104288614,
            104287425
        ],
        "A": [
            104282920,
            104280323,
            104280823,
            104280333,
            104281130,
            104338367,
            104280298,
            104280342,
            104281217,
            104281168,
            104280838,
            104286833,
            104280557,
            104280439,
            104281300,
            104280646,
            104289104,
            104281489,
            104280913
        ]
    },
    "name": "A. Replacing Elements",
    "statement": "You have an array a_1, a_2,\r\ndots, a_n. All a_i are positive integers.In one step you can choose\r\nthree distinct indices i, j, and k (i\r\nneq j; i\r\nneq k; j\r\nneq k) and assign the sum of a_j and a_k to a_i, i. e. make a_i = a_j +\r\na_k.Can you make all a_i lower or equal to d using the operation above\r\nany number of times (possibly, zero)?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, d;\n        std::cin >> n >> d;\n        std::vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            std::cin >> a[i];\n        }\n        std::sort(a.begin(), a.end());\n        if (a[0] + a[1] <= d || a[n - 1] <= d) {\n            std::cout << \"YES\\n\";\n        } else {\n            std::cout << \"NO\\n\";\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math",
        "sortings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Replacing Elements.json",
    "editorial_link": "https://codeforces.com//blog/entry/86827",
    "editorial": "Let\u00e2\u0080\u0099s note that since all are positive, any . It means that we can\u00e2\u0080\u0099t\r\nmake the first and second minimums lower than they already are: suppose\r\nthe first and second minimums are and , if we choose any other element\r\nto replace, we can\u00e2\u0080\u0099t make it less than and if we choose to replace or we\r\nwill only make them bigger.As a result, it means that we can choose for\r\neach element either not to change it or make it equal to . So, to be\r\nable to make all elements we need just check that either or maximum .We\r\ncan do it, for example, by sorting our array in increasing order and\r\nchecking that either or .\r\n"
}