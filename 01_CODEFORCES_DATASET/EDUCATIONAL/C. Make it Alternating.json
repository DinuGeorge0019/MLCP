{
    "link": "https://codeforces.com//contest/1879/problem/C",
    "problemId": "2226287",
    "problem_idx": "C",
    "shortId": "1879C",
    "contest_number": "1879",
    "problem_submissions": {
        "F": [
            224937536,
            224935202,
            224950610,
            224926179,
            224962842,
            224969051,
            224930929,
            224967422,
            224963265,
            224966461,
            224940572,
            224966841,
            224954569,
            225047271,
            224982141,
            224973229,
            225020484,
            225376642,
            224974176,
            225441069
        ],
        "E": [
            224915766,
            224914283,
            224947954,
            224935300,
            224927963,
            224966463,
            224932997,
            224929889,
            224950618,
            224966233,
            224954318,
            224969484,
            224930880,
            224920140,
            224922897,
            224920584,
            224928749,
            224925724,
            224924188,
            224933925
        ],
        "D": [
            224888044,
            224890483,
            224896670,
            224904072,
            224896642,
            224898559,
            224895640,
            224898718,
            224909765,
            224890763,
            224903520,
            224917804,
            224935485,
            224900120,
            224899388,
            224897270,
            224896991,
            224895504,
            224897180,
            224904052
        ],
        "C": [
            224883111,
            224886635,
            224905698,
            224893770,
            224888377,
            224894906,
            224886723,
            224893779,
            224902835,
            224885562,
            224895691,
            224922809,
            224940882,
            224893191,
            224888785,
            224888462,
            224890469,
            224889684,
            224903420,
            224892974
        ],
        "B": [
            224880512,
            224883808,
            224889537,
            224888023,
            224883379,
            224885924,
            224899117,
            224885706,
            224885740,
            224883031,
            224886861,
            224914364,
            224945905,
            224884557,
            224881988,
            224884765,
            224884529,
            224883777,
            224884553,
            224888797
        ],
        "A": [
            224880000,
            224880258,
            224880343,
            224880667,
            224881398,
            224880389,
            224901703,
            224881377,
            224880233,
            224880172,
            224880548,
            224906481,
            224947822,
            224880196,
            224880217,
            225049284,
            224880515,
            224880208,
            224880388,
            224880513,
            224881480
        ]
    },
    "name": "C. Make it Alternating",
    "statement": "You are given a binary string s. A binary string is a string consisting\r\nof characters and/or .You can perform the following operation on s any\r\nnumber of times : choose an integer i such that 1\r\nle i\r\nle |s|, then erase the character s_i. You have to make s alternating, i.\r\ne. after you perform the operations, every two adjacent characters in s\r\nshould be different.Your goal is to calculate two values: the minimum\r\nnumber of operations required to make s alternating; the number of\r\ndifferent sequences of operations that make s alternating. Two sequences\r\nof operations are different if in at least one operation, the chosen\r\ninteger i is different in these two sequences.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 998244353;\nconst char nl = '\\n';\nconst int MX = 200001; \n\nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { v++; if (v == MOD) v = 0; return mi(v); }\n    mi operator--(int) { v--; if (v < 0) v = MOD-1; return mi(v); }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvoid __print(mi X) {\n    cout << X.v;\n}\nmi facs[MX];\nmi facInvs[MX];\n\n//REMEMBER TO CHECK A >= B >= 0\nmi choose(mi _a, mi _b) {\n    ll a = (ll) _a, b = (ll) _b;\n    mi cur = facs[a];\n    cur = cur * facInvs[b];\n    cur = cur * facInvs[a-b];\n    return cur;\n}\n\nvoid initFacs() {\n\tfacs[0] = 1;\n\tFOR(i, 1, MX) {\n\t\tfacs[i] = (facs[i-1] * i);\n\t}\n    facInvs[MX - 1] = inv(facs[MX-1]);\n    F0Rd(i, MX-1) {\n        facInvs[i] = facInvs[i+1] * (i+1);\n    }\n}\nvoid solve() {\n    string S; cin >> S;\n    int cnt = 1;\n    int lst = 0;\n    mi ans = 1;\n    FOR(i, 1, sz(S)) {\n        if (S[i] != S[i-1]) {\n            cnt++;\n            ans *= i-lst;\n            lst = i;\n        }\n    }\n    ans *= sz(S) - lst;\n    cout << sz(S)-cnt << \" \" << facs[sz(S) - cnt] * ans << nl;\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    initFacs();\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Make it Alternating.json",
    "editorial_link": "https://codeforces.com//blog/entry/120773",
    "editorial": "Firstly, let\u00e2\u0080\u0099s divide the string into blocks of equal characters. For\r\nexample, if , then we divide it into four blocks: , , , . Let\u00e2\u0080\u0099s denote\r\nthe length of -th block as , and the number of blocks as .To obtain the\r\nlongest alternating string we can get, we should choose exactly one\r\ncharacter from each block and delete all other characters (we cannot\r\nleave two or more characters from the same block).Now let\u00e2\u0080\u0099s calculate\r\nthe number of ways to choose characters that stay after string become\r\nalternating. In the first block of length , there are ways to choose\r\nthat element; in the second block, there are ways, and so on. So the\r\nfinal number of ways is equal to . For example, let\u00e2\u0080\u0099s consider the\r\nstring . This string is divided into two blocks and , so the number of\r\nways if : ; ; ; ; ; . However, we have chosen the characters that\r\nremain, but we need to choose the characters we erase and the order in\r\nwhich we erase them. Since choosing the characters that remain is\r\nbasically the same as choosing the characters that get erased, we only\r\nhave to choose the order in which the character get erased. The number\r\nof characters we erase is , so the number of ways to order them is equal\r\nto the number of permutations of length . For example, let\u00e2\u0080\u0099s consider\r\nthat the string and the chosen indices to erase are , and . Then there\r\nare ways to choose the order of them: , , ; , , ; , , ; , , ; , , ; , ,\r\n. Note that after we delete a character from the string, the indices of\r\nother characters might change, but it doesn\u00e2\u0080\u0099t actually matter.So, the\r\nfinal answer is: the number of operations we perform is ; and the number\r\nof shortest sequences of operations is .\r\n"
}