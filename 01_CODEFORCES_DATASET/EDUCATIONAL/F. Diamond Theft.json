{
    "link": "https://codeforces.com//contest/1886/problem/F",
    "problemId": "2254334",
    "problem_idx": "F",
    "shortId": "1886F",
    "contest_number": "1886",
    "problem_submissions": {
        "F": [
            227397695,
            227398300,
            228261037,
            228260268,
            228197178
        ],
        "E": [
            227362679,
            227384483,
            227364120,
            227375327,
            227373174,
            227378169,
            227374021,
            227374447,
            227379620,
            227374460,
            227376543,
            227384694,
            227379424,
            227380143,
            227385403,
            227378825,
            227381936,
            227382749,
            227399178,
            227387227
        ],
        "D": [
            227353655,
            227357179,
            227354694,
            227357584,
            227358464,
            227358468,
            227358349,
            227362290,
            227362059,
            227356663,
            227359799,
            227363314,
            227364815,
            227364540,
            227348253,
            227359972,
            227351995,
            227364703,
            227363479,
            227364505
        ],
        "C": [
            227350420,
            227354094,
            227350822,
            227351738,
            227353206,
            227352928,
            227352755,
            227358100,
            227355646,
            227353873,
            227356426,
            227357990,
            228289531,
            227359928,
            227359265,
            227363015,
            227354512,
            227347330,
            227360346,
            227356740,
            227359383
        ],
        "B": [
            227345467,
            227345695,
            227345097,
            227345886,
            227347778,
            227347034,
            227345776,
            227346855,
            227347299,
            227344500,
            227348328,
            227348902,
            227344888,
            227345167,
            227353779,
            227346134,
            227384569,
            227355313,
            227346381,
            227345209
        ],
        "A": [
            227342113,
            227340918,
            227341455,
            227340893,
            227341201,
            227341171,
            227340846,
            227340875,
            227341099,
            227340925,
            227340854,
            227342810,
            227341042,
            227341115,
            227341596,
            227341490,
            227340923,
            227349667,
            227341619,
            227341191
        ]
    },
    "name": "F. Diamond Theft",
    "statement": "Monocarp is the most famous thief in Berland. This time, he decided to\r\nsteal two diamonds. Unfortunately for Monocarp, there are n cameras\r\nmonitoring the diamonds. Each camera has two parameters, t_i and s_i.\r\nThe first parameter determines whether the camera is monitoring the\r\nfirst diamond only (t_i=1), the second diamond only (t_i=2), or both\r\ndiamonds (t_i=3). The second parameter determines the number of seconds\r\nthe camera will be disabled after it is hacked.Every second, Monocarp\r\ncan perform one of the following three actions: do nothing; choose a\r\ncamera and hack it; if Monocarp hacks the i-th camera, it will be\r\ndisabled for the next s_i seconds (if the current second is the T-th\r\none, the camera will be disabled from the (T+1)-th to the (T+s_i)-th\r\nsecond, inclusive); steal a diamond if all cameras monitoring it are\r\ncurrently disabled. Monocarp cannot steal the second diamond if he\r\nhasn\u2019t stolen the first diamond yet. Note that Monocarp can hack a\r\ncamera multiple times, even if it is currently disabled.Your task is to\r\ndetermine the minimum time it will take Monocarp to steal both diamonds,\r\n, or report that it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n    \n    int find(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return siz[find(x)];\n    }\n};\n\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a[4];\n    for (int i = 0; i < n; i++) {\n        int t, s;\n        std::cin >> t >> s;\n        a[t].push_back(s);\n    }\n    for (int t = 1; t <= 3; t++) {\n        std::sort(a[t].begin(), a[t].end());\n    }\n    \n    int ans = 2 * n + 3;\n    \n    std::vector<int> p(n + 1);\n    std::iota(p.begin(), p.end(), 1);\n    std::shuffle(p.begin(), p.end(), rng);\n    \n    auto check = [&](int sum, int t2) {\n        int t1 = sum - t2;\n        if (t1 < 1) {\n            return false;\n        }\n        DSU d1(t1), d2(t2);\n        for (auto s : a[1]) {\n            int x = std::max(0, t1 - 1 - s);\n            x = d1.find(x);\n            if (x == t1 - 1) {\n                return false;\n            }\n            d1.merge(x + 1, x);\n        }\n        for (auto s : a[3]) {\n            if (s > t2) {\n                int x = std::max(0, t1 - 1 - (s - t2));\n                x = d1.find(x);\n                if (x < t1 - 1) {\n                    d1.merge(x + 1, x);\n                    continue;\n                }\n            }\n            int x = std::max(0, t1 - 1 - s);\n            x = d1.find(x);\n            if (x == t1 - 1) {\n                return false;\n            }\n            d1.merge(x + 1, x);\n            x = std::max(0, t2 - 1 - s);\n            x = d2.find(x);\n            if (x == t2 - 1) {\n                return false;\n            }\n            d2.merge(x + 1, x);\n        }\n        for (auto s : a[2]) {\n            if (s > t2) {\n                int x = std::max(0, t1 - 1 - (s - t2));\n                x = d1.find(x);\n                if (x < t1 - 1) {\n                    d1.merge(x + 1, x);\n                    continue;\n                }\n            }\n            int x = std::max(0, t2 - 1 - s);\n            x = d2.find(x);\n            if (x == t2 - 1) {\n                return false;\n            }\n            d2.merge(x + 1, x);\n        }\n        return true;\n    };\n    \n    for (auto t2 : p) {\n        if (!check(ans - 1, t2)) {\n            continue;\n        }\n        ans = *std::ranges::partition_point(std::ranges::iota_view(1, ans),\n            [&](int s) {\n                return !check(s, t2);\n            });\n    }\n    \n    if (ans > 2 * n + 2) {\n        ans = -1;\n    }\n    \n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy"
    ],
    "dificulty": "3300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Diamond Theft.json",
    "editorial_link": "https://codeforces.com//blog/entry/121255",
    "editorial": "In this editorial, we will denote the number of cameras of type as\r\n.Without loss of generality, we can assume that our sequence of actions\r\nwill look as follows: hack all cameras of type , some cameras of type\r\nand all cameras of type in some order (let\u00e2\u0080\u0099s call it the first block of\r\nactions); steal the first diamond; hack the remaining cameras of type\r\nand some cameras of type (the second block of actions); steal the second\r\ndiamond. Note that we don\u00e2\u0080\u0099t hack the same camera of type or twice (this\r\nis just suboptimal), but some cameras of type will be hacked twice. We\r\nhave to minimize the number of cameras of type which will be hacked\r\ntwice.Let\u00e2\u0080\u0099s iterate on the number of actions we make after stealing the\r\nfirst diamond (denote it by ), and then iterate on the number of cameras\r\nof type in the first block (denote it by ). Then, the number of cameras\r\nof type we hack in the second block will be , and the number of cameras\r\nof type we hack in the second block is . Since this is also the number\r\nof cameras of type we hack twice, we have to minimize this number. Note\r\nthat the length of the first block is also fixed: it should be .Suppose\r\nwe fixed which cameras of type and go to the second block, and which\r\ndon\u00e2\u0080\u0099t. For each block, we will store a special data structure that, for\r\nevery from to the length of the block, calculates the value of , where\r\nis the number of cameras which have to be hacked during the last actions\r\nin the block. Using something like Hall\u00e2\u0080\u0099s theorem, we can prove that if\r\nevery value of for every block is non-positive, there exists a way to\r\nhack all cameras in time. This can be efficiently modeled with a segment\r\ntree.All cameras of type should be inserted into the data structure for\r\nthe first block. For the cameras of type , we either insert them into\r\nthe second block, or insert them into the first block while subtracting\r\nfrom their values of . For the cameras of type , we either insert them\r\ninto both blocks, or insert them into the first block while subtracting\r\nfrom their values of .Among all cameras of type , which ones should\r\nbelong to the first block, and which ones to the second block? It\u00e2\u0080\u0099s\r\nquite easy to see that the \"longest\" cameras of type should be in the\r\nfirst block. Unfortunately, with cameras of type , it\u00e2\u0080\u0099s a bit more\r\ntricky.First, let\u00e2\u0080\u0099s insert all cameras of type into the first block and\r\nall cameras of type into the blocks chosen for them. Then sort all\r\ncameras of type (in ascending order of their values) and use the\r\nfollowing greedy approach: if a camera can be inserted into the first\r\nblock after we subtract from its , we insert it there; otherwise, we\r\ninsert it into both blocks without subtraction. This greedy approach can\r\nbe proved using something like exchange argument: if we skipped some\r\ncamera which could be inserted into the first block, and chose some\r\nother camera for the same slot, they can be \"swapped\". So, all cameras\r\nof type are partitioned into two types.After you\u00e2\u0080\u0099ve done inserting\r\ncameras into the respective blocks, check that everything\u00e2\u0080\u0099s fine. This\r\nworks in something like . Unfortunately, it is too slow.To speed this\r\nup, let\u00e2\u0080\u0099s use the following strategy: iterate on the value of , then try\r\nsolving the problem for (i. e. all cameras of type are initially in the\r\nsecond block). If it fails, we can try increasing , shifting a camera of\r\ntype from the second block to the first block and rebuilding the\r\npartition of cameras of type , instead of starting it from scratch.But\r\nhow do we rebuild the partition of cameras of type ? We can use the\r\nfollowing strategy. Store a set of cameras of type (sorted by their )\r\nwhich are inserted only into the first block. While the first block is\r\nnot OK (i. e. there exists some value of such that is positive), we will\r\nfind the minimum such that is positive, and try to decrease it as\r\nfollows: search for the camera of type which belongs only to the first\r\nblock, has , and has the maximum among all such cameras. This is the\r\ncamera which should be moved in the partition (i. e. instead of storing\r\nit in the first block, we store it in both blocks). Note that you might\r\nneed to repeat this process (i. e. when you move a camera of type to the\r\nfirst block, it can force multiple cameras of type into the second\r\nblock). Thus, our solution now works in .\r\n"
}