{"link": "https://codeforces.com//contest/1886/problem/F", "problemId": "2254334", "problem_idx": "F", "shortId": "1886F", "contest_number": "1886", "problem_submissions": {"F": [227397695, 227398300, 228261037, 228260268, 228197178], "E": [227362679, 227384483, 227364120, 227375327, 227373174, 227378169, 227374021, 227374447, 227379620, 227374460, 227376543, 227384694, 227379424, 227380143, 227385403, 227378825, 227381936, 227382749, 227399178, 227387227], "D": [227353655, 227357179, 227354694, 227357584, 227358464, 227358468, 227358349, 227362290, 227362059, 227356663, 227359799, 227363314, 227364815, 227364540, 227348253, 227359972, 227351995, 227364703, 227363479, 227364505], "C": [227350420, 227354094, 227350822, 227351738, 227353206, 227352928, 227352755, 227358100, 227355646, 227353873, 227356426, 227357990, 228289531, 227359928, 227359265, 227363015, 227354512, 227347330, 227360346, 227356740, 227359383], "B": [227345467, 227345695, 227345097, 227345886, 227347778, 227347034, 227345776, 227346855, 227347299, 227344500, 227348328, 227348902, 227344888, 227345167, 227353779, 227346134, 227384569, 227355313, 227346381, 227345209], "A": [227342113, 227340918, 227341455, 227340893, 227341201, 227341171, 227340846, 227340875, 227341099, 227340925, 227340854, 227342810, 227341042, 227341115, 227341596, 227341490, 227340923, 227349667, 227341619, 227341191]}, "name": "F. Diamond Theft", "statement": "Monocarp is the most famous thief in Berland. This time, he decided to\r\nsteal two diamonds. Unfortunately for Monocarp, there are n cameras\r\nmonitoring the diamonds. Each camera has two parameters, t_i and s_i.\r\nThe first parameter determines whether the camera is monitoring the\r\nfirst diamond only (t_i=1), the second diamond only (t_i=2), or both\r\ndiamonds (t_i=3). The second parameter determines the number of seconds\r\nthe camera will be disabled after it is hacked.Every second, Monocarp\r\ncan perform one of the following three actions: do nothing; choose a\r\ncamera and hack it; if Monocarp hacks the i-th camera, it will be\r\ndisabled for the next s_i seconds (if the current second is the T-th\r\none, the camera will be disabled from the (T+1)-th to the (T+s_i)-th\r\nsecond, inclusive); steal a diamond if all cameras monitoring it are\r\ncurrently disabled. Monocarp cannot steal the second diamond if he\r\nhasn\u2019t stolen the first diamond yet. Note that Monocarp can hack a\r\ncamera multiple times, even if it is currently disabled.Your task is to\r\ndetermine the minimum time it will take Monocarp to steal both diamonds,\r\n, or report that it is impossible.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n    \n    int find(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return siz[find(x)];\n    }\n};\n\nstd::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a[4];\n    for (int i = 0; i < n; i++) {\n        int t, s;\n        std::cin >> t >> s;\n        a[t].push_back(s);\n    }\n    for (int t = 1; t <= 3; t++) {\n        std::sort(a[t].begin(), a[t].end());\n    }\n    \n    int ans = 2 * n + 3;\n    \n    std::vector<int> p(n + 1);\n    std::iota(p.begin(), p.end(), 1);\n    std::shuffle(p.begin(), p.end(), rng);\n    \n    auto check = [&](int sum, int t2) {\n        int t1 = sum - t2;\n        if (t1 < 1) {\n            return false;\n        }\n        DSU d1(t1), d2(t2);\n        for (auto s : a[1]) {\n            int x = std::max(0, t1 - 1 - s);\n            x = d1.find(x);\n            if (x == t1 - 1) {\n                return false;\n            }\n            d1.merge(x + 1, x);\n        }\n        for (auto s : a[3]) {\n            if (s > t2) {\n                int x = std::max(0, t1 - 1 - (s - t2));\n                x = d1.find(x);\n                if (x < t1 - 1) {\n                    d1.merge(x + 1, x);\n                    continue;\n                }\n            }\n            int x = std::max(0, t1 - 1 - s);\n            x = d1.find(x);\n            if (x == t1 - 1) {\n                return false;\n            }\n            d1.merge(x + 1, x);\n            x = std::max(0, t2 - 1 - s);\n            x = d2.find(x);\n            if (x == t2 - 1) {\n                return false;\n            }\n            d2.merge(x + 1, x);\n        }\n        for (auto s : a[2]) {\n            if (s > t2) {\n                int x = std::max(0, t1 - 1 - (s - t2));\n                x = d1.find(x);\n                if (x < t1 - 1) {\n                    d1.merge(x + 1, x);\n                    continue;\n                }\n            }\n            int x = std::max(0, t2 - 1 - s);\n            x = d2.find(x);\n            if (x == t2 - 1) {\n                return false;\n            }\n            d2.merge(x + 1, x);\n        }\n        return true;\n    };\n    \n    for (auto t2 : p) {\n        if (!check(ans - 1, t2)) {\n            continue;\n        }\n        ans = *std::ranges::partition_point(std::ranges::iota_view(1, ans),\n            [&](int s) {\n                return !check(s, t2);\n            });\n    }\n    \n    if (ans > 2 * n + 2) {\n        ans = -1;\n    }\n    \n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "3300", "interactive": false}