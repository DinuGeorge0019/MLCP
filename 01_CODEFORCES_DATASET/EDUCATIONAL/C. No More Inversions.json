{
    "link": "https://codeforces.com//contest/1473/problem/C",
    "problemId": "864971",
    "problem_idx": "C",
    "shortId": "1473C",
    "contest_number": "1473",
    "problem_submissions": {
        "G": [
            104324184,
            104387693,
            104338182,
            104349212,
            104348798,
            104346480,
            104390780,
            104390610,
            104390495,
            104389764,
            104383982,
            104383801,
            104346655,
            104341001,
            104315264,
            104352224,
            104352185,
            104375589,
            104397435,
            104397194,
            104376606,
            104352690,
            104352754,
            104352534,
            104398919,
            104398235,
            104330024
        ],
        "F": [
            104316672,
            104314197,
            104321921,
            104322437,
            104324528,
            104322986,
            104314395,
            104317108,
            104322022,
            104311306,
            136810058,
            104327481,
            104330457,
            104324027,
            104334280,
            104334405,
            104340043,
            104329360,
            104332558
        ],
        "E": [
            104307026,
            104303673,
            104306129,
            104311187,
            104320601,
            104327879,
            104304639,
            104302012,
            104310767,
            104318435,
            104314089,
            104313021,
            104316783,
            104313523,
            104318767,
            104312111,
            104314876,
            104327257,
            104303395
        ],
        "D": [
            104300616,
            104298125,
            104298419,
            104305187,
            104310558,
            104332950,
            104295784,
            104297395,
            104304904,
            104298645,
            104306694,
            104301645,
            104305953,
            104307851,
            104307522,
            104307146,
            104309694,
            104303434,
            104321617
        ],
        "C": [
            104297127,
            104291328,
            104310275,
            104297010,
            104300137,
            104335806,
            104289962,
            104291239,
            104299846,
            104320575,
            104299422,
            104297141,
            104307584,
            104296827,
            104299646,
            104301166,
            104302797,
            104297015,
            104316440
        ],
        "B": [
            104289189,
            104283439,
            104284166,
            104288050,
            104287625,
            104337404,
            104283726,
            104283807,
            104286751,
            104285766,
            104285844,
            104292438,
            104285398,
            104287974,
            104288404,
            104287047,
            104293072,
            104288614,
            104287425
        ],
        "A": [
            104282920,
            104280323,
            104280823,
            104280333,
            104281130,
            104338367,
            104280298,
            104280342,
            104281217,
            104281168,
            104280838,
            104286833,
            104280557,
            104280439,
            104281300,
            104280646,
            104289104,
            104281489,
            104280913
        ]
    },
    "name": "C. No More Inversions",
    "statement": "You have a sequence a with n elements 1, 2, 3,\r\ndots, k - 1, k, k - 1, k - 2,\r\ndots, k - (n - k) (k\r\nle n < 2k).Let\u2019s call as inversion in a a pair of indices i < j such\r\nthat a[i] > a[j].Suppose, you have some permutation p of size k and you\r\nbuild a sequence b of size n in the following manner: b[i] =\r\np[a[i]].Your goal is to find such permutation p that the total number of\r\ninversions in b doesn\u2019t exceed the total number of inversions in a, and\r\nb is .Small reminder: the sequence of k integers is called a permutation\r\nif it contains all integers from 1 to k exactly once.Another small\r\nreminder: a sequence s is than another sequence t, if either s is a\r\nprefix of t, or for the first i such that s_i\r\nne t_i, s_i < t_i holds (in the first position that these sequences are\r\ndifferent, s has smaller number than t).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, k;\n        std::cin >> n >> k;\n        int x = n - k;\n        for (int i = 1; i <= k; i++) {\n            if (i < k - x) {\n                std::cout << i;\n            } else {\n                std::cout << k - x + k - i;\n            }\n            std::cout << \" \\n\"[i == k];\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. No More Inversions.json",
    "editorial_link": "https://codeforces.com//blog/entry/86827",
    "editorial": "At first, let\u00e2\u0080\u0099s look at sequence : . Let\u00e2\u0080\u0099s prove that the number of\r\ninversions in is the same regardless of what are (the only condition is\r\nthat should be distinct).Let\u00e2\u0080\u0099s group all elements by their value there\r\nwill be or elements in each group. Then we can take any two groups with\r\nvalues and and calculate the number of inversions between elements in\r\nthese groups. It\u00e2\u0080\u0099s easy to note that construction will always be like\r\n(or ) and regardless of or in both cases there will be exactly two\r\ninversions between groups equal to and to (or one inversion in the\r\nsecond case). So the total number of inversion will be equal to .Now we\r\ncan split sequences and into two parts. Let , then the first part is\r\nelements from segment and the second is from . Note that the second\r\nparts both in and are exactly the sequence described above.The total\r\nnumber of inversions is equal to the sum of inversions in the first\r\npart, in the second part, and the inversions with elements from both\r\nparts. Note that in the first and the third components are equal to and\r\nthe second component is constant, so in we must also have inversions in\r\nthe first part and inversion between parts.It means that must start from\r\n. But since the number of inversions in the second part is constant we\r\ncan set the remaining elements the way we want. And since we want to\r\nbuild lexicographically maximum , we should make the second part as .In\r\nthe end, optimal is . The permutation to make such is equal to .\r\n"
}