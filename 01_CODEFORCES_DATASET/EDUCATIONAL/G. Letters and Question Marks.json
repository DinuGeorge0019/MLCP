{
    "link": "https://codeforces.com//contest/1327/problem/G",
    "problemId": "571330",
    "problem_idx": "G",
    "shortId": "1327G",
    "contest_number": "1327",
    "problem_submissions": {
        "F": [
            74109494,
            74096912,
            74114522,
            74102690,
            74088644,
            74096945,
            74118574,
            74105095,
            74095826,
            74113555,
            74098825,
            74097831,
            74105606,
            74109593,
            74101097,
            74708534,
            74098586
        ],
        "G": [
            74091723,
            74123968,
            74123925,
            74114197,
            76629927,
            74211867,
            74588194,
            74135043,
            143583395,
            74127397,
            74126425,
            74105678,
            74715507
        ],
        "B": [
            74068544,
            74058114,
            74057729,
            74055609,
            74062072,
            74057059,
            74054855,
            74056002,
            74059330,
            74057094,
            74057214,
            74063726,
            74054652,
            74058809,
            74054826,
            74057170,
            74057831,
            74708239,
            74069029
        ],
        "E": [
            74063712,
            74072104,
            74084153,
            74095848,
            74069496,
            74077697,
            74073149,
            74081984,
            74074950,
            74080019,
            74086353,
            74075499,
            74090079,
            74089858,
            74078241,
            74086260,
            74708411,
            74085708
        ],
        "C": [
            74060977,
            74064317,
            74075501,
            74070865,
            74062695,
            74059969,
            74061257,
            74063448,
            74063934,
            74060895,
            74069645,
            74078565,
            74065457,
            74072914,
            74062504,
            74072575,
            74708279,
            74073328
        ],
        "D": [
            74058988,
            74081137,
            74080575,
            74087567,
            74078030,
            74085278,
            74068392,
            74068497,
            74084912,
            74069773,
            74079760,
            74085394,
            74082419,
            74068982,
            74073656,
            74080794,
            74708339,
            74079780
        ],
        "A": [
            74048309,
            74098107,
            74049366,
            74047546,
            74050945,
            74048503,
            74046989,
            74047125,
            74048033,
            74048151,
            74049565,
            74047828,
            74047513,
            74049730,
            74046774,
            74049977,
            74047800,
            74708180,
            74063309
        ]
    },
    "name": "G. Letters and Question Marks",
    "statement": "You are given a string S and an array of strings [t_1, t_2,\r\ndots, t_k]. Each string t_i consists of lowercase Latin letters from to\r\n; S consists of lowercase Latin letters from to and question marks.Each\r\nstring t_i has its cost c_i an integer number. The value of some string\r\nT is calculated as\r\nsum\r\nlimits_{i = 1}^{k} F(T, t_i)\r\ncdot c_i, where F(T, t_i) is the number of occurences of string t_i in T\r\nas a substring. For example, F(\r\ntext{aaabaaa},\r\ntext{aa}) = 4.You have to replace all question marks in S with lowercase\r\nLatin letters from to so the value of S is maximum possible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n;\n\nconst int AC_SIGMA=14,AC_V=22,AC_N=2010;\nstruct node {\n\tnode *go[AC_V],*fail,*f;\n\tll fg;\n}pool[AC_N],*cur,*root,*q[AC_N];\nnode* newnode() {\n\tnode *p=cur++;\n\tmemset(p->go,0,sizeof(p->go)); p->fail=p->f=NULL; p->fg=0;\n\treturn p;\n}\nvoid init() { cur=pool; root=newnode();}\nnode* append(node *p,int w) {\n\tif (!p->go[w]) p->go[w]=newnode(),p->go[w]->f=p;\n\treturn p=p->go[w];\n}\nvoid build() {\n\tint t=1;\n\tq[0]=root;\n\trep(i,0,t) rep(j,0,AC_SIGMA) if (q[i]->go[j]) {\n\t\tnode *v=q[i]->go[j],*p=v->f->fail;\n\t\twhile (p&&!p->go[j]) p=p->fail;\n\t\tif (p) v->fail=p->go[j]; else v->fail=root;\n\t\tq[t++]=q[i]->go[j];\n\t}\n\trep(i,0,t) if (q[i]->fail) q[i]->fg+=q[i]->fail->fg;\n\trep(i,0,t) rep(j,0,AC_SIGMA) if (!q[i]->go[j]) {\n\t\tnode *p=q[i]->fail;\n\t\tif (!p) q[i]->go[j]=root; else q[i]->go[j]=p->go[j];\n\t}\n}\n\nint k,go[20][1010];\nll val[20][1010];\nchar s[401000];\nll dp[(1<<14)+10][1010],tmp[1010];\n\nint main() {\n\tscanf(\"%d\",&k);\n\tinit();\n\trep(i,0,k) {\n\t\tscanf(\"%s\",s);\n\t\tnode *p=root;\n\t\tint m=strlen(s);\n\t\trep(j,0,m) p=append(p,s[j]-'a');\n\t\tint w;\n\t\tscanf(\"%d\",&w);\n\t\tp->fg+=w;\n\t}\n\tbuild();\n\tscanf(\"%s\",s);\n\tint n=strlen(s);\n\tVI qm;\n\trep(i,0,n) if (s[i]=='?') qm.pb(i);\n\tint m=SZ(qm),g=cur-pool;\n\trep(S,0,(1<<14)) rep(j,0,g) dp[S][j]=-(1ll<<60);\n\tdp[0][0]=0;\n\t/*rep(j,0,g) {\n\t\tprintf(\"%d %lld\\n\",j,pool[j].fg);\n\t\trep(k,0,14) printf(\"go %d %d %d\\n\",j,k,pool[j].go[k]-pool);\n\t}*/\n\tll ans=-(1ll<<60);\n\trep(pf,0,m+1) {\n\t\tint l=(pf==0)?0:qm[pf-1]+1;\n\t\tint r=(pf==m)?(n-1):(qm[pf]-1);\n\t\trep(j,0,g) {\n\t\t\tnode *p=pool+j;\n\t\t\tll ss=0;\n\t\t\trep(k,l,r+1) {\n\t\t\t\tassert(s[k]!='?');\n\t\t\t\tp=p->go[s[k]-'a'];\n\t\t\t\tss+=p->fg;\n\t\t\t}\n\t\t\tgo[pf][j]=p-pool;\n\t\t\tval[pf][j]=ss;\n\t\t}\n\t}\n\trep(S,0,(1<<14)) {\n\t\tint pf=__builtin_popcount(S);\n\t\tif (pf>m) continue;\n\t\trep(j,0,g) tmp[j]=-(1ll<<60);\n\t\trep(j,0,g) tmp[go[pf][j]]=max(tmp[go[pf][j]],dp[S][j]+val[pf][j]);\n\t\tif (__builtin_popcount(S)==m) {\n\t\t\trep(i,0,g) ans=max(ans,tmp[i]);\n\t\t}\n\t\t//rep(k,0,g) printf(\"Tmp %d %d %lld\\n\",S,k,tmp[k]);\n\t\t//rep(k,0,g) printf(\"Dp %d %d %lld\\n\",S,k,dp[S][k]);\n\t\trep(j,0,14) if (!(S&(1<<j))) {\n\t\t\trep(k,0,g) {\n\t\t\t\tnode *p=pool[k].go[j];\n\t\t\t\tdp[S|(1<<j)][p-pool]=max(dp[S|(1<<j)][p-pool],tmp[k]+p->fg);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "string suffix structures"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Letters and Question Marks.json",
    "editorial_link": "https://codeforces.com//blog/entry/75147",
    "editorial": "Suppose we want to calculate the value of some already fixed string (we\r\nshould be able to do so at least to solve the test cases without\r\nquestion marks). How can we do it? We can use some substring searching\r\nalgorithms to calculate F(S, t_i), but a better solution is to build an\r\nAho-Corasick automaton over the array [t_1, t_k], and then for each node\r\ncalculate the sum of costs of all strings ending in that node (these are\r\nthe strings represented by that node and the strings represented by\r\nother nodes reachable by suffix links). After that, process S by the\r\nautomaton and calculate the sum of the aforementioned values over all\r\nstates that were reached. Building an Aho-Corasick automaton can be done\r\nin O(\r\nsum\r\nlimits_{i = 1}^{k} |t_i|), and processing the string S in O(|S|).Okay,\r\nwhat if weâve got some question marks in our string? The first solution\r\nthat comes to mind is to calculate dp[i][mask][c] we processed i first\r\npositions in S, used a mask of characters for question marks, and the\r\ncurrent state of the automaton is c; then dp[i][mask][c] denotes the\r\nmaximum value of first i characters of S we could have got. But itâs\r\nO(L|S|2^KK), where L =\r\nsum\r\nlimits_{i = 1}^{k} |t_i| and K is the size of the alphabet, which is too\r\nslow.To speed it up, we can see that there are only 14 positions in our\r\nstring where we actually choose something in our dynamic programming.\r\nAll substrings not containing question marks can be skipped in O(1) as\r\nfollows: for each substring of S bounded by two question marks (or\r\nbounded by one question mark and one of the ends of S) and each state of\r\nthe automaton x, we may precalculate the resulting state of the\r\nautomaton and the change to the value of the string, if we process this\r\nsubstring by the automaton with the initial state x. This precalculation\r\nis done in O(L|S|) overall, and using this, we may skip the states of\r\ndynamic programming such that i is not a position with a question mark,\r\nso our complexity becomes O(L2^KK + L|S|).A note about the model\r\nsolution: itâs a bit more complicated because we wanted to increase the\r\nconstraints to |S|\r\nle 8\r\ncdot 10^6, but then we decided that it would be too complicated to code,\r\nso the main function still contains some parts of the code that were\r\nused to improve its complexity. We will post a clearer version of the\r\nmodel solution soon.\r\n",
    "hint": []
}