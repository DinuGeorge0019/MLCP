{
    "link": "https://codeforces.com//contest/2042/problem/F",
    "problemId": "3063464",
    "problem_idx": "F",
    "shortId": "2042F",
    "contest_number": "2042",
    "problem_submissions": {
        "E": [
            294423774,
            294419934,
            294425145,
            294427314,
            294461391,
            294454616,
            294469820,
            294456785,
            294473828,
            294432050,
            294452832,
            294430074,
            294720157,
            294431481,
            294468510,
            294470387,
            294430159
        ],
        "F": [
            294412520,
            294425551,
            294432280,
            294452436,
            294434993,
            294433145,
            294446063,
            294428799,
            294413717,
            294412873,
            294411042,
            294425120,
            294428614,
            294424117,
            294468671,
            294445770,
            294425722,
            294433551,
            294468661,
            294431992,
            294436625
        ],
        "D": [
            294403997,
            294407353,
            294409781,
            294414370,
            294407554,
            294410319,
            294417815,
            294419253,
            294437550,
            294410412,
            294413967,
            294418349,
            294411907,
            294402733,
            294411823,
            294409744,
            294417262,
            294417181,
            294415900
        ],
        "C": [
            294397589,
            294400380,
            294403833,
            294401565,
            294414063,
            294405958,
            294407677,
            294415266,
            294453518,
            294402202,
            294397037,
            294403746,
            294403563,
            294397148,
            294404737,
            294399098,
            294402722,
            294400450,
            294396822
        ],
        "B": [
            294394491,
            294397696,
            294398701,
            294393052,
            294393883,
            294395178,
            294398939,
            294412364,
            294455866,
            294393748,
            294393435,
            294395970,
            294392768,
            294392321,
            294399650,
            294391444,
            294395529,
            294395407,
            294392933
        ],
        "A": [
            294390734,
            294395467,
            294390153,
            294389939,
            294390115,
            294390408,
            294402923,
            294412466,
            294454482,
            294389870,
            294390174,
            294391619,
            294390031,
            294390265,
            294390266,
            294389845,
            294389856,
            294390624,
            294389907
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136886",
    "editorial": "To begin with, let\u00e2\u0080\u0099s understand how to calculate the answer if we\r\nconsider only one query of the third type. For this, we can use the\r\nfollowing dynamic programming: the maximum result if we have considered\r\nthe first elements and chosen boundaries of subsegments (i.e., the first\r\nsegment has not started yet, the first segment has started, the first\r\nsegment is finished, but the second segment hasn\u00e2\u0080\u0099t started yet, and so\r\non). The transitions in this dynamic programming are quite\r\nstraightforward: we can select the current element as the next boundary\r\nof the subsegment (increase by ), in which case we have to increase the\r\nvalue of dynamic programming by ; or we can keep the current value of .\r\nAdditionally, the dynamic programming value needs to be increased by if\r\nthe value of corresponds to an open segment ( or ). Note that an element\r\ncan be both the left and the right border of the segment at the same\r\ntime; so we also need a transition from to and from to .Note that the\r\ntransition from to requires only numbers: , , . Therefore, this dynamic\r\nprogramming can be easily packaged within some data structure, for\r\nexample, a segment tree.In each vertex of the segment tree, let\u00e2\u0080\u0099s store\r\na transition matrix of size the maximum result if we started in this\r\nsegment in state with and must end in state with . This matrix is easy\r\nto update when changing values in the arrays and , and it is also easy\r\nto merge (to merge two such matrices, it is necessary to consider\r\ntriples of the form , and there are only of them).Thus, we know how to\r\nperform one query in .Note that you should keep a static size array in\r\neach vertex of the segment tree (for example, you can use ) in C++; if\r\nyou use something like a , it will consume much more memory (static\r\narrays require about bytes for each vertex of the segment tree, which is\r\nalready a lot). This also works faster in practice, even though the\r\nasymptotic complexity of the solution is the same.\r\n",
    "name": "F. Two Subarrays",
    "statement": "You are given two integer arrays a and b, both of size n.Let\u2019s define\r\nthe cost of the subarray [l, r] as a_l + a_{l + 1} +\r\ncdots + a_{r - 1} + a_r + b_l + b_r. If l=r, then the cost of the\r\nsubarray is a_l + 2\r\ncdot b_l.You have to perform queries of three types: \"1 p x\" assign\r\na_{p} := x; \"2 p x\" assign b_{p} := x; \"3 l r\" find within the segment\r\n[l, r] with the maximum total cost and print their total cost.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"using namespace std;#define all(x) x.begin(),x.end()template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << \" \" << p.second; }template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { string sep; for (const T &x : v) os << sep << x, sep = \" \"; return os; }#ifdef LOCAL#include \"debug.h\"#else#define debug(...) 42#define ASSERT(...) 42#endiftypedef long long ll;typedef vector<int> vi;typedef vector<vi> vvi;typedef pair<int,int> pi;const ll oo = 1e18;int sgn(int i) {    if(i%2==1) return -1;    return 0;}struct node {    ll suma=0;    ll mat[5][5];    // i-->j in the automaton!    node() {        // *this = node(0);        for(int i=0;i<5;++i) {            fill(mat[i],mat[i]+5,-oo);            mat[i][i]=0; // do nothing is free!        }    }    node(ll a, ll b) {        *this = node();        suma=a;        for(int i=0;i<4;i+=2) {            mat[i][i+2]=2*b+a;            mat[i][i+1]=0+b;            mat[i+1][i+2]=a+b;        }    }\u00a0    void merge(node o) {        for(int i=0;i<5;++i) {            for(int j=i;j<5;++j) {                o.mat[i][j]+=(sgn(j)-sgn(i))*suma;            }        }        \u00a0        node res;        for(int i=0;i<5;++i) {            for(int j=i;j<5;++j) for(int k=j;k<5;++k) {                res.mat[i][k]=max(res.mat[i][k],mat[i][j]+o.mat[j][k]);            }        }        res.suma=suma+o.suma;        *this=res;    }    friend node merge(node a, const node& b) {        a.merge(b);        return a;    }};struct segtree {    int ptwo;    vector<node> seg;    segtree(){}    node& operator[](int i) {        return seg[i+ptwo];    }    segtree(int nn) {        ptwo=nn;        seg.assign(ptwo*2,{});    }    auto query(int l, int r) {        assert(l>=0 and l<ptwo and r >=0 and r<ptwo);        l+=ptwo; r+=ptwo;        node resl, resr;        while(l and l<=r) {            if(l%2==1) resl = merge(resl,seg[l++]);            if(r%2==0) resr = merge(seg[r--],resr);            l/=2; r/=2;        }        return merge(resl,resr);    }    void update(int i, int aa, int bb) {        assert(i>=0 and i<ptwo);        i+=ptwo;        seg[i] = node(aa,bb);        for(i/=2;i>=1;i/=2) {            seg[i] = merge(seg[2*i],seg[2*i+1]);        }    }    void build() {        for(int i=ptwo-1;i>=1;--i) {            seg[i] = merge(seg[2*i],seg[2*i+1]);        }    }};int main() {    ios_base::sync_with_stdio(false);    cin.tie(NULL);    int n; cin >> n;    vi a(n);    vi b(n);    for(auto& i : a) cin >> i;    for(auto& i : b) cin >> i;    segtree seg(n);    for(int i=0;i<n;++i) seg[i] = node(a[i],b[i]);    seg.build();    int q; cin >> q;    while(q--) {        int t; cin >> t;        if(t<=2) {            int p,x; cin >> p >> x;            --p;            if(t==1) a[p]=x;            else b[p]=x;            seg.update(p,a[p],b[p]);        } else {            int l,r; cin >> l >> r;            --l,--r;            cout << seg.query(l,r).mat[0][4] << '\\n';        }    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "implementation",
        "matrices"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Two Subarrays.json"
}