{
    "link": "https://codeforces.com//contest/1303/problem/F",
    "problemId": "538605",
    "problem_idx": "F",
    "shortId": "1303F",
    "contest_number": "1303",
    "problem_submissions": {
        "G": [
            71097266,
            70883386,
            70955431,
            70955302,
            71079595,
            71079587,
            71079399,
            71079349,
            71033664,
            70936374,
            70936308,
            70936214,
            70880989,
            70891160,
            70926122,
            70886272,
            71216890,
            71204250,
            70902620,
            71200015,
            70940169,
            71279910,
            70899562,
            71278035,
            70896282,
            70900541,
            70900494
        ],
        "F": [
            71044888,
            71044744,
            70899994,
            70890051,
            70888815,
            70932923,
            70932898,
            70932421,
            70932306,
            70932207,
            70932013,
            70931555,
            70915800,
            70904497,
            70912908,
            70884185,
            138818627,
            70892348,
            70886515,
            70891950,
            71199846,
            70884407,
            70897531,
            70893903,
            70894963,
            70893107,
            70925189,
            70924800,
            70897907
        ],
        "E": [
            70868559,
            70868408,
            70868922,
            70872692,
            70869150,
            70869901,
            70874174,
            70872386,
            70874403,
            70875550,
            71199810,
            70873171,
            70863746,
            70871476,
            70905263,
            70869281,
            70875226,
            70874988,
            70881045,
            70874968,
            70882383,
            70877044
        ],
        "D": [
            70863251,
            70862650,
            70863288,
            70862684,
            70865048,
            70865462,
            70867179,
            70866583,
            70869772,
            70868436,
            71199774,
            70869707,
            70873016,
            70865851,
            70862875,
            70869379,
            70868162,
            70869500,
            70869186,
            70873860,
            70869244
        ],
        "C": [
            70859686,
            70858172,
            70859652,
            70865909,
            70861024,
            70860138,
            70862819,
            70861003,
            70864530,
            70863875,
            71199753,
            70865732,
            70856962,
            70860948,
            70858736,
            70863123,
            70860398,
            70864062,
            70861729,
            70862531,
            70860453
        ],
        "B": [
            70855213,
            70854594,
            70853630,
            70935416,
            70856554,
            70855070,
            70861321,
            70855979,
            70856395,
            70857261,
            70857192,
            71199724,
            70861383,
            70852833,
            70856458,
            70855360,
            70857332,
            70856143,
            70857430,
            70853208,
            70856253,
            70853781
        ],
        "A": [
            70849936,
            70850631,
            70849990,
            70849934,
            70850041,
            70849959,
            70849980,
            70850863,
            70852663,
            70850352,
            71199700,
            70859542,
            70849914,
            70851564,
            70849996,
            70851983,
            70850145,
            70850480,
            70850071,
            70850741,
            70850778
        ]
    },
    "name": "F. Number of Components",
    "statement": "You are given a matrix n\r\ntimes m, initially filled with zeroes. We define a_{i, j} as the element\r\nin the i-th row and the j-th column of the matrix.Two cells of the\r\nmatrix are if they share a side, and the elements in these cells are\r\nequal. Two cells of the matrix belong to the same if there exists a\r\nsequence s_1, s_2, ..., s_k such that s_1 is the first cell, s_k is the\r\nsecond cell, and for every i\r\nin [1, k - 1], s_i and s_{i + 1} are connected.You are given q queries\r\nof the form x_i y_i c_i (i\r\nin [1, q]). For every such query, you have to do the following: replace\r\nthe element a_{x, y} with c; count the number of connected components in\r\nthe matrix. There is one additional constraint: for every i\r\nin [1, q - 1], c_i\r\nle c_{i + 1}.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define ar array\n \nconst int mxN=300, mxQ=2e6;\nint n, m, q, ans[mxQ+1], a[mxN][mxN], p[mxN*mxN];\nvector<ar<int, 3>> ta[mxQ+1], td[mxQ+1];\nbool vis[mxN*mxN];\n \nint find(int x) {\n\treturn x^p[x]?p[x]=find(p[x]):x;\n}\n \nbool join(int x, int y) {\n\tif((x=find(x))==(y=find(y)))\n\t\treturn 0;\n\tp[x]=y;\n\treturn 1;\n}\n \nvoid solve(int c) {\n\tiota(p, p+n*m, 0);\n\tmemset(vis, 0, n*m);\n\tauto f=[&](int x1, int y1, int x2, int y2, int t) {\n\t\tif(x2<0||x2>=n||y2<0||y2>=m||!vis[x2*m+y2])\n\t\t\treturn;\n\t\tint x=join(x1*m+y1, x2*m+y2);\n\t\tans[t]-=x;\n\t};\n\tfor(ar<int, 3> a : ta[c]) {\n\t\t++ans[a[0]];\n\t\tf(a[1], a[2], a[1]-1, a[2], a[0]);\n\t\tf(a[1], a[2], a[1]+1, a[2], a[0]);\n\t\tf(a[1], a[2], a[1], a[2]-1, a[0]);\n\t\tf(a[1], a[2], a[1], a[2]+1, a[0]);\n\t\tvis[a[1]*m+a[2]]=1;\n\t}\n\tfor(ar<int, 3> a : td[c])\n\t\tvis[a[1]*m+a[2]]=0;\n\tiota(p, p+n*m, 0);\n\tauto g=[&](int x1, int y1, int x2, int y2, int t) {\n\t\tif(x2<0||x2>=n||y2<0||y2>=m||!vis[x2*m+y2])\n\t\t\treturn;\n\t\tint x=join(x1*m+y1, x2*m+y2);\n\t\tans[t]+=x;\n\t};\n\tfor(int i=0; i<n; ++i) {\n\t\tfor(int j=0; j<m; ++j) {\n\t\t\tif(!vis[i*m+j])\n\t\t\t\tcontinue;\n\t\t\tg(i, j, i-1, j, q);\n\t\t\tg(i, j, i+1, j, q);\n\t\t\tg(i, j, i, j-1, q);\n\t\t\tg(i, j, i, j+1, q);\n\t\t}\n\t}\n\treverse(td[c].begin(), td[c].end());\n\tfor(ar<int, 3> a : td[c]) {\n\t\t--ans[a[0]];\n\t\tg(a[1], a[2], a[1]-1, a[2], a[0]);\n\t\tg(a[1], a[2], a[1]+1, a[2], a[0]);\n\t\tg(a[1], a[2], a[1], a[2]-1, a[0]);\n\t\tg(a[1], a[2], a[1], a[2]+1, a[0]);\n\t\tvis[a[1]*m+a[2]]=1;\n\t}\n}\n \nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n \n\tcin >> n >> m >> q;\n\tfor(int i=0; i<n; ++i)\n\t\tfor(int j=0; j<m; ++j)\n\t\t\tta[0].push_back({0, i, j});\n\tfor(int i=0, x, y, c; i<q; ++i) {\n\t\tcin >> x >> y >> c, --x, --y;\n\t\tif(a[x][y]==c)\n\t\t\tcontinue;\n\t\tta[c].push_back({i, x, y});\n\t\ttd[a[x][y]].push_back({i, x, y});\n\t\ta[x][y]=c;\n\t}\n\tfor(int i=0; i<=max(1000, (mxQ-1)/(n*m)+1); ++i)\n\t\tsolve(i);\n\tfor(int i=0; i<q; ++i) {\n\t\tans[i+1]+=ans[i];\n\t\tcout << ans[i] << \"\\n\";\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "implementation"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Number of Components.json",
    "editorial_link": "https://codeforces.com//blog/entry/73872",
    "editorial": "Note that because of the low constraints on the number of colors, the\r\nproblem can be solved independently for each color. Now you can divide\r\nthe queries into two types: add a cell to the field and delete it. You\r\nhave to maintain the number of components formed by added cells. Cell\r\ndeletions will occur after all additions because of the condition . The\r\nfirst part of the solution will be to calculate the number of components\r\nwhile adding new cells. This is a standard problem that can be solved\r\nusing the DSU.After that, we should note that if we consider the process\r\nof removing cells from the end, this process is similar to the process\r\nof adding. Therefore, we have to process delete requests from the end in\r\nthe same way as add requests, only their contribution to the number of\r\ncomponents will be opposite in sign.\r\n"
}