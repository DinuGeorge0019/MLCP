{
    "link": "https://codeforces.com//contest/1644/problem/E",
    "problemId": "1306306",
    "problem_idx": "E",
    "shortId": "1644E",
    "contest_number": "1644",
    "problem_submissions": {
        "F": [
            147320866,
            147353077,
            147335774,
            147336779,
            147338284,
            147344072,
            147361395,
            147361328,
            147360591,
            147341020,
            147347713,
            147363763,
            147363723,
            147322590,
            152772960,
            147359576,
            147689521
        ],
        "E": [
            147306717,
            147306569,
            147311348,
            147309095,
            147307844,
            147307929,
            147314427,
            147326156,
            147310695,
            147307982,
            147306896,
            147305676,
            147310587,
            147307037,
            147315289,
            147313121,
            147313445,
            147321773
        ],
        "D": [
            147293584,
            147307300,
            147301707,
            147294952,
            147298642,
            147298634,
            147300618,
            147333853,
            147291913,
            147295056,
            147298209,
            147295009,
            147295505,
            147297361,
            147296680,
            147301724,
            147303329,
            147296313
        ],
        "C": [
            147288888,
            147290549,
            147296803,
            147287863,
            147292950,
            147291474,
            147293826,
            147331175,
            147286835,
            147291088,
            147291894,
            147288455,
            147290620,
            147288872,
            147289111,
            147292816,
            147293660,
            147289532
        ],
        "B": [
            147281121,
            147281154,
            147291952,
            147280086,
            147282998,
            147283506,
            147285667,
            147332125,
            147281901,
            147282926,
            147283802,
            147281429,
            147284985,
            147282861,
            147283027,
            147287392,
            147286913,
            147282167
        ],
        "A": [
            147278514,
            147278406,
            147278697,
            147278304,
            147278969,
            147279113,
            147278307,
            147332805,
            147278673,
            147278387,
            147278783,
            147278331,
            147278464,
            147278483,
            147278302,
            147278920,
            147278819,
            147278413
        ]
    },
    "name": "E. Expand the Path",
    "statement": "Consider a grid of size n\r\ntimes n. The rows are numbered top to bottom from 1 to n, the columns\r\nare numbered left to right from 1 to n.The robot is positioned in a cell\r\n(1, 1). It can perform two types of moves: move one cell down; move one\r\ncell right. The robot is not allowed to move outside the grid.You are\r\ngiven a sequence of moves s the initial path of the robot. This path\r\ndoesn’t lead the robot outside the grid.You are allowed to perform an\r\narbitrary number of modifications to it (possibly, zero). With one\r\nmodification, you can duplicate one move in the sequence. That is,\r\nreplace a single occurrence of with or a single occurrence of with\r\n.Count the number of cells such that there exists at least one sequence\r\nof modifications that the robot visits this cell on the modified path\r\nand doesn’t move outside the grid.\r\n",
    "solutions": [
        "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\nint MOD =  998244353 ;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n\nconst int LIM = 1000005;\n\nvector<int> facs(LIM), invfacs(LIM), invs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n\n    for (int i = 1; i<LIM; i++) invs[i] = mul(invfacs[i], facs[i-1]);\n\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\n/*\nconst int mod = 998244353;\n\ntemplate<int mod>\nstruct NTT {\n    static constexpr int max_lev = __builtin_ctz(mod - 1);\n\n    int prod[2][max_lev - 1];\n\n    NTT() {\n        int root = find_root();//(mod == 998244353) ? 31 : find_root();\n        int rroot = power(root, mod - 2);\n        vector<vector<int>> roots(2, vector<int>(max_lev - 1));\n        roots[0][max_lev - 2] = root;\n        roots[1][max_lev - 2] = rroot;\n        for (int tp = 0; tp < 2; ++tp) {\n            for (int i = max_lev - 3; i >= 0; --i) {\n                roots[tp][i] = mul(roots[tp][i + 1], roots[tp][i + 1]);\n            }\n        }\n        for (int tp = 0; tp < 2; ++tp) {\n            int cur = 1;\n            for (int i = 0; i < max_lev - 1; ++i) {\n                prod[tp][i] = mul(cur, roots[tp][i]);\n                cur = mul(cur, roots[tp ^ 1][i]);\n            }\n        }\n    }\n\n    template<bool inv>\n    void fft(int *a, int lg) const {\n        const int n = 1 << lg;\n        int pos = max_lev - 1;\n        for (int it = 0; it < lg; ++it) {\n            const int h = inv ? lg - 1 - it : it;\n            const int shift = (1 << (lg - h - 1));\n            int coef = 1;\n            for (int start = 0; start < (1 << h); ++start) {\n                for (int i = start << (lg - h); i < (start << (lg - h)) + shift; ++i) {\n                    if (!inv) {\n                        const int y = mul(a[i + shift], coef);\n                        a[i + shift] = a[i];\n                        inc(a[i], y);\n                        dec(a[i + shift], y);\n                    } else {\n                        const int y = mul(a[i] + mod - a[i + shift], coef);\n                        inc(a[i], a[i + shift]);\n                        a[i + shift] = y;\n                    }\n                }\n                coef = mul(coef, prod[inv][__builtin_ctz(~start)]);\n            }\n        }\n    }\n\n    vector<int> product(vector<int> a, vector<int> b) const {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        const int sz = a.size() + b.size() - 1;\n        const int lg = 32 - __builtin_clz(sz - 1), n = 1 << lg;\n        a.resize(n);\n        b.resize(n);\n        fft<false>(a.data(), lg);\n        fft<false>(b.data(), lg);\n        for (int i = 0; i < n; ++i) {\n            a[i] = mul(a[i], b[i]);\n        }\n        fft<true>(a.data(), lg);\n        a.resize(sz);\n        const int rn = power(n, mod - 2);\n        for (int &x : a) {\n            x = mul(x, rn);\n        }\n        return a;\n    }\n\nprivate:\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline void dec(int &x, int y) {\n        x -= y;\n        if (x < 0) {\n            x += mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, (1 << max_lev)) == 1 && power(root, (1 << (max_lev - 1))) != 1) {\n                return root;\n            }\n        }\n    }\n};\n\nNTT<mod> ntt;*/\n\nvoid solve()\n{\n    ll n; cin>>n;\n    string s; cin>>s;\n    int cntr = 0; int cntd = 0;\n    for (auto c: s)\n    {\n        if (c=='D') cntd++;\n        else cntr++;\n    }\n\n\n    int x = 1; int y = 1;\n\n    map<int, int> xmap, ymap;\n\n    xmap[1] = 1;\n    ymap[1] = 1;\n\n    for (auto c: s)\n    {\n        if (c=='D') y++;\n        else x++;\n        xmap[x] = y;\n        ymap[y] = x;\n    }\n\n    ll leftr = n-x;\n    ll leftd = n-y;\n\n\n    ll ans = 1 + (int)s.size();\n    for (auto it: xmap) if (it.second>1)\n    {\n        ans+=min(n-it.second, leftd);\n    }\n\n    for (auto it: ymap) if (it.second>1)\n    {\n        ans+=min(n-it.second, leftr);\n    }\n\n    if (x>1 && y>1) ans+=1ll*min(n-x, leftr)*min(n-y, leftd);\n    cout<<ans<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t;\n    while (t--) solve();\n\n}\n/*\n1\n3\nD\n */"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "data structures",
        "implementation",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Expand the Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/100227",
    "editorial": "First, get rid of the corner cases. If the string doesnât contain either\r\nof the letters, the answer is .The general solution to the problem is to\r\nconsider every single way to modify the path, then find the union of\r\nthem. Well, every single path is too much, letâs learn to reduce the\r\nnumber of different sequences of modifications that we have to\r\nconsider.The main observation is that all cells that the robot can visit\r\nare enclosed in the space formed by the following two paths: the first\r\nâRâ is duplicated the maximum number of times, then the last âDâ is\r\nduplicated the maximum number of times; the first âDâ is duplicated the\r\nmaximum number of times, then the last âRâ is duplicated the maximum\r\nnumber of times. You can realize that by drawing the visited cells for\r\nsome large test.To show that more formally, you can consider the visited\r\ncells row by row. Letâs show that for every two different visited cells\r\nin the same row, all cells in-between them can also be visited.In\r\ngeneral case, we want to show that we can take the prefix of the path to\r\nthe left one of these cells and duplicate any âRâ on it to reach the\r\nright cell. The suffixes of the paths will remain the same as in the\r\ninitial path.If there exists an âRâ on the prefix, then we are good.\r\nOtherwise, the reason that it doesnât exist is that we duplicated âDâ\r\ntoo many times. Reduce that and there will be âRâ immediately after\r\nreaching the cell or earlier.We should also show that the number of âRâs\r\non the path to the left cell wonât reach the maximum allowed amount\r\nuntil reaching the right cell. Use the fact that the number of âDâs on\r\nboth prefixes of the paths is the same.The other non-obvious part is\r\nthat you canât reach cells outside this space. However, that can also be\r\nshown by analyzing each row independently.Finally, about the way to\r\ncalculate the area of this space. The main idea is to calculate the\r\ntotal number of cells outside this area and subtract it from .Notice\r\nthat non-visited cells form two separate parts: the one above the first\r\npath and the one to the left of the second path. These are pretty\r\nsimilar to each other. Moreover, you can calculate them with a same\r\nfunction. If we replace all âDâs in the string with âRâ and vice versa,\r\nthen these parts swap places. So we can calculate the upper part, swap\r\nthem and calculate it again.I think the algorithm is best described with\r\na picture. Consider test , , for example. First, there are some rows\r\nthat only have one cell visited. Then the first âRâ in the string\r\nappears. Since we duplicate it the maximum amount of times, it produces\r\na long row of visited cells. The remaining part of the part becomes the\r\noutline of the area.Note that the row that marks the end of the string,\r\nalways ends at the last column. Thus, only at most first rows matter. To\r\nbe exact, the amount of rows that matter is equal to the number of\r\nletters âDâ in the string.For each letter âDâ, letâs calculate the\r\nnumber of non-visited cells in a row it goes down to.I found the most\r\nconvenient way is to go over the string backwards. We start from the row\r\ncorresponding to the number of letters âDâ in the string. It has zero\r\nnon-visited cells. We can maintain the number of non-visited cells in\r\nthe current row. If we encounter an âRâ in the string, we add to this\r\nnumber. If we encounter a âDâ, we add the number to the answer.We have\r\nto stop after the first âRâ in the string. The later (well, earlier,\r\nsince we are going backwards) part corresponds to the prefix of letters\r\nâDâ the starting column on the picture.Each of these rows have visited\r\ncell, so non-visited. So we can easily calculate this part as\r\nwell.Overall complexity: per testcase.\r\n",
    "hint": []
}