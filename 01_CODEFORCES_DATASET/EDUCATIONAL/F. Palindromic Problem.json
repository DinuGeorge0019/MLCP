{
    "link": "https://codeforces.com//contest/1913/problem/F",
    "problemId": "2387092",
    "problem_idx": "F",
    "shortId": "1913F",
    "contest_number": "1913",
    "problem_submissions": {
        "F": [
            237765417,
            237786045,
            237798410,
            237793751,
            237794290,
            237782267,
            237795023,
            237800140,
            237807937,
            237810699,
            237812614,
            249487858,
            249487734,
            237811339,
            237810034,
            237786173,
            237918310,
            238095706,
            238317726,
            238317705,
            238317604,
            238062834,
            238062445,
            237828170
        ],
        "E": [
            237747038,
            237760786,
            237768219,
            237770076,
            237769118,
            237750176,
            237762212,
            237777254,
            237781408,
            237770526,
            237770804,
            237785103,
            237769588,
            237762037,
            237767968,
            237768315,
            237776019,
            237777315,
            237775619
        ],
        "D": [
            237741941,
            237751825,
            237754635,
            237754576,
            237759161,
            237795697,
            237798473,
            237753926,
            237756867,
            237764842,
            237762933,
            237761396,
            237809126,
            237799893,
            237754034,
            237759987,
            237761087,
            237760420,
            237755829,
            237761290
        ],
        "C": [
            237735693,
            237739173,
            237740092,
            237741221,
            237739010,
            237738520,
            237799594,
            237738193,
            237740375,
            237744478,
            237744080,
            237745844,
            237762290,
            237803855,
            237741083,
            237740358,
            237744813,
            237743742,
            237745330,
            237745113
        ],
        "B": [
            237734023,
            237735619,
            237736194,
            237737923,
            237736443,
            237735162,
            237800569,
            237735958,
            237737285,
            237740748,
            237737318,
            237739744,
            237743140,
            237806408,
            237735801,
            237736968,
            237740846,
            237738174,
            237741145,
            237740499
        ],
        "A": [
            237733399,
            237733472,
            237733545,
            237733680,
            237733544,
            237733357,
            237734167,
            237733513,
            237734405,
            237733701,
            237733822,
            237734094,
            237807435,
            237733584,
            237733737,
            237733530,
            237733681,
            237735085,
            237733871
        ]
    },
    "name": "F. Palindromic Problem",
    "statement": "You are given a string s of length n, consisting of lowercase Latin\r\nletters.You are allowed to replace at most one character in the string\r\nwith an arbitrary lowercase Latin letter.Print the lexicographically\r\nminimal string that can be obtained from the original string and\r\ncontains the maximum number of palindromes as substrings. Note that if a\r\npalindrome appears more than once as a substring, it is counted the same\r\nnumber of times it appears.The string a is lexicographically smaller\r\nthan the string b if and only if one of the following holds: a is a\r\nprefix of b, but a\r\nne b; in the first position where a and b are different, the string a\r\ncontains a letter that appears earlier in the alphabet than the\r\ncorresponding letter in b.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 18.12.2023 09:53:41       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nvector<int> suffix_array(int n, const T &s, int char_bound) {\n  vector<int> a(n);\n  if (n == 0) {\n    return a;\n  }\n  if (char_bound != -1) {\n    vector<int> aux(char_bound, 0);\n    for (int i = 0; i < n; i++) {\n      aux[s[i]]++;\n    }\n    int sum = 0;\n    for (int i = 0; i < char_bound; i++) {\n      int add = aux[i];\n      aux[i] = sum;\n      sum += add;\n    }\n    for (int i = 0; i < n; i++) {\n      a[aux[s[i]]++] = i;\n    }\n  } else {\n    iota(a.begin(), a.end(), 0);\n    sort(a.begin(), a.end(), [&s](int i, int j) { return s[i] < s[j]; });\n  }\n  vector<int> sorted_by_second(n);\n  vector<int> ptr_group(n);\n  vector<int> new_group(n);\n  vector<int> group(n);\n  group[a[0]] = 0;\n  for (int i = 1; i < n; i++) {\n    group[a[i]] = group[a[i - 1]] + (!(s[a[i]] == s[a[i - 1]]));\n  }\n  int cnt = group[a[n - 1]] + 1;\n  int step = 1;\n  while (cnt < n) {\n    int at = 0;\n    for (int i = n - step; i < n; i++) {\n      sorted_by_second[at++] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      if (a[i] - step >= 0) {\n        sorted_by_second[at++] = a[i] - step;\n      }\n    }\n    for (int i = n - 1; i >= 0; i--) {\n      ptr_group[group[a[i]]] = i;\n    }\n    for (int i = 0; i < n; i++) {\n      int x = sorted_by_second[i];\n      a[ptr_group[group[x]]++] = x;\n    }\n    new_group[a[0]] = 0;\n    for (int i = 1; i < n; i++) {\n      if (group[a[i]] != group[a[i - 1]]) {\n        new_group[a[i]] = new_group[a[i - 1]] + 1;\n      } else {\n        int pre = (a[i - 1] + step >= n ? -1 : group[a[i - 1] + step]);\n        int cur = (a[i] + step >= n ? -1 : group[a[i] + step]);\n        new_group[a[i]] = new_group[a[i - 1]] + (pre != cur);\n      }\n    }\n    swap(group, new_group);\n    cnt = group[a[n - 1]] + 1;\n    step <<= 1;\n  }\n  return a;\n}\n\ntemplate <typename T>\nvector<int> suffix_array(const T &s, int char_bound) {\n  return suffix_array((int) s.size(), s, char_bound);\n}\n\ntemplate <typename T>\nvector<int> build_lcp(int n, const T &s, const vector<int> &sa) {\n  assert((int) sa.size() == n);\n  vector<int> pos(n);\n  for (int i = 0; i < n; i++) {\n    pos[sa[i]] = i;\n  }\n  vector<int> lcp(max(n - 1, 0));\n  int k = 0;\n  for (int i = 0; i < n; i++) {\n    k = max(k - 1, 0);\n    if (pos[i] == n - 1) {\n      k = 0;\n    } else {\n      int j = sa[pos[i] + 1];\n      while (i + k < n && j + k < n && s[i + k] == s[j + k]) {\n        k++;\n      }\n      lcp[pos[i]] = k;\n    }\n  }\n  return lcp;\n}\n\ntemplate <typename T>\nvector<int> build_lcp(const T &s, const vector<int> &sa) {\n  return build_lcp((int) s.size(), s, sa);\n}\n\ntemplate <typename T, class F = function<T(const T&, const T&)>>\nclass SparseTable {\n public:\n  int n;\n  vector<vector<T>> mat;\n  F func;\n\n  SparseTable(const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int max_log = 32 - __builtin_clz(n);\n    mat.resize(max_log);\n    mat[0] = a;\n    for (int j = 1; j < max_log; j++) {\n      mat[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        mat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);\n      }\n    }\n  }\n\n  T get(int from, int to) const {\n    assert(0 <= from && from <= to && to <= n - 1);\n    int lg = 32 - __builtin_clz(to - from + 1) - 1;\n    return func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  string u = s + \"#\" + string(s.rbegin(), s.rend());\n  auto sa = suffix_array(u, 256);\n  auto lcp = build_lcp(u, sa);\n  SparseTable<int> st(lcp, [&](int i, int j) { return min(i, j); });\n  vector<int> pos(sa.size());\n  for (int i = 0; i < (int) sa.size(); i++) {\n    pos[sa[i]] = i;\n  }\n  auto LCP = [&](int i, int j) {\n    i = n + 1 + (n - 1 - i);\n    i = pos[i];\n    j = pos[j];\n    if (i > j) {\n      swap(i, j);\n    }\n    return st.get(i, j - 1);\n  };\n  const int ALPHA = 26;\n  vector<vector<long long>> delta(n, vector<long long>(ALPHA));\n  vector<long long> broke_k(n + 1);\n  vector<long long> broke_b(n + 1);\n  auto Add = [&](int l, int r, int k, int b) {\n    broke_k[l] += k;\n    broke_k[r + 1] -= k;\n    broke_b[l] += b;\n    broke_b[r + 1] -= b;\n  };\n  long long init = 0;\n  for (int t = 0; t <= 2 * (n - 1); t++) {\n    int i = t >> 1;\n    int j = (t + 1) >> 1;\n    int v = LCP(i, j);\n    init += v;\n    if (i - v >= 0 && j + v < n) {\n      assert(s[i - v] != s[j + v]);\n      int add = 1;\n      if (i - v - 1 >= 0 && j + v + 1 < n) {\n        add += LCP(i - v - 1, j + v + 1);\n      }\n      delta[i - v][(int) (s[j + v] - 'a')] += add;\n      delta[j + v][(int) (s[i - v] - 'a')] += add;\n    }\n    if (i == j) {\n      i -= 1;\n      j += 1;\n      v -= 1;\n    }\n    if (v > 0) {\n      Add(i - v + 1, i, 1, -(i - v));\n      Add(j, j + v - 1, -1, j + v);\n    }\n  }\n  vector<long long> broke(n);\n  for (int i = 0; i < n; i++) {\n    broke[i] = broke_k[i] * i + broke_b[i];\n    broke_k[i + 1] += broke_k[i];\n    broke_b[i + 1] += broke_b[i];\n  }\n  auto Better = [&](pair<int, int> a, pair<int, int> b) {\n    assert(a.first <= b.first);\n    if (a.first == b.first) {\n      return a.second < b.second;\n    }\n    return a.second < (int) (s[a.first] - 'a');\n  };\n  long long ans = init;\n  pair<int, int> p = {n, -1};\n  for (int i = n - 1; i >= 0; i--) {\n    for (int j = 0; j < 26; j++) {\n      if (j == (int) (s[i] - 'a')) {\n        continue;\n      }\n      long long cur = init + delta[i][j] - broke[i];\n      pair<int, int> q = {i, j};\n      if (cur > ans || (cur == ans && Better(q, p))) {\n        ans = cur;\n        p = q;\n      }\n    }\n  }\n  cout << ans << '\\n';\n  if (p.first < n) {\n    s[p.first] = (char) ('a' + p.second);\n  }\n  cout << s << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "hashing",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Palindromic Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/123493",
    "editorial": "Letâs recall the algorithm for counting the number of palindromes in a\r\nstring. For each position, we can calculate the longest odd and even\r\npalindromes with centers at that position (the right one for even). Then\r\nsum up all the values.If we forget about the complexity, we can consider\r\nthe following algorithm for solving the full problem. Iterate over the\r\nindex of the change and the new letter. Make the change, count the\r\nnumber of palindromes, and update the answer. In case of equality,\r\nchoose the lexicographically minimal change.Letâs keep the first step\r\nand optimize the rest. It wonât be possible to count the number of\r\npalindromes from scratch for every change, so letâs try to calculate how\r\nmuch their number will change from the original. Itâs also not feasible\r\nto compare all strings lexicographically naively, so we have to come up\r\nwith a faster way to compare.Letâs fix the change position . Which of\r\nthe longest palindromes change? If for some center , the longest\r\npalindrome included , then we definitely know its new length. Due to the\r\nchange at , the longest palindrome will stop at . If the longest\r\npalindrome did not reach , it will not change. And only if it stopped at\r\n, it can become longer, and we donât know by how much yet. But for each\r\ncenter and the parity of the palindrome, there are only positions to the\r\nleft and to the right where it stops. So, in total, we will need to make\r\nsuch checks.How to take into account the palindromes that become\r\nshorter? We need to calculate the sum of the differences for all\r\npalindromes that include . For an odd palindrome, this change looks like\r\nthis: , where is the center of the palindrome, and the values show the\r\ndifference in the number of palindromes for each position of the string.\r\nFor an even palindrome: . To calculate the sum at each position, we can\r\npre-calculate a difference array based on these values.The difference\r\narray usually implies first-order changes: write at , write at , then\r\ncollect the prefix sum to get . But we can also record second-order\r\nchanges. For the odd construction, we will write as follows. Let the\r\nlength of the palindrome be , and the center be . Then: ; ; . Then\r\niterate from left to right, maintaining two variables. The current\r\nchange and the current value. At each , add to the change, add the\r\nchange to the value, and save the value to some array.For the even case,\r\nit is built similarly. It is easy to see that such changes can be made\r\nat the same time. Basically the same as the regular difference\r\narray.Now, in each position, the total decrease in the length of the\r\npalindromes passing through that position is recorded. The answer will\r\ndecrease by almost this amount. The only difference is the odd-length\r\npalindromes with a center at this position. They will not change at all,\r\nand we accidentally subtracted them. Thus, letâs save the longest odd\r\npalindrome for each position in advance and add it back.Letâs learn how\r\nto calculate the longest palindromes for each center. Yes, there is the\r\nManacherâs algorithm for a static string. We can use it for counting at\r\nthe very beginning, but itâs not really necessary. Instead, letâs learn\r\nto count palindromes using suffix structures. In particular, with a\r\nsuffix array.It is known that with an additional sparse table, we can\r\nquery the longest common prefix of two suffixes in with pre-calculation\r\nin . Letâs build a suffix array on the string . Then we can query the\r\nLCP of both suffixes and reverse prefixes. Then the longest odd\r\npalindrome with center at is LCP(, ()). The even one is LCP(, ()).So, we\r\ncan count the palindromes at the very beginning with pre-calculation and\r\nextra calculations.The following task remains. For each position, the\r\ncenters of the palindromes that reach it are known. For each such\r\ncenter, we need to be able to recalculate how much longer the palindrome\r\nwill become after changing the letter at that position.Obviously, even\r\nthe new letter may still not match the letter on the other side. If it\r\ndoes match, we would like to know how many letters further match the\r\nopposite ones in the original string. And we already have a tool for\r\nthis. Itâs still a simple LCP query on the suffix to the right of the\r\nright letter and the reverse prefix to the left of the left letter.Now\r\nwe have everything necessary to recalculate the number of palindromes.If\r\nthe new count is greater than the current maximum, we will simply update\r\nthe answer. If it is equal, we need to check the lexicographic order.\r\nThe following check works: if one change increased the original letter,\r\nand the other decreased it, then the second one will definitely produce\r\na smaller string; if both changes decreased it, then the more left one\r\nwill produce a smaller string; if both are in the same position, the\r\nsmaller letter will produce a smaller string; if both changes increased\r\nit, then the more right one will produce a smaller string; if both are\r\nin the same position, the smaller letter will produce a smaller string.\r\nAll these checks can be performed in .Overall complexity: .\r\n",
    "hint": []
}