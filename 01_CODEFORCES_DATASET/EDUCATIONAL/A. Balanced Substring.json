{
    "link": "https://codeforces.com//contest/1569/problem/A",
    "problemId": "1103179",
    "problem_idx": "A",
    "shortId": "1569A",
    "contest_number": "1569",
    "problem_submissions": {
        "F": [
            128266355,
            128271363,
            128276594,
            128274140,
            128277636,
            128276419,
            128239230,
            128386349,
            128320123
        ],
        "E": [
            128250268,
            128256767,
            128246439,
            128253452,
            128257933,
            128258504,
            128255293,
            128254536,
            128252116,
            128261192,
            128578023,
            128259291,
            128263798,
            128266969,
            128259594,
            128258410,
            128275140,
            128271709,
            128263862,
            128264259
        ],
        "D": [
            128235337,
            128235527,
            128231804,
            128235402,
            128242825,
            128262573,
            128235767,
            128236235,
            128236769,
            128233977,
            128578016,
            128240282,
            128241897,
            128232635,
            128238819,
            128243586,
            128233606,
            128230968,
            128243956,
            128245831
        ],
        "C": [
            128220989,
            128228983,
            128226656,
            128226748,
            128234279,
            128264995,
            128226270,
            128225854,
            128229844,
            128225694,
            128578004,
            128230030,
            128228479,
            128225884,
            128230468,
            128226610,
            128225551,
            128233122,
            128232240,
            128234418
        ],
        "B": [
            128217208,
            128223439,
            128220536,
            128221217,
            128228682,
            128267165,
            128220994,
            128220572,
            128221551,
            128221442,
            128577996,
            128221801,
            128220084,
            128221194,
            128224466,
            128232979,
            128220020,
            128224325,
            128224652,
            128224175
        ],
        "A": [
            128212769,
            128212941,
            128213029,
            128212974,
            128213857,
            128267874,
            128212779,
            128212821,
            128212915,
            128213233,
            128577977,
            128213929,
            128212944,
            128212794,
            128212959,
            128213921,
            128212839,
            128214062,
            128216496,
            128214843
        ]
    },
    "name": "A. Balanced Substring",
    "statement": "You are given a string s, consisting of n letters, each letter is either\r\n\u201d or \u201d. The letters in the string are numbered from 1 to n.s[l; r] is a\r\ncontinuous substring of letters from index l to r of the string\r\ninclusive. A string is called balanced if the number of letters \u201d in it\r\nis equal to the number of letters \u201d. For example, strings \"\" and \"\" are\r\nbalanced and strings \"\" and \"\" are not.Find any non-empty balanced\r\nsubstring s[l; r] of string s. Print its l and r (1\r\nle l\r\nle r\r\nle n). If there is no such substring, then print -1 -1.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    string S; cin >> S;\n    F0R(i, N-1) {\n        if (S[i] != S[i+1]) {\n            cout << i+1 << \" \" << i+2 << nl; return;\n        }\n    }\n    cout << \"-1 -1\" << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Balanced Substring.json",
    "editorial_link": "https://codeforces.com//blog/entry/94721",
    "editorial": "Any non-empty balanced string contains at least one letter \u00e2\u0080\u009d and at\r\nleast one letter \u00e2\u0080\u009d. That implies that there\u00e2\u0080\u0099s an \u00e2\u0080\u009d adjacent to a \u00e2\u0080\u009d\r\nsomewhere in that string. Both strings \"\" and \"\" are balanced. Thus, any\r\nbalanced string contains a balanced substring of length . So the\r\nsolution is to check all pairs of adjacent letters. If there exists a\r\npair of different ones, print it.Overall complexity: per testcase.\r\n"
}