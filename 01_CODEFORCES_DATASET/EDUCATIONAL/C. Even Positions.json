{
    "link": "https://codeforces.com//contest/1997/problem/C",
    "problemId": "2784496",
    "problem_idx": "C",
    "shortId": "1997C",
    "contest_number": "1997",
    "problem_submissions": {
        "F": [
            273554813,
            273562336,
            273555588,
            273558521,
            273558184,
            273555359,
            273562297,
            273565830,
            273546283,
            273544285,
            273566836,
            273566119,
            273585907,
            273568802,
            273555309,
            273574760,
            273588700,
            273578615,
            273575242,
            273588906
        ],
        "E": [
            273537014,
            273527320,
            273531772,
            273535164,
            273526322,
            273540324,
            273541553,
            273544138,
            273572699,
            273564384,
            273777832,
            273550008,
            273548972,
            273536881,
            273554636,
            273544552,
            273556209,
            273544842,
            273546282,
            273666737,
            273666189,
            273553954,
            273545375
        ],
        "D": [
            273513568,
            273513144,
            273513742,
            273512836,
            273510170,
            273516169,
            273515679,
            273515838,
            273510617,
            273513446,
            273517815,
            273525464,
            273518352,
            273521955,
            273529234,
            273520142,
            273512102,
            273520565,
            273515266,
            273520749
        ],
        "C": [
            273496813,
            273497815,
            273498571,
            273503315,
            273497876,
            273499195,
            273500860,
            273502791,
            273499347,
            273496485,
            273508798,
            273507268,
            273509198,
            273511156,
            273522873,
            273509562,
            273503505,
            273507797,
            273508832,
            273510628
        ],
        "B": [
            273490300,
            273489109,
            273490092,
            273494428,
            273492341,
            273491848,
            273492911,
            273494262,
            273492523,
            273491731,
            273501850,
            273497360,
            273496735,
            273504535,
            273502692,
            273496964,
            273493065,
            273497766,
            273504790,
            273497879
        ],
        "A": [
            273486630,
            273485994,
            273491236,
            273487968,
            273486132,
            273486581,
            273486579,
            273487757,
            273487599,
            273486090,
            273488578,
            273489964,
            273488719,
            273489029,
            273504662,
            273489452,
            273486034,
            273487994,
            273500770,
            273488432
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132154",
    "editorial": "Let\u00e2\u0080\u0099s define a of a bracket sequence as the .It\u00e2\u0080\u0099s a well-known fact that\r\nfor RBS the balance of all its prefixes must be greater than or equal to\r\nzero and the balance of the whole string must be exactly zero. So, if we\r\nwant to restore RBS from we shouldn\u00e2\u0080\u0099t break that rule.Next, let\u00e2\u0080\u0099s define\r\nas the sum of positions of the opening brackets in RBS and as the sum of\r\npositions of the closing brackets in RBS.It turns out that the defined\r\nin the statement is just . Moreover, you can see that . It means that in\r\norder to minimize the cost, we should minimize , or we should try to\r\nplace closing brackets on the smaller positions.The most interesting\r\npart is that it\u00e2\u0080\u0099s enough to come up with the right strategy. Let\u00e2\u0080\u0099s\r\niterate from left to right, maintaining the current balance and place\r\nthe closing brackets whenever we can: if the current balance is we can\u00e2\u0080\u0099t\r\nplace a closing bracket, since it will make the balance negative, so we\r\nplace an opening bracket; if the current balance is bigger than we place\r\na closing bracket. Since we need to calculate the cost of the RBS, we\r\ncan replace the balance counter with a stack containing positions of\r\nopening brackets that don\u00e2\u0080\u0099t have a pair yet. Each time we meet an\r\nopening bracket, we\u00e2\u0080\u0099ll push its position to the top of the stack, and\r\neach time we meet a closing bracket, we\u00e2\u0080\u0099ll take one bracket from the top\r\nof the stack. The current balance is just the size of the stack.Here is\r\na sketch of the proof, why the strategy above is correct.Firstly, the\r\nstrategy creates RBS, because after processing a prefix of even length\r\nthe current balance will be equal to either or , while after an odd\r\nlength prefix it will be always . At the start, the balance is and we\r\nmake it , then it either becomes or , and in both cases we return it to\r\nand so on. Since the last character is always a closing bracket, the\r\ntotal balance will return to .Secondly, to prove that the strategy\r\nminimizes the cost, we can use a standard technique of proof by\r\ncontradiction: suppose there is a better answer, look at the first\r\nposition of the difference: it will be in our string and in the answer.\r\nThen just find the next in the answer and swap them. The answer will\r\nstay RBS, while will decrease contradiction.\r\n",
    "name": "C. Even Positions",
    "statement": "Monocarp had a regular bracket sequence s of length n (n is even). He\r\neven came up with his own way to calculate its cost.He knows that in a\r\nregular bracket sequence (RBS), each opening bracket is paired up with\r\nthe corresponding closing bracket. So he decided to calculate the of RBS\r\nas the sum of distances between pairs of corresponding bracket pairs.For\r\nexample, let\u2019s look at RBS . It has three pairs of brackets: : the\r\ndistance between brackets at position 1 and at 4 is 4 - 1 = 3; : the\r\ndistance is 3 - 2 = 1; : the distance is 6 - 5 = 1. So the cost of is\r\n3 + 1 + 1 = 5.Unfortunately, due to data corruption, Monocarp lost all\r\ncharacters on odd positions s_1, s_3,\r\ndots, s_{n-1}. Only characters on even positions (s_2, s_4,\r\ndots, s_{n}) remain. For example, turned to .Monocarp wants to restore\r\nhis RBS by placing brackets on the odd positions. But since the restored\r\nRBS may not be unique, he wants to choose one with . It\u2019s too hard to do\r\nfor Monocarp alone, so can you help him?Reminder: A is a string\r\nconsisting of only brackets, such that this sequence, when inserted -s\r\nand -s, gives a valid mathematical expression. For example, , or are\r\nRBS, while , or are not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>//#define int li#define f first#define s second\u00a0using namespace std;using li = long long;using ld = long double;\u00a0\u00a0int32_t main(){    ios_base::sync_with_stdio(0);    cin.tie(0);\u00a0    int t;    cin >> t;\u00a0    while(t--)    {        int n;        cin >> n;\u00a0        string s;        cin >> s;\u00a0        vector <int> v;\u00a0        li ans = 0;\u00a0        for(int i = n - 1; i >= 0; i--)        {            if(s[i] == ')')                v.push_back(i);            else if(s[i] == '(')            {                ans += v.back() - i;                v.pop_back();            }            else            {                if(v.empty() || v.size() == 1 && i > 0 && s[i - 1] == '(')                    v.push_back(i);                else                {                    ans += v.back() - i;                    v.pop_back();                }            }        }\u00a0        cout << ans << \"\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "greedy"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Even Positions.json"
}