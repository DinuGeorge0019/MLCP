{
    "link": "https://codeforces.com//contest/1251/problem/A",
    "problemId": "449544",
    "problem_idx": "A",
    "shortId": "1251A",
    "contest_number": "1251",
    "problem_submissions": {
        "D": [
            63400316,
            63400298,
            63400254,
            63400203,
            63400050,
            63399984,
            63399855,
            63312403,
            63311940,
            63318990,
            63314573,
            63427346,
            63313882,
            63324960,
            63323872,
            63313008,
            63319425,
            63312837,
            63313209,
            63313402,
            63313713,
            63313403,
            64630107,
            63316214,
            63315539,
            63310152,
            63317232,
            63314816
        ],
        "E2": [
            63399693,
            63399662,
            63399248,
            63399098,
            63398546,
            63365832,
            63365269,
            63364770,
            63338273,
            63317755,
            63314968,
            63314711,
            63319868,
            63427473,
            63323675,
            63322799,
            63317013,
            63330304,
            63326912,
            63315944,
            63319041,
            63319971,
            63319185,
            63322016,
            64630154,
            63319603,
            63323442,
            63321804,
            63320973
        ],
        "F": [
            63396794,
            63395657,
            63340397,
            63340247,
            63322387,
            63331974,
            63347502,
            63345880,
            63325885,
            63328608,
            63427571,
            63333465,
            63330239,
            63311325,
            63320807,
            63332225,
            63349152,
            63349006,
            63348927,
            63346482,
            63354827,
            63555798,
            63396546,
            63361055,
            63321261,
            63339709
        ],
        "C": [
            63339509,
            63309630,
            63308770,
            63309154,
            63311219,
            63425373,
            63310517,
            63308226,
            63320102,
            63309048,
            63314299,
            63306755,
            63309969,
            63308377,
            63311623,
            63309667,
            64630061,
            63312827,
            63308776,
            63307614,
            63311843,
            63311519
        ],
        "E1": [
            63317840,
            63315090,
            63315149,
            63319942,
            63427459,
            63323582,
            63322914,
            63316888,
            63330357,
            63326985,
            63315977,
            63318948,
            63319867,
            63319014,
            63322137,
            64630159,
            63319793,
            63323604,
            63329086,
            63321906,
            63320849
        ],
        "B": [
            63308319,
            63306252,
            63306938,
            63308521,
            63425306,
            63309307,
            63306115,
            63321613,
            63306650,
            63307802,
            63305211,
            63307273,
            63305885,
            63310074,
            63307855,
            64630021,
            63308550,
            63306496,
            63305718,
            63309015,
            63308105
        ],
        "A": [
            63304668,
            63304379,
            63304115,
            63305872,
            63425273,
            63304642,
            63304137,
            63319299,
            63304384,
            63304697,
            63304218,
            63304454,
            63304321,
            63307231,
            63304364,
            64629970,
            63304438,
            63304343,
            63304369,
            63305312,
            63306229
        ]
    },
    "name": "A. Broken Keyboard",
    "statement": "Recently Polycarp noticed that some of the buttons of his keyboard are\r\nmalfunctioning. For simplicity, we assume that Polycarp’s keyboard\r\ncontains 26 buttons (one for each letter of the Latin alphabet). Each\r\nbutton is either working fine or malfunctioning. To check which buttons\r\nneed replacement, Polycarp pressed some buttons in sequence, and a\r\nstring s appeared on the screen. When Polycarp presses a button with\r\ncharacter c, one of the following events happened: if the button was\r\nworking correctly, a character c appeared at the end of the string\r\nPolycarp was typing; if the button was malfunctioning, characters c\r\nappeared at the end of the string. For example, suppose the buttons\r\ncorresponding to characters and are working correctly, and the button\r\ncorresponding to is malfunctioning. If Polycarp presses the buttons in\r\nthe order , , , , , , , then the string he is typing changes as follows:\r\nrightarrow\r\nrightarrow\r\nrightarrow\r\nrightarrow\r\nrightarrow\r\nrightarrow .You are given a string s which appeared on the screen after\r\nPolycarp pressed some buttons. Help Polycarp to determine which buttons\r\nare working correctly for sure (that is, this string could not appear on\r\nthe screen if any of these buttons was malfunctioning).You may assume\r\nthat the buttons don’t start malfunctioning when Polycarp types the\r\nstring: each button either works correctly throughout the whole process,\r\nor malfunctions throughout the whole process.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <set>\n#include <vector>\nusing namespace std;\n\nvoid solve_case() {\n    string S;\n    cin >> S;\n    int n = S.size();\n    set<char> odd;\n\n    for (int i = 0, j = 0; i < n; i = j) {\n        while (j < n && S[i] == S[j])\n            j++;\n\n        if ((j - i) % 2 != 0)\n            odd.insert(S[i]);\n    }\n\n    cout << string(odd.begin(), odd.end()) << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n\n    while (T-- > 0)\n        solve_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "strings",
        "two pointers"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Broken Keyboard.json",
    "editorial_link": "https://codeforces.com//blog/entry/70860",
    "editorial": "If a key malfunctions, each sequence of presses of this key gives a\r\nstring with even number of characters. So, if there is a substring\r\nconsisting of odd number of equal characters , such that it cannot be\r\nextended to the left or to the right without adding other characters,\r\nthen it could not be produced by presses of button if was\r\nmalfunctioning.The only thing thatâs left is to find all maximal by\r\ninclusion substrings consisting of the same character.\r\n",
    "hint": []
}