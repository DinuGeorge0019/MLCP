{
    "link": "https://codeforces.com//contest/1065/problem/B",
    "problemId": "235279",
    "problem_idx": "B",
    "shortId": "1065B",
    "contest_number": "1065",
    "problem_submissions": {
        "G": [
            44147383,
            44142689,
            64875649,
            44176191,
            44151224,
            44148655
        ],
        "F": [
            44140103,
            44135158,
            44149164,
            44170796,
            44144683,
            44147682,
            44150813,
            44148584,
            44232284,
            44149497,
            44149530,
            44147181,
            44142305,
            44150346,
            44135080,
            44139962,
            44154242,
            44143115,
            44173159
        ],
        "E": [
            44135655,
            44147876,
            44135777,
            44147851,
            44136930,
            44146829,
            44136198,
            44142963,
            44143566,
            44144277,
            44137199,
            44146967,
            44148616,
            44133656,
            44142278,
            44138211,
            44126340,
            44141084,
            44146795,
            44140823
        ],
        "D": [
            44131742,
            44145378,
            44140071,
            44135909,
            44143930,
            44133600,
            44143692,
            44140442,
            44140210,
            44138706,
            44143640,
            44144314,
            44158291,
            44137709,
            44163831,
            44137474,
            44135591,
            44136408
        ],
        "C": [
            44121602,
            44120175,
            44124781,
            44126011,
            44125676,
            44121365,
            44127681,
            44121729,
            44126925,
            44123439,
            44127185,
            44130687,
            44137712,
            44126326,
            44122320,
            44121809,
            44122322,
            44129853,
            44123901,
            44127061
        ],
        "B": [
            44119298,
            44120920,
            44120806,
            44122001,
            44121592,
            44118170,
            44120220,
            44123249,
            44122493,
            44127205,
            44122290,
            44123314,
            44136224,
            44122582,
            44118742,
            44120144,
            44119274,
            44120858,
            44120292,
            44127423
        ],
        "A": [
            44117312,
            44121828,
            44117393,
            44117877,
            44118469,
            44117250,
            44118091,
            44118967,
            44118166,
            44118757,
            44117346,
            44118839,
            44117870,
            44119633,
            44117273,
            44117291,
            44117281,
            44117657,
            44117462,
            44117869
        ]
    },
    "name": "B. Vasya and Isolated Vertices",
    "statement": "Vasya has got an undirected graph consisting of n vertices and m edges.\r\nThis graph doesn\u2019t contain any self-loops or multiple edges. Self-loop\r\nis an edge connecting a vertex to itself. Multiple edges are a pair of\r\nedges such that they connect the same pair of vertices. Since the graph\r\nis undirected, the pair of edges (1, 2) and (2, 1) is considered to be\r\nmultiple edges. Isolated vertex of the graph is a vertex such that there\r\nis no edge connecting this vertex to any other vertex.Vasya wants to\r\nknow the minimum and maximum possible number of isolated vertices in an\r\nundirected graph consisting of n vertices and m edges.\r\n",
    "solutions": [
        "/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fastIO ios_base::sync_with_stdio(0)\n#define nul point(0, 0)\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define solve_system int number; cin >> number; for (int i = 0; i < number; i++) solve()\n#define solve_system_scanf int number; scanf(\"%d\", &number); for (int i = 0; i < number; i++) solve()\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst ll prost = 239;\nconst int two = 2;\nconst int th = 3;\nconst ll MOD = 998244353;\nconst ll MOD2 = MOD * MOD;\nconst int BIG = 1e9 + 239;\nconst int alf = 26;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dig = 10;\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n//easy functions\ntemplate< typename T >\ninline T gcd(T a, T b)\n{\n    while (a)\n    {\n        b %= a;\n        swap(a, b);\n    }\n    return b;\n}\ntemplate< typename T >\ninline T lcm(T a, T b) { return (a / gcd(a, b)) * b; }\ninline bool is_down(char x) { return ('a' <= x && x <= 'z'); }\ninline bool is_upper(char x) { return ('A' <= x && x <= 'Z'); }\ninline bool is_digit(char x) { return ('0' <= x && x <= '9'); }\n\n//random\nmt19937 rnd(239);\n\n//constants\nconst int M = 2 * 1e5 + 239;\nconst int N = 2 * 1e3 + 239;\nconst int L = 20;\nconst int T = (1 << 18);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 1e4 + 239;\n\nint main()\n{\n    #ifdef ONPC\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    ll n, m;\n    cin >> n >> m;\n    ll l = n;\n    ll r = 0;\n    for (ll x = 0; x <= n; x++)\n    {\n        ll v = (n - x);\n        ll e = m;\n        if (e < (v + 1) / 2LL) continue;\n        if (e > ((v * (v - 1)) / 2LL)) continue;\n        l = min(l, x);\n        r = max(r, x);\n    }\n    cout << l << \" \" << r;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "graphs"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Vasya and Isolated Vertices.json",
    "editorial_link": "https://codeforces.com//blog/entry/62411",
    "editorial": "Vasya can decrease number of isolated vertices up to using one edge and\r\npairing them. So minimum number of isolated vertices is .To calculate\r\nmaximum number of isolated vertices let\u00e2\u0080\u0099s keep number of non-isolated\r\nvertices knowing that each pair connected by edge (i.e. size of clique).\r\nLet we have size of clique and edges remained unassigned at current\r\nstep. If then answer is . Otherwise we need to increase clique with one\r\nvertex. Maximum number of edges we can add to connect this vertex is .\r\nSo, subtract it from and increase by one. Repeat this step while greater\r\nthan zero. Answer is .One corner case is next: if , then answer is , not\r\n.\r\n"
}