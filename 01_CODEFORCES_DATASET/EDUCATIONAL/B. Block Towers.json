{"link": "https://codeforces.com//contest/1767/problem/B", "problemId": "1697001", "problem_idx": "B", "shortId": "1767B", "contest_number": "1767", "problem_submissions": {"F": [185514153, 185548652, 185548569, 185548494, 185548166, 185548104, 185548070, 185547990, 185547931, 185538816, 185538731, 185536681, 185536510, 185533881, 185548043, 185547524, 185547405, 187061027, 188938985, 188938874, 188938733, 188938538, 188662943], "E": [185496241, 185503484, 185495581, 185501980, 185500616, 185536545, 185506476, 185505796, 185502863, 185502893, 185509737, 185509089, 185503658, 185500454, 188653481, 185507693, 185510300, 185512188, 185507422, 185511136, 191847813, 185508302], "D": [185485689, 185480567, 185486073, 185487205, 185489767, 185484058, 185487337, 185490632, 185495647, 185490973, 185492256, 185494935, 185488073, 185492422, 185494405, 185494252, 185494078, 185493034, 185501838], "C": [185476244, 185474583, 185478107, 185476554, 185481773, 185476338, 185483596, 185484239, 185478556, 185481931, 185485024, 185484128, 185481474, 185482158, 185486113, 185484367, 185484937, 185482445, 185483985], "B": [185470025, 185469866, 185470325, 185469767, 185469743, 185469974, 185468835, 185473229, 185470539, 185470117, 185471331, 185471042, 185470304, 185473480, 185472801, 185471018, 185472578, 185469524, 185472904], "A": [185468810, 185468911, 185468716, 185468796, 185468875, 185468821, 185471076, 185576332, 185469327, 185470858, 185468733, 185468950, 185468986, 185469052, 185468910, 185469302, 185469202, 185470756, 185472308, 185469751]}, "name": "B. Block Towers", "statement": "There are n block towers, numbered from 1 to n. The i-th tower consists\r\nof a_i blocks.In one move, you can move one block from tower i to tower\r\nj, but only if a_i > a_j. That move increases a_j by 1 and decreases a_i\r\nby 1. You can perform as many moves as you would like (possibly,\r\nzero).What\u2019s the largest amount of blocks you can have on the tower 1\r\nafter the moves?\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 500500;\nint n;\nint a[N];\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tint x = a[0];\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++) if (x < a[i])\n\t\tx += (a[i] - x + 1) / 2;\n\tprintf(\"%d\\n\", x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "greedy", "sortings"], "dificulty": "800", "interactive": false}