{
    "link": "https://codeforces.com//contest/2111/problem/G",
    "problemId": "3419292",
    "problem_idx": "G",
    "shortId": "2111G",
    "contest_number": "2111",
    "problem_submissions": {
        "G": [
            322719568,
            322738251,
            322737232,
            322734882,
            322733848,
            322739705,
            322765348,
            322764688,
            322752005,
            322753587,
            322751319,
            322720568,
            322729631,
            322757116,
            322785461,
            322890645,
            323020347,
            322778439,
            322778419,
            322778201,
            322778119,
            322778020,
            322777882,
            322777223,
            322776997,
            322776001,
            322775936
        ],
        "E": [
            322697990,
            322695191,
            322705487,
            322705821,
            322705980,
            322713283,
            322724677,
            322738049,
            322690431,
            322700985,
            322700076,
            322704262,
            322702259,
            322707219,
            322704094,
            322705822,
            322703551
        ],
        "F": [
            322691387,
            322716243,
            322719103,
            322728613,
            322729993,
            322731051,
            322740913,
            322686943,
            322710192,
            322719720,
            322713672,
            322713636,
            322726013,
            322721562,
            322720556,
            322728230,
            322730210
        ],
        "D": [
            322678511,
            322686771,
            322684334,
            322692059,
            322689019,
            322692746,
            322686820,
            322741814,
            322683201,
            322689247,
            322687368,
            322686598,
            322691632,
            322687656,
            322691451,
            322694053,
            322684204
        ],
        "C": [
            322676707,
            322681404,
            322679043,
            322681662,
            322681314,
            322683752,
            322680197,
            322743070,
            322679811,
            322681807,
            322679034,
            322681517,
            322680587,
            322678741,
            322686213,
            322679235,
            322680369
        ],
        "B": [
            322676127,
            322679449,
            322677961,
            322679172,
            322678800,
            322680312,
            322678349,
            322745453,
            322678542,
            322679221,
            322677917,
            322679124,
            322677847,
            322677424,
            322681157,
            322677471,
            322677308
        ],
        "A": [
            322675651,
            322676474,
            322676120,
            322676736,
            322675861,
            322677535,
            322676082,
            322747128,
            322675974,
            322676468,
            322676128,
            322676492,
            322675977,
            322675843,
            322676405,
            322675792,
            322675708
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/143528",
    "editorial": ":Note that you are asked to solve the problem \"online\". This means there\r\nis some simple \"offline\" solution that is being cut off. In other words,\r\nthe problem can be solved more easily if you could answer the queries in\r\nan arbitrary order.Let’s iterate over in an increasing order. Maintain\r\nthe following binary array : is equal to if , and if . When you move\r\nfrom to , find in the permutation and change the corresponding value in\r\nfrom to .Then, the segment from to is divisible by the value if the\r\ncorresponding subsegment in is of the form or , where the number of s\r\nand s is strictly greater than . Let’s consider blocks of consecutive\r\nzeros and ones (maximal by inclusion) in the array . Now you can say\r\nthat and must belong to neighboring blocks.Note that when moving from to\r\n, the number of blocks in the array changes by at most . That is, for\r\nall possible values of , there are different blocks in total. The blocks\r\nthemselves can be maintained in a set of pairs.The blocks of equal\r\nelements look like . For convenience, let’s store the blocks as\r\nhalf-intervals. Each time the blocks change, you should write down new\r\nneighboring pairs in the form of triples . In this interpretation, the\r\nsegment is divisible if there exists a triple such that .This check can\r\nbe performed using a sweep line. For each triple, let’s add two events:\r\nat time , the triple is turned on; at time , the triple is turned off.\r\nLet’s process the events in order of increasing time. The query can be\r\nanswered at time . Each triple , that is currently on, generates a\r\nhalf-interval . So, you need to check if there is at least one\r\nhalf-interval that includes index . This can be implemented using a\r\nsegment tree. When the triple is turned on, you add on the half-interval\r\n. When it is turned off, you subtract . To check, you can query the\r\nvalue at point . If the value is , the answer is \"NO\"; otherwise, it is\r\n\"YES\".This algorithm solves the problem \"offline\" because it answers\r\nqueries not in the order of the input but in the order of increasing .\r\nYou can apply the classic trick to convert the problem to \"online\". At\r\neach moment of time, you are only interested in the state of the segment\r\ntree, so you can make the tree persistent, saving a version at each\r\nmoment of time. Now you can answer the queries \"online\".Overall\r\ncomplexity: .:Without loss of generality, let’s check only the first\r\ncondition. To check the second one, you can reverse the array (and\r\ntransform and accordingly) and check the first condition. Now let’s\r\nrestate the condition as follows: there exists an index such that the\r\nmaximum to the left of (inclusive) is less than or equal to the minimum\r\nto the right of (exclusive).Let’s learn to check if the array is\r\ndivisible in a smarter way than by iterating through all possible and\r\nchecking the maximum and minimum.Let’s fix the index of the maximum in\r\nthe left half, let it be . Where can the cut be? All values in the right\r\nhalf must be greater than . That is, let’s find the index of the nearest\r\nnumber to the right of that is greater than . Let this be index . Then\r\nall values on indices from to (exclusive) must belong to the left half.\r\nThe index cannot belong to the left half, as , and it’s been fixed that\r\nis the maximum. Thus, for each prefix maximum (since the left half is a\r\nprefix of the array ), there is only one candidate for the cut the index\r\nbefore the next prefix maximum.First, let’s precompute the index of the\r\nnearest greater number to the right for each element. This can be done\r\nusing a monotonic stack by traversing from right to left. Let’s call\r\nthis for each index .Then the solution should go as follows. Let’s try\r\nto answer the query. Find the first and second prefix maxima on the\r\nsegment . Let them be at indices and , respectively. Check that is a\r\nvalid cut for , by ensuring that all values on indices from to are\r\nstrictly greater than . If this is not the case, move on to the second\r\nand third prefix maxima ( and ). And so on. If the next prefix maximum\r\nlies to the right of , and no pair of neighboring prefix maxima fits,\r\nthen the answer is \"NO\". Obviously, you can make of these jumps in the\r\nworst case, so for now, the solution is too slow. Ideally, you would\r\nlike to replace trivial jumps with the binary lifting to answer queries\r\nin . However, for this, you want to have a condition that can be used to\r\ncheck the cuts in bulk. That is, to perform the check simultaneously for\r\ncuts.Such a condition can be stated as follows. Once again, let there be\r\na prefix maximum at index and the next prefix maximum at index . Then\r\nfor all indices from to , all values must be greater than . In other\r\nwords, the nearest number to the right of that is less than must lie\r\nstrictly to the right of . Great, now you can save this index of the\r\nnearest number in the binary lifting. Let’s call it . To check many cuts\r\nat once, you can do the following: if at least one of the values is\r\ngreater than , then the answer is \"YES\". That is, if the maximum of them\r\nis greater than , then the answer is \"YES\". Thus, you can also save the\r\nmaximum in the binary lifting.The only thing left is to learn how to\r\nfind the nearest number to the right of that is less than . This can\r\nalso be done using a monotonic stack with a sweep line. In the first\r\npass, let’s find the values for all with an increasing monotonic stack\r\n(the next larger, the next larger after that, and so on). In the second\r\npass from right to left, maintain a decreasing monotonic stack. To find\r\nthe nearest number to the right of that is less than , you can perform a\r\nbinary search on the stack built for index .After these two passes with\r\nthe monotonic stack, you finally have all the information needed for the\r\nbinary lifting. Calculate the binary lifting, while saving the maximum\r\nof over jumps. Then you can answer the query as follows. Start from\r\nindex . Let be the index after jumps, and be the minimum over the\r\ncorresponding jumps. If , decrease . If , the answer is \"NO\". Otherwise,\r\nif , the answer is \"YES\". Otherwise, set and continue checking.Overall\r\ncomplexity: .\r\n",
    "name": "G. Divisible Subarrays",
    "statement": "An array a of m numbers is called if at least one of the following\r\nconditions holds: There exists an index i (1\r\nle i < m) and an integer x such that for all indices j (j\r\nle i), it holds that a_{j}\r\nle x and for all indices k (k > i), it holds that a_{k} > x. There\r\nexists an index i (1\r\nle i < m) and an integer x such that for all indices j (j\r\nle i), it holds that a_{j} > x and for all indices k (k > i), it holds\r\nthat a_{k}\r\nle x. You are given a permutation p of integers 1, 2,\r\ndots, n. Your task is to answer queries of the following form fast: if\r\nwe take only the segment [l, r] from the permutation, that is, the\r\nnumbers p_{l}, p_{l + 1},\r\ndots, p_{r}, is this subarray of numbers ?Queries will be submitted in\r\ninteractive mode in groups of 10, meaning you will not receive the next\r\ngroup of queries until you output all answers for the current group.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "interactive"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Divisible Subarrays.json",
    "hint": []
}