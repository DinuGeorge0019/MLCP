{"link": "https://codeforces.com//contest/622/problem/E", "problemId": "47919", "problem_idx": "E", "shortId": "622E", "contest_number": "622", "problem_submissions": {"F": [27693832, 15938161, 15938350, 15937525, 15940871, 15940468, 15941715, 15935758, 15942132, 15939672, 15962566, 15966525, 15955821, 16477461, 16135097], "E": [15936192, 15935128, 15935464, 15935136, 15937412, 15942338, 15942779, 15939453, 15935850, 15933034, 15937053, 15935414, 15937343, 15937472, 15938233, 15935244, 15936698, 15939486, 15936424], "D": [15933494, 15933221, 15933776, 15937480, 15935164, 15939366, 15936035, 15940787, 15933859, 15935298, 15934473, 15934644, 15933986, 15934369, 15934813, 15934580, 15935083, 15935405, 15937710], "C": [15932039, 15931591, 15932212, 15932351, 15933060, 15933265, 15932091, 15936323, 15932756, 15931784, 15931982, 15933549, 15932246, 15932409, 15933086, 15932288, 15932372, 15932233, 15932181], "B": [15931075, 15931135, 15931295, 15931505, 15932084, 15932002, 15931182, 15931089, 15931279, 15931134, 15931176, 15931455, 15931488, 15931348, 15931223, 15931203, 15931572, 15931376, 15931416], "A": [15930972, 15930991, 15931097, 15931150, 15931799, 15931265, 15930996, 15931213, 15930997, 15930976, 15930999, 15931143, 15931011, 15931015, 15931009, 15931021, 15931298, 15931086, 15931092]}, "name": "E. Ants in Leaves", "statement": "Tree is a connected graph without cycles. A leaf of a tree is any vertex\r\nconnected with exactly one other vertex.You are given a tree with\r\nvertices and a root in the vertex . There is an ant in each leaf of the\r\ntree. In one second some ants can simultaneously go to the parent vertex\r\nfrom the vertex they were in. No two ants can be in the same vertex\r\nsimultaneously except for the root of the tree.Find the minimal time\r\nrequired for all ants to be in the root of the tree. Note that at start\r\nthe ants are only in the leaves of the tree.\r\n", "solutions": ["#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define RI(X) scanf(\"%d\", &(X))\n#define RII(X, Y) scanf(\"%d%d\", &(X), &(Y))\n#define RIII(X, Y, Z) scanf(\"%d%d%d\", &(X), &(Y), &(Z))\n#define DRI(X) int (X); scanf(\"%d\", &X)\n#define DRII(X, Y) int X, Y; scanf(\"%d%d\", &X, &Y)\n#define DRIII(X, Y, Z) int X, Y, Z; scanf(\"%d%d%d\", &X, &Y, &Z)\n#define RS(X) scanf(\"%s\", (X))\n#define CASET int ___T, case_n = 1; scanf(\"%d \", &___T); while (___T-- > 0)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define PII pair<int,int>\n#define VI vector<int>\n#define VPII vector<pair<int,int> >\n#define PLL pair<long long,long long>\n#define VPLL vector<pair<long long,long long> >\n#define F first\n#define S second\ntypedef long long LL;\nusing namespace std;\nconst int MOD = 1e9+7;\nconst int SIZE = 1e6+10;\nVI e[SIZE];\nVI now;\nvoid dfs(int x,int lt,int lv){\n    if(SZ(e[x])==1)now.PB(lv);\n    REP(i,SZ(e[x])){\n        int y=e[x][i];\n        if(y==lt)continue;\n        dfs(y,x,lv+1);\n    }\n}\nint main(){\n    DRI(n);\n    REPP(i,1,n){\n        DRII(x,y);\n        e[x].PB(y);\n        e[y].PB(x);\n    }\n    int an=0;\n    REP(i,SZ(e[1])){\n        now.clear();\n        dfs(e[1][i],1,1);\n        sort(ALL(now));\n        int me=0;\n        REP(j,SZ(now)){\n            if(now[j]>me)me=now[j];\n            else me++;\n        }\n        an=max(an,me);\n    }\n    cout<<an;\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "greedy", "sortings", "trees"], "dificulty": "2200", "interactive": false}