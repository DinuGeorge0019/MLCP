{
    "link": "https://codeforces.com//contest/1622/problem/D",
    "problemId": "1242580",
    "problem_idx": "D",
    "shortId": "1622D",
    "contest_number": "1622",
    "problem_submissions": {
        "F": [
            140796824,
            140798013,
            140806008,
            140808778,
            140806009,
            140805051,
            140814076,
            140828348,
            140819179,
            140855589,
            140855586,
            140839728,
            140839370,
            140821060,
            140807144,
            140812999,
            140804188,
            140824231,
            140824165,
            140822940,
            140804052,
            140823222,
            140819745,
            140824560,
            140857950,
            140834838,
            140832376,
            140829343,
            140828751,
            140828269,
            140827798
        ],
        "E": [
            140765216,
            140779319,
            140785115,
            140782340,
            140780692,
            140780184,
            140838345,
            140780973,
            140780107,
            140783378,
            140789562,
            140786801,
            140785714,
            140786518,
            140775048,
            140770202,
            140781928,
            140783559,
            140781100,
            140785123,
            140785377,
            140784613
        ],
        "D": [
            140761526,
            140770308,
            140773276,
            140775500,
            140776032,
            140771575,
            140837879,
            140773697,
            140780198,
            140777190,
            140779965,
            140773920,
            140787545,
            140769780,
            140775729,
            140849022,
            140772131,
            140772048,
            140774887,
            140775893,
            140779501,
            140776197
        ],
        "C": [
            140756712,
            140763210,
            140766719,
            140766708,
            140766349,
            140764400,
            140762686,
            140760355,
            140768706,
            140766328,
            140766600,
            140768126,
            140759456,
            140764367,
            140761869,
            140765074,
            140766561,
            140767346,
            140764755,
            140763284,
            140767658
        ],
        "B": [
            140752335,
            140756349,
            140756665,
            140761975,
            140757886,
            140760857,
            140757453,
            140753171,
            140760768,
            140761439,
            140759017,
            140757918,
            140754004,
            140754798,
            140756955,
            140757416,
            140757531,
            140759831,
            140758370,
            140759772
        ],
        "A": [
            140751413,
            140751825,
            140751782,
            140754411,
            140752339,
            140751676,
            140751944,
            140751415,
            140752483,
            140751783,
            140754865,
            140752090,
            140751540,
            140751564,
            140751671,
            140751951,
            140752002,
            140751977,
            140751451,
            140754316
        ]
    },
    "name": "D. Shuffle",
    "statement": "You are given a binary string (i. e. a string consisting of characters\r\nand/or ) s of length n. You can perform the following operation with the\r\nstring s : choose a substring (a contiguous subsequence) of s having k\r\ncharacters in it, and shuffle it (reorder the characters in the\r\nsubstring as you wish).Calculate the number of different strings which\r\ncan be obtained from s by performing this operation at most once.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 27.12.2021 17:41:36       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, k;\n  cin >> n >> k;\n  string foo;\n  cin >> foo;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    a[i] = (int) (foo[i] - '0');\n  }\n  vector<int> pref(n + 1);\n  for (int i = 0; i < n; i++) {\n    pref[i + 1] = pref[i] + a[i];\n  }\n  Mint ans = 1;\n  if (pref[n] >= k) {\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) {\n        int cnt = pref[j + 1] - pref[i];\n        if (cnt <= k) {\n          cnt -= (a[i] ^ 1) + (a[j] ^ 1);\n          int len = j - i - 1;\n          ans += C(len, cnt);\n        }\n      }\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Shuffle.json",
    "editorial_link": "https://codeforces.com//blog/entry/98453",
    "editorial": "We could iterate on the substrings we want to shuffle and try to count\r\nthe number of ways to reorder their characters, but, unfortunately,\r\nthere\u00e2\u0080\u0099s no easy way to take care of the fact that shuffling different\r\nsubstrings may yield the same result.Instead, we will iterate on the\r\nfirst and the last character that are changed. Let these characters be\r\nand . First of all, let\u00e2\u0080\u0099s check that they can belong to the same\r\nsubstring we can shuffle it is the case if the string contains at least\r\ncharacters , and the substring from the -th character to the -th\r\ncharacter contains at most characters .Then, after we\u00e2\u0080\u0099ve fixed the first\r\nand the last characters that are changed, we have to calculate the\r\nnumber of ways to shuffle the characters between them (including them)\r\nso that both of these characters are changed. Let\u00e2\u0080\u0099s calculate and the\r\nnumber of characters and respectively in the substring. Then, we need to\r\nmodify these two values: for example, if the -th character is , then\r\nsince it is the first changed character, it should become , so we need\r\nto put there and decrease by one. The same for the -th character. Let\r\nand be the values of and after we take care of the fact that the -th and\r\nthe -th character are fixed. The remaining characters can be in any\r\norder, so the number of ways to arrang them is .We can add up these\r\nvalues for all pairs () such that we can shuffle a substring containing\r\nthese two characters. We won\u00e2\u0080\u0099t be counting any string twice because we\r\nensure that is the first changed character, and is the last changed\r\ncharacter. Don\u00e2\u0080\u0099t forget to add to the answer the string we didn\u00e2\u0080\u0099t count\r\nis the original one.This solution works in , but the problem is solvable\r\nin .\r\n"
}