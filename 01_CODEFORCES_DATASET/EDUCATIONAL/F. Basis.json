{
    "link": "https://codeforces.com//contest/1644/problem/F",
    "problemId": "1306307",
    "problem_idx": "F",
    "shortId": "1644F",
    "contest_number": "1644",
    "problem_submissions": {
        "F": [
            147320866,
            147353077,
            147335774,
            147336779,
            147338284,
            147344072,
            147361395,
            147361328,
            147360591,
            147341020,
            147347713,
            147363763,
            147363723,
            147322590,
            152772960,
            147359576,
            147689521
        ],
        "E": [
            147306717,
            147306569,
            147311348,
            147309095,
            147307844,
            147307929,
            147314427,
            147326156,
            147310695,
            147307982,
            147306896,
            147305676,
            147310587,
            147307037,
            147315289,
            147313121,
            147313445,
            147321773
        ],
        "D": [
            147293584,
            147307300,
            147301707,
            147294952,
            147298642,
            147298634,
            147300618,
            147333853,
            147291913,
            147295056,
            147298209,
            147295009,
            147295505,
            147297361,
            147296680,
            147301724,
            147303329,
            147296313
        ],
        "C": [
            147288888,
            147290549,
            147296803,
            147287863,
            147292950,
            147291474,
            147293826,
            147331175,
            147286835,
            147291088,
            147291894,
            147288455,
            147290620,
            147288872,
            147289111,
            147292816,
            147293660,
            147289532
        ],
        "B": [
            147281121,
            147281154,
            147291952,
            147280086,
            147282998,
            147283506,
            147285667,
            147332125,
            147281901,
            147282926,
            147283802,
            147281429,
            147284985,
            147282861,
            147283027,
            147287392,
            147286913,
            147282167
        ],
        "A": [
            147278514,
            147278406,
            147278697,
            147278304,
            147278969,
            147279113,
            147278307,
            147332805,
            147278673,
            147278387,
            147278783,
            147278331,
            147278464,
            147278483,
            147278302,
            147278920,
            147278819,
            147278413
        ]
    },
    "name": "F. Basis",
    "statement": "For an array of integers a, let\u2019s define |a| as the number of elements\r\nin it.Let\u2019s denote two functions: F(a, k) is a function that takes an\r\narray of integers a and a positive integer k. The result of this\r\nfunction is the array containing |a| first elements of the array that\r\nyou get by replacing each element of a with exactly k copies of that\r\nelement.For example, F([2, 2, 1, 3, 5, 6, 8], 2) is calculated as\r\nfollows: first, you replace each element of the array with 2 copies of\r\nit, so you obtain [2, 2, 2, 2, 1, 1, 3, 3, 5, 5, 6, 6, 8, 8]. Then, you\r\ntake the first 7 elements of the array you obtained, so the result of\r\nthe function is [2, 2, 2, 2, 1, 1, 3]. G(a, x, y) is a function that\r\ntakes an array of integers a and two integers x and y. The result of\r\nthis function is the array a with every element equal to x replaced by\r\ny, and every element equal to y replaced by x.For example, G([1, 1, 2,\r\n3, 5], 3, 1) = [3, 3, 2, 1, 5].An array a is a of the array b if: either\r\nthere exists a positive integer k such that F(a, k) = b; or there exist\r\ntwo different integers x and y such that G(a, x, y) = b. An array a is\r\nan of the array b if there exists a finite sequence of arrays c_0, c_1,\r\ndots, c_m (m\r\nge 0) such that c_0 is a, c_m is b, and for every i\r\nin [1, m], c_{i-1} is a parent of c_i..You are given two integers n and\r\nk. Your goal is to construct a sequence of arrays s_1, s_2,\r\ndots, s_m in such a way that: every array s_i contains exactly n\r\nelements, and all elements are integers from 1 to k; for every array a\r\nconsisting of exactly n integers from 1 to k, the sequence contains at\r\nleast one array s_i such that s_i is an ancestor of a. Print the minimum\r\nnumber of arrays in such sequence.\r\n",
    "solutions": [
        "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\nint MOD =  998244353 ;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n\nconst int LIM = 1000005;\n\nvector<int> facs(LIM), invfacs(LIM), invs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n\n    for (int i = 1; i<LIM; i++) invs[i] = mul(invfacs[i], facs[i-1]);\n\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\n\nconst int mod = 998244353;\n\ntemplate<int mod>\nstruct NTT {\n    static constexpr int max_lev = __builtin_ctz(mod - 1);\n\n    int prod[2][max_lev - 1];\n\n    NTT() {\n        int root = find_root();//(mod == 998244353) ? 31 : find_root();\n        int rroot = power(root, mod - 2);\n        vector<vector<int>> roots(2, vector<int>(max_lev - 1));\n        roots[0][max_lev - 2] = root;\n        roots[1][max_lev - 2] = rroot;\n        for (int tp = 0; tp < 2; ++tp) {\n            for (int i = max_lev - 3; i >= 0; --i) {\n                roots[tp][i] = mul(roots[tp][i + 1], roots[tp][i + 1]);\n            }\n        }\n        for (int tp = 0; tp < 2; ++tp) {\n            int cur = 1;\n            for (int i = 0; i < max_lev - 1; ++i) {\n                prod[tp][i] = mul(cur, roots[tp][i]);\n                cur = mul(cur, roots[tp ^ 1][i]);\n            }\n        }\n    }\n\n    template<bool inv>\n    void fft(int *a, int lg) const {\n        const int n = 1 << lg;\n        int pos = max_lev - 1;\n        for (int it = 0; it < lg; ++it) {\n            const int h = inv ? lg - 1 - it : it;\n            const int shift = (1 << (lg - h - 1));\n            int coef = 1;\n            for (int start = 0; start < (1 << h); ++start) {\n                for (int i = start << (lg - h); i < (start << (lg - h)) + shift; ++i) {\n                    if (!inv) {\n                        const int y = mul(a[i + shift], coef);\n                        a[i + shift] = a[i];\n                        inc(a[i], y);\n                        dec(a[i + shift], y);\n                    } else {\n                        const int y = mul(a[i] + mod - a[i + shift], coef);\n                        inc(a[i], a[i + shift]);\n                        a[i + shift] = y;\n                    }\n                }\n                coef = mul(coef, prod[inv][__builtin_ctz(~start)]);\n            }\n        }\n    }\n\n    vector<int> product(vector<int> a, vector<int> b) const {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        const int sz = a.size() + b.size() - 1;\n        const int lg = 32 - __builtin_clz(sz - 1), n = 1 << lg;\n        a.resize(n);\n        b.resize(n);\n        fft<false>(a.data(), lg);\n        fft<false>(b.data(), lg);\n        for (int i = 0; i < n; ++i) {\n            a[i] = mul(a[i], b[i]);\n        }\n        fft<true>(a.data(), lg);\n        a.resize(sz);\n        const int rn = power(n, mod - 2);\n        for (int &x : a) {\n            x = mul(x, rn);\n        }\n        return a;\n    }\n\nprivate:\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline void dec(int &x, int y) {\n        x -= y;\n        if (x < 0) {\n            x += mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, (1 << max_lev)) == 1 && power(root, (1 << (max_lev - 1))) != 1) {\n                return root;\n            }\n        }\n    }\n};\n\nNTT<mod> ntt;\n\nvector<int> stirling(int n)\n{\n    vector<int> a(n+1);\n    for (int i = 0; i<=n; i++)\n    {\n        a[i] = invfacs[i];\n        if (i%2) a[i] = sub(0, a[i]);\n    }\n    vector<int> b(n+1);\n    for (int i = 0; i<=n; i++)\n    {\n        b[i] = mul(po(i, n), invfacs[i]);\n    }\n\n    auto res = ntt.product(a, b);\n    res.resize(n+1);\n    return res;\n}\n\nmap<int, vector<int>> cool;\n\nvoid print(vector<int> a)\n{\n    for (auto it: a) cout<<it<<' ';\n    cout<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    init();\n\n    int n, k; cin>>n>>k;\n\n    if (n==1 || k==1)\n    {\n        cout<<1<<endl;\n        return 0;\n    }\n\n    vector<int> dp(n+1);\n\n    dp[n] = 0;\n    for (int len = n-1; len>=1; len--)\n    {\n        int cnt = (n+len-1)/len;\n\n        if (cool.find(cnt)==cool.end())\n        {\n            cool[cnt] = stirling(cnt);\n        }\n\n        for (int groups = 1; groups<=min(k, cnt); groups++)\n        {\n            dp[len] = add(dp[len], cool[cnt][groups]);\n        }\n\n        dp[len] = sub(dp[len], 1);\n\n        for (int i = 2*len; i<=n; i+=len) dp[len] = sub(dp[len], dp[i]);\n    }\n\n    /*for (auto it: cool)\n    {\n        cout<<it.first<<\": \"; print(it.second);\n    }*/\n\n    cout<<dp[1];\n\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "fft",
        "math",
        "number theory"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Basis.json",
    "editorial_link": "https://codeforces.com//blog/entry/100227",
    "editorial": "First of all, since the second operation changes all occurrences of some\r\nnumber to other number and vice versa, then, by using it, we can convert\r\nan array into another array if there exists a bijection between elements\r\nin the first array and elements in the second array. It can also be\r\nshown that , so we can consider that if we want to transform an array\r\ninto another array, then we first apply the function , then the function\r\n.Another relation that helps us is that , it means that every time we\r\napply the function , we can easily rollback the changes. Considering\r\nthat we have already shown that a sequence of transformations can be\r\nreordered so that we apply only after we\u00e2\u0080\u0099ve made all operations with the\r\nfunction , let\u00e2\u0080\u0099s try to \"rollback\" the second part of transformations,\r\ni. e. for each array, find some which can be obtained by using the\r\nfunction .Since applying the second operation several times is equal to\r\napplying some bijective function to the array, we can treat each array\r\nas a partition of the set into several subsets. So, if we are not\r\nallowed to perform the first operation, the answer to the problem is\r\nequal to , where is the number of ways to partition a set of objects\r\ninto non-empty sets (these are known as ). There are many ways to\r\ncalculate Stirling numbers of the second kind, but in this problem, we\r\nwill have to use some FFT-related approach which allows getting all\r\nStirling numbers for some value of in time . For example, you can use\r\nthe following relation: If we substitute and , we can see that the\r\nsequence of Stirling numbers for some fixed is just the convolution of\r\nsequences and .For simplicity in the following formulas, let\u00e2\u0080\u0099s denote .\r\nWe now know that this value can be calculated in .Okay, now back to the\r\noriginal problem. Unfortunately, we didn\u00e2\u0080\u0099t take the operation into\r\naccount. Let\u00e2\u0080\u0099s analyze it.The result of function consists of several\r\nblocks of equal elements, and it\u00e2\u0080\u0099s easy to see that the lengths of these\r\nblocks (except for maybe the last one) should be divisible by . The\r\nopposite is also true if the lengths of all blocks (except maybe for the\r\nlast one) are divisible by some integer , then the array can be produced\r\nas for some array .What does it mean? If the greatest common divisor of\r\nthe lengths of the blocks (except for the last one) is not , the array\r\nthat we consider can be obtained by applying the function to some other\r\narray. Otherwise, it cannot be obtained in such a way. Now,\r\ninclusion-exclusion principle comes to the rescue.Let\u00e2\u0080\u0099s define as the\r\nnumber of arrays that we consider which have the lengths of all their\r\nblocks (except maybe for the last one) divisible by . It\u00e2\u0080\u0099s easy to see\r\nthat (we can compress every consecutive elements into one). Then, using\r\ninclusion exclusion principle, we can see that the answer is,where is\r\nthe Mobius function. Using this formula, we can calculate the answer in\r\n.. This inclusion-exclusion principle handles the arrays according to\r\nthe GCD of the blocks that they consist of, except for the last one. But\r\nwhat if the array consists only of one block? These arrays can be\r\ncounted wrongly, so we should exclude them i. e. use instead of just and\r\ncount the arrays consisting of the same element (if we need any of them\r\nin the answer separately).. Depending on the way you implement this, or\r\n(or both) may be a corner case.\r\n"
}