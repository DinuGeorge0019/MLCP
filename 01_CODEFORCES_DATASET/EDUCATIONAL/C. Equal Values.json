{
    "link": "https://codeforces.com//contest/2111/problem/C",
    "problemId": "3419288",
    "problem_idx": "C",
    "shortId": "2111C",
    "contest_number": "2111",
    "problem_submissions": {
        "G": [
            322719568,
            322738251,
            322737232,
            322734882,
            322733848,
            322739705,
            322765348,
            322764688,
            322752005,
            322753587,
            322751319,
            322720568,
            322729631,
            322757116,
            322785461,
            322890645,
            323020347,
            322778439,
            322778419,
            322778201,
            322778119,
            322778020,
            322777882,
            322777223,
            322776997,
            322776001,
            322775936
        ],
        "E": [
            322697990,
            322695191,
            322705487,
            322705821,
            322705980,
            322713283,
            322724677,
            322738049,
            322690431,
            322700985,
            322700076,
            322704262,
            322702259,
            322707219,
            322704094,
            322705822,
            322703551
        ],
        "F": [
            322691387,
            322716243,
            322719103,
            322728613,
            322729993,
            322731051,
            322740913,
            322686943,
            322710192,
            322719720,
            322713672,
            322713636,
            322726013,
            322721562,
            322720556,
            322728230,
            322730210
        ],
        "D": [
            322678511,
            322686771,
            322684334,
            322692059,
            322689019,
            322692746,
            322686820,
            322741814,
            322683201,
            322689247,
            322687368,
            322686598,
            322691632,
            322687656,
            322691451,
            322694053,
            322684204
        ],
        "C": [
            322676707,
            322681404,
            322679043,
            322681662,
            322681314,
            322683752,
            322680197,
            322743070,
            322679811,
            322681807,
            322679034,
            322681517,
            322680587,
            322678741,
            322686213,
            322679235,
            322680369
        ],
        "B": [
            322676127,
            322679449,
            322677961,
            322679172,
            322678800,
            322680312,
            322678349,
            322745453,
            322678542,
            322679221,
            322677917,
            322679124,
            322677847,
            322677424,
            322681157,
            322677471,
            322677308
        ],
        "A": [
            322675651,
            322676474,
            322676120,
            322676736,
            322675861,
            322677535,
            322676082,
            322747128,
            322675974,
            322676468,
            322676128,
            322676492,
            322675977,
            322675843,
            322676405,
            322675792,
            322675708
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/143528",
    "editorial": "The first minor observation is that the cost of both operations is the\r\nvalue of the element times the number of the elements affected by the\r\noperation. Let’s also expand the scope of both operations so that we can\r\napply the first operation to the first element (with cost , since\r\nelements are affected) and the second operation to the last element.Fix\r\nthe value that will be the final value of all elements of the array.\r\nObviously, it only makes sense to apply the operations to the elements\r\nequal to .Let’s consider the operations of the first and second types\r\nseparately. Note that if we apply an operation that changes values to\r\nthe left at position , and an operation that changes values to the right\r\nat position , with , we can always reduce the total cost by applying\r\nboth operations to either or . This means that there exists an optimal\r\nsolution in which operations of the first type never affect elements\r\nchanged by operations of the second type.Now, let’s consider only the\r\noperations that change elements to the left. Suppose one operation is\r\napplied at position , and another at position . If instead of them we\r\napply one operation at position , the effect will be exactly the same.\r\nSimilarly, we can show this for operations that change elements to the\r\nright. Thus, it is sufficient to apply one operation of each type.Let\r\nthe operation to the left be applied at position , and the operation to\r\nthe right at position (with ). All elements between and must be equal to\r\n, because they are not affected by the operations. The total cost of\r\nsuch operations will be equal to . So, the answer depends on the\r\ndistance between and and the value of . Since all values between and\r\nmust be equal to , they form a continuous block of identical values.\r\nTherefore, to find the optimal answer, it is sufficient to iterate over\r\nthe blocks of identical values in the array and choose the minimum\r\nanswer from them. This can be done using the two-pointer method.Overall\r\ncomplexity: per test case.\r\n",
    "name": "C. Equal Values",
    "statement": "You are given an array a_1, a_2,\r\ndots, a_n, consisting of n integers.In one operation, you are allowed to\r\nperform one of the following actions: Choose a position i (1 < i\r\nle n) and make all elements to the left of i equal to a_i. That is,\r\nassign the value a_i to all a_j (1\r\nle j < i). The cost of such an operation is (i - 1)\r\ncdot a_i. Choose a position i (1\r\nle i < n) and make all elements to the right of i equal to a_i. That is,\r\nassign the value a_i to all a_j (i < j\r\nle n). The cost of such an operation is (n - i)\r\ncdot a_i. Note that the elements affected by an operation may already be\r\nequal to a_i, but that doesn’t change the cost.You are allowed to\r\nperform any number of operations (including zero). What is the minimum\r\ntotal cost to make all elements of the array equal?\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "two pointers"
    ],
    "dificulty": "",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Equal Values.json",
    "hint": []
}