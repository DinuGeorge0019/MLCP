{"link": "https://codeforces.com//contest/1036/problem/D", "problemId": "216420", "problem_idx": "D", "shortId": "1036D", "contest_number": "1036", "problem_submissions": {"G": [42635175, 42627436, 42635430, 42626359, 42737989, 42717556, 42717524, 42717521, 42651041, 42700940, 42700625, 54263107, 42638239, 42625046, 42815013], "B": [42631894, 42635568, 42631049, 42642897, 42640457, 42621960, 42628162, 42621741, 42621550, 42618797, 42623868, 42633347, 42620322, 42622448, 42641969, 42624721, 42635114, 42625827, 42628122, 42634984, 42644768], "F": [42629280, 42634265, 42627972, 42642001, 42641962, 42630707, 42634470, 42717490, 42631938, 42631850, 42631382, 42631058, 42629288, 42629020, 42633820, 42633355, 42631044, 42636476, 42635060, 42629290, 42636959, 42643700, 42637023, 42633474, 42641007], "E": [42626026, 42624301, 42644046, 42634366, 42634335, 42634205, 42630482, 42637851, 42633450, 42641281, 42638561, 42638638, 42639628, 42642761, 42644666, 42649447, 42648312, 42643498, 42631013, 42635443, 42642733, 42645034, 42634920], "D": [42623581, 42621638, 42636628, 42635516, 42624651, 42622909, 42625901, 42624230, 42627616, 42623027, 42622706, 42628513, 42629952, 42622220, 42628717, 42631816, 42630498, 42632680, 42629722, 42643211], "C": [42622041, 42620587, 42639507, 42636945, 42623531, 42620800, 42624388, 42623206, 42625364, 42621712, 81464229, 42620946, 42626482, 42628744, 42619137, 42627629, 42632962, 42629275, 42630870, 42627504, 42631469], "A": [42617741, 42628137, 42620189, 42640915, 42619770, 42617799, 42621837, 42618858, 42617734, 42618440, 42617898, 42617724, 42617895, 42631014, 42618014, 42635499, 42624408, 42620380, 42619824]}, "name": "D. Vasya and Arrays", "statement": "Vasya has two arrays A and B of lengths n and m, respectively.He can\r\nperform the following operation arbitrary number of times (possibly\r\nzero): he takes some consecutive subsegment of the array and replaces it\r\nwith a single element, equal to the sum of all elements on this\r\nsubsegment. For example, from the array [1, 10, 100, 1000, 10000] Vasya\r\ncan obtain array [1, 1110, 10000], and from array [1, 2, 3] Vasya can\r\nobtain array [6].Two arrays A and B are considered equal if and only if\r\nthey have the same length and for each valid i A_i = B_i.Vasya wants to\r\nperform some of these operations on array A, some on array B, in such a\r\nway that arrays A and B become equal. Moreover, the lengths of the\r\nresulting arrays should be maximal possible.Help Vasya to determine the\r\nmaximum length of the arrays that he can achieve or output that it is\r\nimpossible to make arrays A and B equal.\r\n", "solutions": ["// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nconst int N=303030;\nvoid build(){\n\n}\nLL n, a[N];\nLL m, b[N];\nvoid init(){\n  n=getint();\n  for(int i=0; i<n; i++) a[i]=getint();\n  m=getint();\n  for(int i=0; i<m; i++) b[i]=getint();\n}\nvoid solve(){\n  int ii=0, jj=0, ans=0;\n  LL si=0, sj=0;\n  while(ii<n or jj<m){\n    while(si==0 or (si != sj)){\n      if(si == 0 or si<sj){\n        if(ii >= n) break;\n        si+=a[ii++];\n        continue;\n      }\n      if(jj >= m) break;\n      sj+=b[jj++];\n    }\n    if(si==0 or (si != sj)){\n      puts(\"-1\");\n      exit(0);\n    }\n    ans++;\n    si=sj=0;\n    if(ii == n and jj == m) break;\n  }\n  printf(\"%d\\n\", ans);\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n"], "input": "", "output": "", "tags": ["greedy", "two pointers"], "dificulty": "1600", "interactive": false}