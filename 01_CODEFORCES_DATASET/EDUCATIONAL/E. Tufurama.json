{
    "link": "https://codeforces.com//contest/961/problem/E",
    "problemId": "171416",
    "problem_idx": "E",
    "shortId": "961E",
    "contest_number": "961",
    "problem_submissions": {
        "G": [
            36970557,
            36961677,
            36955373,
            36966255,
            36968767,
            36972374,
            36973392,
            36957451,
            36991516,
            36977772,
            37364242,
            37112264,
            37103114
        ],
        "F": [
            36962483,
            58125816,
            58125730,
            36966139,
            36964087,
            37005545,
            36970234,
            36973408,
            36969033,
            36991746,
            37364493,
            37112764
        ],
        "E": [
            36956673,
            36957355,
            36966375,
            36957711,
            36958527,
            36964823,
            36966940,
            36964605,
            36962819,
            36970706,
            36966486,
            36958105,
            36958693,
            36959772,
            36960024,
            36961569,
            36960764,
            36960481,
            36957668,
            36960105
        ],
        "D": [
            36955388,
            36956052,
            36969754,
            36955080,
            36956362,
            36961025,
            36963713,
            36962592,
            36966993,
            36973138,
            36969906,
            36956687,
            36956700,
            36954860,
            36958377,
            36958046,
            36957936,
            36957484,
            36960554,
            36961499
        ],
        "C": [
            36953672,
            36954711,
            36971159,
            36953758,
            36954957,
            36955003,
            36960223,
            36959774,
            36965066,
            36959731,
            36967876,
            36954453,
            36954510,
            36957051,
            36956228,
            36956460,
            36956413,
            36954603,
            36954325,
            36955697
        ],
        "B": [
            36952423,
            36952593,
            36971775,
            36952372,
            36952637,
            36953362,
            36954152,
            36957455,
            36960770,
            36955533,
            36967266,
            36952701,
            36952953,
            36954148,
            36953570,
            36952980,
            36953956,
            36952386,
            36952552,
            36953095
        ],
        "A": [
            36951806,
            36951845,
            36972158,
            36951809,
            36951933,
            36951849,
            36952464,
            36956565,
            36959860,
            36954250,
            36966810,
            36951886,
            36952011,
            36951975,
            36952180,
            36951811,
            36952978,
            36951822,
            36951814,
            36951906
        ]
    },
    "name": "E. Tufurama",
    "statement": "One day Polycarp decided to rewatch his absolute favourite episode of\r\nwell-known TV series \"Tufurama\". He was pretty surprised when he got\r\nresults only for season 7 episode 3 with his search query of \"Watch\r\nTufurama season 3 episode 7 online full hd free\". This got Polycarp\r\nconfused what if he decides to rewatch the entire series someday and\r\nwon’t be able to find the right episodes to watch? Polycarp now wants to\r\ncount the number of times he will be forced to search for an episode\r\nusing some different method.TV series have seasons (numbered through ),\r\nthe -th season has episodes (numbered through ). Polycarp thinks that if\r\nfor some pair of integers and () exist both season episode and season\r\nepisode then one of these search queries will include the wrong results.\r\nHelp Polycarp to calculate the number of such pairs!\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint indt[600000];\nvoid update(int p, int v) {\n\tp += IT_MAX;\n\tfor (; p; p /= 2) indt[p] += v;\n}\nint getsum(int p1, int p2) {\n\tp1 += IT_MAX;\n\tp2 += IT_MAX;\n\tint rv = 0;\n\tfor (; p1 <= p2; p1 /= 2, p2 /= 2) {\n\t\tif (p1 % 2 == 1) rv = rv + indt[p1++];\n\t\tif (p2 % 2 == 0) rv = rv + indt[p2--];\n\t}\n\treturn rv;\n}\n\nint in[200050];\n\nvector <int> Vq[200050];\nint main() {\n\tint N, i;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(\"%d\", &in[i]);\n\t\tif (in[i] <= N) Vq[in[i]].push_back(i);\n\t}\n\n\tfor (i = 1; i <= N; i++) update(i, 1);\n\t\n\tll ans = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (auto it : Vq[i - 1]) update(it, -1);\n\t\tans += getsum(i + 1, min(N, in[i]));\n\t}\n\treturn !printf(\"%lld\\n\", ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Tufurama.json",
    "editorial_link": "https://codeforces.com//blog/entry/58743",
    "editorial": "At first, it doesnât matter if some season has more than episodes, so we\r\ncan set .Letâs maintain next invariant: when we proceed -th season we\r\nwill have only seasons containing the episodes with indices . Then the\r\nnumber of pairs is just number of seasons with index . One of the ways\r\nto maintain this invariant is the following: for each number of episodes\r\nstore a list with indices of seasons with exactly episodes. Then after\r\nproceeding of -th season just erase all seasons with exactly\r\nepisodes.Maintaining seasons and counting them can be done by BIT with\r\nzeros and ones.Finally, notice, that we counted each pair twice, and\r\nalso counted the pairs , so we must subtract the number of pairs (where\r\n) and divide the result by two.\r\n",
    "hint": []
}