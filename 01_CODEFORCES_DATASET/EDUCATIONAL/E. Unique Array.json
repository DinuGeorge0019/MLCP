{
    "link": "https://codeforces.com//contest/1969/problem/E",
    "problemId": "2619521",
    "problem_idx": "E",
    "shortId": "1969E",
    "contest_number": "1969",
    "problem_submissions": {
        "F": [
            258740971,
            258740820,
            258746132,
            258746716,
            258755183,
            258754014,
            258764616,
            258761581,
            258761069,
            258757448,
            258733006,
            258743321,
            258792091,
            258769461
        ],
        "E": [
            258725328,
            258720683,
            258724478,
            258731693,
            258756331,
            258755767,
            258736057,
            258804715,
            258733183,
            258735874,
            258730875,
            258757457,
            258749091,
            258722655,
            258724259,
            258731836,
            258735531,
            258733424,
            258733392,
            258730397,
            258733010,
            258733415,
            258736757
        ],
        "D": [
            258715496,
            258711950,
            258717455,
            258715807,
            258715309,
            258717478,
            258718891,
            258722961,
            258744444,
            258753841,
            258715868,
            258714258,
            258718192,
            258717839,
            258720978,
            258721300,
            258722241,
            258769261,
            258723656,
            258722483,
            258717125
        ],
        "C": [
            258709519,
            258714184,
            258710089,
            258708902,
            258709129,
            258711287,
            258711586,
            258731391,
            258739788,
            258758308,
            258709210,
            258714988,
            258712692,
            258710594,
            258712746,
            258713533,
            258716060,
            258713283,
            258715693,
            258710630
        ],
        "B": [
            258705054,
            258704158,
            258705135,
            258705001,
            258705619,
            258707939,
            258707446,
            258706758,
            258736445,
            258759399,
            258704770,
            258705679,
            258707425,
            258706710,
            258706746,
            258707793,
            258708419,
            258705968,
            258708957,
            258706188
        ],
        "A": [
            258703665,
            258703553,
            258703758,
            258703560,
            258703556,
            258703637,
            258704655,
            258703660,
            258734943,
            258760234,
            258703586,
            258703687,
            258704850,
            258703730,
            258703995,
            258703579,
            258704091,
            258703811,
            258704619,
            258703722
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129022",
    "editorial": "When we replace an element, we can always choose an integer that is not\r\npresent in the array. So, if we replace the -th element, every subarray\r\ncontaining it becomes unique; and the problem can be reformulated as\r\nfollows: consider all non-unique subarrays of the array, and calculate\r\nthe minimum number of elements you have to choose so that, for every\r\nnon-unique subarray, at least one of its elements is chosen.We can use\r\nthe following greedy strategy to do it: go through the array from left\r\nto right, maintaining the index of the last element we replaced. When we\r\nconsider the -th element of the array, if there is a non-unique subarray\r\nwith , we replace the -th element, otherwise we donât replace\r\nanything.Why is it optimal? Essentially, this greedy approach always\r\nfinds a non-unique subarray with the lowest value of , and replaces the\r\n-th element. We obviously have to replace at least one element from the\r\nsubarray ; but replacing the -th element is optimal since we picked the\r\nlowest value of , so every non-unique subarray which contains any\r\nelement from also contains the -th element.Okay, but we need to make\r\nthis greedy solution work fast. When we consider the -th element, how do\r\nwe check that thereâs a non-unique subarray starting after the element\r\nand ending at the -th element? Suppose we go from the -th element to the\r\nleft and maintain a counter; when we meet an element for the first time,\r\nwe increase this counter; when we meet an element for the second time,\r\nwe decrease this counter. If this counter is equal to , then the current\r\nsubarray is non-unique: every element appears at least twice. Otherwise,\r\nat least one element has exactly one occurrence.Suppose we maintain an\r\narray where for each integer present in the original array, we put in\r\nthe last position weâve seen this element, and in the second-to-last\r\nposition weâve seen this element (i. e. for every element, we consider\r\nits two last occurrences among the first positions in the array, put in\r\nthe last of them, and in the second-to-last of them). Then, if we go\r\nfrom to and maintain the counter in the same way as we described in the\r\nprevious paragraph, the value of this counter will be equal to the sum\r\nof the corresponding segment in this array .So, we want to check if\r\nthereâs a segment in the array such that its left border is greater than\r\n(the last position where we made a replacement), the right border is ,\r\nand the sum is . We can show that the sum on any segment ending in the\r\n-th position is currently non-negative; so, we actually want to find the\r\nsegment with the minimum sum. We can store a segment tree that, for\r\nevery position from to , maintains the sum on segment ; then changing an\r\nelement is just performing the query \"add on segment\", and finding the\r\nminimum sum is just performing the query \"minimum on segment\". This\r\nallows us to get a solution with complexity of .\r\n",
    "name": "E. Unique Array",
    "statement": "You are given an integer array a of length n. A subarray of a is one of\r\nits contiguous subsequences (i. e. an array [a_l, a_{l+1},\r\ndots, a_r] for some integers l and r such that 1\r\nle l < r\r\nle n). Let’s call a subarray if there is an integer that occurs exactly\r\nonce in the subarray.You can perform the following operation any number\r\nof times (possibly zero): choose an element of the array and replace it\r\nwith any integer.Your task is to calculate the minimum number of\r\naforementioned operation in order for all the subarrays of the array a\r\nto be unique.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"#pragma GCC optimize (\"O3\")#pragma GCC target (\"sse4\") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd; template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << '\\'' << x << '\\'';}void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}void __print(bool x) {cerr << (x ? \"true\" : \"false\");} template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}template<typename T>void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}void _print() {cerr << \"]\\n\";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;#else#define dbg(x...)#endif  const int MOD = 1000000007;const char nl = '\\n';const int MX = 100001;   const ll identity = 0;const ll SZ = 131072*4; pl sum[2*SZ]; ll lazy[2*SZ]; pl combine(pl A, pl B) {    return min(A, B);} pl combineUpd(pl A, ll B) {    return {A.f+B, A.s};} void push(int index, ll L, ll R) {    sum[index] = combineUpd(sum[index], lazy[index]);    if (L != R) lazy[2*index] += lazy[index], lazy[2*index+1] += lazy[index];    lazy[index] = identity;} void pull(int index) {    sum[index] = combine(sum[2*index], sum[2*index+1]);} pl query(int lo, int hi, int index = 1, ll L = 0, ll R = SZ-1) {    push(index, L, R);    if (lo > R || L > hi) return {MOD, -1};    if (lo <= L && R <= hi) return sum[index];     int M = (L+R) / 2;    return combine(query(lo, hi, 2*index, L, M), query(lo, hi, 2*index+1, M+1, R));} void update(int lo, int hi, ll increase, int index = 1, ll L = 0, ll R = SZ-1) {    push(index, L, R);    if (hi < L || R < lo) return;    if (lo <= L && R <= hi) {        lazy[index] = increase;        push(index, L, R);        return;    }     int M = (L+R) / 2;    update(lo, hi, increase, 2*index, L, M); update(lo, hi, increase, 2*index+1, M+1, R);    pull(index);} void solve() {    int N; cin >> N;    vi A(N); F0R(i, N) cin >> A[i];    int nxtOcc[N+1]; F0R(i, N+1) nxtOcc[i] = N;    int twoOcc[N+1]; F0R(i, N+1) twoOcc[i] = N;    int nxtBad[N];    F0Rd(i, N) {        int v = A[i];        if (nxtOcc[v] != N) {            //dbg(nxtOcc[v], twoOcc[v] - 1, \"MINUS\");            update(nxtOcc[v], twoOcc[v] - 1, -1);        }        //dbg(i, nxtOcc[v] - 1, \"PLUS\");        update(i, nxtOcc[v] - 1, 1);        twoOcc[v] = nxtOcc[v];        nxtOcc[v] = i;        nxtBad[i] = query(i, N).s;        ckmin(nxtBad[i], N);        if (i < N-1) {            ckmin(nxtBad[i], nxtBad[i+1]);        }        //dbg(i, nxtBad[i], query(i, N), query(N, N));    }     int v = 0;    int ans = 0;    while (v < N && nxtBad[v] < N) {        ans++;        v = nxtBad[v] + 1;    }    cout << ans << nl;      F0R(i, N+10) {        update(i, i, -query(i, i).f);    } } int main() {    ios_base::sync_with_stdio(0); cin.tie(0);     FOR(i, SZ, 2*SZ) {        sum[i].s = i-SZ;    }    F0Rd(i, SZ) {        pull(i);    }    int T = 1;    cin >> T;    while(T--) {        solve();    } \treturn 0;}  "
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dp",
        "greedy"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Unique Array.json",
    "hint": []
}