{
    "link": "https://codeforces.com//contest/1487/problem/G",
    "problemId": "897753",
    "problem_idx": "G",
    "shortId": "1487G",
    "contest_number": "1487",
    "problem_submissions": {
        "G": [
            107454023,
            107463460,
            108576854,
            107460627,
            107450583,
            107451415,
            107430357,
            107444206,
            107450475,
            107450812,
            107922779,
            107446295,
            107455969,
            107448609,
            107460406,
            107464872,
            107461634,
            107460893,
            107461280,
            107537497
        ],
        "F": [
            107439893,
            107447022,
            107443885,
            107469668,
            107469505,
            107444768,
            107452696,
            107498096,
            107498067,
            107494456,
            107622368,
            107452390,
            107465180
        ],
        "E": [
            107424178,
            107424961,
            107432865,
            107429617,
            107432584,
            107450909,
            107426371,
            107427677,
            107427122,
            107429815,
            107619068,
            107618663,
            107432462,
            107430691,
            107435461,
            107433872,
            107429938,
            107432421,
            107433935,
            107430580,
            107430754
        ],
        "D": [
            107421373,
            107421309,
            107427665,
            107423119,
            107428301,
            107453801,
            107421667,
            107423926,
            107424261,
            107424540,
            107428634,
            107426278,
            107425386,
            107425551,
            107425722,
            107429097,
            107425401,
            107424375,
            107424284
        ],
        "C": [
            107420002,
            107418181,
            108576710,
            107420782,
            107436848,
            107423312,
            107458805,
            107419068,
            107421219,
            107421707,
            107421854,
            107426343,
            107423376,
            107421931,
            107421521,
            107423818,
            107421650,
            107421555,
            107422095,
            107421412
        ],
        "B": [
            107416333,
            107413010,
            108576679,
            107416798,
            107424397,
            107419739,
            107460613,
            107414304,
            107416812,
            107415960,
            107414948,
            107416874,
            107418655,
            107417622,
            107416871,
            107416648,
            107416339,
            107414794,
            107418914,
            107416654
        ],
        "A": [
            107410359,
            107409706,
            108576659,
            107410154,
            107409888,
            107412513,
            107461425,
            107409652,
            107410618,
            107410216,
            107410119,
            107412422,
            107409710,
            107411124,
            107409938,
            107409679,
            107409688,
            107409851,
            107409775,
            107410068
        ]
    },
    "name": "G. String Counting",
    "statement": "You have c_1 letters \u201d, c_2 letters \u201d, ..., c_{26} letters \u201d. You want\r\nto build a string of length n from them (obviously, you cannot use the\r\ni-th letter more than c_i times). .A string is called if there are no\r\npalindromic contiguous substrings of odd length greater than 1 in it.\r\nFor example, the string \"\" is not beautiful, it has several palindromic\r\nsubstrings of odd length greater than 1 (for example, \"\"). Another\r\nexample: the string \"\" is .Calculate the number of different strings you\r\ncan build, and print the answer modulo 998244353.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n\nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvoid solve() {\n\n    int N; cin >> N;\n    int A[26]; F0R(i, 26) cin >> A[i];\n    mi dp[N+1][N+1][3][3];\n    mi nxt[N+1][N+1][3][3];\n    dp[0][0][2][2] = 1;\n    F0R(iter, N) {\n        F0R(i, N+1) {\n            F0R(j, N+1) {\n                F0R(k, 3) {\n                    F0R(l, 3) {\n                        if (i < N && k != 0) {\n                            nxt[i+1][j][l][0]+=dp[i][j][k][l];\n                        }\n                        if (j < N && k != 1) {\n                            nxt[i][j+1][l][1] += dp[i][j][k][l];\n                        } \n                        if (k != 2 || iter < 2)  {\n                            nxt[i][j][l][2] += dp[i][j][k][l];\n                        }\n                        nxt[i][j][l][2] += dp[i][j][k][l] * 23;\n                    }\n                }\n            }\n        }\n        F0R(i, N+1) F0R(j, N+1) F0R(k, 3) F0R(l, 3) dp[i][j][k][l] = nxt[i][j][k][l];\n        F0R(i, N+1) F0R(j, N+1) F0R(k, 3) F0R(l, 3) nxt[i][j][k][l] = 0;\n    }\n\n    mi wayOne[N+1], wayTwo[N+1][N+1];\n    F0R(i, N+1) {\n        F0R(j, N+1) {\n            F0R(k, 3) {\n                F0R(l, 3) {\n                    wayOne[i] += dp[i][j][k][l];\n                    wayTwo[i][j] += dp[i][j][k][l];\n                }\n            }\n        }\n    }\n    F0Rd(i, N) wayOne[i] += wayOne[i+1];\n    F0Rd(i, N+1) {\n        F0Rd(j, N+1) {\n            if (i < N) {\n                wayTwo[i][j] += wayTwo[i+1][j];\n            }\n            if (j < N) {\n                wayTwo[i][j] += wayTwo[i][j+1];\n            }\n            if (i < N && j < N) wayTwo[i][j] -= wayTwo[i+1][j+1];\n        }\n    }\n    mi ans = pow(mi(25), N-2) * 26 * 26;\n    F0R(i, 26) {\n        if (A[i] < N) ans -= wayOne[A[i]+1];\n        FOR(j, i+1, 26) {\n            if (A[i] + A[j] + 2 <= N) ans += wayTwo[A[i]+1][A[j]+1];\n        }\n    }\n    cout << ans << nl;\n    \n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "math"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. String Counting.json",
    "editorial_link": "https://codeforces.com//blog/entry/87873",
    "editorial": "Suppose there is no constraint on the number of letters used. Then this\r\nproblem can be solved with the following dynamic programming: let be the\r\nnumber of strings of length ending with characters and that don\u00e2\u0080\u0099t\r\ncontain palindromes of odd length greater than (obviously, each\r\nforbidden palindrome contains a subpalindrome of length , so we only\r\nneed to ensure that there are no palindromes of length ).The thing we\r\nare going to use in order to ensure that all the constraints on the\r\nnumber of characters are met is inclusion-exclusion. Since each , at\r\nmost two characters can violate their constraints in a single string, so\r\nwe will iterate on some character of the alphabet and subtract the\r\nnumber of strings violating the constraint on this character from the\r\nanswer, then iterate on a pair of characters and add the number of\r\nstrings violating the constraints on these two characters to the\r\nanswer.Okay, how to calculate the number of strings violating the\r\nconstraint on some fixed character? Let\u00e2\u0080\u0099s use dynamic programming the\r\nnumber of strings such that they contain characters, of them have the\r\nsame type that we fixed, the previous-to-last character is and the last\r\ncharacter is . The number of states here seems to be something about ,\r\nbut in fact, and can be optimized to have only two different values\r\nsince we are interested in two types of characters: the ones that\r\ncoincide with the character we fixed, and the ones that don\u00e2\u0080\u0099t.Okay, what\r\nabout violating the constraints on two characters? The same method can\r\nbe used here: let be the number of strings consisting of characters such\r\nthat the number of occurrences of the first fixed character is , the\r\nnumber of occurrences of the second fixed character is , the\r\nprevious-to-last character is and the last character is . Again, at\r\nfirst it seems that there are up to states, but and can be optimized to\r\nhave only different values, so the number of states is actually .It\r\nseems that we have to run this dynamic programming for each pair of\r\ncharacters, right? In fact, no, , the only difference is which states\r\nviolate the constraints and which don\u00e2\u0080\u0099t. We can run this dp only once,\r\nand when we need an answer for the pair of characters , we can use\r\ntwo-dimensional prefix sums to query the sum over with , and in . In\r\nfact, this dynamic programming can also be used for the first and the\r\nsecond part of the solution (calculating the strings that don\u00e2\u0080\u0099t violate\r\nany constraints and the strings that violate the constraints on one\r\ncharacter), so the hardest part of the solution runs in , though with a\r\npretty big constant factor.\r\n"
}