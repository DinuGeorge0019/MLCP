{
    "link": "https://codeforces.com//contest/1156/problem/D",
    "problemId": "338451",
    "problem_idx": "D",
    "shortId": "1156D",
    "contest_number": "1156",
    "problem_submissions": {
        "A": [
            53639029,
            53626152,
            53625678,
            53630793,
            53625404,
            53614352,
            53623128,
            53628986,
            53624721,
            53623695,
            53625017,
            53634723,
            53624542,
            53628079,
            53633627,
            53624437,
            53623236,
            53629488,
            53623966,
            53615060
        ],
        "B": [
            53637891,
            53617977,
            53617293,
            53625525,
            53620909,
            53621377,
            53618385,
            53633927,
            53620068,
            53619804,
            53621825,
            53614635,
            53623085,
            53633560,
            53636498,
            53618667,
            53619022,
            53619496,
            53620680,
            53624386
        ],
        "C": [
            53636621,
            53619670,
            53619150,
            53614135,
            53617663,
            53625504,
            53624957,
            53661619,
            53635201,
            53626601,
            53622201,
            53615675,
            53635681,
            53619089,
            53620360,
            53614001,
            53620016,
            53634903,
            53620881,
            53615566,
            53626189
        ],
        "G": [
            53635130,
            53641842,
            53954352,
            53641770,
            203176755,
            53643379
        ],
        "D": [
            53620605,
            53623897,
            53623535,
            53629070,
            53631245,
            53633026,
            53629459,
            53616004,
            53628435,
            53632954,
            53632904,
            53620339,
            53632312,
            53623609,
            53618157,
            53629146,
            53629263,
            53627644,
            53629790,
            53630995
        ],
        "F": [
            53617719,
            53632417,
            53636572,
            53634637,
            53627300,
            53636941,
            53634698,
            53625519,
            53635307,
            53636482,
            53636370,
            53630747,
            53636740,
            53635472,
            53633389,
            53637182,
            53632117,
            53637419,
            53635743,
            53636158
        ],
        "E": [
            53614077,
            53629771,
            53629915,
            53618247,
            53637367,
            53630569,
            53631126,
            53661599,
            53620934,
            53631115,
            53629004,
            53629934,
            53625980,
            53630101,
            53619260,
            53627891,
            53632780,
            53621624,
            53634838,
            53638304,
            53634716
        ]
    },
    "name": "D. 0-1-Tree",
    "statement": "You are given a tree (an undirected connected acyclic graph) consisting\r\nof n vertices and n - 1 edges. A number is written on each edge, each\r\nnumber is either 0 (let’s call such edges 0-edges) or 1 (those are\r\n1-edges).Let’s call an ordered pair of vertices (x, y) (x\r\nne y) if, while traversing the simple path from x to y, we never go\r\nthrough a 0-edge after going through a 1-edge. Your task is to calculate\r\nthe number of pairs in the tree.\r\n",
    "solutions": [
        "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nvector<int> g0[N], g1[N];\nbool used[N];\nint cnt0[N], cnt1[N];\n\nvector<int> comp;\n\nvoid dfs0(int u) {\n    used[u] = true;\n    comp.push_back(u);\n    for (int v : g0[u]) {\n        if (!used[v]) {\n            dfs0(v);\n        }\n    }\n}\n\nvoid dfs1(int u) {\n    used[u] = true;\n    comp.push_back(u);\n    for (int v : g1[u]) {\n        if (!used[v]) {\n            dfs1(v);\n        }\n    }\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    rep(i, 0, n - 1) {\n        int u, v, w;\n        cin >> u >> v >> w; u--; v--;\n        if (w == 0) {\n            g0[u].push_back(v);\n            g0[v].push_back(u);\n        } else {\n            g1[u].push_back(v);\n            g1[v].push_back(u);\n        }\n    }\n    ll ans = 0;\n    fill(used, used + n, false);\n    rep(i, 0, n) {\n        if (!used[i]) {\n            comp.clear();\n            dfs0(i);\n            ans += 1LL * sz(comp) * (sz(comp) - 1);\n            for (int x : comp) {\n                cnt0[x] = sz(comp);\n            }\n        }\n    }\n    fill(used, used + n, false);\n    rep(i, 0, n) {\n        if (!used[i]) {\n            comp.clear();\n            dfs1(i);\n            ans += 1LL * sz(comp) * (sz(comp) - 1);\n            for (int x : comp) {\n                cnt1[x] = sz(comp);\n            }\n        }\n    }\n    rep(i, 0, n) {\n        ans += 1LL * (cnt0[i] - 1) * (cnt1[i] - 1);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "divide and conquer",
        "dp",
        "dsu",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. 0-1-Tree.json",
    "editorial_link": "https://codeforces.com/blog/entry/66827",
    "editorial": "Letâs divide all valid pairs into three categories: the ones containing\r\nonly -edges on the path, the ones containing only -edges, and the ones\r\ncontaining both types of edges.To calculate the number of pairs\r\ncontaining only -edges, we may build a forest on the vertices of the\r\noriginal graph and -edges, and choose all pairs of vertices belonging to\r\nthe same connected components of this forest (we can find all connected\r\ncomponents with DSU or any graph traversal algorithm). The same can be\r\ndone for the pairs containing only -edges.If a path from to is valid and\r\ncontains both types of edges, then there exists a vertex such that the\r\nsimple path from to goes only through -edges, and the simple path from\r\nto goes only through -edges. So, letâs iterate on this vertex , and\r\nchoose some other vertex from its component in -graph as , and some\r\nother vertex from its component in -graph as , and add the number of\r\nways to choose them to the answer.\r\n",
    "hint": []
}