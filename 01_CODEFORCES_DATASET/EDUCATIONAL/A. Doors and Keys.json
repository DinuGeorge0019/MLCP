{"link": "https://codeforces.com//contest/1644/problem/A", "problemId": "1306302", "problem_idx": "A", "shortId": "1644A", "contest_number": "1644", "problem_submissions": {"F": [147320866, 147353077, 147335774, 147336779, 147338284, 147344072, 147361395, 147361328, 147360591, 147341020, 147347713, 147363763, 147363723, 147322590, 152772960, 147359576, 147689521], "E": [147306717, 147306569, 147311348, 147309095, 147307844, 147307929, 147314427, 147326156, 147310695, 147307982, 147306896, 147305676, 147310587, 147307037, 147315289, 147313121, 147313445, 147321773], "D": [147293584, 147307300, 147301707, 147294952, 147298642, 147298634, 147300618, 147333853, 147291913, 147295056, 147298209, 147295009, 147295505, 147297361, 147296680, 147301724, 147303329, 147296313], "C": [147288888, 147290549, 147296803, 147287863, 147292950, 147291474, 147293826, 147331175, 147286835, 147291088, 147291894, 147288455, 147290620, 147288872, 147289111, 147292816, 147293660, 147289532], "B": [147281121, 147281154, 147291952, 147280086, 147282998, 147283506, 147285667, 147332125, 147281901, 147282926, 147283802, 147281429, 147284985, 147282861, 147283027, 147287392, 147286913, 147282167], "A": [147278514, 147278406, 147278697, 147278304, 147278969, 147279113, 147278307, 147332805, 147278673, 147278387, 147278783, 147278331, 147278464, 147278483, 147278302, 147278920, 147278819, 147278413]}, "name": "A. Doors and Keys", "statement": "The knight is standing in front of a long and narrow hallway. A princess\r\nis waiting at the end of it.In a hallway there are three doors: a red\r\ndoor, a green door and a blue door. The doors are placed one after\r\nanother, however, possibly in a different order. To proceed to the next\r\ndoor, the knight must first open the door before.Each door can be only\r\nopened with a key of the corresponding color. So three keys: a red key,\r\na green key and a blue key are also placed somewhere in the hallway. To\r\nopen the door, the knight should first pick up the key of its color.The\r\nknight has a map of the hallway. It can be transcribed as a string,\r\nconsisting of six characters: , , denoting red, green and blue doors,\r\nrespectively; , , denoting red, green and blue keys, respectively. Each\r\nof these six characters appears in the string exactly once.The knight is\r\nstanding at the beginning of the hallway on the left on the map.Given a\r\nmap of the hallway, determine if the knight can open all doors and meet\r\nthe princess at the end of the hallway.\r\n", "solutions": ["#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\nint MOD =  1e9 + 7;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n\nconst int LIM = 1000005;\n\nvector<int> facs(LIM), invfacs(LIM), invs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n\n    for (int i = 1; i<LIM; i++) invs[i] = mul(invfacs[i], facs[i-1]);\n\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\n/*\nconst int mod = 998244353;\n\ntemplate<int mod>\nstruct NTT {\n    static constexpr int max_lev = __builtin_ctz(mod - 1);\n\n    int prod[2][max_lev - 1];\n\n    NTT() {\n        int root = find_root();//(mod == 998244353) ? 31 : find_root();\n        int rroot = power(root, mod - 2);\n        vector<vector<int>> roots(2, vector<int>(max_lev - 1));\n        roots[0][max_lev - 2] = root;\n        roots[1][max_lev - 2] = rroot;\n        for (int tp = 0; tp < 2; ++tp) {\n            for (int i = max_lev - 3; i >= 0; --i) {\n                roots[tp][i] = mul(roots[tp][i + 1], roots[tp][i + 1]);\n            }\n        }\n        for (int tp = 0; tp < 2; ++tp) {\n            int cur = 1;\n            for (int i = 0; i < max_lev - 1; ++i) {\n                prod[tp][i] = mul(cur, roots[tp][i]);\n                cur = mul(cur, roots[tp ^ 1][i]);\n            }\n        }\n    }\n\n    template<bool inv>\n    void fft(int *a, int lg) const {\n        const int n = 1 << lg;\n        int pos = max_lev - 1;\n        for (int it = 0; it < lg; ++it) {\n            const int h = inv ? lg - 1 - it : it;\n            const int shift = (1 << (lg - h - 1));\n            int coef = 1;\n            for (int start = 0; start < (1 << h); ++start) {\n                for (int i = start << (lg - h); i < (start << (lg - h)) + shift; ++i) {\n                    if (!inv) {\n                        const int y = mul(a[i + shift], coef);\n                        a[i + shift] = a[i];\n                        inc(a[i], y);\n                        dec(a[i + shift], y);\n                    } else {\n                        const int y = mul(a[i] + mod - a[i + shift], coef);\n                        inc(a[i], a[i + shift]);\n                        a[i + shift] = y;\n                    }\n                }\n                coef = mul(coef, prod[inv][__builtin_ctz(~start)]);\n            }\n        }\n    }\n\n    vector<int> product(vector<int> a, vector<int> b) const {\n        if (a.empty() || b.empty()) {\n            return {};\n        }\n        const int sz = a.size() + b.size() - 1;\n        const int lg = 32 - __builtin_clz(sz - 1), n = 1 << lg;\n        a.resize(n);\n        b.resize(n);\n        fft<false>(a.data(), lg);\n        fft<false>(b.data(), lg);\n        for (int i = 0; i < n; ++i) {\n            a[i] = mul(a[i], b[i]);\n        }\n        fft<true>(a.data(), lg);\n        a.resize(sz);\n        const int rn = power(n, mod - 2);\n        for (int &x : a) {\n            x = mul(x, rn);\n        }\n        return a;\n    }\n\nprivate:\n    static inline void inc(int &x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n    }\n\n    static inline void dec(int &x, int y) {\n        x -= y;\n        if (x < 0) {\n            x += mod;\n        }\n    }\n\n    static inline int mul(int x, int y) {\n        return (1LL * x * y) % mod;\n    }\n\n    static int power(int x, int y) {\n        if (y == 0) {\n            return 1;\n        }\n        if (y % 2 == 0) {\n            return power(mul(x, x), y / 2);\n        }\n        return mul(x, power(x, y - 1));\n    }\n\n    static int find_root() {\n        for (int root = 2; ; ++root) {\n            if (power(root, (1 << max_lev)) == 1 && power(root, (1 << (max_lev - 1))) != 1) {\n                return root;\n            }\n        }\n    }\n};\n\nNTT<mod> ntt;*/\n\nvoid solve()\n{\n    string s; cin>>s;\n    set<int> have;\n    for (auto c: s)\n    {\n        if ('a'<=c && c<='z') have.insert(c-'a');\n        else\n        {\n            if (!have.count(c-'A')) {cout<<\"NO\"<<endl; return;}\n        }\n    }\n    cout<<\"YES\"<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t;\n    while (t--) solve();\n\n}\n"], "input": "", "output": "", "tags": ["implementation"], "dificulty": "800", "interactive": false}