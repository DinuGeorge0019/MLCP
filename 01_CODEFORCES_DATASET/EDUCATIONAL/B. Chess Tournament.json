{
    "link": "https://codeforces.com//contest/1569/problem/B",
    "problemId": "1103180",
    "problem_idx": "B",
    "shortId": "1569B",
    "contest_number": "1569",
    "problem_submissions": {
        "F": [
            128266355,
            128271363,
            128276594,
            128274140,
            128277636,
            128276419,
            128239230,
            128386349,
            128320123
        ],
        "E": [
            128250268,
            128256767,
            128246439,
            128253452,
            128257933,
            128258504,
            128255293,
            128254536,
            128252116,
            128261192,
            128578023,
            128259291,
            128263798,
            128266969,
            128259594,
            128258410,
            128275140,
            128271709,
            128263862,
            128264259
        ],
        "D": [
            128235337,
            128235527,
            128231804,
            128235402,
            128242825,
            128262573,
            128235767,
            128236235,
            128236769,
            128233977,
            128578016,
            128240282,
            128241897,
            128232635,
            128238819,
            128243586,
            128233606,
            128230968,
            128243956,
            128245831
        ],
        "C": [
            128220989,
            128228983,
            128226656,
            128226748,
            128234279,
            128264995,
            128226270,
            128225854,
            128229844,
            128225694,
            128578004,
            128230030,
            128228479,
            128225884,
            128230468,
            128226610,
            128225551,
            128233122,
            128232240,
            128234418
        ],
        "B": [
            128217208,
            128223439,
            128220536,
            128221217,
            128228682,
            128267165,
            128220994,
            128220572,
            128221551,
            128221442,
            128577996,
            128221801,
            128220084,
            128221194,
            128224466,
            128232979,
            128220020,
            128224325,
            128224652,
            128224175
        ],
        "A": [
            128212769,
            128212941,
            128213029,
            128212974,
            128213857,
            128267874,
            128212779,
            128212821,
            128212915,
            128213233,
            128577977,
            128213929,
            128212944,
            128212794,
            128212959,
            128213921,
            128212839,
            128214062,
            128216496,
            128214843
        ]
    },
    "name": "B. Chess Tournament",
    "statement": "A chess tournament will be held soon, where n chess players will take\r\npart. Every participant will play one game against every other\r\nparticipant. Each game ends in either a win for one player and a loss\r\nfor another player, or a draw for both players.Each of the players has\r\ntheir own expectations about the tournament, they can be one of two\r\ntypes: a player wants not to lose any game (i. e. finish the tournament\r\nwith ); a player wants to win at least one game. You have to determine\r\nif there exists an outcome for all the matches such that all the players\r\nmeet their expectations. If there are several possible outcomes, print\r\nany of them. If there are none, report that it\u2019s impossible.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    string S; cin >> S;\n    int cnt = 0; trav(a, S) if (a == '2') cnt++;\n    if (cnt == 1 || cnt == 2) {\n        cout << \"NO\" << nl; return;\n    }\n    cout << \"YES\" << nl;\n    char ans[N][N];\n    F0R(i, N) {\n        F0R(j, N) {\n            ans[i][j] = (i==j?'X':'=');\n        }\n    }\n\n    F0R(i, N) {\n        if (S[i] == '2') {\n            FOR(j, i+1, i+N) {\n                if (S[j%N] == '2') {\n                    ans[i][j%N] = '+';\n                    ans[j%N][i] = '-';\n                    break;\n                }\n            }\n        }\n    }\n    F0R(i, N) {\n        F0R(j, N) {\n            cout << ans[i][j];\n        }\n        cout << nl;\n    }\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Chess Tournament.json",
    "editorial_link": "https://codeforces.com//blog/entry/94721",
    "editorial": "Since the chess players of the first type should not lose a single game,\r\neach game between two chess players of the first type should end in a\r\ndraw (so that none of them gets defeated). And a game between a chess\r\nplayer of the first type and the second type should end either with a\r\nvictory of the first or a draw. Therefore, for convenience, we will say\r\nthat all games with a chess player of the first type end in a draw.Now\r\nthere are only games between chess players of the second type left. If\r\nthere are only or such players, then there is no answer. Otherwise, we\r\ncan choose the following method: the -th chess player of the second type\r\nwins against the -th chess player of the second type, and the last one\r\nwins against the first; all remaining games are drawn.\r\n"
}