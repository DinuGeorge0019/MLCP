{"link": "https://codeforces.com//contest/1809/problem/F", "problemId": "1839366", "problem_idx": "F", "shortId": "1809F", "contest_number": "1809", "problem_submissions": {"G": [198800857, 198819538, 198819377, 198819202, 198818781, 198818684, 198816759, 198811816, 198806762, 198815231, 198818773, 198822181, 198828608, 198822299, 203672607, 208381746, 198835108, 198831844, 198829525, 198853349, 198853245], "F": [198786104, 198791363, 198796885, 198804709, 198810152, 198814173, 198809216, 198791415, 198800965, 198804541, 198830839, 198809769, 198804908, 198811366, 198815172, 198805151, 198812101, 198817151, 198808903, 198814662], "E": [198775336, 198782430, 198786246, 199182668, 198794243, 198792695, 198792300, 198799038, 198776769, 198784470, 198788708, 198793376, 198789791, 198792668, 198843793, 198805320, 198800053, 198802037, 198804412, 198800677, 198799758], "D": [198768775, 198772012, 198776224, 198777641, 198882283, 198777443, 198779801, 198782367, 198766389, 198769656, 198777387, 198777057, 198779683, 198776616, 198772288, 198785016, 198783361, 198781028, 198791791, 198778758], "C": [198764545, 198765840, 198768929, 198772658, 198770321, 198766724, 198776128, 198761542, 198765111, 198760078, 198766275, 198773341, 198769090, 198764454, 198770468, 198769676, 198767761, 198771860, 198780776], "B": [198760964, 198755413, 198762260, 198758056, 198766256, 198759317, 198761525, 198757070, 198756430, 198755376, 198758155, 198765573, 198760583, 198758103, 198766309, 198762187, 198761139, 198766037, 198760442], "A": [198757842, 198756487, 198756930, 198755206, 198755963, 198755170, 198755335, 198755127, 198755119, 198756462, 198755191, 198755804, 198757456, 198755555, 198757141, 198756133, 198756023, 198760810, 198755407]}, "name": "F. Traveling in Berland", "statement": "There are n cities in Berland, arranged in a circle and numbered from 1\r\nto n in clockwise order.You want to travel all over Berland, starting in\r\nsome city, visiting all the other cities and returning to the starting\r\ncity. Unfortunately, you can only drive along the Berland Ring Highway,\r\nwhich connects all n cities. The road was designed by a very titled and\r\nrespectable minister, so it is one-directional it can only be traversed\r\nclockwise, only from the city i to the city (i\r\nbmod n) + 1 (i.e. from 1 to 2, from 2 in 3, ..., from n to 1).The fuel\r\ntank of your car holds up to k liters of fuel. To drive from the i-th\r\ncity to the next one, a_i liters of fuel are needed (and are consumed in\r\nthe process).Every city has a fuel station; a liter of fuel in the i-th\r\ncity costs b_i burles. Refueling between cities is not allowed; if fuel\r\nhas run out between cities, then your journey is considered\r\nincomplete.For each city, calculate the minimum cost of the journey if\r\nyou start and finish it in that city.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    i64 sum = std::accumulate(a.begin(), a.end(), 0LL);\n    \n    std::vector<i64> f(2 * n + 1);\n    for (int i = 0; i < 2 * n; i++) {\n        f[i + 1] = f[i] + a[i % n];\n    }\n    \n    int last = -1;\n    std::vector<int> pre(2 * n);\n    for (int i = 0; i < 2 * n; i++) {\n        if (b[i % n] == 1) {\n            last = i;\n        }\n        pre[i] = last;\n    }\n    \n    std::vector<i64> ans(n);\n    ans[0] += sum;\n    for (int i = 0; i < 2 * n - 1; i++) {\n        if (b[i % n] == 2) {\n            if (pre[i] == -1) {\n                ans[std::max(0, i - n + 1)] += a[i % n];\n                if (i + 1 < n) {\n                    ans[i + 1] -= a[i % n];\n                }\n            } else {\n                int v = std::max(0LL, std::min(1LL * a[i % n], f[i + 1] - f[pre[i]] - k));\n                ans[std::max(0, i - n + 1)] += v;\n                if (pre[i] + 1 < n) {\n                    ans[pre[i] + 1] += a[i % n] - v;\n                }\n                if (i + 1 < n) {\n                    ans[i + 1] -= a[i % n];\n                }\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        ans[i] += ans[i - 1];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i] << \" \\n\"[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "graphs", "greedy", "implementation"], "dificulty": "2500", "interactive": false}