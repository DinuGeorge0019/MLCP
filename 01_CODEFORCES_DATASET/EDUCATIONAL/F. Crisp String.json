{
    "link": "https://codeforces.com//contest/1117/problem/F",
    "problemId": "300046",
    "problem_idx": "F",
    "shortId": "1117F",
    "contest_number": "1117",
    "problem_submissions": {
        "G": [
            50133387,
            50123254,
            50123975,
            50124239,
            50123132,
            50123974,
            50123215,
            50127013,
            50125132,
            50130140,
            50133285,
            50124682,
            50142168,
            50142000,
            50128625,
            50127307,
            50133494,
            50129719,
            50134469,
            50129830
        ],
        "F": [
            50129894,
            50129949,
            50128458,
            50125468,
            50258283,
            50124925,
            50127988,
            50122434,
            50127178,
            50132498,
            50126909,
            50125577
        ],
        "E": [
            50113506,
            50115627,
            50118164,
            50107209,
            50118889,
            50116932,
            50118288,
            50119948,
            50118689,
            50116057,
            50116780,
            50120258,
            50120803,
            50119739,
            50121927,
            50120709,
            50116907,
            50127759,
            50122643
        ],
        "D": [
            50110620,
            50112367,
            50131628,
            50126652,
            50113412,
            50109860,
            50115490,
            50114987,
            50116012,
            50113616,
            50125192,
            50118574,
            50115262,
            50116431,
            50116297,
            50116049,
            50110665,
            50113350,
            50117624
        ],
        "C": [
            50108198,
            50108891,
            50111125,
            50127915,
            50107557,
            50112815,
            50111363,
            50117842,
            50111074,
            50110415,
            50111200,
            50113692,
            50111129,
            50113480,
            50108576,
            50111462,
            50115486,
            50110963,
            50119614
        ],
        "B": [
            50104160,
            50104529,
            50104672,
            50128597,
            50104068,
            50103950,
            50111786,
            50105649,
            50106152,
            50105125,
            50105851,
            50105634,
            50104517,
            50104965,
            50103901,
            50105704,
            50105385,
            50105318,
            50104942
        ],
        "A": [
            50102635,
            50102746,
            50102713,
            50128246,
            50102816,
            50102612,
            50103360,
            50104051,
            50103578,
            50102668,
            50103665,
            50103717,
            50102845,
            50102752,
            50102665,
            50102783,
            50102642,
            50102966,
            50102721
        ]
    },
    "name": "F. Crisp String",
    "statement": "You are given a string of length n. Each character is one of the first p\r\nlowercase Latin letters.You are also given a matrix A with binary values\r\nof size p\r\ntimes p. This matrix is symmetric (A_{ij} = A_{ji}). A_{ij} = 1 means\r\nthat the string can have the i-th and j-th letters of Latin alphabet\r\nadjacent.Let’s call the string if in it can be adjacent (have 1 in the\r\ncorresponding cell of matrix A).You are allowed to do the following\r\nmove. Choose any letter, remove and join the remaining parts of the\r\nstring without changing their order. For example, removing letter ’a’\r\nfrom \"abacaba\" will yield \"bcb\".The string you are given is . The string\r\nshould remain .You are allowed to do arbitrary number of moves (possible\r\nzero). What is the shortest resulting string you can obtain?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,P;\nstring S;\nint A[17][17];\nint nex[18];\nint num[18];\n\nvector<int> ngpat[1<<17];\nint ok[1<<17];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>P>>S;\n\tFOR(i,P) nex[i]=N;\n\tFORR(c,S) {\n\t\tc-='a';\n\t\tnum[c]++;\n\t}\n\tFOR(y,P) FOR(x,P) cin>>A[y][x];\n\tfor(i=N-1;i>=0;i--) {\n\t\tvector<pair<int,int>> V;\n\t\tFOR(j,P) if(nex[j]<N) V.push_back({nex[j],j});\n\t\tsort(ALL(V));\n\t\tint fixed=(1<<P)-1-(1<<S[i]);\n\t\tint mat=1<<S[i];\n\t\tFORR(v,V) {\n\t\t\tif(v.second!=S[i]) {\n\t\t\t\tfixed ^= 1<<(v.second);\n\t\t\t\tmat^= 1<<(v.second);\n\t\t\t}\n\t\t\tif(A[S[i]][v.second]==0) ngpat[fixed].push_back(mat);\n\t\t\tif(v.second==S[i]) break;\n\t\t\tmat^= 1<<(v.second);\n\t\t}\n\t\tnex[S[i]]=i;\n\t}\n\t\n\tint mask;\n\tFOR(mask,1<<P) ok[mask]=1;\n\tFOR(mask,1<<P) {\n\t\tsort(ALL(ngpat[mask]));\n\t\tngpat[mask].erase(unique(ALL(ngpat[mask])),ngpat[mask].end());\n\t\tfor(int submask=mask; submask>=0; submask--) {\n\t\t\tsubmask&=mask;\n\t\t\tFORR(p,ngpat[mask]) ok[submask|p]=0;\n\t\t}\n\t}\n\t\n\tint ma=0;\n\tFOR(i,P) ma+=num[i];\n\tfor(mask=(1<<P)-2;mask>=0;mask--) if(ok[mask]) {\n\t\tok[mask]=0;\n\t\tFOR(i,P) if((mask&(1<<i))==0 && ok[mask|(1<<i)]) ok[mask]=1;\n\t\tif(ok[mask]) {\n\t\t\tint sum=0;\n\t\t\tFOR(i,P) if(mask&(1<<i)) sum+=num[i];\n\t\t\tma=min(ma,sum);\n\t\t}\n\t}\n\tcout<<ma<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Crisp String.json",
    "editorial_link": "https://codeforces.com//blog/entry/65365",
    "editorial": "Each state of the string can be denoted as the set of characters we\r\ndeleted from it, and each such set can be represented as a -bit binary\r\nmask, where -th bit is equal to if -th character of the alphabet is\r\nalready deleted, and otherwise.Letâs call a mask if the string formed by\r\nthis mask is not crisp. Letâs also say that a pair of characters forbids\r\nmask if is a pair of characters that should not be adjacent, but they\r\nare adjacent in the string formed by mask .If we somehow find all bad\r\nmasks, then the solution would be writing simple bitmask dp to find the\r\nbest mask that is not bad and reachable from the initial mask (the one\r\nhaving all bits set to ). So letâs focus on finding all bad masks.\r\nObviously, if some pair of characters forbids a mask, then itâs bad, and\r\nvice versa.Letâs pick some pair of characters and find all masks\r\nforbidden by it (we will do the same for every pair of characters that\r\ncannot be adjacent). Letâs check every occurence of in the initial\r\nstring. For each occurence, we will find the closest occurence of to the\r\nright of it. If thereâs no any, or if thereâs another between them,\r\nletâs ignore the occurence of we have chosen and move to the next one.\r\nOtherwise, letâs find all characters that occur at least once between\r\nthe fixed occurences of and . If all those characters are deleted, then\r\nthese occurences of and will be adjacent so pair forbids any mask that\r\nhas bits representing and set to , bits representing every character\r\noccuring in between to , and all other bits to any values. Letâs mark\r\nall these masks as forbidden as follows: we will write a recursive\r\nfunction that marks mask and every its submask that has bits and set to\r\nas forbidden. This function should check if is not forbidden; if not,\r\nthen mark it as forbidden, iterate on the bit we may remove from , and\r\ncall recursively (but only if is set to in mask , and if and ). If we\r\nimplement it in such a way, then for each pair , it will take operations\r\nto mark all masks forbidden by this pair of characters, so overall\r\ncomplexity will be or , depending on your implementation.\r\n",
    "hint": []
}