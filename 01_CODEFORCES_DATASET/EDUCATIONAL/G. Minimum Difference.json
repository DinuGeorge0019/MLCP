{
    "link": "https://codeforces.com//contest/1476/problem/G",
    "problemId": "881708",
    "problem_idx": "G",
    "shortId": "1476G",
    "contest_number": "1476",
    "problem_submissions": {
        "G": [
            105913861,
            105944560,
            105939646,
            105923864,
            105934727,
            105937410,
            105935084
        ],
        "E": [
            105882617,
            105882778,
            105909929,
            105895535,
            105907314,
            105884522,
            105881576,
            105889515,
            105891029,
            105897702,
            105902043,
            105904102,
            105909138,
            105899391,
            105895913,
            105970659,
            105900322,
            105895017,
            105909435,
            105904890
        ],
        "D": [
            105872560,
            105872434,
            105872750,
            105874690,
            105888665,
            105869131,
            105875044,
            105876453,
            105878527,
            105868738,
            105873785,
            105878660,
            105867024,
            105887668,
            105877564,
            105874050,
            105886943,
            105878950,
            105887180
        ],
        "C": [
            105865233,
            105867141,
            105882799,
            105868688,
            105880463,
            105863560,
            105866932,
            105868909,
            105872012,
            105880982,
            105868535,
            105869296,
            105877911,
            105869813,
            105870709,
            105864538,
            105872343,
            105869274,
            105872286
        ],
        "B": [
            105854579,
            105853524,
            105854032,
            105858231,
            105859227,
            105853292,
            105853315,
            105856769,
            105859608,
            105859912,
            105854635,
            105856976,
            105853309,
            105859505,
            105858926,
            105855562,
            105860530,
            105853840,
            105860836
        ],
        "A": [
            105850622,
            105850650,
            105852722,
            105850820,
            105851490,
            105850582,
            105850685,
            105850741,
            105851248,
            105853267,
            105850773,
            105851638,
            105850636,
            105851230,
            105852640,
            105850665,
            105852244,
            105850634,
            105851161
        ],
        "F": [
            131696052,
            106171367
        ]
    },
    "name": "G. Minimum Difference",
    "statement": "You are given an integer array a of size n.You have to perform m\r\nqueries. Each query has one of two types: \"1 l r k\" calculate the\r\nminimum value dif such that there are exist k integers x_1, x_2,\r\ndots, x_k such that cnt_i > 0 (for every i\r\nin [1, k]) and |cnt_i - cnt_j|\r\nle dif (for every i\r\nin [1, k], j\r\nin [1, k]), where cnt_i is the number of occurrences of x_i in the\r\nsubarray a[l..r]. If it is impossible to choose k integers, report it;\r\n\"2 p x\" assign a_{p} := x.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n//dengyaotriangle!\n\nconst int maxn=100005;\nconst int ks=pow(maxn,2.0/3);\n\nstruct qry{\n    int t,l,r,k,id;\n};\n\n\nbool cmp(const qry&a,const qry&b){\n    return (a.t/ks!=b.t/ks?a.t<b.t:(a.l/ks!=b.l/ks?a.l<b.l:a.r<b.r));\n}\nint n,m,t;\nint a[maxn],a0[maxn];\nint ox[maxn],oy[maxn],oz[maxn];\nqry q[maxn];\nint cnt[maxn],ccnt[maxn];\n\ninline void add(int x){\n    ++cnt[x];\n    ++ccnt[cnt[x]];\n}\ninline void del(int x){\n    --ccnt[cnt[x]];\n    --cnt[x];\n}\n\nint aans[maxn];\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)cin>>a[i],a0[i]=a[i];\n    for(int i=1;i<=m;i++){\n        int op;\n        cin>>op;\n        if(op==2){\n            cin>>ox[i]>>oy[i];\n            oz[i]=a[ox[i]];\n            a[ox[i]]=oy[i];\n        }else{\n            ++t;int l,r,k;cin>>l>>r>>k;\n            q[t]=qry({i,l,r,k,t});\n        }\n    }\n    for(int i=1;i<=n;i++)a[i]=a0[i];\n    sort(q+1,q+1+t,cmp);\n    int cl=1,cr=0,ct=1;\n    ccnt[0]=1e5;\n    for(int i=1;i<=t;i++){\n        int tl=q[i].l,tr=q[i].r,tt=q[i].t;\n        while(ct<tt){\n            if(ox[ct]){\n                if(cl<=ox[ct]&&ox[ct]<=cr)del(oz[ct]),add(oy[ct]);\n                a[ox[ct]]=oy[ct];\n            }\n            ++ct;\n        }\n        while(ct>tt){\n            --ct;\n            if(ox[ct]){\n                if(cl<=ox[ct]&&ox[ct]<=cr)del(oy[ct]),add(oz[ct]);\n                a[ox[ct]]=oz[ct];\n            }\n        }\n        while(cl>tl){--cl;add(a[cl]);}\n        while(cr<tr){++cr;add(a[cr]);}\n        while(cl<tl){del(a[cl]);cl++;}\n        while(cr>tr){del(a[cr]);cr--;}\n        int v=1;\n        int k=q[i].k;\n        int ans=INT_MAX;\n        vector<pair<int,int>> pt;\n        while(ccnt[v]){\n            int id=upper_bound(ccnt+v+1,ccnt+n+1,ccnt[v],greater<int>())-ccnt;\n            pt.push_back(make_pair(id-1,ccnt[v]-ccnt[id]));\n            v=id;\n        }/*\n        cout<<q[i].id<<','<<q[i].l<<' '<<q[i].r<<endl;\n        for(int i=0;i<=10;i++)cout<<ccnt[i]<<' ';cout<<endl;\n        for(auto x:pt)cout<<x.first<<' '<<x.second<<'\\n';*/\n        int lp=0,ls=0,sz=0;\n        for(int i=0;i<(int)pt.size();i++){\n            sz+=pt[i].second;\n            while(sz>k){\n                int g=pt[lp].second-ls;\n                if(sz-g>=k){\n                    sz-=g;\n                    lp++;ls=0;\n                }else{\n                    ls+=sz-k;\n                    sz=k;\n                }\n            }\n            if(sz==k){\n                ans=min(ans,pt[i].first-pt[lp].first);\n            }\n        }\n        aans[q[i].id]=ans==INT_MAX?-1:ans;\n    }\n    for(int i=1;i<=t;i++)cout<<aans[i]<<'\\n';\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "hashing",
        "sortings",
        "two pointers"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Minimum Difference.json",
    "editorial_link": "https://codeforces.com//blog/entry/87356",
    "editorial": "Letâs consider a problem without queries of the second type.Now we can\r\ntry to solve the problem using Moâs algorithm. Letâs maintain array the\r\nnumber of occurrences of on the current segment and array array sorted\r\nin descending order.Letâs take a look at how we should handle adding an\r\nelement equal to . Surely, we should increase by , but now we should\r\nerase an element equal to from the array and insert an element is such a\r\nway that the array is still sorted. Instead, we can increase the\r\nleftmost element equal to by . Similarly, we can handle deleting an\r\nelement (decrease the rightmost element equal to by ). In order to\r\nquickly find the leftmost (rightmost) element equal to , we can store\r\nthe left and the right bounds of the array where all the numbers are\r\nequal to .To answer the query of type , we should find two elements in\r\nthe array at distance whose absolute difference is minimal. Since the\r\nsize of the array (without zero elements) is , we canât look at the\r\nwhole array. But using the fact that there are no more than different\r\nvalues in the array, we can create an auxiliary array of pairs (the\r\nvalue from the array and the number of occurrences of that value). In\r\nsuch an array, we need to find a subarray where the sum of the second\r\nelements in the pairs is at least , and the absolute difference between\r\nthe first elements in the pairs is minimal. That can be solved using\r\nstandard two pointers method in .The total complexity of the solution is\r\n.In fact, we can use Moâs algorithm even with updates. But its\r\ncomplexity is . You can read the editorial of the problem 940F on\r\nCodeforces or the following blog to learn about processing updates in\r\nMo: https://codeforces.com/blog/entry/72690\r\n",
    "hint": []
}