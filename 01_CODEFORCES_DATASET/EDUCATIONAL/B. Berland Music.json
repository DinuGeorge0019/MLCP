{
    "link": "https://codeforces.com//contest/1622/problem/B",
    "problemId": "1242578",
    "problem_idx": "B",
    "shortId": "1622B",
    "contest_number": "1622",
    "problem_submissions": {
        "F": [
            140796824,
            140798013,
            140806008,
            140808778,
            140806009,
            140805051,
            140814076,
            140828348,
            140819179,
            140855589,
            140855586,
            140839728,
            140839370,
            140821060,
            140807144,
            140812999,
            140804188,
            140824231,
            140824165,
            140822940,
            140804052,
            140823222,
            140819745,
            140824560,
            140857950,
            140834838,
            140832376,
            140829343,
            140828751,
            140828269,
            140827798
        ],
        "E": [
            140765216,
            140779319,
            140785115,
            140782340,
            140780692,
            140780184,
            140838345,
            140780973,
            140780107,
            140783378,
            140789562,
            140786801,
            140785714,
            140786518,
            140775048,
            140770202,
            140781928,
            140783559,
            140781100,
            140785123,
            140785377,
            140784613
        ],
        "D": [
            140761526,
            140770308,
            140773276,
            140775500,
            140776032,
            140771575,
            140837879,
            140773697,
            140780198,
            140777190,
            140779965,
            140773920,
            140787545,
            140769780,
            140775729,
            140849022,
            140772131,
            140772048,
            140774887,
            140775893,
            140779501,
            140776197
        ],
        "C": [
            140756712,
            140763210,
            140766719,
            140766708,
            140766349,
            140764400,
            140762686,
            140760355,
            140768706,
            140766328,
            140766600,
            140768126,
            140759456,
            140764367,
            140761869,
            140765074,
            140766561,
            140767346,
            140764755,
            140763284,
            140767658
        ],
        "B": [
            140752335,
            140756349,
            140756665,
            140761975,
            140757886,
            140760857,
            140757453,
            140753171,
            140760768,
            140761439,
            140759017,
            140757918,
            140754004,
            140754798,
            140756955,
            140757416,
            140757531,
            140759831,
            140758370,
            140759772
        ],
        "A": [
            140751413,
            140751825,
            140751782,
            140754411,
            140752339,
            140751676,
            140751944,
            140751415,
            140752483,
            140751783,
            140754865,
            140752090,
            140751540,
            140751564,
            140751671,
            140751951,
            140752002,
            140751977,
            140751451,
            140754316
        ]
    },
    "name": "B. Berland Music",
    "statement": "Berland Music is a music streaming service built specifically to support\r\nBerland local artist. Its developers are currently working on a song\r\nrecommendation module.So imagine Monocarp got recommended n songs,\r\nnumbered from 1 to n. The i-th song had its predicted rating equal to\r\np_i, where 1\r\nle p_i\r\nle n and every integer from 1 to n appears exactly once. In other words,\r\np is a permutation.After listening to each of them, Monocarp pressed\r\neither a like or a dislike button. Let his vote sequence be represented\r\nwith a string s, such that s_i=0 means that he disliked the i-th song,\r\nand s_i=1 means that he liked it.Now the service has to re-evaluate the\r\nsong ratings in such a way that: the new ratings q_1, q_2,\r\ndots, q_n still form a permutation (1\r\nle q_i\r\nle n; each integer from 1 to n appears exactly once); every song that\r\nMonocarp liked should have a greater rating than every song that\r\nMonocarp disliked (formally, for all i, j such that s_i=1 and s_j=0,\r\nq_i>q_j should hold). Among all valid permutations q find the one that\r\nhas the smallest value of\r\nsum\r\nlimits_{i=1}^n |p_i-q_i|, where |x| is an absolute value of x.Print the\r\npermutation q_1, q_2,\r\ndots, q_n. If there are multiple answers, you can print any of them.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 27.12.2021 17:36:35       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n      cin >> p[i];\n    }\n    string s;\n    cin >> s;\n    vector<int> res(n, -1);\n    int ptr = 0;\n    for (int r = 0; r <= 1; r++) {\n      vector<pair<int, int>> a;\n      for (int i = 0; i < n; i++) {\n        if ((int) (s[i] - '0') == r) {\n          a.emplace_back(p[i], i);\n        }\n      }\n      sort(a.begin(), a.end());\n      for (auto& p : a) {\n        res[p.second] = ++ptr;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      if (i > 0) {\n        cout << \" \";\n      }\n      cout << res[i];\n    }\n    cout << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Berland Music.json",
    "editorial_link": "https://codeforces.com//blog/entry/98453",
    "editorial": "Since we know that every disliked song should have lower rating than\r\nevery liked song, we actually know which new ratings should belong to\r\ndisliked songs and which should belong to the liked ones.The disliked\r\nsongs take ratings from to the number of zeros in . The liked songs take\r\nratings from the number of zeros in plus to . Thus, we have two\r\nindependent tasks to solve.Let the disliked songs have ratings . Their\r\nnew ratings should be . We can show that if we sort the array , then\r\nwill be the lowest possible. The general way to prove it is to show that\r\nif the order has any inversions, we can always fix the leftmost of them\r\n(swap two adjacent values), and the cost doesn\u00e2\u0080\u0099t increase.So the\r\nsolution can be to sort triples and restore from the order of in\r\nthese.Overall complexity: per testcase.\r\n"
}