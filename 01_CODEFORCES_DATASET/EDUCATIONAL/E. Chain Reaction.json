{
    "link": "https://codeforces.com//contest/1954/problem/E",
    "problemId": "2586695",
    "problem_idx": "E",
    "shortId": "1954E",
    "contest_number": "1954",
    "problem_submissions": {
        "F": [
            256316895,
            256329295,
            256334035,
            256332306,
            256344392,
            256332853,
            256328005,
            256347592,
            256335011,
            256352109,
            256350995,
            258635003,
            256340118,
            256372395,
            256325447,
            256325322,
            256346283,
            256316023,
            256323588,
            256320924
        ],
        "E": [
            256282413,
            256358889,
            256358516,
            256282751,
            256340120,
            256301294,
            256294589,
            256283411,
            256294052,
            256306491,
            256303451,
            256299550,
            256302258,
            256354417,
            256293685,
            256303935,
            256308643,
            256372754,
            256335764,
            256333289,
            256297901,
            256327707,
            256340547,
            256345064,
            256288665
        ],
        "D": [
            256268895,
            256269992,
            256269812,
            256286958,
            256273436,
            256278229,
            256282928,
            256272144,
            256284841,
            256280990,
            256279861,
            256284063,
            256273990,
            256301346,
            256280827,
            256332605,
            256335916,
            256339422,
            256279104
        ],
        "C": [
            256263031,
            256263009,
            256264769,
            256265286,
            256267161,
            256271687,
            256272827,
            256264797,
            256276178,
            256267220,
            256271392,
            256275794,
            256262221,
            256288253,
            256273238,
            256334487,
            256333463,
            256330248,
            256269277
        ],
        "B": [
            256260210,
            256260093,
            256260556,
            256262624,
            256263445,
            256260047,
            256260173,
            256261053,
            256267415,
            256261634,
            256268733,
            256270204,
            256275934,
            256283332,
            256344932,
            256336999,
            256331860,
            256328039,
            256266244
        ],
        "A": [
            256256940,
            256256909,
            256256942,
            256256970,
            256256990,
            256256907,
            256256875,
            256257032,
            256259999,
            256257112,
            256257788,
            256257203,
            256259580,
            256256932,
            256338388,
            256326736,
            256328175,
            256257406
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128421",
    "editorial": "Let\u00e2\u0080\u0099s solve the problem for a single . We\u00e2\u0080\u0099ll start with for\r\nsimplicity.The first lightning can be launched at any monster, as it\r\nwill always spread to all of them. We will continue launching lightnings\r\nuntil a monster dies. When one or more monsters die, the problem breaks\r\ndown into several independent subproblems, because no lightning will\r\npass through dead monsters. This means that there is no concept of\r\n\"minimum number of seconds\" the answer does not depend on the choice of\r\nmonsters to launch the lightnings.Great, so how do we calculate this\r\nanswer? The idea is as follows. We will attack the first monster until\r\nit dies. This will take seconds. We then move on to the second monster.\r\nIf it has more health than the first one, we need to launch an\r\nadditional lightnings to kill it. Otherwise, it will already be dead.\r\nHow much damage will the third monster receive in both cases? Let\u00e2\u0080\u0099s say\r\nit has a lot of health. In the first case, it will receive damage,\r\nbecause all the lightnings will reach it. But in the second case, it\r\nwill also receive damage, because the lightnings launched at the first\r\nmonster after the death of the second one will not reach the third one.\r\nThis means that we now need to compare the health of the second monster\r\nwith the third one in the same way. And so on. This means that the -th\r\nmonster needs to be hit with lightnings.Then the answer for is equal to\r\n.How to calculate the answer for any ? In fact, the difference is not\r\nvery significant. It is sufficient to change the health of each monster\r\nfrom to , and the entire process described earlier will remain the same.\r\nTherefore, the answer for any is equal to .To further optimize this\r\nsolution, another transformation is needed. Ideally, we would like each\r\nto contribute to the answer independently of other values. And this can\r\nalmost be achieved. Notice that the maximum returns only if for any ,\r\nnot just for . This may require proof, but it is quite obvious.This\r\nmeans that the coefficient for in the answer depends on two conditions:\r\nit is increased by if or ; it is decreased by if and . Let\u00e2\u0080\u0099s call this\r\ncoefficient for the -th monster . Therefore, we need to calculate .There\r\nare two ways to optimize the solution further.The first option is to\r\nnotice that doesn\u00e2\u0080\u0099t take a lot of different values for different . More\r\nprecisely, it is . This can be shown as follows. Consider . Either , or\r\n. Therefore, takes no more than different values.Then the solution can\r\nbe implemented as follows. For each , we will identify all possible\r\nvalues that the rounding result takes. For each of them, we will find\r\nthe range of for which the result is equal to that. And we will add the\r\ncontribution of the -th monster within this range of values to the\r\nresult. This can be done using a difference array to achieve a\r\ncomplexity of .The second option is a bit smarter. Let\u00e2\u0080\u0099s take another\r\nlook at the formula for calculating the answer for a fixed : . Let\u00e2\u0080\u0099s\r\ngroup the terms by equal values of . What do they look like? Numbers\r\nfrom to give the value . Numbers from to give the value , and so on.\r\nThis means that for a certain , there are segments, on each of which we\r\nneed to calculate the sum of for those for which fall into this segment.\r\nThe total number of segments for all is . The complexity of the solution\r\nwill then be .\r\n",
    "name": "E. Chain Reaction",
    "statement": "There are n monsters standing in a row. The i-th monster has a_i health\r\npoints.Every second, you can choose one monster and launch a chain\r\nlightning at it. The lightning deals k damage to it, and also spreads to\r\nthe left (towards decreasing i) and to the right (towards increasing i)\r\nto monsters, dealing k damage to each. When the lightning reaches a dead\r\nmonster or the beginning/end of the row, it stops. A monster is\r\nconsidered alive if its health points are strictly greater than 0.For\r\nexample, consider the following scenario: there are three monsters with\r\nhealth equal to [5, 2, 7], and k = 3. You can kill them all in 4\r\nseconds: launch a chain lightning at the 3-rd monster, then their health\r\nvalues are [2, -1, 4]; launch a chain lightning at the 1-st monster,\r\nthen their health values are [-1, -1, 4]; launch a chain lightning at\r\nthe 3-rd monster, then their health values are [-1, -1, 1]; launch a\r\nchain lightning at the 3-th monster, then their health values are [-1,\r\n-1, -2]. For each k from 1 to\r\nmax(a_1, a_2,\r\ndots, a_n), calculate the minimum number of seconds it takes to kill all\r\nthe monsters.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;\u00a0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\u00a0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\u00a0using pii=pair<int,int>;using pll=pair<ll,ll>;\u00a0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\u00a0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\u00a0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\u00a0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\u00a0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\u00a0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\u00a0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\u00a0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\u00a0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << ' ' << p.second;}\u00a0#ifdef i_am_noob#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}#else#define bug(...) 777771449#endif\u00a0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(T && x) {cout << x << \"\\n\";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\u00a0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\u00a0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\u00a0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\u00a0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\u00a0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\u00a0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\u00a0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\u00a0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\u00a0\u00a0\u00a0#include <utility>\u00a0namespace atcoder {\u00a0namespace internal {\u00a0// @param m `1 <= m`// @return x mod mconstexpr long long safe_mod(long long x, long long m) {    x %= m;    if (x < 0) x += m;    return x;}\u00a0// Fast modular multiplication by barrett reduction// Reference: https://en.wikipedia.org/wiki/Barrett_reduction// NOTE: reconsider after Ice Lakestruct barrett {    unsigned int _m;    unsigned long long im;\u00a0    // @param m `1 <= m < 2^31`    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\u00a0    // @return m    unsigned int umod() const { return _m; }\u00a0    // @param a `0 <= a < m`    // @param b `0 <= b < m`    // @return `a * b % m`    unsigned int mul(unsigned int a, unsigned int b) const {        // [1] m = 1        // a = b = im = 0, so okay\u00a0        // [2] m >= 2        // im = ceil(2^64 / m)        // -> im * m = 2^64 + r (0 <= r < m)        // let z = a*b = c*m + d (0 <= c, d < m)        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2        // ((ab * im) >> 64) == c or c + 1        unsigned long long z = a;        z *= b;#ifdef _MSC_VER        unsigned long long x;        _umul128(z, im, &x);#else        unsigned long long x =            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);#endif        unsigned int v = (unsigned int)(z - x * _m);        if (_m <= v) v += _m;        return v;    }};\u00a0// @param n `0 <= n`// @param m `1 <= m`// @return `(x ** n) % m`constexpr long long pow_mod_constexpr(long long x, long long n, int m) {    if (m == 1) return 0;    unsigned int _m = (unsigned int)(m);    unsigned long long r = 1;    unsigned long long y = safe_mod(x, m);    while (n) {        if (n & 1) r = (r * y) % _m;        y = (y * y) % _m;        n >>= 1;    }    return r;}\u00a0// Reference:// M. Forisek and J. Jancina,// Fast Primality Testing for Integers That Fit into a Machine Word// @param n `0 <= n`constexpr bool is_prime_constexpr(int n) {    if (n <= 1) return false;    if (n == 2 || n == 7 || n == 61) return true;    if (n % 2 == 0) return false;    long long d = n - 1;    while (d % 2 == 0) d /= 2;    constexpr long long bases[3] = {2, 7, 61};    for (long long a : bases) {        long long t = d;        long long y = pow_mod_constexpr(a, t, n);        while (t != n - 1 && y != 1 && y != n - 1) {            y = y * y % n;            t <<= 1;        }        if (y != n - 1 && t % 2 == 0) {            return false;        }    }    return true;}template <int n> constexpr bool is_prime = is_prime_constexpr(n);\u00a0// @param b `1 <= b`// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/gconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {    a = safe_mod(a, b);    if (a == 0) return {b, 0};\u00a0    // Contracts:    // [1] s - m0 * a = 0 (mod b)    // [2] t - m1 * a = 0 (mod b)    // [3] s * |m1| + t * |m0| <= b    long long s = b, t = a;    long long m0 = 0, m1 = 1;\u00a0    while (t) {        long long u = s / t;        s -= t * u;        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\u00a0        // [3]:        // (s - t * u) * |m1| + t * |m0 - m1 * u|        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)        // = s * |m1| + t * |m0| <= b\u00a0        auto tmp = s;        s = t;        t = tmp;        tmp = m0;        m0 = m1;        m1 = tmp;    }    // by [3]: |m0| <= b/g    // by g != b: |m0| < b/g    if (m0 < 0) m0 += b / s;    return {s, m0};}\u00a0// Compile time primitive root// @param m must be prime// @return primitive root (and minimum in now)constexpr int primitive_root_constexpr(int m) {    if (m == 2) return 1;    if (m == 167772161) return 3;    if (m == 469762049) return 3;    if (m == 754974721) return 11;    if (m == 998244353) return 3;    int divs[20] = {};    divs[0] = 2;    int cnt = 1;    int x = (m - 1) / 2;    while (x % 2 == 0) x /= 2;    for (int i = 3; (long long)(i)*i <= x; i += 2) {        if (x % i == 0) {            divs[cnt++] = i;            while (x % i == 0) {                x /= i;            }        }    }    if (x > 1) {        divs[cnt++] = x;    }    for (int g = 2;; g++) {        bool ok = true;        for (int i = 0; i < cnt; i++) {            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {                ok = false;                break;            }        }        if (ok) return g;    }}template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\u00a0}  // namespace internal\u00a0}  // namespace atcoder\u00a0\u00a0#include <cassert>#include <numeric>#include <type_traits>\u00a0namespace atcoder {\u00a0namespace internal {\u00a0#ifndef _MSC_VERtemplate <class T>using is_signed_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value ||                                  std::is_same<T, __int128>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using is_unsigned_int128 =    typename std::conditional<std::is_same<T, __uint128_t>::value ||                                  std::is_same<T, unsigned __int128>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using make_unsigned_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value,                              __uint128_t,                              unsigned __int128>;\u00a0template <class T>using is_integral = typename std::conditional<std::is_integral<T>::value ||                                                  is_signed_int128<T>::value ||                                                  is_unsigned_int128<T>::value,                                              std::true_type,                                              std::false_type>::type;\u00a0template <class T>using is_signed_int = typename std::conditional<(is_integral<T>::value &&                                                 std::is_signed<T>::value) ||                                                    is_signed_int128<T>::value,                                                std::true_type,                                                std::false_type>::type;\u00a0template <class T>using is_unsigned_int =    typename std::conditional<(is_integral<T>::value &&                               std::is_unsigned<T>::value) ||                                  is_unsigned_int128<T>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using to_unsigned = typename std::conditional<    is_signed_int128<T>::value,    make_unsigned_int128<T>,    typename std::conditional<std::is_signed<T>::value,                              std::make_unsigned<T>,                              std::common_type<T>>::type>::type;\u00a0#else\u00a0template <class T> using is_integral = typename std::is_integral<T>;\u00a0template <class T>using is_signed_int =    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using is_unsigned_int =    typename std::conditional<is_integral<T>::value &&                                  std::is_unsigned<T>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using to_unsigned = typename std::conditional<is_signed_int<T>::value,                                              std::make_unsigned<T>,                                              std::common_type<T>>::type;\u00a0#endif\u00a0template <class T>using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\u00a0template <class T>using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\u00a0template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\u00a0}  // namespace internal\u00a0}  // namespace atcoder\u00a0#include <cassert>#include <numeric>#include <type_traits>\u00a0#ifdef _MSC_VER#include <intrin.h>#endif\u00a0namespace atcoder {\u00a0namespace internal {\u00a0struct modint_base {};struct static_modint_base : modint_base {};\u00a0template <class T> using is_modint = std::is_base_of<modint_base, T>;template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\u00a0}  // namespace internal\u00a0template <int m, std::enable_if_t<(1 <= m)>* = nullptr>struct static_modint : internal::static_modint_base {    using mint = static_modint;\u00a0  public:    static constexpr int mod() { return m; }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\u00a0    static_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    static_modint(T v) {        long long x = (long long)(v % (long long)(umod()));        if (x < 0) x += umod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    static_modint(T v) {        _v = (unsigned int)(v % umod());    }    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\u00a0    unsigned int val() const { return _v; }\u00a0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\u00a0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v -= rhs._v;        if (_v >= umod()) _v += umod();        return *this;    }    mint& operator*=(const mint& rhs) {        unsigned long long z = _v;        z *= rhs._v;        _v = (unsigned int)(z % umod());        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\u00a0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\u00a0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        if (prime) {            assert(_v);            return pow(umod() - 2);        } else {            auto eg = internal::inv_gcd(_v, m);            assert(eg.first == 1);            return eg.second;        }    }\u00a0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\u00a0  private:    unsigned int _v;    static constexpr unsigned int umod() { return m; }    static constexpr bool prime = internal::is_prime<m>;};\u00a0template <int id> struct dynamic_modint : internal::modint_base {    using mint = dynamic_modint;\u00a0  public:    static int mod() { return (int)(bt.umod()); }    static void set_mod(int m) {        assert(1 <= m);        bt = internal::barrett(m);    }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\u00a0    dynamic_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    dynamic_modint(T v) {        long long x = (long long)(v % (long long)(mod()));        if (x < 0) x += mod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    dynamic_modint(T v) {        _v = (unsigned int)(v % mod());    }    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\u00a0    unsigned int val() const { return _v; }\u00a0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\u00a0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v += mod() - rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator*=(const mint& rhs) {        _v = bt.mul(_v, rhs._v);        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\u00a0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\u00a0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        auto eg = internal::inv_gcd(_v, mod());        assert(eg.first == 1);        return eg.second;    }\u00a0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\u00a0  private:    unsigned int _v;    static internal::barrett bt;    static unsigned int umod() { return bt.umod(); }};template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\u00a0using modint998244353 = static_modint<998244353>;using modint1000000007 = static_modint<1000000007>;using modint = dynamic_modint<-1>;\u00a0namespace internal {\u00a0template <class T>using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\u00a0template <class T>using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\u00a0template <class> struct is_dynamic_modint : public std::false_type {};template <int id>struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\u00a0template <class T>using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\u00a0}  // namespace internal\u00a0}  // namespace atcoder\u00a0using namespace atcoder;\u00a0using mint=modint998244353;//using mint=modint1000000007;\u00a0void ahcorz(){    int n; cin >> n;    vi a(n); cin >> a;    int m=*max_element(all(a));    vll res(m+1);    auto solve=[&](int x, int y){        res[1]+=y-x;        int curx=x,cury=y;        while(1){            int nxt=m+1;            if(curx>1){                chmin(nxt,iceil(x,curx-1));            }            if(cury>1){                chmin(nxt,iceil(y,cury-1));            }            if(nxt==m+1) break;            int prev=cury-curx;            curx=iceil(x,nxt),cury=iceil(y,nxt);            res[nxt]+=cury-curx-prev;        }    };    solve(0,a[0]);    rep(n-1) if(a[i]<a[i+1]) solve(a[i],a[i+1]);    rep(i,2,m+1) res[i]+=res[i-1];    rep(i,1,m+1) cout << res[i] << ' ';    cout << '\\n';}\u00a0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dsu",
        "greedy",
        "implementation",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Chain Reaction.json"
}