{"link": "https://codeforces.com//contest/920/problem/F", "problemId": "152866", "problem_idx": "F", "shortId": "920F", "contest_number": "920", "problem_submissions": {"G": [34852743, 34853590, 34854300, 34853934, 34856261, 34853609, 34857997, 34854137, 34863997, 34863325, 34845932, 35124212, 35123972, 34865228, 34854370, 34856832, 34844552, 34869557, 34855295, 34853458, 34855692, 34852849, 34855311, 34861027, 34859762], "F": [34850786, 34848482, 34849125, 34847410, 34850587, 34855922, 34851634, 34865588, 34861253, 34849345, 35122442, 34861362, 34851005, 34852570, 34847838, 34850627, 34847445, 34849654, 34849272, 34857704, 34855104, 34855630], "E": [34849129, 34851685, 34845896, 34844151, 34856145, 34852326, 34847420, 34858206, 34852441, 35117849, 34858048, 34856421, 64420065, 59900329, 59900252, 34850422, 34851876, 34846457, 34850665, 34846959, 34846751, 34850722, 34850540, 34853490], "D": [34846246, 34857983, 34865210, 34864920, 34863172, 34865887, 34863373, 34855083, 34863045, 34852180, 34864800, 34865039, 34861962, 34930637, 34904017, 34882639, 34870887, 34935056, 34932865], "C": [34843334, 34845308, 34844415, 34853136, 34845188, 34848715, 34849757, 34845177, 34857782, 35115887, 35115738, 35114927, 34846351, 34860924, 34843957, 34863534, 34843082, 34844466, 34843157, 34844360, 34846666, 34847453, 34846518], "B": [34842856, 34846490, 34843649, 34849908, 34843576, 34845185, 34844678, 34844108, 34855655, 35114208, 34844457, 34859635, 34842933, 34867088, 34844653, 34842667, 34842611, 34843316, 34845332, 34845365, 34845176], "A": [34842470, 34844425, 34842543, 34843209, 34842761, 34843665, 34842482, 34842652, 34854235, 35113527, 34842534, 34843074, 34842510, 34864789, 34842605, 34842461, 34842474, 34849846, 34842901, 34843015, 34842733]}, "name": "F. SUM and REPLACE", "statement": "Let be the number of positive divisors of a positive integer . For\r\nexample, ( is divisible by and ), ( is divisible by , , and ).You are\r\ngiven an array of integers. You have to process two types of queries:\r\nfor every replace with ; calculate . Print the answer for each query.\r\n", "solutions": ["#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nll indt[1100000];\nvoid update(int p, ll v) {\n\tp += IT_MAX - 1;\n\tindt[p] = v;\n\tfor (p /= 2; p; p /= 2) indt[p] = indt[2 * p] + indt[2 * p + 1];\n}\nll getsum(int p1, int p2) {\n\tp1 += IT_MAX - 1;\n\tp2 += IT_MAX - 1;\n\tll rv = 0;\n\tfor (; p1 <= p2; p1 /= 2, p2 /= 2) {\n\t\tif (p1 % 2 == 1) rv = rv + indt[p1++];\n\t\tif (p2 % 2 == 0) rv = rv + indt[p2--];\n\t}\n\treturn rv;\n}\n\nset <int> Sx;\nint in[300050];\nint D[1000050];\n\nvector <int> Vl;\nint main() {\n\tint N, M, i, j;\n\tscanf(\"%d %d\", &N, &M);\n\tfor (i = 1; i <= N; i++) scanf(\"%d\", &in[i]);\n\tfor (i = 1; i <= N; i++) update(i, in[i]);\n\tfor (i = 1; i <= N; i++) if (in[i] >= 3) Sx.insert(i);\n\n\tfor (i = 1; i <= 1000000; i++) for (j = i; j <= 1000000; j += i) D[j]++;\n\twhile (M--) {\n\t\tint t1, t2, t3;\n\t\tscanf(\"%d %d %d\", &t1, &t2, &t3);\n\t\tif (t1 == 1) {\n\t\t\twhile (1) {\n\t\t\t\tauto it = Sx.lower_bound(t2);\n\t\t\t\tif (it == Sx.end() || *it > t3) break;\n\t\t\t\tVl.push_back(*it);\n\t\t\t\tSx.erase(it);\n\t\t\t}\n\t\t\tfor (auto it : Vl) {\n\t\t\t\tin[it] = D[in[it]];\n\t\t\t\tupdate(it, in[it]);\n\t\t\t\tif (in[it] >= 3) Sx.insert(it);\n\t\t\t}\n\t\t\tVl.clear();\n\t\t}\n\t\telse printf(\"%lld\\n\", getsum(t2, t3));\n\t}\n\treturn 0;\n}\n//*/"], "input": "", "output": "", "tags": ["brute force", "data structures", "dsu", "number theory"], "dificulty": "2000", "interactive": false}