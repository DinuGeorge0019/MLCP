{
    "link": "https://codeforces.com//contest/1849/problem/C",
    "problemId": "2121800",
    "problem_idx": "C",
    "shortId": "1849C",
    "contest_number": "1849",
    "problem_submissions": {
        "F": [
            215983324,
            215952856,
            215937825,
            216386632,
            215955686,
            215953676,
            215963177,
            215957010,
            215951070,
            215964780,
            216982954,
            215957194,
            215972632,
            215944919,
            215944313,
            215955103,
            215959952,
            215969003,
            215980309,
            215974158,
            215944399,
            215979671,
            215977278
        ],
        "E": [
            215924453,
            215947662,
            216386610,
            215933511,
            215933733,
            215934077,
            215914493,
            215965756,
            215977352,
            215941711,
            233941264,
            215936437,
            215935391,
            215977463,
            215969180,
            215945577,
            215912738,
            215939893,
            215950899,
            215934318,
            215964596,
            215959218,
            215957991,
            215955934
        ],
        "D": [
            215901738,
            215911695,
            216386594,
            215909113,
            215918034,
            215916358,
            215933169,
            215909241,
            215922975,
            234220985,
            215915496,
            215918649,
            215921028,
            215919624,
            215925910,
            215965913,
            215944986,
            215923778,
            215918733,
            215917075,
            215927258,
            215909167,
            215930917
        ],
        "C": [
            215896251,
            215894479,
            216386570,
            215900243,
            215896179,
            215907225,
            215897874,
            215899171,
            215913186,
            216103314,
            215910665,
            215904112,
            215906218,
            215893558,
            215913416,
            215898003,
            215913451,
            215905641,
            215906717,
            215916261,
            215893733,
            215907522
        ],
        "B": [
            215891011,
            215887978,
            215890857,
            215886817,
            215889862,
            215890551,
            215889747,
            215890405,
            216103286,
            215904981,
            215895899,
            215891636,
            215886438,
            215894588,
            215888040,
            215888730,
            215892001,
            215891534,
            215895784,
            215887055,
            215895512
        ],
        "A": [
            215887103,
            215884849,
            215885125,
            215884783,
            215885307,
            215885029,
            215884781,
            215885053,
            216103329,
            215902406,
            215889192,
            215885764,
            215884723,
            215885605,
            215884732,
            215884795,
            215885200,
            215885812,
            215885953,
            215884704,
            215884853
        ]
    },
    "name": "C. Binary String Copying",
    "statement": "You are given a string s consisting of n characters and/or .You make m\r\ncopies of this string, let the i-th copy be the string t_i. Then you\r\nperform exactly one operation on each of the copies: for the i-th copy,\r\nyou sort its substring [l_i; r_i] (the substring from the l_i-th\r\ncharacter to the r_i-th character, both endpoints inclusive). .Your task\r\nis to calculate the number of different strings among t_1, t_2,\r\nldots, t_m. Note that the initial string s should be counted only if at\r\nleast one of the copies stays the same after the operation.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::set<std::pair<int, int>> S;\n    \n    std::vector<int> nxt(n + 1, n), lst(n + 1, -1);\n    for (int i = n - 1; i >= 0; i--) {\n        nxt[i] = s[i] == '1' ? i : nxt[i + 1];\n    }\n    for (int i = 0; i < n; i++) {\n        lst[i + 1] = s[i] == '0' ? i : lst[i];\n    }\n    \n    while (m--) {\n        int l, r;\n        std::cin >> l >> r;\n        l--;\n        l = nxt[l];\n        r = lst[r];\n        if (l > r) {\n            l = r = -1;\n        }\n        S.emplace(l, r);\n    }\n    std::cout << S.size() << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "hashing",
        "strings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Binary String Copying.json",
    "editorial_link": "https://codeforces.com//blog/entry/118752",
    "editorial": "We can see that each modified copy is determined by only two integers\r\nand the first position at which the character has changed and the last\r\nsuch position. If we can find such numbers for each of the copies, the\r\nnumber of different pairs will be the answer to the problem.Let be the\r\nposition of the nearest character at the position or to the left of it,\r\nand be the position of the nearest character at the position or to the\r\nright of it. If the first character of the string is then , otherwise .\r\nAnd if the last character of the string is , then , otherwise . The\r\nvalues and can be calculated using simple dynamic programming, is\r\ncalculated from left to right, and from right to left. Then the numbers\r\nand we need are equal to and , respectively. If , then the changed\r\nsegment is degenerate (and this means that the string does not change at\r\nall). We can define some special segment for this type of strings, for\r\nexample, . Otherwise, the segment of the string will change.Time\r\ncomplexity: .\r\n"
}