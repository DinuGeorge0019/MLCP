{"link": "https://codeforces.com//contest/1354/problem/E", "problemId": "623448", "problem_idx": "E", "shortId": "1354E", "contest_number": "1354", "problem_submissions": {"G": [80502712, 80500640, 80479424, 80521575, 80514570, 80507519, 80516727, 80506952, 80522749, 80517834], "F": [80492752, 80491818, 80486741, 80486733, 80498606, 80506559, 80492000, 80506147, 80493453, 80507365, 80500930, 80492368, 80502196, 80506705, 80501348, 80502603, 80507003, 80504378, 80500666, 80509209], "E": [80478361, 80481693, 80494073, 80473313, 80489080, 80489590, 80500698, 80489890, 80484400, 80477593, 80478451, 80492063, 80495115, 80483322, 80494477, 80486894, 80494427, 80491606, 80488314], "D": [80469519, 80470691, 80498555, 80467168, 80480497, 80478286, 80477445, 80477111, 80466399, 80471019, 80473056, 80471601, 80482362, 80488495, 80473238, 80482948, 80466995, 80486731, 80484796, 80475358], "C2": [80463522, 80484245, 80502970, 80478908, 80472069, 80468985, 80468689, 80472664, 80476619, 80476720, 80489656, 80477361, 80476069, 80503667, 80473397, 80472911, 80489616, 80481827, 80482549, 80500296], "C1": [80463378, 80464968, 80501505, 80478534, 80468463, 80462050, 80463990, 80463377, 80459508, 80460645, 80463967, 80465199, 80472341, 80461193, 80463170, 80458830, 80475032, 80470173, 80520837, 80468845, 80464138], "B": [80454412, 80455734, 80504343, 80456075, 80456469, 80457930, 80459404, 80456913, 80454847, 80456739, 80454406, 80455296, 80457195, 80455557, 80457336, 80455902, 80456106, 80460925, 80455491, 80455115], "A": [80454037, 80454106, 80505746, 80454365, 80454427, 80454271, 80454716, 80454697, 80454135, 80454424, 80455156, 80454027, 80454887, 80454126, 80454558, 80454452, 80454285, 80456834, 80476438, 80454206]}, "name": "E. Graph Coloring", "statement": "You are given an undirected graph without self-loops or multiple edges\r\nwhich consists of n vertices and m edges. Also you are given three\r\nintegers n_1, n_2 and n_3.Can you label each vertex with one of three\r\nnumbers , or in such way, that: Each vertex should be labeled by exactly\r\none number , or ; The total number of vertices with label should be\r\nequal to n_1; The total number of vertices with label should be equal to\r\nn_2; The total number of vertices with label should be equal to n_3;\r\n|col_u - col_v| = 1 for each edge (u, v), where col_x is the label of\r\nvertex x. If there are multiple valid labelings, print any of them.\r\n", "solutions": ["#include <queue>\n#include <bitset>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N, M; vector<int> A(3);\n\tcin >> N >> M >> A[0] >> A[1] >> A[2];\n\tvector<vector<int> > G(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y; --x, --y;\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tvector<vector<int> > gs;\n\tbool ok = true;\n\tvector<int> col(N, -1);\n\tvector<int> comp(N, -1);\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (col[i] != -1) continue;\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\tcol[i] = 0;\n\t\tvector<int> subgs;\n\t\twhile (!que.empty()) {\n\t\t\tint u = que.front();\n\t\t\tque.pop();\n\t\t\tsubgs.push_back(u);\n\t\t\tcomp[u] = gs.size();\n\t\t\tfor (int j : G[u]) {\n\t\t\t\tif (col[j] == -1) {\n\t\t\t\t\tcol[j] = col[u] ^ 1;\n\t\t\t\t\tque.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tgs.push_back(subgs);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j : G[i]) {\n\t\t\tif (col[i] == col[j]) {\n\t\t\t\tok = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (!ok) {\n\t\tcout << \"NO\" << endl;\n\t}\n\telse {\n\t\tint K = gs.size();\n\t\tvector<int> a(K), b(K);\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tfor (int j : gs[i]) {\n\t\t\t\tif (col[j] == 0) ++a[i];\n\t\t\t\telse ++b[i];\n\t\t\t}\n\t\t}\n\t\tvector<vector<bool> > dp(K + 1, vector<bool>(A[1] + 1));\n\t\tdp[0][0] = true;\n\t\tfor (int i = 0; i < K; ++i) {\n\t\t\tfor (int j = 0; j <= A[1]; ++j) {\n\t\t\t\tif (j >= a[i] && dp[i][j - a[i]]) dp[i + 1][j] = true;\n\t\t\t\tif (j >= b[i] && dp[i][j - b[i]]) dp[i + 1][j] = true;\n\t\t\t}\n\t\t}\n\t\tif (!dp[K][A[1]]) {\n\t\t\tcout << \"NO\" << endl;\n\t\t}\n\t\telse {\n\t\t\tvector<int> sel(K, -1);\n\t\t\tint pos = A[1];\n\t\t\tfor (int i = K - 1; i >= 0; --i) {\n\t\t\t\tif (pos >= a[i] && dp[i][pos - a[i]]) {\n\t\t\t\t\tpos -= a[i];\n\t\t\t\t\tsel[i] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpos -= b[i];\n\t\t\t\t\tsel[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> ans(N);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif ((sel[comp[i]] ^ col[i]) == 0) {\n\t\t\t\t\tans[i] = 2; --A[2];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (A[0] > 0) ans[i] = 1, --A[0];\n\t\t\t\t\telse ans[i] = 3, --A[2];\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << \"YES\" << endl;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tcout << ans[i];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs"], "dificulty": "2100", "interactive": false}