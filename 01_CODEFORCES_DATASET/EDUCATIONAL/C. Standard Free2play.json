{
    "link": "https://codeforces.com//contest/1238/problem/C",
    "problemId": "434107",
    "problem_idx": "C",
    "shortId": "1238C",
    "contest_number": "1238",
    "problem_submissions": {
        "G": [
            62148377,
            62150345,
            62148994,
            62146428,
            62171195,
            62152430,
            62150450,
            62151715,
            63077598,
            62153399,
            62153961,
            62326923,
            62163873,
            62157710,
            63252631
        ],
        "C": [
            62139579,
            62128875,
            62134212,
            62149084,
            62171152,
            62131518,
            62131617,
            62138927,
            62130356,
            62145335,
            62127646,
            62128518,
            62127470,
            62128489,
            62132928,
            62130729,
            62130656,
            62131114,
            62129400,
            62129293,
            62129389,
            62141737
        ],
        "F": [
            62135057,
            62143199,
            62146057,
            62137636,
            62171175,
            62141888,
            62144431,
            62147441,
            62144667,
            62133761,
            62136545,
            62139411,
            62133600,
            62138749,
            62143755,
            62143321,
            62145892,
            62144865,
            62148327,
            62148901,
            62145390
        ],
        "E": [
            62130371,
            62135558,
            62133197,
            62133178,
            62171181,
            62138707,
            62138998,
            71444053,
            62143394,
            62142446,
            62126207,
            62132191,
            62134744,
            62139465,
            62131237,
            62138771,
            62335532,
            62136799,
            62138459,
            62139760,
            62138816,
            62133466,
            62139306,
            62136690
        ],
        "D": [
            62130325,
            62130011,
            62129721,
            62133154,
            62171155,
            62134587,
            62136980,
            62133511,
            62142844,
            62150513,
            62130499,
            62130138,
            62131294,
            62128520,
            62132339,
            62134000,
            62132013,
            62132252,
            62131248,
            62131658,
            62131164
        ],
        "B": [
            62124194,
            62124712,
            62125813,
            62133117,
            62171147,
            62134676,
            62126226,
            62125252,
            62142403,
            62146274,
            62123866,
            62124453,
            62125991,
            62125432,
            62124476,
            62123794,
            62126146,
            62127228,
            62126305,
            62123963,
            62127931,
            62125892
        ],
        "A": [
            62120855,
            62121082,
            62121998,
            62121600,
            62171137,
            62121874,
            62120946,
            62121255,
            62120923,
            62120856,
            62121293,
            62121013,
            62121176,
            62120783,
            62120942,
            62121012,
            62121072,
            62121136,
            62121767,
            62121527
        ]
    },
    "name": "C. Standard Free2play",
    "statement": "You are playing a game where your character should overcome different\r\nobstacles. The current problem is to come down from a cliff. The cliff\r\nhas height h, and there is a moving platform on each height x from 1 to\r\nh.Each platform is either hidden inside the cliff or moved out. At\r\nfirst, there are n moved out platforms on heights p_1, p_2,\r\ndots, p_n. The platform on height h is moved out (and the character is\r\ninitially standing there).If you character is standing on some moved out\r\nplatform on height x, then he can pull a special lever, which switches\r\nthe state of . In other words, the platform you are currently standing\r\non will hide in the cliff and the platform one unit below will change it\r\nstate: it will hide if it was moved out or move out if it was hidden. In\r\nthe second case, you will safely land on it. .Your character is quite\r\nfragile, so it can safely fall from the height no more than 2. In other\r\nwords falling from the platform x to platform x - 2 is okay, but falling\r\nfrom x to x - 3 (or lower) is certain death. Sometimes it\u2019s not possible\r\nto come down from the cliff, but you can always buy (for donate\r\ncurrency) several magic crystals. Each magic crystal can be used to\r\nchange the state of any single platform (except platform on height h,\r\nwhich is unaffected by the crystals). After being used, the crystal\r\ndisappears.What is the minimum number of magic crystal you need to buy\r\nto safely land on the 0 ground level?\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint q;\nint main(){\n\tcin >> q;\n\twhile(q--){\n\t\tint n,r; cin >> r >> n;\n\t\tvector<int>vi;\n\t\trep(i,n){\n\t\t\tint a; scanf(\"%d\",&a); vi.pb(a);\n\t\t}\n\t\tint look = 1;\n\t\twhile(vi.size() && vi.back() == look){\n\t\t\tvi.pop_back(); look++;\n\t\t}\n\t\tif(vi.empty()){ cout << 0 << endl; }\n\t\telse{\n\t\t\tvector<int>vecc;\n\t\t\tint cur = r+1;\n\t\t\tint len = 0;\n\t\t\trep(i,vi.size()){\n\t\t\t\tif(cur == vi[i]+1){\n\t\t\t\t\tcur--; len++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvecc.pb(len);\n\t\t\t\t\tlen = 1;\n\t\t\t\t\tcur = vi[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvecc.pb(len);\n\t\t\tint ans = 0;\n\t\t\tif(vecc[0]%2 == 0) ans++;\n\t\t\tfor(int i=1;i<vecc.size();i++) if(vecc[i]%2 == 1) ans++;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Standard Free2play.json",
    "editorial_link": "https://codeforces.com//blog/entry/70450",
    "editorial": "You are given the input data in compressed format, let\u00e2\u0080\u0099s decompress it\r\nin binary string, where the -th character is if the -th platform is\r\nhidden and otherwise. For, example, the third query is .Let\u00e2\u0080\u0099s look how\r\nour string changes: if we had then after pulling the lever it becomes\r\nand if we had then we\u00e2\u0080\u0099d get (The underlined index is the platform we are\r\ncurrently on). So it looks like we are standing on and move it to the\r\nleft until it clashes with the next one. So we can determine that we\r\nshould look only at subsegments on -s.Now we can note, that the \"good\"\r\nstring should have all subsegments of ones with even length except two\r\ncases: the subsegment that starts from should have odd length and\r\nsubsegment, which ends in can have any length.Now we can say, that the\r\nanswer is equal to number of subsegments which doesn\u00e2\u0080\u0099t match the pattern\r\nof the \"good string\", since we can fix each subsegment with one crystal.\r\nAnd we can prove that it\u00e2\u0080\u0099s optimal since the only way to fix two\r\nsubsegments with one crystal is to merge them but it does not\r\nhelp.Finally, we can understand that we have no need in decompressing\r\nthe input and can determine subsegments of ones straightforwardly.\r\n"
}