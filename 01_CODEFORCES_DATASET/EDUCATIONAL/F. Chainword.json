{
    "link": "https://codeforces.com//contest/1511/problem/F",
    "problemId": "955217",
    "problem_idx": "F",
    "shortId": "1511F",
    "contest_number": "1511",
    "problem_submissions": {
        "F": [
            112840077,
            112828537,
            112827087,
            113002746,
            112851650,
            112835176,
            112837815,
            112833990,
            112833873,
            112824360,
            112844580,
            112864617,
            112862363,
            112847364,
            112866931,
            112854217,
            112847572,
            112854389,
            112862579,
            112845350
        ],
        "G": [
            112827572,
            112849564,
            114661033,
            114660887,
            114660767,
            114660706,
            114660307,
            114660076,
            114659999,
            114659915,
            112892560,
            112862384,
            112862341,
            112862288,
            112850067,
            112846404,
            112853880,
            112853846,
            112850825,
            112896875,
            112847874,
            113122868,
            112859368,
            112858002,
            112857690,
            112970481,
            112947065,
            112923272,
            112913505,
            113005183,
            112847551,
            112853638,
            112855715
        ],
        "E": [
            112819190,
            112811502,
            112809874,
            112818379,
            112809749,
            112819391,
            112816521,
            112812422,
            112824024,
            112811228,
            112816399,
            112821852,
            112825588,
            112822496,
            112814072,
            112820021,
            112829060,
            112824596
        ],
        "D": [
            112810190,
            112804690,
            112802519,
            112810990,
            112813483,
            112807233,
            112809814,
            112797395,
            112806426,
            112804268,
            112810141,
            112805389,
            112810319,
            112811043,
            112802328,
            112810501,
            112810922,
            112816639
        ],
        "C": [
            112798920,
            112798787,
            112796760,
            112804959,
            112800997,
            112799737,
            112805004,
            112792842,
            112799549,
            112797984,
            112795724,
            112796489,
            112801048,
            112802109,
            112797807,
            112801283,
            112801426,
            112804850
        ],
        "B": [
            112794609,
            112794368,
            112790815,
            112794707,
            112794954,
            112796065,
            112801022,
            112788437,
            112794356,
            112792946,
            112790545,
            112792316,
            112798211,
            112798547,
            112790397,
            112797545,
            112796307,
            112796695
        ],
        "A": [
            112787944,
            112786809,
            112787014,
            112786892,
            112787663,
            112788591,
            112791727,
            112786823,
            112788650,
            112788073,
            112786815,
            112787413,
            112786972,
            112791493,
            112787338,
            112792315,
            112786886,
            112787405
        ]
    },
    "name": "F. Chainword",
    "statement": "A chainword is a special type of crossword. As most of the crosswords\r\ndo, it has cells that you put the letters in and some sort of hints to\r\nwhat these letters should be.The letter cells in a chainword are put in\r\na single row. We will consider chainwords of length m in this task.A\r\nhint to a chainword is a sequence of segments such that the segments\r\ndon\u2019t intersect with each other and cover all m letter cells. Each\r\nsegment contains a description of the word in the corresponding\r\ncells.The twist is that there are actually two hints: one sequence is\r\nthe row above the letter cells and the other sequence is the row below\r\nthe letter cells. When the sequences are different, they provide a way\r\nto resolve the ambiguity in the answers.You are provided with a\r\ndictionary of n words, each word consists of lowercase Latin letters.\r\nAll words are pairwise distinct.An instance of a chainword is the\r\nfollowing triple: a string of m lowercase Latin letters; the first hint:\r\na sequence of segments such that the letters that correspond to each\r\nsegment spell a word from the dictionary; the second hint: another\r\nsequence of segments such that the letters that correspond to each\r\nsegment spell a word from the dictionary. Note that the sequences of\r\nsegments don\u2019t necessarily have to be distinct.Two instances of\r\nchainwords are considered different if they have different strings,\r\ndifferent first hints different second hints.Count the number of\r\ndifferent instances of chainwords. Since the number might be pretty\r\nlarge, output it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n// https :  // github.com/ecnerwala/cp-book/blob/master/src/bm.hpp\ntemplate <typename num>\nstd::vector<num> BerlekampMassey(const std::vector<num>& s) {\n  int n = int(s.size()), L = 0, m = 0;\n  std::vector<num> C(n), B(n), T;\n  C[0] = B[0] = 1;\n\n  num b = 1;\n  for (int i = 0; i < n; i++) {\n    ++m;\n    num d = s[i];\n    for (int j = 1; j <= L; j++) d += C[j] * s[i - j];\n    if (d == 0) continue;\n    T = C;\n    num coef = d / b;\n    for (int j = m; j < n; j++) C[j] -= coef * B[j - m];\n    if (2 * L > i) continue;\n    L = i + 1 - L;\n    B = T;\n    b = d;\n    m = 0;\n  }\n\n  C.resize(L + 1);\n  C.erase(C.begin());\n  for (auto& x : C) {\n    x = -x;\n  }\n  return C;\n}\n\ntemplate <typename num>\nnum linearRec(const std::vector<num>& S, const std::vector<num>& tr,\n              long long k) {\n  int n = int(tr.size());\n  assert(S.size() >= tr.size());\n\n  auto combine = [&](std::vector<num> a, std::vector<num> b) {\n    std::vector<num> res(n * 2 + 1);\n    for (int i = 0; i <= n; i++)\n      for (int j = 0; j <= n; j++) res[i + j] += a[i] * b[j];\n    for (int i = 2 * n; i > n; --i)\n      for (int j = 0; j < n; j++) res[i - 1 - j] += res[i] * tr[j];\n    res.resize(n + 1);\n    return res;\n  };\n\n  std::vector<num> pol(n + 1), e(pol);\n  pol[0] = e[1] = 1;\n\n  for (++k; k; k /= 2) {\n    if (k % 2) pol = combine(pol, e);\n    e = combine(e, e);\n  }\n\n  num res = 0;\n  for (int i = 0; i < n; i++) res += pol[i + 1] * S[i];\n  return res;\n}\n\ntemplate <uint32_t Modulus>\nclass ModularInt {\n  using M = ModularInt;\n\n public:\n  static_assert(int(Modulus) >= 1, \"Modulus must be in the range [1, 2^31)\");\n  static constexpr int modulus() { return Modulus; }\n  static M raw(uint32_t v) { return *reinterpret_cast<M*>(&v); }\n\n  ModularInt() : v_(0) {}\n  ModularInt(int64_t v) : v_((v %= Modulus) < 0 ? v + Modulus : v) {}\n\n  template <class T>\n  explicit operator T() const {\n    return v_;\n  }\n  M& operator++() { return v_ = ++v_ == Modulus ? 0 : v_, *this; }\n  M& operator--() { return --(v_ ? v_ : v_ = Modulus), *this; }\n  M operator+() const { return *this; }\n  M operator-() const { return raw(v_ ? Modulus - v_ : 0); }\n  M& operator*=(M o) { return v_ = uint64_t(v_) * o.v_ % Modulus, *this; }\n  M& operator/=(M o) {\n    auto [inv, gcd] = extgcd(o.v_, Modulus);\n    assert(gcd == 1);\n    return *this *= inv;\n  }\n  M& operator+=(M o) {\n    return v_ = int(v_ += o.v_ - Modulus) < 0 ? v_ + Modulus : v_, *this;\n  }\n  M& operator-=(M o) {\n    return v_ = int(v_ -= o.v_) < 0 ? v_ + Modulus : v_, *this;\n  }\n\n  friend M operator++(M& a, int) { return std::exchange(a, ++M(a)); }\n  friend M operator--(M& a, int) { return std::exchange(a, --M(a)); }\n  friend M operator*(M a, M b) { return a *= b; }\n  friend M operator/(M a, M b) { return a /= b; }\n  friend M operator+(M a, M b) { return a += b; }\n  friend M operator-(M a, M b) { return a -= b; }\n  friend std::istream& operator>>(std::istream& is, M& x) {\n    int64_t v;\n    return is >> v, x = v, is;\n  }\n  friend std::ostream& operator<<(std::ostream& os, M x) { return os << x.v_; }\n  friend bool operator==(M a, M b) { return a.v_ == b.v_; }\n  friend bool operator!=(M a, M b) { return a.v_ != b.v_; }\n\n private:\n  static std::pair<int, int> extgcd(int a, int b) {\n    std::array x{1, 0};\n    while (b) std::swap(x[0] -= a / b * x[1], x[1]), std::swap(a %= b, b);\n    return {x[0], a};\n  }\n\n  uint32_t v_;\n};\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nusing Mint = ModularInt<998244353>;\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n = scan();\n  int m = scan();\n  vector<string> s(n);\n  generate(ALL(s), scan<string>);\n  vector<string> suff;\n  for (auto&& e : s)\n    for (int i : Rep(size(e) + 1)) suff.push_back(e.substr(i));\n  sort(ALL(suff));\n  suff.erase(unique(ALL(suff)), end(suff));\n\n  int lim = 100;\n  vector f(lim + 1, vector<Mint>(size(suff)));\n  f[0][0] = 1;\n\n  for (int len : Rep(lim))\n    for (int i : Rep(size(suff)))\n      for (auto&& e : s)\n        if (size(e) < size(suff[i])) {\n          if (suff[i].substr(0, size(e)) != e) continue;\n          if (len + int(size(e)) > lim) continue;\n          f[len + size(e)][lower_bound(ALL(suff), suff[i].substr(size(e))) -\n                           begin(suff)] += f[len][i];\n        } else {\n          if (e.substr(0, size(suff[i])) != suff[i]) continue;\n          if (len + int(size(suff[i])) > lim) continue;\n          f[len + size(suff[i])]\n           [lower_bound(ALL(suff), e.substr(size(suff[i]))) - begin(suff)] +=\n              f[len][i];\n        }\n\n  vector<Mint> a(lim + 1);\n  for (int i : Rep(lim + 1)) a[i] = f[i][0];\n  cout << linearRec(a, BerlekampMassey(a), m) << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "matrices",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Chainword.json",
    "editorial_link": "https://codeforces.com//blog/entry/89634",
    "editorial": "Let\u00e2\u0080\u0099s use a trie to store the given words. Now let\u00e2\u0080\u0099s imagine a procedure\r\nthat checks if some string of length can be represented as a\r\nconcatenation of some of these words. If the words were\r\nprefix-independent no word was a prefix of another word, that task would\r\nbe solvable with a greedy algorithm.We could iterate over a string and\r\nmaintain the current vertex of the trie we are in. Append a current\r\nletter. If there is no such transition in a trie, it can\u00e2\u0080\u0099t be\r\nrepresented. If the vertex we go to is a terminal, jump to the root of\r\nthe trie. Otherwise, just go to that vertex. However, since the words\r\naren\u00e2\u0080\u0099t prefix-independent, we have a terminal on a path to other\r\nterminals. Thus, we can\u00e2\u0080\u0099t immediately decide if we should jump to the\r\nroot or just go.Let\u00e2\u0080\u0099s handle this with dynamic programming. can we put\r\nletters in such a way that the vertex of a trie we are in is .Is\r\nbuilding a chainword letter by letter that different from this process?\r\nApparently, it isn\u00e2\u0080\u0099t. Consider how many ways are there to put letters in\r\na string so that the first hint is in a vertex and the second hint is in\r\na vertex . For the transition we can try all letters to put and jump to\r\nthe corresponding vertices.That obviously, is too slow. The intuition\r\ntells us that this dp should be calculated with some kind of matrix\r\nexponentiation (since ). That dp can be rewritten as a matrix pretty\r\neasily. However, its size is up to (the maximum number of vertices in a\r\ntrie squared).Some say that there is a way to compute the -th power of\r\nsuch a huge matrix fast enough with Berlekamp Massey, but I\r\nunfortunately am not familiar with it.Thus, we\u00e2\u0080\u0099ll have to reduce the\r\nsize of our matrix. First, notice that the only reachable states are\r\nsuch that the word that is written on a path from the root to is a\r\nsuffix of a word that is written on a path from the root to or vice\r\nversa.Look at it the other way: if we build a trie on the reversed\r\nwords, then one of the vertices will be an ancestor of another one. Now\r\nit\u00e2\u0080\u0099s easy to estimate the number of states as the sum of depths of all\r\nvertices. However, since we look at ordered pairs of , we should more or\r\nless double that amount. That should be states at max.This can probably\r\npass with an optimal enough implementation. We can do better, though.\r\nLet\u00e2\u0080\u0099s merge the states and into one state. The intuition is basically\r\nthat you can swap the hints at will. That makes the pairs unordered: now\r\nthere are up to pairs. That surely will work fast enough.The way to\r\ngenerate all the possible states is the following: run a dfs/bfs,\r\nstarting from that makes all valid transition and record all the states\r\nthat can be visited.While preparing the tests, I only managed to get up\r\nto states and I would really love to hear an approach to either prove a\r\ntighter bound or to generate a test closer to the bound of .\r\n"
}