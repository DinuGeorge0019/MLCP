{
    "link": "https://codeforces.com//contest/2025/problem/F",
    "problemId": "2948776",
    "problem_idx": "F",
    "shortId": "2025F",
    "contest_number": "2025",
    "problem_submissions": {
        "G": [
            285888128,
            285968165,
            285968156,
            285968149,
            285968144,
            285897832,
            285920810,
            285910851,
            285909011,
            285930826,
            285929850,
            285925790,
            285926690,
            285922742,
            285921341,
            285927635,
            285927533,
            285927378,
            285927290,
            285927201,
            285926718,
            285927241,
            285924989,
            299831833,
            286121442
        ],
        "F": [
            285868426,
            285875834,
            285881666,
            285895954,
            285888111,
            285886401,
            285885303,
            285891958,
            285893731,
            285892263,
            285879653,
            285886660,
            285891778,
            285886231,
            285896708,
            285895437,
            285887128,
            285901645,
            285898009,
            285911413,
            285909168
        ],
        "E": [
            285859957,
            285867757,
            285870223,
            285876387,
            285873807,
            285876494,
            285872556,
            285873708,
            285881956,
            285870423,
            285874469,
            285878077,
            285869033,
            285872685,
            285876656,
            285892958,
            285888168,
            285880850,
            285877703,
            285879472
        ],
        "C": [
            285855265,
            285848963,
            285851041,
            285855836,
            285849335,
            285851254,
            285854960,
            285854181,
            285864164,
            285852009,
            285850624,
            285853432,
            285850248,
            285850107,
            285852412,
            285937663,
            285937269,
            285852480,
            285853757,
            285856229,
            285852397,
            285853481
        ],
        "D": [
            285854273,
            285858071,
            285858183,
            285867921,
            285860641,
            285863810,
            285864716,
            285864881,
            285873876,
            285863514,
            285859817,
            285865001,
            285869981,
            285860140,
            285866304,
            285941352,
            285868260,
            285864450,
            285868121,
            285865847,
            285869499
        ],
        "B": [
            285844312,
            285844368,
            285843910,
            285848590,
            285844872,
            285845275,
            285846752,
            285845703,
            285858394,
            285844772,
            285844563,
            285847140,
            285845401,
            285845320,
            285848121,
            285848201,
            285847162,
            285850578,
            285846812,
            285847900
        ],
        "A": [
            285841954,
            285841960,
            285842031,
            285842286,
            285842224,
            285842066,
            285842261,
            285842191,
            285843710,
            285842044,
            285842146,
            285842134,
            285841991,
            285842021,
            285846906,
            285842091,
            285842126,
            285842764,
            285842102,
            285842266
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135173",
    "editorial": "We will use the classical method for solving maximization/minimization\r\nproblems: we will come up with an estimate for the answer and try to\r\nachieve it constructively.The first idea. Since we have objects\r\nconnected by binary relations, we can model the problem as a graph. Let\r\nthe elements of the array be the vertices, and the queries be the edges.\r\nFor each query, we would like to choose the direction of the edge (let\r\nthe edge be directed towards the vertex to which the operation is\r\napplied) and the sign of the operation.It would be great if, in each\r\nconnected component, we could choose an equal number of pluses and\r\nminuses so that the sum equals zero. Or, if the number of edges in the\r\ncomponent is odd, to make the sum equal to one. Obviously, it is not\r\npossible to do less than this.It turns out that this is always possible.\r\nThere is a well-known graph problem: to split the edges of an undirected\r\nconnected graph into pairs with at least one common endpoint. We will\r\nreduce our problem to this one. If we split the graph into pairs, we\r\nwill construct the answer from them as follows: we will direct the edges\r\nof each pair towards any common vertex, write on the edge with the\r\nsmaller number (query index), and write on the edge with the larger\r\nnumber. This construction guarantees that each pair will not add\r\nanything to the sum, and each element will be non-negative after each\r\nquery.The problem of splitting into pair can be solved using the\r\nfollowing algorithm. We will perform a DFS from any vertex and construct\r\na DFS tree. Now we will divide the edges into pairs in the order from\r\nthe leaves to the root. Let us stand at some vertex . First, run the\r\nalgorithm recursively for the children of . When we finish processing\r\nthe children, we will consider the following edges from the current\r\nvertex : tree edges to the children, the edge to the parent, and back\r\nedges with the lower endpoint at . Now, we form as many pairs as\r\npossible from the edges to the children and the back edges. We will\r\nremove all such edges from the graph. If their total number was odd,\r\nthen one edge remains unpaired. Form a pair from it and the edge to the\r\nparent, and again remove them from the graph. It turns out that when we\r\nexit the recursive call, either there will be no edges left in the\r\nsubtree at all, or there will be one tree edge that will be processed by\r\nthe parent later. If the number of edges in the component is odd, then\r\nat the end, one edge without a pair will remain at the root.I would also\r\nlike to mention the following implementation details. In the adjacency\r\nlist, it is better to store the indices of the queries rather than the\r\nvertices, and then derive the vertex numbers from them. This will allow\r\nfor careful handling of multiple edges. Removing edges from the graph\r\ndirectly is also not very convenient. The most convenient way to work\r\naround this, in my opinion, is to maintain an array that marks that the\r\nedge with such a query number is now removed. Alternatively, for back\r\nedges, we can check whether is the upper or lower endpoint, as well as\r\nreturn a flag from the depth-first search indicating \"is the edge to the\r\nchild removed\".Overall complexity: .\r\n",
    "name": "F. Choose Your Queries",
    "statement": "You are given an array a, consisting of n integers (numbered from 1 to\r\nn). Initially, they are all zeroes.You have to process q queries. The\r\ni-th query consists of two different integers x_i and y_i. During the\r\ni-th query, you have to choose an integer p (which is either x_i or y_i)\r\nand an integer d (which is either 1 or -1), and assign a_p = a_p +\r\nd.After each query, every element of a should be a non-negative\r\ninteger.Process all queries in such a way that the sum of all elements\r\nof a after the last query is the minimum possible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned; int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n, q;    std::cin >> n >> q;        std::vector<int> x(q), y(q);    std::vector<std::vector<std::array<int, 2>>> adj(n);    for (int i = 0; i < q; i++) {        std::cin >> x[i] >> y[i];        x[i]--;        y[i]--;        adj[x[i]].push_back({y[i], 2 * i});        adj[y[i]].push_back({x[i], 2 * i + 1});    }        std::vector<bool> vis(n);    std::vector<int> dep(n);        std::vector<std::string> ans(q, \"x+\");         auto match = [&](int i, int j, int x) {        ans[i / 2][1] = (i < j ? '+' : '-');        ans[j / 2][1] = (i < j ? '-' : '+');        ans[i / 2][0] = \"xy\"[i % 2];        ans[j / 2][0] = \"xy\"[j % 2];    };        for (int s = 0; s < n; s++) {        if (vis[s]) {            continue;        }        auto dfs = [&](auto &self, int x, int p) -> int {            vis[x] = true;            int c = -1;            for (auto [y, i] : adj[x]) {                if (vis[y]) {                    if (dep[y] > dep[x]) {                        if (c != -1) {                            match(c, i, x);                            c = -1;                        } else {                            c = i;                        }                    }                } else {                    dep[y] = dep[x] + 1;                    int d = self(self, y, i);                    if (d != -1) {                        match(i ^ 1, d, y);                    } else {                        if (c != -1) {                            match(c, i, x);                            c = -1;                        } else {                            c = i;                        }                    }                }            }            return c;        };        dfs(dfs, s, -1);    }        for (int i = 0; i < q; i++) {        std::cout << ans[i] << \"\\n\";    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Choose Your Queries.json",
    "hint": []
}