{
    "link": "https://codeforces.com//contest/2104/problem/F",
    "problemId": "3357542",
    "problem_idx": "F",
    "shortId": "2104F",
    "contest_number": "2104",
    "problem_submissions": {
        "G": [
            317634002,
            317631743,
            320673214,
            317636349,
            317639303,
            317631308,
            317640372,
            317641490,
            317634993,
            317623920,
            317623580,
            317647581,
            317646744,
            317640479,
            317649324,
            317648614,
            317603575,
            317625986,
            317658338,
            317654956,
            317656090
        ],
        "F": [
            317618453,
            317615339,
            317611576,
            317619502,
            317642933,
            317616740,
            317626825,
            317624444,
            317635700,
            317630227,
            317652195,
            317651366,
            317632460,
            317639846,
            317622626,
            317627252,
            317618955,
            317629645,
            317633465
        ],
        "E": [
            317600678,
            317604770,
            317604225,
            317601494,
            317605089,
            317605713,
            317610349,
            317606588,
            317606228,
            317611391,
            317609737,
            317616567,
            317624447,
            317604365,
            317605239,
            317606517,
            317605527,
            317603967
        ],
        "D": [
            317596832,
            317600994,
            317595577,
            317597224,
            317599585,
            317599131,
            317603322,
            317601392,
            317602519,
            317606339,
            317605002,
            317608223,
            317625926,
            317598715,
            317596708,
            317599445,
            317601363,
            317598919
        ],
        "C": [
            317592206,
            317594503,
            317591740,
            317592536,
            317595007,
            317592453,
            317599440,
            317596483,
            317666768,
            317597634,
            317597533,
            317596118,
            317603421,
            317628135,
            317593822,
            317592818,
            317594552,
            317594062,
            317592586
        ],
        "B": [
            317586512,
            317588149,
            317586474,
            317586748,
            317587897,
            317586575,
            317590393,
            317589124,
            317590519,
            317590566,
            317590505,
            317595035,
            317629001,
            317588704,
            317587930,
            317589549,
            317586793,
            317587862
        ],
        "A": [
            317583850,
            317584199,
            317583696,
            317583966,
            317584221,
            317583906,
            317584707,
            317583779,
            317583664,
            317586307,
            317586411,
            317589674,
            317629578,
            317583905,
            317584152,
            317583791,
            317583699,
            317583693
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142472",
    "editorial": "Consider how the decimal representation of depends on . Usually, all\r\ndigits of remain the same, except for the last digit, which is increased\r\nby . It does not actually work if the last digit of is , but we can get\r\na more general rule that handles that case: all ’s at the end of the\r\nnumber change to ’s, and then the digit before that block of ’s gets\r\nincreased by .Let’s split each integer into three parts: the last block\r\nof ’s (possibly empty), the digit before that block of ’s, and all\r\ndigits before that (possibly none). For example, the number is split as\r\nfollows: .The first part of the integer will not be affected if we\r\nincrease the integer by . So, the order of digits in the first part does\r\nnot matter: gives the same string as , since is a permutation of .So, if\r\nthere are two integers for which the \"middle\" and the \"right\" part are\r\nthe same, and the left parts are permutations of each other, the strings\r\nare the same for them. Among several numbers having the same , we are\r\ninterested only in the smallest number.Let’s brute force all numbers\r\nsuch that their left parts are . So, if some digit of the number is less\r\nthan the previous one, then this digit is the \"middle\" part and every\r\ndigit to the right of it should be . In my opinion, the easiest way to\r\ndo this is to run a recursive function like , where is the current\r\ndecimal representation of the number, and denotes whether we have\r\nalready built the left and the middle part of the number. If is false,\r\nwe can append any digit to the end of the number (and if it is less than\r\nthe last digit of , we set to true); otherwise, we can only append .This\r\nmay cause our integers to have leading zeroes, but I have an easy fix\r\nfor this: when converting the decimal representation of the integer to\r\nthe integer itself, if it has leading zeroes, swap the first digit with\r\nthe first non-zero digit.Unfortunately, this brute force approach may\r\ngenerate multiple integers having the same , since, for example, and\r\nhave the same , but their left parts are not permutations of each other.\r\nSo we need to filter the list of numbers we get: if multiple numbers\r\ngive the same , get rid of all of them except for the minimum one. The\r\nmodel solution does this by storing pairs and sorting them.After we’ve\r\nfiltered the numbers, we can sort them again in non-descending order and\r\nuse binary search to answer the test cases.The only thing that’s left to\r\ndiscuss is why this works fast. We can estimate the number of integers\r\nour search will consider as follows: each integer consists of the left\r\npart, the digit after it, and the block of ’s. The length of the integer\r\nis at most , so the length of the left part is at most . The number of\r\npossible left parts of length is , since constructing the integer of\r\nlength with ascending digits can be represetned as a partition of into\r\nnon-negative summands. If the length of the left part is , the number of\r\npossible left parts is , the number of ways to choose the middle part is\r\n. This is clearly the largest group of numbers we are interested in, but\r\nif you want to check the other groups as well, you can sum them up as\r\nfollows: here represents the number of ways to choose the length for the\r\nblock of ’s. Evaluating this formula gives that a bit less than integers\r\nare considered by our search.\r\n",
    "name": "F. Numbers and Strings",
    "statement": "For each integer x from 1 to n, we will form the string S(x) according\r\nto the following rules: compute (x+1); write x and x+1 next to each\r\nother in the decimal system without separators and leading zeros; in the\r\nresulting string, sort all digits in non-decreasing order. For example,\r\nthe string S(139) is (before sorting the digits, it is ). The string\r\nS(99) is .Your task is to count the number of distinct strings among\r\nS(1), S(2),\r\ndots, S(n).\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "dfs and similar",
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Numbers and Strings.json",
    "hint": []
}