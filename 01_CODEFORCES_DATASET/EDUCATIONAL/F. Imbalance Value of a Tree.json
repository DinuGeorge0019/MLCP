{
    "link": "https://codeforces.com//contest/915/problem/F",
    "problemId": "146473",
    "problem_idx": "F",
    "shortId": "915F",
    "contest_number": "915",
    "problem_submissions": {
        "G": [
            34149372,
            34145802,
            34144917,
            34149940,
            34145497,
            34145091,
            34146841,
            34133578,
            34140368,
            34156614,
            34136642,
            34149433,
            34141049,
            34151857,
            34143141,
            34142291,
            34153795,
            34152031,
            34149642
        ],
        "F": [
            34141740,
            34141911,
            34142659,
            34144461,
            34139648,
            34150037,
            34135451,
            34135325,
            34136765,
            34139507,
            34185912,
            34185895,
            34185884,
            34144212,
            34147801,
            34138374,
            34149691,
            34145676,
            34149957
        ],
        "E": [
            34139509,
            34136671,
            34139993,
            34142857,
            34141594,
            34143243,
            34138759,
            34150868,
            34131224,
            34145365,
            34144825,
            34146415,
            34139658,
            34148670,
            34147938,
            34144847,
            34142409,
            34147934,
            34152612
        ],
        "D": [
            34136912,
            34138946,
            34136834,
            34138837,
            34134917,
            34139148,
            34142081,
            34147574,
            34141584,
            34140548,
            34136477,
            34136703,
            34136486,
            34145522,
            34138909,
            34138016,
            34141644,
            34141385,
            34135263
        ],
        "C": [
            34133179,
            34132160,
            34132616,
            34134296,
            34131528,
            34132656,
            34145969,
            34144943,
            34139362,
            34131971,
            34135532,
            34132111,
            34166504,
            34134375,
            34134967,
            34134748,
            34132949,
            34134607,
            34133338
        ],
        "B": [
            34129725,
            34129567,
            34129784,
            34132321,
            34130243,
            34147501,
            34142325,
            34138326,
            34132523,
            34157084,
            34130697,
            34130455,
            34131022,
            34130794,
            34158518,
            34130482
        ],
        "A": [
            34127694,
            34127702,
            34127886,
            34130517,
            34127730,
            34147894,
            34141073,
            34137409,
            34128096,
            34127668,
            34127948,
            34127873,
            34127723,
            34128273,
            34128083,
            34127880
        ]
    },
    "name": "F. Imbalance Value of a Tree",
    "statement": "You are given a tree consisting of vertices. A number is written on each\r\nvertex; the number written on vertex is . Let’s denote the function as\r\nthe difference between maximum and minimum value of on a simple path\r\nconnecting vertices and .Your task is to calculate .\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:167772160000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(\"%d\", &n);\n#define read2(n, m) scanf(\"%d%d\", &n, &m);\n#define readll(n) scanf(\"%I64d\", &n);\n#define mp make_pair\nint n;\nvector<int>edges[1100000];\nint par[1100000];\nint siz[1100000];\nint find(int a) {\n\tif (par[a] == a)return a;\n\tpar[a] = find(par[a]);\n\treturn par[a];\n}\nvoid unite(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b)return;\n\tsiz[a] += siz[b];\n\tpar[b] = a;\n}\nll w[1100000];\npll p[1100000];\nbool vis[1100000];\nll solve() {\n\tfori1(n) {\n\t\tvis[i] = false;\n\t\tpar[i] = i;\n\t\tsiz[i] = 1;\n\t}\n\tll answer = 0;\n\tfori1(n) {\n\t\tp[i] = mp(w[i], i);\n\t}\n\tsort(p + 1, p + 1 + n);\n\n\tfork1(n) {\n\t\tint a = p[k].second;\n\t\tanswer += w[a];\n\t\tll have = 1;\n\t\tfor (auto x : edges[a]) {\n\t\t\tif (!vis[x])continue;\n\t\t\tanswer += have*siz[find(x)] * w[a];\n\t\t\thave += siz[find(x)];\n\t\t\tunite(a, x);\n\t\t}\n\t\tvis[a] = true;\n\t}\n\treturn answer;\n}\n\n\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tcin >> n;\n\tfori1(n)cin >> w[i];\n\tfori(n - 1) {\n\t\tint a, b; cin >> a >> b;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tll ans = solve();\n\tfori1(n)w[i] = -w[i];\n\tans += solve();\n\tcout << ans;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Imbalance Value of a Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/57123",
    "editorial": "Letâs calculate the answer as the difference between sum of maxima and\r\nsum of minima over all paths. These sums can be found by the following\r\napproach:Consider the sum of maxima. Letâs sort all vertices in\r\nascending order of values of (if two vertices have equal values, their\r\norder doesnât matter). This order has an important property that we can\r\nuse: for every path, the maximum on this path is written on the vertex\r\nthat has the greatest position in sorted order. This allows us to do the\r\nfollowing:Letâs denote as a tree, rooted at vertex , that is formed by\r\nthe set of such vertices that are directly connected to or some other\r\nvertex from the set, and have . Consider the vertices that are connected\r\nto in this tree. Letâs denote them as , , ..., (the order doesnât\r\nmatter), and denote by the size of the subtree of in the tree . Letâs\r\ntry to calculate the number of paths going through in this tree: paths\r\nthat have as its endpoint; paths (connecting a vertex from subtree of to\r\na vertex from subtree of ). So vertex adds the sum of these values,\r\nmultiplied by , to the sum of maxima. To calculate these sums, we will\r\nuse the following algorithm:Initialize a DSU (disjoint set union),\r\nmaking a set for each vertex. Process the vertices in sorted order. When\r\nwe process some vertex , find all its already processed neighbours (they\r\nwill be , , ..., in ). For every neighbour , denote the size of its set\r\nin DSU as . Then calculate the number of paths going through using\r\naforementioned formulas (to do it in linear time, use partial sums). Add\r\nthis number, multiplied by , to the sum of maxima, and merge with , ,\r\n..., in DSU.To calculate the sum of minima, you can do the same while\r\nprocessing vertices in reversed order.Time complexity of this solution\r\nis .\r\n",
    "hint": []
}