{
    "link": "https://codeforces.com//contest/808/problem/F",
    "problemId": "106402",
    "problem_idx": "F",
    "shortId": "808F",
    "contest_number": "808",
    "problem_submissions": {
        "E": [
            27137197,
            27134808,
            27134054,
            27132549,
            27131870,
            27132812,
            27138350,
            27133736,
            27131963,
            27140761,
            27135118,
            27134983,
            27132973,
            27138881,
            27134671,
            27261177,
            27134231
        ],
        "G": [
            27135167,
            27130618,
            27132801,
            27169611,
            27134965,
            27137204,
            27160747,
            27136267,
            27135740,
            27136906,
            27138137,
            27159188,
            27140353,
            27136012,
            27136390,
            27133992,
            27143226,
            27141294
        ],
        "F": [
            27133833,
            27138112,
            27177906,
            27136765,
            27164228,
            27142537,
            27133888,
            27166317,
            27145346,
            27277981,
            27273337,
            27267183,
            27141042,
            27133326,
            27139365,
            27141028,
            27139853,
            27137233,
            27203781,
            27164790,
            27139352
        ],
        "D": [
            27128503,
            27127219,
            27129431,
            27127572,
            27126819,
            27126652,
            27126413,
            27131013,
            27128036,
            27144856,
            27149028,
            27130439,
            27159164,
            27158696,
            27130609,
            27129280,
            31052395,
            27170361,
            27127426,
            27204067
        ],
        "C": [
            27127241,
            27126114,
            27126407,
            27126117,
            27125155,
            27125545,
            27125616,
            27128374,
            27126308,
            27126044,
            27126773,
            27128917,
            27129043,
            27127777,
            27126008,
            27126821,
            27129336
        ],
        "B": [
            27125488,
            27124939,
            27125624,
            27125294,
            27125238,
            27124591,
            27125024,
            27127379,
            27125310,
            27124893,
            27125455,
            27127633,
            27127827,
            27131416,
            27125036,
            27126129,
            27163815,
            27127143
        ],
        "A": [
            27124684,
            27124405,
            27124596,
            27124469,
            27124323,
            27124317,
            27124491,
            27126511,
            27124424,
            27124395,
            27124442,
            27124926,
            27125033,
            27130660,
            27124528,
            27124407,
            27163707,
            27124848
        ]
    },
    "name": "F. Card Game",
    "statement": "Digital collectible card games have become very popular recently. So\r\nVova decided to try one of these.Vova has cards in his collection. Each\r\nof these cards is characterised by its power , magic number and level .\r\nVova wants to build a deck with total power not less than , but magic\r\nnumbers may not allow him to do so Vova can\u2019t place two cards in a deck\r\nif the sum of the magic numbers written on these cards is a prime\r\nnumber. Also Vova cannot use a card if its level is greater than the\r\nlevel of Vova\u2019s character.At the moment Vova\u2019s character\u2019s level is .\r\nHelp Vova to determine the minimum level he needs to reach in order to\r\nbuild a deck with the required total power.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nconst int N=300007,inf=0x3f3f3f3f;\nint n,ans,S,T;\nint es[N],enx[N],ev[N],e0[N],e1[N],h[N],q[N],ep=2;\nint min(int a,int b){return a<b?a:b;}\nbool bfs(){\n\tint ql=0,qr=0;\n\tmemset(h,0,sizeof(int)*(T+2));\n\th[q[++qr]=S]=1;\n\twhile(ql!=qr){\n\t\tint w=q[++ql];\n\t\te1[w]=e0[w];\n\t\tif(w==T)return 1;\n\t\tfor(int i=e0[w];i;i=enx[i])if(ev[i]){\n\t\t\tint u=es[i];\n\t\t\tif(!h[u])h[q[++qr]=u]=h[w]+1;\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int w,int f){\n\tif(w==T)return f;\n\tint c,used=0;\n\tfor(int&i=e1[w];i;i=enx[i])if(ev[i]){\n\t\tint u=es[i];\n\t\tif(h[u]!=h[w]+1)continue;\n\t\tc=dfs(u,min(f-used,ev[i]));\n\t\tif(!c)continue;\n\t\tev[i]-=c;ev[i^1]+=c;used+=c;\n\t\tif(f==used)return f;\n\t}\n\th[w]=0;\n\treturn used;\n}\nvoid ae(int a,int b,int c){\n\tes[ep]=b;enx[ep]=e0[a];ev[ep]=c;e0[a]=ep++;\n\tes[ep]=a;enx[ep]=e0[b];ev[ep]=0;e0[b]=ep++;\n}\nint k;\nbool np[200007]={1,1};\nstruct pos{\n\tint p,c,l;\n}ps[107];\nint main(){\n\tfor(int i=2;i<=200000;++i)if(!np[i])\n\t\tfor(int j=i*2;j<=200000;j+=i)np[j]=1;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d%d%d\",&ps[i].p,&ps[i].c,&ps[i].l);\n\t}\n\tint L=1,R=n+1,M;\n\tS=n+1,T=n+2;\n\twhile(L<R){\n\t\tM=L+R>>1;\n\t\tmemset(e0,0,sizeof(int)*(T+2));ep=2;\n\t\tint m1=-1,w1=-1;\n\t\tfor(int i=1;i<=n;++i)if(ps[i].l<=M){\n\t\t\tif(ps[i].c==1&&ps[i].p>m1)m1=ps[i].p,w1=i;\n\t\t}\n\t\tans=0;\n\t\tfor(int i=1;i<=n;++i)if(ps[i].l<=M){\n\t\t\tif(ps[i].c==1&&i!=w1)continue;\n\t\t\tans+=ps[i].p;\n\t\t\tif(ps[i].c&1){\n\t\t\t\tae(S,i,ps[i].p);\n\t\t\t\tfor(int j=1;j<=n;++j)if(ps[j].l<=M&&(~ps[j].c&1)&&!np[ps[i].c+ps[j].c]){\n\t\t\t\t\tae(i,j,inf);\n\t\t\t\t}\n\t\t\t}else ae(i,T,ps[i].p);\n\t\t}\n\t\twhile(bfs())ans-=dfs(S,inf);\n\t\tif(ans<k)L=M+1;\n\t\telse R=M;\n\t}\n\tprintf(\"%d\",L>n?-1:L);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "flows",
        "graphs"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Card Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/52010",
    "editorial": "The most tricky part of the problem is how to check if some set of cards\r\nallows us to build a deck with the required power (not taking the levels\r\nof cards into account).Suppose we have not more than one card with magic\r\nnumber (if there are multiple cards with this magic number, then we\r\nobviously can use only one of these). Then two cards may conflict only\r\nif one of them has an odd magic number, and another has an even magic\r\nnumber otherwise their sum is even and not less than , so it\u00e2\u0080\u0099s not a\r\nprime number.This allows us to solve this problem as follows:Construct a\r\nbipartite graph: each vertex represents a card, and two vertices are\r\nconnected by an edge if the corresponding pair of cards can\u00e2\u0080\u0099t be put in\r\na deck. Then we have to find the maximum weight of independent set in\r\nthis graph. This can be solved using maximum flow algorithm: construct a\r\nnetwork where source is connected with every \"odd\" vertex (a vertex that\r\nrepresents a card with an odd magic number) by an edge with capacity\r\nequal to the power of this card; then connect every \"odd\" vertex to all\r\n\"even\" vertices that are conflicting with this vertex by edges with\r\ninfinite capacities; and then connect every \"even\" vertex to the sink by\r\nan edge with capacity equal to the power of the card (all edges have to\r\nbe directed). Then the maximum power of the deck is equal to , where is\r\nthe sum of all powers and is the minimum cut value between the source\r\nand the sink (which is equal to the maximum flow).This allows us to\r\ncheck if we can build a deck of required power using only some set of\r\ncards (for example, only cards with level less than or equal to some ).\r\n"
}