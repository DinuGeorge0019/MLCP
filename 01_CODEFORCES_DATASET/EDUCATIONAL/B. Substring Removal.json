{
    "link": "https://codeforces.com//contest/1096/problem/B",
    "problemId": "275409",
    "problem_idx": "B",
    "shortId": "1096B",
    "contest_number": "1096",
    "problem_submissions": {
        "E": [
            47642254,
            47649536,
            47653679,
            47648526,
            47652142,
            47650532,
            47647313,
            47647929,
            47648225,
            47694278,
            47661678,
            47661672,
            47660722,
            47660711,
            47660680,
            47660618,
            47660582,
            47660120,
            47656494,
            47655953,
            47657647,
            47817653,
            47648933,
            47665496,
            47659752
        ],
        "F": [
            47639264,
            47644997,
            47642974,
            47644488,
            47645071,
            47645827,
            47642225,
            47651889,
            47635316,
            47632710,
            47640155,
            47703351,
            47703260,
            47636058,
            47646007,
            47639902,
            47642860,
            47639982,
            47644292,
            47643281,
            47642796
        ],
        "G": [
            47638289,
            47637580,
            47634875,
            47638768,
            47640048,
            47642247,
            47630999,
            47650309,
            47660389,
            47657262,
            47654048,
            47629119,
            47636649,
            47642830,
            47708729,
            47708522,
            47703016,
            47700940,
            47672367,
            47656352,
            47640712,
            47641093,
            47648435,
            47638969,
            47687049,
            47686924,
            47686825,
            47646867,
            47636051,
            47647716
        ],
        "D": [
            47635471,
            47633956,
            47638959,
            47636889,
            47629667,
            47638623,
            47639300,
            47633153,
            47649242,
            47638629,
            47633639,
            47630356,
            47634376,
            47631648,
            47636547,
            47634092,
            47638812,
            72047403,
            47632964,
            47638521
        ],
        "C": [
            47633317,
            47631680,
            47629418,
            47632179,
            47634755,
            47633350,
            47643997,
            47635493,
            47651183,
            47635153,
            47632143,
            47638363,
            47631171,
            47629984,
            47635983,
            47631947,
            47634094,
            47646109,
            47636660
        ],
        "B": [
            47631281,
            47629817,
            47632624,
            47628290,
            47637243,
            47631678,
            47637542,
            47630349,
            47652229,
            47629170,
            47629856,
            47637300,
            47629416,
            47628505,
            47627019,
            47628065,
            47630666,
            94912172,
            47637515,
            47631993
        ],
        "A": [
            47628887,
            47626041,
            47629759,
            47624992,
            47630193,
            47627541,
            47635962,
            47626700,
            47652441,
            47625024,
            47625341,
            47625412,
            47625492,
            47624882,
            47624919,
            47624912,
            47627405,
            47625425,
            47625087
        ]
    },
    "name": "B. Substring Removal",
    "statement": "You are given a string s of length n consisting only of lowercase Latin\r\nletters.A substring of a string is a contiguous subsequence of that\r\nstring. So, string \"\" is substring of string \"\", but string \"\" is\r\nnot.Your task is to calculate the number of ways to remove one substring\r\nfrom this string in such a way that remaining characters are (the number\r\nof distinct characters either zero or one).It is guaranteed that there\r\nis different characters in s.Note that you remove the whole string and\r\nit is correct. Also note that you should .Since the answer can be rather\r\nlarge (not very large though) print it modulo 998244353.\r\n",
    "solutions": [
        "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 200005\n#define INF 1000000000\n#define MOD 998244353\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,k,a[MAXN];\nstring str;\nvoid inc(int &a) {a++; if(a>=MOD) a-=MOD;}\nint main()\n{\n    scanf(\"%d\",&n);\n    cin>>str;\n    char ch=str[0];\n    int ans=1;\n    for(int i=1;i<n;i++) \n    {\n        if(str[i]!=ch) break;\n        inc(ans);\n    }\n    inc(ans);\n    ch=str[n-1];\n    for(int i=n-2;i>=0;i--)\n    {\n        if(str[i]!=ch) break;\n        inc(ans);\n    }\n    if(str[0]==str[n-1])\n    {\n        ch=str[0];\n        int l=1,r=n-2;\n        while(str[r]==ch) r--;\n        while(str[l]==ch) l++;\n        ans=1LL*(l+1)*(n-r)%MOD;\n    }\n    else inc(ans);\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "strings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Substring Removal.json",
    "editorial_link": "https://codeforces.com//blog/entry/64156",
    "editorial": "Firstly, letâs calculate the length of the prefix of equal letters (let\r\nit be ) and the length of the suffix of equal letters (let it be ). It\r\ncan be done with two cycles with breaks. It is obvious that this prefix\r\nand suffix wouldnât overlap.Then letâs consider two cases: the first one\r\nis when and the second one is when .In the first case we can only remain\r\neither prefix or suffix of consisting only of equal letters. Then the\r\nanswer is (because we can remain from to letters on the prefix, from to\r\non the suffix or empty string).In the second case we can remain from to\r\nletters on the prefix and from to letters on the suffix. But now because\r\nwe can combine these ways, so the answer is .And the bonus (this case is\r\nnot belong to the given problem): if all letters in the string are equal\r\nthen then answer is because we can choose any substring of of length at\r\nleast and any substring of length .\r\n",
    "hint": []
}