{
    "link": "https://codeforces.com//contest/1016/problem/F",
    "problemId": "204441",
    "problem_idx": "F",
    "shortId": "1016F",
    "contest_number": "1016",
    "problem_submissions": {
        "G": [
            41182699,
            41182152,
            41208590,
            41208565,
            41208533,
            41186176
        ],
        "E": [
            41176649,
            41174782,
            41175307,
            41175790,
            41176170,
            41175960,
            41179374,
            41176561,
            41175646,
            41175201,
            41179908,
            41184095,
            41179907,
            41172878,
            41174329,
            41178174,
            41177502,
            41177414,
            41176901,
            41187225,
            41186968,
            41177073,
            41179262,
            41178795,
            41177041
        ],
        "C": [
            41173342,
            41166585,
            41171261,
            41168340,
            41167894,
            41169421,
            41170385,
            41170240,
            41169071,
            41173849,
            41167601,
            41164969,
            41165695,
            41170115,
            41170716,
            41168026,
            41168718,
            41168530,
            41166879
        ],
        "F": [
            41171110,
            41181183,
            41180305,
            41183918,
            41185092,
            41183413,
            41183773,
            41181947,
            41183454,
            41180224,
            41185015,
            41178764,
            41188501,
            42098047,
            42098011,
            41192515,
            41197238,
            41187801
        ],
        "D": [
            41165638,
            41168213,
            41167884,
            41169638,
            41172158,
            41171342,
            41172221,
            41172202,
            41173341,
            41167097,
            41174977,
            41169216,
            41167575,
            41163502,
            41165286,
            41170742,
            41170760,
            41171944,
            41162657
        ],
        "B": [
            41161071,
            41162662,
            41164375,
            41162058,
            41164067,
            41164871,
            41164742,
            41161857,
            41162316,
            41161724,
            41169935,
            41161660,
            41162105,
            41161158,
            41162458,
            41162731,
            41163603,
            41163495,
            41169324
        ],
        "A": [
            41160184,
            41161181,
            41160522,
            41160409,
            41160935,
            41160830,
            41161646,
            41160641,
            41160349,
            41160611,
            41175572,
            41160281,
            41160461,
            41160190,
            41160493,
            41160416,
            41161519,
            41160623,
            41167976
        ]
    },
    "name": "F. Road Projects",
    "statement": "There are n cities in the country of Berland. Some of them are connected\r\nby bidirectional roads in such a way that there exists path, which\r\nvisits each road no more than once, between every pair of cities. Each\r\nroad has its own length. Cities are numbered from 1 to n.The travelling\r\ntime between some cities v and u is the total length of the roads on the\r\nshortest path from v to u. The two most important cities in Berland are\r\ncities 1 and n.The Berland Ministry of Transport decided to build a\r\nsingle new road to decrease the traffic between the most important\r\ncities. However, lots of people are used to the current travelling time\r\nbetween the most important cities, so the new road shouldn’t change it\r\ntoo much. The new road can only be built between such cities v and u\r\nthat v\r\nneq u and v and u aren’t already connected by some road.They came up\r\nwith m possible projects. Each project is just the length x of the new\r\nroad.Polycarp works as a head analyst at the Berland Ministry of\r\nTransport and it’s his job to deal with all those m projects. For the\r\ni-th project he is required to choose some cities v and u to build the\r\nnew road of length x_i between such that the travelling time between the\r\nmost important cities is . Unfortunately, Polycarp is not a programmer\r\nand no analyst in the world is capable to process all projects using\r\nonly pen and paper. Thus, he asks you to help him to calculate the\r\nmaximal possible travelling time between the most important cities for\r\neach project. Note that the choice of v and u can differ for different\r\nprojects.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=303030;\nint n, m;\nvector<pair<LL,LL>> v[N];\nvector<int> cen;\nvector<LL> dst;\nbool on_cen[N];\nbool go(int now, int prt, LL cur=0){\n  if(now == n){\n    cen.push_back(now);\n    dst.push_back(cur);\n    return true;\n  }\n  for(auto e: v[now]){\n    int son=e.first;\n    if(son == prt) continue;\n    if(go(son, now, cur+e.second)){\n      cen.push_back(now);\n      dst.push_back(cur);\n      return true;\n    }\n  }\n  return false;\n}\nvoid gogo(int now, int prt, LL cur, int& who, LL& dd){\n  if(now != prt){\n    if(who){\n      who=-1;\n      dd=0;\n      return;\n    }\n    who=now;\n    dd=cur;\n  }\n  for(auto e: v[now]){\n    int son=e.first;\n    if(on_cen[son] or son==prt) continue;\n    gogo(son, now, cur+e.second, who, dd);\n  }\n}\nbool flag;\nint nei[N];\nLL dei[N], bst=-1e16;\nvoid upd(LL con){\n  bst=max(bst, con);\n}\nint main(){\n  scanf(\"%d%d\", &n, &m);\n  for(int i=1; i<n; i++){\n    int ui, vi, wi;\n    scanf(\"%d%d%d\", &ui, &vi, &wi);\n    v[ui].push_back({vi, wi});\n    v[vi].push_back({ui, wi});\n  }\n  assert(go(1, 1));\n  reverse(cen.begin(), cen.end());\n  reverse(dst.begin(), dst.end());\n  for(int i: cen) on_cen[i]=true;\n  for(int i: cen){\n    gogo(i, i, 0, nei[i], dei[i]);\n    if(nei[i] == -1) flag=true;\n  }\n  for(size_t i=0; i<cen.size(); i++){\n    if(i > 1) upd(-(dst[i]-dst[i-2]));\n    if(nei[cen[i]]){\n      if(i) upd(dei[cen[i]]-(dst[i]-dst[i-1]));\n      if(i+1<cen.size()) upd(dei[cen[i]]-(dst[i+1]-dst[i]));\n      if(i and nei[cen[i-1]])\n        upd(dei[cen[i]]+dei[cen[i-1]]-(dst[i]-dst[i-1]));\n    }\n  }\n  while(m --){\n    LL x; scanf(\"%lld\", &x);\n    LL ans=dst.back();\n    if(not flag)\n      ans=min(ans, ans+bst+x);\n    printf(\"%lld\\n\", ans);\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Road Projects.json",
    "editorial_link": "https://codeforces.com/blog/entry/61015",
    "editorial": "(editorial by PikMike)Firtsly, we can notice that we get the most profit\r\nby placing the edge in a same position, no matter the query. Moreover,\r\nonce you have calculated the minimum difference you can apply to the\r\nshortest path by adding edge of the weight , you can answer the queries\r\nin each. Let the current shortest distance between and be . Then the\r\nanswer to some query is . Letâs proceed to proofs of the following.\r\nConsider any of the optimal positions for the edge of weight . Then\r\nweight will add to the answer in this position (if the path isnât\r\nalready but that is trivial). Let there be another position such that\r\nthe answer in it is less than the current one. That means that the\r\nanswer for weight in it is less by which is smaller than the first one\r\nwe got, which leads to contradiction. The second fact can deduced from\r\nthe first one.Then let me introduce the next bold statement. We root the\r\ntree with vertex . Then if there exists such a vertex in that itâs not\r\nan ancestor of vertex and the number of vertices in its subtree\r\n(inclusive) is greater than then . That is simple: just put the edge\r\nbetween the parent of this vertex and any of vertices of the subtree,\r\nthere always be such that the edge doesnât exist yet. That wonât change\r\nthe shortest path, no matter which it is.Then, we have a graph of the\r\nfollowing kind:That is the simple path between and and some vetices on\r\nit have additional children leaves. Finally, letâs proceed to the\r\nsolution.We want to choose such a pair of vertices that the sum of edge\r\non a path between them, which are also a part of the path between and\r\nplus the weights of the newly included to shortest path edges (if any)\r\nis minimal possible. Letâs precalc the sum of weights of edges from\r\nvertex to vertex and parent of vertex . Let be the weight of an edge\r\nbetween and . Then we end up with the four basic cases for these\r\nvertices and with having greater or equal number of edges on path to\r\nthan : each of the form (whether belongs to the simple path between and\r\n, whether belongs to it). doesnât belong: the answer is ; belongs,\r\ndoesnât: ; both belongs: . Each of these formulas can be broken down to\r\nparts with exacly one of the vertices. Letâs call them and . That means\r\nminimizing the result is be the same as minimizing each of the parts.We\r\nrun depth-first search on vertices which belong to a simple path between\r\nand inclusive. Maintain the minimum value of you have already passed by.\r\nTry connecting each vertex with this and also parent of the parent of\r\nthe current vertex using all the possible formulas and updating with the\r\nresulting value.Finally, after the precalc is finished, asnwer the\r\nqueries in with .Overall complexity: . (editorial by BledDest)Letâs\r\ndenote the distance from vertex to vertex in the tree as . Similarly,\r\ndenote the distance from to in the tree as .Suppose we try to add a new\r\nedge between vertices and with length . Then two new paths from to are\r\nformed: one with length , and another with length . Then the new length\r\nof shortest path becomes . So if we find two non-adjacent vertices such\r\nthat is maximum possible, then it will always be optimal to add an edge\r\nbetween these two vertices.How can we find this pair of vertices?\r\nFirstly, letâs suppose that when we pick vertex , we will try to pair it\r\nonly with vertices corresponding to the aforementioned constraint. This\r\ncan be done by sorting vertices by the value of and then for each vertex\r\npairing it only with vertices that are later than in the sorted\r\norder.How do we find the best pair for ? The best pair could be just the\r\nvertex with maximum possible , but it is not allowed to connect a vertex\r\nwith itself or its neighbour. To handle it, we may maintain a set of\r\npossible vertices , delete all neighbours of from it, pick a vertex with\r\nmaximum , and then insert all neighbours of back into the set.This\r\nsolution works in time.\r\n",
    "hint": []
}