{"link": "https://codeforces.com//contest/1016/problem/F", "problemId": "204441", "problem_idx": "F", "shortId": "1016F", "contest_number": "1016", "problem_submissions": {"G": [41182699, 41182152, 41208590, 41208565, 41208533, 41186176], "E": [41176649, 41174782, 41175307, 41175790, 41176170, 41175960, 41179374, 41176561, 41175646, 41175201, 41179908, 41184095, 41179907, 41172878, 41174329, 41178174, 41177502, 41177414, 41176901, 41187225, 41186968, 41177073, 41179262, 41178795, 41177041], "C": [41173342, 41166585, 41171261, 41168340, 41167894, 41169421, 41170385, 41170240, 41169071, 41173849, 41167601, 41164969, 41165695, 41170115, 41170716, 41168026, 41168718, 41168530, 41166879], "F": [41171110, 41181183, 41180305, 41183918, 41185092, 41183413, 41183773, 41181947, 41183454, 41180224, 41185015, 41178764, 41188501, 42098047, 42098011, 41192515, 41197238, 41187801], "D": [41165638, 41168213, 41167884, 41169638, 41172158, 41171342, 41172221, 41172202, 41173341, 41167097, 41174977, 41169216, 41167575, 41163502, 41165286, 41170742, 41170760, 41171944, 41162657], "B": [41161071, 41162662, 41164375, 41162058, 41164067, 41164871, 41164742, 41161857, 41162316, 41161724, 41169935, 41161660, 41162105, 41161158, 41162458, 41162731, 41163603, 41163495, 41169324], "A": [41160184, 41161181, 41160522, 41160409, 41160935, 41160830, 41161646, 41160641, 41160349, 41160611, 41175572, 41160281, 41160461, 41160190, 41160493, 41160416, 41161519, 41160623, 41167976]}, "name": "F. Road Projects", "statement": "There are n cities in the country of Berland. Some of them are connected\r\nby bidirectional roads in such a way that there exists path, which\r\nvisits each road no more than once, between every pair of cities. Each\r\nroad has its own length. Cities are numbered from 1 to n.The travelling\r\ntime between some cities v and u is the total length of the roads on the\r\nshortest path from v to u. The two most important cities in Berland are\r\ncities 1 and n.The Berland Ministry of Transport decided to build a\r\nsingle new road to decrease the traffic between the most important\r\ncities. However, lots of people are used to the current travelling time\r\nbetween the most important cities, so the new road shouldn\u2019t change it\r\ntoo much. The new road can only be built between such cities v and u\r\nthat v\r\nneq u and v and u aren\u2019t already connected by some road.They came up\r\nwith m possible projects. Each project is just the length x of the new\r\nroad.Polycarp works as a head analyst at the Berland Ministry of\r\nTransport and it\u2019s his job to deal with all those m projects. For the\r\ni-th project he is required to choose some cities v and u to build the\r\nnew road of length x_i between such that the travelling time between the\r\nmost important cities is . Unfortunately, Polycarp is not a programmer\r\nand no analyst in the world is capable to process all projects using\r\nonly pen and paper. Thus, he asks you to help him to calculate the\r\nmaximal possible travelling time between the most important cities for\r\neach project. Note that the choice of v and u can differ for different\r\nprojects.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=303030;\nint n, m;\nvector<pair<LL,LL>> v[N];\nvector<int> cen;\nvector<LL> dst;\nbool on_cen[N];\nbool go(int now, int prt, LL cur=0){\n  if(now == n){\n    cen.push_back(now);\n    dst.push_back(cur);\n    return true;\n  }\n  for(auto e: v[now]){\n    int son=e.first;\n    if(son == prt) continue;\n    if(go(son, now, cur+e.second)){\n      cen.push_back(now);\n      dst.push_back(cur);\n      return true;\n    }\n  }\n  return false;\n}\nvoid gogo(int now, int prt, LL cur, int& who, LL& dd){\n  if(now != prt){\n    if(who){\n      who=-1;\n      dd=0;\n      return;\n    }\n    who=now;\n    dd=cur;\n  }\n  for(auto e: v[now]){\n    int son=e.first;\n    if(on_cen[son] or son==prt) continue;\n    gogo(son, now, cur+e.second, who, dd);\n  }\n}\nbool flag;\nint nei[N];\nLL dei[N], bst=-1e16;\nvoid upd(LL con){\n  bst=max(bst, con);\n}\nint main(){\n  scanf(\"%d%d\", &n, &m);\n  for(int i=1; i<n; i++){\n    int ui, vi, wi;\n    scanf(\"%d%d%d\", &ui, &vi, &wi);\n    v[ui].push_back({vi, wi});\n    v[vi].push_back({ui, wi});\n  }\n  assert(go(1, 1));\n  reverse(cen.begin(), cen.end());\n  reverse(dst.begin(), dst.end());\n  for(int i: cen) on_cen[i]=true;\n  for(int i: cen){\n    gogo(i, i, 0, nei[i], dei[i]);\n    if(nei[i] == -1) flag=true;\n  }\n  for(size_t i=0; i<cen.size(); i++){\n    if(i > 1) upd(-(dst[i]-dst[i-2]));\n    if(nei[cen[i]]){\n      if(i) upd(dei[cen[i]]-(dst[i]-dst[i-1]));\n      if(i+1<cen.size()) upd(dei[cen[i]]-(dst[i+1]-dst[i]));\n      if(i and nei[cen[i-1]])\n        upd(dei[cen[i]]+dei[cen[i-1]]-(dst[i]-dst[i-1]));\n    }\n  }\n  while(m --){\n    LL x; scanf(\"%lld\", &x);\n    LL ans=dst.back();\n    if(not flag)\n      ans=min(ans, ans+bst+x);\n    printf(\"%lld\\n\", ans);\n  }\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "trees"], "dificulty": "2600", "interactive": false}