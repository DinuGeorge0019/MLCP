{"link": "https://codeforces.com//contest/1187/problem/D", "problemId": "365120", "problem_idx": "D", "shortId": "1187D", "contest_number": "1187", "problem_submissions": {"G": [56332310, 56340989, 56686103, 56327820, 56357942, 56357893, 56357546, 56393615, 56385554, 56337872, 56340206, 56343105, 56383525, 56344635, 56413429, 56342762, 56340438, 56341811, 56342716, 56365621], "F": [56329446, 56334290, 56324078, 56328221, 56327378, 56337303, 56342526, 56331177, 56340043, 56336355, 56334752, 56336077, 56336627, 56360333], "E": [56323030, 56330456, 56319363, 56322371, 56320247, 56329005, 56327923, 56326133, 56329409, 56326249, 56424958, 56328252, 56326656, 56325346, 56328882, 56328436, 56328661, 56323830, 56324440, 56325389], "D": [56321688, 56327439, 56325081, 56328701, 56323355, 56322789, 56358499, 56324879, 56323568, 56320080, 56323458, 56413111, 56325452, 56541360, 56321839, 56320767, 56323441], "C": [56317291, 56315455, 56314711, 56314827, 56313223, 56319121, 56318984, 56317025, 56320070, 56318484, 56425545, 56329379, 56320274, 56318352, 56316738, 56318754, 56319277, 56317240, 56316893, 56317391], "B": [56314215, 56313013, 56312493, 56311346, 56311654, 56315580, 56313289, 56312101, 56313618, 56315894, 56313703, 56315753, 56314242, 56313556, 56315340, 56314265, 56313400, 56314155, 56314393], "A": [56311354, 56311017, 56311059, 56312444, 56310978, 56312306, 56311272, 56310955, 56311255, 56311625, 56311777, 56313786, 56311277, 56310994, 56311316, 56311426, 56311025, 56311856, 56311363]}, "name": "D. Subarray Sorting", "statement": "You are given an array a_1, a_2,\r\ndots, a_n and an array b_1, b_2,\r\ndots, b_n.For one operation you can sort in non-decreasing order any\r\nsubarray a[l\r\ndots r] of the array a.For example, if a = [4, 2, 2, 1, 3, 1] and you\r\nchoose subbarray a[2\r\ndots 5], then the array turns into [4, 1, 2, 2, 3, 1]. You are asked to\r\ndetermine whether it is possible to obtain the array b by applying this\r\noperation any number of times (possibly zero) to the array a.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1200*1007;\nconst int n1=(1<<19);\n\nint n;\n\nint a[nax];\nint b[nax];\n\nint gdz[nax];\n\nmap <int,int> sta, kon;\n\nvoid nie()\n{\n\tprintf(\"NO\\n\");\n}\n\nvoid tak()\n{\n\tprintf(\"YES\\n\");\n}\n\nint drz[nax];\n\nvoid zmien(int v, int w)\n{\n\tv+=n1-1;\n\tdrz[v]=w;\n\tv>>=1;\n\twhile(v)\n\t{\n\t\tdrz[v]=min(drz[v*2], drz[v*2+1]);\n\t\tv>>=1;\n\t}\n}\n\nint czyt(int v, int a, int b, int graa, int grab)\n{\n\tif (a>=graa && b<=grab)\n\t{\n\t\treturn drz[v];\n\t}\n\tif (a>grab || b<graa)\n\t{\n\t\treturn 1e9;\n\t}\n\treturn min(\n\t\tczyt((v<<1), a, (a+b)>>1, graa, grab),\n\t\tczyt((v<<1)^1, (a+b+2)>>1, b, graa, grab)\n\t);\n}\n\nvoid test()\n{\n\tsta.clear();\n\tkon.clear();\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &a[i]);\n\t\tsta[a[i]]++;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\", &b[i]);\n\t\tkon[b[i]]++;\n\t}\n\tif (sta!=kon)\n\t{\n\t\tnie();\n\t\treturn;\n\t}\n\tvector <pii> raz, dwa;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\traz.push_back({a[i], i});\n\t\tdwa.push_back({b[i], i});\n\t}\n\tsort(raz.begin(), raz.end());\n\tsort(dwa.begin(), dwa.end());\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\ta[raz[i-1].second]=i;\n\t\tb[dwa[i-1].second]=i;\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tgdz[a[i]]=i;\n\t//~ debug() << range(a+1, a+1+n);\n\t//~ debug() << range(b+1, b+1+n);\n\tfor (int i=1; i<=n; i++)\n\t\tzmien(i, a[i]);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tint x=gdz[b[i]];\n\t\t//~ debug() << imie(x) << czyt(1, 1, n1, 1, x);\n\t\tif (czyt(1, 1, n1, 1, x)<b[i])\n\t\t{\n\t\t\tnie();\n\t\t\treturn;\n\t\t}\n\t\tzmien(x, 1e9);\n\t}\n\ttak();\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "sortings"], "dificulty": "2400", "interactive": false}