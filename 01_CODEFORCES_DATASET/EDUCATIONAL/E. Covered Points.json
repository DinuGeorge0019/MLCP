{
    "link": "https://codeforces.com//contest/1036/problem/E",
    "problemId": "216421",
    "problem_idx": "E",
    "shortId": "1036E",
    "contest_number": "1036",
    "problem_submissions": {
        "G": [
            42635175,
            42627436,
            42635430,
            42626359,
            42737989,
            42717556,
            42717524,
            42717521,
            42651041,
            42700940,
            42700625,
            54263107,
            42638239,
            42625046,
            42815013
        ],
        "B": [
            42631894,
            42635568,
            42631049,
            42642897,
            42640457,
            42621960,
            42628162,
            42621741,
            42621550,
            42618797,
            42623868,
            42633347,
            42620322,
            42622448,
            42641969,
            42624721,
            42635114,
            42625827,
            42628122,
            42634984,
            42644768
        ],
        "F": [
            42629280,
            42634265,
            42627972,
            42642001,
            42641962,
            42630707,
            42634470,
            42717490,
            42631938,
            42631850,
            42631382,
            42631058,
            42629288,
            42629020,
            42633820,
            42633355,
            42631044,
            42636476,
            42635060,
            42629290,
            42636959,
            42643700,
            42637023,
            42633474,
            42641007
        ],
        "E": [
            42626026,
            42624301,
            42644046,
            42634366,
            42634335,
            42634205,
            42630482,
            42637851,
            42633450,
            42641281,
            42638561,
            42638638,
            42639628,
            42642761,
            42644666,
            42649447,
            42648312,
            42643498,
            42631013,
            42635443,
            42642733,
            42645034,
            42634920
        ],
        "D": [
            42623581,
            42621638,
            42636628,
            42635516,
            42624651,
            42622909,
            42625901,
            42624230,
            42627616,
            42623027,
            42622706,
            42628513,
            42629952,
            42622220,
            42628717,
            42631816,
            42630498,
            42632680,
            42629722,
            42643211
        ],
        "C": [
            42622041,
            42620587,
            42639507,
            42636945,
            42623531,
            42620800,
            42624388,
            42623206,
            42625364,
            42621712,
            81464229,
            42620946,
            42626482,
            42628744,
            42619137,
            42627629,
            42632962,
            42629275,
            42630870,
            42627504,
            42631469
        ],
        "A": [
            42617741,
            42628137,
            42620189,
            42640915,
            42619770,
            42617799,
            42621837,
            42618858,
            42617734,
            42618440,
            42617898,
            42617724,
            42617895,
            42631014,
            42618014,
            42635499,
            42624408,
            42620380,
            42619824
        ]
    },
    "name": "E. Covered Points",
    "statement": "You are given n segments on a Cartesian plane. Each segment\u2019s endpoints\r\nhave integer coordinates. Segments can intersect with each other. No two\r\nsegments lie on the same line.Count the number of distinct points with ,\r\nwhich are covered by at least one segment.\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\ntypedef LL type;\ntypedef pair<type,type> Pt;\ntypedef pair<Pt,Pt> Seg;\ntypedef pair<Pt,type> Circle;\n#define X first\n#define Y second\n#define A first\n#define B second\n#define O first\n#define R second\nPt operator+( const Pt& p1 , const Pt& p2 ){\n  return { p1.X + p2.X , p1.Y + p2.Y };\n}\nPt operator-( const Pt& p1 , const Pt& p2 ){\n  return { p1.X - p2.X , p1.Y - p2.Y };\n}\nPt operator*( const Pt& tp , const type& tk ){\n  return { tp.X * tk , tp.Y * tk };\n}\nPt operator/( const Pt& tp , const type& tk ){\n  return { tp.X / tk , tp.Y / tk };\n}\ntype operator*( const Pt& p1 , const Pt& p2 ){\n  return p1.X * p2.X + p1.Y * p2.Y;\n}\ntype operator^( const Pt& p1 , const Pt& p2 ){\n  return p1.X * p2.Y - p1.Y * p2.X;\n}\ntype norm2( const Pt& tp ){\n  return tp * tp;\n}\ndouble norm( const Pt& tp ){\n  return sqrt( norm2( tp ) );\n}\nPt perp( const Pt& tp ){\n  return { tp.Y , -tp.X };\n}\nvoid scan(Pt& p){\n  p.X=getint();\n  p.Y=getint();\n}\nLL ori( const Pt& o , const Pt& a , const Pt& b ){\n  LL ret = ( a - o ) ^ ( b - o );\n  return (ret > 0) - (ret < 0);\n}\n// p1 == p2 || q1 == q2 need to be handled\nbool banana( const Pt& p1 , const Pt& p2 ,\n             const Pt& q1 , const Pt& q2 ){\n  if( ( ( p2 - p1 ) ^ ( q2 - q1 ) ) == 0 ){ // parallel\n    return false;\n  }\n  return (ori( p1, p2, q1 ) * ori( p1, p2, q2 )<=0) &&\n         (ori( q1, q2, p1 ) * ori( q1, q2, p2 )<=0);\n}\nPt interPnt( Pt p1, Pt p2, Pt q1, Pt q2, bool& res){\n  if(not banana(p1, p2, q1, q2)){\n    res=false;\n    return {0, 0};\n  }\n\tLL f1 = ( p2 - p1 ) ^ ( q1 - p1 );\n\tLL f2 = ( p2 - p1 ) ^ ( p1 - q2 );\n\tLL f = ( f1 + f2 );\n\tif(f == 0){\n    res=false;\n    return {0, 0};\n  }\n  LL rx=q1.X*f2+q2.X*f1;\n  LL ry=q1.Y*f2+q2.Y*f1;\n  if(rx % f or ry % f){\n    res=false;\n    return {0, 0};\n  }\n  res=true;\n  rx/=f;\n  ry/=f;\n  return {rx, ry};\n}\nvoid build(){\n\n}\nconst int N=1021;\nint n;\nSeg s[N];\nLL ans;\nLL gcd(LL a, LL b){\n  if(a and b) return __gcd(a, b);\n  return a+b;\n}\nset<pair<LL,LL>> tot;\nset<pair<LL,LL>> on[N];\nvoid init(){\n  n=getint();\n  for(int i=0; i<n; i++){\n    scan(s[i].A);\n    scan(s[i].B);\n    LL dx=abs(s[i].B.X-s[i].A.X);\n    LL dy=abs(s[i].B.Y-s[i].A.Y);\n    LL gg=gcd(dx, dy);\n    ans+=gg+1;\n  }\n}\nvoid solve(){\n  for(int i=0; i<n; i++)\n    for(int j=0; j<n; j++){\n      if(i == j) continue;\n      bool r=false;\n      Pt ret=interPnt(s[i].A, s[i].B, s[j].A, s[j].B, r);\n      if(not r) continue;\n      tot.insert(ret);\n      on[i].insert(ret);\n    }\n  for(int i=0; i<n; i++)\n    ans-=on[i].size();\n  ans+=tot.size();\n  printf(\"%lld\\n\", ans);\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "fft",
        "geometry",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Covered Points.json",
    "editorial_link": "https://codeforces.com/blog/entry/61727",
    "editorial": "I won\u00e2\u0080\u0099t tell all the small geometric details, just cover some major\r\npoints.The problem asks you the following thing. Sum up the total number\r\nof points covered by each segment and for each unique point subtract the\r\nnumber of segments covering it minus one. Let\u00e2\u0080\u0099s reformulate it. For each\r\nsegment add the number of points covered by it and subtract the number\r\nof points covered by it and by some already processed segment.The first\r\npart is easy. Segment covers exactly points with integer coordinates.\r\nThe proof left to the reader as an exercise.The second part can be done\r\nin the following manner. Intersect the segment with all segments ,\r\ninsert all the points of intersection into set and take its size. You\r\ncan consider only integer points of intersection and use no\r\nfloating-point numbers in your program.Overall complexity: .\r\n"
}