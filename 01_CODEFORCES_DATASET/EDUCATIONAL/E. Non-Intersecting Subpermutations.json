{"link": "https://codeforces.com//contest/1861/problem/E", "problemId": "2187865", "problem_idx": "E", "shortId": "1861E", "contest_number": "1861", "problem_submissions": {"F": [221319232, 221334797, 221343700, 221334746, 221435327], "E": [221294949, 221294627, 221307083, 221304545, 221289987, 221293214, 221302482, 221312615, 221307967, 221303480, 221309861, 221307296, 221307859, 221320123, 221304501, 221805824, 221308535, 221309691, 221307994, 221314449, 221316461], "D": [221289547, 221296942, 221291864, 221307784, 221293468, 221297421, 221296816, 221288510, 221291806, 221295562, 221296430, 221296186, 221290647, 221296713, 221298445, 221297975, 221298865, 221297626, 221298343], "C": [221285558, 221285843, 221287563, 221293257, 221282816, 221283475, 221287126, 221284366, 221286970, 221291172, 221290155, 221290726, 221290133, 221287629, 221289108, 221291690, 221291845, 221290307, 221291196, 221291877], "B": [221280891, 221279490, 221280612, 221282637, 221278148, 221277443, 221280003, 221278598, 221281862, 221281453, 221282384, 221284462, 221279905, 221283500, 221283423, 221284241, 221280164, 221284009, 221283159], "A": [221277133, 221276828, 221277503, 221276971, 221276729, 221276717, 221276917, 221276888, 221277198, 221278164, 221278677, 221280809, 221276797, 221278399, 221277159, 221277434, 221276991, 221278067, 221276850]}, "name": "E. Non-Intersecting Subpermutations", "statement": "You are given two integers n and k.For an array of length n, let\u2019s\r\ndefine its as the maximum number of contiguous subarrays of this array\r\nthat can be chosen so that: each element belongs to at most one\r\nsubarray; the length of each subarray is exactly k; each subarray\r\ncontains each integer from 1 to k exactly once. For example, if n = 10,\r\nk = 3 and the array is [1, 2, 1, 3, 2, 3, 2, 3, 1, 3], its cost is 2\r\nbecause, for example, we can choose the subarrays from the 2-nd element\r\nto the 4-th element and from the 7-th element to the 9-th element, and\r\nwe can show that it\u2019s impossible to choose more than 2\r\nsubarrays.Calculate the sum of costs over all arrays of length n\r\nconsisting of integers from 1 to k, and print it modulo 998244353.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=4007;\nconst ll mod=998244353;\n\nint n, k;\n\nll dp[nax][nax];\n\nll wyn;\n\nll pot[nax];\n\nvoid dod(ll &a, ll b)\n{\n\ta=(a+b)%mod;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &k);\n\tpot[0]=1;\n\tfor (int i=1; i<=n; i++)\n\t\tpot[i]=pot[i-1]*k%mod;\n\tdp[0][0]=1;\n\tfor (int i=0; i<n; i++)\n\t{\n\t\tll s=0;\n\t\tfor (int j=k-1; j>=0; j--)\n\t\t{\n\t\t\t//~ if (!dp[i][j])\n\t\t\t\t//~ continue;\n\t\t\tif (!j)\n\t\t\t{\n\t\t\t\tdod(dp[i+1][1], dp[i][j]*k);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdod(s, dp[i][j]);\n\t\t\t\tdod(dp[i+1][j], s);\n\t\t\t\tif (j+1<k)\n\t\t\t\t{\n\t\t\t\t\tdod(dp[i+1][j+1], dp[i][j]*(k-j));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdod(dp[i+1][0], dp[i][j]);\n\t\t\t\t\tdod(wyn, dp[i][j]*pot[n-i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "implementation", "math"], "dificulty": "2300", "interactive": false}