{"link": "https://codeforces.com//contest/1814/problem/F", "problemId": "1867161", "problem_idx": "F", "shortId": "1814F", "contest_number": "1814", "problem_submissions": {"F": [201036702, 201037659, 201028227, 201050534, 201005326, 201050567, 201051354, 201158503, 202793506, 201087367, 202961596, 202961442, 202961147, 201054424, 201057597, 201057439, 201061539], "E": [201020903, 201018973, 201013610, 201039745, 201017818, 201033040, 201037281, 201034750, 201024677, 201030462, 201026865, 201030498, 201034907, 201040830, 201037552, 201041417, 201042340, 201036940, 201015059, 201040959], "D": [201007638, 201011987, 201038257, 201026423, 201158753, 201158000, 201029908, 201043932, 201052993, 201045921, 201082509, 201058213, 201035019, 201016854, 201013631, 201010624, 201014339, 201022685, 201018472, 201019148, 201025982, 201024394, 201027376, 201024423, 201027368, 201021262, 201025020, 201019825, 201029085, 201044637, 201027275], "C": [200997961, 201000063, 201003769, 201024541, 201036517, 201006380, 201034351, 200999416, 201001849, 201000732, 201005802, 201004502, 201004247, 201004311, 201006996, 201002331, 201000424, 200997419, 201005850, 201004743], "B": [200988415, 200991922, 200990827, 200995877, 201038223, 200997671, 201032023, 200991419, 200988849, 200991883, 200998660, 200995028, 200998040, 200993967, 200992160, 200993164, 200991747, 200987467, 201004511, 200997597], "A": [200985126, 200985107, 200985078, 200985613, 201039035, 200990896, 201030957, 200985096, 200985148, 200986607, 200985454, 200988595, 200985783, 200985667, 200986043, 200985871, 200988700, 200985284, 201001220, 200986768]}, "name": "F. Communication Towers", "statement": "There are n communication towers, numbered from 1 to n, and m\r\nbidirectional wires between them. Each tower has a certain set of\r\nfrequencies that it accepts, the i-th of them accepts frequencies from\r\nl_i to r_i.Let\u2019s say that a tower b is accessible from a tower a, if\r\nthere exists a frequency x and a sequence of towers a=v_1, v_2,\r\ndots, v_k=b, where consecutive towers in the sequence are directly\r\nconnected by a wire, and each of them accepts frequency x. Note that\r\naccessibility is not transitive, i. e if b is accessible from a and c is\r\naccessible from b, then c may not be accessible from a.Your task is to\r\ndetermine the towers that are accessible from the 1-st tower.\r\n", "solutions": ["#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n\ta = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n\ta = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n\tvector<T> res;\n\tint ida = 0, idb = 0;\n\twhile (ida < a.size() || idb < b.size()) {\n\t\tif (idb == b.size()) {\n\t\t\tres.push_back(a[ida]); ida++;\n\t\t}\n\t\telse if (ida == a.size()) {\n\t\t\tres.push_back(b[idb]); idb++;\n\t\t}\n\t\telse {\n\t\t\tif (a[ida] < b[idb]) {\n\t\t\t\tres.push_back(a[ida]); ida++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.push_back(b[idb]); idb++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n\trep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << \" \"; cout << v[i];\n\t}\n\tcout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n\tif (n < 0) {\n\t\tll res = mod_pow(x, -n, m);\n\t\treturn mod_pow(res, m - 2, m);\n\t}\n\tif (abs(x) >= m)x %= m;\n\tif (x < 0)x += m;\n\t//if (x == 0)return 0;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\n//mod should be <2^31\nstruct modint {\n\tint n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) {\n\t\tif (m < 0 || mod <= m) {\n\t\t\tm %= mod; if (m < 0)m += mod;\n\t\t}\n\t\tn = m;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\ta = abs(a); b = abs(b);\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n\tif (loc >= v.size())v.resize(loc + 1, 0);\n\tv[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n\tfill(isp + 2, isp + mn, true);\n\tfor (int i = 2; i < mn; i++) {\n\t\tif (!isp[i])continue;\n\t\tps.push_back(i);\n\t\tfor (int j = 2 * i; j < mn; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\tif (res == st.begin())return st.end();\n\tres--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\treturn res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n\ta = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n\ta = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n\ta = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n\ta = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\nusing ar = array<int, 3>;\nstruct ufundo {\nprivate:\n\tvector<int> par, sz;\n\tvector<ar> mem;\n\tvector<bool> can;\npublic:\n\tufundo(int n) {\n\t\tpar.resize(n, 0);\n\t\tsz.resize(n, 1);\n\t\tcan.resize(n, false);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t\tcan[0] = true;\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) {\n\t\t\tmem.push_back({ -1,-1,-1 });\n\t\t\treturn;\n\t\t}\n\t\tar cur;\n\t\tif (sz[x] > sz[y])swap(x, y);\n\t\tcur[0] = x;\n\t\tcur[1] = y;\n\t\tcur[2] = 0;\n\t\tif (can[x])cur[2] |= 1;\n\t\tif (can[y])cur[2] |= 2;\n\t\tcan[x] = can[y] = false;\n\t\tpar[x] = y; sz[y] += sz[x];\n\t\tmem.push_back(cur);\n\t}\n\tvoid addcan(int k) {\n\t\tcan[k] = true;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint getsize(int k) {\n\t\treturn sz[find(k)];\n\t}\n\tvoid undo(int num) {\n\t\trep(_, num) {\n\t\t\tassert(mem.size());\n\t\t\tar a = mem.back(); mem.pop_back();\n\t\t\tif (a[0] < 0)continue;\n\t\t\tint x = a[0], y = a[1], s = a[2];\n\t\t\tpar[x] = x;\n\t\t\tsz[y] -= sz[x];\n\t\t\tif (can[y])can[x] = true;\n\t\t\tif (s & 1)can[x] = true;\n\t\t\tif (s & 2)can[y] = true;\n\t\t}\n\t}\n\tvector<int> query() {\n\t\tvector<int> res;\n\t\trep(i, par.size()) {\n\t\t\tif (can[i])res.push_back(i + 1);\n\t\t}\n\t\treturn res;\n\t}\n};\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tvector<int> l(n), r(n);\n\trep(i, n)cin >> l[i] >> r[i];\n\trep(i, n)r[i]++;\n\tint sz = (1 << 18);\n\tusing ar = array<int, 3>;\n\tauto resol = [&](int a, int b) {\n\t\tvector<int> res;\n\t\tvector<ar> vs;\n\t\tvs.push_back({ 0,0,sz });\n\t\twhile (!vs.empty()) {\n\t\t\tar v = vs.back(); vs.pop_back();\n\t\t\tif (v[2] <= a || b <= v[1])continue;\n\t\t\tif (a <= v[1] && v[2] <= b) {\n\t\t\t\tres.push_back(v[0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvs.push_back({ 2 * v[0] + 1,v[1],(v[1] + v[2]) / 2 });\n\t\t\t\tvs.push_back({ 2 * v[0] + 2,(v[1] + v[2]) / 2,v[2] });\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t};\n\tvector<vector<P>> ads(2 * sz - 1);\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tint cl = max(l[a], l[b]);\n\t\tint cr = min(r[a], r[b]);\n\t\tauto ks = resol(cl, cr);\n\t\tfor (int k : ks) {\n\t\t\tads[k].push_back({ a,b });\n\t\t}\n\t}\n\tufundo u(n);\n\tfunction<void(int)> dfs = [&](int k) {\n\t\tfor (auto p : ads[k]) {\n\t\t\tu.unite(p.first, p.second);\n\t\t}\n\t\tif (k >= sz - 1) {\n\t\t\tint loc = u.find(0);\n\t\t\tu.addcan(loc);\n\t\t}\n\t\telse {\n\t\t\tdfs(2 * k + 1);\n\t\t\tdfs(2 * k + 2);\n\t\t}\n\n\t\tu.undo(ads[k].size());\n\t};\n\tdfs(0);\n\tauto ans = u.query();\n\tcoutarray(ans);\n}\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//init();\n\t//while(true)\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["brute force", "divide and conquer", "dsu"], "dificulty": "2700", "interactive": false}