{
    "link": "https://codeforces.com//contest/1535/problem/E",
    "problemId": "1005286",
    "problem_idx": "E",
    "shortId": "1535E",
    "contest_number": "1535",
    "problem_submissions": {
        "F": [
            118419611,
            118426010,
            118430867,
            118426204,
            118431979,
            118430548,
            118427577,
            118427147,
            118426507,
            118434537,
            118439125,
            118438429,
            118430864,
            118436547,
            118434959,
            118453422,
            118456471,
            118456451,
            118456355,
            118456131,
            118456058,
            118456048,
            118455909,
            118455542,
            118455503,
            118455485
        ],
        "E": [
            118400147,
            118402299,
            118394572,
            118405499,
            118401297,
            118401883,
            118414866,
            118411914,
            118414294,
            118416129,
            118415333,
            118407183,
            118406610,
            118405332,
            118409528,
            118409895,
            118409924,
            118411325,
            118411281,
            118410495
        ],
        "D": [
            118386781,
            118389062,
            118387245,
            118390389,
            118390997,
            118394077,
            118396153,
            118398368,
            118392634,
            118407760,
            118505002,
            118402523,
            118396763,
            118398598,
            118397636,
            118397134,
            118395495,
            118396828,
            118399622,
            118398243,
            118400710,
            118402452
        ],
        "C": [
            118378877,
            118377465,
            118375938,
            118430752,
            118379578,
            118379282,
            118380197,
            118383333,
            118382719,
            118391368,
            118391117,
            118384601,
            118383707,
            118399476,
            118384199,
            118383290,
            118382649,
            118384396,
            118382126,
            118382935,
            118380453,
            118382432
        ],
        "B": [
            118372987,
            118446923,
            118371985,
            118371638,
            118369895,
            118374146,
            118373752,
            118371435,
            118372857,
            118372165,
            118379497,
            118375234,
            118373646,
            118372652,
            118378295,
            118372318,
            118372891,
            118372700,
            118376055,
            118373052,
            118370572
        ],
        "A": [
            118369280,
            118369165,
            118369096,
            118369133,
            118369295,
            118369220,
            118369112,
            118369384,
            118369143,
            118369677,
            118369872,
            118369144,
            118369236,
            118370094,
            118369134,
            118369278,
            118369451,
            118369228,
            118369772,
            118369174
        ]
    },
    "name": "E. Gold Transfer",
    "statement": "You are given a rooted tree. Each vertex contains a_i tons of gold,\r\nwhich costs c_i per one ton. Initially, the tree consists only a root\r\nnumbered 0 with a_0 tons of gold and price c_0 per ton.There are q\r\nqueries. Each query has one of two types: Add vertex i (where i is an\r\nindex of query) as a son to some vertex p_i; vertex i will have a_i tons\r\nof gold with c_i per ton. It\u2019s guaranteed that c_i > c_{p_i}. For a\r\ngiven vertex v_i consider the simple path from v_i to the root. We need\r\nto purchase w_i tons of gold from vertices on this path, spending the\r\nminimum amount of money. If there isn\u2019t enough gold on the path, . If we\r\nbuy x tons of gold in some vertex v the remaining amount of gold in it\r\ndecreases by x (of course, we can\u2019t buy more gold that vertex has at the\r\nmoment). For each query of the second type, calculate the resulting\r\namount of gold we bought and the amount of money we should spend.Note\r\nthat you should solve the problem in mode. It means that you can\u2019t read\r\nthe whole input at once. You can read each query only after writing the\r\nanswer for the last query, so don\u2019t forget to flush output after\r\nprinting answers. You can use functions like in and in or similar after\r\neach writing in your program. In standard (if you don\u2019t tweak I/O),\r\nflushes in and in (or in ) makes automatic flush as well.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int LOG = 19;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int q, a0, c0;\n  cin >> q >> a0 >> c0;\n  vector<int> A(1), C(1);\n  A[0] = a0;\n  C[0] = c0;\n  int N = 1;\n  vector<int> d(1, 0);\n  vector<int> P(1, -1);\n  vector<vector<int>> pp(LOG, vector<int>(1, -1));\n  vector<int> id(q + 1, -1);\n  id[0] = 0;\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 1){\n      id[i + 1] = N;\n      int p, a, c;\n      cin >> p >> a >> c;\n      p = id[p];\n      P.push_back(p);\n      A.push_back(a);\n      C.push_back(c);\n      int d2 = d[p] + 1;\n      d.push_back(d2);\n      pp[0].push_back(p);\n      for (int j = 0; j < LOG - 1; j++){\n        if (pp[j][N] == -1){\n          pp[j + 1].push_back(-1);\n        } else {\n          pp[j + 1].push_back(pp[j][pp[j][N]]);\n        }\n      }\n      N++;\n    }\n    if (t == 2){\n      int v, w;\n      cin >> v >> w;\n      v = id[v];\n      if (A[v] == 0){\n        cout << 0 << ' ' << 0 << endl;\n      } else {\n        int p = v;\n        for (int j = LOG - 1; j >= 0; j--){\n          int p2 = pp[j][p];\n          if (p2 != -1){\n            if (A[p2] > 0){\n              p = p2;\n            }\n          }\n        }\n        int D = d[v] - d[p];\n        int ans1 = 0;\n        long long ans2 = 0;\n        for (int j = D; j >= 0; j--){\n          int v2 = v;\n          for (int k = 0; k < LOG; k++){\n            if ((j >> k & 1) == 1){\n              v2 = pp[k][v2];\n            }\n          }\n          int a = min(A[v2], w);\n          ans1 += a;\n          ans2 += (long long) C[v2] * a;\n          w -= a;\n          A[v2] -= a;\n          if (w == 0){\n            break;\n          }\n        }\n        cout << ans1 << ' ' << ans2 << endl;\n      }\n    }\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "interactive",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Gold Transfer.json",
    "editorial_link": "https://codeforces.com//blog/entry/91481",
    "editorial": "Note, that for each vertex . So if we consider a path from some vertex\r\nto , the closer you are to , the cheaper the cost. In other words, it\u00e2\u0080\u0099s\r\nalways optimal to choose the highest vertex on the path with .Suppose we\r\ncan find such vertex for a given . How many times we will repeat this\r\nsearch operation? If we need to buy tons and has tons, then it\u00e2\u0080\u0099s optimal\r\nto buy tons in . After we buy tons, either becomes or becomes .Since for\r\neach vertex , can become equal to zero at most once, and since after is\r\nzero we stop buying, then there will be searches in total. The next\r\nquestion is how to find efficiently for a given ?Consider the path from\r\nto some vertex . Since we prefer to buy from higher vertices, all empty\r\nvertices on this path will form some prefix of it (possibly, empty\r\nprefix). So we can make some sort of binary search to find the first\r\nnon-empty vertex . But instead of binary search we will use binary\r\nlifting technique.If we know for each () which vertex on the path from\r\nto on distance from then we can efficiently jump up the path. Let\u00e2\u0080\u0099s\r\nfirstly jump at distance : if then we jump too high let\u00e2\u0080\u0099s not jump. But\r\nif then we can safely jump (or ). Now we know that we don\u00e2\u0080\u0099t need a\r\nsecond jump, so we try jump and so on.In other words, using binary\r\nlifting we can find the highest vertex with in steps. Also, we can\r\ncalculate array for vertex right after we add vertex to the tree, since\r\nand .The resulting complexity is .\r\n"
}