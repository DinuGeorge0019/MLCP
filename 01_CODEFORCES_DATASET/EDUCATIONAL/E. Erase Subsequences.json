{
    "link": "https://codeforces.com//contest/1303/problem/E",
    "problemId": "538604",
    "problem_idx": "E",
    "shortId": "1303E",
    "contest_number": "1303",
    "problem_submissions": {
        "G": [
            71097266,
            70883386,
            70955431,
            70955302,
            71079595,
            71079587,
            71079399,
            71079349,
            71033664,
            70936374,
            70936308,
            70936214,
            70880989,
            70891160,
            70926122,
            70886272,
            71216890,
            71204250,
            70902620,
            71200015,
            70940169,
            71279910,
            70899562,
            71278035,
            70896282,
            70900541,
            70900494
        ],
        "F": [
            71044888,
            71044744,
            70899994,
            70890051,
            70888815,
            70932923,
            70932898,
            70932421,
            70932306,
            70932207,
            70932013,
            70931555,
            70915800,
            70904497,
            70912908,
            70884185,
            138818627,
            70892348,
            70886515,
            70891950,
            71199846,
            70884407,
            70897531,
            70893903,
            70894963,
            70893107,
            70925189,
            70924800,
            70897907
        ],
        "E": [
            70868559,
            70868408,
            70868922,
            70872692,
            70869150,
            70869901,
            70874174,
            70872386,
            70874403,
            70875550,
            71199810,
            70873171,
            70863746,
            70871476,
            70905263,
            70869281,
            70875226,
            70874988,
            70881045,
            70874968,
            70882383,
            70877044
        ],
        "D": [
            70863251,
            70862650,
            70863288,
            70862684,
            70865048,
            70865462,
            70867179,
            70866583,
            70869772,
            70868436,
            71199774,
            70869707,
            70873016,
            70865851,
            70862875,
            70869379,
            70868162,
            70869500,
            70869186,
            70873860,
            70869244
        ],
        "C": [
            70859686,
            70858172,
            70859652,
            70865909,
            70861024,
            70860138,
            70862819,
            70861003,
            70864530,
            70863875,
            71199753,
            70865732,
            70856962,
            70860948,
            70858736,
            70863123,
            70860398,
            70864062,
            70861729,
            70862531,
            70860453
        ],
        "B": [
            70855213,
            70854594,
            70853630,
            70935416,
            70856554,
            70855070,
            70861321,
            70855979,
            70856395,
            70857261,
            70857192,
            71199724,
            70861383,
            70852833,
            70856458,
            70855360,
            70857332,
            70856143,
            70857430,
            70853208,
            70856253,
            70853781
        ],
        "A": [
            70849936,
            70850631,
            70849990,
            70849934,
            70850041,
            70849959,
            70849980,
            70850863,
            70852663,
            70850352,
            71199700,
            70859542,
            70849914,
            70851564,
            70849996,
            70851983,
            70850145,
            70850480,
            70850071,
            70850741,
            70850778
        ]
    },
    "name": "E. Erase Subsequences",
    "statement": "You are given a string s. You can build new string p from s using the\r\nfollowing operation : choose any subsequence s_{i_1}, s_{i_2},\r\ndots, s_{i_k} where 1\r\nle i_1 < i_2 <\r\ndots < i_k\r\nle |s|; erase the chosen subsequence from s (s can become empty);\r\nconcatenate chosen subsequence to the right of the string p (in other\r\nwords, p = p + s_{i_1}s_{i_2}\r\ndots s_{i_k}). Of course, initially the string p is empty. For example,\r\nlet s =\r\ntext{ababcd}. At first, let’s choose subsequence s_1 s_4 s_5 =\r\ntext{abc} we will get s =\r\ntext{bad} and p =\r\ntext{abc}. At second, let’s choose s_1 s_2 =\r\ntext{ba} we will get s =\r\ntext{d} and p =\r\ntext{abcba}. So we can build\r\ntext{abcba} from\r\ntext{ababcd}.Can you build a given string t using the algorithm above?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nint n, m, nxt[402][26];\nstring s, t;\nint dp[401][401];\n\nbool solve2(string t1, string t2) {\n\tdp[0][0]=-1;\n\tfor(int i=0; i<=t1.size(); ++i) {\n\t\tfor(int j=0; j<=t2.size(); ++j) {\n\t\t\tif(!i&&!j)\n\t\t\t\tcontinue;\n\t\t\tdp[i][j]=n;\n\t\t\tif(i)\n\t\t\t\tdp[i][j]=min(dp[i][j], nxt[dp[i-1][j]+1][t1[i-1]-'a']);\n\t\t\tif(j)\n\t\t\t\tdp[i][j]=min(dp[i][j], nxt[dp[i][j-1]+1][t2[j-1]-'a']);\n\t\t}\n\t}\n\treturn dp[t1.size()][t2.size()]<n;\n}\n\nvoid solve() {\n\tcin >> s >> t;\n\tn=s.size();\n\tm=t.size();\n\tfor(int i=0; i<26; ++i)\n\t\tnxt[n][i]=nxt[n+1][i]=n;\n\tfor(int i=n-1; ~i; --i) {\n\t\tmemcpy(nxt[i], nxt[i+1], sizeof(nxt[0]));\n\t\tnxt[i][s[i]-'a']=i;\n\t}\n\t//cout << nxt[0]['x'-'a'] << endl;\n\tfor(int i=0; i<m; ++i)\n\t\tif(solve2(t.substr(0, i), t.substr(i))) {\n\t\t\tcout << \"YES\\n\";\n\t\t\treturn;\n\t\t}\n\tcout << \"NO\\n\";\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint t;\n\tcin >> t;\n\twhile(t--)\n\t\tsolve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "strings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Erase Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/73872",
    "editorial": "Letâs look at string . Since we should get it using no more than two\r\nsubsequences, then where is the first subsequence and is the second one.\r\nIn the general case, can be empty. Let iterate all possible lengths of\r\n(), so we can check the existence of solution for each pair and .If weâd\r\nfix and we need to check the following: is it true that contains and as\r\nsubsequences and these subsequences donât intersect. Initially, we can\r\ninvent the following dp: let be if the prefix of of length contains\r\nprefixes of and of length and as non-intersecting subsequences. The\r\ntransitions are straingforward: if we can either skip (-indexed) and\r\nupdate . If (-indexed) then we can update and if then we can update .\r\nBut this dp has complexity in general case.But we can transform it in\r\nthe next way: instead of the boolean value, we will make as a value of\r\ndp. In other words, we will maintain as minimal appropriate prefix . But\r\nthe problem now is to define transitions.Letâs note the next fact:\r\nsuppose we have and weâd like to add next character to which is equal to\r\n. The idea is next: itâs always optimal to choose the first occurrence\r\nof in . It can be proved by contradiction: if the first occurrence is\r\nfree then itâs better to take it, or if the first occurrence will be\r\noccupied by then this will be handled by the other state with . The\r\nlogic for increasing is analogical. In result, we need to precalculate\r\narray with the next occurrence of character in suffix of one time before\r\nchoosing and and use it each time to acquire complexity.The total\r\ncomplexity if for each test case.\r\n",
    "hint": []
}