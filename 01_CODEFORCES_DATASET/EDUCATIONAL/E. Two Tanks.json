{
    "link": "https://codeforces.com//contest/1809/problem/E",
    "problemId": "1839365",
    "problem_idx": "E",
    "shortId": "1809E",
    "contest_number": "1809",
    "problem_submissions": {
        "G": [
            198800857,
            198819538,
            198819377,
            198819202,
            198818781,
            198818684,
            198816759,
            198811816,
            198806762,
            198815231,
            198818773,
            198822181,
            198828608,
            198822299,
            203672607,
            208381746,
            198835108,
            198831844,
            198829525,
            198853349,
            198853245
        ],
        "F": [
            198786104,
            198791363,
            198796885,
            198804709,
            198810152,
            198814173,
            198809216,
            198791415,
            198800965,
            198804541,
            198830839,
            198809769,
            198804908,
            198811366,
            198815172,
            198805151,
            198812101,
            198817151,
            198808903,
            198814662
        ],
        "E": [
            198775336,
            198782430,
            198786246,
            199182668,
            198794243,
            198792695,
            198792300,
            198799038,
            198776769,
            198784470,
            198788708,
            198793376,
            198789791,
            198792668,
            198843793,
            198805320,
            198800053,
            198802037,
            198804412,
            198800677,
            198799758
        ],
        "D": [
            198768775,
            198772012,
            198776224,
            198777641,
            198882283,
            198777443,
            198779801,
            198782367,
            198766389,
            198769656,
            198777387,
            198777057,
            198779683,
            198776616,
            198772288,
            198785016,
            198783361,
            198781028,
            198791791,
            198778758
        ],
        "C": [
            198764545,
            198765840,
            198768929,
            198772658,
            198770321,
            198766724,
            198776128,
            198761542,
            198765111,
            198760078,
            198766275,
            198773341,
            198769090,
            198764454,
            198770468,
            198769676,
            198767761,
            198771860,
            198780776
        ],
        "B": [
            198760964,
            198755413,
            198762260,
            198758056,
            198766256,
            198759317,
            198761525,
            198757070,
            198756430,
            198755376,
            198758155,
            198765573,
            198760583,
            198758103,
            198766309,
            198762187,
            198761139,
            198766037,
            198760442
        ],
        "A": [
            198757842,
            198756487,
            198756930,
            198755206,
            198755963,
            198755170,
            198755335,
            198755127,
            198755119,
            198756462,
            198755191,
            198755804,
            198757456,
            198755555,
            198757141,
            198756133,
            198756023,
            198760810,
            198755407
        ]
    },
    "name": "E. Two Tanks",
    "statement": "There are two water tanks, the first one fits a liters of water, the\r\nsecond one fits b liters of water. The first tank has c (0\r\nle c\r\nle a) liters of water initially, the second tank has d (0\r\nle d\r\nle b) liters of water initially.You want to perform n operations on\r\nthem. The i-th operation is specified by a single non-zero integer v_i.\r\nIf v_i > 0, then you try to pour v_i liters of water from the first tank\r\ninto the second one. If v_i < 0, you try to pour -v_i liters of water\r\nfrom the second tank to the first one.When you try to pour x liters of\r\nwater from the tank that has y liters currently available to the tank\r\nthat can fit z more liters of water, the operation only moves\r\nmin(x, y, z) liters of water.For all pairs of the initial volumes of\r\nwater (c, d) such that 0\r\nle c\r\nle a and 0\r\nle d\r\nle b, calculate the volume of water in the first tank after all\r\noperations are performed.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, a, b;\n    std::cin >> n >> a >> b;\n    \n    std::vector<int> v(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> v[i];\n    }\n    \n    std::vector ans(a + 1, std::vector<int>(b + 1));\n    for (int s = 0; s <= a + b; s++) {\n        int X = std::max(0, s - b);\n        int Y = std::min(a, s);\n        int lo = X, hi = Y;\n        for (int i = n - 1; i >= 0; i--) {\n            lo += v[i];\n            hi += v[i];\n            lo = std::max(lo, X);\n            hi = std::min(hi, Y);\n        }\n        int flo = lo, fhi = hi;\n        for (int i = 0; i < n; i++) {\n            flo = std::max(std::min(flo - v[i], Y), X);\n            fhi = std::max(std::min(fhi - v[i], Y), X);\n        }\n        for (int c = X; c <= Y; c++) {\n            int d = s - c;\n            if (c <= lo) {\n                ans[c][d] = flo;\n            } else if (c >= hi) {\n                ans[c][d] = fhi;\n            } else {\n                ans[c][d] = flo + c - lo;\n            }\n        }\n    }\n    \n    for (int c = 0; c <= a; c++) {\n        for (int d = 0; d <= b; d++) {\n            std::cout << ans[c][d] << \" \\n\"[d == b];\n        }\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Two Tanks.json",
    "editorial_link": "https://codeforces.com//blog/entry/114300",
    "editorial": "Consider a naive solution. Iterate over all pairs and apply all\r\noperations. The complexity is . The constraints obviously imply that\r\nitâs too much. What can we cut from it? Well, surely will still remain\r\nthere. Both of and also should. So we can probably only hope to turn\r\nthis into . Letâs try that.Notice that no matter what operations are\r\napplied, never changes. You can also peek at the examples and see that\r\nthe patterns are suspiciously diagonal-shaped in the matrix. Letâs try\r\nto solve the problem by fixing and calculating the answer for all values\r\nof .I will call the fixed variable . Consider case where and . Here, all\r\ncan fit into both and , so we can avoid caring about one restriction on\r\nthe operations. Weâll think what to do with large volumes later.If there\r\nare no operations, the answer for each initial is for all from to . Now\r\nconsider an operation for some . For , nothing changes. Actually, for\r\nall the result of the operation is the same as for . Hmm, but if the\r\nresult is the same, it will remain the same until the end. Same from the\r\nother side. The answers for and also get merged together. To me it kind\r\nof looks like a primitive form of DSU on these volume states: you merge\r\nsome prefix of the answers together and merge some suffix of the answers\r\ntogether.If the state was merged to either or , then itâs easy to\r\ncalculate the actual answer for that state. What happens to the\r\nremaining states? Well, since they werenât merged anywhere, the\r\noperation for them was applied fully: if was requested, all was\r\npoured.How to deal with multiple operations then? I propose the\r\nfollowing idea. When applying an operation, we only want to know which\r\nof the previously non-merged states become merged. Basically, we can\r\nsquish all previous operations into one: just sum up the signed amounts\r\nof water. Since they all were applied fully to the non-merged states,\r\nitâs completely valid. After the squish, check for the new merges.You\r\ncan actually study the structure of the answers and see that they go\r\nlike that: for some values of and such that . It isnât that important,\r\nbut it makes the code easier. You can basically calculate the length of\r\nthe merged prefix, the length of the merged suffix, then calculate the\r\nanswer at the end of the prefix in and restore all answers from it.We\r\nneglected larger values of earlier, time to return to them. Another kind\r\nof limit to each operation is added: when extra water doesnât fit in\r\nanother tank. Well, it doesnât change that much. It only makes more\r\nprefix/suffix merges. To come up with the exact formulas, I followed\r\nthese points. Something merges on an operation , when any of these\r\nholds: (not enough water in the first tank); (not enough space in the\r\nsecond tank); (not enough water in the second tank); (not enough space\r\nin the first tank). Replace all with , and you get the constraints for\r\nprefix and suffix merges.Overall complexity: .\r\n",
    "hint": []
}