{
    "link": "https://codeforces.com//contest/792/problem/D",
    "problemId": "100427",
    "problem_idx": "D",
    "shortId": "792D",
    "contest_number": "792",
    "problem_submissions": {
        "F": [
            25853903,
            25865237
        ],
        "E": [
            25848693,
            25847349,
            25847865,
            25848336,
            25849755,
            25879304,
            25850910,
            25852379,
            25850927,
            25851533,
            25846730,
            25852220,
            25853726,
            25852467,
            25850303,
            25850709,
            25864381,
            25958829
        ],
        "D": [
            25844822,
            25845472,
            25845024,
            25845925,
            25845207,
            25846638,
            25846685,
            25844772,
            25847053,
            25844370,
            25847875,
            25846005,
            25849330,
            25846978,
            25848700,
            25846288,
            25847259,
            25846482,
            25845802
        ],
        "C": [
            25843667,
            25844426,
            25843057,
            25844653,
            25843502,
            25843226,
            25845206,
            25847034,
            25852877,
            25845288,
            25853718,
            25845444,
            25844045,
            25846780,
            25853037,
            25847850,
            25843767,
            25844267,
            25844868,
            25843846
        ],
        "B": [
            25841582,
            25841630,
            25841112,
            25842707,
            25841353,
            25841339,
            25842555,
            25842111,
            25842036,
            25841205,
            25844104,
            25841963,
            25843854,
            25843428,
            25846396,
            25841879,
            25841715,
            25842437,
            25841499
        ],
        "A": [
            25840740,
            25840467,
            25840502,
            25840643,
            25840525,
            25840508,
            25840842,
            25840507,
            25840672,
            25840477,
            25843123,
            25840669,
            25840725,
            25840826,
            25845885,
            25840646,
            25840520,
            25840707,
            25840777
        ]
    },
    "name": "D. Paths in a Complete Binary Tree",
    "statement": "is a complete binary tree consisting of vertices. It means that exactly\r\none vertex is a root, and each vertex is either a leaf (and doesn\u2019t have\r\nchildren) or an inner node (and has exactly two children). All leaves of\r\na complete binary tree have the same depth (distance from the root). So\r\nis a number such that is a power of .In the picture you can see a\r\ncomplete binary tree with . Vertices are numbered from to in a special\r\nrecursive way: we recursively assign numbers to all vertices from the\r\nleft subtree (if current vertex is not a leaf), then assign a number to\r\nthe current vertex, and then recursively assign numbers to all vertices\r\nfrom the right subtree (if it exists). In the picture vertices are\r\nnumbered exactly using this algorithm. It is clear that for each size of\r\na complete binary tree exists exactly one way to give numbers to all\r\nvertices. This way of numbering is called .You have to write a program\r\nthat for given answers queries to the tree.Each query consists of an\r\ninteger number () and a string , where is the number of vertex, and\r\nrepresents the path starting from this vertex. String doesn\u2019t contain\r\nany characters other than \u201d, \u201d and \u201d, which mean traverse to the left\r\nchild, to the right child and to the parent, respectively. Characters\r\nfrom have to be processed from left to right, considering that is the\r\nvertex where the path starts. If it\u2019s impossible to process a character\r\n(for example, to go to the left child of a leaf), then you have to skip\r\nit. The answer is the number of vertex where the path represented by\r\nends.For example, if and , then the answer is .\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nll n;\nint q;\nchar s[120000];\n\nint main() {\n\tscanf(\"%lld%d\", &n, &q);\n\tfor (int i = 0; i < q; ++i) {\n\t\tll u;\n\t\tscanf(\"%lld %s\", &u, s);\n\t\tint l = strlen(s);\n\t\tll now = 1;\n\t\twhile (u % (2 * now) == 0)\n\t\t\tnow *= 2;\n\t\tfor (int j = 0; j < l; ++j) {\n\t\t\tif (s[j] == 'U') {\n\t\t\t\tif (2 * now > n)\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((u + now) % (4 * now) == 0)\n\t\t\t\t\tu -= now;\n\t\t\t\telse\n\t\t\t\t\tu += now;\n\t\t\t\tnow *= 2;\n\t\t\t}\n\t\t\telse if (s[j] == 'L') {\n\t\t\t\tif (u % 2 == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tnow /= 2;\n\t\t\t\tu -= now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (u % 2 == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tnow /= 2;\n\t\t\t\tu += now;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", u);\n\t}\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Paths in a Complete Binary Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/51254",
    "editorial": "In this editorial represents the number of vertex we are currently\r\nin.Let be the maximum integer number such that is divisible by (or the\r\nnumber of zeroes at the end of the binary representation of ). It is\r\neasy to prove that if , then is a leaf; if , then both children of are\r\nleaves, and so on. Even more, the difference between and any of his\r\nchildren is exactly . So to traverse to the left child, we have to\r\nsubtract from (if is not a leaf), and to traverse to the right child, we\r\nadd to . How can we process traversions up? Let be the number of the\r\nparent node. has exactly zeroes at the end of its binary representation,\r\nso to traverse from to , we need to either add or subtract from . And to\r\ntraverse from to we also have to either subtract or add to . One of\r\nthese operations will lead us to the number divisible by and not\r\ndivisible by , and we need to choose this operation.Time complexity is .\r\n"
}