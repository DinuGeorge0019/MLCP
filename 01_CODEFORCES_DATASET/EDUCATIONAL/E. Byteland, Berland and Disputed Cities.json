{
    "link": "https://codeforces.com//contest/962/problem/E",
    "problemId": "173206",
    "problem_idx": "E",
    "shortId": "962E",
    "contest_number": "962",
    "problem_submissions": {
        "G": [
            37172159,
            83380479,
            37224207
        ],
        "F": [
            37161607,
            37156639,
            37157368,
            37160858,
            37168373,
            37163241,
            37162662,
            37165808,
            37164621,
            37171463,
            37169577,
            37166104,
            37163342,
            37173342,
            37165989,
            37161726,
            37173135,
            37178620
        ],
        "E": [
            37153541,
            37151735,
            37153606,
            37152970,
            37152043,
            37166043,
            37160792,
            37170495,
            37160553,
            37168665,
            37158596,
            37163761,
            37162634,
            37170755,
            37158513,
            37157137,
            37165223,
            37172878,
            37170948,
            37159083,
            37152437
        ],
        "D": [
            37152390,
            37151214,
            37151627,
            37153937,
            37156427,
            37155745,
            37155575,
            37154679,
            37154153,
            37157155,
            37157760,
            37157154,
            37160470,
            37158892,
            37157799,
            37158412,
            37156233,
            37151441
        ],
        "C": [
            37150680,
            37149822,
            37150471,
            37152075,
            37154129,
            37152922,
            37153000,
            37151382,
            37151999,
            37153115,
            37152133,
            37154853,
            37152337,
            37154136,
            37153887,
            37154222,
            37150166
        ],
        "B": [
            37148859,
            37148433,
            37150807,
            37150329,
            37150353,
            37151339,
            37150005,
            37149509,
            37149604,
            37150809,
            37150669,
            37150725,
            37163838,
            37150528,
            37151572,
            37173974,
            37149032
        ],
        "A": [
            37147366,
            37147343,
            37147362,
            37147371,
            37147659,
            37147394,
            37147434,
            37147365,
            37147570,
            37147605,
            37147447,
            37147530,
            37147430,
            37147619,
            37147410,
            37174371,
            37147400
        ]
    },
    "name": "E. Byteland, Berland and Disputed Cities",
    "statement": "The cities of Byteland and Berland are located on the axis Ox. In\r\naddition, on this axis there are also disputed cities, which belong to\r\neach of the countries in their opinion. Thus, on the line Ox there are\r\nthree types of cities: the cities of Byteland, the cities of Berland,\r\ndisputed cities. Recently, the project BNET has been launched a computer\r\nnetwork of a new generation. Now the task of the both countries is to\r\nconnect the cities so that the network of this country is .The countries\r\nagreed to connect of cities with BNET cables in such a way that: If you\r\nlook at the cities of Byteland and the disputed cities, then in the\r\nresulting set of cities, any city should be reachable from any other one\r\nby one or more cables, If you look at the cities of Berland and the\r\ndisputed cities, then in the resulting set of cities, any city should be\r\nreachable from any other one by one or more cables. Thus, it is\r\nnecessary to choose a set of pairs of cities to connect by cables in\r\nsuch a way that both conditions are satisfied simultaneously. Cables\r\nallow bi-directional data transfer. Each cable connects exactly two\r\ndistinct cities.The cost of laying a cable from one city to another is\r\nequal to the distance between them. Find the minimum total cost of\r\nlaying a set of cables so that two subsets of cities (Byteland and\r\ndisputed cities, Berland and disputed cities) are connected.Each city is\r\na point on the line Ox. It is technically possible to connect the cities\r\na and b with a cable so that the city c (a < c < b) is not connected to\r\nthis cable, where a, b and c are simultaneously coordinates of the\r\ncities a, b and c.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\n\nint n;\nll ans = 0;\nvector<ll> b, r, g;\n\nvoid process(bool f = 0) {\n    if (f == 0) {\n        if (sz(g) == 1) {\n            if (sz(r)) ans += g[0]-r[0];\n            if (sz(b)) ans += g[0]-b[0];\n        } else {\n            ll a1 = 2*(g.back()-g[sz(g)-2]);\n            ll a2 = g.back()-g[sz(g)-2];\n            \n            if (sz(r)) {\n                ll mx = max(g.back()-r.back(),r.front()-g[sz(g)-2]);\n                F0R(i,sz(r)-1) mx = max(mx,r[i+1]-r[i]);\n                a2 += g.back()-g[sz(g)-2]-mx;\n            }\n            if (sz(b)) {\n                ll mx = max(g.back()-b.back(),b.front()-g[sz(g)-2]);\n                F0R(i,sz(b)-1) mx = max(mx,b[i+1]-b[i]);\n                a2 += g.back()-g[sz(g)-2]-mx;\n            }\n            ans += min(a1,a2);\n        }\n    } else {\n        if (sz(g) == 0) {\n            if (sz(r)) ans += r.back()-r.front();\n            if (sz(b)) ans += b.back()-b.front();\n        } else {\n            if (sz(r)) ans += r.back()-g.back();\n            if (sz(b)) ans += b.back()-g.back();\n        }\n    }\n    b.clear(), r.clear();\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);cin.tie(0);\n\tcin >> n;\n\tF0R(i,n) {\n\t    int p; char c; cin >> p >> c;\n\t    if (c == 'P') {\n\t        g.pb(p);\n\t        process();\n\t    } else if (c == 'R') r.pb(p);\n\t    else b.pb(p);\n\t}\n\tprocess(1);\n\tcout << ans;\n}\n\n// read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!read!\n// ll vs. int!"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Byteland, Berland and Disputed Cities.json",
    "editorial_link": "https://codeforces.com//blog/entry/58869",
    "editorial": "We will call the disputed cities purple points, the cities of Byteland\r\nblue points, and the cities of Berland red points.If there are no any\r\npurple points among the given points, you just need to connect all the\r\nneighboring red points between each other and all the neighboring blue\r\npoints with each other. Thus, the answer is the sum of the distances\r\nbetween the leftmost red point and the rightmost red point and between\r\nthe leftmost blue point and the rightmost red point.Otherwise, you\r\nfirstly should connect all the neighboring purple points with each\r\nother. Consider what you should do to connect the red points. All the\r\nred points to the left of the leftmost purple point should be connected\r\nas follows: first from the left with the second from the left, second\r\nfrom the left with the third from the left and so on. The rightmost of\r\nthese red points should be connected to the leftmost purple point. All\r\nthe red points to the right of the rightmost purple point are connected\r\nin a similar way. Consider all the gaps between the neighboring purple\r\npoints, and all the red and blue points between them. They should be\r\nconnected in one of two ways.The first way is to connect the left purple\r\nwith the leftmost red, the rightmost red with the right purple, and also\r\nconnect all the neighboring red dots. Similarly we should make for the\r\nblue points. Let the total length of the edges for such a connection is\r\nequal to .The second way is to connect the left and right purple point.\r\nNow consider only the purple points and the red ones. All adjacent\r\npoints need to be connected to each other, except those which are on the\r\nmaximum distance from all other pairs. If there are several, then we do\r\nnot connect any pair. Similarly we make for the purple and blue points.\r\nLet the total length of the edges for such a connection is equal to .If\r\nwe should connect points from the current gap in the second way,\r\notherwise, in the first.\r\n"
}