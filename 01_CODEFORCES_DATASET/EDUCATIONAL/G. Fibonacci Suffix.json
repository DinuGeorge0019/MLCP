{
    "link": "https://codeforces.com//contest/1065/problem/G",
    "problemId": "235284",
    "problem_idx": "G",
    "shortId": "1065G",
    "contest_number": "1065",
    "problem_submissions": {
        "G": [
            44147383,
            44142689,
            64875649,
            44176191,
            44151224,
            44148655
        ],
        "F": [
            44140103,
            44135158,
            44149164,
            44170796,
            44144683,
            44147682,
            44150813,
            44148584,
            44232284,
            44149497,
            44149530,
            44147181,
            44142305,
            44150346,
            44135080,
            44139962,
            44154242,
            44143115,
            44173159
        ],
        "E": [
            44135655,
            44147876,
            44135777,
            44147851,
            44136930,
            44146829,
            44136198,
            44142963,
            44143566,
            44144277,
            44137199,
            44146967,
            44148616,
            44133656,
            44142278,
            44138211,
            44126340,
            44141084,
            44146795,
            44140823
        ],
        "D": [
            44131742,
            44145378,
            44140071,
            44135909,
            44143930,
            44133600,
            44143692,
            44140442,
            44140210,
            44138706,
            44143640,
            44144314,
            44158291,
            44137709,
            44163831,
            44137474,
            44135591,
            44136408
        ],
        "C": [
            44121602,
            44120175,
            44124781,
            44126011,
            44125676,
            44121365,
            44127681,
            44121729,
            44126925,
            44123439,
            44127185,
            44130687,
            44137712,
            44126326,
            44122320,
            44121809,
            44122322,
            44129853,
            44123901,
            44127061
        ],
        "B": [
            44119298,
            44120920,
            44120806,
            44122001,
            44121592,
            44118170,
            44120220,
            44123249,
            44122493,
            44127205,
            44122290,
            44123314,
            44136224,
            44122582,
            44118742,
            44120144,
            44119274,
            44120858,
            44120292,
            44127423
        ],
        "A": [
            44117312,
            44121828,
            44117393,
            44117877,
            44118469,
            44117250,
            44118091,
            44118967,
            44118166,
            44118757,
            44117346,
            44118839,
            44117870,
            44119633,
            44117273,
            44117291,
            44117281,
            44117657,
            44117462,
            44117869
        ]
    },
    "name": "G. Fibonacci Suffix",
    "statement": "Let\u2019s denote (yet again) the sequence of Fibonacci strings:F(0) = , F(1)\r\n= , F(i) = F(i - 2) + F(i - 1), where the plus sign denotes the\r\nconcatenation of two strings.Let\u2019s denote the sequence of suffixes of\r\nstring F(i) as A(F(i)). For example, F(4) is , and A(F(4)) is the\r\nfollowing sequence: , , , , . Elements in this sequence are numbered\r\nfrom 1.Your task is to print m first characters of k-th element of\r\nA(F(n)). If there are less than m characters in this suffix, then output\r\nthe whole suffix.\r\n",
    "solutions": [
        "/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fastIO ios_base::sync_with_stdio(0)\n#define nul point(0, 0)\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define solve_system int number; cin >> number; for (int i = 0; i < number; i++) solve()\n#define solve_system_scanf int number; scanf(\"%d\", &number); for (int i = 0; i < number; i++) solve()\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst ll prost = 239;\nconst int two = 2;\nconst int th = 3;\nconst ll MOD = 998244353;\nconst ll MOD2 = MOD * MOD;\nconst int BIG = 1e9 + 239;\nconst int alf = 26;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dig = 10;\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n//easy functions\ntemplate< typename T >\ninline T gcd(T a, T b)\n{\n    while (a)\n    {\n        b %= a;\n        swap(a, b);\n    }\n    return b;\n}\ntemplate< typename T >\ninline T lcm(T a, T b) { return (a / gcd(a, b)) * b; }\ninline bool is_down(char x) { return ('a' <= x && x <= 'z'); }\ninline bool is_upper(char x) { return ('A' <= x && x <= 'Z'); }\ninline bool is_digit(char x) { return ('0' <= x && x <= '9'); }\n\n//random\nmt19937 rnd(239);\n\n//constants\nconst int M = 1e6 + 239;\nconst int N = 2 * 1e3 + 239;\nconst int L = 20;\nconst int T = (1 << 18);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 210;\n\nstring s[X], f[X];\nstring t;\nll kol[two][X];\n\nvector<int> z_function(string s)\n{\n    int n = s.length();\n    vector<int> z;\n    z.resize(n);\n    z[0] = 0;\n    int l = 0;\n    int r = 0;\n    for (int i = 1; i < n; i++)\n    {\n        z[i] = min(z[i - l], r - i);\n        if (z[i] < 0)\n            z[i] = 0;\n        while (i + z[i] < n && s[z[i]] == s[i + z[i]])\n            z[i]++;\n        if (i + z[i] > r)\n        {\n            l = i;\n            r = i + z[i];\n        }\n    }\n    return z;\n}\n\nvoid compute(int x)\n{\n    kol[0][x] = 0;\n    kol[1][x] = 0;\n    if (x <= 1)\n    {\n        if (x == 1) compute(x - 1);\n        for (int i = 0; i < (int)s[x].size() - (int)t.size(); i++)\n            if (s[x].substr(i, (int)t.size()) == t)\n                kol[s[x][i + (int)t.size()] - '0'][x]++;\n        return;\n    }\n    compute(x - 1);\n    if (kol[0][x - 1] >= INF || kol[0][x - 2] >= INF)\n        kol[0][x] = INF;\n    else\n        kol[0][x] = kol[0][x - 1] + kol[0][x - 2];\n    if (kol[1][x - 1] >= INF || kol[1][x - 2] >= INF)\n        kol[1][x] = INF;\n    else\n        kol[1][x] = kol[1][x - 1] + kol[1][x - 2];\n    string nw = \"\";\n    nw += t;\n    nw += '$';\n    nw += f[x - 2];\n    nw += s[x - 1];\n    vector<int> z = z_function(nw);\n    for (int i = (int)f[x - 2].size() - (int)t.size(); i < (int)f[x - 2].size(); i++)\n    {\n        int r = i + (int)t.size();\n        int p = (r - f[x - 2].size());\n        if (p >= (int)s[x - 1].size()) continue;\n        if (z[i + (int)t.size() + 1] == (int)t.size())\n            kol[s[x - 1][p] - '0'][x]++;\n    }\n}\n\nint main()\n{\n    #ifdef ONPC\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    s[0] = \"0\";\n    f[0] = \"0\";\n    s[1] = \"1\";\n    f[1] = \"1\";\n    for (int i = 2; i < X; i++)\n    {\n        if (s[i - 2].size() == X)\n            s[i] = s[i - 2];\n        else\n        {\n            string w = s[i - 2] + s[i - 1];\n            for (int t = 0; t < min((int)w.size(), X); t++)\n                s[i] += w[t];\n        }\n        if (f[i - 1].size() == X)\n            f[i] = f[i - 1];\n        else\n        {\n            string w = f[i - 2] + f[i - 1];\n            for (int t = 0; t < min((int)w.size(), X); t++)\n                f[i] += w[(int)w.size() - t - 1];\n            reverse(f[i].begin(), f[i].end());\n        }\n    }\n    ll n, k, m;\n    cin >> n >> k >> m;\n    t = \"\";\n    for (int i = 0; i < m; i++)\n    {\n        string ls = \"\";\n        for (int x = 0; x < min(i, (int)f[n].size()); x++)\n            ls += f[n][(int)f[n].size() - x - 1];\n        reverse(ls.begin(), ls.end());\n        if (ls == t && k == 0)\n        {\n            cout << ls;\n            return 0;\n        }\n        if (ls == t) k--;\n        compute(n);\n        if (k < kol[0][n])\n        {\n            t += '0';\n            continue;\n        }\n        t += '1';\n        k -= kol[0][n];\n    }\n    cout << t;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "strings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Fibonacci Suffix.json",
    "editorial_link": "https://codeforces.com//blog/entry/62411",
    "editorial": "Suppose we added all the suffixes of into a trie. Then we can find -th\r\nsuffix by descending the trie, checking the sizes of subtrees to choose\r\nwhere to go on each iteration.The model solution actually does that, but\r\ncomputes the sizes of subtrees without building the whole trie. Recall\r\nthat if we insert all suffixes of a string into the trie, then the size\r\nof subtree of some vertex is equal to the number of occurences of the\r\nstring denoted by this vertex in the original string.Since in our\r\nproblem the strings are recurrent, we may use prefix automaton to count\r\nthe number of occurences. To calculate the number of occurences of\r\nstring in , let\u00e2\u0080\u0099s build prefix function for , and an automaton which\r\ntells the value of prefix function, if the previous value was , and we\r\nappended to the string (the same approach is used in KMP substring\r\nsearch algorithm). Then, let\u00e2\u0080\u0099s build another automaton that will help us\r\nwork with Fibonacci string: what will be the value of prefix function,\r\nif we append to the string? For and , this automaton can be easily built\r\nusing and ; and for , we may build using the automatons for and . We\r\nalso have to keep track of the number of occurences, that can be done\r\nwith another automaton on fibonacci strings.There is a corner case when\r\nwe need to stop descending the trie; to handle it, we need to check\r\nwhether some string is a suffix of , but that can be easily made by\r\nchecking if .Each step in trie forces us to do up to three (depending on\r\nyour implementation) queries like \"count the number of occurences of\r\nsome string in \", so overall the solution works in .\r\n"
}