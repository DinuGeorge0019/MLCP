{
    "link": "https://codeforces.com//contest/1155/problem/A",
    "problemId": "334461",
    "problem_idx": "A",
    "shortId": "1155A",
    "contest_number": "1155",
    "problem_submissions": {
        "F": [
            53147227,
            53157176,
            53156900,
            53156084,
            53154052,
            53160034,
            53156325,
            53151832,
            53154755,
            53148688,
            53161959,
            53262750,
            53737446,
            53737379,
            53175185
        ],
        "E": [
            53135994,
            53143627,
            53147598,
            53158466,
            53136989,
            53158165,
            53136136,
            53151523,
            53138725,
            53138756,
            53143870,
            53141750,
            53144225,
            53141600,
            53144263,
            53142970,
            53144678,
            53143027,
            53146492,
            53139061
        ],
        "D": [
            53132284,
            53136375,
            53137845,
            53140433,
            53131955,
            53144376,
            53152771,
            53133770,
            53130242,
            53133856,
            53135466,
            53137404,
            53132457,
            53137383,
            53135331,
            53136120,
            53161942,
            53136545,
            53137490,
            53137142
        ],
        "C": [
            53130521,
            53133027,
            53132212,
            53133949,
            53152978,
            53158707,
            53154112,
            53130838,
            53134553,
            53131325,
            53130045,
            53131332,
            53135487,
            53132186,
            53132107,
            53133338,
            53132645,
            53132555,
            53132260
        ],
        "B": [
            53127872,
            53130197,
            53129680,
            53129662,
            53128390,
            53156310,
            53155054,
            53129416,
            53131929,
            53128726,
            53127750,
            53128694,
            53130002,
            53129606,
            53130017,
            53128669,
            53130637,
            53130008,
            53131121
        ],
        "A": [
            53127037,
            53127563,
            53127047,
            53127010,
            53127272,
            53156874,
            53155461,
            53127028,
            53127341,
            53127201,
            53128346,
            53127115,
            53128140,
            53127708,
            53127365,
            53130750,
            53128472,
            53127451,
            53127014
        ]
    },
    "name": "A. Reverse a Substring",
    "statement": "You are given a string s consisting of n lowercase Latin letters.Let’s\r\ndefine a substring as a contiguous subsegment of a string. For example,\r\n\"\" is a substring of \"\" (it starts in position 3 and ends in position\r\n6), but \"\" or \"\" aren’t substrings of this string. So the substring of\r\nthe string s from position l to position r is s[l; r] = s_l s_{l + 1}\r\ndots s_r.You have to choose one of the substrings of the given string\r\nand reverse it (i. e. make s[l; r] = s_r s_{r - 1}\r\ndots s_l) to obtain a string that is lexicographically. Note that it to\r\nobtain the minimum possible string.If it is impossible to reverse some\r\nsubstring of the given string to obtain a string that is less, print \"\".\r\nOtherwise print \"\" and suitable substring.String x is lexicographically\r\nless than string y, if either x is a prefix of y (and x\r\nne y), or there exists such i (1\r\nle i\r\nle min(|x|, |y|)), that x_i < y_i, and for any j (1\r\nle j < i) x_j = y_j. Here |a| denotes the length of the string a. The\r\nlexicographic comparison of strings is implemented by operator in modern\r\nprogramming languages .\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 300300;\nint n;\nchar s[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d %s\", &n, s);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (s[i] > s[i + 1]) {\n\t\t\tprintf(\"YES\\n\");\n\t\t\tprintf(\"%d %d\\n\", i + 1, i + 2);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"NO\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "sortings",
        "strings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Reverse a Substring.json",
    "editorial_link": "https://codeforces.com/blog/entry/66687",
    "editorial": "If the answer is \"\" then we always can reverse a substring of length .\r\nSo we need to check only pairs of adjacent characters in . If there is\r\nno such pair of characters for all from to then the answer is \"\".Why is\r\nit so? Consider the substring we have to reverse. It is obvious that ,\r\notherwise it is pointless to reverse this substring. Then consider two\r\ncases: then (by transitivity) and then we can go to a smaller substring\r\n(); otherwise and it means that we can take the substring .\r\n",
    "hint": []
}