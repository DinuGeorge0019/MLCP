{
    "link": "https://codeforces.com//contest/1767/problem/E",
    "problemId": "1697004",
    "problem_idx": "E",
    "shortId": "1767E",
    "contest_number": "1767",
    "problem_submissions": {
        "F": [
            185514153,
            185548652,
            185548569,
            185548494,
            185548166,
            185548104,
            185548070,
            185547990,
            185547931,
            185538816,
            185538731,
            185536681,
            185536510,
            185533881,
            185548043,
            185547524,
            185547405,
            187061027,
            188938985,
            188938874,
            188938733,
            188938538,
            188662943
        ],
        "E": [
            185496241,
            185503484,
            185495581,
            185501980,
            185500616,
            185536545,
            185506476,
            185505796,
            185502863,
            185502893,
            185509737,
            185509089,
            185503658,
            185500454,
            188653481,
            185507693,
            185510300,
            185512188,
            185507422,
            185511136,
            191847813,
            185508302
        ],
        "D": [
            185485689,
            185480567,
            185486073,
            185487205,
            185489767,
            185484058,
            185487337,
            185490632,
            185495647,
            185490973,
            185492256,
            185494935,
            185488073,
            185492422,
            185494405,
            185494252,
            185494078,
            185493034,
            185501838
        ],
        "C": [
            185476244,
            185474583,
            185478107,
            185476554,
            185481773,
            185476338,
            185483596,
            185484239,
            185478556,
            185481931,
            185485024,
            185484128,
            185481474,
            185482158,
            185486113,
            185484367,
            185484937,
            185482445,
            185483985
        ],
        "B": [
            185470025,
            185469866,
            185470325,
            185469767,
            185469743,
            185469974,
            185468835,
            185473229,
            185470539,
            185470117,
            185471331,
            185471042,
            185470304,
            185473480,
            185472801,
            185471018,
            185472578,
            185469524,
            185472904
        ],
        "A": [
            185468810,
            185468911,
            185468716,
            185468796,
            185468875,
            185468821,
            185471076,
            185576332,
            185469327,
            185470858,
            185468733,
            185468950,
            185468986,
            185469052,
            185468910,
            185469302,
            185469202,
            185470756,
            185472308,
            185469751
        ]
    },
    "name": "E. Algebra Flash",
    "statement": "New gamemode! Huh, is that it? Slightly disappointed, you boot up the\r\ngame and click on the new gamemode. It says \"\".There are n platforms,\r\nnumbered from 1 to n, placed one after another. There are m colors\r\navailable in the game, numbered from 1 to m. The i-th platform is\r\ncolored c_i.You start on the platform 1 and want to reach platform n. In\r\none move, you can jump from some platform i to platforms i + 1 or i +\r\n2.All platforms are initially deactivated (including platforms 1 and n).\r\nFor each color j, you can pay x_j coins to activate all platforms of\r\nthat color.You want to activate some platforms so that you could start\r\non an activated platform 1, jump through some activated platforms and\r\nreach an activated platform n.What\u2019s the smallest amount of coins you\r\ncan spend to achieve that?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int INF = (int)1e9;\nconst int N = 41;\nint n, m;\nint a[N];\nbool G[N][N];\nbool used[N];\nint deg[N];\nint ans = INF;\n\nvoid take(int v) {\n\tused[v] = 1;\n\tfor (int u = 0; u < n; u++)\n\t\tif (!used[u] && G[v][u])\n\t\t\tdeg[u]--;\n}\nvoid untake(int v) {\n\tused[v] = 0;\n\tfor (int u = 0; u < n; u++)\n\t\tif (!used[u] && G[v][u])\n\t\t\tdeg[u]++;\n}\n\nvoid brute(int score) {\n\tint V = -1;\n\tfor (int v = 0; v < n; v++) if (!used[v]) {\n\t\tif (V == -1 || deg[v] > deg[V])\n\t\t\tV = v;\n\t}\n\tif (V == -1 || deg[V] == 0) {\n\t\tans = min(ans, score);\n\t\treturn;\n\t}\n\tif (deg[V] == 1) {\n\t\tfor (int v = 0; v < n; v++) if (!used[v]) {\n\t\t\tint u = v + 1;\n\t\t\twhile(u < n && (used[u] || !G[v][u])) u++;\n\t\t\tif (u == n) continue;\n\t\t\tscore += min(a[v], a[u]);\n\t\t}\n\t\tans = min(ans, score);\n\t\treturn;\n\t}\n\ttake(V);\n\tbrute(score + a[V]);\n\tuntake(V);\n\tvector<int> taken;\n\tfor (int v = 0; v < n; v++) if (!used[v] && G[V][v]) {\n\t\ttake(v);\n\t\tscore += a[v];\n\t\ttaken.push_back(v);\n\t}\n\tbrute(score);\n\treverse(all(taken));\n\tfor (int v : taken) untake(v);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &m, &n);\n\tint x, y;\n\tscanf(\"%d\", &x);\n\tx--;\n\tused[x] = 1;\n\tfor (int i = 1; i < m; i++) {\n\t\tscanf(\"%d\", &y);\n\t\ty--;\n\t\tG[x][y] = G[y][x] = 1;\n\t\tx = y;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tused[y] = 1;\n\tint score = 0;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (G[v][v]) used[v] = 1;\n\t\tif (used[v]) {\n\t\t\tscore += a[v];\n\t\t}\n\t}\n\tfor (int v = 0; v < n; v++) if (!used[v]) {\n\t\tfor (int u = 0; u < n; u++) if (!used[u] && G[v][u])\n\t\t\tdeg[u]++;\n\t}\n\tbrute(score);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "graphs",
        "math",
        "meet-in-the-middle",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Algebra Flash.json",
    "editorial_link": "https://codeforces.com//blog/entry/110225",
    "editorial": "Imagine we bought some subset of colors. How to check if there exists a\r\npath from to ?Well, we could write an easy dp. However, it\u00e2\u0080\u0099s not\r\nimmediately obvious where to proceed from that. You can\u00e2\u0080\u0099t really\r\nimplement buying colors inside the dp, because you should somehow know\r\nif you bought the current color before, and that\u00e2\u0080\u0099s not really viable\r\nwithout storing a lot of information.Let\u00e2\u0080\u0099s find another approach. Let\u00e2\u0080\u0099s\r\ntry to deduce when the subset is bad the path doesn\u00e2\u0080\u0099t exist. Trivial\r\ncases: or aren\u00e2\u0080\u0099t bought. Now, if there are two consecutive platforms\r\nsuch that their colors aren\u00e2\u0080\u0099t bought, the path doesn\u00e2\u0080\u0099t exist. Otherwise,\r\nif there are no such platforms, you can show that the path always\r\nexists.In particular, that implies that among all pairs of consecutive\r\nplatforms, at least one color of the pair have to be bought. If the\r\ncolors of the pair are the same, then it\u00e2\u0080\u0099s just that this color have to\r\nbe bought.The next step is probably hard to get without prior\r\nexperience. Notice how the condition is similar to a well-known graph\r\nproblem called \"vertex cover\". That problem is about finding a set of\r\nvertices in an undirected graph such that all graph edges have at least\r\none of their endpoints in the set. In particular, our problem would be\r\nto find a vertex cover of minimum cost.That problem is known to be\r\nNP-hard, thus the constraints. We can\u00e2\u0080\u0099t solve it in polynomial time but\r\nwe\u00e2\u0080\u0099ll attempt to it faster than the naive approach in .Let\u00e2\u0080\u0099s start with\r\nthis approach anyway. We can iterate over a mask of taken vertices and\r\ncheck if that mask is ok. In order to do that, we iterate over edges and\r\ncheck if at least vertex is taken for each of them.Again, having a bit\r\nof prior experience, one could tell from the constraints that the\r\nintended solution involves meet-in-the-middle technique.Let\u00e2\u0080\u0099s iterate\r\nover the mask of taken vertices among vertices from to . Then over the\r\nmask of taken vertices from to . The conditions on edges split them into\r\nthree groups: the edges that are completely in , the edges that are\r\ncompletely in and the edges that have one endpoint in and another\r\nendpoint in .First two types are easy to check, but how to force the\r\nthird type to be all good? Consider the vertices that are not taken into\r\n. All edges that have them as one of the endpoints will turn out bad if\r\nwe don\u00e2\u0080\u0099t take their other endpoints into . That gives us a minimal set\r\nof constraints for each : a mask that includes all vertices from the\r\nsecond half that have edges to at least one of non-taken vertex in .Then\r\nis good if it has as its submask. Thus, we would want to update the\r\nanswer with the of the minimum cost such that its is a submask of\r\n.Finally, let store the minimum cost of some such that its is a submask\r\nof . Initialize the with the exact for each . Then push the values of up\r\nby adding any new non-taken bit to each mask.When iterating over , check\r\nif it\u00e2\u0080\u0099s good for edges of the second kind and update the answer with\r\n.Overall complexity: .\r\n"
}