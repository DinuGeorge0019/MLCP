{
    "link": "https://codeforces.com//contest/1525/problem/E",
    "problemId": "987015",
    "problem_idx": "E",
    "shortId": "1525E",
    "contest_number": "1525",
    "problem_submissions": {
        "D": [
            116596850,
            116594983,
            116556621,
            116344048,
            116344302,
            116349055,
            116346341,
            116347417,
            116335585,
            116344826,
            116338508,
            116335707,
            116341307,
            116349851,
            116341668,
            116351051,
            116353738,
            116347590,
            116343356,
            116345813,
            116346453,
            116348324
        ],
        "F": [
            116372175,
            116372025,
            116380530,
            116381098,
            116381539,
            116374296,
            116382706,
            116380101,
            116523025,
            116385915,
            116383799,
            116377898,
            116380915,
            116382591,
            116385839,
            116395698
        ],
        "E": [
            116351338,
            116353665,
            116354964,
            116353294,
            116353957,
            116361966,
            116348163,
            116347670,
            116343533,
            116351101,
            116353993,
            116360946,
            116355058,
            116358519,
            116354709,
            116351286,
            116352542,
            116358011,
            116357879
        ],
        "C": [
            116334549,
            116339182,
            116340233,
            116340613,
            116342489,
            116350963,
            116337654,
            116366806,
            116362628,
            116359745,
            116345739,
            116358283,
            116349150,
            116349846,
            116332723,
            116338076,
            116338563,
            116342647,
            116341792
        ],
        "B": [
            116321920,
            116322956,
            116323732,
            116325314,
            116321887,
            116323618,
            116323021,
            116322464,
            116326670,
            116325875,
            116323111,
            116331257,
            116322276,
            116322144,
            116322587,
            116325439,
            116323730,
            116321987,
            116325764
        ],
        "A": [
            116320634,
            116320705,
            116320798,
            116320688,
            116320665,
            116321107,
            116320786,
            116320654,
            116321098,
            116320865,
            116320734,
            116327758,
            116320593,
            116320655,
            116320605,
            116320657,
            116320652,
            116320617,
            116320774
        ]
    },
    "name": "E. Assimilation IV",
    "statement": "Monocarp is playing a game \"Assimilation IV\". In this game he manages a\r\ngreat empire: builds cities and conquers new lands.Monocarp\u2019s empire has\r\nn cities. In order to conquer new lands he plans to build . The game is\r\nturn-based and, since Monocarp is still amateur, he builds exactly one\r\nMonument per turn.Monocarp has m points on the map he\u2019d like to control\r\nusing the constructed Monuments. For each point he knows the distance\r\nbetween it and each city. Monuments work in the following way: when\r\nbuilt in some city, a Monument controls all points at distance at most 1\r\nto this city. Next turn, the Monument controls all points at distance at\r\nmost 2, the turn after at distance at most 3, and so on. Monocarp will\r\nbuild n Monuments in n turns and his empire will conquer all points that\r\nare controlled by at least one Monument.Monocarp can\u2019t figure out any\r\nstrategy, so during each turn he will choose a city for a Monument\r\nrandomly among all remaining cities (cities without Monuments). Monocarp\r\nwants to know how many points (among m of them) he will conquer at the\r\nend of turn number n. Help him to calculate the expected number of\r\nconquered points!\r\n",
    "solutions": [
        "/*\n    author:  Maksim1744\n    created: 16.05.2021 11:28:52\n*/\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp   make_pair\n#define pb   push_back\n#define eb   emplace_back\n\n#define sum(a)     ( accumulate ((a).begin(), (a).end(), 0ll))\n#define mine(a)    (*min_element((a).begin(), (a).end()))\n#define maxe(a)    (*max_element((a).begin(), (a).end()))\n#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())\n#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())\n#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())\n#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())\n\ntemplate<typename T>             vector<T>& operator--            (vector<T> &v){for (auto& i : v) --i;            return  v;}\ntemplate<typename T>             vector<T>& operator++            (vector<T> &v){for (auto& i : v) ++i;            return  v;}\ntemplate<typename T>             istream& operator>>(istream& is,  vector<T> &v){for (auto& i : v) is >> i;        return is;}\ntemplate<typename T>             ostream& operator<<(ostream& os,  vector<T>  v){for (auto& i : v) os << i << ' '; return os;}\ntemplate<typename T, typename U> pair<T,U>& operator--           (pair<T, U> &p){--p.first; --p.second;            return  p;}\ntemplate<typename T, typename U> pair<T,U>& operator++           (pair<T, U> &p){++p.first; ++p.second;            return  p;}\ntemplate<typename T, typename U> istream& operator>>(istream& is, pair<T, U> &p){is >> p.first >> p.second;        return is;}\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, pair<T, U>  p){os << p.first << ' ' << p.second; return os;}\ntemplate<typename T, typename U> pair<T,U> operator-(pair<T,U> a, pair<T,U> b){return mp(a.first-b.first, a.second-b.second);}\ntemplate<typename T, typename U> pair<T,U> operator+(pair<T,U> a, pair<T,U> b){return mp(a.first+b.first, a.second+b.second);}\ntemplate<typename T, typename U> void umin(T& a, U b){if (a > b) a = b;}\ntemplate<typename T, typename U> void umax(T& a, U b){if (a < b) a = b;}\n\n#ifdef HOME\n#define SHOW_COLORS\n#include \"C:/C++ libs/print.cpp\"\n#else\n#define show(...) void(0)\n#define mclock    void(0)\n#define shows     void(0)\n#define debug  if (false)\n#endif\n\nnamespace mint_ns {\ntemplate<auto P>\nstruct Modular {\n    using value_type = decltype(P);\n    value_type value;\n\n    Modular(ll k = 0) : value(norm(k)) {}\n\n    friend Modular<P>& operator += (      Modular<P> &n, const Modular<P>& m) { n.value += m.value; if (n.value >= P) n.value -= P; return n; }\n    friend Modular<P>  operator +  (const Modular<P> &n, const Modular<P>& m) { Modular<P> r = n; return r += m; }\n\n    friend Modular<P>& operator -= (      Modular<P> &n, const Modular<P>& m) { n.value -= m.value; if (n.value < 0)  n.value += P; return n; }\n    friend Modular<P>  operator -  (const Modular<P> &n, const Modular<P>& m) { Modular<P> r = n; return r -= m; }\n    friend Modular<P>  operator -  (const Modular<P> &n)                      { return Modular<P>(-n.value); }\n\n    friend Modular<P>& operator *= (      Modular<P> &n, const Modular<P>& m) { n.value = n.value * 1ll * m.value % P; return n; }\n    friend Modular<P>  operator *  (const Modular<P> &n, const Modular<P>& m) { Modular<P> r = n; return r *= m; }\n\n    friend Modular<P>& operator /= (      Modular<P> &n, const Modular<P>& m) { return n *= m.inv(); }\n    friend Modular<P>  operator /  (const Modular<P> &n, const Modular<P>& m) { Modular<P> r = n; return r /= m; }\n\n    Modular<P>& operator ++                    ()       { return *this += 1; }\n    Modular<P>& operator --                    ()       { return *this -= 1; }\n    Modular<P>  operator ++                 (int)       { Modular<P> r = *this; *this += 1; return r; }\n    Modular<P>  operator --                 (int)       { Modular<P> r = *this; *this -= 1; return r; }\n\n    friend bool operator == (const Modular<P> &n, const Modular<P>& m) { return n.value == m.value; }\n    friend bool operator != (const Modular<P> &n, const Modular<P>& m) { return n.value != m.value; }\n\n    explicit    operator       int() const { return value; }\n    explicit    operator      bool() const { return value; }\n    explicit    operator long long() const { return value; }\n\n    constexpr static value_type mod()      { return     P; }\n\n    value_type norm(ll k) {\n        if (!(-P <= k && k < P)) k %= P;\n        if (k < 0) k += P;\n        return k;\n    }\n\n    Modular<P> inv() const {\n        value_type a = value, b = P, x = 0, y = 1;\n        while (a != 0) { value_type k = b / a; b -= k * a; x -= k * y; swap(a, b); swap(x, y); }\n        return Modular<P>(x);\n    }\n};\ntemplate<auto P> Modular<P> pow(Modular<P> m, ll p) {\n    Modular<P> r(1);\n    while (p) {\n        if (p & 1) r *= m;\n        m *= m;\n        p >>= 1;\n    }\n    return r;\n}\n\ntemplate<auto P> ostream& operator << (ostream& o, const Modular<P> &m) { return o << m.value; }\ntemplate<auto P> istream& operator >> (istream& i,       Modular<P> &m) { ll k; i >> k; m.value = m.norm(k); return i; }\ntemplate<auto P> string   to_string(const Modular<P>& m) { return to_string(m.value); }\n\n// using Mint = Modular<1000000007>;\nusing Mint = Modular<998244353>;\n// using Mint = long double;\n\nvector<Mint> f, fi;\nvoid init_C(int n) {\n    f.assign(n, 1); fi.assign(n, 1);\n    for (int i = 2; i < n; ++i) f[i] = f[i - 1] * i;\n    fi.back() = Mint(1) / f.back();\n    for (int i = n - 2; i >= 0; --i) fi[i] = fi[i + 1] * (i + 1);\n}\nMint C(int n, int k) {\n    if (k < 0 || k > n) return 0;\n    else return f[n] * fi[k] * fi[n - k];\n}\n}\nusing namespace mint_ns;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> d(n, vector<int>(m));\n    cin >> d;\n\n    init_C(n + m);\n\n    Mint tot = 0;\n\n    for (int i = 0; i < m; ++i) {\n        vector<int> v(n);\n        for (int j = 0; j < n; ++j) {\n            v[j] = d[j][i];\n        }\n        sort(v.begin(), v.end());\n        show(v);\n        // v : []\n        // rel = a[1..n]\n        // a[1] > i\n        Mint ans = 1;\n        for (int i = 0; i < v.size(); ++i) {\n            ans *= C(min(n, v[i] - 1) - i, 1);\n        }\n        show(ans);\n        ans /= f[n];\n        show(ans);\n        tot += 1 - ans;\n    }\n    cout << tot << '\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "probabilities",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Assimilation IV.json",
    "editorial_link": "https://codeforces.com//blog/entry/90793",
    "editorial": "Let be the indicator function equal to if the -th point is controlled by\r\nany city and otherwise. Then the expected number of controlled points\r\ncan be written as (by linearity of expected value).The expected value of\r\nthe indicator function is equal to the probability of this function\r\nequal to (). In other words, for each point we need to calculate the\r\nprobability of this point being controlled by any city.Let\u00e2\u0080\u0099s instead\r\ncalculate the probability of point not being controlled by any city.\r\nSuppose, the distance between point and some city is equal to . If we\r\nbuild a Monument in city at step (zero indexed) then the point will be\r\ncontrolled by city . But building the Monument at any step greater or\r\nequal than is fine.Let\u00e2\u0080\u0099s for each turn calculate the number of cities\r\nthat you can build Monument in starting this turn as . Our task is to\r\ncalculate the number of permutations that are consistent with array .At\r\nfirst turn, we can choose one of cities, at second turn we have choices,\r\nat third step choices, and so on. Using this idea, it\u00e2\u0080\u0099s not hard to\r\ncalculate the number of good permutations and then the initial\r\nprobablity .The expected value .\r\n"
}