{
    "link": "https://codeforces.com//contest/1861/problem/B",
    "problemId": "2187862",
    "problem_idx": "B",
    "shortId": "1861B",
    "contest_number": "1861",
    "problem_submissions": {
        "F": [
            221319232,
            221334797,
            221343700,
            221334746,
            221435327
        ],
        "E": [
            221294949,
            221294627,
            221307083,
            221304545,
            221289987,
            221293214,
            221302482,
            221312615,
            221307967,
            221303480,
            221309861,
            221307296,
            221307859,
            221320123,
            221304501,
            221805824,
            221308535,
            221309691,
            221307994,
            221314449,
            221316461
        ],
        "D": [
            221289547,
            221296942,
            221291864,
            221307784,
            221293468,
            221297421,
            221296816,
            221288510,
            221291806,
            221295562,
            221296430,
            221296186,
            221290647,
            221296713,
            221298445,
            221297975,
            221298865,
            221297626,
            221298343
        ],
        "C": [
            221285558,
            221285843,
            221287563,
            221293257,
            221282816,
            221283475,
            221287126,
            221284366,
            221286970,
            221291172,
            221290155,
            221290726,
            221290133,
            221287629,
            221289108,
            221291690,
            221291845,
            221290307,
            221291196,
            221291877
        ],
        "B": [
            221280891,
            221279490,
            221280612,
            221282637,
            221278148,
            221277443,
            221280003,
            221278598,
            221281862,
            221281453,
            221282384,
            221284462,
            221279905,
            221283500,
            221283423,
            221284241,
            221280164,
            221284009,
            221283159
        ],
        "A": [
            221277133,
            221276828,
            221277503,
            221276971,
            221276729,
            221276717,
            221276917,
            221276888,
            221277198,
            221278164,
            221278677,
            221280809,
            221276797,
            221278399,
            221277159,
            221277434,
            221276991,
            221278067,
            221276850
        ]
    },
    "name": "B. Two Binary Strings",
    "statement": "You are given two strings a and b of equal length, consisting of only\r\ncharacters and/or ; both strings start with character and end with\r\ncharacter . You can perform the following operation any number of times\r\n(possibly zero): choose one of the strings and two characters in it;\r\nthen turn all characters between them into those characters. Formally,\r\nyou choose one of these two strings (let the chosen string be s), then\r\npick two integers l and r such that 1\r\nle l < r\r\nle |s| and s_l = s_r, then replace every character s_i such that l < i <\r\nr with s_l.For example, if the chosen string is , you can transform it\r\ninto one of the following strings by applying one operation: if you\r\nchoose l = 1 and r = 3; if you choose l = 1 and r = 5; if you choose l =\r\n3 and r = 5; if you choose l = 4 and r = 6; if you choose l = 2 and r =\r\n6; if you choose l = 2 and r = 4. You have to determine if it’s possible\r\nto make the given strings equal by applying this operation any number of\r\ntimes.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nvoid ans(int v)\n{\n\tif (v)\n\t\tprintf(\"YES\\n\");\n\telse\n\t\tprintf(\"NO\\n\");\n}\n\nint n;\nchar raz[nax];\nchar dwa[nax];\n\nvoid test()\n{\n\tscanf(\"%s\", raz+1);\n\tscanf(\"%s\", dwa+1);\n\tn=strlen(raz+1);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tif (raz[i]=='0' && dwa[i]=='0' && raz[i+1]=='1' && dwa[i+1]=='1')\n\t\t{\n\t\t\tans(1);\n\t\t\treturn;\n\t\t}\n\t}\n\tans(0);\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Two Binary Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/119964",
    "editorial": "If the answer is , we can always bring both strings to the form (some\r\nprefix consists of zeros, some suffix consists of ones, and all zeroes\r\nare before all ones). Itâs true because after we make both strings\r\nequal, we can apply another operation with , where is the minimum index\r\nwhere both strings have after we made them equal. For example, in the\r\nfirst test case, the strings are equal to after applying all operations\r\nconsidered in the statement. We can turn them into the string by\r\napplying operation with .Okay, now letâs try to find out when we can\r\ntransform a string into the form . We claim that itâs possible to\r\ntransform the string into the form \" first elements are zeroes, all the\r\nremaining elements are ones\" if and only if and : if and , we can apply\r\ntwo operations with and , and the string turns into the form \" first\r\nelements are zeroes, all the remaining elements are ones\"; however, if\r\nthatâs not the case, then either , or and . In the former case, we need\r\nto change one of these two elements; but since they are equal and\r\nadjacent, every operation on them will affect them both, so itâs\r\nimpossible to change only one of them. In the latter case, we need to\r\nset either to or to first; and when we do it, the elements become equal,\r\nand every operation on them will affect them both. So, itâs impossible\r\nto bring the string into the form \" first elements are zeroes, all the\r\nremaining elements are ones\". So, the answer is if there is an index\r\nsuch that and . Otherwise, the answer is .\r\n",
    "hint": []
}