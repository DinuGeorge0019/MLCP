{
    "link": "https://codeforces.com//contest/1792/problem/F2",
    "problemId": "1749565",
    "problem_idx": "F2",
    "shortId": "1792F2",
    "contest_number": "1792",
    "problem_submissions": {
        "F2": [
            190375653,
            190403355,
            190403314,
            190376566,
            190371354,
            190371009,
            190378681,
            190390688,
            190380339,
            190390744,
            190397281,
            190395571,
            190396332,
            190405095,
            190396914,
            190408873,
            190408290,
            190408068,
            190403016,
            190399709,
            190399068,
            190440777,
            190401995
        ],
        "F1": [
            190360560,
            190376613,
            190370799,
            190366049,
            190372835,
            190357166,
            190380441,
            190390644,
            190395529,
            190392693,
            190394679,
            190392495,
            190385352,
            190378233,
            190371980,
            190376961,
            190394240,
            190393976,
            190392996,
            190356477,
            190392540,
            190390220,
            190391148,
            190435798,
            190392761
        ],
        "E": [
            190349536,
            190396415,
            190356797,
            190355921,
            190355685,
            190354329,
            190356654,
            190379338,
            190367695,
            190364381,
            190379913,
            190372928,
            190374531,
            190346879,
            190354441,
            190356992,
            190357830,
            190369017,
            190404398,
            190369702,
            190375086,
            190345346,
            190361270
        ],
        "D": [
            190338681,
            190342485,
            190377665,
            190342856,
            190335191,
            190347677,
            190340391,
            190336758,
            190364512,
            190353489,
            190336022,
            190340377,
            190341608,
            190336712,
            190338416,
            190338462,
            190342927,
            190342951,
            190340969,
            190356126,
            190343824
        ],
        "C": [
            190332032,
            190336067,
            190327325,
            190335874,
            190328548,
            190335825,
            190331257,
            190329975,
            190341574,
            190346406,
            190329101,
            190331331,
            190332174,
            190331190,
            190328589,
            190329328,
            190333145,
            190331745,
            190324986,
            190335758
        ],
        "B": [
            190326313,
            190322698,
            190320989,
            190331751,
            190324446,
            190330720,
            190326021,
            190327400,
            190330429,
            190335776,
            190324890,
            190326657,
            190333559,
            190327470,
            190325870,
            190324745,
            190327323,
            190329410,
            190330842,
            190329835
        ],
        "A": [
            190321850,
            190318780,
            190318690,
            190319485,
            190319112,
            190319183,
            190319784,
            190318833,
            190324148,
            190321022,
            190318836,
            190320391,
            190319287,
            190319729,
            190318884,
            190319911,
            190320170,
            190319083,
            190321001,
            190322167
        ]
    },
    "name": "F2. Graph Coloring  hard version ",
    "statement": "You are given an undirected complete graph on n vertices. A complete\r\ngraph is a graph where each pair of vertices is connected by an edge.\r\nYou have to paint the edges of the graph into two colors, red and blue\r\n(each edge will have one color).A set of vertices S is if, for every\r\npair of vertices (v_1, v_2) such that v_1\r\nin S and v_2\r\nin S, there exists a path from v_1 to v_2 that goes only through red\r\nedges and vertices from S. Similarly, a set of vertices S is if, for\r\nevery pair of vertices (v_1, v_2) such that v_1\r\nin S and v_2\r\nin S, there exists a path from v_1 to v_2 that goes only through blue\r\nedges and vertices from S.You have to paint the graph in such a way\r\nthat: there is at least one red edge; there is at least one blue edge;\r\nfor each set of vertices S such that |S|\r\nge 2, S is either red-connected or blue-connected, but . Calculate the\r\nnumber of ways to paint the graph, and print it modulo 998244353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define int long long\n#define mod 998244353\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint dp[50005];\nint jc[50005],njc[50005];\nint ksm(int n,int k)\n{\n\tint ans=1;\n\twhile(k>=1)\n\t{\n\t\tif(k&1)ans=1LL*ans*n%mod;\n\t\tk>>=1;\n\t\tn=1LL*n*n%mod;\n\t}\n\treturn ans;\n}\nint a[500005],b[500005];\nint r[4000001],tr,lll;\nvoid ntt(int* f,int flag)\n{\n\tfor(int i=1;i<tr;i++)if(i<r[i])swap(f[i],f[r[i]]);\n\tfor(int j=1;j<tr;j<<=1)\n\t{\n\t\tint tt=ksm(3,(mod-1)/(j<<1));\n\t\tif(flag==-1)tt=ksm(tt,mod-2);\n\t\tfor(int k=0;k<tr;k+=(j<<1))\n\t\t{\n\t\t\tint t=1;\n\t\t\tfor(int l=0;l<j;l++,t=1LL*t*tt%mod)\n\t\t\t{\n\t\t\t\tint sth=f[k+l],sth2=1LL*f[j+k+l]*t%mod;\n\t\t\t\tf[k+l]=(sth+sth2)%mod;\n\t\t\t\tf[k+j+l]=(sth+mod-sth2)%mod;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag==-1)\n\t{\n\t\tint sth=ksm(tr,mod-2);\n\t\tfor(int i=0;i<tr;i++)f[i]=1LL*f[i]*sth%mod;\n\t}\n}\nsigned main()\n{\n\tint n;\n\tn=read();\n\tjc[0]=1;\n\tfor(int i=1;i<=50000;i++)jc[i]=1LL*i*jc[i-1]%mod;\n\tnjc[50000]=ksm(jc[50000],mod-2);\n\tfor(int i=49999;i>=0;i--)njc[i]=1LL*(i+1)*njc[i+1]%mod;\n\tdp[0]=0;\n\tdp[1]=1;\n\tfor(int i=2;i<=5001;i++)\n\t{\n\t\tfor(int j=1;j<=i-1;j++)\n\t\t{\n\t\t\tdp[i]=(dp[i]+2LL*dp[j]*dp[i-j]%mod*jc[i-1]%mod*njc[j-1]%mod*njc[i-j]%mod)%mod;\n\t\t}\n\t\tdp[i]=(dp[i]+mod-1LL*(i-1)*dp[i-1]%mod)%mod;\n\t}\n\t//printf(\"%lld\\n\",dp[5001]);\n\tfor(int sth=2;sth<=10;sth++)\n\t{\n\t\tint cs=(sth-1)*5000;\n\t\ttr=1;\n\t\tlll=0;\n\t\twhile(tr<=2*cs)\n\t\t{\n\t\t\ttr<<=1;\n\t\t\tlll++;\n\t\t}\n\t\tfor(int i=0;i<tr;i++)r[i]=(r[i>>1]>>1)|((i&1)<<(lll-1));\n\t\tfor(int i=0;i<=cs;i++)a[i]=1LL*njc[i-1]*dp[i]%mod;\n\t\tfor(int i=0;i<=cs;i++)b[i]=1LL*njc[i]*dp[i]%mod;\n\t\tfor(int i=cs+1;i<tr;i++)a[i]=b[i]=0;\n\t\tntt(a,1);\n\t\tntt(b,1);\n\t\tfor(int i=0;i<tr;i++)a[i]=1LL*a[i]*b[i]%mod;\n\t\tntt(a,-1);\n\t\tfor(int i=(sth-1)*5000+1;i<=sth*5000;i++)\n\t\t{\n\t\t\tdp[i]=2LL*a[i]*jc[i-1]%mod;\n\t\t\tfor(int j=1;j<=i-1;j++)\n\t\t\t{\n\t\t\t\tif(i-j<=(sth-1)*5000)break;\n\t\t\t\tdp[i]=(dp[i]+2LL*dp[j]*dp[i-j]%mod*jc[i-1]%mod*njc[j-1]%mod*njc[i-j])%mod;\n\t\t\t}\n\t\t\tfor(int j=(sth-1)*5000+1;j<=i-1;j++)\n\t\t\t{\n\t\t\t\tdp[i]=(dp[i]+2LL*dp[j]*dp[i-j]%mod*jc[i-1]%mod*njc[j-1]%mod*njc[i-j])%mod;\n\t\t\t}\n\t\t\tdp[i]=(dp[i]+mod-1LL*(i-1)*dp[i-1]%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",(2LL*(dp[n]+mod-1)%mod)%mod);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "divide and conquer",
        "dp",
        "fft",
        "graphs"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F2. Graph Coloring  hard version .json",
    "editorial_link": "https://codeforces.com//blog/entry/111835",
    "editorial": ".Okay, we need more definitions. Here they come:This way, we can\r\ntransform the formula for to the following:.Or even this, since :.This\r\nis almost the convolution of the sequences and (with a bit extra\r\nadditional operations after the convolution), so, to compute the\r\nsequence , we just need to compute the sequences and , and then\r\ncalculate their convolution with NTT. All that\u00e2\u0080\u0099s left is to multiply\r\nevery element by the corresponding factorial.But wait, that\u00e2\u0080\u0099s not so\r\neasy. In order to calculate and , we need to know . Note that we can\r\nignore the fact that and appear in the formula for , since they are\r\nmultiplied by , so at least we don\u00e2\u0080\u0099t have a dependency cycle.\r\nUnfortunately, we cannot just straightforwardly use convolution if we\r\ndon\u00e2\u0080\u0099t know the sequences and .The model solution handles it using the\r\nfollowing approach. Let\u00e2\u0080\u0099s generate , , and in parallel: on the -th\r\niteration, calculate , then calculate , and using it. And we will\r\ncalculate the convolution of the sequences and .Suppose we want to\r\ncalculate , and the last time we calculated the convolution of and was\r\nafter the iteration . Back then, we knew all elements from to and from\r\nto . So, the -th term in the convolution of and contained the sum of\r\nover all such that and . So, in order to calculate , we have to pick\r\nthis value from the convolution and then add the sum of over all such\r\nthat or , and there are such values.Suppose we compute the convolution\r\nevery iterations. Then the maximum value of is , and every value of is\r\ncalculated in . We also make convolutions, so the total complexity of\r\nthis solution will be , which can be transformed into if we pick .\r\n"
}