{"link": "https://codeforces.com//contest/1525/problem/F", "problemId": "987016", "problem_idx": "F", "shortId": "1525F", "contest_number": "1525", "problem_submissions": {"D": [116596850, 116594983, 116556621, 116344048, 116344302, 116349055, 116346341, 116347417, 116335585, 116344826, 116338508, 116335707, 116341307, 116349851, 116341668, 116351051, 116353738, 116347590, 116343356, 116345813, 116346453, 116348324], "F": [116372175, 116372025, 116380530, 116381098, 116381539, 116374296, 116382706, 116380101, 116523025, 116385915, 116383799, 116377898, 116380915, 116382591, 116385839, 116395698], "E": [116351338, 116353665, 116354964, 116353294, 116353957, 116361966, 116348163, 116347670, 116343533, 116351101, 116353993, 116360946, 116355058, 116358519, 116354709, 116351286, 116352542, 116358011, 116357879], "C": [116334549, 116339182, 116340233, 116340613, 116342489, 116350963, 116337654, 116366806, 116362628, 116359745, 116345739, 116358283, 116349150, 116349846, 116332723, 116338076, 116338563, 116342647, 116341792], "B": [116321920, 116322956, 116323732, 116325314, 116321887, 116323618, 116323021, 116322464, 116326670, 116325875, 116323111, 116331257, 116322276, 116322144, 116322587, 116325439, 116323730, 116321987, 116325764], "A": [116320634, 116320705, 116320798, 116320688, 116320665, 116321107, 116320786, 116320654, 116321098, 116320865, 116320734, 116327758, 116320593, 116320655, 116320605, 116320657, 116320652, 116320617, 116320774]}, "name": "F. Goblins And Gnomes", "statement": "Monocarp plays a computer game called \"Goblins and Gnomes\". In this\r\ngame, he manages a large underground city of gnomes and defends it from\r\nhordes of goblins.The city consists of n halls and m one-directional\r\ntunnels connecting them. The structure of tunnels has the following\r\nproperty: if a goblin leaves any hall, he cannot return to that hall.\r\nThe city will be attacked by k waves of goblins; during the i-th wave, i\r\ngoblins attack the city. Monocarp\u2019s goal is to pass all k waves.The i-th\r\nwave goes as follows: firstly, i goblins appear in some halls of the\r\ncity and pillage them; . Then, goblins start moving along the tunnels,\r\npillaging all the halls in their path. Goblins are very greedy and\r\ncunning, so they choose their paths so that no two goblins pass through\r\nthe same hall. Among all possible attack plans, they choose a plan which\r\nallows them to . After goblins are done pillaging, they leave the\r\ncity.If all halls are pillaged during the wave Monocarp loses the game.\r\nOtherwise, the city is restored. If some hall is pillaged during a wave,\r\ngoblins are still interested in pillaging it during the next\r\nwaves.Before each wave, Monocarp can spend some time preparing to it.\r\nMonocarp doesn\u2019t have any strict time limits on his preparations (he\r\ndecides when to call each wave by himself), but the longer he prepares\r\nfor a wave, the fewer points he gets for passing it. If Monocarp\r\nprepares for the i-th wave for t_i minutes, then he gets\r\nmax(0, x_i - t_i\r\ncdot y_i) points for passing it (obviously, if he doesn\u2019t lose in the\r\nprocess).While preparing for a wave, Monocarp can block tunnels. He can\r\nspend one minute to . If Monocarp blocks a tunnel while preparing for a\r\nwave, it stays blocked during the next waves as well.Help Monocarp to\r\ndefend against all k waves of goblins and get the maximum possible\r\namount of points!\r\n", "solutions": ["/*\n    author:  Maksim1744\n    created: 16.05.2021 11:55:48\n*/\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp   make_pair\n#define pb   push_back\n#define eb   emplace_back\n\n#define sum(a)     ( accumulate ((a).begin(), (a).end(), 0ll))\n#define mine(a)    (*min_element((a).begin(), (a).end()))\n#define maxe(a)    (*max_element((a).begin(), (a).end()))\n#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())\n#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())\n#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())\n#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())\n\ntemplate<typename T>             vector<T>& operator--            (vector<T> &v){for (auto& i : v) --i;            return  v;}\ntemplate<typename T>             vector<T>& operator++            (vector<T> &v){for (auto& i : v) ++i;            return  v;}\ntemplate<typename T>             istream& operator>>(istream& is,  vector<T> &v){for (auto& i : v) is >> i;        return is;}\ntemplate<typename T>             ostream& operator<<(ostream& os,  vector<T>  v){for (auto& i : v) os << i << ' '; return os;}\ntemplate<typename T, typename U> pair<T,U>& operator--           (pair<T, U> &p){--p.first; --p.second;            return  p;}\ntemplate<typename T, typename U> pair<T,U>& operator++           (pair<T, U> &p){++p.first; ++p.second;            return  p;}\ntemplate<typename T, typename U> istream& operator>>(istream& is, pair<T, U> &p){is >> p.first >> p.second;        return is;}\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, pair<T, U>  p){os << p.first << ' ' << p.second; return os;}\ntemplate<typename T, typename U> pair<T,U> operator-(pair<T,U> a, pair<T,U> b){return mp(a.first-b.first, a.second-b.second);}\ntemplate<typename T, typename U> pair<T,U> operator+(pair<T,U> a, pair<T,U> b){return mp(a.first+b.first, a.second+b.second);}\ntemplate<typename T, typename U> void umin(T& a, U b){if (a > b) a = b;}\ntemplate<typename T, typename U> void umax(T& a, U b){if (a < b) a = b;}\n\n#ifdef HOME\n#define SHOW_COLORS\n#include \"C:/C++ libs/print.cpp\"\n#else\n#define show(...) void(0)\n#define mclock    void(0)\n#define shows     void(0)\n#define debug  if (false)\n#endif\n\nbool matching_dfs(int v, vector<vector<int>>& g, vector<int>& from, vector<bool>& u) {\n    u[v] = true;\n    for (auto k : g[v]) {\n        if (from[k] == -1 || (!u[from[k]] && matching_dfs(from[k], g, from, u))) {\n            from[k] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nvector<pair<int, int>> find_matching(vector<vector<int>>& g, vector<int> a) {\n    bool rev = false;\n    if (2 * a.size() > g.size()) {\n        rev = true;\n        vector<bool> has(g.size(), false);\n        for (auto v : a)\n            has[v] = true;\n        a.clear();\n        a.reserve(g.size() - a.size());\n        for (int i = 0; i < g.size(); ++i)\n            if (!has[i])\n                a.push_back(i);\n    }\n    vector<bool> u(g.size(), false);\n    vector<int> from(g.size(), -1);\n    for (auto v : a)\n        if (matching_dfs(v, g, from, u))\n            u.assign(g.size(), false);\n    vector<pair<int, int>> result;\n    for (int v = 0; v < from.size(); ++v) {\n        if (from[v] != -1) {\n            if (rev) result.emplace_back(v, from[v]);\n            else result.emplace_back(from[v], v);\n        }\n    }\n    return result;\n}\n\nvoid dominating_set_dfs(int v, vector<vector<int>>& g, vector<int>& with, vector<bool>& u,\n                                                                          vector<bool>& take) {\n    u[v] = true;\n    for (auto k : g[v]) {\n        take[k] = true;\n        if (!u[with[k]])\n            dominating_set_dfs(with[k], g, with, u, take);\n    }\n}\n\nvector<int> find_dominating_set(vector<vector<int>>& g, vector<int>& a) {\n    auto matching = find_matching(g, a);\n    vector<int> with(g.size(), -1);\n    for (auto edge : matching) {\n        with[edge.first] = edge.second;\n        with[edge.second] = edge.first;\n    }\n    vector<bool> u(g.size(), false);\n    vector<bool> take(g.size(), false);\n    for (auto v : a)\n        if (with[v] == -1)\n            dominating_set_dfs(v, g, with, u, take);\n    for (auto e : matching)\n        if (!take[e.second])\n            take[e.first] = true;\n    vector<int> result(matching.size());\n    for (int i = 0; i < matching.size(); ++i) {\n        if (take[matching[i].second]) result[i] = matching[i].second;\n        else result[i] = matching[i].first;\n    }\n    return result;\n}\n\nvector<int> find_independent_set(vector<vector<int>>& g, vector<int>& a) {\n    vector<int> result;\n    vector<bool> u(g.size(), false);\n    for (auto v : find_dominating_set(g, a))\n        u[v] = true;\n    for (int i = 0; i < g.size(); ++i)\n        if (!u[i])\n            result.push_back(i);\n    return result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<int>> g(n * 2);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        g[u].pb(v + n);\n        g[v + n].pb(u);\n    }\n    vector<int> aaa(n);\n    iota(aaa.begin(), aaa.end(), 0);\n\n    int sz0 = n - find_matching(g, aaa).size();\n    vector<int> ord;\n    show(sz0);\n    while (true) {\n        auto st = find_independent_set(g, aaa);\n        show(st);\n        if (st.size() == n * 2) break;\n        set<int> sst(st.begin(), st.end());\n        int v = 0;\n        while (sst.count(v)) ++v;\n        g[v].clear();\n        show(g);\n        for (int i = 0; i < g.size(); ++i) {\n            int ind = find(g[i].begin(), g[i].end(), v) - g[i].begin();\n            if (ind != g[i].size())\n                g[i].erase(g[i].begin() + ind);\n        }\n        ord.pb(v);\n        show(find_matching(g, aaa).size());\n    }\n    show(ord);\n    assert(ord.size() == n - sz0);\n\n    vector<ll> x(k), y(k);\n    for (int i = 0; i < k; ++i) {\n        cin >> x[i] >> y[i];\n    }\n    \n    vector<int> at_least(k);\n    for (int i = 0; i < k; ++i) {\n        at_least[i] = max(0, (i + 1) - sz0 + 1);\n    }\n\n    vector<vector<ll>> dp(k, vector<ll>(n * 2 + 5, -1));\n    for (int i = 0; i < dp[0].size(); ++i) {\n        dp[0][i] = max(0ll, x[0] - y[0] * i);\n    }\n    show(x, y);\n    vector<vector<int>> from(k, vector<int>(n * 2 + 5, 0));\n    for (int i = 1; i < dp.size(); ++i) {\n        for (int j = 0; j < dp[i].size(); ++j) {\n            for (int u = 0; u <= j; ++u) {\n                if (j - u < at_least[i - 1]) continue;\n                ll val = dp[i - 1][j - u] + max(0ll, x[i] - y[i] * u);\n                if (val > dp[i][j]) {\n                    dp[i][j] = max(dp[i][j], val);\n                    from[i][j] = j - u;\n                }\n            }\n        }\n    }\n    show(at_least);\n    show(dp);\n    show(dp.back()[at_least.back()]);\n\n    vector<int> counts(k, 0);\n    {\n        int x = k - 1;\n        int y = at_least.back();\n        while (x >= 0) {\n            int d = from[x][y];\n            counts[x] = y - d;\n            x--;\n            y = d;\n        }\n    }\n    show(counts);\n\n    cout << sum(counts) + k << '\\n';\n    int ind = 0;\n    for (int i = 0; i < k; ++i) {\n        for (int j = 0; j < counts[i]; ++j) {\n            int v = ord[ind];\n            ++ind;\n            if (v >= n) v = -(v - n + 1);\n            else v++;\n            cout << v << ' ';\n        }\n        cout << 0 << ' ';\n    }\n    cout << '\\n';\n\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp", "flows", "graph matchings"], "dificulty": "2800", "interactive": false}