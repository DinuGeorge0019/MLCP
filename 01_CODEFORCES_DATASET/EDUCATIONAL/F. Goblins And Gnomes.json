{
    "link": "https://codeforces.com//contest/1525/problem/F",
    "problemId": "987016",
    "problem_idx": "F",
    "shortId": "1525F",
    "contest_number": "1525",
    "problem_submissions": {
        "D": [
            116596850,
            116594983,
            116556621,
            116344048,
            116344302,
            116349055,
            116346341,
            116347417,
            116335585,
            116344826,
            116338508,
            116335707,
            116341307,
            116349851,
            116341668,
            116351051,
            116353738,
            116347590,
            116343356,
            116345813,
            116346453,
            116348324
        ],
        "F": [
            116372175,
            116372025,
            116380530,
            116381098,
            116381539,
            116374296,
            116382706,
            116380101,
            116523025,
            116385915,
            116383799,
            116377898,
            116380915,
            116382591,
            116385839,
            116395698
        ],
        "E": [
            116351338,
            116353665,
            116354964,
            116353294,
            116353957,
            116361966,
            116348163,
            116347670,
            116343533,
            116351101,
            116353993,
            116360946,
            116355058,
            116358519,
            116354709,
            116351286,
            116352542,
            116358011,
            116357879
        ],
        "C": [
            116334549,
            116339182,
            116340233,
            116340613,
            116342489,
            116350963,
            116337654,
            116366806,
            116362628,
            116359745,
            116345739,
            116358283,
            116349150,
            116349846,
            116332723,
            116338076,
            116338563,
            116342647,
            116341792
        ],
        "B": [
            116321920,
            116322956,
            116323732,
            116325314,
            116321887,
            116323618,
            116323021,
            116322464,
            116326670,
            116325875,
            116323111,
            116331257,
            116322276,
            116322144,
            116322587,
            116325439,
            116323730,
            116321987,
            116325764
        ],
        "A": [
            116320634,
            116320705,
            116320798,
            116320688,
            116320665,
            116321107,
            116320786,
            116320654,
            116321098,
            116320865,
            116320734,
            116327758,
            116320593,
            116320655,
            116320605,
            116320657,
            116320652,
            116320617,
            116320774
        ]
    },
    "name": "F. Goblins And Gnomes",
    "statement": "Monocarp plays a computer game called \"Goblins and Gnomes\". In this\r\ngame, he manages a large underground city of gnomes and defends it from\r\nhordes of goblins.The city consists of n halls and m one-directional\r\ntunnels connecting them. The structure of tunnels has the following\r\nproperty: if a goblin leaves any hall, he cannot return to that hall.\r\nThe city will be attacked by k waves of goblins; during the i-th wave, i\r\ngoblins attack the city. Monocarp\u2019s goal is to pass all k waves.The i-th\r\nwave goes as follows: firstly, i goblins appear in some halls of the\r\ncity and pillage them; . Then, goblins start moving along the tunnels,\r\npillaging all the halls in their path. Goblins are very greedy and\r\ncunning, so they choose their paths so that no two goblins pass through\r\nthe same hall. Among all possible attack plans, they choose a plan which\r\nallows them to . After goblins are done pillaging, they leave the\r\ncity.If all halls are pillaged during the wave Monocarp loses the game.\r\nOtherwise, the city is restored. If some hall is pillaged during a wave,\r\ngoblins are still interested in pillaging it during the next\r\nwaves.Before each wave, Monocarp can spend some time preparing to it.\r\nMonocarp doesn\u2019t have any strict time limits on his preparations (he\r\ndecides when to call each wave by himself), but the longer he prepares\r\nfor a wave, the fewer points he gets for passing it. If Monocarp\r\nprepares for the i-th wave for t_i minutes, then he gets\r\nmax(0, x_i - t_i\r\ncdot y_i) points for passing it (obviously, if he doesn\u2019t lose in the\r\nprocess).While preparing for a wave, Monocarp can block tunnels. He can\r\nspend one minute to . If Monocarp blocks a tunnel while preparing for a\r\nwave, it stays blocked during the next waves as well.Help Monocarp to\r\ndefend against all k waves of goblins and get the maximum possible\r\namount of points!\r\n",
    "solutions": [
        "/*\n    author:  Maksim1744\n    created: 16.05.2021 11:55:48\n*/\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp   make_pair\n#define pb   push_back\n#define eb   emplace_back\n\n#define sum(a)     ( accumulate ((a).begin(), (a).end(), 0ll))\n#define mine(a)    (*min_element((a).begin(), (a).end()))\n#define maxe(a)    (*max_element((a).begin(), (a).end()))\n#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())\n#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())\n#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())\n#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())\n\ntemplate<typename T>             vector<T>& operator--            (vector<T> &v){for (auto& i : v) --i;            return  v;}\ntemplate<typename T>             vector<T>& operator++            (vector<T> &v){for (auto& i : v) ++i;            return  v;}\ntemplate<typename T>             istream& operator>>(istream& is,  vector<T> &v){for (auto& i : v) is >> i;        return is;}\ntemplate<typename T>             ostream& operator<<(ostream& os,  vector<T>  v){for (auto& i : v) os << i << ' '; return os;}\ntemplate<typename T, typename U> pair<T,U>& operator--           (pair<T, U> &p){--p.first; --p.second;            return  p;}\ntemplate<typename T, typename U> pair<T,U>& operator++           (pair<T, U> &p){++p.first; ++p.second;            return  p;}\ntemplate<typename T, typename U> istream& operator>>(istream& is, pair<T, U> &p){is >> p.first >> p.second;        return is;}\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, pair<T, U>  p){os << p.first << ' ' << p.second; return os;}\ntemplate<typename T, typename U> pair<T,U> operator-(pair<T,U> a, pair<T,U> b){return mp(a.first-b.first, a.second-b.second);}\ntemplate<typename T, typename U> pair<T,U> operator+(pair<T,U> a, pair<T,U> b){return mp(a.first+b.first, a.second+b.second);}\ntemplate<typename T, typename U> void umin(T& a, U b){if (a > b) a = b;}\ntemplate<typename T, typename U> void umax(T& a, U b){if (a < b) a = b;}\n\n#ifdef HOME\n#define SHOW_COLORS\n#include \"C:/C++ libs/print.cpp\"\n#else\n#define show(...) void(0)\n#define mclock    void(0)\n#define shows     void(0)\n#define debug  if (false)\n#endif\n\nbool matching_dfs(int v, vector<vector<int>>& g, vector<int>& from, vector<bool>& u) {\n    u[v] = true;\n    for (auto k : g[v]) {\n        if (from[k] == -1 || (!u[from[k]] && matching_dfs(from[k], g, from, u))) {\n            from[k] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nvector<pair<int, int>> find_matching(vector<vector<int>>& g, vector<int> a) {\n    bool rev = false;\n    if (2 * a.size() > g.size()) {\n        rev = true;\n        vector<bool> has(g.size(), false);\n        for (auto v : a)\n            has[v] = true;\n        a.clear();\n        a.reserve(g.size() - a.size());\n        for (int i = 0; i < g.size(); ++i)\n            if (!has[i])\n                a.push_back(i);\n    }\n    vector<bool> u(g.size(), false);\n    vector<int> from(g.size(), -1);\n    for (auto v : a)\n        if (matching_dfs(v, g, from, u))\n            u.assign(g.size(), false);\n    vector<pair<int, int>> result;\n    for (int v = 0; v < from.size(); ++v) {\n        if (from[v] != -1) {\n            if (rev) result.emplace_back(v, from[v]);\n            else result.emplace_back(from[v], v);\n        }\n    }\n    return result;\n}\n\nvoid dominating_set_dfs(int v, vector<vector<int>>& g, vector<int>& with, vector<bool>& u,\n                                                                          vector<bool>& take) {\n    u[v] = true;\n    for (auto k : g[v]) {\n        take[k] = true;\n        if (!u[with[k]])\n            dominating_set_dfs(with[k], g, with, u, take);\n    }\n}\n\nvector<int> find_dominating_set(vector<vector<int>>& g, vector<int>& a) {\n    auto matching = find_matching(g, a);\n    vector<int> with(g.size(), -1);\n    for (auto edge : matching) {\n        with[edge.first] = edge.second;\n        with[edge.second] = edge.first;\n    }\n    vector<bool> u(g.size(), false);\n    vector<bool> take(g.size(), false);\n    for (auto v : a)\n        if (with[v] == -1)\n            dominating_set_dfs(v, g, with, u, take);\n    for (auto e : matching)\n        if (!take[e.second])\n            take[e.first] = true;\n    vector<int> result(matching.size());\n    for (int i = 0; i < matching.size(); ++i) {\n        if (take[matching[i].second]) result[i] = matching[i].second;\n        else result[i] = matching[i].first;\n    }\n    return result;\n}\n\nvector<int> find_independent_set(vector<vector<int>>& g, vector<int>& a) {\n    vector<int> result;\n    vector<bool> u(g.size(), false);\n    for (auto v : find_dominating_set(g, a))\n        u[v] = true;\n    for (int i = 0; i < g.size(); ++i)\n        if (!u[i])\n            result.push_back(i);\n    return result;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n, m, k;\n    cin >> n >> m >> k;\n\n    vector<vector<int>> g(n * 2);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        --u; --v;\n        g[u].pb(v + n);\n        g[v + n].pb(u);\n    }\n    vector<int> aaa(n);\n    iota(aaa.begin(), aaa.end(), 0);\n\n    int sz0 = n - find_matching(g, aaa).size();\n    vector<int> ord;\n    show(sz0);\n    while (true) {\n        auto st = find_independent_set(g, aaa);\n        show(st);\n        if (st.size() == n * 2) break;\n        set<int> sst(st.begin(), st.end());\n        int v = 0;\n        while (sst.count(v)) ++v;\n        g[v].clear();\n        show(g);\n        for (int i = 0; i < g.size(); ++i) {\n            int ind = find(g[i].begin(), g[i].end(), v) - g[i].begin();\n            if (ind != g[i].size())\n                g[i].erase(g[i].begin() + ind);\n        }\n        ord.pb(v);\n        show(find_matching(g, aaa).size());\n    }\n    show(ord);\n    assert(ord.size() == n - sz0);\n\n    vector<ll> x(k), y(k);\n    for (int i = 0; i < k; ++i) {\n        cin >> x[i] >> y[i];\n    }\n    \n    vector<int> at_least(k);\n    for (int i = 0; i < k; ++i) {\n        at_least[i] = max(0, (i + 1) - sz0 + 1);\n    }\n\n    vector<vector<ll>> dp(k, vector<ll>(n * 2 + 5, -1));\n    for (int i = 0; i < dp[0].size(); ++i) {\n        dp[0][i] = max(0ll, x[0] - y[0] * i);\n    }\n    show(x, y);\n    vector<vector<int>> from(k, vector<int>(n * 2 + 5, 0));\n    for (int i = 1; i < dp.size(); ++i) {\n        for (int j = 0; j < dp[i].size(); ++j) {\n            for (int u = 0; u <= j; ++u) {\n                if (j - u < at_least[i - 1]) continue;\n                ll val = dp[i - 1][j - u] + max(0ll, x[i] - y[i] * u);\n                if (val > dp[i][j]) {\n                    dp[i][j] = max(dp[i][j], val);\n                    from[i][j] = j - u;\n                }\n            }\n        }\n    }\n    show(at_least);\n    show(dp);\n    show(dp.back()[at_least.back()]);\n\n    vector<int> counts(k, 0);\n    {\n        int x = k - 1;\n        int y = at_least.back();\n        while (x >= 0) {\n            int d = from[x][y];\n            counts[x] = y - d;\n            x--;\n            y = d;\n        }\n    }\n    show(counts);\n\n    cout << sum(counts) + k << '\\n';\n    int ind = 0;\n    for (int i = 0; i < k; ++i) {\n        for (int j = 0; j < counts[i]; ++j) {\n            int v = ord[ind];\n            ++ind;\n            if (v >= n) v = -(v - n + 1);\n            else v++;\n            cout << v << ' ';\n        }\n        cout << 0 << ' ';\n    }\n    cout << '\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "flows",
        "graph matchings"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Goblins And Gnomes.json",
    "editorial_link": "https://codeforces.com//blog/entry/90793",
    "editorial": "First of all, let\u00e2\u0080\u0099s try to solve the following problem: given a DAG,\r\ncover its vertices with the minimum number of vertex-disjoint paths.\r\nSolving this problem allows us to calculate the number of goblins that\r\ncan pillage all of the halls when the tunnel network is fixed. This\r\nproblem is a fairly classical one; since the number of vertices in each\r\npath is greater than the number of arcs in it exactly by , we should\r\ntake the maximum possible number of arcs into our paths. So we can\r\nreduce this problem to bipartite maximum matching build a bipartite\r\ngraph where each part consists of vertices, and for every directed arc\r\nin the original graph, connect the vertex of the left part to the vertex\r\nin the right part of the bipartite graph. The maximum matching in this\r\ngraph allows us to pick the maximum number of arcs into the paths of the\r\noriginal problem (the matching ensures that each vertex has at most one\r\nchosen ingoing arc and at most one chosen outgoing arc, so the paths are\r\nvertex-disjoint). Okay, now we at least can check if the goblin wave can\r\npillage all of the halls.Let\u00e2\u0080\u0099s say that the minimum number of goblins\r\nrequired to pillage the original city is . Obviously, in order to pass\r\nthe -th wave and waves after it, we have to increase this number. In one\r\nminute, Monocarp can block all of the tunnels leading to some hall or\r\nout of some hall and in terms of our reduction to the bipartite matching\r\nproblem, it means that we remove all edges connected to some vertex of\r\nthe bipartite graph. Obviously, in one minute, we can increase by at\r\nmost , since is equal to the difference between and the maximum matching\r\nsize.It turns out that it\u00e2\u0080\u0099s always possible to choose a vertex that\r\nbelongs to all maximum matchings in the bipartite graph (note that it\r\ndoesn\u00e2\u0080\u0099t work in non-bipartite graphs, but in our problem, it doesn\u00e2\u0080\u0099t\r\nmatter). For the proof of this fact, you can check the last paragraph of\r\nthe editorial. So, each minute Monocarp prepares for a wave, he\r\nincreases the maximum number of goblins he can repel by .Now the\r\nsolution splits into two much easier parts. The first part is finding a\r\nsequence in which Monocarp blocks the tunnels, so that each his action\r\nreduces the size of the maximum matching by . Since the constraints are\r\nsmall, even a naive approach in always iterate on the vertex we try to\r\nremove from the graph and check that removing it is possible by running\r\nKuhn\u00e2\u0080\u0099s algorithm is fast enough. The second part is to choose when\r\nMonocarp calls waves of goblins and when he prepares for them this can\r\nbe easily done with dynamic programming: let be the maximum Monocarp\u00e2\u0080\u0099s\r\nscore if he has already passed waves, and the current size of the\r\nmaximum matching is . The most naive implementation of this dynamic\r\nprogramming runs in , so the whole solution works in .We can improve it\r\nto , though it is not needed under these constraints. Instead of finding\r\nthe vertices to remove from the bipartite graph one-by-one, let\u00e2\u0080\u0099s find\r\nall of them at once in . Recall that the size of maximum matching in a\r\nbipartite graph is equal to the size of its minimum vertex cover, and\r\nthe minimum vertex cover can be reconstructed after finding the maximum\r\nmatching. If we remove a vertex from the minimum vertex cover, the size\r\nof the minimum vertex cover of the remaining graph is reduced by , so\r\nthe size of the maximum matching is reduced by as well. It means that we\r\ncan always choose to remove a vertex from the minimum vertex cover we\r\nfound. By the way, it also proves that it\u00e2\u0080\u0099s always possible to remove a\r\nvertex from a bipartite graph so the size of the maximum matching\r\ndecreases by (obviously, if it\u00e2\u0080\u0099s not already).\r\n"
}