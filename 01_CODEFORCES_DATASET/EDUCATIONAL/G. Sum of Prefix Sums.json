{
    "link": "https://codeforces.com//contest/1303/problem/G",
    "problemId": "538606",
    "problem_idx": "G",
    "shortId": "1303G",
    "contest_number": "1303",
    "problem_submissions": {
        "G": [
            71097266,
            70883386,
            70955431,
            70955302,
            71079595,
            71079587,
            71079399,
            71079349,
            71033664,
            70936374,
            70936308,
            70936214,
            70880989,
            70891160,
            70926122,
            70886272,
            71216890,
            71204250,
            70902620,
            71200015,
            70940169,
            71279910,
            70899562,
            71278035,
            70896282,
            70900541,
            70900494
        ],
        "F": [
            71044888,
            71044744,
            70899994,
            70890051,
            70888815,
            70932923,
            70932898,
            70932421,
            70932306,
            70932207,
            70932013,
            70931555,
            70915800,
            70904497,
            70912908,
            70884185,
            138818627,
            70892348,
            70886515,
            70891950,
            71199846,
            70884407,
            70897531,
            70893903,
            70894963,
            70893107,
            70925189,
            70924800,
            70897907
        ],
        "E": [
            70868559,
            70868408,
            70868922,
            70872692,
            70869150,
            70869901,
            70874174,
            70872386,
            70874403,
            70875550,
            71199810,
            70873171,
            70863746,
            70871476,
            70905263,
            70869281,
            70875226,
            70874988,
            70881045,
            70874968,
            70882383,
            70877044
        ],
        "D": [
            70863251,
            70862650,
            70863288,
            70862684,
            70865048,
            70865462,
            70867179,
            70866583,
            70869772,
            70868436,
            71199774,
            70869707,
            70873016,
            70865851,
            70862875,
            70869379,
            70868162,
            70869500,
            70869186,
            70873860,
            70869244
        ],
        "C": [
            70859686,
            70858172,
            70859652,
            70865909,
            70861024,
            70860138,
            70862819,
            70861003,
            70864530,
            70863875,
            71199753,
            70865732,
            70856962,
            70860948,
            70858736,
            70863123,
            70860398,
            70864062,
            70861729,
            70862531,
            70860453
        ],
        "B": [
            70855213,
            70854594,
            70853630,
            70935416,
            70856554,
            70855070,
            70861321,
            70855979,
            70856395,
            70857261,
            70857192,
            71199724,
            70861383,
            70852833,
            70856458,
            70855360,
            70857332,
            70856143,
            70857430,
            70853208,
            70856253,
            70853781
        ],
        "A": [
            70849936,
            70850631,
            70849990,
            70849934,
            70850041,
            70849959,
            70849980,
            70850863,
            70852663,
            70850352,
            71199700,
            70859542,
            70849914,
            70851564,
            70849996,
            70851983,
            70850145,
            70850480,
            70850071,
            70850741,
            70850778
        ]
    },
    "name": "G. Sum of Prefix Sums",
    "statement": "We define the of an array [s_1, s_2,\r\ndots, s_k] as s_1 + (s_1 + s_2) + (s_1 + s_2 + s_3) +\r\ndots + (s_1 + s_2 +\r\ndots + s_k).You are given a tree consisting of n vertices. Each vertex i\r\nhas an integer a_i written on it. We define the value of the path from\r\nvertex u to vertex v as follows: consider all vertices appearing on the\r\npath from u to v, write down all the numbers written on these vertices\r\nin the order they appear on the path, and compute the of the resulting\r\nsequence.Your task is to calculate the maximum value over all paths in\r\nthe tree.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define ar array\n\nconst int mxN=1.5e5;\nint n, s[mxN], ctp[mxN], a[mxN];\nvector<int> adj[mxN];\nll ans;\nvector<vector<ar<ll, 2>>> v1, v2;\n\nstruct line {\n\tll m, b;\n\tmutable function<const line *()> succ;\n\tbool operator<(const line &o) const {\n\t\tif(o.b^LLONG_MAX)\n\t\t\treturn m<o.m;\n\t\tconst line *s=succ();\n\t\treturn s?b-s->b<(s->m-m)*o.m:0;\n\t}\n};\nstruct dynamic_hull : public multiset<line> {\n\tbool bad(auto y) {\n\t\tauto z=next(y);\n\t\tif(y==begin())\n\t\t\treturn z==end()?0:y->m==z->m&&y->b<=z->b;\n\t\tauto x=prev(y);\n\t\treturn z==end()?y->m==x->m&&y->b<=x->b:(x->b-y->b)*(z->m-y->m)>=(y->b-z->b)*(y->m-x->m);\n\t}\n\tvoid upd(ll m, ll b) {\n\t\tauto y=insert({m, b});\n\t\ty->succ=[=] {\n\t\t\treturn next(y)==end()?0:&*next(y);\n\t\t};\n\t\tif(bad(y)) {\n\t\t\terase(y);\n\t\t\treturn;\n\t\t}\n\t\twhile(next(y)!=end()&&bad(next(y)))\n\t\t\terase(next(y));\n\t\twhile(y!=begin()&&bad(prev(y)))\n\t\t\terase(prev(y));\n\t}\n\tll qry(ll x) {\n\t\tline l=*lower_bound((line){x, LLONG_MAX});\n\t\treturn l.m*x+l.b;\n\t}\n};\n\nvoid dfs2(int u, int p=-1) {\n\ts[u]=1;\n\tfor(int v : adj[u]) {\n\t\tif(v^p&&ctp[v]==-1) {\n\t\t\tdfs2(v, u);\n\t\t\ts[u]+=s[v];\n\t\t}\n\t}\n}\n\nint dfs4(int u, int n, int p=-1) {\n\tfor(int v : adj[u])\n\t\tif(v^p&&ctp[v]==-1&&s[v]>n/2)\n\t\t\treturn dfs4(v, n, u);\n\treturn u;\n}\n\nvoid dfs5(int u, int d, ll s10, ll s11, ll s20, ll s21, int p=-1) {\n\tint nc=0;\n\ts10+=a[u];\n\ts11+=(ll)a[u]*(d+1);\n\ts20+=a[u];\n\ts21+=s20;\n\tfor(int v : adj[u]) {\n\t\tif(v==p||~ctp[v])\n\t\t\tcontinue;\n\t\t++nc;\n\t\tdfs5(v, d+1, s10, s11, s20, s21, u);\n\t}\n\tif(!nc) {\n\t\tv1.back().push_back({s10, s11});\n\t\tv2.back().push_back({d, s21});\n\t}\n}\n\nvoid dfs3(int u=0, int p=-2) {\n\tint c=dfs4(u, s[u]);\n\tctp[c]=p;\n\tdfs2(c);\n\tv1.push_back({{a[c], a[c]}});\n\tv2.push_back({{0, 0}});\n\tfor(int v : adj[c]) {\n\t\tif(~ctp[v])\n\t\t\tcontinue;\n\t\tv1.push_back({});\n\t\tv2.push_back({});\n\t\tdfs5(v, 1, a[c], a[c], 0, 0);\n\t}\n\tfor(int k : {0, 1}) {\n\t\tdynamic_hull d;\n\t\td.upd(0, 0);\n\t\tfor(int i=0; i<v1.size(); ++i) {\n\t\t\tfor(ar<ll, 2> a : v2[i])\n\t\t\t\tans=max(d.qry(a[0])+a[1], ans);\n\t\t\tfor(ar<ll, 2> a : v1[i])\n\t\t\t\td.upd(a[0], a[1]);\n\t\t}\n\t\treverse(v1.begin(), v1.end());\n\t\treverse(v2.begin(), v2.end());\n\t}\n\tv1.clear();\n\tv2.clear();\n\tfor(int v : adj[c])\n\t\tif(ctp[v]==-1)\n\t\t\tdfs3(v, c);\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor(int i=1, u, v; i<n; ++i) {\n\t\tcin >> u >> v, --u, --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tfor(int i=0; i<n; ++i)\n\t\tcin >> a[i];\n\tmemset(ctp, -1, 4*n);\n\tdfs2(0);\n\tdfs3();\n\tcout << ans;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "geometry",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Sum of Prefix Sums.json",
    "editorial_link": "https://codeforces.com//blog/entry/73872",
    "editorial": "Let\u00e2\u0080\u0099s use centroid decomposition to solve the problem. We need to\r\nprocess all the paths going through each centroid somehow.Consider a\r\npath from vertex to vertex going through vertex , which is an ancestor\r\nof both and in the centroid decomposition tree. Suppose the sequence of\r\nnumbers on path from to (including both these vertices) is , and the\r\nsequence of numbers on path from to (including , but excluding ) is .\r\nLet , , and . We can show that the sum of prefix sums of is equal to\r\n.Now, suppose we fix the second part of the path ( and are fixed), and\r\nwe want to find the best first part for this second part. Each possible\r\nfirst part is represented by a linear function, and our goal is to find\r\nthe maximum over all these linear functions in the point , and add to\r\nthis maximum. This can be done with the help of convex hull or Li Chao\r\ntree.The most difficult part of implementation is how to process each\r\ncentroid\u00e2\u0080\u0099s subtree. It\u00e2\u0080\u0099s easy to obtain all \"first parts\" and \"second\r\nparts\" of paths going through the centroid, but pairing them up can be\r\ncomplicated for each second part, we have to build a convex hull or Li\r\nChao tree on all first parts going to this centroid, excluding those\r\nwhich go through the same child of the centroid as the \"second part\" we\r\nare considering. One of the best ways to implement this is the\r\nfollowing. Suppose our centroid has children, is the set of \"first\r\nparts\" going from the -th child of the centroid, and is the set of\r\n\"second parts\" going to the -th child. We will create a new data\r\nstructure (initially empty), process all second parts from , add all\r\nfirst parts from , process all second parts from , add all first parts\r\nfrom , and so on. After that, we will clear our data structure, process\r\nall second parts from , add all first parts from , process all second\r\nparts from , add all first parts from , and so on, until we add all\r\nfirst parts from . That way we will consider all possible first parts\r\nfor each second part we are trying to use.\r\n"
}