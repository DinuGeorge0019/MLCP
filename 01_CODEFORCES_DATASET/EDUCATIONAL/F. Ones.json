{
    "link": "https://codeforces.com//contest/1487/problem/F",
    "problemId": "897752",
    "problem_idx": "F",
    "shortId": "1487F",
    "contest_number": "1487",
    "problem_submissions": {
        "G": [
            107454023,
            107463460,
            108576854,
            107460627,
            107450583,
            107451415,
            107430357,
            107444206,
            107450475,
            107450812,
            107922779,
            107446295,
            107455969,
            107448609,
            107460406,
            107464872,
            107461634,
            107460893,
            107461280,
            107537497
        ],
        "F": [
            107439893,
            107447022,
            107443885,
            107469668,
            107469505,
            107444768,
            107452696,
            107498096,
            107498067,
            107494456,
            107622368,
            107452390,
            107465180
        ],
        "E": [
            107424178,
            107424961,
            107432865,
            107429617,
            107432584,
            107450909,
            107426371,
            107427677,
            107427122,
            107429815,
            107619068,
            107618663,
            107432462,
            107430691,
            107435461,
            107433872,
            107429938,
            107432421,
            107433935,
            107430580,
            107430754
        ],
        "D": [
            107421373,
            107421309,
            107427665,
            107423119,
            107428301,
            107453801,
            107421667,
            107423926,
            107424261,
            107424540,
            107428634,
            107426278,
            107425386,
            107425551,
            107425722,
            107429097,
            107425401,
            107424375,
            107424284
        ],
        "C": [
            107420002,
            107418181,
            108576710,
            107420782,
            107436848,
            107423312,
            107458805,
            107419068,
            107421219,
            107421707,
            107421854,
            107426343,
            107423376,
            107421931,
            107421521,
            107423818,
            107421650,
            107421555,
            107422095,
            107421412
        ],
        "B": [
            107416333,
            107413010,
            108576679,
            107416798,
            107424397,
            107419739,
            107460613,
            107414304,
            107416812,
            107415960,
            107414948,
            107416874,
            107418655,
            107417622,
            107416871,
            107416648,
            107416339,
            107414794,
            107418914,
            107416654
        ],
        "A": [
            107410359,
            107409706,
            108576659,
            107410154,
            107409888,
            107412513,
            107461425,
            107409652,
            107410618,
            107410216,
            107410119,
            107412422,
            107409710,
            107411124,
            107409938,
            107409679,
            107409688,
            107409851,
            107409775,
            107410068
        ]
    },
    "name": "F. Ones",
    "statement": "You are given a positive (greater than zero) integer n.You have to\r\nrepresent n as the sum of integers (possibly negative) consisting only\r\nof ones (digits \u201d). For example, 24 = 11 + 11 + 1 + 1 and 102 = 111 -\r\n11 + 1 + 1. Among all possible representations, you have to find the one\r\nthat uses the minimum number of ones in total.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n\nvoid solve() {\n\n    string S; cin >> S;\n    S = \"0\" + S;\n    int N = sz(S);\n    int dp[N][101][2001];\n    F0R(i, N) {\n        F0R(j, 101) F0R(k, 2001) dp[i][j][k] = 1000000;\n    }\n    dp[0][50][1000] = 0;\n    F0R(i, N-1) {\n        F0R(j, 100) {\n            F0R(k, 2000) {\n                ckmin(dp[i][j+1][k+1], dp[i][j][k] + N-i);\n            }\n        }\n        FORd(j, 1, 101) {\n            FORd(k, 1, 2001) {\n                ckmin(dp[i][j-1][k-1], dp[i][j][k]+N-i);\n            }\n        }\n        F0R(j, 101) {\n            F0R(k, 2001) {\n                int nxt = 50 + (j-50)*10 - (S[i+1]-'0') + (k-1000);\n                if (nxt < 101 && nxt >= 0) {\n                    ckmin(dp[i+1][nxt][k], dp[i][j][k]);\n                    /*if (i+1 == N-1 && nxt == 56 && k == 1003) {\n                        cout << \"TEST \" << j << \" \" << k << endl;\n                    }*/\n                }\n            }\n        }\n    }\n    int ans = 1000000;\n    F0R(i, 101) F0R(j, 2001) {\n        ckmin(ans, dp[N-1][i][j] + abs(i-50));\n        /*if (dp[N-1][i][j] + abs(i-50) == 20) {\n            cout << i-50 << \" \" << j-1000 << nl;\n        }*/\n    }\n    cout << ans << nl;\n\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "shortest paths"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Ones.json",
    "editorial_link": "https://codeforces.com//blog/entry/87873",
    "editorial": "Let\u00e2\u0080\u0099s build the number from the lowest digit to the highest digit with\r\nthe following dynamic programming: the minimum number of ones, if least\r\nsignificant digits are already fixed, the carry to the next digit is\r\n(can be negative), there are positive numbers (of the form ) of length\r\ngreater than or equal to and negative numbers of length greater than or\r\nequal to .First, consider the transitions when we reduce the values of\r\nand/or . Such transitions correspond to the fact that in the optimal\r\nanswer there were several numbers of length exactly , and they should\r\nnot be considered further.If the value of matches the -th least\r\nsignificant digit in , then we can use transition to -th state with the\r\nnew value of and the number of ones in the answer increased by .It\r\nremains to estimate what the maximum value of () and we need. The value\r\nof doesn\u00e2\u0080\u0099t exceed the total number of numbers that we use in the answer.\r\nUsing at most numbers we can decrease the length of by at least . Thus,\r\nthe maximum value of and is at most (where |n| is the length of the\r\nnumber ). For the value of , the condition should be met (similarly for\r\na negative value). Thus, we can assume that the absolute value of\r\ndoesn\u00e2\u0080\u0099t exceed . The total complexity of this solution is , yet with a\r\nhigh constant factor.\r\n"
}