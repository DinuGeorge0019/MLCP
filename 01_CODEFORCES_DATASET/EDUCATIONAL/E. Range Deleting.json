{
    "link": "https://codeforces.com//contest/1167/problem/E",
    "problemId": "344634",
    "problem_idx": "E",
    "shortId": "1167E",
    "contest_number": "1167",
    "problem_submissions": {
        "G": [
            54199521,
            54201009,
            54517594,
            54222661,
            54364012,
            54215552,
            54224700,
            54210170,
            54210125,
            54210060,
            54209496,
            54208961,
            54219271,
            58247930
        ],
        "F": [
            54189763,
            54191560,
            54188017,
            54193815,
            54198047,
            54197721,
            54195395,
            54190513,
            54198962,
            54198980,
            54197783,
            54198116,
            54209016,
            54200221,
            54197337,
            54195561,
            54196921,
            54190680,
            54201016,
            54197503,
            54199324
        ],
        "E": [
            54187099,
            54187335,
            54196048,
            54186318,
            54187789,
            54191563,
            54192086,
            54195810,
            54191131,
            54191667,
            54192242,
            54194803,
            54192777,
            54191266,
            54189610,
            54192694,
            54196385,
            54241812,
            54208508,
            54196237,
            54192975,
            54196282
        ],
        "D": [
            54184655,
            54183868,
            54182601,
            54254072,
            54187816,
            54183265,
            54184958,
            54187415,
            54186508,
            54185650,
            54184214,
            54187917,
            54185330,
            54215169,
            54214062,
            54213957,
            54213940,
            54212912,
            54212894,
            54186804,
            54192578,
            54182335,
            54185963,
            54184762,
            54186406,
            54188164,
            54188808
        ],
        "C": [
            54183325,
            54182652,
            54179797,
            54181639,
            54180270,
            54183029,
            54186018,
            54184791,
            54184638,
            54183698,
            54183060,
            54181938,
            54183556,
            54183141,
            54183089,
            54180288,
            54184423,
            54183220,
            54184555,
            54185863,
            54182921
        ],
        "B": [
            54182048,
            54181521,
            54184836,
            54179971,
            54182085,
            54181491,
            54183487,
            54185276,
            54182631,
            54181677,
            54186071,
            54182415,
            54181445,
            54182146,
            54198453,
            54183319,
            54181503,
            54182555,
            54184235,
            54186573
        ],
        "A": [
            54178078,
            54178458,
            54177903,
            54177871,
            54177876,
            54178109,
            54178374,
            54178382,
            54178054,
            54178274,
            54179924,
            54177952,
            54177881,
            54177926,
            54178075,
            54177978,
            54177900,
            54179121,
            54179411,
            54179558
        ]
    },
    "name": "E. Range Deleting",
    "statement": "You are given an array consisting of n integers a_1, a_2,\r\ndots , a_n and an integer x. It is guaranteed that for every i, 1\r\nle a_i\r\nle x.Let’s denote a function f(l, r) which erases all values such that l\r\nle a_i\r\nle r from the array a and returns the resulting array. For example, if a\r\n= [4, 1, 1, 4, 5, 2, 4, 3], then f(2, 4) = [1, 1, 5].Your task is to\r\ncalculate the number of pairs (l, r) such that 1\r\nle l\r\nle r\r\nle x and f(l, r) is sorted in non-descending order. Note that the empty\r\narray is also considered sorted.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\nint tab[nax];\n\nvi wek[nax];\n\nll wyn;\n\nint pocz[nax];\nint kon[nax];\n\nint czyok(int a, int b)\n{\n\treturn pocz[a-1]<kon[b+1];\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\tfor (int i=1; i<=n; i++)\n\t\twek[tab[i]].push_back(i);\n\tpocz[0]=0;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tif (wek[i].empty())\n\t\t{\n\t\t\tpocz[i]=pocz[i-1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (wek[i][0]<pocz[i-1])\n\t\t\t\tpocz[i]=n+7;\n\t\t\telse\n\t\t\t\tpocz[i]=wek[i].back();\n\t\t}\n\t}\n\tkon[m+1]=n+1;\n\tfor (int i=m; i; i--)\n\t{\n\t\tif (wek[i].empty())\n\t\t{\n\t\t\tkon[i]=kon[i+1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (wek[i].back()>kon[i+1])\n\t\t\t\tkon[i]=-7;\n\t\t\telse\n\t\t\t\tkon[i]=wek[i][0];\n\t\t}\n\t}\n\t//~ debug() << range(pocz+1, pocz+m);\n\t//~ debug() << range(kon+1, kon+m);\n\tint w=0;\n\tfor (int i=1; i<=m && czyok(i, m); i++)\n\t{\n\t\tw=max(w, i);\n\t\twhile(!czyok(i, w))\n\t\t\tw++;\n\t\t//~ debug() << i << \" \" << w;\n\t\twyn+=m-w+1;\n\t}\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "data structures",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Range Deleting.json",
    "editorial_link": "https://codeforces.com/blog/entry/67058",
    "editorial": "Lets find the maximum number such that all values form the\r\nnon-descending order array. It can be done the following way. Let values\r\nform the non-descending order array. Then values will form the\r\nnon-descending order array if the first occurrence of in array is after\r\nthe last occurrence of . In similar manner we can find the minimum\r\nnumber such that all values form the non-descending order array.Now\r\nletâs find out how to get the minimum number such that all values form\r\nthe non-descending order array if we fixed the value . We denote this\r\nvalue for some fixed value as . Firstly, conditions , and should hold.\r\nSecondly, there should be no such a pair that conditions , and hold.\r\nSince the condition is satisfied, it means that must be greater than ,\r\nwhere is the last occurrence of in array .In this way the answer is .\r\n",
    "hint": []
}