{
    "link": "https://codeforces.com//contest/2043/problem/C",
    "problemId": "3103848",
    "problem_idx": "C",
    "shortId": "2043C",
    "contest_number": "2043",
    "problem_submissions": {
        "G": [
            298276621,
            298458376,
            298455954,
            298459741,
            298498128,
            298494225,
            298493989,
            298368643,
            298368617
        ],
        "F": [
            298243973,
            298258053,
            298242817,
            298260253,
            298257085,
            298250612,
            298241233,
            298252743,
            298266622,
            298254223,
            298258269,
            298270540,
            298270292,
            298270970,
            298272964,
            298350526,
            298284182,
            298276985,
            298272819,
            298283274,
            298421391,
            298417038,
            298257904
        ],
        "E": [
            298230325,
            298236565,
            298229495,
            298226934,
            298227308,
            298237122,
            298220698,
            298238215,
            298226770,
            298234499,
            298239196,
            298230091,
            298228297,
            298244169,
            298310355,
            298234798,
            298238168,
            298247710,
            298242187,
            298286367
        ],
        "D": [
            298219869,
            298216982,
            298222571,
            298218218,
            298213410,
            298224781,
            298213619,
            298219577,
            298216318,
            298221470,
            298226089,
            298219311,
            298219518,
            298230143,
            298226137,
            298226579,
            298229601,
            298224236,
            298231826
        ],
        "C": [
            298215825,
            298213305,
            298214855,
            298212674,
            298210052,
            298218770,
            298246686,
            298216835,
            298211668,
            298217178,
            298218473,
            298215699,
            298214498,
            298219482,
            298220559,
            298222653,
            298215672,
            298216539,
            298220531
        ],
        "B": [
            298205974,
            298203999,
            298204560,
            298204165,
            298201534,
            298206623,
            298209665,
            298205595,
            298204637,
            298205310,
            298207112,
            298207961,
            298204179,
            298210111,
            298210081,
            298211372,
            298204136,
            298203902,
            298209938
        ],
        "A": [
            298200061,
            298199218,
            298199258,
            298199378,
            298199175,
            298200132,
            298199984,
            298200407,
            298199812,
            298205860,
            298199259,
            298199630,
            298199502,
            298199251,
            298211149,
            298199244,
            298199260,
            298199390,
            298200087
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137801",
    "editorial": "What could the answer to the problem be if all elements were equal to or\r\n? Letâs consider all segments with a fixed left boundary . The empty\r\nsegment has a sum of . As we move the right boundary to the right, the\r\nsum will change by . That is, we can obtain all sums from the minimum\r\nsum to the maximum one. To find the sums for the entire array, we need\r\nto find the union of the segments. Since all segments include , their\r\nunion is also a segment. Therefore, the possible sums are all sums from\r\nthe minimum sum to the maximum sum in the entire array.Now letâs apply\r\nthis reasoning to the given problem. The segments that do not include\r\nthe strange element still form a segment of possible sums that includes\r\n. As for the segments that include the strange element, we can look at\r\nthem this way. We will remember these segments and remove the strange\r\nelement. Then the resulting sums will also form a segment that includes\r\n. If we return the element to its place, all sums will increase exactly\r\nby this element. Thus, it will remain a segment, however, not\r\nnecessarily including now.Then the solution could be as follows. We will\r\nfind the minimum and maximum sum among the segments that do not contain\r\nthe strange element. We will find the minimum and maximum sum among the\r\nsegments that do contain it. Then we will output the union of the\r\nobtained sum segments.Next, you need to adapt your favorite algorithm\r\nfor finding the maximum sum segment for this problem. My favorite is\r\nreducing it to prefix sums. The sum of the segment is equal to . We fix\r\nthe right boundary of the segment . Since the first term for all\r\nsegments is now the same, the maximum sum segment with this right\r\nboundary is the one with the minimum possible prefix sum at the left\r\nboundary. We will then iterate over in increasing order and find the\r\nmaximum sum among all right boundaries. The minimum prefix sum on the\r\nleft can be maintained on the fly.For a fixed right boundary, we have\r\ntwo options: for some prefix of left boundaries, the strange element is\r\ninside the segment, and for some suffix, it is outside. This suffix may\r\nbe empty if the boundary is to the left of the strange element.\r\nTherefore, we will maintain two values on the fly: the minimum prefix\r\nsum before the strange element and after it.Finally, we need to find the\r\npossible sums in the union of the two segments. There are two options\r\nhere. If the segments intersect, then it includes all sums from the\r\nminimum of the left boundaries to the maximum of the right ones. If they\r\ndo not intersect, then it is simply two segments.Overall complexity: per\r\ntestcase.\r\n",
    "name": "C. Sums on Segments",
    "statement": "You are given an array a of n integers, where all elements except for\r\nare equal to -1 or 1. The remaining element x satisfies -10^9\r\nle x\r\nle 10^9.Find all possible sums of subarrays of a, including the empty\r\nsubarray, whose sum is defined as 0. In other words, find all integers x\r\nsuch that the array a has at least one subarray (possibly empty) with\r\nsum equal to x. A subarray is a contiguous subsegment of an array.Output\r\nthese sums in ascending order. Each sum should be printed only once,\r\neven if it is achieved by multiple subarrays.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ALL(x) begin(x), end(x)using namespace std;void file() {  freopen(\"1.in\", \"r\", stdin);  freopen(\"1.out\", \"w\", stdout);}using ll = long long; const ll kInfl = 1e18;const int kN = 2e5 + 5;int n;array<ll, kN> a, pre;vector<ll> ans; ll Query(int l, int r) { return pre[r] - pre[l - 1]; } void Push(ll l, ll r) {  for(ll i = l; i <= r; i++) {    ans.push_back(i);  }} void Case1(int l, int r) {  ll mn, mx, ansl = 0, ansr = 0;  mn = mx = pre[l - 1];  for(int i = l; i <= r; i++) {    ansl = min(ansl, pre[i] - mx);    ansr = max(ansr, pre[i] - mn);    mn = min(mn, pre[i]);    mx = max(mx, pre[i]);  }  Push(ansl, ansr);} void Case2(int x) {  ll lx, ln, rx, rn;  lx = rx = -kInfl, ln = rn = kInfl;  for(int i = x; i; i--) {    ll val = Query(i, x);    lx = max(lx, val), ln = min(ln, val);  }  for(int i = x; i <= n; i++) {    ll val = Query(x, i);    rx = max(rx, val), rn = min(rn, val);  }  Push(ln + rn - a[x], lx + rx - a[x]);} void Solve() {  cin >> n, ans.clear();  for(int i = 1; i <= n; i++) {    cin >> a[i], pre[i] = pre[i - 1] + a[i];  }  int p = 1;  for(int i = 1; i <= n; i++) {    if(abs(a[i]) != 1) p = i;  }  Case1(1, p - 1), Case1(p + 1, n), Case2(p);  sort(ALL(ans));  ans.erase(unique(ALL(ans)), end(ans));  cout << ans.size() << \"\\n\";  for(ll x : ans) cout << x << \" \";  cout << \"\\n\";} int main() {  // file();  ios::sync_with_stdio(0), cin.tie(0);  int T;  cin >> T;  while(T--) Solve();  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Sums on Segments.json",
    "hint": []
}