{
    "link": "https://codeforces.com//contest/1661/problem/A",
    "problemId": "1361827",
    "problem_idx": "A",
    "shortId": "1661A",
    "contest_number": "1661",
    "problem_submissions": {
        "F": [
            153187553,
            153195355,
            153198079,
            153192699,
            153208735,
            153197140,
            153204834,
            153209679,
            153216895,
            153192345,
            153209985,
            153215287,
            153214260,
            153206784,
            153181924,
            153187391,
            153499691
        ],
        "E": [
            153181602,
            153183458,
            153186252,
            153186023,
            153206034,
            153195940,
            153194023,
            153206147,
            153218775,
            153197839,
            153195670,
            153202578,
            153201319,
            153198707,
            153201518,
            153192938,
            153189205,
            153195957,
            153196511
        ],
        "D": [
            153174390,
            153174537,
            153175638,
            153174007,
            153176690,
            153176745,
            153185907,
            153182627,
            153178744,
            153172686,
            153190154,
            153190396,
            153190106,
            153210872,
            153207891,
            153175462,
            153176825,
            153177570,
            153175676
        ],
        "C": [
            153170138,
            153167530,
            153168248,
            153169048,
            153170259,
            153170541,
            153168119,
            153170774,
            153172726,
            153194437,
            153178130,
            153175287,
            153185061,
            153205419,
            153246548,
            153215381,
            153166182,
            153169099,
            153168642,
            153167758
        ],
        "B": [
            153162156,
            153162580,
            153161952,
            153162200,
            153164678,
            153162918,
            153163800,
            153162935,
            153167883,
            153164440,
            153162927,
            153168126,
            153181318,
            153200885,
            153216655,
            153161628,
            153165270,
            153163647,
            153161926
        ],
        "A": [
            153160994,
            153160951,
            153163491,
            153160922,
            153160942,
            153161262,
            153161508,
            153160985,
            153162410,
            153161094,
            153160862,
            153162511,
            153178823,
            153198439,
            153217630,
            153160910,
            153162727,
            153160959,
            153160858
        ]
    },
    "name": "A. Array Balancing",
    "statement": "You are given two arrays of length n: a_1, a_2,\r\ndots, a_n and b_1, b_2,\r\ndots, b_n.You can perform the following operation any number of times:\r\nChoose integer index i (1\r\nle i\r\nle n); Swap a_i and b_i. What is the minimum possible sum |a_1 - a_2| +\r\n|a_2 - a_3| +\r\ndots + |a_{n-1} - a_n| + |b_1 - b_2| + |b_2 - b_3| +\r\ndots + |b_{n-1} - b_n| (in other words,\r\nsum\r\nlimits_{i=1}^{n - 1}{\r\nleft(|a_i - a_{i+1}| + |b_i - b_{i+1}|\r\nright)}) you can achieve after performing several (possibly, zero)\r\noperations?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int j = 0; j < n; j++){\n      cin >> a[j];\n    }\n    vector<int> b(n);\n    for (int j = 0; j < n; j++){\n      cin >> b[j];\n    }\n    long long ans = 0;\n    for (int j = 0; j < n - 1; j++){\n      ans += min(abs(a[j + 1] - a[j]) + abs(b[j + 1] - b[j]), abs(a[j + 1] - b[j]) + abs(b[j + 1] - a[j]));\n    }\n    cout << ans << endl;\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Array Balancing.json",
    "editorial_link": "https://codeforces.com//blog/entry/101790",
    "editorial": "Let\u00e2\u0080\u0099s look at our arrays and . Note that for any position such that we\r\ncan always \"fix it\" by swapping positions from to . In that case,\r\ncontribution from all won\u00e2\u0080\u0099t change, contribution of pair will decrease\r\nand contribution from all won\u00e2\u0080\u0099t change again, since we swapped all of\r\nthem.It means that we already can use the following algorithm: while\r\nexists such that just swap all from to . This solution works for per\r\ntest, that should be enough.But we can optimize our approach by\r\nrealizing that we can (instead of searching each time) just go from to\r\nand fix pairs one by one: if then swap with ; next, if then swap with\r\nand so on. In such way, solution works in .\r\n"
}