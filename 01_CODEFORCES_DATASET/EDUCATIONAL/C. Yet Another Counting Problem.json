{
    "link": "https://codeforces.com//contest/1342/problem/C",
    "problemId": "604758",
    "problem_idx": "C",
    "shortId": "1342C",
    "contest_number": "1342",
    "problem_submissions": {
        "F": [
            78207467,
            78205817,
            78205943,
            78204678,
            78303371,
            78242472,
            78242440,
            78242319,
            78242310,
            78242303,
            78242233,
            78206781,
            78205447,
            78186696,
            78527031,
            78214922,
            78227172,
            78226873,
            78225695,
            78223681,
            78223297,
            78309995
        ],
        "E": [
            78177071,
            78184631,
            78183322,
            78182599,
            78180358,
            78183013,
            78207444,
            78167441,
            78172844,
            78527023,
            78170429,
            78166909,
            78409946,
            78177636,
            78170212,
            78167446,
            78169823,
            78170875,
            78173864,
            78184907,
            78181489,
            78183649,
            78170771,
            78176771
        ],
        "D": [
            78151939,
            78159481,
            78160158,
            78169080,
            78162112,
            78191720,
            78157598,
            78162251,
            78527016,
            78158733,
            78159121,
            78158539,
            78153238,
            78158581,
            78162104,
            78158417,
            78161220,
            78159573,
            78156760,
            78155231,
            78161242
        ],
        "B": [
            78134011,
            78131222,
            78131215,
            78138260,
            78132277,
            78189261,
            78129032,
            78126918,
            78527008,
            78133543,
            78129305,
            78126816,
            78131103,
            78132696,
            78132210,
            78133794,
            78131695,
            78131819,
            78131288,
            78134923,
            78135996
        ],
        "A": [
            78131888,
            78126534,
            78126963,
            78132887,
            78127318,
            78126206,
            78126166,
            78126082,
            78527005,
            78128059,
            78126263,
            78126121,
            78126742,
            78126275,
            78127236,
            78128360,
            78126590,
            78126515,
            78127035,
            78131641,
            78127186
        ],
        "C": [
            78127633,
            78147176,
            78139297,
            78163411,
            78150308,
            78144130,
            78139528,
            78141789,
            78138222,
            78527011,
            78139530,
            78141232,
            78145910,
            78135141,
            78142133,
            78151945,
            78141231,
            78149349,
            78144977,
            78144111,
            78142843,
            78144643,
            78150859
        ]
    },
    "name": "C. Yet Another Counting Problem",
    "statement": "You are given two integers a and b, and q queries. The i-th query\r\nconsists of two numbers l_i and r_i, and the answer to it is the number\r\nof integers x such that l_i\r\nle x\r\nle r_i, and ((x\r\nbmod a)\r\nbmod b)\r\nne ((x\r\nbmod b)\r\nbmod a). Calculate the answer for each query.Recall that y\r\nbmod z is the remainder of the division of y by z. For example, 5\r\nbmod 3 = 2, 7\r\nbmod 8 = 7, 9\r\nbmod 4 = 1, 9\r\nbmod 9 = 0.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint f[100000];\nlong long solve(long long p, int n) {\n\treturn f[n - 1] * (p / n) + f[p % n];\n}\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t --) {\n\t\tint a, b, q;\n\t\tscanf(\"%d %d %d\", &a, &b, &q);\n\t\tint n = a * b;\n\t\tfor (int i = 1; i < n; i ++) {\n\t\t\tf[i] = f[i - 1];\n\t\t\tif(i % a % b != i % b % a)\n\t\t\t                f[i] ++;\n\t\t}\n\t\twhile(q --) {\n\t\t\tlong long l, r;\n\t\t\tscanf(\"%I64d %I64d\", &l, &r);\n\t\t\tprintf(\"%I64d \", solve(r, n) - solve(l - 1, n));\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Yet Another Counting Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/76633",
    "editorial": "It\u00e2\u0080\u0099s quite easy to see that . What does it mean? The property given in\r\nthe statement holds for if and only if it holds for . It allows us to\r\nanswer each testcase in as follows: for each number from to , we may\r\ncheck the given property before processing the queries, and build an\r\narray of prefix sums on it to efficiently count the number of integers\r\nsatisfying the property from the segment , where . Then each query can\r\nbe divided into two prefix-queries and . To answer a prefix query in ,\r\nwe can calculate the number of \"full segments\" of length inside this\r\nprefix (that is ) and the length of the last segment of numbers that\r\ndon\u00e2\u0080\u0099t belong into a full segment (that is ). To handle full segments, we\r\nmultiply the number of integers satisfying the property on one segment\r\nby the number of such segments, and to handle the last part of segment,\r\nwe use prefix sums.\r\n"
}