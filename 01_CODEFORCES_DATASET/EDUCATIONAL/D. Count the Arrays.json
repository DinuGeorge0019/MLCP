{
    "link": "https://codeforces.com//contest/1312/problem/D",
    "problemId": "557980",
    "problem_idx": "D",
    "shortId": "1312D",
    "contest_number": "1312",
    "problem_submissions": {
        "G": [
            72824912,
            72825940,
            72832858,
            72832125,
            72830981,
            72830579,
            72827258,
            72818410,
            73118157,
            72832195,
            72826680,
            72837006,
            72831183,
            72846291,
            72845347,
            72835299,
            72834657,
            72834166,
            72836122,
            72834407,
            72826975,
            72828977,
            72837738,
            72829233,
            72828895,
            72814710
        ],
        "F": [
            72816196,
            72815449,
            72836440,
            72835939,
            72833544,
            72818707,
            72831850,
            73118148,
            72823917,
            72821869,
            72817848,
            72823973,
            72825602,
            72821962,
            72825661,
            72827867,
            72825004,
            72836754,
            72835570,
            72830789,
            72837405,
            72824053,
            72824708
        ],
        "E": [
            72807538,
            72806508,
            72938781,
            72938462,
            72938238,
            72849613,
            72849474,
            72839861,
            72834168,
            72811533,
            72810583,
            73118128,
            72810138,
            72811240,
            72806275,
            72810780,
            72813492,
            72813999,
            72814345,
            72819726,
            72816559,
            72814069,
            72818755,
            72815412,
            72820356,
            72810691,
            72826172
        ],
        "D": [
            72804418,
            72803272,
            72940991,
            72940962,
            72801330,
            72805787,
            73118118,
            72807156,
            72809073,
            86477031,
            72803786,
            72808232,
            72806322,
            72805660,
            72809462,
            72812808,
            72814419,
            72810586,
            72812917,
            72812165,
            72817006,
            72832064,
            72827740
        ],
        "C": [
            72798692,
            72799958,
            72796730,
            72804789,
            73118106,
            72800009,
            72800362,
            72797813,
            72800910,
            72799283,
            72799712,
            72801433,
            72802442,
            72813095,
            72802040,
            72808078,
            72800616,
            72812371,
            72830092,
            72828590
        ],
        "B": [
            72793777,
            72794214,
            72793197,
            72797455,
            73118103,
            72795859,
            72796621,
            72793808,
            72794859,
            72794981,
            72794667,
            72795692,
            72795259,
            72794528,
            72797051,
            72796632,
            72795714,
            72810192,
            72793542,
            72829098
        ],
        "A": [
            72792172,
            72792542,
            72792143,
            72792487,
            73118076,
            72793403,
            72793192,
            72792295,
            72792118,
            72792591,
            72792492,
            72792213,
            72792502,
            72792229,
            72794177,
            72793376,
            72792458,
            72809334,
            72829278,
            72829336
        ]
    },
    "name": "D. Count the Arrays",
    "statement": "Your task is to calculate the number of arrays such that: each array\r\ncontains n elements; each element is an integer from 1 to m; for each\r\narray, there is one pair of equal elements; for each array a, there\r\nexists an index i such that the array is before the i-th element and\r\nafter it (formally, it means that a_j < a_{j + 1}, if j < i, and a_j >\r\na_{j + 1}, if j\r\nge i).\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = 998244353;\n\nconst int root = 646;\n\nconst int root_1 = 208611436;\n\nconst int root_pw = 1<<20;\n\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\n\nconst int maxN = 2 * (int)1e5 + 100;\n\nint fact[maxN], invfact[maxN], inv[maxN];\n\nvoid init() {\n    inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n}\n\nint cnk(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return mult(fact[n], mult(invfact[k], invfact[n - k]));\n}\n\nint invNumber(int a) {\n    return pw(a, mod - 2);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    init();\n    int n, m;\n    cin >> n >> m;\n    if (n == 2) {\n        cout << 0;\n        return 0;\n    }\n    cout << mult(pw(2, n - 3), mult(cnk(m, n - 1), n - 2));\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Count the Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/74640",
    "editorial": "First of all, there will be exactly distinct elements in our array.\r\nLetâs choose them, there are ways to do that.After that, there should be\r\nexactly one element that appears twice. There are elements to choose\r\nfrom, but are all of them eligible? If we duplicate the maximum element,\r\nthere will be no way to meet the fourth condition. So we should multiply\r\nthe current answer by , not .And finally, some elements will appear\r\nearlier than the maximum in our array, and some later. The duplicated\r\nelement will appear on both sides, but all other elements should appear\r\neither to the left or to the right, so there are ways to choose their\r\npositions.Thus the answer is . Note that you have to precompute all\r\nfactorials and use their inverse elements to calculate .Note that there\r\nis a tricky case when : some binpow implementations go into infinite\r\nloop trying to compute , so you may have to handle it specifically.\r\n",
    "hint": []
}