{"link": "https://codeforces.com//contest/1499/problem/F", "problemId": "928254", "problem_idx": "F", "shortId": "1499F", "contest_number": "1499", "problem_submissions": {"F": [110357719, 110358460, 110349173, 110358016, 110369330, 110363127, 110361036, 110362817, 110367470, 110357203, 110369171, 110368211, 110370268, 110366091, 110355624, 110365992, 110369429, 110370266, 110365656], "E": [110348041, 110354549, 110362433, 110350437, 110347357, 110357359, 110349011, 110357563, 110354502, 110352211, 110355950, 110358510, 110361861, 110360330, 110370250, 110360561, 110360403, 110361550, 110357936], "D": [110338625, 110339185, 110410334, 110410318, 110410229, 110342082, 110340758, 110337901, 110434363, 110434311, 110432471, 110432456, 110384121, 110347999, 110344468, 110349024, 110347133, 110346694, 110345990, 110348574, 110343676, 110346592, 110347088, 110350111, 110350771, 110350595, 110349856], "C": [110333651, 110331021, 110334430, 110335594, 110331843, 110335775, 110331846, 110336227, 110336058, 110339413, 110333925, 110337781, 110335754, 110338528, 110342766, 110337144, 110339220, 110337699, 110337911], "B": [110328704, 110327182, 110329276, 110330310, 110327534, 110329852, 110327723, 110329207, 110329841, 110333664, 110328875, 110331182, 110328187, 110334069, 110334004, 110328671, 110331437, 110330565, 110331774], "A": [110326019, 110325991, 110326313, 110326005, 110325865, 110325899, 110325997, 110326125, 110326016, 110326091, 110326392, 110325908, 110325927, 110326243, 110325858, 110326228, 110326284, 110326209, 110326298], "G": [110573818, 110399277, 112155486, 110386520, 110388825]}, "name": "F. Diameter Cuts", "statement": "You are given an integer k and an undirected tree, consisting of n\r\nvertices.The length of a simple path (a path in which each vertex\r\nappears at most once) between some pair of vertices is the number of\r\nedges in this path. A diameter of a tree is the maximum length of a\r\nsimple path between all pairs of vertices of this tree.You are about to\r\nremove a set of edges from the tree. The tree splits into multiple\r\nsmaller trees when the edges are removed. The set of edges is valid if\r\nall the resulting trees have diameter less than or equal to k.Two sets\r\nof edges are different if there is an edge such that it appears in only\r\none of the sets.Count the number of valid sets of edges modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nint N, K;\nint sz[5050];\nll D[5050][5050];\nll tmp[5050];\n\nvector<int> adj[5050];\n\nvoid dfs(int v, int p) {\n\tsz[v] = 1;\n\tD[v][0] = 1;\n\tfor(int i : adj[v]) {\n\t\tif(i == p) continue;\n\t\tdfs(i, v);\n\t\tfor(int j = 0; j <= sz[v] + sz[i]; j++) tmp[j] = 0;\n\t\tll tot = 0;\n\t\tfor(int j = 0; j <= sz[i]; j++) tot = (tot + D[i][j]) % MOD;\n\n\t\tfor(int j = 0; j <= sz[v]; j++) tmp[j] = (D[v][j] * tot) % MOD;\n\t\tfor(int j = 0; j <= sz[v]; j++) {\n\t\t\tfor(int k = 0; k <= sz[i]; k++) {\n\t\t\t\tif(j + k + 1 > K) continue;\n\t\t\t\tint m = max(j, k + 1);\n\t\t\t\ttmp[m] = (tmp[m] + D[v][j] * D[i][k]) % MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j <= sz[v] + sz[i]; j++) D[v][j] = tmp[j];\n\t\tsz[v] += sz[i];\n\t}\n\t// printf(\"%d\\n\", v);\n\t// for(int i = 0; i <= sz[v]; i++) printf(\"%lld \", D[v][i]); puts(\"\");\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &K);\n\tfor(int i = 1; i < N; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\n\tdfs(1, 0);\n\tll ans = 0;\n\tfor(int i = 0; i <= N; i++) ans = (ans + D[1][i]) % MOD;\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "dfs and similar", "dp", "trees"], "dificulty": "2400", "interactive": false}