{
    "link": "https://codeforces.com//contest/1499/problem/F",
    "problemId": "928254",
    "problem_idx": "F",
    "shortId": "1499F",
    "contest_number": "1499",
    "problem_submissions": {
        "F": [
            110357719,
            110358460,
            110349173,
            110358016,
            110369330,
            110363127,
            110361036,
            110362817,
            110367470,
            110357203,
            110369171,
            110368211,
            110370268,
            110366091,
            110355624,
            110365992,
            110369429,
            110370266,
            110365656
        ],
        "E": [
            110348041,
            110354549,
            110362433,
            110350437,
            110347357,
            110357359,
            110349011,
            110357563,
            110354502,
            110352211,
            110355950,
            110358510,
            110361861,
            110360330,
            110370250,
            110360561,
            110360403,
            110361550,
            110357936
        ],
        "D": [
            110338625,
            110339185,
            110410334,
            110410318,
            110410229,
            110342082,
            110340758,
            110337901,
            110434363,
            110434311,
            110432471,
            110432456,
            110384121,
            110347999,
            110344468,
            110349024,
            110347133,
            110346694,
            110345990,
            110348574,
            110343676,
            110346592,
            110347088,
            110350111,
            110350771,
            110350595,
            110349856
        ],
        "C": [
            110333651,
            110331021,
            110334430,
            110335594,
            110331843,
            110335775,
            110331846,
            110336227,
            110336058,
            110339413,
            110333925,
            110337781,
            110335754,
            110338528,
            110342766,
            110337144,
            110339220,
            110337699,
            110337911
        ],
        "B": [
            110328704,
            110327182,
            110329276,
            110330310,
            110327534,
            110329852,
            110327723,
            110329207,
            110329841,
            110333664,
            110328875,
            110331182,
            110328187,
            110334069,
            110334004,
            110328671,
            110331437,
            110330565,
            110331774
        ],
        "A": [
            110326019,
            110325991,
            110326313,
            110326005,
            110325865,
            110325899,
            110325997,
            110326125,
            110326016,
            110326091,
            110326392,
            110325908,
            110325927,
            110326243,
            110325858,
            110326228,
            110326284,
            110326209,
            110326298
        ],
        "G": [
            110573818,
            110399277,
            112155486,
            110386520,
            110388825
        ]
    },
    "name": "F. Diameter Cuts",
    "statement": "You are given an integer k and an undirected tree, consisting of n\r\nvertices.The length of a simple path (a path in which each vertex\r\nappears at most once) between some pair of vertices is the number of\r\nedges in this path. A diameter of a tree is the maximum length of a\r\nsimple path between all pairs of vertices of this tree.You are about to\r\nremove a set of edges from the tree. The tree splits into multiple\r\nsmaller trees when the edges are removed. The set of edges is valid if\r\nall the resulting trees have diameter less than or equal to k.Two sets\r\nof edges are different if there is an edge such that it appears in only\r\none of the sets.Count the number of valid sets of edges modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nint N, K;\nint sz[5050];\nll D[5050][5050];\nll tmp[5050];\n\nvector<int> adj[5050];\n\nvoid dfs(int v, int p) {\n\tsz[v] = 1;\n\tD[v][0] = 1;\n\tfor(int i : adj[v]) {\n\t\tif(i == p) continue;\n\t\tdfs(i, v);\n\t\tfor(int j = 0; j <= sz[v] + sz[i]; j++) tmp[j] = 0;\n\t\tll tot = 0;\n\t\tfor(int j = 0; j <= sz[i]; j++) tot = (tot + D[i][j]) % MOD;\n\n\t\tfor(int j = 0; j <= sz[v]; j++) tmp[j] = (D[v][j] * tot) % MOD;\n\t\tfor(int j = 0; j <= sz[v]; j++) {\n\t\t\tfor(int k = 0; k <= sz[i]; k++) {\n\t\t\t\tif(j + k + 1 > K) continue;\n\t\t\t\tint m = max(j, k + 1);\n\t\t\t\ttmp[m] = (tmp[m] + D[v][j] * D[i][k]) % MOD;\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j <= sz[v] + sz[i]; j++) D[v][j] = tmp[j];\n\t\tsz[v] += sz[i];\n\t}\n\t// printf(\"%d\\n\", v);\n\t// for(int i = 0; i <= sz[v]; i++) printf(\"%lld \", D[v][i]); puts(\"\");\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &K);\n\tfor(int i = 1; i < N; i++) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\tadj[a].push_back(b);\n\t\tadj[b].push_back(a);\n\t}\n\n\tdfs(1, 0);\n\tll ans = 0;\n\tfor(int i = 0; i <= N; i++) ans = (ans + D[1][i]) % MOD;\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Diameter Cuts.json",
    "editorial_link": "https://codeforces.com//blog/entry/88812",
    "editorial": "The task is obviously solved by dynamic programming, so our first\r\nreaction should be to start looking for meaningful states for it.\r\nObviously, one of the states is the vertex which subtree we are\r\nprocessing. We can choose the root for the tree arbitrarily, let it be\r\nvertex . What can be the other helpful state?Consider the method to find\r\nthe diameter of the subtree of vertex . The diameter can be one of the\r\nfollowing paths: either the longest path that is completely in some\r\nsubtree of or the concatenation of the longest paths that start in\r\nvertex and end in different subtrees.The diameter is the longest path.\r\nThus, the diameter being less than or equal to means that all paths\r\nshould have length less than or equal to .If we can guarantee that no\r\npath that is completely in some subtree of have length greater than ,\r\nthen we will only have to worry about not concatenating long paths from\r\ndifferent subtrees. Phrase it the other way around: if we never\r\nconcatenate the paths from the different subtrees in such a way that\r\ntheir total length is greater than , then no diameter will be greater\r\nthan .Thus, we can attempt to have the number of ways to cut some edges\r\nin the subtree of in such a way that there is no path of length greater\r\nthan and the longest path starting at vertex has length .Now for the\r\ntransitions. For the simplicity, let vertex have exactly two children.\r\nItâs not too hard to merge their âs. Iterate over the length of the\r\nfirst child, the length of the second child. If , then you can\r\nconcatenate their longest paths and the longest path for will be of\r\nlength . You can also cut either of the edges from to the first child or\r\nto the second child.The approach is good, however, itâs not clear how to\r\nmake it work on a larger number of children. Also, the complexity sounds\r\npretty bad.Instead of merging children to each other, letâs merge each\r\nchild to the of one by one. can store the current maximum length over\r\nall processed children. When processing a new child, you can choose to\r\ncut or not to cut the edge to it. So you can iterate over the current\r\nlongest path from and the longest path from that child.So far, the only\r\nway to estimate the complexity is to say that each child has to merge\r\nits dp to the parent in , thus making the algorithm . Thatâs obviously\r\ntoo slow.The trick that makes the solution fast is to iterate not to but\r\nto the height of the subtree of and the subtree of a child. Surely, that\r\nis allowed, since the path just canât grow longer than that\r\nvalue.Consider the even worse option: not the height but the size of the\r\nsubtree. Itâs easy to see that the size is always greater or equal than\r\nthe height. Interpret the merge the following way: enumerate the\r\nvertices inside all the subtrees of the processed children and the\r\nvertices inside the subtree of the new child. Iterating up to the size\r\nof the subtree is the same number of moves as going over the vertices in\r\nit. The merge will go over all the pairs of vertices such that the first\r\nvertex of the pair is in the first set and the second vertex is in the\r\nsecond set. Thus, each pair of vertices of the tree will be processed\r\nexactly once (in lca of these vertices). There are such pairs, thus,\r\nsuch âs work in .Overall complexity: .\r\n",
    "hint": []
}