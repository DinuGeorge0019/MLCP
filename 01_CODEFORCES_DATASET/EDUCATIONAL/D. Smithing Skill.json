{
    "link": "https://codeforces.com//contest/1989/problem/D",
    "problemId": "2721697",
    "problem_idx": "D",
    "shortId": "1989D",
    "contest_number": "1989",
    "problem_submissions": {
        "F": [
            267852420,
            267715974,
            267712917,
            267719491,
            267734751,
            267735803,
            267741899,
            267747574,
            267768221,
            267767174,
            267766869,
            267748546,
            267750041,
            267754842,
            267760865,
            267768505,
            267763937,
            267766037,
            267765066,
            267764999,
            267764810
        ],
        "E": [
            267696430,
            267693533,
            267711891,
            267704153,
            267703845,
            267698823,
            267707139,
            267719026,
            267719849,
            267686019,
            267704171,
            267710707,
            267716623,
            267703403,
            267709172,
            267705649,
            267704995,
            267702509,
            267709118
        ],
        "D": [
            267685825,
            267682182,
            267696815,
            267692972,
            267693652,
            267703361,
            267692957,
            267722874,
            267708867,
            267680276,
            267687696,
            267691183,
            267686958,
            267692334,
            267690676,
            267692758,
            267695564,
            267692452,
            267700297
        ],
        "C": [
            267675529,
            267714300,
            267687642,
            267680264,
            267681105,
            267674205,
            267682216,
            267688126,
            267695068,
            267674713,
            267675536,
            267677226,
            267678584,
            267680860,
            267675171,
            267685177,
            267682170,
            267678912,
            267679841
        ],
        "B": [
            267671283,
            267671757,
            267674622,
            267674567,
            267676014,
            267669993,
            267681783,
            267674853,
            267678346,
            267669871,
            267670383,
            267672053,
            267670683,
            267671626,
            267671697,
            267673455,
            267674468,
            267674321,
            267671951
        ],
        "A": [
            267669443,
            267669849,
            267669717,
            267672060,
            267669107,
            267669168,
            267670166,
            267670012,
            267669413,
            267669118,
            267669169,
            267669489,
            267669101,
            267669245,
            267670092,
            267671181,
            267671315,
            267669875,
            267669241
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/130937",
    "editorial": "It's quite obvious that we should melt every weapon we forge, and we can do it as soon as we forge it. So, let's do these actions in pairs: forge a weapon, then instantly melt it.\n\nSince you can't use two types of metal while forging one weapon, we can solve our task independently for each metal type. Suppose you have x\n ingots of the chosen metal.\n\nYou can act greedily: you can forge only weapons of classes with ai?x\n, but among them, it's optimal to chose one that makes us lose the minimum number of ingots by forging it and melting it; so, we need to minimize the value of ai?bi\n. However, this greedy solution is too slow when implemented naively.\n\nLet's define A=maxai\n and look at two cases: x?A\n or x>A\n. If x?A\n, let's just precalculate answers ans[x]\n for all x\n from 0\n to A\n. To do so, let's precalculate another value best[x]\n as \"the minimum ai?bi\n among all classes i\n where ai?x\n\". In other words, best[x]\n will be equal to the minimum amount of ingots you'll lose if you have x\n ingots, and you need to forge-melt one weapon.\n\nWe can precalculate best[x]\n in two steps:\n\nfor each class i\n, we can set best[ai]=min(best[ai],ai?bi)\n;\nusing approach similar to prefix minima or dynamic programming, we can also update best[x]=min(best[x],best[x?1])\n for all x\n from 1\n to A\n.\nUsing the array best\n, we can calculate ans\n easily with dynamic programming: ans[x]=2+ans[x?best[x]]\n for all x\n from 1\n to A\n.\nIn case x>A\n, we can forge-melt a weapon with minimum ai?bi\n as many times as we can until x?A\n. Once x\n becomes less or equal to A\n, we can take the value ans[x]\n and finish processing that metal type.\n\nKnowing that the minimum ai?bi\n is just best[A]\n, we can reformulate our first step as finding minimum k\n such that x?k?best[A]?A\n or k?x?Abest[A]\n. In other words, we'll make the first step exactly k=?x?Abest[A]?\n times. So we can calculate the final answer as 2k+ans[x?k?best[A]]\n.\n\nAs a result, we run precalculating in O(n+A)\n time and process each metal type in O(1)\n time. The total complexity is O(n+m+A)\n time and space.\n",
    "name": "D. Smithing Skill",
    "statement": "You are playing a famous computer game (that just works) where you have\r\nvarious skills you can level up. Today, you focused on the \"Smithing\"\r\nskill. Your tactic is obvious: forging weapons from ingots and then\r\nmelting them back to return the materials partially. For simplicity,\r\nevery time you create an item, you get 1 experience point, and every\r\ntime you melt an item, you also get 1 experience point.There are n\r\nclasses of weapons you can forge and m types of metal ingots.You can\r\ncreate one weapon of the i-th class, spending a_i ingots of metal of .\r\nMelting a weapon of the i-th class (which you crafted earlier) returns\r\nyou b_i ingots of the type of metal .You have c_j metal ingots of the\r\nj-th type, and you know that you can craft a weapon of any class from\r\nany metal type. Each combination of a weapon class and a metal type can\r\nbe used any number of times.What is the maximum total amount of\r\nexperience you can earn by crafting and melting weapons?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;\u00a0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\u00a0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\u00a0using pii=pair<int,int>;using pll=pair<ll,ll>;\u00a0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\u00a0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\u00a0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\u00a0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\u00a0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\u00a0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\u00a0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\u00a0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\u00a0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << ' ' << p.second;}\u00a0#ifdef i_am_noob#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}#else#define bug(...) 777771449#endif\u00a0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(T && x) {cout << x << \"\\n\";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\u00a0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\u00a0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\u00a0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\u00a0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\u00a0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\u00a0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\u00a0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\u00a0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\u00a0//#include<atcoder/all>//using namespace atcoder;\u00a0//using mint=modint998244353;//using mint=modint1000000007;\u00a0void ahcorz(){    int n,m; cin >> n >> m;    vc<pii> a(n);    rep(n) cin >> a[i].first;    rep(n) cin >> a[i].second,a[i].second=a[i].first-a[i].second;    sort(all(a));    vc<pii> b;    for(auto &[x,y]: a){        if(sz(b)&&y>=b.back().second) continue;        b.pb({x,y});    }    vi dp(1000005);    int cur=0;    rep(i,1,sz(dp)){        while(cur+1<sz(b)&&b[cur+1].first<=i) cur++;        if(b[cur].first<=i){            dp[i]=dp[i-b[cur].second]+1;        }    }    ll res=0;    rep(_,m){        ll x; cin >> x;        if(x>=sz(dp)){            ll y=(x-sz(dp)+1+b.back().second-1)/b.back().second;            res+=y;            x-=y*b.back().second;        }        if(x>=0) res+=dp[x];    }    print(res*2);}\u00a0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dp",
        "greedy",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Smithing Skill.json"
}