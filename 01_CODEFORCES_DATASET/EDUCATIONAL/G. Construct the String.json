{
    "link": "https://codeforces.com//contest/1366/problem/G",
    "problemId": "646805",
    "problem_idx": "G",
    "shortId": "1366G",
    "contest_number": "1366",
    "problem_submissions": {
        "F": [
            83447668,
            83448434,
            83444622,
            83426763,
            83441574,
            83428280,
            83460965,
            83423891,
            83442353,
            83757770,
            83445090,
            83429919,
            83438895,
            83437207,
            83492622,
            83492442,
            83474062,
            83453556,
            83447806
        ],
        "G": [
            83429184,
            83428882,
            83457684,
            83412158,
            83433864,
            83437984,
            83494857,
            83757790,
            83510645,
            83444271,
            83455262,
            83440823,
            83444943,
            83578671,
            83450093
        ],
        "E": [
            83398532,
            83418602,
            83409360,
            83402434,
            83412489,
            83410962,
            83757722,
            83418361,
            83408316,
            83407997,
            83427080,
            83413277,
            83416924,
            83424580,
            83418188,
            83406625,
            83420403,
            83421638
        ],
        "D": [
            83393167,
            83406995,
            83402251,
            83397827,
            83397479,
            83404641,
            83397199,
            83402779,
            83757690,
            83407778,
            83401287,
            83402226,
            83406676,
            83407995,
            83406280,
            83407838,
            83409402,
            83421660,
            83414839,
            83414935
        ],
        "C": [
            83390782,
            83401605,
            83394916,
            83391593,
            83392337,
            83394149,
            83393867,
            83397548,
            83757664,
            83394207,
            83391231,
            83395559,
            83398133,
            83401855,
            83400985,
            83402206,
            83402544,
            83397821,
            83396193,
            83400630
        ],
        "B": [
            83389935,
            83490415,
            83397273,
            83390226,
            83389902,
            83389999,
            83390997,
            83390624,
            83757653,
            83390343,
            83389925,
            83392810,
            83391891,
            83392040,
            83392753,
            83394886,
            83392865,
            83391554,
            83391226,
            83391686
        ],
        "A": [
            83389637,
            83390640,
            83389645,
            83389626,
            83389634,
            83389655,
            83389755,
            83757620,
            83389748,
            83389663,
            83390083,
            83389875,
            83389821,
            83390216,
            83392108,
            83390187,
            83390121,
            83389679,
            83389858
        ]
    },
    "name": "G. Construct the String",
    "statement": "Let’s denote the function f(s) that takes a string s consisting of\r\nlowercase Latin letters and dots, and returns a string consisting of\r\nlowercase Latin letters as follows: let r be an empty string; process\r\nthe characters of s from left to right. For each character c, do the\r\nfollowing: if c is a lowercase Latin letter, append c at the end of the\r\nstring r; otherwise, delete the last character from r (if r is empty\r\nbefore deleting the last character the function crashes); return r as\r\nthe result of the function. You are given two strings s and t. You have\r\nto delete the minimum possible number of characters from s so that f(s)\r\n= t (and the function does not crash). Note that you aren’t allowed to\r\ninsert new characters into s or reorder the existing ones.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tstring s, t;\n\tcin >> s >> t;\n\tvector<int> psum(21000, 0);\n\tpsum[0] = 10100;\n\ts = s + \"48\";\n\tt = t + \"48\";\n\tint n = (int)s.size();\n\tfor(int i = 0; i < n; i++){\n\t\tpsum[i+1] = psum[i] + (s[i] == '.' ? -1 : 1);\n\t}\n\tvector<int> dp(n+1, 1e8);\n\tdp[0] = 0;\n\tvector<int> dp_mid(n+1, 1e8);\n\tvector<int> new_dp(n+1, 1e8);\n\tvector<int> z1(21000);\n\tvector<int> z2(21000);\n\tfor(char c : t){\n\t\tz1.assign(21000, 1e8);\n\t\tz2.assign(21000, 1e8);\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tdp[i] += psum[i];\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tz1[psum[i]] = min(z1[psum[i]], dp[i]);\n\t\t\tz1[psum[i]] = min(z1[psum[i]], z1[psum[i] + 1]);\n\t\t\tif(i > 0 && psum[i-1] > psum[i]) z1[psum[i-1]] = 1e8;\n\t\t\tdp_mid[i] = z1[psum[i]];\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tdp_mid[i] -= 2 * psum[i];\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tz2[psum[i]] = min(z2[psum[i]], dp_mid[i]);\n\t\t\tz2[psum[i]] = min(z2[psum[i]], z2[psum[i] - 1]);\n\t\t\tz2[psum[i] + 1] = 1e8;\n\t\t\tnew_dp[i] = z2[psum[i]];\n\t\t}\n\t\tfor(int i = 0; i <= n; i++){\n\t\t\tnew_dp[i] += psum[i];\n\t\t}\n\t\tdp.assign(n+1, 1e8);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(s[i-1] == c) dp[i] = new_dp[i-1];\n\t\t}\n\t}\n\tassert(dp.back() < (int)1e8);\n\tcout << dp.back() << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "strings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Construct the String.json",
    "editorial_link": "https://codeforces.com//blog/entry/78735",
    "editorial": "The core idea of the solution is the following dynamic programming: is\r\nthe minimum number of characters we have to delete if we considered a\r\nsubsequence of first characters of , and it maps to first characters of\r\n.There are three obvious transitions in this dynamic programming: we can\r\ngo from to by skipping ; if , we can go from to ; if is a dot, we can go\r\nfrom to . Unfortunately, these transitions cannot fully handle the case\r\nwhen we want to put some character and then delete it (these transitions\r\ndonât allow us to do it for any character, only for some specific ones\r\nin specific situations). To handle it, suppose we want to take the\r\ncharacter and then delete it, and we model it as follows: there exists\r\nthe fourth transition from to without deleting anything, where is the\r\nlength of the shortest substring of starting from that becomes empty if\r\nwe apply the function to it. This substring can be described as a\r\nregular bracket sequence, where opening brackets correspond to letters,\r\nand closing brackets to dots. We can precalculate this substring for\r\neach in .Why is this transition enough? Suppose we donât want to take\r\nsome letter from this shortest substring in the optimal answer; since it\r\nis the shortest substring meeting these constraints, the number of\r\nletters on each prefix of it (excluding the substring itself) is greater\r\nthan the number of dots, so we can instead skip the first letter and try\r\napplying this transition from , so this case is handled. And skipping\r\nany dots from this shortest substring is also suboptimal since we have\r\nto get rid of the character .\r\n",
    "hint": []
}