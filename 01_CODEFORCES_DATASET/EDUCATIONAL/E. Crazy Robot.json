{
    "link": "https://codeforces.com//contest/1613/problem/E",
    "problemId": "1209365",
    "problem_idx": "E",
    "shortId": "1613E",
    "contest_number": "1613",
    "problem_submissions": {
        "F": [
            137662460,
            137680102,
            137669930,
            137680388,
            137676481,
            137689054,
            137677544,
            137670783,
            137684225,
            137683109,
            137695659,
            137689822,
            137678272,
            137672898,
            137688331,
            137700851,
            137691450,
            137776678,
            137775393,
            137689226,
            137689675,
            137703031
        ],
        "E": [
            137655072,
            137656585,
            137663380,
            137661012,
            137661380,
            137660230,
            137663524,
            137662766,
            137664563,
            137669185,
            137669422,
            137670709,
            137669302,
            137681566,
            137674305,
            137665393,
            137678462,
            137670584,
            137679435,
            137664635
        ],
        "D": [
            137646881,
            137645109,
            137652424,
            137648321,
            137652518,
            137652740,
            137657211,
            137653818,
            137651858,
            137656413,
            137653916,
            137656694,
            137657143,
            137657455,
            137659528,
            137655936,
            137665693,
            137656041,
            137646478,
            137655272
        ],
        "C": [
            137634971,
            137635045,
            137641150,
            137632004,
            137642031,
            137634798,
            137639433,
            137636954,
            137638798,
            137636121,
            137638972,
            137644414,
            137635322,
            137642182,
            137647281,
            137639264,
            137643162,
            137637445,
            137634607,
            137639818
        ],
        "B": [
            137631052,
            137629986,
            137635688,
            137629262,
            137630431,
            137630193,
            137632384,
            137630955,
            137634981,
            137632132,
            137632097,
            137637773,
            137629234,
            137636896,
            137636754,
            137634314,
            137635536,
            137633727,
            137630130,
            137635595
        ],
        "A": [
            137628660,
            137628698,
            137630882,
            137628467,
            137628655,
            137628608,
            137630089,
            137628835,
            137631891,
            137629156,
            137628914,
            137629328,
            137628519,
            137632470,
            137630776,
            137629772,
            137629039,
            137628924,
            137628505,
            137630736
        ]
    },
    "name": "E. Crazy Robot",
    "statement": "There is a grid, consisting of n rows and m columns. Each cell of the\r\ngrid is either free or blocked. One of the free cells contains a lab.\r\nAll the cells beyond the borders of the grid are also blocked.A crazy\r\nrobot has escaped from this lab. It is currently in some free cell of\r\nthe grid. You can send one of the following commands to the robot: \"move\r\nright\", \"move down\", \"move left\" or \"move up\". Each command means moving\r\nto a neighbouring cell in the corresponding direction.However, as the\r\nrobot is crazy, it will do anything except following the command. Upon\r\nreceiving a command, it will choose a direction such that it differs\r\nfrom the one in command and the cell in that direction is not blocked.\r\nIf there is such a direction, then it will move to a neighbouring cell\r\nin that direction. Otherwise, it will do nothing.We want to get the\r\nrobot to the lab to get it fixed. For each free cell, determine if the\r\nrobot can be forced to reach the lab starting in this cell. That is,\r\nafter each step of the robot a command can be sent to a robot such that\r\nno matter what different directions the robot chooses, it will end up in\r\na lab.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nvoid solve() {\n\tint n = nxt(), m = nxt();\n\tvector<string> a(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t}\n\n\tvector<pair<int, int>> coords;\n\tvector<vector<int>> g;\n\tvector<vector<int>> id(n, vector<int>(m, -1));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (a[i][j] == '#') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid[i][j] = g.size();\n\t\t\tg.push_back({});\n\t\t\tcoords.push_back({i, j});\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (a[i][j] == '#') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (int dx = -1; dx <= 1; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 1; ++dy) {\n\t\t\t\t\tif (abs(dx) + abs(dy) != 1) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint ni = i + dx, nj = j + dy;\n\t\t\t\t\tif (clamp(ni, 0, n - 1) != ni || clamp(nj, 0, m - 1) != nj) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (a[ni][nj] == '#') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tg[id[i][j]].push_back(id[ni][nj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint lab = -1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (a[i][j] == 'L') {\n\t\t\t\tlab = id[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tconst int sz = g.size();\n\tvector<char> used(sz);\n\tvector<int> rem(sz);\n\tfor (int i = 0; i < sz; ++i) {\n\t\trem[i] = g[i].size();\n\t}\n\tvector<int> st = {lab};\n\tused[lab] = true;\n\twhile (!st.empty()) {\n\t\tint v = st.back();\n\t\tst.pop_back();\n\t\tfor (int x : g[v]) {\n\t\t\t--rem[x];\n\t\t\tif (!used[x] && rem[x] <= 1) {\n\t\t\t\tused[x] = 1;\n\t\t\t\tst.push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < sz; ++i) {\n\t\tif (used[i] && i != lab) {\n\t\t\tauto [x, y] = coords[i];\n\t\t\ta[x][y] = '+';\n\t\t}\n\t}\n\tfor (auto s : a) {\n\t\tcout << s << \"\\n\";\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint t = nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Crazy Robot.json",
    "editorial_link": "https://codeforces.com//blog/entry/97467",
    "editorial": "One way to think about this problem is in game theory terms.Imagine a\r\nfollowing game. Two players alternate moves. The first players chooses a\r\ndirection. The second player chooses a different direction and moves a\r\nrobot there. The game ends when the robot reaches the lab, and the first\r\nplayer wins. Otherwise, it\u00e2\u0080\u0099s a draw. What\u00e2\u0080\u0099s the outcome of the game if\r\nboth players play optimally (as in the first player tries to win, the\r\nsecond player tries to draw)?Does it sound easier? Well, it sure does if\r\nyou ever dealt with solving games on arbitrary graphs. You can skim\r\nthrough this article if that\u00e2\u0080\u0099s unfamiliar to you. The state of the game\r\nis a pair . If a direction is not chosen (denote it with ), it\u00e2\u0080\u0099s the\r\nfirst player\u00e2\u0080\u0099s move. Otherwise, it\u00e2\u0080\u0099s the second player\u00e2\u0080\u0099s move.You can\r\neven implement it as is. Or you can adjust a part of this algorithm for\r\nthis particular problem. Initially, all the states are drawing, only the\r\nstate is winning. What we basically need is a way to determine if a\r\nstate is winning or not. From game theory, we can tell that the state is\r\nwinning if there\u00e2\u0080\u0099s a transition from it to a losing state. The state is\r\nlosing if all the transitions from it lead to winning states. So is\r\nwinning if any of are losing.Promote that one step further. The state is\r\nwinning if there exists such a direction that all neighbouring free\r\ncells except in this direction are winning states. Rephrase it. The\r\nstate is winning if it has at least one winning state neighbour and no\r\nmore than one non-winning state neighbour.Let\u00e2\u0080\u0099s store the number of\r\nnon-winning neighbouring states for each cell. Initially, it\u00e2\u0080\u0099s the\r\nnumber of neighbouring free cells. If some state becomes marked as\r\nwinning, decrease the value for each of its neighbours by . If some\r\nstate\u00e2\u0080\u0099s value reaches or after this operation, mark it as winning.Since\r\nwhat this does is basically a traversal of a grid, this can be done with\r\na DFS/BFS, starting from the lab.Overall complexity: per testcase.\r\n"
}