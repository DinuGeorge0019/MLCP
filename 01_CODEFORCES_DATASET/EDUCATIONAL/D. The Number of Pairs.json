{
    "link": "https://codeforces.com//contest/1499/problem/D",
    "problemId": "928252",
    "problem_idx": "D",
    "shortId": "1499D",
    "contest_number": "1499",
    "problem_submissions": {
        "F": [
            110357719,
            110358460,
            110349173,
            110358016,
            110369330,
            110363127,
            110361036,
            110362817,
            110367470,
            110357203,
            110369171,
            110368211,
            110370268,
            110366091,
            110355624,
            110365992,
            110369429,
            110370266,
            110365656
        ],
        "E": [
            110348041,
            110354549,
            110362433,
            110350437,
            110347357,
            110357359,
            110349011,
            110357563,
            110354502,
            110352211,
            110355950,
            110358510,
            110361861,
            110360330,
            110370250,
            110360561,
            110360403,
            110361550,
            110357936
        ],
        "D": [
            110338625,
            110339185,
            110410334,
            110410318,
            110410229,
            110342082,
            110340758,
            110337901,
            110434363,
            110434311,
            110432471,
            110432456,
            110384121,
            110347999,
            110344468,
            110349024,
            110347133,
            110346694,
            110345990,
            110348574,
            110343676,
            110346592,
            110347088,
            110350111,
            110350771,
            110350595,
            110349856
        ],
        "C": [
            110333651,
            110331021,
            110334430,
            110335594,
            110331843,
            110335775,
            110331846,
            110336227,
            110336058,
            110339413,
            110333925,
            110337781,
            110335754,
            110338528,
            110342766,
            110337144,
            110339220,
            110337699,
            110337911
        ],
        "B": [
            110328704,
            110327182,
            110329276,
            110330310,
            110327534,
            110329852,
            110327723,
            110329207,
            110329841,
            110333664,
            110328875,
            110331182,
            110328187,
            110334069,
            110334004,
            110328671,
            110331437,
            110330565,
            110331774
        ],
        "A": [
            110326019,
            110325991,
            110326313,
            110326005,
            110325865,
            110325899,
            110325997,
            110326125,
            110326016,
            110326091,
            110326392,
            110325908,
            110325927,
            110326243,
            110325858,
            110326228,
            110326284,
            110326209,
            110326298
        ],
        "G": [
            110573818,
            110399277,
            112155486,
            110386520,
            110388825
        ]
    },
    "name": "D. The Number of Pairs",
    "statement": "You are given three positive (greater than zero) integers c, d and x.\r\nYou have to find the number of pairs of positive integers (a, b) such\r\nthat equality c\r\ncdot lcm(a, b) - d\r\ncdot gcd(a, b) = x holds. Where lcm(a, b) is the least common multiple\r\nof a and b and gcd(a, b) is the greatest common divisor of a and b.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MX = 20000000;\n\nvector<int> primes;\nint sieve[20202020];\nll ans;\nint c, d, x;\n\nvoid f(int g) {\n\tint y = (x / g + d);\n\tif(y % c) return;\n\ty /= c;\n\tint cnt = 0, last = 0;\n\twhile(y > 1) {\n\t\tint t = sieve[y];\n\t\tif(last != t) { cnt++; last = t; }\n\t\ty /= t;\n\t}\n\tans += (1 << cnt);\n}\n\nint main() {\n\tfor(int i = 2; i <= MX; i++) {\n\t\tif(!sieve[i]) { sieve[i] = i; primes.push_back(i); }\n\t\tfor(int j : primes) {\n\t\t\tif(i * j > MX) break;\n\t\t\tsieve[i * j] = j;\n\t\t\tif(i % j == 0) break;\n\t\t}\n\t}\n\n\tint tc; scanf(\"%d\", &tc);\n\twhile(tc--) {\n\t\tscanf(\"%d%d%d\", &c, &d, &x);\n\t\tans = 0;\n\t\tfor(int i = 1; i * i <= x; i++) {\n\t\t\tif(x % i) continue;\n\t\t\tf(i);\n\t\t\tif(i != x / i) f(x / i);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. The Number of Pairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/88812",
    "editorial": "Letâs represent as and as , where and . By definition , so we can\r\nrepresent as . Now we can rewrite the equation from the statement as\r\nfollows: . Since the left-hand side is divisible by , the right-hand\r\nside should also be divisible. So we can iterate over as divisors of .\r\nIf the right-hand side of is not divisible by then we can skip such .\r\n(letâs denote as ). If has some prime divisor then exactly one of and\r\nshould be divisible by because ( and have no common divisors). So there\r\nare pairs of and for current value of .We can precalculate the minimum\r\nprime divisor for each number up to (the maximum value of that you may\r\nneed) in using Eratosthenes sieve. Now we can solve the problem in for\r\neach testcase, but thatâs not fast enough. To speed up this approach, we\r\ncan precalculate the number of prime divisors for each number up to .\r\nLetâs denote as the minimum prime divisor of and as the number of prime\r\ndivisors of . Then plus if . Now, to solve the problem, we only need to\r\niterate over the divisors of , so the time complexity is per testcase.\r\n",
    "hint": []
}