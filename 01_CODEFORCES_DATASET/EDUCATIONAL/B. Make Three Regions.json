{
    "link": "https://codeforces.com//contest/1997/problem/B",
    "problemId": "2784495",
    "problem_idx": "B",
    "shortId": "1997B",
    "contest_number": "1997",
    "problem_submissions": {
        "F": [
            273554813,
            273562336,
            273555588,
            273558521,
            273558184,
            273555359,
            273562297,
            273565830,
            273546283,
            273544285,
            273566836,
            273566119,
            273585907,
            273568802,
            273555309,
            273574760,
            273588700,
            273578615,
            273575242,
            273588906
        ],
        "E": [
            273537014,
            273527320,
            273531772,
            273535164,
            273526322,
            273540324,
            273541553,
            273544138,
            273572699,
            273564384,
            273777832,
            273550008,
            273548972,
            273536881,
            273554636,
            273544552,
            273556209,
            273544842,
            273546282,
            273666737,
            273666189,
            273553954,
            273545375
        ],
        "D": [
            273513568,
            273513144,
            273513742,
            273512836,
            273510170,
            273516169,
            273515679,
            273515838,
            273510617,
            273513446,
            273517815,
            273525464,
            273518352,
            273521955,
            273529234,
            273520142,
            273512102,
            273520565,
            273515266,
            273520749
        ],
        "C": [
            273496813,
            273497815,
            273498571,
            273503315,
            273497876,
            273499195,
            273500860,
            273502791,
            273499347,
            273496485,
            273508798,
            273507268,
            273509198,
            273511156,
            273522873,
            273509562,
            273503505,
            273507797,
            273508832,
            273510628
        ],
        "B": [
            273490300,
            273489109,
            273490092,
            273494428,
            273492341,
            273491848,
            273492911,
            273494262,
            273492523,
            273491731,
            273501850,
            273497360,
            273496735,
            273504535,
            273502692,
            273496964,
            273493065,
            273497766,
            273504790,
            273497879
        ],
        "A": [
            273486630,
            273485994,
            273491236,
            273487968,
            273486132,
            273486581,
            273486579,
            273487757,
            273487599,
            273486090,
            273488578,
            273489964,
            273488719,
            273489029,
            273504662,
            273489452,
            273486034,
            273487994,
            273500770,
            273488432
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132154",
    "editorial": "Since the chosen cell should split a connected region into non-empty\r\nparts, this cell should share a side with all of them. But any cell has\r\nat most neighbor cells (because there are only rows), and they should be\r\nsplit from each other by blocked cells.From the above, we can conclude\r\nhow a pattern of a \"good\" cell should look like. In fact, there are only\r\nof them (on the layouts below, white cells are free, dark grey cells are\r\nblocked, and the red cell is a \"good\" cell): These patterns are the only\r\npossible ones: all neighbors of a \"good\" cell should be free (otherwise\r\nthere will be less than regions connected to it); and both of the\r\n\"corner\" cells should be blocked (if at least one of them is free, two\r\nregions will merge into one, so there will be less than regions). So the\r\nproblem becomes to calculate the number of the above patterns inside the\r\ngiven grid.\r\n",
    "name": "B. Make Three Regions",
    "statement": "There is a grid, consisting of 2 rows and n columns. Each cell of the\r\ngrid is either free or blocked.A free cell y is reachable from a free\r\ncell x if at least one of these conditions holds: x and y share a side;\r\nthere exists a free cell z such that z is reachable from x and y is\r\nreachable from z. A connected region is a set of free cells of the grid\r\nsuch that all cells in it are reachable from one another, but adding any\r\nother free cell to the set violates this rule.For example, consider the\r\nfollowing layout, where white cells are free, and dark grey cells are\r\nblocked: There are 3 regions in it, denoted with red, green and blue\r\ncolor respectively: The given grid contains at most 1 connected region.\r\nYour task is to calculate the number of free cells meeting the following\r\nconstraint: if this cell is blocked, the number of connected regions\r\nbecomes exactly 3.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>//#define int li#define f first#define s second\u00a0using namespace std;using li = long long;using ld = long double;\u00a0\u00a0int32_t main(){    ios_base::sync_with_stdio(0);    cin.tie(0);\u00a0    int t;    cin >> t;\u00a0    while(t--)    {        int n;        cin >> n;\u00a0        string a[2];        cin >> a[0] >> a[1];\u00a0        int ans = 0;\u00a0        for(int i = 1; i < n - 1; i++)            for(int j = 0; j < 2; j++)                if(a[j][i] == '.' && a[j ^ 1][i] == '.' && a[j][i + 1] == '.' && a[j][i - 1] == '.' && a[j ^ 1][i + 1] == 'x' && a[j ^ 1][i - 1] == 'x')                    ans++;\u00a0        cout << ans << \"\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "two pointers"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Make Three Regions.json"
}