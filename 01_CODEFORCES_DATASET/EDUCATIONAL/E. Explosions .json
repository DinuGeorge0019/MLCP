{
    "link": "https://codeforces.com//contest/1795/problem/E",
    "problemId": "1785701",
    "problem_idx": "E",
    "shortId": "1795E",
    "contest_number": "1795",
    "problem_submissions": {
        "G": [
            193868249,
            193922126,
            193880640,
            193880242,
            193879883,
            193877939,
            193892319,
            193909416,
            193909281,
            193909039,
            193908855,
            193907982,
            193907256,
            193907116,
            193905885,
            193905428,
            193895936,
            193894919,
            193900585,
            193900447,
            193900331,
            193900021,
            193895212,
            193901119,
            193897399,
            194065980,
            193895350,
            193897364,
            193910352,
            193909678,
            193877594,
            193901310,
            193900708,
            193909774,
            193909664,
            193908826,
            193902609,
            193895098,
            193898582,
            193887169,
            193989778,
            193903191,
            193906575,
            193901677
        ],
        "E": [
            193858484,
            193864061,
            193860485,
            193866472,
            193870118,
            193881494,
            193869535,
            193877440,
            194065966,
            193867450,
            193873381,
            193864290,
            193872060,
            193880762,
            193876051,
            193901176,
            193882421,
            193899122,
            193881276,
            193885055
        ],
        "F": [
            193849592,
            193871412,
            193870619,
            193880295,
            193883585,
            193866256,
            193887756,
            193901053,
            193899102,
            193887184,
            194065972,
            193879792,
            193887970,
            193889897,
            193889600,
            193879424,
            193886027,
            193888430,
            193890811,
            193880065,
            193894847,
            193891841
        ],
        "D": [
            193842483,
            193853701,
            193849666,
            193849500,
            193854093,
            193850355,
            193858853,
            193853243,
            194065953,
            193855818,
            193855956,
            193852941,
            193856134,
            193845600,
            193859844,
            193851729,
            193849114,
            193866588,
            193860778,
            193855517
        ],
        "C": [
            193840570,
            193847474,
            193846113,
            193844888,
            193847932,
            193844693,
            193851549,
            193846559,
            194065943,
            193849210,
            193849704,
            193847867,
            193849903,
            193858596,
            193851945,
            193847688,
            193845368,
            193860332,
            193855373,
            193849162
        ],
        "B": [
            193839119,
            193839637,
            193839480,
            193839407,
            193839832,
            193839202,
            193842405,
            193840503,
            194065925,
            193843321,
            193841514,
            193841857,
            193840539,
            193848293,
            193839850,
            193839356,
            193839529,
            193847088,
            193842717,
            193840388
        ],
        "A": [
            193838910,
            193838985,
            193838946,
            193838908,
            193839007,
            193838901,
            193840204,
            193839189,
            194065914,
            193839222,
            193839386,
            193882631,
            193839087,
            193843666,
            193841139,
            193839086,
            193838960,
            193838928,
            193845036,
            193840156,
            193838911
        ]
    },
    "name": "E. Explosions ",
    "statement": "You are playing yet another game where you kill monsters using magic\r\nspells. There are n cells in the row, numbered from 1 to n. Initially,\r\nthe i-th cell contains the i-th monster with h_i health.You have a basic\r\nspell that costs 1 MP and deals 1 damage to the monster you choose. You\r\ncan cast it any number of times. Also, you have a special scroll with\r\n\"Explosion\" spell you can use only once. You want to finish killing\r\nmonsters with explosion, that\u2019s why you, firstly, cast the basic spell\r\nseveral times (possibly, zero), and then after that, you cast one\r\n\"Explosion\".How does \"Explosion\" spell work? Firstly, you choose the\r\npower of the spell: if you pour x MP into it, \"Explosion\" will deal x\r\ndamage. Secondly, you choose some monster i, which will be targeted by\r\nthe spell. That\u2019s what happens next: if its health h_i > x, then he\r\nstays alive with health decreased by x; if h_i\r\nle x, the i-th monster dies with an explosion that deals h_i - 1 damage\r\nto monsters in the neighboring cells i - 1 and i + 1, if these cells\r\nexist and monsters inside are still alive; if the damage dealt by the\r\nexplosion is enough to kill the monster i - 1 (or i + 1), i. e. the\r\ncurrent h_{i - 1}\r\nle h_i - 1 (or h_{i + 1}\r\nle h_i - 1), then that monster also dies creating a secondary explosion\r\nof power h_{i-1} - 1 (or h_{i+1} - 1) that may deals damage to their\r\nneighbors, and so on, until the explosions end. Your goal is to kill all\r\nthe remaining monsters with those \"chaining\" explosions, that\u2019s why you\r\nneed a basic spell to decrease h_i of some monsters or even kill them\r\nbeforehand (monsters die when their current health h_i becomes less or\r\nequal to zero). Note that monsters don\u2019t move between cells, so, for\r\nexample, monsters i and i + 2 will never become neighbors.What is the\r\nminimum total MP you need to kill all monsters in the way you want? The\r\ntotal MP is counted as the sum of the number of basic spells you cast\r\nand the power x of explosion scroll you\u2019ve chosen.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.02.2023 18:54:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> h(n);\n    for (int i = 0; i < n; i++) {\n      cin >> h[i];\n    }\n    vector<long long> L(n);\n    vector<long long> R(n);\n    for (int rot = 0; rot < 2; rot++) {\n      vector<pair<long long, long long>> st;\n      long long sum = 0;\n      for (int i = 0; i < n; i++) {\n        long long cnt = 1;\n        while (!st.empty() && h[i] - cnt < st.back().first) {\n          long long diff = st.back().first - (h[i] - cnt);\n          sum += diff * st.back().second;\n          cnt += st.back().second;\n          st.pop_back();\n        }\n        if (cnt - 1 > h[i]) {\n          long long extra = cnt - 1 - h[i];\n          sum -= extra * (extra + 1) / 2;\n          cnt = h[i];\n        }\n        L[i] = sum;\n        st.emplace_back(h[i], cnt);\n      }\n      reverse(L.begin(), L.end());\n      reverse(R.begin(), R.end());\n      reverse(h.begin(), h.end());\n      swap(L, R);\n    }\n    long long ans = (long long) 1e18;\n    for (int i = 0; i < n; i++) {\n      ans = min(ans, L[i] + R[i] + h[i]);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Explosions .json",
    "editorial_link": "https://codeforces.com//blog/entry/112963",
    "editorial": "Note that each unit of damage dealt by explosions save us from using one\r\nmore basic spell. In other words, the more the damage from explosions,\r\nthe better. So, the answer will be equal to .Note that in order to kill\r\nall remaining monsters with the last spell, the array should have the\r\nfollowing structure: there is a monster we cast the spell onto it and is\r\nstrictly increasing in and strictly decreasing in (ignoring prefix and\r\nsuffix of -s).Let\u00e2\u0080\u0099s focus on the left part of array (segment ), since\r\nsolving the right part is exactly the same. Maximizing the total damage\r\nis equivalent to maximizing the sum of right before the final spell.\r\nNote that we can use the straight greedy strategy: to kill the chosen\r\nmonster we should use \"Explosion\" spell of power exactly it\u00e2\u0080\u0099s not\r\noptimal to make it either more or less powerful.After that, monster will\r\ncreate an explosion of power . If we must decrease it to exactly to\r\ncontinue the chain of explosions of maximum total damage. If we also\r\ndecrease it to exactly and so on. (The general formula is ).This series\r\nwill stop either if (or ), or there are no monsters left (), or we met\r\nthe monster with . The two first cases are easy to check in constant\r\ntime, so let\u00e2\u0080\u0099s look at the last case. Suppose that monster position is\r\nequal to , then or .That monster is interesting to us because after\r\ndeath it creates an explosion of damage that already doesn\u00e2\u0080\u0099t depend on\r\nand next calculation is practically the same task: what chain of\r\nexplosion we can have if we start from . That idea drives us to dp: let\r\nbe the maximum damage of chaining explosion we can deal if we start from\r\nand move to the left. For simplicity, let\u00e2\u0080\u0099s include into that total\r\ndamage.Calculating is next: let\u00e2\u0080\u0099s find the \"first\" such that . If there\r\nare no such (or if that is too far from , i. e. ), we will set .Now we\r\nknow that on interval the damage dealt is the arithmetic progression:\r\nfor it\u00e2\u0080\u0099s , for it\u00e2\u0080\u0099s , ..., for it\u00e2\u0080\u0099s . In total, . And if such exists and\r\nnot too far away, we increase by as well.The last question is finding\r\nfor each the closest such that . Note that if we define , we need just\r\nneed to find last and that\u00e2\u0080\u0099s quite standard task that can be solved with\r\nstack.Let\u00e2\u0080\u0099s iterate over and maintain a stack of previous . When we need\r\nto find for the current let\u00e2\u0080\u0099s just look at the top of the stack: if we\r\nfound we wanted, otherwise just pop it and check the new top again and\r\nso on, until either we find or stack becomes empty that would mean that\r\nthere are no . After processing the -th element, push on top of the\r\nstack.Why it works? Consider some . The element on top of the stack is\r\n(firstly, it\u00e2\u0080\u0099s but we are talking about general case). If we found what\r\nwe want. Otherwise, but it also means that previous elements , that was\r\npopped on previous iteration , was greater than . So, is bigger than as\r\nwell, and there were no need to even consider them, i. e. popping them\r\nout earlier doesn\u00e2\u0080\u0099t break anything.Since each element is pushed in the\r\nstack once and popped out once, then the complexity is for all for to ,\r\nor amortized.The answer for the chosen position then is where is dp we\r\ndiscussed above, is the same dp but on reversed array and because we\r\nincluded into both and .Both and are calculated in , so the total\r\ncomlpexity is .\r\n"
}