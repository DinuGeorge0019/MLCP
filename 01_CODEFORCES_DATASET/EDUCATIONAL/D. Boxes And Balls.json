{"link": "https://codeforces.com//contest/884/problem/D", "problemId": "130890", "problem_idx": "D", "shortId": "884D", "contest_number": "884", "problem_submissions": {"F": [31808128, 31809259, 31810428, 31811126, 31807028, 31810125, 31808407, 31808014, 31873745, 31808068, 31810481, 70767801, 36469296, 36469289, 31909919, 31809387, 31822510, 31808175, 31811034], "E": [31805401, 31807388, 31807565, 31808478, 31804019, 31805975, 31805687, 31805755, 31841462, 31810079, 31810699, 31810217, 31811063, 31809732, 31810149], "D": [31802703, 31804699, 31804124, 31804641, 31808138, 31803343, 31802113, 31801774, 31802510, 31803536, 31804976, 31801949, 31805944, 31805607, 31803821, 31809103, 31803969, 31818412, 31806095], "C": [31800883, 31800607, 31802838, 31802069, 31799616, 31802362, 31800429, 31800236, 31800839, 31801291, 31801670, 31800496, 31801796, 31802338, 31801055, 31801861, 31801455, 31800685, 31802138], "B": [31799211, 31799036, 31801939, 31801321, 31801497, 31798756, 31799168, 31799265, 31799895, 31799341, 31799382, 31800133, 31800205, 31799009, 31800238, 31799378, 31799257, 31800274], "A": [31798352, 31798382, 31801358, 31800677, 31801116, 31798306, 31798460, 31798672, 31798979, 31798397, 31798744, 31798807, 31798611, 31798307, 31798790, 31798478, 31798275, 31799367]}, "name": "D. Boxes And Balls", "statement": "Ivan has different boxes. The first of them contains some balls of\r\ndifferent colors.Ivan wants to play a strange game. He wants to\r\ndistribute the balls into boxes in such a way that for every () -th box\r\nwill contain all balls with color .In order to do this, Ivan will make\r\nsome turns. Each turn he does the following: Ivan chooses any non-empty\r\nbox and takes all balls from this box; Then Ivan chooses any empty boxes\r\n(the box from the first step becomes empty, and Ivan is allowed to\r\nchoose it), separates the balls he took on the previous step into\r\nnon-empty groups and puts each group into one of the boxes. He should\r\nput each group into a separate box. He can choose either or . The of the\r\nturn is the number of balls Ivan takes from the box during the first\r\nstep of the turn. And of the game is the total of turns made by Ivan\r\nuntil he distributes all balls to corresponding boxes.Help Ivan to\r\ndetermine the minimum possible of the game!\r\n", "solutions": ["#include <cstdio>\n#include <utility>\n#include <array>\n#include <map>\n#include <vector>\n#include <functional>\n#include <iterator>\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nint main()\n{\n    int N;\n    RD(N);\n\n    ll ans = 0;\n\n    priority_queue<ll, vector<ll>, greater<ll>> que;\n\n    for(int i: RG(N))\n    {\n        ll a;\n        RD(a);\n        que.push(a);\n    }\n\n    if(que.size() % 2 == 0)\n    {\n        ll sum = que.top();\n        que.pop();\n        sum += que.top();\n        que.pop();\n\n        ans += sum;\n        que.push(sum);\n    }\n\n    while(que.size() > 1)\n    {\n        ll sum = 0;\n        for(int i: RG(3))\n        {\n            sum += que.top();\n            que.pop();\n        }\n\n        ans += sum;\n        que.push(sum);\n\n    }\n\n\n    WTL(ans);\n\n}\n\n\n\n\n"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "2300", "interactive": false}