{
    "link": "https://codeforces.com//contest/1902/problem/D",
    "problemId": "2362201",
    "problem_idx": "D",
    "shortId": "1902D",
    "contest_number": "1902",
    "problem_submissions": {
        "B": [
            235588094,
            235541813,
            235538695,
            235540200,
            235541986,
            235546581,
            235539624,
            235542221,
            235543196,
            235570763,
            235543003,
            235539161,
            235543236,
            235569611,
            235570026,
            235542153,
            235655407,
            235543168,
            235545066,
            235549273,
            235544565,
            235544393
        ],
        "D": [
            235587336,
            235552561,
            235553295,
            235563680,
            235553330,
            235555395,
            235568492,
            235559700,
            235568658,
            235567617,
            235560146,
            235561416,
            235554309,
            235551620,
            235562986,
            235561764,
            235586816,
            235566705,
            235566898,
            235564749,
            235564461
        ],
        "E": [
            235583583,
            235582606,
            235582050,
            235581289,
            235558586,
            235559098,
            235551541,
            235558190,
            235559848,
            235566108,
            235566192,
            235566094,
            235564789,
            235564113,
            235549751,
            235553064,
            235566369,
            235568437,
            235561807,
            235546129,
            235601857,
            235573551,
            235578412,
            235572635,
            235576054,
            235577219,
            235558759
        ],
        "F": [
            235562465,
            235568838,
            236129130,
            236129102,
            235556472,
            235565709,
            235569182,
            235561417,
            235572126,
            235555263,
            235543234,
            235574528,
            235579496,
            235582447,
            235591540,
            235554289,
            235597722,
            235587185,
            235557652,
            235580838,
            235744278,
            235581308,
            235591762,
            235592390
        ],
        "C": [
            235547363,
            235542973,
            235546654,
            235544681,
            235542274,
            235544554,
            235550388,
            235549932,
            235558653,
            235546403,
            235544913,
            235545913,
            235542697,
            235566604,
            235546411,
            235656040,
            235549867,
            235560184,
            235557908,
            235596779,
            235549641,
            235614612,
            235549186
        ],
        "A": [
            235534144,
            235534113,
            235534651,
            235534058,
            235534240,
            235534127,
            235534119,
            235534985,
            235553076,
            235538076,
            235534100,
            235534474,
            235534171,
            235570865,
            235534497,
            235654959,
            235535402,
            235534132,
            235535287,
            235538251,
            235534330
        ]
    },
    "name": "D. Robot Queries",
    "statement": "There is an infinite 2-dimensional grid. Initially, a robot stands in\r\nthe point (0, 0). The robot can execute four commands: move from point\r\n(x, y) to (x, y + 1); move from point (x, y) to (x, y - 1); move from\r\npoint (x, y) to (x - 1, y); move from point (x, y) to (x + 1, y). You\r\nare given a sequence of commands s of length n. Your task is to answer q\r\nqueries: given four integers x, y, l and r; determine whether the robot\r\nvisits the point (x, y), while executing a sequence s, but the substring\r\nfrom l to r is reversed (i. e. the robot performs commands in order s_1\r\ns_2 s_3\r\ndots s_{l-1} s_r s_{r-1} s_{r-2}\r\ndots s_l s_{r+1} s_{r+2}\r\ndots s_n).\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate <class T> int arglb(const std::vector<T> &v, const T &x) { return std::distance(v.begin(), std::lower_bound(v.begin(), v.end(), x)); }\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n\n    int N, Q;\n    string S;\n\n    cin >> N >> Q >> S;\n\n    vector<int> xs(N + 1), ys(N + 1);\n\n    map<pair<int, int>, vector<int>> mp;\n    mp[{0, 0}].push_back(0);\n\n    for (int i = 0; i < N; ++i) {\n        xs.at(i + 1) = xs.at(i) + (S.at(i) == 'R') - (S.at(i) == 'L');\n        ys.at(i + 1) = ys.at(i) + (S.at(i) == 'U') - (S.at(i) == 'D');\n        mp[{xs.at(i + 1), ys.at(i + 1)}].push_back(i + 1);\n    }\n\n    while (Q--) {\n        int x, y, l, r;\n        cin >> x >> y >> l >> r;\n        --l;\n\n        const int xrem = x - xs.at(l), yrem = y - ys.at(l);\n\n        const int xt = xs.at(r) - xrem, yt = ys.at(r) - yrem;\n\n        bool found = false;\n        if (auto itr = mp.find({xt, yt}); itr != mp.end()) {\n            const auto &vec = itr->second;\n            int i = arglb(vec, l);\n            if (i < (int)vec.size() and vec.at(i) <= r) found = true;\n        }\n\n        if (auto itr = mp.find({x, y}); itr != mp.end()) {\n            const auto &vec = itr->second;\n            if (vec.back() >= r) found = true;\n            if (vec.front() <= l) found = true;\n        }\n\n        cout << (found ? \"YES\" : \"NO\") << '\\n';\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "implementation"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Robot Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/122951",
    "editorial": "Let\u00e2\u0080\u0099s divide the path of the robot into three parts: points before the\r\n-th operation; points from the -th to the -th operations; points after\r\nthe -th operation; The first and the third parts are pretty simple to\r\ncheck because the reverse of the substring does not affect them. So we\r\ncan precompute a dictionary that stores all indices of operations in the\r\ninitial sequence after which the robot stands at the point . Then point\r\nlies on the first part if contains at least one index among indices from\r\nto . Similarly, for the third part, but we have to check indices from to\r\n.It remains to understand how the second part works. Reversing of the\r\norder of commands from to means that the robot first performs all\r\ncommands from to in the original string, then the command , then , and\r\nso on, until the command . So, it means that the points that the robot\r\nvisits can be represented as follows: for an integer such that , perform\r\nall commands from to , the commands from to .Let be the point where the\r\nrobot stands after the -th operation, and be the total movement using\r\noperations from to (note that ). Then we have to check whether there is\r\nsuch that and . Using the aforementioned equality for , we can rewrite\r\nthis as . As a result, our task is to check whether there is such that\r\nand . And we already know how to check that, using the dictionary (you\r\nwill need some sort of binary search or a function similar to to find\r\nwhether there is a moment from to when a point is visited).If the point\r\nbelongs to at least one of the parts of the path, then the answer is ,\r\notherwise the answer is .\r\n"
}