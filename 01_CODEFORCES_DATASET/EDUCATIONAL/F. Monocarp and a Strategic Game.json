{
    "link": "https://codeforces.com//contest/1841/problem/F",
    "problemId": "1962595",
    "problem_idx": "F",
    "shortId": "1841F",
    "contest_number": "1841",
    "problem_submissions": {
        "F": [
            209441446,
            209449956,
            209447296,
            209453943,
            209449863,
            209446444,
            209454347,
            209678776,
            209452092,
            209454468,
            209458945,
            209453449,
            209451716,
            209465466,
            209464638,
            209461720,
            209460276,
            209459819,
            209458504,
            209458152,
            209453975,
            209486469,
            209486319,
            209486054,
            209459375,
            209456147,
            209463444,
            209466329,
            209466771,
            209609259,
            209462972,
            209467839,
            209463203
        ],
        "E": [
            209420520,
            209430600,
            209434973,
            209427885,
            209438551,
            209434946,
            209433065,
            209431302,
            209443745,
            209434541,
            209438545,
            209438034,
            209444420,
            209422689,
            209420477,
            209458913,
            209440856,
            209447420,
            209460885,
            209429843
        ],
        "D": [
            209412776,
            209418240,
            209420286,
            209421079,
            209475842,
            209428591,
            209423202,
            209420942,
            209417076,
            209424719,
            209423326,
            209425276,
            209464164,
            209425284,
            209430127,
            209413537,
            209411059,
            209426861,
            209442988,
            209439319,
            209441486,
            209421279
        ],
        "C": [
            209400973,
            209405174,
            209401188,
            209410862,
            209415662,
            209408968,
            209409562,
            209408253,
            209414636,
            209413637,
            209410942,
            209421138,
            209419542,
            209405503,
            209431667,
            209409468,
            209421971,
            209433784,
            209431914,
            209416091
        ],
        "B": [
            209395303,
            209394968,
            209391532,
            209391351,
            209395229,
            209393535,
            209397133,
            209392667,
            209405342,
            209396380,
            209399455,
            209465838,
            209465126,
            209398959,
            209401067,
            209395449,
            209398643,
            209399436,
            209394778,
            209404496,
            209407644,
            209470007
        ],
        "A": [
            209388179,
            209388192,
            209387876,
            209387947,
            209389004,
            209388221,
            209388559,
            209388171,
            209393927,
            209405420,
            209388257,
            209389054,
            209391461,
            209401864,
            209387894,
            209390233,
            209387972,
            209392823,
            209407382,
            209389297
        ]
    },
    "name": "F. Monocarp and a Strategic Game",
    "statement": "Monocarp plays a strategic computer game in which he develops a city.\r\nThe city is inhabited by creatures of four different races humans,\r\nelves, orcs, and dwarves.Each inhabitant of the city has a happiness\r\nvalue, which is an integer. It depends on how many creatures of\r\ndifferent races inhabit the city. Specifically, the happiness of each\r\ninhabitant is 0 by default; it increases by 1 for each creature of the\r\nsame race and decreases by 1 for each creature of a hostile race. Humans\r\nare hostile to orcs (and vice versa), and elves are hostile to dwarves\r\n(and vice versa).At the beginning of the game, Monocarp\u2019s city is not\r\ninhabited by anyone. During the game, n groups of creatures will come to\r\nhis city, wishing to settle there. The i-th group consists of a_i\r\nhumans, b_i orcs, c_i elves, and d_i dwarves. Each time, Monocarp can\r\neither accept the group of creatures into the city, or reject the\r\ngroup.The game calculates Monocarp\u2019s score according to the following\r\nformula: m + k, where m is the number of inhabitants in the city, and k\r\nis the sum of the happiness values of all creatures in the city.Help\r\nMonocarp earn the maximum possible number of points by the end of the\r\ngame!\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << \" \"; cout << v[i];\n    }\n    cout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\n\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n), b(n), c(n), d(n);\n    rep(i, n)cin >> a[i] >> b[i] >> c[i] >> d[i];\n    vector<P> vp;\n    rep(i, n) {\n        int x = b[i] - a[i];\n        int y = d[i] - c[i];\n        if (x == 0 && y == 0)continue;\n        vp.push_back({ x,y });\n    }\n    if (vp.empty()) {\n        cout << 0 << \"\\n\"; return;\n    }\n    P pp = { -mod17,-mod17 };\n    vector<pair<ld, P>> ps;\n    rep(i, vp.size()) {\n        ld t = atan2(vp[i].second, vp[i].first);\n        ps.push_back({ t,vp[i] });\n\n        int cx = vp[i].first, cy = vp[i].second;\n        rep(_, 3) {\n            swap(cx, cy);\n            cx *= -1;\n            ld nt = atan2(cy, cx);\n            ps.push_back({ nt,pp });\n        }\n    }\n    sort(all(ps));\n    int len = ps.size();\n    rep(i, len) {\n        /*if (ps[i].second != pp) {\n            cout << ps[i].second.first << \" \" << ps[i].second.second << \"\\n\";\n        }*/\n        auto ad = ps[i];\n        ad.first += 2 * pi;\n        ps.push_back(ad);\n    }\n    vector<ll> sx(ps.size() + 1);\n    vector<ll> sy(ps.size() + 1);\n    rep(i, ps.size()) {\n        sx[i + 1] = sx[i];\n        sy[i + 1] = sy[i];\n        if (ps[i].second != pp) {\n            sx[i + 1] += ps[i].second.first;\n            sy[i + 1] += ps[i].second.second;\n        }\n    }\n    int ri = 0;\n    ld ans = 0;\n    rep(i, len) {\n        while (ps[ri].first < ps[i].first + pi-eps)ri++;\n        ld dx = sx[ri] - sx[i];\n        ld dy = sy[ri] - sy[i];\n        ld val = dx * dx + dy * dy;\n        chmax(ans, val);\n        dx = sx[ri] - sx[i + 1];\n        dy = sy[ri] - sy[i + 1];\n        val = dx * dx + dy * dy;\n        chmax(ans, val);\n    }\n    cout << ans << \"\\n\";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed<<setprecision(12);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    //int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "geometry",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Monocarp and a Strategic Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/117262",
    "editorial": "Let\u00e2\u0080\u0099s denote as the total number of humans, orcs, elves, and dwarves\r\ntaken respectively. We calculate the contribution of humans and orcs to\r\nthe final score. It will be , where is the contribution to the total\r\nhappiness (and thus to the final score) for an increase of happiness\r\npoint per inhabitant of the same race, is the contribution to the total\r\nhappiness decrease by point for each inhabitant of the hostile race, and\r\nthe last two terms is the total number of humans and orcs, which\r\ncontributes to the total score. Notice that .Similarly for the\r\ncontribution of elves and dwarves. So we need to maximize the expression\r\n. Let\u00e2\u0080\u0099s say we have vectors, the -th of which is equal to . Then note\r\nthat we want to select some subset of vectors among the vectors , a\r\nsubset such that the value of the function is maximum for the vector\r\nequal to the sum of the vectors of subset .For each subset of vectors,\r\nwe get a vector equal to the sum of the elements of the subset\r\n(vectors), let\u00e2\u0080\u0099s denote the set of all such vectors as .Then consider\r\nthe line segments at the vertices and and calculate their Minkowski sum.\r\nWe get a convex polygon. Notice that all elements of are in it by the\r\ndefinition of the Minkowski sum. Also, each vertex of the resulting\r\nconvex polygon is in , which is also known from the properties of the\r\nsum. Note that due to the upward convexity of the function we want to\r\nmaximize, it is enough for us to only consider the vertices of the\r\nresulting polygon, not all vectors from .Thus, using a standard\r\nalgorithm for calculating the Minkowski sum, we obtain the polygon of\r\ninterest and calculate the values of the function at its vertices. We\r\ntake the maximum from them. The total asymptotic time complexity is .\r\n"
}