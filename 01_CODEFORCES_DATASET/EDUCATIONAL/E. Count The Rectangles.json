{
    "link": "https://codeforces.com//contest/1194/problem/E",
    "problemId": "372219",
    "problem_idx": "E",
    "shortId": "1194E",
    "contest_number": "1194",
    "problem_submissions": {
        "E": [
            57460080,
            57035519,
            57036170,
            57036063,
            57128801,
            57128706,
            57128697,
            57128659,
            57128612,
            57128540,
            57128243,
            57128111,
            57036122,
            57038525,
            57047818,
            57039795,
            57039479,
            57042294,
            57040196,
            57036224,
            57042239,
            57040076,
            57104697,
            57102024,
            57101946,
            57062641,
            57042300,
            57042350,
            57042204,
            57055044,
            57053556,
            57046934,
            57046549,
            57042532
        ],
        "A": [
            57046342,
            57022752,
            57022576,
            57022542,
            57022673,
            57022779,
            57022508,
            57024885,
            57022776,
            57023918,
            57022665,
            57023995,
            57022524,
            57022685,
            57028419,
            57027614,
            57022718,
            57022691,
            57023076,
            57024152
        ],
        "B": [
            57046133,
            57024457,
            57023825,
            57024116,
            57024620,
            57026379,
            57024611,
            57023215,
            57025344,
            57025498,
            57024993,
            57026889,
            57024968,
            57025445,
            57030710,
            57029529,
            57024907,
            57024604,
            57025406,
            57027222
        ],
        "C": [
            57045626,
            57025890,
            57026227,
            57026533,
            57026651,
            57028509,
            57026843,
            57027145,
            57026992,
            57027849,
            57027432,
            57029395,
            57027548,
            57028521,
            57032512,
            57032102,
            57027763,
            57027180,
            57027134,
            57031699
        ],
        "G": [
            57044495,
            57124672,
            57083729,
            57083446,
            57083302,
            57051811,
            144563243,
            57059946,
            57059836,
            57059526,
            57059380,
            57058688,
            57057384,
            66619078,
            66618958,
            66618872,
            57059217,
            57080922,
            57079990,
            57079590,
            57079506,
            99043474,
            99036226
        ],
        "F": [
            57028516,
            57040353,
            57042500,
            57037960,
            57127884,
            57047571,
            57045756,
            57041898,
            57051035,
            57048196,
            57045806,
            57053225,
            57047719,
            57051194,
            57063470,
            57052822,
            57047382,
            57051062,
            57040128,
            57052740,
            57051156,
            57053947,
            57051969
        ],
        "D": [
            57026382,
            57028806,
            57032441,
            57028933,
            57029747,
            57030899,
            57031250,
            57031182,
            57036191,
            57030939,
            57039325,
            57034516,
            57033749,
            57033063,
            57035777,
            57036535,
            57031217,
            57033511,
            57038656,
            57037146
        ]
    },
    "name": "E. Count The Rectangles",
    "statement": "There are n segments drawn on a plane; the i-th segment connects two\r\npoints (x_{i, 1}, y_{i, 1}) and (x_{i, 2}, y_{i, 2}). Each segment is\r\nnon-degenerate, and is either horizontal or vertical formally, for every\r\ni\r\nin [1, n] either x_{i, 1} = x_{i, 2} or y_{i, 1} = y_{i, 2} (but only\r\none of these conditions holds). Only segments of different types may\r\nintersect: no pair of horizontal segments shares any common points, and\r\nno pair of vertical segments shares any common points.We say that four\r\nsegments having indices h_1, h_2, v_1 and v_2 such that h_1 < h_2 and\r\nv_1 < v_2 form a rectangle if the following conditions hold: segments\r\nh_1 and h_2 are horizontal; segments v_1 and v_2 are vertical; segment\r\nh_1 intersects with segment v_1; segment h_2 intersects with segment\r\nv_1; segment h_1 intersects with segment v_2; segment h_2 intersects\r\nwith segment v_2. Please calculate the number of ways to choose four\r\nsegments so they form a rectangle. Note that the conditions h_1 < h_2\r\nand v_1 < v_2 should hold.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n \nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<ll, ll> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<ll> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n \n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define F0R(i, a) for (ll i = 0; i < (a); i++)\n#define FORd(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (ll i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n \n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n \n#define sz(x) (ll)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n \nconst ll MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst ll MX = 100001;\nconst ld PI = 4*atan((ld)1);\n \ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n \ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n \nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n \n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n \n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n \nusing namespace input;\n \nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n \n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n \n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // prll w/ spaces\n    }\n}\n \nusing namespace output;\n \nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n \nusing namespace io;\n \ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n \ntemplate<class T> struct modll {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n \n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modll(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modll(T v = 0, T m = 0) : val(v) { normalize(); }\n \n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modll& a) { return os << a.val; }\n    friend bool operator==(const modll& a, const modll& b) { return a.val == b.val; }\n    friend bool operator!=(const modll& a, const modll& b) { return !(a == b); }\n \n    friend void check(modll& a, modll& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modll operator+(modll a, modll b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modll operator-(modll a, modll b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modll operator-(const modll& a) { return modll(0)-a; }\n \n    friend modll operator*(modll a, modll b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modll exp(modll a, ll p) {\n        modll ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modll inv(const modll& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modll operator/(modll a, modll b) { \n        check(a,b); return a*inv(b); \n    }\n};\n \ntypedef modll<ll> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n ll ans;\nint main() {\n    setIO();\n    ll n; cin >> n;\n    vector<pair<ll, pi>> horzs; // y, left x, right x\n    vector<pair<pi, ll>> verts; //bottom y, top y, x val\n    for(ll i = 0; i < n; i++){\n    \tll x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n    \t/*x1 = x2 = i;\n    \ty1 = 0, y2 = 5000;*/\n    \tif(x1 == x2){ // vert\n    \t\tverts.pb(mp(mp(min(y1, y2), max(y1, y2)), x1));\n    \t}\n    \telse horzs.pb(mp(y1, mp(min(x1, x2), max(x1, x2))));\n    }\n    sort(horzs.begin(), horzs.end());\n    sort(verts.begin(), verts.end());\n    \n\tfor(ll i = sz(horzs)-1; i >= 0; i--){\n\t\tll curtop = horzs[i].f;\n\t\tll curleftx = horzs[i].s.f;\n\t\tll currightx = horzs[i].s.s;\n\t\tTree<ll> xvals;\n\t\tvector<pi> erasers;\n\t\tfor(ll j = sz(verts)-1; j>= 0; j--){\n\t\t\tif(verts[j].f.s < curtop) continue;\n\t\t\tif(verts[j].f.f > curtop) continue;\n\t\t\txvals.insert(verts[j].s);\n\t\t\terasers.pb(mp(verts[j].s, verts[j].f.f));\n\t\t}\n\t\tll ind = 0;\n\t\tfor(ll j = i-1; j >= 0; j--){\n\t\t\tif(horzs[j].s.f >= currightx) continue;\n\t\t\tif(horzs[j].s.s <= curleftx) continue;\n\t\t\tll cury = horzs[j].f;\n\t\t\twhile(ind < erasers.size() && erasers[ind].s > cury){\n\t\t\t\txvals.erase(erasers[ind].f);\n\t\t\t\tind++;\n\t\t\t}\n\t\t\tll nums = (ll)xvals.order_of_key(min(horzs[j].s.s+1, (ll)currightx+1))-(ll)xvals.order_of_key(max(horzs[j].s.f, (ll)curleftx));\n\t\t\tans+=(nums*(nums-1))/2;\n\t\t}\n\t}\n\tcout << ans;\n}\n \n/* stuff you should look for\n    * ll overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "data structures",
        "geometry",
        "sortings"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Count The Rectangles.json",
    "editorial_link": "https://codeforces.com//blog/entry/68405",
    "editorial": "Letâs iterate over the lower horizontal segment. Denote its coordinates\r\nas () and (), where . We call vertical segment (, ), (, ) good, if\r\nfollowings conditions holds: ; . Now letâs use the scanline method. At\r\nfirst, for each good vertical segment we increment the value of element\r\nin position in some data structure (for example, Fenwick Tree). Next we\r\nwill process two types of queries in order of increasing their\r\ny-coordinate: horizontal segments with coordinates (, ), (, ); upper\r\npoint of some vertical segment with coordinates . And if two events of\r\ndifferent types have the same y-coordinate then the event of first type\r\nmust be processed first.For event of first type we need to find sum on\r\nrange () in our data structure. Letâs denote this sum as . Then we need\r\nto add to the answer (because we have vertical segments which intersect\r\nwith both fixed horizontal segments and we can choose two of them in so\r\nmany ways).For event of second type we just need decrement the value of\r\nelement in position in our data structure.\r\n",
    "hint": []
}