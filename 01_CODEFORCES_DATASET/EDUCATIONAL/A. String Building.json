{
    "link": "https://codeforces.com//contest/1671/problem/A",
    "problemId": "1376215",
    "problem_idx": "A",
    "shortId": "1671A",
    "contest_number": "1671",
    "problem_submissions": {
        "F": [
            154542143,
            154558308,
            154555068,
            154557074,
            154562560,
            154560412,
            154560334,
            154580455,
            154580066,
            154579893,
            154579534,
            154559391,
            154560455,
            154556037,
            154570936,
            154568652,
            154567294,
            154570123,
            154570095,
            154571694,
            154567547,
            154573773,
            154574629
        ],
        "E": [
            154528618,
            154523246,
            154538308,
            154531841,
            154536634,
            154537536,
            154534868,
            154536863,
            154540214,
            154537733,
            154537068,
            154539560,
            154544853,
            154541083,
            154543961,
            154546659,
            154540036,
            154543052
        ],
        "D": [
            154515283,
            154518590,
            154521489,
            154520458,
            154521403,
            154524920,
            154528513,
            154532728,
            154525208,
            154525643,
            154525793,
            154526566,
            154525948,
            154532548,
            154534260,
            154534156,
            154549567,
            154532508
        ],
        "C": [
            154510946,
            154513613,
            154516509,
            154516298,
            154514632,
            154518397,
            154518432,
            154511688,
            154514098,
            154517459,
            154516109,
            154520271,
            154520298,
            154520714,
            154518755,
            154518674,
            154516230,
            154526116
        ],
        "B": [
            154508972,
            154509429,
            154511794,
            154511150,
            154510866,
            154511702,
            154510603,
            154509631,
            154511147,
            154510842,
            154511266,
            154514390,
            154513321,
            154513559,
            154512703,
            154511916,
            154511617,
            154520025
        ],
        "A": [
            154508532,
            154508535,
            154508654,
            154509163,
            154508619,
            154508583,
            154508765,
            154508590,
            154508804,
            154509162,
            154508941,
            154509310,
            154508759,
            154508605,
            154508711,
            154508600,
            154508845,
            154516250
        ]
    },
    "name": "A. String Building",
    "statement": "You are given a string s. You have to determine whether it is possible\r\nto build the string s out of strings , , and/or by concatenating them.\r\nYou can use the strings , , and/or any number of times and in any\r\norder.For example: can be built as + + ; can be built as + + + ; can be\r\nbuilt as + + ; cannot be built from , , and/or .\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 22.04.2022 18:35:32       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string s;\n    cin >> s;\n    bool ok = true;\n    for (int i = 0; i < (int) s.size(); i++) {\n      bool good = false;\n      if (i > 0 && s[i] == s[i - 1]) good = true;\n      if (i < (int) s.size() - 1 && s[i] == s[i + 1]) good = true;\n      ok &= good;\n    }\n    cout << (ok ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. String Building.json",
    "editorial_link": "https://codeforces.com//blog/entry/102181",
    "editorial": "Every character in strings , , and has at least one character adjacent\r\nto it that is the same. So, if there is an isolated character in our\r\nstring (a character that has no neighbors equal to it), we cannot build\r\nit.Itâs easy to see that in the other case, we can build the string: we\r\ncan split it into blocks of consecutive equal characters, and since\r\nthere are no isolated characters, each block will have at least\r\ncharacters, so it can be formed from strings of length and/or consisting\r\nof equal characters.So, the problem is reduced to checking if each\r\ncharacter has a neighbor equal to it.\r\n",
    "hint": []
}