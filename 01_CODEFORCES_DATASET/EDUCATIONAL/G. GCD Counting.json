{
    "link": "https://codeforces.com//contest/990/problem/G",
    "problemId": "188996",
    "problem_idx": "G",
    "shortId": "990G",
    "contest_number": "990",
    "problem_submissions": {
        "F": [
            39110066,
            39104822,
            39113275,
            39114587,
            39116563,
            39116347,
            39108471,
            39110743,
            39112419,
            39112294,
            39108515,
            39111997,
            39116686,
            39101868,
            39116200,
            39118004,
            39116805
        ],
        "G": [
            39103567,
            39107402,
            39106809,
            39106218,
            39109082,
            39109620,
            39112690,
            39099088,
            39107571,
            39107687,
            39101902,
            39093184,
            39110367,
            39109522,
            39104630,
            39111664,
            39109028,
            39108412,
            39110999,
            39098996,
            39104033,
            39110989
        ],
        "E": [
            39100436,
            39099837,
            39102349,
            39105427,
            39103107,
            39102633,
            39102885,
            39108880,
            39105761,
            39109203,
            39112620,
            39094389,
            39105905,
            39112883,
            39105943,
            39113374,
            39104376,
            39107310,
            39113606,
            39104223
        ],
        "D": [
            39097266,
            39096033,
            39098379,
            39099218,
            39098520,
            39098083,
            39096052,
            39105736,
            39099850,
            39105515,
            39109276,
            39104646,
            39099923,
            39115103,
            39100668,
            39103321,
            39099280,
            39102959,
            39097613,
            39097717
        ],
        "C": [
            39093177,
            39093378,
            39093798,
            39094808,
            39094793,
            39094824,
            39092448,
            39093937,
            39096177,
            39100038,
            39095064,
            39091685,
            39095797,
            39094884,
            39094704,
            39096565,
            39094721,
            39095152,
            39094603,
            39094594
        ],
        "B": [
            39090464,
            39091292,
            39090459,
            39091170,
            39091740,
            39091855,
            39090681,
            39099050,
            39093555,
            39099346,
            39098193,
            39090407,
            39092627,
            39091505,
            39092737,
            39092039,
            39090632,
            39091613,
            39090743,
            39091072
        ],
        "A": [
            39088999,
            39088905,
            39088870,
            39088899,
            39089924,
            39089350,
            39089008,
            39089597,
            39089600,
            39090391,
            39090409,
            39089125,
            39089740,
            39090714,
            39089522,
            39088868,
            39088892,
            39089011,
            39089148
        ]
    },
    "name": "G. GCD Counting",
    "statement": "You are given a tree consisting of n vertices. A number is written on\r\neach vertex; the number on vertex i is equal to a_i.Let\u2019s denote the\r\nfunction g(x, y) as the greatest common divisor of the numbers written\r\non the vertices belonging to the simple path from vertex x to vertex y\r\n(including these two vertices).For every integer from 1 to 2\r\ncdot 10^5 you have to count the number of pairs (x, y) (1\r\nle x\r\nle y\r\nle n) such that g(x, y) is equal to this number.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef long long ll;\n\nconst int Maxm = 200001;\n\nint n;\nint a[Maxm];\nint par[Maxm], siz[Maxm];\nll cur;\nvector <int> V[Maxm];\nvector <ii> E[Maxm];\nll res[Maxm];\n\nint gcd(int x, int y) { return x? gcd(y % x, x): y; }\n\nint getPar(int x) { return par[x] == x? x: par[x] = getPar(par[x]); }\n\nvoid unionSet(int a, int b)\n{\n\ta = getPar(a), b = getPar(b);\n\tif (a == b) return;\n\tif (siz[a] < siz[b]) swap(a, b);\n\tcur -= ll(siz[a]) * (siz[a] + 1) / 2;\n\tcur -= ll(siz[b]) * (siz[b] + 1) / 2;\n\tsiz[a] += siz[b]; par[b] = a;\n\tcur += ll(siz[a]) * (siz[a] + 1) / 2;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tV[a[i]].push_back(i);\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint u, v; scanf(\"%d %d\", &u, &v);\n\t\tE[gcd(a[u], a[v])].push_back(ii(u, v));\n\t}\n\tfor (int i = Maxm - 1; i > 0; i--) {\n\t\tcur = 0;\n\t\tfor (int j = i; j < Maxm; j += i) {\n\t\t\tfor (int k = 0; k < V[j].size(); k++) {\n\t\t\t\tint v = V[j][k];\n\t\t\t\tpar[v] = v; siz[v] = 1;\n\t\t\t\tcur++;\n\t\t\t}\n\t\t\tif (j > i) res[i] -= res[j];\n\t\t}\n\t\tfor (int j = i; j < Maxm; j += i)\n\t\t\tfor (int k = 0; k < E[j].size(); k++) {\n\t\t\t\tii& p = E[j][k];\n\t\t\t\tunionSet(p.first, p.second);\n\t\t\t}\n\t\tres[i] += cur;\n\t}\n\tfor (int i = 1; i < Maxm; i++) if (res[i] > 0)\n\t\tprintf(\"%d %I64d\\n\", i, res[i]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "dp",
        "dsu",
        "number theory",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. GCD Counting.json",
    "editorial_link": "https://codeforces.com//blog/entry/59962",
    "editorial": "Firstly, for every we can calculate the number of paths such that is\r\ndivisible by . We can do it as follows: generate all divisors of numbers\r\n(numbers not exceeding have at most divisors, so this will be fast\r\nenough), and then for every analyze the graph containing the vertices\r\nthat have as its divisor. Each component of this graph gives us paths\r\n(if its size is ), and this is the only formula we need to calculate the\r\nnumber of paths where is divisible by (let this be ).How can we get the\r\nanswer if we know the values of ? We can use inclusion-exclusion with\r\nMobius function, for example, to prove that ; and then if we want to\r\napply the same technique for finding with any possible , we could divide\r\nall numbers by and do the same thing. But it might be too slow, so it\u00e2\u0080\u0099s\r\nbetter to rewrite this formula as , because we will do exactly the same\r\nwhen dividing all numbers by .In fact, most contestants have written a\r\nmuch easier version of this solution, so this might be a bit too\r\ncomplicated.This problem can also be solved with centroid decomposition.\r\n"
}