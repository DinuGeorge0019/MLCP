{
    "link": "https://codeforces.com//contest/1487/problem/E",
    "problemId": "897751",
    "problem_idx": "E",
    "shortId": "1487E",
    "contest_number": "1487",
    "problem_submissions": {
        "G": [
            107454023,
            107463460,
            108576854,
            107460627,
            107450583,
            107451415,
            107430357,
            107444206,
            107450475,
            107450812,
            107922779,
            107446295,
            107455969,
            107448609,
            107460406,
            107464872,
            107461634,
            107460893,
            107461280,
            107537497
        ],
        "F": [
            107439893,
            107447022,
            107443885,
            107469668,
            107469505,
            107444768,
            107452696,
            107498096,
            107498067,
            107494456,
            107622368,
            107452390,
            107465180
        ],
        "E": [
            107424178,
            107424961,
            107432865,
            107429617,
            107432584,
            107450909,
            107426371,
            107427677,
            107427122,
            107429815,
            107619068,
            107618663,
            107432462,
            107430691,
            107435461,
            107433872,
            107429938,
            107432421,
            107433935,
            107430580,
            107430754
        ],
        "D": [
            107421373,
            107421309,
            107427665,
            107423119,
            107428301,
            107453801,
            107421667,
            107423926,
            107424261,
            107424540,
            107428634,
            107426278,
            107425386,
            107425551,
            107425722,
            107429097,
            107425401,
            107424375,
            107424284
        ],
        "C": [
            107420002,
            107418181,
            108576710,
            107420782,
            107436848,
            107423312,
            107458805,
            107419068,
            107421219,
            107421707,
            107421854,
            107426343,
            107423376,
            107421931,
            107421521,
            107423818,
            107421650,
            107421555,
            107422095,
            107421412
        ],
        "B": [
            107416333,
            107413010,
            108576679,
            107416798,
            107424397,
            107419739,
            107460613,
            107414304,
            107416812,
            107415960,
            107414948,
            107416874,
            107418655,
            107417622,
            107416871,
            107416648,
            107416339,
            107414794,
            107418914,
            107416654
        ],
        "A": [
            107410359,
            107409706,
            108576659,
            107410154,
            107409888,
            107412513,
            107461425,
            107409652,
            107410618,
            107410216,
            107410119,
            107412422,
            107409710,
            107411124,
            107409938,
            107409679,
            107409688,
            107409851,
            107409775,
            107410068
        ]
    },
    "name": "E. Cheap Dinner",
    "statement": "Ivan wants to have a good dinner. A good dinner should consist of a\r\nfirst course, a second course, a drink, and a dessert.There are n_1\r\ndifferent types of first courses Ivan can buy (the i-th of them costs\r\na_i coins), n_2 different types of second courses (the i-th of them\r\ncosts b_i coins), n_3 different types of drinks (the i-th of them costs\r\nc_i coins) and n_4 different types of desserts (the i-th of them costs\r\nd_i coins).Some dishes don\u2019t go well with each other. There are m_1\r\npairs of first courses and second courses that don\u2019t go well with each\r\nother, m_2 pairs of second courses and drinks, and m_3 pairs of drinks\r\nand desserts that don\u2019t go well with each other.Ivan wants to buy\r\nexactly one first course, one second course, one drink, and one dessert\r\nso that they go well with each other, and the total cost of the dinner\r\nis the minimum possible. Help him to find the cheapest dinner option!\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 150001; //check the limits, dummy\n\nvoid solve() {\n\n    int N[4]; F0R(i, 4) cin >> N[i];\n    ll A[4][MX]; F0R(i, 4) F0R(j, N[i]) cin >> A[i][j];\n    vector<set<int>> graph[3];\n    F0R(i, 3) {\n        graph[i] = vector<set<int>>(N[i+1]);\n        int M; cin >> M;\n        F0R(j, M) {\n            int X, Y; cin >> X >> Y; X--; Y--; graph[i][Y].ins(X);\n        }\n    }\n\n    set<pl> cost[4];\n    F0R(i, N[0]) cost[0].ins({A[0][i], i});\n    FOR(i, 1, 4) {\n        F0R(j, N[i]) {\n            auto it = cost[i-1].begin();\n            while (it != cost[i-1].end() && graph[i-1][j].count(it->s)) {\n                it++;\n            }\n            if (it != cost[i-1].end()) {\n                cost[i].ins({it->f + A[i][j], j});\n            }\n        }\n    }\n    if (sz(cost[3]) == 0) {\n        cout << -1 << nl;\n    } else {\n        cout << cost[3].begin()->f << nl;\n    }\n}\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "graphs",
        "greedy",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Cheap Dinner.json",
    "editorial_link": "https://codeforces.com//blog/entry/87873",
    "editorial": "The main solution is dynamic programming: let for every possible dish be\r\nthe minimum cost to assemble a prefix of a dinner ending with the dish\r\n(here, can be a dish of any type: first course, second course, drink, or\r\ndessert). Then, the answer to the problem is the minimum value among all\r\ndesserts.The number of transitions in this dynamic programming is too\r\nbig, since, for example, when transitioning from first courses to second\r\ncourses, we need to check ) options. To speed this up, we need some sort\r\nof data structure built over the values of for all first courses that\r\nallows to recalculate for a second course quickly. There are two main\r\napproaches to this: build any version of RMQ over the values of dynamic\r\nprogramming for the first courses. Then, when we want to calculate the\r\nanswer for some second course , sort all types of first courses which\r\ndon\u00e2\u0080\u0099t go well with it, and make several RMQ queries to find the minimum\r\nvalue over all non-forbidden first courses; store all values of in a\r\ndata structure that supports adding an element, deleting an element, and\r\nfinding the minimum element (this DS should allow duplicate elements as\r\nwell). When we want to calculate the answer for some second course ,\r\nremove all values of corresponding to the first courses that don\u00e2\u0080\u0099t go\r\nwell with it from the data structure, query the minimum in it, and\r\ninsert the removed elements back. The same approach can be used to\r\nadvance from second courses to drinks and from drinks to desserts (you\r\ncan even use the same code in a for-loop with iterations, so the\r\nresulting solution is actually short and simple).\r\n"
}