{"link": "https://codeforces.com//contest/1767/problem/F", "problemId": "1697005", "problem_idx": "F", "shortId": "1767F", "contest_number": "1767", "problem_submissions": {"F": [185514153, 185548652, 185548569, 185548494, 185548166, 185548104, 185548070, 185547990, 185547931, 185538816, 185538731, 185536681, 185536510, 185533881, 185548043, 185547524, 185547405, 187061027, 188938985, 188938874, 188938733, 188938538, 188662943], "E": [185496241, 185503484, 185495581, 185501980, 185500616, 185536545, 185506476, 185505796, 185502863, 185502893, 185509737, 185509089, 185503658, 185500454, 188653481, 185507693, 185510300, 185512188, 185507422, 185511136, 191847813, 185508302], "D": [185485689, 185480567, 185486073, 185487205, 185489767, 185484058, 185487337, 185490632, 185495647, 185490973, 185492256, 185494935, 185488073, 185492422, 185494405, 185494252, 185494078, 185493034, 185501838], "C": [185476244, 185474583, 185478107, 185476554, 185481773, 185476338, 185483596, 185484239, 185478556, 185481931, 185485024, 185484128, 185481474, 185482158, 185486113, 185484367, 185484937, 185482445, 185483985], "B": [185470025, 185469866, 185470325, 185469767, 185469743, 185469974, 185468835, 185473229, 185470539, 185470117, 185471331, 185471042, 185470304, 185473480, 185472801, 185471018, 185472578, 185469524, 185472904], "A": [185468810, 185468911, 185468716, 185468796, 185468875, 185468821, 185471076, 185576332, 185469327, 185470858, 185468733, 185468950, 185468986, 185469052, 185468910, 185469302, 185469202, 185470756, 185472308, 185469751]}, "name": "F. Two Subtrees", "statement": "You are given a rooted tree consisting of n vertices. The vertex 1 is\r\nthe root. Each vertex has an integer written on it; this integer is\r\nval_i for the vertex i.You are given q queries to the tree. The i-th\r\nquery is represented by two vertices, u_i and v_i. To answer the query,\r\nconsider all vertices w that lie in the subtree of u_i or v_i . For all\r\nvertices in these two subtrees, list all integers written on them, and\r\nfind the integer with the maximum number of occurrences. If there are\r\nmultiple integers with maximum number of occurrences, the among them is\r\nthe answer.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int B = 5000;\nconst int N = 200200;\nvector<int> g[N];\nint par[N];\nint sz[N];\nint a[N];\nint aa[N];\nint c[N];\nint t[N][2];\nint tt[N];\nint cnt[N];\nint mainSon[N];\nint maxVal, bst;\nint n, q;\nint T;\nint ANS[N];\narray<int, 5> Q[N];\n\nvoid dfsSz(int v, int p) {\n\tpar[v] = p;\n\tsz[v] = 1;\n\tfor (int u : g[v]) if (u != p) {\n\t\tdfsSz(u, v);\n\t\tsz[v] += sz[u];\n\t}\n}\nvoid dfsTime(int v, int p) {\n\tvector<pii> ord;\n\tfor (int u : g[v]) if (u != p)\n\t\tord.push_back(mp(sz[u], u));\n\tsort(all(ord));\n\treverse(all(ord));\n\tif (!ord.empty()) mainSon[v] = ord[0].second;\n\ttt[T] = v;\n\tt[v][0] = T++;\n\tfor (int i = 0; i < (int)ord.size(); i++)\n\t\tdfsTime(ord[i].second, v);\n\tt[v][1] = T;\n}\n\nvoid addOne(int x) {\n\tcnt[x]++;\n\tif (cnt[x] > maxVal || (cnt[x] == maxVal && x < bst)) {\n\t\tmaxVal = cnt[x];\n\t\tbst = x;\n\t}\n}\nvoid remOne(int x) {\n\tcnt[x]--;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &aa[i]);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tmainSon[i] = -1;\n\tdfsSz(0, -1);\n\tdfsTime(0, -1);\n\tfor (int i = 0; i < n; i++)\n\t\ta[t[i][0]] = aa[i];\n\tfor (int i = 0; i < n; i++)\n\t\tc[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = tt[i];\n\t\tif (c[v] != -1) continue;\n\t\tif (sz[v] <= B) {\n\t\t\tc[v] = -2;\n\t\t\tcontinue;\n\t\t}\n\t\tint u = v;\n\t\twhile(mainSon[u] != -1 && sz[mainSon[u]] + B > sz[v]) u = mainSon[u];\n\t\tint w = u;\n\t\twhile(w != v) {\n\t\t\tc[w] = u;\n\t\t\tw = par[w];\n\t\t}\n\t\tc[v] = u;\n\t}\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tif (c[v] > c[u]) swap(v, u);\n\t\tQ[i] = {c[v], c[u], v, u, i};\n\t}\n\tsort(Q, Q + q);\n\tint l = 0;\n\twhile(l < q) {\n\t\tint r = l;\n\t\twhile(r < q && Q[l][0] == Q[r][0] && Q[l][1] == Q[r][1]) r++;\n\t\tint L1 = -1, R1 = -1, L2 = -1, R2 = -1;\n\t\tmaxVal = 0;\n\t\tbst = -1;\n\t\tint c1 = Q[l][0], c2 = Q[l][1];\n\t\tif (c1 != -2) {\n\t\t\tL1 = R1 = t[c1][0];\n\t\t\twhile(R1 < t[c1][1]) {\n\t\t\t\taddOne(a[R1++]);\n\t\t\t}\n\t\t}\n\t\tif (c2 != -2) {\n\t\t\tL2 = R2 = t[c2][0];\n\t\t\twhile(R2 < t[c2][1]) {\n\t\t\t\taddOne(a[R2++]);\n\t\t\t}\n\t\t}\n\t\tint curVal = maxVal;\n\t\tint curBst = bst;\n\t\tfor (int it = l; it < r; it++) {\n\t\t\tmaxVal = curVal;\n\t\t\tbst = curBst;\n\t\t\tint v = Q[it][2], u = Q[it][3];\n\t\t\tif (c1 == -2) {\n\t\t\t\tfor (int i = t[v][0]; i < t[v][1]; i++)\n\t\t\t\t\taddOne(a[i]);\n\t\t\t} else {\n\t\t\t\tassert(L1 >= t[v][0] && R1 <= t[v][1]);\n\t\t\t\twhile(L1 > t[v][0]) {\n\t\t\t\t\taddOne(a[--L1]);\n\t\t\t\t}\n\t\t\t\twhile(R1 < t[v][1]) {\n\t\t\t\t\taddOne(a[R1++]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c2 == -2) {\n\t\t\t\tfor (int i = t[u][0]; i < t[u][1]; i++)\n\t\t\t\t\taddOne(a[i]);\n\t\t\t} else {\n\t\t\t\tassert(L2 >= t[u][0] && R2 <= t[u][1]);\n\t\t\t\twhile(L2 > t[u][0]) {\n\t\t\t\t\taddOne(a[--L2]);\n\t\t\t\t}\n\t\t\t\twhile(R2 < t[u][1]) {\n\t\t\t\t\taddOne(a[R2++]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tANS[Q[it][4]] = bst;\n\t\t\tif (c1 == -2) {\n\t\t\t\tfor (int i = t[v][0]; i < t[v][1]; i++)\n\t\t\t\t\tremOne(a[i]);\n\t\t\t} else {\n\t\t\t\twhile(L1 < t[c1][0]) {\n\t\t\t\t\tremOne(a[L1++]);\n\t\t\t\t}\n\t\t\t\twhile(R1 > t[c1][1]) {\n\t\t\t\t\tremOne(a[--R1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c2 == -2) {\n\t\t\t\tfor (int i = t[u][0]; i < t[u][1]; i++)\n\t\t\t\t\tremOne(a[i]);\n\t\t\t} else {\n\t\t\t\twhile(L2 < t[c2][0]) {\n\t\t\t\t\tremOne(a[L2++]);\n\t\t\t\t}\n\t\t\t\twhile(R2 > t[c2][1]) {\n\t\t\t\t\tremOne(a[--R2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tl = r;\n\t\tif (c1 != -2) {\n\t\t\tfor (int i = L1; i < R1; i++)\n\t\t\t\tremOne(a[i]);\n\t\t}\n\t\tif (c2 != -2) {\n\t\t\tfor (int i = L2; i < R2; i++)\n\t\t\t\tremOne(a[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++)\n\t\tprintf(\"%d\\n\", ANS[i]);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "trees"], "dificulty": "3100", "interactive": false}