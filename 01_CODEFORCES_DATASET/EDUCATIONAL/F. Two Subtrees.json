{
    "link": "https://codeforces.com//contest/1767/problem/F",
    "problemId": "1697005",
    "problem_idx": "F",
    "shortId": "1767F",
    "contest_number": "1767",
    "problem_submissions": {
        "F": [
            185514153,
            185548652,
            185548569,
            185548494,
            185548166,
            185548104,
            185548070,
            185547990,
            185547931,
            185538816,
            185538731,
            185536681,
            185536510,
            185533881,
            185548043,
            185547524,
            185547405,
            187061027,
            188938985,
            188938874,
            188938733,
            188938538,
            188662943
        ],
        "E": [
            185496241,
            185503484,
            185495581,
            185501980,
            185500616,
            185536545,
            185506476,
            185505796,
            185502863,
            185502893,
            185509737,
            185509089,
            185503658,
            185500454,
            188653481,
            185507693,
            185510300,
            185512188,
            185507422,
            185511136,
            191847813,
            185508302
        ],
        "D": [
            185485689,
            185480567,
            185486073,
            185487205,
            185489767,
            185484058,
            185487337,
            185490632,
            185495647,
            185490973,
            185492256,
            185494935,
            185488073,
            185492422,
            185494405,
            185494252,
            185494078,
            185493034,
            185501838
        ],
        "C": [
            185476244,
            185474583,
            185478107,
            185476554,
            185481773,
            185476338,
            185483596,
            185484239,
            185478556,
            185481931,
            185485024,
            185484128,
            185481474,
            185482158,
            185486113,
            185484367,
            185484937,
            185482445,
            185483985
        ],
        "B": [
            185470025,
            185469866,
            185470325,
            185469767,
            185469743,
            185469974,
            185468835,
            185473229,
            185470539,
            185470117,
            185471331,
            185471042,
            185470304,
            185473480,
            185472801,
            185471018,
            185472578,
            185469524,
            185472904
        ],
        "A": [
            185468810,
            185468911,
            185468716,
            185468796,
            185468875,
            185468821,
            185471076,
            185576332,
            185469327,
            185470858,
            185468733,
            185468950,
            185468986,
            185469052,
            185468910,
            185469302,
            185469202,
            185470756,
            185472308,
            185469751
        ]
    },
    "name": "F. Two Subtrees",
    "statement": "You are given a rooted tree consisting of n vertices. The vertex 1 is\r\nthe root. Each vertex has an integer written on it; this integer is\r\nval_i for the vertex i.You are given q queries to the tree. The i-th\r\nquery is represented by two vertices, u_i and v_i. To answer the query,\r\nconsider all vertices w that lie in the subtree of u_i or v_i . For all\r\nvertices in these two subtrees, list all integers written on them, and\r\nfind the integer with the maximum number of occurrences. If there are\r\nmultiple integers with maximum number of occurrences, the among them is\r\nthe answer.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int B = 5000;\nconst int N = 200200;\nvector<int> g[N];\nint par[N];\nint sz[N];\nint a[N];\nint aa[N];\nint c[N];\nint t[N][2];\nint tt[N];\nint cnt[N];\nint mainSon[N];\nint maxVal, bst;\nint n, q;\nint T;\nint ANS[N];\narray<int, 5> Q[N];\n\nvoid dfsSz(int v, int p) {\n\tpar[v] = p;\n\tsz[v] = 1;\n\tfor (int u : g[v]) if (u != p) {\n\t\tdfsSz(u, v);\n\t\tsz[v] += sz[u];\n\t}\n}\nvoid dfsTime(int v, int p) {\n\tvector<pii> ord;\n\tfor (int u : g[v]) if (u != p)\n\t\tord.push_back(mp(sz[u], u));\n\tsort(all(ord));\n\treverse(all(ord));\n\tif (!ord.empty()) mainSon[v] = ord[0].second;\n\ttt[T] = v;\n\tt[v][0] = T++;\n\tfor (int i = 0; i < (int)ord.size(); i++)\n\t\tdfsTime(ord[i].second, v);\n\tt[v][1] = T;\n}\n\nvoid addOne(int x) {\n\tcnt[x]++;\n\tif (cnt[x] > maxVal || (cnt[x] == maxVal && x < bst)) {\n\t\tmaxVal = cnt[x];\n\t\tbst = x;\n\t}\n}\nvoid remOne(int x) {\n\tcnt[x]--;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &aa[i]);\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tg[v].push_back(u);\n\t\tg[u].push_back(v);\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tmainSon[i] = -1;\n\tdfsSz(0, -1);\n\tdfsTime(0, -1);\n\tfor (int i = 0; i < n; i++)\n\t\ta[t[i][0]] = aa[i];\n\tfor (int i = 0; i < n; i++)\n\t\tc[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = tt[i];\n\t\tif (c[v] != -1) continue;\n\t\tif (sz[v] <= B) {\n\t\t\tc[v] = -2;\n\t\t\tcontinue;\n\t\t}\n\t\tint u = v;\n\t\twhile(mainSon[u] != -1 && sz[mainSon[u]] + B > sz[v]) u = mainSon[u];\n\t\tint w = u;\n\t\twhile(w != v) {\n\t\t\tc[w] = u;\n\t\t\tw = par[w];\n\t\t}\n\t\tc[v] = u;\n\t}\n\tscanf(\"%d\", &q);\n\tfor (int i = 0; i < q; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\tif (c[v] > c[u]) swap(v, u);\n\t\tQ[i] = {c[v], c[u], v, u, i};\n\t}\n\tsort(Q, Q + q);\n\tint l = 0;\n\twhile(l < q) {\n\t\tint r = l;\n\t\twhile(r < q && Q[l][0] == Q[r][0] && Q[l][1] == Q[r][1]) r++;\n\t\tint L1 = -1, R1 = -1, L2 = -1, R2 = -1;\n\t\tmaxVal = 0;\n\t\tbst = -1;\n\t\tint c1 = Q[l][0], c2 = Q[l][1];\n\t\tif (c1 != -2) {\n\t\t\tL1 = R1 = t[c1][0];\n\t\t\twhile(R1 < t[c1][1]) {\n\t\t\t\taddOne(a[R1++]);\n\t\t\t}\n\t\t}\n\t\tif (c2 != -2) {\n\t\t\tL2 = R2 = t[c2][0];\n\t\t\twhile(R2 < t[c2][1]) {\n\t\t\t\taddOne(a[R2++]);\n\t\t\t}\n\t\t}\n\t\tint curVal = maxVal;\n\t\tint curBst = bst;\n\t\tfor (int it = l; it < r; it++) {\n\t\t\tmaxVal = curVal;\n\t\t\tbst = curBst;\n\t\t\tint v = Q[it][2], u = Q[it][3];\n\t\t\tif (c1 == -2) {\n\t\t\t\tfor (int i = t[v][0]; i < t[v][1]; i++)\n\t\t\t\t\taddOne(a[i]);\n\t\t\t} else {\n\t\t\t\tassert(L1 >= t[v][0] && R1 <= t[v][1]);\n\t\t\t\twhile(L1 > t[v][0]) {\n\t\t\t\t\taddOne(a[--L1]);\n\t\t\t\t}\n\t\t\t\twhile(R1 < t[v][1]) {\n\t\t\t\t\taddOne(a[R1++]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c2 == -2) {\n\t\t\t\tfor (int i = t[u][0]; i < t[u][1]; i++)\n\t\t\t\t\taddOne(a[i]);\n\t\t\t} else {\n\t\t\t\tassert(L2 >= t[u][0] && R2 <= t[u][1]);\n\t\t\t\twhile(L2 > t[u][0]) {\n\t\t\t\t\taddOne(a[--L2]);\n\t\t\t\t}\n\t\t\t\twhile(R2 < t[u][1]) {\n\t\t\t\t\taddOne(a[R2++]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tANS[Q[it][4]] = bst;\n\t\t\tif (c1 == -2) {\n\t\t\t\tfor (int i = t[v][0]; i < t[v][1]; i++)\n\t\t\t\t\tremOne(a[i]);\n\t\t\t} else {\n\t\t\t\twhile(L1 < t[c1][0]) {\n\t\t\t\t\tremOne(a[L1++]);\n\t\t\t\t}\n\t\t\t\twhile(R1 > t[c1][1]) {\n\t\t\t\t\tremOne(a[--R1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c2 == -2) {\n\t\t\t\tfor (int i = t[u][0]; i < t[u][1]; i++)\n\t\t\t\t\tremOne(a[i]);\n\t\t\t} else {\n\t\t\t\twhile(L2 < t[c2][0]) {\n\t\t\t\t\tremOne(a[L2++]);\n\t\t\t\t}\n\t\t\t\twhile(R2 > t[c2][1]) {\n\t\t\t\t\tremOne(a[--R2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tl = r;\n\t\tif (c1 != -2) {\n\t\t\tfor (int i = L1; i < R1; i++)\n\t\t\t\tremOne(a[i]);\n\t\t}\n\t\tif (c2 != -2) {\n\t\t\tfor (int i = L2; i < R2; i++)\n\t\t\t\tremOne(a[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i < q; i++)\n\t\tprintf(\"%d\\n\", ANS[i]);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Two Subtrees.json",
    "editorial_link": "https://codeforces.com//blog/entry/110225",
    "editorial": "First, let\u00e2\u0080\u0099s solve the following problem: we need to maintain a multiset\r\nof numbers and process queries of -th types: add a number to the\r\nmultiset, remove one occurrence of a number from the multiset (it is\r\nguaranteed that it exists), calculate the mode on this multiset. To do\r\nthis, we will maintain the array the frequency of in the multiset. Now\r\nthe mode is the position of the leftmost maximum in this array. There\r\nare many ways to search for this position, we will use the following: we\r\nwill build a sqrt-decomposition on the array : for a block we will\r\nmaintain a maximum on this block and an array the number of positions in\r\nthis block, such that . Since in each of the initial requests changes by\r\nno more than , the maximum in the block also changes by no more than 1\r\nand, using the array, it is easy to update it after each query. Now, to\r\nfind the mode (the position of the leftmost maximum in the array), you\r\nfirst need to go through all the blocks to find the value of the maximum\r\nand the leftmost block in which this maximum occurs, then iterate over\r\nthe desired position in this block. Thus, queries to add and remove an\r\nelement run in , and a mode search query runs in , where is the number\r\nof possible distinct values, in a given problem .Now let\u00e2\u0080\u0099s get back to\r\nthe problem itself. Let\u00e2\u0080\u0099s build a Preorder traversal of our tree. Let be\r\nthe position in the -indexing of the vertex in the Preorder traversal,\r\nbe the size of the Preorder traversal after leaving the vertex . Then\r\nthe half-interval of the Preorder traversal represents the set of\r\nvertices of the subtree of the vertex . For the -th query, we will\r\nconsider .Let be the size of the subtree of , be some integer, then will\r\nbe called light if , and heavy otherwise. A query is called light\r\n(heavy) if is a light (heavy) vertex. We will solve the problem for\r\nlight and heavy queries independently. Let\u00e2\u0080\u0099s use the small-to-large\r\ntechnique and maintain the multiset described at the beginning of the\r\nsolution. Let at the moment we have this multiset for the vertex . Let\u00e2\u0080\u0099s\r\nanswer all light queries for which . To do this, take all the vertices\r\nfrom the subtree of and add the numbers written on them, calculate the\r\nmode on the current multiset this will be the answer to the query, and\r\nthen delete the newly added vertices. In the standard implementation of\r\nsmall-to-large, you need to maintain several structures at the same\r\ntime, which in this case is impossible due to the fact that each of them\r\ntakes up of memory. This problem can be avoided, for example, as\r\nfollows: before constructing the Preorder traversal for each vertex ,\r\nput its heaviest son at the head of the adjacency list. Then it will be\r\npossible to iterate over the vertices in the order of the Preorder\r\ntraversal, preserving the asymptotics. This part of the solution runs in\r\n. Let\u00e2\u0080\u0099s divide all heavy vertices into non-intersecting vertical paths,\r\nso that two vertices from the same path have subtrees that differ by no\r\nmore than vertices, and the number of the paths themselves is . To do\r\nthis, let\u00e2\u0080\u0099s take the deepest of the unused heavy vertices and build one\r\nof the desired paths, going up to the parent, while the first of these\r\nconditions is met. Then we mark all the vertices in this path as used,\r\nand start over. We will continue to do this while there are still unused\r\nheavy vertices. It is easy to see that the resulting paths are vertical\r\nand the subtrees of two vertices from the same path differ by no more\r\nthan by construction. Let\u00e2\u0080\u0099s prove that there are not very many of these\r\npaths. To do this, we will understand in which cases the path breaks: If\r\nthe current path contains a root, then since the root has no parent, the\r\npath will terminate. Obviously, this path is only . If the parent of the\r\nlast vertex of the path has only one heavy child (this last vertex\r\nitself). From the construction, a break means that the number of\r\nvertices in this path plus the number of children outside the heaviest\r\nson subtree of the parent of the last vertex and each vertex of the\r\npath, except for the initial one, is more than in total, but each of the\r\ncounted vertices can be counted in only one of such cases, that is, the\r\nnumber of paths that terminate in this way does not exceed . If the\r\nparent of the last node has more than one heavy child. Let\u00e2\u0080\u0099s leave only\r\nheavy vertices in the tree (since the parent of a heavy vertex is a\r\nheavy vertex too, it will indeed be a tree (or an empty graph)). This\r\ntree contains at most leafs. Calculating the total degree of the\r\nvertices of this tree, we can see that there are at most additional sons\r\n(all sons of a vertex except one). This means that the number of paths\r\nterminating in this way is at most . We got that the paths are .Let\u00e2\u0080\u0099s\r\ndivide the heavy queries according to the paths where the is situated.\r\nWe will answer queries with vertices from the same path together. We\r\nwill do it similarly to the case with light queries, with minor\r\ndifferences: at the very beginning, we add to the multiset all the\r\nvertices of the subtree of the initial vertex of the path and mentally\r\nremove these vertices from the subtrees of vertices. Everything else is\r\npreserved. Let\u00e2\u0080\u0099s calculate how long it takes: add all vertices from one\r\nsubtree: , small-to-large: , to answer one query due to condition on\r\nvertices from one path we have to add at most vertices. Since there are\r\nonly paths, the whole solution will take . We take and, counting , we\r\nget and total running time . As already mentioned, a subtree corresponds\r\nto a segment of the Preorder traversal, so subtrees are segments. We\r\nwill maintain the data structure described at the beginning on the sum\r\nof segments. By moving the boundaries of these segments, you can move\r\nfrom one query to another, as in Mo\u00e2\u0080\u0099s algorithm. It remains only to sort\r\nthe queries. Heavy queries are sorted first by path number of , then by\r\n. Light queries are sorted only by , but here you can\u00e2\u0080\u0099t just move the\r\nsegment of the subtree, you need to rebuild it for each query. Solve\r\nthis problem for two subtrees and a path connecting the roots of these\r\nsubtrees.This solution partially intersects with the one described by\r\nthe problem author. We will use the same data structure for maintaining\r\nthe mode; and we will also use DFS order of the tree (but before\r\nconstructing it, we will reorder the children of each vertex so that the\r\nheaviest child is the first one).Let be the moment we enter the vertex\r\nin DFS, and be the moment we leave the vertex. As usual, the segment\r\nrepresents the subtree of vertex , and we can change the state of the\r\nstructure from the subtree of the vertex to the subtree of the vertex in\r\noperations. Let this number of operations be .Let be the DFS order of\r\nthe tree. We can prove that is estimated as if we order the children of\r\neach vertex in such a way that the first of them is the heaviest one..\r\nLet\u00e2\u0080\u0099s analyze how many times some vertex is added when we go in DFS\r\norder and maintain the current set of vertices. When some vertex is\r\nadded to the current subtree, this means that the previous vertex in DFS\r\norder was not an ancestor of the current vertex, so the current vertex\r\nis not the first son of its parent. So, the size of the subtree of the\r\nparent is at least 2x the size of the current vertex. Since the path\r\nfrom to root can have at most such vertices, then the vertex is added at\r\nmost times.Okay, how do we use it to process queries efficiently? Let\u00e2\u0080\u0099s\r\nsay that the vertex (the -th vertex in DFS order) has coordinate equal\r\nto . Let this coordinate be . Then, if we have the data structure for\r\nthe query and we want to change it so it meets the query , we can do it\r\nin at most operations, which can be treated as the Manhattan distance\r\nbetween points and .Do you see where this is going? We can map each\r\nquery to the point , and then order them in such a way that the total\r\ndistance we need to travel between them is not too large. We can use\r\nMo\u00e2\u0080\u0099s algorithm to do this. Since the coordinates are up to , but there\r\nare only points, some alternative sorting orders for Mo (like the one\r\nthat uses Hilbert\u00e2\u0080\u0099s curve) may work better than the usual one.\r\n"
}