{"link": "https://codeforces.com//contest/1499/problem/C", "problemId": "928251", "problem_idx": "C", "shortId": "1499C", "contest_number": "1499", "problem_submissions": {"F": [110357719, 110358460, 110349173, 110358016, 110369330, 110363127, 110361036, 110362817, 110367470, 110357203, 110369171, 110368211, 110370268, 110366091, 110355624, 110365992, 110369429, 110370266, 110365656], "E": [110348041, 110354549, 110362433, 110350437, 110347357, 110357359, 110349011, 110357563, 110354502, 110352211, 110355950, 110358510, 110361861, 110360330, 110370250, 110360561, 110360403, 110361550, 110357936], "D": [110338625, 110339185, 110410334, 110410318, 110410229, 110342082, 110340758, 110337901, 110434363, 110434311, 110432471, 110432456, 110384121, 110347999, 110344468, 110349024, 110347133, 110346694, 110345990, 110348574, 110343676, 110346592, 110347088, 110350111, 110350771, 110350595, 110349856], "C": [110333651, 110331021, 110334430, 110335594, 110331843, 110335775, 110331846, 110336227, 110336058, 110339413, 110333925, 110337781, 110335754, 110338528, 110342766, 110337144, 110339220, 110337699, 110337911], "B": [110328704, 110327182, 110329276, 110330310, 110327534, 110329852, 110327723, 110329207, 110329841, 110333664, 110328875, 110331182, 110328187, 110334069, 110334004, 110328671, 110331437, 110330565, 110331774], "A": [110326019, 110325991, 110326313, 110326005, 110325865, 110325899, 110325997, 110326125, 110326016, 110326091, 110326392, 110325908, 110325927, 110326243, 110325858, 110326228, 110326284, 110326209, 110326298], "G": [110573818, 110399277, 112155486, 110386520, 110388825]}, "name": "C. Minimum Grid Path", "statement": "Let\u2019s say you are standing on the XY-plane at point (0, 0) and you want\r\nto reach point (n, n).You can move only in two directions: to the , i.\r\ne. horizontally and in the direction that increase your x coordinate, or\r\n, i. e. vertically and in the direction that increase your y coordinate.\r\nIn other words, your path will have the following structure: initially,\r\nyou choose to go to the right or up; then you go some distance in the\r\nchosen direction (distances can be chosen independently); after that you\r\nchange your direction (from right to up, or from up to right) and repeat\r\nthe process. You don\u2019t like to change your direction too much, so you\r\nwill make no more than n - 1 direction changes.As a result, your path\r\nwill be a polygonal chain from (0, 0) to (n, n), consisting of n line\r\nsegments where each segment has positive integer length and vertical and\r\nhorizontal segments alternate.Not all paths are equal. You have n\r\nintegers c_1, c_2,\r\ndots, c_n where c_i is the cost of the i-th segment.Using these costs we\r\ncan define the as the sum of lengths of the segments of this path\r\nmultiplied by their cost, i. e. if the path consists of k segments (k\r\nle n), then the cost of the path is equal to\r\nsum\r\nlimits_{i=1}^{k}{c_i\r\ncdot length_i} (segments are numbered from 1 to k in the order they are\r\nin the path).Find the path of the minimum cost and print its cost.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint N;\nll C[101010];\n\nint main() {\n\tint tc; scanf(\"%d\", &tc);\n\twhile(tc--) {\n\t\tscanf(\"%d\", &N);\n\t\tfor(int i = 1; i <= N; i++) scanf(\"%lld\", &C[i]);\n\t\tll s0 = C[1], mn0 = C[1];\n\t\tll s1 = C[2], mn1 = C[2];\n\t\tll ans = (C[1] + C[2]) * N;\n\n\t\tfor(int i = 3; i <= N; i++) {\n\t\t\tif(i & 1) {\n\t\t\t\ts0 += C[i]; mn0 = min(mn0, C[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts1 += C[i]; mn1 = min(mn1, C[i]);\n\t\t\t}\n\t\t\tans = min(ans, s0 + mn0 * (N - (i + 1) / 2) + s1 + mn1 * (N - i / 2));\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["brute force", "data structures", "greedy", "math"], "dificulty": "1500", "interactive": false}