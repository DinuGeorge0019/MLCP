{
    "link": "https://codeforces.com//contest/660/problem/F",
    "problemId": "54418",
    "problem_idx": "F",
    "shortId": "660F",
    "contest_number": "660",
    "problem_submissions": {
        "F": [
            17239364,
            17239205,
            17239755,
            17238017,
            32736003,
            32634422,
            17240355,
            17266440,
            17390273,
            17390239,
            17390167,
            17239067,
            17283949,
            17242419,
            28385899,
            17237899
        ],
        "E": [
            17237675,
            18655900,
            17236241,
            17236591,
            17240301,
            17237690,
            17235572,
            17235893,
            17238324,
            17238151,
            17239741,
            17240955,
            17239261,
            17238105,
            28384744,
            17238510,
            17241405,
            17239444,
            17239692
        ],
        "C": [
            17233149,
            17233742,
            17234548,
            17232545,
            17234726,
            17232794,
            17232880,
            17232362,
            17233050,
            17232479,
            17233218,
            17232540,
            17233780,
            17233237,
            17233749,
            17233672,
            17233999,
            17234257
        ],
        "D": [
            17232410,
            17234486,
            17232234,
            17233026,
            17235245,
            17233173,
            17233945,
            17233153,
            17235270,
            17235762,
            17234096,
            17244499,
            17244482,
            17233228,
            17234097,
            17233913,
            17234439,
            17234508,
            17394145,
            17235565,
            17235267
        ],
        "B": [
            17232075,
            17232491,
            17233215,
            17240579,
            17234008,
            17232211,
            17232270,
            17233552,
            17232203,
            17233514,
            17232306,
            17232154,
            17233087,
            17233547,
            17232582,
            17233079,
            17232801,
            17232756
        ],
        "A": [
            17231695,
            17231866,
            17231724,
            17231870,
            17233301,
            17231713,
            17231748,
            17231689,
            17231712,
            17231907,
            17231758,
            17231697,
            17231904,
            17231863,
            17232106,
            17232315,
            17231848,
            17231851
        ]
    },
    "name": "F. Bear and Bowling 4",
    "statement": "Limak is an old brown bear. He often goes bowling with his friends.\r\nToday he feels really good and tries to beat his own record!For rolling\r\na ball one gets a score an integer (maybe negative) number of points.\r\nScore for the -th roll is multiplied by and scores are summed up. So,\r\nfor rolls with scores , the total score is . The total score is if there\r\nwere no rolls.Limak made rolls and got score for the -th of them. He\r\nwants to maximize his total score and he came up with an interesting\r\nidea. He can say that some first rolls were only a warm-up, and that he\r\nwasn\u2019t focused during the last rolls. More formally, he can cancel any\r\nprefix and any suffix of the sequence . It is allowed to cancel all\r\nrolls, or to cancel none of them.The total score is calculated as if\r\nthere were only non-canceled rolls. So, the first non-canceled roll has\r\nscore multiplied by , the second one has score multiplied by , and so\r\non, till the last non-canceled roll.What maximum total score can Limak\r\nget?\r\n",
    "solutions": [
        "# include <cstdio>\n# include <vector>\nusing namespace std;\nconst int MN = 2e5 + 44;\nlong long a[MN];\nvector <pair <int, long long> > hull;\nbool bad(pair <int, long long> x)\n{\n\tif (hull.size() < 2)\n\t\treturn false;\n\tpair <int, long long> y = hull.back();\n\tpair <int, long long> z = hull[hull.size() - 2];\n\treturn (x.second - y.second) * (z.first - y.first) < (z.second - y.second) * (x.first - y.first);\n}\nlong long eval(pair <int, long long> a, long long x, long long y)\n{\n// \tprintf(\"return %I64d\\n\", a.first * x + a.second + y);\n\treturn a.first * x + a.second + y;\n}\nlong long sufsum[MN];\nlong long sufscores[MN];\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\"%I64d\", a + i);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufsum[i] = sufsum[i + 1] + a[i];\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tsufscores[i] = sufscores[i + 1] + sufsum[i];\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tpair <int, long long> add = make_pair(i, sufscores[i]);\n// \t\tprintf(\"add %d %I64d\\n\", add.first, add.second);\n\t\twhile (bad(add))\n\t\t\thull.pop_back();\n\t\thull.push_back(add);\n\t}\n// \tfor (auto x : hull)\n// \t\tprintf(\"%d %I64d\\n\", x.first, x.second);\n\tlong long res = 0;\n\tlong long x = 0, y = 0;\n\tfor (int i = n - 1; i >= 0; --i)\n\t{\n// \t\tprintf(\"i = %d x = %I64d y = %I64d\\n\", i, x, y);\n\t\tint low = 0, high = hull.size() - 1;\n\t\twhile (low < high - 3)\n\t\t{\n\t\t\tint med = (low + high) / 2;\n\t\t\tif (hull[med].first > i)\n\t\t\t\thigh = med - 1;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlong long val = eval(hull[med], x, y);\n// \t\t\t\tprintf(\"include %d %I64d\\n\", hull[med].first, hull[med].second);\n\t\t\t\tres = max(res, val);\n\t\t\t\tif (eval(hull[med], x, y) > eval(hull[med + 1], x, y))\n\t\t\t\t\thigh = med;\n\t\t\t\telse\n\t\t\t\t\tlow = med;\n\t\t\t}\n\t\t}\n// \t\tprintf(\"binsearch done\\n\");\n\t\tfor (int k = low; k <= high; ++k)\n\t\t\tif (hull[k].first <= i)\n\t\t\t{\n// \t\t\t\tprintf(\"include %d %I64d\\n\", hull[k].first, hull[k].second);\n\t\t\t\tres = max(res, eval(hull[k], x, y));\n\t\t\t}\n\t\ty -= (i + 1) * a[i];\n\t\tx += a[i];\n\t}\n\tprintf(\"%I64d\\n\", res);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "geometry",
        "ternary search"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Bear and Bowling 4.json",
    "editorial_link": "https://codeforces.com//blog/entry/44259",
    "editorial": "The problem was prepared by Kamil Debowski Errichto. The problem\r\nanalysis is also prepared by him. The key is to use divide and conquer.\r\nWe need a recursive function f(left, right) that runs f(left, mid) and\r\nf(mid+1, right) (where ) and also considers all intervals going through\r\n. We will eventually need a convex hull of lines (linear functions) and\r\nlet\u00e2\u0080\u0099s see how to achieve it. For variables (, ) we will try to write the\r\nscore of interval as a linear function. It would be good to get\r\nsomething close to where and depend on , and depends on only. For each\r\nwe should find a linear function where should fit the equation : Now we\r\nhave a set of linear functions representing all possible left endpoints\r\n. For each right endpoint we should find and to fit equation again. With\r\nvalue of we can iterate over functions to find the one maximizing value\r\nof . And (still for fixed ) we should add to get the maximum possible\r\nscore of interval ending in . Brute Force with functions\r\n"
}