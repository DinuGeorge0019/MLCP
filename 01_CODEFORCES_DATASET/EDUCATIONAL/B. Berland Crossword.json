{
    "link": "https://codeforces.com//contest/1494/problem/B",
    "problemId": "913251",
    "problem_idx": "B",
    "shortId": "1494B",
    "contest_number": "1494",
    "problem_submissions": {
        "F": [
            108939157,
            108939159,
            108941615,
            108940380,
            108936690,
            108949404,
            108939049,
            108976002,
            109259098,
            114355817,
            114300723,
            109105687,
            108952860
        ],
        "E": [
            108917863,
            108917179,
            108917875,
            108920789,
            108924713,
            108911681,
            108911479,
            108897566,
            108915498,
            108912071,
            108919266,
            108916392,
            108921553,
            108913575,
            108918608,
            108932427,
            108930755,
            108916943
        ],
        "D": [
            108912126,
            108910016,
            108906106,
            108913150,
            108917394,
            108924483,
            108905862,
            108906091,
            108907069,
            108901150,
            108912737,
            108909289,
            108909997,
            108901829,
            108912218,
            108906405,
            108912083
        ],
        "C": [
            108899963,
            108897106,
            108898254,
            108894965,
            108905337,
            108946028,
            108904267,
            108903529,
            108894912,
            108900440,
            108893773,
            108903235,
            108896270,
            108897186,
            108897145,
            108895547,
            108897140,
            108897478,
            108896885
        ],
        "B": [
            108887573,
            108887648,
            108887088,
            108887791,
            108891184,
            108886492,
            108887122,
            108892723,
            108887267,
            108886341,
            108887638,
            108889178,
            108889629,
            108886479,
            108887946,
            108888463,
            108886261
        ],
        "A": [
            108886097,
            108886134,
            108886049,
            108886041,
            108887001,
            108886021,
            108886051,
            108886176,
            108886040,
            108887099,
            108886184,
            108886195,
            108886220,
            108886015,
            108886138,
            108886325,
            108885985
        ]
    },
    "name": "B. Berland Crossword",
    "statement": "Berland crossword is a puzzle that is solved on a square grid with n\r\nrows and n columns. Initially all the cells are white.To solve the\r\npuzzle one has to color some cells on the border of the grid black in\r\nsuch a way that: exactly U cells in the top row are black; exactly R\r\ncells in the rightmost column are black; exactly D cells in the bottom\r\nrow are black; exactly L cells in the leftmost column are black. Note\r\nthat you can color zero cells black and leave every cell white.Your task\r\nis to check if there exists a solution to the given puzzle.\r\n",
    "solutions": [
        "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\n\n\nvoid solve()\n{\n    int n, U, R, D, L;\n    cin>>n>>U>>R>>D>>L;\n\n    for (int mask = 0; mask<16; mask++)\n    {\n        bool check = true;\n\n        int u = 0, d = 0, r = 0, l = 0;\n        if (mask&1)\n        {\n            u++; l++;\n        }\n        if (mask&2)\n        {\n            l++; d++;\n        }\n        if (mask&4)\n        {\n            d++; r++;\n        }\n        if (mask&8)\n        {\n            r++; u++;\n        }\n        if (u>U || u + (n-2)<U) check = false;\n        if (d>D || d + (n-2)<D) check = false;\n        if (l>L || l + (n-2)<L) check = false;\n        if (r>R || r + (n-2)<R) check = false;\n\n        if (check) {cout<<\"YES\"<<endl; return;}\n    }\n    cout<<\"NO\"<<endl;\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t; while (t--) solve();\n\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "greedy",
        "implementation"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Berland Crossword.json",
    "editorial_link": "https://codeforces.com//blog/entry/88344",
    "editorial": "Consider some corner of the picture. If it\u00e2\u0080\u0099s colored black, then it\r\ncontributes to counts to both of the adjacent sides. Otherwise, it\r\ncontributes to none. All the remaining cells can contribute only to the\r\nside they are on. There are of such cells on each side.So let\u00e2\u0080\u0099s try all\r\noptions of coloring the corners. After fixing the colors of the corners,\r\nwe can calculate the number of cells that have to be colored on each\r\nside. That is calculated by taking the initial requirement and\r\nsubtracting the adjacent colored corners from it. If any of the numbers\r\nis below or above then that corner coloring doesn\u00e2\u0080\u0099t work. Otherwise, you\r\ncan always color the cells in some way.Overall complexity: per testcase.\r\n"
}