{
    "link": "https://codeforces.com//contest/1620/problem/C",
    "problemId": "1233290",
    "problem_idx": "C",
    "shortId": "1620C",
    "contest_number": "1620",
    "problem_submissions": {
        "G": [
            139834723,
            139834630,
            139800025,
            139798720,
            139797780,
            139795833,
            139793177,
            139797195,
            139801753,
            139800125,
            139798252,
            139806590,
            139801965,
            139799470,
            139800885,
            139815133,
            139836989,
            139836961,
            139803234,
            139783937,
            139766371,
            139781791,
            198626640,
            139785516,
            139791910,
            139794593,
            139799506,
            139797098,
            139802371,
            139794714
        ],
        "E": [
            139834170,
            139768900,
            139778404,
            139777262,
            139781401,
            139780307,
            180264469,
            139772320,
            139783598,
            139787731,
            139788776,
            139795635,
            139801166,
            139803161,
            139771172,
            139772982,
            139775572,
            139777494,
            139781749,
            139783689,
            139782938,
            139773708
        ],
        "D": [
            139828795,
            139828599,
            139828445,
            139801175,
            139773916,
            139773661,
            139775200,
            139772309,
            139777532,
            139778435,
            139852816,
            139778132,
            139769927,
            139780286,
            139786796,
            139790402,
            139791529,
            139805624,
            139765400,
            139770581,
            139781836,
            139766109,
            139779076,
            139774566,
            139785166
        ],
        "F": [
            139826678,
            139786211,
            139791869,
            139787814,
            139791341,
            139788904,
            139814807,
            139811473,
            139818294,
            139801200,
            139837073,
            139811622,
            139810717,
            139801430,
            139908478,
            139834808,
            139830354
        ],
        "B": [
            139800559,
            139758636,
            139759221,
            139759228,
            139768929,
            139762743,
            139760389,
            139791856,
            139762557,
            139759423,
            139779986,
            139793644,
            139810932,
            139757813,
            139761675,
            139760955,
            139759416,
            139760977,
            139759368,
            139760377
        ],
        "C": [
            139765159,
            139765932,
            139765302,
            139774145,
            139773181,
            207683198,
            139765484,
            139764863,
            139771290,
            139772950,
            139784482,
            139796217,
            139807967,
            139762141,
            139766772,
            139767896,
            139775442,
            139767619,
            139767081,
            139780353
        ],
        "A": [
            139756564,
            139756597,
            139756503,
            139756739,
            139759409,
            139756692,
            139757881,
            139756729,
            139756611,
            139777143,
            139792512,
            139812388,
            139756396,
            139756654,
            139757129,
            139756551,
            139756903,
            139756439,
            139756571
        ]
    },
    "name": "C. BA-String",
    "statement": "You are given an integer k and a string s that consists only of\r\ncharacters \u2019a\u2019 (a lowercase Latin letter) and \u2019*\u2019 (an asterisk).Each\r\nasterisk should be replaced with several (from 0 to k inclusive)\r\nlowercase Latin letters \u2019b\u2019. Different asterisk can be replaced with\r\ndifferent counts of letter \u2019b\u2019.The result of the replacement is called a\r\n.Two strings a and b are different if they either have different lengths\r\nor there exists such a position i that a_i\r\nneq b_i.A string a is lexicographically smaller than a string b if and\r\nonly if one of the following holds: a is a prefix of b, but a\r\nne b; in the first position where a and b differ, the string a has a\r\nletter that appears earlier in the alphabet than the corresponding\r\nletter in b. Now consider all different BA-strings and find the x-th\r\nlexicographically smallest of them.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<typename T, typename T_iterable>\nvector<pair<T, int>> run_length_encoding(const T_iterable &items) {\n    vector<pair<T, int>> encoding;\n    T previous;\n    int count = 0;\n\n    for (const T &item : items)\n        if (item == previous) {\n            count++;\n        } else {\n            if (count > 0)\n                encoding.emplace_back(previous, count);\n\n            previous = item;\n            count = 1;\n        }\n\n    if (count > 0)\n        encoding.emplace_back(previous, count);\n\n    return encoding;\n}\n\n\nvoid run_case() {\n    int N, K;\n    int64_t X;\n    string S;\n    cin >> N >> K >> X >> S;\n    X--;\n    vector<pair<char, int>> encoding = run_length_encoding<char>(S);\n    dbg(encoding);\n    vector<int64_t> bases;\n\n    for (auto &pr : encoding)\n        if (pr.first == '*')\n            bases.push_back(pr.second * K + 1);\n\n    dbg(bases);\n    vector<int64_t> B;\n\n    while (!bases.empty()) {\n        B.push_back(X % bases.back());\n        X /= bases.back();\n        bases.pop_back();\n    }\n\n    dbg(B);\n    string ans;\n\n    for (auto &pr : encoding)\n        if (pr.first == '*') {\n            ans += string(B.back(), 'b');\n            B.pop_back();\n        } else {\n            ans += string(pr.second, pr.first);\n        }\n\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. BA-String.json",
    "editorial_link": "https://codeforces.com//blog/entry/98061",
    "editorial": "Find all segments of asterisks in the string. Let there be of them, and\r\nthe number of asterisks in them be . That tells us that the -th segment\r\nof asterisks can be replaced with at most letters \u00e2\u0080\u0099b\u00e2\u0080\u0099.Notice that we can\r\ncompare two strings lexicographically using just the number of letters\r\n\u00e2\u0080\u0099b\u00e2\u0080\u0099 that replace each of segments of asterisks. Let that sequence for\r\nsome string be and that sequence for some string be . Then if and only\r\nif . That is, there exists such position that . The proof is trivial.So\r\nwe can actually look at the sequence as some kind of number in a mixed\r\nbase. The lowest \"digit\" can be of one of values (from to ). The second\r\nlowest one of . And so on. Then, comparison of two strings is the same\r\nas comparison of these two mixed base numbers.Thus, the task is to\r\nconvert number to this mixed base. Turns out, it\u00e2\u0080\u0099s not that hard. In\r\nbase , for example, the lowest digit can be determined as the remainder\r\nof the number of dividing by . Here it will be the remainder of dividing\r\nby . After that, divide and floor the number and proceed to the next\r\n\"digit\".After steps are done, the \"digits\" of that mixed base number\r\ntell exactly how many letters \u00e2\u0080\u0099b\u00e2\u0080\u0099 should replace each segment of\r\nasterisks.Overall complexity: per testcase to recover the string, to\r\nprint it.\r\n"
}