{
    "link": "https://codeforces.com//contest/911/problem/F",
    "problemId": "142500",
    "problem_idx": "F",
    "shortId": "911F",
    "contest_number": "911",
    "problem_submissions": {
        "F": [
            33730338,
            33736236,
            33729501,
            33733851,
            33737431,
            33736160,
            33727192,
            33731600,
            33738270,
            33731121,
            33731406,
            33727367,
            33728276,
            33726638,
            33731778,
            33732737,
            33730029,
            33731049,
            33829722,
            33829713,
            33734856
        ],
        "G": [
            33728994,
            33728318,
            33736310,
            33730624,
            33734693,
            33730072,
            33735518,
            33736927,
            33973095,
            33726198,
            33734145,
            33725486,
            33916145,
            33742312,
            33742380,
            33759087,
            33796642,
            33796567,
            76805271,
            33829935,
            33829896,
            33829810,
            33829610
        ],
        "E": [
            33722163,
            33722735,
            33725907,
            33726299,
            33730629,
            33721023,
            33733522,
            33726343,
            33733907,
            33718645,
            33736707,
            33723912,
            33723633,
            33723315,
            33722403,
            33726466,
            33724328,
            33722719,
            33725898
        ],
        "D": [
            33717830,
            33719177,
            33731193,
            33727114,
            33724269,
            33733276,
            33731713,
            33720741,
            33735525,
            33736390,
            33733900,
            33719447,
            33718488,
            33721217,
            33717781,
            33719325,
            33720612,
            33717555,
            33721885
        ],
        "C": [
            33716749,
            33717557,
            33718909,
            33717327,
            33726728,
            33731930,
            33730836,
            33718913,
            33730374,
            33721277,
            33735066,
            33717357,
            33719578,
            33716462,
            33717823,
            33718307,
            33715178,
            33719484
        ],
        "B": [
            33714368,
            33718005,
            33715412,
            33715624,
            33717403,
            33729431,
            33715928,
            33715342,
            33736651,
            33732506,
            33715356,
            33714796,
            33715837,
            33713865,
            33715844,
            33716072,
            33718139,
            33716208
        ],
        "A": [
            33713428,
            33714079,
            33713974,
            33713612,
            33713484,
            33713403,
            33728723,
            33713514,
            33713445,
            33735048,
            33731862,
            33714094,
            33713551,
            33713430,
            33713412,
            33713709,
            33713489,
            33714231,
            33713552
        ]
    },
    "name": "F. Tree Destruction",
    "statement": "You are given an unweighted tree with vertices. Then following\r\noperations are applied to the tree. A single operation consists of the\r\nfollowing steps: choose two leaves; add the length of the simple path\r\nbetween them to the answer; remove one of the chosen leaves from the\r\ntree. Initial answer (before applying operations) is . Obviously after\r\nsuch operations the tree will consist of a single vertex. Calculate the\r\nmaximal possible answer you can achieve, and construct a sequence of\r\noperations that allows you to achieve this answer!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nstatic int N;\nstatic vector<vi> edges;\nstatic vi parent;\nstatic vi depth;\nstatic vector<pii> dist;\nstatic vector<bool> diam;\nstatic int D, root, bot;\nstatic vector<pii> cuts;\n\nstatic void dfs(int cur, int p, int d)\n{\n    parent[cur] = p;\n    depth[cur] = d;\n    for (int v : edges[cur])\n        if (v != p)\n            dfs(v, cur, d + 1);\n}\n\nstatic pii get_dist(int cur)\n{\n    if (dist[cur].first == -1)\n    {\n        if (diam[cur])\n        {\n            if (depth[cur] > D - depth[cur])\n                dist[cur] = pii(depth[cur], root);\n            else\n                dist[cur] = pii(D - depth[cur], bot);\n        }\n        else\n        {\n            auto sub = get_dist(parent[cur]);\n            sub.first++;\n            cuts.emplace_back(sub.second, cur);\n            dist[cur] = sub;\n        }\n    }\n    return dist[cur];\n}\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    cin >> N;\n    edges.resize(N);\n    parent.resize(N);\n    depth.resize(N);\n    diam.resize(N);\n    dist.resize(N, pii(-1, -1));\n    for (int i = 0; i < N - 1; i++)\n    {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        edges[a].push_back(b);\n        edges[b].push_back(a);\n    }\n    dfs(0, -1, 0);\n    root = max_element(RA(depth)) - depth.begin();\n    dfs(root, -1, 0);\n    bot = max_element(RA(depth)) - depth.begin();\n    D = depth[bot];\n    for (int i = bot; i != -1; i = parent[i])\n        diam[i] = true;\n    ll score = ll(D) * ll(D + 1) / 2;\n    for (int i = 0; i < N; i++)\n        if (!diam[i])\n        {\n            auto sub = get_dist(i);\n            score += sub.first;\n        }\n    reverse(RA(cuts));\n    for (int i = bot; i != root; i = parent[i])\n        cuts.emplace_back(root, i);\n    cout << score << '\\n';\n    for (const auto &c : cuts)\n        cout << c.first + 1 << ' ' << c.second + 1 << ' ' << c.second + 1 << '\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Tree Destruction.json",
    "editorial_link": "https://codeforces.com/blog/entry/56771",
    "editorial": "The solution is to choose some diameter of given tree, then delete all\r\nthe leaves which don\u00e2\u0080\u0099t belong to diameter (iteratively), and then delete\r\nthe diameter. I.e. while tree includes vertices aside from the ones\r\nforming diameter we choose some leaf, increase answer by the length of\r\nthe path between this leaf and farthest endpoint of the diameter (from\r\nthis leaf) and delete this leaf. Then while tree consists of more than\r\none vertex we choose two endpoints of diameter, increase answer by the\r\nlength of the path between it and delete any of them.At first we need to\r\nprove that we can choose any diameter. It can be proved by next fact: we\r\ncan find the diameter by two graph traversals (DFS/BFS) (we need to find\r\nfarthest vertex and then again find farthest vertex from found farthest\r\nvertex, given path is a diameter of the tree). It means that for each\r\nvertex that doesn\u00e2\u0080\u0099t belongs to the diameter we will add maximal possible\r\npath length by the algorithm described above.And finally obviously that\r\nat some moment we need to delete the diameter and there is no way to do\r\nthis better than we do it in described solution.\r\n"
}