{
    "link": "https://codeforces.com//contest/1327/problem/D",
    "problemId": "571327",
    "problem_idx": "D",
    "shortId": "1327D",
    "contest_number": "1327",
    "problem_submissions": {
        "F": [
            74109494,
            74096912,
            74114522,
            74102690,
            74088644,
            74096945,
            74118574,
            74105095,
            74095826,
            74113555,
            74098825,
            74097831,
            74105606,
            74109593,
            74101097,
            74708534,
            74098586
        ],
        "G": [
            74091723,
            74123968,
            74123925,
            74114197,
            76629927,
            74211867,
            74588194,
            74135043,
            143583395,
            74127397,
            74126425,
            74105678,
            74715507
        ],
        "B": [
            74068544,
            74058114,
            74057729,
            74055609,
            74062072,
            74057059,
            74054855,
            74056002,
            74059330,
            74057094,
            74057214,
            74063726,
            74054652,
            74058809,
            74054826,
            74057170,
            74057831,
            74708239,
            74069029
        ],
        "E": [
            74063712,
            74072104,
            74084153,
            74095848,
            74069496,
            74077697,
            74073149,
            74081984,
            74074950,
            74080019,
            74086353,
            74075499,
            74090079,
            74089858,
            74078241,
            74086260,
            74708411,
            74085708
        ],
        "C": [
            74060977,
            74064317,
            74075501,
            74070865,
            74062695,
            74059969,
            74061257,
            74063448,
            74063934,
            74060895,
            74069645,
            74078565,
            74065457,
            74072914,
            74062504,
            74072575,
            74708279,
            74073328
        ],
        "D": [
            74058988,
            74081137,
            74080575,
            74087567,
            74078030,
            74085278,
            74068392,
            74068497,
            74084912,
            74069773,
            74079760,
            74085394,
            74082419,
            74068982,
            74073656,
            74080794,
            74708339,
            74079780
        ],
        "A": [
            74048309,
            74098107,
            74049366,
            74047546,
            74050945,
            74048503,
            74046989,
            74047125,
            74048033,
            74048151,
            74049565,
            74047828,
            74047513,
            74049730,
            74046774,
            74049977,
            74047800,
            74708180,
            74063309
        ]
    },
    "name": "D. Infinite Path",
    "statement": "You are given a colored permutation p_1, p_2,\r\ndots, p_n. The i-th element of the permutation has color c_i.Let’s\r\ndefine an as infinite sequence i, p[i], p[p[i]], p[p[p[i]]]\r\ndots where all elements have (c[i] = c[p[i]] = c[p[p[i]]] =\r\ndots).We can also define a multiplication of permutations a and b as\r\npermutation c = a\r\ntimes b where c[i] = b[a[i]]. Moreover, we can define a power k of\r\npermutation p as p^k=\r\nunderbrace{p\r\ntimes p\r\ntimes\r\ndots\r\ntimes p}_{k\r\ntext{ times}}.Find the minimum k > 0 such that p^k has at least one\r\ninfinite path (i.e. there is a position i in p^k such that the sequence\r\nstarting from i is an infinite path).It can be proved that the answer\r\nalways exists.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint _,p[N],c[N],vis[N],n;\nVI d[N];\nint main() {\n\tfor (int i=1;i<=200000;i++) for (int j=i;j<=200000;j+=i)\n\t\td[j].pb(i);\n\tfor (scanf(\"%d\",&_);_;_--) {\n\t\tscanf(\"%d\",&n);\n\t\trep(i,1,n+1) scanf(\"%d\",p+i);\n\t\trep(i,1,n+1) scanf(\"%d\",c+i),vis[i]=0;\n\t\tint ans=n+1;\n\t\trep(i,1,n+1) if (!vis[i]) {\n\t\t\tint u=i;\n\t\t\tVI cyc;\n\t\t\twhile (!vis[u]) {\n\t\t\t\tcyc.pb(c[u]);\n\t\t\t\tvis[u]=1;\n\t\t\t\tu=p[u];\n\t\t\t}\n\t\t\tint m=SZ(cyc);\n\t\t\tfor (auto k:d[m]) for (int j=0;j<k;j++) {\n\t\t\t\tbool suc=1;\n\t\t\t\tfor (int r=j;r<m;r+=k) {\n\t\t\t\t\tsuc&=cyc[r]==cyc[j];\n\t\t\t\t}\n\t\t\t\tif (suc) ans=min(ans,k);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "graphs",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Infinite Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/75147",
    "editorial": "Letâs look at the permutation as at a graph with n vertices and edges\r\n(i, p_i). Itâs not hard to prove that the graph consists of several\r\ncycles (self-loops are also considered as cycles). So, the sequence i,\r\np[i], p[p[i]],\r\ndots is just a walking on the corresponding cycle.Letâs consider one\r\ncycle c_1, c_2,\r\ndots, c_m. In permutation p we have p[c_i] = c_{(i + 1)\r\nmod m}. But since p^2 = p\r\ntimes p or p^2[i] = p[p[i]], so p^2[c_i] = c_{(i + 2)\r\nmod m} and in general case, p^k[c_i] = c_{(i + k)\r\nmod m}.Now, walking with step k we can note, that the initial cycle c\r\nsplit up on GCD(k, m) cycles of length\r\nfrac{m}{GCD(k, m)}. Looking at the definition of infinite path we can\r\nunderstand that all we need to do is to check that at least one of\r\nGCD(k, m) cycles have all vertices of the same color. We can check it in\r\nO(m) time for the cycle c and fixed k.The final observation is next: for\r\nk_1 and k_2 such that GCD(k_1, m) = GCD(k_2, m) the produced cycles will\r\nhave the same sets of vertices and differ only in the order of walking,\r\nso we can check only one representative for each GCD(k, m), i.e. we can\r\ntake only such k which divide m.We can handle each cycle of p\r\nseparately. So, using the approximation that the number of divisors of n\r\nis O(n^{\r\nfrac{1}{3}}), we get O(n^{\r\nfrac{4}{3}}) time complexity.\r\n",
    "hint": []
}