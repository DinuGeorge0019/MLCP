{
    "link": "https://codeforces.com//contest/985/problem/E",
    "problemId": "184586",
    "problem_idx": "E",
    "shortId": "985E",
    "contest_number": "985",
    "problem_submissions": {
        "G": [
            38542149,
            38512186,
            38512236,
            38513581,
            38508155,
            38634852,
            38634344,
            38634277,
            38515048
        ],
        "F": [
            38499146,
            38499001,
            38501533,
            38502149,
            44969812,
            38501168,
            38505525,
            38502880,
            38530512,
            38499950,
            38499753,
            38505154,
            38503491,
            38504126,
            38510981,
            38505877,
            38504312,
            38507584,
            38509250,
            38506993,
            38507253
        ],
        "E": [
            38493702,
            38497357,
            38497944,
            38499266,
            38496305,
            38496738,
            38500977,
            38502378,
            38496622,
            38497691,
            38498718,
            38497100,
            38498488,
            38496555,
            38502188,
            38501286,
            38496578,
            38488837,
            38503513,
            38500067,
            38501389
        ],
        "D": [
            38491674,
            38495666,
            38493742,
            38495486,
            38495900,
            38495531,
            38494634,
            38495573,
            38493765,
            38502434,
            38497951,
            38500032,
            38496113,
            38498092
        ],
        "C": [
            38489266,
            38490508,
            38491062,
            38490764,
            38489327,
            38492089,
            38489607,
            38491317,
            38489050,
            38492258,
            38493205,
            38490810,
            38490379,
            38491131,
            38492401,
            38495949,
            38492200,
            38493338,
            38495062
        ],
        "B": [
            38486666,
            38488118,
            38487524,
            38488045,
            38487258,
            38487260,
            38487379,
            38487785,
            38486818,
            38488660,
            38487046,
            38487281,
            38487622,
            38487410,
            38487870,
            38578001,
            38491648,
            38488972,
            38488613,
            38488764
        ],
        "A": [
            38486349,
            38486599,
            38486409,
            38487064,
            38486426,
            38486427,
            38486493,
            38486415,
            38486362,
            38487242,
            38486378,
            38489634,
            38486554,
            38486364,
            38486402,
            38577942,
            38487704,
            38486613,
            38486447,
            38487421
        ]
    },
    "name": "E. Pencils and Boxes",
    "statement": "Mishka received a gift of multicolored pencils for his birthday!\r\nUnfortunately he lives in a monochrome world, where everything is of the\r\nsame color and only saturation differs. This pack can be represented as\r\na sequence of integer numbers saturation of the color of each pencil.\r\nNow Mishka wants to put all the mess in the pack in order. He has an\r\ninfinite number of empty boxes to do this. He would like to fill some\r\nboxes in such a way that: Each pencil belongs to one box; Each non-empty\r\nbox has at least pencils in it; If pencils and belong to the same box,\r\nthen , where means absolute value of . Note that the opposite is\r\noptional, there can be pencils and such that and they belong to\r\ndifferent boxes. Help Mishka to determine if it’s possible to distribute\r\nall the pencils into boxes. Print \"\" if there exists such a\r\ndistribution. Otherwise print \"\".\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 500001;\n\nint n,k,d, cum[MX], lo;\nvi a;\n\nint getSum(int l, int r) {\n    if (l > r) return 0;\n    if (l == 0) return cum[r];\n    return cum[r]-cum[l-1];\n}\n\nvoid solve(int x) {\n    while (a[x-1]-a[lo] > d) lo ++;\n    int hi = x-k;\n    cum[x] = cum[x-1];\n    if (getSum(lo,hi)) cum[x] ++;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> k >> d;\n    a.resize(n);\n    F0R(i,n) cin >> a[i];\n    sort(all(a));\n    cum[0] = 1;\n    FOR(i,1,n+1) solve(i);\n    if (cum[n]-cum[n-1]) {\n        cout << \"YES\";\n        exit(0);\n    }\n    cout << \"NO\";\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Pencils and Boxes.json",
    "editorial_link": "https://codeforces.com//blog/entry/59623",
    "editorial": "At first you need to sort the sequence. Then if there exists some\r\nanswer, there also exists an answer such that every box in it contains\r\nsome segment of pencils.Now itâs pretty standard dp approach. Let be if\r\nitâs possible to distribute the first pencils into boxes correctly,\r\notherwise, initially. Now you can come up with straightforward\r\nimplementation. Letâs iterate over every and set to if for some , and\r\n.Now we should optimize it a bit. Notice that the second and the third\r\nconditions actually form some segment of indices. You need to check if\r\nthere is at least one value on this segment. This can be maintained with\r\ntwo pointers, set, BIT, segment tree. Anything you can code to get\r\nupdate in point and sum/max on segment queries. Overall complexity: .\r\n",
    "hint": []
}