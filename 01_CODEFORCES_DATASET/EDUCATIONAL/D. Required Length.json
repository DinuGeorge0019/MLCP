{
    "link": "https://codeforces.com//contest/1681/problem/D",
    "problemId": "1408805",
    "problem_idx": "D",
    "shortId": "1681D",
    "contest_number": "1681",
    "problem_submissions": {
        "E": [
            158182756,
            158181599,
            158189245,
            158201402,
            158212176,
            158209977,
            158197244,
            158200543,
            158207419,
            158195422,
            158212507,
            158201688,
            158217615,
            158236025,
            158203326,
            158213610,
            158220340,
            158209570,
            158222642,
            158202788
        ],
        "D": [
            158169620,
            158166339,
            158168627,
            158176540,
            158180183,
            158179810,
            158175614,
            158171745,
            158169793,
            158171043,
            158176143,
            158179351,
            158198071,
            158177219,
            158193904,
            158184952,
            158187520,
            158180354,
            158208785
        ],
        "F": [
            158163420,
            158197514,
            158198216,
            158189118,
            158175678,
            158193941,
            158204936,
            158208270,
            158190074,
            158203305,
            158200335,
            158211270,
            158186690,
            158250369,
            158237153,
            158219180,
            158187046,
            158203102,
            158220096,
            158206596,
            158220727
        ],
        "C": [
            158154298,
            158157033,
            158157275,
            158158888,
            158161011,
            158157520,
            158164047,
            158162763,
            158158338,
            158166846,
            158162496,
            158167443,
            158168946,
            158167710,
            158166768,
            158169766,
            158168157,
            158169965,
            158164354
        ],
        "B": [
            158153598,
            158154121,
            158153990,
            158154166,
            158155404,
            158154059,
            158159057,
            158156022,
            158154367,
            158163137,
            158157819,
            158159126,
            158157005,
            158167777,
            158160391,
            158158841,
            158161305,
            158161887,
            158159104
        ],
        "A": [
            158153541,
            158153617,
            158153597,
            158153653,
            158153683,
            158153631,
            158155593,
            158153768,
            158153633,
            158155729,
            158155747,
            158154711,
            158154019,
            158167893,
            158153987,
            158154332,
            158156617,
            158157260,
            158154882
        ]
    },
    "name": "D. Required Length",
    "statement": "You are given two integer numbers, n and x. You may perform several\r\noperations with the integer x.Each operation you perform is the\r\nfollowing one: choose any digit y that occurs in the decimal\r\nrepresentation of x at least once, and replace x by x\r\ncdot y.You want to make the length of decimal representation of x\r\n(without leading zeroes) equal to n. What is the minimum number of\r\noperations required to do that?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 23.05.2022 18:39:11       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  long long x;\n  cin >> n >> x;\n  vector<long long> p10(n);\n  p10[0] = 1;\n  for (int i = 1; i < n; i++) {\n    p10[i] = p10[i - 1] * 10;\n  }\n  long long goal = p10[n - 1];\n  const int inf = (int) 1e9;\n  int ans = inf;\n  function<void(int, long long)> Dfs = [&](int cnt, long long num) {\n    if (cnt >= ans) {\n      return;\n    }\n    if (num >= goal) {\n      ans = cnt;\n      return;\n    }\n    int need = 0;\n    long long tmp = num;\n    while (tmp < goal) {\n      tmp *= 9;\n      need += 1;\n    }\n    if (cnt + need >= ans) {\n      return;\n    }\n    array<bool, 10> has;\n    for (int d = 0; d < 10; d++) {\n      has[d] = false;\n    }\n    tmp = num;\n    while (tmp > 0) {\n      has[tmp % 10] = true;\n      tmp /= 10;\n    }\n    for (int d = 9; d >= 2; d--) {\n      if (has[d]) {\n        Dfs(cnt + 1, num * d);\n      }\n    }\n  };\n  Dfs(0, x);\n  cout << (ans == inf ? -1 : ans) << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "hashing",
        "shortest paths"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Required Length.json",
    "editorial_link": "https://codeforces.com//blog/entry/103163",
    "editorial": "One of the possible approaches to this problem is to try multiplying\r\nonly by the largest digit in it. Unfortunately, this doesnât work quite\r\nwell, since it gives WA on one of the examples. That example is too big\r\nto consider, but a smaller version of it can prove that this is an\r\nincorrect solution: let , . If we multiply by , we get , and thereâs no\r\nway to obtain a number with digits using the next action. But, if we\r\nmultiply by , we get , which can then be multiplied by to obtain a\r\n-digit number. So, considering only the largest digit is not enough.This\r\nimplies that we somehow need to consider the options that are not\r\noptimal locally, but optimal globally (i. e. choose a lower digit right\r\nnow to obtain a higher digit in the future). Letâs try to estimate the\r\nnumber of possible integers that can be obtained using these operations\r\nto see if we can consider all possible options. The key observation is\r\nthat each integer we obtain will have the form , since only one-digit\r\nprimes can be added to the factorization. Since we consider only numbers\r\nless than , is not greater than , is not greater than , is not greater\r\nthan , and is not greater than , and the number of reachable integers is\r\nabout million (note that this is a very generous bound since not all\r\ncombinations of yield an integer less than , and not all such integers\r\ncan be reached with the operations).This allows us to use BFS or dynamic\r\nprogramming to calculate the answer.\r\n",
    "hint": []
}