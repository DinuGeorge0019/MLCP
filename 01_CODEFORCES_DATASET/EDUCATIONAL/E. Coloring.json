{
    "link": "https://codeforces.com//contest/1697/problem/E",
    "problemId": "1427644",
    "problem_idx": "E",
    "shortId": "1697E",
    "contest_number": "1697",
    "problem_submissions": {
        "F": [
            160316028,
            160335271,
            160331836,
            160345509,
            160346300,
            160344663,
            160340959,
            160455567,
            160365066,
            160450918
        ],
        "E": [
            160306724,
            160317216,
            160317720,
            160323985,
            160325271,
            160325964,
            160354419,
            160319599,
            160322353,
            160325146,
            160325548,
            160320808,
            160330194,
            160331332,
            160324375,
            160329677,
            160325210,
            160439973,
            160435649,
            160435501,
            160334542,
            160334158
        ],
        "D": [
            160297103,
            160308079,
            160308707,
            160309184,
            160311087,
            160315683,
            160304446,
            160307456,
            160306088,
            160309775,
            160310589,
            160312120,
            160309909,
            160314751,
            160306875,
            160306002,
            160313672,
            160319695,
            160308549
        ],
        "C": [
            160289797,
            160295599,
            160301341,
            160300167,
            160298909,
            160307057,
            160312096,
            160291233,
            160293256,
            160294510,
            160299611,
            160297247,
            160296258,
            160299415,
            160296418,
            160293099,
            160299382,
            160299241,
            160297402
        ],
        "B": [
            160279508,
            160282090,
            160301342,
            160292066,
            160285118,
            160283650,
            160284312,
            160283738,
            160281629,
            160287785,
            160284110,
            160279928,
            160285652,
            160285722,
            160282180,
            160283286,
            160288457,
            160284205,
            160285201
        ],
        "A": [
            160279237,
            160279338,
            160286569,
            160289515,
            160279504,
            160279374,
            160279443,
            160279381,
            160279282,
            160282067,
            160279274,
            160279241,
            160281284,
            160279454,
            160279294,
            160279242,
            160281815,
            160279598,
            160280937
        ]
    },
    "name": "E. Coloring",
    "statement": "You are given n points on the plane, the coordinates of the i-th point\r\nare (x_i, y_i). No two points have the same coordinates.The distance\r\nbetween points i and j is defined as d(i,j) = |x_i - x_j| + |y_i -\r\ny_j|.For each point, you have to choose a color, represented by an\r\ninteger from 1 to n. For every ordered triple of different points\r\n(a,b,c), the following constraints should be met: if a, b and c have the\r\nsame color, then d(a,b) = d(a,c) = d(b,c); if a and b have the same\r\ncolor, and the color of c is different from the color of a, then d(a,b)\r\n< d(a,c) and d(a,b) < d(b,c). Calculate the number of different ways to\r\nchoose the colors that meet these constraints.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 12.06.2022 18:54:34       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  vector<vector<int>> d(n, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      d[i][j] = abs(x[i] - x[j]) + abs(y[i] - y[j]);\n    }\n  }\n  vector<vector<int>> mins(n);\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (i == j) {\n        continue;\n      }\n      if (!mins[i].empty() && d[i][j] < d[i][mins[i][0]]) {\n        mins[i].clear();\n      }\n      if (mins[i].empty() || d[i][j] == d[i][mins[i][0]]) {\n        mins[i].push_back(j);\n      }\n    }\n    mins[i].push_back(i);\n    sort(mins[i].begin(), mins[i].end());\n  }\n  vector<bool> alive(n, true);\n  vector<Mint> dp(n + 1, 0);\n  dp[0] = 1;\n  for (int i = 0; i < n; i++) {\n    if (!alive[i]) {\n      continue;\n    }\n    bool ok = true;\n    for (int x : mins[i]) {\n      if (mins[i] != mins[x]) {\n        ok = false;\n        break;\n      }\n    }\n    int sz;\n    if (ok) {\n      sz = (int) mins[i].size();\n      for (int x : mins[i]) {\n        alive[x] = false;\n      }\n    } else {\n      sz = 1;\n      alive[i] = false;\n    }\n    for (int j = n - 1; j >= 0; j--) {\n      dp[j + 1] += dp[j];\n      if (sz > 1 && j + sz <= n) {\n        dp[j + sz] += dp[j];\n      }\n      dp[j] = 0;\n    }\n  }\n  C(n, 0);\n  Mint ans = 0;\n  for (int i = 1; i <= n; i++) {\n    ans += dp[i] * C(n, i) * fact[i];\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "dp",
        "geometry",
        "graphs",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/103835",
    "editorial": "Let\u00e2\u0080\u0099s call a point if its color does not match the color of any other\r\npoint. If a point is not isolated, then it has the same color as the\r\npoints with minimum distance to it (and only these points should have\r\nthis color).Let\u00e2\u0080\u0099s build a directed graph where the arc means that the\r\npoint is one of the closest to the point (i. e. ). If there is a path\r\nfrom the vertex to the vertex , it means that if the vertex is not\r\nisolated, the vertex should have the same color as vertex .Suppose the\r\nset of vertices reachable from (including itself) is . Finding is easy\r\njust run DFS from the vertex . Let\u00e2\u0080\u0099s analyze two cases: there exists a\r\npair of vertices such that , , and there is no arc from to ; for every\r\npair of vertices such that and , there is an arc . Why do we need to\r\nanalyze these two cases? In the first case, the vertex be isolated,\r\nbecause painting it and some other vertex into the same color means that\r\nevery vertex from will have this color, and it will break the condition\r\nin the statement. In the second case, the vertex may be isolated, or it\r\nmay have the same color as all vertices in and if it is isolated, then\r\nthe whole set should consist of isolated vertices.Let\u00e2\u0080\u0099s find all such\r\nset of vertices that meet the second case. Each vertex will belong to at\r\nmost one of these sets; if it doesn\u00e2\u0080\u0099t belong to any, it must be\r\nisolated, otherwise either the whole its set consists of isolated\r\nvertices, or the whole set has the same color. So, for each set, we\r\neither use color or colors. This allows us to implement a knapsack-like\r\ndynamic programming: let be the number of ways to paint first sets into\r\ncolors, such that the colors are not ordered. After running this dynamic\r\nprogramming, we can get the answer by simple combinatorics: iterate on\r\nthe number of colors we use in these sets in total, multiply the dynamic\r\nprogramming for it by the (ordered) number of ways to choose these\r\ncolors from , and then by the number of ways to choose the colors for\r\npoints that must be isolated.This dynamic programming can even be\r\nimplemented a bit easier if we treat every vertex that must be isolated\r\nas a set of size , and this is the way it\u00e2\u0080\u0099s written in the model\r\nsolution.\r\n"
}