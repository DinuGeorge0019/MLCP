{
    "link": "https://codeforces.com//contest/2104/problem/E",
    "problemId": "3357541",
    "problem_idx": "E",
    "shortId": "2104E",
    "contest_number": "2104",
    "problem_submissions": {
        "G": [
            317634002,
            317631743,
            320673214,
            317636349,
            317639303,
            317631308,
            317640372,
            317641490,
            317634993,
            317623920,
            317623580,
            317647581,
            317646744,
            317640479,
            317649324,
            317648614,
            317603575,
            317625986,
            317658338,
            317654956,
            317656090
        ],
        "F": [
            317618453,
            317615339,
            317611576,
            317619502,
            317642933,
            317616740,
            317626825,
            317624444,
            317635700,
            317630227,
            317652195,
            317651366,
            317632460,
            317639846,
            317622626,
            317627252,
            317618955,
            317629645,
            317633465
        ],
        "E": [
            317600678,
            317604770,
            317604225,
            317601494,
            317605089,
            317605713,
            317610349,
            317606588,
            317606228,
            317611391,
            317609737,
            317616567,
            317624447,
            317604365,
            317605239,
            317606517,
            317605527,
            317603967
        ],
        "D": [
            317596832,
            317600994,
            317595577,
            317597224,
            317599585,
            317599131,
            317603322,
            317601392,
            317602519,
            317606339,
            317605002,
            317608223,
            317625926,
            317598715,
            317596708,
            317599445,
            317601363,
            317598919
        ],
        "C": [
            317592206,
            317594503,
            317591740,
            317592536,
            317595007,
            317592453,
            317599440,
            317596483,
            317666768,
            317597634,
            317597533,
            317596118,
            317603421,
            317628135,
            317593822,
            317592818,
            317594552,
            317594062,
            317592586
        ],
        "B": [
            317586512,
            317588149,
            317586474,
            317586748,
            317587897,
            317586575,
            317590393,
            317589124,
            317590519,
            317590566,
            317590505,
            317595035,
            317629001,
            317588704,
            317587930,
            317589549,
            317586793,
            317587862
        ],
        "A": [
            317583850,
            317584199,
            317583696,
            317583966,
            317584221,
            317583906,
            317584707,
            317583779,
            317583664,
            317586307,
            317586411,
            317589674,
            317629578,
            317583905,
            317584152,
            317583791,
            317583699,
            317583693
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/142472",
    "editorial": "For a start, let’s think about how to check, is a subsequence of . There\r\nis a greedy solution to that: let’s match with the leftmost character in\r\nthat is equal to it. Then match with the next leftmost character in that\r\ngoes after the first one, and so on. If we matched all characters in ,\r\nthen is a subsequence of .One of the common ways to write the algorithm\r\nabove is to count array where is the position of the next occurrence of\r\ncharacter starting from position . Array can be calculated in linear\r\ntime, since differs from in only one position.Then we can check the\r\nstring in time, just jumping from current position (in ) to until either\r\nends or \"doesn’t exist\" (we can set such equal to (remember, zero\r\nindexation)).So, how to add the minimum numbers of characters to string\r\nto make it unpleasant? It’s equivalent to making the minimum number of\r\nextra jumps in array to reach . Suppose, we applied the algorithm above\r\non and finished at position . Now, we are choosing which character to\r\nadd. It’s the same as choosing which to choose as the next jump.It’s not\r\nhard to prove that it’s optimal to choose with the maximum value (since\r\nit won’t increase the answer). After that, we jump to and the procedure\r\nrepeats. When becomes bigger or equal to , we’ve reached the goal.In\r\nother words, the answer depends only on the \"starting\" position . So, we\r\ncan calculate all of them as a dp array , where is the minimum number of\r\njumps needed. Then is equal to ( here is to exclude the situation where\r\nwe match the same character in with several characters from ).In total,\r\nwe precalculate arrays and . Then for each we match it in and print the\r\nvalue of . The total complexity is .\r\n",
    "name": "E. Unpleasant Strings",
    "statement": "Let’s call a letter if it is a lowercase letter and is one of the first\r\nk letters of the Latin alphabet.You are given a string s of length n,\r\nconsisting only of allowed letters.Let’s call a string t if t is a\r\nsubsequence of s.You are given q strings t_1, t_2,\r\ndots, t_q. All of them consist only of allowed letters. For each string\r\nt_i, calculate the minimum number of allowed letters you need to append\r\nto it on the right so that it being pleasant.A sequence t is a\r\nsubsequence of a sequence s if t can be obtained from s by the deletion\r\nof several (possibly, zero or all) element from arbitrary positions.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Unpleasant Strings.json",
    "hint": []
}