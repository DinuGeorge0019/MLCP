{"link": "https://codeforces.com//contest/1334/problem/F", "problemId": "590686", "problem_idx": "F", "shortId": "1334F", "contest_number": "1334", "problem_submissions": {"G": [76150604, 76454180, 76191944, 76188027, 76167647, 76177375, 76173628, 76186408, 76177963, 76163688, 76192725, 76184456, 76199963, 76199932, 76182086, 76197235, 76196570, 76214003, 76498225, 76495336, 76260338], "F": [76137544, 76454142, 76145547, 76157286, 76163120, 76164905, 76178511, 76167121, 76165115, 77917392, 76145490, 76152253, 76160935, 76165553, 76165708, 76168968, 76174508, 76168274, 76170642, 76172386, 76176147], "E": [76125664, 76454103, 76130620, 76144771, 76144664, 76158374, 76133358, 76154175, 76146278, 77917431, 76130418, 76125237, 76138118, 76141034, 76142668, 76149616, 76144057, 76143238, 76146704, 76123897, 76133227], "D": [76117930, 76454057, 76121143, 76124195, 76129444, 76121217, 76145661, 76143168, 76138942, 76118871, 76134614, 76125142, 76129022, 76126912, 76131421, 76134529, 76131763, 76126502, 76140986, 76147818], "C": [76108518, 76454007, 76107934, 76107462, 76112664, 76110005, 76119790, 76108604, 76117844, 76213964, 76213679, 76105910, 76110649, 76113576, 76108183, 76111773, 76111557, 76110114, 76109227, 76109093, 76106723, 76112412], "B": [76102992, 76453951, 76102307, 76102229, 76104046, 76104090, 76113043, 76104228, 76113456, 76102698, 76104186, 76104760, 76102468, 76104601, 76103592, 76102759, 76103107, 76101604, 76101877, 76102615], "A": [76101170, 76453913, 76100742, 76100982, 76101188, 76101149, 76107978, 76101072, 76103065, 76100866, 76101471, 76100923, 76100719, 76101105, 76100817, 76100705, 76100882, 76100750, 76100773, 76100924]}, "name": "F. Strange Function", "statement": "Let\u2019s denote the following function f. This function takes an array a of\r\nlength n and returns an array. Initially the result is an empty array.\r\nFor each integer i from 1 to n we add element a_i to the end of the\r\nresulting array if it is greater than all previous elements (more\r\nformally, if a_i >\r\nmax\r\nlimits_{1\r\nle j < i}a_j). Some examples of the function f: if a = [3, 1, 2, 7, 7,\r\n3, 6, 7, 8] then f(a) = [3, 7, 8]; if a = [1] then f(a) = [1]; if a =\r\n[4, 1, 1, 2, 3] then f(a) = [4]; if a = [1, 3, 1, 2, 6, 8, 7, 7, 4, 11,\r\n10] then f(a) = [1, 3, 6, 8, 11]. You are given two arrays: array a_1,\r\na_2,\r\ndots , a_n and array b_1, b_2,\r\ndots , b_m. You can delete some elements of array a (possibly zero). To\r\ndelete the element a_i, you have to pay p_i coins (the value of p_i can\r\nbe negative, then you get |p_i| coins, if you delete this element).\r\nCalculate the minimum number of coins (possibly negative) you have to\r\nspend for fulfilling equality f(a) = b.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=501000;\nstruct node {\n\tll fg;\n\tll val;\n}nd[4*N];\nvoid upd(int p) {\n\n}\nvoid setf(int p,ll v) {\n\tnd[p].fg+=v;\n\tnd[p].val+=v;\n}\nvoid build(int p,int l,int r) {\n\tnd[p].fg=0;\n\tnd[p].val=1ll<<60;\n\tif (l==r) {\n\t\tif (l==0) nd[p].val=0;\n\t} else {\n\t\tint md=(l+r)>>1;\n\t\tbuild(p+p,l,md);\n\t\tbuild(p+p+1,md+1,r);\n\t\tupd(p);\n\t}\n}\nvoid push(int p) {\n\tif (nd[p].fg) {\n\t\tsetf(p+p,nd[p].fg);\n\t\tsetf(p+p+1,nd[p].fg);\n\t\tnd[p].fg=0;\n\t}\n}\nll query(int p,int l,int r,int x) {\n\tif (l==r) return nd[p].val;\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (x<=md) return query(p+p,l,md,x);\n\t\telse return query(p+p+1,md+1,r,x);\n\t}\n}\nvoid modify(int p,int l,int r,int tl,int tr,ll v) {\n\tif (tl>tr) return;\n\tif (tl==l&&tr==r) return setf(p,v);\n\telse {\n\t\tpush(p);\n\t\tint md=(l+r)>>1;\n\t\tif (tr<=md) modify(p+p,l,md,tl,tr,v);\n\t\telse if (tl>md) modify(p+p+1,md+1,r,tl,tr,v);\n\t\telse modify(p+p,l,md,tl,md,v),modify(p+p+1,md+1,r,md+1,tr,v);\n\t\tupd(p);\n\t}\n}\n\nint n,a[N],p[N],b[N],m;\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n+1) scanf(\"%d\",a+i);\n\trep(i,1,n+1) scanf(\"%d\",p+i);\n\tscanf(\"%d\",&m);\n\trep(i,1,m+1) scanf(\"%d\",b+i);\n\tb[m+1]=1<<30;\n\tbuild(1,0,m);\n\trep(i,1,n+1) {\n\t\tint j=lower_bound(b+1,b+m+1,a[i])-b;\n\t\tif (b[j]==a[i]) {\n\t\t\tmodify(1,0,m,j+1,m,min(p[i],0));\n\t\t\tll a=query(1,0,m,j);\n\t\t\tll x=a+min(p[i],0),y=query(1,0,m,j-1);\n\t\t\tmodify(1,0,m,j,j,min(x,y)-a);\n\t\t\tmodify(1,0,m,0,j-1,p[i]);\n\t\t} else {\n\t\t\tmodify(1,0,m,j,m,min(p[i],0));\n\t\t\tmodify(1,0,m,0,j-1,p[i]);\n\t\t}\n\t\t//rep(j,0,m+1) printf(\"%lld \",query(1,0,m,j));\n\t\t//puts(\"\");\n\t}\n\tll a=query(1,0,m,m);\n\tif (a>=1ll<<55) puts(\"NO\"); else printf(\"YES\\n%lld\\n\",a);\n}"], "input": "", "output": "", "tags": ["binary search", "data structures", "dp", "greedy"], "dificulty": "2500", "interactive": false}