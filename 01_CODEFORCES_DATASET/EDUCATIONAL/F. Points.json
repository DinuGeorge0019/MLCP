{
    "link": "https://codeforces.com//contest/1701/problem/F",
    "problemId": "1455054",
    "problem_idx": "F",
    "shortId": "1701F",
    "contest_number": "1701",
    "problem_submissions": {
        "F": [
            163251511,
            163268194,
            163257685,
            163252572,
            163254045,
            163268305,
            163279907,
            163277017,
            163279770,
            163277875,
            163278549,
            163242709,
            163276457,
            163283113,
            163287382,
            163289836,
            163287332,
            163286601,
            163290833,
            163270658
        ],
        "E": [
            163244868,
            163259890,
            163266161,
            163272812,
            163264648,
            163275442,
            163258821,
            163268518,
            163268841,
            163260671,
            163264743,
            163281368,
            163267683,
            163251911,
            163266438,
            163264157,
            163269030,
            163266798,
            163269366,
            163285662
        ],
        "D": [
            163228805,
            163243794,
            163241985,
            163230350,
            163241043,
            163238273,
            163235471,
            163239458,
            163247152,
            163243702,
            163253899,
            163251145,
            163245848,
            163241441,
            163251457,
            163249655,
            163254700,
            163255033,
            163238314,
            163253263
        ],
        "C": [
            163221033,
            163229733,
            163226787,
            163222248,
            163228927,
            163224161,
            163224146,
            163230155,
            163230384,
            163234091,
            163239295,
            163237663,
            163233141,
            163239841,
            163244784,
            163239399,
            163238796,
            163229460,
            163228482,
            163229332
        ],
        "B": [
            163216526,
            163223020,
            163218771,
            163216500,
            163222790,
            163218690,
            163217320,
            163219287,
            163222344,
            163220198,
            163229802,
            163224763,
            163220303,
            163218845,
            163218374,
            163222260,
            163227662,
            163222420,
            163219736,
            163217995
        ],
        "A": [
            163216029,
            163216466,
            163216829,
            163216062,
            163216261,
            163216352,
            163216058,
            163216701,
            163216924,
            163216152,
            163225075,
            163216629,
            163216398,
            163216381,
            163216162,
            163216559,
            163221320,
            163216621,
            163217196,
            163216126
        ]
    },
    "name": "F. Points",
    "statement": "A triple of points i, j and k on a coordinate line is called if i < j <\r\nk and k - i\r\nle d.You are given a set of points on a coordinate line, initially\r\nempty. You have to process queries of three types: add a point; remove a\r\npoint; calculate the number of beautiful triples consisting of points\r\nbelonging to the set.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 08.07.2022 18:58:34       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nclass segtree {\n public:\n  struct node {\n    long long a = 0;\n    long long b = 0;\n    long long p = 0;\n\n    void apply(int l, int r, int va, int vb) {\n      a += va;\n      b += vb;\n      p = a * b;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.a = a.a + b.a;\n    res.b = a.b + b.b;\n    res.p = a.p + b.p + a.a * b.b;\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int q, d;\n  cin >> q >> d;\n  const int N = (int) 5e5 + 10;\n  long long ans = 0;\n  vector<int> a(N);\n  segtree st(N);\n  for (int i = 0; i < q; i++) {\n    int x;\n    cin >> x;\n    long long coeff = (a[x] == 0 ? 1 : -1);\n    long long delta = 0;\n    auto nd1 = st.get(x + 1, x + d);\n    auto nd2 = st.get(max(0, x - d), x - 1);\n    delta += nd1.a * (nd1.a - 1) / 2;\n    delta += nd2.a * (nd2.a - 1) / 2;\n    if (d > 1) {\n      auto nd3 = st.get(x + 1, x + d - 1);\n      delta += nd3.p;\n    }\n    ans += coeff * delta;\n    st.modify(x, x, coeff, 0);\n    st.modify(x + d, x + d, 0, coeff);\n    a[x] ^= 1;\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "implementation",
        "math",
        "matrices"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Points.json",
    "editorial_link": "https://codeforces.com//blog/entry/104671",
    "editorial": "We are going to calculate the answer as follows: for every point , let\r\nbe the number of points such that (i. e. the number of points that are\r\nto the right of and have distance at most from it). Then, the number of\r\nbeautiful triples where is the leftmost point is . We can sum these\r\nvalues over all points to get the answer; so, the solution should\r\nsomehow maintain and update the sum of these values efficiently.Letâs\r\nsee what happens when we add a new point or remove an existing point.\r\nFor all points to the left of it with distance no more than , the value\r\nof increases or decreases by . So, we need some sort of data structure\r\nthat allows adding/subtracting on segment and maintains the sum of .\r\nThis looks like a lazy segment tree, but updating the sum of can be\r\ntricky.One way to do this is to notice that . So maybe we can maintain\r\nthe sum of and the sum of on the segment? It turns out we can. The model\r\nsolution does this as follows: the leaf of the segment tree\r\ncorresponding to the position stores a vector with three values: . The\r\ninner nodes store the sums of these vectors in the subtree. We can find\r\na matrix which, when multiplied by , gets the vector , and the inverse\r\nmatrix to it. Then adding to on segment means multiplying all vectors on\r\nsegment by that matrix, and subtracting means multiplying by the inverse\r\nmatrix; and since matrix multiplication is both associative and\r\ndistributive, the segment tree can handle these queries..Okay, thereâs\r\nonly one small issue left: right now our structure can store the sum of\r\nand over all possible points (we build it on segment , for example), but\r\nwe only need the sum over points. One way to handle it is to use a flag\r\nfor each leaf of the segment tree, and pull the value up from the leaf\r\nonly if this flag is true. We will need a function that changes the\r\nvalue of this flag for a single leaf, but itâs not very different from a\r\nfunction that changes one value in a lazy segment tree.Time complexity\r\nof the solution is , where is the maximum coordinate of the point,\r\nalthough the constant factor of the described approach is fairly large\r\nsince it involves matrix multiplications. You can improve the constant\r\nfactor by getting rid of the matrices, as mentioned earlier.\r\n",
    "hint": []
}