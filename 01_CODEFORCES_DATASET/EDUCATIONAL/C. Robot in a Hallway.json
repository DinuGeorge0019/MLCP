{
    "link": "https://codeforces.com//contest/1716/problem/C",
    "problemId": "1494202",
    "problem_idx": "C",
    "shortId": "1716C",
    "contest_number": "1716",
    "problem_submissions": {
        "F": [
            166973182,
            166969763,
            166955726,
            166980503,
            166971153,
            166982692,
            166980605,
            166983476,
            166980127,
            166991091,
            166984328,
            174506735,
            166989832,
            166994539,
            166994104,
            167001346,
            166987296,
            166992176,
            167001598,
            166984678,
            166980048,
            166989609,
            166991438
        ],
        "E": [
            166965293,
            166978547,
            166976884,
            166972995,
            166981522,
            166965872,
            166976854,
            166973781,
            166987347,
            166978953,
            166992476,
            174506754,
            166979608,
            166979158,
            166999544,
            166982891,
            166981173,
            166992198,
            166994171,
            166998037,
            166985315
        ],
        "D": [
            166956573,
            166961021,
            166948324,
            166940829,
            166964589,
            166961790,
            166945640,
            166966226,
            166990484,
            166958577,
            166963786,
            166970823,
            166970282,
            166968378,
            166964318,
            166974075,
            166965600,
            166970563,
            166970355,
            166971544,
            166978778
        ],
        "C": [
            166949159,
            166950864,
            166972142,
            166963779,
            166956508,
            166957181,
            166966957,
            166958122,
            166972096,
            166974861,
            166961876,
            166963035,
            166961356,
            166959918,
            166967210,
            166954669,
            166964729,
            166960756,
            166967143,
            166974763
        ],
        "B": [
            166933142,
            166932739,
            166939087,
            166932145,
            166933138,
            166932019,
            166931348,
            166934835,
            166932251,
            166931312,
            166937500,
            166936523,
            166932821,
            166932877,
            166940841,
            166932031,
            166935420,
            166935573,
            166933744,
            166937079
        ],
        "A": [
            166930228,
            166930333,
            166931520,
            166930280,
            166930300,
            166930222,
            166930190,
            166930301,
            166930500,
            166930207,
            166932038,
            166930537,
            166930220,
            166930271,
            166933329,
            166930353,
            166930639,
            166930376,
            166930158,
            166931421
        ]
    },
    "name": "C. Robot in a Hallway",
    "statement": "There is a grid, consisting of 2 rows and m columns. The rows are\r\nnumbered from 1 to 2 from top to bottom. The columns are numbered from 1\r\nto m from left to right.The robot starts in a cell (1, 1). In one\r\nsecond, it can perform either of two actions: move into a cell adjacent\r\nby a side: up, right, down or left; remain in the same cell. The robot\r\nis not allowed to move outside the grid.Initially, all cells, except for\r\nthe cell (1, 1), are locked. Each cell (i, j) contains a value a_{i,j}\r\nthe moment that this cell gets unlocked. The robot can only move into a\r\ncell (i, j) if at least a_{i,j} seconds have passed before the move.The\r\nrobot should visit all cells (cell (1, 1) is considered entered at the\r\nstart). It can finish in any cell.What is the fastest the robot can\r\nachieve that?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[2][N];\nint b[2][N];\nint c[2][N];\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < 2; i++)\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\tif (i + j > 0) a[i][j]++;\n\t\t}\n\tb[0][n] = b[1][n] = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tfor (int k = 0; k < 2; k++) {\n\t\t\tb[k][i] = max(max(a[k ^ 1][i], a[k][i] + 2 * (n - i) - 1), b[k][i + 1] + 1);\n\t\t}\n\t}\n\tint ans = (int)1e9 + (int)1e8;\n\tint cur = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint k = i & 1;\n\t\tans = min(ans, max(cur, b[k][i]));\n\t\tcur = max(cur, a[k][i] + 2 * (n - i) - 1);\n\t\tcur = max(cur, a[k ^ 1][i] + 2 * (n - i) - 2);\n\t}\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "implementation",
        "ternary search"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Robot in a Hallway.json",
    "editorial_link": "https://codeforces.com//blog/entry/105653",
    "editorial": "Let\u00e2\u0080\u0099s first consider the possible paths across the grid that visit all\r\ncells. You can immediately think of two of them. The first one is: go\r\nright to the wall, turn into the other row and return. Let\u00e2\u0080\u0099s call it a\r\nhook. The second one is: go down, go right, go up, go right and so on.\r\nLet\u00e2\u0080\u0099s call it a snake.Turns out, these two are basically the two\r\nextremes of all paths. You can start with a snake and turn into a hook\r\nwhen you wish. You can see that once you move right twice in a row, you\r\ncan only continue with a hook. And as long as you didn\u00e2\u0080\u0099t move right\r\ntwice, you are just doing a snake.Let\u00e2\u0080\u0099s fix some path across the grid.\r\nWhat will its minimum time be? Calculate it iteratively. If you want to\r\nenter the next cell, and it\u00e2\u0080\u0099s still locked, wait until it isn\u00e2\u0080\u0099t. So\r\nthere are some seconds of waiting (possibly, zero) before each\r\ncell.However, why not instead do the following. Let\u00e2\u0080\u0099s calculate the sum\r\nof waiting time required and wait for that amount of seconds before\r\nstarting to move. All cells will be visited at the same time as before\r\nor even later. Thus, they will surely be unlocked if they were in the\r\noriginal plan.So the goal is to calculate the minimum amount of time\r\nrequired to wait in the start, then add the movement time to it.Once\r\nagain, the path is fixed. Let the -th cell of the path be . If you start\r\nafter waiting for seconds, then you reach the -th cell at time ( is\r\n-indexed). Thus, the -th cell should have . If all cells satisfy this\r\ncondition, then the path can be done after waiting for seconds at the\r\nstart.Let\u00e2\u0080\u0099s rewrite it into . So, the condition tells us that should be\r\ngreater or equal than this value for all cells. In other words, should\r\nbe greater or equal than the maximum of the values over all cells.Study\r\nthe formula. Imagine we have some path with a known length and want to\r\nappend a cell to it. That\u00e2\u0080\u0099s pretty simple. Just update the maximum with\r\nthe value with the corresponding cell and increase the length.What if we\r\nwanted to prepend a cell to it? Turns out, it\u00e2\u0080\u0099s not that hard as well.\r\nEvery cell in the path gets its value increased by . From the formula,\r\nyou can see that this actually decreases the value of each cell by . So\r\nthe maximum decreases by as well. The only thing left is to update the\r\nmaximum with the value of the new first cell. Well, and increase the\r\nlength again.Finally, let\u00e2\u0080\u0099s learn how to choose the best path. We can\r\niterate over the length of the snake part. The hook part is determined\r\nuniquely.It\u00e2\u0080\u0099s easy to maintain the maximum on the snake. Just append the\r\nnew cell to the path.How to glue up the hook part to that?Well,\r\nactually, realize that the formula allows us to glue up two paths into\r\none. Let path have length and maximum and path have length and maximum .\r\nTo make path start after path , we just decrease its maximum by . The\r\nresulting path has length and maximum .Let\u00e2\u0080\u0099s look closer into what the\r\nhooks look like. They start in some column , traverse all the way right,\r\nthen left up to the same column . If the snake part took both cells in\r\nits last column, then that\u00e2\u0080\u0099s it. Otherwise, the hook has to take the\r\nfinal cell in the last column column .If we manage to precalculate\r\nsomething for hooks that start in some column and end in column , then\r\nwe will be able to use that. Appending the final cell is not a hard\r\ntask, since we know its index in the path ().Let be the waiting time\r\nrequired for a hook that starts in cell and ends in a cell as if the\r\npath started with the hook (cell is the first one). can be calculated\r\nfrom . Prepend it with a cell and append it with a cell .The only thing\r\nleft is to find the best answer. I found the most convenient to start\r\nwith a snake of length (only cell ) and progress it two steps at the\r\ntime: update the answer; progress the snake to the other cell of the\r\ncurrent column; update the answer; progress the snake into the next\r\ncolumn. Overall complexity: per testcase.\r\n"
}