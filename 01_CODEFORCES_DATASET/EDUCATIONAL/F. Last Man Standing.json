{
    "link": "https://codeforces.com//contest/1879/problem/F",
    "problemId": "2226290",
    "problem_idx": "F",
    "shortId": "1879F",
    "contest_number": "1879",
    "problem_submissions": {
        "F": [
            224937536,
            224935202,
            224950610,
            224926179,
            224962842,
            224969051,
            224930929,
            224967422,
            224963265,
            224966461,
            224940572,
            224966841,
            224954569,
            225047271,
            224982141,
            224973229,
            225020484,
            225376642,
            224974176,
            225441069
        ],
        "E": [
            224915766,
            224914283,
            224947954,
            224935300,
            224927963,
            224966463,
            224932997,
            224929889,
            224950618,
            224966233,
            224954318,
            224969484,
            224930880,
            224920140,
            224922897,
            224920584,
            224928749,
            224925724,
            224924188,
            224933925
        ],
        "D": [
            224888044,
            224890483,
            224896670,
            224904072,
            224896642,
            224898559,
            224895640,
            224898718,
            224909765,
            224890763,
            224903520,
            224917804,
            224935485,
            224900120,
            224899388,
            224897270,
            224896991,
            224895504,
            224897180,
            224904052
        ],
        "C": [
            224883111,
            224886635,
            224905698,
            224893770,
            224888377,
            224894906,
            224886723,
            224893779,
            224902835,
            224885562,
            224895691,
            224922809,
            224940882,
            224893191,
            224888785,
            224888462,
            224890469,
            224889684,
            224903420,
            224892974
        ],
        "B": [
            224880512,
            224883808,
            224889537,
            224888023,
            224883379,
            224885924,
            224899117,
            224885706,
            224885740,
            224883031,
            224886861,
            224914364,
            224945905,
            224884557,
            224881988,
            224884765,
            224884529,
            224883777,
            224884553,
            224888797
        ],
        "A": [
            224880000,
            224880258,
            224880343,
            224880667,
            224881398,
            224880389,
            224901703,
            224881377,
            224880233,
            224880172,
            224880548,
            224906481,
            224947822,
            224880196,
            224880217,
            225049284,
            224880515,
            224880208,
            224880388,
            224880513,
            224881480
        ]
    },
    "name": "F. Last Man Standing",
    "statement": "There are n heroes in a videogame. Each hero has some health value h and\r\ninitial armor value a. Let the current value of armor be a_{\r\nmathit{cur}}, initially equal to a.When x points of damage are inflicted\r\non a hero, the following happens: if x < a_{\r\nmathit{cur}}, then x gets subtracted from a_{\r\nmathit{cur}}; otherwise, 1 gets subtracted from h and a_{\r\nmathit{cur}} gets assigned back to a.In the start of the game, you\r\nchoose the value x (an integer strictly greater than 0, arbitrarily\r\nlarge). Then you keep attacking all heroes in rounds: in one round, you\r\ninflict x points of damage to all alive heroes. A hero dies when his\r\nhealth becomes 0. The game ends when all heroes are dead.The last hero\r\nto die earns the number of points, equal to the number of rounds he was\r\nthe only hero alive. The other heroes get 0 points. In particular, if\r\nthe last round ends with multiple heroes dying, then every hero gets 0\r\npoints.The game is played for every possible x (from 1 to infinity). The\r\npoints are reset between the games. What’s the maximum number of points\r\neach hero has had?\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 200011; \n\nvoid solve() {\n\n    ll H[MX][2], val[MX]; \n    int pos[MX];\n    F0R(i, MX) {\n        F0R(j, 2) {\n            H[i][j] = 0;\n        }\n        val[i] = 0; pos[i] = -1;\n    }\n    int N; cin >> N;\n    ll ans[N]; F0R(i, N) ans[i] = 0;\n    int inH[N], inA[N];\n    F0R(i, N) cin >> inH[i];\n    F0R(i, N) cin >> inA[i];\n    ll cb = 0, csb = 0;\n    int pb = 0;\n    F0R(i, N) {\n        if (inH[i] > H[inA[i]][0]) {\n            H[inA[i]][1] = H[inA[i]][0];\n            H[inA[i]][0] = inH[i];\n            pos[inA[i]] = i;\n            val[inA[i]] = inH[i];\n        } else if (inH[i] > H[inA[i]][1]) {\n            H[inA[i]][1] = inH[i];\n        }\n        pb = inH[i];\n    }\n    FOR(i, 1, MX) {\n        if (val[i] > cb) {\n            csb = cb;\n            cb = val[i];\n            pb = i;\n        } else if (val[i] > csb) {\n            csb = val[i];\n        }\n    }\n    ckmax(ans[pos[pb]], cb - max(csb, H[pb][1]));\n    FORd(i, 1, MX) {\n        int lo = 1;\n        for (int j = 0; j * i < MX; j++) {\n            for (int k = max(j * i + 1, lo); k <= j * (i+1) && k < MX; k++) {\n                ckmax(lo, k);\n                val[k] = ((k + i - 1) / i) * H[k][0];\n                if (val[k] > cb) {\n                    if (pb != k) csb = cb;\n                    cb = val[k];\n                    pb = k;\n                } else if (val[k] > csb && pb != k) {\n                    csb = val[k];\n                }\n            }\n        }\n        ckmax(ans[pos[pb]], cb - max(csb, ((pb + i - 1) / i) * H[pb][1]));\n            //dbg(i, pb, pos[pb], val[pb], cb, csb);\n        \n    }\n\n    F0R(i, N) {\n        cout << ans[i] << \" \";\n    }\n    cout << nl;\n\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "number theory"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Last Man Standing.json",
    "editorial_link": "https://codeforces.com//blog/entry/120773",
    "editorial": "For each , we can easily tell how many rounds each hero will last. That\r\nis equal to . The last hero to die is the one with the maximum of this\r\nvalue. And the number of rounds he will be the only hero alive is\r\ndetermined by the second maximum.Also notice that all that are greater\r\nor equal to the maximum of behave the same. In one round, all heroes\r\njust lose one point of health. Thus, it only makes sense to calculate\r\nthe answer for all from to .The problem currently is the following: for\r\neach from to , find the index and the value of the maximum and the value\r\nof the second maximum of .Letâs group all heroes by the value of . The\r\nvalues of for the heroes in the group form a segment from to . From each\r\ngroup, we only care about the maximum and the second maximum over .\r\nThus, if we can extract the maximum and the second maximum in , the\r\nsolution will be because of the harmonic series (iterating over , then\r\nover ).First, for each , find the maximum and the second maximum of . To\r\nquery the maximum on a segment, we can use a sparse table. Apparently,\r\nwe can modify it to query the second maximum as well.Store a tuple of\r\n(value of maximum, index of maximum, value of the second maximum). To\r\nmerge two segments, we compare if the indices of the maximums are the\r\nsame. They can possibly be the same because we often query intersecting\r\nsegments in the sparse table. If they are, the second maximum is the\r\nlargest of the respective second maximums. If they arenât, let the first\r\nnode has a large or equal value of maximum. Then the second maximum is\r\nthe larger of the second maximum of the first node and the maximum of\r\nthe second node.Overall complexity: time and memory per testcase.\r\n",
    "hint": []
}