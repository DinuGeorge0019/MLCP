{
    "link": "https://codeforces.com//contest/884/problem/C",
    "problemId": "130889",
    "problem_idx": "C",
    "shortId": "884C",
    "contest_number": "884",
    "problem_submissions": {
        "F": [
            31808128,
            31809259,
            31810428,
            31811126,
            31807028,
            31810125,
            31808407,
            31808014,
            31873745,
            31808068,
            31810481,
            70767801,
            36469296,
            36469289,
            31909919,
            31809387,
            31822510,
            31808175,
            31811034
        ],
        "E": [
            31805401,
            31807388,
            31807565,
            31808478,
            31804019,
            31805975,
            31805687,
            31805755,
            31841462,
            31810079,
            31810699,
            31810217,
            31811063,
            31809732,
            31810149
        ],
        "D": [
            31802703,
            31804699,
            31804124,
            31804641,
            31808138,
            31803343,
            31802113,
            31801774,
            31802510,
            31803536,
            31804976,
            31801949,
            31805944,
            31805607,
            31803821,
            31809103,
            31803969,
            31818412,
            31806095
        ],
        "C": [
            31800883,
            31800607,
            31802838,
            31802069,
            31799616,
            31802362,
            31800429,
            31800236,
            31800839,
            31801291,
            31801670,
            31800496,
            31801796,
            31802338,
            31801055,
            31801861,
            31801455,
            31800685,
            31802138
        ],
        "B": [
            31799211,
            31799036,
            31801939,
            31801321,
            31801497,
            31798756,
            31799168,
            31799265,
            31799895,
            31799341,
            31799382,
            31800133,
            31800205,
            31799009,
            31800238,
            31799378,
            31799257,
            31800274
        ],
        "A": [
            31798352,
            31798382,
            31801358,
            31800677,
            31801116,
            31798306,
            31798460,
            31798672,
            31798979,
            31798397,
            31798744,
            31798807,
            31798611,
            31798307,
            31798790,
            31798478,
            31798275,
            31799367
        ]
    },
    "name": "C. Bertown Subway",
    "statement": "The construction of subway in Bertown is almost finished! The President\r\nof Berland will visit this city soon to look at the new subway\r\nhimself.There are stations in the subway. It was built according to the\r\n: For each station there exists exactly one train that goes from this\r\nstation. Its destination station is , possibly ; For each station there\r\nexists exactly one station such that . The President will consider the\r\nof subway after visiting it. The is the number of ordered pairs such\r\nthat person can start at station and, after taking some subway trains\r\n(possibly zero), arrive at station ().The mayor of Bertown thinks that\r\nif the subway is not enough, then the President might consider\r\ninstalling a new mayor (and, of course, the current mayor doesn\u2019t want\r\nit to happen). Before President visits the city mayor has enough time to\r\nrebuild some paths of subway, thus changing the values of for . Of\r\ncourse, breaking the is really bad, so the subway must be built\r\naccording to the even after changes.The mayor wants to do these changes\r\nin such a way that the of the subway is maximized. Help him to calculate\r\nthe maximum possible he can get!\r\n",
    "solutions": [
        "#include <array>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <cstdio>\n#include <vector>\n#include <map>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\n\n//alias\n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int SIZE = 100009;\nint P[SIZE];\n\nint main()\n{\n    int N;\n    RD(N);\n    RDV(P + 1, P + N + 1);\n\n    vector<ll> cad;\n    for(int i: RG(1, N + 1))\n        if(P[i])\n        {\n            int alc = 0;\n            for(int j = i; P[j]; )\n            {\n                int k = P[j];\n                P[j] = 0;\n                j = k;\n                alc++;\n            }\n\n            cad.push_back(alc);\n        }\n\n    sort(cad.begin(), cad.end());\n    if(cad.size() == 1)\n        WTL(cad[0] * cad[0]);\n    else\n    {\n        ll ans = cad.back() + cad.end()[-2];\n        cad.pop_back();\n        cad.pop_back();\n        ans *= ans;\n        for(ll v: cad)\n            ans += v * v;\n        WTL(ans);\n\n\n    }\n\n\n\n}\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "greedy",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Bertown Subway.json",
    "editorial_link": "https://codeforces.com//blog/entry/55470",
    "editorial": "Let\u00e2\u0080\u0099s notice that one swap can affect at most two cycles of this\r\npermutation. Moreover you can join two cycles into one with the length\r\nequal to the sums of lengths of initial ones. The function we are going\r\nto maximize is , where and are the lengths of the cycles we are joining\r\ntogether. . Now its easily seen that the maximum is achived when joining\r\ntwo cycles with the greatest product of lengths. Finally they are the\r\ntwo longest cycles in permutation.Overall complexity: .\r\n"
}