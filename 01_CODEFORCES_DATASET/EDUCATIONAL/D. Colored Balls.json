{
    "link": "https://codeforces.com//contest/1954/problem/D",
    "problemId": "2586694",
    "problem_idx": "D",
    "shortId": "1954D",
    "contest_number": "1954",
    "problem_submissions": {
        "F": [
            256316895,
            256329295,
            256334035,
            256332306,
            256344392,
            256332853,
            256328005,
            256347592,
            256335011,
            256352109,
            256350995,
            258635003,
            256340118,
            256372395,
            256325447,
            256325322,
            256346283,
            256316023,
            256323588,
            256320924
        ],
        "E": [
            256282413,
            256358889,
            256358516,
            256282751,
            256340120,
            256301294,
            256294589,
            256283411,
            256294052,
            256306491,
            256303451,
            256299550,
            256302258,
            256354417,
            256293685,
            256303935,
            256308643,
            256372754,
            256335764,
            256333289,
            256297901,
            256327707,
            256340547,
            256345064,
            256288665
        ],
        "D": [
            256268895,
            256269992,
            256269812,
            256286958,
            256273436,
            256278229,
            256282928,
            256272144,
            256284841,
            256280990,
            256279861,
            256284063,
            256273990,
            256301346,
            256280827,
            256332605,
            256335916,
            256339422,
            256279104
        ],
        "C": [
            256263031,
            256263009,
            256264769,
            256265286,
            256267161,
            256271687,
            256272827,
            256264797,
            256276178,
            256267220,
            256271392,
            256275794,
            256262221,
            256288253,
            256273238,
            256334487,
            256333463,
            256330248,
            256269277
        ],
        "B": [
            256260210,
            256260093,
            256260556,
            256262624,
            256263445,
            256260047,
            256260173,
            256261053,
            256267415,
            256261634,
            256268733,
            256270204,
            256275934,
            256283332,
            256344932,
            256336999,
            256331860,
            256328039,
            256266244
        ],
        "A": [
            256256940,
            256256909,
            256256942,
            256256970,
            256256990,
            256256907,
            256256875,
            256257032,
            256259999,
            256257112,
            256257788,
            256257203,
            256259580,
            256256932,
            256338388,
            256326736,
            256328175,
            256257406
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128421",
    "editorial": "For a fixed set of colors, this is a standard problem with the following\r\nsolution: let\u00e2\u0080\u0099s denote the total number of balls as , then the value of\r\nthe set is ; but there is an exception in the case when there is a color\r\nwith more than balls, then the value is the number of balls of this\r\ncolor.So the answer depends only on whether there is a color that has\r\nmore balls than all the others combined.Using the aforementioned fact,\r\nwe can come up with the following solution: let\u00e2\u0080\u0099s iterate over the total\r\nnumber of balls in the set (denote it as ) and increase the answer by\r\nfor each subset of colors with exactly balls in it. The number of\r\nsubsets with the fixed number of balls can be calculated using simple\r\nknapsack dynamic programming.It remains to consider the subsets of\r\ncolors with a \"dominant\" color, because we added the wrong value to the\r\nanswer for them. Let the \"dominant\" color be and the total number of\r\nballs in all other colors be (). The answer should be increased by (the\r\ncorrect value of this set is , but we have already added the wrong value\r\nin the answer , so we should compensate it) for each subset of colors\r\nwith exactly balls in it (we can use the same dp as in previous case).\r\nNote that if you consider only , you don\u00e2\u0080\u0099t have to deal with the\r\npossibility that the \"dominant\" color could already be included in the\r\nsubset.This solution works in time, where is the total number of balls.\r\n",
    "name": "D. Colored Balls",
    "statement": "There are balls of n different colors; the number of balls of the i-th\r\ncolor is a_i.The balls can be combined into groups. Each group should\r\ncontain at most 2 balls, and no more than 1 ball of each color.Consider\r\nall 2^n sets of colors. For a set of colors, let\u2019s denote its as the\r\nminimum number of groups the balls of those colors can be distributed\r\ninto. For example, if there are three colors with 3, 1 and 7 balls\r\nrespectively, they can be combined into 7 groups (and not less than 7),\r\nso the value of that set of colors is 7.Your task is to calculate the\r\nsum of over all 2^n possible sets of colors. Since the answer may be too\r\nlarge, print it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std;\u00a0#define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size())\u00a0using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128;\u00a0using pii=pair<int,int>;using pll=pair<ll,ll>;\u00a0template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>;\u00a0using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>;\u00a0#define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__)))\u00a0template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>;\u00a0// https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s)))\u00a0template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);}\u00a0template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());}\u00a0template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;}\u00a0template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << ' ' << p.second;}\u00a0#ifdef i_am_noob#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}#else#define bug(...) 777771449#endif\u00a0template<typename T> void print(vector<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(T && x) {cout << x << \"\\n\";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);}\u00a0template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;}\u00a0vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;}\u00a0vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);}\u00a0template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};}\u00a0template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f;\u00a0template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;}\u00a0template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;}\u00a0#define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count())\u00a0\u00a0\u00a0#include <utility>\u00a0namespace atcoder {\u00a0namespace internal {\u00a0// @param m `1 <= m`// @return x mod mconstexpr long long safe_mod(long long x, long long m) {    x %= m;    if (x < 0) x += m;    return x;}\u00a0// Fast modular multiplication by barrett reduction// Reference: https://en.wikipedia.org/wiki/Barrett_reduction// NOTE: reconsider after Ice Lakestruct barrett {    unsigned int _m;    unsigned long long im;\u00a0    // @param m `1 <= m < 2^31`    barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}\u00a0    // @return m    unsigned int umod() const { return _m; }\u00a0    // @param a `0 <= a < m`    // @param b `0 <= b < m`    // @return `a * b % m`    unsigned int mul(unsigned int a, unsigned int b) const {        // [1] m = 1        // a = b = im = 0, so okay\u00a0        // [2] m >= 2        // im = ceil(2^64 / m)        // -> im * m = 2^64 + r (0 <= r < m)        // let z = a*b = c*m + d (0 <= c, d < m)        // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im        // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2        // ((ab * im) >> 64) == c or c + 1        unsigned long long z = a;        z *= b;#ifdef _MSC_VER        unsigned long long x;        _umul128(z, im, &x);#else        unsigned long long x =            (unsigned long long)(((unsigned __int128)(z)*im) >> 64);#endif        unsigned int v = (unsigned int)(z - x * _m);        if (_m <= v) v += _m;        return v;    }};\u00a0// @param n `0 <= n`// @param m `1 <= m`// @return `(x ** n) % m`constexpr long long pow_mod_constexpr(long long x, long long n, int m) {    if (m == 1) return 0;    unsigned int _m = (unsigned int)(m);    unsigned long long r = 1;    unsigned long long y = safe_mod(x, m);    while (n) {        if (n & 1) r = (r * y) % _m;        y = (y * y) % _m;        n >>= 1;    }    return r;}\u00a0// Reference:// M. Forisek and J. Jancina,// Fast Primality Testing for Integers That Fit into a Machine Word// @param n `0 <= n`constexpr bool is_prime_constexpr(int n) {    if (n <= 1) return false;    if (n == 2 || n == 7 || n == 61) return true;    if (n % 2 == 0) return false;    long long d = n - 1;    while (d % 2 == 0) d /= 2;    constexpr long long bases[3] = {2, 7, 61};    for (long long a : bases) {        long long t = d;        long long y = pow_mod_constexpr(a, t, n);        while (t != n - 1 && y != 1 && y != n - 1) {            y = y * y % n;            t <<= 1;        }        if (y != n - 1 && t % 2 == 0) {            return false;        }    }    return true;}template <int n> constexpr bool is_prime = is_prime_constexpr(n);\u00a0// @param b `1 <= b`// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/gconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {    a = safe_mod(a, b);    if (a == 0) return {b, 0};\u00a0    // Contracts:    // [1] s - m0 * a = 0 (mod b)    // [2] t - m1 * a = 0 (mod b)    // [3] s * |m1| + t * |m0| <= b    long long s = b, t = a;    long long m0 = 0, m1 = 1;\u00a0    while (t) {        long long u = s / t;        s -= t * u;        m0 -= m1 * u;  // |m1 * u| <= |m1| * s <= b\u00a0        // [3]:        // (s - t * u) * |m1| + t * |m0 - m1 * u|        // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)        // = s * |m1| + t * |m0| <= b\u00a0        auto tmp = s;        s = t;        t = tmp;        tmp = m0;        m0 = m1;        m1 = tmp;    }    // by [3]: |m0| <= b/g    // by g != b: |m0| < b/g    if (m0 < 0) m0 += b / s;    return {s, m0};}\u00a0// Compile time primitive root// @param m must be prime// @return primitive root (and minimum in now)constexpr int primitive_root_constexpr(int m) {    if (m == 2) return 1;    if (m == 167772161) return 3;    if (m == 469762049) return 3;    if (m == 754974721) return 11;    if (m == 998244353) return 3;    int divs[20] = {};    divs[0] = 2;    int cnt = 1;    int x = (m - 1) / 2;    while (x % 2 == 0) x /= 2;    for (int i = 3; (long long)(i)*i <= x; i += 2) {        if (x % i == 0) {            divs[cnt++] = i;            while (x % i == 0) {                x /= i;            }        }    }    if (x > 1) {        divs[cnt++] = x;    }    for (int g = 2;; g++) {        bool ok = true;        for (int i = 0; i < cnt; i++) {            if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1) {                ok = false;                break;            }        }        if (ok) return g;    }}template <int m> constexpr int primitive_root = primitive_root_constexpr(m);\u00a0}  // namespace internal\u00a0}  // namespace atcoder\u00a0\u00a0#include <cassert>#include <numeric>#include <type_traits>\u00a0namespace atcoder {\u00a0namespace internal {\u00a0#ifndef _MSC_VERtemplate <class T>using is_signed_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value ||                                  std::is_same<T, __int128>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using is_unsigned_int128 =    typename std::conditional<std::is_same<T, __uint128_t>::value ||                                  std::is_same<T, unsigned __int128>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using make_unsigned_int128 =    typename std::conditional<std::is_same<T, __int128_t>::value,                              __uint128_t,                              unsigned __int128>;\u00a0template <class T>using is_integral = typename std::conditional<std::is_integral<T>::value ||                                                  is_signed_int128<T>::value ||                                                  is_unsigned_int128<T>::value,                                              std::true_type,                                              std::false_type>::type;\u00a0template <class T>using is_signed_int = typename std::conditional<(is_integral<T>::value &&                                                 std::is_signed<T>::value) ||                                                    is_signed_int128<T>::value,                                                std::true_type,                                                std::false_type>::type;\u00a0template <class T>using is_unsigned_int =    typename std::conditional<(is_integral<T>::value &&                               std::is_unsigned<T>::value) ||                                  is_unsigned_int128<T>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using to_unsigned = typename std::conditional<    is_signed_int128<T>::value,    make_unsigned_int128<T>,    typename std::conditional<std::is_signed<T>::value,                              std::make_unsigned<T>,                              std::common_type<T>>::type>::type;\u00a0#else\u00a0template <class T> using is_integral = typename std::is_integral<T>;\u00a0template <class T>using is_signed_int =    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using is_unsigned_int =    typename std::conditional<is_integral<T>::value &&                                  std::is_unsigned<T>::value,                              std::true_type,                              std::false_type>::type;\u00a0template <class T>using to_unsigned = typename std::conditional<is_signed_int<T>::value,                                              std::make_unsigned<T>,                                              std::common_type<T>>::type;\u00a0#endif\u00a0template <class T>using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\u00a0template <class T>using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\u00a0template <class T> using to_unsigned_t = typename to_unsigned<T>::type;\u00a0}  // namespace internal\u00a0}  // namespace atcoder\u00a0#include <cassert>#include <numeric>#include <type_traits>\u00a0#ifdef _MSC_VER#include <intrin.h>#endif\u00a0namespace atcoder {\u00a0namespace internal {\u00a0struct modint_base {};struct static_modint_base : modint_base {};\u00a0template <class T> using is_modint = std::is_base_of<modint_base, T>;template <class T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\u00a0}  // namespace internal\u00a0template <int m, std::enable_if_t<(1 <= m)>* = nullptr>struct static_modint : internal::static_modint_base {    using mint = static_modint;\u00a0  public:    static constexpr int mod() { return m; }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\u00a0    static_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    static_modint(T v) {        long long x = (long long)(v % (long long)(umod()));        if (x < 0) x += umod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    static_modint(T v) {        _v = (unsigned int)(v % umod());    }    static_modint(bool v) { _v = ((unsigned int)(v) % umod()); }\u00a0    unsigned int val() const { return _v; }\u00a0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\u00a0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v -= rhs._v;        if (_v >= umod()) _v += umod();        return *this;    }    mint& operator*=(const mint& rhs) {        unsigned long long z = _v;        z *= rhs._v;        _v = (unsigned int)(z % umod());        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\u00a0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\u00a0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        if (prime) {            assert(_v);            return pow(umod() - 2);        } else {            auto eg = internal::inv_gcd(_v, m);            assert(eg.first == 1);            return eg.second;        }    }\u00a0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\u00a0  private:    unsigned int _v;    static constexpr unsigned int umod() { return m; }    static constexpr bool prime = internal::is_prime<m>;};\u00a0template <int id> struct dynamic_modint : internal::modint_base {    using mint = dynamic_modint;\u00a0  public:    static int mod() { return (int)(bt.umod()); }    static void set_mod(int m) {        assert(1 <= m);        bt = internal::barrett(m);    }    static mint raw(int v) {        mint x;        x._v = v;        return x;    }\u00a0    dynamic_modint() : _v(0) {}    template <class T, internal::is_signed_int_t<T>* = nullptr>    dynamic_modint(T v) {        long long x = (long long)(v % (long long)(mod()));        if (x < 0) x += mod();        _v = (unsigned int)(x);    }    template <class T, internal::is_unsigned_int_t<T>* = nullptr>    dynamic_modint(T v) {        _v = (unsigned int)(v % mod());    }    dynamic_modint(bool v) { _v = ((unsigned int)(v) % mod()); }\u00a0    unsigned int val() const { return _v; }\u00a0    mint& operator++() {        _v++;        if (_v == umod()) _v = 0;        return *this;    }    mint& operator--() {        if (_v == 0) _v = umod();        _v--;        return *this;    }    mint operator++(int) {        mint result = *this;        ++*this;        return result;    }    mint operator--(int) {        mint result = *this;        --*this;        return result;    }\u00a0    mint& operator+=(const mint& rhs) {        _v += rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator-=(const mint& rhs) {        _v += mod() - rhs._v;        if (_v >= umod()) _v -= umod();        return *this;    }    mint& operator*=(const mint& rhs) {        _v = bt.mul(_v, rhs._v);        return *this;    }    mint& operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\u00a0    mint operator+() const { return *this; }    mint operator-() const { return mint() - *this; }\u00a0    mint pow(long long n) const {        assert(0 <= n);        mint x = *this, r = 1;        while (n) {            if (n & 1) r *= x;            x *= x;            n >>= 1;        }        return r;    }    mint inv() const {        auto eg = internal::inv_gcd(_v, mod());        assert(eg.first == 1);        return eg.second;    }\u00a0    friend mint operator+(const mint& lhs, const mint& rhs) {        return mint(lhs) += rhs;    }    friend mint operator-(const mint& lhs, const mint& rhs) {        return mint(lhs) -= rhs;    }    friend mint operator*(const mint& lhs, const mint& rhs) {        return mint(lhs) *= rhs;    }    friend mint operator/(const mint& lhs, const mint& rhs) {        return mint(lhs) /= rhs;    }    friend bool operator==(const mint& lhs, const mint& rhs) {        return lhs._v == rhs._v;    }    friend bool operator!=(const mint& lhs, const mint& rhs) {        return lhs._v != rhs._v;    }\u00a0  private:    unsigned int _v;    static internal::barrett bt;    static unsigned int umod() { return bt.umod(); }};template <int id> internal::barrett dynamic_modint<id>::bt = 998244353;\u00a0using modint998244353 = static_modint<998244353>;using modint1000000007 = static_modint<1000000007>;using modint = dynamic_modint<-1>;\u00a0namespace internal {\u00a0template <class T>using is_static_modint = std::is_base_of<internal::static_modint_base, T>;\u00a0template <class T>using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\u00a0template <class> struct is_dynamic_modint : public std::false_type {};template <int id>struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type {};\u00a0template <class T>using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\u00a0}  // namespace internal\u00a0}  // namespace atcoder\u00a0using namespace atcoder;\u00a0using mint=modint998244353;//using mint=modint1000000007;\u00a0void ahcorz(){    int n; cin >> n;    vi a(n); cin >> a;    sort(all(a));    int m=accumulate(all(a),0);    vc<mint> dp(m+1);    dp[0]=1;    mint res;    rep(n){        rep(j,m+1){            if(j<=a[i]) res+=a[i]*dp[j];            else res+=iceil(a[i]+j,2)*dp[j];        }        per(j,m+1,a[i]) dp[j]+=dp[j-a[i]];    }    print(res.val());}\u00a0signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    //cin >> t;    while(t--) ahcorz();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Colored Balls.json"
}