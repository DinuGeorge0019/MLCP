{"link": "https://codeforces.com//contest/1494/problem/A", "problemId": "913250", "problem_idx": "A", "shortId": "1494A", "contest_number": "1494", "problem_submissions": {"F": [108939157, 108939159, 108941615, 108940380, 108936690, 108949404, 108939049, 108976002, 109259098, 114355817, 114300723, 109105687, 108952860], "E": [108917863, 108917179, 108917875, 108920789, 108924713, 108911681, 108911479, 108897566, 108915498, 108912071, 108919266, 108916392, 108921553, 108913575, 108918608, 108932427, 108930755, 108916943], "D": [108912126, 108910016, 108906106, 108913150, 108917394, 108924483, 108905862, 108906091, 108907069, 108901150, 108912737, 108909289, 108909997, 108901829, 108912218, 108906405, 108912083], "C": [108899963, 108897106, 108898254, 108894965, 108905337, 108946028, 108904267, 108903529, 108894912, 108900440, 108893773, 108903235, 108896270, 108897186, 108897145, 108895547, 108897140, 108897478, 108896885], "B": [108887573, 108887648, 108887088, 108887791, 108891184, 108886492, 108887122, 108892723, 108887267, 108886341, 108887638, 108889178, 108889629, 108886479, 108887946, 108888463, 108886261], "A": [108886097, 108886134, 108886049, 108886041, 108887001, 108886021, 108886051, 108886176, 108886040, 108887099, 108886184, 108886195, 108886220, 108886015, 108886138, 108886325, 108885985]}, "name": "A. ABC String", "statement": "You are given a string a, consisting of n characters, n is even. For\r\neach i from 1 to n a_i is one of \u201d, \u201d or \u201d.A bracket sequence is a\r\nstring containing only characters \"\" and \"\". A regular bracket sequence\r\nis a bracket sequence that can be transformed into a correct arithmetic\r\nexpression by inserting characters \"\" and \"\" between the original\r\ncharacters of the sequence. For example, bracket sequences \"\" and \"\" are\r\nregular (the resulting expressions are: \"\" and \"\"), and \"\", \"\" and \"\"\r\nare not.You want to find a string b that consists of n characters such\r\nthat: b is a regular bracket sequence; if for some i and j (1\r\nle i, j\r\nle n) a_i=a_j, then b_i=b_j. In other words, you want to replace all\r\noccurrences of \u201d with the same type of bracket, then all occurrences of\r\n\u201d with the same type of bracket and all occurrences of \u201d with the same\r\ntype of bracket.Your task is to determine if such a string b exists.\r\n", "solutions": ["#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nbool check(string s)\n{\n    int n = s.size();\n    int balance = 0;\n    for (auto c: s)\n    {\n        if (c==')') balance--; else balance++;\n        if (balance<0) return false;\n    }\n    if (balance!=0) return false;\n    return true;\n}\n\nvoid solve()\n{\n    string s; cin>>s;\n    for (int mask = 0; mask<8; mask++)\n    {\n        string s1;\n        for (auto c: s)\n        {\n            if (mask&(1<<(c-'A'))) s1+='('; else s1+=')';\n        }\n        if (check(s1)) {cout<<\"YES\"<<endl; return;}\n    }\n    cout<<\"NO\"<<endl;\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int t; cin>>t; while (t--) solve();\n\n\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "implementation"], "dificulty": "900", "interactive": false}