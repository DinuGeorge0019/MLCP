{
    "link": "https://codeforces.com//contest/1473/problem/D",
    "problemId": "864972",
    "problem_idx": "D",
    "shortId": "1473D",
    "contest_number": "1473",
    "problem_submissions": {
        "G": [
            104324184,
            104387693,
            104338182,
            104349212,
            104348798,
            104346480,
            104390780,
            104390610,
            104390495,
            104389764,
            104383982,
            104383801,
            104346655,
            104341001,
            104315264,
            104352224,
            104352185,
            104375589,
            104397435,
            104397194,
            104376606,
            104352690,
            104352754,
            104352534,
            104398919,
            104398235,
            104330024
        ],
        "F": [
            104316672,
            104314197,
            104321921,
            104322437,
            104324528,
            104322986,
            104314395,
            104317108,
            104322022,
            104311306,
            136810058,
            104327481,
            104330457,
            104324027,
            104334280,
            104334405,
            104340043,
            104329360,
            104332558
        ],
        "E": [
            104307026,
            104303673,
            104306129,
            104311187,
            104320601,
            104327879,
            104304639,
            104302012,
            104310767,
            104318435,
            104314089,
            104313021,
            104316783,
            104313523,
            104318767,
            104312111,
            104314876,
            104327257,
            104303395
        ],
        "D": [
            104300616,
            104298125,
            104298419,
            104305187,
            104310558,
            104332950,
            104295784,
            104297395,
            104304904,
            104298645,
            104306694,
            104301645,
            104305953,
            104307851,
            104307522,
            104307146,
            104309694,
            104303434,
            104321617
        ],
        "C": [
            104297127,
            104291328,
            104310275,
            104297010,
            104300137,
            104335806,
            104289962,
            104291239,
            104299846,
            104320575,
            104299422,
            104297141,
            104307584,
            104296827,
            104299646,
            104301166,
            104302797,
            104297015,
            104316440
        ],
        "B": [
            104289189,
            104283439,
            104284166,
            104288050,
            104287625,
            104337404,
            104283726,
            104283807,
            104286751,
            104285766,
            104285844,
            104292438,
            104285398,
            104287974,
            104288404,
            104287047,
            104293072,
            104288614,
            104287425
        ],
        "A": [
            104282920,
            104280323,
            104280823,
            104280333,
            104281130,
            104338367,
            104280298,
            104280342,
            104281217,
            104281168,
            104280838,
            104286833,
            104280557,
            104280439,
            104281300,
            104280646,
            104289104,
            104281489,
            104280913
        ]
    },
    "name": "D. Program",
    "statement": "You are given a program that consists of n instructions. Initially a\r\nsingle variable x is assigned to 0. Afterwards, the instructions are of\r\ntwo types: increase x by 1; decrease x by 1. You are given m queries of\r\nthe following format: query l r how many distinct values is x assigned\r\nto if all the instructions between the l-th one and the r-th one\r\ninclusive are ignored and the rest are executed without changing the\r\norder?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nstruct Data {\n    int mx;\n    int mn;\n    int add;\n    Data(int mx = 0, int mn = 0, int add = 0) : mx(mx), mn(mn), add(add) {}\n};\nData operator+(const Data &a, const Data &b) {\n    return Data(std::max(a.mx, a.add + b.mx), std::min(a.mn, a.add + b.mn), a.add + b.add);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n, m;\n        std::cin >> n >> m;\n        std::string s;\n        std::cin >> s;\n        std::vector<Data> a(n);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '+') {\n                a[i] = Data(1, 0, 1);\n            } else {\n                a[i] = Data(0, -1, -1);\n            }\n        }\n        std::vector<Data> pre(n + 1), suf(n + 1);\n        for (int i = 0; i < n; i++) {\n            pre[i + 1] = pre[i] + a[i];\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            suf[i] = a[i] + suf[i + 1];\n        }\n        while (m--) {\n            int l, r;\n            std::cin >> l >> r;\n            l--;\n            auto v = pre[l] + suf[r];\n            std::cout << v.mx - v.mn + 1 << \"\\n\";\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "implementation",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Program.json",
    "editorial_link": "https://codeforces.com//blog/entry/86827",
    "editorial": "The value of always changes by , thus, the set of values of is always\r\nsome contiguous segment. The length of such segment can be determined by\r\njust its minimum and maximum values.So we have to solve two separate\r\ntasks for each query: find the minimum and the maximum value gets\r\nassigned to. Iâll describe only the minimum one.This task, however, can\r\nas well be split into two parts: minimum value on a prefix before and on\r\na suffix after . The prefix is easy it doesnât get changed by a query,\r\nso it can be precalculated beforehand. Minimum value on a prefix of\r\nlength is minimum of a minimum value on a prefix of length and the\r\ncurrent value.The suffix minimum is not that trivial. First, in order to\r\nprecalculate the minimum value on a suffix of length , we have to learn\r\nto prepend an instruction to the suffix of length . Consider the graph\r\nof values of over time. What happens to it if the initial value of is\r\nnot but , for example? It just gets shifted by upwards. That move is\r\nactually the same as prepending a â instruction. So the minimum value\r\nfor a suffix of length is a minimum of a minimum value for a suffix of\r\nlength , increased by the current instruction, and (the start of the\r\ngraph).So now we have a minimum value on a suffix after . However, it\r\ncanât be taken into the answer as it is, because it considers the graph\r\nfor the suffix to be starting from . And thatâs not the case. The graph\r\nfor the suffix starts from the value the prefix ends on. So we can shift\r\nthe answer for the suffix by the value of after the prefix. The overall\r\nminimum value is just the minimum on a prefix and on a suffix,\r\nthen.Overall complexity: per testcase.\r\n",
    "hint": []
}