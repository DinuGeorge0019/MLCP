{
    "link": "https://codeforces.com//contest/1511/problem/E",
    "problemId": "955216",
    "problem_idx": "E",
    "shortId": "1511E",
    "contest_number": "1511",
    "problem_submissions": {
        "F": [
            112840077,
            112828537,
            112827087,
            113002746,
            112851650,
            112835176,
            112837815,
            112833990,
            112833873,
            112824360,
            112844580,
            112864617,
            112862363,
            112847364,
            112866931,
            112854217,
            112847572,
            112854389,
            112862579,
            112845350
        ],
        "G": [
            112827572,
            112849564,
            114661033,
            114660887,
            114660767,
            114660706,
            114660307,
            114660076,
            114659999,
            114659915,
            112892560,
            112862384,
            112862341,
            112862288,
            112850067,
            112846404,
            112853880,
            112853846,
            112850825,
            112896875,
            112847874,
            113122868,
            112859368,
            112858002,
            112857690,
            112970481,
            112947065,
            112923272,
            112913505,
            113005183,
            112847551,
            112853638,
            112855715
        ],
        "E": [
            112819190,
            112811502,
            112809874,
            112818379,
            112809749,
            112819391,
            112816521,
            112812422,
            112824024,
            112811228,
            112816399,
            112821852,
            112825588,
            112822496,
            112814072,
            112820021,
            112829060,
            112824596
        ],
        "D": [
            112810190,
            112804690,
            112802519,
            112810990,
            112813483,
            112807233,
            112809814,
            112797395,
            112806426,
            112804268,
            112810141,
            112805389,
            112810319,
            112811043,
            112802328,
            112810501,
            112810922,
            112816639
        ],
        "C": [
            112798920,
            112798787,
            112796760,
            112804959,
            112800997,
            112799737,
            112805004,
            112792842,
            112799549,
            112797984,
            112795724,
            112796489,
            112801048,
            112802109,
            112797807,
            112801283,
            112801426,
            112804850
        ],
        "B": [
            112794609,
            112794368,
            112790815,
            112794707,
            112794954,
            112796065,
            112801022,
            112788437,
            112794356,
            112792946,
            112790545,
            112792316,
            112798211,
            112798547,
            112790397,
            112797545,
            112796307,
            112796695
        ],
        "A": [
            112787944,
            112786809,
            112787014,
            112786892,
            112787663,
            112788591,
            112791727,
            112786823,
            112788650,
            112788073,
            112786815,
            112787413,
            112786972,
            112791493,
            112787338,
            112792315,
            112786886,
            112787405
        ]
    },
    "name": "E. Colorings and Dominoes",
    "statement": "You have a large rectangular board which is divided into n\r\ntimes m cells (the board has n rows and m columns). Each cell is either\r\nwhite or black.You paint each white cell either red or blue. Obviously,\r\nthe number of different ways to paint them is 2^w, where w is the number\r\nof white cells.After painting the white cells of the board, you want to\r\nplace the maximum number of dominoes on it, according to the following\r\nrules: each domino covers two adjacent cells; each cell is covered by at\r\nmost one domino; if a domino is placed horizontally (it covers two\r\nadjacent cells in one of the rows), it should cover only red cells; if a\r\ndomino is placed vertically (it covers two adjacent cells in one of the\r\ncolumns), it should cover only blue cells. Let the of the board be the\r\nmaximum number of dominoes you can place. Calculate the sum of of the\r\nboard over all 2^w possible ways to paint it. Since it can be huge,\r\nprint it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\ntemplate <class ForwardIterator,\n          class T = typename std::iterator_traits<ForwardIterator>::value_type>\nstd::vector<std::pair<T, int>> rle(ForwardIterator first,\n                                   ForwardIterator last) {\n  std::vector<std::pair<T, int>> res;\n  int n = 0;\n  for (auto it = first; it != last; ++it)\n    n += std::next(it) == last or not(*it == *std::next(it));\n  res.reserve(n);\n  for (; first != last; ++first)\n    if (std::empty(res) or not(res.back().first == *first))\n      res.emplace_back(*first, 1);\n    else\n      ++res.back().second;\n  return res;\n}\n\ntemplate <uint32_t Modulus>\nclass ModularInt {\n  using M = ModularInt;\n\n public:\n  static_assert(int(Modulus) >= 1, \"Modulus must be in the range [1, 2^31)\");\n  static constexpr int modulus() { return Modulus; }\n  static M raw(uint32_t v) { return *reinterpret_cast<M*>(&v); }\n\n  ModularInt() : v_(0) {}\n  ModularInt(int64_t v) : v_((v %= Modulus) < 0 ? v + Modulus : v) {}\n\n  template <class T>\n  explicit operator T() const {\n    return v_;\n  }\n  M& operator++() { return v_ = ++v_ == Modulus ? 0 : v_, *this; }\n  M& operator--() { return --(v_ ? v_ : v_ = Modulus), *this; }\n  M operator+() const { return *this; }\n  M operator-() const { return raw(v_ ? Modulus - v_ : 0); }\n  M& operator*=(M o) { return v_ = uint64_t(v_) * o.v_ % Modulus, *this; }\n  M& operator/=(M o) {\n    auto [inv, gcd] = extgcd(o.v_, Modulus);\n    assert(gcd == 1);\n    return *this *= inv;\n  }\n  M& operator+=(M o) {\n    return v_ = int(v_ += o.v_ - Modulus) < 0 ? v_ + Modulus : v_, *this;\n  }\n  M& operator-=(M o) {\n    return v_ = int(v_ -= o.v_) < 0 ? v_ + Modulus : v_, *this;\n  }\n\n  friend M operator++(M& a, int) { return std::exchange(a, ++M(a)); }\n  friend M operator--(M& a, int) { return std::exchange(a, --M(a)); }\n  friend M operator*(M a, M b) { return a *= b; }\n  friend M operator/(M a, M b) { return a /= b; }\n  friend M operator+(M a, M b) { return a += b; }\n  friend M operator-(M a, M b) { return a -= b; }\n  friend std::istream& operator>>(std::istream& is, M& x) {\n    int64_t v;\n    return is >> v, x = v, is;\n  }\n  friend std::ostream& operator<<(std::ostream& os, M x) { return os << x.v_; }\n  friend bool operator==(M a, M b) { return a.v_ == b.v_; }\n  friend bool operator!=(M a, M b) { return a.v_ != b.v_; }\n\n private:\n  static std::pair<int, int> extgcd(int a, int b) {\n    std::array x{1, 0};\n    while (b) std::swap(x[0] -= a / b * x[1], x[1]), std::swap(a %= b, b);\n    return {x[0], a};\n  }\n\n  uint32_t v_;\n};\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nusing Mint = ModularInt<998244353>;\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  vector<Mint> f(3e5 + 1);\n  f[2] = 1;\n  for (int i : Rep(3, 3e5 + 1)) f[i] = 3 * f[i - 1] - 4 * f[i - 3];\n\n  vector<Mint> p2(3e5 + 1);\n  p2[0] = 1;\n  for (int i : Rep(3e5)) p2[i + 1] = 2 * p2[i];\n\n  int h = scan();\n  int w = scan();\n  vector<string> s(h);\n  generate(ALL(s), scan<string>);\n  int white = 0;\n  for (auto&& e : s) white += count(ALL(e), 'o');\n\n  Mint ans;\n  for (int _ = 2; _--;) {\n    {\n      vector ns(w, string(h, '?'));\n      for (int i : Rep(h))\n        for (int j : Rep(w)) ns[j][i] = s[i][j];\n      s = ns;\n      swap(h, w);\n    }\n    for (auto&& e : s) {\n      for (auto&& [c, len] : rle(ALL(e))) {\n        if (c == '*') continue;\n        ans += f[len] * p2[white - len];\n      }\n    }\n  }\n  cout << ans << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Colorings and Dominoes.json",
    "editorial_link": "https://codeforces.com//blog/entry/89634",
    "editorial": "There are different solutions to this problem involving combinatorics\r\nand/or dynamic programming, but, in my opinion, itâs a bit easier to\r\nlook at the problem from the perspective of probability theory.Letâs\r\nsuppose a coloring is already chosen. Then it can be covered with\r\ndominoes greedily: red and blue cells are independent from each other,\r\nand, for example, red cells can be analyzed as a set of \"strips\" of them\r\nof different length. Letâs say that we cover each \"strip\" from left to\r\nright, so, in each \"strip\", the first domino covers the cells and , the\r\nsecond domino the cells and , and so on.Letâs calculate the value of the\r\ncoloring, that is, the expected value of the coloring if it is chosen\r\nrandomly. Let it be , then the answer is .By linearity of expectation,\r\ncan be calculated as , where is the set of all places we can use for a\r\ndomino, and is the probability that there is a domino in place in our\r\ndomino covering (which we construct greedily). Each domino covers two\r\nadjacent cells, so we can iterate on pairs of adjacent cells, and for\r\neach pair, find the probability that this pair is covered. Letâs suppose\r\nthat we want to cover the cells and with a domino. Then: both of these\r\ncells should be red; the length of the red \"strip\" before these cells\r\nshould be even (otherwise the cell will be paired with the cell ). The\r\nonly thing we need to know in order to calculate the probability of\r\nthese two conditions being true is the number of white cells before the\r\ncell which can be easily maintained. Knowing the number of white cells\r\nbefore , we can either use dynamic programming to calculate the required\r\nprobability, or do the math on several easy examples and try to notice\r\nthe pattern: if there are white cells before the current one, the\r\nprobability of that pair being covered with a domino (letâs call it ) is\r\n(both these cells should be red); if there is white cell before the\r\ncurrent one, the probability of that pair being covered with a domino\r\n(letâs call it ) is (the cells and should be red, but the cell before\r\nthem should not be red); is (either the chosen two cells are red and the\r\ncell before them is not red, or all four cells are red); is , and so on.\r\nSo, knowing the number of white cells before and , we easily calculate\r\nthe probability of this pair being covered by a domino. By summing up\r\nthe probabilities over all pairs of adjacent white cells (donât forget\r\nthe vertical ones!), we get the average (or expected) value of the\r\ncoloring. All thatâs left is to multiply it by .\r\n",
    "hint": []
}