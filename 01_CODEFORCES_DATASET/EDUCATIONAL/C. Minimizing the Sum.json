{
    "link": "https://codeforces.com//contest/1969/problem/C",
    "problemId": "2619519",
    "problem_idx": "C",
    "shortId": "1969C",
    "contest_number": "1969",
    "problem_submissions": {
        "F": [
            258740971,
            258740820,
            258746132,
            258746716,
            258755183,
            258754014,
            258764616,
            258761581,
            258761069,
            258757448,
            258733006,
            258743321,
            258792091,
            258769461
        ],
        "E": [
            258725328,
            258720683,
            258724478,
            258731693,
            258756331,
            258755767,
            258736057,
            258804715,
            258733183,
            258735874,
            258730875,
            258757457,
            258749091,
            258722655,
            258724259,
            258731836,
            258735531,
            258733424,
            258733392,
            258730397,
            258733010,
            258733415,
            258736757
        ],
        "D": [
            258715496,
            258711950,
            258717455,
            258715807,
            258715309,
            258717478,
            258718891,
            258722961,
            258744444,
            258753841,
            258715868,
            258714258,
            258718192,
            258717839,
            258720978,
            258721300,
            258722241,
            258769261,
            258723656,
            258722483,
            258717125
        ],
        "C": [
            258709519,
            258714184,
            258710089,
            258708902,
            258709129,
            258711287,
            258711586,
            258731391,
            258739788,
            258758308,
            258709210,
            258714988,
            258712692,
            258710594,
            258712746,
            258713533,
            258716060,
            258713283,
            258715693,
            258710630
        ],
        "B": [
            258705054,
            258704158,
            258705135,
            258705001,
            258705619,
            258707939,
            258707446,
            258706758,
            258736445,
            258759399,
            258704770,
            258705679,
            258707425,
            258706710,
            258706746,
            258707793,
            258708419,
            258705968,
            258708957,
            258706188
        ],
        "A": [
            258703665,
            258703553,
            258703758,
            258703560,
            258703556,
            258703637,
            258704655,
            258703660,
            258734943,
            258760234,
            258703586,
            258703687,
            258704850,
            258703730,
            258703995,
            258703579,
            258704091,
            258703811,
            258704619,
            258703722
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129022",
    "editorial": "The small values of leads to the idea that expected solution is dynamic\r\nprogramming. In fact, we can actually design a dynamic programming\r\nsolution.Let be the minimum sum, if we considered the first elements and\r\nalready done operations. Note that, we can turn a segment of length into\r\na minimum on it using operations. So the transitions can be done by\r\niterating over the length of the next segment (denote it as ) and we can\r\nupdate with , where is the minimum among (that can be maintained in a\r\nsingle variable during iteration over ).There are states in the dynamic\r\nprogramming and transitions from each of them, so the solution works in\r\n.\r\n",
    "name": "C. Minimizing the Sum",
    "statement": "You are given an integer array a of length n.You can perform the\r\nfollowing operation: choose an element of the array and replace it with\r\nany of its neighbor\u2019s value.For example, if a=[3, 1, 2], you can get one\r\nof the arrays [3, 3, 2], [3, 2, 2] and [1, 1, 2] using one operation,\r\nbut not [2, 1, 2] or [3, 4, 2]. Your task is to calculate the minimum\r\npossible total sum of the array if you can perform the aforementioned\r\noperation at most k times.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"#pragma GCC optimize (\"O3\")#pragma GCC target (\"sse4\") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd;\u00a0template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert\u00a0template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\u00a0void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << '\\'' << x << '\\'';}void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}void __print(bool x) {cerr << (x ? \"true\" : \"false\");}\u00a0template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}template<typename T>void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}void _print() {cerr << \"]\\n\";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;#else#define dbg(x...)#endif\u00a0\u00a0const int MOD = 1000000007;const char nl = '\\n';const int MX = 100001; \u00a0void solve() {    int N, K; cin >> N >> K;    ll dp[N+1][K+1]; F0R(i, N+1) F0R(j, K+1) dp[i][j] = 1e18;    dp[0][0] = 0;    ll A[N]; F0R(i, N) cin >> A[i];    F0R(i, N) {        F0R(j, K+1) {            ll cval = MOD;            F0R(k, min(N-i, K-j+1)) {                ckmin(cval, A[i+k]);                ckmin(dp[i+k+1][j+k], cval * (k+1) + dp[i][j]);            }        }    }\u00a0    ll ans = 1e18; F0R(i, K+1) ckmin(ans, dp[N][i]);    cout << ans << nl;\u00a0} int main() {    ios_base::sync_with_stdio(0); cin.tie(0);\u00a0    int T = 1;    cin >> T;    while(T--) {        solve();    }\u00a0\treturn 0;}\u00a0\u00a0"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Minimizing the Sum.json"
}