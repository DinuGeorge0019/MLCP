{
    "link": "https://codeforces.com//contest/1278/problem/E",
    "problemId": "498934",
    "problem_idx": "E",
    "shortId": "1278E",
    "contest_number": "1278",
    "problem_submissions": {
        "E": [
            67224918,
            67231614,
            67223912,
            67253812,
            67225741,
            67224871,
            67225251,
            67224253,
            67224097,
            67228073,
            67224351,
            67238384,
            67238891,
            67235763,
            67230622,
            67227930,
            67239651,
            67240882,
            67235370,
            67231237,
            67232624
        ],
        "F": [
            67220843,
            67234059,
            67225490,
            67229828,
            67232198,
            67228232,
            67234554,
            67236753,
            67235814,
            67235952,
            67222634,
            67222261,
            67233844,
            67234877,
            67233597,
            67235880,
            168626483,
            67236179,
            67239000,
            67242413,
            67234942
        ],
        "D": [
            67217029,
            67303164,
            67301866,
            67298063,
            67237371,
            67236431,
            67235408,
            67220294,
            67220865,
            67220608,
            67221489,
            67220476,
            67219646,
            67219320,
            67220067,
            67226705,
            67224401,
            67222526,
            67227114,
            67223817,
            67223367,
            67231531,
            67228179,
            67226295
        ],
        "C": [
            67214007,
            67214267,
            67217998,
            67216889,
            67218307,
            67216554,
            67216623,
            67215042,
            67215238,
            67217005,
            67217682,
            67215492,
            67219419,
            67219630,
            67218331,
            67220921,
            67220564,
            67238779
        ],
        "B": [
            67212862,
            67212809,
            67214461,
            67213367,
            67214581,
            67214399,
            67214511,
            67213321,
            67213424,
            67214716,
            67216187,
            67217236,
            67216491,
            67238990,
            67224941,
            67214356,
            67216320,
            67214479,
            67213910
        ],
        "A": [
            67212605,
            67233989,
            67212600,
            67213460,
            67212650,
            67212623,
            67213201,
            67212677,
            67212601,
            67212657,
            67213584,
            67212831,
            67213003,
            67213058,
            67213442,
            67213081,
            67213875,
            67213272,
            67212886
        ]
    },
    "name": "E. Tests for problem D",
    "statement": "We had a really tough time generating tests for problem D. In order to\r\nprepare strong tests, we had to solve the following problem.Given an\r\nundirected labeled tree consisting of n vertices, find a set of segments\r\nsuch that: both endpoints of each segment are integers from 1 to 2n, and\r\neach integer from 1 to 2n should appear as an endpoint of exactly one\r\nsegment; all segments are non-degenerate; for each pair (i, j) such that\r\ni\r\nne j, i\r\nin [1, n] and j\r\nin [1, n], the vertices i and j are connected with an edge if and only\r\nif the segments i and j intersect, but neither segment i is fully\r\ncontained in segment j, nor segment j is fully contained in segment i.\r\nCan you solve this problem too?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nvector<int>edge[500005];\nvector<int>num[500005];\nvoid dfs(int v,int u){\n\tbool ch = 0;\n\tP p = mp(-1,-1);\n\trep(i,edge[v].size()){\n\t\tif(edge[v][i]==u) continue;\n\t\tch = 1; dfs(edge[v][i],v);\n\t\tp = max(p,mp((int)num[edge[v][i]].size(),edge[v][i]));\n\t}\n\tif(!ch){\n\t\trep(i,2) num[v].pb(v);\n\t\treturn;\n\t}\n\tswap(num[v],num[p.sc]);\n\tvector<int>las; las.pb(num[v].back()); num[v].pop_back();\n\t\n\trep(i,edge[v].size()){\n\t\tif(edge[v][i]==u||edge[v][i]==p.sc) continue;\n\t\tlas.pb(num[edge[v][i]].back());\n\t\trep(j,num[edge[v][i]].size()-1) num[v].pb(num[edge[v][i]][j]);\n\t}\n\tnum[v].pb(v); reverse(las.begin(),las.end());\n\trep(i,las.size()) num[v].pb(las[i]);\n\tnum[v].pb(v);\n//\tcout << v << endl;\n//\trep(i,num[v].size()) cout << num[v][i] << \" \"; cout << endl;\n}\nvector<int>vec[500005];\nint main(){\n\tscanf(\"%d\",&n);\n\trep(i,n-1){\n\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\tedge[a].pb(b);\n\t\tedge[b].pb(a);\n\t}\n\tdfs(1,-1);\n\trep(i,num[1].size()) vec[num[1][i]].pb(i+1);\n\trepn(i,n) printf(\"%d %d\\n\",vec[i][0],vec[i][1]);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "divide and conquer",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Tests for problem D.json",
    "editorial_link": "https://codeforces.com//blog/entry/72330",
    "editorial": "For each vertex, we will build the following structure for its children:\r\nthe segment for the second child is nested in the segment for the first\r\nchild, the nested for the third child is nested in the segment for the\r\nsecond child, and so on; and the children of different vertices do not\r\nintersect at all.Let\u00e2\u0080\u0099s solve the problem recursively: for each of the\r\nchildren, create a set of segments with endpoints from to , where is the\r\nsize of the subtree. After that, combine them. To do this, you can use\r\nsmall-to-large technique and change the coordinates of the segments or\r\nuse the necessary offset in the function call for the next child.After\r\nthat, it remains to cross children\u00e2\u0080\u0099s segments with the segment of the\r\nvertex itself. To do this, you can move the right ends of all segments\r\nof the children by to the right, and add a segment that starts before\r\nthe first one and ends immediately after the last one.\r\n"
}