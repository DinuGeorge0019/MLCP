{"link": "https://codeforces.com//contest/1257/problem/C", "problemId": "470638", "problem_idx": "C", "shortId": "1257C", "contest_number": "1257", "problem_submissions": {"D": [65057118, 65056815, 64811909, 64812228, 64902701, 64852999, 64814000, 64812775, 64810546, 64816528, 64811860, 64815149, 64813583, 64859190, 64812263, 64833625, 64835681, 64837730, 64812160, 64814684, 64816849, 64813089, 64816979, 64819402, 64816732], "C": [65056409, 64806576, 64805235, 64806785, 64807190, 64804696, 64807450, 64806032, 64809153, 64805479, 64859181, 64806083, 64833699, 64837249, 64838553, 64806562, 64809106, 64808660, 64805745, 64806256, 64807560, 64807194], "G": [64897847, 64897831, 64897799, 64897485, 64897435, 64897360, 64897323, 64897206, 64897135, 64897132, 64832008, 64834753, 64834055, 65121895, 65107512, 65106890, 64896695, 64896568, 64824847, 64838006, 64831302, 64827437, 64838916, 64835759, 64897295, 64843586, 64835359, 64859234, 64838704, 65758026, 65701826, 64838221, 64811892, 64819153, 64825152, 64845699, 211233713], "E": [64865638, 64865598, 64816641, 64819423, 64857985, 64831912, 64817543, 64814313, 64819647, 64817584, 64819210, 64817767, 64859197, 64814324, 64824835, 64832464, 64832777, 64820509, 64818561, 64820860, 64817451, 64823687, 64821709, 64824423], "F": [64821055, 64823926, 64819069, 64824118, 64836060, 64833509, 64822156, 64828427, 64823151, 64859227, 64836114, 64824755, 64828355, 64829448, 64829060, 64827403, 64826552, 64828456, 64828341, 64826098, 64830812], "B": [64802390, 64803311, 64804526, 64804462, 64802487, 64804783, 64803616, 64806366, 64802273, 64859169, 64803153, 64833735, 64838243, 64839005, 64803686, 64806451, 64806108, 64802622, 64803655, 64803331, 64803958], "A": [64800956, 64800953, 64801859, 64801038, 64800918, 64800975, 64800962, 64803138, 64800908, 64859160, 64801089, 64833779, 64838753, 64839327, 64800961, 64801572, 64801191, 64800917, 64801440, 64800919, 64801087]}, "name": "C. Dominated Subarray", "statement": "Let\u2019s call an array t by value v in the next situation.At first, array t\r\nshould have at least 2 elements. Now, let\u2019s calculate number of\r\noccurrences of each number num in t and define it as occ(num). Then t is\r\ndominated (by v) if (and only if) occ(v) > occ(v\u2019) for any other number\r\nv\u2019. For example, arrays [1, 2, 3, 4, 5, 2], [11, 11] and [3, 2, 3, 2, 3]\r\nare dominated (by 2, 11 and 3 respectevitely) but arrays [3], [1, 2] and\r\n[3, 3, 2, 2, 1] are not.Small remark: since any array can be dominated\r\nonly by one number, we can not specify this number and just say that\r\narray is either dominated or not.You are given array a_1, a_2,\r\ndots, a_n. Calculate its shortest dominated subarray or say that there\r\nare no such subarrays.The subarray of a is a contiguous part of the\r\narray a, i. e. the array a_i, a_{i + 1},\r\ndots, a_j for some 1\r\nle i\r\nle j\r\nle n.\r\n", "solutions": ["#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e9 + 5;\n\nvoid solve_case() {\n    int N;\n    cin >> N;\n    vector<int> last(N + 1, -INF);\n    int best = INF;\n\n    for (int i = 0; i < N; i++) {\n        int a;\n        cin >> a;\n        best = min(best, i - last[a] + 1);\n        last[a] = i;\n    }\n\n    cout << (best <= N ? best : -1) << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int T;\n    cin >> T;\n\n    while (T-- > 0)\n        solve_case();\n}\n"], "input": "", "output": "", "tags": ["greedy", "implementation", "sortings", "strings", "two pointers"], "dificulty": "1200", "interactive": false}