{"link": "https://codeforces.com//contest/598/problem/F", "problemId": "40769", "problem_idx": "F", "shortId": "598F", "contest_number": "598", "problem_submissions": {"C": [14258282, 14258243, 14230694, 14231202, 14231643, 14230605, 14232276, 14232531, 14233681, 14236053, 14234393, 14237043, 14234521, 14238674, 14254495], "E": [14232918, 14233759, 14233061, 14234500, 14235984, 14231617, 14235791, 14234781, 14237980, 27723122, 14234802, 14238606, 14238276, 14230968, 14231346, 14231257, 14229755, 14231535, 14232059], "D": [14231500, 14232200, 14231256, 14232148, 14233968, 14233300, 14231514, 14231409, 14235674, 14233048, 14236255, 14231336, 14229735, 14229704, 14230486, 14231024, 14230489, 14230566], "B": [14228934, 14229369, 14229229, 14229653, 14229332, 14229739, 14232154, 14232624, 14229585, 14231038, 14232631, 14229469, 14229277, 14228902, 14228794, 14230341, 14229075, 14229130], "A": [14228503, 14228566, 14228506, 14229062, 14228523, 14229086, 14229170, 14228699, 14228571, 14228539, 14228982, 14228489, 14228480, 14228476, 14228530, 14228507, 14228550], "F": [59190852, 14260771]}, "name": "F. Cut Length", "statement": "Given simple (without self-intersections) -gon. It is not necessary\r\nconvex. Also you are given lines. For each line find the length of\r\ncommon part of the line and the -gon.The boundary of -gon belongs to\r\npolygon. It is possible that -gon contains 180-degree angles.\r\n", "solutions": ["#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <cassert>\n#include <iostream>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n\ntypedef long long ll;\n\nconst int INF=1000000000;\nconst double EPS=1e-5;\n\ntemplate<typename T>\nstruct point\n{\n\tT x,y;\n\tpoint(T x=0, T y=0):x(x), y(y){}\n\ttemplate<typename W>\n\tpoint(const point<W>& p):x(p.x), y(p.y){}\n\tpoint<T> operator+(const point<T>& b)\n\t{\n\t\treturn point(x+b.x, y+b.y);\n\t}\n\tpoint<T> operator-(const point<T>& b)\n\t{\n\t\treturn point(x-b.x, y-b.y);\n\t}\n\tpoint<T> operator*(T b) const\n\t{\n\t\treturn point<T>(x*b, y*b);\n\t}\n\tT inner(const point<T>& b) const\n\t{\n\t\treturn x*b.x + y*b.y;\n\t}\n\tT cross(const point<T>& b) const\n\t{\n\t\treturn x*b.y - y*b.x;\n\t}\n\tbool operator<(const point<T>& b) const\n\t{\n\t\tif(x!=b.x)\n\t\t\treturn x<b.x;\n\t\treturn y>b.y;\n\t}\n};\n\npoint<double> intersection;\nll d1, det;\n\nbool intersect(point<ll> A, point<ll> B, point<ll> C, point<ll> D)\n{\n\tif(B<A)\n\t\tswap(A,B);\n\tdet=(B-A).cross(C-D);\n\tif(det==0) return false;\n\td1=(C-A).cross(C-D);\n\tif(det<0)\n\t{\n\t\tdet*=-1;\n\t\td1*=-1;\n\t}\n\tintersection= point<double>(A)+point<double>(B-A)*(double(d1)/det);\n\treturn 0<=d1 && d1<=det;\n}\n\ndouble norm(const point<double> & p)\n{\n\treturn sqrt(p.inner(p));\n}\n\nll sign(ll x)\n{\n\tif(x<0) return -1;\n\tif(x==0) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tvector<point<ll> > poly;\n\tREP(i,n)\n\t{\n\t\tdouble x,y;\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t\tll X=round(x*100);\n\t\tll Y=round(y*100);\n\t\tpoly.push_back(point<ll>(X,Y));\n\t}\n\tREP(j,m)\n\t{\n\t\tdouble x1, y1, x2, y2;\n\t\tscanf(\"%lf%lf%lf%lf\",&x1,&y1,&x2,&y2);\n\t\tll X1, Y1, X2, Y2;\n\t\tX1=round(x1*100);\n\t\tY1=round(y1*100);\n\t\tX2=round(x2*100);\n\t\tY2=round(y2*100);\n\t\tpoint<ll> p1(X1,Y1), p2(X2,Y2);\n\t\tvector<point<double> > p;\n\t\tvector<point<double> > segms;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpoint<ll> B=poly[i];\n\t\t\tpoint<ll> C=poly[(i+1)%n];\n\n\t\t\tif((p1-p2).cross(B-p2) == 0 && (p1-p2).cross(C-p2) == 0)\n\t\t\t{\n\t\t\t\tsegms.push_back(B);\n\t\t\t\tsegms.push_back(C);\n\t\t\t}\n\t\t\telse if(intersect(B, C, p1, p2))\n\t\t\t{\n\t\t\t\tll v1 = (p1-C).cross(p1-p2);\n\t\t\t\tll v2 = (p1-B).cross(p1-p2);\n\t\t\t\tif((v1 == 0 && v2<0) || (v2 == 0 && v1<0))\n\t\t\t\t\tcontinue;\n//\t\t\t\tif(sign((A-B).cross(p2-p1))*sign((C-B).cross(p2-p1))==-1 && norm(point<double>(B)-intersection)<EPS)\n//\t\t\t\t\tcontinue;\n\t\t\t\tp.push_back(intersection);\n\t\t\t}\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\tsort(segms.begin(), segms.end());\n\t\tdouble res=0;\n\t\tint i1 = 0;\n\t\tint i2 = 0;\n\n\t\tpoint<double> prv;\n\t\twhile(i1 < p.size() || i2 < segms.size())\n\t\t{\n\t\t\tpoint<double> cur;\n\t\t\tint inside = i1%2==1 || i2%2==1;\n\t\t\tif(i2>=segms.size() || (i1<p.size() && p[i1]<segms[i2]))\n\t\t\t\tcur = p[i1++];\n\t\t\telse\n\t\t\t\tcur = segms[i2++];\n\t\t\tif(inside)\n\t\t\t\tres+= norm(prv-cur);\n\t\t\tprv = cur;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",res/100);\n\t}\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["geometry"], "dificulty": "2900", "interactive": false}