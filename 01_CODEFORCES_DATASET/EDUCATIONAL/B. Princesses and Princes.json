{"link": "https://codeforces.com//contest/1327/problem/B", "problemId": "571325", "problem_idx": "B", "shortId": "1327B", "contest_number": "1327", "problem_submissions": {"F": [74109494, 74096912, 74114522, 74102690, 74088644, 74096945, 74118574, 74105095, 74095826, 74113555, 74098825, 74097831, 74105606, 74109593, 74101097, 74708534, 74098586], "G": [74091723, 74123968, 74123925, 74114197, 76629927, 74211867, 74588194, 74135043, 143583395, 74127397, 74126425, 74105678, 74715507], "B": [74068544, 74058114, 74057729, 74055609, 74062072, 74057059, 74054855, 74056002, 74059330, 74057094, 74057214, 74063726, 74054652, 74058809, 74054826, 74057170, 74057831, 74708239, 74069029], "E": [74063712, 74072104, 74084153, 74095848, 74069496, 74077697, 74073149, 74081984, 74074950, 74080019, 74086353, 74075499, 74090079, 74089858, 74078241, 74086260, 74708411, 74085708], "C": [74060977, 74064317, 74075501, 74070865, 74062695, 74059969, 74061257, 74063448, 74063934, 74060895, 74069645, 74078565, 74065457, 74072914, 74062504, 74072575, 74708279, 74073328], "D": [74058988, 74081137, 74080575, 74087567, 74078030, 74085278, 74068392, 74068497, 74084912, 74069773, 74079760, 74085394, 74082419, 74068982, 74073656, 74080794, 74708339, 74079780], "A": [74048309, 74098107, 74049366, 74047546, 74050945, 74048503, 74046989, 74047125, 74048033, 74048151, 74049565, 74047828, 74047513, 74049730, 74046774, 74049977, 74047800, 74708180, 74063309]}, "name": "B. Princesses and Princes", "statement": "The King of Berland Polycarp LXXXIV has n daughters. To establish his\r\npower to the neighbouring kingdoms he wants to marry his daughters to\r\nthe princes of these kingdoms. As a lucky coincidence there are n other\r\nkingdoms as well.So Polycarp LXXXIV has enumerated his daughters from 1\r\nto n and the kingdoms from 1 to n. For each daughter he has compiled a\r\nlist of kingdoms princes of which she wanted to marry.Polycarp LXXXIV is\r\nvery busy, so he finds a couple for his daughters greedily one after\r\nanother.For the first daughter he takes and marries the daughter to\r\ntheir prince. For the second daughter he takes . If there are no free\r\nprinces in the list then the daughter marries nobody and Polycarp LXXXIV\r\nproceeds to the next daughter. The process ends after the n-th\r\ndaughter.For example, let there be 4 daughters and kingdoms, the lists\r\ndaughters have are [2, 3], [1, 2], [3, 4], [3], respectively. In that\r\ncase daughter 1 marries the prince of kingdom 2, daughter 2 marries the\r\nprince of kingdom 1, daughter 3 marries the prince of kingdom 3, leaving\r\ndaughter 4 nobody to marry to.Actually, before starting the marriage\r\nprocess Polycarp LXXXIV has the time to convince one of his daughters\r\nthat some prince is also worth marrying to. Effectively, that means that\r\nhe can add exactly one kingdom to exactly one of his daughter\u2019s list.\r\nPolycarp LXXXIV wants to increase the number of married\r\ncouples.Unfortunately, what he doesn\u2019t have the time for is determining\r\nwhat entry to add. If there is no way to increase the total number of\r\nmarried couples then output that the marriages are already optimal.\r\nOtherwise, find such an entry that the total number of married couples\r\nincreases if Polycarp LXXXIV adds it.If there are multiple ways to add\r\nan entry so that the total number of married couples increases then\r\nprint any of them.For your and our convenience you are asked to answer t\r\nindependent test cases.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nint _,n,matl[N],matr[N];\nint main() {\n\tfor (scanf(\"%d\",&_);_;_--) {\n\t\tscanf(\"%d\",&n);\n\t\tint cnt=0;\n\t\trep(i,1,n+1) matr[i]=0,matl[i]=0;\n\t\trep(i,1,n+1) {\n\t\t\tint k,x;\n\t\t\tscanf(\"%d\",&k);\n\t\t\trep(j,0,k) {\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tif (matl[i]||matr[x]) continue;\n\t\t\t\tmatr[x]=1; matl[i]=1; cnt++;\n\t\t\t}\n\t\t}\n\t\tif (cnt==n) {\n\t\t\tputs(\"OPTIMAL\");\n\t\t} else {\n\t\t\tint pl=0,pr=0;\n\t\t\trep(i,1,n+1) if (matl[i]==0) pl=i;\n\t\t\trep(i,1,n+1) if (matr[i]==0) pr=i;\n\t\t\tputs(\"IMPROVE\");\n\t\t\tprintf(\"%d %d\\n\",pl,pr);\n\t\t}\n\t}\n}\n"], "input": "", "output": "", "tags": ["brute force", "graphs", "greedy"], "dificulty": "1200", "interactive": false}