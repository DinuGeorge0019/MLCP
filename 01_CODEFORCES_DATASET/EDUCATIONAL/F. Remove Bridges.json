{
    "link": "https://codeforces.com//contest/1976/problem/F",
    "problemId": "2672922",
    "problem_idx": "F",
    "shortId": "1976F",
    "contest_number": "1976",
    "problem_submissions": {
        "F": [
            263314410,
            263323534,
            263323690,
            263325512,
            263334653,
            263331007,
            263325411,
            263343899,
            263340351,
            263335929,
            263326828,
            263332991,
            263341073,
            263348258,
            263349127,
            263349457,
            263346381,
            263355969,
            263347175,
            263342030
        ],
        "E": [
            263305882,
            263313991,
            263310881,
            263312246,
            263315063,
            263311135,
            263313445,
            263315175,
            263343942,
            263328216,
            263320417,
            263320641,
            263323277,
            263324951,
            263331673,
            263329104,
            263324699,
            263325555,
            263316314,
            263328040,
            263331822
        ],
        "C": [
            263292519,
            263287752,
            263288751,
            263286876,
            263284054,
            263285532,
            263285507,
            263293215,
            263285305,
            263285884,
            263286170,
            263285744,
            263298002,
            263303206,
            263289650,
            263291396,
            263291844,
            263302664,
            263303154,
            263303039,
            263301515
        ],
        "D": [
            263292311,
            263298587,
            263366307,
            263299064,
            263295271,
            263295241,
            263295262,
            263303840,
            263298130,
            263292787,
            263298290,
            263306115,
            263312088,
            263291555,
            263300847,
            263305912,
            263364926,
            263302707,
            263310976,
            263298729,
            263311543,
            263313366
        ],
        "B": [
            263272017,
            263272271,
            263275878,
            263272612,
            263272889,
            263274173,
            263277739,
            263274170,
            263273861,
            263276359,
            263274099,
            263279892,
            263280435,
            263273730,
            263275861,
            263277331,
            263275586,
            263274544,
            263272648,
            263279232
        ],
        "A": [
            263268782,
            263268834,
            263269741,
            263268999,
            263269168,
            263269203,
            263269867,
            263269889,
            263269156,
            263268775,
            263269596,
            263270510,
            263268758,
            263268826,
            263268756,
            263270814,
            263269912,
            263269509,
            263268983,
            263270469
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129992",
    "editorial": "What does an extra edge change in the configuration of the bridges?\r\nWell, all tree edges on the path between the two vertices that an extra\r\nedge connects, stop being bridges.So, the task can be restated as\r\nfollows: choose pairs of distinct vertices such that: a root is present\r\nin at least one pair; the number of edges in the union of the paths\r\nbetween the vertices of all pairs is as large as possible; there is no\r\nvertex covered by at least one path such that an edge to its parent is\r\nnot a part of any path. The next idea is quite intuitive. It only makes\r\nsense to choose a root or the leaves of the tree into the pairs. If any\r\npair has a non-leaf vertex, you can safely prolong the path until any of\r\nthe leaves in its subtree, and the union of the paths will not become\r\nsmaller.Now for the tricky idea. Instead of choosing pairs of\r\nroot/leaves, you can actually just take a root and leaves, and there\r\nwill always be a way to split them into pairs to satisfy all\r\nconditions.Letâs show that. Traverse the tree with a DFS and record the\r\norder you visit the leaves. Pair up a root with the middle leaf in that\r\norder. Then pair up leaves and , and and so on. This way, the path for\r\nevery pair includes a vertex on the path of the first pair (the one that\r\nincludes the root). Thus, the union of the paths is the same as the\r\nunion of all vertical paths from the leaves to the root. That obviously\r\nsatisfies the condition on the connectedness of the bridges.Notice how\r\nthat union of the paths is also the largest possible on that set of\r\nleaves. Every path between the leaves can be viewed at as two vertical\r\npaths from each leaf. The longest vertical path from each leaf is the\r\none going to the root. And we have exactly the union of these vertical\r\npaths as our solution.Thus, the task actually becomes as follows: choose\r\nleaves in such a way that the union of their paths to the root is as\r\nlarge as possible.That can actually be done greedily. Take a leaf with\r\nthe longest path to the root. Then keep taking leaves that add as many\r\nnew edges into the union as possible.That idea can be implemented as\r\nfollows. For every vertex, calculate the longest path that starts in it\r\nand ends in some leaf. Can be done with a single DFS. Maintain a set of\r\nall vertices sorted by their longest paths. On each step, take a vertex\r\nwith the largest value and remove all vertices on that path (any path of\r\nthe maximum length if there are multiple) from the set.Overall\r\ncomplexity: per testcase.\r\n",
    "name": "F. Remove Bridges",
    "statement": "You are given a rooted tree, consisting of n vertices, numbered from 1\r\nto n. Vertex 1 is the root. Additionally, the root only has one\r\nchild.You are asked to add exactly k edges to the tree (possibly,\r\nmultiple edges and/or edges already existing in the tree).Recall that a\r\nbridge is such an edge that, after you remove it, the number of\r\nconnected components in the graph increases. So, initially, all edges of\r\nthe tree are bridges.After k edges are added, some original edges of the\r\ntree are still bridges and some are not anymore. You want to satisfy two\r\nconditions: for every bridge, all tree edges in the subtree of the lower\r\nvertex of that bridge should also be bridges; the number of bridges is\r\nas small as possible. Solve the task for all values of k from 1 to n - 1\r\nand output the smallest number of bridges.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long; void solve() {    int n;    std::cin >> n;        std::vector<std::vector<int>> adj(n);    for (int i = 1; i < n; i++) {        int u, v;        std::cin >> u >> v;        u--, v--;        adj[u].push_back(v);        adj[v].push_back(u);    }        std::vector<int> a;    auto dfs = [&](auto &&self, int x, int p) -> int {        int h = 0;        for (auto y : adj[x]) {            if (y == p) {                continue;            }            int v = self(self, y, x) + 1;            if (v > h) {                std::swap(v, h);            }            if (v > 0) {                a.push_back(v);            }        }        return h;    };    a.push_back(dfs(dfs, 0, -1));        std::sort(a.begin(), a.end(), std::greater());        int ans = n - 1;    for (int i = 1, j = 0; i < n; i++) {        while (j < 2 * i - 1 && j < a.size()) {            ans -= a[j];            j++;        }        std::cout << ans << \" \\n\"[i == n - 1];    }} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dp",
        "greedy",
        "sortings",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Remove Bridges.json",
    "hint": []
}