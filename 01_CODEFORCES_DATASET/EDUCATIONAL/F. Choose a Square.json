{
    "link": "https://codeforces.com//contest/1221/problem/F",
    "problemId": "415612",
    "problem_idx": "F",
    "shortId": "1221F",
    "contest_number": "1221",
    "problem_submissions": {
        "G": [
            60878901,
            60954325,
            60892510,
            60889777,
            60939440,
            60957169,
            60954037,
            60954018,
            60887759,
            60892512,
            61066187,
            60888304,
            60953665,
            60884074
        ],
        "F": [
            60872429,
            60906430,
            60877026,
            60879328,
            60873795,
            60880496,
            60880041,
            60882317,
            60876205,
            60881638,
            60879016,
            60884701,
            60883109,
            60876230,
            60885368,
            60884882,
            60888631,
            60877275
        ],
        "E": [
            60865427,
            60906424,
            60870455,
            60872355,
            60881944,
            60867813,
            60873346,
            60871774,
            60882236,
            60957159,
            60869840,
            60865430,
            60870324,
            60874697,
            60871945,
            60886034,
            60875073,
            60873664,
            60883200,
            60875153,
            60886105,
            60887173
        ],
        "D": [
            60858978,
            60906413,
            60858963,
            60862133,
            60857697,
            60858483,
            60858390,
            60860167,
            60862000,
            60957149,
            60859058,
            60857548,
            60865511,
            60860504,
            60857388,
            60865183,
            60887076,
            60866989,
            60863673,
            60861492,
            60857971,
            60867806,
            60885376
        ],
        "C": [
            60854799,
            60906405,
            60854087,
            60858148,
            60855694,
            60855339,
            60856078,
            60857408,
            60859538,
            60957138,
            60855511,
            60854166,
            60860646,
            60858018,
            60854647,
            60856215,
            60857135,
            60857947,
            60855000,
            60855230,
            60864597,
            60884317
        ],
        "B": [
            60853702,
            60906395,
            60853284,
            60856858,
            60853405,
            60869020,
            60854977,
            60855791,
            60854474,
            60957129,
            60854297,
            60853117,
            60859658,
            60856090,
            60853528,
            60854286,
            60855985,
            60856982,
            60854601,
            60853843,
            60862970,
            60883738
        ],
        "A": [
            60853175,
            60906382,
            60852746,
            60855419,
            60852846,
            60852969,
            60852978,
            60853994,
            60853299,
            60957119,
            60852836,
            60852764,
            60858768,
            60853799,
            60852813,
            60853187,
            60854280,
            60853549,
            60853275,
            60852850,
            60861325,
            60883303
        ]
    },
    "name": "F. Choose a Square",
    "statement": "Petya recently found a game \"Choose a Square\". In this game, there are n\r\npoints numbered from 1 to n on an infinite field. The i-th point has\r\ncoordinates (x_i, y_i) and cost c_i.You have to choose a square such\r\nthat its sides are parallel to coordinate axes, the lower left and upper\r\nright corners belong to the line y = x, and all corners have integer\r\ncoordinates.The score you get is the sum of costs of the points covered\r\nby the selected square minus the length of the side of the square. Note\r\nthat the length of the side can be zero.Petya asks you to calculate the\r\nmaximum possible score in the game that can be achieved by placing\r\nexactly one square.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = (int)1e6 + 100;\nint x[maxN], y[maxN], c[maxN];\nint bestX = 1.5e9;\nint bestY = bestX;\nll cost = 0;\nint idX[maxN], idY[maxN];\nint id[maxN];\nvector < int > events[maxN];\npair < ll, int > t[4 * maxN];\nll upd[4 * maxN];\nvoid build(int v, int tl, int tr) {\n    t[v] = make_pair(0, tl);\n    if (tl == tr) return;\n    int tm = (tl + tr) / 2;\n    build(2 * v, tl, tm);\n    build(2 * v + 1, tm + 1, tr);\n}\nvoid push(int v, int tl, int tr) {\n    if (upd[v] == 0) return;\n    t[v].first += upd[v];\n    if (tl != tr) {\n        upd[2 * v] += upd[v];\n        upd[2 * v + 1] += upd[v];\n    }\n    upd[v] = 0;\n}\nvoid add(int v, int tl, int tr, int l, int r, ll val) {\n    if (l <= tl && tr <= r) {\n        upd[v] += val;\n        push(v, tl, tr);\n        return;\n    }\n    push(v, tl, tr);\n    if (r < tl || l > tr) return;\n    int tm = (tl + tr) / 2;\n    add(2 * v, tl, tm, l, r, val);\n    add(2 * v + 1, tm + 1, tr, l, r, val);\n    t[v] = max(t[2 * v], t[2 * v + 1]);\n}\nconst ll INF = 2e18;\npair < ll, int > get_mx(int v, int tl, int tr, int l, int r) {\n    push(v, tl, tr);\n    if (l <= tl && tr <= r) return t[v];\n    if (l > r) return make_pair(-INF, -1);\n    int tm = (tl + tr) / 2;\n    return max(get_mx(2 * v, tl, tm, l, min(r, tm)), get_mx(2 * v + 1, tm + 1, tr, max(l, tm + 1), r));\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    vector < int > cords;\n    for (int i = 1; i <= n; i++) {\n        cin >> x[i] >> y[i] >> c[i];\n        if (x[i] < y[i]) swap(x[i], y[i]);\n        cords.push_back(x[i]);\n        cords.push_back(y[i]);\n    }\n    sort(cords.begin(), cords.end());\n    cords.erase(unique(cords.begin(), cords.end()), cords.end());\n    for (int i = 0; i < cords.size(); i++) {\n        id[i + 1] = cords[i];\n    }\n    for (int i = 1; i <= n; i++) {\n        idX[i] = lower_bound(cords.begin(), cords.end(), x[i]) - cords.begin() + 1;\n        idY[i] = lower_bound(cords.begin(), cords.end(), y[i]) - cords.begin() + 1;\n        events[idX[i]].push_back(i);\n    }\n    int m = cords.size();\n    build(1, 1, m);\n    for (int i = 1; i <= cords.size(); i++) {\n        add(1, 1, m, i, i, id[i]);\n        for (int v : events[i]) {\n            add(1, 1, m, 1, idY[v], c[v]);\n        }\n        auto it = get_mx(1, 1, m, 1, i);\n        ll val = it.first - id[i];\n        if (val > cost) {\n            bestX = id[i];\n            bestY = id[it.second];\n            cost = val;\n        }\n    }\n    cout << cost << '\\n';\n    cout << bestY << \" \" << bestY << \" \" << bestX << \" \" << bestX;\n\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Choose a Square.json",
    "editorial_link": "https://codeforces.com//blog/entry/69925",
    "editorial": "Notice that the square () () covers the point () if and only if .Using\r\nthis fact, letâs reformulate the problem the following way: we have to\r\nfind the segment , such that the sum of the segments fully covered by it\r\nis maximal.Letâs build a segment tree, the -th of its leaves stores the\r\nsum of the segments covered by the segment . Initially, itâs built for\r\nsome such that it is to the right of all segments. Other nodes store the\r\nmaximum in them.Now letâs iterate over the values of in descending\r\norder. Let there be some segment starting in with the cost . All the\r\nanswers for wonât change because they donât cover that new segment. And\r\nthe values on the suffix from the position () will increase by .The only\r\nthing left is to learn how to handle the subtraction of the length of\r\nthe side. That term is and the thing we are looking for is . Rewrite it\r\nin form and youâll see that you can just subtract from the value of the\r\n-th leaf of the segment tree at the beginning to get the correct result.\r\nSurely, youâll need to add that after you ask the maximum of all the\r\nsegtree to obtain the answer.Youâll probably need to compress the\r\ncoordinates leave only such positions that there is at least one or .\r\nImplicit segtree might work but neither ML, nor TL are not friendly to\r\nit. Also be careful with the case with all points being negative.\r\n",
    "hint": []
}