{
    "link": "https://codeforces.com//contest/961/problem/F",
    "problemId": "171417",
    "problem_idx": "F",
    "shortId": "961F",
    "contest_number": "961",
    "problem_submissions": {
        "G": [
            36970557,
            36961677,
            36955373,
            36966255,
            36968767,
            36972374,
            36973392,
            36957451,
            36991516,
            36977772,
            37364242,
            37112264,
            37103114
        ],
        "F": [
            36962483,
            58125816,
            58125730,
            36966139,
            36964087,
            37005545,
            36970234,
            36973408,
            36969033,
            36991746,
            37364493,
            37112764
        ],
        "E": [
            36956673,
            36957355,
            36966375,
            36957711,
            36958527,
            36964823,
            36966940,
            36964605,
            36962819,
            36970706,
            36966486,
            36958105,
            36958693,
            36959772,
            36960024,
            36961569,
            36960764,
            36960481,
            36957668,
            36960105
        ],
        "D": [
            36955388,
            36956052,
            36969754,
            36955080,
            36956362,
            36961025,
            36963713,
            36962592,
            36966993,
            36973138,
            36969906,
            36956687,
            36956700,
            36954860,
            36958377,
            36958046,
            36957936,
            36957484,
            36960554,
            36961499
        ],
        "C": [
            36953672,
            36954711,
            36971159,
            36953758,
            36954957,
            36955003,
            36960223,
            36959774,
            36965066,
            36959731,
            36967876,
            36954453,
            36954510,
            36957051,
            36956228,
            36956460,
            36956413,
            36954603,
            36954325,
            36955697
        ],
        "B": [
            36952423,
            36952593,
            36971775,
            36952372,
            36952637,
            36953362,
            36954152,
            36957455,
            36960770,
            36955533,
            36967266,
            36952701,
            36952953,
            36954148,
            36953570,
            36952980,
            36953956,
            36952386,
            36952552,
            36953095
        ],
        "A": [
            36951806,
            36951845,
            36972158,
            36951809,
            36951933,
            36951849,
            36952464,
            36956565,
            36959860,
            36954250,
            36966810,
            36951886,
            36952011,
            36951975,
            36952180,
            36951811,
            36952978,
            36951822,
            36951814,
            36951906
        ]
    },
    "name": "F. k-substrings",
    "statement": "You are given a string consisting of lowercase Latin letters.Let’s\r\ndenote -substring of as a string . Obviously, , and there are exactly\r\nsuch substrings.Let’s call some string an of a string iff the following\r\nconditions are met: ; is an odd number; is simultaneously a prefix and a\r\nsuffix of .For evey -substring () of you have to calculate the maximum\r\nlength of its odd proper suprefix.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint P[3] = { 359, 1039, 2797 };\nll MO[3] = { MOD, MOD + 2, 1000000087 };\n\nchar in[1000050];\nll po[3][1000050];\nll sum[3][1000050];\nbool isEqual(int s1, int e1, int s2, int e2) {\n\tfor (int i = 0; i < 3; i++) {\n\t\tll v1 = (sum[i][e1] - sum[i][s1 - 1]) % MO[i];\n\t\tv1 = (v1 + MO[i]) % MO[i];\n\t\tv1 = v1 * po[i][1000000 - e1] % MO[i];\n\n\t\tll v2 = (sum[i][e2] - sum[i][s2 - 1]) % MO[i];\n\t\tv2 = (v2 + MO[i]) % MO[i];\n\t\tv2 = v2 * po[i][1000000 - e2] % MO[i];\n\t\tif (v1 != v2) return false;\n\t}\n\treturn true;\n}\nint main() {\n\tint N, i, j;\n\tscanf(\"%d\", &N);\n\tscanf(\"%s\", in + 1);\n\n\tfor (i = 0; i < 3; i++) {\n\t\tpo[i][0] = P[i];\n\t\tfor (j = 1; j <= 1000000; j++) po[i][j] = po[i][j - 1] * P[i] % MO[i];\n\t\tfor (j = 1; j <= N; j++) sum[i][j] = (sum[i][j - 1] + po[i][j] * in[j]) % MO[i];\n\t}\n\n\tvector <int> Va;\n\tint prv = -1;\n\tfor (i = (N + 1) / 2; i >= 1; i--) {\n\t\tint st = i, en = N + 1 - st;\n\t\tint L = en - st + 1;\n\t\tint mx = min(L - 1, prv + 2);\n\t\tif (mx % 2 == 0) mx--;\n\t\tfor (j = mx; j >= 1; j-=2) {\n\t\t\tif (isEqual(st, st + j - 1, en - j + 1, en)) break;\n\t\t}\n\t\tif (j >= 1) Va.push_back(j);\n\t\telse Va.push_back(-1);\n\t\tprv = j;\n\t}\n\treverse(all(Va));\n\tfor (auto it : Va) printf(\"%d \", it);\n\treturn !printf(\"\\n\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "hashing",
        "string suffix structures"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. k-substrings.json",
    "editorial_link": "https://codeforces.com//blog/entry/58743",
    "editorial": "Letâs look at suprefix of fixed -substring: we canât find its maximal\r\nlength via binary search because this function isnât monotone in general\r\ncase. But, by fixing not the left border but the center of the prefix,\r\nwe also fix the center of the corresponding suffix (center of a prefix\r\nin position is tied with the center of the suffix in position ), and,\r\nmore important, function becomes monotone.So solution is next: iterate\r\nover all valid centers of prefix and try to binary search maximal length\r\nof such substring that its center is in position , and itâs equal to the\r\nsubsting with center in . then can be updated with value . And donât\r\nforget to update each with value .Easy way to check substrings for\r\nequality is to use hashes. Harder way is to use string suffix structures\r\n(like bundle of Suffix Array + LCP + Sparse Table or Suffix Tree +\r\nLCA).Note for SuffArray users: donât forget about changing sort to\r\nstable_sort (merge sort) and breaking if all suffixes are different.\r\nThis optimizations can save you from writing radix (or bucket) sort.\r\n",
    "hint": []
}