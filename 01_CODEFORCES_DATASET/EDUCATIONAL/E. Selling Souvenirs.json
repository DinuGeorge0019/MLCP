{
    "link": "https://codeforces.com//contest/808/problem/E",
    "problemId": "106401",
    "problem_idx": "E",
    "shortId": "808E",
    "contest_number": "808",
    "problem_submissions": {
        "E": [
            27137197,
            27134808,
            27134054,
            27132549,
            27131870,
            27132812,
            27138350,
            27133736,
            27131963,
            27140761,
            27135118,
            27134983,
            27132973,
            27138881,
            27134671,
            27261177,
            27134231
        ],
        "G": [
            27135167,
            27130618,
            27132801,
            27169611,
            27134965,
            27137204,
            27160747,
            27136267,
            27135740,
            27136906,
            27138137,
            27159188,
            27140353,
            27136012,
            27136390,
            27133992,
            27143226,
            27141294
        ],
        "F": [
            27133833,
            27138112,
            27177906,
            27136765,
            27164228,
            27142537,
            27133888,
            27166317,
            27145346,
            27277981,
            27273337,
            27267183,
            27141042,
            27133326,
            27139365,
            27141028,
            27139853,
            27137233,
            27203781,
            27164790,
            27139352
        ],
        "D": [
            27128503,
            27127219,
            27129431,
            27127572,
            27126819,
            27126652,
            27126413,
            27131013,
            27128036,
            27144856,
            27149028,
            27130439,
            27159164,
            27158696,
            27130609,
            27129280,
            31052395,
            27170361,
            27127426,
            27204067
        ],
        "C": [
            27127241,
            27126114,
            27126407,
            27126117,
            27125155,
            27125545,
            27125616,
            27128374,
            27126308,
            27126044,
            27126773,
            27128917,
            27129043,
            27127777,
            27126008,
            27126821,
            27129336
        ],
        "B": [
            27125488,
            27124939,
            27125624,
            27125294,
            27125238,
            27124591,
            27125024,
            27127379,
            27125310,
            27124893,
            27125455,
            27127633,
            27127827,
            27131416,
            27125036,
            27126129,
            27163815,
            27127143
        ],
        "A": [
            27124684,
            27124405,
            27124596,
            27124469,
            27124323,
            27124317,
            27124491,
            27126511,
            27124424,
            27124395,
            27124442,
            27124926,
            27125033,
            27130660,
            27124528,
            27124407,
            27163707,
            27124848
        ]
    },
    "name": "E. Selling Souvenirs",
    "statement": "After several latest reforms many tourists are planning to visit\r\nBerland, and Berland people understood that itâ€™s an opportunity to earn\r\nmoney and changed their jobs to attract tourists. Petya, for example,\r\nleft the IT corporation he had been working for and started to sell\r\nsouvenirs at the market.This morning, as usual, Petya will come to the\r\nmarket. Petya has different souvenirs to sell; th souvenir is\r\ncharacterised by its weight and cost . Petya knows that he might not be\r\nable to carry all the souvenirs to the market. So Petya wants to choose\r\na subset of souvenirs such that its total weight is not greater than ,\r\nand total cost is maximum possible.Help Petya to determine maximum\r\npossible total cost.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\ntypedef long long i64;\nint n,m,vs[4][100007],vp[4];\ni64 s1[100007],s2[100007],ans=0,now=0;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;++i){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tvs[x][++vp[x]]=y;\n\t}\n\tfor(int i=1;i<=3;++i)std::sort(vs[i]+1,vs[i]+vp[i]+1,std::greater<int>());\n\tfor(int i=1;i<=vp[1];++i)s1[i]=s1[i-1]+vs[1][i];\n\tfor(int i=1;i<=vp[2];++i)s2[i]=s2[i-1]+vs[2][i];\n\tfor(int i=0;i<=vp[3]&&m>=0;++i){\n\t\tint L=0,R=std::min(vp[2],m/2),M;\n\t\twhile(L<R){\n\t\t\tM=L+R>>1;\n\t\t\tint m2=std::min(m-M*2,vp[1]);\n\t\t\tif(M*2+m2<m-1||vs[2][M]>vs[1][m2]*2)L=M+1;\n\t\t\telse R=M;\n\t\t}\n\t\tfor(int x=std::max(0,M-50);x<=std::min(vp[2],M+50);++x){\n\t\t\tif(x*2>m)continue;\n\t\t\tint y=std::min(vp[1],m-x*2);\n\t\t\ti64 a1=now+s1[y]+s2[x];\n\t\t\tif(a1>ans)ans=a1;\n\t\t}\n\t\tm-=3;now+=vs[3][i+1];\n\t}\n\tprintf(\"%I64d\\n\",ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "ternary search"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Selling Souvenirs.json",
    "editorial_link": "https://codeforces.com//blog/entry/52010",
    "editorial": "There are lots of different solutions for this problem.We can iterate on\r\nthe number of -elements we will take (in this editorial -element is a\r\nsouvenir with weight ). When fixing the number of -elements (let it be\r\n), we want to know the best possible answer for the weight , while\r\ntaking into account only -elements and -elements.To answer these\r\nqueries, we can precalculate the values triples , where is the best\r\npossible answer for the weight , and and is the number of -elements and\r\n-elements we are taking to get this answer. Of course, , and we can\r\nupdate and using value of . After precalculating for each possible we\r\ncan iterate on the number of -elements.There are also several\r\nbinary/ternary search solutions.\r\n",
    "hint": []
}