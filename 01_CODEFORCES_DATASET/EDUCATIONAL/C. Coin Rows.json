{
    "link": "https://codeforces.com//contest/1555/problem/C",
    "problemId": "1062142",
    "problem_idx": "C",
    "shortId": "1555C",
    "contest_number": "1555",
    "problem_submissions": {
        "F": [
            124306614,
            124343856,
            124312339,
            124307563,
            124318196,
            124319806,
            124318258,
            124337936,
            124326369,
            124312719,
            124312071,
            124325220,
            124322375,
            124337491,
            124327796,
            124313538,
            124320609,
            124319069,
            124334134
        ],
        "E": [
            124292614,
            124284546,
            124290978,
            124299668,
            124299626,
            124301534,
            124305345,
            124311168,
            124315291,
            124304878,
            124305598,
            124300363,
            124304344,
            124324832,
            124306310,
            124305064,
            124305374
        ],
        "C": [
            124284989,
            124280595,
            124283283,
            124284609,
            124285731,
            124291694,
            124283589,
            124282860,
            124292981,
            124286855,
            124287174,
            124284102,
            124289820,
            124283315,
            124290207,
            124292792,
            124290345
        ],
        "D": [
            124282896,
            124281706,
            124287585,
            124287694,
            124291470,
            124295363,
            124329814,
            124293642,
            124293299,
            124285216,
            124284331,
            124294215,
            124292885,
            124291338,
            124294163,
            124296113,
            124299446,
            124297892,
            124294376
        ],
        "B": [
            124280802,
            124279957,
            124281993,
            124281520,
            124282708,
            124281869,
            124281852,
            124283175,
            124289412,
            124282989,
            124282919,
            124281809,
            124286550,
            124291562,
            124286726,
            124289852,
            124285340
        ],
        "A": [
            124279594,
            124279557,
            124279608,
            124279611,
            124279723,
            124279607,
            124279587,
            124279711,
            124282014,
            124280166,
            124279749,
            124279696,
            124279824,
            124279602,
            124281131,
            124280445,
            124279990
        ]
    },
    "name": "C. Coin Rows",
    "statement": "Alice and Bob are playing a game on a matrix, consisting of 2 rows and m\r\ncolumns. The cell in the i-th row in the j-th column contains a_{i, j}\r\ncoins in it.Initially, both Alice and Bob are standing in a cell (1, 1).\r\nThey are going to perform a sequence of moves to reach a cell (2, m).The\r\npossible moves are: Move right from some cell (x, y) to (x, y + 1); Move\r\ndown from some cell (x, y) to (x + 1, y). First, Alice makes until she\r\nreaches (2, m). She collects the coins in all cells she visit (including\r\nthe starting cell).When Alice finishes, Bob starts his journey. He also\r\nperforms the moves to reach (2, m) and collects the coins in all cells\r\nthat he visited, .The score of the game is the total number of coins Bob\r\ncollects.Alice wants to minimize the score. Bob wants to maximize the\r\nscore. What will the score of the game be if both players play\r\noptimally?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int m;\n    cin >> m;\n    vector<vector<int>> a(2, vector<int>(m));\n    for (int j = 0; j < 2; j++){\n      for (int k = 0; k < m; k++){\n        cin >> a[j][k];\n      }\n    }\n    vector<int> S1(m + 1);\n    S1[m] = 0;\n    for (int j = m - 1; j >= 0; j--){\n      S1[j] = S1[j + 1] + a[0][j];\n    }\n    vector<int> S2(m + 1);\n    S2[0] = 0;\n    for (int j = 0; j < m; j++){\n      S2[j + 1] = S2[j] + a[1][j];\n    }\n    int ans = INF;\n    for (int j = 0; j < m; j++){\n      ans = min(ans, max(S1[j + 1], S2[j]));\n    }\n    cout << ans << endl;\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dp",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Coin Rows.json",
    "editorial_link": "https://codeforces.com//blog/entry/93389",
    "editorial": "First, observe that each of the players has only options for their path\r\nwhich column to go down in.Let\u00e2\u0080\u0099s consider a Bob\u00e2\u0080\u0099s response to a strategy\r\nchosen by Alice. The easiest way to approach that is to look at the\r\npicture of the Alice\u00e2\u0080\u0099s path. The path clearly separates the field into\r\ntwo independent pieces suffix of the first row and the prefix of the\r\nsecond row. Bob can\u00e2\u0080\u0099t grab the coins from both of them at once. However,\r\nhe can grab either of them fully. So the optimal path for him will be\r\none of these two options.You can precalculate some prefix sums and\r\nbecome able to get the Bob\u00e2\u0080\u0099s score given the Alice\u00e2\u0080\u0099s path. Alice has\r\npossibly paths, so you can iterate over them and choose the minimum\r\nanswer.However, prefix sums are not required, since you can quickly\r\nrecalculate both needed sums while iterating over the Alice\u00e2\u0080\u0099s column to\r\ngo down in.Overall complexity: per testcase.\r\n"
}