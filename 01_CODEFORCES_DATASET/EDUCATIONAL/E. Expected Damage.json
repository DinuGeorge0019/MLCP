{
    "link": "https://codeforces.com//contest/1418/problem/E",
    "problemId": "727427",
    "problem_idx": "E",
    "shortId": "1418E",
    "contest_number": "1418",
    "problem_submissions": {
        "F": [
            92827621,
            92992766,
            92847130,
            92847007,
            92846498,
            92840659,
            92838710,
            92837329,
            92835778,
            92821703,
            92839298,
            92833921,
            92885700,
            92870799,
            92830172,
            92989347,
            92845726
        ],
        "G": [
            92817256,
            93890104,
            93890054,
            93890004,
            93889956,
            93889783,
            93889650,
            93889392,
            93889084,
            93888189,
            93888010,
            93887834,
            93887831,
            93887519,
            93887334,
            93887004,
            93839244,
            93839240,
            93839237,
            93835786,
            93835763,
            93835704,
            93828053,
            93828000,
            92855419,
            92854972,
            92815447,
            92815164,
            92824652,
            92823576,
            92837977,
            92824758,
            92885721,
            92823789,
            92823462,
            92820493,
            92830232,
            93485501,
            92866692,
            92833116,
            92832754,
            92824217,
            92833610,
            92830510,
            92833625,
            92828988,
            92837204,
            92830405,
            92834428
        ],
        "A": [
            92809737,
            92851684,
            92804370,
            92802575,
            92799307,
            92799729,
            92800647,
            92885635,
            92800218,
            92800425,
            92802031,
            92799884,
            92800952,
            92799036,
            92800270,
            92799895,
            92801328,
            92799861,
            92800242,
            92800050,
            92800040,
            92801512
        ],
        "D": [
            92806930,
            92847621,
            92803255,
            92806570,
            92812108,
            92817724,
            92809504,
            92885678,
            92808863,
            92812638,
            92810774,
            92842221,
            92815078,
            92815207,
            92817058,
            92813567,
            92813334,
            92817631,
            92827883,
            92813906,
            92816619,
            92816135,
            92820186
        ],
        "E": [
            92805758,
            92809090,
            92809687,
            92815513,
            92824046,
            92816662,
            92885694,
            92814615,
            92816908,
            92930467,
            92820677,
            92822734,
            92822919,
            92819310,
            92822831,
            92824275,
            92815296,
            92836469,
            92823732,
            92819866,
            92826009
        ],
        "C": [
            92798839,
            92798564,
            92801110,
            92802769,
            92810140,
            92803375,
            92885666,
            92803075,
            92805736,
            92801242,
            92805901,
            92804239,
            92807896,
            92805622,
            92804878,
            92809071,
            92805265,
            92806697,
            92803772,
            92811897,
            92812555
        ],
        "B": [
            92797501,
            92797816,
            92799405,
            92798968,
            92805443,
            92800263,
            92885648,
            92799516,
            92803590,
            92799029,
            92802282,
            92800352,
            92804945,
            92826085,
            92800306,
            92804932,
            92801700,
            92803543,
            92799506,
            92808871,
            92806614
        ]
    },
    "name": "E. Expected Damage",
    "statement": "You are playing a computer game. In this game, you have to fight n\r\nmonsters.To defend from monsters, you need a shield. Each shield has two\r\nparameters: its current durability a and its defence rating b. Each\r\nmonster has only one parameter: its strength d.When you fight a monster\r\nwith strength d while having a shield with current durability a and\r\ndefence b, there are three possible outcomes: if a = 0, then you receive\r\nd damage; if a > 0 and d\r\nge b, you receive no damage, but the current durability of the shield\r\ndecreases by 1; if a > 0 and d < b, nothing happens. The i-th monster\r\nhas strength d_i, and you will fight each of the monsters exactly once,\r\nin some random order (all n! orders are equiprobable). You have to\r\nconsider m different shields, the i-th shield has initial durability a_i\r\nand defence rating b_i. For each shield, calculate the expected amount\r\nof damage you will receive if you take this shield and fight the given n\r\nmonsters in random order.\r\n",
    "solutions": [
        "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\n\nconst int N=200005,p=998244353;\n\nstruct xay{int a,b,id;}a[N];\n\nint d[N],ans[N];\nint n,m,allsum;\n\nbool cmp(xay a,xay b){return a.b>b.b;}\n\nint fpow(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1)ans=1ll*ans*x%p;\n\t\ty>>=1;x=1ll*x*x%p;\n\t}\n\treturn ans;\n}\n\nsigned main(){\n\trd(n);rd(m);\n\trep(i,1,n)rd(d[i]),allsum=(allsum+d[i])%p;\n\trep(i,1,m)rd(a[i].a),rd(a[i].b),a[i].id=i;\n\tsort(d+1,d+n+1);reverse(d+1,d+n+1);sort(a+1,a+n+1,cmp);\n\tint pos=1,sum=0;\n\trep(i,1,m){\n\t\twhile(pos<=n&&d[pos]>=a[i].b)sum=(sum+d[pos])%p,++pos;\n\t\tif(pos-1>=a[i].a)ans[a[i].id]=(1ll*sum*fpow(pos-1,p-2)%p*(pos-1-a[i].a)%p+1ll*(allsum-sum+p)*fpow(pos,p-2)%p*(pos-a[i].a)%p)%p;\n\t}\n\trep(i,1,m)pt(ans[i],'\\n');\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "probabilities"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Expected Damage.json",
    "editorial_link": "https://codeforces.com//blog/entry/82673",
    "editorial": "First of all, let\u00e2\u0080\u0099s find a solution in . We will use the lineriality of\r\nexpectation: the answer for some shield is equal to , where is the\r\nprobability that the monster will deal damage if we use the -th shield.\r\nLet\u00e2\u0080\u0099s see how to calculate .Consider a monster such that . To deal\r\ndamage, he should be preceded by at least other monsters having . We can\r\nwrite a complicated formula with binomial coefficients to calculate the\r\nprobability of this happening, and then simplify it, but a much easier\r\nsolution is to consider the order of these \"strong\" monsters. Suppose\r\nthere are of them, then there are strong monsters that will deal damage.\r\nSince all orderings are equiprobable, the probability that our fixed\r\nmonster will deal damage is since it is the probability that it will\r\ntake one of the last places in the order.Okay, what about \"weak\"\r\nmonsters? It turns out that we can use the same approach: to deal\r\ndamage, a weak monster should be preceded by at least strong monsters.\r\nConsider the relative order of strong monsters and that weak monster we\r\nare analyzing. There are positions where the weak monster will deal\r\ndamage, so the probability of weak monster dealing damage is .Okay, we\r\ngot a solution in . How to make it faster? Whenever we consider a\r\nshield, all monsters are split into two types: strong and weak, and we\r\nmay sort the monsters beforehand, so the number of strong monsters (and\r\ntheir total strength) can be found with binary search. Since the\r\nprobabilities for all strong monsters are the same, we can multiply\r\ntheir total strength by the probability that one fixed strong monster\r\nwill deal damage (we already described how to calculate it). The same\r\napplies for the weak monsters, so the total complexity is .\r\n"
}