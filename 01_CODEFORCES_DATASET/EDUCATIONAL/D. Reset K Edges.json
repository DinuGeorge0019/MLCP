{
    "link": "https://codeforces.com//contest/1739/problem/D",
    "problemId": "1559866",
    "problem_idx": "D",
    "shortId": "1739D",
    "contest_number": "1739",
    "problem_submissions": {
        "F": [
            173982711,
            173969607,
            173981022,
            173986288,
            173992146,
            173980539,
            173991072,
            173980378,
            173978555,
            174245795,
            174000933,
            173993564,
            173995270,
            173994662,
            173995645,
            173994787,
            173991035,
            173995175,
            173975986,
            173996342,
            173995107,
            173986566
        ],
        "E": [
            173962909,
            173976378,
            173969496,
            173967080,
            173967227,
            173969366,
            173969799,
            173988104,
            173970277,
            173983172,
            173983299,
            173978308,
            173974083,
            173979712,
            173983159,
            173980060,
            173986740,
            173979502,
            173967920
        ],
        "D": [
            173953446,
            173954284,
            173959501,
            173953114,
            173950233,
            173963545,
            173960383,
            173950745,
            173966040,
            173950883,
            173962543,
            173951795,
            173957703,
            173966024,
            173951939,
            173967693,
            173958723,
            173974529,
            173956732
        ],
        "C": [
            173946487,
            173945498,
            173949713,
            174075655,
            174075624,
            173946209,
            173940986,
            173958498,
            173954556,
            173955135,
            173961377,
            173958964,
            173957077,
            173960274,
            173951680,
            173958743,
            173985617,
            173961155,
            173949432,
            173968872,
            173953205
        ],
        "B": [
            173936382,
            173937044,
            173937069,
            173935458,
            173935314,
            173943298,
            173937530,
            173935389,
            173954918,
            173937400,
            173937767,
            173940608,
            173940106,
            173945520,
            173936795,
            173941470,
            173938759,
            173964539,
            173936543
        ],
        "A": [
            173934470,
            173935151,
            173934498,
            173934222,
            173934344,
            173939803,
            173934700,
            173934286,
            173952986,
            173934928,
            173934527,
            173936084,
            173935340,
            173938305,
            173937802,
            173937555,
            173935130,
            173963081,
            173934367
        ]
    },
    "name": "D. Reset K Edges",
    "statement": "You are given a rooted tree, consisting of n vertices. The vertices are\r\nnumbered from 1 to n, the root is the vertex 1.You can perform the\r\nfollowing operation k times: choose an edge (v, u) of the tree such that\r\nv is a parent of u; remove the edge (v, u); add an edge (1, u) (i. e.\r\nmake u with its subtree a child of the root). of a tree is the maximum\r\ndepth of its vertices, and the depth of a vertex is the number of edges\r\non the path from the root to it. For example, the depth of vertex 1 is\r\n0, since it’s the root, and the depth of all its children is 1.What’s\r\nthe smallest height of the tree that can be achieved?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while (tt--) {\n        int n, k;\n        cin >> n >> k;\n        vector<vector<int>> g(n);\n        for (int i = 1; i < n; i++) {\n            int j;\n            cin >> j;\n            j--;\n            g[j].emplace_back(i);\n        }\n        int low = 0, high = n;\n        while (high - low > 1) {\n            int mid = (high + low) >> 1;\n            int need = 0;\n            function<int(int, int)> Dfs = [&](int v, int p) {\n                int a = 0;\n                for (int to : g[v]) {\n                    a = max(a, Dfs(to, v));\n                }\n                a++;\n                if (v != 0 && p != 0 && a >= mid) {\n                    need++;\n                    return 0;\n                }\n                return a;\n            };\n            Dfs(0, -1);\n            if (need <= k) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        cout << high << '\\n';\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "graphs",
        "greedy",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Reset K Edges.json",
    "editorial_link": "https://codeforces.com//blog/entry/107461",
    "editorial": "Start with the following. Letâs look at the input format and consider\r\nwhat the operation actually does to it. Since it only changes the parent\r\nof some vertex, it modifies only one value in it. Moreover, it just\r\nassigns it to . Thus, the goal is to assign at most values of parents to\r\nto minimize the resulting height of the tree.In particular, that implies\r\nthat we can freely rearrange the operations, since the assignments donât\r\ndepend on each other.One more conclusion. Imagine we have already built\r\nsome answer. One by one, we moved some subtrees to be children of the\r\nroot. It could happen that we first moved some subtree of a vertex and\r\nthen applied the operation to an edge inside the subtree of . Letâs show\r\nthat itâs always possible to rearrange the operations in the answer to\r\navoid that. Just apply the operations in order of decreasing the depth\r\nof the vertex .If we knew what height we want to get, we could have been\r\nmaking sure that cut subtree has height at most (since it gets increased\r\nby when glueing it to the root), then pretending that that subtree\r\ndoesnât exist anymore.Moreover, itâs always required to cut subtrees\r\nwith height at most . If you cut a higher subtree, then the answer canât\r\nbe smaller than , since we rearranged the operation to not touch that\r\nsubtree anymore.Well, letâs fix that height if we wanted that. Letâs try\r\nthe solve the opposite problem. How many operations will it require to\r\nmake the tree height at most ? Obviously, the values for this problem\r\nare non-increasing the greater we allow the height to be, the less\r\noperations it will require. Thus, we will be able to apply binary search\r\nto it to find the smallest height we can achieve with at most\r\noperations.Now we want to be choosing the subtrees of height at most\r\nrepeatedly and cutting them off until the height of the tree becomes at\r\nmost .Letâs think greedily. If the height of the tree is not at most\r\nyet, then there exists a vertex with the depth greater than . Letâs look\r\nat the deepest of them. That leaf has to be cut in some subtree.\r\nOtherwise, the tree wonât become any less higher. What subtree is the\r\nbest for it? What options do we have? That vertex itself and all its\r\nparents up until above. Itâs always optimal to cut the highest of them\r\nthe -st parent, since it will remove at least all the vertices of any\r\nother cut and some other vertices along with them. Itâs also always\r\npossible to remove the -st parent, since it will always have height\r\nexactly . The vertex we are looking at is the deepest in the entire tree\r\nthere are no deeper vertices in the subtree of the -st parent.Thus, the\r\nstrategy is to keep cutting the -st parent of the deepest vertex until\r\nthe tree becomes at most height.Now about the implementation\r\ndetails.First, we can process the vertices from the deepest upwards in\r\ntheir order in the original tree. The operation only removes some\r\nvertices but doesnât change the depth of the remaining ones. For\r\nexample, you can do a bfs from the root to find the order.Now the -st\r\nparent. Letâs find it for each vertex before starting the process. Run a\r\ndfs and maintain the stack of the ascendants. When going down the child,\r\nappend it to the stack. What exiting, pop from the stack. Now you can\r\njust look at the -st element from the top of the stack. To be able to do\r\nthat, simulate the stack with a vector (C++) or a list (Python).Finally,\r\nwe would have to determine if the current vertex in the order is removed\r\nor not. For that, we could maintain a boolean array for the removed\r\nvertices. Once you apply the operation, run the dfs from the removed\r\nvertex and mark all the newly removed descendants of it in . If you\r\ndonât go into already marked vertices, there will be no more than calls\r\nof the dfs.The number of cut vertices is the answer for the fixed height\r\n.Overall complexity: per testcase.\r\n",
    "hint": []
}