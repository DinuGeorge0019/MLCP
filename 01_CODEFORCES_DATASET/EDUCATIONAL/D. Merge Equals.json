{
    "link": "https://codeforces.com//contest/962/problem/D",
    "problemId": "173205",
    "problem_idx": "D",
    "shortId": "962D",
    "contest_number": "962",
    "problem_submissions": {
        "G": [
            37172159,
            83380479,
            37224207
        ],
        "F": [
            37161607,
            37156639,
            37157368,
            37160858,
            37168373,
            37163241,
            37162662,
            37165808,
            37164621,
            37171463,
            37169577,
            37166104,
            37163342,
            37173342,
            37165989,
            37161726,
            37173135,
            37178620
        ],
        "E": [
            37153541,
            37151735,
            37153606,
            37152970,
            37152043,
            37166043,
            37160792,
            37170495,
            37160553,
            37168665,
            37158596,
            37163761,
            37162634,
            37170755,
            37158513,
            37157137,
            37165223,
            37172878,
            37170948,
            37159083,
            37152437
        ],
        "D": [
            37152390,
            37151214,
            37151627,
            37153937,
            37156427,
            37155745,
            37155575,
            37154679,
            37154153,
            37157155,
            37157760,
            37157154,
            37160470,
            37158892,
            37157799,
            37158412,
            37156233,
            37151441
        ],
        "C": [
            37150680,
            37149822,
            37150471,
            37152075,
            37154129,
            37152922,
            37153000,
            37151382,
            37151999,
            37153115,
            37152133,
            37154853,
            37152337,
            37154136,
            37153887,
            37154222,
            37150166
        ],
        "B": [
            37148859,
            37148433,
            37150807,
            37150329,
            37150353,
            37151339,
            37150005,
            37149509,
            37149604,
            37150809,
            37150669,
            37150725,
            37163838,
            37150528,
            37151572,
            37173974,
            37149032
        ],
        "A": [
            37147366,
            37147343,
            37147362,
            37147371,
            37147659,
            37147394,
            37147434,
            37147365,
            37147570,
            37147605,
            37147447,
            37147530,
            37147430,
            37147619,
            37147410,
            37174371,
            37147400
        ]
    },
    "name": "D. Merge Equals",
    "statement": "You are given an array of positive integers. While there are at least\r\ntwo equal elements, we will perform the following operation. We choose\r\nthe smallest value x that occurs in the array 2 or more times. Take the\r\nfirst two occurrences of x in this array (the two leftmost occurrences).\r\nRemove the left of these two occurrences, and the right one is replaced\r\nby the sum of this two values (that is, 2\r\ncdot x).Determine how the array will look after described operations are\r\nperformed.For example, consider the given array looks like [3, 4, 1, 2,\r\n2, 1, 1]. It will be changed in the following way: [3, 4, 1, 2, 2, 1,\r\n1]\u00a0\r\nrightarrow\u00a0[3, 4, 2, 2, 2, 1]\u00a0\r\nrightarrow\u00a0[3, 4, 4, 2, 1]\u00a0\r\nrightarrow\u00a0[3, 8, 2, 1].If the given array is look like [1, 1, 3, 1, 1]\r\nit will be changed in the following way: [1, 1, 3, 1, 1]\u00a0\r\nrightarrow\u00a0[2, 3, 1, 1]\u00a0\r\nrightarrow\u00a0[2, 3, 2]\u00a0\r\nrightarrow\u00a0[3, 4].\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<double,double> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\nint n;\nmap<ll,set<int>> m;\nset<pl> en;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n; \n    vi a(n);\n    F0R(i,n) {\n        cin >> a[i]; \n        m[a[i]].insert(i);\n    }\n    while (sz(m)) {\n        auto a = *m.begin(); m.erase(m.begin());\n        while (sz(a.s) >= 2) {\n            a.s.erase(a.s.begin());\n            m[2*a.f].insert(*a.s.begin());\n            a.s.erase(a.s.begin());\n        }\n        if (sz(a.s) == 1) en.insert({*a.s.begin(),a.f});\n    }\n    cout << sz(en) << \"\\n\";\n    for (auto a: en) cout << a.s << \" \";\n}\n\n// read the question correctly (is y a vowel?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Merge Equals.json",
    "editorial_link": "https://codeforces.com//blog/entry/58869",
    "editorial": "To solve this problem we should use a set of pairs, let\u00e2\u0080\u0099s call it . We\r\nwill store in it all the elements of the current array (the first number\r\nin the pair)and the positions of these elements in the current array\r\n(the second number in the pair). The first elements of pairs should have\r\ntype , because the result of merging the array elements can become large\r\nand the type will overflow.Initially, you need to put in all elements of\r\nthe given array with their positions.While there are elements in , we\r\nwill perform the following algorithm. Let be a pair in the beginning of\r\n. Then look at the next element of . If it does not exist, the algorithm\r\nis complete. Otherwise, let the next element is equal to .If , then\r\nthere is no pair number for the element , which is in the position , and\r\nit will never appear, because all elements can only increase. So, remove\r\nfrom and repeat the algorithm from the beginning.Otherwise, the number\r\nat the position will be deleted, and the number in the position will be\r\ndouble up. So, remove and from , put in and repeat the algorithm from\r\nthe beginning. For the convenience of restoring the answer, you can mark\r\ndeleted positions of the given array in an additional array, so, in this\r\ncase you need to mark as a deleted position.\r\n"
}