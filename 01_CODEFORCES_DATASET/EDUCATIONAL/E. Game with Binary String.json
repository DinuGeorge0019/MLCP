{
    "link": "https://codeforces.com//contest/2070/problem/E",
    "problemId": "3233354",
    "problem_idx": "E",
    "shortId": "2070E",
    "contest_number": "2070",
    "problem_submissions": {
        "F": [
            308138412,
            308139598,
            308140261,
            308135086,
            308908838,
            308908402,
            308148058,
            308132721,
            308156502,
            308160384,
            308171018,
            308167755,
            308165459,
            308169840,
            308157047,
            308169763,
            308168481,
            308160062,
            308168693,
            308165415,
            308163695,
            308171178,
            308169858,
            308170143,
            308112373,
            308154384
        ],
        "E": [
            308118136,
            308123977,
            308115696,
            308119993,
            308121221,
            308160669,
            308139138,
            308136015,
            308135014,
            308127816,
            308146323,
            308144103,
            308131271,
            308145219,
            308126468,
            308144951,
            308131787,
            308146433,
            308129269,
            308170336
        ],
        "D": [
            308106225,
            308103599,
            308103669,
            308108885,
            308112445,
            308106317,
            308115443,
            308108990,
            308111970,
            308115191,
            308111541,
            308110510,
            308111609,
            308122150,
            308114708,
            308128882,
            308117643,
            308118502,
            308133018,
            308115402
        ],
        "C": [
            308100859,
            308098324,
            308098879,
            308109896,
            308106577,
            308101095,
            308107090,
            308102322,
            308104592,
            308108143,
            308104331,
            308111140,
            308106216,
            308114471,
            308109710,
            308123284,
            308111358,
            308110052,
            308140320,
            308124878
        ],
        "B": [
            308096187,
            308093094,
            308093408,
            308096114,
            308095735,
            308094203,
            308101217,
            308098141,
            308098911,
            308093342,
            308098262,
            308097763,
            308099852,
            308108770,
            308099377,
            308099819,
            308097452,
            308104146,
            308143559,
            308098413
        ],
        "A": [
            308091489,
            308091216,
            308091213,
            308091721,
            308091212,
            308091326,
            308095453,
            308091596,
            308092398,
            308091301,
            308091697,
            308091411,
            308091275,
            308091454,
            308091384,
            308091843,
            308091304,
            308091461,
            308145036,
            308091695
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140146",
    "editorial": "First, we need to modify the game a bit. Suppose that, instead of\r\nremoving two characters, a player can remove pair of characters of the\r\nrequired type. So, the first player can remove any two characters equal\r\nto ; the second player can remove any two characters, at least one of\r\nwhich is . Now the order of characters does not matter, only their\r\nquantities. Let be the number of ’s in the string, be the number of\r\n’s.It’s pretty obvious that in this version of the game, the second\r\nplayer should always remove one and one , if it is possible (and only if\r\nthere are no ’s, remove two ’s). So, after each pair of moves, one and\r\nthree ’s are removed.Suppose that the length of the string is divisible\r\nby . Then, if , the game lasts until the whole string is removed, and\r\nthe first player loses. If , the first player runs out of moves before\r\nthe second, and if , the second player runs out of moves first. So, if\r\nthe length of the string is divisible by , the first player wins iff .If\r\nthe length of the string is not divisible by , then we can derive a\r\nsimilar condition, but it will depend on the remainder of the length\r\nmodulo . For example, let’s derive a condition for the case when the\r\nlength is equal to modulo . We need to derive a threshold like \"if , the\r\nfirst player wins, otherwise the second player wins\".Suppose we made\r\nmoves for both players. Then we have removed some characters equal to\r\nand characters equal to . If the resulting string has at least\r\ncharacters equal to , then the first player wins, otherwise the second\r\nplayer wins. So, if or , then the first player wins. We can rewrite this\r\ncondition to : if it is met, then the first player wins (either the\r\nstring gets reduced to size and the first player can make a move, or the\r\nsecond player runs out of ’s before that).We can derive similar\r\nconditions for and . All of them have the form , where is some constant\r\ndepending on . You can either derive them analytically, or write a\r\ndynamic programming to check all strings with length and derive this\r\nconstant for every remainder from this dynamic programming.The only\r\nissue is that we have allowed the players to take non-adjacent\r\ncharacters. For the second player, it does not matter: that player\r\nalways wants to take one and one , and if there are at least one pair of\r\ndifferent characters in the string, there is at least one substring or .\r\nHowever, for the first player, this might be an issue: we have allowed\r\nto remove two characters equal to even if there is no substring .We can\r\nprove that the result of the game does not depend on it. If the first\r\nplayer cannot make a move according to the rules of the original game\r\n(there is no substring , and either the first or the last character is\r\n), then . And since every pair of moves removes three ’s and one , the\r\nfirst player will run out of moves before the second player even if the\r\nfirst player is allowed to remove non-adjacent character.Okay, now the\r\nproblem reduces to the following: for every remainder of length modulo ,\r\nthere is some constant , and we have to calculate the number of\r\nsubstrings such that: ; in , . Let’s replace every character with the\r\ninteger , and every character with the integer . Then, the condition\r\nmeans that , where is the sum on segment of the resulting array. To\r\ncalculate the number of such subarrays efficiently, we can build the\r\nprefix sums over the array (let the sum of first elements be ), and\r\nrewrite this condition as .Let’s go through prefix sums from left to\r\nright and maintain four data structures , where stores the sums on\r\nprefixes we met earlier such that . When we process the prefix , for\r\neach of these data structures , we need to calculate the number of\r\nvalues in it such that , or . Then, we need to add into the data\r\nstructure .Which data structure we need? It should support operations\r\nlike \"insert an element\" and \"get the number of elements less than some\r\nvalue \". You can use something like an order statistics tree, a Fenwick\r\ntree or a Segment tree. Note that you have to insert negative elements\r\nup to , so if you use a Fenwick tree or a Segment tree, you should add\r\nto all values you insert there.This solution works in . You can actually\r\nspeed this up by merging these data structures into one and/or getting\r\nrid of the altogether using the fact that every next query you make is\r\npretty close to the previous query, but this was not needed.\r\n",
    "name": "E. Game with Binary String",
    "statement": "Consider the following game. Two players have a binary string (a string\r\nconsisting of characters and/or ). The players take turns, the first\r\nplayer makes the first turn. During a player’s turn, he or she has to\r\nchoose exactly two adjacent elements of the string and remove them ().\r\nFurthermore, there are additional constraints depending on who makes the\r\nmove: if it’s the first player’s move, chosen characters should be ; if\r\nit’s the second player’s move, of the chosen characters should be . The\r\nplayer who can’t make a valid move loses the game. This also means that\r\nif the string currently has less than 2 characters, the current player\r\nloses the game.You are given a binary string s of length n. You have to\r\ncalculate the number of its substrings such that, if the game is played\r\non that substring and both players make optimal decisions, the first\r\nplayer wins. In other words, calculate the number of pairs (l, r) such\r\nthat 1\r\nle l\r\nle r\r\nle n and the first player has a winning strategy on the string s_l\r\ns_{l+1}\r\ndots s_r.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "divide and conquer",
        "games",
        "greedy",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Game with Binary String.json"
}