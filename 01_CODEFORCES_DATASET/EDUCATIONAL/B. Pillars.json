{
    "link": "https://codeforces.com//contest/1197/problem/B",
    "problemId": "376703",
    "problem_idx": "B",
    "shortId": "1197B",
    "contest_number": "1197",
    "problem_submissions": {
        "E": [
            57531154,
            57527419,
            57524743,
            57530013,
            57536981,
            57526074,
            57537246,
            57517565,
            57532671,
            57531296,
            57535739,
            57533494,
            57533139,
            57532015,
            57531974,
            57534465,
            57537214,
            57536595,
            57532983,
            57537941
        ],
        "F": [
            57526205,
            57536510,
            57543227,
            57542356,
            57545070,
            57550429,
            57543354,
            57546681,
            57528127,
            57549295,
            57552678,
            57550308,
            57548615,
            57551319,
            57581907,
            57549488,
            57548121,
            57552168,
            57768625,
            57596008
        ],
        "D": [
            57517769,
            57521167,
            57531349,
            57521225,
            57523524,
            57536466,
            57530751,
            57531287,
            57521039,
            57522693,
            57521081,
            57524029,
            57524614,
            57523599,
            57524677,
            65550218,
            65550195,
            57524514,
            57523363,
            57524805,
            57525867,
            57524276
        ],
        "C": [
            57514645,
            57521161,
            57515560,
            57517240,
            57519467,
            57517149,
            57517926,
            57531832,
            57516648,
            57519324,
            57516744,
            57516779,
            57517866,
            57515185,
            57519335,
            57518781,
            57516998,
            57518983,
            57516506,
            57517063
        ],
        "B": [
            57513686,
            57521152,
            57513883,
            57515172,
            57516705,
            57515562,
            57515187,
            57532696,
            57515047,
            57517088,
            57514854,
            57515032,
            57514991,
            57513966,
            57514537,
            57515780,
            57514347,
            57514964,
            57514669,
            57515319
        ],
        "A": [
            57513085,
            57521143,
            57513101,
            57513203,
            57513756,
            57513671,
            57513230,
            57532141,
            57513274,
            57513512,
            57513153,
            57513271,
            57513173,
            57513091,
            57513126,
            57513220,
            57513223,
            57513310,
            57513141,
            57513251
        ]
    },
    "name": "B. Pillars",
    "statement": "There are n pillars aligned in a row and numbered from 1 to n.Initially\r\neach pillar contains exactly one disk. The i-th pillar contains a disk\r\nhaving radius a_i.You can move these disks from one pillar to another.\r\nYou can take a disk from pillar i and place it on top of pillar j if all\r\nthese conditions are met: there is no other pillar between pillars i and\r\nj. Formally, it means that |i - j| = 1; pillar i contains one disk;\r\neither pillar j contains no disks, or the topmost disk on pillar j has\r\nradius strictly greater than the radius of the disk you move. When you\r\nplace a disk on a pillar that already has some disks on it, you put the\r\nnew disk on top of previously placed disks, so the new disk will be used\r\nto check the third condition if you try to place another disk on the\r\nsame pillar.You may take any disk and place it on other pillar any\r\nnumber of times, provided that every time you do it, all three\r\naforementioned conditions are met. Now you wonder, is it possible to\r\nplace all n disks on the same pillar simultaneously?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nint n;\nint a[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tint m = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tif (a[i] > a[m])\n\t\t\tm = i;\n\tfor (int i = m; i > 0; i--) {\n\t\tif (a[i] < a[i - 1]) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = m; i < n - 1; i++) {\n\t\tif (a[i] < a[i + 1]) {\n\t\t\tprintf(\"NO\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"YES\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Pillars.json",
    "editorial_link": "https://codeforces.com/blog/entry/68615",
    "editorial": "Suppose we have a disk that is smaller than both of its neighbours. Then\r\nitâs impossible to collect all the disks on the same pillar: eventually\r\nwe will put this disk on the same pillar with one of its neighbours, and\r\nthen we canât put the other neighbouring disk on the same pillar since\r\nit is greater than the middle disk.Okay, and what if there is no disk\r\nthat is strictly smaller than both of its neighbours? Let be the index\r\nof the largest disk. , that implies , and so on. , , and so on. It means\r\nthat the array is sorted in ascending until the index , and after that\r\nit is sorted in descending order. If this condition is met, then we can\r\ncollect all the disks on the pillar one by one, starting with the disk\r\nhaving radius and ending with the disk having radius .So the only thing\r\nthat we need to check is the following condition: array is sorted in\r\nascending order until , and then it is sorted in descending order.\r\n",
    "hint": []
}