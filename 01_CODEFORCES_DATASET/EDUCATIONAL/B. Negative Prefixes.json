{
    "link": "https://codeforces.com//contest/1418/problem/B",
    "problemId": "727424",
    "problem_idx": "B",
    "shortId": "1418B",
    "contest_number": "1418",
    "problem_submissions": {
        "F": [
            92827621,
            92992766,
            92847130,
            92847007,
            92846498,
            92840659,
            92838710,
            92837329,
            92835778,
            92821703,
            92839298,
            92833921,
            92885700,
            92870799,
            92830172,
            92989347,
            92845726
        ],
        "G": [
            92817256,
            93890104,
            93890054,
            93890004,
            93889956,
            93889783,
            93889650,
            93889392,
            93889084,
            93888189,
            93888010,
            93887834,
            93887831,
            93887519,
            93887334,
            93887004,
            93839244,
            93839240,
            93839237,
            93835786,
            93835763,
            93835704,
            93828053,
            93828000,
            92855419,
            92854972,
            92815447,
            92815164,
            92824652,
            92823576,
            92837977,
            92824758,
            92885721,
            92823789,
            92823462,
            92820493,
            92830232,
            93485501,
            92866692,
            92833116,
            92832754,
            92824217,
            92833610,
            92830510,
            92833625,
            92828988,
            92837204,
            92830405,
            92834428
        ],
        "A": [
            92809737,
            92851684,
            92804370,
            92802575,
            92799307,
            92799729,
            92800647,
            92885635,
            92800218,
            92800425,
            92802031,
            92799884,
            92800952,
            92799036,
            92800270,
            92799895,
            92801328,
            92799861,
            92800242,
            92800050,
            92800040,
            92801512
        ],
        "D": [
            92806930,
            92847621,
            92803255,
            92806570,
            92812108,
            92817724,
            92809504,
            92885678,
            92808863,
            92812638,
            92810774,
            92842221,
            92815078,
            92815207,
            92817058,
            92813567,
            92813334,
            92817631,
            92827883,
            92813906,
            92816619,
            92816135,
            92820186
        ],
        "E": [
            92805758,
            92809090,
            92809687,
            92815513,
            92824046,
            92816662,
            92885694,
            92814615,
            92816908,
            92930467,
            92820677,
            92822734,
            92822919,
            92819310,
            92822831,
            92824275,
            92815296,
            92836469,
            92823732,
            92819866,
            92826009
        ],
        "C": [
            92798839,
            92798564,
            92801110,
            92802769,
            92810140,
            92803375,
            92885666,
            92803075,
            92805736,
            92801242,
            92805901,
            92804239,
            92807896,
            92805622,
            92804878,
            92809071,
            92805265,
            92806697,
            92803772,
            92811897,
            92812555
        ],
        "B": [
            92797501,
            92797816,
            92799405,
            92798968,
            92805443,
            92800263,
            92885648,
            92799516,
            92803590,
            92799029,
            92802282,
            92800352,
            92804945,
            92826085,
            92800306,
            92804932,
            92801700,
            92803543,
            92799506,
            92808871,
            92806614
        ]
    },
    "name": "B. Negative Prefixes",
    "statement": "You are given an array a, consisting of n integers.Each position i (1\r\nle i\r\nle n) of the array is either locked or unlocked. You can take the values\r\non the unlocked positions, rearrange them in any order and place them\r\nback into the unlocked positions. You are not allowed to remove any\r\nvalues, add the new ones or rearrange the values on the locked\r\npositions. You are allowed to leave the values in the same order as they\r\nwere.For example, let a = [-1, 1,\r\nunderline{3}, 2,\r\nunderline{-2}, 1, -4,\r\nunderline{0}], the underlined positions are locked. You can obtain the\r\nfollowing arrays: [-1, 1,\r\nunderline{3}, 2,\r\nunderline{-2}, 1, -4,\r\nunderline{0}]; [-4, -1,\r\nunderline{3}, 2,\r\nunderline{-2}, 1, 1,\r\nunderline{0}]; [1, -1,\r\nunderline{3}, 2,\r\nunderline{-2}, 1, -4,\r\nunderline{0}]; [1, 2,\r\nunderline{3}, -1,\r\nunderline{-2}, -4, 1,\r\nunderline{0}]; and some others. Let p be a sequence of prefix sums of\r\nthe array a after the rearrangement. So p_1 = a_1, p_2 = a_1 + a_2, p_3\r\n= a_1 + a_2 + a_3,\r\ndots, p_n = a_1 + a_2 +\r\ndots + a_n.Let k be the maximum j (1\r\nle j\r\nle n) such that p_j < 0. If there are no j such that p_j < 0, then k =\r\n0.Your goal is to rearrange the values in such a way that k is minimum\r\npossible.Output the array a after the rearrangement such that the value\r\nk for it is minimum possible. If there are multiple answers then print\r\nany of them.\r\n",
    "solutions": [
        "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\n\nint a[105],l[105];\nint T,n;\n\nsigned main(){\n\trd(T);\n\twhile(T--){\n\t\trd(n);\n\t\trep(i,1,n)rd(a[i]);\n\t\tVI now;\n\t\trep(i,1,n){\n\t\t\trd(l[i]);\n\t\t\tif(!l[i])now.PB(a[i]);\n\t\t}\n\t\tsort(ALL(now));reverse(ALL(now));\n\t\tint pos=0;\n\t\trep(i,1,n){\n\t\t\tif(!l[i]){\n\t\t\t\ta[i]=now[pos];\n\t\t\t\t++pos;\n\t\t\t}\n\t\t}\n\t\trep(i,1,n)pt(a[i],i==n?'\\n':' ');\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Negative Prefixes.json",
    "editorial_link": "https://codeforces.com//blog/entry/82673",
    "editorial": "Letâs collect the prefix sums of the initial array . How do they change\r\nif you swap two values in the array? Letâs swap values on positions and\r\n(). Prefix sums from to arenât changed. Prefix sums from to are\r\nincreased by (note that if then these sums become smaller). Finally,\r\nprefix sums from to arenât changed as well.Thus, swapping two values\r\nwill only increase some prefix sums but never decrease any of them.That\r\nhelps us see that the array such that all values on the unlocked\r\npositions are sorted in a non-increasing order is the most optimal one.\r\nOverall complexity: per testcase.\r\n",
    "hint": []
}