{
    "link": "https://codeforces.com//contest/1555/problem/F",
    "problemId": "1062145",
    "problem_idx": "F",
    "shortId": "1555F",
    "contest_number": "1555",
    "problem_submissions": {
        "F": [
            124306614,
            124343856,
            124312339,
            124307563,
            124318196,
            124319806,
            124318258,
            124337936,
            124326369,
            124312719,
            124312071,
            124325220,
            124322375,
            124337491,
            124327796,
            124313538,
            124320609,
            124319069,
            124334134
        ],
        "E": [
            124292614,
            124284546,
            124290978,
            124299668,
            124299626,
            124301534,
            124305345,
            124311168,
            124315291,
            124304878,
            124305598,
            124300363,
            124304344,
            124324832,
            124306310,
            124305064,
            124305374
        ],
        "C": [
            124284989,
            124280595,
            124283283,
            124284609,
            124285731,
            124291694,
            124283589,
            124282860,
            124292981,
            124286855,
            124287174,
            124284102,
            124289820,
            124283315,
            124290207,
            124292792,
            124290345
        ],
        "D": [
            124282896,
            124281706,
            124287585,
            124287694,
            124291470,
            124295363,
            124329814,
            124293642,
            124293299,
            124285216,
            124284331,
            124294215,
            124292885,
            124291338,
            124294163,
            124296113,
            124299446,
            124297892,
            124294376
        ],
        "B": [
            124280802,
            124279957,
            124281993,
            124281520,
            124282708,
            124281869,
            124281852,
            124283175,
            124289412,
            124282989,
            124282919,
            124281809,
            124286550,
            124291562,
            124286726,
            124289852,
            124285340
        ],
        "A": [
            124279594,
            124279557,
            124279608,
            124279611,
            124279723,
            124279607,
            124279587,
            124279711,
            124282014,
            124280166,
            124279749,
            124279696,
            124279824,
            124279602,
            124281131,
            124280445,
            124279990
        ]
    },
    "name": "F. Good Graph",
    "statement": "You have an undirected graph consisting of n vertices with weighted\r\nedges.A simple cycle is a cycle of the graph without repeated vertices.\r\nLet the of the cycle be the XOR of weights of edges it consists of.Let’s\r\nsay the graph is if all its cycles have weight 1. A graph is bad if it’s\r\nnot good.Initially, the graph is empty. Then q queries follow. Each\r\nquery has the next type: u v x add edge between vertices u and v of\r\nweight x if it doesn’t make the graph bad. For each query print, was the\r\nedge added or not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nstruct unionfind{\n\tvector<int> p;\n\tunionfind(int N){\n\t\tp = vector<int>(N, -1);\n\t}\n\tint root(int x){\n\t\tif (p[x] < 0){\n\t\t\treturn x;\n\t\t} else {\n\t\t\tp[x] = root(p[x]);\n\t\t\treturn p[x];\n\t\t}\n\t}\n\tbool same(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x != y){\n\t\t\tif (p[x] < p[y]){\n\t\t\t\tswap(x, y);\n\t\t\t}\n\t\t\tp[y] += p[x];\n\t\t\tp[x] = y;\n\t\t}\n\t}\n};\ntemplate <typename T>\nstruct lazy_segment_tree{\n\tint N;\n\tvector<T> ST;\n\tvector<T> lazy;\n\tlazy_segment_tree(){\n\t}\n\tlazy_segment_tree(int n){\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<T>(N * 2 - 1, 0);\n\t\tlazy = vector<T>(N * 2 - 1, -1);\n\t}\n\tvoid eval(int i, int l, int r){\n\t\tif (lazy[i] != -1){\n\t\t\tif (i < N - 1){\n\t\t\t\tlazy[i * 2 + 1] = lazy[i];\n\t\t\t\tlazy[i * 2 + 2] = lazy[i];\n\t\t\t}\n\t\t\tST[i] = lazy[i] * (r - l);\n\t\t\tlazy[i] = -1;\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x, int i, int l, int r){\n\t\teval(i, l, r);\n\t\tif (R <= l || r <= L){\n\t\t\treturn;\n\t\t} else if (L <= l && r <= R){\n\t\t\tlazy[i] = x;\n\t\t\teval(i, l, r);\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\trange_update(L, R, x, i * 2 + 1, l, m);\n\t\t\trange_update(L, R, x, i * 2 + 2, m, r);\n\t\t\tST[i] = ST[i * 2 + 1] + ST[i * 2 + 2];\n\t\t}\n\t}\n\tvoid range_update(int L, int R, T x){\n\t\trange_update(L, R, x, 0, 0, N);\n\t}\n\tT range_sum(int L, int R, int i, int l, int r){\n\t\teval(i, l, r);\n\t\tif (R <= l || r <= L){\n\t\t\treturn 0;\n\t\t} else if (L <= l && r <= R){\n\t\t\treturn ST[i];\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn range_sum(L, R, i * 2 + 1, l, m) + range_sum(L, R, i * 2 + 2, m, r);\n\t\t}\n\t}\n\tT range_sum(int L, int R){\n\t\treturn range_sum(L, R, 0, 0, N);\n\t}\n};\nstruct heavy_light_decomposition{\n  vector<int> p, sz, in, next;\n  lazy_segment_tree<int> ST;\n  heavy_light_decomposition(vector<int> &p, vector<vector<int>> &c): p(p){\n    int N = p.size();\n    sz = vector<int>(N);\n    dfs1(c);\n    in = vector<int>(N);\n    next = vector<int>(N, 0);\n    int t = 0;\n    dfs2(c, t);\n    ST = lazy_segment_tree<int>(N);\n  }\n  void dfs1(vector<vector<int>> &c, int v = 0){\n    sz[v] = 1;\n    for (int &w : c[v]){\n      dfs1(c, w);\n      sz[v] += sz[w];\n      if (sz[w] > sz[c[v][0]]){\n        swap(w, c[v][0]);\n      }\n    }\n  }\n  void dfs2(vector<vector<int>> &c, int &t, int v = 0){\n    in[v] = t;\n    t++;\n    for (int w : c[v]){\n      if (w == c[v][0]){\n        next[w] = next[v];\n      } else {\n        next[w] = w;\n      }\n      dfs2(c, t, w);\n    }\n  }\n  int lca(int u, int v){\n    while (true){\n      if (in[u] > in[v]){\n        swap(u, v);\n      }\n      if (next[u] == next[v]){\n        return u;\n      }\n      v = p[next[v]];\n    }\n  }\n  void path_update(int u, int v){\n    int w = lca(u, v);\n    while (next[u] != next[w]){\n      ST.range_update(in[next[u]], in[u] + 1, 1);\n      u = p[next[u]];\n    }\n    ST.range_update(in[w] + 1, in[u] + 1, 1);\n    while (next[v] != next[w]){\n      ST.range_update(in[next[v]], in[v] + 1, 1);\n      v = p[next[v]];\n    }\n    ST.range_update(in[w] + 1, in[v] + 1, 1);\n  }\n  int path_sum(int u, int v){\n    int w = lca(u, v);\n    int ans = 0;\n    while (next[u] != next[w]){\n      ans += ST.range_sum(in[next[u]], in[u] + 1);\n      u = p[next[u]];\n    }\n    ans += ST.range_sum(in[w] + 1, in[u] + 1);\n    while (next[v] != next[w]){\n      ans += ST.range_sum(in[next[v]], in[v] + 1);\n      v = p[next[v]];\n    }\n    ans += ST.range_sum(in[w] + 1, in[v] + 1);\n    return ans;\n  }\n};\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, q;\n  cin >> n >> q;\n  vector<int> a(q), b(q), x(q);\n  for (int i = 0; i < q; i++){\n    cin >> a[i] >> b[i] >> x[i];\n    a[i]--;\n    b[i]--;\n  }\n  unionfind UF(n);\n  vector<bool> tree(q, false);\n  vector<vector<pair<int, int>>> E(n);\n  for (int i = 0; i < q; i++){\n    if (!UF.same(a[i], b[i])){\n      UF.unite(a[i], b[i]);\n      tree[i] = true;\n      E[a[i]].push_back(make_pair(x[i], b[i]));\n      E[b[i]].push_back(make_pair(x[i], a[i]));\n    }\n  }\n  for (int i = 1; i < n; i++){\n    if (!UF.same(0, i)){\n      UF.unite(0, i);\n      E[0].push_back(make_pair(0, i));\n      E[i].push_back(make_pair(i, 0));\n    }\n  }\n  vector<int> p(n, -1);\n  vector<vector<int>> c(n);\n  vector<int> s(n, 0);\n  queue<int> Q;\n  Q.push(0);\n  while (!Q.empty()){\n    int v = Q.front();\n    Q.pop();\n    for (auto P : E[v]){\n      int w = P.second;\n      if (w != p[v]){\n        p[w] = v;\n        c[v].push_back(w);\n        s[w] = s[v] + P.first;\n        Q.push(w);\n      }\n    }\n  }\n  heavy_light_decomposition T(p, c);\n  vector<bool> ans = tree;\n  for (int i = 0; i < q; i++){\n    if (!tree[i]){\n      if ((s[a[i]] % 2 - s[b[i]] % 2 + 2 + x[i]) % 2 == 1){\n        if (T.path_sum(a[i], b[i]) == 0){\n          ans[i] = true;\n          T.path_update(a[i], b[i]);\n        }\n      }\n    }\n  }\n  for (int i = 0; i < q; i++){\n    if (ans[i]){\n      cout << \"YES\" << \"\\n\";\n    } else {\n      cout << \"NO\" << \"\\n\";\n    }\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Good Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/93389",
    "editorial": "Firstly, letâs prove that a good graph has one important property: any\r\ntwo of its simple cycles intersect by at most one vertex, i. e. there is\r\nno edge that belongs to more than one simple cycle (cactus definition,\r\nyeah).Letâs prove it by showing that if two simple cycles of weight\r\nintersects (by edges) then they will induce a simple cycle of weight .\r\nThere are two cases: if cycles intersect by a single path, then we can\r\ncreate a new cycle by merging parts of cycles excluding the intersecting\r\npath it will be simple and will have weight ; if cycles intersect by\r\nmore than one path, we can do the next transformation: suppose the\r\ncommon paths are , , , and they are ordered in the way how they lie on\r\nthe first cycle. Letâs create a third cycle using two paths from to :\r\nfrom the first cycle and from the second cycle. Itâs easy to see that\r\nthe third cycle is simple, and more over it has only one common path\r\nwith the second cycle. So, itâs either the third cycle has weight not\r\nequal to or the case . Okay, letâs analyze the edges we try to add.\r\nLetâs divide all edges in two types: edges and all other edges (we will\r\nname them edges). Letâs name an edge as a edge if it connects two\r\ndifferent components at a moment when we are trying to add it in the\r\ngraph.Itâs obvious that we will add all tree edges in the graph, since\r\nthey canât make it bad (since they donât induce new cycles). But there\r\nis a more interesting observation: when we try to add a cycle edge , it\r\nshould induce an only one simple cycle where all other edges are tree\r\nedges and these tree edges canât be used in any other cycle.It induces\r\nat least one \"all-tree-edge\" cycle, since and are already connected. It\r\ncanât induce more than one \"all-tree-edge\" cycle, since it contradicts\r\nwith definition, and if it induces a cycle with some other cycle edge,\r\nthen we can replace that cycle edge with its own tree-edge path: our\r\ncycle will become \"all-tree-edge\" cycle, but it will use already used\r\ntree edges. In other words, itâs enough to consider only one\r\n\"all-tree-edge\" cycle induced by any cycle edge.The final trick is to\r\ncalculate the answer in two steps: at the first step, we will find only\r\ntree edges (using DSU) that will form a spanning forest in our graph.The\r\nsecond step is for each cycle edge to calculate the on a path between\r\nand in our spanning forest, check that and check that none of edges on\r\nthe path from to are used in other cycle.Calculating is easy: if we\r\nprecalculate for each vertex the on path from to root then .Checking\r\nthat none of the edges are used on the path from to is a bit tricky: if\r\nwe mark an edge by adding to it, then we should be able to take a sum on\r\npath and add on path. There are structures that are capable of it (like\r\nHLD and other), but letâs look closely.Note that we mark each tree edge\r\nat most once, so we can manually add to each edge, and only asking sum\r\non path should be fast. In other words, we need a data structure (DS)\r\nthat can add value at edge and take the sum on path and such DS is a\r\nFenwick tree (BIT) built on Euler tour of tree: it can add value at edge\r\nand ask a sum on path from to root. So we need to find LCA as well,\r\nsince sum of path is equal to .As a result, complexity is with quite a\r\nlow constant from LCA and BIT.\r\n",
    "hint": []
}