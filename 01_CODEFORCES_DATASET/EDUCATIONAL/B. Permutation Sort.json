{
    "link": "https://codeforces.com//contest/1525/problem/B",
    "problemId": "987012",
    "problem_idx": "B",
    "shortId": "1525B",
    "contest_number": "1525",
    "problem_submissions": {
        "D": [
            116596850,
            116594983,
            116556621,
            116344048,
            116344302,
            116349055,
            116346341,
            116347417,
            116335585,
            116344826,
            116338508,
            116335707,
            116341307,
            116349851,
            116341668,
            116351051,
            116353738,
            116347590,
            116343356,
            116345813,
            116346453,
            116348324
        ],
        "F": [
            116372175,
            116372025,
            116380530,
            116381098,
            116381539,
            116374296,
            116382706,
            116380101,
            116523025,
            116385915,
            116383799,
            116377898,
            116380915,
            116382591,
            116385839,
            116395698
        ],
        "E": [
            116351338,
            116353665,
            116354964,
            116353294,
            116353957,
            116361966,
            116348163,
            116347670,
            116343533,
            116351101,
            116353993,
            116360946,
            116355058,
            116358519,
            116354709,
            116351286,
            116352542,
            116358011,
            116357879
        ],
        "C": [
            116334549,
            116339182,
            116340233,
            116340613,
            116342489,
            116350963,
            116337654,
            116366806,
            116362628,
            116359745,
            116345739,
            116358283,
            116349150,
            116349846,
            116332723,
            116338076,
            116338563,
            116342647,
            116341792
        ],
        "B": [
            116321920,
            116322956,
            116323732,
            116325314,
            116321887,
            116323618,
            116323021,
            116322464,
            116326670,
            116325875,
            116323111,
            116331257,
            116322276,
            116322144,
            116322587,
            116325439,
            116323730,
            116321987,
            116325764
        ],
        "A": [
            116320634,
            116320705,
            116320798,
            116320688,
            116320665,
            116321107,
            116320786,
            116320654,
            116321098,
            116320865,
            116320734,
            116327758,
            116320593,
            116320655,
            116320605,
            116320657,
            116320652,
            116320617,
            116320774
        ]
    },
    "name": "B. Permutation Sort",
    "statement": "You are given a permutation a consisting of n numbers 1, 2, ..., n (a\r\npermutation is an array in which each element from 1 to n occurs exactly\r\nonce).You can perform the following operation: choose some subarray\r\n(contiguous subsegment) of a and rearrange the elements in it in any way\r\nyou want. But this operation cannot be applied to the whole array.For\r\nexample, if a = [2, 1, 4, 5, 3] and we want to apply the operation to\r\nthe subarray a[2, 4] (the subarray containing all elements from the 2-nd\r\nto the 4-th), then after the operation, the array can become a = [2, 5,\r\n1, 4, 3] or, for example, a = [2, 1, 5, 4, 3].Your task is to calculate\r\nthe minimum number of operations described above to sort the permutation\r\na in ascending order.\r\n",
    "solutions": [
        "/*\n    author:  Maksim1744\n    created: 16.05.2021 11:02:10\n*/\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp   make_pair\n#define pb   push_back\n#define eb   emplace_back\n\n#define sum(a)     ( accumulate ((a).begin(), (a).end(), 0ll))\n#define mine(a)    (*min_element((a).begin(), (a).end()))\n#define maxe(a)    (*max_element((a).begin(), (a).end()))\n#define mini(a)    ( min_element((a).begin(), (a).end()) - (a).begin())\n#define maxi(a)    ( max_element((a).begin(), (a).end()) - (a).begin())\n#define lowb(a, x) ( lower_bound((a).begin(), (a).end(), (x)) - (a).begin())\n#define uppb(a, x) ( upper_bound((a).begin(), (a).end(), (x)) - (a).begin())\n\ntemplate<typename T>             vector<T>& operator--            (vector<T> &v){for (auto& i : v) --i;            return  v;}\ntemplate<typename T>             vector<T>& operator++            (vector<T> &v){for (auto& i : v) ++i;            return  v;}\ntemplate<typename T>             istream& operator>>(istream& is,  vector<T> &v){for (auto& i : v) is >> i;        return is;}\ntemplate<typename T>             ostream& operator<<(ostream& os,  vector<T>  v){for (auto& i : v) os << i << ' '; return os;}\ntemplate<typename T, typename U> pair<T,U>& operator--           (pair<T, U> &p){--p.first; --p.second;            return  p;}\ntemplate<typename T, typename U> pair<T,U>& operator++           (pair<T, U> &p){++p.first; ++p.second;            return  p;}\ntemplate<typename T, typename U> istream& operator>>(istream& is, pair<T, U> &p){is >> p.first >> p.second;        return is;}\ntemplate<typename T, typename U> ostream& operator<<(ostream& os, pair<T, U>  p){os << p.first << ' ' << p.second; return os;}\ntemplate<typename T, typename U> pair<T,U> operator-(pair<T,U> a, pair<T,U> b){return mp(a.first-b.first, a.second-b.second);}\ntemplate<typename T, typename U> pair<T,U> operator+(pair<T,U> a, pair<T,U> b){return mp(a.first+b.first, a.second+b.second);}\ntemplate<typename T, typename U> void umin(T& a, U b){if (a > b) a = b;}\ntemplate<typename T, typename U> void umax(T& a, U b){if (a < b) a = b;}\n\n#ifdef HOME\n#define SHOW_COLORS\n#include \"C:/C++ libs/print.cpp\"\n#else\n#define show(...) void(0)\n#define mclock    void(0)\n#define shows     void(0)\n#define debug  if (false)\n#endif\n\nvoid test_case(int test) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    cin >> a;\n    if (is_sorted(a.begin(), a.end())) {\n        cout << 0 << '\\n';\n        return;\n    }\n    if (a[0] == 1 || a.back() == n) {\n        cout << 1 << '\\n';\n        return;\n    }\n    if (a[0] != n || a.back() != 1) {\n        cout << 2 << '\\n';\n        return;\n    }\n    cout << 3 << '\\n';\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int T;\n    cin >> T;\n    for (int test = 1; test <= T; ++test) {\n        test_case(test);\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Permutation Sort.json",
    "editorial_link": "https://codeforces.com//blog/entry/90793",
    "editorial": "To solve the problem, it is enough to consider several cases: if the\r\narray is already sorted, the answer is ; if (or ), then you can sort the\r\narray in one operation by selecting the subarray (or ); if and , you can\r\nperform the sequence of operations , and and sort the array on each of\r\nthem (you can\u00e2\u0080\u0099t do it faster since you can\u00e2\u0080\u0099t move both to position and\r\nto position in only operations); otherwise, the array can be sorted in\r\noperations.\r\n"
}