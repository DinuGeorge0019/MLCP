{
    "link": "https://codeforces.com//contest/2075/problem/E",
    "problemId": "3273594",
    "problem_idx": "E",
    "shortId": "2075E",
    "contest_number": "2075",
    "problem_submissions": {
        "F": [
            311092897,
            311105371,
            311091977,
            311106822,
            311119612,
            311127395,
            311111998,
            311124374,
            311123265,
            311135481,
            311127374,
            311124949,
            311133033,
            311127513,
            311123593,
            311131608,
            311137578,
            311136881,
            311133323,
            311066636
        ],
        "E": [
            311078477,
            311076658,
            311072206,
            311087192,
            311086935,
            311076933,
            311081142,
            311089235,
            311087311,
            311085142,
            311096896,
            311100487,
            311099554,
            311111156,
            311091394,
            311097405,
            311088422,
            311171203,
            311103877,
            311113693,
            311080280
        ],
        "D": [
            311061322,
            311057750,
            311060365,
            311055119,
            311060010,
            311059723,
            311071257,
            311070356,
            311063998,
            311066698,
            311082700,
            311064184,
            311068410,
            311078395,
            311082862,
            311069076,
            311068306,
            311073979,
            311087117,
            311088989
        ],
        "C": [
            311052044,
            311051318,
            311056183,
            311050640,
            311054145,
            311055185,
            311051870,
            311052149,
            311059642,
            311052003,
            311055738,
            311055390,
            311062256,
            311062646,
            311066843,
            311053249,
            311062988,
            311059819,
            311096162
        ],
        "B": [
            311045239,
            311044707,
            311043555,
            311043641,
            311046416,
            311046113,
            311044758,
            311043793,
            311048255,
            311045137,
            311044396,
            311044990,
            311049796,
            311048015,
            311058751,
            311045105,
            311045287,
            311046394,
            311099408
        ],
        "A": [
            311042018,
            311040390,
            311040326,
            311040380,
            311040339,
            311040623,
            311040931,
            311040288,
            311041987,
            311040424,
            311040342,
            311040291,
            311041844,
            311040490,
            311049977,
            311040412,
            311040468,
            311040975,
            311101264
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140781",
    "editorial": "If there are at least three pairwise distinct elements in one of the two\r\narrays ( and ), then there will also be at least three distinct elements\r\nin the matrix. Therefore, we can assume that the number of distinct\r\nelements in each of the arrays does not exceed .This allows us to\r\nconstruct the answer from the following parts: the number of pairs of\r\narrays where all elements in are the same and all elements in are the\r\nsame; the number of pairs of arrays where all elements in are the same,\r\nand the number of distinct elements in is ; the number of pairs of\r\narrays where the number of distinct elements in is , and all elements in\r\nare the same; the number of pairs of arrays where both and have two\r\ndistinct elements each. The first part of the answer is simply , as we\r\ncan choose which number all elements in will equal, and which number all\r\nelements in will equal.The second and third parts are very similar to\r\neach other. Therefore, we will explain how the second part is\r\ncalculated, and the third can be computed similarly. We can choose which\r\nnumber will be in , and the number of ways to do this is . We can also\r\nchoose which two numbers will be in , which can be done in ways.\r\nAdditionally, we need to choose the positions in where the first number\r\nwill be; the number of ways to do this is (not , since we need to\r\nexclude the cases where the same number appears in all positions).\r\nTherefore, the second part of the answer is .The fourth part is the most\r\ncomplex. The main problem is that it is important which specific values\r\nwe choose for the arrays and . Let all elements of be either or (), and\r\nall elements of be either or (). Then for this quadruple , there are\r\nways to choose which positions in which arrays correspond to which\r\nnumbers. This must be multiplied by the number of suitable quadruples,\r\nso let’s learn how to count them.We are interested in quadruples of\r\nnumbers that satisfy the conditions: ; ; (otherwise, we will have more\r\nthan two distinct values in the matrix, since ). This condition is also\r\nequivalent to , so if it holds, there are exactly two distinct values in\r\nthe matrix. The third condition can be rewritten as . Let’s then count\r\nnot the quadruples , but the triples such that and .This can be done\r\nusing digit dynamic programming on the bits of these three numbers from\r\nthe most significant to the least significant. Let be the number of ways\r\nto set the most significant bits in these three numbers such that: , if\r\nthe number is still equal to the upper limit , or , if it is definitely\r\nless; , if the number is still equal to the upper limit , or , if it is\r\ndefinitely less; , if the number is still equal to , or , if it is\r\ndefinitely not . Transitions in this dynamic programming are done as\r\nfollows: we iterate over which values will be in the next bit of these\r\nthree numbers, check that this does not violate any conditions, and\r\nobserve how the values of change.What conditions do we need to check? We\r\nneed to ensure that , so if is and the next bit in is , we cannot set in\r\nthe next bit of ; We need to ensure that (similarly); We need to ensure\r\nthat , so if is and we set the next bit in to , this bit must also be in\r\nthe number ; We need to ensure that (similarly). The flags are\r\nrecalculated quite trivially, and we will not discuss this in detail in\r\nthe explanation.The answer should be collected from all states of the\r\nform , where is the number of bits in the numbers. This way, we will\r\nobtain the number of pairs that can be used.This dynamic programming is\r\nthe most computationally intensive part of the solution, so the entire\r\nsolution works in , but with a very large constant in the asymptotic\r\nnotation.\r\n",
    "name": "E. XOR Matrix",
    "statement": "For two arrays a = [a_1, a_2,\r\ndots, a_n] and b = [b_1, b_2,\r\ndots, b_m], we define the XOR matrix X of size n\r\ntimes m, where for each pair (i,j) (1\r\nle i\r\nle n; 1\r\nle j\r\nle m) it holds that X_{i,j} = a_i\r\noplus b_j. The symbol\r\noplus denotes the bitwise XOR operation.You are given four integers n,\r\nm, A, B. Count the number of such pairs of arrays (a, b) such that: a\r\nconsists of n integers, each of which is from 0 to A; b consists of m\r\nintegers, each of which is from 0 to B; in the XOR matrix formed from\r\nthese arrays, there are no more than two distinct values.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. XOR Matrix.json"
}