{
    "link": "https://codeforces.com//contest/985/problem/F",
    "problemId": "184587",
    "problem_idx": "F",
    "shortId": "985F",
    "contest_number": "985",
    "problem_submissions": {
        "G": [
            38542149,
            38512186,
            38512236,
            38513581,
            38508155,
            38634852,
            38634344,
            38634277,
            38515048
        ],
        "F": [
            38499146,
            38499001,
            38501533,
            38502149,
            44969812,
            38501168,
            38505525,
            38502880,
            38530512,
            38499950,
            38499753,
            38505154,
            38503491,
            38504126,
            38510981,
            38505877,
            38504312,
            38507584,
            38509250,
            38506993,
            38507253
        ],
        "E": [
            38493702,
            38497357,
            38497944,
            38499266,
            38496305,
            38496738,
            38500977,
            38502378,
            38496622,
            38497691,
            38498718,
            38497100,
            38498488,
            38496555,
            38502188,
            38501286,
            38496578,
            38488837,
            38503513,
            38500067,
            38501389
        ],
        "D": [
            38491674,
            38495666,
            38493742,
            38495486,
            38495900,
            38495531,
            38494634,
            38495573,
            38493765,
            38502434,
            38497951,
            38500032,
            38496113,
            38498092
        ],
        "C": [
            38489266,
            38490508,
            38491062,
            38490764,
            38489327,
            38492089,
            38489607,
            38491317,
            38489050,
            38492258,
            38493205,
            38490810,
            38490379,
            38491131,
            38492401,
            38495949,
            38492200,
            38493338,
            38495062
        ],
        "B": [
            38486666,
            38488118,
            38487524,
            38488045,
            38487258,
            38487260,
            38487379,
            38487785,
            38486818,
            38488660,
            38487046,
            38487281,
            38487622,
            38487410,
            38487870,
            38578001,
            38491648,
            38488972,
            38488613,
            38488764
        ],
        "A": [
            38486349,
            38486599,
            38486409,
            38487064,
            38486426,
            38486427,
            38486493,
            38486415,
            38486362,
            38487242,
            38486378,
            38489634,
            38486554,
            38486364,
            38486402,
            38577942,
            38487704,
            38486613,
            38486447,
            38487421
        ]
    },
    "name": "F. Isomorphic Strings",
    "statement": "You are given a string of length consisting of lowercase English\r\nletters.For two given strings and , say is the set of distinct\r\ncharacters of and is the set of distinct characters of . The strings and\r\nare if their lengths are equal and there is a one-to-one mapping\r\n(bijection) between and for which . Formally: for any index , for any\r\ncharacter there is exactly one character that , for any character there\r\nis exactly one character that . For example, the strings \"\" and \"\" are\r\nisomorphic. Also the strings \"\" and \"\" are isomorphic. The following\r\npairs of strings are not isomorphic: \"\" and \"\", \"\" and \"\".You have to\r\nhandle queries characterized by three integers (). For each query check\r\nif two substrings and are isomorphic.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntemplate<class T> pair<T,T> operator+(const pair<T,T>& l, const pair<T,T>& r) {\n    return {(l.f+r.f)%MOD,(l.s+r.s)%MOD};\n}\n \ntemplate<class T> pair<T,T> operator-(const pair<T,T>& l, const pair<T,T>& r) {\n    return {(l.f-r.f+MOD)%MOD,(l.s-r.s+MOD)%MOD};\n}\n \ntemplate<class T> pair<T,T> operator*(const pair<T,T>& l, const T& r) {\n    return {l.f*r%MOD,l.s*r%MOD};\n}\n\ntemplate<class T> pair<T,T> operator*(const pair<T,T>& l, const pair<T,T>& r) {\n    return {l.f*r.f%MOD,l.s*r.s%MOD};\n}\n\narray<pl,26> operator-(const array<pl,26>& a, const array<pl,26>& b) {\n    array<pl,26> c; F0R(i,26) c[i] = a[i]-b[i];\n    return c;\n}\n\narray<pl,26> operator*(const pl& a, const array<pl,26>& b) {\n    array<pl,26> c; F0R(i,26) c[i] = b[i]*a;\n    return c;\n}\n\nstruct hsh {\n    string S; \n    vector<pl> po, ipo;\n    vector<array<pl,26>> cum;\n    pl base = mp(948392576,573928192), invbase = mp(499499562,829828935);\n\n    ll modpow(ll b, ll p) {\n        return !p?1:modpow(b*b%MOD,p/2)*(p&1?b:1)%MOD;\n    }\n    \n    ll inv(ll x) {\n        return modpow(x,MOD-2);\n    }\n    \n    void gen(string _S) {\n        S = _S;\n        po.resize(sz(S)), ipo.resize(sz(S)), cum.resize(sz(S)+1);\n        po[0] = ipo[0] = {1,1};\n        \n        base.s = rand() % MOD; invbase.s = inv(base.s);\n        FOR(i,1,sz(S)) {\n            po[i] = po[i-1]*base;\n            ipo[i] = ipo[i-1]*invbase;\n        }\n        F0R(i,sz(S)) {\n            cum[i+1] = cum[i];\n            cum[i+1][S[i]-'a'] = cum[i+1][S[i]-'a']+po[i];\n        }\n        //cout << \"HI \" << cum[2][0].f << \" \" << cum[2][0].s << \"\\n\";\n        //cout << \"HI \" << cum[2][1].f << \" \" << cum[2][1].s << \"\\n\";\n        //cout << (cum[2][1]*invbase).f << \" \" << (cum[2][1]*invbase).s << \"\\n\";\n    }\n    \n    vpl get(int l, int r) {\n        array<pl,26> a = ipo[l]*(cum[r+1]-cum[l]);\n        vpl z; F0R(i,26) z.pb(a[i]);\n        sort(all(z));\n        // F0R(i,26) cout << z[i].f << \" \" << z[i].s << \"\\n\";\n        return z;\n    }\n};\n\nhsh H;\n\nint n,m;\n\nint main() {\n    srand(time(0));\n    cin >> n >> m;\n    string t; cin >> t;\n    H.gen(t);\n    F0R(i,m) {\n        int x,y,len; cin >> x >> y >> len;\n        x--, y--;\n        if (H.get(x,x+len-1) == H.get(y,y+len-1)) cout << \"YES\\n\";\n        else cout << \"NO\\n\";\n        // cout << \"----\\n\";\n    }\n}\n\n// read the question correctly (is y a vowel? what are the exact constraints?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"
    ],
    "input": "",
    "output": "",
    "tags": [
        "hashing",
        "strings"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Isomorphic Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/59623",
    "editorial": "Yes, authors also implemented hashes.Note that if substrings and are\r\nisomophic, then position of first encounter of some character in must be\r\nposition of first encounter of some character in . More over, if we sort\r\nall positions for all distict characters in and sort all positions for ,\r\nthen must be equal for any . This observation gives us fact, that .So,\r\nto check isomorphism of and we need check for each , that positions of\r\nall encounters of character equal to posistions of all encounters of\r\ncharacter .To do that we can generate for each character boolean array\r\nwith checked positions of its encounter and calculate prefix hashes on\r\nthis arrays. Also we need precalculate order of first encounters for\r\neach suffix of string . To do it fast note that in transition from to\r\nonly can change its relative order.Result complexity is with quite big\r\nconstant from hashing.\r\n",
    "hint": []
}