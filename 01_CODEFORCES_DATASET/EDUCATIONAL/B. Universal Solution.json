{
    "link": "https://codeforces.com//contest/1380/problem/B",
    "problemId": "670984",
    "problem_idx": "B",
    "shortId": "1380B",
    "contest_number": "1380",
    "problem_submissions": {
        "F": [
            86713166,
            86683254,
            86680631,
            86680966,
            86687165,
            86684140,
            86669350,
            86688621,
            86687283,
            86673002,
            86689951,
            86691835,
            86685205,
            86710315,
            86689156,
            86687400,
            86687045,
            86687896,
            86690019
        ],
        "G": [
            86677566,
            86685201,
            86688237,
            86689481,
            86686718,
            86691383,
            86690954,
            86692142,
            86694360,
            86693986,
            86693332,
            86693299,
            86700820,
            86693764,
            86685196,
            86684314
        ],
        "E": [
            86675522,
            86675407,
            86673302,
            86676691,
            86680473,
            86684037,
            86681297,
            86679620,
            86685647,
            86685220,
            86686544,
            86674567,
            86678512,
            86684412,
            86683830,
            86676323,
            86680714,
            86681696,
            86690990
        ],
        "D": [
            86667662,
            86670333,
            86669219,
            86673424,
            86678569,
            86680592,
            86676914,
            86676735,
            86681998,
            86680522,
            86687871,
            86670447,
            86672345,
            86680156,
            86679073,
            86689461,
            86721905,
            86687223
        ],
        "C": [
            86667582,
            86670259,
            86669101,
            86667895,
            86670203,
            86672224,
            86667959,
            86672685,
            86676101,
            86675384,
            86675814,
            86668973,
            86672498,
            86672045,
            86670655,
            86667252,
            86668731,
            86674537,
            86668780
        ],
        "B": [
            86667335,
            86670187,
            86671042,
            86667790,
            86672794,
            86670893,
            86667752,
            86671215,
            86673431,
            86671665,
            86674484,
            86670341,
            86660822,
            86669327,
            86673817,
            86667069,
            86673326,
            86672657,
            86668683
        ],
        "A": [
            86667075,
            86670143,
            86668605,
            86667568,
            86667937,
            86657614,
            86657741,
            86669480,
            86673357,
            86672922,
            86672973,
            86668720,
            86672438,
            86659787,
            86671597,
            86666992,
            86671323,
            86669608,
            86668545
        ]
    },
    "name": "B. Universal Solution",
    "statement": "Recently, you found a bot to play \"Rock paper scissors\" with.\r\nUnfortunately, the bot uses quite a simple algorithm to play: he has a\r\nstring s = s_1 s_2\r\ndots s_{n} of length n where each letter is either , or .While\r\ninitializing, the bot is choosing a starting index pos (1\r\nle pos\r\nle n), and then it can play any number of rounds. In the first round, he\r\nchooses \"Rock\", \"Scissors\" or \"Paper\" based on the value of s_{pos}: if\r\ns_{pos} is equal to the bot chooses \"Rock\"; if s_{pos} is equal to the\r\nbot chooses \"Scissors\"; if s_{pos} is equal to the bot chooses \"Paper\";\r\nIn the second round, the bot\u2019s choice is based on the value of s_{pos +\r\n1}. In the third round on s_{pos + 2} and so on. After s_n the bot\r\nreturns to s_1 and continues his game.You plan to play n rounds and\r\nyou\u2019ve already figured out the string s but still don\u2019t know what is the\r\nstarting index pos. But since the bot\u2019s tactic is so boring, you\u2019ve\r\ndecided to find n choices to each round to maximize the average number\r\nof wins.In other words, let\u2019s suggest your choices are c_1 c_2\r\ndots c_n and if the bot starts from index pos then you\u2019ll win in\r\nwin(pos) rounds. Find c_1 c_2\r\ndots c_n such that\r\nfrac{win(1) + win(2) +\r\ndots + win(n)}{n} is maximum possible.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        string S; cin >> S;\n        char C[3] = {'R', 'S', 'P'};\n        char R[3] = {'P', 'R', 'S'};\n        int cnt[3] = {0, 0, 0};\n        F0R(i, sz(S)) {\n            F0R(j, 3) {\n                if (S[i] == C[j]) cnt[j]++;\n            }\n        }\n        int best = 0, pos = 0;\n        F0R(i, 3) if (ckmax(best, cnt[i])) pos = i;\n        F0R(i, sz(S)) cout << R[pos];\n        cout << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Universal Solution.json",
    "editorial_link": "https://codeforces.com//blog/entry/80054",
    "editorial": "Let\u00e2\u0080\u0099s look at the contribution of each choice to the total number of\r\nwins (we can look at \"total\" instead of \"average\", since \"average\" is\r\nequal to \"total\" divided by ). For example, let\u00e2\u0080\u0099s look at the first\r\nchoice : in we compare with , in with , in with and so on.In the result,\r\nwe compare with all once. So, to maximize the total sum, we need to\r\nchoose that beats the maximum number of or, in other words, let\u00e2\u0080\u0099s find\r\nthe most frequent character in and choose that beats it.Okay, we found\r\nthe optimal . But if we look at the contribution of any other we can\r\nnote that we compare any with all once. So we can choose all equal to\r\nwhich is equal to the choice that beats the most frequent choice in .\r\n"
}