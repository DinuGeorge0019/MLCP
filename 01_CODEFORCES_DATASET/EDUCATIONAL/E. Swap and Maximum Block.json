{
    "link": "https://codeforces.com//contest/1716/problem/E",
    "problemId": "1494204",
    "problem_idx": "E",
    "shortId": "1716E",
    "contest_number": "1716",
    "problem_submissions": {
        "F": [
            166973182,
            166969763,
            166955726,
            166980503,
            166971153,
            166982692,
            166980605,
            166983476,
            166980127,
            166991091,
            166984328,
            174506735,
            166989832,
            166994539,
            166994104,
            167001346,
            166987296,
            166992176,
            167001598,
            166984678,
            166980048,
            166989609,
            166991438
        ],
        "E": [
            166965293,
            166978547,
            166976884,
            166972995,
            166981522,
            166965872,
            166976854,
            166973781,
            166987347,
            166978953,
            166992476,
            174506754,
            166979608,
            166979158,
            166999544,
            166982891,
            166981173,
            166992198,
            166994171,
            166998037,
            166985315
        ],
        "D": [
            166956573,
            166961021,
            166948324,
            166940829,
            166964589,
            166961790,
            166945640,
            166966226,
            166990484,
            166958577,
            166963786,
            166970823,
            166970282,
            166968378,
            166964318,
            166974075,
            166965600,
            166970563,
            166970355,
            166971544,
            166978778
        ],
        "C": [
            166949159,
            166950864,
            166972142,
            166963779,
            166956508,
            166957181,
            166966957,
            166958122,
            166972096,
            166974861,
            166961876,
            166963035,
            166961356,
            166959918,
            166967210,
            166954669,
            166964729,
            166960756,
            166967143,
            166974763
        ],
        "B": [
            166933142,
            166932739,
            166939087,
            166932145,
            166933138,
            166932019,
            166931348,
            166934835,
            166932251,
            166931312,
            166937500,
            166936523,
            166932821,
            166932877,
            166940841,
            166932031,
            166935420,
            166935573,
            166933744,
            166937079
        ],
        "A": [
            166930228,
            166930333,
            166931520,
            166930280,
            166930300,
            166930222,
            166930190,
            166930301,
            166930500,
            166930207,
            166932038,
            166930537,
            166930220,
            166930271,
            166933329,
            166930353,
            166930639,
            166930376,
            166930158,
            166931421
        ]
    },
    "name": "E. Swap and Maximum Block",
    "statement": "You are given an array of length 2^n. The elements of the array are\r\nnumbered from 1 to 2^n.You have to process q queries to this array. In\r\nthe i-th query, you will be given an integer k (0\r\nle k\r\nle n-1). To process the query, you should do the following: for every i\r\nin [1, 2^n-2^k] , do the following: if the i-th element was already\r\nswapped with some other element , skip it; otherwise, swap a_i and\r\na_{i+2^k}; after that, print the maximum sum over all contiguous\r\nsubsegments of the array (including the empty subsegment). For example,\r\nif the array a is [-3, 5, -3, 2, 8, -20, 6, -1], and k = 1, the query is\r\nprocessed as follows: the 1-st element wasn’t swapped yet, so we swap it\r\nwith the 3-rd element; the 2-nd element wasn’t swapped yet, so we swap\r\nit with the 4-th element; the 3-rd element was swapped already; the 4-th\r\nelement was swapped already; the 5-th element wasn’t swapped yet, so we\r\nswap it with the 7-th element; the 6-th element wasn’t swapped yet, so\r\nwe swap it with the 8-th element. So, the array becomes [-3, 2, -3, 5,\r\n6, -1, 8, -20]. The subsegment with the maximum sum is [5, 6, -1, 8],\r\nand the answer to the query is 18.Note that the queries actually , i. e.\r\nafter a query is performed, the array does not return to its original\r\nstate, and the next query will be applied to the modified array.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 18) + 7;\nll a[N];\nint n;\n\nstruct Item {\n\tint len;\n\tll sum;\n\tvector<ll> pref, suf, mx;\n\n\tItem() : len(), sum(), pref(), suf(), mx() {}\n\tItem(int _len) {\n\t\tlen = _len;\n\t\tsum = 0;\n\t\tpref = vector<ll>(len, 0);\n\t\tsuf = vector<ll>(len, 0);\n\t\tmx = vector<ll>(len, 0);\n\t}\n};\n\nItem solve(int l, int r) {\n\tint len = r - l;\n\tItem I = Item(len);\n\tif (len == 1) {\n\t\tI.sum = a[l];\n\t\tI.pref[0] = I.suf[0] = I.mx[0] = max(0LL, a[l]);\n\t\treturn I;\n\t}\n\tItem L = solve(l, l + len / 2), R = solve(l + len / 2, r);\n\tI.sum = L.sum + R.sum;\n\tfor (int i = 0; i < len / 2; i++) {\n\t\tI.pref[i] = max(L.pref[i], L.sum + R.pref[i]);\n\t\tI.suf[i] = max(R.suf[i], R.sum + L.suf[i]);\n\t\tI.mx[i] = max(max(L.mx[i], R.mx[i]), L.suf[i] + R.pref[i]);\n\t\tI.pref[i + len / 2] = max(R.pref[i], R.sum + L.pref[i]);\n\t\tI.suf[i + len / 2] = max(L.suf[i], L.sum + R.suf[i]);\n\t\tI.mx[i + len / 2] = max(max(L.mx[i], R.mx[i]), R.suf[i] + L.pref[i]);\n\t}\n\treturn I;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tn = 1 << n;\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tItem I = solve(0, n);\n\tint q;\n\tint x = 0;\n\tscanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tx ^= 1 << k;\n\t\tprintf(\"%lld\\n\", I.mx[x]);\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Swap and Maximum Block.json",
    "editorial_link": "https://codeforces.com//blog/entry/105653",
    "editorial": "Letâs carefully analyze the operation denoted in the query. Since the\r\nlength of the array is always divisible by , every element will be\r\nswapped with some other element. The elements can be split into two\r\ngroups the ones whose positions increase by , and the ones whose\r\npositions decrease by .Letâs find some trait of the elements which will\r\nallow us to distinguish the elements of one group from the elements of\r\nthe other group. The first elements will be shifted to the right, the\r\nnext elements will be shifted to the left, the next elements will be\r\nshifted to the right, etc. If we look at the binary representations of\r\nintegers , then we can see that the first elements have in the -th bit,\r\nthe next elements have in the -th bit, the next elements have in the -th\r\nbit, and so on. So, if we consider the positions of elements as\r\n-indexed, then the operation can be described as follows: \"Let the\r\nposition of the element be . If the -th bit in is , gets increased by ,\r\notherwise gets decreased by \". What does it look like? Actually, it is\r\njust (where denotes XOR).So, each query can be represented as \"swap with\r\nfor some integer \". The combination of two queries can also be\r\nrepresented with a single query; in fact, the state of the array can be\r\ndenoted as the XOR of all from the previous queries.Now, letâs try to\r\nsolve the following problem: for every , calculate the maximum sum of\r\nsubsegment if every element is swapped with . To solve this problem, we\r\ncan use a segment tree.First of all, we need to understand how to solve\r\nthe problem of finding the maximum sum on subsegment using a segment\r\ntree. To do this, we should store the following four values in each\r\nvertex of the segment tree: the sum of elements on the segment denoted\r\nby the vertex; the maximum sum of elements on the prefix of the segment\r\ndenoted by the vertex; the maximum sum of elements on the suffix of the\r\nsegment denoted by the vertex; the answer on the segment. If some vertex\r\nof the segment tree has two children, these values for it can be easily\r\ncalculated using the values from the children. So, we can \"glue\" two\r\nsegments represented by the vertices together, creating a new vertex\r\nrepresenting the concatenation of these segments.Okay, but how do we\r\napply XOR to this? For every vertex of the segment tree, letâs create\r\nseveral versions; the -th version of the vertex represents the segment\r\ncorresponding to this vertex if we apply swapping query with to it. For\r\na vertex representing the segment of length , we can use the following\r\nrelation to get all its versions (here, we denote as the -th version of\r\n, and and as the children of ): if , then ; else ; The function here\r\ndenotes the \"glueing together\" of two vertices we described above.Now\r\nletâs try to analyze how many versions of each vertex we need. For the\r\nroot, we will need all versions. For its children, we need only\r\nversions. For the children of the children of the root, we need only\r\nversions, and so on; so, overall, the total number of versions is only ,\r\nand each version can be constructed in , so the solution works in .\r\n",
    "hint": []
}