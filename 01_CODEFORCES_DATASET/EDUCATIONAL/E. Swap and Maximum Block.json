{"link": "https://codeforces.com//contest/1716/problem/E", "problemId": "1494204", "problem_idx": "E", "shortId": "1716E", "contest_number": "1716", "problem_submissions": {"F": [166973182, 166969763, 166955726, 166980503, 166971153, 166982692, 166980605, 166983476, 166980127, 166991091, 166984328, 174506735, 166989832, 166994539, 166994104, 167001346, 166987296, 166992176, 167001598, 166984678, 166980048, 166989609, 166991438], "E": [166965293, 166978547, 166976884, 166972995, 166981522, 166965872, 166976854, 166973781, 166987347, 166978953, 166992476, 174506754, 166979608, 166979158, 166999544, 166982891, 166981173, 166992198, 166994171, 166998037, 166985315], "D": [166956573, 166961021, 166948324, 166940829, 166964589, 166961790, 166945640, 166966226, 166990484, 166958577, 166963786, 166970823, 166970282, 166968378, 166964318, 166974075, 166965600, 166970563, 166970355, 166971544, 166978778], "C": [166949159, 166950864, 166972142, 166963779, 166956508, 166957181, 166966957, 166958122, 166972096, 166974861, 166961876, 166963035, 166961356, 166959918, 166967210, 166954669, 166964729, 166960756, 166967143, 166974763], "B": [166933142, 166932739, 166939087, 166932145, 166933138, 166932019, 166931348, 166934835, 166932251, 166931312, 166937500, 166936523, 166932821, 166932877, 166940841, 166932031, 166935420, 166935573, 166933744, 166937079], "A": [166930228, 166930333, 166931520, 166930280, 166930300, 166930222, 166930190, 166930301, 166930500, 166930207, 166932038, 166930537, 166930220, 166930271, 166933329, 166930353, 166930639, 166930376, 166930158, 166931421]}, "name": "E. Swap and Maximum Block", "statement": "You are given an array of length 2^n. The elements of the array are\r\nnumbered from 1 to 2^n.You have to process q queries to this array. In\r\nthe i-th query, you will be given an integer k (0\r\nle k\r\nle n-1). To process the query, you should do the following: for every i\r\nin [1, 2^n-2^k] , do the following: if the i-th element was already\r\nswapped with some other element , skip it; otherwise, swap a_i and\r\na_{i+2^k}; after that, print the maximum sum over all contiguous\r\nsubsegments of the array (including the empty subsegment). For example,\r\nif the array a is [-3, 5, -3, 2, 8, -20, 6, -1], and k = 1, the query is\r\nprocessed as follows: the 1-st element wasn\u2019t swapped yet, so we swap it\r\nwith the 3-rd element; the 2-nd element wasn\u2019t swapped yet, so we swap\r\nit with the 4-th element; the 3-rd element was swapped already; the 4-th\r\nelement was swapped already; the 5-th element wasn\u2019t swapped yet, so we\r\nswap it with the 7-th element; the 6-th element wasn\u2019t swapped yet, so\r\nwe swap it with the 8-th element. So, the array becomes [-3, 2, -3, 5,\r\n6, -1, 8, -20]. The subsegment with the maximum sum is [5, 6, -1, 8],\r\nand the answer to the query is 18.Note that the queries actually , i. e.\r\nafter a query is performed, the array does not return to its original\r\nstate, and the next query will be applied to the modified array.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 18) + 7;\nll a[N];\nint n;\n\nstruct Item {\n\tint len;\n\tll sum;\n\tvector<ll> pref, suf, mx;\n\n\tItem() : len(), sum(), pref(), suf(), mx() {}\n\tItem(int _len) {\n\t\tlen = _len;\n\t\tsum = 0;\n\t\tpref = vector<ll>(len, 0);\n\t\tsuf = vector<ll>(len, 0);\n\t\tmx = vector<ll>(len, 0);\n\t}\n};\n\nItem solve(int l, int r) {\n\tint len = r - l;\n\tItem I = Item(len);\n\tif (len == 1) {\n\t\tI.sum = a[l];\n\t\tI.pref[0] = I.suf[0] = I.mx[0] = max(0LL, a[l]);\n\t\treturn I;\n\t}\n\tItem L = solve(l, l + len / 2), R = solve(l + len / 2, r);\n\tI.sum = L.sum + R.sum;\n\tfor (int i = 0; i < len / 2; i++) {\n\t\tI.pref[i] = max(L.pref[i], L.sum + R.pref[i]);\n\t\tI.suf[i] = max(R.suf[i], R.sum + L.suf[i]);\n\t\tI.mx[i] = max(max(L.mx[i], R.mx[i]), L.suf[i] + R.pref[i]);\n\t\tI.pref[i + len / 2] = max(R.pref[i], R.sum + L.pref[i]);\n\t\tI.suf[i + len / 2] = max(L.suf[i], L.sum + R.suf[i]);\n\t\tI.mx[i + len / 2] = max(max(L.mx[i], R.mx[i]), R.suf[i] + L.pref[i]);\n\t}\n\treturn I;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tn = 1 << n;\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &a[i]);\n\tItem I = solve(0, n);\n\tint q;\n\tint x = 0;\n\tscanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tx ^= 1 << k;\n\t\tprintf(\"%lld\\n\", I.mx[x]);\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "data structures", "dfs and similar", "divide and conquer", "dp"], "dificulty": "2500", "interactive": false}