{
    "link": "https://codeforces.com//contest/1709/problem/F",
    "problemId": "1473249",
    "problem_idx": "F",
    "shortId": "1709F",
    "contest_number": "1709",
    "problem_submissions": {
        "F": [
            165168347,
            165171155,
            165167911,
            165174463,
            165176163,
            165160774,
            165168485,
            165153508,
            165190349,
            165187538,
            165182010,
            165187878,
            165188862,
            165199087,
            165192962,
            165196109,
            165191946,
            165144458,
            165186818,
            165193512,
            165203160
        ],
        "E": [
            165159365,
            165161441,
            165158406,
            165162017,
            165168742,
            165174634,
            165187067,
            165172843,
            165175285,
            165185776,
            165171787,
            165176500,
            165174638,
            165175948,
            165172273,
            165158835,
            165190131,
            165153154,
            165197774,
            165181829,
            165178900
        ],
        "D": [
            165150554,
            165148981,
            165152094,
            165156213,
            165151693,
            165153019,
            165151289,
            165162605,
            165149121,
            165155132,
            165160454,
            165159258,
            165152293,
            165165679,
            165219278,
            165218001,
            165217824,
            165217721,
            165217510,
            165217230,
            165156286,
            165159148,
            165160000,
            165161618,
            165152984
        ],
        "C": [
            165144629,
            165143580,
            165141216,
            165150836,
            165145746,
            165145999,
            165145473,
            165163144,
            165144208,
            165149116,
            165150518,
            165148291,
            165145172,
            165171500,
            165146230,
            165166415,
            165151667,
            165148193,
            165146642
        ],
        "B": [
            165139451,
            165137999,
            165136858,
            165138643,
            165140562,
            165138703,
            165137403,
            165156435,
            165139221,
            165142115,
            165142999,
            165139377,
            165138165,
            165141728,
            165137879,
            165168796,
            165142050,
            165141198,
            165138920
        ],
        "A": [
            165135387,
            165134436,
            165133952,
            165134310,
            165134821,
            165133959,
            165133957,
            165138163,
            165134268,
            165134365,
            165134868,
            165134280,
            165133923,
            165136754,
            165134369,
            165170607,
            165135087,
            165136295,
            165134364
        ]
    },
    "name": "F. Multiset of Strings",
    "statement": "You are given three integers n, k and f.Consider all binary strings (i.\r\ne. all strings consisting of characters 0 and/or 1) of length from 1 to\r\nn. For every such string s, you need to choose an integer c_s from 0 to\r\nk.A multiset of binary strings of length n is considered beautiful if\r\nfor every binary string s with length from 1 to n, the number of strings\r\nin the multiset such that s is their prefix is not exceeding c_s.For\r\nexample, let n = 2, c_{0} = 3, c_{00} = 1, c_{01} = 2, c_{1} = 1, c_{10}\r\n= 2, and c_{11} = 3. The multiset of strings\r\n{11, 01, 00, 01\r\n} is beautiful, since: for the string 0, there are 3 strings in the\r\nmultiset such that 0 is their prefix, and 3\r\nle c_0; for the string 00, there is one string in the multiset such that\r\n00 is its prefix, and 1\r\nle c_{00}; for the string 01, there are 2 strings in the multiset such\r\nthat 01 is their prefix, and 2\r\nle c_{01}; for the string 1, there is one string in the multiset such\r\nthat 1 is its prefix, and 1\r\nle c_1; for the string 10, there are 0 strings in the multiset such that\r\n10 is their prefix, and 0\r\nle c_{10}; for the string 11, there is one string in the multiset such\r\nthat 11 is its prefix, and 1\r\nle c_{11}. Now, for the problem itself. You have to calculate the number\r\nof ways to choose the integer c_s for every binary string s of length\r\nfrom 1 to n in such a way that the possible size of a beautiful multiset\r\nis f.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\nconst int LOG = 20; // CHECK!!!!\nPowers W;\nvector<int> binRev;\nvoid initFFT() {\n\tbinRev = vector<int>((1 << LOG) + 3, 0);\n\tMint w = 2;\n\twhile(true) {\n\t\tMint x = w;\n\t\tfor (int i = 1; i < LOG; i++)\n\t\t\tx *= x;\n\t\tif (x == -1) break;\n\t\tw += 1;\n\t}\n\tW = Powers(1 << LOG, w);\n\tfor (int mask = 1; mask < (1 << LOG); mask++) {\n\t\tbinRev[mask] = (binRev[mask >> 1] >> 1) ^ ((mask & 1) << (LOG - 1));\n\t}\n}\n\ntemplate<unsigned mod = MOD> struct Poly {\n\tusing Mint = mint<mod>;\n\tvector<Mint> a;\n\n\tPoly() : a() {}\n\tPoly(vector<Mint> _a) {\n\t\ta = _a;\n\t\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\t}\n\n\tvoid print(int n = -1) {\n\t\tif (n == -1) n = (int)a.size();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%u \", at(i).x);\n\t\tprintf(\"\\n\");\n\t}\n\tvoid eprint() {\n\t\teprintf(\"[\");\n\t\tfor (int i = 0; i < (int)a.size(); i++)\n\t\t\teprintf(\"%u \", a[i].x);\n\t\teprintf(\"]\\n\");\n\t}\n\n\tstatic void fft(vector<Mint> &A) {\n\t\tint L = (int)A.size();\n\t\tassert((L & (L - 1)) == 0);\n\t\tint k = 0;\n\t\twhile((1 << k) < L) k++;\n\t\tfor (int i = 0; i < L; i++) {\n\t\t\tint x = binRev[i] >> (LOG - k);\n\t\t\tif (i < x) swap(A[i], A[x]);\n\t\t}\n\t\tfor (int lvl = 0; lvl < k; lvl++) {\n\t\t\tint len = 1 << lvl;\n\t\t\tfor (int st = 0; st < L; st += (len << 1))\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\tMint x = A[st + i], y = A[st + len + i] * W.pow(i << (LOG - 1 - lvl));\n\t\t\t\t\tA[st + i] = x + y;\n\t\t\t\t\tA[st + len + i] = x - y;\n\t\t\t\t}\n\t\t}\n\t}\n\n\tMint& operator [] (const int i) {\n\t\tassert(0 <= i && i <= deg()); \n\t\treturn a[i];\n\t}\n\tMint at(const int i) const {\n\t\tif (i < 0 || i > deg()) return 0;\n\t\treturn a[i];\n\t}\n\tint deg() const { // deg of polynomial 0 is -1\n\t\treturn (int)a.size() - 1;\n\t}\n\tMint eval(const Mint &x) const {\n\t\tMint res = 0;\n\t\tfor (int i = deg(); i >= 0; i--)\n\t\t\tres = res * x + a[i];\n\t\treturn res;\n\t}\n\tPoly substr(const int &l, const int &r) const {\n\t\tvector<Mint> f(r - l);\n\t\tfor (int i = l; i < r; i++)\n\t\t\tf[i - l] = at(i);\n\t\treturn f;\n\t}\n\n\tPoly& operator += (const Poly &A) {\n\t\tif (deg() < A.deg()) a.resize(A.a.size());\n\t\tfor (int i = 0; i <= A.deg(); i++)\n\t\t\ta[i] += A.a[i];\n\t\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\t\treturn *this;\n\t}\n\tPoly& operator -= (const Poly &A) {\n\t\tif (deg() < A.deg()) a.resize(A.a.size());\n\t\tfor (int i = 0; i <= A.deg(); i++)\n\t\t\ta[i] -= A.a[i];\n\t\twhile(!a.empty() && a.back() == 0) a.pop_back();\n\t\treturn *this;\n\t}\n\tPoly& operator *= (const Mint &k) {\n\t\tif (k == 0) a.clear();\n\t\tfor (Mint &x : a) x *= k;\n\t\treturn *this;\n\t}\n\tPoly& operator /= (const Mint &k) {\n\t\tMint ki = k.inv();\n\t\tfor (Mint &x : a) x *= ki;\n\t\treturn *this;\n\t}\n\tPoly operator + (const Poly &A) const {\n\t\treturn Poly(*this) += A;\n\t}\n\tPoly operator - (const Poly &A) const {\n\t\treturn Poly(*this) -= A;\n\t}\n\tPoly operator * (const Mint &k) const {\n\t\treturn Poly(*this) *= k;\n\t}\n\tPoly operator / (const Mint &k) const {\n\t\treturn Poly(*this) /= k;\n\t}\n\t\n\tPoly& operator *= (const Poly &A) {\n\t\tif (a.empty() || A.a.empty()) {\n\t\t\ta.clear();\n\t\t\treturn *this;\n\t\t}\n\t\tint nd = deg() + A.deg();\n\t\t\n\t\tif (deg() < LOG || A.deg() < LOG) {\n\t\t\tvector<Mint> res(nd + 1, 0);\n\t\t\tfor (int i = 0; i <= deg(); i++)\n\t\t\t\tfor (int j = 0; j <= A.deg(); j++)\n\t\t\t\t\tres[i + j] += a[i] * A.a[j];\n\t\t\treturn *this = Poly(res);\n\t\t}\n\t\t\n\t\tint k = 0;\n\t\twhile((1 << k) <= nd) k++;\n\t\tint L = 1 << k;\n\t\tvector<Mint> f = a, g = A.a;\n\t\tf.resize(L, 0);\n\t\tg.resize(L, 0);\n\t\tfft(f);\n\t\tfft(g);\n\t\tfor (int i = 0; i < L; i++)\n\t\t\tf[i] *= g[i];\n\t\tfft(f);\n\t\treverse(f.begin() + 1, f.end());\n\t\treturn *this = (Poly(f) / L);\n\t}\n\tPoly operator * (const Poly &A) const {\n\t\treturn Poly(*this) *= A;\n\t}\n\n\tPoly inv(int n) const {\n\t\tassert(deg() >= 0 && at(0) != 0);\n\t\tif (n <= 0) return Poly();\n\t\tvector<Mint> res(n);\n\t\tres[0] = a[0].inv();\n\t\tvector<Mint> f, g;\n\t\tfor (int L = 1; L < n; L <<= 1) {\n\t\t\tf = vector<Mint>(2 * L);\n\t\t\tg = vector<Mint>(2 * L);\n\t\t\tfor (int i = 0; i < 2 * L && i <= deg(); i++)\n\t\t\t\tf[i] = a[i];\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tg[i] = res[i];\n\t\t\tfft(f);\n\t\t\tfft(g);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tf[i] = 0;\n\t\t\tfor (int i = L; i < 2 * L; i++)\n\t\t\t\tf[i] = Mint() - f[i];\n\t\t\tfft(f);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tMint Li = Mint(2 * L).inv();\n\t\t\tLi *= Li;\n\t\t\tfor (int i = L; i < 2 * L && i < n; i++)\n\t\t\t\tres[i] = f[i] * Li;\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic vector<Mint> div_stupid(vector<Mint> A, vector<Mint> B) {\n\t\tint n = (int)A.size(), m = (int)B.size();\n\t\tMint Bi = B.back().inv();\n\t\tfor (auto &x : B) x *= Bi;\n\t\tvector<Mint> C(n - m + 1);\n\t\tfor (int i = n; i >= m; i--) {\n\t\t\tC[i - m] = A[i - 1] * Bi;\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tA[i - m + j] -= B[j] * A[i - 1];\n\t\t}\n\t\treturn C;\n\t}\n\tPoly& operator /= (const Poly &A) {\n\t\tint d1 = deg(), d2 = A.deg();\n\t\tassert(d2 >= 0);\n\t\tif (d1 < d2) return *this = Poly();\n\t\tif (d2 < 4 * LOG || d1 - d2 < 4 * LOG)\n\t\t\treturn *this = div_stupid(a, A.a);\n\t\tvector<Mint> f = a, g = A.a;\n\t\treverse(all(f));\n\t\treverse(all(g));\n\t\tPoly H = Poly(vector<Mint>(f.begin(), f.begin() + d1 - d2 + 1)) * Poly(g).inv(d1 - d2 + 1);\n\t\tvector<Mint> t = vector<Mint>(H.a.begin(), H.a.begin() + d1 - d2 + 1);\n\t\treverse(all(t));\n\t\treturn *this = t;\n\t}\n\tPoly operator / (const Poly &A) const {\n\t\treturn Poly(*this) /= A;\n\t}\n\tPoly& operator %= (const Poly &A) {\n\t\tassert(A.deg() >= 0);\n\t\tif (deg() < A.deg()) return *this;\n\t\treturn *this -= A * (*this / A);\n\t}\n\tPoly operator % (const Poly &A) const {\n\t\treturn Poly(*this) %= A;\n\t}\n\n\tPoly derivate() const {\n\t\tint n = deg();\n\t\tif (n <= 0) return Poly();\n\t\tvector<Mint> f(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tf[i] = a[i + 1] * (i + 1);\n\t\treturn f;\n\t}\n\tPoly integrate() const {\n\t\tint n = deg();\n\t\tif (n < 0) return Poly();\n\t\tn += 2;\n\t\tvector<Mint> f(n);\n\t\tInverses I = Inverses(n);\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = a[i - 1] * I.inv(i);\n\t\treturn f;\n\t}\n\tPoly log(int n) const {\n\t\tif (n <= 1) return Poly();\n\t\tassert(deg() >= 0 && at(0) == 1);\n\t\treturn (derivate() * inv(n)).substr(0, n - 1).integrate();\n\t}\n\tPoly exp(int n) const {\n\t\tif (n <= 0) return Poly();\n\t\tif (deg() < 0) return Poly({1});\n\t\tassert(at(0) == 0);\n\t\tvector<Mint> res(n);\n\t\tres[0] = 1;\n\t\tvector<Mint> f, g;\n\t\tfor (int L = 1; L < n; L <<= 1) {\n\t\t\tf = vector<Mint>(2 * L);\n\t\t\tg = vector<Mint>(2 * L);\n\t\t\tPoly LG = Poly(vector<Mint>(res.begin(), res.begin() + L)).log(2 * L);\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tassert(at(i) == LG.at(i));\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tf[i] = res[i];\n\t\t\t\tg[i] = at(L + i) - LG.at(L + i);\n\t\t\t}\n\t\t\tfft(f);\n\t\t\tfft(g);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tMint Li = Mint(2 * L).inv();\n\t\t\tfor (int i = L; i < 2 * L && i < n; i++)\n\t\t\t\tres[i] = f[i - L] * Li;\n\t\t}\n\t\treturn res;\n\t}\n\tPoly sqr(int n) const {\n\t\treturn (*this * *this).substr(0, n);\n\t}\n\tPoly pow_(Mint k, int n) const { // k can be non-negative rational (k = 1/2 is sqrt), but assert(a[0] == 1);\n\t\tif (deg() < 0 || n <= 0) return Poly();\n\t\treturn (log(n) * k).exp(n);\n\t}\n\tPoly pow(ll k, int n) const { // k is non-negative integer\n\t\tif (n <= 0) return Poly();\n\t\tif (k == 0) return Poly({1});\n\t\tif (k == 1) return substr(0, n);\n\t\tif (k == 2) return sqr(n);\n\t\tif (k < LOG) {\n\t\t\tPoly cur = substr(0, n);\n\t\t\tPoly res = Poly({1});\n\t\t\twhile(k) {\n\t\t\t\tif (k & 1) res = (res * cur).substr(0, n);\n\t\t\t\tcur = cur.sqr(n);\n\t\t\t\tk >>= 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tint z = 0;\n\t\twhile(z * k < n && at(z) == 0) z++;\n\t\tif (z * k >= n) return Poly();\n\t\tPoly A = substr(z, z + n - z * k);\n\t\tMint cf = A[0].pow(k);\n\t\tA /= A[0];\n\t\tA = A.pow_(k, n - z * k) * cf;\n\t\treturn A.substr(-z * k, n - z * k);\n\t}\n\tPoly sqrt_(int n) const {\n\t\tif (deg() < 0 || n <= 0) return Poly();\n\t\tassert(at(0) == 1);\n//\t\treturn pow_(Mint(2).inv(), n);\n\t\tvector<Mint> res(n);\n\t\tres[0] = 1;\n\t\tvector<Mint> f, g;\n\t\tfor (int L = 1; L < n; L <<= 1) {\n\t\t\tf = vector<Mint>(2 * L);\n\t\t\tg = vector<Mint>(2 * L);\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tf[i] = res[i];\n\t\t\tfft(f);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= f[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tMint Li = Mint(2 * L).inv();\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= Li;\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] = at(i) - f[i];\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tassert(f[i] == 0);\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tf[i] = f[i + L];\n\t\t\t\tf[i + L] = 0;\n\t\t\t}\n\t\t\tPoly Q = Poly(vector<Mint>(res.begin(), res.begin() + L)).inv(L);\n\t\t\tfor (int i = 0; i < L; i++)\n\t\t\t\tg[i] = Q.at(i);\n\t\t\tfft(f);\n\t\t\tfft(g);\n\t\t\tfor (int i = 0; i < 2 * L; i++)\n\t\t\t\tf[i] *= g[i];\n\t\t\tfft(f);\n\t\t\treverse(f.begin() + 1, f.end());\n\t\t\tLi /= 2;\n\t\t\tfor (int i = L; i < 2 * L && i < n; i++)\n\t\t\t\tres[i] = f[i - L] * Li;\n\t\t}\n\t\treturn res;\n\t}\n\tbool sqrt(int n, Poly &R) const {\n\t\tif (deg() < 0) {\n\t\t\tR = Poly();\n\t\t\treturn true;\n\t\t}\n\t\tif (at(0) == 1) {\n\t\t\tR = sqrt_(n);\n\t\t\treturn true;\n\t\t}\n\t\tint z = 0;\n\t\twhile(at(z) == 0) z++;\n\t\tif (z & 1) return false;\n\t\tPoly A = substr(z, n + z / 2);\n\t\tMint cf;\n\t\tif (!A[0].sqrt(cf)) return false;\n\t\tA /= A[0];\n\t\tA = A.sqrt_(n - z / 2) * cf;\n\t\tR = A.substr(-z / 2, n - z / 2);\n\t\treturn true;\n\t}\n\n\tstatic Poly multiply_all(vector<Poly> polys) {\n\t\tif (polys.empty()) return Poly({1});\n\t\tset<pii> setik;\n\t\tfor (int i = 0; i < (int)polys.size(); i++)\n\t\t\tsetik.insert(mp(polys[i].deg(), i));\n\t\twhile((int)setik.size() > 1) {\n\t\t\tint p = setik.begin()->second;\n\t\t\tsetik.erase(setik.begin());\n\t\t\tint q = setik.begin()->second;\n\t\t\tsetik.erase(setik.begin());\n\t\t\tpolys[p] *= polys[q];\n\t\t\tsetik.insert(mp(polys[p].deg(), p));\n\t\t}\n\t\treturn polys[setik.begin()->second];\n\t}\n\tstatic Poly given_roots(const vector<Mint> &xs) {\n\t\tint n = (int)xs.size();\n\t\tvector<Poly> polys(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tpolys[i] = Poly({Mint() - xs[i], 1});\n\t\treturn multiply_all(polys);\n\t}\n\n\tvector<Mint> multipoint(const vector<Mint> &xs) const {\n\t\tint n = (int)xs.size();\n\t\tif (n == 0) return {};\n\t\tif (n == 1) return {eval(xs[0])};\n\t\tint L = n;\n\t\twhile(L & (L - 1)) L++;\n\t\tvector<Poly> tree(2 * L);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ttree[L + i] = Poly({Mint() - xs[i], 1});\n\t\tfor (int i = n; i < L; i++)\n\t\t\ttree[L + i] = Poly({1});\n\t\tfor (int i = L - 1; i > 0; i--)\n\t\t\ttree[i] = tree[2 * i] * tree[2 * i + 1];\n\t\ttree[1] = *this % tree[1];\n\t\tfor (int i = 2; i < L + n; i++)\n\t\t\ttree[i] = tree[i / 2] % tree[i];\n\t\tvector<Mint> res(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres[i] = tree[L + i].at(0);\n\t\treturn res;\n\t}\n\tstatic pair<Poly, Poly> interpolate_(const vector<pair<Mint, Mint>> &vals, int l, int r) {\n\t\tif (r - l == 1) return mp(Poly({vals[l].second}), Poly({Mint() - vals[l].first, 1}));\n\t\tint m = (l + r) / 2;\n\t\tauto L = interpolate_(vals, l, m), R = interpolate_(vals, m, r);\n\t\treturn mp(L.first * R.second + R.first * L.second, L.second * R.second);\n\n\t}\n\tstatic Poly interpolate(vector<pair<Mint, Mint>> vals) {\n\t\tif (vals.empty()) return Poly();\n\t\tint n = (int)vals.size();\n\t\tvector<Mint> xs(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\txs[i] = vals[i].first;\n\t\tPoly P = given_roots(xs);\n\t\tP = P.derivate();\n\t\tvector<Mint> cf = P.multipoint(xs);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tvals[i].second /= cf[i];\n\t\treturn interpolate_(vals, 0, (int)vals.size()).first;\n\t}\n\tPoly x_k_mod_this(ll k) const { // x^k % P\n\t\tPoly res = Poly({1});\n\t\tint t = 0;\n\t\twhile((1LL << t) <= k) t++;\n\t\tfor (int i = t - 1; i >= 0; i--) {\n\t\t\tres *= res;\n\t\t\tif ((k >> i) & 1) res = res.substr(-1, res.deg() + 1);\n\t\t\tres %= *this;\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<Mint> chirp_z(Mint z, int n) const { // eval at [z^0, z^1, ..., z^(n-1)]\n\t\tint m = deg();\n\t\tif (m < 0 || n == 0) return vector<Mint>(n);\n\t\tif (z == 0) {\n\t\t\tvector<Mint> res(n, at(0));\n\t\t\tres[0] = eval(1);\n\t\t\treturn res;\n\t\t}\n\t\tMint zi = z.inv();\n\t\tvector<Mint> Z(n + m, 1), Zi(max(m + 1, n), 1);\n\t\tMint w = 1, wi = 1;\n\t\tfor (int i = 1; i < (int)Z.size(); i++) {\n\t\t\tZ[i] = Z[i - 1] * w;\n\t\t\tw *= z;\n\t\t}\n\t\tfor (int i = 1; i < (int)Zi.size(); i++) {\n\t\t\tZi[i] = Zi[i - 1] * wi;\n\t\t\twi *= zi;\n\t\t}\n\t\tvector<Mint> f(m + 1);\n\t\tfor (int i = 0; i <= m; i++)\n\t\t\tf[i] = at(i) * Zi[i];\n\t\treverse(all(Z));\n\t\tPoly C = Poly(f) * Z;\n\t\tvector<Mint> res(n);\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tres[k] = C.at(n + m - 1 - k) * Zi[k];\n\t\treturn res;\n\t}\n\n\tPoly shift_c(Mint c) const { // P(x + c)\n\t\tint n = deg();\n\t\tif (n < 0) return Poly();\n\t\tFactorials F(n);\n\t\tPowers P(n, c);\n\t\tvector<Mint> f(n + 1), g(n + 1);\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tf[i] = at(i) * F.f[i];\n\t\t\tg[i] = P.pow(i) * F.fi[i];\n\t\t}\n\t\treverse(all(g));\n\t\tPoly C = Poly(f) * g;\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tf[i] = C.at(n + i) * F.fi[i];\n\t\treturn f;\n\t}\n};\n\ntemplate<uint mod = MOD>\nvector<mint<mod>> BerlekampMassey(vector<mint<mod>> x) {\n    using Mint = mint<mod>;\n    vector<Mint> ls, cur;\n    int lf;\n    Mint ld;\n    for (int i = 0; i < (int)x.size(); i++) {\n        Mint t = 0;\n        for (int j = 0; j < (int)cur.size(); j++)\n            t += cur[j] * x[i - j - 1];\n        if (t == x[i]) continue;\n        if (cur.empty()) {\n            cur.resize(i + 1);\n            lf = i;\n            ld = t - x[i];\n            continue;\n        }\n        Mint k = (t - x[i]) / ld;\n        vector<Mint> c(i - lf - 1);\n        c.push_back(k);\n        for (auto t : ls) {\n            c.push_back(Mint() - t * k);\n        }\n        if (c.size() < cur.size()) c.resize(cur.size());\n        for (int j = 0; j < (int)cur.size(); j++)\n            c[j] += cur[j];\n        if (i - lf + (int)ls.size() >= (int)cur.size()) {\n            ls = cur;\n            lf = i;\n            ld = t - x[i];\n        }\n        cur = c;\n    }\n    return cur;\n}\n\n// CALL initFFT() and CHECK LOG\n\nconst int N = 200200;\nint n, k, f;\nMint a[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tinitFFT();\n\n\tscanf(\"%d%d%d\", &n, &k, &f);\n\tfor (int i = 0; i <= k; i++)\n\t\ta[i] = 1;\n\tn--;\n\twhile(n--) {\n\t\tvector<Mint> b(k + 1, 0);\n\t\tfor (int i = 0; i <= k; i++)\n\t\t\tb[i] = a[i];\n\t\tPoly<> C = Poly<>(b) * Poly<>(b);\n\t\tMint sum = 0;\n\t\tfor (int i = C.deg(); i >= 0; i--) {\n\t\t\tsum += C.at(i);\n\t\t\tif (i <= k) {\n\t\t\t\ta[i] = sum;\n\t\t\t\ta[i] += C.at(i) * (k - i);\n\t\t\t}\n\t\t}\n\t}\n\tvector<Mint> b(k + 1, 0);\n\tfor (int i = 0; i <= k; i++)\n\t\tb[i] = a[i];\n\tPoly<> C = Poly<>(b) * Poly<>(b);\n\tprintf(\"%u\\n\", C.at(f).x);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp",
        "fft",
        "flows",
        "graphs",
        "math",
        "meet-in-the-middle",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Multiset of Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/105164",
    "editorial": "First of all, letâs visualize the problem in a different way. We have to\r\nset some constraints on the number of strings which have some kind of\r\nprefix. Letâs think about a data structure that would allow us to\r\nunderstand it better. One of the most common data structures to store\r\nstrings which works with their prefixes and maintains the number of\r\nstrings with some prefix is a trie; so, we can reformulate this problem\r\nusing tries.Now the problem is the following one: we have a binary trie\r\nof depth ; the leaves of this trie may store strings, and for each\r\nvertex except for the root, we can set a constraint on the number of\r\nstrings stored in the subtree; what is the number of ways to choose\r\nthese constraints so that the maximum number of strings (possibly with\r\ncopies) the trie can store is exactly ? To handle it, we can use dynamic\r\nprogramming of the form the number of ways to choose the constraints for\r\nthe vertex and its subtree so that the maximum number of strings which\r\ncan be stored in the subtree is exactly . When calculating , we can\r\niterate on the constraint for the vertex (let it be ), and the maximum\r\nnumber of strings in the subtrees of and (let these be and ), and make\r\nupdates of the form \"add to the value of \". This dynamic programming\r\nwill work in or depending on the implementation, which is too\r\nslow.However, we can use the following optimizations to improve the\r\ncomplexity of the solution: all vertices on the same depth can be\r\ntreated as equivalent, so we can actually calculate this dynamic\r\nprogramming not for vertices, but just for ; when handling transitions\r\nfrom some nodeâs children to that node, letâs split these transitions\r\ninto two steps. The first step is iterating on the number of strings\r\nwhich fit into the subtrees of the children; the second step is\r\niterating on the constraint for the subtree of the node. The first step\r\nis actually a convolution: if we donât consider the constraint for the\r\nnode itself, then the transitions would be something like \"add to the\r\nvalue of \"; so it can be improved to with FFT. The second step can be\r\nimproved to as well, if we iterate on the minimum between the constraint\r\nfor the node and the total number of strings which can be stored in the\r\nchildren, and maintain the sum on suffix for the values of dynamic\r\nprogramming. Overall, these optimizations lead to a solution with\r\ncomplexity .\r\n",
    "hint": []
}