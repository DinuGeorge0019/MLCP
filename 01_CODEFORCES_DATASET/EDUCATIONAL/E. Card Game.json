{
    "link": "https://codeforces.com//contest/2025/problem/E",
    "problemId": "2948775",
    "problem_idx": "E",
    "shortId": "2025E",
    "contest_number": "2025",
    "problem_submissions": {
        "G": [
            285888128,
            285968165,
            285968156,
            285968149,
            285968144,
            285897832,
            285920810,
            285910851,
            285909011,
            285930826,
            285929850,
            285925790,
            285926690,
            285922742,
            285921341,
            285927635,
            285927533,
            285927378,
            285927290,
            285927201,
            285926718,
            285927241,
            285924989,
            299831833,
            286121442
        ],
        "F": [
            285868426,
            285875834,
            285881666,
            285895954,
            285888111,
            285886401,
            285885303,
            285891958,
            285893731,
            285892263,
            285879653,
            285886660,
            285891778,
            285886231,
            285896708,
            285895437,
            285887128,
            285901645,
            285898009,
            285911413,
            285909168
        ],
        "E": [
            285859957,
            285867757,
            285870223,
            285876387,
            285873807,
            285876494,
            285872556,
            285873708,
            285881956,
            285870423,
            285874469,
            285878077,
            285869033,
            285872685,
            285876656,
            285892958,
            285888168,
            285880850,
            285877703,
            285879472
        ],
        "C": [
            285855265,
            285848963,
            285851041,
            285855836,
            285849335,
            285851254,
            285854960,
            285854181,
            285864164,
            285852009,
            285850624,
            285853432,
            285850248,
            285850107,
            285852412,
            285937663,
            285937269,
            285852480,
            285853757,
            285856229,
            285852397,
            285853481
        ],
        "D": [
            285854273,
            285858071,
            285858183,
            285867921,
            285860641,
            285863810,
            285864716,
            285864881,
            285873876,
            285863514,
            285859817,
            285865001,
            285869981,
            285860140,
            285866304,
            285941352,
            285868260,
            285864450,
            285868121,
            285865847,
            285869499
        ],
        "B": [
            285844312,
            285844368,
            285843910,
            285848590,
            285844872,
            285845275,
            285846752,
            285845703,
            285858394,
            285844772,
            285844563,
            285847140,
            285845401,
            285845320,
            285848121,
            285848201,
            285847162,
            285850578,
            285846812,
            285847900
        ],
        "A": [
            285841954,
            285841960,
            285842031,
            285842286,
            285842224,
            285842066,
            285842261,
            285842191,
            285843710,
            285842044,
            285842146,
            285842134,
            285841991,
            285842021,
            285846906,
            285842091,
            285842126,
            285842764,
            285842102,
            285842266
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135173",
    "editorial": "Suppose weâre solving the problem for one suit. Consider a distribution\r\nof cards between two players; how to check if at least one matching\r\nbetween cards of the first player and cards of the second player\r\nexists?Letâs order the cards from the highest rank to the lowest rank\r\nand go through them in that order. If we get a card of the first player,\r\nwe can add it to the \"pool\" of cards to be matched; if we get a card\r\nbelonging to the second player, we match it with one of the cards from\r\nthe \"pool\" (if there are none there is no valid matching). So, if there\r\nexists a prefix of this order where the number of cards of the second\r\nplayer exceeds the number of cards belonging to the first player, it is\r\nnot a valid distribution. Does this sound familiar?Letâs say that a card\r\nbelonging to the first player is represented by an opening bracket, and\r\na card belonging to the second player is represented by a closing\r\nbracket. Then, if we need to solve the problem for just one suit, the\r\ndistribution must be a regular bracket sequence. So, in this case, we\r\njust need to count the number of regular bracket sequences.However, if\r\nthere are at least suits, there might be \"extra\" cards of the -st suit\r\nbelonging to the first player, which we can match with \"extra\" cards of\r\nother suits belonging to the second player. To resolve this issue, we\r\ncan use the following dynamic programming: let be the number of ways to\r\ndistribute the cards of the first suits so that there are extra cards of\r\nthe -st suit belonging to the -st player.To calculate , we have to count\r\nthe number of bracket sequences such that the balance on each prefix is\r\nat least , and the balance of the whole sequence is exactly . In my\r\nopinion, the easiest way to do this is to run another dynamic\r\nprogramming (something like \" is the number of sequences with elements\r\nand balance \"); however, you can try solving it in a combinatorial way\r\nsimilar to how Catalan numbers are calculated.What about transitions\r\nfrom to ? Letâs iterate on the number of \"extra\" cards we will use to\r\nmatch the cards of the -th suit belonging to the second player, so we\r\ntransition from to . Now we need to count the ways to distribute cards\r\nof the same suit so that the second player receives cards more than the\r\nfirst player, and all cards of the first player can be matched. Consider\r\nthat we ordered the cards from the lowest rank to the highest rank.\r\nThen, on every prefix, the number of cards belonging to the first player\r\nshould not exceed the number of cards belonging to the second player\r\n(otherwise we wonât be able to match all cards belonging to the first\r\nplayer), and in total, the number of cards belonging to the second\r\nplayer should be greater by . So this is exactly the number of bracket\r\nsequences with balance on every prefix and balance equal to in total\r\n(and we have already calculated that)!So, the solution consists of two\r\nsteps. First, for every , we calculate the number of bracket sequences\r\nwith non-negative balance on each prefix and total balance equal to ;\r\nthen we run dynamic programming of the form \" is the number of ways to\r\ndistribute the cards of the first suits so that there are extra cards of\r\nthe -st suit belonging to the -st player\". The most time-consuming part\r\nof the solution is this dynamic programming, and it works in , so the\r\nwhole solution works in .\r\n",
    "name": "E. Card Game",
    "statement": "In the most popular card game in Berland, a deck of n\r\ntimes m cards is used. Each card has two parameters: suit and rank.\r\nSuits in the game are numbered from 1 to n, and ranks are numbered from\r\n1 to m. There is exactly one card in the deck for each combination of\r\nsuit and rank.A card with suit a and rank b can beat a card with suit c\r\nand rank d in one of two cases: a = 1, c\r\nne 1 (a card of suit 1 can beat a card of any other suit); a = c, b > d\r\n(a card can beat any other card of the same suit but of a lower rank).\r\nTwo players play the game. Before the game starts, they receive exactly\r\nhalf of the deck each. The first player wins if for every card of the\r\nsecond player, he can choose his card that can beat it, and there is no\r\ncard that is chosen twice (i. e. there exists a matching of the first\r\nplayer’s cards with the second player’s cards such that in each pair the\r\nfirst player’s card beats the second player’s card). Otherwise, the\r\nsecond player wins.Your task is to calculate the number of ways to\r\ndistribute the cards so that the first player wins. Two ways are\r\nconsidered different if there exists a card such that in one way it\r\nbelongs to the first player and in the other way it belongs to the\r\nsecond player. The number of ways can be very large, so print it modulo\r\n998244353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long;using u64 = unsigned long long;using u32 = unsigned; // TODO: Dynamic ModInt template<typename T>constexpr T power(T a, u64 b) {    T res {1};    for (; b != 0; b /= 2, a *= a) {        if (b % 2 == 1) {            res *= a;        }    }    return res;} template<u32 P>constexpr u32 mulMod(u32 a, u32 b) {    return 1ULL * a * b % P;} template<u64 P>constexpr u64 mulMod(u64 a, u64 b) {    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;    res %= P;    return res;} template<typename U, U P>requires std::unsigned_integral<U>struct ModIntBase {public:    constexpr ModIntBase() : x(0) {}        template<typename T>    requires std::integral<T>    constexpr ModIntBase(T x_) : x(norm(x_ % T {P})) {}        constexpr static U norm(U x) {        if ((x >> (8 * sizeof(U) - 1) & 1) == 1) {            x += P;        }        if (x >= P) {            x -= P;        }        return x;    }        constexpr U val() const {        return x;    }        constexpr ModIntBase operator-() const {        ModIntBase res;        res.x = norm(P - x);        return res;    }        constexpr ModIntBase inv() const {        return power(*this, P - 2);    }        constexpr ModIntBase &operator*=(const ModIntBase &rhs) & {        x = mulMod<P>(x, rhs.val());        return *this;    }        constexpr ModIntBase &operator+=(const ModIntBase &rhs) & {        x = norm(x + rhs.x);        return *this;    }        constexpr ModIntBase &operator-=(const ModIntBase &rhs) & {        x = norm(x - rhs.x);        return *this;    }        constexpr ModIntBase &operator/=(const ModIntBase &rhs) & {        return *this *= rhs.inv();    }        friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase &rhs) {        lhs *= rhs;        return lhs;    }        friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase &rhs) {        lhs += rhs;        return lhs;    }        friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase &rhs) {        lhs -= rhs;        return lhs;    }        friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase &rhs) {        lhs /= rhs;        return lhs;    }        friend constexpr std::ostream &operator<<(std::ostream &os, const ModIntBase &a) {        return os << a.val();    }        friend constexpr bool operator==(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() == rhs.val();    }        friend constexpr bool operator!=(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() != rhs.val();    }        friend constexpr bool operator<(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() < rhs.val();    }    private:    U x;}; template<u32 P>using ModInt = ModIntBase<u32, P>; template<u64 P>using ModInt64 = ModIntBase<u64, P>; constexpr u32 P = 998244353;using Z = ModInt<P>; int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int n, m;    std::cin >> n >> m;        std::vector<Z> dp(m + 1);    dp[0] = 1;    for (int i = 0; i < m; i++) {        std::vector<Z> ndp(m + 1);        for (int j = i; j >= 0; j--) {            ndp[j + 1] += dp[j];            if (j) {                ndp[j - 1] += dp[j];            }        }        std::swap(dp, ndp);    }        std::vector<Z> f(m + 1);    f[0] = 1;    for (int i = 0; i < n - 1; i++) {        std::vector<Z> nf(m + 1);        for (int x = 0; x <= m; x++) {            for (int y = 0; x + y <= m; y++) {                nf[x + y] += f[x] * dp[y];            }        }        std::swap(f, nf);    }        Z ans = 0;    for (int i = 0; i <= m; i++) {        ans += dp[i] * f[i];    }    std::cout << ans << \"\\n\";        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "fft",
        "greedy",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Card Game.json",
    "hint": []
}