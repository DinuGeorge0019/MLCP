{
    "link": "https://codeforces.com//contest/2075/problem/F",
    "problemId": "3273595",
    "problem_idx": "F",
    "shortId": "2075F",
    "contest_number": "2075",
    "problem_submissions": {
        "F": [
            311092897,
            311105371,
            311091977,
            311106822,
            311119612,
            311127395,
            311111998,
            311124374,
            311123265,
            311135481,
            311127374,
            311124949,
            311133033,
            311127513,
            311123593,
            311131608,
            311137578,
            311136881,
            311133323,
            311066636
        ],
        "E": [
            311078477,
            311076658,
            311072206,
            311087192,
            311086935,
            311076933,
            311081142,
            311089235,
            311087311,
            311085142,
            311096896,
            311100487,
            311099554,
            311111156,
            311091394,
            311097405,
            311088422,
            311171203,
            311103877,
            311113693,
            311080280
        ],
        "D": [
            311061322,
            311057750,
            311060365,
            311055119,
            311060010,
            311059723,
            311071257,
            311070356,
            311063998,
            311066698,
            311082700,
            311064184,
            311068410,
            311078395,
            311082862,
            311069076,
            311068306,
            311073979,
            311087117,
            311088989
        ],
        "C": [
            311052044,
            311051318,
            311056183,
            311050640,
            311054145,
            311055185,
            311051870,
            311052149,
            311059642,
            311052003,
            311055738,
            311055390,
            311062256,
            311062646,
            311066843,
            311053249,
            311062988,
            311059819,
            311096162
        ],
        "B": [
            311045239,
            311044707,
            311043555,
            311043641,
            311046416,
            311046113,
            311044758,
            311043793,
            311048255,
            311045137,
            311044396,
            311044990,
            311049796,
            311048015,
            311058751,
            311045105,
            311045287,
            311046394,
            311099408
        ],
        "A": [
            311042018,
            311040390,
            311040326,
            311040380,
            311040339,
            311040623,
            311040931,
            311040288,
            311041987,
            311040424,
            311040342,
            311040291,
            311041844,
            311040490,
            311049977,
            311040412,
            311040468,
            311040975,
            311101264
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140781",
    "editorial": "For the start, let’s note that the definition of the beauty of a\r\nsequence is equivalent to the following: a sequence is if and only if\r\nthe first element is a unique minimum and the last element is a unique\r\nmaximum.Next, consider each element of the array as a point in : let’s\r\ntransform into the point . Observe that the length of the longest\r\nbeautiful subsequence can be found as follows: iterate over the position\r\nof the start of the subsequence and the position of the end of the\r\nsubsequence; look at the rectangle where the bottom left point is and\r\nthe top right point is ; take the corners and all points that lie\r\nstrictly inside this rectangle. The algorithm described above will\r\ndefinitely find the answer, but it works too slowly, so let’s try to\r\nspeed it up.Notice that if the chosen point has another point , such\r\nthat and , then the answer for will definitely be no worse than for ,\r\nwhich means we do not need to check the answer for . Therefore, let’s\r\nwrite down in a separate array only those elements that make sense to\r\nchoose as the bottom left corners of the rectangle. These will be\r\nindices such that for all , (we will call them prefix minimums).Note\r\nthat the resulting array has interesting monotonicity properties: and at\r\nthe same time . Therefore, if we look at an arbitrary point , the left\r\ncorners of the rectangles it falls into form an in the array , the\r\nboundaries of which can be found using binary search: is the minimum\r\nsuch that ; is the minimum such that . Thus, for each point, we can\r\nprecompute which bottom left corners are \"suitable\" for it.Now, let’s\r\nnote that a similar situation occurs with the top right point: we are\r\nonly interested in points that form \"suffix maximums\". They will have\r\nsimilar monotonicity: as we move from right to left, the values will\r\nonly increase.Therefore, let’s iterate over the right corner of the\r\nrectangle from right to left, maintaining the necessary information for\r\nall left corners. Specifically, we will \"include\" and \"exclude\" points,\r\nand for each left corner, we will keep track of how many included points\r\nare located to its top right.Assume that for the current right corner ,\r\nwe have included only points that lie strictly to its bottom left. Then\r\nwe can already find the answer for it as follows: let’s take the maximum\r\nover the left corners from the interval only these corners can be bottom\r\nleft for the current corner, and the necessary values are already\r\nthere.When we need to move from the right corner to the corner , we know\r\nthat . Therefore, we need to: include all points for which ; exclude all\r\npoints for which . Including/excluding a point is simply adding over the\r\ninterval .Note that each point is included and excluded no more than\r\nonce, which means there will be no more than operations of addition over\r\nthe segment.To handle the addition over a segment and the maximum over a\r\nsegment, it is sufficient to use a Segment Tree. Thus, the resulting\r\nasymptotic complexity is .\r\n",
    "name": "F. Beautiful Sequence Returns",
    "statement": "Let’s call an integer sequence if the following conditions hold: for\r\nevery element except the first one, there is an element to the left less\r\nthan it; for every element except the last one, there is an element to\r\nthe right larger than it; For example, [1, 2], [42], [1, 4, 2, 4, 7],\r\nand [1, 2, 4, 8] are beautiful, but [2, 2, 4] and [1, 3, 5, 3] are\r\nnot.Recall that a subsequence is a sequence that can be obtained from\r\nanother sequence by removing some elements (possibly zero) without\r\nchanging the order of the remaining elements.You are given an integer\r\narray a of size n. Find the longest beautiful subsequence of the array a\r\nand print its length.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "implementation"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Beautiful Sequence Returns.json"
}