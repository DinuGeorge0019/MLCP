{
    "link": "https://codeforces.com//contest/1895/problem/G",
    "problemId": "2305461",
    "problem_idx": "G",
    "shortId": "1895G",
    "contest_number": "1895",
    "problem_submissions": {
        "F": [
            231327821,
            231171975,
            231177341,
            231177139,
            231181247,
            231175451,
            231179505,
            231178754,
            231171033,
            231178007,
            231174701,
            231183326,
            231187269,
            231180010,
            231181283,
            231185538,
            231191457,
            231188914,
            231183055,
            231180065,
            231188744
        ],
        "E": [
            231166411,
            231162837,
            231168539,
            231171744,
            231170279,
            231169982,
            231169182,
            231183134,
            231173048,
            231168317,
            231174671,
            231173323,
            231173438,
            231175391,
            231175133,
            231176680,
            231179383,
            231171479,
            231175722,
            231195510
        ],
        "D": [
            231152062,
            231147559,
            231156462,
            231152946,
            231160742,
            231157174,
            231157872,
            231159102,
            231163758,
            231163699,
            231163345,
            231153744,
            231159964,
            231158155,
            231162193,
            231160798,
            231161526,
            231144729,
            231162242,
            231164715,
            231182588,
            231152194
        ],
        "C": [
            231148538,
            231143114,
            231150605,
            231147252,
            231154149,
            231154615,
            231153991,
            231151789,
            231144066,
            231169078,
            231151364,
            231154661,
            231154195,
            231153927,
            231153798,
            231162003,
            231153879,
            231145977,
            231148366,
            231148040
        ],
        "B": [
            231139170,
            231136290,
            231139512,
            231137580,
            231137719,
            231135569,
            231140209,
            231138699,
            231136948,
            231136771,
            231139306,
            231136791,
            231139010,
            231138206,
            231140302,
            231137608,
            231140161,
            231139339,
            231137240,
            231137323
        ],
        "A": [
            231135878,
            231135554,
            231135956,
            231135743,
            231135841,
            231137384,
            231140495,
            231135913,
            231135720,
            231135699,
            231136135,
            231135592,
            231135620,
            231135621,
            231136784,
            231135521,
            231136631,
            231135611,
            231135732,
            231135594
        ],
        "G": [
            231214354,
            231210500,
            231273875,
            231214703,
            231213900,
            231213313
        ]
    },
    "name": "G. Two Characters, Two Colors",
    "statement": "You are given a string consisting of characters and/or . You have to\r\npaint every character of this string into one of two colors, red or\r\nblue.If you paint the i-th character red, you get r_i coins. If you\r\npaint it blue, you get b_i coins.After coloring the string, you remove\r\nevery character from it, and count the number of inversions in the\r\nresulting string (i. e. the number of pairs of characters such that the\r\nleft character in the pair is , and the right character in the pair is\r\n). For each inversion, you have to pay 1 coin.What is the maximum number\r\nof coins you can earn?\r\n",
    "solutions": [
        "#pragma region Macros\n#ifdef noimi\n#include \"my_template.hpp\"\n#else\n\n#include <immintrin.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cfenv>\n#include <cfloat>\n#include <chrono>\n#include <cinttypes>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <immintrin.h>\n#include <initializer_list>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <streambuf>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <utility>\n#include <variant>\n\n#ifdef noimi\n#define oj_local(a, b) b\n#else\n#define oj_local(a, b) a\n#endif\n\n#define LOCAL if(oj_local(0, 1))\n#define OJ if(oj_local(1, 0))\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long int;\nusing i128 = __int128_t;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing ld = long double;\ntemplate <typename T> using vc = vector<T>;\ntemplate <typename T> using vvc = vector<vc<T>>;\ntemplate <typename T> using vvvc = vector<vvc<T>>;\nusing vi = vc<int>;\nusing vl = vc<ll>;\nusing vpi = vc<pii>;\nusing vpl = vc<pll>;\ntemplate <class T> using pq = priority_queue<T>;\ntemplate <class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> int si(const T &x) { return x.size(); }\ntemplate <class T, class S> inline bool chmax(T &a, const S &b) { return (a < b ? a = b, 1 : 0); }\ntemplate <class T, class S> inline bool chmin(T &a, const S &b) { return (a > b ? a = b, 1 : 0); }\nvi iota(int n) {\n    vi a(n);\n    return iota(a.begin(), a.end(), 0), a;\n}\ntemplate <typename T> vi iota(const vector<T> &a, bool greater = false) {\n    vi res(a.size());\n    iota(res.begin(), res.end(), 0);\n    sort(res.begin(), res.end(), [&](int i, int j) {\n        if(greater) return a[i] > a[j];\n        return a[i] < a[j];\n    });\n    return res;\n}\n\n// macros\n#define overload5(a, b, c, d, e, name, ...) name\n#define overload4(a, b, c, d, name, ...) name\n#define endl '\\n'\n#define REP0(n) for(ll jidlsjf = 0; jidlsjf < n; ++jidlsjf)\n#define REP1(i, n) for(ll i = 0; i < (n); ++i)\n#define REP2(i, a, b) for(ll i = (a); i < (b); ++i)\n#define REP3(i, a, b, c) for(ll i = (a); i < (b); i += (c))\n#define rep(...) overload4(__VA_ARGS__, REP3, REP2, REP1, REP0)(__VA_ARGS__)\n#define per0(n) for(int jidlsjf = 0; jidlsjf < (n); ++jidlsjf)\n#define per1(i, n) for(ll i = (n)-1; i >= 0; --i)\n#define per2(i, a, b) for(ll i = (a)-1; i >= b; --i)\n#define per3(i, a, b, c) for(ll i = (a)-1; i >= (b); i -= (c))\n#define per(...) overload4(__VA_ARGS__, per3, per2, per1, per0)(__VA_ARGS__)\n#define fore0(a) rep(a.size())\n#define fore1(i, a) for(auto &&i : a)\n#define fore2(a, b, v) for(auto &&[a, b] : v)\n#define fore3(a, b, c, v) for(auto &&[a, b, c] : v)\n#define fore4(a, b, c, d, v) for(auto &&[a, b, c, d] : v)\n#define fore(...) overload5(__VA_ARGS__, fore4, fore3, fore2, fore1, fore0)(__VA_ARGS__)\n#define setbits(j, n) for(ll iiiii = (n), j = lowbit(iiiii); iiiii; iiiii ^= 1 << j, j = lowbit(iiiii))\n#define perm(v) for(bool permrepflag = true; (permrepflag ? exchange(permrepflag, false) : next_permutation(all(v)));)\n#define fi first\n#define se second\n#define pb push_back\n#define ppb pop_back\n#define ppf pop_front\n#define eb emplace_back\n#define drop(s) cout << #s << endl, exit(0)\n#define si(c) (int)(c).size()\n#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))\n#define lbg(c, x) distance((c).begin(), lower_bound(all(c), (x), greater{}))\n#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))\n#define ubg(c, x) distance((c).begin(), upper_bound(all(c), (x), greater{}))\n#define rng(v, l, r) v.begin() + (l), v.begin() + (r)\n#define all(c) begin(c), end(c)\n#define rall(c) rbegin(c), rend(c)\n#define SORT(v) sort(all(v))\n#define REV(v) reverse(all(v))\n#define UNIQUE(x) SORT(x), x.erase(unique(all(x)), x.end())\ntemplate <typename T = ll, typename S> T SUM(const S &v) { return accumulate(all(v), T(0)); }\n#define MIN(v) *min_element(all(v))\n#define MAX(v) *max_element(all(v))\n#define overload2(_1, _2, name, ...) name\n#define vec(type, name, ...) vector<type> name(__VA_ARGS__)\n#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))\n#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))\n#define vvvv(type, name, a, b, c, ...)                                                                                                                         \\\n    vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\nconstexpr pii dx4[4] = {pii{1, 0}, pii{0, 1}, pii{-1, 0}, pii{0, -1}};\nconstexpr pii dx8[8] = {{1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1}};\n\nnamespace yesno_impl {\nconst string YESNO[2] = {\"NO\", \"YES\"};\nconst string YesNo[2] = {\"No\", \"Yes\"};\nconst string yesno[2] = {\"no\", \"yes\"};\nconst string firstsecond[2] = {\"second\", \"first\"};\nconst string FirstSecond[2] = {\"Second\", \"First\"};\nconst string possiblestr[2] = {\"impossible\", \"possible\"};\nconst string Possiblestr[2] = {\"Impossible\", \"Possible\"};\nvoid YES(bool t = 1) { cout << YESNO[t] << endl; }\nvoid NO(bool t = 1) { YES(!t); }\nvoid Yes(bool t = 1) { cout << YesNo[t] << endl; }\nvoid No(bool t = 1) { Yes(!t); }\nvoid yes(bool t = 1) { cout << yesno[t] << endl; }\nvoid no(bool t = 1) { yes(!t); }\nvoid first(bool t = 1) { cout << firstsecond[t] << endl; }\nvoid First(bool t = 1) { cout << FirstSecond[t] << endl; }\nvoid possible(bool t = 1) { cout << possiblestr[t] << endl; }\nvoid Possible(bool t = 1) { cout << Possiblestr[t] << endl; }\n}; // namespace yesno_impl\nusing namespace yesno_impl;\n\n#define INT(...)                                                                                                                                               \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN(__VA_ARGS__)\n#define INTd(...)                                                                                                                                              \\\n    int __VA_ARGS__;                                                                                                                                           \\\n    IN2(__VA_ARGS__)\n#define LL(...)                                                                                                                                                \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN(__VA_ARGS__)\n#define LLd(...)                                                                                                                                               \\\n    ll __VA_ARGS__;                                                                                                                                            \\\n    IN2(__VA_ARGS__)\n#define STR(...)                                                                                                                                               \\\n    string __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define CHR(...)                                                                                                                                               \\\n    char __VA_ARGS__;                                                                                                                                          \\\n    IN(__VA_ARGS__)\n#define DBL(...)                                                                                                                                               \\\n    double __VA_ARGS__;                                                                                                                                        \\\n    IN(__VA_ARGS__)\n#define VEC(type, name, size)                                                                                                                                  \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN(name)\n#define VECd(type, name, size)                                                                                                                                 \\\n    vector<type> name(size);                                                                                                                                   \\\n    IN2(name)\n#define VEC2(type, name1, name2, size)                                                                                                                         \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i])\n#define VEC2d(type, name1, name2, size)                                                                                                                        \\\n    vector<type> name1(size), name2(size);                                                                                                                     \\\n    for(int i = 0; i < size; i++) IN2(name1[i], name2[i])\n#define VEC3(type, name1, name2, name3, size)                                                                                                                  \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i])\n#define VEC3d(type, name1, name2, name3, size)                                                                                                                 \\\n    vector<type> name1(size), name2(size), name3(size);                                                                                                        \\\n    for(int i = 0; i < size; i++) IN2(name1[i], name2[i], name3[i])\n#define VEC4(type, name1, name2, name3, name4, size)                                                                                                           \\\n    vector<type> name1(size), name2(size), name3(size), name4(size);                                                                                           \\\n    for(int i = 0; i < size; i++) IN(name1[i], name2[i], name3[i], name4[i]);\n#define VEC4d(type, name1, name2, name3, name4, size)                                                                                                          \\\n    vector<type> name1(size), name2(size), name3(size), name4(size);                                                                                           \\\n    for(int i = 0; i < size; i++) IN2(name1[i], name2[i], name3[i], name4[i]);\n#define VV(type, name, h, w)                                                                                                                                   \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN(name)\n#define VVd(type, name, h, w)                                                                                                                                  \\\n    vector<vector<type>> name(h, vector<type>(w));                                                                                                             \\\n    IN2(name)\nint scan() { return getchar(); }\nvoid scan(int &a) { cin >> a; }\nvoid scan(long long &a) { cin >> a; }\nvoid scan(char &a) { cin >> a; }\nvoid scan(double &a) { cin >> a; }\nvoid scan(string &a) { cin >> a; }\ntemplate <class T, class S> void scan(pair<T, S> &p) { scan(p.first), scan(p.second); }\ntemplate <class T> void scan(vector<T> &);\ntemplate <class T> void scan(vector<T> &a) {\n    for(auto &i : a) scan(i);\n}\ntemplate <class T> void scan(T &a) { cin >> a; }\nvoid IN() {}\nvoid IN2() {}\ntemplate <class Head, class... Tail> void IN(Head &head, Tail &...tail) {\n    scan(head);\n    IN(tail...);\n}\ntemplate <class Head, class... Tail> void IN2(Head &head, Tail &...tail) {\n    scan(head);\n    --head;\n    IN2(tail...);\n}\n\ntemplate <int p = -1> void pat() {}\ntemplate <int p = -1, class Head, class... Tail> void pat(Head &h, Tail &...tail) {\n    h += p;\n    pat<p>(tail...);\n}\n\ntemplate <typename T, typename S> T ceil(T x, S y) {\n    assert(y);\n    return (y < 0 ? ceil(-x, -y) : (x > 0 ? (x + y - 1) / y : x / y));\n}\n\ntemplate <typename T, typename S> T floor(T x, S y) {\n    assert(y);\n    return (y < 0 ? floor(-x, -y) : (x > 0 ? x / y : x / y - (x % y == 0 ? 0 : 1)));\n}\ntemplate <typename T, typename S, typename U> U bigmul(const T &x, const S &y, const U &lim) { // clamp(x * y, -lim, lim)\n    if(x < 0 and y < 0) return bigmul(-x, -y, lim);\n    if(x < 0) return -bigmul(-x, y, lim);\n    if(y < 0) return -bigmul(x, -y, lim);\n    return y == 0 or x <= lim / y ? x * y : lim;\n}\ntemplate <class T> T POW(T x, int n) {\n    T res = 1;\n    for(; n; n >>= 1, x *= x)\n        if(n & 1) res *= x;\n    return res;\n}\ntemplate <class T, class S> T POW(T x, S n, const ll &mod) {\n    T res = 1;\n    x %= mod;\n    for(; n; n >>= 1, x = x * x % mod)\n        if(n & 1) res = res * x % mod;\n    return res;\n}\nvector<pll> factor(ll x) {\n    vector<pll> ans;\n    for(ll i = 2; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.push_back({i, 1});\n            while((x /= i) % i == 0) ans.back().second++;\n        }\n    if(x != 1) ans.push_back({x, 1});\n    return ans;\n}\ntemplate <class T> vector<T> divisor(T x) {\n    vector<T> ans;\n    for(T i = 1; i * i <= x; i++)\n        if(x % i == 0) {\n            ans.pb(i);\n            if(i * i != x) ans.pb(x / i);\n        }\n    return ans;\n}\ntemplate <typename T> void zip(vector<T> &x) {\n    vector<T> y = x;\n    UNIQUE(y);\n    for(int i = 0; i < x.size(); ++i) { x[i] = lb(y, x[i]); }\n}\ntemplate <class S> void fold_in(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void fold_in(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto e : a) v.emplace_back(e);\n    fold_in(v, tail...);\n}\ntemplate <class S> void renumber(vector<S> &v) {}\ntemplate <typename Head, typename... Tail, class S> void renumber(vector<S> &v, Head &&a, Tail &&...tail) {\n    for(auto &&e : a) e = lb(v, e);\n    renumber(v, tail...);\n}\ntemplate <class S, class... Args> vector<S> zip(vector<S> &head, Args &&...args) {\n    vector<S> v;\n    fold_in(v, head, args...);\n    sort(all(v)), v.erase(unique(all(v)), v.end());\n    renumber(v, head, args...);\n    return v;\n}\n\ntemplate <typename S> void rearrange(const vector<S> &id) {}\ntemplate <typename S, typename T> void rearrange_exec(const vector<S> &id, vector<T> &v) {\n    vector<T> w(v.size());\n    rep(i, si(id)) w[i] = v[id[i]];\n    v.swap(w);\n}\n// 並び替える順番, 並び替える vector 達\ntemplate <typename S, typename Head, typename... Tail> void rearrange(const vector<S> &id, Head &a, Tail &...tail) {\n    rearrange_exec(id, a);\n    rearrange(id, tail...);\n}\n\ntemplate <typename T> vector<T> RUI(const vector<T> &v) {\n    vector<T> res(v.size() + 1);\n    for(int i = 0; i < v.size(); i++) res[i + 1] = res[i] + v[i];\n    return res;\n}\ntemplate <typename T> void zeta_supersetsum(vector<T> &f) {\n    int n = f.size();\n    for(int i = 1; i < n; i <<= 1) rep(b, n) if(!(i & b)) f[b] += f[b | i];\n}\n\ntemplate <typename T> void zeta_subsetsum(vector<T> &f) {\n    int n = f.size();\n    for(int i = 1; i < n; i <<= 1) rep(b, n) if(!(i & b)) f[b | i] += f[b];\n}\ntemplate <typename T> void mobius_subset(vector<T> &f) {\n    int n = f.size();\n    for(int i = 1; i < n; i <<= 1) rep(b, n) if(!(i & b)) f[b] -= f[b | i];\n}\ntemplate <typename T> void mobius_superset(vector<T> &f) {\n    int n = f.size();\n    for(int i = 1; i < n; i <<= 1) rep(b, n) if(!(i & b)) f[b | i] -= f[b];\n}\n// 反時計周りに 90 度回転\ntemplate <typename T> void rot(vector<vector<T>> &v) {\n    if(empty(v)) return;\n    int n = v.size(), m = v[0].size();\n    vector<vector<T>> res(m, vector<T>(n));\n    rep(i, n) rep(j, m) res[m - 1 - j][i] = v[i][j];\n    v.swap(res);\n}\n\nvector<int> counter(const vector<int> &v, int max_num = -1) {\n    if(max_num == -1) max_num = MAX(v);\n    vector<int> res(max_num + 1);\n    fore(e, v) res[e]++;\n    return res;\n}\n\n// x in [l, r)\ntemplate <class T, class S> bool inc(const T &x, const S &l, const S &r) { return l <= x and x < r; }\ntemplate <class T, class S> bool inc(const T &x, const pair<S, S> &p) { return p.first <= x and x < p.second; }\n\n// 便利関数\nconstexpr ll ten(int n) { return n == 0 ? 1 : ten(n - 1) * 10; }\nconstexpr ll tri(ll n) { return n * (n + 1) / 2; }\n// l + ... + r\nconstexpr ll tri(ll l, ll r) { return (l + r) * (r - l + 1) / 2; }\nll max(int x, ll y) { return max((ll)x, y); }\nll max(ll x, int y) { return max(x, (ll)y); }\nint min(int x, ll y) { return min((ll)x, y); }\nint min(ll x, int y) { return min(x, (ll)y); }\n// bit 演算系\n#define bit(i) (1LL << i)       // (1 << i)\n#define test(b, i) (b >> i & 1) // b の i bit 目が立っているか\nll pow2(int i) { return 1LL << i; }\nint topbit(signed t) { return t == 0 ? -1 : 31 - __builtin_clz(t); }\nint topbit(ll t) { return t == 0 ? -1 : 63 - __builtin_clzll(t); }\nint lowbit(signed a) { return a == 0 ? 32 : __builtin_ctz(a); }\nint lowbit(ll a) { return a == 0 ? 64 : __builtin_ctzll(a); }\n// int allbit(int n) { return (1 << n) - 1; }\nconstexpr ll mask(int n) { return (1LL << n) - 1; }\n// int popcount(signed t) { return __builtin_popcount(t); }\n// int popcount(ll t) { return __builtin_popcountll(t); }\nint popcount(uint64_t t) { return __builtin_popcountll(t); }\nstatic inline uint64_t popcount64(uint64_t x) {\n    uint64_t m1 = 0x5555555555555555ll;\n    uint64_t m2 = 0x3333333333333333ll;\n    uint64_t m4 = 0x0F0F0F0F0F0F0F0Fll;\n    uint64_t h01 = 0x0101010101010101ll;\n\n    x -= (x >> 1) & m1;\n    x = (x & m2) + ((x >> 2) & m2);\n    x = (x + (x >> 4)) & m4;\n\n    return (x * h01) >> 56;\n}\nbool ispow2(int i) { return i && (i & -i) == i; }\n\nll rnd(ll l, ll r) { //[l, r)\n#ifdef noimi\n    static mt19937_64 gen;\n#else\n    static mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n#endif\n    return uniform_int_distribution<ll>(l, r - 1)(gen);\n}\nll rnd(ll n) { return rnd(0, n); }\n\ntemplate <class t> void random_shuffle(vc<t> &a) { rep(i, si(a)) swap(a[i], a[rnd(0, i + 1)]); }\n\nint in() {\n    int x;\n    cin >> x;\n    return x;\n}\nll lin() {\n    unsigned long long x;\n    cin >> x;\n    return x;\n}\n\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x) { return pair<T, S>(-x.first, -x.second); }\ntemplate <class T, class S> pair<T, S> operator-(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi - y.fi, x.se - y.se); }\ntemplate <class T, class S> pair<T, S> operator+(const pair<T, S> &x, const pair<T, S> &y) { return pair<T, S>(x.fi + y.fi, x.se + y.se); }\ntemplate <class T> pair<T, T> operator&(const pair<T, T> &l, const pair<T, T> &r) { return pair<T, T>(max(l.fi, r.fi), min(l.se, r.se)); }\ntemplate <class T, class S> pair<T, S> operator+=(pair<T, S> &l, const pair<T, S> &r) { return l = l + r; }\ntemplate <class T, class S> pair<T, S> operator-=(pair<T, S> &l, const pair<T, S> &r) { return l = l - r; }\ntemplate <class T> bool intersect(const pair<T, T> &l, const pair<T, T> &r) { return (l.se < r.se ? r.fi < l.se : l.fi < r.se); }\n\ntemplate <class T> vector<T> &operator++(vector<T> &v) {\n    fore(e, v) e++;\n    return v;\n}\ntemplate <class T> vector<T> operator++(vector<T> &v, int) {\n    auto res = v;\n    fore(e, v) e++;\n    return res;\n}\ntemplate <class T> vector<T> &operator--(vector<T> &v) {\n    fore(e, v) e--;\n    return v;\n}\ntemplate <class T> vector<T> operator--(vector<T> &v, int) {\n    auto res = v;\n    fore(e, v) e--;\n    return res;\n}\ntemplate <class T> void connect(vector<T> &l, const vector<T> &r) { fore(e, r) l.eb(e); }\ntemplate <class T> vector<T> operator+(const vector<T> &l, const vector<T> &r) {\n    vector<T> res(max(si(l), si(r)));\n    rep(i, si(l)) res[i] += l[i];\n    rep(i, si(r)) res[i] += r[i];\n    return res;\n}\ntemplate <class T> vector<T> operator-(const vector<T> &l, const vector<T> &r) {\n    vector<T> res(max(si(l), si(r)));\n    rep(i, si(l)) res[i] += l[i];\n    rep(i, si(r)) res[i] -= r[i];\n    return res;\n}\ntemplate <class T> vector<T> &operator+=(const vector<T> &l, const vector<T> &r) {\n    if(si(l) < si(r)) l.resize(si(r));\n    rep(i, si(r)) l[i] += r[i];\n    return l;\n}\ntemplate <class T> vector<T> &operator-=(const vector<T> &l, const vector<T> &r) {\n    if(si(l) < si(r)) l.resize(si(r));\n    rep(i, si(r)) l[i] -= r[i];\n    return l;\n}\ntemplate <class T> vector<T> &operator+=(vector<T> &v, const T &x) {\n    fore(e, v) e += x;\n    return v;\n}\ntemplate <class T> vector<T> &operator-=(vector<T> &v, const T &x) {\n    fore(e, v) e -= x;\n    return v;\n}\n\ntemplate <typename T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n    edge(int from, int to, T cost, int id) : from(from), to(to), cost(cost), id(id) {}\n    constexpr bool operator<(const edge<T> &rhs) const noexcept { return cost < rhs.cost; }\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n    operator int() const { return to; }\n    friend ostream operator<<(ostream &os, const edge &e) { return os << e.to; }\n};\ntemplate <typename T> using Edges = vector<edge<T>>;\n\ntemplate <typename T = int> Edges<T> read_edges(int m, bool weighted = false) {\n    Edges<T> res;\n    res.reserve(m);\n    for(int i = 0; i < m; i++) {\n        int u, v, c = 0;\n        scan(u), scan(v), u--, v--;\n        if(weighted) scan(c);\n        res.eb(u, v, c, i);\n    }\n    return res;\n}\n\nusing Tree = vector<vector<int>>;\nusing Graph = vector<vector<int>>;\ntemplate <class T> using Wgraph = vector<vector<edge<T>>>;\nGraph getG(int n, int m = -1, bool directed = false, int margin = 1) {\n    Tree res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        cin >> a >> b;\n        a -= margin, b -= margin;\n        res[a].emplace_back(b);\n        if(!directed) res[b].emplace_back(a);\n    }\n    return res;\n}\nGraph getTreeFromPar(int n, int margin = 1) {\n    Graph res(n);\n    for(int i = 1; i < n; i++) {\n        int a;\n        cin >> a;\n        res[a - margin].emplace_back(i);\n    }\n    return res;\n}\ntemplate <class T> Wgraph<T> getWg(int n, int m = -1, bool directed = false, int margin = 1) {\n    Wgraph<T> res(n);\n    if(m == -1) m = n - 1;\n    while(m--) {\n        int a, b;\n        T c;\n        scan(a), scan(b), scan(c);\n        a -= margin, b -= margin;\n        res[a].emplace_back(b, c);\n        if(!directed) res[b].emplace_back(a, c);\n    }\n    return res;\n}\nvoid add(Graph &G, int x, int y) { G[x].eb(y), G[y].eb(x); }\ntemplate <class S, class T> void add(Wgraph<S> &G, int x, int y, T c) { G[x].eb(y, c), G[y].eb(x, c); }\n\n#define TEST                                                                                                                                                   \\\n    INT(testcases);                                                                                                                                            \\\n    while(testcases--)\n\ni128 abs(const i128 &x) { return x > 0 ? x : -x; }\nistream &operator>>(istream &is, i128 &v) {\n    string s;\n    is >> s;\n    v = 0;\n    for(int i = 0; i < (int)s.size(); i++) {\n        if(isdigit(s[i])) { v = v * 10 + s[i] - '0'; }\n    }\n    if(s[0] == '-') { v *= -1; }\n    return is;\n}\n\nostream &operator<<(ostream &os, const i128 &v) {\n    if(v == 0) { return (os << \"0\"); }\n    i128 num = v;\n    if(v < 0) {\n        os << '-';\n        num = -num;\n    }\n    string s;\n    for(; num > 0; num /= 10) { s.push_back((char)(num % 10) + '0'); }\n    reverse(s.begin(), s.end());\n    return (os << s);\n}\nnamespace aux {\ntemplate <typename T, unsigned N, unsigned L> struct tp {\n    static void output(std::ostream &os, const T &v) {\n        os << std::get<N>(v) << (&os == &cerr ? \", \" : \" \");\n        tp<T, N + 1, L>::output(os, v);\n    }\n};\ntemplate <typename T, unsigned N> struct tp<T, N, N> {\n    static void output(std::ostream &os, const T &v) { os << std::get<N>(v); }\n};\n} // namespace aux\ntemplate <typename... Ts> std::ostream &operator<<(std::ostream &os, const std::tuple<Ts...> &t) {\n    if(&os == &cerr) { os << '('; }\n    aux::tp<std::tuple<Ts...>, 0, sizeof...(Ts) - 1>::output(os, t);\n    if(&os == &cerr) { os << ')'; }\n    return os;\n}\ntemplate <typename T, typename S, typename U> std::ostream &operator<<(std::ostream &os, const priority_queue<T, S, U> &_pq) {\n    auto pq = _pq;\n    vector<T> res;\n    while(!empty(pq)) res.emplace_back(pq.top()), pq.pop();\n    return os << res;\n}\ntemplate <class T, class S> ostream &operator<<(ostream &os, const pair<T, S> &p) {\n    if(&os == &cerr) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\n    return os << p.first << \" \" << p.second;\n}\ntemplate <class Ch, class Tr, class Container> std::basic_ostream<Ch, Tr> &operator<<(std::basic_ostream<Ch, Tr> &os, const Container &x) {\n    bool f = true;\n    if(&os == &cerr) os << \"[\";\n    for(auto &y : x) {\n        if(&os == &cerr)\n            os << (f ? \"\" : \", \") << y;\n        else\n            os << (f ? \"\" : \" \") << y;\n        f = false;\n    }\n    if(&os == &cerr) os << \"]\";\n    return os;\n}\n\n#define dump(...) static_cast<void>(0)\n#define dbg(...) static_cast<void>(0)\n\nvoid OUT() { cout << endl; }\ntemplate <class Head, class... Tail> void OUT(const Head &head, const Tail &...tail) {\n    cout << head;\n    if(sizeof...(tail)) cout << ' ';\n    OUT(tail...);\n}\n\ntemplate <typename T> static constexpr T inf = numeric_limits<T>::max() / 2;\ntemplate <class T, class S> constexpr pair<T, S> inf<pair<T, S>> = {inf<T>, inf<S>};\n\ntemplate <class T> void OUT2(const T &t, T INF = inf<T>, T res = -1) { OUT(t != INF ? t : res); }\ntemplate <class T> void OUT2(vector<T> &v, T INF = inf<T>, T res = -1) {\n    fore(e, v) if(e == INF) e = res;\n    OUT(v);\n    fore(e, v) if(e == res) e = INF;\n}\n\ntemplate <class F> struct REC {\n    F f;\n    REC(F &&f_) : f(forward<F>(f_)) {}\n    template <class... Args> auto operator()(Args &&...args) const { return f(*this, forward<Args>(args)...); }\n};\n\ntemplate <class S> vector<pair<S, int>> runLength(const vector<S> &v) {\n    vector<pair<S, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\nvector<pair<char, int>> runLength(const string &v) {\n    vector<pair<char, int>> res;\n    for(auto &e : v) {\n        if(res.empty() or res.back().fi != e)\n            res.eb(e, 1);\n        else\n            res.back().se++;\n    }\n    return res;\n}\n\nstruct string_converter {\n    char start = 0;\n    char type(const char &c) const { return (islower(c) ? 'a' : isupper(c) ? 'A' : isdigit(c) ? '0' : 0); }\n    int convert(const char &c) {\n        if(!start) start = type(c);\n        return c - start;\n    }\n    int convert(const char &c, const string &chars) { return chars.find(c); }\n    template <typename T> auto convert(const T &v) {\n        vector<decltype(convert(v[0]))> ret;\n        ret.reserve(size(v));\n        for(auto &&e : v) ret.emplace_back(convert(e));\n        return ret;\n    }\n    template <typename T> auto convert(const T &v, const string &chars) {\n        vector<decltype(convert(v[0], chars))> ret;\n        ret.reserve(size(v));\n        for(auto &&e : v) ret.emplace_back(convert(e, chars));\n        return ret;\n    }\n    int operator()(const char &v, char s = 0) {\n        start = s;\n        return convert(v);\n    }\n    int operator()(const char &v, const string &chars) { return convert(v, chars); }\n    template <typename T> auto operator()(const T &v, char s = 0) {\n        start = s;\n        return convert(v);\n    }\n    template <typename T> auto operator()(const T &v, const string &chars) { return convert(v, chars); }\n} toint;\n\ntemplate <class T, class F> T bin_search(T ok, T ng, const F &f) {\n    while(abs(ok - ng) > 1) {\n        T mid = ok + ng >> 1;\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class T, class F> T bin_search_double(T ok, T ng, const F &f, int iter = 80) {\n    while(iter--) {\n        // T mid = (ok + ng) / 2;\n        T mid = sqrtl(ok * ng);\n        (f(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n\nstruct Setup_io {\n    Setup_io() {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        cout << fixed << setprecision(11);\n    }\n} setup_io;\n\n#endif\n\n#pragma endregion\n\n/**\n * @brief Lazy-Reversible-Splay-Tree(遅延伝搬反転可能Splay木)\n */\ntemplate <typename Monoid = int, typename OperatorMonoid = Monoid> struct LazyReversibleSplayTree {\n  public:\n    using F = function<Monoid(Monoid, Monoid)>;\n    using G = function<Monoid(Monoid, OperatorMonoid)>;\n    using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n    using S = function<Monoid(Monoid)>;\n\n    struct Node {\n        Node *l, *r, *p;\n        Monoid key, sum;\n        OperatorMonoid lazy;\n        bool rev;\n        size_t sz;\n\n        bool is_root() const { return !p || (p->l != this && p->r != this); }\n\n        Node(const Monoid &key, const OperatorMonoid &om) : key(key), sum(key), lazy(om), sz(1), rev(false), l(nullptr), r(nullptr), p(nullptr) {}\n    };\n\n    LazyReversibleSplayTree(const F &f, const Monoid &M1)\n        : LazyReversibleSplayTree(\n              f, [](const Monoid &a) { return a; }, M1) {}\n\n    LazyReversibleSplayTree(const F &f, const S &s, const Monoid &M1) : LazyReversibleSplayTree(f, G(), H(), s, M1, OperatorMonoid()) {}\n\n    LazyReversibleSplayTree(const F &f, const G &g, const H &h, const S &s, const Monoid &M1, const OperatorMonoid &OM0)\n        : f(f), g(g), h(h), s(s), M1(M1), OM0(OM0) {}\n\n    inline size_t count(const Node *t) { return t ? t->sz : 0; }\n\n    inline const Monoid &sum(const Node *t) { return t ? t->sum : M1; }\n\n    Node *alloc(const Monoid &v = Monoid()) { return new Node(v, OM0); }\n\n    void splay(Node *t) {\n        push(t);\n        while(!t->is_root()) {\n            auto *q = t->p;\n            if(q->is_root()) {\n                push(q), push(t);\n                if(q->l == t)\n                    rotr(t);\n                else\n                    rotl(t);\n            } else {\n                auto *r = q->p;\n                push(r), push(q), push(t);\n                if(r->l == q) {\n                    if(q->l == t)\n                        rotr(q), rotr(t);\n                    else\n                        rotl(t), rotr(t);\n                } else {\n                    if(q->r == t)\n                        rotl(q), rotl(t);\n                    else\n                        rotr(t), rotl(t);\n                }\n            }\n        }\n    }\n\n    Node *push_front(Node *t, const Monoid &v = Monoid()) {\n        if(!t) {\n            t = alloc(v);\n            return t;\n        } else {\n            splay(t);\n            Node *cur = get_left(t), *z = alloc(v);\n            splay(cur);\n            z->p = cur;\n            cur->l = z;\n            splay(z);\n            return z;\n        }\n    }\n\n    Node *push_back(Node *t, const Monoid &v = Monoid()) {\n        if(!t) {\n            t = alloc(v);\n            return t;\n        } else {\n            splay(t);\n            Node *cur = get_right(t), *z = alloc(v);\n            splay(cur);\n            z->p = cur;\n            cur->r = z;\n            splay(z);\n            return z;\n        }\n    }\n\n    Node *erase(Node *t) {\n        splay(t);\n        Node *x = t->l, *y = t->r;\n        delete t;\n        if(!x) {\n            t = y;\n            if(t) t->p = nullptr;\n        } else if(!y) {\n            t = x;\n            t->p = nullptr;\n        } else {\n            x->p = nullptr;\n            t = get_right(x);\n            splay(t);\n            t->r = y;\n            y->p = t;\n        }\n        return t;\n    }\n\n    Node *get_left(Node *t) const {\n        while(t->l) t = t->l;\n        return t;\n    }\n\n    Node *get_right(Node *t) const {\n        while(t->r) t = t->r;\n        return t;\n    }\n\n    void set_propagate(Node *&t, int a, int b, const OperatorMonoid &pp) {\n        if(!t) return;\n        splay(t);\n        auto x = split(t, a);\n        auto y = split(x.second, b - a);\n        set_propagate(y.first, pp);\n        t = merge(x.first, y.first, y.second);\n    }\n\n    virtual void set_propagate(Node *&t, const OperatorMonoid &pp) {\n        splay(t);\n        propagate(t, pp);\n        push(t);\n    }\n\n    pair<Node *, Node *> split(Node *t, int k) {\n        if(!t) return {nullptr, nullptr};\n        push(t);\n        if(k <= count(t->l)) {\n            auto x = split(t->l, k);\n            t->l = x.second;\n            t->p = nullptr;\n            if(x.second) x.second->p = t;\n            return {x.first, update(t)};\n        } else {\n            auto x = split(t->r, k - count(t->l) - 1);\n            t->r = x.first;\n            t->p = nullptr;\n            if(x.first) x.first->p = t;\n            return {update(t), x.second};\n        }\n    }\n\n    tuple<Node *, Node *, Node *> split3(Node *t, int a, int b) {\n        splay(t);\n        auto x = split(t, a);\n        auto y = split(x.second, b - a);\n        return make_tuple(x.first, y.first, y.second);\n    }\n\n    template <typename... Args> Node *merge(Node *l, Args... rest) {\n        Node *r = merge(rest...);\n        if(!l && !r) return nullptr;\n        if(!l) return splay(r), r;\n        if(!r) return splay(l), l;\n        splay(l), splay(r);\n        l = get_right(l);\n        splay(l);\n        l->r = r;\n        r->p = l;\n        update(l);\n        return l;\n    }\n\n    void insert(Node *&t, int k, const Monoid &v) {\n        splay(t);\n        auto x = split(t, k);\n        t = merge(x.first, alloc(v), x.second);\n    }\n\n    Monoid erase(Node *&t, int k) {\n        splay(t);\n        auto x = split(t, k);\n        auto y = split(x.second, 1);\n        auto v = y.first->c;\n        delete y.first;\n        t = merge(x.first, y.second);\n        return v;\n    }\n\n    Monoid query(Node *&t, int a, int b) {\n        splay(t);\n        auto x = split(t, a);\n        auto y = split(x.second, b - a);\n        auto ret = sum(y.first);\n        t = merge(x.first, y.first, y.second);\n        return ret;\n    }\n\n    Node *build(const vector<Monoid> &v) { return build(0, (int)v.size(), v); }\n\n    void toggle(Node *t) {\n        swap(t->l, t->r);\n        t->sum = s(t->sum);\n        t->rev ^= true;\n    }\n\n    Node *update(Node *t) {\n        t->sz = 1;\n        t->sum = t->key;\n        if(t->l) t->sz += t->l->sz, t->sum = f(t->l->sum, t->sum);\n        if(t->r) t->sz += t->r->sz, t->sum = f(t->sum, t->r->sum);\n        return t;\n    }\n\n    void push(Node *t) {\n        if(t->lazy != OM0) {\n            if(t->l) propagate(t->l, t->lazy);\n            if(t->r) propagate(t->r, t->lazy);\n            t->lazy = OM0;\n        }\n        if(t->rev) {\n            if(t->l) toggle(t->l);\n            if(t->r) toggle(t->r);\n            t->rev = false;\n        }\n    }\n\n    void set_element(Node *&t, int k, const Monoid &x) {\n        splay(t);\n        sub_set_element(t, k, x);\n    }\n\n  private:\n    const Monoid M1;\n    const OperatorMonoid OM0;\n    const F f;\n    const G g;\n    const H h;\n    const S s;\n\n    Node *build(int l, int r, const vector<Monoid> &v) {\n        // dump(l, r);\n        if(l + 1 >= r) return alloc(v[l]);\n        return merge(build(l, (l + r) >> 1, v), build((l + r) >> 1, r, v));\n    }\n\n    void propagate(Node *t, const OperatorMonoid &x) {\n        t->lazy = h(t->lazy, x);\n        t->key = g(t->key, x);\n        t->sum = g(t->sum, x);\n    }\n\n    void rotr(Node *t) {\n        auto *x = t->p, *y = x->p;\n        if((x->l = t->r)) t->r->p = x;\n        t->r = x, x->p = t;\n        update(x), update(t);\n        if((t->p = y)) {\n            if(y->l == x) y->l = t;\n            if(y->r == x) y->r = t;\n            update(y);\n        }\n    }\n\n    void rotl(Node *t) {\n        auto *x = t->p, *y = x->p;\n        if((x->r = t->l)) t->l->p = x;\n        t->l = x, x->p = t;\n        update(x), update(t);\n        if((t->p = y)) {\n            if(y->l == x) y->l = t;\n            if(y->r == x) y->r = t;\n            update(y);\n        }\n    }\n\n    Node *merge(Node *l) { return l; }\n\n    Node *sub_set_element(Node *&t, int k, const Monoid &x) {\n        push(t);\n        if(k < count(t->l)) {\n            return sub_set_element(t->l, k, x);\n        } else if(k == count(t->l)) {\n            t->key = x;\n            splay(t);\n            return t;\n        } else {\n            return sub_set_element(t->r, k - count(t->l) - 1, x);\n        }\n    }\n\n  public:\n    int lowb(Node *&t, const Monoid &x, int L) {\n        if(!t) return L;\n        push(t);\n        if(t->l and sum(t->l) < x) return lowb(t->l, x, L);\n        L += count(t->l);\n        if(t->key < x) {\n            splay(t);\n            return L;\n        }\n        if(!t->r) {\n            splay(t);\n            return L + 1;\n        }\n        return lowb(t->r, x, L + 1);\n    }\n\n    void ddump(Node *&t, vector<Monoid> &v) {\n        // splay(t);\n        push(t);\n        if(t->l) ddump(t->l, v);\n        v.eb(t->key);\n        if(t->r) ddump(t->r, v);\n    }\n};\n\nll f(ll x, ll y) { return min(x, y); }\nll g(ll x, ll y) { return x + y; }\nll ts(ll x) { return x; }\n\nint main() {\n    TEST {\n        INT(n);\n        STR(s);\n        VEC(ll, r, n);\n        VEC(ll, b, n);\n        ll ans = SUM(b);\n        string t;\n        vl c;\n        rep(i, n) {\n            if(r[i] > b[i]) {\n                c.eb(r[i] - b[i]);\n                t += s[i];\n            }\n        }\n        n = si(t);\n\n        ll k = 0;\n        // vl dp;\n        auto a = toint(t);\n        dump(a);\n        dump(c);\n\n        // LazyReversibleSplayTree<ll, ll, f, f, f, ts> rbst;\n        LazyReversibleSplayTree<ll, ll> rbst(f, g, g, ts, inf<ll>, 0);\n\n        LazyReversibleSplayTree<ll, ll>::Node *root = nullptr;\n        int cnt = 0;\n        rep(i, n) {\n            if(a[i]) {\n                if(root) rbst.splay(root);\n                int k = rbst.lowb(root, c[i], 0);\n                if(!root) {\n                    root = rbst.build(vl{c[i]});\n                } else\n                    rbst.insert(root, k, c[i]);\n                cnt++;\n            } else {\n                int m = min(cnt, c[i]);\n                rbst.set_propagate(root, 0, m, -1);\n\n                k += c[i];\n            }\n\n            // vl dp;\n            // rep(j, cnt) dp.eb(rbst.query(root, j, j + 1));\n            // dump(dp);\n        }\n\n        vl dp;\n        if(root) rbst.ddump(root, dp);\n        // rep(i, cnt) dp.eb(rbst.query(root, i, i + 1));\n\n        ll ma = k;\n        dump(k, dp);\n\n        fore(e, dp) {\n            k += e;\n            chmax(ma, k);\n        }\n        // fore(e, dp) if(e > 0) k += e;\n        OUT(ans + ma);\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "flows",
        "greedy"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Two Characters, Two Colors.json",
    "editorial_link": "https://codeforces.com//blog/entry/122034",
    "editorial": "This problem requires partitioning some object into two parts, and\r\nimposes different costs depending on how we perform the partition. Let’s\r\ntry to model it with minimum cuts.Create a flow network with vertices: a\r\nvertex for every character of the string, a source and a sink. Using the\r\nedges of the network, we will try to model the following: if we paint\r\nthe -th character red, we lose coins (we can treat it as always gaining\r\ncoins no matter what, and then losing coins instead of earning them for\r\ncoloring the characters); if we paint the -th character blue, we lose\r\ncoins (the same applies here); if , , and both and are red, we lose\r\ncoin. To model the third constraint, let’s say that the vertices\r\nrepresenting ’s are red if they belong to the set in the cut, or blue if\r\nthey belong to . For the vertices representing ’s, this will be the\r\nopposite: they will be red if they belong to the set , or blue if they\r\nbelong to the set . So, if we add a directed edge with capacity from to\r\nwhen , and , this edge will be cut exactly when both and are red, and\r\nthey create an inversion.To model the second constraint, for vertices\r\nrepresenting ’s, add an incoming edge from the source with capacity ,\r\nand an outgoing edge to the sink with capacity . For vertices\r\nrepresenting ’s, this will be vice versa (since red vertices\r\nrepresenting ’s belong to , the edge from the source to that vertex\r\nshould have capacity , not ).Now we got ourselves a flow network. The\r\nanswer to the problem will be , where is the minimum cut in this\r\nnetwork. But instead of searching for the minimum cut, we will try to\r\ncalculate the maximum flow.We are going to do it greedily. Let’s process\r\nthe vertices of the network, from the vertex representing the -st\r\ncharacter to the vertex representing the -th character. Every time, we\r\nwill try to push as much flow as possible through the current\r\nvertex.When processing a vertex, first of all, let’s try to push flow\r\nthrough the edges connecting the source and the sink with it. Then, if\r\nit is a vertex with a character of type , let’s remember that we can\r\npush flow through it to successive vertices of type (let’s call this\r\nexcess flow for that vertex). And if it is a vertex representing a\r\ncharacter of type , let’s try to push at most flow into it from the\r\nvertices of type we processed earlier (but no more than unit of flow\r\nfrom each vertex). But when we process a vertex of type , how do we\r\nchoose from which vertices of type we take the flow? It can be shown\r\nthat we can take unit of flow from the vertices with the maximum amount\r\nof excess flow (the formal proof is kinda long, but the main idea is\r\nthat every optimal flow assignment can be transformed into the one\r\nworking in this greedy way without breaking anything).So, to recap, when\r\nwe process a vertex of type , we remember that it has some excess flow.\r\nAnd when we process a vertex of type , we take unit of excess flow from\r\nseveral vertices with the maximum amount of excess flow. So, we need a\r\ndata structure that allows us to process the following queries: add an\r\ninteger; calculate the number of positive integers in the structure;\r\nsubtract from maximum integers in the structure. Model implementation of\r\nthis data structure is kinda long (there are easier ways to do it), but\r\nI will describe it nevertheless. We will use an explicit-key treap which\r\nstores two values in each vertex an integer belonging to the structure\r\nand the quantity of that integer in the structure (so, it’s kinda like a\r\nmap which counts the number of occurrences of each integer). This treap\r\nhas to support adding to all values in some subtree (with lazy\r\npropagation). Most operations with it are fairly straightforward, but\r\nhow do we actually subtract from maximum values in the tree? We will do\r\nit in the following way: split the treap to extract maximum elements\r\n(let’s denote the first treap as the part without maximums, and the\r\nsecond treap as the part with those maximums); add to the values in the\r\nsecond treap; while the minimum element in the second treap is not\r\ngreater than the maximum element in the first treap, remove the minimum\r\nfrom the second treap and insert it into the first treap; merge the\r\ntreaps. It’s quite easy to see that if you store the pairs of the form\r\n\"element, the number of its occurrences\" in the treap, the third step\r\nwill require moving at most elements. And the resulting complexity of\r\nevery operation with this data structure becomes , so the whole solution\r\nworks in .\r\n"
}