{
    "link": "https://codeforces.com//contest/1743/problem/G",
    "problemId": "1590322",
    "problem_idx": "G",
    "shortId": "1743G",
    "contest_number": "1743",
    "problem_submissions": {
        "G": [
            176744926,
            176752632,
            176765710,
            176759446,
            176826731,
            176825958,
            176825876,
            176825841,
            176825795,
            176825757,
            176777747,
            176767399,
            176787833,
            176794001,
            176793915,
            176793787,
            176793693,
            176793601,
            176793457,
            176793414,
            176793075,
            176792582,
            176790966,
            176790830,
            176790739,
            176790602,
            176790480,
            176790442,
            176790394,
            176877236,
            176797381,
            177041275
        ],
        "F": [
            176737097,
            176733706,
            176744244,
            176746662,
            176734362,
            176741223,
            176737910,
            176729577,
            176742322,
            176771541,
            176747634,
            176866127,
            176744359,
            176742533,
            176764904,
            176749314,
            176748844,
            176759565,
            176751246,
            176746192,
            176742294,
            176760205
        ],
        "E": [
            176732507,
            176757486,
            176736176,
            176739966,
            176749212,
            176748013,
            176727666,
            176739006,
            176729866,
            176763689,
            176763186,
            176762781,
            176756640,
            176764718,
            176740887,
            176756959,
            176787283,
            176742950,
            176761500,
            176766019,
            176770369,
            176749818
        ],
        "D": [
            176723746,
            176718140,
            176716615,
            176721411,
            176719450,
            176723698,
            176718782,
            176720745,
            176721715,
            176722102,
            176729581,
            176725500,
            176730292,
            176719597,
            176730936,
            176731941,
            176724207,
            176723731,
            176736911
        ],
        "C": [
            176716029,
            176704815,
            176706962,
            176708929,
            176705118,
            176704124,
            176715109,
            176705993,
            176708271,
            176707432,
            176707937,
            176714968,
            176710289,
            176708841,
            176705755,
            176710426,
            176713787,
            176707796,
            176708736,
            176710057
        ],
        "B": [
            176712751,
            176699478,
            176698683,
            176699488,
            176698322,
            176698046,
            176699875,
            176699384,
            176699501,
            176699739,
            176704430,
            176700303,
            176700238,
            176699124,
            176702452,
            176707386,
            176700133,
            176698867,
            176703708
        ],
        "A": [
            176712234,
            176698003,
            176697838,
            176697817,
            176697799,
            176697771,
            176697968,
            176697810,
            176698111,
            176698066,
            176699952,
            176697901,
            176698001,
            176697928,
            176699293,
            176697926,
            176697958,
            176697832,
            176698850
        ]
    },
    "name": "G. Antifibonacci Cut",
    "statement": "Let\u2019s define the sequence of Fibonacci strings as follows: f_0 is , f_1\r\nis , f_i is f_{i-1} + f_{i-2} for i>1 (+ denotes the concatenation of\r\ntwo strings). So, for example, f_2 is , f_3 is , f_4 is .For a given\r\nstring s, let\u2019s define g(s) as the number of ways to cut it into several\r\n(any number, possibly even just one) strings such that none of these\r\nstrings are Fibonacci strings. For example, if s is , g(s) = 3 since\r\nthere are three ways to cut it: + ; + ; + + . You are given a sequence\r\nof strings s_1, s_2,\r\ndots, s_n. Calculate g(s_1), g(s_1 + s_2),\r\ndots, g(s_1 + s_2 +\r\nldots + s_n). Since these values can be huge, print them modulo\r\n998244353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nstd::vector<int> fib{1, 2};\n\nint get(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return 0;\n    }\n    auto it = std::prev(std::upper_bound(fib.begin(), fib.end(), n));\n    return get(n - *it);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    for (int i = 0; i < 30; i++) {\n        fib.push_back(fib[fib.size() - 2] + fib.back());\n    }\n    \n    int n;\n    std::cin >> n;\n    \n    Z dp = 1, sum = 1;\n    std::vector<std::pair<int, Z>> suf;\n    \n    auto add = [&](int x) {\n        Z ndp = sum - dp;\n        std::vector<std::pair<int, Z>> nsuf;\n        \n        if (x) {\n            nsuf.push_back({1, dp});\n        }\n        for (auto [l, v] : suf) {\n            if (x == get(l)) {\n                nsuf.emplace_back(l + 1, v);\n                if (std::binary_search(fib.begin(), fib.end(), l + 1)) {\n                    ndp -= v;\n                }\n            }\n        }\n        std::swap(suf, nsuf);\n        dp = ndp;\n        \n        sum += ndp;\n    };\n    \n    for (int i = 0; i < n; i++) {\n        std::string s;\n        std::cin >> s;\n        \n        for (auto c : s) {\n            add(c - '0');\n        }\n        std::cout << dp << \"\\n\";\n    }\n    \n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "constructive algorithms",
        "data structures",
        "dp",
        "hashing",
        "math"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Antifibonacci Cut.json",
    "editorial_link": "https://codeforces.com//blog/entry/108153",
    "editorial": "The first idea that comes to mind is running some sort of dynamic\r\nprogramming: the number of ways to cut the string consisting of the\r\nfirst characters. When we calculate , we need to take the sum of the\r\nprevious values of , and then subtract for every such that the string\r\nfrom the -th character (inclusive) to the -th character (non-inclusive)\r\nis a Fibonacci string. Unfortunately, there are two main issues with\r\nthis solution: firstly, we cannot store the array in memory; and\r\nsecondly, we have to search for the Fibonacci strings ending in a\r\ncertain index quickly (something like Aho-Corasick could work with a\r\nless strict memory limit, but right now we cannot use it).We will try to\r\nresolve both of these issues with the following approach: while we\r\nprocess the characters, we will maintain the list of tuples such that\r\nthe string from the -th character to the current one is a prefix of some\r\nFibonacci string. How do we maintain them?Every Fibonacci string (except\r\nfor ) is a prefix of . So, all Fibonacci strings we are interested in\r\n(except for again) are prefixes of the same long Fibonacci string.\r\nSuppose a tuple represents some index such that the string from the -th\r\ncharacter to the current one is a prefix of that long Fibonacci string.\r\nEach time we append a character, we filter this list of tuples by trying\r\nto check if this new character matches the next character in the prefix\r\n(if it does not, the tuple is discarded). For the tuples that represent\r\nthe prefixes equal to Fibonacci strings, we need to subtract the value\r\nof from the new value we are trying to calculate (checking if a prefix\r\nis a Fibonacci string is easy, we just need to check its length). How do\r\nwe check that if we add a character or , it is still a prefix? There are\r\ntwo ways to do this: either generate the first characters of the long\r\nFibonacci string; or represent the current prefix as the sum of\r\nFibonacci strings such that for every , the condition holds (i. e. the\r\nFibonacci strings we split the current prefix into are arranged in\r\ndescending order, and there is no pair of equal or adjacent (by index)\r\nFibonacci strings in the split). This representation is very similar to\r\nwriting an integer in Zeckendorf system. The next character in the\r\nprefix depends on whether belongs to this split: if it belongs, it is\r\nthe last string in the split, so we need to append to transform into ;\r\notherwise, we need to append . Okay, so now we can solve the problem in\r\ntime (where is the total length of the strings in the input, and is the\r\nsize of the list of tuples we discussed earlier). This actually works\r\nsince it looks like the size of the list of tuples is bounded as .\r\nUnfortunately, we don\u00e2\u0080\u0099t have a strict mathematical proof of this; we\r\nchecked this by brute force with up to , so it definitely works under\r\nthe constraints of the problem.\r\n"
}