{"link": "https://codeforces.com//contest/1743/problem/G", "problemId": "1590322", "problem_idx": "G", "shortId": "1743G", "contest_number": "1743", "problem_submissions": {"G": [176744926, 176752632, 176765710, 176759446, 176826731, 176825958, 176825876, 176825841, 176825795, 176825757, 176777747, 176767399, 176787833, 176794001, 176793915, 176793787, 176793693, 176793601, 176793457, 176793414, 176793075, 176792582, 176790966, 176790830, 176790739, 176790602, 176790480, 176790442, 176790394, 176877236, 176797381, 177041275], "F": [176737097, 176733706, 176744244, 176746662, 176734362, 176741223, 176737910, 176729577, 176742322, 176771541, 176747634, 176866127, 176744359, 176742533, 176764904, 176749314, 176748844, 176759565, 176751246, 176746192, 176742294, 176760205], "E": [176732507, 176757486, 176736176, 176739966, 176749212, 176748013, 176727666, 176739006, 176729866, 176763689, 176763186, 176762781, 176756640, 176764718, 176740887, 176756959, 176787283, 176742950, 176761500, 176766019, 176770369, 176749818], "D": [176723746, 176718140, 176716615, 176721411, 176719450, 176723698, 176718782, 176720745, 176721715, 176722102, 176729581, 176725500, 176730292, 176719597, 176730936, 176731941, 176724207, 176723731, 176736911], "C": [176716029, 176704815, 176706962, 176708929, 176705118, 176704124, 176715109, 176705993, 176708271, 176707432, 176707937, 176714968, 176710289, 176708841, 176705755, 176710426, 176713787, 176707796, 176708736, 176710057], "B": [176712751, 176699478, 176698683, 176699488, 176698322, 176698046, 176699875, 176699384, 176699501, 176699739, 176704430, 176700303, 176700238, 176699124, 176702452, 176707386, 176700133, 176698867, 176703708], "A": [176712234, 176698003, 176697838, 176697817, 176697799, 176697771, 176697968, 176697810, 176698111, 176698066, 176699952, 176697901, 176698001, 176697928, 176699293, 176697926, 176697958, 176697832, 176698850]}, "name": "G. Antifibonacci Cut", "statement": "Let\u2019s define the sequence of Fibonacci strings as follows: f_0 is , f_1\r\nis , f_i is f_{i-1} + f_{i-2} for i>1 (+ denotes the concatenation of\r\ntwo strings). So, for example, f_2 is , f_3 is , f_4 is .For a given\r\nstring s, let\u2019s define g(s) as the number of ways to cut it into several\r\n(any number, possibly even just one) strings such that none of these\r\nstrings are Fibonacci strings. For example, if s is , g(s) = 3 since\r\nthere are three ways to cut it: + ; + ; + + . You are given a sequence\r\nof strings s_1, s_2,\r\ndots, s_n. Calculate g(s_1), g(s_1 + s_2),\r\ndots, g(s_1 + s_2 +\r\nldots + s_n). Since these values can be huge, print them modulo\r\n998244353.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};\n\nstd::vector<int> fib{1, 2};\n\nint get(int n) {\n    if (n == 0) {\n        return 1;\n    }\n    if (n == 1) {\n        return 0;\n    }\n    auto it = std::prev(std::upper_bound(fib.begin(), fib.end(), n));\n    return get(n - *it);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    for (int i = 0; i < 30; i++) {\n        fib.push_back(fib[fib.size() - 2] + fib.back());\n    }\n    \n    int n;\n    std::cin >> n;\n    \n    Z dp = 1, sum = 1;\n    std::vector<std::pair<int, Z>> suf;\n    \n    auto add = [&](int x) {\n        Z ndp = sum - dp;\n        std::vector<std::pair<int, Z>> nsuf;\n        \n        if (x) {\n            nsuf.push_back({1, dp});\n        }\n        for (auto [l, v] : suf) {\n            if (x == get(l)) {\n                nsuf.emplace_back(l + 1, v);\n                if (std::binary_search(fib.begin(), fib.end(), l + 1)) {\n                    ndp -= v;\n                }\n            }\n        }\n        std::swap(suf, nsuf);\n        dp = ndp;\n        \n        sum += ndp;\n    };\n    \n    for (int i = 0; i < n; i++) {\n        std::string s;\n        std::cin >> s;\n        \n        for (auto c : s) {\n            add(c - '0');\n        }\n        std::cout << dp << \"\\n\";\n    }\n    \n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "combinatorics", "constructive algorithms", "data structures", "dp", "hashing", "math"], "dificulty": "3000", "interactive": false}