{
    "link": "https://codeforces.com//contest/1380/problem/G",
    "problemId": "670989",
    "problem_idx": "G",
    "shortId": "1380G",
    "contest_number": "1380",
    "problem_submissions": {
        "F": [
            86713166,
            86683254,
            86680631,
            86680966,
            86687165,
            86684140,
            86669350,
            86688621,
            86687283,
            86673002,
            86689951,
            86691835,
            86685205,
            86710315,
            86689156,
            86687400,
            86687045,
            86687896,
            86690019
        ],
        "G": [
            86677566,
            86685201,
            86688237,
            86689481,
            86686718,
            86691383,
            86690954,
            86692142,
            86694360,
            86693986,
            86693332,
            86693299,
            86700820,
            86693764,
            86685196,
            86684314
        ],
        "E": [
            86675522,
            86675407,
            86673302,
            86676691,
            86680473,
            86684037,
            86681297,
            86679620,
            86685647,
            86685220,
            86686544,
            86674567,
            86678512,
            86684412,
            86683830,
            86676323,
            86680714,
            86681696,
            86690990
        ],
        "D": [
            86667662,
            86670333,
            86669219,
            86673424,
            86678569,
            86680592,
            86676914,
            86676735,
            86681998,
            86680522,
            86687871,
            86670447,
            86672345,
            86680156,
            86679073,
            86689461,
            86721905,
            86687223
        ],
        "C": [
            86667582,
            86670259,
            86669101,
            86667895,
            86670203,
            86672224,
            86667959,
            86672685,
            86676101,
            86675384,
            86675814,
            86668973,
            86672498,
            86672045,
            86670655,
            86667252,
            86668731,
            86674537,
            86668780
        ],
        "B": [
            86667335,
            86670187,
            86671042,
            86667790,
            86672794,
            86670893,
            86667752,
            86671215,
            86673431,
            86671665,
            86674484,
            86670341,
            86660822,
            86669327,
            86673817,
            86667069,
            86673326,
            86672657,
            86668683
        ],
        "A": [
            86667075,
            86670143,
            86668605,
            86667568,
            86667937,
            86657614,
            86657741,
            86669480,
            86673357,
            86672922,
            86672973,
            86668720,
            86672438,
            86659787,
            86671597,
            86666992,
            86671323,
            86669608,
            86668545
        ]
    },
    "name": "G. Circular Dungeon",
    "statement": "You are creating a level for a video game. The level consists of n rooms\r\nplaced in a circle. The rooms are numbered 1 through n. Each room\r\ncontains exactly one exit: completing the j-th room allows you to go the\r\n(j+1)-th room (and completing the n-th room allows you to go the 1-st\r\nroom).You are given the description of the multiset of n chests: the\r\ni-th chest has treasure value c_i.Each chest can be of one of two types:\r\nregular chest when a player enters a room with this chest, he grabs the\r\ntreasure and proceeds to the next room; mimic chest when a player enters\r\na room with this chest, the chest eats him alive, and he loses. The\r\nplayer starts in a random room with each room having an equal\r\nprobability of being chosen. The players earnings is equal to the total\r\nvalue of treasure chests he\u2019d collected before he lost.You are allowed\r\nto choose the order the chests go into the rooms. For each k from 1 to n\r\nplace the chests into the rooms in such a way that: each room contains\r\none chest; k chests are mimics; the expected value of players earnings\r\nis possible. Please note that for each k the placement is chosen\r\nindependently.It can be shown that it is in the form of\r\nfrac{P}{Q} where P and Q are non-negative integers and Q\r\nne 0. Report the values of P\r\ncdot Q^{-1}\r\npmod {998244353}.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n \nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N; cin >> N;\n    vi C(N); F0R(i, N) cin >> C[i];\n\n    mi in = inv(mi(N));\n\n    sort(all(C)); reverse(all(C));\n    mi pre[N+1];\n    pre[0] = 0;\n    F0R(i, N) pre[i+1] = pre[i] + C[i];\n\n    FOR(K, 1, N+1) {\n        mi ans = 0;\n        for (int i = 0; i < N; i += K) {\n            ans += (i / K) * (pre[min(i+K, N)] - pre[i]);\n        }\n        ans *= in;\n        cout << ans << \" \";\n    }\n    cout << nl;\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "math",
        "probabilities"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Circular Dungeon.json",
    "editorial_link": "https://codeforces.com//blog/entry/80054",
    "editorial": "TutorialAt first, let\u00e2\u0080\u0099s say that the expected value is equal to the\r\naverage of total earnings over all positions and is equal to the sum of\r\nearnings over all positions divided by . So we can trasition to\r\nminimizing the sum.Let\u00e2\u0080\u0099s learn how to solve the task for some fixed .\r\nFix some arrangement and rotate the rooms so that the last room contains\r\na mimic. So now you have regular chests, then a single mimic, regular\r\nchests, single mimic, , regular chests, single mimic. All and .Take a\r\nlook at some of these intervals of length . The last chest in the\r\ninterval is taken from starting positions, the second-to-last is taken\r\ntimes and so on.Now let\u00e2\u0080\u0099s find the optimal way to choose . Fix some\r\nvalues of . Take a look at the smallest of these values and the largest\r\nof them. Let the values be and . If they differ by at least (), then the\r\nsmaller result can always be achieved by moving a regular chest from the\r\nlarger one to the smaller one. ProofConsider two sequences of\r\ncoefficients for both intervals: and .However, if you remove one chest,\r\nthen they will be equal to and .If you only consider the difference\r\nbetween the numbers of both sequences, then you can see that only\r\ncoefficient got removed and coefficient was added. So you can rearrange\r\nthe chests in such a way that all chests are assigned to the same value\r\nand only the chest that was assigned to becomes assigned to , thus\r\ndecreasing the total value.Now we have all set now. The only thing left\r\nis to assign chests optimally. Write down the union of all the\r\ncoefficient sequences from all the intervals and sort them in the\r\nnon-decreasing order. It\u00e2\u0080\u0099s easy to show that the chests should be sorted\r\nin the non-increasing order (really classical thing, you can try proving\r\nthat by showing that any other arrangement can easily be improved once\r\nagain).That allows us to write a solution in . Sort all the chests in\r\nthe beginning, after that for some multiply the value of the -th chest\r\nby and sum up the results.Finally, let\u00e2\u0080\u0099s speed this up with prefix sums.\r\nNotice that the first values are multiplied by , the second values by\r\nand so on. If is not divisible by , then the last block just has length\r\nsmaller than . Thus, we can calculate the answer for some in . And\r\nthat\u00e2\u0080\u0099s equal to = .Overall complexity: .\r\n"
}