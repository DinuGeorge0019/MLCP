{"link": "https://codeforces.com//contest/1895/problem/E", "problemId": "2305459", "problem_idx": "E", "shortId": "1895E", "contest_number": "1895", "problem_submissions": {"F": [231327821, 231171975, 231177341, 231177139, 231181247, 231175451, 231179505, 231178754, 231171033, 231178007, 231174701, 231183326, 231187269, 231180010, 231181283, 231185538, 231191457, 231188914, 231183055, 231180065, 231188744], "E": [231166411, 231162837, 231168539, 231171744, 231170279, 231169982, 231169182, 231183134, 231173048, 231168317, 231174671, 231173323, 231173438, 231175391, 231175133, 231176680, 231179383, 231171479, 231175722, 231195510], "D": [231152062, 231147559, 231156462, 231152946, 231160742, 231157174, 231157872, 231159102, 231163758, 231163699, 231163345, 231153744, 231159964, 231158155, 231162193, 231160798, 231161526, 231144729, 231162242, 231164715, 231182588, 231152194], "C": [231148538, 231143114, 231150605, 231147252, 231154149, 231154615, 231153991, 231151789, 231144066, 231169078, 231151364, 231154661, 231154195, 231153927, 231153798, 231162003, 231153879, 231145977, 231148366, 231148040], "B": [231139170, 231136290, 231139512, 231137580, 231137719, 231135569, 231140209, 231138699, 231136948, 231136771, 231139306, 231136791, 231139010, 231138206, 231140302, 231137608, 231140161, 231139339, 231137240, 231137323], "A": [231135878, 231135554, 231135956, 231135743, 231135841, 231137384, 231140495, 231135913, 231135720, 231135699, 231136135, 231135592, 231135620, 231135621, 231136784, 231135521, 231136631, 231135611, 231135732, 231135594], "G": [231214354, 231210500, 231273875, 231214703, 231213900, 231213313]}, "name": "E. Infinite Card Game", "statement": "Monocarp and Bicarp are playing a card game. Each card has two\r\nparameters: an attack value and a defence value. A card s beats another\r\ncard t if the attack of s is strictly greater than the defence of\r\nt.Monocarp has n cards, the i-th of them has an attack value of\r\nmathit{ax}_i and a defence value of\r\nmathit{ay}_i. Bicarp has m cards, the j-th of them has an attack value\r\nof\r\nmathit{bx}_j and a defence value of\r\nmathit{by}_j.On the first move, Monocarp chooses one of his cards and\r\nplays it. Bicarp has to respond with his own card that beats that card.\r\nAfter that, Monocarp has to respond with a card that beats Bicarp\u2019s\r\ncard. After that, it\u2019s Bicarp\u2019s turn, and so forth. It implies that each\r\nplayer always has the same set of cards to play as at the start of the\r\ngame. The game ends when the current player has no cards that beat the\r\ncard which their opponent just played, and the current player loses.If\r\nthe game lasts for 100^{500} moves, it\u2019s declared a draw.Both Monocarp\r\nand Bicarp play optimally. That is, if a player has a winning strategy\r\nregardless of his opponent\u2019s moves, he plays for a win. Otherwise, if he\r\nhas a drawing strategy, he plays for a draw.You are asked to calculate\r\nthree values: the number of Monocarp\u2019s starting moves that result in a\r\nwin for Monocarp; the number of Monocarp\u2019s starting moves that result in\r\na draw; the number of Monocarp\u2019s starting moves that result in a win for\r\nBicarp.\r\n", "solutions": ["#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll=long long;\nusing ld=long double;\nconst ll ILL=2167167167167167167;\nconst int INF=2100000000;\nconst int mod=998244353;\n#define rep(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define all(p) p.begin(),p.end()\ntemplate<class T> using _pq = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T> ll LB(vector<T> &v,T a){return lower_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> ll UB(vector<T> &v,T a){return upper_bound(v.begin(),v.end(),a)-v.begin();}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}else return 0;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}else return 0;}\ntemplate<class T> void So(vector<T> &v) {sort(v.begin(),v.end());}\ntemplate<class T> void Sore(vector<T> &v) {sort(v.begin(),v.end(),[](T x,T y){return x>y;});}\nvoid yneos(bool a,bool upp=0){if(a) cout<<(upp?\"YES\\n\":\"Yes\\n\"); else cout<<(upp?\"NO\\n\":\"No\\n\");}\ntemplate<class T> void vec_out(vector<T> &p,int ty=0){\nif(ty==2){cout<<'{';for(int i=0;i<(int)p.size();i++){if(i){cout<<\",\";}cout<<'\"'<<p[i]<<'\"';}cout<<\"}\\n\";}\nelse{if(ty==1){cout<<p.size()<<\"\\n\";}for(int i=0;i<(int)(p.size());i++){if(i) cout<<\" \";cout<<p[i];}cout<<\"\\n\";}}\ntemplate<class T> T vec_min(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmin(ans,x);return ans;}\ntemplate<class T> T vec_max(vector<T> &a){assert(!a.empty());T ans=a[0];for(auto &x:a) chmax(ans,x);return ans;}\ntemplate<class T> T vec_sum(vector<T> &a){assert(!a.empty());T ans=a[0]-a[0];for(auto &x:a) ans+=x;return ans;}\nint pop_count(long long a){int res=0;while(a){res+=(a&1),a>>=1;}return res;}\n\n\n\nvoid solve();\n// oddloop\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    int t=1;\n    cin>>t;\n    rep(i,0,t) solve();\n}\n\nvoid solve(){\n\tvector<vector<pair<int,int>>> A(2);\n\tvector<vector<int>> B(2),seen(2);\n\tvector<vector<vector<int>>> G(2);\n\trep(i,0,2){\n\t\tint N;\n\t\tcin>>N;\n\t\tA[i].resize(N);\n\t\trep(j,0,N) cin>>A[i][j].first;\n\t\trep(j,0,N) cin>>A[i][j].second;\n\t\tSo(A[i]);\n\t\tB[i].resize(N);\n\t\tG[i].resize(N);\n\t\tseen[i].resize(N,0);\n\t\tint tmp=0,ind=-1;\n\t\tfor(int j=N-1;j>=0;j--){\n\t\t\tif(chmax(tmp,A[i][j].second)) ind=j;\n\t\t\tB[i][j]=ind;\n\t\t}\n\t}\n\tvector<pair<int,int>> order;\n\trep(i,0,2){\n\t\trep(j,0,A[i].size()){\n\t\t\tint b=UB(A[i^1],make_pair(A[i][j].second,INF));\n\t\t\tif(b==(int)(A[i^1].size())){\n\t\t\t\tseen[i][j]=1;\n\t\t\t\torder.push_back({i,j});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tG[i^1][B[i^1][b]].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,order.size()){\n\t\tint a,b;\n\t\ttie(a,b)=order[i];\n\t\tfor(auto x:G[a][b]){\n\t\t\tseen[a^1][x]=seen[a][b]*-1;\n\t\t\torder.push_back({a^1,x});\n\t\t}\n\t}\n\tvector<int> ans(3);\n\tfor(auto x:seen[0]) ans[1-x]++;\n\tvec_out(ans); \n}"], "input": "", "output": "", "tags": ["binary search", "brute force", "data structures", "dfs and similar", "dp", "dsu", "games", "graphs", "greedy", "sortings", "two pointers"], "dificulty": "2300", "interactive": false}