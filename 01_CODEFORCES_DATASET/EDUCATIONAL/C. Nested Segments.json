{
    "link": "https://codeforces.com//contest/976/problem/C",
    "problemId": "179787",
    "problem_idx": "C",
    "shortId": "976C",
    "contest_number": "976",
    "problem_submissions": {
        "F": [
            37763363,
            37769230,
            37771809,
            37769578,
            37765676,
            37771852,
            37775489,
            40889146,
            37778041,
            37772108,
            37770120,
            37757030
        ],
        "E": [
            37759612,
            37757569,
            37763598,
            37765549,
            37756497,
            37767476,
            37763904,
            37761921,
            37762005,
            37760373,
            37795909,
            37761211,
            37765405,
            72387001,
            37763422,
            37761979,
            37766932,
            37762131,
            37774529,
            37769526
        ],
        "D": [
            37757523,
            37766476,
            37758195,
            37762921,
            38269676,
            37760546,
            37768835,
            37769171,
            37773037,
            37769443,
            37775265,
            37789135,
            37775829,
            37773943,
            37772078,
            37768377,
            37772102
        ],
        "C": [
            37753334,
            37753217,
            37761367,
            37754559,
            37753952,
            37755372,
            37756629,
            37754330,
            37754742,
            37756131,
            37753666,
            37754884,
            37754248,
            37754586,
            37754439,
            37755438,
            37764985,
            37761302,
            37758356
        ],
        "B": [
            37752460,
            37751754,
            37759385,
            37753338,
            37752699,
            37754118,
            37754359,
            37753149,
            37755340,
            37754515,
            37752717,
            37753548,
            37753298,
            37756555,
            37753663,
            37754307,
            37766708,
            37755815,
            37756102
        ],
        "A": [
            37750664,
            37750612,
            37751755,
            37750646,
            37750641,
            37751080,
            37750713,
            37750665,
            37750980,
            37750618,
            37750952,
            37750900,
            37751444,
            37752036,
            37752198,
            37763975,
            37751822,
            37753480
        ]
    },
    "name": "C. Nested Segments",
    "statement": "You are given a sequence of one-dimensional segments numbered through .\r\nYour task is to find two distinct indices and such that segment lies\r\nwithin segment .Segment lies within segment iff and .Print indices and .\r\nIf there are multiple answers, print any of them. If no answer exists,\r\nprint .\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\npii in[300050];\nint u[300050];\n\nint main() {\n\tint N, i;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tu[i] = i;\n\t\tscanf(\"%d %d\", &in[i].first, &in[i].second);\n\t}\n\tsort(u + 1, u + N + 1, [](int a, int b) {\n\t\tif (in[a].first != in[b].first) return in[a].first < in[b].first;\n\t\telse return in[a].second > in[b].second;\n\t});\n\n\tint mxp = u[1];\n\tfor (i = 2; i <= N; i++) {\n\t\tif (in[u[i]].second <= in[mxp].second) return !printf(\"%d %d\\n\", u[i], mxp);\n\t\telse mxp = u[i];\n\t}\n\treturn !printf(\"-1 -1\\n\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "sortings"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Nested Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/59195",
    "editorial": "Letâs sort segments firstly by their left border in increasing order and\r\nin case of equal by their right border in decreasing order. If there is\r\nany valid pair then the inner segment will always go after the outer\r\none. Now you can go from left to right, keep the maximum right border of\r\nprocessed segments and compare it to the current segment. Overall\r\ncomplexity: .\r\n",
    "hint": []
}