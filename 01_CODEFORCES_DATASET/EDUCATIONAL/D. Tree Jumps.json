{
    "link": "https://codeforces.com//contest/2070/problem/D",
    "problemId": "3233353",
    "problem_idx": "D",
    "shortId": "2070D",
    "contest_number": "2070",
    "problem_submissions": {
        "F": [
            308138412,
            308139598,
            308140261,
            308135086,
            308908838,
            308908402,
            308148058,
            308132721,
            308156502,
            308160384,
            308171018,
            308167755,
            308165459,
            308169840,
            308157047,
            308169763,
            308168481,
            308160062,
            308168693,
            308165415,
            308163695,
            308171178,
            308169858,
            308170143,
            308112373,
            308154384
        ],
        "E": [
            308118136,
            308123977,
            308115696,
            308119993,
            308121221,
            308160669,
            308139138,
            308136015,
            308135014,
            308127816,
            308146323,
            308144103,
            308131271,
            308145219,
            308126468,
            308144951,
            308131787,
            308146433,
            308129269,
            308170336
        ],
        "D": [
            308106225,
            308103599,
            308103669,
            308108885,
            308112445,
            308106317,
            308115443,
            308108990,
            308111970,
            308115191,
            308111541,
            308110510,
            308111609,
            308122150,
            308114708,
            308128882,
            308117643,
            308118502,
            308133018,
            308115402
        ],
        "C": [
            308100859,
            308098324,
            308098879,
            308109896,
            308106577,
            308101095,
            308107090,
            308102322,
            308104592,
            308108143,
            308104331,
            308111140,
            308106216,
            308114471,
            308109710,
            308123284,
            308111358,
            308110052,
            308140320,
            308124878
        ],
        "B": [
            308096187,
            308093094,
            308093408,
            308096114,
            308095735,
            308094203,
            308101217,
            308098141,
            308098911,
            308093342,
            308098262,
            308097763,
            308099852,
            308108770,
            308099377,
            308099819,
            308097452,
            308104146,
            308143559,
            308098413
        ],
        "A": [
            308091489,
            308091216,
            308091213,
            308091721,
            308091212,
            308091326,
            308095453,
            308091596,
            308092398,
            308091301,
            308091697,
            308091411,
            308091275,
            308091454,
            308091384,
            308091843,
            308091304,
            308091461,
            308145036,
            308091695
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/140146",
    "editorial": "We can solve this problem by using dynamic programming. Let represent\r\nthe number of valid sequences ending at vertex . To calculate , we can\r\niterate over all previous vertices in the sequence, such that and (or is\r\nthe root). Then, is the sum of for all such . Note that the vertices\r\nshould be processed in order of increasing distance from the root,\r\nbecause otherwise, might not be calculated when we need to use it in .\r\nHowever, this approach can be very slow, as there may be vertices for\r\neach vertex . In order to speed up this solution, we can observe that if\r\nvertices have the same distance from the root, the calculation of their\r\nvalues follows a similar pattern. Specifically, we only need to consider\r\nthe values of vertices in the previous \"layer\" of the tree, excluding\r\ntheir parent node. Thus, we can store the sum of all values for each\r\n\"layer\". Let be the sum of for all vertices with distance from the root.\r\nThen we can easily calculate as (or minus if is the root). The answer to\r\nthe problem is the sum of all values . To order the vertices according\r\nto the distance from the root, you can use DFS (and then sort the\r\nvertices according to the distance) or BFS. Or you can use the following\r\nmethod: since for every vertex, the index of its parent is less, we can\r\nprocess the vertices from to and set . Then, for every depth, you can\r\nbuild a vector of all vertices on that depth (by adding each vertex to\r\nthe corresponding vector). This approach works in .\r\n",
    "name": "D. Tree Jumps",
    "statement": "You are given a rooted tree, consisting of n vertices. The vertices in\r\nthe tree are numbered from 1 to n, and the root is the vertex 1. Let d_x\r\nbe the distance (the number of edges on the shortest path) from the root\r\nto the vertex x.There is a chip that is initially placed at the root.\r\nYou can perform the following operation as many times as you want\r\n(possibly zero): move the chip from the current vertex v to a vertex u\r\nsuch that d_u = d_v + 1. If v is the root, you can choose any vertex u\r\nmeeting this constraint; however, if v is not the root, u should not be\r\na neighbor of v (there should be no edge connecting v and u). For\r\nexample, in the tree above, the following chip moves are possible: 1\r\nrightarrow 2, 1\r\nrightarrow 5, 2\r\nrightarrow 7, 5\r\nrightarrow 3, 5\r\nrightarrow 4, 3\r\nrightarrow 6, 7\r\nrightarrow 6.A sequence of vertices is if you can move the chip in such\r\na way that it visits all vertices from the sequence (and only them), in\r\nthe order they are given in the sequence.Your task is to calculate the\r\nnumber of valid vertex sequences. Since the answer might be large, print\r\nit modulo 998244353.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Tree Jumps.json",
    "hint": []
}