{
    "link": "https://codeforces.com//contest/1065/problem/D",
    "problemId": "235281",
    "problem_idx": "D",
    "shortId": "1065D",
    "contest_number": "1065",
    "problem_submissions": {
        "G": [
            44147383,
            44142689,
            64875649,
            44176191,
            44151224,
            44148655
        ],
        "F": [
            44140103,
            44135158,
            44149164,
            44170796,
            44144683,
            44147682,
            44150813,
            44148584,
            44232284,
            44149497,
            44149530,
            44147181,
            44142305,
            44150346,
            44135080,
            44139962,
            44154242,
            44143115,
            44173159
        ],
        "E": [
            44135655,
            44147876,
            44135777,
            44147851,
            44136930,
            44146829,
            44136198,
            44142963,
            44143566,
            44144277,
            44137199,
            44146967,
            44148616,
            44133656,
            44142278,
            44138211,
            44126340,
            44141084,
            44146795,
            44140823
        ],
        "D": [
            44131742,
            44145378,
            44140071,
            44135909,
            44143930,
            44133600,
            44143692,
            44140442,
            44140210,
            44138706,
            44143640,
            44144314,
            44158291,
            44137709,
            44163831,
            44137474,
            44135591,
            44136408
        ],
        "C": [
            44121602,
            44120175,
            44124781,
            44126011,
            44125676,
            44121365,
            44127681,
            44121729,
            44126925,
            44123439,
            44127185,
            44130687,
            44137712,
            44126326,
            44122320,
            44121809,
            44122322,
            44129853,
            44123901,
            44127061
        ],
        "B": [
            44119298,
            44120920,
            44120806,
            44122001,
            44121592,
            44118170,
            44120220,
            44123249,
            44122493,
            44127205,
            44122290,
            44123314,
            44136224,
            44122582,
            44118742,
            44120144,
            44119274,
            44120858,
            44120292,
            44127423
        ],
        "A": [
            44117312,
            44121828,
            44117393,
            44117877,
            44118469,
            44117250,
            44118091,
            44118967,
            44118166,
            44118757,
            44117346,
            44118839,
            44117870,
            44119633,
            44117273,
            44117291,
            44117281,
            44117657,
            44117462,
            44117869
        ]
    },
    "name": "D. Three Pieces",
    "statement": "You stumbled upon a new kind of chess puzzles. The chessboard you are\r\ngiven is not necesserily 8\r\ntimes 8, but it still is N\r\ntimes N. Each square has some number written on it, all the numbers are\r\nfrom 1 to N^2 and all the numbers are pairwise distinct. The j-th square\r\nin the i-th row has a number A_{ij} written on it.In your chess set you\r\nhave only three pieces: a knight, a bishop and a rook. At first, you put\r\none of them on the square with the number 1 (you can choose which one).\r\nThen you want to reach square 2 (possibly passing through some other\r\nsquares in process), then square 3 and so on until you reach square N^2.\r\nIn one step you are allowed to either make a valid move with the current\r\npiece or replace it with some other piece. .A knight can move to a\r\nsquare that is two squares away horizontally and one square vertically,\r\nor two squares vertically and one square horizontally. A bishop moves\r\ndiagonally. A rook moves horizontally or vertically. The move should be\r\nperformed to a different square from the one a piece is currently\r\nstanding on.You want to minimize the number of steps of the whole\r\ntraversal. Among all the paths to have the same number of steps you want\r\nto choose the one with the lowest number of piece replacements.What is\r\nthe path you should take to satisfy all conditions?\r\n",
    "solutions": [
        "/*\n    Author: isaf27 (Ivan Safonov)\n*/\n\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//defines\ntypedef long long ll;\ntypedef long double ld;\n#define TIME clock() * 1.0 / CLOCKS_PER_SEC\n#define fastIO ios_base::sync_with_stdio(0)\n#define nul point(0, 0)\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define solve_system int number; cin >> number; for (int i = 0; i < number; i++) solve()\n#define solve_system_scanf int number; scanf(\"%d\", &number); for (int i = 0; i < number; i++) solve()\n\n//permanent constants\nconst ld pi = acos(-1.0);\nconst ld log23 = 1.58496250072115618145373894394781;\nconst ld eps = 1e-8;\nconst ll INF = 1e18 + 239;\nconst ll prost = 239;\nconst int two = 2;\nconst int th = 3;\nconst ll MOD = 998244353;\nconst ll MOD2 = MOD * MOD;\nconst int BIG = 1e9 + 239;\nconst int alf = 26;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nconst int dig = 10;\nconst int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nconst int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};\nconst int bt = 31;\n\n//easy functions\ntemplate< typename T >\ninline T gcd(T a, T b)\n{\n    while (a)\n    {\n        b %= a;\n        swap(a, b);\n    }\n    return b;\n}\ntemplate< typename T >\ninline T lcm(T a, T b) { return (a / gcd(a, b)) * b; }\ninline bool is_down(char x) { return ('a' <= x && x <= 'z'); }\ninline bool is_upper(char x) { return ('A' <= x && x <= 'Z'); }\ninline bool is_digit(char x) { return ('0' <= x && x <= '9'); }\n\n//random\nmt19937 rnd(239);\n\n//constants\nconst int M = 2 * 1e5 + 239;\nconst int N = 2 * 1e3 + 239;\nconst int L = 20;\nconst int T = (1 << 18);\nconst int B = trunc(sqrt(M)) + 1;\nconst int X = 150;\nconst int Y = 11;\n\nint n;\npair<int, int> dp[th][X];\npair<int, int> pos[X];\nint vx[th][X], vy[th][X], k[X];\npair<int, int> dist[th][Y][Y][th][Y][Y];\n\nbool check(int x, int y)\n{\n    return (0 <= x && x < n && 0 <= y && y < n);\n}\n\n/*int way(int c, int xs, int ys, int xf, int yf)\n{\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dist[i][j] = BIG;\n    dist[xs][ys] = 0;\n    queue<pair<int, int> > q;\n    q.push(make_pair(xs, ys));\n    while (!q.empty())\n    {\n        pair<int, int> nw = q.front();\n        q.pop();\n        int x = nw.first;\n        int y = nw.second;\n        for (int d = 0; d < k[c]; d++)\n        {\n            int gx = x + vx[c][d];\n            int gy = y + vy[c][d];\n            if ()\n        }\n    }\n}*/\n\nint main()\n{\n    #ifdef ONPC\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    ios::sync_with_stdio(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n            int a;\n            cin >> a;\n            a--;\n            pos[a] = make_pair(i, j);\n        }\n    k[0] = (4 * n);\n    for (int i = 0; i < n; i++)\n    {\n        vx[0][i] = 0;\n        vy[0][i] = i + 1;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        vx[0][i + n] = i + 1;\n        vy[0][i + n] = 0;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        vx[0][i + 2 * n] = 0;\n        vy[0][i + 2 * n] = -(i + 1);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        vx[0][i + 3 * n] = -(i + 1);\n        vy[0][i + 3 * n] = 0;\n    }\n    k[1] = (4 * n);\n    for (int i = 0; i < n; i++)\n    {\n        vx[1][i] = i + 1;\n        vy[1][i] = i + 1;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        vx[1][i + n] = i + 1;\n        vy[1][i + n] = -(i + 1);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        vx[1][i + 2 * n] = -(i + 1);\n        vy[1][i + 2 * n] = (i + 1);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        vx[1][i + 3 * n] = -(i + 1);\n        vy[1][i + 3 * n] = -(i + 1);\n    }\n    k[2] = 8;\n    vx[2][0] = 1;\n    vx[2][1] = 2;\n    vx[2][2] = 2;\n    vx[2][3] = 1;\n    vx[2][4] = -1;\n    vx[2][5] = -2;\n    vx[2][6] = -2;\n    vx[2][7] = -1;\n    vy[2][0] = -2;\n    vy[2][1] = -1;\n    vy[2][2] = 1;\n    vy[2][3] = 2;\n    vy[2][4] = 2;\n    vy[2][5] = 1;\n    vy[2][6] = -1;\n    vy[2][7] = -2;\n    for (int i = 0; i < 3; i++)\n        for (int x1 = 0; x1 < n; x1++)\n            for (int y1 = 0; y1 < n; y1++)\n    for (int j = 0; j < 3; j++)\n        for (int x2 = 0; x2 < n; x2++)\n            for (int y2 = 0; y2 < n; y2++)\n                dist[i][x1][y1][j][x2][y2] = make_pair(BIG, BIG);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            for (int h = 0; h < 3; h++)\n                dist[h][i][j][h][i][j] = make_pair(0, 0);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            for (int h1 = 0; h1 < 3; h1++)\n                for (int h2 = 0; h2 < 3; h2++)\n                    if (h1 != h2)\n                        dist[h1][i][j][h2][i][j] = make_pair(1, 1);\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            for (int h = 0; h < 3; h++)\n                for (int d = 0; d < k[h]; d++)\n                {\n                    int gx = i + vx[h][d];\n                    int gy = j + vy[h][d];\n                    if (!check(gx, gy)) continue;\n                    dist[h][i][j][h][gx][gy] = make_pair(1, 0);\n                }\n    for (int i = 0; i < 3; i++)\n        for (int x1 = 0; x1 < n; x1++)\n            for (int y1 = 0; y1 < n; y1++)\n    for (int j = 0; j < 3; j++)\n        for (int x2 = 0; x2 < n; x2++)\n            for (int y2 = 0; y2 < n; y2++)\n    for (int h = 0; h < 3; h++)\n        for (int x3 = 0; x3 < n; x3++)\n            for (int y3 = 0; y3 < n; y3++)\n            {\n                pair<int, int> now = dist[j][x2][y2][i][x1][y1];\n                now.first += dist[i][x1][y1][h][x3][y3].first;\n                now.second += dist[i][x1][y1][h][x3][y3].second;\n                dist[j][x2][y2][h][x3][y3] = min(now, dist[j][x2][y2][h][x3][y3]);\n            }\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < n * n; j++)\n            dp[i][j] = make_pair(BIG, BIG);\n    for (int i = 0; i < 3; i++)\n        dp[i][0] = make_pair(0, 0);\n    for (int i = 0; i < n * n - 1; i++)\n    {\n        int xs = pos[i].first;\n        int ys = pos[i].second;\n        int xf = pos[i + 1].first;\n        int yf = pos[i + 1].second;\n        for (int t1 = 0; t1 < 3; t1++)\n            for (int t2 = 0; t2 < 3; t2++)\n            {\n                pair<int, int> now = dp[t1][i];\n                pair<int, int> ch = dist[t1][xs][ys][t2][xf][yf];\n                now.first += ch.first;\n                now.second += ch.second;\n                dp[t2][i + 1] = min(dp[t2][i + 1], now);\n            }\n    }\n    pair<int, int> ans = make_pair(BIG, BIG);\n    for (int i = 0; i < 3; i++)\n        ans = min(ans, dp[i][n * n - 1]);\n    cout << ans.first << \" \" << ans.second;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "shortest paths"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Three Pieces.json",
    "editorial_link": "https://codeforces.com//blog/entry/62411",
    "editorial": "There are a lot of different solutions for the problem. Most of them\r\nhave the similar structure.The first part is to find the shortest\r\ndistance between the states and , where and are the coordinates of the\r\nsquare and is the current piece. This can be done with 0-1 bfs, Floyd or\r\nDijkstra. Just represent the triple as a single integer by transforming\r\nit to and do everything on that graph.The second part is to write some\r\ndp to go from -th square with piece to -th square with piece . The value\r\nof this is a pair (moves, replacements). It is easy to see that you can\r\nalways choose the minimum of two such pairs while updating.Overall\r\ncomplexity may vary. We believe, is achievable. However, the particular\r\nsolution I coded works in .\r\n",
    "hint": []
}