{
    "link": "https://codeforces.com//contest/1354/problem/F",
    "problemId": "623449",
    "problem_idx": "F",
    "shortId": "1354F",
    "contest_number": "1354",
    "problem_submissions": {
        "G": [
            80502712,
            80500640,
            80479424,
            80521575,
            80514570,
            80507519,
            80516727,
            80506952,
            80522749,
            80517834
        ],
        "F": [
            80492752,
            80491818,
            80486741,
            80486733,
            80498606,
            80506559,
            80492000,
            80506147,
            80493453,
            80507365,
            80500930,
            80492368,
            80502196,
            80506705,
            80501348,
            80502603,
            80507003,
            80504378,
            80500666,
            80509209
        ],
        "E": [
            80478361,
            80481693,
            80494073,
            80473313,
            80489080,
            80489590,
            80500698,
            80489890,
            80484400,
            80477593,
            80478451,
            80492063,
            80495115,
            80483322,
            80494477,
            80486894,
            80494427,
            80491606,
            80488314
        ],
        "D": [
            80469519,
            80470691,
            80498555,
            80467168,
            80480497,
            80478286,
            80477445,
            80477111,
            80466399,
            80471019,
            80473056,
            80471601,
            80482362,
            80488495,
            80473238,
            80482948,
            80466995,
            80486731,
            80484796,
            80475358
        ],
        "C2": [
            80463522,
            80484245,
            80502970,
            80478908,
            80472069,
            80468985,
            80468689,
            80472664,
            80476619,
            80476720,
            80489656,
            80477361,
            80476069,
            80503667,
            80473397,
            80472911,
            80489616,
            80481827,
            80482549,
            80500296
        ],
        "C1": [
            80463378,
            80464968,
            80501505,
            80478534,
            80468463,
            80462050,
            80463990,
            80463377,
            80459508,
            80460645,
            80463967,
            80465199,
            80472341,
            80461193,
            80463170,
            80458830,
            80475032,
            80470173,
            80520837,
            80468845,
            80464138
        ],
        "B": [
            80454412,
            80455734,
            80504343,
            80456075,
            80456469,
            80457930,
            80459404,
            80456913,
            80454847,
            80456739,
            80454406,
            80455296,
            80457195,
            80455557,
            80457336,
            80455902,
            80456106,
            80460925,
            80455491,
            80455115
        ],
        "A": [
            80454037,
            80454106,
            80505746,
            80454365,
            80454427,
            80454271,
            80454716,
            80454697,
            80454135,
            80454424,
            80455156,
            80454027,
            80454887,
            80454126,
            80454558,
            80454452,
            80454285,
            80456834,
            80476438,
            80454206
        ]
    },
    "name": "F. Summoning Minions",
    "statement": "Polycarp plays a computer game. In this game, the players summon armies\r\nof magical minions, which then fight each other.Polycarp can summon n\r\ndifferent minions. The initial power level of the i-th minion is a_i,\r\nand when it is summoned, all previously summoned minions’ power levels\r\nare increased by b_i. The minions can be summoned in any\r\norder.Unfortunately, Polycarp cannot have more than k minions under his\r\ncontrol. To get rid of unwanted minions after summoning them, he may\r\ndestroy them. Each minion can be summoned (and destroyed) only\r\nonce.Polycarp’s goal is to summon the strongest possible army. Formally,\r\nhe wants to maximize the sum of power levels of all minions under his\r\ncontrol (those which are summoned and not destroyed).Help Polycarp to\r\nmake up a plan of actions to summon the strongest possible army!\r\n",
    "solutions": [
        "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1012345678;\nvector<int> transform(int n, vector<int> arr, vector<int> perm) {\n\tvector<int> res(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tres[i] = arr[perm[i]];\n\t}\n\treturn res;\n}\nint main() {\n\tint Q;\n\tcin >> Q;\n\twhile (Q--) {\n\t\tint N, K;\n\t\tcin >> N >> K;\n\t\tvector<int> A(N), B(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> A[i] >> B[i];\n\t\t}\n\t\tvector<int> perm(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tperm[i] = i;\n\t\t}\n\t\tsort(perm.begin(), perm.end(), [&](int i, int j) { return B[i] < B[j]; });\n\t\tA = transform(N, A, perm);\n\t\tB = transform(N, B, perm);\n\t\tint bsum = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tbsum += B[i] * (K - 1);\n\t\t}\n\t\tvector<vector<int> > dp(N + 1, vector<int>(K, -inf));\n\t\tdp[0][0] = bsum;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < K; ++j) {\n\t\t\t\tdp[i + 1][j] = dp[i][j];\n\t\t\t\tif (j >= 1) {\n\t\t\t\t\tdp[i + 1][j] = max(dp[i + 1][j], dp[i][j - 1] + A[i] - B[i] * (K - j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint opt = -1, optval = -inf;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (dp[i][K - 1] == -inf) continue;\n\t\t\tint val = dp[i][K - 1];\n\t\t\tint mx = *max_element(A.begin() + i, A.end());\n\t\t\tval += mx;\n\t\t\tif (optval < val) {\n\t\t\t\toptval = val;\n\t\t\t\topt = i;\n\t\t\t}\n\t\t}\n\t\tvector<int> seq;\n\t\tint ptr = K - 1;\n\t\tfor (int i = opt - 1; i >= 0; --i) {\n\t\t\tif (dp[i][ptr] != dp[i + 1][ptr]) {\n\t\t\t\tseq.push_back(i);\n\t\t\t\t--ptr;\n\t\t\t}\n\t\t}\n\t\treverse(seq.begin(), seq.end());\n\t\tint last = max_element(A.begin() + opt, A.end()) - A.begin();\n\t\tvector<int> ans;\n\t\tfor (int i : seq) {\n\t\t\tans.push_back(perm[i] + 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!binary_search(seq.begin(), seq.end(), i) && i != last) {\n\t\t\t\tans.push_back(perm[i] + 1);\n\t\t\t\tans.push_back(-(perm[i] + 1));\n\t\t\t}\n\t\t}\n\t\tans.push_back(perm[last] + 1);\n\t\tcout << ans.size() << endl;\n\t\tfor (int i = 0; i < ans.size(); ++i) {\n\t\t\tif (i) cout << ' ';\n\t\t\tcout << ans[i];\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "flows",
        "graph matchings",
        "greedy",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Summoning Minions.json",
    "editorial_link": "https://codeforces.com//blog/entry/77593",
    "editorial": "First of all, letâs try to find the best strategy to play minions. All\r\nminions should be summoned (if someone is not summoned, summoning and\r\ndeleting it wonât make the answer worse), the resulting number of\r\nminions should be exactly (if it is less, then we didnât need to delete\r\nthe last deleted minion). Furthermore, if some minion should be deleted,\r\nwe can delete it just after it is summoned. All these greedy ideas lead\r\nto the following structure of the answer: we choose minions and summon\r\nthem in some order; we choose minions which will be summoned and\r\ninstantly deleted; we summon the remaining minion. Letâs analyze how\r\nthese minions affect the answer. The first minion has power and does not\r\ngive bonus to anyone, the second one has power and gives bonus to one\r\nminion, and so on the -th minion from the first group adds to the\r\nanswer. Minions from the second group buff minions each, so they add to\r\nthe answer; and the last minion adds . Letâs unite the first group and\r\nthe last minion; then we will have two groups of minions those which are\r\ndestroyed (the second group) and those which are not destroyed (the\r\nfirst group).From there, we will have two possible ways to finish the\r\nsolution: there are minions and positions for them, and for each pair\r\n(minion, position) we may calculate the value this pair adds to the\r\nanswer. After that, we should assign each monster a position in such a\r\nway that each position is chosen exactly once, and the sum of values is\r\nmaximized. It can be done with mincost flows or Hungarian algorithm; the\r\nminions from the first group should be played in non-descending order of\r\ntheir . Letâs sort all minions by and write the following dynamic\r\nprogramming: is the maximum answer if we considered first minions, and\r\nof them were assigned to the first group. Since the minions are sorted\r\nby , whenever we add a minion to the first group, it should add exactly\r\nto the answer (and increase by ); and if a minion is added to the second\r\ngroup, the answer is increased by .\r\n",
    "hint": []
}