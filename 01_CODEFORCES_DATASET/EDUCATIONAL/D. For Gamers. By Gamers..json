{
    "link": "https://codeforces.com//contest/1657/problem/D",
    "problemId": "1339154",
    "problem_idx": "D",
    "shortId": "1657D",
    "contest_number": "1657",
    "problem_submissions": {
        "F": [
            150503115,
            150499453,
            150509321,
            150511905,
            150517571,
            150521311,
            150511942,
            150512719,
            150504329,
            150515960,
            150512240,
            150519562,
            150516193,
            150522557,
            150517792,
            150525082,
            150521099,
            150526532,
            150498258
        ],
        "E": [
            150486345,
            150490802,
            150491754,
            150496559,
            150501319,
            150488737,
            150492757,
            150496033,
            150497203,
            150502682,
            150498901,
            150493901,
            150495208,
            150499778,
            150499542,
            150491019,
            150503092,
            150493803,
            150498682
        ],
        "D": [
            150478088,
            150483562,
            150484230,
            150485188,
            150483314,
            150482900,
            150485882,
            150491440,
            150494087,
            150489766,
            150493543,
            150488170,
            150502719,
            150493520,
            150493571,
            150497861,
            150497439,
            150487471,
            150503395
        ],
        "C": [
            150470574,
            150477398,
            150472059,
            150473115,
            150473331,
            150472319,
            150476196,
            150478092,
            150490090,
            150480365,
            150484688,
            150478395,
            150476845,
            150477792,
            150483257,
            150480052,
            150480944,
            150481904,
            150506549
        ],
        "B": [
            150466899,
            150465684,
            150465706,
            150466831,
            150467217,
            150466293,
            150467748,
            150486194,
            150467057,
            150470591,
            150468677,
            150466989,
            150468064,
            150466642,
            150468045,
            150467383,
            150467499,
            150468669
        ],
        "A": [
            150464865,
            150464773,
            150464769,
            150464812,
            150465126,
            150464939,
            150464906,
            150472446,
            150464866,
            150467928,
            150466097,
            150464791,
            150464960,
            150464872,
            150464833,
            150465034,
            150465120,
            150470046
        ]
    },
    "name": "D. For Gamers. By Gamers.",
    "statement": "Monocarp is playing a strategy game. In the game, he recruits a squad to\r\nfight monsters. Before each battle, Monocarp has C coins to spend on his\r\nsquad.Before each battle starts, his squad is empty. Monocarp chooses\r\nand recruits no more units of that type than he can recruit with C\r\ncoins.There are n types of units. Every unit type has three parameters:\r\nc_i the cost of recruiting one unit of the i-th type; d_i the damage\r\nthat one unit of the i-th type deals in a second; h_i the amount of\r\nhealth of one unit of the i-th type. Monocarp has to face m monsters.\r\nEvery monster has two parameters: D_j the damage that the j-th monster\r\ndeals in a second; H_j the amount of health the j-th monster has.\r\nMonocarp has to fight only the j-th monster during the j-th battle. He\r\nwants all his recruited units to stay alive. Both Monocarp’s squad and\r\nthe monster attack continuously (not once per second) and at the same\r\ntime. Thus, Monocarp wins the battle if and only if his squad kills the\r\nmonster strictly faster than the monster kills one of his units. The\r\ntime is compared with no rounding.For each monster, Monocarp wants to\r\nknow the minimum amount of coins he has to spend to kill that monster.\r\nIf this amount is greater than C, then report that it’s impossible to\r\nkill that monster.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (int)1e6 + 77;\nconst ll INF = (ll)2e18;\nll a[N];\nll b[N];\nint n, m;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\twhile(n--) {\n\t\tll x, y, z;\n\t\tscanf(\"%lld%lld%lld\", &x, &y, &z);\n\t\tb[x] = max(b[x], y * z);\n\t}\n\tfor (int i = 1; i <= m; i++) if (b[i] > 0)\n\t\tfor (int j = 1; i * j <= m; j++)\n\t\t\ta[i * j] = max(a[i * j], b[i] * j);\n\tfor (int i = 1; i <= m; i++)\n\t\ta[i] = max(a[i], a[i - 1]);\n\tscanf(\"%d\", &n);\n\twhile(n--) {\n\t\tll x, y;\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\tx *= y;\n\t\tint p = upper_bound(a, a + m + 1, x) - a;\n\t\tif (p <= m)\n\t\t\tprintf(\"%d\\n\", p);\n\t\telse\n\t\t\tprintf(\"-1\\n\");\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. For Gamers. By Gamers..json",
    "editorial_link": "https://codeforces.com//blog/entry/101161",
    "editorial": "Imagine you are fighting the -th monster, and you fixed the type of\r\nunits and their amount .Whatâs the win condition? . Rewrite it as .\r\nNotice how we only care about for both the units and the monster, but\r\nnot about and on their own.Letâs call and the power of the squad and the\r\nmonster.You can see that for each cost we can only leave one unit type\r\nof that price that has the largest value of . Letâs call it . Now letâs\r\nlearn to determine the maximum power we can obtain for cost exactly . We\r\ncan iterate over the cost of one unit and the count of units in the\r\nsquad. Since should not exceed , that will take . Propagate to be the\r\nmaximum power for cost exactly .We have the knowledge about cost exactly\r\n, but we actually want no more than . Calculate prefix maximums over\r\nthat will be the maximum power we can obtain with no more than coins.For\r\neach monster, we just have to find the smallest such that . Since the\r\narray is monotone, we can use binary search.Overall complexity: .\r\n",
    "hint": []
}