{
    "link": "https://codeforces.com//contest/2042/problem/E",
    "problemId": "3063463",
    "problem_idx": "E",
    "shortId": "2042E",
    "contest_number": "2042",
    "problem_submissions": {
        "E": [
            294423774,
            294419934,
            294425145,
            294427314,
            294461391,
            294454616,
            294469820,
            294456785,
            294473828,
            294432050,
            294452832,
            294430074,
            294720157,
            294431481,
            294468510,
            294470387,
            294430159
        ],
        "F": [
            294412520,
            294425551,
            294432280,
            294452436,
            294434993,
            294433145,
            294446063,
            294428799,
            294413717,
            294412873,
            294411042,
            294425120,
            294428614,
            294424117,
            294468671,
            294445770,
            294425722,
            294433551,
            294468661,
            294431992,
            294436625
        ],
        "D": [
            294403997,
            294407353,
            294409781,
            294414370,
            294407554,
            294410319,
            294417815,
            294419253,
            294437550,
            294410412,
            294413967,
            294418349,
            294411907,
            294402733,
            294411823,
            294409744,
            294417262,
            294417181,
            294415900
        ],
        "C": [
            294397589,
            294400380,
            294403833,
            294401565,
            294414063,
            294405958,
            294407677,
            294415266,
            294453518,
            294402202,
            294397037,
            294403746,
            294403563,
            294397148,
            294404737,
            294399098,
            294402722,
            294400450,
            294396822
        ],
        "B": [
            294394491,
            294397696,
            294398701,
            294393052,
            294393883,
            294395178,
            294398939,
            294412364,
            294455866,
            294393748,
            294393435,
            294395970,
            294392768,
            294392321,
            294399650,
            294391444,
            294395529,
            294395407,
            294392933
        ],
        "A": [
            294390734,
            294395467,
            294390153,
            294389939,
            294390115,
            294390408,
            294402923,
            294412466,
            294454482,
            294389870,
            294390174,
            294391619,
            294390031,
            294390265,
            294390266,
            294389845,
            294389856,
            294390624,
            294389907
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136886",
    "editorial": "Note that the cost function of a subset actually states the following:\r\nyou are asked to choose the minimum lexicographic subset if the vertices\r\nare ordered in descending order. This can be shown by looking at the\r\nbinary representations of the subset costs.Intuitively, we want to\r\nimplement the following process. Iterate over the vertices in descending\r\norder and check whether we have to take the current vertex in the\r\nsubset, or we can skip it. If we can, we skip it; otherwise, we take\r\nit.How to write this checking function? I think that it is easier to do\r\nthis if we root the tree by a vertex that will definitely be in the\r\nanswer. Finding such a vertex is easy out of two vertices with the value\r\n, at least one will definitely be in the answer. Iterate over it and\r\ntake the best answer from the two options. We can compare the answers by\r\ntheir by binary representations.In the rooted tree, where the root is\r\nalways taken, it is easier to check connectivity. If a vertex is taken\r\nin the subset, then its parent must also be taken. Otherwise, the subset\r\nwill definitely be disconnected.A vertex must be taken in the subset if\r\nthere is a value such that vertices with this value are in its subtree.\r\nHowever, sometimes it happens that one of the two vertices with some\r\nvalue has already been prohibited from being taken. In this case, for\r\nthis value, we need to check that only the non-prohibited vertex is in\r\nthe subtree.Letâs maintain the state of each vertex: the vertex must be\r\ntaken in the subset; the vertex must not be taken in the subset; it has\r\nnot been determined whether to take the vertex or not. Initially, we\r\nknow that for each value, we must take the vertices that are on both\r\npaths from the vertices with this value to the root. So, on the path\r\nfrom their LCA (lowest common ancestor) to the root. If at least one\r\nsuch vertex is not taken, then that value will not appear in the\r\nsubset.A vertex can be skipped if its state is not determined. When we\r\ndecide not to take a vertex, the following happens. The vertices in its\r\nsubtree must also not be taken. And if for some vertex it is marked that\r\nit must not be taken in the subset, then another vertex with the same\r\nvalue must now be taken.We will write two auxiliary functions.The first\r\nfunction marks the state as \"must take\". So, it takes a vertex and jumps\r\nover the parents of vertex until it either reaches the root or an\r\nalready marked vertex. In total, this function will make iterations, as\r\nwith each successful iteration of the loop, another vertex gets\r\nmarked.The second function marks the state as \"must not take\". That is,\r\nit takes a vertex and traverses the subtree of vertex , marking all\r\ndescendants as \"must not take\". I chose to implement this function using\r\na breadth-first search. Again, we can stop the traversal when we see\r\nthat a vertex is already marked as \"must not take\". In total, there will\r\nalso be iterations. When we mark a vertex, we call the first function\r\nfrom another vertex with its value.Overall complexity: (where everything\r\nexcept LCA works in ).\r\n",
    "name": "E. Vertex Pairs",
    "statement": "You are given a tree consisting of 2n vertices. Recall that a tree is a\r\nconnected undirected graph with no cycles. Each vertex has an integer\r\nfrom 1 to n written on it. Each value from 1 to n is written on\r\ndifferent vertices. Each vertex also has a cost vertex i costs 2^i.You\r\nneed to choose a subset of vertices of the tree such that: the subset is\r\nconnected; that is, from each vertex in the subset, you can reach every\r\nother vertex in the subset by passing only through the vertices in the\r\nsubset; each value from 1 to n is written on at least one vertex in the\r\nsubset. Among all such subsets, you need to find the one with the\r\nsmallest total cost of the vertices in it. Note that you are not\r\nrequired to minimize the number of vertices in the subset.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"using namespace std;#define all(x) x.begin(),x.end()template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << \" \" << p.second; }template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { string sep; for (const T &x : v) os << sep << x, sep = \" \"; return os; }#ifdef LOCAL#include \"debug.h\"#else#define debug(...) 42#define ASSERT(...) 42#endiftypedef long long ll;typedef vector<int> vi;typedef vector<vi> vvi;typedef pair<int,int> pi;const int oo = 1e9;struct LCA {    vi par,d,jmp,in,out;    vector<basic_string<int>> adj;    vi ord;    int root;    LCA(int n,int root=0) : par(n,root),d(n),jmp(n,root),in(n),out(n),adj(n),root(root) {}    void add(int i) {        int p = par[i];        d[i]=1+d[p];        if(d[p] - d[jmp[p]] == d[jmp[p]] - d[jmp[jmp[p]]]) jmp[i] = jmp[jmp[p]];        else jmp[i] = p;    }    int jump(int a, int k) {        int D = max(0,d[a]-k);        while(d[a]>D) {            if(d[jmp[a]]>=D) a = jmp[a];            else a = par[a];        }        return a;    }    template<typename F> pi find(int a, F f) {        int steps=d[a];        while(!f(a)) {            if(!f(jmp[a])) a = jmp[a];            else a = par[a];        }        steps-=d[a]-1;        return {a,steps};    }    int lca(int a, int b) {        if(d[a]<d[b]) swap(a,b);        a = jump(a,d[a]-d[b]);        while(a!=b) {            if(jmp[a]!=jmp[b]) a=jmp[a],b=jmp[b];            else a=par[a],b=par[b];        }        return a;    }    void addE(int u, int v) {        adj[u].push_back(v);        adj[v].push_back(u);    }    int cnt=0;    void dfs(int at) {        ord.push_back(at);        in[at]=cnt++;        for(int to: adj[at]) if(to!=par[at])  {            par[to]=at;            add(to);            dfs(to);        }        out[at]=cnt;    }    void init() {        dfs(root);    }};int main() {    ios_base::sync_with_stdio(false);    cin.tie(NULL);    int n; cin >> n;    vi a(2*n);    for(auto& i : a) cin >> i,--i;    vector<basic_string<int>> who(n);    for(int i=0;i<n*2;++i) {        who[a[i]].push_back(i);    }    vector<pi> es(n*2-1);    for(auto& [u,v] : es) cin >> u >> v ,--u,--v;    auto t = who[0];      auto solve = [&](int rt) {        LCA lca(n*2,rt);        for(auto [u,v] : es) {            lca.addE(u,v);        }        lca.init();        vector<bool> vis(n*2),vis2(n*2);        auto put = [&](int i) {            while(!vis[i]) {                vis[i]=1;                                if(lca.par[i]==i) break;                 i=lca.par[i];            }        };        for(auto w : who) {            put(lca.lca(w[0],w[1]));        }        for(int i=n*2-1;i>=0;--i) {            if(!vis[i]) {                auto dfs = [&](auto&& self, int at) {                    if(vis2[at]) return;                    vis2[at]=1;                    auto& w = who[a[at]];                    put(w[0]^w[1]^at);                    for(int to : lca.adj[at]) if(to!=lca.par[at]) {                        self(self,to);                    }                };                dfs(dfs,i);            }        }        return vis;     };    auto res = solve(t[0]);    auto res2 = solve(t[1]);    reverse(all(res));    reverse(all(res2));    res=min(res,res2);    reverse(all(res));    vi ans;    for(int i=0;i<2*n;++i) if(res[i]) ans.push_back(i+1);    cout<<ans.size() << '\\n' << ans << '\\n';  }"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Vertex Pairs.json",
    "hint": []
}