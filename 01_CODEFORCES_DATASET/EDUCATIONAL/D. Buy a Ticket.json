{"link": "https://codeforces.com//contest/938/problem/D", "problemId": "157306", "problem_idx": "D", "shortId": "938D", "contest_number": "938", "problem_submissions": {"G": [35382589, 142741934, 35374754, 35374730, 35374710, 35374477, 46133767, 35440047], "F": [35355120, 35364585, 35363394, 35363174, 35367302, 35374806, 35369385, 35368951, 35367527, 35361321, 35357853, 35375040, 35422822], "E": [35352538, 35354313, 35352415, 35358415, 35352081, 35358431, 35356947, 35369123, 35351851, 35352768, 35353204, 35355446, 35355331, 35364623, 35352359, 35354851, 35364184, 35361370, 35349789], "D": [35346635, 35346136, 35347680, 35354109, 35356864, 35352477, 35380385, 35375255, 35364649, 35366010, 35347274, 35349910, 35350445, 35351420, 35351959, 35348864, 35350459, 35349429, 35350797, 35351471, 35353004], "C": [35345282, 35350127, 35345829, 35352431, 35355200, 35349840, 35349239, 35363657, 35345361, 35347976, 35348608, 35349044, 35347701, 35346898, 35346389, 35351193, 35383156, 35355323, 35348814, 35348388, 35350097, 35356762], "B": [35342225, 35343255, 35342194, 35342912, 35343411, 35345634, 35362645, 35360273, 35342183, 35342830, 35342648, 35343913, 35343057, 35342574, 35342930, 35343254, 35345517, 35342996, 35357602], "A": [35341839, 35341862, 35342757, 35341910, 35341845, 35344578, 35362076, 35359775, 35341793, 35341960, 35341885, 35342136, 35341987, 35341868, 35342317, 35344022, 35341914, 35342769]}, "name": "D. Buy a Ticket", "statement": "Musicians of a popular band \"Flayer\" have announced that they are going\r\nto \"make their exit\" with a world tour. Of course, they will visit\r\nBerland as well.There are cities in Berland. People can travel between\r\ncities using two-directional train routes; there are exactly routes, -th\r\nroute can be used to go from city to city (and from to ), and it costs\r\ncoins to use this route.Each city will be visited by \"Flayer\", and the\r\ncost of the concert ticket in -th city is coins.You have friends in\r\nevery city of Berland, and they, knowing about your programming skills,\r\nasked you to calculate the minimum possible number of coins they have to\r\npay to visit the concert. For every city you have to compute the minimum\r\nnumber of coins a person from city has to spend to travel to some city\r\n(or possibly stay in city ), attend a concert there, and return to city\r\n(if ).Formally, for every you have to calculate , where is the minimum\r\nnumber of coins you have to spend to travel from city to city . If there\r\nis no way to reach city from city , then we consider to be infinitely\r\nlarge.\r\n", "solutions": ["#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nvector <pll> conn[200050];\nll dis[200050];\n\nint main() {\n\tint N, M, i, j;\n\tscanf(\"%d %d\", &N, &M);\n\tfor (i = 1; i <= M; i++) {\n\t\tll t1, t2, t3;\n\t\tscanf(\"%lld %lld %lld\", &t1, &t2, &t3);\n\t\tconn[t1].emplace_back(t3*2, t2);\n\t\tconn[t2].emplace_back(t3*2, t1);\n\t}\n\n\tpriority_queue <pll, vector<pll>, greater<pll>> Hx;\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(\"%lld\", &dis[i]);\n\t\tHx.emplace(dis[i], i);\n\t}\n\twhile (!Hx.empty()) {\n\t\tpll u = Hx.top();\n\t\tHx.pop();\n\t\tif (u.first != dis[u.second]) continue;\n\n\t\tfor (auto it : conn[u.second]) {\n\t\t\tpll u2 = pll(it.first + u.first, it.second);\n\t\t\tif (dis[u2.second] > u2.first) {\n\t\t\t\tdis[u2.second] = u2.first;\n\t\t\t\tHx.push(u2);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= N; i++) printf(\"%lld \", dis[i]);\n\treturn !printf(\"\\n\");\n}"], "input": "", "output": "", "tags": ["data structures", "graphs", "shortest paths"], "dificulty": "2000", "interactive": false}