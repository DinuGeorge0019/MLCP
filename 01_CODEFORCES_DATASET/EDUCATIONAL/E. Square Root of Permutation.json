{
    "link": "https://codeforces.com//contest/612/problem/E",
    "problemId": "43953",
    "problem_idx": "E",
    "shortId": "612E",
    "contest_number": "612",
    "problem_submissions": {
        "F": [
            15015795,
            15017252,
            15017564,
            15018652,
            15015599,
            15019361,
            15017340,
            15018654,
            15018390
        ],
        "E": [
            15010777,
            15013400,
            15012462,
            15011810,
            15012679,
            15013333,
            15013462,
            15013944,
            15012201,
            15013667,
            15013024,
            15014276,
            15013859,
            15015715,
            15015116,
            15015247,
            15029017,
            15014027
        ],
        "D": [
            15009323,
            15008963,
            15010162,
            15010758,
            15010353,
            15011058,
            15011357,
            15011634,
            15014470,
            15010446,
            15011643,
            15012291,
            15011559,
            15012012,
            15012245,
            15011608,
            15011635,
            15028872,
            15012187
        ],
        "C": [
            15008569,
            15009102,
            15009409,
            15009193,
            15010189,
            15009546,
            15011006,
            15009509,
            15009168,
            115507184,
            115502940,
            15010264,
            15009734,
            15009610,
            15009584,
            15010138,
            15009962,
            15009608,
            15009629
        ],
        "B": [
            15008273,
            15008554,
            15008493,
            15008437,
            15009218,
            15008849,
            15010423,
            15011364,
            15008522,
            15009393,
            15008208,
            15008534,
            15008851,
            15008467,
            15008897,
            15008961,
            15010023
        ],
        "A": [
            15008217,
            15008351,
            15008267,
            15008284,
            15008898,
            15008420,
            15010012,
            15010693,
            15008295,
            15008665,
            15008737,
            15008297,
            15008383,
            15008260,
            15008327,
            15008392,
            15008492
        ]
    },
    "name": "E. Square Root of Permutation",
    "statement": "A of length is an array containing each integer from to exactly once.\r\nFor example, is a permutation. For the permutation the square of\r\npermutation is the permutation that for each . For example, the square\r\nof is .This problem is about the inverse operation: given the\r\npermutation you task is to find such permutation that . If there are\r\nseveral such find any of them.\r\n",
    "solutions": [
        "/*\nWe live for the magic in the sound, distorted guitars are breaking ground\nThe drum pounding faster than my heart, the vocals are screaming extreme art\nThe passion for metal drives us forth, the best heavy metal comes from north\n\nThe powerful tunes, spectacular shows, the audience screams in ecstasy\n\nMetal, Metal\nBack with the vengeance\nMetal, Metal\nAll that I need is heavy metal\nMetal\nScreaming together\nMetal, Metal\nMetal is all that I need\n\nWhile hell bends for leather we stand strong, a rocker can party all night long\nthe school couldn't teach us rock' n roll, the school couldn't help us reach our goal\nWe live for the magic in the sound, distorted guitars are breaking ground\n\nThe powerful tunes, spectacular shows, the audience screams in ecstasy\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-8\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 1100000;\n\nusing namespace std;\n\nvector<vector<int> >cycles[N];\nint used[N];\nint ans[N];\nint p[N];\nvector<int> cycle;\nint n;\n\nvoid dfs(int v)\n{\n\tcycle.push_back(v);\n\tused[v] = 1;\n\tint to = p[v];\n\tif (used[to])\n\t\treturn;\n\tdfs(to);\n}\n\nvoid update(vector<int> v)\n{\n\tfor (int i = 0; i < v.size(); i++)\n\t{\n\t\tans[v[i]] = v[(i + 1) % v.size()];\n\t}\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\t//ios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d\", &p[i]);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (used[i])\n\t\t\tcontinue;\n\t\tcycle.clear();\n\t\tdfs(i);\n\t\tcycles[cycle.size()].push_back(cycle);\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i % 2 == 0 && cycles[i].size() % 2 == 1)\n\t\t{\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tused[i] = 0;\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i % 2 == 1)\n\t\t{\n\t\t\tfor (int j = 0; j < cycles[i].size(); j++)\n\t\t\t{\n\t\t\t\tvector<int> V;\n\t\t\t\tfor (int q = 0; q < i / 2; q++)\n\t\t\t\t{\n\t\t\t\t\tV.push_back(cycles[i][j][q]);\n\t\t\t\t\tV.push_back(cycles[i][j][(q+1) + i / 2]);\n\t\t\t\t}\n\t\t\t\tV.push_back(cycles[i][j][i / 2 ]);\n\t\t\t\tupdate(V);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int j = 0; j < cycles[i].size(); j += 2)\n\t\t\t{\n\t\t\t\tvector<int> V;\n\t\t\t\tfor (int q = 0; q < cycles[i][j].size(); q++)\n\t\t\t\t{\n\t\t\t\t\tV.push_back(cycles[i][j][q]);\n\t\t\t\t\tV.push_back(cycles[i][j + 1][q]);\n\t\t\t\t}\n\t\t\t\tupdate(V);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (i > 1)\n\t\t\tprintf(\" \");\n\t\tprintf(\"%d\", ans[i]);\n//\t\tcout << ans[i];\n\t}\n\tcout << endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Square Root of Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/22299",
    "editorial": "Consider some permutation . Let\u00e2\u0080\u0099s build by it the oriented graph with\r\nedges . Easy to see (and easy to prove) that this graph is the set of\r\ndisjoint cycles. Now let\u00e2\u0080\u0099s see what would be with that graph when the\r\npermutation will be multiplied by itself: all the cycles of odd length\r\nwould remain so (only the order of vertices will change, they will be\r\nalternated), but the cycles of even length will be split to the two\r\ncycles of the same length. So to get the square root from the\r\npermutation we should simply alternate (in reverse order) all cycles of\r\nthe odd length, and group all the cycles of the same even length to\r\npairs and merge cycles in each pair. If it\u00e2\u0080\u0099s impossible to group all\r\neven cycles to pairs then the answer doesn\u00e2\u0080\u0099t exist. Complexity: .\r\n"
}