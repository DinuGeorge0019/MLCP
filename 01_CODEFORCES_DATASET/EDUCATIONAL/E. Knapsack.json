{
    "link": "https://codeforces.com//contest/1132/problem/E",
    "problemId": "307699",
    "problem_idx": "E",
    "shortId": "1132E",
    "contest_number": "1132",
    "problem_submissions": {
        "E": [
            50850068,
            50849530,
            50845767,
            50845285,
            50999251,
            50998220,
            50984714,
            50983025,
            50849124,
            50834937,
            50849964,
            50853384,
            50853400,
            50852279,
            50851280,
            50853752,
            50855850,
            50853199,
            51446514,
            50851785,
            50834992,
            50854163,
            50845937
        ],
        "G": [
            50842167,
            50854823,
            50857129,
            50854920,
            50844161,
            50859138,
            57119782,
            50878894,
            51002265,
            50995547,
            50857246,
            50834458,
            50982974,
            50871478
        ],
        "F": [
            50840202,
            50838419,
            50836444,
            50982824,
            50982298,
            50914403,
            50914340,
            50845586,
            50832740,
            50838344,
            50839910,
            50835170,
            50841485,
            50845495,
            50850234,
            50846859,
            50849525,
            50847269,
            50833261,
            50843613,
            50842907,
            50837062,
            50843690,
            50848869
        ],
        "D": [
            50834165,
            50842583,
            50852105,
            50872042,
            50872030,
            50859910,
            50859897,
            50858488,
            50851238,
            50841187,
            50848482,
            50846027,
            50850423,
            50849233,
            50840756,
            50846142,
            50842178,
            50842159,
            50851492,
            50842299,
            50850678,
            50854836,
            50842129,
            50854102
        ],
        "C": [
            50827032,
            50833764,
            50832215,
            50839270,
            50881672,
            50828449,
            50836070,
            50832571,
            50831895,
            50835165,
            50830486,
            50829266,
            50832724,
            50834393,
            50838461,
            50842825,
            50830636,
            50837272,
            50843085,
            50842733,
            50838178
        ],
        "B": [
            50825116,
            50826216,
            50828719,
            50855444,
            50825477,
            50825790,
            50828172,
            50826213,
            50832189,
            50825110,
            50828347,
            50828834,
            50837439,
            50825450,
            50826572,
            50843916,
            50826867,
            50835237
        ],
        "A": [
            50824651,
            50824679,
            50826667,
            50855859,
            50824764,
            50824716,
            50825124,
            50824755,
            50829449,
            50824659,
            50826098,
            50836545,
            50824668,
            50824888,
            50845090,
            50825359,
            50834758
        ]
    },
    "name": "E. Knapsack",
    "statement": "You have a set of items, each having some integer weight not greater\r\nthan 8. You denote that a subset of items is good if total weight of\r\nitems in the subset does not exceed W.You want to calculate the maximum\r\npossible weight of a good subset of items. Note that you have to\r\nconsider the empty set and the original set when calculating the answer.\r\n",
    "solutions": [
        "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 840;\nconst int MANY = 1000 * 1000 + 7;\nconst ll C = 1e16;\n\nbitset<MANY> bs;\nll a[10];\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    bs[0] = 1;\n    ll w;\n    cin >> w;\n    ll fulls = 0;\n\n    ll sm = 0;\n    mt19937 rng(time(nullptr));\n\n    for (int i = 1; i <= 8; i++) {\n        cin >> a[i];\n//    a[i] = rng() % C;\n        sm += a[i] * i;\n        assert(840 % i == 0);\n        int gr = 840 / i;\n        ll cg = a[i] / gr;\n        cg = max(0ll, cg - 5);\n        fulls += cg;\n        a[i] -= cg * gr;\n        for (int j = 0; j < (int)a[i]; j++) {\n            bs |= (bs << i);\n        }\n    }\n    ll ans = 0;\n    for (int i = 0; i < MANY; i++) {\n        if (bs[i]) {\n            ll more = w - i;\n            if (more < 0) {\n                continue;\n            }\n            ll take = min(fulls, more / MX);\n            ans = max(ans, i + take * MX);\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "greedy"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Knapsack.json",
    "editorial_link": "https://codeforces.com/blog/entry/65752",
    "editorial": "Let\u00e2\u0080\u0099s consider the optimal answer. Suppose we take items of weight .Let\r\nbe the least common multiple of all weights (that is ). Then we may\r\nrepresent as , where . Let\u00e2\u0080\u0099s do the following trick: we will take items\r\nof weight , and all the remaining items of this weight can be merged\r\ninto some items of weight .Then we can write a brute force solution that\r\npicks less than items of each weight, transforms the remaining ones into\r\nitems of weight as much as possible, and when we fix the whole subset,\r\nadds maximum possible number of items of weight to the answer. This\r\nworks in something like operations, which is too much.How can we speed\r\nit up? Rewrite it using dynamic programming! When we have fixed the\r\nnumber of items we take from first sets, the only two things that matter\r\nnow are the current total weight of taken items and the number of items\r\nof weight we can use; and it\u00e2\u0080\u0099s obvious that the more items of weight we\r\ncan use, the better. So let\u00e2\u0080\u0099s write the following dynamic programming\r\nsolution: maximum number of items of weight we can have, if we processed\r\nfirst types of items, and current total weight is . Note that the second\r\ndimension should have size .\r\n"
}