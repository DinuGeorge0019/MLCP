{
    "link": "https://codeforces.com//contest/1845/problem/C",
    "problemId": "1986290",
    "problem_idx": "C",
    "shortId": "1845C",
    "contest_number": "1845",
    "problem_submissions": {
        "F": [
            211475859,
            211492939,
            211497555,
            211490825,
            211491595,
            211499186,
            211501170,
            211510297,
            211505215,
            211508507,
            211523706,
            211508142,
            211526813,
            211526845,
            211523227,
            211522513,
            211521610,
            211527973
        ],
        "E": [
            211462563,
            211461492,
            211471272,
            211472249,
            211480189,
            211485085,
            211477384,
            211480631,
            211479180,
            211479798,
            211487222,
            211476273,
            211646872,
            211490174,
            211488484,
            211525957,
            211524499,
            211523817,
            211482860,
            211491352,
            211488220,
            211483247,
            211483585,
            211488962,
            211482756,
            211497978
        ],
        "B": [
            211453598,
            211442082,
            211444910,
            211443511,
            211441772,
            211442686,
            211445493,
            211443115,
            211444001,
            211449977,
            211446525,
            211444666,
            211443749,
            211447761,
            211449897,
            211443106,
            211444760,
            211445575,
            211449630,
            211442921
        ],
        "D": [
            211450415,
            211448543,
            211458729,
            211462418,
            211460113,
            211454656,
            211463763,
            211469130,
            211470306,
            211471906,
            211459492,
            211645284,
            211472007,
            211475281,
            211467877,
            211468462,
            211468425,
            211461450,
            211463088,
            211470068,
            211462856
        ],
        "C": [
            211443935,
            211445016,
            211453965,
            211452711,
            211452512,
            211450213,
            211454682,
            211448771,
            211452473,
            211462596,
            211453195,
            211455269,
            211452431,
            211458111,
            211462223,
            211458912,
            211452900,
            211451834,
            211462935,
            211452522
        ],
        "A": [
            211441020,
            211441082,
            211441390,
            211441217,
            211441011,
            211441288,
            211441347,
            211441228,
            211442540,
            211441983,
            211441400,
            211441604,
            211441498,
            211442268,
            211443714,
            211441364,
            211441612,
            211441912,
            211442694,
            211441281
        ]
    },
    "name": "C. Strong Password",
    "statement": "Monocarp finally got the courage to register on ForceCoders. He came up\r\nwith a handle but is still thinking about the password.He wants his\r\npassword to be as strong as possible, so he came up with the following\r\ncriteria: the length of the password should be exactly m; the password\r\nshould only consist of digits from 0 to 9; the password should not\r\nappear in the password database (given as a string s) as a (not\r\nnecessarily contiguous). Monocarp also came up with two strings of\r\nlength m: l and r, both consisting only of digits from 0 to 9. He wants\r\nthe i-th digit of his password to be between l_i and r_i, inclusive.Does\r\nthere exist a password that fits all criteria?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int t;cin>>t;\n    while(t--)\n    {\n        string s;cin>>s;int n=s.size();\n        int m;cin>>m;\n        string l,r;cin>>l>>r;\n        int nxt[n+1][10];\n        for(int i=0;i<10;++i) nxt[n][i]=n;\n        for(int i=n-1;i>=0;--i)\n        {\n            for(int j=0;j<10;++j)\n            {\n                nxt[i][j]=nxt[i+1][j];\n                if(j==(s[i]-'0'))\n                {\n                    nxt[i][j]=i;\n                }\n            }\n        }\n        int ma=0;\n        for(int i=0;i<m;++i)\n        {\n            int ma1=0;\n            for(int j=l[i]-'0';j<=r[i]-'0';++j)\n            {\n                ma1=max(ma1,nxt[ma][j]+1);\n            }\n            ma=ma1;\n            if(ma1>n) break;\n        }\n        puts(ma>n ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "greedy",
        "strings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Strong Password.json",
    "editorial_link": "https://codeforces.com//blog/entry/117791",
    "editorial": "Consider the naive solution. You iterate over all password options that\r\nfit the criteria on and and check if they appear in as a\r\nsubsequence.That check can be performed greedily: find the first\r\noccurrence of the first digit of the password, then find the first\r\noccurrence after it of the second digit of the password, and so on. If\r\nall digits are found, then itâs present. Otherwise, it isnât.Notice how\r\nthe checks from the -th digit onwards only depend on the position of the\r\n-st digit. Moreover, to have a lower probability to find these digits,\r\nwe want the -st digit to be as much to the right as possible.That leads\r\nus to the greedy solution to the full problem. Iterate over the first\r\ndigit and choose the one that appears as much to the right as possible.\r\nThen the same for the second digit, and so on. If any digit is not found\r\nin the string after the starting position of the check, then the\r\npassword that starts with the chosen digits is strong.So far, the\r\nsolution sounds like , where is the number of digits (equal to ). Which\r\nis actually fine under these constraints, but we can do better.One\r\noption is to precalculate something to help us find the next occurrence\r\nof each digit. For example, that can be an array of positions of each\r\ndigit. Then we can use lower_bound on it to find the next one. That\r\nwould be .Alternatively, you can calculate an array that stores the next\r\noccurrence of digit from position . Itâs possible to calculate from .\r\nNotice that only changes. So you can copy into and set . Now you can\r\njust query the array by looking into the corresponding cells. That would\r\nbe .Finally, letâs analyze the complexity of the linear search better.\r\nSo, for each digit, actually run a loop that searches the string until\r\nit encounters that letter. We proposed that it is . Notice that if some\r\niteration of the loop for the -th digit passes a position , then the\r\ndigits from the -st onwards wonât look into it. So, such position can\r\nonly be checked in loops (all loops for the current digit). Thus, each\r\nof positions can only be accessed times, making the solution , which\r\nmakes it the fastest of all our options. That is basically the same\r\nanalysis as two pointers. comes from the outer loop over digits that you\r\ncanât really get rid of. However, you can say that ( can be solved in ),\r\nand call the solution .Overall complexity: for each testcase.\r\n",
    "hint": []
}