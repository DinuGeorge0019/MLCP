{
    "link": "https://codeforces.com//contest/1452/problem/C",
    "problemId": "802106",
    "problem_idx": "C",
    "shortId": "1452C",
    "contest_number": "1452",
    "problem_submissions": {
        "F": [
            98942480,
            98939437,
            98940434,
            106494164,
            106494140,
            98942341,
            98945383,
            98935697,
            98927001,
            98944945,
            98934044,
            98976764,
            99270253
        ],
        "E": [
            98926708,
            98926305,
            98923150,
            98930994,
            98926114,
            98927253,
            98926662,
            99001021,
            98943947,
            99042260,
            98926234,
            98930834,
            98943700,
            98921374,
            98925742,
            98930269,
            98929950,
            98918489,
            98928745,
            98929548
        ],
        "D": [
            98906301,
            98909937,
            98915472,
            98909763,
            98919427,
            98912085,
            99000804,
            98903628,
            98909739,
            98911723,
            98911927,
            98913556,
            98901042,
            98908884,
            98907045,
            98910263,
            98910231,
            98913804,
            98909129
        ],
        "C": [
            98899318,
            98901635,
            98905651,
            98903381,
            98906519,
            98900085,
            98896987,
            98906559,
            98901684,
            98905788,
            98906611,
            98898047,
            98901391,
            98899348,
            98900377,
            98902439,
            98902965,
            98898261
        ],
        "B": [
            98897777,
            98898220,
            98901029,
            98900303,
            98904013,
            98898005,
            99000726,
            99000688,
            98978607,
            98898951,
            98904401,
            98905057,
            98908639,
            98904166,
            98896699,
            98898174,
            98897853,
            98902989,
            98899546,
            98900510,
            98903751
        ],
        "A": [
            98895449,
            98895686,
            98896660,
            98896462,
            98897246,
            98895467,
            98895360,
            98896351,
            100779606,
            98895507,
            98904547,
            98896942,
            98895363,
            98895604,
            98895575,
            98895460,
            98903659,
            98895637,
            98896531
        ],
        "G": [
            99251139,
            98943421,
            99550385,
            99358496,
            99358463,
            99358399,
            99296629,
            99296419,
            99053359,
            99052180,
            98944458,
            98945555,
            99287849
        ]
    },
    "name": "C. Two Brackets",
    "statement": "You are given a string s, consisting of brackets of two types: ”, ”, ”\r\nand ”.A string is called a regular bracket sequence (RBS) if it’s of one\r\nof the following types: empty string; ” + RBS + ”; ” + RBS + ”; RBS +\r\nRBS. where plus is a concatenation of two strings.In one move you can\r\nchoose a non-empty subsequence of the string s (not necessarily\r\nconsecutive) that is an RBS, remove it from the string and concatenate\r\nthe remaining parts without changing the order.What is the maximum\r\nnumber of moves you can perform?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nchar A[202020];\n\nint main() {\n\tint tc; scanf(\"%d\", &tc);\n\twhile(tc--) {\n\t\tscanf(\"%s\", A + 1);\n\t\tN = strlen(A + 1);\n\t\tint a = 0, b = 0;\n\t\tint ans = 0;\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tif(A[i] == '(') a++;\n\t\t\telse if(A[i] == '[') b++;\n\t\t\telse if(A[i] == ')') {\n\t\t\t\tif(a > 0) { a--; ans++; }\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(b > 0) { b--; ans++; }\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Two Brackets.json",
    "editorial_link": "https://codeforces.com//blog/entry/84847",
    "editorial": "Notice that itâs never optimal to erase a subsequence of length greater\r\nthan because every RBS of length above contains an RBS of length inside\r\nand removing it wonât break the regular property of the outside one.So\r\nthe task can be solved for the round and the square brackets\r\nindependently, the answer will be the sum of both. Letâs solve the\r\nversion for brackets â and â. In general, you just want to remove\r\nconsecutive substring \"\" until there is no more left in the string. That\r\ncan be done by processing the string from left and right and maintaining\r\na stack of current brackets. If the top bracket in it is â and the\r\ncurrent bracket is â, then you can increment the answer and remove that\r\nbracket from the stack. Otherwise, you push the current bracket to the\r\nstack.Overall complexity: per testcase.\r\n",
    "hint": []
}