{"link": "https://codeforces.com//contest/598/problem/D", "problemId": "40732", "problem_idx": "D", "shortId": "598D", "contest_number": "598", "problem_submissions": {"C": [14258282, 14258243, 14230694, 14231202, 14231643, 14230605, 14232276, 14232531, 14233681, 14236053, 14234393, 14237043, 14234521, 14238674, 14254495], "E": [14232918, 14233759, 14233061, 14234500, 14235984, 14231617, 14235791, 14234781, 14237980, 27723122, 14234802, 14238606, 14238276, 14230968, 14231346, 14231257, 14229755, 14231535, 14232059], "D": [14231500, 14232200, 14231256, 14232148, 14233968, 14233300, 14231514, 14231409, 14235674, 14233048, 14236255, 14231336, 14229735, 14229704, 14230486, 14231024, 14230489, 14230566], "B": [14228934, 14229369, 14229229, 14229653, 14229332, 14229739, 14232154, 14232624, 14229585, 14231038, 14232631, 14229469, 14229277, 14228902, 14228794, 14230341, 14229075, 14229130], "A": [14228503, 14228566, 14228506, 14229062, 14228523, 14229086, 14229170, 14228699, 14228571, 14228539, 14228982, 14228489, 14228480, 14228476, 14228530, 14228507, 14228550], "F": [59190852, 14260771]}, "name": "D. Igor In the Museum", "statement": "Igor is in the museum and he wants to see as many pictures as\r\npossible.Museum can be represented as a rectangular field of cells. Each\r\ncell is either empty or impassable. Empty cells are marked with \u201d,\r\nimpassable cells are marked with \u201d. Every two adjacent cells of\r\ndifferent types (one empty and one impassable) are divided by a wall\r\ncontaining one picture.At the beginning Igor is in some empty cell. At\r\nevery moment he can move to any empty cell that share a side with the\r\ncurrent one.For several starting positions you should calculate the\r\nmaximum number of pictures that Igor can see. Igor is able to see the\r\npicture only if he is in the cell adjacent to the wall with this\r\npicture. Igor have a lot of time, so he will examine every picture he\r\ncan see.\r\n", "solutions": ["//ITNOA\n#include<bits/stdc++.h> \n\nusing namespace std;\n \n\n#define scan(x) do{while((x=getchar())<'0'); for(x-='0'; '0'<=(_=getchar()); x=(x<<3)+(x<<1)+_-'0');}while(0)\nchar _;\n\n#define int long long\n#define rep(i, s, e) for(int i = s; i < e; i ++)\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxN = 1000 + 5;\nconst int mod = 1000*1000*1000 + 7;\nconst int base = 701;\nconst int SQ = 600;\nconst int maxL = 302;\n\nchar a[maxN][maxN];\nbool mark[maxN][maxN];\nint col[maxN][maxN];\nint dx[] = {-1,1,0,0};\nint dy[] = {0,0,-1,1};\nint n,m;\n\nint ted[maxN*maxN];\n\nbool is_ok(int x, int y)\n{\n    if(x < 0 || y < 0 || n <= x || m <= y) return false;\n    return true;\n}\n\nvoid dfs(int x, int y, int c)\n{\n    mark[x][y] = 1; col[x][y] = c;\n    rep(i,0,4)\n    {\n\tint v = x + dx[i], u = y + dy[i];\n\tif(is_ok(v,u) && mark[v][u] == 0 && a[v][u] == '.')\n\t    dfs(v,u,c);\n    }    \n}\n\n\nint32_t main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    int q; cin >> n >> m >> q;\n    rep(i,0,n) rep(j,0,m)\n\tcin >> a[i][j];\n\n    int cnt = 0;\n    rep(i,1,n-1) rep(j,1,m-1)\n    {\n\tif(mark[i][j] == 0 && a[i][j] == '.')\n\t    dfs(i,j,cnt++);\n    }\n\n    rep(i,1,n-1) rep(j,1,m-1)\n\tif(a[i][j] == '.')\n\t{\n\t    rep(k,0,4)\n\t    {\n\t\tint v = i + dx[k], u = j + dy[k];\n\t\tif(is_ok(v,u) && a[v][u] == '*')\n\t\t    ted[col[i][j]] ++;\n\t    }\n\t\t\n\t}\n\n    rep(i,0,q)\n    {\n\tint x, y; cin >> x >> y; x --; y --;\n\tcout << ted[col[x][y]] << endl;\n    }\n    return 0;    \n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "shortest paths"], "dificulty": "1700", "interactive": false}