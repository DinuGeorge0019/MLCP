{
    "link": "https://codeforces.com//contest/846/problem/B",
    "problemId": "120998",
    "problem_idx": "B",
    "shortId": "846B",
    "contest_number": "846",
    "problem_submissions": {
        "F": [
            30108156,
            30107162,
            30106647,
            30108328,
            30107786,
            30107476,
            30108023,
            30105549,
            30105678,
            30108397,
            30109633,
            30109280,
            30109385,
            30107975,
            30110238,
            30108732,
            30108760,
            30110164
        ],
        "E": [
            30107342,
            30108640,
            30109160,
            30110715,
            30110194,
            30109970,
            30108774,
            30110412,
            30109505,
            30110880,
            30108739,
            30110755,
            30111630,
            30111870,
            30111911,
            30111723,
            30113425,
            30111880
        ],
        "D": [
            30105892,
            30106073,
            30106673,
            30106266,
            30106933,
            30108722,
            30106872,
            30105786,
            30108926,
            30106473,
            30106803,
            30107029,
            30107512,
            30108104,
            30109714,
            30108207,
            30110001,
            30111074,
            30108770
        ],
        "C": [
            30105238,
            30104755,
            30105662,
            30105293,
            30106309,
            30106223,
            30104825,
            30107791,
            30105043,
            30105080,
            30106115,
            30105906,
            30106686,
            30106808,
            30107246,
            30107701,
            30107036,
            30107208
        ],
        "B": [
            30103719,
            30103777,
            30104242,
            30103580,
            30104340,
            30105094,
            30103843,
            30104470,
            30103928,
            30103957,
            30104536,
            30104441,
            30104836,
            30104758,
            30104309,
            30105851,
            30104847,
            30105774
        ],
        "A": [
            30103161,
            30103232,
            30103250,
            30103170,
            30103456,
            30103369,
            30103168,
            30103235,
            30103196,
            30103253,
            30103176,
            30103313,
            30103584,
            30103300,
            30103249,
            30104174,
            30103638,
            30104542
        ]
    },
    "name": "B. Math Show",
    "statement": "Polycarp takes part in a math show. He is given tasks, each consists of\r\nsubtasks, numbered through . It takes him minutes to solve the -th\r\nsubtask of any task. Thus, time required to solve a subtask depends only\r\non its index, but not on the task itself. Polycarp can solve subtasks in\r\nany order.By solving subtask of arbitrary problem he earns one point.\r\nThus, the number of points for task is equal to the number of solved\r\nsubtasks in it. Moreover, if Polycarp solves the task (solves all of its\r\nsubtasks), he recieves one extra point. Thus, total number of points he\r\nrecieves for the complete solution of the task is .Polycarp has minutes\r\nof time. What is the maximum number of points he can earn?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define N 55\nconst LL inf = 10000000000000000LL;\nLL n , k , M , dp[ N * N ] , t[ N ];\nint main(){\n  cin >> n >> k >> M;\n  for( int i = 0 ; i < k ; i ++ )\n    cin >> t[ i ];\n  sort( t , t + k );\n  for( int i = 1 ; i < k ; i ++ )\n    t[ i ] += t[ i - 1 ];\n  for( int i = 1 ; i <= n * ( k + 1 ) ; i ++ )\n    dp[ i ] = inf;\n  for( int _ = 0 ; _ < n ; _ ++ ){\n    for( int i = n * ( k + 1 ) ; i >= 0 ; i -- ){\n      if( dp[ i ] == inf ) continue;\n      for( int solved = 1 ; solved <= k ; solved ++ ){\n        LL tdp = dp[ i ] + t[ solved - 1 ];\n        int ii = i + solved + (solved == k);\n        dp[ ii ] = min( dp[ ii ] , tdp );\n      }\n    }\n  }\n  int ans = 0;\n  for( int i = 1 ; i <= n * ( k + 1 ) ; i ++ )\n    if( dp[ i ] <= M )\n      ans = i;\n  cout << ans << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Math Show.json",
    "editorial_link": "https://codeforces.com//blog/entry/54357",
    "editorial": "Constraints tell us that we can avoid making any weird assumptions for\r\nany greedy solutions. You can easily count the answer for some fixed\r\namount of tasks completed. Just sort all left subtasks (but the longest\r\nto solve in each uncompleted task) and take the easiest till the time is\r\nover. Now you can iterate from to tasks completed and take maximum over\r\nall options.Overall complexity: .\r\n",
    "hint": []
}