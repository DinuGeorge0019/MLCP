{
    "link": "https://codeforces.com//contest/1463/problem/E",
    "problemId": "836005",
    "problem_idx": "E",
    "shortId": "1463E",
    "contest_number": "1463",
    "problem_submissions": {
        "F": [
            101559554,
            101581978,
            101567286,
            101577708,
            101580696,
            101680102,
            101680098,
            101605801,
            101605564,
            101602968,
            101602931,
            101594909,
            101594099,
            102434679,
            101661639,
            101713126,
            101711433,
            101812801
        ],
        "E": [
            101543691,
            101541624,
            101550722,
            101542275,
            101561956,
            101542640,
            101551028,
            101551947,
            101553418,
            101552115,
            101553474,
            101556641,
            101557969,
            101556648,
            101554530,
            101557890,
            101556692,
            101561428,
            101553035
        ],
        "D": [
            101533227,
            101528710,
            101537667,
            101530458,
            101531312,
            101543635,
            101536909,
            101536759,
            101540131,
            101537456,
            101542046,
            101537094,
            101540598,
            101539288,
            101544433,
            101525965,
            101526650,
            101536306,
            101544222
        ],
        "C": [
            101526320,
            101520150,
            101529141,
            101525986,
            101523000,
            101525367,
            101530714,
            101526273,
            102544695,
            101524853,
            101531194,
            101530250,
            101529215,
            101530504,
            101529471,
            101533604,
            101540078,
            101541782,
            101523573,
            101536896
        ],
        "B": [
            101518923,
            101515147,
            101518366,
            101516293,
            101513263,
            101522496,
            101520454,
            101515435,
            101517061,
            101515098,
            101516483,
            101522667,
            101516542,
            101515577,
            101515224,
            101517780,
            101517682,
            101515176,
            101521789
        ],
        "A": [
            101515277,
            101512560,
            101513602,
            101512825,
            101512593,
            101512667,
            101513802,
            101512900,
            101514221,
            101512986,
            101513229,
            101513515,
            101512759,
            101512530,
            101512877,
            101514648,
            101514992,
            101512816,
            101514556
        ]
    },
    "name": "E. Plan of Lectures",
    "statement": "Ivan is a programming teacher. During the academic year, he plans to\r\ngive n lectures on n different topics. Each topic should be used in\r\nexactly one lecture. Ivan wants to choose which topic will he explain\r\nduring the 1-st, 2-nd, ..., n-th lecture formally, he wants to choose\r\nsome permutation of integers from 1 to n (let’s call this permutation\r\nq). q_i is the index of the topic Ivan will explain during the i-th\r\nlecture.For each topic (except ), there exists a prerequisite topic (for\r\nthe topic i, the prerequisite topic is p_i). Ivan cannot give a lecture\r\non a topic before giving a lecture on its prerequisite topic. There\r\nexists at least one valid ordering of topics according to these\r\nprerequisite constraints.Ordering the topics correctly can help students\r\nunderstand the lectures better. Ivan has k special pairs of topics (x_i,\r\ny_i) such that he knows that the students will understand the y_i-th\r\ntopic better if the lecture on it is conducted the lecture on the x_i-th\r\ntopic. Ivan wants to satisfy the constraints on every such pair, that\r\nis, for every i\r\nin [1, k], there should exist some j\r\nin [1, n - 1] such that q_j = x_i and q_{j + 1} = y_i.Now Ivan wants to\r\nknow if there exists an ordering of topics that satisfies all these\r\nconstraints, and if at least one exists, find any of them.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target (\"sse4\")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\nstruct graph {\nprivate:\n\tint n;\n\tvector<vector<int>> G, rG;\n\tvector<bool> used;\n\tvector<int> vs;\n\n\tint mk;\n\tvector<vector<int>> fG;\n\tvector<vector<int>> ori;\n\tvector<int> trans;\npublic:\n\tgraph(int sz) {\n\t\tn = sz;\n\t\tG.resize(n);\n\t\trG.resize(n);\n\t\tused.resize(n);\n\n\t\tfG.resize(n);\n\t\ttrans.resize(n, -1);\n\t\tori.resize(n);\n\t}\n\tvoid add_edge(int a, int b) {\n\t\tG[a].push_back(b);\n\t\trG[b].push_back(a);\n\t}\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\trep(i, G[v].size()) {\n\t\t\tif (!used[G[v][i]])dfs(G[v][i]);\n\t\t}\n\t\tvs.push_back(v);\n\t}\n\tvoid rdfs(int v, int k) {\n\t\tused[v] = true;\n\t\tqueue<int> q; q.push(v);\n\t\tvector<int> c;\n\t\twhile (!q.empty()) {\n\t\t\tint id = q.front(); q.pop();\n\t\t\tori[k].push_back(id);\n\t\t\trep(j, rG[id].size()) {\n\t\t\t\tint to = rG[id][j];\n\t\t\t\tif (used[to]) {\n\t\t\t\t\tif (trans[to] >= 0)c.push_back(trans[to]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tused[to] = true; q.push(to);\n\t\t\t}\n\t\t}\n\t\tsort(c.begin(), c.end());\n\t\tint len = unique(c.begin(), c.end()) - c.begin();\n\t\trep(i, len) {\n\t\t\tfG[c[i]].push_back(k);\n\t\t}\n\t\trep(i, ori[k].size()) {\n\t\t\ttrans[ori[k][i]] = k;\n\t\t}\n\t}\n\tvoid scc() {\n\t\tfill(used.begin(), used.end(), false);\n\t\trep(i, n) {\n\t\t\tif (!used[i])dfs(i);\n\t\t}\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tper(i, (int)vs.size()) {\n\t\t\tif (!used[vs[i]]) {\n\t\t\t\trdfs(vs[i], k); k++;\n\t\t\t}\n\t\t}\n\t\tmk = k;\n\t}\n\tvector<int> query() {\n\t\trep(i, mk)if (ori[i].size() > 1)return {};\n\t\tvector<int> res;\n\t\trep(i, mk)res.push_back(ori[i][0]);\n\t\treturn res;\n\t}\n};\n\nvoid solve() {\n\tint n, k; cin >> n >> k;\n\tvector<int> p(n);\n\trep(i, n) {\n\t\tcin >> p[i]; p[i]--;\n\t}\n\tvector<P> memo;\n\tvector<int> pre(n, -1);\n\tvector<int> nex(n, -1);\n\trep(i, k) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tpre[b] = a;\n\t\tnex[a] = b;\n\t\tmemo.push_back({ a,b });\n\t}\n\tuf u(n);\n\trep(i, k) {\n\t\tif (u.same(memo[i].first, memo[i].second)) {\n\t\t\tcout << 0 << \"\\n\"; return;\n\t\t}\n\t\tu.unite(memo[i].first, memo[i].second);\n\t}\n\tgraph c(n);\n\trep(i, n) {\n\t\tif (p[i] >= 0)c.add_edge(p[i], i);\n\t}\n\trep(i, k) {\n\t\tc.add_edge(memo[i].first, memo[i].second);\n\t}\n\tc.scc();\n\tvector<int> cc = c.query();\n\tif (cc.empty()) {\n\t\tcout << 0 << \"\\n\"; return;\n\t}\n\tgraph g(n);\n\trep(i, n) {\n\t\tif (p[i] >= 0) {\n\t\t\tint fr = u.find(p[i]);\n\t\t\tint sc = u.find(i);\n\t\t\tg.add_edge(fr, sc);\n\t\t}\n\t}\n\tg.scc();\n\tvector<int> ord = g.query();\n\tif (ord.empty()) {\n\t\tcout << 0 << \"\\n\"; return;\n\t}\n\tvector<int> ans;\n\tvector<vector<int>> ids(n);\n\trep(i, n)ids[u.find(i)].push_back(i);\n\tfor (int id : ord) {\n\t\tif (ids[id].empty())continue;\n\t\tint sta = -1;\n\t\tfor (int v : ids[id])if (pre[v] < 0)sta = v;\n\t\twhile (sta>=0) {\n\t\t\tans.push_back(sta);\n\t\t\tsta = nex[sta];\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (i > 0)cout << \" \";\n\t\tcout << ans[i] + 1;\n\t}\n\tcout << \"\\n\";\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "dsu",
        "graphs",
        "implementation",
        "sortings",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Plan of Lectures.json",
    "editorial_link": "https://codeforces.com//blog/entry/85707",
    "editorial": "The prerequisites for each lecture form a rooted tree, so letâs forget\r\nabout the legend and learn how to find such an order of vertices of a\r\ntree that all conditions work.Letâs introduce some algorithm that\r\nproduces an ordering of vertices for every possible case. If any valid\r\nordering exists, it should produce a valid one. So we will only have to\r\ncheck if the resulting ordering is fine and output it if it is.If there\r\nwere no special pairs, the task would be perfectly solvable with an\r\nalgorithm of topological sorting. Thus, letâs come up with a way to\r\nmodify the graph, so that topsort could still be a solution.We know that\r\nthe vertices that are in the special pairs should follow each other in\r\nthe ordering. Look at these special pairs as edges as well. Letâs first\r\nimagine they are undirected. These edges connect some vertices in the\r\ntree into components. Each component should be a segment of vertices in\r\na valid answer. So how about we compress them into one vertex first\r\neach, find some answer for a compressed version and decompress them\r\nback?Let each of these connected components be a vertex in the new\r\ngraph. Two components are connected by an edge if there is a edge in the\r\ntree between vertices of the corresponding components. Topsort in this\r\ngraph will tell us the order the components should go.However, we should\r\nalso find the order the vertices should go inside each component. Letâs\r\ntopsort the graph of all directed special pairs and sort the vertices in\r\nthat order in every component. We can sort the entire graph instead of\r\nsorting each component separately because the components are totally\r\nindependent. Finally, write down the answer: iterate over the compressed\r\nvertices of the first new graph in the order of its topsort, for each\r\none write down all the actual vertices inside it in the order of the\r\ntopsort of the second new graph. Check if each vertex has its parent\r\nearlier than itself in the answer. If all the graphs were topologically\r\nsortable and that holds, then the answer exists, and we found it.\r\nOtherwise, the answer doesnât exist.Overall complexity: .\r\n",
    "hint": []
}