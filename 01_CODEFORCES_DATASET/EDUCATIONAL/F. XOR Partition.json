{
    "link": "https://codeforces.com//contest/1849/problem/F",
    "problemId": "2121803",
    "problem_idx": "F",
    "shortId": "1849F",
    "contest_number": "1849",
    "problem_submissions": {
        "F": [
            215983324,
            215952856,
            215937825,
            216386632,
            215955686,
            215953676,
            215963177,
            215957010,
            215951070,
            215964780,
            216982954,
            215957194,
            215972632,
            215944919,
            215944313,
            215955103,
            215959952,
            215969003,
            215980309,
            215974158,
            215944399,
            215979671,
            215977278
        ],
        "E": [
            215924453,
            215947662,
            216386610,
            215933511,
            215933733,
            215934077,
            215914493,
            215965756,
            215977352,
            215941711,
            233941264,
            215936437,
            215935391,
            215977463,
            215969180,
            215945577,
            215912738,
            215939893,
            215950899,
            215934318,
            215964596,
            215959218,
            215957991,
            215955934
        ],
        "D": [
            215901738,
            215911695,
            216386594,
            215909113,
            215918034,
            215916358,
            215933169,
            215909241,
            215922975,
            234220985,
            215915496,
            215918649,
            215921028,
            215919624,
            215925910,
            215965913,
            215944986,
            215923778,
            215918733,
            215917075,
            215927258,
            215909167,
            215930917
        ],
        "C": [
            215896251,
            215894479,
            216386570,
            215900243,
            215896179,
            215907225,
            215897874,
            215899171,
            215913186,
            216103314,
            215910665,
            215904112,
            215906218,
            215893558,
            215913416,
            215898003,
            215913451,
            215905641,
            215906717,
            215916261,
            215893733,
            215907522
        ],
        "B": [
            215891011,
            215887978,
            215890857,
            215886817,
            215889862,
            215890551,
            215889747,
            215890405,
            216103286,
            215904981,
            215895899,
            215891636,
            215886438,
            215894588,
            215888040,
            215888730,
            215892001,
            215891534,
            215895784,
            215887055,
            215895512
        ],
        "A": [
            215887103,
            215884849,
            215885125,
            215884783,
            215885307,
            215885029,
            215884781,
            215885053,
            216103329,
            215902406,
            215889192,
            215885764,
            215884723,
            215885605,
            215884732,
            215884795,
            215885200,
            215885812,
            215885953,
            215884704,
            215884853
        ]
    },
    "name": "F. XOR Partition",
    "statement": "For a set of integers S, let’s define its cost as the minimum value of x\r\noplus y among all pairs of integers from the set (here,\r\noplus denotes bitwise XOR). If there are less than two elements in the\r\nset, its cost is equal to 2^{30}.You are given a set of integers\r\n{a_1, a_2,\r\ndots, a_n\r\n}. You have to partition it into two sets S_1 and S_2 in such a way that\r\nevery element of the given set belongs to exactly one of these two sets.\r\nThe value of the partition is the among the costs of S_1 and S_2.Find\r\nthe partition with the possible value.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n    \n    int find(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return siz[find(x)];\n    }\n};\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<std::pair<int, int>> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i].first;\n        a[i].second = i;\n    }\n    std::sort(a.begin(), a.end());\n    \n    std::vector<std::array<int, 3>> edges;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n && j <= i + 3; j++) {\n            edges.push_back({a[i].first ^ a[j].first, a[i].second, a[j].second});\n        }\n    }\n    std::sort(edges.begin(), edges.end());\n    \n    DSU dsu(n);\n    std::vector<std::vector<int>> adj(n);\n    for (auto [_, i, j] : edges) {\n        if (dsu.merge(i, j)) {\n            adj[i].push_back(j);\n            adj[j].push_back(i);\n        }\n    }\n    \n    std::vector<int> ans(n);\n    auto dfs = [&](auto self, int x, int p) -> void {\n        for (auto y : adj[x]) {\n            if (y == p) {\n                continue;\n            }\n            ans[y] = ans[x] ^ 1;\n            self(self, y, x);\n        }\n    };\n    dfs(dfs, 0, -1);\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i];\n    }\n    std::cout << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "data structures",
        "divide and conquer",
        "greedy",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. XOR Partition.json",
    "editorial_link": "https://codeforces.com//blog/entry/118752",
    "editorial": "the model solution to this problem is a bit more complicated than most\r\nof the solutions written by participants, but I will still use it for\r\nthe editorial so that I can explain some of the classical techniques\r\nappearing in it.Suppose we have built a graph on vertices, where each\r\npair of vertices is connected by an edge, and the weight of the edge\r\nconnecting with is . If we treat the partition of the set as a coloring\r\nof this graph, then the cost of the partition is equal to the minimum\r\nweight of an edge connecting two vertices of the same color. So, suppose\r\nwe want to check that the answer is at least . It means that every edge\r\nwith weight less than should connect two vertices of different colors;\r\nso, the graph where we erase all edges with weight greater than or equal\r\nto should be bipartite. This allows us to write a binary search solution\r\nif we somehow understand how to construct the graph and check that it is\r\nbipartite implicitly, but this is not the way the model solution\r\ngoes.Instead, suppose we do the following greedy. Initially, let the\r\ngraph be empty. Then, we add all edges with weight , and check if it is\r\nbipartite. Then, we add all edges with weight , and check if it is\r\nbipartite. And so on, until the graph is no longer bipartite.Of course,\r\nthere are edges, so this is too slow. But in fact, we donât need all the\r\nedges for this graph. Some of the edges we added didnât really affect\r\nthe coloring of the graph: if, in this process, we add an edge which\r\nconnects two vertices from the same component, one of the following two\r\nthings happens: if it connects two vertices of the same color, then the\r\ngraph is no longer bipartite; otherwise, this edge actually does not\r\nchange anything in the coloring. Now, suppose we stop before making the\r\ngraph non-bipartite. It means if an edge we added was connecting two\r\nvertices from the same component, that edge was actually redundant.Letâs\r\ntake a look again at what weâre actually doing. Initially, the graph is\r\nempty. Then, we consider all possible edges in ascending order of their\r\nweights; if an edge connects two vertices in different components, it\r\nshould be added to the graph (and it affects the coloring), otherwise,\r\nit does not matter (unless it makes us stop the algorithm, since the\r\ngraph is no longer bipartite). Doesnât it sound familiar? Yup, it is\r\nalmost like Kruskalâs algorithm.And in fact, the problem can be solved\r\nas follows: build any MST of this graph, and use it to form the\r\ntwo-coloring (paint the vertices in such a way that every edge from MST\r\nconnects two vertices of different colors). The paragraph below contains\r\nthe formal proof that this coloring is optimal; feel free to skip it if\r\nyouâre not interested in the strict proof.Okay, now we have to actually\r\nbuild the MST in this graph. XOR-MST is a fairly classical problem (it\r\nwas even used in one of the previous Educational Rounds several years\r\nago). I know two different solutions to it: the one based on Boruvkaâs\r\nalgorithm and the D&C + trie merging method. I will describe the former\r\none.The classical Boruvkaâs algorithm is one of the algorithms of\r\nfinding a minimum spanning tree. It begins with a graph containing no\r\nedges, and performs several iterations until it becomes connected. On\r\neach iteration, the algorithm considers each component of the graph and\r\nadds the minimum edge connecting any vertex from this component with any\r\nvertex outside this component (these edges are added at the same time\r\nfor all components of the graph, so be careful about creating a cycle or\r\nadding the same edge twice; different methods can be used to prevent\r\nthis in the model solution, I memorize the edges I want to add on each\r\niteration, then use a DSU to actually check which ones should be added\r\nwithout causing a cycle to appear).During each iteration of the\r\nalgorithm, the number of components decreases to at least half of the\r\noriginal number, so the algorithm works in , where is the complexity of\r\none iteration. Usually, is since we need to consider each edge of the\r\ngraph twice; but in this problem, we can perform one iteration of\r\nBoruvkaâs algorithm much faster, in , where is the constraint on the\r\nnumbers in the input.It can be done as follows: maintain a trie data\r\nstructure which stores all values of and allows processing a query\r\n\"given an integer , find the value in the data structure such that is\r\nthe minimum possible\" (this can be done with a trie descent). When we\r\nconsider a component and try to find the minimum edge leading outside of\r\nit, we first delete all vertices belonging to this component from the\r\ndata structure; then, for each vertex from the component, find the best\r\nvertex in the data structure; and then, insert all vertices back. That\r\nway, a component of size will be processed in , and the total time for\r\none iteration is .All of this results in a solution with complexity .\r\n",
    "hint": []
}