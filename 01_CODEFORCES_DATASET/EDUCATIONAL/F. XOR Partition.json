{"link": "https://codeforces.com//contest/1849/problem/F", "problemId": "2121803", "problem_idx": "F", "shortId": "1849F", "contest_number": "1849", "problem_submissions": {"F": [215983324, 215952856, 215937825, 216386632, 215955686, 215953676, 215963177, 215957010, 215951070, 215964780, 216982954, 215957194, 215972632, 215944919, 215944313, 215955103, 215959952, 215969003, 215980309, 215974158, 215944399, 215979671, 215977278], "E": [215924453, 215947662, 216386610, 215933511, 215933733, 215934077, 215914493, 215965756, 215977352, 215941711, 233941264, 215936437, 215935391, 215977463, 215969180, 215945577, 215912738, 215939893, 215950899, 215934318, 215964596, 215959218, 215957991, 215955934], "D": [215901738, 215911695, 216386594, 215909113, 215918034, 215916358, 215933169, 215909241, 215922975, 234220985, 215915496, 215918649, 215921028, 215919624, 215925910, 215965913, 215944986, 215923778, 215918733, 215917075, 215927258, 215909167, 215930917], "C": [215896251, 215894479, 216386570, 215900243, 215896179, 215907225, 215897874, 215899171, 215913186, 216103314, 215910665, 215904112, 215906218, 215893558, 215913416, 215898003, 215913451, 215905641, 215906717, 215916261, 215893733, 215907522], "B": [215891011, 215887978, 215890857, 215886817, 215889862, 215890551, 215889747, 215890405, 216103286, 215904981, 215895899, 215891636, 215886438, 215894588, 215888040, 215888730, 215892001, 215891534, 215895784, 215887055, 215895512], "A": [215887103, 215884849, 215885125, 215884783, 215885307, 215885029, 215884781, 215885053, 216103329, 215902406, 215889192, 215885764, 215884723, 215885605, 215884732, 215884795, 215885200, 215885812, 215885953, 215884704, 215884853]}, "name": "F. XOR Partition", "statement": "For a set of integers S, let\u2019s define its cost as the minimum value of x\r\noplus y among all pairs of integers from the set (here,\r\noplus denotes bitwise XOR). If there are less than two elements in the\r\nset, its cost is equal to 2^{30}.You are given a set of integers\r\n{a_1, a_2,\r\ndots, a_n\r\n}. You have to partition it into two sets S_1 and S_2 in such a way that\r\nevery element of the given set belongs to exactly one of these two sets.\r\nThe value of the partition is the among the costs of S_1 and S_2.Find\r\nthe partition with the possible value.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\nstruct DSU {\n    std::vector<int> f, siz;\n    \n    DSU() {}\n    DSU(int n) {\n        init(n);\n    }\n    \n    void init(int n) {\n        f.resize(n);\n        std::iota(f.begin(), f.end(), 0);\n        siz.assign(n, 1);\n    }\n    \n    int find(int x) {\n        while (x != f[x]) {\n            x = f[x] = f[f[x]];\n        }\n        return x;\n    }\n    \n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) {\n            return false;\n        }\n        siz[x] += siz[y];\n        f[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return siz[find(x)];\n    }\n};\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<std::pair<int, int>> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i].first;\n        a[i].second = i;\n    }\n    std::sort(a.begin(), a.end());\n    \n    std::vector<std::array<int, 3>> edges;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n && j <= i + 3; j++) {\n            edges.push_back({a[i].first ^ a[j].first, a[i].second, a[j].second});\n        }\n    }\n    std::sort(edges.begin(), edges.end());\n    \n    DSU dsu(n);\n    std::vector<std::vector<int>> adj(n);\n    for (auto [_, i, j] : edges) {\n        if (dsu.merge(i, j)) {\n            adj[i].push_back(j);\n            adj[j].push_back(i);\n        }\n    }\n    \n    std::vector<int> ans(n);\n    auto dfs = [&](auto self, int x, int p) -> void {\n        for (auto y : adj[x]) {\n            if (y == p) {\n                continue;\n            }\n            ans[y] = ans[x] ^ 1;\n            self(self, y, x);\n        }\n    };\n    dfs(dfs, 0, -1);\n    \n    for (int i = 0; i < n; i++) {\n        std::cout << ans[i];\n    }\n    std::cout << \"\\n\";\n    \n    return 0;\n}"], "input": "", "output": "", "tags": ["binary search", "bitmasks", "data structures", "divide and conquer", "greedy", "trees"], "dificulty": "2700", "interactive": false}