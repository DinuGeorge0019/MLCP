{
    "link": "https://codeforces.com//contest/1101/problem/G",
    "problemId": "281060",
    "problem_idx": "G",
    "shortId": "1101G",
    "contest_number": "1101",
    "problem_submissions": {
        "G": [
            48239479,
            48229345,
            48232833,
            48236005,
            48238584,
            48237077,
            48239817,
            48236726,
            48424442,
            48241897,
            48244236,
            48246271,
            48243763,
            48241853,
            48248346,
            48243669,
            48239804,
            48232428,
            48236056,
            48233716
        ],
        "F": [
            48234729,
            48238339,
            48245658,
            48241971,
            48243102,
            48243980,
            48248208,
            48253790,
            48249237,
            48251881,
            48251772,
            48254209,
            48250740,
            48252733,
            48257301,
            48253052,
            48236429,
            48245061,
            48242715,
            48241926,
            48292686,
            48258183
        ],
        "E": [
            48227685,
            48224274,
            48222676,
            48226514,
            48225235,
            48225759,
            48224993,
            48229382,
            48234805,
            48231496,
            48237158,
            48276590,
            48233129,
            48237913,
            48231111,
            48230324,
            48226575,
            48224137,
            48222074,
            48228244,
            48223937
        ],
        "D": [
            48225904,
            132803821,
            132802920,
            48232171,
            48230596,
            48230036,
            48246912,
            48230700,
            48231186,
            48232249,
            48228292,
            48232968,
            48229870,
            48235723,
            48238573,
            48253038,
            48236119,
            48237471,
            48242160,
            48224926,
            48233664,
            48227806,
            48238739,
            48236228
        ],
        "C": [
            48220755,
            48221737,
            48220938,
            48222851,
            48222128,
            48224023,
            48222001,
            48221817,
            48228289,
            48227053,
            48229439,
            48222389,
            48224672,
            48228555,
            48228217,
            48221108,
            48222667,
            48220453,
            48229806,
            48227541
        ],
        "B": [
            48218348,
            48218521,
            48218025,
            48219067,
            48219419,
            48219511,
            48219183,
            48218594,
            48221174,
            48217036,
            48221983,
            48224393,
            48219257,
            48217297,
            48224770,
            48217931,
            48218900,
            50490666,
            48220404,
            48221056
        ],
        "A": [
            48216068,
            48216088,
            48215851,
            48216101,
            48215964,
            48215856,
            48216330,
            48216376,
            48215843,
            48215822,
            48218304,
            48215863,
            48216823,
            48215814,
            48216519,
            48216032,
            48215829,
            48216427,
            48216203
        ]
    },
    "name": "G.  Zero XOR Subset -less",
    "statement": "You are given an array a_1, a_2,\r\ndots, a_n of integer numbers.Your task is to divide the array into the\r\nmaximum number of segments in such a way that: each element is contained\r\nin segment; each segment contains at least one element; there doesn’t\r\nexist a non-empty subset of segments such that bitwise XOR of the\r\nnumbers from them is equal to 0. Print the maximum number of segments\r\nthe array can be divided into. Print if no suitable division exists.\r\n",
    "solutions": [
        "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=200000;\n\nint n;\nint a[MAXN];\n\nint b[MAXN];\n\nint solve() {\n\tint sum=0; REP(i,n) sum^=a[i]; if(sum==0) return -1;\n\n\tREP(i,n) b[i]=a[i];\n\tint nhave=0;\n\tREP(bit,30) {\n\t\tbool found=false; FOR(i,nhave,n) if((b[i]&(1<<bit))!=0) { swap(b[i],b[nhave]); found=true; break; } if(!found) continue;\n\t\tFOR(i,nhave+1,n) if((b[i]&(1<<bit))!=0) b[i]^=b[nhave];\n\t\t++nhave;\n\t}\n\treturn nhave;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) scanf(\"%d\",&a[i]);\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "matrices"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G.  Zero XOR Subset -less.json",
    "editorial_link": "https://codeforces.com/blog/entry/64483",
    "editorial": "Letâs consider some division , , ..., . Represent the XOR sum of the\r\nsubset via prefix-XOR. Those are , , ..., .I claim that you can collect\r\nany subset that is a XOR of an even number of for pairwise distinct\r\nvalues of . Letâs take a look on some prefix of processed segments,\r\nwhere the last segment is taken into subset. The previous taken âs canât\r\nbe changed, the last taken can either be eliminated if we also take the\r\ncurrent segment (and that segment erases one value and adds one) or\r\nadded to the answer if we donât take it (but the next taken segment will\r\nadd two values). You can see that the parity doesnât change.Moreover,\r\nyou can collect any subset that is a XOR of an odd number of for\r\npairwise distinct values of . Just forget about taken into the answer,\r\nas its value is . Then all the even subsets which included it will\r\nbecome odd.This way we can collect all subsets of for some division. Now\r\nyou just want find the division that produces the maximum number of\r\nlinearly independent numbers (binary vectors). That is the size of the\r\nbasis of the space of chosen numbers (binary vectors). Now itâs time to\r\nabuse the fact that adding a number into the set can only increase the\r\nsize of basis of the space. Thus, adding anything to the maximum set\r\nwonât change the answer (otherwise the result would be greater than the\r\n\"maximum\").Finally, you say that the maximum basis size is equal to the\r\nbasis size of all the prefix-XOR and easily calculate in .The only\r\ncorner case is being itself. Then for any division the full subset will\r\nalso give result. That is the only case with answer .Overall complexity:\r\n.\r\n",
    "hint": []
}