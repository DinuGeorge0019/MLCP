{
    "link": "https://codeforces.com//contest/1455/problem/G",
    "problemId": "815720",
    "problem_idx": "G",
    "shortId": "1455G",
    "contest_number": "1455",
    "problem_submissions": {
        "E": [
            100080155,
            100079381,
            100078449,
            100069275,
            100012146,
            100015897,
            100022845,
            100016854,
            100016418,
            100020237,
            100020046,
            100028425,
            100029068,
            100034230,
            100029402,
            100051234,
            100023750,
            100021088,
            100056948,
            100056790,
            100027354,
            100027044,
            100024946,
            100025731
        ],
        "F": [
            100078450,
            100025388,
            100024460,
            100036395,
            100043068,
            100042389,
            100045529,
            100060216,
            100044226,
            100043456,
            100052099,
            100046594,
            100048576,
            103031134
        ],
        "D": [
            100078448,
            100005946,
            100008735,
            100010384,
            100011871,
            100006215,
            100010441,
            100013223,
            100016383,
            100022310,
            100014989,
            100021069,
            100012652,
            100006839,
            100007553,
            100009178,
            100010622,
            100017383
        ],
        "B": [
            100078446,
            99997720,
            100001458,
            100004151,
            99999328,
            99996708,
            100002292,
            99997258,
            100004647,
            100006268,
            100003306,
            100007106,
            100000261,
            99994951,
            99999396,
            99999653,
            100001010,
            99999631,
            100001869
        ],
        "G": [
            100042304,
            100034172,
            100133399,
            100133353,
            100129809,
            100466593,
            100055077,
            100046402,
            100109589,
            102917383,
            100053452
        ],
        "C": [
            100002522,
            100004461,
            100006266,
            100003366,
            100000366,
            100005398,
            100004212,
            100008763,
            100010135,
            100006377,
            100015174,
            100005740,
            99999911,
            100008765,
            100001216,
            100002465,
            100006020
        ],
        "A": [
            99993343,
            99993450,
            99994266,
            99993464,
            99993313,
            99995467,
            99993403,
            99995627,
            99997962,
            99993689,
            99993532,
            99993614,
            99993321,
            99993386,
            99994914,
            99994222,
            99993353
        ]
    },
    "name": "G. Forbidden Value",
    "statement": "Polycarp is editing a complicated computer program. First, variable x is\r\ndeclared and assigned to 0. Then there are instructions of two types:\r\nassign x a value y or spend v burles to remove that instruction (thus,\r\nnot reassign x); block execute instructions inside the block if the\r\nvalue of x is y and ignore the block otherwise. blocks can contain\r\ninstructions and other blocks inside them.However, when the value of x\r\ngets assigned to s, the computer breaks and immediately catches fire.\r\nPolycarp wants to prevent that from happening and spend as few burles as\r\npossible.What is the minimum amount of burles he can spend on removing\r\ninstructions to never assign x to s?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nconst int64_t INF64 = int64_t(2e18) + 5;\n\nstruct DP_DS {\n    map<int, int64_t> dp;\n    set<pair<int64_t, int>> values;\n    int64_t offset = 0;\n\n    void add_all(int64_t delta) {\n        offset += delta;\n    }\n\n    bool contains(int x) const {\n        return dp.count(x);\n    }\n\n    int64_t get(int x) const {\n        return !contains(x) ? INF64 : dp.at(x) + offset;\n    }\n\n    int64_t pop(int x) {\n        if (!contains(x))\n            return INF64;\n\n        int64_t dp_value = dp[x];\n        dp.erase(x);\n        values.erase({dp_value, x});\n        return dp_value + offset;\n    }\n\n    void add_option(int x, int64_t cost) {\n        if (contains(x))\n            cost = min(cost, pop(x));\n\n        cost -= offset;\n        dp[x] = cost;\n        values.emplace(cost, x);\n    }\n\n    int64_t get_min() const {\n        return values.begin()->first + offset;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, BAD;\n    cin >> N >> BAD;\n    vector<DP_DS> dp_stack(1);\n    dp_stack[0].add_option(0, 0);\n\n    for (int i = 0; i < N; i++) {\n        string instruction;\n        cin >> instruction;\n\n        if (instruction == \"set\") {\n            int y, v;\n            cin >> y >> v;\n\n            if (y == BAD) {\n                dp_stack.back().add_all(v);\n            } else {\n                int64_t minimum = dp_stack.back().get_min();\n                dp_stack.back().add_all(v);\n                dp_stack.back().add_option(y, minimum);\n            }\n        } else if (instruction == \"if\") {\n            int y;\n            cin >> y;\n            int64_t cost = dp_stack.back().pop(y);\n            dp_stack.emplace_back();\n            dp_stack.back().add_option(y, cost);\n        } else if (instruction == \"end\") {\n            DP_DS &back = dp_stack.back();\n            DP_DS &second = dp_stack[dp_stack.size() - 2];\n\n            if (back.dp.size() > second.dp.size())\n                swap(back, second);\n\n            for (auto &pr : back.dp)\n                second.add_option(pr.first, back.get(pr.first));\n\n            dp_stack.pop_back();\n        } else {\n            assert(false);\n        }\n    }\n\n    assert(dp_stack.size() == 1);\n    cout << dp_stack[0].get_min() << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Forbidden Value.json",
    "editorial_link": "https://codeforces.com//blog/entry/85186",
    "editorial": "Consider the following dynamic programming. the minimum cost to make\r\nhave value after the -th line. The transitions here are pretty easy: on\r\nset you just consider two options of skipping or not skipping the\r\ninstructions and on if you either go to the next line or to the end of\r\nthe block depending on the value.There are a lot of possible values, so\r\nthat dp works in . First, let\u00e2\u0080\u0099s notice that all the values that don\u00e2\u0080\u0099t\r\nappear in the input won\u00e2\u0080\u0099t matter, so you can keep only the existing\r\nvalues in the dp.Next, let\u00e2\u0080\u0099s consider the following modification to it.\r\nWhat happens when you enter an if block? It\u00e2\u0080\u0099s actually the same dp but\r\nthe only starting value is not with cost as in the beginning of the\r\nwhole program but some value with some cost . So let\u00e2\u0080\u0099s calculate this dp\r\nseparately from the outer one and just merge the values together. Notice\r\nthat if some value doesn\u00e2\u0080\u0099t appear inside the if block then its cost can\r\nnot decrease exiting out of it. Thus, it\u00e2\u0080\u0099s enough to calculate the inner\r\ndp only for values that appear inside the if block.Okay, the transitions\r\nfor if became easier. The set transitions are still slow, though.\r\nExamine the nature of them. All the values besides the written on the\r\nset instruction increase their cost by . As for the , its cost becomes\r\nequal to the cost of the cheapest value before the instruction.Thus,\r\nlet\u00e2\u0080\u0099s maintain the dp in some data structure that allows to add the same\r\ninteger to all elements and take the minimum of its elements. That can\r\nbe done with a set and a single integer that stores the current shift\r\nthat should be applied to all elements. Surely, you\u00e2\u0080\u0099ll also need a map\r\nto retrieve the current cost of particular values.The final part is fast\r\nmerging of the if block dp and the outer one. It might not appear\r\nobvious but if you do that in a straightforward manner of adding all the\r\ncosts from if one by one it can become in total. So we can apply\r\nsmall-to-large and swap these dp\u00e2\u0080\u0099s based on their sizes.Overall\r\ncomplexity: .\r\n"
}