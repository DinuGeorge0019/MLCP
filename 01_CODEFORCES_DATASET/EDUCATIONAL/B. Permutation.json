{
    "link": "https://codeforces.com//contest/1701/problem/B",
    "problemId": "1455050",
    "problem_idx": "B",
    "shortId": "1701B",
    "contest_number": "1701",
    "problem_submissions": {
        "F": [
            163251511,
            163268194,
            163257685,
            163252572,
            163254045,
            163268305,
            163279907,
            163277017,
            163279770,
            163277875,
            163278549,
            163242709,
            163276457,
            163283113,
            163287382,
            163289836,
            163287332,
            163286601,
            163290833,
            163270658
        ],
        "E": [
            163244868,
            163259890,
            163266161,
            163272812,
            163264648,
            163275442,
            163258821,
            163268518,
            163268841,
            163260671,
            163264743,
            163281368,
            163267683,
            163251911,
            163266438,
            163264157,
            163269030,
            163266798,
            163269366,
            163285662
        ],
        "D": [
            163228805,
            163243794,
            163241985,
            163230350,
            163241043,
            163238273,
            163235471,
            163239458,
            163247152,
            163243702,
            163253899,
            163251145,
            163245848,
            163241441,
            163251457,
            163249655,
            163254700,
            163255033,
            163238314,
            163253263
        ],
        "C": [
            163221033,
            163229733,
            163226787,
            163222248,
            163228927,
            163224161,
            163224146,
            163230155,
            163230384,
            163234091,
            163239295,
            163237663,
            163233141,
            163239841,
            163244784,
            163239399,
            163238796,
            163229460,
            163228482,
            163229332
        ],
        "B": [
            163216526,
            163223020,
            163218771,
            163216500,
            163222790,
            163218690,
            163217320,
            163219287,
            163222344,
            163220198,
            163229802,
            163224763,
            163220303,
            163218845,
            163218374,
            163222260,
            163227662,
            163222420,
            163219736,
            163217995
        ],
        "A": [
            163216029,
            163216466,
            163216829,
            163216062,
            163216261,
            163216352,
            163216058,
            163216701,
            163216924,
            163216152,
            163225075,
            163216629,
            163216398,
            163216381,
            163216162,
            163216559,
            163221320,
            163216621,
            163217196,
            163216126
        ]
    },
    "name": "B. Permutation",
    "statement": "Recall that a permutation of length n is an array where each element\r\nfrom 1 to n occurs exactly once.For a fixed positive integer d, let’s\r\ndefine the cost of the permutation p of length n as the number of\r\nindices i (1\r\nle i < n) such that p_i\r\ncdot d = p_{i + 1}.For example, if d = 3 and p = [5, 2, 6, 7, 1, 3, 4],\r\nthen the cost of such a permutation is 2, because p_2\r\ncdot 3 = p_3 and p_5\r\ncdot 3 = p_6.Your task is the following one: for a given value n, find\r\nthe permutation of length n and the value d with maximum possible cost\r\n(over all ways to choose the permutation and d). If there are multiple\r\nanswers, then print any of them.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 08.07.2022 18:36:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a;\n    for (int i = 1; i <= n; i++) {\n      if (i % 2 == 1) {\n        int j = i;\n        while (j <= n) {\n          a.push_back(j);\n          j *= 2;\n        }\n      }\n    }\n    cout << 2 << '\\n';\n    for (int i = 0; i < n; i++) {\n      cout << a[i] << \" \\n\"[i == n - 1];\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Permutation.json",
    "editorial_link": "https://codeforces.com//blog/entry/104671",
    "editorial": "Letâs notice that for a fixed value of , the answer (the cost of\r\npermutation) does not exceed , because only numbers from to can have a\r\npair. It turns out that it is always possible to construct a permutation\r\nwith the cost of exactly . It is enough to consider the number \"chains\"\r\nof the form: , where . It is not difficult to understand that each\r\nnumber is included in exactly one such chain. Therefore, if we append\r\nthe chains one after another, then in such a permutation the answer will\r\nbe equal to (because all numbers will have a pair except the last\r\nelement in the chain). The number of chains is equal to , which means\r\nthe cost of the permutation is equal to . By choosing the permutation\r\nwill have the maximum possible cost.\r\n",
    "hint": []
}