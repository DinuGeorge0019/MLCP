{
    "link": "https://codeforces.com//contest/1606/problem/D",
    "problemId": "1163615",
    "problem_idx": "D",
    "shortId": "1606D",
    "contest_number": "1606",
    "problem_submissions": {
        "F": [
            133507404,
            133507818,
            133498109,
            133510274,
            133508292,
            133516889,
            133520516,
            133515497,
            133516080,
            133502968,
            134316313,
            133499324,
            134054804,
            133588873,
            133583029,
            133581709
        ],
        "D": [
            133486455,
            133493884,
            133513223,
            133492283,
            133485348,
            133494162,
            133496696,
            133482809,
            133492529,
            133517460,
            133476721,
            133498136,
            133495480,
            135925509,
            133485100,
            133479592,
            133499757,
            133522973,
            133486537,
            133503209,
            133499457
        ],
        "E": [
            133463795,
            133481392,
            133471511,
            133490729,
            133490179,
            133495042,
            133479686,
            133483637,
            133491209,
            133498277,
            133483064,
            133494409,
            133480178,
            133476474,
            135922690,
            133494013,
            133498349,
            133478322,
            133477984,
            133495608,
            133473401,
            133487605
        ],
        "C": [
            133458872,
            133464915,
            133459336,
            133460040,
            133464064,
            133462782,
            133466153,
            133471330,
            133463944,
            133471558,
            133463840,
            133462653,
            133461264,
            133462854,
            133461230,
            133467241,
            133464884,
            133472085,
            133464159,
            133466246
        ],
        "B": [
            133458354,
            133459359,
            133457772,
            133458154,
            133459800,
            133458862,
            133459689,
            133467167,
            133459191,
            133458183,
            133459448,
            133458263,
            133464726,
            133458679,
            133458193,
            133459842,
            133457910,
            133460625,
            133459355,
            133458301
        ],
        "A": [
            133457621,
            133458135,
            133457507,
            133457613,
            133457801,
            133457608,
            133458264,
            133457856,
            133457610,
            133457684,
            133457591,
            133457600,
            133457598,
            133457574,
            133457611,
            133457877,
            133457514,
            133458100,
            133457524,
            133457605
        ]
    },
    "name": "D. Red-Blue Matrix",
    "statement": "You are given a matrix, consisting of n rows and m columns. The j-th\r\ncell of the i-th row contains an integer a_{ij}.First, you have to color\r\neach row of the matrix either red or blue in such a way that and .Then,\r\nyou have to choose an integer k (1\r\nle k < m) and cut the colored matrix in such a way that the first k\r\ncolumns become a separate matrix (the matrix) and the last m-k columns\r\nbecome a separate matrix (the matrix).The coloring and the cut are\r\ncalled if two properties hold: every red cell in the left matrix\r\ncontains an integer greater than every blue cell in the left matrix;\r\nevery blue cell in the right matrix contains an integer greater than\r\nevery red cell in the right matrix. Find any perfect coloring and cut,\r\nor report that there are none.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n#define x first\n#define y second\n#define pb push_back\n#define mp make_pair\ntemplate <typename T> void chkmin(T &x,T y){y<x?x=y:T();}\ntemplate <typename T> void chkmax(T &x,T y){x<y?x=y:T();}\ntemplate <typename T> void readint(T &x)\n{\n\tint f=1;char c;x=0;\n\tfor(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=getchar())x=x*10+(c-'0');\n\tx*=f;\n}\nconst int MOD=998244353;\ninline int dmy(int x){return x>=MOD?x-MOD:x;}\ninline void inc(int &x,int y){x=dmy(x+y);}\nint qmi(int x,int y)\n{\n\tint ans=1;\n\tfor(;y;y>>=1,x=1ll*x*x%MOD)\n\t\tif(y&1)ans=1ll*ans*x%MOD;\n\treturn ans;\n}\nconst int MAXN=1000005;\n\nint n,m,a[MAXN];\nint p[MAXN];\nint pl[MAXN],sl[MAXN],pr[MAXN],sr[MAXN];\nint lx[MAXN],ly[MAXN],rx[MAXN],ry[MAXN];\nchar res[MAXN];\nvoid solve()\n{\n\treadint(n),readint(m);\n\tfor(int i=0;i<n;++i)\n\t\tfor(int j=0;j<m;++j)\n\t\t\treadint(a[i*m+j]);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tlx[i*m]=ly[i*m]=a[i*m];\n\t\tfor(int j=1;j<m;++j)lx[i*m+j]=min(lx[i*m+j-1],a[i*m+j]),ly[i*m+j]=max(ly[i*m+j-1],a[i*m+j]);\n\t\trx[i*m+m-1]=ry[i*m+m-1]=a[i*m+m-1];\n\t\tfor(int j=m-2;j>=0;--j)rx[i*m+j]=min(rx[i*m+j+1],a[i*m+j]),ry[i*m+j]=max(ry[i*m+j+1],a[i*m+j]);\n\t}\n\tfor(int j=0;j<m-1;++j)\n\t{\n\t\tfor(int i=0;i<n;++i)p[i]=i;\n\t\tsort(p,p+n,[&](int x,int y){return ly[x*m+j]<ly[y*m+j];});\n\t\tpl[0]=ly[p[0]*m+j],pr[0]=rx[p[0]*m+j+1];\n\t\tfor(int i=1;i<n;++i)pl[i]=max(pl[i-1],ly[p[i]*m+j]),pr[i]=min(pr[i-1],rx[p[i]*m+j+1]);\n\t\tsl[n-1]=lx[p[n-1]*m+j],sr[n-1]=ry[p[n-1]*m+j+1];\n\t\tfor(int i=n-2;i>=0;--i)sl[i]=min(sl[i+1],lx[p[i]*m+j]),sr[i]=max(sr[i+1],ry[p[i]*m+j+1]);\n\t\tfor(int i=0;i<n-1;++i)\n\t\t\tif(pl[i]<sl[i+1] && pr[i]>sr[i+1])\n\t\t\t{\n\t\t\t\tprintf(\"YES\\n\");\n\t\t\t\tfor(int t=0;t<n;++t)res[p[t]]=(t<=i?'B':'R');\n\t\t\t\tres[n]='\\0';\n\t\t\t\tprintf(\"%s %d\\n\",res,j+1);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tprintf(\"NO\\n\");\n}\n\nint main()\n{\n\t#ifdef LOCAL\n\tfreopen(\"code.in\",\"r\",stdin);\n//\tfreopen(\"code.out\",\"w\",stdout);\n\t#endif\n\tint T;\n\treadint(T);\n\twhile(T--)solve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "implementation",
        "sortings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Red-Blue Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/96454",
    "editorial": "Imagine you fixed some cut and then colored one row red. Which rows can\r\nnow be colored red or blue so that the condition on the left matrix is\r\nsatisfied? If the row has at least one number greater or equal than the\r\nnumbers in the red row, then the row must be red. Otherwise, it can be\r\neither red or blue.However, imagine a weaker condition. Letâs look only\r\nat the first cell in each row. Sort the rows by the first cell in them.\r\nSimilarly, if a row is colored red, all the rows that are further in the\r\nsorted order should also be red, because they already have a greater or\r\nequal number in them.It implies that after you sort the rows, the only\r\npossible colorings are: color some prefix of the rows in blue and the\r\nremaining suffix in red.So there are possible colorings and possible\r\ncuts. If we learn to check if they are perfect in , we can get the\r\nsolution in .Turns out, the condition \"all numbers in the submatrix\r\nshould be greater than all numbers in the other submatrix\" is the same\r\nas \"the minimum in the first submatrix should be greater than the\r\nmaximum in the second submatrix\".Thus, you can first precalculate prefix\r\nand suffix minimums and maximums and check a coloring and a cut in\r\n.Overall complexity: per testcase.\r\n",
    "hint": []
}