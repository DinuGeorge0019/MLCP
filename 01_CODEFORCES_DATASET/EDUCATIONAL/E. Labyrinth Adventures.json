{
    "link": "https://codeforces.com//contest/1681/problem/E",
    "problemId": "1408806",
    "problem_idx": "E",
    "shortId": "1681E",
    "contest_number": "1681",
    "problem_submissions": {
        "E": [
            158182756,
            158181599,
            158189245,
            158201402,
            158212176,
            158209977,
            158197244,
            158200543,
            158207419,
            158195422,
            158212507,
            158201688,
            158217615,
            158236025,
            158203326,
            158213610,
            158220340,
            158209570,
            158222642,
            158202788
        ],
        "D": [
            158169620,
            158166339,
            158168627,
            158176540,
            158180183,
            158179810,
            158175614,
            158171745,
            158169793,
            158171043,
            158176143,
            158179351,
            158198071,
            158177219,
            158193904,
            158184952,
            158187520,
            158180354,
            158208785
        ],
        "F": [
            158163420,
            158197514,
            158198216,
            158189118,
            158175678,
            158193941,
            158204936,
            158208270,
            158190074,
            158203305,
            158200335,
            158211270,
            158186690,
            158250369,
            158237153,
            158219180,
            158187046,
            158203102,
            158220096,
            158206596,
            158220727
        ],
        "C": [
            158154298,
            158157033,
            158157275,
            158158888,
            158161011,
            158157520,
            158164047,
            158162763,
            158158338,
            158166846,
            158162496,
            158167443,
            158168946,
            158167710,
            158166768,
            158169766,
            158168157,
            158169965,
            158164354
        ],
        "B": [
            158153598,
            158154121,
            158153990,
            158154166,
            158155404,
            158154059,
            158159057,
            158156022,
            158154367,
            158163137,
            158157819,
            158159126,
            158157005,
            158167777,
            158160391,
            158158841,
            158161305,
            158161887,
            158159104
        ],
        "A": [
            158153541,
            158153617,
            158153597,
            158153653,
            158153683,
            158153631,
            158155593,
            158153768,
            158153633,
            158155729,
            158155747,
            158154711,
            158154019,
            158167893,
            158153987,
            158154332,
            158156617,
            158157260,
            158154882
        ]
    },
    "name": "E. Labyrinth Adventures",
    "statement": "You found a map of a weirdly shaped labyrinth. The map is a grid,\r\nconsisting of n rows and n columns. The rows of the grid are numbered\r\nfrom 1 to n from bottom to top. The columns of the grid are numbered\r\nfrom 1 to n from left to right.The labyrinth has n layers. The first\r\nlayer is the bottom left corner (cell (1, 1)). The second layer consists\r\nof all cells that are in the grid and adjacent to the first layer by a\r\nside or a corner. The third layer consists of all cells that are in the\r\ngrid and adjacent to the second layer by a side or a corner. And so on.\r\nThe labyrinth with 5 layers, for example, is shaped as follows: The\r\nlayers are separated from one another with walls. However, there are\r\ndoors in these walls.Each layer (except for layer n) has exactly two\r\ndoors to the next layer. One door is placed on the top wall of the layer\r\nand another door is placed on the right wall of the layer. For each\r\nlayer from 1 to n-1 you are given positions of these two doors. The\r\ndoors can be passed in both directions: either from layer i to layer i+1\r\nor from layer i+1 to layer i.If you are standing in some cell, you can\r\nmove to an adjacent by a side cell if a wall doesn\u2019t block your move\r\n(e.g. you can\u2019t move to a cell in another layer if there is no door\r\nbetween the cells).Now you have m queries of sort: what\u2019s the minimum\r\nnumber of moves one has to make to go from cell (x_1, y_1) to cell (x_2,\r\ny_2).\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 23.05.2022 18:54:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nvector<array<array<int, 2>, 2>> dist;\n\nclass segtree {\n public:\n  struct node {\n    array<long long, 4> a;\n    int L;\n    int R;\n\n    void apply(int l, int r, array<long long, 4> v) {\n      a = v;\n      L = l;\n      R = r;\n    }\n  };\n\n  node unite(const node &a, const node &b) const {\n    node res;\n    res.L = a.L;\n    res.R = b.R;\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        long long best = (long long) 1e18;\n        for (int k = 0; k < 2; k++) {\n          for (int t = 0; t < 2; t++) {\n            long long cur = a.a[i * 2 + k] + b.a[t * 2 + j];\n            cur += dist[b.L][k][t];\n            best = min(best, cur);\n          }\n        }\n        res.a[i * 2 + j] = best;\n      }\n    }\n    return res;\n  }\n\n  inline void push(int x, int l, int r) {\n  }\n\n  inline void pull(int x, int z) {\n    tree[x] = unite(tree[x + 1], tree[z]);\n  }\n\n  int n;\n  vector<node> tree;\n\n  void build(int x, int l, int r) {\n    if (l == r) {\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y);\n    build(z, y + 1, r);\n    pull(x, z);\n  }\n\n  template <typename M>\n  void build(int x, int l, int r, const vector<M> &v) {\n    if (l == r) {\n      tree[x].apply(l, r, v[l]);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    build(x + 1, l, y, v);\n    build(z, y + 1, r, v);\n    pull(x, z);\n  }\n\n  node get(int x, int l, int r, int ll, int rr) {\n    if (ll <= l && r <= rr) {\n      return tree[x];\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    node res{};\n    if (rr <= y) {\n      res = get(x + 1, l, y, ll, rr);\n    } else {\n      if (ll > y) {\n        res = get(z, y + 1, r, ll, rr);\n      } else {\n        res = unite(get(x + 1, l, y, ll, rr), get(z, y + 1, r, ll, rr));\n      }\n    }\n    pull(x, z);\n    return res;\n  }\n\n  template <typename... M>\n  void modify(int x, int l, int r, int ll, int rr, const M&... v) {\n    if (ll <= l && r <= rr) {\n      tree[x].apply(l, r, v...);\n      return;\n    }\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    push(x, l, r);\n    if (ll <= y) {\n      modify(x + 1, l, y, ll, rr, v...);\n    }\n    if (rr > y) {\n      modify(z, y + 1, r, ll, rr, v...);\n    }\n    pull(x, z);\n  }\n\n  int find_first_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[x + 1])) {\n      res = find_first_knowingly(x + 1, l, y, f);\n    } else {\n      res = find_first_knowingly(z, y + 1, r, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_first(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_first_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (ll <= y) {\n      res = find_first(x + 1, l, y, ll, rr, f);\n    }\n    if (rr > y && res == -1) {\n      res = find_first(z, y + 1, r, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last_knowingly(int x, int l, int r, const function<bool(const node&)> &f) {\n    if (l == r) {\n      return l;\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res;\n    if (f(tree[z])) {\n      res = find_last_knowingly(z, y + 1, r, f);\n    } else {\n      res = find_last_knowingly(x + 1, l, y, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  int find_last(int x, int l, int r, int ll, int rr, const function<bool(const node&)> &f) {\n    if (ll <= l && r <= rr) {\n      if (!f(tree[x])) {\n        return -1;\n      }\n      return find_last_knowingly(x, l, r, f);\n    }\n    push(x, l, r);\n    int y = (l + r) >> 1;\n    int z = x + ((y - l + 1) << 1);\n    int res = -1;\n    if (rr > y) {\n      res = find_last(z, y + 1, r, ll, rr, f);\n    }\n    if (ll <= y && res == -1) {\n      res = find_last(x + 1, l, y, ll, rr, f);\n    }\n    pull(x, z);\n    return res;\n  }\n\n  segtree(int _n) : n(_n) {\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1);\n  }\n\n  template <typename M>\n  segtree(const vector<M> &v) {\n    n = v.size();\n    assert(n > 0);\n    tree.resize(2 * n - 1);\n    build(0, 0, n - 1, v);\n  }\n\n  node get(int ll, int rr) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return get(0, 0, n - 1, ll, rr);\n  }\n\n  node get(int p) {\n    assert(0 <= p && p <= n - 1);\n    return get(0, 0, n - 1, p, p);\n  }\n\n  template <typename... M>\n  void modify(int ll, int rr, const M&... v) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    modify(0, 0, n - 1, ll, rr, v...);\n  }\n\n  // find_first and find_last call all FALSE elements\n  // to the left (right) of the sought position exactly once\n\n  int find_first(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_first(0, 0, n - 1, ll, rr, f);\n  }\n\n  int find_last(int ll, int rr, const function<bool(const node&)> &f) {\n    assert(0 <= ll && ll <= rr && rr <= n - 1);\n    return find_last(0, 0, n - 1, ll, rr, f);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<pair<int, int>> bot(n - 1);\n  vector<pair<int, int>> lft(n - 1);\n  vector<pair<int, int>> top(n - 1);\n  vector<pair<int, int>> rgt(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    cin >> bot[i].first >> bot[i].second >> lft[i].first >> lft[i].second;\n    top[i] = bot[i];\n    top[i].first += 1;\n    rgt[i] = lft[i];\n    rgt[i].second += 1;\n  }\n  vector<array<long long, 4>> p(n - 1);\n  for (int i = 0; i < n - 1; i++) {\n    int d = abs(bot[i].first - lft[i].first) + abs(bot[i].second - lft[i].second);\n    p[i] = {1, d + 1, d + 1, 1};\n  }\n  dist.resize(n - 1);\n  for (int q = 1; q < n - 1; q++) {\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        auto ga = (i == 0 ? top[q - 1] : rgt[q - 1]);\n        auto gb = (j == 0 ? bot[q] : lft[q]);\n        dist[q][i][j] = abs(ga.first - gb.first) + abs(ga.second - gb.second);\n      }\n    }\n  }\n  segtree st(p);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int xa, ya, xb, yb;\n    cin >> xa >> ya >> xb >> yb;\n    int ia = max(xa, ya) - 1;\n    int ib = max(xb, yb) - 1;\n    if (ia > ib) {\n      swap(xa, xb);\n      swap(ya, yb);\n      swap(ia, ib);\n    }\n    if (ia == ib) {\n      cout << abs(xa - xb) + abs(ya - yb) << '\\n';\n      continue;\n    }\n    auto nd = st.get(ia, ib - 1);\n    long long ans = (long long) 1e18;\n    for (int i = 0; i < 2; i++) {\n      for (int j = 0; j < 2; j++) {\n        auto ga = (i == 0 ? bot[ia] : lft[ia]);\n        int da = abs(ga.first - xa) + abs(ga.second - ya);\n        auto gb = (j == 0 ? top[ib - 1] : rgt[ib - 1]);\n        int db = abs(gb.first - xb) + abs(gb.second - yb);\n        ans = min(ans, da + db + nd.a[i * 2 + j]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "matrices",
        "shortest paths"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Labyrinth Adventures.json",
    "editorial_link": "https://codeforces.com//blog/entry/103163",
    "editorial": "WLOG, assume all queries ask to move from a lower layer to a higher\r\nlayer. The first thing to notice in the problem is that it is always\r\noptimal to never go down a layer. You have an optimal path that is going\r\ndown some layers, and then returning to the same layer. So it leaves a\r\nlayer in some its cell and returns to it in some other cell (or the same\r\none). The best distance it can achieve is the Manhattan distance between\r\nthese two cells. However, we can also achieve the Manhattan distance by\r\njust going along this layer, and the answer will be at least as\r\noptimal.If the query asks about the cells of the same layer, just answer\r\nwith the Manhattan distance. Otherwise, we can describe the path as\r\nfollows: go from the first cell to some door on its layer, enter the\r\ndoor and go to another door on the next layer, so on until the layer of\r\nthe second cell, where you go from a door to the second cell.Thus, we\r\ncould potentially write the shortest distance from the start to the -th\r\ndoor of the -th layer. Initialize both doors of the first layer, take\r\nthe best answer from the both doors of the last layer. That would be per\r\nquery, which is too slow.Let\u00e2\u0080\u0099s optimize it with some precalculations. In\r\nparticular, we want to know the shortest distance between one door of\r\nsome layer and one door of another layer.We can use the technique\r\nsimilar to binary lifting. Calculate the distance between a pair of\r\ndoors on layers which are apart for all up to . Let be the distance from\r\ndoor of layer to door of layer . can be initialized straightforwardly.\r\nThen, to calculate , we can use the values for : and for some\r\nintermediate door on layer .To obtain the answer, use jumps to reach the\r\nlayer one before the last one. Then iterate over the last\r\ndoor.Alternatively, you could pack this dynamic programming into a\r\nsegment tree, use divide and conquer on queries or do square root\r\ndecomposition.Overall complexity: .\r\n"
}