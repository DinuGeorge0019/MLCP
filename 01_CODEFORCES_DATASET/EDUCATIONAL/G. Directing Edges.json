{"link": "https://codeforces.com//contest/1389/problem/G", "problemId": "686128", "problem_idx": "G", "shortId": "1389G", "contest_number": "1389", "problem_submissions": {"F": [88348682, 88338153, 88328943, 88335897, 88333690, 88373314, 88373278, 88339376, 88563610, 88324437, 88323357, 90193331, 88370216, 88338670, 88346193, 88335414, 88340450, 88343043, 88354834, 88350683, 88354635, 88351121, 88341928, 88353006, 88617212, 88617191, 88616644, 88339094], "G": [88341915, 88358421, 88361866, 88360257, 88360333, 88361126, 88563627, 88370757, 88366719, 88625823, 88368266], "E": [88316360, 88314884, 88313039, 88320696, 88327221, 88331067, 88563585, 88316358, 88316429, 88316758, 88324617, 88315489, 88322575, 88325697, 88318058, 88335501, 88333747, 88335296, 88331670, 88336084, 88330920], "D": [88313541, 88323588, 88322172, 88317239, 88320907, 88324683, 88563559, 88313756, 88311946, 88313492, 88320253, 88324924, 88317796, 88320516, 88314433, 88325709, 88322521, 88323822, 88326845, 88325546, 88326242], "C": [88305803, 88306793, 88305781, 88311961, 88313905, 88313498, 88563542, 88308288, 88306505, 88301578, 88306622, 88310987, 88310892, 88306012, 88305081, 88310508, 88309198, 88313956, 88307817, 88312102, 88315317], "B": [88302673, 88302689, 88302324, 88309761, 88336897, 88305352, 88563516, 88305445, 88304272, 88310119, 88303921, 88308221, 88312057, 88313228, 88301014, 88307222, 88306963, 88309964, 88398537, 88306205, 88308367, 88311740], "A": [88294762, 88294889, 88294798, 88296225, 88294786, 88295833, 88563453, 88295598, 88294725, 88294981, 88294767, 88294779, 88295244, 88294853, 88294700, 88297412, 88295036, 88299886, 88294845, 88296400, 88294879]}, "name": "G. Directing Edges", "statement": "You are given an undirected connected graph consisting of n vertices and\r\nm edges. k vertices of this graph are special.You have to direct each\r\nedge of this graph or leave it undirected. If you leave the i-th edge\r\nundirected, you pay w_i coins, and if you direct it, you don\u2019t have to\r\npay for it.Let\u2019s call a vertex if it is reachable from each special\r\nvertex along the edges of the graph (if an edge is undirected, it can be\r\ntraversed in both directions). After you direct the edges of the graph\r\n(possibly leaving some of them undirected), you receive c_i coins for\r\neach saturated vertex i. Thus, your total profit can be calculated as\r\nsum\r\nlimits_{i\r\nin S} c_i -\r\nsum\r\nlimits_{j\r\nin U} w_j, where S is the set of saturated vertices, and U is the set of\r\nedges you leave undirected.For each vertex i, calculate the maximum\r\npossible profit you can get if you have to make the vertex i saturated.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 300300;\nint n, m, k;\nvector<int> g[N];\nvector<pii> G[N];\nint cntSpec[N];\nll sumVal[N];\nint h[N];\nint minH[N];\nint root;\nint ed[N][3];\nbool isBridge[N];\nint myComp[N];\nll val[N];\nmap<pii, ll> dp;\nint deg[N];\nll ans[N];\nint q[2 * N];\nint topQ;\n\nint getOther(int id, int v) {\n\treturn ed[id][0] ^ ed[id][1] ^ v;\n}\n\nvoid dfs1(int v) {\n//\teprintf(\"dfs1 %d %d\\n\", v, h[v]);\n\tminH[v] = h[v];\n\tfor (int id : g[v]) {\n\t\tint u = getOther(id, v);\n\t\tif (h[u] != -1) {\n\t\t\tif (h[u] != h[v] - 1)\n\t\t\t\tminH[v] = min(minH[v], h[u]);\n\t\t\tcontinue;\n\t\t}\n\t\th[u] = h[v] + 1;\n\t\tdfs1(u);\n\t\tcntSpec[v] += cntSpec[u];\n//\t\tsumVal[v] += sumVal[u];\n\t\tminH[v] = min(minH[v], minH[u]);\n\t\tif (minH[u] > h[v] && cntSpec[u] > 0) {\n\t\t\tisBridge[id] = 1;\n\t\t}\n\t}\n}\nvoid dfsComp(int v) {\n\tmyComp[v] = k;\n\tval[k] += sumVal[v];\n\tfor (int id : g[v]) {\n\t\tif (isBridge[id]) continue;\n\t\tint u = getOther(id, v);\n\t\tif (myComp[u] == -1)\n\t\t\tdfsComp(u);\n\t}\n}\n\nvoid solve(int v) {\n\tif (deg[v] == 1) {\n\t\tpii u = mp(-1, -1);\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(v, w))) {\n\t\t\t\tsum += dp[mp(v, w)];\n\t\t\t} else {\n\t\t\t\tu = e;\n\t\t\t}\n\t\t}\n\t\tif (u.first != -1) {\n\t\t\tint w = u.first;\n\t\t\tsum = max(0LL, sum - u.second);\n\t\t\tdp[mp(w, v)] = sum;\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else if (deg[v] == 0) {\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tsum += dp[mp(v, w)];\n\t\t}\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(w, v))) continue;\n\t\t\tdp[mp(w, v)] = max(0LL, sum - dp[mp(v, w)] - e.second);\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else throw;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tx--;\n\t\troot = x;\n\t\tcntSpec[x]++;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &sumVal[i]);\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(\"%d\", &ed[i][2]);\n\tfor (int i = 0; i < m; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\ted[i][0] = v;\n\t\ted[i][1] = u;\n\t\tg[v].push_back(i);\n\t\tg[u].push_back(i);\n\t}\n\tk = 0;\n\tfor (int i = 0; i < n; i++)\n\t\th[i] = -1;\n\th[root] = 0;\n\tdfs1(root);\n\t/*\n\tfor (int i = 0; i < m; i++)\n\t\teprintf(\"%d\", (int)isBridge[i]);\n\teprintf(\"\\n\");\n\t*/\n\tfor (int v = 0; v < n; v++)\n\t\tmyComp[v] = -1;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (myComp[v] != -1) continue;\n\t\tdfsComp(v);\n\t\tk++;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!isBridge[i]) continue;\n\t\tint v = myComp[ed[i][0]], u = myComp[ed[i][1]];\n\t\tassert(v != u);\n\t\tG[v].push_back(mp(u, ed[i][2]));\n\t\tG[u].push_back(mp(v, ed[i][2]));\n\t}\n\n\tif (k == 1) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%lld \", val[0]);\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tdeg[v] = (int)G[v].size();\n\t\tif (deg[v] <= 1) q[topQ++] = v;\n\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tsolve(q[i]);\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tans[v] = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint u = e.first;\n\t\t\tans[v] += dp[mp(v, u)];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%lld \", ans[myComp[i]]);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "graphs", "trees"], "dificulty": "2800", "interactive": false}