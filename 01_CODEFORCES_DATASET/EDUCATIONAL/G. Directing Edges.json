{
    "link": "https://codeforces.com//contest/1389/problem/G",
    "problemId": "686128",
    "problem_idx": "G",
    "shortId": "1389G",
    "contest_number": "1389",
    "problem_submissions": {
        "F": [
            88348682,
            88338153,
            88328943,
            88335897,
            88333690,
            88373314,
            88373278,
            88339376,
            88563610,
            88324437,
            88323357,
            90193331,
            88370216,
            88338670,
            88346193,
            88335414,
            88340450,
            88343043,
            88354834,
            88350683,
            88354635,
            88351121,
            88341928,
            88353006,
            88617212,
            88617191,
            88616644,
            88339094
        ],
        "G": [
            88341915,
            88358421,
            88361866,
            88360257,
            88360333,
            88361126,
            88563627,
            88370757,
            88366719,
            88625823,
            88368266
        ],
        "E": [
            88316360,
            88314884,
            88313039,
            88320696,
            88327221,
            88331067,
            88563585,
            88316358,
            88316429,
            88316758,
            88324617,
            88315489,
            88322575,
            88325697,
            88318058,
            88335501,
            88333747,
            88335296,
            88331670,
            88336084,
            88330920
        ],
        "D": [
            88313541,
            88323588,
            88322172,
            88317239,
            88320907,
            88324683,
            88563559,
            88313756,
            88311946,
            88313492,
            88320253,
            88324924,
            88317796,
            88320516,
            88314433,
            88325709,
            88322521,
            88323822,
            88326845,
            88325546,
            88326242
        ],
        "C": [
            88305803,
            88306793,
            88305781,
            88311961,
            88313905,
            88313498,
            88563542,
            88308288,
            88306505,
            88301578,
            88306622,
            88310987,
            88310892,
            88306012,
            88305081,
            88310508,
            88309198,
            88313956,
            88307817,
            88312102,
            88315317
        ],
        "B": [
            88302673,
            88302689,
            88302324,
            88309761,
            88336897,
            88305352,
            88563516,
            88305445,
            88304272,
            88310119,
            88303921,
            88308221,
            88312057,
            88313228,
            88301014,
            88307222,
            88306963,
            88309964,
            88398537,
            88306205,
            88308367,
            88311740
        ],
        "A": [
            88294762,
            88294889,
            88294798,
            88296225,
            88294786,
            88295833,
            88563453,
            88295598,
            88294725,
            88294981,
            88294767,
            88294779,
            88295244,
            88294853,
            88294700,
            88297412,
            88295036,
            88299886,
            88294845,
            88296400,
            88294879
        ]
    },
    "name": "G. Directing Edges",
    "statement": "You are given an undirected connected graph consisting of n vertices and\r\nm edges. k vertices of this graph are special.You have to direct each\r\nedge of this graph or leave it undirected. If you leave the i-th edge\r\nundirected, you pay w_i coins, and if you direct it, you don’t have to\r\npay for it.Let’s call a vertex if it is reachable from each special\r\nvertex along the edges of the graph (if an edge is undirected, it can be\r\ntraversed in both directions). After you direct the edges of the graph\r\n(possibly leaving some of them undirected), you receive c_i coins for\r\neach saturated vertex i. Thus, your total profit can be calculated as\r\nsum\r\nlimits_{i\r\nin S} c_i -\r\nsum\r\nlimits_{j\r\nin U} w_j, where S is the set of saturated vertices, and U is the set of\r\nedges you leave undirected.For each vertex i, calculate the maximum\r\npossible profit you can get if you have to make the vertex i saturated.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 300300;\nint n, m, k;\nvector<int> g[N];\nvector<pii> G[N];\nint cntSpec[N];\nll sumVal[N];\nint h[N];\nint minH[N];\nint root;\nint ed[N][3];\nbool isBridge[N];\nint myComp[N];\nll val[N];\nmap<pii, ll> dp;\nint deg[N];\nll ans[N];\nint q[2 * N];\nint topQ;\n\nint getOther(int id, int v) {\n\treturn ed[id][0] ^ ed[id][1] ^ v;\n}\n\nvoid dfs1(int v) {\n//\teprintf(\"dfs1 %d %d\\n\", v, h[v]);\n\tminH[v] = h[v];\n\tfor (int id : g[v]) {\n\t\tint u = getOther(id, v);\n\t\tif (h[u] != -1) {\n\t\t\tif (h[u] != h[v] - 1)\n\t\t\t\tminH[v] = min(minH[v], h[u]);\n\t\t\tcontinue;\n\t\t}\n\t\th[u] = h[v] + 1;\n\t\tdfs1(u);\n\t\tcntSpec[v] += cntSpec[u];\n//\t\tsumVal[v] += sumVal[u];\n\t\tminH[v] = min(minH[v], minH[u]);\n\t\tif (minH[u] > h[v] && cntSpec[u] > 0) {\n\t\t\tisBridge[id] = 1;\n\t\t}\n\t}\n}\nvoid dfsComp(int v) {\n\tmyComp[v] = k;\n\tval[k] += sumVal[v];\n\tfor (int id : g[v]) {\n\t\tif (isBridge[id]) continue;\n\t\tint u = getOther(id, v);\n\t\tif (myComp[u] == -1)\n\t\t\tdfsComp(u);\n\t}\n}\n\nvoid solve(int v) {\n\tif (deg[v] == 1) {\n\t\tpii u = mp(-1, -1);\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(v, w))) {\n\t\t\t\tsum += dp[mp(v, w)];\n\t\t\t} else {\n\t\t\t\tu = e;\n\t\t\t}\n\t\t}\n\t\tif (u.first != -1) {\n\t\t\tint w = u.first;\n\t\t\tsum = max(0LL, sum - u.second);\n\t\t\tdp[mp(w, v)] = sum;\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else if (deg[v] == 0) {\n\t\tll sum = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tsum += dp[mp(v, w)];\n\t\t}\n\t\tfor (pii e : G[v]) {\n\t\t\tint w = e.first;\n\t\t\tif (dp.count(mp(w, v))) continue;\n\t\t\tdp[mp(w, v)] = max(0LL, sum - dp[mp(v, w)] - e.second);\n\t\t\tdeg[w]--;\n\t\t\tif (deg[w] <= 1) q[topQ++] = w;\n\t\t}\n\t} else throw;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor (int i = 0; i < k; i++) {\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tx--;\n\t\troot = x;\n\t\tcntSpec[x]++;\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%lld\", &sumVal[i]);\n\tfor (int i = 0; i < m; i++)\n\t\tscanf(\"%d\", &ed[i][2]);\n\tfor (int i = 0; i < m; i++) {\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--;u--;\n\t\ted[i][0] = v;\n\t\ted[i][1] = u;\n\t\tg[v].push_back(i);\n\t\tg[u].push_back(i);\n\t}\n\tk = 0;\n\tfor (int i = 0; i < n; i++)\n\t\th[i] = -1;\n\th[root] = 0;\n\tdfs1(root);\n\t/*\n\tfor (int i = 0; i < m; i++)\n\t\teprintf(\"%d\", (int)isBridge[i]);\n\teprintf(\"\\n\");\n\t*/\n\tfor (int v = 0; v < n; v++)\n\t\tmyComp[v] = -1;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (myComp[v] != -1) continue;\n\t\tdfsComp(v);\n\t\tk++;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tif (!isBridge[i]) continue;\n\t\tint v = myComp[ed[i][0]], u = myComp[ed[i][1]];\n\t\tassert(v != u);\n\t\tG[v].push_back(mp(u, ed[i][2]));\n\t\tG[u].push_back(mp(v, ed[i][2]));\n\t}\n\n\tif (k == 1) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprintf(\"%lld \", val[0]);\n\t\tprintf(\"\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tdeg[v] = (int)G[v].size();\n\t\tif (deg[v] <= 1) q[topQ++] = v;\n\t}\n\tfor (int i = 0; i < topQ; i++) {\n\t\tsolve(q[i]);\n\t}\n\n\tfor (int v = 0; v < k; v++) {\n\t\tans[v] = val[v];\n\t\tfor (pii e : G[v]) {\n\t\t\tint u = e.first;\n\t\t\tans[v] += dp[mp(v, u)];\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tprintf(\"%lld \", ans[myComp[i]]);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "graphs",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Directing Edges.json",
    "editorial_link": "https://codeforces.com//blog/entry/80809",
    "editorial": "Suppose we want to calculate the maximum profit for some vertex in .\r\nLetâs try to find out how it can be done, and then optimize this process\r\nso we donât have to run it times.First of all, we have to find the\r\nbridges and biconnected components in our graph. Why do we need them?\r\nEdges in each biconnected component can be directed in such a way that\r\nit becomes a strongly connected component, so we donât have to leave\r\nthese edges undirected (it is never optimal). Furthermore, for each such\r\ncomponent, either all vertices are saturated or no vertex is saturated.\r\nLetâs build a tree where each vertex represents a biconnected component\r\nof the original graph, and each edge represents a bridge. We can solve\r\nthe problem for this tree, and then the answer for some vertex of the\r\noriginal graph is equal to the answer for the biconnected component this\r\nvertex belongs to.Okay, now we have a problem on tree. Letâs implement\r\nthe following dynamic programming solution: root the tree at the vertex\r\nwe want to find the answer for, and for each vertex, calculate the value\r\nof the maximum profit we can get for the subtree of vertex , if it\r\nshould be reachable by all special vertices from its subtree.Letâs\r\nanalyze how we can calculate these values. Suppose we have a vertex with\r\nchildren , , ..., , we have already calculated the values for the\r\nchildren, and we want to calculate . First of all, since the vertex is\r\ngoing to be saturated, we will get the profit from it, so we initialize\r\nwith . Then we should decide whether we want to get the profit from the\r\nchildren of vertex . Suppose the edge leading from to has weight . If we\r\nwant to take the profit from the subtree of , we (usually) have to make\r\nthis edge undirected, so both vertices are saturated, thus we get as\r\nprofit or we could leave this edge directed from to , so the vertex is\r\nsaturated, and is not, and get as the profit. But sometimes we can gain\r\nthe profit from the vertex and its subtree without leaving the edge\r\nundirected: if all special vertices belong to the subtree of , we can\r\njust direct this edge from to , and there is no reason to choose the\r\nopposite direction or leave the edge undirected. Similarly, if all\r\nspecial vertices are outside of this subtree, thereâs no reason to\r\ndirect the edge from to . So, if one of this conditions is met, we can\r\nget the full profit from the subtree of without leaving the edge\r\nundirected.Okay, letâs summarize it. We can calculate as , where is\r\neither if one of the aforementioned conditions is met (we donât have to\r\nleave the edge undirected if we want to saturate both vertices), or\r\notherwise. Now we have an solution.Letâs optimize it to . Root the tree\r\nat vertex and calculate the dynamic programming as if is the root. Then,\r\nwe shall use technique to recalculate the dynamic programming for all\r\nother vertices: we will try each vertex as the root of the tree, and is\r\nthe answer for the vertex if it is the root. The rerooting technique\r\nworks as follows: letâs run DFS from the initial root of the tree, and\r\nwhen we traverse an edge by starting or finishing a recursive call of\r\nDFS, we move the root along the edge; so, if we call , is the current\r\nroot; if it has some child , we move the root to the same moment when we\r\ncall , and when the call of ends, the root moves back to .Okay, the only\r\nthing thatâs left is to describe how we move the root. If the current\r\nroot is , and we want to move it to (a vertex adjacent to ), then we\r\nhave to change only the values of and : first of all, since is no longer\r\na child of , we have to subtract the value that was added to while we\r\nconsidered vertex ; then, we have to make the child of vertex , so we\r\nadd the profit we can get from the vertex to . It can be done in , so\r\nour solution runs in , though with a very heavy constant factor.\r\n",
    "hint": []
}