{
    "link": "https://codeforces.com//contest/1969/problem/F",
    "problemId": "2619522",
    "problem_idx": "F",
    "shortId": "1969F",
    "contest_number": "1969",
    "problem_submissions": {
        "F": [
            258740971,
            258740820,
            258746132,
            258746716,
            258755183,
            258754014,
            258764616,
            258761581,
            258761069,
            258757448,
            258733006,
            258743321,
            258792091,
            258769461
        ],
        "E": [
            258725328,
            258720683,
            258724478,
            258731693,
            258756331,
            258755767,
            258736057,
            258804715,
            258733183,
            258735874,
            258730875,
            258757457,
            258749091,
            258722655,
            258724259,
            258731836,
            258735531,
            258733424,
            258733392,
            258730397,
            258733010,
            258733415,
            258736757
        ],
        "D": [
            258715496,
            258711950,
            258717455,
            258715807,
            258715309,
            258717478,
            258718891,
            258722961,
            258744444,
            258753841,
            258715868,
            258714258,
            258718192,
            258717839,
            258720978,
            258721300,
            258722241,
            258769261,
            258723656,
            258722483,
            258717125
        ],
        "C": [
            258709519,
            258714184,
            258710089,
            258708902,
            258709129,
            258711287,
            258711586,
            258731391,
            258739788,
            258758308,
            258709210,
            258714988,
            258712692,
            258710594,
            258712746,
            258713533,
            258716060,
            258713283,
            258715693,
            258710630
        ],
        "B": [
            258705054,
            258704158,
            258705135,
            258705001,
            258705619,
            258707939,
            258707446,
            258706758,
            258736445,
            258759399,
            258704770,
            258705679,
            258707425,
            258706710,
            258706746,
            258707793,
            258708419,
            258705968,
            258708957,
            258706188
        ],
        "A": [
            258703665,
            258703553,
            258703758,
            258703560,
            258703556,
            258703637,
            258704655,
            258703660,
            258734943,
            258760234,
            258703586,
            258703687,
            258704850,
            258703730,
            258703995,
            258703579,
            258704091,
            258703811,
            258704619,
            258703722
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129022",
    "editorial": "It\u00e2\u0080\u0099s pretty obvious that every time we have a pair of equal cards in\r\nhand, we should play one of these pairs. If you\u00e2\u0080\u0099re interested in a\r\nformal proof, please read the paragraph in italic, otherwise skip\r\nit.Whenever we have a pair of equal cards, we will always play it at\r\nsome moment and earn a coin, and it does not matter in which order we\r\nplay different pairs. So we have to make a meaningful choice about which\r\ncards we play only when all cards in our hand are different.In the ideal\r\nsituation, if there are cards of type , we want to earn coins by playing\r\nthese cards. But whenever we play only one card of type and there is an\r\nodd number of cards of type left (both in hand and in deck), we \"lose\" a\r\ncoin, because the number of pairs we can make decreases by . Let\u00e2\u0080\u0099s\r\ncalculate the answer as the maximum possible number of pairs we can form\r\n(equal to ), minus the minimum number of coins we \"lose\" in such a\r\nway.Since we play a pair when we have at least one pair, we can \"lose\"\r\ncoins only when all cards in our hand are different. So, let\u00e2\u0080\u0099s try to\r\nuse a dynamic programming of the form: is the minimum number of coins we\r\ncould lose when we have drawn first cards from the deck, and all cards\r\nin our hand are different.Let\u00e2\u0080\u0099s analyze the transitions of this dynamic\r\nprogramming. When transitioning out of , we can iterate on the pair of\r\ncards we play (since we consider the situation when all cards in our\r\nhand are different, we can play any pair of different cards); for each\r\nof these two cards, check if we \"lose\" a coin by playing them, and try\r\nto find the next moment when all cards in our hand will be different (or\r\nupdate the answer if there is no such moment).However, when implemented\r\nnaively, it is too slow (might take up to ). We can use the following\r\noptimizations to improve it: : this is one of my favorite techniques.\r\nLet\u00e2\u0080\u0099s assign each card type a random -bit number (let it be for type ).\r\nThen, let be the XOR of the numbers assigned to the first cards in the\r\ndeck. Suppose we are considering transitions from ; we try to play cards\r\nof type and ; when will be the next moment when we have all types of\r\ncards? If this moment is , then we need to take an odd number of cards\r\nof type and from moment to moment , and an even number of cards for all\r\nother types. So, we can see that , and this allows us to locate the next\r\nmoment when we have different cards more easily, in or even . we have up\r\nto pairs of cards we can play from each state, but only different states\r\nwe can go into, and no two transitions lead to the same state. Let\u00e2\u0080\u0099s try\r\nto make only transitions from each state. When considering a state, we\r\ncan split all cards into two types: the ones that make us lose a coin\r\nwhen we play them (group ), and all the others (group ). First, let\u00e2\u0080\u0099s\r\ntry to play two cards from the group ; if we find a combination of them\r\nsuch that, after playing it, we never have different cards in our hand ,\r\nbecause this transition updates the answer directly without any\r\nincreases. Otherwise, perform all transitions with pairs of cards from\r\ngroup , and try to play a pair of cards from different groups. If we\r\nfind a combination that updates the answer directly, we again can stop\r\nconsidering transitions, the next transitions we use won\u00e2\u0080\u0099t be more\r\noptimal. And then we do the same with transitions where we use a pair of\r\ncards of group . This way, we will consider at most transitions from\r\neach state.Combining these two optimizations results in a solution in or\r\n, but there are other optimizations you can try.\r\n",
    "name": "F. Card Pairing",
    "statement": "There is a deck of n cards, each card has one of k types. You are given\r\nthe sequence a_1, a_2,\r\ndots, a_n denoting the types of cards in the deck from top to bottom.\r\nBoth n and k are even numbers.You play a game with these cards. First,\r\nyou draw k topmost cards from the deck. Then, the following happens each\r\nturn of the game: you choose two cards from your hand and play them. If\r\nthese cards have the same type, you earn a coin; then, if the deck is\r\nnot empty, you draw two top cards from it; then, if both your hand and\r\nyour deck are empty, the game ends. Otherwise, the new turn begins. You\r\nhave to calculate the maximum number of coins you can earn during the\r\ngame.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"#pragma GCC optimize (\"O3\")#pragma GCC target (\"sse4\") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd;\u00a0template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert\u00a0template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\u00a0void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << '\\'' << x << '\\'';}void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}void __print(bool x) {cerr << (x ? \"true\" : \"false\");}\u00a0template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}template<typename T>void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}void _print() {cerr << \"]\\n\";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;#else#define dbg(x...)#endif\u00a0\u00a0const int MOD = 1000000007;const char nl = '\\n';const int MX = 100001; \u00a0set<int> cur;\u00a0void flip(int X) {    if (cur.count(X)) {        cur.erase(X);    } else cur.ins(X);}\u00a0void solve() {    int N, K; cin >> N >> K;    vi A(N); F0R(i, N) cin >> A[i];    F0R(i, N) A[i]--;    F0R(i, K) flip(A[i]);    int dp[(N-K)/2 + 1];    F0R(i, (N-K)/2 + 1) dp[i] = MX;    F0R(i, (N-K)/2) {        if (sz(cur) == K) {            dp[i] = 0;            goto done;        }        flip(A[K+i*2]); flip(A[K+i*2+1]);    }    dp[(N-K)/2] = 0;    done:    ;\u00a0    F0R(i, (N-K)/2) {        bool ev[K]; F0R(j, K) ev[j] = false;        FOR(j, K+i*2, N) {            ev[A[j]] = !ev[A[j]];        }        cur.clear();        int cOdd = K, cEv = 0;        F0R(i, K) if (ev[i]) {            cEv++; cOdd--;        }        int c0 = (cOdd * (cOdd - 1)) / 2;        int c1 = cOdd * cEv;        int c2 = (cEv * (cEv - 1)) / 2;        set<pi> used;        FOR(j, i+1, (N-K)/2) {            flip(A[K+j*2-2]); flip(A[K+j*2-1]);            if (sz(cur) == 2) {                pi cp = {*cur.begin(), *cur.rbegin()};                if (used.count(cp)) continue;                if (!ev[cp.f] && !ev[cp.s]) {                    c0--;                } else if (ev[cp.f] && ev[cp.s]) {                    c2--;                } else c1--;                used.ins(cp);                int cv = dp[i];                if (ev[*cur.begin()]) cv++;                if (ev[*cur.rbegin()]) cv++;                ckmin(dp[j], cv);            }        }        if (c0) {            ckmin(dp[(N-K)/2], dp[i]);        } else if (c1) {            ckmin(dp[(N-K)/2], dp[i] + 1);        } else if (c2) {            ckmin(dp[(N-K)/2], dp[i] + 2);        }    }\u00a0    cur.clear();    F0R(i, N) flip(A[i]);    cout << (N-sz(cur))/2 - dp[(N-K)/2] << nl;\u00a0\u00a0} int main() {    ios_base::sync_with_stdio(0); cin.tie(0);\u00a0    int T = 1;//    cin >> T;    while(T--) {        solve();    }\u00a0\treturn 0;}\u00a0\u00a0"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "hashing",
        "implementation"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Card Pairing.json"
}