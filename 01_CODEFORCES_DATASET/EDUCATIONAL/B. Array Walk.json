{
    "link": "https://codeforces.com//contest/1389/problem/B",
    "problemId": "686123",
    "problem_idx": "B",
    "shortId": "1389B",
    "contest_number": "1389",
    "problem_submissions": {
        "F": [
            88348682,
            88338153,
            88328943,
            88335897,
            88333690,
            88373314,
            88373278,
            88339376,
            88563610,
            88324437,
            88323357,
            90193331,
            88370216,
            88338670,
            88346193,
            88335414,
            88340450,
            88343043,
            88354834,
            88350683,
            88354635,
            88351121,
            88341928,
            88353006,
            88617212,
            88617191,
            88616644,
            88339094
        ],
        "G": [
            88341915,
            88358421,
            88361866,
            88360257,
            88360333,
            88361126,
            88563627,
            88370757,
            88366719,
            88625823,
            88368266
        ],
        "E": [
            88316360,
            88314884,
            88313039,
            88320696,
            88327221,
            88331067,
            88563585,
            88316358,
            88316429,
            88316758,
            88324617,
            88315489,
            88322575,
            88325697,
            88318058,
            88335501,
            88333747,
            88335296,
            88331670,
            88336084,
            88330920
        ],
        "D": [
            88313541,
            88323588,
            88322172,
            88317239,
            88320907,
            88324683,
            88563559,
            88313756,
            88311946,
            88313492,
            88320253,
            88324924,
            88317796,
            88320516,
            88314433,
            88325709,
            88322521,
            88323822,
            88326845,
            88325546,
            88326242
        ],
        "C": [
            88305803,
            88306793,
            88305781,
            88311961,
            88313905,
            88313498,
            88563542,
            88308288,
            88306505,
            88301578,
            88306622,
            88310987,
            88310892,
            88306012,
            88305081,
            88310508,
            88309198,
            88313956,
            88307817,
            88312102,
            88315317
        ],
        "B": [
            88302673,
            88302689,
            88302324,
            88309761,
            88336897,
            88305352,
            88563516,
            88305445,
            88304272,
            88310119,
            88303921,
            88308221,
            88312057,
            88313228,
            88301014,
            88307222,
            88306963,
            88309964,
            88398537,
            88306205,
            88308367,
            88311740
        ],
        "A": [
            88294762,
            88294889,
            88294798,
            88296225,
            88294786,
            88295833,
            88563453,
            88295598,
            88294725,
            88294981,
            88294767,
            88294779,
            88295244,
            88294853,
            88294700,
            88297412,
            88295036,
            88299886,
            88294845,
            88296400,
            88294879
        ]
    },
    "name": "B. Array Walk",
    "statement": "You are given an array a_1, a_2,\r\ndots, a_n, consisting of n integers. Initially you are standing at index\r\n1 and have a score equal to a_1. You can perform two kinds of moves:\r\nmove right go from your current index x to x+1 and add a_{x+1} to your\r\nscore. This move can only be performed if x<n. move left go from your\r\ncurrent index x to x-1 and add a_{x-1} to your score. This move can only\r\nbe performed if x>1. You want to perform k moves. Also, there should be\r\nno more than z moves to the left among them.What is the maximum score\r\nyou can achieve?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int INF = (int)1e9 + (int)1e8;\nconst int N = 100100;\nconst int K = 7;\nint n, m, k;\nint a[N];\nint dp[N][K][2];\n\nvoid solve() {\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tfor (int i = 0; i <= m; i++)\n\t\tfor (int j = 0; j <= k; j++)\n\t\t\tfor (int h = 0; h < 2; h++)\n\t\t\t\tdp[i][j][h] = -INF;\n\tdp[0][0][0] = a[0];\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int x = 0; x <= k; x++)\n\t\t\tfor (int f = 0; f < 2; f++) {\n\t\t\t\tif (dp[i][x][f] == -INF) continue;\n\t\t\t\tfor (int g = 0; g < 2; g++) {\n\t\t\t\t\tif (f & g) continue;\n\t\t\t\t\tif (x + g > k) continue;\n\t\t\t\t\tint pos = i + 1 - 2 * (x + g);\n\t\t\t\t\tif (pos < 0 || pos >= n) continue;\n\t\t\t\t\tdp[i + 1][x + g][g] = max(dp[i + 1][x + g][g], dp[i][x][f] + a[pos]);\n\t\t\t\t}\n\t\t\t}\n\tint ans = -INF;\n\tfor (int i = 0; i <= k; i++)\n\t\tfor (int j = 0; j < 2; j++)\n\t\t\tans = max(ans, dp[m][i][j]);\n\tprintf(\"%d\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Array Walk.json",
    "editorial_link": "https://codeforces.com//blog/entry/80809",
    "editorial": "Notice that your final position is determined by the number of moves to\r\nthe left you make. Let there be exactly moves to the left, that leaves\r\nus with moves to the right. However, let\u00e2\u0080\u0099s interpret this the other way.\r\nYou have pairs of moves (right, left) to insert somewhere inside the\r\nsequence of moves to the right.Easy to see that all the positions from\r\nto will always be visited. And the extra pairs can also increase the\r\nscore by visiting some positions (, ) for some from to .Notice that it\u00e2\u0080\u0099s\r\nalways optimal to choose exactly the same for all the pairs (right,\r\nleft). And that should be such that is maximum possible.You can\r\nimplement this idea in a straightforward manner: iterate over and\r\ncalculate the sum of values from to and the maximum value of over from\r\nto .That will lead to a solution per testcase.You can optimize it to\r\nwith prefix sums or with some clever order to iterate over . It\u00e2\u0080\u0099s also\r\npossible to iterate over the final position and restore the number of\r\nleft moves required to achieve it.Overall complexity: or per testcase.\r\n"
}