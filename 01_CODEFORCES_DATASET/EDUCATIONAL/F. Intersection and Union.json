{
    "link": "https://codeforces.com//contest/1743/problem/F",
    "problemId": "1590321",
    "problem_idx": "F",
    "shortId": "1743F",
    "contest_number": "1743",
    "problem_submissions": {
        "G": [
            176744926,
            176752632,
            176765710,
            176759446,
            176826731,
            176825958,
            176825876,
            176825841,
            176825795,
            176825757,
            176777747,
            176767399,
            176787833,
            176794001,
            176793915,
            176793787,
            176793693,
            176793601,
            176793457,
            176793414,
            176793075,
            176792582,
            176790966,
            176790830,
            176790739,
            176790602,
            176790480,
            176790442,
            176790394,
            176877236,
            176797381,
            177041275
        ],
        "F": [
            176737097,
            176733706,
            176744244,
            176746662,
            176734362,
            176741223,
            176737910,
            176729577,
            176742322,
            176771541,
            176747634,
            176866127,
            176744359,
            176742533,
            176764904,
            176749314,
            176748844,
            176759565,
            176751246,
            176746192,
            176742294,
            176760205
        ],
        "E": [
            176732507,
            176757486,
            176736176,
            176739966,
            176749212,
            176748013,
            176727666,
            176739006,
            176729866,
            176763689,
            176763186,
            176762781,
            176756640,
            176764718,
            176740887,
            176756959,
            176787283,
            176742950,
            176761500,
            176766019,
            176770369,
            176749818
        ],
        "D": [
            176723746,
            176718140,
            176716615,
            176721411,
            176719450,
            176723698,
            176718782,
            176720745,
            176721715,
            176722102,
            176729581,
            176725500,
            176730292,
            176719597,
            176730936,
            176731941,
            176724207,
            176723731,
            176736911
        ],
        "C": [
            176716029,
            176704815,
            176706962,
            176708929,
            176705118,
            176704124,
            176715109,
            176705993,
            176708271,
            176707432,
            176707937,
            176714968,
            176710289,
            176708841,
            176705755,
            176710426,
            176713787,
            176707796,
            176708736,
            176710057
        ],
        "B": [
            176712751,
            176699478,
            176698683,
            176699488,
            176698322,
            176698046,
            176699875,
            176699384,
            176699501,
            176699739,
            176704430,
            176700303,
            176700238,
            176699124,
            176702452,
            176707386,
            176700133,
            176698867,
            176703708
        ],
        "A": [
            176712234,
            176698003,
            176697838,
            176697817,
            176697799,
            176697771,
            176697968,
            176697810,
            176698111,
            176698066,
            176699952,
            176697901,
            176698001,
            176697928,
            176699293,
            176697926,
            176697958,
            176697832,
            176698850
        ]
    },
    "name": "F. Intersection and Union",
    "statement": "You are given n segments on the coordinate axis. The i-th segment is\r\n[l_i, r_i]. Letâ€™s denote the set of all integer points belonging to the\r\ni-th segment as S_i.Let A\r\ncup B be the union of two sets A and B, A\r\ncap B be the intersection of two sets A and B, and A\r\noplus B be the symmetric difference of A and B (a set which contains all\r\nelements of A and all elements of B, except for the ones that belong to\r\nboth sets).Let [\r\nmathbin{op}_1,\r\nmathbin{op}_2,\r\ndots,\r\nmathbin{op}_{n-1}] be an array where each element is either\r\ncup,\r\noplus, or\r\ncap. Over all 3^{n-1} ways to choose this array, calculate the sum of\r\nthe following values:|(((S_1\r\nmathbin{op}_1\r\nS_2)\r\nmathbin{op}_2\r\nS_3)\r\nmathbin{op}_3\r\nS_4)\r\ndots\r\nmathbin{op}_{n-1}\r\nS_n|In this expression, |S| denotes the size of the set S.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int P = 998244353;\nusing i64 = long long;\n// assume -P <= x < 2P\nint norm(int x) {\n    if (x < 0) {\n        x += P;\n    }\n    if (x >= P) {\n        x -= P;\n    }\n    return x;\n}\ntemplate<class T>\nT power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\nstruct Z {\n    int x;\n    Z(int x = 0) : x(norm(x)) {}\n    Z(i64 x) : x(norm(x % P)) {}\n    int val() const {\n        return x;\n    }\n    Z operator-() const {\n        return Z(norm(P - x));\n    }\n    Z inv() const {\n        assert(x != 0);\n        return power(*this, P - 2);\n    }\n    Z &operator*=(const Z &rhs) {\n        x = i64(x) * rhs.x % P;\n        return *this;\n    }\n    Z &operator+=(const Z &rhs) {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    Z &operator-=(const Z &rhs) {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    Z &operator/=(const Z &rhs) {\n        return *this *= rhs.inv();\n    }\n    friend Z operator*(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend Z operator+(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend Z operator-(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend Z operator/(const Z &lhs, const Z &rhs) {\n        Z res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend std::istream &operator>>(std::istream &is, Z &a) {\n        i64 v;\n        is >> v;\n        a = Z(v);\n        return is;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const Z &a) {\n        return os << a.val();\n    }\n};template<class Info,\n    class Merge = std::plus<Info>>\nstruct SegmentTree {\n    const int n;\n    const Merge merge;\n    std::vector<Info> info;\n    SegmentTree(int n) : n(n), merge(Merge()), info(4 << std::__lg(n)) {}\n    SegmentTree(std::vector<Info> init) : SegmentTree(init.size()) {\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                info[p] = init[l];\n                return;\n            }\n            int m = (l + r) / 2;\n            build(2 * p, l, m);\n            build(2 * p + 1, m, r);\n            pull(p);\n        };\n        build(1, 0, n);\n    }\n    void pull(int p) {\n        info[p] = merge(info[2 * p], info[2 * p + 1]);\n    }\n    void modify(int p, int l, int r, int x, const Info &v) {\n        if (r - l == 1) {\n            info[p] = v;\n            return;\n        }\n        int m = (l + r) / 2;\n        if (x < m) {\n            modify(2 * p, l, m, x, v);\n        } else {\n            modify(2 * p + 1, m, r, x, v);\n        }\n        pull(p);\n    }\n    void modify(int p, const Info &v) {\n        modify(1, 0, n, p, v);\n    }\n    Info rangeQuery(int p, int l, int r, int x, int y) {\n        if (l >= y || r <= x) {\n            return Info();\n        }\n        if (l >= x && r <= y) {\n            return info[p];\n        }\n        int m = (l + r) / 2;\n        return merge(rangeQuery(2 * p, l, m, x, y), rangeQuery(2 * p + 1, m, r, x, y));\n    }\n    Info rangeQuery(int l, int r) {\n        return rangeQuery(1, 0, n, l, r);\n    }\n};\n\nstruct Matrix {\n    Z a[2][2];\n};\n\nMatrix operator+(const Matrix &a, const Matrix &b) {\n    Matrix c;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            for (int k = 0; k < 2; k++) {\n                c.a[i][j] += a.a[i][k] * b.a[k][j];\n            }\n        }\n    }\n    return c;\n}\n\nMatrix M0, M1;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    M0.a[0][0] = 3;\n    M0.a[0][1] = 0;\n    M0.a[1][0] = 1;\n    M0.a[1][1] = 2;\n    \n    M1.a[0][0] = 1;\n    M1.a[0][1] = 2;\n    M1.a[1][0] = 1;\n    M1.a[1][1] = 2;\n    \n    int n;\n    std::cin >> n;\n    \n    std::vector<int> l(n), r(n);\n    int max = 0;\n    for (int i = 0; i < n; i++) {\n        std::cin >> l[i] >> r[i];\n        max = std::max(max, r[i]);\n    }\n    \n    max++;\n    std::vector<std::vector<int>> add(max), del(max);\n    for (int i = 0; i < n; i++) {\n        add[l[i]].push_back(i);\n        del[r[i]].push_back(i);\n    }\n    \n    int a0 = 0;\n    \n    SegmentTree<Matrix> seg(std::vector(n - 1, M0));\n    \n    Z ans = 0;\n    \n    for (int i = 0; i < max; i++) {\n        for (auto j : add[i]) {\n            if (j) {\n                seg.modify(j - 1, M1);\n            } else {\n                a0 = 1;\n            }\n        }\n        ans += seg.info[1].a[a0][1];\n        for (auto j : del[i]) {\n            if (j) {\n                seg.modify(j - 1, M0);\n            } else {\n                a0 = 0;\n            }\n        }\n    }\n    \n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "matrices",
        "probabilities"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Intersection and Union.json",
    "editorial_link": "https://codeforces.com//blog/entry/108153",
    "editorial": "We will use the Contribution to the Sum technique to solve this problem:\r\nfor every integer from to , letÃ¢Â€Â™s calculate the number of ways to choose\r\nthe operators so it belongs to the result, and add all of the\r\nresults.For a fixed integer , the number of ways to choose the operators\r\nso that belongs to the result can be done as follows: let be the number\r\nof ways to choose the first operators so that, after applying them, the\r\nresulting set contains if , and does not contain if . The transitions\r\nfrom to depend on whether the number belongs to the segment .Obviously,\r\nthis is too slow if we compute the dynamic programming from scratch for\r\nevery integer . Instead, we can notice that the transitions from to are\r\nlinear combinations: both and are linear combinations of and with\r\ncoefficients depending on whether the element belongs to the set or not.\r\nSo, transitioning from to can be written in terms of multiplying by a\r\nmatrix.LetÃ¢Â€Â™s build a segment tree where each vertex stores a transition\r\nmatrix, and operations are \"calculate the product of matrices on a\r\nsegment\" and \"replace a matrix at some index\". We can build a sequence\r\nof these transition matrices for and store them in the segment tree; for\r\n, this sequence of transition matrices will change only in positions\r\nsuch that either belongs to and does not belong to it, or vice versa.\r\nSo, we can go from to by replacing these transition matrices in the\r\nsegment tree. For , the only changes from are in positions such that\r\neither belongs to and does not belong to it, or vice versa and we can\r\nreplace the matrices in these positions as well. In total, there will be\r\nonly such replacements; so, we solve the problem in , where is the\r\nconstraint on the numbers belonging to the sets.\r\n",
    "hint": []
}