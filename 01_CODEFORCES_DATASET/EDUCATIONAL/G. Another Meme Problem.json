{
    "link": "https://codeforces.com//contest/1194/problem/G",
    "problemId": "372221",
    "problem_idx": "G",
    "shortId": "1194G",
    "contest_number": "1194",
    "problem_submissions": {
        "E": [
            57460080,
            57035519,
            57036170,
            57036063,
            57128801,
            57128706,
            57128697,
            57128659,
            57128612,
            57128540,
            57128243,
            57128111,
            57036122,
            57038525,
            57047818,
            57039795,
            57039479,
            57042294,
            57040196,
            57036224,
            57042239,
            57040076,
            57104697,
            57102024,
            57101946,
            57062641,
            57042300,
            57042350,
            57042204,
            57055044,
            57053556,
            57046934,
            57046549,
            57042532
        ],
        "A": [
            57046342,
            57022752,
            57022576,
            57022542,
            57022673,
            57022779,
            57022508,
            57024885,
            57022776,
            57023918,
            57022665,
            57023995,
            57022524,
            57022685,
            57028419,
            57027614,
            57022718,
            57022691,
            57023076,
            57024152
        ],
        "B": [
            57046133,
            57024457,
            57023825,
            57024116,
            57024620,
            57026379,
            57024611,
            57023215,
            57025344,
            57025498,
            57024993,
            57026889,
            57024968,
            57025445,
            57030710,
            57029529,
            57024907,
            57024604,
            57025406,
            57027222
        ],
        "C": [
            57045626,
            57025890,
            57026227,
            57026533,
            57026651,
            57028509,
            57026843,
            57027145,
            57026992,
            57027849,
            57027432,
            57029395,
            57027548,
            57028521,
            57032512,
            57032102,
            57027763,
            57027180,
            57027134,
            57031699
        ],
        "G": [
            57044495,
            57124672,
            57083729,
            57083446,
            57083302,
            57051811,
            144563243,
            57059946,
            57059836,
            57059526,
            57059380,
            57058688,
            57057384,
            66619078,
            66618958,
            66618872,
            57059217,
            57080922,
            57079990,
            57079590,
            57079506,
            99043474,
            99036226
        ],
        "F": [
            57028516,
            57040353,
            57042500,
            57037960,
            57127884,
            57047571,
            57045756,
            57041898,
            57051035,
            57048196,
            57045806,
            57053225,
            57047719,
            57051194,
            57063470,
            57052822,
            57047382,
            57051062,
            57040128,
            57052740,
            57051156,
            57053947,
            57051969
        ],
        "D": [
            57026382,
            57028806,
            57032441,
            57028933,
            57029747,
            57030899,
            57031250,
            57031182,
            57036191,
            57030939,
            57039325,
            57034516,
            57033749,
            57033063,
            57035777,
            57036535,
            57031217,
            57033511,
            57038656,
            57037146
        ]
    },
    "name": "G. Another Meme Problem",
    "statement": "Let’s call a fraction\r\nfrac{x}{y} good if there exists at least one another fraction\r\nfrac{x’}{y’} such that\r\nfrac{x}{y} =\r\nfrac{x’}{y’}, 1\r\nle x’, y’\r\nle 9, the digit denoting x’ is contained in the decimal representation\r\nof x, and the digit denoting y’ is contained in the decimal\r\nrepresentation of y. For example,\r\nfrac{26}{13} is a good fraction, because\r\nfrac{26}{13} =\r\nfrac{2}{1}.You are given an integer number n. Please calculate the\r\nnumber of good fractions\r\nfrac{x}{y} such that 1\r\nle x\r\nle n and 1\r\nle y\r\nle n. The answer may be really large, so print it modulo 998244353.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\n// base and base_digits must be consistent\nconstexpr int base = 1000000000;\nconstexpr int base_digits = 9;\n\nstruct bigint {\n    // value == 0 is represented by empty z\n    vector<int> z; // digits\n\n    // sign == 1 <==> value >= 0\n    // sign == -1 <==> value < 0\n    int sign;\n\n    bigint() : sign(1) {}\n    bigint(long long v) { *this = v; }\n\n    bigint &operator=(long long v) {\n        sign = v < 0 ? -1 : 1; v *= sign;\n        z.clear(); for (; v > 0; v = v / base) z.push_back((int) (v % base));\n        return *this;\n    }\n\n    bigint(const string &s) { read(s); }\n\n    bigint &operator+=(const bigint &other) {\n        if (sign == other.sign) {\n            for (int i = 0, carry = 0; i < other.z.size() || carry; ++i) {\n                if (i == z.size())\n                    z.push_back(0);\n                z[i] += carry + (i < other.z.size() ? other.z[i] : 0);\n                carry = z[i] >= base;\n                if (carry)\n                    z[i] -= base;\n            }\n        } else if (other != 0 /* prevent infinite loop */) {\n            *this -= -other;\n        }\n        return *this;\n    }\n\n    friend bigint operator+(bigint a, const bigint &b) { return a += b; }\n\n    bigint &operator-=(const bigint &other) {\n        if (sign == other.sign) {\n            if (sign == 1 && *this >= other || sign == -1 && *this <= other) {\n                for (int i = 0, carry = 0; i < other.z.size() || carry; ++i) {\n                    z[i] -= carry + (i < other.z.size() ? other.z[i] : 0);\n                    carry = z[i] < 0;\n                    if (carry)\n                        z[i] += base;\n                }\n                trim();\n            } else {\n                *this = other - *this;\n                this->sign = -this->sign;\n            }\n        } else {\n            *this += -other;\n        }\n        return *this;\n    }\n\n    friend bigint operator-(bigint a, const bigint &b) { return a -= b; }\n\n    bigint &operator*=(int v) {\n        if (v < 0) sign = -sign, v = -v;\n        for (int i = 0, carry = 0; i < z.size() || carry; ++i) {\n            if (i == z.size())\n                z.push_back(0);\n            long long cur = (long long) z[i] * v + carry;\n            carry = (int) (cur / base);\n            z[i] = (int) (cur % base);\n        }\n        trim();\n        return *this;\n    }\n\n    bigint operator*(int v) const { return bigint(*this) *= v; }\n\n    friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {\n        int norm = base / (b1.z.back() + 1);\n        bigint a = a1.abs() * norm;\n        bigint b = b1.abs() * norm;\n        bigint q, r;\n        q.z.resize(a.z.size());\n\n        for (int i = (int) a.z.size() - 1; i >= 0; i--) {\n            r *= base;\n            r += a.z[i];\n            int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;\n            int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;\n            int d = (int) (((long long) s1 * base + s2) / b.z.back());\n            r -= b * d;\n            while (r < 0)\n                r += b, --d;\n            q.z[i] = d;\n        }\n\n        q.sign = a1.sign * b1.sign;\n        r.sign = a1.sign;\n        q.trim();\n        r.trim();\n        return {q, r / norm};\n    }\n\n    friend bigint sqrt(const bigint &a1) {\n        bigint a = a1;\n        while (a.z.empty() || a.z.size() % 2 == 1)\n            a.z.push_back(0);\n\n        int n = a.z.size();\n\n        int firstDigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]);\n        int norm = base / (firstDigit + 1);\n        a *= norm;\n        a *= norm;\n        while (a.z.empty() || a.z.size() % 2 == 1)\n            a.z.push_back(0);\n\n        bigint r = (long long) a.z[n - 1] * base + a.z[n - 2];\n        firstDigit = (int) ::sqrt((double) a.z[n - 1] * base + a.z[n - 2]);\n        int q = firstDigit;\n        bigint res;\n\n        for (int j = n / 2 - 1; j >= 0; j--) {\n            for (;; --q) {\n                bigint r1 = (r - (res * 2 * base + q) * q) * base * base +\n                            (j > 0 ? (long long) a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);\n                if (r1 >= 0) {\n                    r = r1;\n                    break;\n                }\n            }\n            res *= base;\n            res += q;\n\n            if (j > 0) {\n                int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;\n                int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;\n                int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;\n                q = (int) (((long long) d1 * base * base + (long long) d2 * base + d3) / (firstDigit * 2));\n            }\n        }\n\n        res.trim();\n        return res / norm;\n    }\n\n    bigint operator/(const bigint &v) const { return divmod(*this, v).first; }\n\n    bigint operator%(const bigint &v) const { return divmod(*this, v).second; }\n\n    bigint &operator/=(int v) {\n        if (v < 0) sign = -sign, v = -v;\n        for (int i = (int) z.size() - 1, rem = 0; i >= 0; --i) {\n            long long cur = z[i] + rem * (long long) base;\n            z[i] = (int) (cur / v);\n            rem = (int) (cur % v);\n        }\n        trim();\n        return *this;\n    }\n\n    bigint operator/(int v) const { return bigint(*this) /= v; }\n\n    int operator%(int v) const {\n        if (v < 0) v = -v;\n        int m = 0;\n        for (int i = (int) z.size() - 1; i >= 0; --i)\n            m = (int) ((z[i] + m * (long long) base) % v);\n        return m * sign;\n    }\n\n    bigint &operator*=(const bigint &v) { return *this = *this * v; }\n    bigint &operator/=(const bigint &v) { return *this = *this / v; }\n\n    bool operator<(const bigint &v) const {\n        if (sign != v.sign)\n            return sign < v.sign;\n        if (z.size() != v.z.size())\n            return z.size() * sign < v.z.size() * v.sign;\n        for (int i = (int) z.size() - 1; i >= 0; i--)\n            if (z[i] != v.z[i])\n                return z[i] * sign < v.z[i] * sign;\n        return false;\n    }\n\n    bool operator>(const bigint &v) const { return v < *this; }\n    bool operator<=(const bigint &v) const { return !(v < *this); }\n    bool operator>=(const bigint &v) const { return !(*this < v); }\n\n    bool operator==(const bigint &v) const { return !(*this < v) && !(v < *this); }\n\n    bool operator!=(const bigint &v) const { return *this < v || v < *this; }\n\n    void trim() {\n        while (!z.empty() && z.back() == 0) z.pop_back();\n        if (z.empty()) sign = 1;\n    }\n\n    bool isZero() const { return z.empty(); }\n\n    friend bigint operator-(bigint v) {\n        if (!v.z.empty()) v.sign = -v.sign;\n        return v;\n    }\n\n    bigint abs() const {\n        return sign == 1 ? *this : -*this;\n    }\n\n    long long longValue() const {\n        long long res = 0;\n        for (int i = (int) z.size() - 1; i >= 0; i--)\n            res = res * base + z[i];\n        return res * sign;\n    }\n\n    friend bigint gcd(const bigint &a, const bigint &b) {\n        return b.isZero() ? a : gcd(b, a % b);\n    }\n\n    friend bigint lcm(const bigint &a, const bigint &b) {\n        return a / gcd(a, b) * b;\n    }\n\n    void read(const string &s) {\n        sign = 1;\n        z.clear();\n        int pos = 0;\n        while (pos < s.size() && (s[pos] == '-' || s[pos] == '+')) {\n            if (s[pos] == '-')\n                sign = -sign;\n            ++pos;\n        }\n        for (int i = (int) s.size() - 1; i >= pos; i -= base_digits) {\n            int x = 0;\n            for (int j = max(pos, i - base_digits + 1); j <= i; j++)\n                x = x * 10 + s[j] - '0';\n            z.push_back(x);\n        }\n        trim();\n    }\n\n    friend istream &operator>>(istream &stream, bigint &v) {\n        string s; stream >> s;\n        v.read(s);\n        return stream;\n    }\n\n    friend ostream &operator<<(ostream &stream, const bigint &v) {\n        if (v.sign == -1)\n            stream << '-';\n        stream << (v.z.empty() ? 0 : v.z.back());\n        for (int i = (int) v.z.size() - 2; i >= 0; --i)\n            stream << setw(base_digits) << setfill('0') << v.z[i];\n        return stream;\n    }\n\n    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {\n        vector<long long> p(max(old_digits, new_digits) + 1);\n        p[0] = 1;\n        for (int i = 1; i < p.size(); i++)\n            p[i] = p[i - 1] * 10;\n        vector<int> res;\n        long long cur = 0;\n        int cur_digits = 0;\n        for (int v : a) {\n            cur += v * p[cur_digits];\n            cur_digits += old_digits;\n            while (cur_digits >= new_digits) {\n                res.push_back(int(cur % p[new_digits]));\n                cur /= p[new_digits];\n                cur_digits -= new_digits;\n            }\n        }\n        res.push_back((int) cur);\n        while (!res.empty() && res.back() == 0)\n            res.pop_back();\n        return res;\n    }\n\n    typedef vector<long long> vll;\n\n    static vll karatsubaMultiply(const vll &a, const vll &b) {\n        int n = a.size();\n        vll res(n + n);\n        if (n <= 32) {\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    res[i + j] += a[i] * b[j];\n            return res;\n        }\n\n        int k = n >> 1;\n        vll a1(a.begin(), a.begin() + k);\n        vll a2(a.begin() + k, a.end());\n        vll b1(b.begin(), b.begin() + k);\n        vll b2(b.begin() + k, b.end());\n\n        vll a1b1 = karatsubaMultiply(a1, b1);\n        vll a2b2 = karatsubaMultiply(a2, b2);\n\n        for (int i = 0; i < k; i++)\n            a2[i] += a1[i];\n        for (int i = 0; i < k; i++)\n            b2[i] += b1[i];\n\n        vll r = karatsubaMultiply(a2, b2);\n        for (int i = 0; i < a1b1.size(); i++)\n            r[i] -= a1b1[i];\n        for (int i = 0; i < a2b2.size(); i++)\n            r[i] -= a2b2[i];\n\n        for (int i = 0; i < r.size(); i++)\n            res[i + k] += r[i];\n        for (int i = 0; i < a1b1.size(); i++)\n            res[i] += a1b1[i];\n        for (int i = 0; i < a2b2.size(); i++)\n            res[i + n] += a2b2[i];\n        return res;\n    }\n\n    bigint operator*(const bigint &v) const {\n        vector<int> a6 = convert_base(this->z, base_digits, 6);\n        vector<int> b6 = convert_base(v.z, base_digits, 6);\n        vll a(a6.begin(), a6.end());\n        vll b(b6.begin(), b6.end());\n        while (a.size() < b.size())\n            a.push_back(0);\n        while (b.size() < a.size())\n            b.push_back(0);\n        while (a.size() & (a.size() - 1))\n            a.push_back(0), b.push_back(0);\n        vll c = karatsubaMultiply(a, b);\n        bigint res;\n        res.sign = sign * v.sign;\n        for (int i = 0, carry = 0; i < c.size(); i++) {\n            long long cur = c[i] + carry;\n            res.z.push_back((int) (cur % 1000000));\n            carry = (int) (cur / 1000000);\n        }\n        res.z = convert_base(res.z, 6, base_digits);\n        res.trim();\n        return res;\n    }\n\n};\n\nbigint random_bigint(int n) {\n    string s;\n    for (int i = 0; i < n; i++) {\n        s += rand() % 10 + '0';\n    }\n    return bigint(s);\n}\n\n// random tests\nvoid bigintTest() {\n    bigint x = bigint(\"120\");\n    bigint y = bigint(\"5\");\n    cout << x / y << endl;\n\n    for (int i = 0; i < 1000; i++) {\n        int n = rand() % 100 + 1;\n        bigint a = random_bigint(n);\n        bigint res = sqrt(a);\n        bigint xx = res * res;\n        bigint yy = (res + 1) * (res + 1);\n\n        if (xx > a || yy <= a) {\n            cout << i << endl;\n            cout << a << \" \" << res << endl;\n            break;\n        }\n\n        int m = rand() % n + 1;\n        bigint b = random_bigint(m) + 1;\n        res = a / b;\n        xx = res * b;\n        yy = b * (res + 1);\n\n        if (xx > a || yy <= a) {\n            cout << i << endl;\n            cout << a << \" \" << b << \" \" << res << endl;\n            break;\n        }\n    }\n\n    bigint a = random_bigint(10000);\n    bigint b = random_bigint(2000);\n    clock_t start = clock();\n    bigint c = a / b;\n    printf(\"time=%.3lfsec\\n\", (clock() - start) * 1. / CLOCKS_PER_SEC);\n}\n\nstring str(bigint b) {\n\tstringstream ss; ss << b;\n\tstring s; ss >> s;\n\treturn s;\n}\n\nstring n;\nbigint B;\n\nmi dp(string x, int a, int b, vpi v) {\n\t// ps(\"WUT\",x,a,b,v);\n\tarray<map<pair<pi,int>,mi>,3> dp;\n\tdp[1][{{0,0},0}] = 1;\n\treverse(all(x)); x += '0';\n\tF0R(i,sz(x)) {\n\t\tarray<map<pair<pi,int>,mi>,3> DP;\n\t\tF0R(q,10) F0R(j,3) {\n\t\t\tint ind = MOD;\n\t\t\tif (q > x[i]-'0') ind = 2;\n\t\t\telse if (q == x[i]-'0') ind = j;\n\t\t\telse ind = 0;\n\t\t\ttrav(t,dp[j]) {\n\t\t\t\tint A = t.f.f.f+q*a;\n\t\t\t\tint B = t.f.f.s+q*b;\n\t\t\t\tint cur = t.f.s;\n\t\t\t\tF0R(z,sz(v)) {\n\t\t\t\t\tif (cur == -1) break;\n\t\t\t\t\tif (A%10 == v[z].f) cur |= 1<<(2*z);\n\t\t\t\t\tif (B%10 == v[z].s) cur |= 1<<(2*z+1);\n\t\t\t\t\tif (((cur>>(2*z))&3) == 3) cur = -1;\n\t\t\t\t}\n\t\t\t\tDP[ind][{{A/10,B/10},cur}] += t.s;\n\t\t\t}\n\t\t}\n\t\tswap(dp,DP);\n\t}\n\tmi ans = 0;\n\ttrav(t,dp[1]) {\n\t\tassert(t.f.f == mp(0,0));\n\t\tif (t.f.s == -1) ans += t.s;\n\t}\n\ttrav(t,dp[0]) {\n\t\tassert(t.f.f == mp(0,0));\n\t\tif (t.f.s == -1) ans += t.s;\n\t}\n\t// ps(\"HA\",ans); exit(0);\n\treturn ans;\n}\n\nmi solve(int a, int b) {\n\tif (a == b) return B%MOD;\n\tvpi v;\n\tfor (int i = 1; i*b < 10; i++) v.pb({a*i,b*i});\n\tauto mx = B/b;\n\treturn dp(str(mx),a,b,v);\n}\n\nint main() {\n    setIO(); re(n); B = bigint(n);\n\tmi ans = 0;\n    FOR(i,1,10) FOR(j,i,10) if (__gcd(i,j) == 1) {\n    \t// ps(\"??\",i,j);\n    \tmi z = solve(i,j);\n    \tif (i != j) ans += 2*z;\n    \telse ans += z;\n    \t// ps(\"HUH\",i,j,ans);\n    }\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Another Meme Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/68405",
    "editorial": "Letâs fix an fraction such that . Obviously, each good fraction is equal\r\nto exactly one of such irreducible fractions. So if we iterate on and ,\r\ncheck that and find the number of good fractions that are equal to , we\r\nwill solve the problem.Okay, suppose we fixed and . Any good fraction\r\ncan be represented as , where is some positive integer. Letâs try all\r\npossible values of , and for them check whether they correspond to a\r\ngood fraction.How do we try all values of without iterating on them?\r\nLetâs construct the decimal representation of from the least significant\r\ndigit to the most. As soon as we fix least significant digits of , we\r\nknow least significant digits of and . So letâs try to use digit DP to\r\ntry all possible values of .Which states do we have to consider? Of\r\ncourse, we need to know the number of digits we already placed, so that\r\nwill be the first state. After we placed digits, we know first digits of\r\nthe numerator of the fraction; but to get the value of digit , knowing\r\nonly the value of the corresponding digit in is not enough: there could\r\nbe some value carried over after multiplying already placed digits by .\r\nFor example, if , and we placed the first digit of and it is , we know\r\nthat the first (least significant) digit of is , and we know that after\r\nfixing the second digit of we should add to it to get the value of this\r\ndigit in , since is carried over from the first digit. So, the second\r\nstate of DP should represent the number that is carried over from the\r\nprevious digit in the numerator, and the third state should do the same\r\nfor the denominator.Okay, in order to know whether the fraction is good,\r\nwe have to keep track of some digits in the numerator and denominator.\r\nIf , and , then we have to keep track of the digit representing in the\r\nnumerator and the digit representing in the denominator. So we have two\r\nadditional states that represent the masks of \"interesting\" digits we\r\nmet in the numerator and in the denominator.The only thing thatâs left\r\nto check is that both and are not greater than . Letâs construct the\r\ndecimal representation of and prepend it with some leading zeroes; and\r\nkeep constructing the numerator and the denominator until they have the\r\nsame number of digits as the decimal representation as . Then we can\r\ncompare the representation of, for example, numerator with the\r\nrepresentation of as strings. Comparing can be done with the following\r\ntechnique: letâs keep a flag denoting whether the number represented by\r\nthe least significant digits of the numerator is less or equal than the\r\nnumber represented by the same digits from . When we place another digit\r\nof the numerator, we can get the new value of this flag as follows: if\r\nnew digit of the numerator is not equal to the corresponding digit of ,\r\nthen the value of the flag is defined by comparing this pair of digits;\r\notherwise the value of the flag is the same as it was without this new\r\ndigit. Of course, we should do the same for the denominator.Okay, now we\r\ncan actually start coding this DP: is the number of possible ways to put\r\nleast significant digits in in such a way that: the value carried over\r\nto the next digit of the numerator is (and for the denominator); denotes\r\nwhether the current numerator is less or equal to the number represented\r\nby least significant digits of ( does the same for the denominator);\r\ndenotes which \"interesting\" digits we already met in the numerator (of\r\ncourse, does the same for the denominator). If you are feeling confident\r\nin your programming abilities, you can just start implementing this DP\r\non a seven-dimensional array. I was too afraid to do it (but, looking at\r\nparticipantsâ solutions, I realize that it sounds much more scary than\r\nit looks in the code), so I decided to write the model solution using a\r\nstructure representing each state, and a map to store all these\r\nstructures. This is a common technique: when a dynamic programming\r\nsolution you come up with has some really complex states and\r\ntransitions, it is sometimes better to use some self-implemented\r\nstructures to define these states and store them in a map or a hashmap.\r\nSome advantages of this technique are: itâs sometimes much easier to\r\ncode (the code may be longer than the same solution with regular DP\r\nstored in a multi-dimensional array, but itâs easier to write and\r\nunderstand this code); if most states are unreachable, they wonât even\r\nappear in our map, so we skip them altogether; it is easy to add some\r\noptimizations related to reducing the number of states. For example, the\r\nnumber of different values for and may be too much, so we can use the\r\nfollowing optimization: as soon as we find some pair of numbers in and\r\nthat can represent and , we can change these masks to some values that\r\nwill mark that they are \"finished\" and stop updating them at all.\r\n",
    "hint": []
}