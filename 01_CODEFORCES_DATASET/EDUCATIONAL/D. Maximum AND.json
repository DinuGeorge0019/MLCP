{
    "link": "https://codeforces.com//contest/1721/problem/D",
    "problemId": "1521727",
    "problem_idx": "D",
    "shortId": "1721D",
    "contest_number": "1721",
    "problem_submissions": {
        "F": [
            169847425,
            169855093,
            169874051,
            169859751,
            169871554,
            169869426,
            169892039,
            169866057,
            169866260,
            169879985,
            169882444,
            169880200,
            169868972,
            169943924,
            169887978,
            169882264,
            169879150,
            169868978,
            169868554,
            169884451,
            169886386,
            169884169,
            169836583,
            169890280,
            169889729
        ],
        "E": [
            169825445,
            169831576,
            169846355,
            169845815,
            169845247,
            169849940,
            170071212,
            169840961,
            169843652,
            169842409,
            169855809,
            169853200,
            169849055,
            169861077,
            169848556,
            169841458,
            169835951,
            169859126,
            169853059,
            169861299,
            169890819,
            169860030,
            169851763,
            169839234
        ],
        "D": [
            169816642,
            169857780,
            169827464,
            169828353,
            169825938,
            169823055,
            169827534,
            169839208,
            169826501,
            169831272,
            169830277,
            169840516,
            169830590,
            169829045,
            169820762,
            169829319,
            169841817,
            169849956,
            169828079,
            169855346,
            169832685
        ],
        "C": [
            169812006,
            169821873,
            169865515,
            169815093,
            169818535,
            169828842,
            169823304,
            169816953,
            169821336,
            169818460,
            169821914,
            169817547,
            169822314,
            169825383,
            169842253,
            169820059,
            169823503,
            169835000,
            169824388,
            169861925,
            169815457
        ],
        "B": [
            169804991,
            169810857,
            169806854,
            169811441,
            169813569,
            169810575,
            169808902,
            169808903,
            169811401,
            169810906,
            169807229,
            169812143,
            169813395,
            169807352,
            169812235,
            169815520,
            169825227,
            169814779,
            169864673,
            169808536
        ],
        "A": [
            169804030,
            169804283,
            169861742,
            169804044,
            169806500,
            169805484,
            169806996,
            169804568,
            169805103,
            169805093,
            169804586,
            169804045,
            169804642,
            169805849,
            169804015,
            169804388,
            169808577,
            169817992,
            169808806,
            169866242,
            169804342
        ]
    },
    "name": "D. Maximum AND",
    "statement": "You are given two arrays a and b, consisting of n integers each.Let’s\r\ndefine a function f(a, b) as follows: let’s define an array c of size n,\r\nwhere c_i = a_i\r\noplus b_i (\r\noplus denotes bitwise XOR); the value of the function is c_1\r\nmathbin{\r\n&} c_2\r\nmathbin{\r\n&}\r\ncdots\r\nmathbin{\r\n&} c_n (i.e. bitwise AND of the entire array c). Find the maximum value\r\nof the function f(a, b) if you can reorder the array b in an arbitrary\r\nway (leaving the initial order is also an option).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    auto check = [&](int x) {\n        std::vector<int> c(n), d(n);\n        for (int i = 0; i < n; i++) {\n            c[i] = a[i] & x;\n            d[i] = ~b[i] & x;\n        }\n        std::sort(c.begin(), c.end());\n        std::sort(d.begin(), d.end());\n        return c == d;\n    };\n    \n    int ans = 0;\n    for (int d = 29; d >= 0; d--) {\n        if (check(ans | 1 << d)) {\n            ans |= 1 << d;\n        }\n    }\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "divide and conquer",
        "greedy",
        "sortings"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Maximum AND.json",
    "editorial_link": "https://codeforces.com//blog/entry/106416",
    "editorial": "We will build the answer greedily, from the highest significant bit to\r\nthe lowest one. Letâs analyze how to check if the answer can have the\r\nhighest bit equal to . It means that every value in should have its\r\nhighest bit equal to , so for every , exactly one of the numbers should\r\nhave this bit equal to . For both of the given arrays, we can calculate\r\nhow many elements have which value of this bit, and then the number of\r\nelements with in this bit in the array should be equal to the number of\r\nelements with in the array (and the same for elements with in and\r\nelements with in ). If these values are equal, it means that the\r\nelements of and can be matched in such a way that in every pair, the XOR\r\nof them has in this bit. If it is so, then the highest bit of the answer\r\nis , otherwise it is .Okay, then letâs proceed to the next bit. Should\r\nwe just do the same to check if this bit can be equal to in the answer?\r\nUnfortunately, thatâs not enough. Letâs look at the case: , . We can get\r\nthe value in the -th bit or in the -st bit, but not in both . So, for\r\nthe next bit, we need to make sure that not only we can get in the\r\nresult, but we can also do this without transforming some of the -s to\r\n-s in the higher bits. If it is impossible, it doesnât matter if we can\r\nget in the current bit since it will be suboptimal, so we have to use an\r\nordering that gets in this bit.In general case, it means that we have to\r\nsolve the following subproblem: check if we can obtain in several bits\r\nof the answer; let these bits be ( to are the bits that we have already\r\nchecked; is the new bit we are trying to check). Let be the number that\r\nhas in every bit and in every other bit. The elements should be matched\r\nin such a way that . If we group all numbers from and from according to\r\nthe value of (or ), then for every group of elements from , there is a\r\ncorresponding group in such that we can match the elements from the\r\nfirst group with the elements from the second group. So, if for every\r\nsuch group, its size in is equal to the size of the corresponding group\r\nin , then we can set all bits from to simultaneously.Some implementation\r\nnotes: if the number of bits we need to check is big, the number of\r\ngroups can become too large to handle all of them (since it is ). So, to\r\nstore the number of elements in each group, we should use some\r\nassociative data structure, like, for example, in C++. If you use a map,\r\nsplitting elements into groups will be done in , so in total, you will\r\nget complexity of , where is the maximum possible value in the input.\r\n",
    "hint": []
}