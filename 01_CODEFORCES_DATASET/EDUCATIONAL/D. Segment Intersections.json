{
    "link": "https://codeforces.com//contest/1389/problem/D",
    "problemId": "686125",
    "problem_idx": "D",
    "shortId": "1389D",
    "contest_number": "1389",
    "problem_submissions": {
        "F": [
            88348682,
            88338153,
            88328943,
            88335897,
            88333690,
            88373314,
            88373278,
            88339376,
            88563610,
            88324437,
            88323357,
            90193331,
            88370216,
            88338670,
            88346193,
            88335414,
            88340450,
            88343043,
            88354834,
            88350683,
            88354635,
            88351121,
            88341928,
            88353006,
            88617212,
            88617191,
            88616644,
            88339094
        ],
        "G": [
            88341915,
            88358421,
            88361866,
            88360257,
            88360333,
            88361126,
            88563627,
            88370757,
            88366719,
            88625823,
            88368266
        ],
        "E": [
            88316360,
            88314884,
            88313039,
            88320696,
            88327221,
            88331067,
            88563585,
            88316358,
            88316429,
            88316758,
            88324617,
            88315489,
            88322575,
            88325697,
            88318058,
            88335501,
            88333747,
            88335296,
            88331670,
            88336084,
            88330920
        ],
        "D": [
            88313541,
            88323588,
            88322172,
            88317239,
            88320907,
            88324683,
            88563559,
            88313756,
            88311946,
            88313492,
            88320253,
            88324924,
            88317796,
            88320516,
            88314433,
            88325709,
            88322521,
            88323822,
            88326845,
            88325546,
            88326242
        ],
        "C": [
            88305803,
            88306793,
            88305781,
            88311961,
            88313905,
            88313498,
            88563542,
            88308288,
            88306505,
            88301578,
            88306622,
            88310987,
            88310892,
            88306012,
            88305081,
            88310508,
            88309198,
            88313956,
            88307817,
            88312102,
            88315317
        ],
        "B": [
            88302673,
            88302689,
            88302324,
            88309761,
            88336897,
            88305352,
            88563516,
            88305445,
            88304272,
            88310119,
            88303921,
            88308221,
            88312057,
            88313228,
            88301014,
            88307222,
            88306963,
            88309964,
            88398537,
            88306205,
            88308367,
            88311740
        ],
        "A": [
            88294762,
            88294889,
            88294798,
            88296225,
            88294786,
            88295833,
            88563453,
            88295598,
            88294725,
            88294981,
            88294767,
            88294779,
            88295244,
            88294853,
            88294700,
            88297412,
            88295036,
            88299886,
            88294845,
            88296400,
            88294879
        ]
    },
    "name": "D. Segment Intersections",
    "statement": "You are given two lists of segments [al_1, ar_1], [al_2, ar_2],\r\ndots, [al_n, ar_n] and [bl_1, br_1], [bl_2, br_2],\r\ndots, [bl_n, br_n].Initially, all segments [al_i, ar_i] are equal to\r\n[l_1, r_1] and all segments [bl_i, br_i] are equal to [l_2, r_2].In one\r\nstep, you can choose one segment (either from the first or from the\r\nsecond list) and extend it by 1. In other words, suppose you\u2019ve chosen\r\nsegment [x, y] then you can transform it either into [x - 1, y] or into\r\n[x, y + 1].Let\u2019s define a total intersection I as the sum of lengths of\r\nintersections of the corresponding pairs of segments, i.e.\r\nsum\r\nlimits_{i=1}^{n}{\r\ntext{intersection_length}([al_i, ar_i], [bl_i, br_i])}. Empty\r\nintersection has length 0 and length of a segment [x, y] is equal to y -\r\nx.What is the minimum number of steps you need to make I greater or\r\nequal to k?\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll INF = (ll)1e18;\n\nll getCost(int l1, int r1, int l2, int r2, int d) {\n\tif (l1 > l2) {\n\t\tswap(l1, l2);\n\t\tswap(r1, r2);\n\t}\n\tll ans = 0;\n\tint w = 0;\n\tif (r1 < l2) {\n\t\tans += l2 - r1;\n\t\tw = r2 - l1;\n\t} else {\n\t\td = max(0, d - (min(r1, r2) - max(l1, l2)));\n\t\tw = max(r1, r2) - min(r1, r2) + max(l1, l2) - min(l1, l2);\n\t}\n\tif (d <= w) return ans + d;\n\treturn ans + w + 2 * (d - w);\n}\n\nvoid solve() {\n\tint n, k, l1, l2, r1, r2;\n\tscanf(\"%d%d%d%d%d%d\", &n, &k, &l1, &r1, &l2, &r2);\n\tll ans = INF;\n\tfor (int m = 1; m <= n; m++) {\n\t\tint d = k / m;\n\t\tll w1 = getCost(l1, r1, l2, r2, d);\n\t\tll w2 = getCost(l1, r1, l2, r2, d + 1);\n//\t\teprintf(\"%d %lld %lld\\n\", m, w1, w2);\n\t\td = k % m;\n\t\tans = min(ans, d * w2 + (m - d) * w1);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Segment Intersections.json",
    "editorial_link": "https://codeforces.com//blog/entry/80809",
    "editorial": "At first, note that of segments and can be calculated as . If it\u00e2\u0080\u0099s\r\nnegative then segments don\u00e2\u0080\u0099t intersect, otherwise it\u00e2\u0080\u0099s exactly length of\r\nintersection.Now we have two major cases: do segments and already\r\nintersect or not.If segments intersect then we already have as the total\r\nintersection. Note, that making both segments equal to in each pair are\r\nalways optimal since in each step we will increase the total\r\nintersection by .After making all segments equal to we can increase\r\ntotal intersection by only in two steps: we need to extend both segments\r\nin one pair.In result, we can find not a hard formula to calculate the\r\nminimum number of steps: we already have of the total intersection, then\r\nwe can increase it by at most using one step per increase, and then to\r\nany number using two steps per increase.In the case of non-intersecting\r\nand , we should at first \"invest\" some number of steps in each pair to\r\nmake them intersect. So let\u00e2\u0080\u0099s iterate over the number of segments to\r\n\"invest\" . We should make steps to make segments touch. Now, segments\r\ntouch so we can use almost the same formulas for them as in the previous\r\ncase.The total complexity is per test case.\r\n"
}