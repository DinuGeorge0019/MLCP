{"link": "https://codeforces.com//contest/1814/problem/C", "problemId": "1867158", "problem_idx": "C", "shortId": "1814C", "contest_number": "1814", "problem_submissions": {"F": [201036702, 201037659, 201028227, 201050534, 201005326, 201050567, 201051354, 201158503, 202793506, 201087367, 202961596, 202961442, 202961147, 201054424, 201057597, 201057439, 201061539], "E": [201020903, 201018973, 201013610, 201039745, 201017818, 201033040, 201037281, 201034750, 201024677, 201030462, 201026865, 201030498, 201034907, 201040830, 201037552, 201041417, 201042340, 201036940, 201015059, 201040959], "D": [201007638, 201011987, 201038257, 201026423, 201158753, 201158000, 201029908, 201043932, 201052993, 201045921, 201082509, 201058213, 201035019, 201016854, 201013631, 201010624, 201014339, 201022685, 201018472, 201019148, 201025982, 201024394, 201027376, 201024423, 201027368, 201021262, 201025020, 201019825, 201029085, 201044637, 201027275], "C": [200997961, 201000063, 201003769, 201024541, 201036517, 201006380, 201034351, 200999416, 201001849, 201000732, 201005802, 201004502, 201004247, 201004311, 201006996, 201002331, 201000424, 200997419, 201005850, 201004743], "B": [200988415, 200991922, 200990827, 200995877, 201038223, 200997671, 201032023, 200991419, 200988849, 200991883, 200998660, 200995028, 200998040, 200993967, 200992160, 200993164, 200991747, 200987467, 201004511, 200997597], "A": [200985126, 200985107, 200985078, 200985613, 201039035, 200990896, 201030957, 200985096, 200985148, 200986607, 200985454, 200988595, 200985783, 200985667, 200986043, 200985871, 200988700, 200985284, 201001220, 200986768]}, "name": "C. Search in Parallel", "statement": "Suppose you have n boxes. The i-th box contains infinitely many balls of\r\ncolor i. Sometimes you need to get a ball with some specific color; but\r\nyou\u2019re too lazy to do it yourself.You have bought two robots to retrieve\r\nthe balls for you. Now you have to program them. In order to program the\r\nrobots, you have to construct two lists [a_1, a_2,\r\ndots, a_k] and [b_1, b_2,\r\ndots, b_{n-k}], where the list a represents the boxes assigned to the\r\nfirst robot, and the list b represents the boxes assigned to the second\r\nrobot. .When you request a ball with color x, the robots work as\r\nfollows. Each robot looks through the boxes that were assigned to that\r\nrobot, in the order they appear in the list. The first robot spends s_1\r\nseconds analyzing the contents of a box; the second robot spends s_2. As\r\nsoon as one of the robots finds the box with balls of color x (and\r\nanalyzes its contents), the search ends. The search time is the number\r\nof seconds from the beginning of the search until one of the robots\r\nfinishes analyzing the contents of the x-th box. If a robot analyzes the\r\ncontents of all boxes assigned to it, it stops searching.For example,\r\nsuppose s_1 = 2, s_2 = 3, a = [4, 1, 5, 3, 7], b = [2, 6]. If you\r\nrequest a ball with color 3, the following happens: initially, the first\r\nrobot starts analyzing the box 4, and the second robot starts analyzing\r\nthe box 2; at the end of the 2-nd second, the first robot finishes\r\nanalyzing the box 4. It is not the box you need, so the robot continues\r\nwith the box 1; at the end of the 3-rd second, the second robot finishes\r\nanalyzing the box 2. It is not the box you need, so the robot continues\r\nwith the box 6; at the end of the 4-th second, the first robot finishes\r\nanalyzing the box 1. It is not the box you need, so the robot continues\r\nwith the box 5; at the end of the 6-th second, the first robot finishes\r\nanalyzing the box 5. It is not the box you need, so the robot continues\r\nwith the box 3. At the same time, the second robot finishes analyzing\r\nthe box 6. It is not the box you need, and the second robot has analyzed\r\nall the boxes in its list, so that robot stops searching; at the end of\r\nthe 8-th second, the first robot finishes analyzing the box 3. It is the\r\nbox you need, so the search ends; so, the search time is 8 seconds. You\r\nknow that you are going to request a ball of color 1 r_1 times, a ball\r\nof color 2 r_2 times, and so on. You want to construct the lists a and b\r\nfor the robots in such a way that the total search time over all\r\nrequests is the minimum possible.\r\n", "solutions": ["#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n\ta = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n\ta = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n\tvector<T> res;\n\tint ida = 0, idb = 0;\n\twhile (ida < a.size() || idb < b.size()) {\n\t\tif (idb == b.size()) {\n\t\t\tres.push_back(a[ida]); ida++;\n\t\t}\n\t\telse if (ida == a.size()) {\n\t\t\tres.push_back(b[idb]); idb++;\n\t\t}\n\t\telse {\n\t\t\tif (a[ida] < b[idb]) {\n\t\t\t\tres.push_back(a[ida]); ida++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.push_back(b[idb]); idb++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n\trep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << \" \"; cout << v[i];\n\t}\n\tcout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n\tif (n < 0) {\n\t\tll res = mod_pow(x, -n, m);\n\t\treturn mod_pow(res, m - 2, m);\n\t}\n\tif (abs(x) >= m)x %= m;\n\tif (x < 0)x += m;\n\t//if (x == 0)return 0;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\n//mod should be <2^31\nstruct modint {\n\tint n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) {\n\t\tif (m < 0 || mod <= m) {\n\t\t\tm %= mod; if (m < 0)m += mod;\n\t\t}\n\t\tn = m;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\ta = abs(a); b = abs(b);\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n\tif (loc >= v.size())v.resize(loc + 1, 0);\n\tv[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n\tfill(isp + 2, isp + mn, true);\n\tfor (int i = 2; i < mn; i++) {\n\t\tif (!isp[i])continue;\n\t\tps.push_back(i);\n\t\tfor (int j = 2 * i; j < mn; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\tif (res == st.begin())return st.end();\n\tres--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\treturn res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n\ta = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n\ta = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n\ta = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n\ta = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\nvoid solve() {\n\tint n, s[2]; cin >> n >> s[0] >> s[1];\n\tvector<int> r(n);\n\trep(i, n)cin >> r[i];\n\tvector<P> vp;\n\trep(i, n)vp.push_back({ r[i],i });\n\tsort(all(vp), greater<P>());\n\tvector<int> ans[2];\n\tint nw[2] = {};\n\trep(j, 2)nw[j] = s[j];\n\trep(i, vp.size()) {\n\t\tint col = vp[i].second + 1;\n\t\tint z = 0;\n\t\tif (nw[0] > nw[1])z = 1;\n\t\tans[z].push_back(col);\n\t\tnw[z] += s[z];\n\t}\n\trep(j, 2) {\n\t\tcout << ans[j].size() << \" \";\n\t\tcoutarray(ans[j]);\n\t}\n}\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//init();\n\t//while(true)\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\t\tsolve();\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy", "sortings"], "dificulty": "1500", "interactive": false}