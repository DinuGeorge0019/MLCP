{
    "link": "https://codeforces.com//contest/2042/problem/D",
    "problemId": "3063462",
    "problem_idx": "D",
    "shortId": "2042D",
    "contest_number": "2042",
    "problem_submissions": {
        "E": [
            294423774,
            294419934,
            294425145,
            294427314,
            294461391,
            294454616,
            294469820,
            294456785,
            294473828,
            294432050,
            294452832,
            294430074,
            294720157,
            294431481,
            294468510,
            294470387,
            294430159
        ],
        "F": [
            294412520,
            294425551,
            294432280,
            294452436,
            294434993,
            294433145,
            294446063,
            294428799,
            294413717,
            294412873,
            294411042,
            294425120,
            294428614,
            294424117,
            294468671,
            294445770,
            294425722,
            294433551,
            294468661,
            294431992,
            294436625
        ],
        "D": [
            294403997,
            294407353,
            294409781,
            294414370,
            294407554,
            294410319,
            294417815,
            294419253,
            294437550,
            294410412,
            294413967,
            294418349,
            294411907,
            294402733,
            294411823,
            294409744,
            294417262,
            294417181,
            294415900
        ],
        "C": [
            294397589,
            294400380,
            294403833,
            294401565,
            294414063,
            294405958,
            294407677,
            294415266,
            294453518,
            294402202,
            294397037,
            294403746,
            294403563,
            294397148,
            294404737,
            294399098,
            294402722,
            294400450,
            294396822
        ],
        "B": [
            294394491,
            294397696,
            294398701,
            294393052,
            294393883,
            294395178,
            294398939,
            294412364,
            294455866,
            294393748,
            294393435,
            294395970,
            294392768,
            294392321,
            294399650,
            294391444,
            294395529,
            294395407,
            294392933
        ],
        "A": [
            294390734,
            294395467,
            294390153,
            294389939,
            294390115,
            294390408,
            294402923,
            294412466,
            294454482,
            294389870,
            294390174,
            294391619,
            294390031,
            294390265,
            294390266,
            294389845,
            294389856,
            294390624,
            294389907
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136886",
    "editorial": "Firstly, if several segments are equal, then the answer for all of them\r\nis zero. Now let\u00e2\u0080\u0099s move to the problem where all segments are\r\ndistinct.User is a predictor for user iff . Also, a track is strongly\r\nrecommended if it is in all predictor segments, i. e. the track belongs\r\nto the intersection of all predictors. Since the segment also belongs to\r\n, then the tracks we need to find form two intervals and .Let\u00e2\u0080\u0099s focus on\r\nfinding interval . Since the right border of the intersection is the\r\nminimum among right borders, then our task is to find the minimum among\r\n-s such that while .Let\u00e2\u0080\u0099s do it in the following way: let\u00e2\u0080\u0099s sort all\r\nsegments by in increasing order; in case of equal -s, sort them by in\r\norder. If we process segments in the given order, then by the moment we\r\nprocess the -th segment, all its predictors will be already\r\nprocessed.Let\u00e2\u0080\u0099s keep -s of all processed segments so far in an \"ordered\r\nset\" (, for example). Suppose we process segment . Since the right\r\nborders of all predictors are already in and their , then finding the\r\nminimum among them is equivalent to just taking . Then we can add to the\r\nanswer for the -th segment.In order to calculate intervals we can just\r\nreflect all segments and solve the same problem.The complexity of the\r\nsolution is .\r\n",
    "name": "D. Recommendations",
    "statement": "Suppose you are working in some audio streaming service. The service has\r\nn active users and 10^9 tracks users can listen to. Users can like\r\ntracks and, based on likes, the service should recommend them new\r\ntracks.Tracks are numbered from 1 to 10^9. It turned out that tracks the\r\ni-th user likes form a segment [l_i, r_i].Let\u2019s say that the user j is a\r\nfor user i (j\r\nneq i) if user j likes all tracks the i-th user likes (and, possibly,\r\nsome other tracks too).Also, let\u2019s say that a track is for user i if the\r\ntrack is not liked by the i-th user yet, but it is liked by predictor\r\nfor the i-th user.Calculate the number of strongly recommended tracks\r\nfor each user i. If a user doesn\u2019t have any predictors, then print 0 for\r\nthat user.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"using namespace std;#define all(x) x.begin(),x.end()template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << \" \" << p.second; }template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { string sep; for (const T &x : v) os << sep << x, sep = \" \"; return os; }#ifdef LOCAL#include \"debug.h\"#else#define debug(...) 42#define ASSERT(...) 42#endiftypedef long long ll;typedef vector<int> vi;typedef vector<vi> vvi;typedef pair<int,int> pi;const int oo = 1e9;\u00a0void solve() {    int n; cin >> n;       vi ans(n);    vector<pi> lr(n);    for(auto& [l,r] : lr) cin >> l >> r;\u00a0    for(int re=0;re<2;++re) {        struct event {            bool open;            int id;            int x;            bool operator<(const event& o) {                if(x==o.x) {                    return open>o.open;                }                return x<o.x;            }        };        vector<event> es;        for(int i=0;i<n;++i) {            auto [l,r] =lr[i];            es.push_back({1,i,l});            es.push_back({0,i,r});        }        sort(all(es));        multiset<int> s;        int last=-oo-1;        vi del;        for(auto e : es) {            if(e.x!=last) {                for(auto x : del) {                    s.erase(s.find(x));                }                del.clear();            }            if(e.open) {                s.insert(e.x);            } else {                auto [l,r] = lr[e.id];                del.push_back(l);\u00a0                auto it = s.upper_bound(l);                it--;                // go over myself!                if(it==s.begin()) {                    ans[e.id]+=-l;\u00a0                } else ans[e.id]+=-(*prev(it));\u00a0            }            last=e.x;        }                for(auto& [l,r] : lr ) {            swap(l,r);            l=-l;            r=-r;        }    }    for(int i=0;i<n;++i) {        cout << ans[i]-lr[i].second+lr[i].first << '\\n';    }}\u00a0int main() {    ios_base::sync_with_stdio(false);    cin.tie(NULL);    int t; cin >> t;    while(t--) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Recommendations.json"
}