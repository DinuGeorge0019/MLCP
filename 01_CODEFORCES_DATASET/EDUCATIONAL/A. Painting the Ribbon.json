{
    "link": "https://codeforces.com//contest/1954/problem/A",
    "problemId": "2586691",
    "problem_idx": "A",
    "shortId": "1954A",
    "contest_number": "1954",
    "problem_submissions": {
        "F": [
            256316895,
            256329295,
            256334035,
            256332306,
            256344392,
            256332853,
            256328005,
            256347592,
            256335011,
            256352109,
            256350995,
            258635003,
            256340118,
            256372395,
            256325447,
            256325322,
            256346283,
            256316023,
            256323588,
            256320924
        ],
        "E": [
            256282413,
            256358889,
            256358516,
            256282751,
            256340120,
            256301294,
            256294589,
            256283411,
            256294052,
            256306491,
            256303451,
            256299550,
            256302258,
            256354417,
            256293685,
            256303935,
            256308643,
            256372754,
            256335764,
            256333289,
            256297901,
            256327707,
            256340547,
            256345064,
            256288665
        ],
        "D": [
            256268895,
            256269992,
            256269812,
            256286958,
            256273436,
            256278229,
            256282928,
            256272144,
            256284841,
            256280990,
            256279861,
            256284063,
            256273990,
            256301346,
            256280827,
            256332605,
            256335916,
            256339422,
            256279104
        ],
        "C": [
            256263031,
            256263009,
            256264769,
            256265286,
            256267161,
            256271687,
            256272827,
            256264797,
            256276178,
            256267220,
            256271392,
            256275794,
            256262221,
            256288253,
            256273238,
            256334487,
            256333463,
            256330248,
            256269277
        ],
        "B": [
            256260210,
            256260093,
            256260556,
            256262624,
            256263445,
            256260047,
            256260173,
            256261053,
            256267415,
            256261634,
            256268733,
            256270204,
            256275934,
            256283332,
            256344932,
            256336999,
            256331860,
            256328039,
            256266244
        ],
        "A": [
            256256940,
            256256909,
            256256942,
            256256970,
            256256990,
            256256907,
            256256875,
            256257032,
            256259999,
            256257112,
            256257788,
            256257203,
            256259580,
            256256932,
            256338388,
            256326736,
            256328175,
            256257406
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/128421",
    "editorial": "When is Bob able to get a ribbon where each part has color ? There\r\nshould be at least parts of color . So if the number of parts with color\r\nis less than , Bob cannot repaint the whole ribbon into color .So, Alice\r\nhas to paint the ribbon in such a way that for every color, there are at\r\nmost parts of that color. There are at least two ways to check if it is\r\npossible: for example, you can calculate the maximum possible length of\r\nthe ribbon such that it contains no more than parts of every color; or\r\nyou can calculate the maximum number of parts among all colors if you\r\ntry to color the ribbon as evenly as possible.\r\n",
    "name": "A. Painting the Ribbon",
    "statement": "Alice and Bob have bought a ribbon consisting of n parts. Now they want\r\nto paint it.First, Alice will paint every part of the ribbon into one of\r\nm colors. For each part, she can choose its color arbitrarily.Then, Bob\r\nwill choose parts of the ribbon and repaint them (he chooses the\r\naffected parts and the color arbitrarily).Bob would like all parts to\r\nhave the same color. However, Alice thinks that this is too dull, so she\r\nwants to paint the ribbon in such a way that Bob cannot make all parts\r\nhave the same color.Is it possible to paint the ribbon in such a way?\r\n",
    "solutions": [
        "#include<bits/stdc++.h>using namespace std; #define all(a) a.begin(),a.end()#define pb push_back#define sz(a) ((int)a.size()) using ll=long long;using u32=unsigned int;using u64=unsigned long long;using i128=__int128;using u128=unsigned __int128;using f128=__float128; using pii=pair<int,int>;using pll=pair<ll,ll>; template<typename T> using vc=vector<T>;template<typename T> using vvc=vc<vc<T>>;template<typename T> using vvvc=vc<vvc<T>>; using vi=vc<int>;using vll=vc<ll>;using vvi=vc<vi>;using vvll=vc<vll>; #define vv(type,name,n,...) \\    vector<vector<type>> name(n,vector<type>(__VA_ARGS__))#define vvv(type,name,n,m,...) \\    vector<vector<vector<type>>> name(n,vector<vector<type>>(m,vector<type>(__VA_ARGS__))) template<typename T> using min_heap=priority_queue<T,vector<T>,greater<T>>;template<typename T> using max_heap=priority_queue<T>; // https://trap.jp/post/1224/#define rep1(n) for(ll i=0; i<(ll)(n); ++i)#define rep2(i,n) for(ll i=0; i<(ll)(n); ++i)#define rep3(i,a,b) for(ll i=(ll)(a); i<(ll)(b); ++i)#define rep4(i,a,b,c) for(ll i=(ll)(a); i<(ll)(b); i+=(c))#define cut4(a,b,c,d,e,...) e#define rep(...) cut4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)#define per1(n) for(ll i=((ll)n)-1; i>=0; --i)#define per2(i,n) for(ll i=((ll)n)-1; i>=0; --i)#define per3(i,a,b) for(ll i=((ll)a)-1; i>=(ll)(b); --i)#define per4(i,a,b,c) for(ll i=((ll)a)-1; i>=(ll)(b); i-=(c))#define per(...) cut4(__VA_ARGS__,per4,per3,per2,per1)(__VA_ARGS__)#define rep_subset(i,s) for(ll i=(s); i>=0; i=(i==0?-1:(i-1)&(s))) template<typename T, typename S> constexpr T ifloor(const T a, const S b){return a/b-(a%b&&(a^b)<0);}template<typename T, typename S> constexpr T iceil(const T a, const S b){return ifloor(a+b-1,b);} template<typename T>void sort_unique(vector<T> &vec){    sort(vec.begin(),vec.end());    vec.resize(unique(vec.begin(),vec.end())-vec.begin());} template<typename T, typename S> constexpr bool chmin(T &a, const S b){if(a>b) return a=b,true; return false;}template<typename T, typename S> constexpr bool chmax(T &a, const S b){if(a<b) return a=b,true; return false;} template<typename T, typename S> istream& operator >> (istream& i, pair<T,S> &p){return i >> p.first >> p.second;}template<typename T, typename S> ostream& operator << (ostream& o, const pair<T,S> &p){return o << p.first << ' ' << p.second;} #ifdef i_am_noob#define bug(...) cerr << \"#\" << __LINE__ << ' ' << #__VA_ARGS__ << \"- \", _do(__VA_ARGS__)template<typename T> void _do(vector<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(unordered_set<T> x){for(auto i: x) cerr << i << ' ';cerr << \"\\n\";}template<typename T> void _do(T && x) {cerr << x << endl;}template<typename T, typename ...S> void _do(T && x, S&&...y) {cerr << x << \", \"; _do(y...);}#else#define bug(...) 777771449#endif template<typename T> void print(vector<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(unordered_set<T> x){for(auto i: x) cout << i << ' ';cout << \"\\n\";}template<typename T> void print(T && x) {cout << x << \"\\n\";}template<typename T, typename... S> void print(T && x, S&&... y) {cout << x << ' ';print(y...);} template<typename T> istream& operator >> (istream& i, vector<T> &vec){for(auto &x: vec) i >> x; return i;} vvi read_graph(int n, int m, int base=1){    vvi adj(n);    for(int i=0,u,v; i<m; ++i){        cin >> u >> v,u-=base,v-=base;        adj[u].pb(v),adj[v].pb(u);    }    return adj;} vvi read_tree(int n, int base=1){return read_graph(n,n-1,base);} template<typename T, typename S> pair<T,S> operator + (const pair<T,S> &a, const pair<T,S> &b){return {a.first+b.first,a.second+b.second};} template<typename T> constexpr T inf=0;template<> constexpr int inf<int> = 0x3f3f3f3f;template<> constexpr ll inf<ll> = 0x3f3f3f3f3f3f3f3f; template<typename T> vector<T> operator += (vector<T> &a, int val){for(auto &i: a) i+=val; return a;} template<typename T> T isqrt(const T &x){T y=sqrt(x+2); while(y*y>x) y--; return y;} #define ykh mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()) //#include<atcoder/all>//using namespace atcoder; //using mint=modint998244353;//using mint=modint1000000007; void ahcorz(){    int n,m,k; cin >> n >> m >> k;    int mx=iceil(n,m);    if(n-mx<=k) print(\"NO\");    else print(\"YES\");} signed main(){    ios_base::sync_with_stdio(0),cin.tie(0);    cout << fixed << setprecision(20);    int t=1;    cin >> t;    while(t--) ahcorz();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Painting the Ribbon.json",
    "hint": []
}