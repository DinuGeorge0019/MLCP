{
    "link": "https://codeforces.com//contest/1251/problem/D",
    "problemId": "449547",
    "problem_idx": "D",
    "shortId": "1251D",
    "contest_number": "1251",
    "problem_submissions": {
        "D": [
            63400316,
            63400298,
            63400254,
            63400203,
            63400050,
            63399984,
            63399855,
            63312403,
            63311940,
            63318990,
            63314573,
            63427346,
            63313882,
            63324960,
            63323872,
            63313008,
            63319425,
            63312837,
            63313209,
            63313402,
            63313713,
            63313403,
            64630107,
            63316214,
            63315539,
            63310152,
            63317232,
            63314816
        ],
        "E2": [
            63399693,
            63399662,
            63399248,
            63399098,
            63398546,
            63365832,
            63365269,
            63364770,
            63338273,
            63317755,
            63314968,
            63314711,
            63319868,
            63427473,
            63323675,
            63322799,
            63317013,
            63330304,
            63326912,
            63315944,
            63319041,
            63319971,
            63319185,
            63322016,
            64630154,
            63319603,
            63323442,
            63321804,
            63320973
        ],
        "F": [
            63396794,
            63395657,
            63340397,
            63340247,
            63322387,
            63331974,
            63347502,
            63345880,
            63325885,
            63328608,
            63427571,
            63333465,
            63330239,
            63311325,
            63320807,
            63332225,
            63349152,
            63349006,
            63348927,
            63346482,
            63354827,
            63555798,
            63396546,
            63361055,
            63321261,
            63339709
        ],
        "C": [
            63339509,
            63309630,
            63308770,
            63309154,
            63311219,
            63425373,
            63310517,
            63308226,
            63320102,
            63309048,
            63314299,
            63306755,
            63309969,
            63308377,
            63311623,
            63309667,
            64630061,
            63312827,
            63308776,
            63307614,
            63311843,
            63311519
        ],
        "E1": [
            63317840,
            63315090,
            63315149,
            63319942,
            63427459,
            63323582,
            63322914,
            63316888,
            63330357,
            63326985,
            63315977,
            63318948,
            63319867,
            63319014,
            63322137,
            64630159,
            63319793,
            63323604,
            63329086,
            63321906,
            63320849
        ],
        "B": [
            63308319,
            63306252,
            63306938,
            63308521,
            63425306,
            63309307,
            63306115,
            63321613,
            63306650,
            63307802,
            63305211,
            63307273,
            63305885,
            63310074,
            63307855,
            64630021,
            63308550,
            63306496,
            63305718,
            63309015,
            63308105
        ],
        "A": [
            63304668,
            63304379,
            63304115,
            63305872,
            63425273,
            63304642,
            63304137,
            63319299,
            63304384,
            63304697,
            63304218,
            63304454,
            63304321,
            63307231,
            63304364,
            64629970,
            63304438,
            63304343,
            63304369,
            63305312,
            63306229
        ]
    },
    "name": "D. Salary Changing",
    "statement": "You are the head of a large enterprise. n people work at you, and n is\r\nodd (i. e. n is not divisible by 2).You have to distribute salaries to\r\nyour employees. Initially, you have s dollars for it, and the i-th\r\nemployee should get a salary from l_i to r_i dollars. You have to\r\ndistribute salaries in such a way that the median salary is .To find the\r\nmedian of a sequence of odd length, you have to sort it and take the\r\nelement in the middle position after sorting. For example: the median of\r\nthe sequence [5, 1, 10, 17, 6] is 6, the median of the sequence [1, 2,\r\n1] is 1. It is guaranteed that you have enough money to pay the minimum\r\nsalary, i.e l_1 + l_2 +\r\ndots + l_n\r\nle s.You have to answer t test cases.\r\n",
    "solutions": [
        "// https://probablydance.com/2016/12/27/i-wrote-a-faster-sorting-algorithm/\n\n//          Copyright Malte Skarupke 2016.\n// Distributed under the Boost Software License, Version 1.0.\n//    (See http://www.boost.org/LICENSE_1_0.txt)\n\n#include <cstdint>\n#include <algorithm>\n\nnamespace detail\n{\ninline unsigned int to_unsigned_or_bool(int i)\n{\n    return static_cast<unsigned int>(i) + static_cast<unsigned int>(1 << (sizeof(int) * 8 - 1));\n}\ninline unsigned int to_unsigned_or_bool(unsigned int i)\n{\n    return i;\n}\ninline unsigned long to_unsigned_or_bool(long l)\n{\n    return static_cast<unsigned long>(l) + static_cast<unsigned long>(1l << (sizeof(long) * 8 - 1));\n}\ninline unsigned long to_unsigned_or_bool(unsigned long l)\n{\n    return l;\n}\ninline unsigned long long to_unsigned_or_bool(long long l)\n{\n    return static_cast<unsigned long long>(l) + static_cast<unsigned long long>(1ll << (sizeof(long long) * 8 - 1));\n}\ninline unsigned long long to_unsigned_or_bool(unsigned long long l)\n{\n    return l;\n}\ninline std::uint32_t to_unsigned_or_bool(float f)\n{\n    union\n    {\n        float f;\n        std::uint32_t u;\n    } as_union = { f };\n    std::uint32_t sign_bit = -std::int32_t(as_union.u >> 31);\n    return as_union.u ^ (sign_bit | 0x80000000);\n}\ninline std::uint64_t to_unsigned_or_bool(double f)\n{\n    union\n    {\n        double d;\n        std::uint64_t u;\n    } as_union = { f };\n    std::uint64_t sign_bit = -std::int64_t(as_union.u >> 63);\n    return as_union.u ^ (sign_bit | 0x8000000000000000);\n}\n\ntemplate<typename...>\nstruct nested_void\n{\n    using type = void;\n};\n\ntemplate<typename... Args>\nusing void_t = typename nested_void<Args...>::type;\n\n\ntemplate<typename It, typename Func>\ninline void unroll_loop_four_times(It begin, size_t iteration_count, Func && to_call)\n{\n    size_t loop_count = iteration_count / 4;\n    size_t remainder_count = iteration_count - loop_count * 4;\n    for (; loop_count > 0; --loop_count)\n    {\n        to_call(begin);\n        ++begin;\n        to_call(begin);\n        ++begin;\n        to_call(begin);\n        ++begin;\n        to_call(begin);\n        ++begin;\n    }\n    switch(remainder_count)\n    {\n    case 3:\n        to_call(begin);\n        ++begin;\n        [[fallthrough]];\n    case 2:\n        to_call(begin);\n        ++begin;\n        [[fallthrough]];\n    case 1:\n        to_call(begin);\n    }\n}\n\ntemplate<typename It, typename F>\ninline It custom_std_partition(It begin, It end, F && func)\n{\n    for (;; ++begin)\n    {\n        if (begin == end)\n            return end;\n        if (!func(*begin))\n            break;\n    }\n    It it = begin;\n    for(++it; it != end; ++it)\n    {\n        if (!func(*it))\n            continue;\n\n        std::iter_swap(begin, it);\n        ++begin;\n    }\n    return begin;\n}\n\nstruct PartitionInfo\n{\n    PartitionInfo()\n        : count(0)\n    {\n    }\n\n    union\n    {\n        size_t count;\n        size_t offset;\n    };\n    size_t next_offset;\n};\n\ntemplate<size_t>\nstruct UnsignedForSize;\ntemplate<>\nstruct UnsignedForSize<4>\n{\n    typedef uint32_t type;\n};\ntemplate<>\nstruct UnsignedForSize<8>\n{\n    typedef uint64_t type;\n};\ntemplate<typename T>\nstruct SubKey;\ntemplate<size_t Size>\nstruct SizedSubKey\n{\n    using sub_key_type = typename UnsignedForSize<Size>::type;\n\n    template<typename T>\n    static sub_key_type sub_key(T && value, void *)\n    {\n        return to_unsigned_or_bool(value);\n    }\n\n    typedef SubKey<void> next;\n};\ntemplate<typename T, typename Enable = void>\nstruct FallbackSubKey\n    : SubKey<decltype(to_radix_sort_key(std::declval<T>()))>\n{\n    using base = SubKey<decltype(to_radix_sort_key(std::declval<T>()))>;\n\n    template<typename U>\n    static base sub_key(U && value, void * data)\n    {\n        return base::sub_key(to_radix_sort_key(value), data);\n    }\n};\ntemplate<typename T>\nstruct FallbackSubKey<T, void_t<decltype(to_unsigned_or_bool(std::declval<T>()))>>\n    : SubKey<decltype(to_unsigned_or_bool(std::declval<T>()))>\n{\n};\ntemplate<typename T>\nstruct SubKey : FallbackSubKey<T>\n{\n};\ntemplate<>\nstruct SubKey<unsigned int> : SizedSubKey<sizeof(unsigned int)>\n{\n};\ntemplate<>\nstruct SubKey<unsigned long> : SizedSubKey<sizeof(unsigned long)>\n{\n};\ntemplate<>\nstruct SubKey<unsigned long long> : SizedSubKey<sizeof(unsigned long long)>\n{\n};\n\ntemplate<typename It, typename ExtractKey>\ninline void StdSortFallback(It begin, It end, ExtractKey & extract_key)\n{\n    std::sort(begin, end, [&](const typename std::remove_reference<decltype(*begin)>::type & l,\n                              const typename std::remove_reference<decltype(*begin)>::type & r) { return extract_key(l) < extract_key(r); });\n}\n\ntemplate<std::ptrdiff_t StdSortThreshold, typename It, typename ExtractKey>\ninline bool StdSortIfLessThanThreshold(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key)\n{\n    if (num_elements <= 1)\n        return true;\n    if (num_elements >= StdSortThreshold)\n        return false;\n    StdSortFallback(begin, end, extract_key);\n    return true;\n}\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, typename SubKeyType = typename CurrentSubKey::sub_key_type>\nstruct InplaceSorter;\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, size_t NumBytes, size_t Offset = 0>\nstruct UnsignedInplaceSorter\n{\n    static constexpr size_t ShiftAmount = (((NumBytes - 1) - Offset) * 8);\n    template<typename T>\n    inline static uint8_t current_byte(T && elem, void * sort_data)\n    {\n        return CurrentSubKey::sub_key(elem, sort_data) >> ShiftAmount;\n    }\n    template<typename It, typename ExtractKey>\n    static void sort(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key, void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data)\n    {\n        if (num_elements < AmericanFlagSortThreshold)\n            american_flag_sort(begin, end, extract_key, next_sort, sort_data);\n        else\n            ska_byte_sort(begin, end, extract_key, next_sort, sort_data);\n    }\n\n    template<typename It, typename ExtractKey>\n    static void american_flag_sort(It begin, It end, ExtractKey & extract_key, void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data)\n    {\n        PartitionInfo partitions[256];\n        for (It it = begin; it != end; ++it)\n        {\n            ++partitions[current_byte(extract_key(*it), sort_data)].count;\n        }\n        size_t total = 0;\n        uint8_t remaining_partitions[256];\n        int num_partitions = 0;\n        for (int i = 0; i < 256; ++i)\n        {\n            size_t count = partitions[i].count;\n            if (!count)\n                continue;\n            partitions[i].offset = total;\n            total += count;\n            partitions[i].next_offset = total;\n            remaining_partitions[num_partitions] = i;\n            ++num_partitions;\n        }\n        if (num_partitions > 1)\n        {\n            uint8_t * current_block_ptr = remaining_partitions;\n            PartitionInfo * current_block = partitions + *current_block_ptr;\n            uint8_t * last_block = remaining_partitions + num_partitions - 1;\n            It it = begin;\n            It block_end = begin + current_block->next_offset;\n            It last_element = end - 1;\n            for (;;)\n            {\n                PartitionInfo * block = partitions + current_byte(extract_key(*it), sort_data);\n                if (block == current_block)\n                {\n                    ++it;\n                    if (it == last_element)\n                        break;\n                    else if (it == block_end)\n                    {\n                        for (;;)\n                        {\n                            ++current_block_ptr;\n                            if (current_block_ptr == last_block)\n                                goto recurse;\n                            current_block = partitions + *current_block_ptr;\n                            if (current_block->offset != current_block->next_offset)\n                                break;\n                        }\n\n                        it = begin + current_block->offset;\n                        block_end = begin + current_block->next_offset;\n                    }\n                }\n                else\n                {\n                    size_t offset = block->offset++;\n                    std::iter_swap(it, begin + offset);\n                }\n            }\n        }\n        recurse:\n        if (Offset + 1 != NumBytes || next_sort)\n        {\n            size_t start_offset = 0;\n            It partition_begin = begin;\n            for (uint8_t * it = remaining_partitions, * part_end = remaining_partitions + num_partitions; it != part_end; ++it)\n            {\n                size_t end_offset = partitions[*it].next_offset;\n                It partition_end = begin + end_offset;\n                std::ptrdiff_t num_elements = end_offset - start_offset;\n                if (!StdSortIfLessThanThreshold<StdSortThreshold>(partition_begin, partition_end, num_elements, extract_key))\n                {\n                    UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, NumBytes, Offset + 1>::sort(partition_begin, partition_end, num_elements, extract_key, next_sort, sort_data);\n                }\n                start_offset = end_offset;\n                partition_begin = partition_end;\n            }\n        }\n    }\n\n    template<typename It, typename ExtractKey>\n    static void ska_byte_sort(It begin, It end, ExtractKey & extract_key, void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * sort_data)\n    {\n        PartitionInfo partitions[256];\n        for (It it = begin; it != end; ++it)\n        {\n            ++partitions[current_byte(extract_key(*it), sort_data)].count;\n        }\n        uint8_t remaining_partitions[256];\n        size_t total = 0;\n        int num_partitions = 0;\n        for (int i = 0; i < 256; ++i)\n        {\n            size_t count = partitions[i].count;\n            if (count)\n            {\n                partitions[i].offset = total;\n                total += count;\n                remaining_partitions[num_partitions] = i;\n                ++num_partitions;\n            }\n            partitions[i].next_offset = total;\n        }\n        for (uint8_t * last_remaining = remaining_partitions + num_partitions, * end_partition = remaining_partitions + 1; last_remaining > end_partition;)\n        {\n            last_remaining = custom_std_partition(remaining_partitions, last_remaining, [&](uint8_t partition)\n            {\n                size_t & begin_offset = partitions[partition].offset;\n                size_t & end_offset = partitions[partition].next_offset;\n                if (begin_offset == end_offset)\n                    return false;\n\n                unroll_loop_four_times(begin + begin_offset, end_offset - begin_offset, [&](It it)\n                {\n                    uint8_t this_partition = current_byte(extract_key(*it), sort_data);\n                    size_t offset = partitions[this_partition].offset++;\n                    std::iter_swap(it, begin + offset);\n                });\n                return begin_offset != end_offset;\n            });\n        }\n        if (Offset + 1 != NumBytes || next_sort)\n        {\n            for (uint8_t * it = remaining_partitions + num_partitions; it != remaining_partitions; --it)\n            {\n                uint8_t partition = it[-1];\n                size_t start_offset = (partition == 0 ? 0 : partitions[partition - 1].next_offset);\n                size_t end_offset = partitions[partition].next_offset;\n                It partition_begin = begin + start_offset;\n                It partition_end = begin + end_offset;\n                std::ptrdiff_t num_elements = end_offset - start_offset;\n                if (!StdSortIfLessThanThreshold<StdSortThreshold>(partition_begin, partition_end, num_elements, extract_key))\n                {\n                    UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, NumBytes, Offset + 1>::sort(partition_begin, partition_end, num_elements, extract_key, next_sort, sort_data);\n                }\n            }\n        }\n    }\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey, size_t NumBytes>\nstruct UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, NumBytes, NumBytes>\n{\n    template<typename It, typename ExtractKey>\n    inline static void sort(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key, void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *), void * next_sort_data)\n    {\n        next_sort(begin, end, num_elements, extract_key, next_sort_data);\n    }\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>\nstruct InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, uint32_t> : UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, 4>\n{\n};\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>\nstruct InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, uint64_t> : UnsignedInplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey, 8>\n{\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>\nstruct SortStarter;\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold>\nstruct SortStarter<StdSortThreshold, AmericanFlagSortThreshold, SubKey<void>>\n{\n    template<typename It, typename ExtractKey>\n    static void sort(It, It, std::ptrdiff_t, ExtractKey &, void *)\n    {\n    }\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename CurrentSubKey>\nstruct SortStarter\n{\n    template<typename It, typename ExtractKey>\n    static void sort(It begin, It end, std::ptrdiff_t num_elements, ExtractKey & extract_key, void * next_sort_data = nullptr)\n    {\n        if (StdSortIfLessThanThreshold<StdSortThreshold>(begin, end, num_elements, extract_key))\n            return;\n\n        void (*next_sort)(It, It, std::ptrdiff_t, ExtractKey &, void *) = static_cast<void (*)(It, It, std::ptrdiff_t, ExtractKey &, void *)>(&SortStarter<StdSortThreshold, AmericanFlagSortThreshold, typename CurrentSubKey::next>::sort);\n        if (next_sort == static_cast<void (*)(It, It, std::ptrdiff_t, ExtractKey &, void *)>(&SortStarter<StdSortThreshold, AmericanFlagSortThreshold, SubKey<void>>::sort))\n            next_sort = nullptr;\n        InplaceSorter<StdSortThreshold, AmericanFlagSortThreshold, CurrentSubKey>::sort(begin, end, num_elements, extract_key, next_sort, next_sort_data);\n    }\n};\n\ntemplate<std::ptrdiff_t StdSortThreshold, std::ptrdiff_t AmericanFlagSortThreshold, typename It, typename ExtractKey>\nvoid inplace_radix_sort(It begin, It end, ExtractKey & extract_key)\n{\n    using SubKey = SubKey<decltype(extract_key(*begin))>;\n    SortStarter<StdSortThreshold, AmericanFlagSortThreshold, SubKey>::sort(begin, end, end - begin, extract_key);\n}\n\nstruct IdentityFunctor\n{\n    template<typename T>\n    T&& operator()(T && i) const\n    {\n        return std::forward<T>(i);\n    }\n};\n}\n\ntemplate<typename It, typename ExtractKey>\nstatic void ska_sort(It begin, It end, ExtractKey && extract_key)\n{\n    detail::inplace_radix_sort<128, 1024>(begin, end, extract_key);\n}\n\ntemplate<typename It>\nstatic void ska_sort(It begin, It end)\n{\n    ska_sort(begin, end, detail::IdentityFunctor());\n}\n\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nnamespace IO {\n    const int BUFFER_SIZE = 1 << 15;\n\n    char input_buffer[BUFFER_SIZE];\n    int input_pos = 0, input_len = 0;\n\n    char output_buffer[BUFFER_SIZE];\n    int output_pos = 0;\n\n    char number_buffer[100];\n    uint8_t lookup[100];\n\n    void _update_input_buffer() {\n        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);\n        input_pos = 0;\n\n        if (input_len == 0)\n            input_buffer[0] = EOF;\n    }\n\n    inline char next_char(bool advance = true) {\n        if (input_pos >= input_len)\n            _update_input_buffer();\n\n        return input_buffer[advance ? input_pos++ : input_pos];\n    }\n\n    template<typename T>\n    inline void read_int(T &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == '-')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - '0');\n        } while (isdigit(next_char(false)));\n\n        if (negative)\n            number = -number;\n    }\n\n    template<typename T, typename... Args>\n    inline void read_int(T &number, Args &... args) {\n        read_int(number);\n        read_int(args...);\n    }\n\n    void _flush_output() {\n        fwrite(output_buffer, sizeof(char), output_pos, stdout);\n        output_pos = 0;\n    }\n\n    inline void write_char(char c) {\n        if (output_pos == BUFFER_SIZE)\n            _flush_output();\n\n        output_buffer[output_pos++] = c;\n    }\n\n    template<typename T>\n    inline void write_int(T number, char after = '\\0') {\n        if (number < 0) {\n            write_char('-');\n            number = -number;\n        }\n\n        int length = 0;\n\n        while (number >= 10) {\n            uint8_t lookup_value = lookup[number % 100];\n            number /= 100;\n            number_buffer[length++] = (lookup_value & 15) + '0';\n            number_buffer[length++] = (lookup_value >> 4) + '0';\n        }\n\n        if (number != 0 || length == 0)\n            write_char(number + '0');\n\n        for (int i = length - 1; i >= 0; i--)\n            write_char(number_buffer[i]);\n\n        if (after)\n            write_char(after);\n    }\n\n    void init() {\n        // Make sure _flush_output() is called at the end of the program.\n        bool exit_success = atexit(_flush_output) == 0;\n        assert(exit_success);\n\n        for (int i = 0; i < 100; i++)\n            lookup[i] = (i / 10 << 4) + i % 10;\n    }\n}\n\n\nconst int INF = 1e9 + 5;\n\nstruct salary {\n    int L, R;\n\n    bool operator<(const salary &other) const {\n        return L < other.L;\n    }\n};\n\nint N, H;\nlong long S;\nvector<salary> salaries;\n\nbool possible(int median) {\n    long long sum = 0;\n    int count = 0;\n\n    for (int i = N - 1; i >= 0; i--)\n        if (salaries[i].R >= median) {\n            sum += max(median - salaries[i].L, 0);\n            count++;\n\n            if (count == H || sum > S)\n                break;\n        }\n\n    return count == H && sum <= S;\n}\n\nvoid solve_case() {\n    IO::read_int(N, S);\n    H = (N + 1) / 2;\n    salaries.resize(N);\n\n    for (salary &s : salaries) {\n        IO::read_int(s.L, s.R);\n        S -= s.L;\n    }\n\n    ska_sort(salaries.begin(), salaries.end(), [](const salary &s) {\n        return s.L;\n    });\n\n    int low = 0, high = INF;\n\n    while (low < high) {\n        int mid = (low + high + 1) / 2;\n\n        if (possible(mid))\n            low = mid;\n        else\n            high = mid - 1;\n    }\n\n    IO::write_int(low, '\\n');\n}\n\nint main() {\n    IO::init();\n\n    int T;\n    IO::read_int(T);\n\n    while (T-- > 0)\n        solve_case();\n}\n   "
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Salary Changing.json",
    "editorial_link": "https://codeforces.com//blog/entry/70860",
    "editorial": "Let be equal minimum amount of money to obtain the median salary at\r\nleast . We\u00e2\u0080\u0099ll solve this problem by binary search by . Suppose the have\r\nto calculate the minimum amount of money for obtaining median salary at\r\nleast . Let\u00e2\u0080\u0099s divide all salaries into three groups: ; ; . In order to\r\nthe median salary be at least there must be at least salaries greater\r\nthan or equal to . Let\u00e2\u0080\u0099s denote the number of such salaries as .Note\r\nthat salaries of the first group can\u00e2\u0080\u0099t increment the value of , so it\u00e2\u0080\u0099s\r\nbeneficial for us to pay the minimum salary for this group. Salaries if\r\nsecond group always increment the value of , so it\u00e2\u0080\u0099s also beneficial for\r\nus to pay the minimum salary.The salaries from the third group are more\r\ninteresting. For each salary in this group we can pay and increment , or\r\nwe can pay and don\u00e2\u0080\u0099t increase . The value of should be increased by .\r\nSo, if the size of the third group is less than than we can\u00e2\u0080\u0099t obtain the\r\nmedian salary . Otherwise, we can define how many salaries we can take\r\nwith value and chose the minimal ones.\r\n"
}