{
    "link": "https://codeforces.com//contest/1217/problem/C",
    "problemId": "404645",
    "problem_idx": "C",
    "shortId": "1217C",
    "contest_number": "1217",
    "problem_submissions": {
        "F": [
            60119255,
            60118536,
            60117179,
            60112264,
            60128130,
            60127503,
            60126918,
            60123155,
            60108293,
            60125049,
            60146948,
            60128055,
            60130824,
            60133706,
            60133628,
            60133577,
            60133431,
            60148111,
            60128465,
            60130939,
            60194071,
            60161365,
            60161338,
            60161260,
            60133265,
            60131839
        ],
        "E": [
            60105066,
            60116418,
            60106390,
            60121938,
            60108304,
            60146942,
            60108305,
            60105389,
            60107537,
            60103856,
            60133910,
            60133496,
            60106424,
            60108802,
            60109228,
            60105208,
            60109038,
            60113612,
            60109155,
            60108937,
            60108739,
            60185912,
            60121211,
            60119745
        ],
        "D": [
            60093380,
            60096462,
            60101910,
            60101769,
            60146935,
            60099412,
            60094151,
            60095526,
            60100622,
            60098634,
            60099130,
            60111816,
            60100421,
            60093903,
            60100608,
            60099424,
            60113888,
            60106298,
            60107083
        ],
        "C": [
            60088873,
            60091347,
            60096256,
            60097679,
            60146931,
            60089815,
            60086473,
            60091850,
            60090230,
            60091598,
            60096228,
            60090577,
            60097512,
            60091408,
            60091681,
            60095632,
            60094356,
            60083533,
            60095174
        ],
        "B": [
            60085129,
            60084473,
            60090224,
            60089598,
            60146927,
            60087277,
            60084144,
            60085003,
            60086682,
            60087576,
            60086106,
            60085538,
            60094264,
            60087892,
            60094300,
            60089353,
            60089039,
            60094083,
            60086577
        ],
        "A": [
            60083114,
            60082761,
            60084492,
            60083647,
            60146918,
            60083293,
            60082871,
            60082868,
            60082958,
            60082935,
            60083622,
            60083726,
            60084591,
            60083527,
            60083900,
            60086802,
            60083832,
            60082824,
            60083536
        ]
    },
    "name": "C. The Number Of Good Substrings",
    "statement": "You are given a binary string s (recall that a string is binary if each\r\ncharacter is either 0 or 1).Let f(t) be the decimal representation of\r\ninteger t written in binary form (possibly with leading zeroes). For\r\nexample f(011) = 3, f(00101) = 5, f(00001) = 1, f(10) = 2, f(000) = 0\r\nand f(000100) = 4.The substring s_{l}, s_{l+1},\r\ndots , s_{r} is good if r - l + 1 = f(s_l\r\ndots s_r).For example string s = 1011 has 5 good substrings: s_1\r\ndots s_1 = 1, s_3\r\ndots s_3 = 1, s_4\r\ndots s_4 = 1, s_1\r\ndots s_2 = 10 and s_2\r\ndots s_4 = 011. Your task is to calculate the number of good substrings\r\nof string s.You have to answer t independent queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/05, 23:45:33\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nchar in[200002];\nint L[200001];\nllong solve() {\n    cin >> in + 1;\n    int n = strlen(in + 1);\n    L[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        if (in[i] == '0') L[i] = L[i - 1];\n        else L[i] = i + 1;\n    }\n    llong ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        int x = 0;\n        for (int j = i; j > 0 && i - j <= 20; --j) {\n            if (in[j] == '1') x |= 1 << i - j;\n            if (i - j + 1 == x) ++ans;\n        }\n        if (i - 20 > 1) {\n            int l = L[i - 20 - 1];\n            int mn = 22;\n            int mx = i - l + 1;\n            if (mn <= x && x <= mx) ++ans;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int T;\n    cin >> T;\n    while (T--) printf(\"%lld\\n\", solve());\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. The Number Of Good Substrings.json",
    "editorial_link": "https://codeforces.com//blog/entry/69605",
    "editorial": "At first, lets precalc the array . The value of if equal the maximum\r\nposition in range such that . After that lets iterate over the right\r\nboundary of substring and high -bit position (denote it as and\r\nrespectively).Note that if then .So we iterate over such pair that and\r\n.Lets look at value . If , then we have to increase the length of\r\nsubstring without increasing the value of . So we need to check if there\r\nexists a position such that and . This position exists if the condition\r\nis met ( is equal to -1).\r\n",
    "hint": []
}