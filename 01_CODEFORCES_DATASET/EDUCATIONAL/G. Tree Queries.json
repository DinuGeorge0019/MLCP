{
    "link": "https://codeforces.com//contest/825/problem/G",
    "problemId": "114550",
    "problem_idx": "G",
    "shortId": "825G",
    "contest_number": "825",
    "problem_submissions": {
        "G": [
            28611826,
            28611356,
            28617070,
            28630000,
            28611377,
            28668357,
            28644356,
            28617410,
            28616887,
            115447701,
            28617449
        ],
        "F": [
            28607801,
            28609631,
            28607347,
            28609116,
            28609094,
            28607614,
            28608923,
            28607754,
            28610528,
            28609319,
            28614043,
            28612882,
            28614726,
            28613035,
            28614128,
            28617246,
            28608834
        ],
        "E": [
            28606236,
            28612183,
            28603943,
            28604761,
            28605629,
            28605699,
            28621023,
            28620710,
            28614410,
            28606910,
            28606445,
            28612588,
            28606404,
            28608319,
            28610978,
            28607253,
            28602716,
            28604390,
            28605864
        ],
        "D": [
            28601870,
            28604440,
            28602315,
            28603224,
            28602271,
            28603578,
            28602162,
            28602307,
            28605123,
            28604422,
            28602824,
            28605475,
            28605112,
            28601966,
            28604848,
            28601067,
            28602879,
            28603271,
            28602582
        ],
        "C": [
            28600566,
            28604558,
            28600573,
            28601511,
            28601329,
            28600992,
            28600584,
            28601117,
            28602961,
            28602487,
            28601481,
            28603635,
            28602536,
            28600048,
            28601839,
            28599960,
            28601178,
            28600725,
            28600385
        ],
        "B": [
            28599824,
            28602822,
            28599867,
            28599843,
            28600338,
            28600036,
            28599560,
            28600486,
            28599738,
            28600276,
            28600463,
            28602528,
            28601519,
            28610253,
            28599911,
            28599338,
            28600292,
            28600011,
            28599745
        ],
        "A": [
            28598954,
            28602676,
            28599093,
            28599010,
            28599148,
            28598936,
            28599534,
            28599292,
            28599020,
            28598945,
            28599332,
            28601537,
            28599412,
            28598882,
            28598949,
            28598917,
            28599099,
            28599150,
            28598894
        ]
    },
    "name": "G. Tree Queries",
    "statement": "You are given a tree consisting of vertices (numbered from to ).\r\nInitially all vertices are white. You have to process queries of two\r\ndifferent types: change the color of vertex to black. It is guaranteed\r\nthat the first query will be of this type. for the vertex , find the\r\nminimum index such that the vertex with index belongs to the simple path\r\nfrom to some black vertex (a simple path never visits any vertex more\r\nthan once). For each query of type print the answer to it..\r\n",
    "solutions": [
        "#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n#include <memory>\n\ntemplate<class T>\nstruct BinTree1 {\n  size_t size;\n  std::vector<T> t;\n\n  BinTree1(size_t N) :\n      size(N),\n      t(2 * N, init()) {}\n\n  BinTree1(const std::vector<T>& other) :\n      size(other.size()),\n      t(2 * other.size()) {\n      std::copy(other.begin(), other.end(), t.begin() + size);\n      for (size_t i = size; i-- > 1;) {\n          t[i] = combine(t[2 * i], t[2 * i + 1]);\n      }\n  }\n\n  T get(size_t p) {\n      return t[p + size];\n  }\n\n  void modify(size_t p, T value) {\n      p += size;\n      t[p] = value;\n      while (p > 1) {\n          p = p / 2;\n          t[p] = combine(t[2 * p], t[2 * p + 1]);\n      }\n  }\n\n  T query(size_t l, size_t r) {\n      l += size;\n      r += size;\n      T left = init();\n      T right = init();\n      while (l < r) {\n          if (l & 1) {\n              left = combine(left, t[l]);\n              l++;\n          }\n          if (r & 1) {\n              r--;\n              right = combine(t[r], right);\n          }\n          l = l / 2;\n          r = r / 2;\n      }\n      return combine(left, right);\n  }\n\n private:\n  T combine(T left, T right) {\n      return std::min(left, right);\n  }\n\n  T init() {\n      return 1000000000;\n  }\n};\n\nstruct Solution {\n  int n;\n  std::unique_ptr<BinTree1<int>> tree;\n  std::vector<std::vector<int>> graph;\n  std::vector<int> left;\n  std::vector<int> right;\n  std::vector<int> value;\n  int dfs(int v, int prev, int order, int cur) {\n      value[v] = cur;\n      left[v] = order;\n      order++;\n      for (int nv : graph[v]) {\n          if (nv != prev) {\n              order = dfs(nv, v, order, std::min(cur, nv));\n          }\n      }\n      right[v] = order;\n      return order;\n  }\n\n  void init(int root) {\n      left.resize(n);\n      right.resize(n);\n      value.resize(n);\n      dfs(root, -1, 0, root);\n  }\n\n  void run(std::istream& in, std::ostream& out) {\n      int q;\n      in >> n >> q;\n      tree.reset(new BinTree1<int>(n));\n      graph.assign(n, std::vector<int>());\n      for (int i = 0; i < n - 1; i++) {\n          int from, to;\n          in >> from >> to;\n          from--;\n          to--;\n          graph[from].push_back(to);\n          graph[to].push_back(from);\n      }\n      int t, x;\n      in >> t >> x;\n      q--;\n      init(x % n);\n      int last = 0;\n      int minBlack = 1000000000;\n      for (int request = 0; request < q; request++) {\n          in >> t >> x;\n          x = (x + last) % n;\n          if (t == 1) {\n              minBlack = std::min(minBlack, value[x]);\n//              tree->modify(x, value[x]);\n          } else {\n              int res = std::min(value[x], minBlack);\n//              if (left[x] > 0) {\n//                  res = std::min(res, tree->query(0, left[x]));\n//              }\n//              if (right[x] < n) {\n//                  res = std::min(res, tree->query(right[x], n));\n//              }\n              last = res + 1;\n              out << last << std::endl;\n          }\n      }\n  }\n};\n\nint main() {\n    std::cin.sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    Solution().run(std::cin, std::cout);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Tree Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/53334",
    "editorial": "After the first query make the vertex that we painted black the root of\r\nthe tree and for each other vertex calculate the minimum index on the\r\npath to the root. This can be done by simple DFS.Then suppose we are\r\npainting some vertex black. In can easily proved that for every vertex\r\nand every vertex that is on a path form to the root there exists a path\r\nfrom to some black vertex coming through . So we have to store the\r\nminimum index among all vertices such that belongs to the path from the\r\nroot to some black vertex (it is a global value, letâs call it ), and\r\nthe answer to every query of type is just the minimum of the value we\r\ncalculated in DFS and . To update quickly after painting vertex black,\r\nwe ascend from to the root until we arrive to some node that was visited\r\nduring previous queries (and we stop there because this node and all\r\nnodes on the path from it to the root were used to update in previous\r\nqueries).This solution works in time.\r\n",
    "hint": []
}