{"link": "https://codeforces.com//contest/1721/problem/E", "problemId": "1521728", "problem_idx": "E", "shortId": "1721E", "contest_number": "1721", "problem_submissions": {"F": [169847425, 169855093, 169874051, 169859751, 169871554, 169869426, 169892039, 169866057, 169866260, 169879985, 169882444, 169880200, 169868972, 169943924, 169887978, 169882264, 169879150, 169868978, 169868554, 169884451, 169886386, 169884169, 169836583, 169890280, 169889729], "E": [169825445, 169831576, 169846355, 169845815, 169845247, 169849940, 170071212, 169840961, 169843652, 169842409, 169855809, 169853200, 169849055, 169861077, 169848556, 169841458, 169835951, 169859126, 169853059, 169861299, 169890819, 169860030, 169851763, 169839234], "D": [169816642, 169857780, 169827464, 169828353, 169825938, 169823055, 169827534, 169839208, 169826501, 169831272, 169830277, 169840516, 169830590, 169829045, 169820762, 169829319, 169841817, 169849956, 169828079, 169855346, 169832685], "C": [169812006, 169821873, 169865515, 169815093, 169818535, 169828842, 169823304, 169816953, 169821336, 169818460, 169821914, 169817547, 169822314, 169825383, 169842253, 169820059, 169823503, 169835000, 169824388, 169861925, 169815457], "B": [169804991, 169810857, 169806854, 169811441, 169813569, 169810575, 169808902, 169808903, 169811401, 169810906, 169807229, 169812143, 169813395, 169807352, 169812235, 169815520, 169825227, 169814779, 169864673, 169808536], "A": [169804030, 169804283, 169861742, 169804044, 169806500, 169805484, 169806996, 169804568, 169805103, 169805093, 169804586, 169804045, 169804642, 169805849, 169804015, 169804388, 169808577, 169817992, 169808806, 169866242, 169804342]}, "name": "E. Prefix Function Queries", "statement": "You are given a string s, consisting of lowercase Latin letters.You are\r\nasked q queries about it: given another string t, consisting of\r\nlowercase Latin letters, perform the following steps: concatenate s and\r\nt; calculate the prefix function of the resulting string s+t; print the\r\nvalues of the prefix function on positions |s|+1, |s|+2,\r\ndots, |s|+|t| (|s| and |t| denote the lengths of strings s and t,\r\nrespectively); revert the string back to s. The prefix function of a\r\nstring a is a sequence p_1, p_2,\r\ndots, p_{|a|}, where p_i is the maximum value of k such that k < i and\r\na[1..k]=a[i-k+1..i] (a[l..r] denotes a contiguous substring of a string\r\na from a position l to a position r, inclusive). In other words, it\u2019s\r\nthe longest proper prefix of the string a[1..i] that is equal to its\r\nsuffix of the same length.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::string s;\n    std::cin >> s;\n    \n    int n = s.length();\n    \n    std::vector<int> fail(n + 10 + 1);\n    fail[0] = -1;\n    std::vector<std::array<int, 26>> f(n + 10 + 1);\n    f[0][s[0] - 'a'] = 1;\n    fail[1] = 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < 26; j++) {\n            if (j == s[i] - 'a') {\n                f[i][j] = i + 1;\n                fail[i + 1] = f[fail[i]][j];\n            } else {\n                f[i][j] = f[fail[i]][j];\n            }\n        }\n    }\n    \n    int q;\n    std::cin >> q;\n    \n    while (q--) {\n        std::string t;\n        std::cin >> t;\n        \n        int m = t.length();\n        for (int i = n; i < n + m; i++) {\n            for (int j = 0; j < 26; j++) {\n                if (j == t[i - n] - 'a') {\n                    f[i][j] = i + 1;\n                    fail[i + 1] = f[fail[i]][j];\n                } else {\n                    f[i][j] = f[fail[i]][j];\n                }\n            }\n            std::cout << fail[i + 1] << \" \\n\"[i == n + m - 1];\n        }\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "hashing", "string suffix structures", "strings", "trees"], "dificulty": "2200", "interactive": false}