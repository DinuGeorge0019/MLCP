{
    "link": "https://codeforces.com//contest/1721/problem/E",
    "problemId": "1521728",
    "problem_idx": "E",
    "shortId": "1721E",
    "contest_number": "1721",
    "problem_submissions": {
        "F": [
            169847425,
            169855093,
            169874051,
            169859751,
            169871554,
            169869426,
            169892039,
            169866057,
            169866260,
            169879985,
            169882444,
            169880200,
            169868972,
            169943924,
            169887978,
            169882264,
            169879150,
            169868978,
            169868554,
            169884451,
            169886386,
            169884169,
            169836583,
            169890280,
            169889729
        ],
        "E": [
            169825445,
            169831576,
            169846355,
            169845815,
            169845247,
            169849940,
            170071212,
            169840961,
            169843652,
            169842409,
            169855809,
            169853200,
            169849055,
            169861077,
            169848556,
            169841458,
            169835951,
            169859126,
            169853059,
            169861299,
            169890819,
            169860030,
            169851763,
            169839234
        ],
        "D": [
            169816642,
            169857780,
            169827464,
            169828353,
            169825938,
            169823055,
            169827534,
            169839208,
            169826501,
            169831272,
            169830277,
            169840516,
            169830590,
            169829045,
            169820762,
            169829319,
            169841817,
            169849956,
            169828079,
            169855346,
            169832685
        ],
        "C": [
            169812006,
            169821873,
            169865515,
            169815093,
            169818535,
            169828842,
            169823304,
            169816953,
            169821336,
            169818460,
            169821914,
            169817547,
            169822314,
            169825383,
            169842253,
            169820059,
            169823503,
            169835000,
            169824388,
            169861925,
            169815457
        ],
        "B": [
            169804991,
            169810857,
            169806854,
            169811441,
            169813569,
            169810575,
            169808902,
            169808903,
            169811401,
            169810906,
            169807229,
            169812143,
            169813395,
            169807352,
            169812235,
            169815520,
            169825227,
            169814779,
            169864673,
            169808536
        ],
        "A": [
            169804030,
            169804283,
            169861742,
            169804044,
            169806500,
            169805484,
            169806996,
            169804568,
            169805103,
            169805093,
            169804586,
            169804045,
            169804642,
            169805849,
            169804015,
            169804388,
            169808577,
            169817992,
            169808806,
            169866242,
            169804342
        ]
    },
    "name": "E. Prefix Function Queries",
    "statement": "You are given a string s, consisting of lowercase Latin letters.You are\r\nasked q queries about it: given another string t, consisting of\r\nlowercase Latin letters, perform the following steps: concatenate s and\r\nt; calculate the prefix function of the resulting string s+t; print the\r\nvalues of the prefix function on positions |s|+1, |s|+2,\r\ndots, |s|+|t| (|s| and |t| denote the lengths of strings s and t,\r\nrespectively); revert the string back to s. The prefix function of a\r\nstring a is a sequence p_1, p_2,\r\ndots, p_{|a|}, where p_i is the maximum value of k such that k < i and\r\na[1..k]=a[i-k+1..i] (a[l..r] denotes a contiguous substring of a string\r\na from a position l to a position r, inclusive). In other words, it\u2019s\r\nthe longest proper prefix of the string a[1..i] that is equal to its\r\nsuffix of the same length.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::string s;\n    std::cin >> s;\n    \n    int n = s.length();\n    \n    std::vector<int> fail(n + 10 + 1);\n    fail[0] = -1;\n    std::vector<std::array<int, 26>> f(n + 10 + 1);\n    f[0][s[0] - 'a'] = 1;\n    fail[1] = 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < 26; j++) {\n            if (j == s[i] - 'a') {\n                f[i][j] = i + 1;\n                fail[i + 1] = f[fail[i]][j];\n            } else {\n                f[i][j] = f[fail[i]][j];\n            }\n        }\n    }\n    \n    int q;\n    std::cin >> q;\n    \n    while (q--) {\n        std::string t;\n        std::cin >> t;\n        \n        int m = t.length();\n        for (int i = n; i < n + m; i++) {\n            for (int j = 0; j < 26; j++) {\n                if (j == t[i - n] - 'a') {\n                    f[i][j] = i + 1;\n                    fail[i + 1] = f[fail[i]][j];\n                } else {\n                    f[i][j] = f[fail[i]][j];\n                }\n            }\n            std::cout << fail[i + 1] << \" \\n\"[i == n + m - 1];\n        }\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "hashing",
        "string suffix structures",
        "strings",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Prefix Function Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/106416",
    "editorial": "What\u00e2\u0080\u0099s the issue with calculating the prefix function on the string and\r\nthen appending the string with an extra recalculations? Calculating\r\nprefix function is linear anyway. Well, it\u00e2\u0080\u0099s linear, but it\u00e2\u0080\u0099s also\r\namortized. So while it will make operations for a string in total, it\r\ncan take up to on every particular letter. These particular letters can\r\nappear in string , making the algorithm work in .Let\u00e2\u0080\u0099s analyze the\r\nclassic way to calculate the prefix function. To append a character to\r\nthe string and calculate the new value of the prefix function, you have\r\nto do the following: take the longest proper prefix of a string before\r\nappending the letter, which is also a suffix; if the letter right after\r\nit is the same as the new one, then the new value is length of it plus\r\none; if it\u00e2\u0080\u0099s empty, then the new value is ; otherwise, take its longest\r\nproper prefix and return to step . Basically, from having the value of\r\nthe prefix function of the string and the new letter, you can determine\r\nthe new value of the prefix function.If was always equal to , then you\r\nwould only want to try all options for the next letter after a\r\nstring.That should remind you of a structure known as prefix function\r\nautomaton. Its states are the values of the prefix function, and the\r\ntransitions are appending a letter to a string with a certain value of\r\nthe prefix function.So you can append a letter in if you have an\r\nautomaton built on the string . However, you can\u00e2\u0080\u0099t just append more\r\nletters after one you don\u00e2\u0080\u0099t have the automaton built this far.You can\r\nfollow two paths.The first one is to jump with a regular way of\r\ncalculating the prefix function until you reach the state of the\r\nautomaton which exists.The second one is to continue building the\r\nautomaton onto the string , calculating the prefix function along the\r\nway. Appending a layer to the automaton takes non-amortized. After you\r\ncalculated everything you needed, pop the states back to the\r\noriginal.Overall complexity: or .\r\n"
}