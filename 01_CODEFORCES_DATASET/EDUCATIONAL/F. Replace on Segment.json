{
    "link": "https://codeforces.com//contest/1922/problem/F",
    "problemId": "2433279",
    "problem_idx": "F",
    "shortId": "1922F",
    "contest_number": "1922",
    "problem_submissions": {
        "F": [
            242258354,
            242278276,
            242274562,
            242271525,
            242258097,
            242274599,
            242271507,
            242268588,
            242285652,
            242271581,
            242270540,
            242278542,
            242282333,
            242270699,
            242270119,
            242276867,
            242286431,
            242276715,
            242276487,
            242283192,
            242281108,
            242278860,
            242278983,
            242285548
        ],
        "E": [
            242241568,
            242225493,
            242242029,
            242279592,
            242237693,
            242231955,
            242236354,
            242245342,
            242255638,
            242244187,
            242239291,
            242260117,
            242249388,
            242249138,
            242239806,
            242257431,
            242256396,
            242263321,
            242231103,
            242254535,
            242253629,
            242270325
        ],
        "D": [
            242234045,
            242236857,
            242236461,
            242246467,
            242239405,
            242245547,
            242240299,
            242240756,
            242237650,
            242234866,
            242248459,
            242242872,
            242244162,
            242252228,
            242244373,
            242239696,
            242254494,
            242245049,
            242250144,
            242243755,
            242246758
        ],
        "C": [
            242227385,
            242230966,
            242228502,
            242224242,
            242227745,
            242228850,
            242229081,
            242228504,
            242227487,
            242227235,
            242229333,
            242232708,
            242229815,
            242234164,
            242230429,
            242229813,
            242239026,
            242239967,
            242231740,
            242235920
        ],
        "B": [
            242220641,
            242221058,
            242221110,
            242219955,
            242221311,
            242233194,
            242221713,
            242221320,
            242222042,
            242223201,
            242221647,
            242219752,
            242221561,
            242226204,
            242224089,
            242222658,
            242227596,
            242222002,
            242224729,
            242223236
        ],
        "A": [
            242219259,
            242219714,
            242223200,
            242219077,
            242219362,
            242220179,
            242219565,
            242219194,
            242219734,
            242219881,
            242219505,
            242219046,
            242219400,
            242221402,
            242220981,
            242220554,
            242223002,
            242219741,
            242219322,
            242220234
        ]
    },
    "name": "F. Replace on Segment",
    "statement": "You are given an array a_1, a_2,\r\ndots, a_n, where each element is an integer from 1 to x.You can perform\r\nthe following operation with it any number of times: choose three\r\nintegers l, r and k such that 1\r\nle l\r\nle r\r\nle n, 1\r\nle k\r\nle x and element a_i such that l\r\nle i\r\nle r is different from k. Then, for each i\r\nin [l, r], replace a_i with k. In other words, you choose a subsegment\r\nof the array and an integer from 1 to x which does not appear in that\r\nsubsegment, and replace every element in the subsegment with that chosen\r\ninteger.Your goal is to make all elements in the array equal. What is\r\nthe minimum number of operations that you have to perform?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"  // https://github.com/Heltion/debug.h/blob/main/debug.h\n#else\n#define debug(...) (void)417\n#endif\nusing i64 = int64_t;\nconstexpr int time_test = false;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int t;\n  cin >> t;\n  if (time_test) { t = 5; }\n  for (int ti = 0; ti < t; ti += 1) {\n    int n, x;\n    cin >> n >> x;\n    if (time_test) {\n      n = 100;\n      x = 100;\n    }\n    vector<int> a(n);\n    for (int& ai : a) {\n      cin >> ai;\n      ai -= 1;\n      if (time_test) { ai = rand() % x; }\n    }\n    vector f(n, vector(n, vector<int>(x, n)));\n    vector g(n, vector(n, vector<int>(x, n)));\n    for (int j = 0; j < n; j += 1) {\n      for (int i = j; i >= 0; i -= 1) {\n        if (i == j) {\n          for (int k = 0; k < x; k += 1) {\n            f[i][j][k] = a[i] == k;\n            g[i][j][k] = a[i] != k;\n          }\n        } else {\n          for (int k = 0; k < x; k += 1) {\n            for (int m = i; m < j; m += 1) {\n              f[i][j][k] = min(f[i][j][k], f[i][m][k] + f[m + 1][j][k]);\n              g[i][j][k] = min(g[i][j][k], g[i][m][k] + g[m + 1][j][k]);\n            }\n          }\n          int mn = n, smn = n;\n          for (int k = 0; k < x; k += 1) {\n            g[i][j][k] = min(g[i][j][k], f[i][j][k] + 1);\n            if (g[i][j][k] < mn) {\n              smn = exchange(mn, g[i][j][k]);\n            } else if (g[i][j][k] < smn) {\n              smn = g[i][j][k];\n            }\n          }\n          for (int k = 0; k < x; k += 1) {\n            f[i][j][k] = min(f[i][j][k], g[i][j][k] == mn ? smn : mn);\n          }\n        }\n      }\n    }\n    cout << ranges::min(g[0].back()) << \"\\n\";\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "graph matchings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Replace on Segment.json",
    "editorial_link": "https://codeforces.com//blog/entry/124890",
    "editorial": "First of all, we claim the following: if you apply an operation on a\r\nsegment, you may treat the resulting segment as one element (i. e. we\r\ncan \"merge\" the elements affected by an operation into one). This is\r\nquite intuitive, but the formal proof is kinda long, so if youâre not\r\ninterested in it, feel free to skip the next paragraphs written in\r\nitalic. This means that after youâve done an operation on a segment, the\r\nnext operations will either affect that whole segment, or not affect any\r\nelement from the segment at all.This allows us to use the following\r\ndynamic programming idea: let be the minimum number of operations\r\nrequired to turn all elements on the segment into . If we want to\r\ntransform all elements into , then there are two options: either the\r\nlast operation will turn the whole segment into , so we need to\r\ncalculate the number of operations required to get rid of all elements\r\nequal to from the segment; or the segment can be split into several\r\nsegments which we will turn into separately. The second option can be\r\nmodeled quite easily: we iterate on the splitting point between two\r\nparts , and update with . However, the first option is a bit more\r\ncomplicated.Letâs introduce a second dynamic programming to our\r\nsolution: let be the minimum number of operations to remove all\r\noccurrences of from the segment . Then, the first option for computing\r\ncan be implemented by simply updating with .Now, letâs show how to\r\ncalculate . Itâs quite similar to the first dynamic programming: either\r\nthe last operation on the segment will turn the whole segment into some\r\nother element , so we can iterate on it and update with ; or the segment\r\ncan be split into two parts, and we will get rid of elements equal to\r\nfrom these parts separately (so we update with ). Okay, it looks like we\r\ngot a solution working in . Thereâs just one problem, though. There are\r\ncyclic dependencies in our dynamic programming: depends on ; depends on\r\n, where ; depends on ; depends on . We have to either somehow deal with\r\nthem, or get rid of them. The model solution eliminates these cyclic\r\ndependencies as follows: when we need to calculate , letâs discard all\r\nelements equal to from the ends of the segment (i. e. move to and to ,\r\nwhere and are the first and last occurrences of elements not equal to ).\r\nSimilarly, when we need to calculate , letâs discard all elements not\r\nequal to from the ends of the segment. Itâs quite easy to show that\r\nthese operations wonât make the answer worse (if you remove an element\r\nfrom an array, the minimum number of operations to \"fix\" the array\r\ndoesnât increase). Itâs also not that hard to show that this method gets\r\nrid of all cyclic dependencies: if we consider the cyclic dependency we\r\ndescribed earlier, we can see that the element will be discarded from\r\nthe segment either when computing (if ) or when computing (if ).That\r\nway, we get a dynamic programming solution working in .\r\n",
    "hint": []
}