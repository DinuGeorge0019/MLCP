{
    "link": "https://codeforces.com//contest/1837/problem/F",
    "problemId": "1937914",
    "problem_idx": "F",
    "shortId": "1837F",
    "contest_number": "1837",
    "problem_submissions": {
        "F": [
            207194085,
            207203613,
            207207682,
            207213171,
            207211865,
            207210824,
            207211176,
            207318425,
            207318356,
            207219269,
            207223400,
            207222112,
            207230081,
            209182293,
            207218386,
            207220953,
            207230258,
            207229992,
            207230774,
            207219053,
            207217652,
            207234599,
            207241428,
            207217300
        ],
        "E": [
            207188119,
            207194518,
            207187724,
            207193975,
            207201887,
            207200866,
            207200402,
            207204477,
            207201158,
            207203473,
            207202659,
            209182421,
            207206918,
            207295603,
            207295577,
            207295208,
            207212525,
            207205450,
            207220600,
            207221757,
            207209332,
            207208536,
            207213556,
            207215245,
            207197679
        ],
        "B": [
            207173438,
            207165428,
            207164196,
            207176139,
            207175678,
            207167732,
            207174974,
            207163573,
            207171463,
            207163877,
            207175371,
            207164199,
            207166728,
            209182537,
            207176961,
            207175758,
            207169369,
            207163934,
            207178400,
            207163937,
            207176249,
            207171837,
            207164338,
            207177413,
            207185470
        ],
        "D": [
            207172764,
            207180689,
            207175489,
            207169386,
            207180603,
            207183437,
            207177453,
            207182367,
            207184812,
            207187481,
            207183382,
            209182475,
            207187168,
            207187553,
            207189679,
            207186480,
            207191942,
            207180382,
            207189882,
            207187720,
            207180792
        ],
        "C": [
            207163791,
            207169258,
            207167268,
            207163200,
            207171135,
            207167990,
            207163968,
            207163247,
            207171084,
            207177546,
            207172770,
            209182511,
            207171094,
            207178509,
            207179374,
            207167154,
            207173221,
            207169406,
            207177662,
            207172590,
            207173505
        ],
        "A": [
            207156762,
            207156505,
            207156456,
            207156409,
            207157257,
            207156929,
            207156537,
            207156398,
            207156432,
            207157333,
            207156686,
            209182570,
            207157924,
            207157341,
            207156863,
            207156455,
            207156545,
            207156506,
            207157325,
            207156712,
            207156556
        ]
    },
    "name": "F. Editorial for Two",
    "statement": "Berland Intercollegiate Contest has just finished. Monocarp and\r\nPolycarp, as the jury, are going to conduct an editorial. Unfortunately,\r\nthe time is limited, since they have to finish before the closing\r\nceremony.There were n problems in the contest. The problems are numbered\r\nfrom 1 to n. The editorial for the i-th problem takes a_i minutes.\r\nMonocarp and Polycarp are going to conduct an editorial for exactly k of\r\nthe problems.The editorial goes as follows. They have a full problemset\r\nof n problems before them, in order. They remove n - k problems without\r\nchanging the order of the remaining k problems. Then, Monocarp takes\r\nsome prefix of these k problems (possibly, an empty one or all\r\nproblems). Polycarp takes the remaining suffix of them. After that, they\r\ngo to different rooms and conduct editorials for their problems in\r\nparallel. So, the editorial takes as much time as the longer of these\r\ntwo does.Please, help Monocarp and Polycarp to choose the problems and\r\nthe split in such a way that the editorial finishes as early as\r\npossible. Print the duration of the editorial.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int j = 0; j < n; j++){\n      cin >> a[j];\n    }\n    long long tv = 1000000000000000, fv = 0;\n    while (tv - fv > 1){\n      long long mid = (tv + fv) / 2;\n      vector<int> L(n + 1, 0);\n      priority_queue<int> pq1;\n      long long sum1 = 0;\n      for (int j = 0; j < n; j++){\n        pq1.push(a[j]);\n        sum1 += a[j];\n        if (sum1 > mid){\n          sum1 -= pq1.top();\n          pq1.pop();\n        }\n        L[j + 1] = pq1.size();\n      }\n      vector<int> R(n + 1, 0);\n      priority_queue<int> pq2;\n      long long sum2 = 0;\n      for (int j = n - 1; j >= 0; j--){\n        pq2.push(a[j]);\n        sum2 += a[j];\n        if (sum2 > mid){\n          sum2 -= pq2.top();\n          pq2.pop();\n        }\n        R[j] = pq2.size();\n      }\n      bool ok = false;\n      for (int j = 0; j <= n; j++){\n        if (L[j] + R[j] >= k){\n          ok = true;\n        }\n      }\n      if (ok){\n        tv = mid;\n      } else {\n        fv = mid;\n      }\n    }\n    cout << tv << endl;\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Editorial for Two.json",
    "editorial_link": "https://codeforces.com//blog/entry/116752",
    "editorial": "In the problem, we are asked to first choose problems, then fix a split\r\ninto a prefix and a suffix. But nothing stops us from doing that in\r\nreverse. Letâs fix the split of an entire problemset first, then choose\r\nsome () and problems to the left of the split and the remaining problems\r\nto the right of it.That allows us to proceed with some polynomial\r\nsolution already. Having fixed the split and , we only have to find\r\nshortest editorials to the left and shortest editorials to the right.\r\nItâs trivial to show that itâs optimal.That can be done in easily or if\r\nyou think a bit more. That solution doesnât really help with the full\r\none, so I wonât elaborate.Next, when we see something along the lines of\r\n\"minimize the maximum\", we think about binary search.Letâs try to apply\r\nit here. Binary search over the answer now we want the sum of the left\r\nand the right parts of the split to be less than or equal to some fixed\r\n.More specifically, there should exist some that the sum of smallest\r\nelements to the left is and the sum of smallest elements to the right is\r\n. Letâs say it differently. There should be at least elements to the\r\nleft with their sum being , same to the right. And once more. The\r\nlargest set with the sum to the left is of size at least , same to the\r\nright.But that doesnât really require that now, does it? Find the\r\nlargest set with the sum to the left and to the right. The sum of their\r\nsizes should be at least .Letâs calculate the size of this largest set\r\nfor all prefixes and all suffixes of the array. Then we will be able to\r\ncheck the condition in .You can precalculate the sizes for all prefixes\r\nin . The idea is the following. Take the set for some prefix . Add the\r\n-st element to it. If its sum is , then itâs the new set. Otherwise,\r\nkeep removing the largest element from it until the sum becomes .That\r\nsolution is , where is the sum of the array, so you should be careful\r\nwith the constant factor. For example, doing it with a multiset or with\r\na segment tree probably wonât pass. priority_queue is fast enough,\r\nthough.However, we can do it faster. Imagine a solution with the\r\nmultiset. Letâs replace it with a doubly-linked list.In particular, we\r\nwant the following operations: insert an element in it; check and remove\r\nthe last element from it. If we never removed any element, we would be\r\nable to determine where to insert each element. We can just precalculate\r\nthat before the binary search in . For each element, find the largest\r\nelement less than or equal to it and to the left of it. That would be\r\nthe previous element when this one is inserted.When we remove elements,\r\nit can happen that this previous element was already removed when we\r\nattempt to insert this one. We can use the specificity of the problem to\r\navoid that issue. Notice that if we removed an element less than or\r\nequal to the current one, then the current one could never be inside an\r\noptimal multiset. So we can just skip this element.To implement such a\r\nlist, we can renumerate all elements into values from to (in order of ).\r\nThen, for each store the value of the previous and the next elements\r\nexisting in the list. For convenience, you can also add nodes and ,\r\ndenoting the tail and the head of the list.Then insert and remove is\r\njust rearranging some links to the previous and the next\r\nelements.Overall complexity: per testcase, where is the sum of the\r\narray.\r\n",
    "hint": []
}