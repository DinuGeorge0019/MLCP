{
    "link": "https://codeforces.com//contest/1167/problem/C",
    "problemId": "344632",
    "problem_idx": "C",
    "shortId": "1167C",
    "contest_number": "1167",
    "problem_submissions": {
        "G": [
            54199521,
            54201009,
            54517594,
            54222661,
            54364012,
            54215552,
            54224700,
            54210170,
            54210125,
            54210060,
            54209496,
            54208961,
            54219271,
            58247930
        ],
        "F": [
            54189763,
            54191560,
            54188017,
            54193815,
            54198047,
            54197721,
            54195395,
            54190513,
            54198962,
            54198980,
            54197783,
            54198116,
            54209016,
            54200221,
            54197337,
            54195561,
            54196921,
            54190680,
            54201016,
            54197503,
            54199324
        ],
        "E": [
            54187099,
            54187335,
            54196048,
            54186318,
            54187789,
            54191563,
            54192086,
            54195810,
            54191131,
            54191667,
            54192242,
            54194803,
            54192777,
            54191266,
            54189610,
            54192694,
            54196385,
            54241812,
            54208508,
            54196237,
            54192975,
            54196282
        ],
        "D": [
            54184655,
            54183868,
            54182601,
            54254072,
            54187816,
            54183265,
            54184958,
            54187415,
            54186508,
            54185650,
            54184214,
            54187917,
            54185330,
            54215169,
            54214062,
            54213957,
            54213940,
            54212912,
            54212894,
            54186804,
            54192578,
            54182335,
            54185963,
            54184762,
            54186406,
            54188164,
            54188808
        ],
        "C": [
            54183325,
            54182652,
            54179797,
            54181639,
            54180270,
            54183029,
            54186018,
            54184791,
            54184638,
            54183698,
            54183060,
            54181938,
            54183556,
            54183141,
            54183089,
            54180288,
            54184423,
            54183220,
            54184555,
            54185863,
            54182921
        ],
        "B": [
            54182048,
            54181521,
            54184836,
            54179971,
            54182085,
            54181491,
            54183487,
            54185276,
            54182631,
            54181677,
            54186071,
            54182415,
            54181445,
            54182146,
            54198453,
            54183319,
            54181503,
            54182555,
            54184235,
            54186573
        ],
        "A": [
            54178078,
            54178458,
            54177903,
            54177871,
            54177876,
            54178109,
            54178374,
            54178382,
            54178054,
            54178274,
            54179924,
            54177952,
            54177881,
            54177926,
            54178075,
            54177978,
            54177900,
            54179121,
            54179411,
            54179558
        ]
    },
    "name": "C. News Distribution",
    "statement": "In some social network, there are n users communicating with each other\r\nin m groups of friends. Let\u2019s analyze the process of distributing some\r\nnews between users.Initially, some user x receives the news from some\r\nsource. Then he or she sends the news to his or her friends (two users\r\nare friends if there is at least one group such that both of them belong\r\nto this group). Friends continue sending the news to their friends, and\r\nso on. The process ends when there is no pair of friends such that one\r\nof them knows the news, and another one doesn\u2019t know.For each user x you\r\nhave to determine what is the number of users that will know the news if\r\ninitially only user x starts distributing it.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n, m;\n\nint oj[nax];\nint roz[nax];\n\nint fin(int v)\n{\n\tif (v!=oj[v])\n\t\toj[v]=fin(oj[v]);\n\treturn oj[v];\n}\n\nvoid uni(int a, int b)\n{\n\ta=fin(a);\n\tb=fin(b);\n\toj[a]=b;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i=1; i<=n; i++)\n\t\toj[i]=i;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint x, y;\n\t\tint p=-1;\n\t\tscanf(\"%d\", &x);\n\t\twhile(x--)\n\t\t{\n\t\t\tscanf(\"%d\", &y);\n\t\t\tif (p==-1)\n\t\t\t\tp=y;\n\t\t\tuni(p, y);\n\t\t}\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\troz[fin(i)]++;\n\tfor (int i=1; i<=n; i++)\n\t\tprintf(\"%d \", roz[fin(i)]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dsu",
        "graphs"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. News Distribution.json",
    "editorial_link": "https://codeforces.com/blog/entry/67058",
    "editorial": "The first intention after reading the problem is to reformulate it in\r\ngraph theory terms. Let people be vertices, edge between two vertices\r\nand exists if and have some group in common. Basically, if person starts\r\ndistributing the news, everyone in his connectivity component recieves\r\nit. Thus, the task is to calculate the number of vertices of each vertex\r\ncomponent.As of now, the graph can have up to edges (consider the case\r\nwhere everyone is in the same group). Let\u00e2\u0080\u0099s reduce the number of edges\r\nwithout changing connectivity components. For each group you know for\r\nsure that people in it are in the same component. Let\u00e2\u0080\u0099s connect not just\r\nevery pair of vertices in it, but every pair of neighbouring ones in\r\neach group. It\u00e2\u0080\u0099s easy to see that they are still in the same\r\ncomponent.This graph will have edges which is a much smaller number. You\r\ncan use dfs or dsu to find the components and their sizes.Overall\r\ncomplexity: .\r\n"
}