{
    "link": "https://codeforces.com//contest/678/problem/F",
    "problemId": "62344",
    "problem_idx": "F",
    "shortId": "678F",
    "contest_number": "678",
    "problem_submissions": {
        "F": [
            18453131,
            18420467,
            18425171,
            18429408,
            18431074,
            18428972,
            18515149,
            18432045,
            89962482,
            18522658,
            18427723
        ],
        "E": [
            18423856,
            18426719,
            18424135,
            18422717,
            18424399,
            18422688,
            18421665,
            18423374,
            18424000,
            18427338,
            18425849,
            18427192,
            18423884,
            18423912,
            18423782,
            18423439,
            18422852,
            18426690,
            18426397,
            18430230,
            18428108
        ],
        "D": [
            18422167,
            18420673,
            18421079,
            18421585,
            18418234,
            18420418,
            18420469,
            18421143,
            18421608,
            18420811,
            18420770,
            18422521,
            18422464,
            18421452,
            18418864,
            18420342,
            18421560,
            18422253,
            18422291,
            18423193
        ],
        "C": [
            18421205,
            18418762,
            18419353,
            18420283,
            18419554,
            18419287,
            18418669,
            18419102,
            18419489,
            18418869,
            18419091,
            18419530,
            18417774,
            18417333,
            18422755,
            18419713,
            18418829
        ],
        "B": [
            18418891,
            18418100,
            18418460,
            18419775,
            18420991,
            18418525,
            18417867,
            18418207,
            18418651,
            18418012,
            18418189,
            18420158,
            18418599,
            18418750,
            18419513,
            18418365,
            18418476,
            18418554,
            18418016
        ],
        "A": [
            18417154,
            18416577,
            18416530,
            18416541,
            18416507,
            18416774,
            18416581,
            18416781,
            18417063,
            18416573,
            18416637,
            18417124,
            18416520,
            18416522,
            18416509,
            18417176,
            18416817,
            18416584
        ]
    },
    "name": "F. Lena and Queries",
    "statement": "Lena is a programmer. She got a task to solve at work.There is an empty\r\nset of pairs of integers and queries to process. Each query is one of\r\nthree types: Add a pair to the set. Remove a pair added in the query\r\nnumber . All queries are numbered with integers from to . For a given\r\ninteger find the maximal value over all pairs from the set. Help Lena to\r\nprocess the queries.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cassert>\n#include <set>\nusing namespace std;\ntypedef long long LL;\nconst int N = 300005;\nstruct Point {\n    int x , y;\n    Point (int _x = 0 , int _y = 0) {\n        x = _x;\n        y = _y;\n    }\n    Point operator - (const Point& R) const {\n        return Point(x - R.x , y - R.y);\n    }\n    LL operator ^ (const Point& R) const {\n        return (LL)x * R.y - (LL)y * R.x;\n    }\n    LL operator % (const Point& R) const {\n        return (LL)x * R.x + (LL)y * R.y;\n    }\n    bool operator < (const Point &R) const {\n        if (x != R.x)\n            return x < R.x;\n        return y < R.y;\n    }\n};\nint n , m , p;\nPoint W[N] , K[N];\nmap<Point , int> Hash;\nLL res[N] , ans[N];\nint a[N];\n\nbool cmpP(const int &A , const int &B) {\n    return W[A] < W[B];\n}\nbool cmpQ(const int &A , const int &B) {\n    return (LL)K[A].x * K[B].y < (LL)K[B].x * K[A].y;\n}\nvoid update(vector<int>& P , vector<int>& Q) {\n    if (P.empty() || Q.empty())\n        return;\n    sort(P.begin() , P.end() , cmpP);\n    vector<int> A , B;\n    for (int i = 0 ; i < Q.size() ; ++ i)\n        if (K[Q[i]].y >= 0) {\n            A.push_back(Q[i]);\n        } else {\n            B.push_back(Q[i]);\n        }\n    sort(A.begin() , A.end() , cmpQ);\n    sort(B.begin() , B.end() , cmpQ);\n    vector<Point> s(P.size() + 1);\n    int t = 0;\n    for (int i = 0 ; i < P.size() ; ++ i) {\n        Point D = W[P[i]];\n        while (t > 1 && ((D - s[t - 2]) ^ (s[t - 1] - s[t - 2])) <= 0)\n            -- t;\n        s[t ++] = D;\n    }\n    for (int i = 0 , j = 0 ; i < A.size() ; ++ i) {\n        while (j + 1 < t && (K[A[i]] % s[j + 1]) >= (K[A[i]] % s[j]))\n            ++ j;\n        res[A[i]] = max(res[A[i]] , K[A[i]] % s[j]);\n    }\n\n    t = 0;\n    for (int i = 0 ; i < P.size() ; ++ i) {\n        Point D = W[P[i]];\n        while (t > 1 && ((D - s[t - 2]) ^ (s[t - 1] - s[t - 2])) >= 0)\n            -- t;\n        s[t ++] = D;\n    }\n    reverse(A.begin() , A.end());\n    reverse(B.begin() , B.end());\n    for (int i = 0 , j = 0 ; i < B.size() ; ++ i) {\n        while (j + 1 < t && (K[B[i]] % s[j + 1]) >= (K[B[i]] % s[j]))\n            ++ j;\n        res[B[i]] = max(res[B[i]] , K[B[i]] % s[j]);\n    }\n}\nint del[N];\nvoid divide(const vector<int> &A) {\n    if (A.size() <= 1)\n        return;\n    vector<int> P , Q;\n    int r = A.size() , mid = r / 2;\n    for (int i = 0 ; i < mid ; ++ i)\n        P.push_back(A[i]);\n    divide(P);\n    P.clear();\n    for (int i = 0 ; i < r ; ++ i)\n        if (A[i] > 0 && (A[i] & 1))\n            del[A[i] >> 1] = 1;\n    for (int i = 0 ; i < mid ; ++ i)\n        if (A[i] > 0 && (~A[i] & 1)) {\n            if (!del[A[i] >> 1])\n                P.push_back(A[i] >> 1);\n            else\n                del[A[i] >> 1] = 2;\n        }\n    for (int i = mid ; i < r ; ++ i)\n        if (A[i] < 0)\n            Q.push_back(-A[i]);\n    update(P , Q);\n    Q.clear();\n    int c1 = 0 , c2 = 0;\n    for (int i = r - 1 ; i >= mid ; -- i) {\n        if (A[i] > 0 && (A[i] & 1) && del[A[i] >> 1] == 2) {\n            Q.push_back(A[i] ^ 1);\n            ++ c1;\n        } else if (A[i] < 0) {\n            Q.push_back(A[i]);\n            ++ c2;\n        }\n    }\n    for (int i = 0 ; i < r ; ++ i)\n        if (A[i] > 0 && (A[i] & 1))\n            del[A[i] >> 1] = 0;\n    if (c1 && c2)\n        divide(Q);\n    P.clear();\n    for (int i = mid ; i < r ; ++ i)\n        P.push_back(A[i]);\n    divide(P);\n}\nint iid[N];\nvoid work() {\n    scanf(\"%d\" , &n);\n    vector<int> A;\n    for (int i = 0; i < n ; ++ i) {\n        Point S;\n        scanf(\"%d\" , &a[i]);\n        if (a[i] == 3) {\n            scanf(\"%d\" , &S.x);\n            S.y = 1;\n            ++ m;\n            res[m] = -1LL << 60;\n            K[m] = S;\n            a[i] = -m;\n        } else {\n            if (a[i] == 1) {\n                scanf(\"%d%d\" , &S.x , &S.y);\n                W[++ p] = S;\n                iid[i] = p;\n                //Hash[S] = p;\n                a[i] = p << 1;\n            } else {\n                int j;\n                scanf(\"%d\" , &j);\n                a[i] = iid[j - 1] << 1 | 1;\n                //Hash.erase(S);\n            }\n        }\n        A.push_back(a[i]);\n    }\n    divide(A);\n    for (int i = 1 ; i <= m ; ++ i) {\n        if (res[i] == -1LL << 60) {\n            puts(\"EMPTY SET\");\n        } else {\n            printf(\"%lld\\n\" , res[i]);\n        }\n    }\n}\n\nint main() {\n    work();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "geometry"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Lena and Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/45405",
    "editorial": "The problem was suggested by AmirMohammad Dehghan PrinceOfPersia. Let\u00e2\u0080\u0099s\r\ninterpret the problem geometrically: the pairs from the set are the\r\nlines and the problem to find to topmost intersection of the vertical\r\nline with the lines from the set. Let\u00e2\u0080\u0099s split the queries to blocks.\r\nConsider the lines added before the current block and that will not\r\ndeleted in the current block. Let\u00e2\u0080\u0099s build the lower envelope by that\r\nlines. Now to calculate the answer to the query we should get maximum\r\nover the lines from the envelope and the lines from the block before the\r\ncurrent query that is not deleted yet. There are no more than lines from\r\nthe block, so we can iterate over them. Let\u00e2\u0080\u0099s find the answers from the\r\nenvelope for all queries of the third type from the block at once: we\r\nshould sort them and iterate over envelope using two pointers technique.\r\nC++ solution\r\n"
}