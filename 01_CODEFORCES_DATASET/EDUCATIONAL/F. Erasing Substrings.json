{
    "link": "https://codeforces.com//contest/938/problem/F",
    "problemId": "157308",
    "problem_idx": "F",
    "shortId": "938F",
    "contest_number": "938",
    "problem_submissions": {
        "G": [
            35382589,
            142741934,
            35374754,
            35374730,
            35374710,
            35374477,
            46133767,
            35440047
        ],
        "F": [
            35355120,
            35364585,
            35363394,
            35363174,
            35367302,
            35374806,
            35369385,
            35368951,
            35367527,
            35361321,
            35357853,
            35375040,
            35422822
        ],
        "E": [
            35352538,
            35354313,
            35352415,
            35358415,
            35352081,
            35358431,
            35356947,
            35369123,
            35351851,
            35352768,
            35353204,
            35355446,
            35355331,
            35364623,
            35352359,
            35354851,
            35364184,
            35361370,
            35349789
        ],
        "D": [
            35346635,
            35346136,
            35347680,
            35354109,
            35356864,
            35352477,
            35380385,
            35375255,
            35364649,
            35366010,
            35347274,
            35349910,
            35350445,
            35351420,
            35351959,
            35348864,
            35350459,
            35349429,
            35350797,
            35351471,
            35353004
        ],
        "C": [
            35345282,
            35350127,
            35345829,
            35352431,
            35355200,
            35349840,
            35349239,
            35363657,
            35345361,
            35347976,
            35348608,
            35349044,
            35347701,
            35346898,
            35346389,
            35351193,
            35383156,
            35355323,
            35348814,
            35348388,
            35350097,
            35356762
        ],
        "B": [
            35342225,
            35343255,
            35342194,
            35342912,
            35343411,
            35345634,
            35362645,
            35360273,
            35342183,
            35342830,
            35342648,
            35343913,
            35343057,
            35342574,
            35342930,
            35343254,
            35345517,
            35342996,
            35357602
        ],
        "A": [
            35341839,
            35341862,
            35342757,
            35341910,
            35341845,
            35344578,
            35362076,
            35359775,
            35341793,
            35341960,
            35341885,
            35342136,
            35341987,
            35341868,
            35342317,
            35344022,
            35341914,
            35342769
        ]
    },
    "name": "F. Erasing Substrings",
    "statement": "You are given a string , initially consisting of lowercase Latin\r\nletters. After that, you perform operations with it, where . During -th\r\noperation you erase some substring of length exactly from .Print the\r\nlexicographically minimal string you may obtain after performing such\r\noperations.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 19;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nchar in[5050];\nbool dp[5050];\n\nbool dp2[14][5050];\n\nint DEBUG = 0;\nint main() {\n\tint N, i, j, k;\n\tif(!DEBUG) scanf(\"%s\", in);\n\telse for (i = 0; i < 5000; i++) in[i] = 'a';\n\tN = strlen(in);\n\tint c = (int)(log2(N) + 1e-9);\n\n\tint M = N - ((1 << c) - 1);\n\tdp[0] = true;\n\tfor (i = 0; i < M; i++) {\n\t\tfor (j = 0; j <= c; j++) for (k = 0; k < (1 << c); k++) dp2[j][k] = false;\n\t\tfor (j = 0; j < (1 << c); j++) dp2[0][j] = dp[j];\n\t\tfor (j = 0; j < c; j++) {\n\t\t\tfor (k = 0; k < (1<<c); k++) {\n\t\t\t\tdp2[j + 1][k] |= dp2[j][k];\n\t\t\t\tdp2[j + 1][k | (1 << j)] |= dp2[j][k];\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < (1 << c); j++) dp[j] = dp2[c][j];\n\n\t\tchar mn = 'z' + 1;\n\t\tfor (j = 0; j < (1 << c); j++) {\n\t\t\tint p = j + i;\n\t\t\tif (!dp[j] || p >= N) continue;\n\t\t\tmn = min(mn, in[p]);\n\t\t}\n\t\tfor (j = 0; j < (1 << c); j++) {\n\t\t\tint p = j + i;\n\t\t\tif (!dp[j] || p >= N || in[p] != mn) dp[j] = false;\n\t\t}\n\t\tprintf(\"%c\", mn);\n\t}\n\treturn !printf(\"\\n\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "greedy"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Erasing Substrings.json",
    "editorial_link": "https://codeforces.com//blog/entry/57840",
    "editorial": "Let's denote n?=?|s|.\n\nHint: There is a simple  solution: dp[m][mask] Â— best answer if we considered first m characters of the string and a mask of erased substrings. However, storing a string as a result of each state won't fit neither into time limit nor into memory limit. Can we make it faster?\n\nSolution\nLet's try to apply some greedy observations. Since each state represents a possible prefix of the resulting string, then among two states dp[m1][mask1] and dp[m2][mask2] such that the lenghts of corresponding prefixes are equal, but the best answers for states are not equal, we don't have to consider the state with lexicographically greater answer. So actually for every length of prefix there exists only one best prefix we will get, and we may store a boolean in each state instead of a string. The boolean will denote if it is possible to get to corresponding state with minimum possible prefix.\n\nTo calculate this, we iterate on the lengths of prefixes of the resulting string. When we fix the length of prefix, we firstly consider dynamic programming transitions that denote deleting a substring (since they don't add any character). Then among all states dp[m][mask] that allow us to reach some fixed length of prefix and have dp[m][mask]?=?true we pick the best character we can use to proceed to next prefix (and for a fixed state that's actually (m?+?1)-th character of the string).\n\nThis is , but in fact it's pretty fast.",
    "hint": []
}