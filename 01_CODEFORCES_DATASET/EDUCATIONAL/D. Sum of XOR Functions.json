{
    "link": "https://codeforces.com//contest/1879/problem/D",
    "problemId": "2226288",
    "problem_idx": "D",
    "shortId": "1879D",
    "contest_number": "1879",
    "problem_submissions": {
        "F": [
            224937536,
            224935202,
            224950610,
            224926179,
            224962842,
            224969051,
            224930929,
            224967422,
            224963265,
            224966461,
            224940572,
            224966841,
            224954569,
            225047271,
            224982141,
            224973229,
            225020484,
            225376642,
            224974176,
            225441069
        ],
        "E": [
            224915766,
            224914283,
            224947954,
            224935300,
            224927963,
            224966463,
            224932997,
            224929889,
            224950618,
            224966233,
            224954318,
            224969484,
            224930880,
            224920140,
            224922897,
            224920584,
            224928749,
            224925724,
            224924188,
            224933925
        ],
        "D": [
            224888044,
            224890483,
            224896670,
            224904072,
            224896642,
            224898559,
            224895640,
            224898718,
            224909765,
            224890763,
            224903520,
            224917804,
            224935485,
            224900120,
            224899388,
            224897270,
            224896991,
            224895504,
            224897180,
            224904052
        ],
        "C": [
            224883111,
            224886635,
            224905698,
            224893770,
            224888377,
            224894906,
            224886723,
            224893779,
            224902835,
            224885562,
            224895691,
            224922809,
            224940882,
            224893191,
            224888785,
            224888462,
            224890469,
            224889684,
            224903420,
            224892974
        ],
        "B": [
            224880512,
            224883808,
            224889537,
            224888023,
            224883379,
            224885924,
            224899117,
            224885706,
            224885740,
            224883031,
            224886861,
            224914364,
            224945905,
            224884557,
            224881988,
            224884765,
            224884529,
            224883777,
            224884553,
            224888797
        ],
        "A": [
            224880000,
            224880258,
            224880343,
            224880667,
            224881398,
            224880389,
            224901703,
            224881377,
            224880233,
            224880172,
            224880548,
            224906481,
            224947822,
            224880196,
            224880217,
            225049284,
            224880515,
            224880208,
            224880388,
            224880513,
            224881480
        ]
    },
    "name": "D. Sum of XOR Functions",
    "statement": "You are given an array a of length n consisting of non-negative\r\nintegers.You have to calculate the value of\r\nsum_{l=1}^{n}\r\nsum_{r=l}^{n} f(l, r)\r\ncdot (r - l + 1), where f(l, r) is a_l\r\noplus a_{l+1}\r\noplus\r\ndots\r\noplus a_{r-1}\r\noplus a_r (the character\r\noplus denotes bitwise XOR).Since the answer can be very large, print it\r\nmodulo 998244353.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 998244353;\nconst char nl = '\\n';\nconst int MX = 100001; \n\nvoid solve() {\n    int N; cin >> N;\n    ll A[N]; F0R(i, N) cin >> A[i];\n    ll ans = 0;\n    F0R(b, 30) {\n        ll cb = 1ll<<b;\n        ll cnt[2]; F0R(i, 2) cnt[i] = 0;\n        cnt[0] = 1;\n        ll sum[2]; F0R(i, 2) sum[i] = 0;\n        ll cur = 0;\n        F0R(i, N) {\n            if (A[i]&cb) cur ^= 1;\n            cnt[cur]++;\n            sum[cur] += i+1;\n            ll cv = cnt[cur^1] * (i+1) - sum[cur^1];\n            cv %= MOD;\n            ans += cv * cb;\n            ans %= MOD;\n        }\n    }\n    cout << ans << nl;\n\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "divide and conquer",
        "dp",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Sum of XOR Functions.json",
    "editorial_link": "https://codeforces.com//blog/entry/120773",
    "editorial": "Let\u00e2\u0080\u0099s solve this problem for each bit separately.When we fix a bit\r\n(let\u00e2\u0080\u0099s denote it as ), all we have to do is solve the original problem\r\nfor a binary string (let\u00e2\u0080\u0099s denote this string as ). Note that if there\r\nis an odd number of \u00e2\u0080\u0099s on a segment, the value of XOR on the segment is\r\n, otherwise it\u00e2\u0080\u0099s . So, for a fixed bit , we have to calculate , where if\r\nthe number of character in substring is odd, otherwise .Now let\u00e2\u0080\u0099s figure\r\nout how to solve this problem if the right border of substrings is fixed\r\n(let\u00e2\u0080\u0099s denote it as ). Let\u00e2\u0080\u0099s denote a function (which we call ) that is\r\nequal to the number of \u00e2\u0080\u0099s on the prefix of length modulo . So, if there\r\nis an even number of \u00e2\u0080\u0099s among the first characters, then , otherwise .\r\nIf we fix the right border of a substring is fixed, we need to consider\r\nsuch left borders that and . We have to maintain the number of such left\r\nborders (let it be for borders which have ) and their total sum (let it\r\nbe for borders which have ). These values can be easily maintained as we\r\niterate on .Why do we need these values? We can calculate the value of\r\nfor a fixed right border , if we denote the length of the segment as the\r\ndifference between the right border and the left border (we can discard\r\nfrom this formula if we treat as an inclusive border, and as an\r\nexclusive border). So, can be rephrased as the difference between the\r\nsum of right borders of those segments (which is equal to multiplied by\r\nthe number of different left borders) and the sum of left borders of\r\nthese segments (which is maintained in ). Now we just need to iterate on\r\nthe right border and sum this up while maintaining the values of and .\r\nDon\u00e2\u0080\u0099t forget that we solved the problem only for the bit , we need to\r\ncombine the results for every bit later (and make sure that we multiply\r\nthe result for the -th bit by ).Overall complexity is , where is the\r\nconstraint on the values in the array.\r\n"
}