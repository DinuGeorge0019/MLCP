{"link": "https://codeforces.com//contest/1739/problem/F", "problemId": "1559868", "problem_idx": "F", "shortId": "1739F", "contest_number": "1739", "problem_submissions": {"F": [173982711, 173969607, 173981022, 173986288, 173992146, 173980539, 173991072, 173980378, 173978555, 174245795, 174000933, 173993564, 173995270, 173994662, 173995645, 173994787, 173991035, 173995175, 173975986, 173996342, 173995107, 173986566], "E": [173962909, 173976378, 173969496, 173967080, 173967227, 173969366, 173969799, 173988104, 173970277, 173983172, 173983299, 173978308, 173974083, 173979712, 173983159, 173980060, 173986740, 173979502, 173967920], "D": [173953446, 173954284, 173959501, 173953114, 173950233, 173963545, 173960383, 173950745, 173966040, 173950883, 173962543, 173951795, 173957703, 173966024, 173951939, 173967693, 173958723, 173974529, 173956732], "C": [173946487, 173945498, 173949713, 174075655, 174075624, 173946209, 173940986, 173958498, 173954556, 173955135, 173961377, 173958964, 173957077, 173960274, 173951680, 173958743, 173985617, 173961155, 173949432, 173968872, 173953205], "B": [173936382, 173937044, 173937069, 173935458, 173935314, 173943298, 173937530, 173935389, 173954918, 173937400, 173937767, 173940608, 173940106, 173945520, 173936795, 173941470, 173938759, 173964539, 173936543], "A": [173934470, 173935151, 173934498, 173934222, 173934344, 173939803, 173934700, 173934286, 173952986, 173934928, 173934527, 173936084, 173935340, 173938305, 173937802, 173937555, 173935130, 173963081, 173934367]}, "name": "F. Keyboard Design", "statement": "Monocarp has a dictionary of n words, consisting of 12 first letters of\r\nthe Latin alphabet. The words are numbered from 1 to n. In every pair of\r\nadjacent characters in each word, the characters are different. For\r\nevery word i, Monocarp also has an integer c_i denoting how often he\r\nuses this word.Monocarp wants to design a keyboard that would allow him\r\nto type some of the words easily. A keyboard can be denoted as a\r\nsequence of 12 first letters of the Latin alphabet, where each letter\r\nfrom to appears exactly once.A word can be typed with the keyboard\r\neasily if, for every pair of adjacent characters in the word, these\r\ncharacters are adjacent in the keyboard as well. The of the keyboard is\r\nthe sum of c_i over all words i that can be typed easily with it.Help\r\nMonocarp to design a keyboard with the maximum possible optimality.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    map<string, int> a;\n    for (int i = 0; i < n; i++) {\n        int c;\n        string s;\n        cin >> c >> s;\n        deque<char> d;\n        d.emplace_back(s[0]);\n        d.emplace_back(s[1]);\n        int now = 1;\n        for (int j = 2; j < (int) s.size(); j++) {\n            int p = -1;\n            for (int k = 0; k < (int) d.size(); k++) {\n                if (s[j] == d[k]) {\n                    p = k;\n                }\n            }\n            if (p == -1) {\n                if (now == 0) {\n                    d.emplace_front(s[j]);\n                } else if (now == (int) d.size() - 1) {\n                    d.emplace_back(s[j]);\n                    now++;\n                } else {\n                    now = -1;\n                    break;\n                }\n            } else {\n                if (abs(p - now) != 1) {\n                    now = -1;\n                    break;\n                }\n                now = p;\n            }\n        }\n        if (now != -1) {\n            string t;\n            for (char b : d) {\n                t += b;\n            }\n            a[t] += c;\n            reverse(t.begin(), t.end());\n            a[t] += c;\n        }\n    }\n    debug(a);\n    vector<map<string, long long>> dp(1 << 12);\n    vector<map<string, pair<int, string>>> pre(1 << 12);\n    dp[0][string()] = 0;\n    pre[0][string()] = make_pair(-1, \"\");\n    for (int mask = 0; mask < (1 << 12); mask++) {\n        for (auto [t, c] : dp[mask]) {\n            for (int i = 0; i < 12; i++) {\n                if (mask & (1 << i)) {\n                    continue;\n                }\n                int nmask = mask | (1 << i);\n                string nt = t + (char) ('a' + i);\n                while (!nt.empty()) {\n                    auto iter = a.lower_bound(nt);\n                    if (iter == a.end()) {\n                        nt.erase(nt.begin());\n                        continue;\n                    }\n                    string z = iter->first;\n                    if (z.size() < nt.size()) {\n                        nt.erase(nt.begin());\n                        continue;\n                    }\n                    z.resize(nt.size());\n                    if (nt != z) {\n                        nt.erase(nt.begin());\n                        continue;\n                    }\n                    break;\n                }\n                long long nc = c;\n                for (int j = 0; j < (int) nt.size(); j++) {\n                    string z = nt.substr(j);\n                    if (a.count(z)) {\n                        nc += a[z];\n                    }\n                }\n                if (dp[nmask][nt] <= nc) {\n                    dp[nmask][nt] = nc;\n                    pre[nmask][nt] = make_pair(i, t);\n                }\n            }\n        }\n    }\n    long long best = -1;\n    string s;\n    for (auto [t, c] : dp.back()) {\n        if (c > best) {\n            best = c;\n            s = t;\n        }\n    }\n    debug(best);\n    debug(dp.back());\n    string ans;\n    int now = (1 << 12) - 1;\n    while (now > 0) {\n        int i = pre[now][s].first;\n        s = pre[now][s].second;\n        now ^= 1 << i;\n        ans += (char) ('a' + i);\n    }\n    cout << ans << '\\n';\n    return 0;\n}"], "input": "", "output": "", "tags": ["bitmasks", "data structures", "dp", "string suffix structures", "strings"], "dificulty": "2600", "interactive": false}