{
    "link": "https://codeforces.com//contest/1739/problem/F",
    "problemId": "1559868",
    "problem_idx": "F",
    "shortId": "1739F",
    "contest_number": "1739",
    "problem_submissions": {
        "F": [
            173982711,
            173969607,
            173981022,
            173986288,
            173992146,
            173980539,
            173991072,
            173980378,
            173978555,
            174245795,
            174000933,
            173993564,
            173995270,
            173994662,
            173995645,
            173994787,
            173991035,
            173995175,
            173975986,
            173996342,
            173995107,
            173986566
        ],
        "E": [
            173962909,
            173976378,
            173969496,
            173967080,
            173967227,
            173969366,
            173969799,
            173988104,
            173970277,
            173983172,
            173983299,
            173978308,
            173974083,
            173979712,
            173983159,
            173980060,
            173986740,
            173979502,
            173967920
        ],
        "D": [
            173953446,
            173954284,
            173959501,
            173953114,
            173950233,
            173963545,
            173960383,
            173950745,
            173966040,
            173950883,
            173962543,
            173951795,
            173957703,
            173966024,
            173951939,
            173967693,
            173958723,
            173974529,
            173956732
        ],
        "C": [
            173946487,
            173945498,
            173949713,
            174075655,
            174075624,
            173946209,
            173940986,
            173958498,
            173954556,
            173955135,
            173961377,
            173958964,
            173957077,
            173960274,
            173951680,
            173958743,
            173985617,
            173961155,
            173949432,
            173968872,
            173953205
        ],
        "B": [
            173936382,
            173937044,
            173937069,
            173935458,
            173935314,
            173943298,
            173937530,
            173935389,
            173954918,
            173937400,
            173937767,
            173940608,
            173940106,
            173945520,
            173936795,
            173941470,
            173938759,
            173964539,
            173936543
        ],
        "A": [
            173934470,
            173935151,
            173934498,
            173934222,
            173934344,
            173939803,
            173934700,
            173934286,
            173952986,
            173934928,
            173934527,
            173936084,
            173935340,
            173938305,
            173937802,
            173937555,
            173935130,
            173963081,
            173934367
        ]
    },
    "name": "F. Keyboard Design",
    "statement": "Monocarp has a dictionary of n words, consisting of 12 first letters of\r\nthe Latin alphabet. The words are numbered from 1 to n. In every pair of\r\nadjacent characters in each word, the characters are different. For\r\nevery word i, Monocarp also has an integer c_i denoting how often he\r\nuses this word.Monocarp wants to design a keyboard that would allow him\r\nto type some of the words easily. A keyboard can be denoted as a\r\nsequence of 12 first letters of the Latin alphabet, where each letter\r\nfrom to appears exactly once.A word can be typed with the keyboard\r\neasily if, for every pair of adjacent characters in the word, these\r\ncharacters are adjacent in the keyboard as well. The of the keyboard is\r\nthe sum of c_i over all words i that can be typed easily with it.Help\r\nMonocarp to design a keyboard with the maximum possible optimality.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    map<string, int> a;\n    for (int i = 0; i < n; i++) {\n        int c;\n        string s;\n        cin >> c >> s;\n        deque<char> d;\n        d.emplace_back(s[0]);\n        d.emplace_back(s[1]);\n        int now = 1;\n        for (int j = 2; j < (int) s.size(); j++) {\n            int p = -1;\n            for (int k = 0; k < (int) d.size(); k++) {\n                if (s[j] == d[k]) {\n                    p = k;\n                }\n            }\n            if (p == -1) {\n                if (now == 0) {\n                    d.emplace_front(s[j]);\n                } else if (now == (int) d.size() - 1) {\n                    d.emplace_back(s[j]);\n                    now++;\n                } else {\n                    now = -1;\n                    break;\n                }\n            } else {\n                if (abs(p - now) != 1) {\n                    now = -1;\n                    break;\n                }\n                now = p;\n            }\n        }\n        if (now != -1) {\n            string t;\n            for (char b : d) {\n                t += b;\n            }\n            a[t] += c;\n            reverse(t.begin(), t.end());\n            a[t] += c;\n        }\n    }\n    debug(a);\n    vector<map<string, long long>> dp(1 << 12);\n    vector<map<string, pair<int, string>>> pre(1 << 12);\n    dp[0][string()] = 0;\n    pre[0][string()] = make_pair(-1, \"\");\n    for (int mask = 0; mask < (1 << 12); mask++) {\n        for (auto [t, c] : dp[mask]) {\n            for (int i = 0; i < 12; i++) {\n                if (mask & (1 << i)) {\n                    continue;\n                }\n                int nmask = mask | (1 << i);\n                string nt = t + (char) ('a' + i);\n                while (!nt.empty()) {\n                    auto iter = a.lower_bound(nt);\n                    if (iter == a.end()) {\n                        nt.erase(nt.begin());\n                        continue;\n                    }\n                    string z = iter->first;\n                    if (z.size() < nt.size()) {\n                        nt.erase(nt.begin());\n                        continue;\n                    }\n                    z.resize(nt.size());\n                    if (nt != z) {\n                        nt.erase(nt.begin());\n                        continue;\n                    }\n                    break;\n                }\n                long long nc = c;\n                for (int j = 0; j < (int) nt.size(); j++) {\n                    string z = nt.substr(j);\n                    if (a.count(z)) {\n                        nc += a[z];\n                    }\n                }\n                if (dp[nmask][nt] <= nc) {\n                    dp[nmask][nt] = nc;\n                    pre[nmask][nt] = make_pair(i, t);\n                }\n            }\n        }\n    }\n    long long best = -1;\n    string s;\n    for (auto [t, c] : dp.back()) {\n        if (c > best) {\n            best = c;\n            s = t;\n        }\n    }\n    debug(best);\n    debug(dp.back());\n    string ans;\n    int now = (1 << 12) - 1;\n    while (now > 0) {\n        int i = pre[now][s].first;\n        s = pre[now][s].second;\n        now ^= 1 << i;\n        ans += (char) ('a' + i);\n    }\n    cout << ans << '\\n';\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "data structures",
        "dp",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Keyboard Design.json",
    "editorial_link": "https://codeforces.com//blog/entry/107461",
    "editorial": "For each word, let\u00e2\u0080\u0099s consider a graph on vertices where the -th and the\r\n-th vertices are connected by an edge iff the -th character of the\r\nalphabet is adjacent to the -th character of the alphabet in this\r\nstring. Obviously, this graph is connected (except for the isolated\r\nvertices). If there is a vertex of degree or more in this graph, or if\r\nthere is a cycle in this graph, it is impossible to design a keyboard to\r\ntype the word easily: in the first case, the letter represented by that\r\nvertex must have at least three neighbors on the keyboard, but can have\r\nonly at most two; in the second case, the keyboard must be cyclic (and\r\nit is not). So, the word can be typed easily only if the graph\r\nrepresenting it consists of one path and several isolated vertices.Let\u00e2\u0080\u0099s\r\nwrite the letters along the path we constructed for the word in a single\r\nstring. For example, for the word , we get edges , and in the graph, so\r\nthe letters along the path are either or (and, obviously, one can be\r\nobtained from the other by reversing the string). Let and be the two\r\nstrings we obtain from the word using this method. Now, we claim that\r\nthe word can be typed easily if and only if one of these two strings (\r\nand ) is a substring of the keyboard this would mean that every pair of\r\nletters that should be on adjacent positions are actually on adjacent\r\npositions.Okay, now we construct and for each word, and our goal is to\r\nfind the permutation of the first characters of Latin alphabet such that\r\nthe sum of over all words having either or as a substring is the maximum\r\npossible. There are two key observations that allow us to solve this\r\nproblem: and cannot be the substrings of the same keyboard (the proof is\r\nsimple: if is a substring, its first character must be before its second\r\ncharacter; and if is a substring, its second-to-last character (which is\r\nthe second character of ) must be before its last character (which is\r\nthe first character of ); neither nor can appear in the keyboard twice\r\n(it\u00e2\u0080\u0099s obvious since the keyboard is a permutation). So, we can\r\nreformulate the problem as follows: let be the cost of the string and\r\nthe cost of the string as well; find the permutation of the first\r\ncharacters of the Latin alphabet so that its cost (which is the sum of\r\ncosts of its substrings) is the maximum possible. To solve this problem,\r\nwe can store the strings in an Aho-Corasick automaton, and for every\r\nstate of the automaton, precalculate the total cost of all string ending\r\nin this state (that is, the cost of this state and all states reachable\r\nfrom it via the suffix links). Then run a dynamic programming of the\r\nform the maximum possible cost of a partial keyboard if we used a of\r\ncharacters and the Aho-Corasick automaton is currently in the state .\r\nThis dynamic programming runs in , where is the size of the alphabet (),\r\nand is the size of the automaton (up to ).\r\n"
}