{
    "link": "https://codeforces.com//contest/1519/problem/C",
    "problemId": "971588",
    "problem_idx": "C",
    "shortId": "1519C",
    "contest_number": "1519",
    "problem_submissions": {
        "C": [
            114616470,
            114551329,
            114551180,
            114564495,
            114550309,
            114552694,
            114547702,
            114548020,
            114553618,
            114563241,
            114559641,
            114555665,
            114557042,
            114556787,
            114554939,
            114556558,
            114555376,
            114549327,
            114552625,
            114552238,
            114554684,
            114559315
        ],
        "F": [
            114613463,
            114611288,
            114604337,
            114598897,
            114611467,
            114680142,
            114636104,
            114635840
        ],
        "E": [
            114607966,
            114580590,
            114575288,
            114583294,
            114570654,
            114566689,
            114580490,
            114581344,
            114581275,
            114584747,
            114587745,
            114586133,
            114587347,
            114590609,
            114592573,
            114589054,
            114601871,
            114596259,
            114594317,
            114625207,
            114625166,
            114600206,
            114595857
        ],
        "D": [
            114555495,
            114555902,
            114567847,
            114556972,
            114556567,
            114552424,
            114552771,
            114561234,
            114544188,
            114558776,
            114560835,
            114564971,
            114561515,
            114561300,
            114565333,
            114554107,
            114558569,
            114558286,
            114563876,
            114568526
        ],
        "B": [
            114542697,
            114545137,
            114558022,
            114545565,
            114550455,
            114542163,
            114542842,
            114545295,
            114550992,
            114551627,
            114546744,
            114549467,
            114548090,
            114544402,
            114547969,
            114543205,
            114546111,
            114545907,
            114546890,
            114546969
        ],
        "A": [
            114541604,
            114541862,
            114551019,
            114541996,
            114541593,
            114541608,
            114541607,
            114541640,
            114546683,
            114543589,
            114543013,
            114543817,
            114542361,
            114541678,
            114541836,
            114541598,
            114541959,
            114541646,
            114541768,
            114542287
        ]
    },
    "name": "C. Berland Regional",
    "statement": "Polycarp is an organizer of a Berland ICPC regional event. There are n\r\nuniversities in Berland numbered from 1 to n. Polycarp knows all\r\ncompetitive programmers in the region. There are n students: the i-th\r\nstudent is enrolled at a university u_i and has a programming skill\r\ns_i.Polycarp has to decide on the rules now. In particular, the number\r\nof members in the team.Polycarp knows that if he chooses the size of the\r\nteam to be some integer k, each university will send their k strongest\r\n(with the highest programming skill s) students in the first team, the\r\nnext k strongest students in the second team and so on. If there are\r\nfewer than k students left, then the team can\u2019t be formed. Note that\r\nthere might be universities that send zero teams.The strength of the\r\nregion is the total skill of the members of all present teams. If there\r\nare no teams present, then the strength is 0.Help Polycarp to find the\r\nstrength of the region for each choice of k from 1 to n.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int N;\n    cin >> N;\n    vector<int> U(N);\n    vector<int64_t> S(N);\n\n    for (auto &u : U) {\n        cin >> u;\n        u--;\n    }\n\n    for (auto &s : S)\n        cin >> s;\n\n    vector<vector<int64_t>> choices(N + 1);\n\n    for (int i = 0; i < N; i++)\n        choices[U[i]].push_back(S[i]);\n\n    vector<int64_t> skill(N + 1, 0);\n\n    for (int u = 0; u < N; u++) {\n        sort(choices[u].begin(), choices[u].end());\n        int len = int(choices[u].size());\n        vector<int64_t> prefix_sum(len + 1, 0);\n\n        for (int i = 0; i < len; i++)\n            prefix_sum[i + 1] = prefix_sum[i] + choices[u][i];\n\n        for (int k = 1; k <= len; k++)\n            skill[k] += prefix_sum[len] - prefix_sum[len % k];\n    }\n\n    for (int k = 1; k <= N; k++)\n        cout << skill[k] << (k < N ? ' ' : '\\n');\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "number theory",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Berland Regional.json",
    "editorial_link": "https://codeforces.com//blog/entry/90212",
    "editorial": "There are two important observations to make.The first one is that you\r\ncan calculate the answers for each university independently of each\r\nother and sum them up to obtain the true answer.The second one is that\r\nif there are students in an university, then that university can only\r\ncontribute to answers for from to .So if we learn to calculate the\r\ncontribution of the -th university for some fixed in , then we will be\r\nable to iterate over all possible for each university and get the\r\nsolution in , where is the number of students in the -th university.To\r\nachieve it, you have to gather the sum of the maximum number of students\r\nthat can form full teams of size . That must be the highest number less\r\nthan or equal to that is divisible by , so . Sort the students of each\r\nuniversity, precalculate partial sums, and now you are free to add the\r\nprefix sum of that number of students to the answer for .Overall\r\ncomplexity: per testcase.\r\n"
}