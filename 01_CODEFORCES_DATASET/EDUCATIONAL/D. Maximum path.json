{
    "link": "https://codeforces.com//contest/762/problem/D",
    "problemId": "90125",
    "problem_idx": "D",
    "shortId": "762D",
    "contest_number": "762",
    "problem_submissions": {
        "F": [
            24128800,
            24127287,
            24131448,
            24128833,
            24128590
        ],
        "E": [
            24122771,
            24123546,
            24117007,
            24124444,
            24127665,
            24127353,
            24122694,
            24124867,
            24128194,
            24130174,
            24129986,
            24129967,
            24127255,
            24123944,
            24123747,
            24128463,
            24126253,
            24117536,
            24126607
        ],
        "D": [
            24120216,
            24117937,
            24120594,
            24123699,
            24120899,
            24122923,
            24125654,
            24122077,
            24124440,
            24123437,
            24124479,
            24129845,
            64773611,
            24129570,
            24127415,
            24125478,
            24129569,
            24125183,
            24124387,
            24117686
        ],
        "C": [
            24117649,
            24115665,
            24118684,
            24120038,
            24118048,
            24119412,
            24117040,
            24153774,
            24117580,
            24118699,
            24120548,
            24119249,
            24120443,
            24120966,
            24122719,
            24122392,
            24134825,
            24118679
        ],
        "B": [
            24115242,
            24114275,
            24114874,
            24121323,
            24115338,
            24115218,
            24114366,
            24115078,
            24114616,
            24115065,
            24117965,
            24115815,
            24115613,
            24116743,
            24116439,
            24116970,
            24124581,
            24115154,
            24114842
        ],
        "A": [
            24113787,
            24113769,
            24113819,
            24114373,
            24113802,
            24113840,
            24113765,
            24113864,
            24113822,
            24115779,
            24114962,
            24114446,
            24113882,
            24114350,
            24114566,
            24114001,
            24114912,
            24113931,
            24113786
        ]
    },
    "name": "D. Maximum path",
    "statement": "You are given a rectangular table . Each cell contains an integer. You\r\ncan move from one cell to another if they share a side.Find such path\r\nfrom the upper left cell to the bottom right cell of the table that\r\ndoesn\u2019t visit any of the cells twice, and the sum of numbers written in\r\nthe cells of this path is maximum possible.\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 101010\nvoid build(){\n\n}\nLL n , a[ 3 ][ N ] , dp[ N ][ 4 ];\nvoid init(){\n  n = getint();\n  for( int j = 0 ; j < 3 ; j ++ )\n    for( int i = 1 ; i <= n ; i ++ )\n      a[ j ][ i ] = getint();\n}\ninline LL sum( int col , int fr , int to ){\n  if( fr > to ) swap( fr , to );\n  LL ret = 0;\n  for( int i = fr ; i <= to ; i ++ )\n    ret += a[ i ][ col ];\n  return ret;\n}\nvoid solve(){\n  dp[ 0 ][ 0 ] = 0;\n  dp[ 0 ][ 1 ] = -INF16;\n  dp[ 0 ][ 2 ] = -INF16;\n  dp[ 0 ][ 3 ] = -INF16;\n  for( int i = 1 ; i <= n ; i ++ ){\n    for( int j = 0 ; j < 4 ; j ++ )\n      dp[ i ][ j ] = -INF16;\n    for( int j = 0 ; j < 3 ; j ++ )\n      for( int nj = 0 ; nj < 3 ; nj ++ )\n        dp[ i ][ nj ] = max( dp[ i ][ nj ] ,\n                             dp[ i - 1 ][ j ] + sum( i , j , nj ) );\n    LL al = sum( i , 0 , 2 );\n    for( int j : { 0 , 2 } ){\n      dp[ i ][ 3 ] = max( dp[ i ][ 3 ] , dp[ i - 1 ][ j ] + al );\n      dp[ i ][ j ] = max( dp[ i ][ j ] , dp[ i - 1 ][ 3 ] + al );\n    }\n  }\n  printf( \"%lld\\n\" , dp[ n ][ 2 ] );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Maximum path.json",
    "editorial_link": "https://codeforces.com//blog/entry/50010",
    "editorial": "The toughest thing about this task, is that you can go to the left. Try to come up with something to handle that.\n\n\nTry to prove that in optimal solution you don't need to go more than one cell to the left before coming back."
}