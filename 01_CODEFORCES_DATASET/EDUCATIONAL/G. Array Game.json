{
    "link": "https://codeforces.com//contest/1076/problem/G",
    "problemId": "253931",
    "problem_idx": "G",
    "shortId": "1076G",
    "contest_number": "1076",
    "problem_submissions": {
        "G": [
            45625846,
            45630140,
            45632982,
            46960572,
            46960569,
            46960484,
            46960479,
            45661891,
            45661748,
            45661556,
            45637887
        ],
        "F": [
            45614239,
            45617004,
            45617675,
            45621744,
            45623056,
            45621580,
            45616229,
            45624418,
            45620163,
            45626942,
            45622892,
            92696270,
            45628245,
            45626700,
            45628806,
            45625577,
            45627726,
            45626872,
            45629774,
            45627914
        ],
        "E": [
            45608069,
            45606664,
            45609407,
            45611410,
            45613399,
            45608388,
            45619010,
            45614637,
            45612416,
            45607002,
            45613856,
            45612132,
            45618044,
            45620715,
            45614237,
            45682359,
            45621599,
            45618734,
            45620976
        ],
        "D": [
            45604073,
            45602278,
            45603983,
            45604745,
            45608217,
            45612332,
            45603996,
            45608096,
            45607173,
            45610865,
            45611014,
            45608491,
            45611013,
            45612751,
            45610584,
            45615172,
            45677601,
            45613074,
            45613230
        ],
        "C": [
            45600029,
            45599030,
            45599822,
            45597549,
            45600013,
            45601957,
            45599535,
            45601880,
            45597795,
            45594983,
            45608083,
            45600343,
            45605220,
            45599746,
            45605736,
            45602724,
            45604906,
            45602506
        ],
        "B": [
            45596357,
            45597200,
            45597164,
            45595268,
            45596818,
            45597059,
            45596991,
            45599540,
            45605291,
            45600750,
            45604626,
            45597294,
            45597956,
            45598110,
            45602593,
            45598676,
            45601974,
            45596576
        ],
        "A": [
            45594616,
            45596057,
            45594765,
            45594566,
            45594867,
            45594852,
            45605960,
            45594859,
            45594710,
            45599455,
            45594781,
            45595172,
            45594643,
            45594748,
            45596363,
            45595242,
            45597244,
            45594970
        ]
    },
    "name": "G. Array Game",
    "statement": "Consider a following game between two players:There is an array b_1,\r\nb_2, ..., b_k, consisting of positive integers. Initially a chip is\r\nplaced into the first cell of the array, and b_1 is decreased by 1.\r\nPlayers move in turns. Each turn the current player has to do the\r\nfollowing: if the index of the cell where the chip is currently placed\r\nis x, then he or she has to choose an index y\r\nin [x, min(k, x + m)] such that b_y > 0, move the chip to the cell y and\r\ndecrease b_y by 1. If it’s impossible to make a valid move, the current\r\nplayer loses the game.Your task is the following: you are given an array\r\na consisting of n positive integers, and q queries to it. There are two\r\ntypes of queries: 1 l r d for every i\r\nin [l, r] increase a_i by d; 2 l r tell who is the winner of the game\r\nthat is played on the subarray of a from index l to index r inclusive.\r\nAssume both players choose an optimal strategy.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef double D;\ntypedef long long int LL;\n\n#define st first\n#define nd second\n#define pb push_back\n#define PLL pair <LL, LL>\n#define PII pair <int, int>\n\nconst int P = 400;\nconst int G = 600;\nconst int N = 2e5 + 7;\n\nconst int MX = 1e9 + 7;\nconst LL INF = 1e18 + 9LL;\n\nint n, m, q;\nint cur[N];\n\nint p;\nint idx[N];\nint clicked[G];\nint group[G][6][2];\n\nint simulate(int l, int r, bool c){\n\twhile(r >= l){\n\t\tif(cur[r] ^ c)\n\t\t\tr -= m + 1;\n\t\telse\n\t\t\t--r;\n\t}\n\n\treturn l - r - 1;\n}\n\nvoid build(int nr){\n\tint from = max(nr * P - P, 1), to = min(nr * P, n + 1);\n\tfor(int i = from; i < to; ++i)\n\t\tcur[i] ^= clicked[nr];\n\tclicked[nr] = false;\n\t\n\tfor(int i = 0; i <= m; ++i){\n\t\tgroup[nr][i][0] = simulate(from, to - i - 1, 0);\n\t\tgroup[nr][i][1] = simulate(from, to - i - 1, 1);\n\t}\n}\n\nvoid change(int l, int r){\n\tif(idx[l] == idx[r]){\n\t\tfor(int i = l; i <= r; ++i)\n\t\t\tcur[i] ^= 1;\n\n\t\tbuild(idx[l]);\n\t\treturn;\n\t}\n\t\n\tfor(int i = idx[l] + 1; i < idx[r]; ++i)\n\t\tclicked[i] ^= 1;\n\t\n\tfor(int i = l; i < idx[l] * P; ++i)\n\t\tcur[i] ^= 1;\n\tbuild(idx[l]);\n\t\n\tfor(int i = idx[r] * P - P; i <= r; ++i)\n\t\tcur[i] ^= 1;\n\tbuild(idx[r]);\n}\n\nint ask(int l, int r){\n\tif(cur[l] == clicked[idx[l]])\n\t\treturn 1;\n\t\n\tif(idx[l] == idx[r]){\n\t\tint t = simulate(l + 1, r, clicked[idx[l]]);\n\t\treturn t == 0 ? 2 : 1;\n\t}\n\n\tint t = simulate(idx[r] * P - P, r, clicked[idx[r]]);\n\tint curN = idx[r] - 1;\n\t\n\twhile(curN > idx[l]){\n\t\tt = group[curN][t][clicked[curN]];\n\t\t--curN;\n\t}\n\t\n\tt = simulate(l + 1, idx[l] * P - t - 1, clicked[idx[l]]);\n\treturn t == 0 ? 2 : 1;\n}\n\nint main(){\n\tscanf(\"%d %d %d\", &n, &m, &q);\n\tfor(int i = 1; i <= n; ++i){\n\t\tLL a;\n\t\tscanf(\"%lld\", &a);\n\t\tcur[i] = a % 2;\n\t}\n\t\n\tfor(int i = 1; i <= n; ++i)\n\t\tidx[i] = i / P + 1;\n\t\n\tp = idx[n];\n\tfor(int i = 1; i <= p; ++i)\n\t\tbuild(i);\n\t\n\twhile(q--){\n\t\tint t, l, r;\n\t\tscanf(\"%d %d %d\", &t, &l, &r);\n\t\t\n\t\tif(t == 1){\n\t\t\tLL v;\n\t\t\tscanf(\"%lld\", &v);\n\n\t\t\tif(v % 2 == 1)\n\t\t\t\tchange(l, r);\n\t\t}\n\t\telse\n\t\t\tprintf(\"%d\\n\", ask(l, r));\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "games"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Array Game.json",
    "editorial_link": "https://codeforces.com/blog/entry/63151",
    "editorial": "Suppose there is only one query, i. e. we are given some array and we\r\nwant to know who is the winner if the game is played on this array. One\r\nof the obvious solutions is will the current player win if the chip is\r\ncurrently in the cell and the number in cell is . We can already see\r\nthat we donât need to know the exact value of , we only want to know\r\nwhether itâs odd: if there is a cell such that we can go from to and is\r\na state where current player will lose, then we should go to this cell\r\nsince our opponent will enter a losing state of the game. Otherwise, we\r\nwant to force our opponent to move out of cell , and we can do so only\r\nif is odd. So we found a dynamic programming solution with states, but\r\nwhat is more important is that we can take all the elements in our array\r\nmodulo .Okay, now letâs solve the problem when there are only queries of\r\ntype (no modifications). Since when calculating the values we are\r\ninterested only in next cells, and there are only variants of whether\r\nthese cells are \"winning\" or \"losing\", we may consider each element of\r\nthe array as a function that maps a mask of next states into a new mask\r\nof states if we pushed our new element into the front. For example, if\r\nthe -th element is even and states , , , , are winning, losing, losing,\r\nwinning and losing respectively, and , then we may consider a mask of\r\nnext states as ; and then we can check if -th state is winning and push\r\na bit to the front of this mask, discarding the last bit; since new\r\nstate is winning, we will get a mask of . It allows us to denote two\r\nfunctions and what will be the resulting mask of next states, if current\r\nmask is and we push an even or odd element to the front.Okay, what about\r\npushing more than one element? We can just take the composition of their\r\nfunctions! Since a function can be stored as an array of integers and\r\nthe composition needs only time to be calculated, then we can build a\r\nsegment tree over the elements of the array, and store a composition of\r\nall functions on the segment in each node. This allows us to answer\r\nqueries of type in .The only thing thatâs left is additions on segment.\r\nAdding an even number is easy: just ignore this query. To be able an odd\r\nnumber, letâs store another function in each node of the segment tree\r\nwhich would be the composition of all functions on the segment if we\r\nwould add to all elements on the segment (so the elements which were odd\r\nbecome even, and vice versa). This allows us to use lazy propagation: if\r\nthe query affects the whole node, we may just swap two functions in it\r\nand push the query to the children of this node.Overall complexity is .\r\nIt turns out (we didnât think about it before the contest, but some\r\ncontestants submitted such solutions) that it can be reduced to if we\r\nwill use the distance to closest losing state instead of a mask of\r\nwinning and losing states.\r\n",
    "hint": []
}