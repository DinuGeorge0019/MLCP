{
    "link": "https://codeforces.com//contest/954/problem/F",
    "problemId": "167343",
    "problem_idx": "F",
    "shortId": "954F",
    "contest_number": "954",
    "problem_submissions": {
        "I": [
            36483613,
            36489921,
            36491468,
            36492587,
            36489151,
            36505182,
            36498444,
            36489158,
            36493599,
            36495253,
            36493983,
            36523197,
            36517457,
            36494315,
            36517490
        ],
        "E": [
            36478770,
            36477321,
            36476296,
            36476332,
            36477191,
            36479277,
            36478407,
            36484072,
            36476637,
            36483722,
            36476830,
            36479359,
            36479273,
            36481624,
            36479515,
            36473956,
            36477339,
            36477449,
            36476422,
            36481260
        ],
        "D": [
            36478485,
            36475307,
            36474083,
            36478258,
            36474970,
            36476455,
            36476263,
            36472023,
            36474824,
            36478016,
            36474200,
            36476982,
            36476891,
            36474372,
            36477175,
            36479984,
            36487971,
            36474275,
            36474076,
            36475466
        ],
        "C": [
            36476002,
            36474037,
            36473020,
            36474296,
            36473832,
            36473968,
            36474218,
            36474540,
            36483525,
            36476724,
            36472809,
            36474171,
            36499291,
            36473004,
            36474442,
            36477242,
            36486700,
            36473123,
            36472782,
            36473808
        ],
        "G": [
            36475037,
            36479869,
            36479819,
            36482297,
            36479701,
            36481399,
            36480184,
            36480325,
            36481161,
            36480550,
            36485383,
            36482231,
            36482668,
            36492299,
            36483624,
            36487406,
            36490213,
            36485274,
            36478330,
            36479287
        ],
        "F": [
            36474930,
            36486416,
            36483404,
            36528491,
            36484207,
            36482822,
            36485630,
            36483061,
            36477477,
            36481839,
            36487500,
            36482960,
            36488051,
            36485000,
            36479677,
            36489393,
            36482816,
            36484976,
            36483377,
            36483862,
            36487177
        ],
        "H": [
            36473564,
            36483628,
            36486927,
            36487388,
            36497291,
            36492759,
            36492641,
            36496336,
            36493059,
            36491960,
            36490810,
            36488245,
            36487713,
            36489798,
            36483087
        ],
        "B": [
            36472231,
            36471541,
            36471094,
            36471718,
            36471325,
            36471918,
            36470816,
            36471290,
            36470543,
            36472680,
            36470969,
            36471052,
            36470688,
            36471049,
            36472812,
            36475352,
            36471581,
            36471121,
            36470814,
            36470886
        ],
        "A": [
            36470941,
            36470615,
            36469920,
            36470743,
            36470038,
            36470789,
            36469978,
            36470246,
            36469943,
            36471510,
            36470178,
            36469918,
            36469982,
            36470334,
            36471516,
            36475017,
            36470944,
            36470503,
            36470133,
            36470029
        ]
    },
    "name": "F. Runner's Problem",
    "statement": "You are running through a rectangular field. This field can be\r\nrepresented as a matrix with rows and columns. denotes a cell belonging\r\nto -th row and -th column.You start in and have to end your path in .\r\nFrom the cell you may advance to: only if , , or only if . However,\r\nthere are obstacles blocking your path. -th obstacle is denoted by three\r\nintegers , and , and it forbids entering any cell such that .You have to\r\ncalculate the number of different paths from to , and print it modulo .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\ninline ll read()\n{\n    ll x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\n#define MN 10000\n#define MOD 1000000007\nstruct P{ll x;int y,z;}p[MN*2+5];\nbool cmp(const P&a,const P&b){return a.x<b.x;}\nstruct mat{int z[3][3];}x,a[8];\ninline mat operator*(const mat&a,const mat&b)\n{\n\tmat c;memset(c.z,0,sizeof(c.z));\n\tfor(int i=0;i<3;++i)for(int j=0;j<3;++j)for(int k=0;k<3;++k)\n\t\tc.z[i][k]=(c.z[i][k]+1LL*a.z[i][j]*b.z[j][k])%MOD;\n\treturn c;\n};\nint u[4];\nint cal(){return (u[1]?4:0)+(u[2]?2:0)+(u[3]?1:0);}\ninline mat pw(mat x,ll y)\n{\n\tmat r;\n\tfor(int i=0;i<3;++i)for(int j=0;j<3;++j)r.z[i][j]=i==j;\n\tfor(;y;y>>=1,x=x*x)if(y&1)r=r*x;\n\treturn r;\n}\nint main()\n{\n\tint n=read(),i,j;ll m=read();\n\tfor(i=1;i<=n;++i)j=read(),p[i]=(P){read(),j,1},p[i+n]=(P){read()+1,j,-1};\n\tsort(p+1,p+n+n+1,cmp);\n\tfor(i=0;i<8;++i)\n\t{\n\t\tif(!(i&4))a[i].z[0][0]=a[i].z[1][0]=1;\n\t\tif(!(i&2))a[i].z[0][1]=a[i].z[1][1]=a[i].z[2][1]=1;\n\t\tif(!(i&1))a[i].z[1][2]=a[i].z[2][2]=1;\n\t}\n\tx.z[0][1]=1;p[0].x=2;\n\tfor(i=1;i<=n+n;++i)x=x*pw(a[cal()],p[i].x-p[i-1].x),u[p[i].y]+=p[i].z;\n\tx=x*pw(a[0],m-p[n+n].x+1);\n\tprintf(\"%d\",x.z[0][1]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "matrices",
        "sortings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Runner's Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/58519",
    "editorial": "There is a simple dynamic programming solution that works in . Letâs try\r\nto improve it.Firstly, if there are no obstacles in some column and we\r\nhave calculated the number of paths to every cell of the previous\r\ncolumn, then we may get the values in column by multiplying the vector\r\nof values in column by the following matrix:Then we may use binary\r\nexponentiation to skip long segments without obstacles in , where is the\r\nlength of the segment.Letâs try to modify this matrix if we have to\r\nforbid some rows. All we need to change is to set every value in -th row\r\nto if -th row is forbidden. So we may skip long segments not only if\r\nthey donât contain any obstacles, but also if the set of forbidden rows\r\ndoesnât change on this segment.So the solution is the following: divide\r\nthe whole matrix into segments by the endpoints of the obstacles, then\r\nin every segment the set of forbidden rows doesnât change (so we can\r\nskip it using fast matrix exponentiation).\r\n",
    "hint": []
}