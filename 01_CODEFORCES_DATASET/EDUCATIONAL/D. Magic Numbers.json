{"link": "https://codeforces.com//contest/628/problem/D", "problemId": "48826", "problem_idx": "D", "shortId": "628D", "contest_number": "628", "problem_submissions": {"F": [16211421, 16211567, 16211169, 16208042, 16208527, 16211299, 16220786, 16205726, 16251882, 16212235, 16209081, 16210918, 16211253], "E": [16209151, 16209513, 16209798, 16210303, 16210389, 16210209, 16207914, 16208921, 16208930, 16210016, 16208755, 16210104, 16210071, 16211325, 16211040, 16210904, 16210538, 16209234, 16210698, 16210531, 16214256], "D": [16206627, 16206845, 16206086, 16207092, 16208100, 16205719, 16205288, 16206076, 16260286, 16206980, 16206584, 16206673, 16206619, 16207592, 16206640, 16380499, 16206826, 16207654], "C": [16204024, 16203998, 16203984, 16204943, 16204160, 16203580, 16204456, 16203644, 16203472, 16204820, 16204285, 16204239, 16203927, 16204552, 16204730, 16203693, 16204713, 16204672], "B": [16203509, 16203431, 16203495, 16204395, 16203326, 16203172, 16204023, 16203232, 16203233, 16204126, 16203462, 16203612, 16203325, 16203859, 16203731, 16203308, 16203766, 16203989], "A": [16203031, 16203135, 16203205, 16203772, 16203048, 16203023, 16203022, 16203045, 16203001, 16203771, 16203077, 16203193, 16203044, 16203133, 16203132, 16203092, 16203204, 16203389]}, "name": "D. Magic Numbers", "statement": "Consider the decimal presentation of an integer. Let\u2019s call a number if\r\ndigit appears in decimal presentation of the number on even positions\r\nand nowhere else.For example, the numbers , , are but , , , , are not .\r\nOn the other hand the number is , is , is and is .Find the number of\r\nnumbers in the segment that are multiple of . Because the answer can be\r\nvery huge you should only find its value modulo (so you should find the\r\nremainder after dividing by ).\r\n", "solutions": ["#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nconst int p = 1000000007;\n\nint mul32(int x, int y) {\n  return (int64_t(x) * y) % p;\n}\n\nint getRes(int d, int m, std::string& x, std::vector<int>& rem, std::vector<std::vector<int>>& dyn) {\n  int n = x.length();\n  int res = 0;\n  int sum = 0;\n  bool bad = false;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < x[i] - '0'; j++) {\n      if ((i % 2 != 0) ^ (j == d)) {\n        continue;\n      }\n      res = (res + dyn[n - i - 1][(sum + j * rem[n - i - 1]) % m]) % p;\n    }\n    sum = (sum + (x[i] - '0') * rem[n - i - 1]) % m;\n    if ((i % 2 != 0) ^ (x[i] - '0' == d)) {\n      bad = true;\n      break;\n    }\n  }\n  if (!bad && sum == 0) {\n    res = (res + 1) % p;\n  }\n  return res;\n}\n\nvoid run(std::istream& in, std::ostream& out) {\n  int m, d;\n  in >> m >> d;\n  std::string a, b;\n  in >> a >> b;\n  int n = a.length();\n  std::vector<int> rem(n);\n  int c = 1;\n  for (int i = 0; i < n; i++) {\n    rem[i] = c;\n    c = (c * 10) % m;\n  }\n  std::vector<std::vector<int>> dyn(n, std::vector<int>(m, 0));\n  dyn[0][0] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int dd = 0; dd < 10; dd++) {\n      if (((n - i) % 2 != 0) ^ (dd == d)) continue;\n      int diff = rem[i - 1] * dd;\n      for (int j = 0; j < m; j++) {\n        dyn[i][j] = (dyn[i][j] + dyn[i - 1][(j + diff) % m]) % p;\n      }\n    }\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    if (a[i] == '0') {\n      a[i] = '9';\n    } else {\n      a[i]--;\n      break;\n    }\n  }\n  int resB = getRes(d, m, b, rem, dyn);\n  int resA = getRes(d, m, a, rem, dyn);\n  int res = resB - resA;\n  if (res < 0) res += p;\n  out << res << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}"], "input": "", "output": "", "tags": ["dp"], "dificulty": "2200", "interactive": false}