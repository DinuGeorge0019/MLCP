{
    "link": "https://codeforces.com//contest/628/problem/D",
    "problemId": "48826",
    "problem_idx": "D",
    "shortId": "628D",
    "contest_number": "628",
    "problem_submissions": {
        "F": [
            16211421,
            16211567,
            16211169,
            16208042,
            16208527,
            16211299,
            16220786,
            16205726,
            16251882,
            16212235,
            16209081,
            16210918,
            16211253
        ],
        "E": [
            16209151,
            16209513,
            16209798,
            16210303,
            16210389,
            16210209,
            16207914,
            16208921,
            16208930,
            16210016,
            16208755,
            16210104,
            16210071,
            16211325,
            16211040,
            16210904,
            16210538,
            16209234,
            16210698,
            16210531,
            16214256
        ],
        "D": [
            16206627,
            16206845,
            16206086,
            16207092,
            16208100,
            16205719,
            16205288,
            16206076,
            16260286,
            16206980,
            16206584,
            16206673,
            16206619,
            16207592,
            16206640,
            16380499,
            16206826,
            16207654
        ],
        "C": [
            16204024,
            16203998,
            16203984,
            16204943,
            16204160,
            16203580,
            16204456,
            16203644,
            16203472,
            16204820,
            16204285,
            16204239,
            16203927,
            16204552,
            16204730,
            16203693,
            16204713,
            16204672
        ],
        "B": [
            16203509,
            16203431,
            16203495,
            16204395,
            16203326,
            16203172,
            16204023,
            16203232,
            16203233,
            16204126,
            16203462,
            16203612,
            16203325,
            16203859,
            16203731,
            16203308,
            16203766,
            16203989
        ],
        "A": [
            16203031,
            16203135,
            16203205,
            16203772,
            16203048,
            16203023,
            16203022,
            16203045,
            16203001,
            16203771,
            16203077,
            16203193,
            16203044,
            16203133,
            16203132,
            16203092,
            16203204,
            16203389
        ]
    },
    "name": "D. Magic Numbers",
    "statement": "Consider the decimal presentation of an integer. Let\u2019s call a number if\r\ndigit appears in decimal presentation of the number on even positions\r\nand nowhere else.For example, the numbers , , are but , , , , are not .\r\nOn the other hand the number is , is , is and is .Find the number of\r\nnumbers in the segment that are multiple of . Because the answer can be\r\nvery huge you should only find its value modulo (so you should find the\r\nremainder after dividing by ).\r\n",
    "solutions": [
        "#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nconst int p = 1000000007;\n\nint mul32(int x, int y) {\n  return (int64_t(x) * y) % p;\n}\n\nint getRes(int d, int m, std::string& x, std::vector<int>& rem, std::vector<std::vector<int>>& dyn) {\n  int n = x.length();\n  int res = 0;\n  int sum = 0;\n  bool bad = false;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < x[i] - '0'; j++) {\n      if ((i % 2 != 0) ^ (j == d)) {\n        continue;\n      }\n      res = (res + dyn[n - i - 1][(sum + j * rem[n - i - 1]) % m]) % p;\n    }\n    sum = (sum + (x[i] - '0') * rem[n - i - 1]) % m;\n    if ((i % 2 != 0) ^ (x[i] - '0' == d)) {\n      bad = true;\n      break;\n    }\n  }\n  if (!bad && sum == 0) {\n    res = (res + 1) % p;\n  }\n  return res;\n}\n\nvoid run(std::istream& in, std::ostream& out) {\n  int m, d;\n  in >> m >> d;\n  std::string a, b;\n  in >> a >> b;\n  int n = a.length();\n  std::vector<int> rem(n);\n  int c = 1;\n  for (int i = 0; i < n; i++) {\n    rem[i] = c;\n    c = (c * 10) % m;\n  }\n  std::vector<std::vector<int>> dyn(n, std::vector<int>(m, 0));\n  dyn[0][0] = 1;\n  for (int i = 1; i < n; i++) {\n    for (int dd = 0; dd < 10; dd++) {\n      if (((n - i) % 2 != 0) ^ (dd == d)) continue;\n      int diff = rem[i - 1] * dd;\n      for (int j = 0; j < m; j++) {\n        dyn[i][j] = (dyn[i][j] + dyn[i - 1][(j + diff) % m]) % p;\n      }\n    }\n  }\n  for (int i = n - 1; i >= 0; i--) {\n    if (a[i] == '0') {\n      a[i] = '9';\n    } else {\n      a[i]--;\n      break;\n    }\n  }\n  int resB = getRes(d, m, b, rem, dyn);\n  int resA = getRes(d, m, a, rem, dyn);\n  int res = resB - resA;\n  if (res < 0) res += p;\n  out << res << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Magic Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/43203",
    "editorial": "Kareem Mohamed Kareem_Mohamed suggested the simpler version of the\r\nproblem. Denote the answer to the problem . Note that or what is the\r\nsame , where equals to one if is a magic number, otherwise equals to\r\nzero. Let\u00e2\u0080\u0099s solve the problem for the segment . Here is described the\r\nstandard technique for this kind of problems, sometimes it is called\r\n\u00e2\u0080\u0099dynamic programming by digits\u00e2\u0080\u0099. It can be realized in a two ways. The\r\nfirst way is to iterate over the length of the common prefix with number\r\n. Next digit should be less than corresponding digit in and other digits\r\ncan be arbitrary. Below is the description of the second approach. Let\r\nbe the number of magic prefixes of length with remainder modulo . If\r\nthan the prefix should be less than the corresponding prefix in and if\r\nthan the prefix should be equal to the prefix of (it can not be\r\ngreater). Let\u00e2\u0080\u0099s do \u00e2\u0080\u0099forward dynamic programming\u00e2\u0080\u0099. Let\u00e2\u0080\u0099s iterate over\r\ndigit in position . We should check that if the position is even than\r\nshould be equal to , otherwise it cannot be equal to . Also we should\r\ncheck for should be not greater than corresponding digit in . Now let\u00e2\u0080\u0099s\r\nsee what will be the next state. Of course . By Horner scheme . Easy to\r\nsee that . To update the next state we should increase it: . Of course\r\nall calculations should be done modulo . C++ solution Complexity: .\r\n"
}