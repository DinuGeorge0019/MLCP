{
    "link": "https://codeforces.com//contest/1101/problem/F",
    "problemId": "281059",
    "problem_idx": "F",
    "shortId": "1101F",
    "contest_number": "1101",
    "problem_submissions": {
        "G": [
            48239479,
            48229345,
            48232833,
            48236005,
            48238584,
            48237077,
            48239817,
            48236726,
            48424442,
            48241897,
            48244236,
            48246271,
            48243763,
            48241853,
            48248346,
            48243669,
            48239804,
            48232428,
            48236056,
            48233716
        ],
        "F": [
            48234729,
            48238339,
            48245658,
            48241971,
            48243102,
            48243980,
            48248208,
            48253790,
            48249237,
            48251881,
            48251772,
            48254209,
            48250740,
            48252733,
            48257301,
            48253052,
            48236429,
            48245061,
            48242715,
            48241926,
            48292686,
            48258183
        ],
        "E": [
            48227685,
            48224274,
            48222676,
            48226514,
            48225235,
            48225759,
            48224993,
            48229382,
            48234805,
            48231496,
            48237158,
            48276590,
            48233129,
            48237913,
            48231111,
            48230324,
            48226575,
            48224137,
            48222074,
            48228244,
            48223937
        ],
        "D": [
            48225904,
            132803821,
            132802920,
            48232171,
            48230596,
            48230036,
            48246912,
            48230700,
            48231186,
            48232249,
            48228292,
            48232968,
            48229870,
            48235723,
            48238573,
            48253038,
            48236119,
            48237471,
            48242160,
            48224926,
            48233664,
            48227806,
            48238739,
            48236228
        ],
        "C": [
            48220755,
            48221737,
            48220938,
            48222851,
            48222128,
            48224023,
            48222001,
            48221817,
            48228289,
            48227053,
            48229439,
            48222389,
            48224672,
            48228555,
            48228217,
            48221108,
            48222667,
            48220453,
            48229806,
            48227541
        ],
        "B": [
            48218348,
            48218521,
            48218025,
            48219067,
            48219419,
            48219511,
            48219183,
            48218594,
            48221174,
            48217036,
            48221983,
            48224393,
            48219257,
            48217297,
            48224770,
            48217931,
            48218900,
            50490666,
            48220404,
            48221056
        ],
        "A": [
            48216068,
            48216088,
            48215851,
            48216101,
            48215964,
            48215856,
            48216330,
            48216376,
            48215843,
            48215822,
            48218304,
            48215863,
            48216823,
            48215814,
            48216519,
            48216032,
            48215829,
            48216427,
            48216203
        ]
    },
    "name": "F. Trucks and Cities",
    "statement": "There are n cities along the road, which can be represented as a\r\nstraight line. The i-th city is situated at the distance of a_i\r\nkilometers from the origin. All cities are situated in the same\r\ndirection from the origin. There are m trucks travelling from one city\r\nto another. Each truck can be described by 4 integers: starting city\r\ns_i, finishing city f_i, fuel consumption c_i and number of possible\r\nrefuelings r_i. The i-th truck will spend c_i litres of fuel per one\r\nkilometer. When a truck arrives in some city, it can be refueled (but\r\nrefueling is impossible in the middle of nowhere). The i-th truck can be\r\nrefueled at most r_i times. Each refueling makes truck’s gas-tank full.\r\nAll trucks start with full gas-tank.All trucks will have gas-tanks of\r\nthe same size V litres. You should find minimum possible V such that all\r\ntrucks can reach their destinations without refueling more times than\r\nallowed.\r\n",
    "solutions": [
        "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=400;\nconst int MAXTRUCK=250000;\n\nint n,ntruck;\nint x[MAXN];\nint s[MAXTRUCK],t[MAXTRUCK],c[MAXTRUCK],r[MAXTRUCK];\n\nint dp[MAXN][MAXN+1]; // dp[i][j][k] = minimum capacity needed for a c=1 truck to get from i to j with at most k refuellings\nint act[MAXN][MAXN+1]; // act[i][j][k] = where the last refuel was\n\nvector<int> bys[MAXN];\n\n// dp[i][j][k]=min(jj,max(dp[i][jj][k-1],x[j]-x[jj]))\nint calc(int i,int j,int k,int jj) {\n\treturn max(dp[jj][k-1],x[j]-x[jj]);\n}\n\nll solve() {\n\tREP(i,n) bys[i].clear(); REP(i,ntruck) bys[s[i]].PB(i);\n\tll ret=0;\n\tREP(i,n) {\n\t\tREPE(k,n) dp[i][k]=0,act[i][k]=i;\n\t\tFOR(j,i+1,n) dp[j][0]=x[j]-x[i],act[j][0]=i;\n\t\tFOR(j,i+1,n) FORE(k,1,n) {\n\t\t\tact[j][k]=act[j-1][k]; while(act[j][k]<j&&calc(i,j,k,act[j][k]+1)<calc(i,j,k,act[j][k])) ++act[j][k];\n\t\t\tdp[j][k]=calc(i,j,k,act[j][k]);\n\t\t}\n\t\tREPSZ(j,bys[i]) {\n\t\t\tint idx=bys[i][j];\n\t\t\tll cur=(ll)dp[t[idx]][r[idx]]*c[idx];\n\t\t\tret=max(ret,cur);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&ntruck);\n\tREP(i,n) scanf(\"%d\",&x[i]);\n\tREP(i,ntruck) scanf(\"%d%d%d%d\",&s[i],&t[i],&c[i],&r[i]),--s[i],--t[i];\n\tprintf(\"%lld\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Trucks and Cities.json",
    "editorial_link": "https://codeforces.com/blog/entry/64483",
    "editorial": "First (bonus) solution: implement idea from Blogewoosh 6. Time\r\ncomplexity will be somewhat and space complexity is .Honest solution:\r\nNote, that for each truck lower bound on the answer is , where is\r\noptimal partition of on segments (partition which minimize maximum\r\nlength of segment) and doesnât depend on of truck.So, it enough to\r\ncalculate optimal partition of segment on segments.Let be position,\r\nwhere last segment starts in partition with value . Note, that .On the\r\nother hand, . But and , then is somewhat \"convex\".Finally, best is no\r\nmore than , And we can look at as second pointer (along with as first\r\npointer). So we can for each move while answer \"relaxes\" (while answer\r\nis decreasing or staying same). In result, for each and there will be\r\noperations in total.Optimizing memory consumption is easy, if we notice\r\nthat we can iterate over but not save it as state of dp.In the end, time\r\ncomplexity is and space complexity is .\r\n",
    "hint": []
}