{
    "link": "https://codeforces.com//contest/1550/problem/F",
    "problemId": "1045986",
    "problem_idx": "F",
    "shortId": "1550F",
    "contest_number": "1550",
    "problem_submissions": {
        "F": [
            122483395,
            122494928,
            122494758,
            122498831,
            122495349,
            122507186,
            122504855,
            122499174,
            122495286,
            122505655,
            122503411,
            122504082,
            122506733,
            122503920,
            122507265,
            122505173,
            122514546,
            122521422,
            122608494,
            122664141
        ],
        "E": [
            122476565,
            122473503,
            122481437,
            122485433,
            122484524,
            122485212,
            122477724,
            122500057,
            122485157,
            122486711,
            122488337,
            122498290,
            122489523,
            122484119,
            122495271,
            122476181,
            122481232,
            122481328,
            122483526,
            122494342
        ],
        "D": [
            122471547,
            122486544,
            122474791,
            122475055,
            122481071,
            122477408,
            122494393,
            122479516,
            122495901,
            122496325,
            122494541,
            122483595,
            122476325,
            122488807,
            122472450,
            122476646,
            122472723,
            122476521,
            122472515
        ],
        "C": [
            122458749,
            122460413,
            122460329,
            122460157,
            122463960,
            122460682,
            122465581,
            122460735,
            122465109,
            122500532,
            122457985,
            122461570,
            122463484,
            122466793,
            122463616,
            122461328,
            122473999,
            122456442,
            122457482,
            122463020,
            122460109,
            122461048
        ],
        "B": [
            122454763,
            122454362,
            122455252,
            122454378,
            122452343,
            122454794,
            122458968,
            122500982,
            122454363,
            122455298,
            122455088,
            122454989,
            122455874,
            122454863,
            122466413,
            122453075,
            122454714,
            122455929,
            122454807,
            122453314
        ],
        "A": [
            122451771,
            122451821,
            122451970,
            122451770,
            122451715,
            122451928,
            122452304,
            122501407,
            122451789,
            122452298,
            122451870,
            122452153,
            122452203,
            122451998,
            122462780,
            122451777,
            122452058,
            122452234,
            122451766,
            122451752
        ]
    },
    "name": "F. Jumping Around",
    "statement": "There is an infinite pond that can be represented with a number line.\r\nThere are n rocks in the pond, numbered from 1 to n. The i-th rock is\r\nlocated at an integer coordinate a_i. The coordinates of the rocks are\r\npairwise distinct. The rocks are numbered in the increasing order of the\r\ncoordinate, so a_1 < a_2 <\r\ndots < a_n.A robot frog sits on the rock number s. The frog is\r\nprogrammable. It has a base jumping distance parameter d. There also is\r\na setting for the jumping distance range. If the jumping distance range\r\nis set to some integer k, then the frog can jump from some rock to any\r\nrock at a distance from d - k to d + k inclusive in any direction. The\r\ndistance between two rocks is an absolute difference between their\r\ncoordinates.You are assigned a task to implement a feature for the frog.\r\nGiven two integers i and k determine if the frog can reach a rock number\r\ni from a rock number s performing a sequence of jumps with the jumping\r\ndistance range set to k. The sequence can be arbitrarily long or\r\nempty.You will be given q testcases for that feature, the j-th testcase\r\nconsists of two integers i and k. Print \"\" if the i-th rock is reachable\r\nand \"\" otherwise.You can output \"\" and \"\" in any case (for example,\r\nstrings \"\", \"\", \"\" and \u2019\"\u2019 will be recognized as a positive answer).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, q, s, d;\n    std::cin >> n >> q >> s >> d;\n    s--;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> f(n, -1);\n    std::priority_queue<std::pair<int, int>> h;\n    \n    std::set<int> jump, stones;\n    for (int i = 0; i < n; i++) {\n        stones.insert(i);\n    }\n    \n    auto getK = [&](int u) {\n        int x = a[u];\n        auto it = jump.lower_bound(x);\n        \n        int ans = 1e9;\n        if (it != jump.end()) {\n            ans = std::min(ans, *it - x);\n        }\n        if (it != jump.begin()) {\n            ans = std::min(ans, x - *std::prev(it));\n        }\n        \n        return ans;\n    };\n    \n    h.emplace(0, s);\n    \n    while (!h.empty()) {\n        auto [x, u] = h.top();\n        h.pop();\n        \n        if (f[u] >= 0) {\n            continue;\n        }\n        \n        f[u] = -x;\n        \n        for (auto v : {a[u] - d, a[u] + d}) {\n            jump.insert(v);\n            \n            int j = std::partition_point(a.begin(), a.end(), [&](int x) { return x < v; }) - a.begin();\n            \n            auto it = stones.lower_bound(j);\n            if (it != stones.end()) {\n                h.emplace(-std::max(f[u], a[*it] - v), *it);\n            }\n            \n            if (it != stones.begin()) {\n                it--;\n                h.emplace(-std::max(f[u], v - a[*it]), *it);\n            }\n        }\n        \n        stones.erase(u);\n        auto it = stones.lower_bound(u);\n        \n        if (it != stones.end()) {\n            h.emplace(-std::max(f[u], getK(*it)), *it);\n        }\n        if (it != stones.begin()) {\n            it--;\n            h.emplace(-std::max(f[u], getK(*it)), *it);\n        }\n    }\n    \n    while (q--) {\n        int i, k;\n        std::cin >> i >> k;\n        i--;\n        \n        if (k >= f[i]) {\n            std::cout << \"Yes\\n\";\n        } else {\n            std::cout << \"No\\n\";\n        }\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "divide and conquer",
        "dp",
        "dsu",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Jumping Around.json",
    "editorial_link": "https://codeforces.com//blog/entry/92864",
    "editorial": "Notice that increasing only increases the range of the jump distances in\r\nboth directions. So every rock that was reachable with some , will be\r\nreachable with as well. Thus, let\u00e2\u0080\u0099s try to find the smallest possible\r\nvalue of to reach each rock.Let\u00e2\u0080\u0099s imagine this problem as a graph one\r\nand consider the following algorithm. For every pair of rocks, make an\r\nedge of weight equal to the smallest required to jump from one to\r\nanother. For some rocks and that is . How to check the reachability with\r\nthese edges? Well, if the jump range value is , then there should exist\r\nof path by edges of weight no more than . So we can start with an empty\r\ngraph, first add the edges of the smallest weight, then the second\r\nsmallest, and so on. The first time a pair of vertices becomes reachable\r\nfrom each other is the minimum such weight.An experienced reader can\r\nnotice the resemblance with the Kruskal algorithm for finding the\r\nminimum spanning tree. After the spanning tree is constructed, the\r\nminimum is the maximum value on a path between the vertices.The issue is\r\nthat Kruskal requires to construct an MST for a complete graph. Prim can\r\nmake it , which is still too much. Thus, the solution is to resort to\r\nBoruvka.On each iteration of Boruvka we have to find the smallest weight\r\nedge from each component to some other one. We can solve it the\r\nfollowing way. Maintain a sorted set of rocks coordinates. The smallest\r\nweight edges are the ones that are the closest to distance from each\r\nrock. So we could query a lower_bound of and on each rock to find them.\r\nDon\u00e2\u0080\u0099t forget to look at the both sides of the lower_bound\r\nresult.However, the issue is that we can bump into the rocks from the\r\nsame component. Thus, let\u00e2\u0080\u0099s process components one by one. When\r\nprocessing a component, first remove all its vertices from the set. Then\r\nquery the edges for each vertex. Then add the vertices back. This way,\r\nonly the edges to other components will be considered.That makes it an\r\nconstruction, with one log from the number of Boruvka iterations and\r\nanother from finding the edges. That should pass if coded carefully\r\nenough, and that is basically the intended solution.Still, there exists\r\na construction. That will require a algorithm for finding the edges. So\r\nthere are four possible edges for each rock : the closest to from the\r\nleft, from the right and the same for . Let\u00e2\u0080\u0099s consider only the first\r\ncase, the rest will be similar.The coordinates are sorted beforehand,\r\nand we are processing the rocks from left to right. We can maintain a\r\npointer to the latest encountered rock to the left of . The issue with\r\nit being from the same component is still there. Let\u00e2\u0080\u0099s go around it by\r\nalso storing the second latest encountered rock such that it\u00e2\u0080\u0099s from the\r\ndifferent component from the actual latest one. This can be updated in\r\nthe same manner one calculates the second maximum of the array.Now you\r\njust have to do that for all four cases. This two pointers approach\r\nmakes it for each iteration, thus making the construction .Since the\r\nqueries ask for a path from some fixed vertex to a certain vertex , it\u00e2\u0080\u0099s\r\nthe same as calculating the maximum edge on a path from the root of the\r\ntree to each vertex. Can be done with a simple dfs. The only thing left\r\nis to check if the minimum possible is less than or equal to the one\r\nprovided in the query.Overall complexity: or .\r\n"
}