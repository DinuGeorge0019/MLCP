{"link": "https://codeforces.com//contest/1550/problem/F", "problemId": "1045986", "problem_idx": "F", "shortId": "1550F", "contest_number": "1550", "problem_submissions": {"F": [122483395, 122494928, 122494758, 122498831, 122495349, 122507186, 122504855, 122499174, 122495286, 122505655, 122503411, 122504082, 122506733, 122503920, 122507265, 122505173, 122514546, 122521422, 122608494, 122664141], "E": [122476565, 122473503, 122481437, 122485433, 122484524, 122485212, 122477724, 122500057, 122485157, 122486711, 122488337, 122498290, 122489523, 122484119, 122495271, 122476181, 122481232, 122481328, 122483526, 122494342], "D": [122471547, 122486544, 122474791, 122475055, 122481071, 122477408, 122494393, 122479516, 122495901, 122496325, 122494541, 122483595, 122476325, 122488807, 122472450, 122476646, 122472723, 122476521, 122472515], "C": [122458749, 122460413, 122460329, 122460157, 122463960, 122460682, 122465581, 122460735, 122465109, 122500532, 122457985, 122461570, 122463484, 122466793, 122463616, 122461328, 122473999, 122456442, 122457482, 122463020, 122460109, 122461048], "B": [122454763, 122454362, 122455252, 122454378, 122452343, 122454794, 122458968, 122500982, 122454363, 122455298, 122455088, 122454989, 122455874, 122454863, 122466413, 122453075, 122454714, 122455929, 122454807, 122453314], "A": [122451771, 122451821, 122451970, 122451770, 122451715, 122451928, 122452304, 122501407, 122451789, 122452298, 122451870, 122452153, 122452203, 122451998, 122462780, 122451777, 122452058, 122452234, 122451766, 122451752]}, "name": "F. Jumping Around", "statement": "There is an infinite pond that can be represented with a number line.\r\nThere are n rocks in the pond, numbered from 1 to n. The i-th rock is\r\nlocated at an integer coordinate a_i. The coordinates of the rocks are\r\npairwise distinct. The rocks are numbered in the increasing order of the\r\ncoordinate, so a_1 < a_2 <\r\ndots < a_n.A robot frog sits on the rock number s. The frog is\r\nprogrammable. It has a base jumping distance parameter d. There also is\r\na setting for the jumping distance range. If the jumping distance range\r\nis set to some integer k, then the frog can jump from some rock to any\r\nrock at a distance from d - k to d + k inclusive in any direction. The\r\ndistance between two rocks is an absolute difference between their\r\ncoordinates.You are assigned a task to implement a feature for the frog.\r\nGiven two integers i and k determine if the frog can reach a rock number\r\ni from a rock number s performing a sequence of jumps with the jumping\r\ndistance range set to k. The sequence can be arbitrarily long or\r\nempty.You will be given q testcases for that feature, the j-th testcase\r\nconsists of two integers i and k. Print \"\" if the i-th rock is reachable\r\nand \"\" otherwise.You can output \"\" and \"\" in any case (for example,\r\nstrings \"\", \"\", \"\" and \u2019\"\u2019 will be recognized as a positive answer).\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, q, s, d;\n    std::cin >> n >> q >> s >> d;\n    s--;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> f(n, -1);\n    std::priority_queue<std::pair<int, int>> h;\n    \n    std::set<int> jump, stones;\n    for (int i = 0; i < n; i++) {\n        stones.insert(i);\n    }\n    \n    auto getK = [&](int u) {\n        int x = a[u];\n        auto it = jump.lower_bound(x);\n        \n        int ans = 1e9;\n        if (it != jump.end()) {\n            ans = std::min(ans, *it - x);\n        }\n        if (it != jump.begin()) {\n            ans = std::min(ans, x - *std::prev(it));\n        }\n        \n        return ans;\n    };\n    \n    h.emplace(0, s);\n    \n    while (!h.empty()) {\n        auto [x, u] = h.top();\n        h.pop();\n        \n        if (f[u] >= 0) {\n            continue;\n        }\n        \n        f[u] = -x;\n        \n        for (auto v : {a[u] - d, a[u] + d}) {\n            jump.insert(v);\n            \n            int j = std::partition_point(a.begin(), a.end(), [&](int x) { return x < v; }) - a.begin();\n            \n            auto it = stones.lower_bound(j);\n            if (it != stones.end()) {\n                h.emplace(-std::max(f[u], a[*it] - v), *it);\n            }\n            \n            if (it != stones.begin()) {\n                it--;\n                h.emplace(-std::max(f[u], v - a[*it]), *it);\n            }\n        }\n        \n        stones.erase(u);\n        auto it = stones.lower_bound(u);\n        \n        if (it != stones.end()) {\n            h.emplace(-std::max(f[u], getK(*it)), *it);\n        }\n        if (it != stones.begin()) {\n            it--;\n            h.emplace(-std::max(f[u], getK(*it)), *it);\n        }\n    }\n    \n    while (q--) {\n        int i, k;\n        std::cin >> i >> k;\n        i--;\n        \n        if (k >= f[i]) {\n            std::cout << \"Yes\\n\";\n        } else {\n            std::cout << \"No\\n\";\n        }\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures", "divide and conquer", "dp", "dsu", "graphs", "shortest paths"], "dificulty": "2700", "interactive": false}