{
    "link": "https://codeforces.com//contest/1525/problem/D",
    "problemId": "987014",
    "problem_idx": "D",
    "shortId": "1525D",
    "contest_number": "1525",
    "problem_submissions": {
        "D": [
            116596850,
            116594983,
            116556621,
            116344048,
            116344302,
            116349055,
            116346341,
            116347417,
            116335585,
            116344826,
            116338508,
            116335707,
            116341307,
            116349851,
            116341668,
            116351051,
            116353738,
            116347590,
            116343356,
            116345813,
            116346453,
            116348324
        ],
        "F": [
            116372175,
            116372025,
            116380530,
            116381098,
            116381539,
            116374296,
            116382706,
            116380101,
            116523025,
            116385915,
            116383799,
            116377898,
            116380915,
            116382591,
            116385839,
            116395698
        ],
        "E": [
            116351338,
            116353665,
            116354964,
            116353294,
            116353957,
            116361966,
            116348163,
            116347670,
            116343533,
            116351101,
            116353993,
            116360946,
            116355058,
            116358519,
            116354709,
            116351286,
            116352542,
            116358011,
            116357879
        ],
        "C": [
            116334549,
            116339182,
            116340233,
            116340613,
            116342489,
            116350963,
            116337654,
            116366806,
            116362628,
            116359745,
            116345739,
            116358283,
            116349150,
            116349846,
            116332723,
            116338076,
            116338563,
            116342647,
            116341792
        ],
        "B": [
            116321920,
            116322956,
            116323732,
            116325314,
            116321887,
            116323618,
            116323021,
            116322464,
            116326670,
            116325875,
            116323111,
            116331257,
            116322276,
            116322144,
            116322587,
            116325439,
            116323730,
            116321987,
            116325764
        ],
        "A": [
            116320634,
            116320705,
            116320798,
            116320688,
            116320665,
            116321107,
            116320786,
            116320654,
            116321098,
            116320865,
            116320734,
            116327758,
            116320593,
            116320655,
            116320605,
            116320657,
            116320652,
            116320617,
            116320774
        ]
    },
    "name": "D. Armchairs",
    "statement": "There are n armchairs, numbered from 1 to n from left to right. Some\r\narmchairs are occupied by people (at most one person per armchair),\r\nothers are not. The number of occupied armchairs is not greater than\r\nfrac{n}{2}.For some reason, you would like to tell people to move from\r\ntheir armchairs to some other ones. If the i-th armchair is occupied by\r\nsomeone and the j-th armchair is not, you can tell the person sitting in\r\nthe i-th armchair to move to the j-th armchair. The time it takes a\r\nperson to move from the i-th armchair to the j-th one is |i - j|\r\nminutes. You may perform this operation any number of times, but these\r\noperations must be done sequentially, i. e. you cannot tell a person to\r\nmove until the person you asked to move in the last operation has\r\nfinished moving to their destination armchair.You want to achieve the\r\nfollowing situation: every seat that was initially occupied must be\r\nfree. What is the minimum time you need to do it?\r\n",
    "solutions": [
        "/*\n    author:  Maksim1744\n    created: 18.05.2021 21:05:42\n*/\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i)\n        cin >> a[i];\n\n    vector<int> sum0(n), sum1(n);\n    for (int i = 0; i < n; ++i) {\n        if (a[i] == 0) sum0[i] = i;\n        else sum1[i] = i;\n    }\n    for (int i = 1; i < n; ++i) {\n        sum0[i] += sum0[i - 1];\n        sum1[i] += sum1[i - 1];\n    }\n\n    auto get_sum = [&](int l, int r) {\n        if (l > r) return 0;\n        int s0 = sum0[r] - (l == 0 ? 0 : sum0[l - 1]);\n        int s1 = sum1[r] - (l == 0 ? 0 : sum1[l - 1]);\n        return abs(s0 - s1);\n    };\n\n    vector<int> dp(n, 1e9);\n\n    // offset for negative balance\n    int N = n;\n    vector<int> with_balance(N * 2 + 1, -1);\n\n    int balance = N + 0;\n    with_balance[N + 0] = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (a[i] == 0) --balance;\n        else ++balance;\n        if (with_balance[balance] != -1) {\n            int l = with_balance[balance];\n            int r = i;\n            int sm = get_sum(l, r);\n            // type 2 edge\n            dp[r] = min(dp[r], sm + (l == 0 ? 0 : dp[l - 1]));\n        }\n        with_balance[balance] = i + 1;\n        if (a[i] == 0) {\n            // type 1 edge\n            dp[i] = min(dp[i], (i == 0 ? 0 : dp[i - 1]));\n        }\n    }\n\n    cout << dp.back() << '\\n';\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "flows",
        "graph matchings",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Armchairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/90793",
    "editorial": "Letâs say that the starting position of people are (in sorted order) and\r\nending positions of people are (also in sorted order). Itâs always\r\noptimal to match these starting and ending positions in sorted order:\r\nthe leftmost starting position is matched with the leftmost ending, the\r\nsecond starting position is matched with the second ending, and so on.\r\nTo prove it, suppose that position is matched with , position is matched\r\nwith , and . If both persons go to the left or to the right, it means\r\nthat either or , so nothing changes if we swap the matched positions.\r\nIf, instead, the person that goes from to goes to the right, and the\r\nperson that goes from to goes to the left, the segment belongs to both\r\npaths, and swapping the matched pairs removes this segment from both\r\npaths (and decreases the total time). So, if the order of starting\r\npositions is sorted and the order of ending positions is sorted, these\r\npositions should be matched exactly in those order.Using this fact, we\r\ncan implement the following dynamic programming: let be the minimum time\r\nif we considered first positions and picked of them as the ending ones.\r\nTransitions are the following: we either take the current position as\r\nthe ending one (if itâs not a starting one), match it with the -th\r\nstarting position and go to , or we skip the current position and go to\r\n. It works in since it has up to states and just up to transitions from\r\neach state.\r\n",
    "hint": []
}