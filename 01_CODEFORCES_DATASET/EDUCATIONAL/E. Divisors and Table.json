{
    "link": "https://codeforces.com//contest/1792/problem/E",
    "problemId": "1749563",
    "problem_idx": "E",
    "shortId": "1792E",
    "contest_number": "1792",
    "problem_submissions": {
        "F2": [
            190375653,
            190403355,
            190403314,
            190376566,
            190371354,
            190371009,
            190378681,
            190390688,
            190380339,
            190390744,
            190397281,
            190395571,
            190396332,
            190405095,
            190396914,
            190408873,
            190408290,
            190408068,
            190403016,
            190399709,
            190399068,
            190440777,
            190401995
        ],
        "F1": [
            190360560,
            190376613,
            190370799,
            190366049,
            190372835,
            190357166,
            190380441,
            190390644,
            190395529,
            190392693,
            190394679,
            190392495,
            190385352,
            190378233,
            190371980,
            190376961,
            190394240,
            190393976,
            190392996,
            190356477,
            190392540,
            190390220,
            190391148,
            190435798,
            190392761
        ],
        "E": [
            190349536,
            190396415,
            190356797,
            190355921,
            190355685,
            190354329,
            190356654,
            190379338,
            190367695,
            190364381,
            190379913,
            190372928,
            190374531,
            190346879,
            190354441,
            190356992,
            190357830,
            190369017,
            190404398,
            190369702,
            190375086,
            190345346,
            190361270
        ],
        "D": [
            190338681,
            190342485,
            190377665,
            190342856,
            190335191,
            190347677,
            190340391,
            190336758,
            190364512,
            190353489,
            190336022,
            190340377,
            190341608,
            190336712,
            190338416,
            190338462,
            190342927,
            190342951,
            190340969,
            190356126,
            190343824
        ],
        "C": [
            190332032,
            190336067,
            190327325,
            190335874,
            190328548,
            190335825,
            190331257,
            190329975,
            190341574,
            190346406,
            190329101,
            190331331,
            190332174,
            190331190,
            190328589,
            190329328,
            190333145,
            190331745,
            190324986,
            190335758
        ],
        "B": [
            190326313,
            190322698,
            190320989,
            190331751,
            190324446,
            190330720,
            190326021,
            190327400,
            190330429,
            190335776,
            190324890,
            190326657,
            190333559,
            190327470,
            190325870,
            190324745,
            190327323,
            190329410,
            190330842,
            190329835
        ],
        "A": [
            190321850,
            190318780,
            190318690,
            190319485,
            190319112,
            190319183,
            190319784,
            190318833,
            190324148,
            190321022,
            190318836,
            190320391,
            190319287,
            190319729,
            190318884,
            190319911,
            190320170,
            190319083,
            190321001,
            190322167
        ]
    },
    "name": "E. Divisors and Table",
    "statement": "You are given an n\r\ntimes n multiplication table and a positive integer m = m_1\r\ncdot m_2. A n\r\ntimes n multiplication table is a table with n rows and n columns\r\nnumbered from 1 to n, where a_{i, j} = i\r\ncdot j.For each divisor d of m, check: does d occur in the table at\r\nleast once, and if it does, what is the row that contains d.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint n=0,f=1,ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tn=n*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn n*f;\n}\nint pri[100005],tsl[100005],cnt;\nint ys[500005],qans[500005],tmp;\nmap<int,int>ma;\nvoid dfs(int x,int now)\n{\n\tif(x==cnt+1)\n\t{\n\t\tys[++tmp]=now;\n\t\treturn;\n\t}\n\tfor(int i=0;i<=tsl[x];i++)\n\t{\n\t\tdfs(x+1,now);\n\t\tnow*=pri[x];\n\t}\n}\nsigned main()\n{\n\tint t,n,m1,m2;\n\tt=read();\n\tfor(int greg=1;greg<=t;greg++)\n\t{\n\t\tn=read();\n\t\tm1=read();\n\t\tm2=read();\n\t\tcnt=0;\n\t\tfor(int i=2;i*i<=m1||i*i<=m2;i++)\n\t\t{\n\t\t\tif(m1%i!=0&&m2%i!=0)continue;\n\t\t\tpri[++cnt]=i;\n\t\t\ttsl[cnt]=0;\n\t\t\twhile(m1%i==0)m1/=i,tsl[cnt]++;\n\t\t\twhile(m2%i==0)m2/=i,tsl[cnt]++;\n\t\t}\n\t\tif(m1<m2)swap(m1,m2);\n\t\tif(m1>1)\n\t\t{\n\t\t\tpri[++cnt]=m1;\n\t\t\ttsl[cnt]=1;\n\t\t}\n\t\tif(m2>1)\n\t\t{\n\t\t\tif(m1==m2)tsl[cnt]++;\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tpri[++cnt]=m2;\n\t\t\t\ttsl[cnt]=1;\n\t\t\t}\n\t\t}\n\t\ttmp=0;\n\t\tdfs(1,1);\n\t\tsort(ys+1,ys+tmp+1);\n\t\tma.clear();\n\t\tfor(int i=1;i<=tmp;i++)ma[ys[i]]=i;\n\t\tfor(int i=1;i<=tmp;i++)\n\t\t{\n\t\t\tif(ys[i]<=n)\n\t\t\t{\n\t\t\t\tqans[i]=ys[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tqans[i]=-1;\n\t\t\tfor(int j=1;j<=cnt;j++)\n\t\t\t{\n\t\t\t\tif(ys[i]%pri[j]==0)qans[i]=max(qans[i],qans[ma[ys[i]/pri[j]]]);\n\t\t\t}\n\t\t}\n\t\tint sl=0,yh=0;\n\t\tfor(int i=1;i<=tmp;i++)\n\t\t{\n\t\t\tif(qans[i]!=0&&ys[i]/qans[i]<=n)\n\t\t\t{\n\t\t\t\t//printf(\"%lld %lld\\n\",ys[i],ys[i]/qans[i]);\n\t\t\t\tsl++;\n\t\t\t\tyh^=(ys[i]/qans[i]); \n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",sl,yh);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "number theory"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Divisors and Table.json",
    "editorial_link": "https://codeforces.com//blog/entry/111835",
    "editorial": "Firstly, let\u00e2\u0080\u0099s factorize . Since we can factorize and separately and\r\nthen \"unite\" divisors. For example, use can get canonical\r\nrepresentations of and to get canonical representation of and then use\r\nit to generate all divisors of .Let\u00e2\u0080\u0099s estimate the number of divisors .\r\nIt\u00e2\u0080\u0099s convenient for our purposes to estimate it as . More precisely,\r\nthere are at most divisors for (search \"Highly Composite Numbers\" for\r\nmore info).How to calculate the answer for each divisor ? There are two\r\nways. for each we are searching for the minimum that and . Since is\r\nfixed, the minimum means the maximum . So let\u00e2\u0080\u0099s find instead. In other\r\nwords, for each we need to find the maximum such that divides and . We\r\ncan do it efficiently with on divisors.Let be the maximum that is a\r\ndivisor of and . If then, obviously, . Otherwise, we know that we are\r\nsearching .Let say that are the prime divisors of the initial number .\r\nSince is a divisor of and then exists some among the set of prime\r\ndivisors such that is a divisor of as well. So, instead of brute search,\r\nit\u00e2\u0080\u0099s enough to take a value .In other words, if we can calculate .Ok,\r\nnow we know value for each divisor . Since we found the maximum , the\r\nlast step is to calculate the desired and if we found the answer ,\r\notherwise () it means that is not presented table and .The total\r\ncomplexity is per test, where is the number of divisors of () and is the\r\nnumber of prime divisor of (). Note that complexity is quite high, so\r\nyou should write it at least a little accurate, for example store in an\r\narray, not map, and search position of with .There is also a way to get\r\nrid of extra factor if you iterate through is a smart way. (faster,\r\neasier, unproven): Let\u00e2\u0080\u0099s generate a list of all divisors of as in the\r\nincreasing order. For some divisor we are searching the minimum that is\r\na divisor of and . It means that .So let\u00e2\u0080\u0099s just find the first position\r\nsuch that with and start iterating from onward searching the first that\r\nis a divisor of . The found would be the minimum we need.It looks like,\r\nin average, we will find the correct quite fast, or we\u00e2\u0080\u0099ll break when .\r\n"
}