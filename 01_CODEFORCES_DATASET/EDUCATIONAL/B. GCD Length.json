{
    "link": "https://codeforces.com//contest/1511/problem/B",
    "problemId": "955213",
    "problem_idx": "B",
    "shortId": "1511B",
    "contest_number": "1511",
    "problem_submissions": {
        "F": [
            112840077,
            112828537,
            112827087,
            113002746,
            112851650,
            112835176,
            112837815,
            112833990,
            112833873,
            112824360,
            112844580,
            112864617,
            112862363,
            112847364,
            112866931,
            112854217,
            112847572,
            112854389,
            112862579,
            112845350
        ],
        "G": [
            112827572,
            112849564,
            114661033,
            114660887,
            114660767,
            114660706,
            114660307,
            114660076,
            114659999,
            114659915,
            112892560,
            112862384,
            112862341,
            112862288,
            112850067,
            112846404,
            112853880,
            112853846,
            112850825,
            112896875,
            112847874,
            113122868,
            112859368,
            112858002,
            112857690,
            112970481,
            112947065,
            112923272,
            112913505,
            113005183,
            112847551,
            112853638,
            112855715
        ],
        "E": [
            112819190,
            112811502,
            112809874,
            112818379,
            112809749,
            112819391,
            112816521,
            112812422,
            112824024,
            112811228,
            112816399,
            112821852,
            112825588,
            112822496,
            112814072,
            112820021,
            112829060,
            112824596
        ],
        "D": [
            112810190,
            112804690,
            112802519,
            112810990,
            112813483,
            112807233,
            112809814,
            112797395,
            112806426,
            112804268,
            112810141,
            112805389,
            112810319,
            112811043,
            112802328,
            112810501,
            112810922,
            112816639
        ],
        "C": [
            112798920,
            112798787,
            112796760,
            112804959,
            112800997,
            112799737,
            112805004,
            112792842,
            112799549,
            112797984,
            112795724,
            112796489,
            112801048,
            112802109,
            112797807,
            112801283,
            112801426,
            112804850
        ],
        "B": [
            112794609,
            112794368,
            112790815,
            112794707,
            112794954,
            112796065,
            112801022,
            112788437,
            112794356,
            112792946,
            112790545,
            112792316,
            112798211,
            112798547,
            112790397,
            112797545,
            112796307,
            112796695
        ],
        "A": [
            112787944,
            112786809,
            112787014,
            112786892,
            112787663,
            112788591,
            112791727,
            112786823,
            112788650,
            112788073,
            112786815,
            112787413,
            112786972,
            112791493,
            112787338,
            112792315,
            112786886,
            112787405
        ]
    },
    "name": "B. GCD Length",
    "statement": "You are given three integers a, b and c.Find two positive integers x and\r\ny (x > 0, y > 0) such that: the decimal representation of x without\r\nleading zeroes consists of a digits; the decimal representation of y\r\nwithout leading zeroes consists of b digits; the decimal representation\r\nof gcd(x, y) without leading zeroes consists of c digits. gcd(x, y)\r\ndenotes the greatest common divisor (GCD) of integers x and y.Output x\r\nand y. If there are multiple answers, output any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\ntemplate <class T>\nconstexpr T power(T a, int64_t n) {\n  assert(n >= 0);\n  T res = n & 1 ? a : 1;\n  while (n >>= 1) {\n    a *= a;\n    if (n & 1) res *= a;\n  }\n  return res;\n}\n\ntemplate <int Id>\nclass DynamicModularInt64 {\n  using D = DynamicModularInt64;\n\n public:\n  static int64_t modulus() { return modulus_; }\n  static void modulus(int64_t modulus) {\n    assert(modulus >= 1);\n    modulus_ = modulus;\n  }\n  static D raw(uint64_t v) { return *reinterpret_cast<D*>(&v); }\n\n  DynamicModularInt64() : v_(0) {}\n  DynamicModularInt64(int64_t v)\n      : v_((v %= modulus()) < 0 ? v + modulus() : v) {}\n\n  template <class T>\n  explicit operator T() const {\n    return v_;\n  }\n  D& operator++() { return v_ = ++v_ == modulus_ ? 0 : v_, *this; }\n  D& operator--() { return --(v_ ? v_ : v_ = modulus_), *this; }\n  D operator+() const { return *this; }\n  D operator-() const { return raw(v_ ? modulus_ - v_ : 0); }\n  D& operator*=(D o) {\n    v_ = v_ * o.v_ - uint64_t((long double)v_ * o.v_ / modulus_) * modulus_;\n    v_ = int64_t(v_) < 0 ? v_ + modulus_ : v_;\n    v_ = v_ >= modulus_ ? v_ - modulus_ : v_;\n    return *this;\n  }\n  D& operator/=(D o) {\n    auto [inv, gcd] = extgcd(o.v_, modulus_);\n    assert(gcd == 1);\n    return *this *= inv;\n  }\n  D& operator+=(D o) {\n    return v_ = int64_t(v_ += o.v_ - modulus_) < 0 ? v_ + modulus_ : v_, *this;\n  }\n  D& operator-=(D o) {\n    return v_ = int64_t(v_ -= o.v_) < 0 ? v_ + modulus_ : v_, *this;\n  }\n\n  friend D operator++(D& a, int) { return std::exchange(a, ++D(a)); }\n  friend D operator--(D& a, int) { return std::exchange(a, --D(a)); }\n  friend D operator*(D a, D b) { return a *= b; }\n  friend D operator/(D a, D b) { return a /= b; }\n  friend D operator+(D a, D b) { return a += b; }\n  friend D operator-(D a, D b) { return a -= b; }\n  friend std::istream& operator>>(std::istream& is, D& x) {\n    int64_t v;\n    return is >> v, x = v, is;\n  }\n  friend std::ostream& operator<<(std::ostream& os, D x) { return os << x.v_; }\n  friend bool operator==(D a, D b) { return a.v_ == b.v_; }\n  friend bool operator!=(D a, D b) { return a.v_ != b.v_; }\n\n private:\n  static std::pair<int64_t, int64_t> extgcd(int64_t a, int64_t b) {\n    std::array<int64_t, 2> x{1, 0};\n    while (b) std::swap(x[0] -= a / b * x[1], x[1]), std::swap(a %= b, b);\n    return {x[0], a};\n  }\n\n  static inline uint64_t modulus_ = std::numeric_limits<int64_t>::max();\n\n  uint64_t v_;\n};\n\nbool miller_rabin(int64_t n, std::initializer_list<int64_t> bases) {\n  using Mint = DynamicModularInt64<__COUNTER__>;\n  Mint::modulus(n);\n  int tz = __builtin_ctzll(n - 1);\n  for (Mint a : bases) {\n    if (a == 0) continue;\n    a = power(a, n >> tz);\n    int i = tz;\n    while (a != 1 and a != -1 and i--) a *= a;\n    if (a != -1 and i != tz) return false;\n  }\n  return true;\n}\n\nbool is_prime(int64_t n) {\n  if (n < 2 or n % 6 % 4 != 1) return n == 2 or n == 3;\n  if (n < 291831) return miller_rabin(n, {126401071349994536});\n  if (n < 1050535501) return miller_rabin(n, {336781006125, 9639812373923155});\n  if (n < 273919523041)\n    return miller_rabin(n, {15, 7363882082, 992620450144556});\n  if (n < 47636622961201)\n    return miller_rabin(n, {2, 2570940, 211991001, 3749873356});\n  if (n < 7999252175582851)\n    return miller_rabin(n, {2, 4130806001517, 149795463772692060,\n                            186635894390467037, 3967304179347715805});\n  if (n < 585226005592931977)\n    return miller_rabin(\n        n, {2, 123635709730000, 9233062284813009, 43835965440333360,\n            761179012939631437, 1263739024124850375});\n  return miller_rabin(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});\n}\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  vector<int> x, y;\n  for (int i : Rep(9)) {\n    int p = power(10, i);\n    while (not is_prime(p)) ++p;\n    x.push_back(p);\n    ++p;\n    while (not is_prime(p)) ++p;\n    y.push_back(p);\n  }\n  DUMP(x);\n  DUMP(y);\n  for (int tt = scan(); tt--;) {\n    int a = scan() - 1;\n    int b = scan() - 1;\n    int c = scan() - 1;\n    cout << x[a - c] * power(10, c) << ' ' << y[b - c] * power(10, c) << '\\n';\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. GCD Length.json",
    "editorial_link": "https://codeforces.com//blog/entry/89634",
    "editorial": "The easiest way to force some gcd to be of some fixed length is to use\r\nthe divisibility rules for , or : if the number produced by the last\r\ndigits is divisible by , then is also divisible by (same goes for and\r\n).One of the possible constructions is the following: let and . Since\r\nand are pairwise prime, gcd is .Overall complexity: per testcase.\r\n"
}