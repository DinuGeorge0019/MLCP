{"link": "https://codeforces.com//contest/598/problem/E", "problemId": "40733", "problem_idx": "E", "shortId": "598E", "contest_number": "598", "problem_submissions": {"C": [14258282, 14258243, 14230694, 14231202, 14231643, 14230605, 14232276, 14232531, 14233681, 14236053, 14234393, 14237043, 14234521, 14238674, 14254495], "E": [14232918, 14233759, 14233061, 14234500, 14235984, 14231617, 14235791, 14234781, 14237980, 27723122, 14234802, 14238606, 14238276, 14230968, 14231346, 14231257, 14229755, 14231535, 14232059], "D": [14231500, 14232200, 14231256, 14232148, 14233968, 14233300, 14231514, 14231409, 14235674, 14233048, 14236255, 14231336, 14229735, 14229704, 14230486, 14231024, 14230489, 14230566], "B": [14228934, 14229369, 14229229, 14229653, 14229332, 14229739, 14232154, 14232624, 14229585, 14231038, 14232631, 14229469, 14229277, 14228902, 14228794, 14230341, 14229075, 14229130], "A": [14228503, 14228566, 14228506, 14229062, 14228523, 14229086, 14229170, 14228699, 14228571, 14228539, 14228982, 14228489, 14228480, 14228476, 14228530, 14228507, 14228550], "F": [59190852, 14260771]}, "name": "E. Chocolate Bar", "statement": "You have a rectangular chocolate bar consisting of single squares. You\r\nwant to eat squares, so you may need to break the chocolate bar. In one\r\nmove you can break any single rectangular piece of chocolate in two\r\nrectangular pieces. You can break only by lines between squares:\r\nhorizontally or vertically. The cost of breaking is equal to square of\r\nthe break length.For example, if you have a chocolate bar consisting of\r\nunit squares then you can break it horizontally and get two pieces (the\r\ncost of such breaking is ), or you can break it vertically in two ways\r\nand get two pieces: and (the cost of such breaking is ).For several\r\ngiven values , and find the minimum total cost of breaking. You can eat\r\nexactly squares of chocolate if after all operations of breaking there\r\nis a set of rectangular pieces of chocolate with the total size equal to\r\nsquares. The remaining squares are not necessarily form a single\r\nrectangular piece.\r\n", "solutions": ["//ITNOA\n#include<bits/stdc++.h> \n\nusing namespace std;\n \n\n#define scan(x) do{while((x=getchar())<'0'); for(x-='0'; '0'<=(_=getchar()); x=(x<<3)+(x<<1)+_-'0');}while(0)\nchar _;\n\n//#define int long long\n#define rep(i, s, e) for(int i = s; i < e; i ++)\n#define X first\n#define Y second\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int maxN = 1000 + 5;\nconst int mod = 1000*1000*1000 + 7;\nconst int base = 701;\nconst int SQ = 600;\nconst int maxL = 302;\n\n\nint dp[32][32][52];\n\nint32_t main()\n{\n    ios::sync_with_stdio(0); cin.tie(0);\n    rep(i,0,32) rep(j,0,32) rep(k,0,52)\n\tdp[i][j][k] = mod;\n\n    rep(i,1,32) rep(j,1,32)\n    {\n\tif(i * j < 52) dp[i][j][i*j] = 0;\n\tdp[i][j][0] = 0;\n\n\tint x = min(52, i*j);\n\trep(k,1,x)\n\t{\n\t    rep(who,0,k+1)\n\t    {\n\t\trep(wh,1,j)\n\t\t    dp[i][j][k] = min(dp[i][j][k], dp[i][wh][who] + dp[i][j-wh][k-who] + i * i);\n\t\trep(wh,1,i)\n\t\t    dp[i][j][k] = min(dp[i][j][k], dp[wh][j][who] + dp[i-wh][j][k-who] + j * j);\n\t    }\n\t}\n    }\n\n    int q; cin >> q;\n    rep(i,0,q)\n    {\n\tint n, m, k; cin >> n >> m >> k;\n\tcout << dp[n][m][k] << endl;\n    }\n    return 0;    \n}\n"], "input": "", "output": "", "tags": ["brute force", "dp"], "dificulty": "2000", "interactive": false}