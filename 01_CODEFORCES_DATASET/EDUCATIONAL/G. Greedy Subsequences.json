{
    "link": "https://codeforces.com//contest/1132/problem/G",
    "problemId": "307701",
    "problem_idx": "G",
    "shortId": "1132G",
    "contest_number": "1132",
    "problem_submissions": {
        "E": [
            50850068,
            50849530,
            50845767,
            50845285,
            50999251,
            50998220,
            50984714,
            50983025,
            50849124,
            50834937,
            50849964,
            50853384,
            50853400,
            50852279,
            50851280,
            50853752,
            50855850,
            50853199,
            51446514,
            50851785,
            50834992,
            50854163,
            50845937
        ],
        "G": [
            50842167,
            50854823,
            50857129,
            50854920,
            50844161,
            50859138,
            57119782,
            50878894,
            51002265,
            50995547,
            50857246,
            50834458,
            50982974,
            50871478
        ],
        "F": [
            50840202,
            50838419,
            50836444,
            50982824,
            50982298,
            50914403,
            50914340,
            50845586,
            50832740,
            50838344,
            50839910,
            50835170,
            50841485,
            50845495,
            50850234,
            50846859,
            50849525,
            50847269,
            50833261,
            50843613,
            50842907,
            50837062,
            50843690,
            50848869
        ],
        "D": [
            50834165,
            50842583,
            50852105,
            50872042,
            50872030,
            50859910,
            50859897,
            50858488,
            50851238,
            50841187,
            50848482,
            50846027,
            50850423,
            50849233,
            50840756,
            50846142,
            50842178,
            50842159,
            50851492,
            50842299,
            50850678,
            50854836,
            50842129,
            50854102
        ],
        "C": [
            50827032,
            50833764,
            50832215,
            50839270,
            50881672,
            50828449,
            50836070,
            50832571,
            50831895,
            50835165,
            50830486,
            50829266,
            50832724,
            50834393,
            50838461,
            50842825,
            50830636,
            50837272,
            50843085,
            50842733,
            50838178
        ],
        "B": [
            50825116,
            50826216,
            50828719,
            50855444,
            50825477,
            50825790,
            50828172,
            50826213,
            50832189,
            50825110,
            50828347,
            50828834,
            50837439,
            50825450,
            50826572,
            50843916,
            50826867,
            50835237
        ],
        "A": [
            50824651,
            50824679,
            50826667,
            50855859,
            50824764,
            50824716,
            50825124,
            50824755,
            50829449,
            50824659,
            50826098,
            50836545,
            50824668,
            50824888,
            50845090,
            50825359,
            50834758
        ]
    },
    "name": "G. Greedy Subsequences",
    "statement": "For some array c, let\u2019s denote a as a sequence of indices p_1, p_2, ...,\r\np_l such that 1\r\nle p_1 < p_2 <\r\ndots < p_l\r\nle |c|, and for each i\r\nin [1, l - 1], p_{i + 1} is the minimum number such that p_{i + 1} > p_i\r\nand c[p_{i + 1}] > c[p_i].You are given an array a_1, a_2,\r\ndots, a_n. For each its subsegment of length k, calculate the length of\r\nits longest greedy subsequence.\r\n",
    "solutions": [
        "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\ntemplate<typename T> T mo(T x, T y) { x %= y; return x <= 0 ? x + y : x; }\n\nconst int MX = 1000 * 1000 + 7;\nconst int INF = 1000 * 1000 * 1000 + 7;\n\nint t[4 * MX];\nint md[4 * MX];\n\nvoid push(int v) {\n    md[v + v] += md[v];\n    md[v + v + 1] += md[v];\n    md[v] = 0;\n}\n\nint gv(int v) {\n    return t[v] + md[v];\n}\n\nvoid pop(int v) {\n    t[v] = max(gv(v + v), gv(v + v + 1));\n}\n\nvoid ad(int v, int tl, int tr, int l, int r, int x) {\n    if (r < tl || l > tr) {\n        return;\n    }\n    if (tl >= l && tr <= r) {\n        md[v] += x;\n    } else {\n        push(v);\n        int tm = (tl + tr) >> 1;\n        ad(v + v, tl, tm, l, r, x);\n        ad(v + v + 1, tm + 1, tr, l, r, x);\n        pop(v);\n    }\n}\n\nvector<int> g[MX];\nint tin[MX], tout[MX];\nint timer = 1;\nint a[MX];\n\nvoid dfs(int v) {\n    tin[v] = timer;\n    timer++;\n    for (int to : g[v]) {\n        dfs(to);\n    }\n    tout[v] = timer - 1;\n}\n\nint main() {\n#ifdef FASTIO\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n    int n, k;\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    vector<pair<int, int> > st;\n    st.emplace_back(INF, n + 1);\n    for (int i = n; i >= 1; i--) {\n        while (!st.empty() && st.back().first <= a[i]) {\n            st.pop_back();\n        }\n        if (st.back().second != n + 1) {\n            g[st.back().second].push_back(i);\n        }\n        st.emplace_back(a[i], i);\n    }\n    for (int i = n; i >= 1; i--) {\n        if (tin[i] == 0) {\n            dfs(i);\n        }\n    }\n    int l = 1, r = 1;\n    auto mvr = [&]() {\n        ad(1, 1, n, tin[r], tout[r], 1);\n        r++;\n    };\n    auto mvl = [&]() {\n        ad(1, 1, n, tin[l], tin[l], -INF);\n        l++;\n    };\n    for (int i = 1; i + k - 1 <= n; i++) {\n        int gl = i, gr = i + k;\n        while (r < gr) {\n            mvr();\n        }\n        while (l < gl) {\n            mvl();\n        }\n        cout << gv(1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Greedy Subsequences.json",
    "editorial_link": "https://codeforces.com/blog/entry/65752",
    "editorial": "Let\u00e2\u0080\u0099s calculate for each position position \"the closest greater from the\r\nright\" element to and add directed edge from to . Then we will get\r\noriented forest (or tree if we\u00e2\u0080\u0099d add fictive vertex) where all edges are\r\ndirected to some root.So, we can look at current subsegment we need to\r\ncalculate the answer for as at a number of marked vertices in the tree.\r\nThen, the answer itself is a longest path up to the tree consisting only\r\nfrom marked vertices. Key observation is next: if and are marked and is\r\nan ancestor of then any vertex on path from to is also marked.So, \"the\r\nlongest path up to the tree consisting only from marked vertices\" has\r\nlength equal to a number of marked vertices on path to the root. And we\r\nhave three types of queries: mark a vertex, unmark a vertex and\r\ncalculate maximum number of marked vertices among all paths to the\r\nroot.It can be done with Segment Tree on Euler Tour of the tree: if we\r\ncalculate and for each vertex in dfs order, then marking/unmarking is\r\njust adding to a segment , and maximum among all paths is a maximum on\r\nthe whole tree.Result time complexity is and space complexity is .\r\n"
}