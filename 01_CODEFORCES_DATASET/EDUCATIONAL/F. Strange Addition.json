{
    "link": "https://codeforces.com//contest/1380/problem/F",
    "problemId": "670988",
    "problem_idx": "F",
    "shortId": "1380F",
    "contest_number": "1380",
    "problem_submissions": {
        "F": [
            86713166,
            86683254,
            86680631,
            86680966,
            86687165,
            86684140,
            86669350,
            86688621,
            86687283,
            86673002,
            86689951,
            86691835,
            86685205,
            86710315,
            86689156,
            86687400,
            86687045,
            86687896,
            86690019
        ],
        "G": [
            86677566,
            86685201,
            86688237,
            86689481,
            86686718,
            86691383,
            86690954,
            86692142,
            86694360,
            86693986,
            86693332,
            86693299,
            86700820,
            86693764,
            86685196,
            86684314
        ],
        "E": [
            86675522,
            86675407,
            86673302,
            86676691,
            86680473,
            86684037,
            86681297,
            86679620,
            86685647,
            86685220,
            86686544,
            86674567,
            86678512,
            86684412,
            86683830,
            86676323,
            86680714,
            86681696,
            86690990
        ],
        "D": [
            86667662,
            86670333,
            86669219,
            86673424,
            86678569,
            86680592,
            86676914,
            86676735,
            86681998,
            86680522,
            86687871,
            86670447,
            86672345,
            86680156,
            86679073,
            86689461,
            86721905,
            86687223
        ],
        "C": [
            86667582,
            86670259,
            86669101,
            86667895,
            86670203,
            86672224,
            86667959,
            86672685,
            86676101,
            86675384,
            86675814,
            86668973,
            86672498,
            86672045,
            86670655,
            86667252,
            86668731,
            86674537,
            86668780
        ],
        "B": [
            86667335,
            86670187,
            86671042,
            86667790,
            86672794,
            86670893,
            86667752,
            86671215,
            86673431,
            86671665,
            86674484,
            86670341,
            86660822,
            86669327,
            86673817,
            86667069,
            86673326,
            86672657,
            86668683
        ],
        "A": [
            86667075,
            86670143,
            86668605,
            86667568,
            86667937,
            86657614,
            86657741,
            86669480,
            86673357,
            86672922,
            86672973,
            86668720,
            86672438,
            86659787,
            86671597,
            86666992,
            86671323,
            86669608,
            86668545
        ]
    },
    "name": "F. Strange Addition",
    "statement": "Let a and b be some non-negative integers. Let\u2019s define of a and b as\r\nfollowing: write down the numbers one under another and align them by\r\ntheir least significant digit; add them up digit by digit and\r\nconcatenate the respective sums together. Assume that both numbers have\r\nan infinite number of leading zeros.For example, let\u2019s take a look at a\r\nof numbers 3248 and 908: You are given a string c, consisting of n\r\ndigits from 0 to 9. You are also given m updates of form: x\u00a0d replace\r\nthe digit at the x-th position of c with a digit d. Note that string c\r\nmight have leading zeros at any point of time.After each update print\r\nthe number of pairs (a, b) such that both a and b are non-negative\r\nintegers and the result of a of a and b is equal to c.Note that the\r\nnumbers of pairs can be quite large, so print them modulo 998244353.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 998244353;\nconst char nl = '\\n';\nconst int MX = 500011; //check the limits, dummy\n \nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\nmi oneVal[MX];\nvoid precomp() {\n    oneVal[0] = 1;\n    oneVal[1] = 2;\n    FOR(i, 2, MX) {\n        oneVal[i] = 8 * oneVal[i-2] + 2 * oneVal[i-1];\n    }\n}\n\ninline mi val(int ones, int lst) {\n    mi res = (lst + 1) * oneVal[ones];\n    if (ones > 0) res += (9 - lst) * oneVal[ones-1];\n    return res;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    set<pi> blocks;\n    int ls = 0;\n    mi ans = 1;\n    precomp();\n    F0R(i, N) {\n        if (S[i] != '1' || i == N-1) {\n            blocks.ins({ls, i});\n            ans *= val(i - ls, S[i] - '0');\n            ls = i+1;\n        }\n    }\n\n    F0R(i, M) {\n        int X, D; cin >> X; X--; cin >> D;\n\n        auto it = blocks.ub({X, N+1});\n        it--;\n        pi block = *it;\n        if (D == 1) {\n            if (X == block.s) {\n                ans *= inv(val(block.s - block.f, S[block.s] - '0'));\n                pi newBlock = block;\n                it++;\n                if (it != blocks.end()) {\n                    pi block2 = *it;\n                    newBlock.s = block2.s;\n                    ans *= inv(val(block2.s - block2.f, S[block2.s] - '0'));\n                    blocks.erase(block2);\n                }\n                blocks.erase(block);\n                blocks.ins(newBlock);\n                S[X] = '0' + D;\n                ans *= val(newBlock.s - newBlock.f, S[newBlock.s]-'0');\n            }\n        } else {\n            ans *= inv(val(block.s - block.f, S[block.s] - '0'));\n            blocks.erase(block);\n            pi nb1 = {block.f, X};\n            blocks.ins(nb1);\n            ans *= val(X-block.f, D);\n            if (X != block.s) {\n                pi nb2 = {X+1, block.s};\n                blocks.ins(nb2);\n                ans *= val(block.s-X-1, S[block.s] - '0');\n            }\n        }\n\n        S[X] = '0' + D;\n        cout << ans << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "matrices"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Strange Addition.json",
    "editorial_link": "https://codeforces.com//blog/entry/80054",
    "editorial": "Let\u00e2\u0080\u0099s solve the task as if there are no updates. This can be done with a\r\npretty straightforward dp. is the number of pairs such that the result\r\nof the strange addition of and is the prefix of of length . . From each\r\nstate you can add a single digit to and to at the same time. You can\r\neither go to and multiply the answer by the number of pairs of digits\r\nthan sum up to . Or go to and multiply the answer by the number of pairs\r\nof digits than sum up to . Note that no pair of digits can sum up to a\r\nthree-digit value, so it makes no sense to go further.Let\u00e2\u0080\u0099s optimize\r\nthis dp with some data structure. Segment tree will work well. Let the\r\nnode store the number of ways to split the segment into blocks of size\r\nor so that: both the leftmost character and the rightmost character are\r\nnot taken into any block; the leftmost character is taken into some\r\nblock and the rightmost character is not taken into any block; the\r\nleftmost character is not taken into any block and the rightmost\r\ncharacter is taken into some block; both the leftmost and the rightmost\r\ncharacters are taken into some blocks. This structure makes the merge\r\npretty manageable. You should glue up the segments in such a way that\r\nall the middle characters are taken into some block: either in separate\r\nblocks in their own segments or into the same block of length .The\r\nanswer will be in the root of the tree in a value such that both\r\ncharacters are taken.The update in the segment tree will still work in\r\n.Overall complexity: .\r\n"
}