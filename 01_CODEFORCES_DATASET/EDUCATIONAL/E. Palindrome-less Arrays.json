{
    "link": "https://codeforces.com//contest/1140/problem/E",
    "problemId": "317588",
    "problem_idx": "E",
    "shortId": "1140E",
    "contest_number": "1140",
    "problem_submissions": {
        "G": [
            51711380,
            51715425,
            51701961,
            51723677,
            51713161,
            51826208,
            51725702,
            51751383,
            51751094,
            51871694
        ],
        "E": [
            51707475,
            51698157,
            51710451,
            51699057,
            51698619,
            51700718,
            51698345,
            51703686,
            51826592,
            51711304,
            51706757,
            51709505,
            51702992,
            51711975,
            51716308,
            51694918,
            51707265,
            51699848,
            51701075,
            51700169,
            51701450
        ],
        "F": [
            51700190,
            51704937,
            51708125,
            51707572,
            51715636,
            51713154,
            51709309,
            51745229,
            51724116,
            51717194,
            51826549,
            51704389,
            51714714,
            51719425,
            51719809,
            51889038,
            51888545,
            51716543,
            51712779,
            51717719,
            51719576,
            51772442,
            51734097,
            51801995,
            52594541,
            52594485
        ],
        "D": [
            51692897,
            51692552,
            51711200,
            51692355,
            51691890,
            51695018,
            51693289,
            51690531,
            51826633,
            51691126,
            51688766,
            51694582,
            51696697,
            51687330,
            51696460,
            51700363,
            51702095,
            51691157,
            51691573,
            51691854,
            51693356
        ],
        "C": [
            51691812,
            51690406,
            51711880,
            51691405,
            51690720,
            51691755,
            51691383,
            51689446,
            51826659,
            51690305,
            51696638,
            51692263,
            51691635,
            51692542,
            51695004,
            51699456,
            51696505,
            51690289,
            51689951,
            51689550,
            51688775
        ],
        "B": [
            51689841,
            51689192,
            51712746,
            51689822,
            51689241,
            51688933,
            51689569,
            51688189,
            51826766,
            51688939,
            51690552,
            51689048,
            51689939,
            51691885,
            51692884,
            51696524,
            51689978,
            51688514,
            51688185,
            51688344,
            51690712
        ],
        "A": [
            51687668,
            51687221,
            51713210,
            51688333,
            51687348,
            51687390,
            51687760,
            51687210,
            51826788,
            51687239,
            51687778,
            51687499,
            51688125,
            51688099,
            51687757,
            51687342,
            51688091,
            51687317,
            51687203,
            51687474,
            51687413
        ]
    },
    "name": "E. Palindrome-less Arrays",
    "statement": "Let\u2019s denote that some array b is if it contains a subarray b_l,\r\nb_{l+1},\r\ndots, b_{r} of odd length more than 1 (l < r and r - l + 1 is odd) such\r\nthat\r\nforall i\r\nin\r\n{0, 1,\r\ndots, r - l\r\n} b_{l + i} = b_{r - i}.If an array is not bad, it is .Now you are given\r\nan array a_1, a_2,\r\ndots, a_n. Some elements are replaced by -1. Calculate the number of\r\ngood arrays you can obtain by replacing each -1 with some integer from 1\r\nto k.Since the answer can be large, print it modulo 998244353.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst int N=500005,P=998244353;\nint n,k,a[N],b[N],m,f[N];\n\ninline void read(int &i){\n\ti=0;char c=getchar();bool j=0;\n\tfor(;!isdigit(c);c=getchar())if(c=='-')j=1;\n\tfor(;isdigit(c);c=getchar())i=(i<<1)+(i<<3)+c-'0';i=j?-i:i;\n}\ninline ll Pow(ll a,int b){ll c=1;for(;b;a=a*a%P,b>>=1)if(b&1)c=c*a%P;return c;}\n\ninline int F(int n,int c,int t){\n\tif(!c)return k*Pow(k-1,n-1)%P;\n\tif(c==1)return Pow(k-1,n);\n\tf[0]=1;\n\tint ans=0;\n\tfor(int i=1;i<=n;++i)f[i]=1ll*f[i-1]*(k-1)%P;\n\tfor(int i=n;i>=1;--i){\n\t\tif((n-i)&1)ans-=f[i];\n\t\telse ans+=f[i];\n\t\tans%=P;\n\t}\n\tif(ans<0)ans+=P;\n\tif(!t){\n\t\tans=Pow(k-1,n+1)-ans;\n\t\tif(ans<0)ans+=P;\n\t\tans=ans*Pow(k-1,P-2)%P;\n\t}\n\treturn ans;\n}\n\nint calc(){\n\tfor(int i=1;i<m;++i)if(b[i]>0&&b[i+1]>0&&b[i]==b[i+1])return 0;\n\tint as=1;\n\tfor(int i=1;i<=m;){\n\t\tint j=i;\n\t\tif(b[i]!=-1){i++;continue;}\n\t\twhile(j+1<=m&&b[j+1]==-1)j++;\n\t\tint c=0;\n\t\tif(i>1)c++;\n\t\tif(j<m)c++;\n\t\tas=1ll*as*F(j-i+1,c,b[i-1]==b[j+1])%P;\n\t\ti=j+1;\n\t}\n\treturn as;\n}\n\nint main(){\n\tread(n);read(k);\n\tfor(int i=1;i<=n;++i)read(a[i]);\n\tfor(int i=1;i<=n;i+=2)b[++m]=a[i];\n\tint ans=calc();\n\tm=0;\n\tfor(int i=2;i<=n;i+=2)b[++m]=a[i];\n\tans=1ll*ans*calc()%P;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Palindrome-less Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/66147",
    "editorial": "At first, \"array contains a palindromic subarray of length \" is\r\nequivalent to \"array contains a palindromic subarray of length \". So we\r\nneed to calculate number of arrays without palindromes of length . It\u00e2\u0080\u0099s\r\nequivalent to finding arrays where for all appropriate .Note, that and\r\nhave same parity, so all odd and all even positions in array are\r\nindependent, and answer is the product of the number of ways to choose\r\nnumbers for odd positions, and the number of ways to choose numbers for\r\neven positions.In terms of same parity our condition morphs to and we\r\nneed to calculate all ways to replace ()-s in such way that all pairs of\r\nconsecutive elements are different.To calculate it let\u00e2\u0080\u0099s look at\r\nsequences of consecutive ()-s. They will look like with ()-s, where and\r\nare positive (case where is empty can be considered as , case with empty\r\nis solved the same way).In the end we need to find a way to calculate\r\nthe number of those sequences. There are only two fundamental types of\r\nsequences: (same value from both ends) and (). Exact values of and don\u00e2\u0080\u0099t\r\nreally matter.Let\u00e2\u0080\u0099s find a way to calculate both values (name them and )\r\nfor consecutive ()-s in time. Base values: .Let\u00e2\u0080\u0099s try to choose value of\r\nin the middle of sequence: if , then we can split sequence in two\r\nsequences of length and and .If then just iterate over value of last ,\r\nthen and .Resulting complexity is .\r\n"
}