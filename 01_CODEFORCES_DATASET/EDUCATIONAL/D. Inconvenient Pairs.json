{
    "link": "https://codeforces.com//contest/1569/problem/D",
    "problemId": "1103182",
    "problem_idx": "D",
    "shortId": "1569D",
    "contest_number": "1569",
    "problem_submissions": {
        "F": [
            128266355,
            128271363,
            128276594,
            128274140,
            128277636,
            128276419,
            128239230,
            128386349,
            128320123
        ],
        "E": [
            128250268,
            128256767,
            128246439,
            128253452,
            128257933,
            128258504,
            128255293,
            128254536,
            128252116,
            128261192,
            128578023,
            128259291,
            128263798,
            128266969,
            128259594,
            128258410,
            128275140,
            128271709,
            128263862,
            128264259
        ],
        "D": [
            128235337,
            128235527,
            128231804,
            128235402,
            128242825,
            128262573,
            128235767,
            128236235,
            128236769,
            128233977,
            128578016,
            128240282,
            128241897,
            128232635,
            128238819,
            128243586,
            128233606,
            128230968,
            128243956,
            128245831
        ],
        "C": [
            128220989,
            128228983,
            128226656,
            128226748,
            128234279,
            128264995,
            128226270,
            128225854,
            128229844,
            128225694,
            128578004,
            128230030,
            128228479,
            128225884,
            128230468,
            128226610,
            128225551,
            128233122,
            128232240,
            128234418
        ],
        "B": [
            128217208,
            128223439,
            128220536,
            128221217,
            128228682,
            128267165,
            128220994,
            128220572,
            128221551,
            128221442,
            128577996,
            128221801,
            128220084,
            128221194,
            128224466,
            128232979,
            128220020,
            128224325,
            128224652,
            128224175
        ],
        "A": [
            128212769,
            128212941,
            128213029,
            128212974,
            128213857,
            128267874,
            128212779,
            128212821,
            128212915,
            128213233,
            128577977,
            128213929,
            128212944,
            128212794,
            128212959,
            128213921,
            128212839,
            128214062,
            128216496,
            128214843
        ]
    },
    "name": "D. Inconvenient Pairs",
    "statement": "There is a city that can be represented as a square grid with corner\r\npoints in (0, 0) and (10^6, 10^6).The city has n vertical and m\r\nhorizontal streets that goes across the whole city, i. e. the i-th\r\nvertical streets goes from (x_i, 0) to (x_i, 10^6) and the j-th\r\nhorizontal street goes from (0, y_j) to (10^6, y_j). All streets are\r\nbidirectional. Borders of the city are streets as well.There are k\r\npersons staying : the p-th person at point (x_p, y_p) (so either x_p\r\nequal to some x_i or y_p equal to some y_j, or both).Let\u2019s say that a\r\npair of persons form an if the shortest path from one person to another\r\ngoing only by streets is than the Manhattan distance between\r\nthem.Calculate the number of inconvenient pairs of persons (pairs (x, y)\r\nand (y, x) are the same pair).Let\u2019s recall that Manhattan distance\r\nbetween points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| + |y_1 - y_2|.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; \n\n\nvoid solve() {\n    int N, M, K; cin >> N >> M >> K;\n    set<int> st[2];\n    F0R(i, N) {\n        int X; cin >> X; st[0].ins(X);\n    }\n    F0R(i, M) {\n        int X; cin >> X; st[1].ins(X);\n    }\n\n    map<int, int> cnt[2];\n    map<pi, int> cnt2[2];\n    st[0].ins(-1); st[1].ins(-1);\n    F0R(i, K) {\n        int X, Y; cin >> X >> Y;\n        if (!st[0].count(X)) {\n            auto it = --(st[0].lb(X));\n            cnt[0][*it]++;\n            cnt2[0][{*it, Y}]++;\n        }\n        if (!st[1].count(Y)) {\n            auto it = --(st[1].lb(Y));\n            cnt[1][*it]++;\n            cnt2[1][{*it, X}]++;\n        }\n    }\n    ll ans = 0;\n    F0R(i, 2) {\n        trav(a, cnt[i]) {\n            ll cur = a.s; ans += cur * (cur - 1) / 2;\n            //dbg(i, a.f, a.s);\n        }\n        trav(a, cnt2[i]) {\n            ll cur = a.s; ans -= cur * (cur - 1) / 2;\n        }\n    }\n    cout << ans << nl;\n\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "implementation",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Inconvenient Pairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/94721",
    "editorial": "Firstly, let\u00e2\u0080\u0099s look at some point . Let\u00e2\u0080\u0099s find closest to it vertical\r\nand horizontal lines. We will name the closest vertical lines from left\r\nand right as and (and and as closest horizontal lines). So, and (we can\r\nalso note that either or ).Now, let\u00e2\u0080\u0099s note that if for some other point\r\neither or then to reach from we must go reach either or (or, or ), so\r\nthe shortest distance will be strictly greater than the Manhattan\r\ndistance. If neither nor , then we can show that it\u00e2\u0080\u0099s always possible to\r\nfind the shortest path equal to the Manhattan distance. As a result, for\r\neach point we should find the number of points such that and or . The\r\nexception here is when lies on the same line as , so we should not count\r\nsuch points.We can note that since either or there is no such point that\r\nand simultaneously, so we can calculate the pairs by and coordinates\r\nindependently.Let\u00e2\u0080\u0099s focus on coordinates (to calculate for coordinates,\r\nwe can just swap all coordinates). Let\u00e2\u0080\u0099s sort all points by coordinate.\r\nTo get rid of the case when points and lies on the same vertical street,\r\nwe can group them by coordinate and process by group (since we sorted by\r\n, groups are just segments). There are no problems with the case when\r\npoints lie on the same horizontal street, since then and there are no\r\nother with .If we store for each horizontal line the number of point\r\ninside the interval then, when we need for point calculate the number of\r\npoints with and , we can just ask for value assigned to , because and\r\nare consecutive elements in the array .So, we go through each group two\r\ntimes: first collecting answer, then updating values in appropriate -s.\r\nNote, that we can calculate and with binary search (using built-in\r\nfunctions).The resulting complexity is .\r\n"
}