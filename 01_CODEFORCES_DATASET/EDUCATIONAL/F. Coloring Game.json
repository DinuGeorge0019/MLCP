{
    "link": "https://codeforces.com//contest/1197/problem/F",
    "problemId": "376707",
    "problem_idx": "F",
    "shortId": "1197F",
    "contest_number": "1197",
    "problem_submissions": {
        "E": [
            57531154,
            57527419,
            57524743,
            57530013,
            57536981,
            57526074,
            57537246,
            57517565,
            57532671,
            57531296,
            57535739,
            57533494,
            57533139,
            57532015,
            57531974,
            57534465,
            57537214,
            57536595,
            57532983,
            57537941
        ],
        "F": [
            57526205,
            57536510,
            57543227,
            57542356,
            57545070,
            57550429,
            57543354,
            57546681,
            57528127,
            57549295,
            57552678,
            57550308,
            57548615,
            57551319,
            57581907,
            57549488,
            57548121,
            57552168,
            57768625,
            57596008
        ],
        "D": [
            57517769,
            57521167,
            57531349,
            57521225,
            57523524,
            57536466,
            57530751,
            57531287,
            57521039,
            57522693,
            57521081,
            57524029,
            57524614,
            57523599,
            57524677,
            65550218,
            65550195,
            57524514,
            57523363,
            57524805,
            57525867,
            57524276
        ],
        "C": [
            57514645,
            57521161,
            57515560,
            57517240,
            57519467,
            57517149,
            57517926,
            57531832,
            57516648,
            57519324,
            57516744,
            57516779,
            57517866,
            57515185,
            57519335,
            57518781,
            57516998,
            57518983,
            57516506,
            57517063
        ],
        "B": [
            57513686,
            57521152,
            57513883,
            57515172,
            57516705,
            57515562,
            57515187,
            57532696,
            57515047,
            57517088,
            57514854,
            57515032,
            57514991,
            57513966,
            57514537,
            57515780,
            57514347,
            57514964,
            57514669,
            57515319
        ],
        "A": [
            57513085,
            57521143,
            57513101,
            57513203,
            57513756,
            57513671,
            57513230,
            57532141,
            57513274,
            57513512,
            57513153,
            57513271,
            57513173,
            57513091,
            57513126,
            57513220,
            57513223,
            57513310,
            57513141,
            57513251
        ]
    },
    "name": "F. Coloring Game",
    "statement": "Alice and Bob want to play a game. They have n colored paper strips; the\r\ni-th strip is divided into a_i cells numbered from 1 to a_i. Each cell\r\ncan have one of 3 colors.In the beginning of the game, Alice and Bob put\r\nn chips, the i-th chip is put in the a_i-th cell of the i-th strip. Then\r\nthey take turns, Alice is first. Each player during their turn has to\r\nchoose one chip and move it 1, 2 or 3 cells backwards (i. e. if the\r\ncurrent cell is x, then the chip can be moved to the cell x - 1, x - 2\r\nor x - 3). There are two restrictions: the chip cannot leave the borders\r\nof the strip (for example, if the current cell is 3, then you can’t move\r\nthe chip 3 cells backwards); and some moves may be prohibited because of\r\ncolor of the current cell (a matrix f with size 3\r\ntimes 3 is given, where f_{i, j} = 1 if it is possible to move the chip\r\nj cells backwards from the cell which has color i, or f_{i, j} = 0 if\r\nsuch move is prohibited). The player who cannot make a move loses the\r\ngame.Initially some cells may be uncolored. Bob can color all uncolored\r\ncells as he wants (but he cannot leave any cell uncolored). Let’s call a\r\ncoloring if Bob can win the game no matter how Alice acts, if the cells\r\nare colored according to this coloring. Two colorings are different if\r\nat least one cell is colored in different colors in these two\r\ncolorings.Bob wants you to calculate the number of good colorings. Can\r\nyou do it for him?Since the answer can be really large, you have to\r\nprint it modulo 998244353.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = 998244353;\nconst ll M2 = MOD * MOD;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x > 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 1010;\nconst int S = 64;\nconst int LOG = 32;\nll A[LOG + 3][S + 1][S + 1];\nint f[3][3];\nll w[2][S + 1];\nll dp[2][4];\nint n;\nint sz[N];\nvector<pii> a[N];\n\nvoid read() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &sz[i]);\n\t\ta[i].push_back(mp(0, -1));\n\t\ta[i].push_back(mp(sz[i] + 1, -1));\n\t}\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y, c;\n\t\tscanf(\"%d%d%d\", &x, &y, &c);\n\t\tx--;c--;\n\t\ta[x].push_back(mp(y, c));\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t}\n\tfor (int i = 0; i < n; i++)\n\t\tsort(a[i].begin(), a[i].end());\n\tfor (int c = 0; c < 3; c++) {\n\t\tfor (int x = 0; x < 4; x++)\n\t\t\tfor (int y = 0; y < 4; y++) \n\t\t\t\tfor (int z = 0; z < 4; z++) {\n\t\t\t\t\tint v = 16 * x + 4 * y + z;\n\t\t\t\t\tint r = 0;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tif (r == x && f[c][2] == 1) {\n\t\t\t\t\t\t\tr++; continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r == y && f[c][1] == 1) {\n\t\t\t\t\t\t\tr++; continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r == z && f[c][0] == 1) {\n\t\t\t\t\t\t\tr++; continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tr += 16 * y + 4 * z;\n\t\t\t\t\tA[LOG + c][v][r]++;\n\t\t\t\t}\n\t\tfor (int i = 0; i < S; i++)\n\t\t\tfor (int j = 0; j < S; j++)\n\t\t\t\tA[0][i][j] += A[LOG + c][i][j];\n\t}\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int i = 0; i < S; i++)\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tA[k + 1][i][j] = 0;\n\t\t\t\tfor (int h = 0; h < S; h++) {\n\t\t\t\t\tA[k + 1][i][j] += A[k][i][h] * A[k][h][j];\n\t\t\t\t\tif (A[k + 1][i][j] >= M2) A[k + 1][i][j] -= M2;\n\t\t\t\t}\n\t\t\t\tA[k + 1][i][j] %= MOD;\n\t\t\t}\n}\n\nvoid apply(int id) {\n\tfor (int i = 0; i < S; i++) {\n\t\tw[1][i] = 0;\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tw[1][i] += w[0][j] * A[id][j][i];\n\t\t\tif (w[1][i] >= M2) w[1][i] -= M2;\n\t\t}\n\t\tw[1][i] %= MOD;\n\t}\n\tfor (int i = 0; i < S; i++)\n\t\tw[0][i] = w[1][i];\n}\n\nvoid bin_pow(int p) {\n\tfor (int k = 0; k < LOG; k++)\n\t\tif ((p >> k) & 1)\n\t\t\tapply(k);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tread();\n\tdp[0][0] = 1;\n\tfor (int id = 0; id < n; id++) {\n\t\tfor (int i = 0; i < S; i++)\n\t\t\tw[0][i] = 0;\n\t\tw[0][S - 1] = 1;\n\t\tfor (int i = 0; i < (int)a[id].size() - 1; i++) {\n\t\t\tbin_pow(a[id][i + 1].first - a[id][i].first - 1);\n\t\t\tif (i != (int)a[id].size() - 2)\n\t\t\t\tapply(LOG + a[id][i + 1].second);\n\t\t}\n\t\tll z[4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tz[i] = 0;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = i; j < S; j += 4)\n\t\t\t\tz[i] = add(z[i], w[0][j]);\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tdp[1][i] = 0;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tdp[1][i ^ j] = add(dp[1][i ^ j], mult(dp[0][i], z[j]));\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tdp[0][i] = dp[1][i];\n\t}\n\tprintf(\"%lld\\n\", dp[0][0]);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "games",
        "matrices"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Coloring Game.json",
    "editorial_link": "https://codeforces.com/blog/entry/68615",
    "editorial": "Suppose there is only one strip and we want to count the number of ways\r\nto paint it. We can do it with some dynamic programming: let be the\r\nnumber of ways to paint first cells of the strip so that denotes the\r\nresult of the game if it starts in the last cell ( if the player that\r\nmakes a turn from this state loses, or if he wins), the result if the\r\ngame starts in the second-to-last, and so on. Then, if we paint the next\r\ncell, we can easily determine the result of the game starting in it,\r\nusing the values of and the set of possible moves: if there is a value\r\nsuch that we can move the chip cells backwards from the cell we just\r\npainted, then that cell is a winning one (if the game starts in it, the\r\nfirst player wins), otherwise it is a losing one.This dynamic\r\nprogramming works too slow since the strip can be very long, but we can\r\nskip long uncolored segments converting the transitions of this dp into\r\nmatrix-vector multiplication: each possible combination of values of (,\r\n, ) can be encoded as a number from to , and we may construct a\r\ntransition matrix : will be equal to the number of ways to color one\r\ncell so that the previous values of (, , ) have code , and the next\r\nvalues have code . To model painting consecutive uncolored segments, we\r\nmay compute with fast exponentiation method. Now we can solve the\r\nproblem for one strip.What changes if we try to apply the same method to\r\nsolve the problem with many strips? Unfortunately, we canât analyze each\r\ncell as \"winning\" or \"losing\" now, we need more information. When\r\nsolving a problem related to a combination of acyclic games, we may use\r\nSprague-Grundy theory (you can read about it here:\r\nhttps://cp-algorithms.com/game_theory/sprague-grundy-nim.html). Instead\r\nof marking each cell as \"winning\" or \"losing\", we can analyze the Grundy\r\nvalue of each cell. When considering a strip, we should count the number\r\nof ways to color it so that its Grundy is exactly (we should do it for\r\nevery possible value of ), which can help us to solve the initial\r\nproblem with the following dynamic programming: is the number of ways to\r\ncolor first strips so that the Grundy value of their combination is\r\nexactly .The only thing thatâs left to consider is how do we count the\r\nnumber of ways to color a single strip so that its Grundy value is\r\nfixed. We can to it by modifying the method described in the first\r\nparagraph: let be the number of ways to paint first cells so that the\r\nGrundy value of the last cell is , the value of the previous-to-last\r\ncell is , and so on. Since we have only possible moves, the Grundy\r\nvalues are limited to , and each possible combination of values of (, ,\r\n) can be encoded as a number from to . The transition matrix that allows\r\nus to skip long uncolored segments will be a one, so if we will just\r\nexponentiate it every time we want to skip a segment, weâll get TL but\r\nwe can optimize it by precalculating , , , ..., and using matrix-vector\r\nmultiplication instead of matrix-matrix multiplication every time we\r\nskip an uncolored segment.\r\n",
    "hint": []
}