{"link": "https://codeforces.com//contest/1197/problem/F", "problemId": "376707", "problem_idx": "F", "shortId": "1197F", "contest_number": "1197", "problem_submissions": {"E": [57531154, 57527419, 57524743, 57530013, 57536981, 57526074, 57537246, 57517565, 57532671, 57531296, 57535739, 57533494, 57533139, 57532015, 57531974, 57534465, 57537214, 57536595, 57532983, 57537941], "F": [57526205, 57536510, 57543227, 57542356, 57545070, 57550429, 57543354, 57546681, 57528127, 57549295, 57552678, 57550308, 57548615, 57551319, 57581907, 57549488, 57548121, 57552168, 57768625, 57596008], "D": [57517769, 57521167, 57531349, 57521225, 57523524, 57536466, 57530751, 57531287, 57521039, 57522693, 57521081, 57524029, 57524614, 57523599, 57524677, 65550218, 65550195, 57524514, 57523363, 57524805, 57525867, 57524276], "C": [57514645, 57521161, 57515560, 57517240, 57519467, 57517149, 57517926, 57531832, 57516648, 57519324, 57516744, 57516779, 57517866, 57515185, 57519335, 57518781, 57516998, 57518983, 57516506, 57517063], "B": [57513686, 57521152, 57513883, 57515172, 57516705, 57515562, 57515187, 57532696, 57515047, 57517088, 57514854, 57515032, 57514991, 57513966, 57514537, 57515780, 57514347, 57514964, 57514669, 57515319], "A": [57513085, 57521143, 57513101, 57513203, 57513756, 57513671, 57513230, 57532141, 57513274, 57513512, 57513153, 57513271, 57513173, 57513091, 57513126, 57513220, 57513223, 57513310, 57513141, 57513251]}, "name": "F. Coloring Game", "statement": "Alice and Bob want to play a game. They have n colored paper strips; the\r\ni-th strip is divided into a_i cells numbered from 1 to a_i. Each cell\r\ncan have one of 3 colors.In the beginning of the game, Alice and Bob put\r\nn chips, the i-th chip is put in the a_i-th cell of the i-th strip. Then\r\nthey take turns, Alice is first. Each player during their turn has to\r\nchoose one chip and move it 1, 2 or 3 cells backwards (i. e. if the\r\ncurrent cell is x, then the chip can be moved to the cell x - 1, x - 2\r\nor x - 3). There are two restrictions: the chip cannot leave the borders\r\nof the strip (for example, if the current cell is 3, then you can\u2019t move\r\nthe chip 3 cells backwards); and some moves may be prohibited because of\r\ncolor of the current cell (a matrix f with size 3\r\ntimes 3 is given, where f_{i, j} = 1 if it is possible to move the chip\r\nj cells backwards from the cell which has color i, or f_{i, j} = 0 if\r\nsuch move is prohibited). The player who cannot make a move loses the\r\ngame.Initially some cells may be uncolored. Bob can color all uncolored\r\ncells as he wants (but he cannot leave any cell uncolored). Let\u2019s call a\r\ncoloring if Bob can win the game no matter how Alice acts, if the cells\r\nare colored according to this coloring. Two colorings are different if\r\nat least one cell is colored in different colors in these two\r\ncolorings.Bob wants you to calculate the number of good colorings. Can\r\nyou do it for him?Since the answer can be really large, you have to\r\nprint it modulo 998244353.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = 998244353;\nconst ll M2 = MOD * MOD;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x > 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 1010;\nconst int S = 64;\nconst int LOG = 32;\nll A[LOG + 3][S + 1][S + 1];\nint f[3][3];\nll w[2][S + 1];\nll dp[2][4];\nint n;\nint sz[N];\nvector<pii> a[N];\n\nvoid read() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", &sz[i]);\n\t\ta[i].push_back(mp(0, -1));\n\t\ta[i].push_back(mp(sz[i] + 1, -1));\n\t}\n\tint m;\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x, y, c;\n\t\tscanf(\"%d%d%d\", &x, &y, &c);\n\t\tx--;c--;\n\t\ta[x].push_back(mp(y, c));\n\t}\n\tfor (int i = 0; i < 3; i++)\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tscanf(\"%d\", &f[i][j]);\n\t\t}\n\tfor (int i = 0; i < n; i++)\n\t\tsort(a[i].begin(), a[i].end());\n\tfor (int c = 0; c < 3; c++) {\n\t\tfor (int x = 0; x < 4; x++)\n\t\t\tfor (int y = 0; y < 4; y++) \n\t\t\t\tfor (int z = 0; z < 4; z++) {\n\t\t\t\t\tint v = 16 * x + 4 * y + z;\n\t\t\t\t\tint r = 0;\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tif (r == x && f[c][2] == 1) {\n\t\t\t\t\t\t\tr++; continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r == y && f[c][1] == 1) {\n\t\t\t\t\t\t\tr++; continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (r == z && f[c][0] == 1) {\n\t\t\t\t\t\t\tr++; continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tr += 16 * y + 4 * z;\n\t\t\t\t\tA[LOG + c][v][r]++;\n\t\t\t\t}\n\t\tfor (int i = 0; i < S; i++)\n\t\t\tfor (int j = 0; j < S; j++)\n\t\t\t\tA[0][i][j] += A[LOG + c][i][j];\n\t}\n\tfor (int k = 0; k < LOG - 1; k++)\n\t\tfor (int i = 0; i < S; i++)\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tA[k + 1][i][j] = 0;\n\t\t\t\tfor (int h = 0; h < S; h++) {\n\t\t\t\t\tA[k + 1][i][j] += A[k][i][h] * A[k][h][j];\n\t\t\t\t\tif (A[k + 1][i][j] >= M2) A[k + 1][i][j] -= M2;\n\t\t\t\t}\n\t\t\t\tA[k + 1][i][j] %= MOD;\n\t\t\t}\n}\n\nvoid apply(int id) {\n\tfor (int i = 0; i < S; i++) {\n\t\tw[1][i] = 0;\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tw[1][i] += w[0][j] * A[id][j][i];\n\t\t\tif (w[1][i] >= M2) w[1][i] -= M2;\n\t\t}\n\t\tw[1][i] %= MOD;\n\t}\n\tfor (int i = 0; i < S; i++)\n\t\tw[0][i] = w[1][i];\n}\n\nvoid bin_pow(int p) {\n\tfor (int k = 0; k < LOG; k++)\n\t\tif ((p >> k) & 1)\n\t\t\tapply(k);\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tread();\n\tdp[0][0] = 1;\n\tfor (int id = 0; id < n; id++) {\n\t\tfor (int i = 0; i < S; i++)\n\t\t\tw[0][i] = 0;\n\t\tw[0][S - 1] = 1;\n\t\tfor (int i = 0; i < (int)a[id].size() - 1; i++) {\n\t\t\tbin_pow(a[id][i + 1].first - a[id][i].first - 1);\n\t\t\tif (i != (int)a[id].size() - 2)\n\t\t\t\tapply(LOG + a[id][i + 1].second);\n\t\t}\n\t\tll z[4];\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tz[i] = 0;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = i; j < S; j += 4)\n\t\t\t\tz[i] = add(z[i], w[0][j]);\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tdp[1][i] = 0;\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tfor (int j = 0; j < 4; j++)\n\t\t\t\tdp[1][i ^ j] = add(dp[1][i ^ j], mult(dp[0][i], z[j]));\n\t\tfor (int i = 0; i < 4; i++)\n\t\t\tdp[0][i] = dp[1][i];\n\t}\n\tprintf(\"%lld\\n\", dp[0][0]);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["dp", "games", "matrices"], "dificulty": "2700", "interactive": false}