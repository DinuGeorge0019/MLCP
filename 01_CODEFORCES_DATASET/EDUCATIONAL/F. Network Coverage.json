{
    "link": "https://codeforces.com//contest/1373/problem/F",
    "problemId": "657375",
    "problem_idx": "F",
    "shortId": "1373F",
    "contest_number": "1373",
    "problem_submissions": {
        "F": [
            85069466,
            85013919,
            85003216,
            85004527,
            85017380,
            85006414,
            85013443,
            85009359,
            85034855,
            85024344,
            85027318,
            85021209,
            85169119,
            85034898,
            85023023,
            85025050,
            85021057,
            85011972,
            85013310,
            85009397,
            85086450,
            85048971,
            85105442,
            85026023,
            85034574
        ],
        "G": [
            85018688,
            85013794,
            85023274,
            85029274,
            85027188,
            85026875,
            85025205,
            85031642,
            85033493,
            85060324,
            85029140,
            85035646,
            85035445,
            85030303,
            85169123,
            85031978,
            85034028,
            85038006,
            85044469,
            85037568,
            85029439,
            85040658,
            85105410,
            85055846,
            85052926,
            85051925,
            85051272,
            85044699
        ],
        "E": [
            84999770,
            85000250,
            85000769,
            85016220,
            85003055,
            85022007,
            85003196,
            85014929,
            85009060,
            85051465,
            85015459,
            85015122,
            85013600,
            85169037,
            85015655,
            85012581,
            85027850,
            85004717,
            85029830,
            85050882,
            85062787,
            85017522,
            85010450,
            85023419
        ],
        "D": [
            84989194,
            84988897,
            84987666,
            84989409,
            84993779,
            84995810,
            84995168,
            84988737,
            84989555,
            84996435,
            84994778,
            85169112,
            84993838,
            84996979,
            84999087,
            84988720,
            84993282,
            84997221,
            84991423,
            84994984,
            85005381
        ],
        "C": [
            84985114,
            84983803,
            84984904,
            84985027,
            84987964,
            84987787,
            84988785,
            84985367,
            84985891,
            84989713,
            84990559,
            85169107,
            84990269,
            84988468,
            84994211,
            84985714,
            84988231,
            84989967,
            84987837,
            84989263,
            84994345
        ],
        "B": [
            84983530,
            84983359,
            84983895,
            84983713,
            84984272,
            84984923,
            84984729,
            84983954,
            84983931,
            84986620,
            85051946,
            84984732,
            85169102,
            84984725,
            84984153,
            84984773,
            84984191,
            84984894,
            84984839,
            84984490,
            84985320,
            84987225
        ],
        "A": [
            84983369,
            84984629,
            84983633,
            84983428,
            84983600,
            84983500,
            84983426,
            84983406,
            84983552,
            84983668,
            84986837,
            85168973,
            84983414,
            84983504,
            84983712,
            85163611,
            84983517,
            84983932,
            84983627,
            84984784,
            84983882,
            84985111
        ]
    },
    "name": "F. Network Coverage",
    "statement": "The government of Berland decided to improve network coverage in his\r\ncountry. Berland has a unique structure: the capital in the center and n\r\ncities around the capital. The capital already has a good network\r\ncoverage (so the government ignores it), but the i-th city contains a_i\r\nhouseholds that require a connection.The government designed a plan to\r\nbuild n network stations between all pairs of neighboring cities which\r\nwill maintain connections only for these cities. In other words, the\r\ni-th network station will provide service only for the i-th and the (i +\r\n1)-th city (the n-th station is connected to the n-th and the 1-st\r\ncity).All network stations have capacities: the i-th station can provide\r\nthe connection to at most b_i households.Now the government asks you to\r\ncheck can the designed stations meet the needs of all cities or not that\r\nis, is it possible to assign each household a network station so that\r\neach network station i provides the connection to at most b_i\r\nhouseholds.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n    int T; cin >> T;\n    while(T--) {\n        int N; cin >> N;\n        int A[N], B[N]; F0R(i, N) cin >> A[i];\n        F0R(i, N) cin >> B[i];\n\n        int S = 0;\n        int last = B[0];\n        FOR(i, 1, 2*N+5) {\n            int cur = B[(i+N-1)%N] - last;\n            last = A[i%N] - cur;\n            ckmax(last, 0);\n//            cout << cur << \" \" << last << nl;\n            if (last > B[i%N]) {\n                S = i;\n                last = B[i%N];\n//                cout << \"S \" << S << nl;\n            }\n        }\n\n        if (S < N) {\n            cout << \"YES\" << nl;\n        } else {\n            cout << \"NO\" << nl;\n        }\n\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Network Coverage.json",
    "editorial_link": "https://codeforces.com//blog/entry/79376",
    "editorial": "There are plenty of different solutions to this problem. Here is one\r\nthat doesn\u00e2\u0080\u0099t use Hall\u00e2\u0080\u0099s theorem.Let\u00e2\u0080\u0099s look at pair as fuction : how many\r\nconnections will be left for the -th city if we take connections from\r\nthe -th station. This function has the following structure: there is a\r\nminimum required (let\u00e2\u0080\u0099s name it ) to meet the needs of the -th city and\r\nwith borrowed connections there will be free connections to the -th\r\ncity. Increasing by some we can get free connections, but there is upper\r\nbound to number of free connections . In other words, the function where\r\n.For example, let\u00e2\u0080\u0099s calculate the corresponding coefficients for the -th\r\nfunction: if then , and ; if then , and . Why did we define such\r\nfunctions? If we can calculate result function then we can check the\r\npossibility of meeting all needs by checking that this fuction exists\r\nand , i. e. the minimum free can be used as borrowed .Fortunately, it\r\nturns out that the superposition is either don\u00e2\u0080\u0099t exists (if, for\r\nexample, ) or it has the same structure as any function . So we can\r\ncalculate in one pass and find the answer.We will skip the detailed\r\nformulas to calculate : you can either find them by yourself or look at\r\nfunction in author\u00e2\u0080\u0099s solution.The resulting complexity is .\r\n"
}