{"link": "https://codeforces.com//contest/1574/problem/F", "problemId": "1115679", "problem_idx": "F", "shortId": "1574F", "contest_number": "1574", "problem_submissions": {"F": [129371777, 129390921, 129389731, 129403988, 129393793, 129405865, 129397624, 129402611, 129407592, 129402025, 129406898, 129404634, 129404840, 129396171, 129404379, 129428143, 129709936], "E": [129358674, 129374904, 129374765, 129380449, 129384709, 129384504, 129386221, 129385268, 129386371, 129386001, 129382985, 129391466, 129400354, 129386981, 129377485, 129381385, 129368975, 129386322, 131512763, 129380209, 129375216], "D": [129351289, 129361598, 129356978, 129361351, 129369248, 129359850, 129368999, 129364465, 129359499, 129374264, 129364919, 129372422, 129366912, 129361472, 129361829, 129360363, 129358818, 129366595, 129366262, 129357077], "C": [129345085, 129349632, 129348099, 129350669, 129350365, 129350502, 129357353, 129349080, 129351966, 129349226, 129354359, 129353753, 129347195, 129407614, 129351570, 129352219, 129351381, 129349196, 129351680, 129362666], "B": [129342942, 129343801, 129344237, 129345556, 129343553, 129345572, 129345752, 129344787, 129345774, 129343483, 129344471, 129343826, 129343420, 129410456, 129346117, 129346262, 129343905, 129345607, 129345689, 129346070], "A": [129341973, 129342397, 129341943, 129342408, 129341991, 129342232, 129342087, 129342285, 129343124, 129342143, 129342078, 129341990, 129341904, 129411806, 129343011, 129342282, 129341912, 129342040, 129342183, 129341989]}, "name": "F. Occurrences", "statement": "A subarray of array a from index l to the index r is the array [a_l,\r\na_{l+1},\r\ndots, a_{r}]. The number of occurrences of the array b in the array a is\r\nthe number of subarrays of a such that they are equal to b.You are given\r\nn arrays A_1, A_2,\r\ndots, A_n; the elements of these arrays are integers from 1 to k. You\r\nhave to build an array a consisting of m integers from 1 to k in such a\r\nway that, for given subarray A_i, the number of occurrences of A_i in\r\nthe array a is than the number of occurrences of each non-empty subarray\r\nof A_i in a. Note that if A_i doesn\u2019t occur in a, and no subarray of A_i\r\noccurs in a, this condition is still met for A_i.Your task is to\r\ncalculate the number of different arrays a you can build, and print it\r\nmodulo 998244353.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 20.09.2021 18:07:08       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> g(k);\n  vector<vector<int>> gr(k);\n  for (int i = 0; i < n; i++) {\n    int len;\n    cin >> len;\n    int last;\n    cin >> last;\n    --last;\n    for (int j = 1; j < len; j++) {\n      int cur;\n      cin >> cur;\n      --cur;\n      g[last].push_back(cur);\n      gr[cur].push_back(last);\n      last = cur;\n    }\n  }\n  for (int i = 0; i < k; i++) {\n    sort(g[i].begin(), g[i].end());\n    g[i].resize(unique(g[i].begin(), g[i].end()) - g[i].begin());\n    sort(gr[i].begin(), gr[i].end());\n    gr[i].resize(unique(gr[i].begin(), gr[i].end()) - gr[i].begin());\n  }\n  map<int, int> mp;\n  vector<bool> was(k, false);\n  vector<bool> used(k, false);\n  for (int start = 0; start < k; start++) {\n    if (was[start]) {\n      continue;\n    }\n    vector<int> que(1, start);\n    was[start] = true;\n    for (int b = 0; b < (int) que.size(); b++) {\n      for (int j : g[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n      for (int j : gr[que[b]]) {\n        if (!was[j]) {\n          que.push_back(j);\n          was[j] = true;\n        }\n      }\n    }\n    int edges = 0;\n    for (int i : que) {\n      edges += (int) g[i].size();\n    }\n    if (edges != (int) que.size() - 1) {\n      continue;\n    }\n    int root = -1;\n    for (int i : que) {\n      if (gr[i].empty()) {\n        root = i;\n        break;\n      }\n    }\n    assert(root != -1);\n    vector<int> seq(1, root);\n    used[root] = true;\n    while (true) {\n      int nxt = -1;\n      for (int i : g[seq.back()]) {\n        if (!used[i]) {\n          nxt = i;\n          break;\n        }\n      }\n      if (nxt == -1) {\n        break;\n      }\n      seq.push_back(nxt);\n      used[nxt] = true;\n    }\n    if (seq.size() == que.size()) {\n      mp[(int) seq.size()] += 1;\n    }\n  }\n  vector<pair<int, int>> ps;\n  for (auto& p : mp) {\n    ps.push_back(p);\n  }\n  vector<Mint> dp(m + 1);\n  dp[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    for (auto& p : ps) {\n      if (i >= p.first) {\n        dp[i] += dp[i - p.first] * p.second;\n      }\n    }\n  }\n  cout << dp[m] << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dfs and similar", "dp", "dsu", "fft", "graphs"], "dificulty": "2700", "interactive": false}