{
    "link": "https://codeforces.com//contest/1221/problem/D",
    "problemId": "415610",
    "problem_idx": "D",
    "shortId": "1221D",
    "contest_number": "1221",
    "problem_submissions": {
        "G": [
            60878901,
            60954325,
            60892510,
            60889777,
            60939440,
            60957169,
            60954037,
            60954018,
            60887759,
            60892512,
            61066187,
            60888304,
            60953665,
            60884074
        ],
        "F": [
            60872429,
            60906430,
            60877026,
            60879328,
            60873795,
            60880496,
            60880041,
            60882317,
            60876205,
            60881638,
            60879016,
            60884701,
            60883109,
            60876230,
            60885368,
            60884882,
            60888631,
            60877275
        ],
        "E": [
            60865427,
            60906424,
            60870455,
            60872355,
            60881944,
            60867813,
            60873346,
            60871774,
            60882236,
            60957159,
            60869840,
            60865430,
            60870324,
            60874697,
            60871945,
            60886034,
            60875073,
            60873664,
            60883200,
            60875153,
            60886105,
            60887173
        ],
        "D": [
            60858978,
            60906413,
            60858963,
            60862133,
            60857697,
            60858483,
            60858390,
            60860167,
            60862000,
            60957149,
            60859058,
            60857548,
            60865511,
            60860504,
            60857388,
            60865183,
            60887076,
            60866989,
            60863673,
            60861492,
            60857971,
            60867806,
            60885376
        ],
        "C": [
            60854799,
            60906405,
            60854087,
            60858148,
            60855694,
            60855339,
            60856078,
            60857408,
            60859538,
            60957138,
            60855511,
            60854166,
            60860646,
            60858018,
            60854647,
            60856215,
            60857135,
            60857947,
            60855000,
            60855230,
            60864597,
            60884317
        ],
        "B": [
            60853702,
            60906395,
            60853284,
            60856858,
            60853405,
            60869020,
            60854977,
            60855791,
            60854474,
            60957129,
            60854297,
            60853117,
            60859658,
            60856090,
            60853528,
            60854286,
            60855985,
            60856982,
            60854601,
            60853843,
            60862970,
            60883738
        ],
        "A": [
            60853175,
            60906382,
            60852746,
            60855419,
            60852846,
            60852969,
            60852978,
            60853994,
            60853299,
            60957119,
            60852836,
            60852764,
            60858768,
            60853799,
            60852813,
            60853187,
            60854280,
            60853549,
            60853275,
            60852850,
            60861325,
            60883303
        ]
    },
    "name": "D. Make The Fence Great Again",
    "statement": "You have a fence consisting of n vertical boards. The width of each\r\nboard is 1. The height of the i-th board is a_i. You think that the\r\nfence is if there is no pair of adjacent boards having the same height.\r\nMore formally, the fence is great if and only if for all indices from 2\r\nto n, the condition a_{i-1}\r\nneq a_i holds.Unfortunately, it is possible that now your fence is not\r\ngreat. But you can change it! You can increase the length of the i-th\r\nboard by 1, but you have to pay b_i rubles for it. The length of each\r\nboard can be increased any number of times (possibly, zero).Calculate\r\nthe minimum number of rubles you have to spend to make the fence great\r\nagain!You have to answer q independent queries.\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 3 * (int)1e5 + 100;\nint n;\nll a[maxN], b[maxN];\nconst int BUBEN = 4;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int q;\n    cin >> q;\n    while (q--) {\n        cin >> n;\n        for (int i = 1; i <= n; i++) {\n            cin >> a[i] >> b[i];\n        }\n        vector < pair < ll, ll > > best;\n        for (int i = 0; i <= BUBEN; i++) {\n            best.emplace_back(b[1] * i, a[1] + i);\n        }\n        for (int i = 2; i <= n; i++) {\n            vector < pair < ll, ll > > nbest;\n            for (int j = 0; j <= BUBEN; j++) {\n                ll mn = 2e18;\n                for (auto it : best) {\n                    if (it.second != a[i] + j) mn = min(mn, it.first);\n                }\n                mn += j * b[i];\n                nbest.emplace_back(mn, a[i] + j);\n            }\n            best = nbest;\n        }\n        ll mn = 2e18;\n        for (auto it : best) mn = min(mn, it.first);\n        cout << mn << '\\n';\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Make The Fence Great Again.json",
    "editorial_link": "https://codeforces.com//blog/entry/69925",
    "editorial": "Letâs notice that in optimal answer all boards will be increased by no\r\nmore than two. It is true because if it is beneficial to increase the\r\nlength of some board by three or more (denote its length as ) then\r\nincreasing to the length , or is cheaper and one of these boards is not\r\nequal to any of its adjacent boards.Noticing this, we can write a\r\nsolution based on dynamic programming. Letâs is minimum amount of money\r\nfor making fence great, moreover the last board(with index ) we increase\r\nby . Then value can be calculated as follows:\r\n",
    "hint": []
}