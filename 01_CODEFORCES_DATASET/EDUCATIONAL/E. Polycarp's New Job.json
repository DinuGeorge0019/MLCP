{
    "link": "https://codeforces.com//contest/1101/problem/E",
    "problemId": "281058",
    "problem_idx": "E",
    "shortId": "1101E",
    "contest_number": "1101",
    "problem_submissions": {
        "G": [
            48239479,
            48229345,
            48232833,
            48236005,
            48238584,
            48237077,
            48239817,
            48236726,
            48424442,
            48241897,
            48244236,
            48246271,
            48243763,
            48241853,
            48248346,
            48243669,
            48239804,
            48232428,
            48236056,
            48233716
        ],
        "F": [
            48234729,
            48238339,
            48245658,
            48241971,
            48243102,
            48243980,
            48248208,
            48253790,
            48249237,
            48251881,
            48251772,
            48254209,
            48250740,
            48252733,
            48257301,
            48253052,
            48236429,
            48245061,
            48242715,
            48241926,
            48292686,
            48258183
        ],
        "E": [
            48227685,
            48224274,
            48222676,
            48226514,
            48225235,
            48225759,
            48224993,
            48229382,
            48234805,
            48231496,
            48237158,
            48276590,
            48233129,
            48237913,
            48231111,
            48230324,
            48226575,
            48224137,
            48222074,
            48228244,
            48223937
        ],
        "D": [
            48225904,
            132803821,
            132802920,
            48232171,
            48230596,
            48230036,
            48246912,
            48230700,
            48231186,
            48232249,
            48228292,
            48232968,
            48229870,
            48235723,
            48238573,
            48253038,
            48236119,
            48237471,
            48242160,
            48224926,
            48233664,
            48227806,
            48238739,
            48236228
        ],
        "C": [
            48220755,
            48221737,
            48220938,
            48222851,
            48222128,
            48224023,
            48222001,
            48221817,
            48228289,
            48227053,
            48229439,
            48222389,
            48224672,
            48228555,
            48228217,
            48221108,
            48222667,
            48220453,
            48229806,
            48227541
        ],
        "B": [
            48218348,
            48218521,
            48218025,
            48219067,
            48219419,
            48219511,
            48219183,
            48218594,
            48221174,
            48217036,
            48221983,
            48224393,
            48219257,
            48217297,
            48224770,
            48217931,
            48218900,
            50490666,
            48220404,
            48221056
        ],
        "A": [
            48216068,
            48216088,
            48215851,
            48216101,
            48215964,
            48215856,
            48216330,
            48216376,
            48215843,
            48215822,
            48218304,
            48215863,
            48216823,
            48215814,
            48216519,
            48216032,
            48215829,
            48216427,
            48216203
        ]
    },
    "name": "E. Polycarp's New Job",
    "statement": "Polycarp has recently got himself a new job. He now earns so much that\r\nhis old wallet can’t even store all the money he has.Berland bills\r\nsomehow come in lots of different sizes. However, all of them are shaped\r\nas rectangles (possibly squares). All wallets are also produced in form\r\nof rectangles (possibly squares).A bill x\r\ntimes y fits into some wallet h\r\ntimes w if either x\r\nle h and y\r\nle w or y\r\nle h and x\r\nle w. Bills can overlap with each other in a wallet and an infinite\r\namount of bills can fit into a wallet. That implies that all the bills\r\nPolycarp currently have fit into a wallet if every single one of them\r\nfits into it independently of the others.Now you are asked to perform\r\nthe queries of two types: + x y Polycarp earns a bill of size x\r\ntimes y; ? h w Polycarp wants to check if all the bills he has earned to\r\nthis moment fit into a wallet of size h\r\ntimes w. It is guaranteed that there is at least one query of type 1\r\nbefore the first query of type 2 and that there is at least one query of\r\ntype 2 in the input data.For each query of type 2 print \"\" if all the\r\nbills he has earned to this moment fit into a wallet of given size.\r\nPrint \"\" otherwise.\r\n",
    "solutions": [
        "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <cstring>\n#include <list>  \n#include <cassert>\n#include <climits>\n#include <bitset>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;  \nint gcd(int a,int b) { return b==0?a:gcd(b,a%b); }\n\nint nq;\n\nvoid run() {\n\tscanf(\"%d\",&nq);\n\tint a=0,b=0;\n\tREP(i,nq) {\n\t\tchar kind; scanf(\" %c\",&kind);\n\t\tif(kind=='+') { int x,y; scanf(\"%d%d\",&x,&y); if(x<y) swap(x,y); a=max(a,x); b=max(b,y); }\n\t\tif(kind=='?') { int x,y; scanf(\"%d%d\",&x,&y); if(x<y) swap(x,y); printf(\"%s\\n\",x>=a&&y>=b?\"YES\":\"NO\"); }\n\t}\n}\n\nint main() {\n\trun();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Polycarp's New Job.json",
    "editorial_link": "https://codeforces.com/blog/entry/64483",
    "editorial": "Letâs find the smallest wallet to fit all bills. One its side is the\r\nmaximum side of any bill. Now we orient the bills in such a way that\r\ntheir longer side is put against this side of the wallet. The second\r\nside of the wallet is the maximum of the other sides. More formally, for\r\nset of bills , , ... ( for each ), the minimum wallet is (, ).The\r\nminimum wallet fits all sufficient wallets.So the solution is\r\nmaintaining the maximum of all and and checking if and ().Choose your\r\ni/o functions wisely.Overall complexity: .\r\n",
    "hint": []
}