{
    "link": "https://codeforces.com//contest/1499/problem/E",
    "problemId": "928253",
    "problem_idx": "E",
    "shortId": "1499E",
    "contest_number": "1499",
    "problem_submissions": {
        "F": [
            110357719,
            110358460,
            110349173,
            110358016,
            110369330,
            110363127,
            110361036,
            110362817,
            110367470,
            110357203,
            110369171,
            110368211,
            110370268,
            110366091,
            110355624,
            110365992,
            110369429,
            110370266,
            110365656
        ],
        "E": [
            110348041,
            110354549,
            110362433,
            110350437,
            110347357,
            110357359,
            110349011,
            110357563,
            110354502,
            110352211,
            110355950,
            110358510,
            110361861,
            110360330,
            110370250,
            110360561,
            110360403,
            110361550,
            110357936
        ],
        "D": [
            110338625,
            110339185,
            110410334,
            110410318,
            110410229,
            110342082,
            110340758,
            110337901,
            110434363,
            110434311,
            110432471,
            110432456,
            110384121,
            110347999,
            110344468,
            110349024,
            110347133,
            110346694,
            110345990,
            110348574,
            110343676,
            110346592,
            110347088,
            110350111,
            110350771,
            110350595,
            110349856
        ],
        "C": [
            110333651,
            110331021,
            110334430,
            110335594,
            110331843,
            110335775,
            110331846,
            110336227,
            110336058,
            110339413,
            110333925,
            110337781,
            110335754,
            110338528,
            110342766,
            110337144,
            110339220,
            110337699,
            110337911
        ],
        "B": [
            110328704,
            110327182,
            110329276,
            110330310,
            110327534,
            110329852,
            110327723,
            110329207,
            110329841,
            110333664,
            110328875,
            110331182,
            110328187,
            110334069,
            110334004,
            110328671,
            110331437,
            110330565,
            110331774
        ],
        "A": [
            110326019,
            110325991,
            110326313,
            110326005,
            110325865,
            110325899,
            110325997,
            110326125,
            110326016,
            110326091,
            110326392,
            110325908,
            110325927,
            110326243,
            110325858,
            110326228,
            110326284,
            110326209,
            110326298
        ],
        "G": [
            110573818,
            110399277,
            112155486,
            110386520,
            110388825
        ]
    },
    "name": "E. Chaotic Merge",
    "statement": "You are given two strings x and y, both consist only of lowercase Latin\r\nletters. Let |s| be the length of string s.Let’s call a sequence a a\r\nmerging sequence if it consists of exactly |x| zeros and exactly |y|\r\nones in some order.A merge z is produced from a sequence a by the\r\nfollowing rules: if a_i=0, then remove a letter from the beginning of x\r\nand append it to the end of z; if a_i=1, then remove a letter from the\r\nbeginning of y and append it to the end of z. Two merging sequences a\r\nand b are different if there is some position i such that a_i\r\nneq b_i.Let’s call a string z if for all i from 2 to |z| z_{i-1}\r\nneq z_i.Let s[l,r] for some 1\r\nle l\r\nle r\r\nle |s| be a substring of consecutive letters of s, starting from\r\nposition l and ending at position r inclusive.Let f(l_1, r_1, l_2, r_2)\r\nbe the number of different merging sequences of x[l_1,r_1] and\r\ny[l_2,r_2] that produce merges. Note that only non-empty substrings of x\r\nand y are considered.Calculate\r\nsum\r\nlimits_{1\r\nle l_1\r\nle r_1\r\nle |x|\r\n1\r\nle l_2\r\nle r_2\r\nle |y|} f(l_1, r_1, l_2, r_2). Output the answer modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nint N, M;\nchar X[1010];\nchar Y[1010];\n\nll D[1010][1010];\nll E[1010][1010];\n\nint main() {\n\tscanf(\"%s\", X + 1);\n\tscanf(\"%s\", Y + 1);\n\tN = strlen(X + 1);\n\tM = strlen(Y + 1);\n\n\tfor(int i = 1; i <= N; i++) {\n\t\tD[i][0] = (X[i] == X[i - 1] ? 0 : D[i - 1][0]) + 1;\n\t}\n\tfor(int i = 1; i <= M; i++) {\n\t\tE[0][i] = (Y[i] == Y[i - 1] ? 0 : E[0][i - 1]) + 1;\n\t}\n\n\tll ans = 0;\n\tfor(int i = 1; i <= N; i++) {\n\t\tfor(int j = 1; j <= M; j++) {\n\t\t\tif(X[i] != X[i - 1]) D[i][j] = D[i - 1][j];\n\t\t\tif(X[i] != Y[j]) {\n\t\t\t\tD[i][j] = (D[i][j] + E[i - 1][j]) % MOD;\n\t\t\t\tif(i > 1) D[i][j] = (D[i][j] + E[0][j]) % MOD;\n\t\t\t}\n\t\t\tif(Y[j] != Y[j - 1]) E[i][j] = E[i][j - 1];\n\t\t\tif(X[i] != Y[j]) {\n\t\t\t\tE[i][j] = (E[i][j] + D[i][j - 1]) % MOD;\n\t\t\t\tif(j > 1) E[i][j] = (E[i][j] + D[i][0]) % MOD;\n\t\t\t}\n\t\t\tans = (ans + D[i][j] + E[i][j]) % MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Chaotic Merge.json",
    "editorial_link": "https://codeforces.com//blog/entry/88812",
    "editorial": "First, letâs try to calculate the number of merging sequences just for\r\nsome fixed pair of strings and .Imagine we build a merge letter by\r\nletter. So far letters are in the merge already. For the -th letter we\r\ncan pick a letter from either string or string (put a or a into the\r\nmerging sequence, respectively). What constraints our choice? Easy to\r\nsee that itâs only the -th letter of the merge. So we can come up with\r\nthe following dynamic programming. is the number of merging sequences\r\nsuch that characters from are taken, characters from are taken and the\r\nlast character of the merge is . can be either just a letter (a\r\ndimension of size ) or an indicator of a string the last character was\r\ntaken from ( for string and from string ). Since we know how many\r\ncharacters are taken from each string, we can easily decide the last\r\ntaken character from that indicator. For each transition we can just\r\ntake a character from either of the strings.The sum of over all will be\r\nthe total number of merging sequences.Now for the substrings. Recall the\r\nfollowing definition of a substring: is a substring of if you can remove\r\nsome characters from the beginning of (possibly, none or all) and some\r\ncharacters from the end of (possibly, none or all) to get the string\r\n.What if we incorporated that definition into our dynamic programming?\r\nLet be the number of merging sequences that end exactly before the -th\r\ncharacter of , exactly before the -th character of and the last\r\ncharacter is still .How to remove some characters from the beginning?\r\nThat actually is the same as attempting to start the merge from every\r\nstate of dp. So, if we are currently in some state , then we can act as\r\nif we have just taken the -th character of or the -th character of as\r\nthe first character of the merge.How to remove some characters from the\r\nend? Since is the number of merging sequences that end exactly there,\r\nwhy not just sum up all the values of dynamic programming into the\r\nanswer? We will count the sequences that end in all possible positions\r\nof both strings.That is almost the answer to the task. The only issue we\r\nhave is that we forgot the condition that asks us to get a non-empty\r\nsubstring from each string. Well, there are multiple ways to resolve the\r\nissue.We can remove bad sequences afterwards: their count is the number\r\nof chaotic substrings of multiplied by all possible empty substrings of\r\n(there are of them) plus the same thing for and . These can be counted\r\nwith two pointers. Alternatively, we can add an extra dimension or two\r\nto the dp to indicate if we have ever taken a character from and from .\r\nSo we get with and being binary flags that tell if a character from and\r\nfrom was ever taken. That way we can only push the states with both\r\nflags set to true to the answer.Overall complexity: .\r\n",
    "hint": []
}