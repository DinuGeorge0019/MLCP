{
    "link": "https://codeforces.com//contest/600/problem/F",
    "problemId": "41578",
    "problem_idx": "F",
    "shortId": "600F",
    "contest_number": "600",
    "problem_submissions": {
        "E": [
            14516781,
            14521796,
            14522661,
            14523717,
            30527329,
            14524644,
            14516280,
            14515812,
            14516214,
            14518451,
            14519071,
            14519248,
            14519280,
            14518850,
            14518744,
            14518295,
            14521024,
            14524030,
            14518640,
            14519985,
            14534724,
            14534675
        ],
        "D": [
            14515579,
            14519010,
            14518774,
            14521193,
            14533916,
            14533879,
            17533027,
            77083288,
            14526699,
            14520082
        ],
        "C": [
            14514280,
            14514611,
            14515088,
            14516246,
            14514489,
            14514198,
            14514520,
            14514586,
            14514814,
            14515845,
            14514811,
            14514852,
            14514847,
            14516022,
            14513813,
            14515214,
            14515296,
            14517008,
            14517583
        ],
        "B": [
            14513498,
            14513713,
            14514312,
            14515199,
            64489984,
            64489958,
            64437360,
            64437339,
            64437310,
            64437262,
            64437238,
            64437187,
            64356527,
            64356317,
            64356304,
            64356219,
            64356053,
            64356040,
            64356029,
            64355961,
            64355802,
            64355581,
            64355572,
            64355497,
            64355269,
            64355250,
            64355067,
            64355022,
            64355018,
            64355008,
            64354957,
            64354927,
            64354893,
            64354674,
            64354610,
            64354604,
            64354499,
            64354477,
            64354377,
            64354366,
            64354314,
            64354299,
            64354208,
            64354016,
            64353840,
            64353829,
            64353816,
            64353659,
            64353647,
            64353627,
            64353521,
            64353432,
            64353406,
            64353383,
            64353315,
            64353296,
            64352793,
            64352299,
            64352204,
            14513750,
            14513852,
            14513619,
            14513719,
            14513814,
            14513671,
            14513567,
            14513744,
            14513927,
            14514916,
            14513319,
            14514212,
            14514452,
            14514809,
            14515622
        ],
        "A": [
            14513396,
            14513543,
            14514079,
            14514797,
            14513623,
            14513416,
            14513555,
            14513558,
            14513502,
            14513418,
            14513548,
            14513680,
            14517095,
            14519574,
            14514382,
            14515226
        ],
        "F": [
            15165948,
            15165905,
            15165817,
            110063771,
            77143032,
            14560500
        ]
    },
    "name": "F. Edge coloring of bipartite graph",
    "statement": "You are given an undirected bipartite graph without multiple edges. You\r\nshould paint the edges of graph to minimal number of colours, so that no\r\ntwo adjacent edges have the same colour.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MP make_pair\n#define A first\n#define B second\n\nint n = 1000,m;\nint ans = 0;\nint deg[2][1013];\npair<int,int> has[2][1013][1013];\nint color[100013];\n\nint c[2];\nvoid dfs(int x, int p) {\n\tauto i = has[p][x][c[!p]];\n\tif (has[!p][i.A][c[p]].B) dfs(i.A,!p);\n\telse has[!p][i.A][c[!p]] = MP(0,0);\n\thas[p][x][c[p]] = i;\n\thas[!p][i.A][c[p]] = MP(x,i.B);\n\tcolor[i.B] = c[p];\n}\n\nint main() {\n\tscanf(\"%*d%*d%d\",&m);\n\tfor (int i=1;i<=m;i++) {\n\t\tint x[2];\n\t\tscanf(\"%d%d\",&x[0],&x[1]);\n\t\tfor (int d=0;d<2;d++) {\n\t\t\tdeg[d][x[d]]+=1;\n\t\t\tans = max(ans,deg[d][x[d]]);\n\t\t\tfor (c[d]=1;has[d][x[d]][c[d]].B;c[d]++);\n\t\t}\n\t\tif (c[0]!=c[1]) dfs(x[1],1);\n\t\tfor (int d=0;d<2;d++) has[d][x[d]][c[0]] = MP(x[!d],i);\n\t\tcolor[i] = c[0];\n\t}\n\tprintf(\"%d\\n\",ans);\n\tfor (int i=1;i<=m;i++) printf(\"%d \",color[i]);\n\tprintf(\"\\n\");\n\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Edge coloring of bipartite graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/21827",
    "editorial": "Let\u00e2\u0080\u0099s denote is the maximum degree of vertex in graph. Let\u00e2\u0080\u0099s prove that\r\nthe answer is . We will build the constructive algorithm for that (it\r\nwill be the solution to problem). Let\u00e2\u0080\u0099s colour the edges one by one in\r\nsome order. Let be the current edge. If there exist colour that is free\r\nin vertex and in vertex then we can simply colour with . If there is no\r\nsuch colour then there are a couple of colours so that is in and not in\r\nand is in but not in . Let\u00e2\u0080\u0099s make vertex free from colour . Denote the\r\nother end of edge from with colour . If is free from colour then we can\r\ncolour with and recolour with . So me make alternation. If is not free\r\nfrom colour let\u00e2\u0080\u0099s denote the other end of the edge from with colour . If\r\nis free from colour then again we can do alternation. And so on. We will\r\nfind an alternating chain because the graph is bipartite. To find the\r\nchain we can use depth first search. Each chain contains no more than\r\nvertices. So we have: : .\r\n"
}