{
    "link": "https://codeforces.com//contest/1606/problem/F",
    "problemId": "1163617",
    "problem_idx": "F",
    "shortId": "1606F",
    "contest_number": "1606",
    "problem_submissions": {
        "F": [
            133507404,
            133507818,
            133498109,
            133510274,
            133508292,
            133516889,
            133520516,
            133515497,
            133516080,
            133502968,
            134316313,
            133499324,
            134054804,
            133588873,
            133583029,
            133581709
        ],
        "D": [
            133486455,
            133493884,
            133513223,
            133492283,
            133485348,
            133494162,
            133496696,
            133482809,
            133492529,
            133517460,
            133476721,
            133498136,
            133495480,
            135925509,
            133485100,
            133479592,
            133499757,
            133522973,
            133486537,
            133503209,
            133499457
        ],
        "E": [
            133463795,
            133481392,
            133471511,
            133490729,
            133490179,
            133495042,
            133479686,
            133483637,
            133491209,
            133498277,
            133483064,
            133494409,
            133480178,
            133476474,
            135922690,
            133494013,
            133498349,
            133478322,
            133477984,
            133495608,
            133473401,
            133487605
        ],
        "C": [
            133458872,
            133464915,
            133459336,
            133460040,
            133464064,
            133462782,
            133466153,
            133471330,
            133463944,
            133471558,
            133463840,
            133462653,
            133461264,
            133462854,
            133461230,
            133467241,
            133464884,
            133472085,
            133464159,
            133466246
        ],
        "B": [
            133458354,
            133459359,
            133457772,
            133458154,
            133459800,
            133458862,
            133459689,
            133467167,
            133459191,
            133458183,
            133459448,
            133458263,
            133464726,
            133458679,
            133458193,
            133459842,
            133457910,
            133460625,
            133459355,
            133458301
        ],
        "A": [
            133457621,
            133458135,
            133457507,
            133457613,
            133457801,
            133457608,
            133458264,
            133457856,
            133457610,
            133457684,
            133457591,
            133457600,
            133457598,
            133457574,
            133457611,
            133457877,
            133457514,
            133458100,
            133457524,
            133457605
        ]
    },
    "name": "F. Tree Queries",
    "statement": "You are given a tree consisting of n vertices. Recall that a tree is an\r\nundirected connected acyclic graph. The given tree is rooted at the\r\nvertex 1.You have to process q queries. In each query, you are given a\r\nvertex of the tree v and an integer k.To process a query, you may delete\r\nany vertices from the tree in any order, except for the root and the\r\nvertex v. When a vertex is deleted, its children become the children of\r\nits parent. You have to process a query in such a way that maximizes the\r\nvalue of c(v) - m\r\ncdot k (where c(v) is the resulting number of children of the vertex v,\r\nand m is the number of vertices you have deleted). Print the maximum\r\npossible value you can obtain.The queries are independent: the changes\r\nyou make to the tree while processing a query don\u2019t affect the tree in\r\nother queries.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\ntemplate<typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nstruct node{\n\tint x,y;\n\tnode(int x=0,int y=0):x(x),y(y){}\n\tbool operator<(const node c)const{return 1ll*y*c.x<1ll*x*c.y;}\n\tbool operator>(const node c)const{return c<*this;}\n\tnode operator+(const node c)const{return node(x+c.x,y+c.y);}\n}val[200005],sum[200005];\n\nmt19937 mrand(1);\nint n,q,tot,ncnt;\nint ch[200005][2],siz[200005],v[400005],nxt[400005],h[200005],son[200005],sz[200005],rt[200005],ans[200005];\nvector<pii> qry[200005];\n\nvoid addedge(int x,int y){\n\tv[++tot]=y; nxt[tot]=h[x]; h[x]=tot;\n\tv[++tot]=x; nxt[tot]=h[y]; h[y]=tot;\n}\n\nvoid dfs1(int u,int fa){\n\tsz[u]=1;\n\tfor(int p=h[u];p;p=nxt[p]){\n\t\tif(v[p]==fa) continue;\n\t\tdfs1(v[p],u);\n\t\tsz[u]+=sz[v[p]];\n\t\tif(sz[v[p]]>sz[son[u]]) son[u]=v[p];\n\t}\n}\n\nvoid update(int u){\n\tsiz[u]=1+siz[ch[u][0]]+siz[ch[u][1]];\n\tsum[u]=val[u]+sum[ch[u][0]]+sum[ch[u][1]];\n}\n\nvoid split(int u,node k,int &x,int &y){\n\tif(!u) return (void)(x=y=0);\n\tif(!(val[u]<k)) x=u,split(ch[u][1],k,ch[x][1],y);\n\telse y=u,split(ch[u][0],k,x,ch[y][0]);\n\tupdate(u);\n}\n\nint merge(int x,int y){\n\tif(!x||!y) return x+y;\n\tif(mrand()%(siz[x]+siz[y])<siz[x]){\n\t\tch[x][1]=merge(ch[x][1],y); update(x);\n\t\treturn x;\n\t}\n\telse{\n\t\tch[y][0]=merge(x,ch[y][0]); update(y);\n\t\treturn y;\n\t}\n}\n\nvoid dfs3(int u,int t){\n\tif(!u) return;\n\tdfs3(ch[u][0],t);\n\tdfs3(ch[u][1],t);\n\tch[u][0]=ch[u][1]=0;\n\tupdate(u);\n\tint a,b;\n\tsplit(rt[t],val[u],a,b);\n\trt[t]=merge(merge(a,u),b);\n}\n\nint getlf(int u){\n\twhile(ch[u][0]) u=ch[u][0];\n\treturn u;\n}\n\nvoid trav(int u){\n\tif(!u) return;\n\ttrav(ch[u][0]);\n\tcout<<\"test \"<<val[u].x<<' '<<val[u].y<<endl;\n\ttrav(ch[u][1]);\n}\n\nvoid dfs2(int u,int fa){\n\tfor(int p=h[u];p;p=nxt[p]) if(v[p]!=fa&&v[p]!=son[u]) dfs2(v[p],u);\n\tint num=-1;\n\tif(son[u]) dfs2(son[u],u),rt[u]=rt[son[u]],num++;\n\tfor(int p=h[u];p;p=nxt[p]){\n\t\tif(v[p]==fa||v[p]==son[u]) continue;\n\t\tdfs3(rt[v[p]],u);\n\t\tnum++;\n\t}\n//\tcout<<\"#################### \"<<u<<' '<<th.x<<' '<<th.y<<endl;\n//\ttrav(rt[u]);\n\tint a,b;\n\tfor(auto r:qry[u]){\n\t\tnode tmp(1,r.fi);\n\t\tsplit(rt[u],tmp,a,b);\n\t\tans[r.se]=sum[a].y-1ll*r.fi*sum[a].x+num+1;\n\t\trt[u]=merge(a,b);\n\t}\n\tnode th(1,num);\n\twhile(siz[rt[u]]>=1){\n\t\tint tmp=getlf(rt[u]);\n\t\tif(th>val[tmp]) break;\n\t\tsplit(rt[u],val[tmp],a,b);\n\t\tth=th+val[a];\n\t\trt[u]=merge(merge(ch[a][0],ch[a][1]),b);\n\t}\n\tncnt++;\n\tval[ncnt]=sum[ncnt]=th,siz[ncnt]=1;\n\trt[u]=merge(ncnt,rt[u]);\n}\n\nint main(){\n\tn=readint();\n\tfor(int i=1;i<n;i++) addedge(readint(),readint());\n\tq=readint();\n\tfor(int i=1;i<=q;i++){\n\t\tint x=readint(),y=readint();\n\t\tqry[x].pb(mp(y,i));\n\t}\n\tdfs1(1,-1);\n\tdfs2(1,-1);\n\tfor(int i=1;i<=q;i++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Tree Queries.json",
    "editorial_link": "https://codeforces.com//blog/entry/96454",
    "editorial": "A naive solution to this problem would be to implement a recursive\r\nfunction which answers each query: let be the answer to the query \" \",\r\nwe can calculate it as , since for each child of vertex , we either\r\ndelete it and change the score by , or choose to let it remain, and this\r\nincreases the score by . Unfortunately, it is too slow.Let\u00e2\u0080\u0099s try to\r\noptimize it. First of all, since if we choose the exact same subset of\r\nvertices to delete for the query \" \" as we\u00e2\u0080\u0099ve chosen for the query \" \",\r\nour score won\u00e2\u0080\u0099t decrease. Using this fact, we can show that if it\u00e2\u0080\u0099s\r\noptimal to remove some vertex in the query \" \", it\u00e2\u0080\u0099s also optimal to\r\nremove a vertex in the query \" \" because it\u00e2\u0080\u0099s optimal to remove vertex\r\nif , and if this condition holds for some value of , then it holds for\r\neach smaller value of .Let be the maximum value of when it\u00e2\u0080\u0099s optimal to\r\nremove the vertex . We will calculate these values for all vertices of\r\nthe tree using an event processing method: we\u00e2\u0080\u0099ll process the values of\r\nfrom to and use a set or a priority queue to store events of the form\r\n\"at the value , vertex becomes optimal to delete\". This set/priority\r\nqueue should sort the events in descending order of the value of , and\r\nin case of ties, in descending order of depths of the vertices (to make\r\nsure that vertices with the same value of are processed from bottom to\r\nup). Let\u00e2\u0080\u0099s analyze the implementation of this process more in detail.\r\nFor each vertex, we will store two values the number of vertices we\r\nshould remove from its subtree, and the number of children this vertex\r\nwill optimally have. Using these two values, we can easily calculate the\r\nvalue of for a vertex. When a vertex is \"removed\" (that is, the event\r\ncorresponding to this vertex is processed), these values for this vertex\r\nshould be added to its current parent (we can use DSU to find the\r\ncurrent parent easily, for example; and don\u00e2\u0080\u0099t forget that the number of\r\nvertices we have to remove for this new parent also increases by ); then\r\nwe recalculate the value of for the current parent and change the event\r\ncorresponding to this current parent (note that the value of for the\r\ncurrent parent shouldn\u00e2\u0080\u0099t be greater than the value of for the vertex\r\nwe\u00e2\u0080\u0099ve deleted).Okay, this allows us to calculate when it\u00e2\u0080\u0099s optimal to\r\ndelete each vertex. But how do we answer queries? One of the ways to do\r\nthis is to process queries in the same event processing algorithm (and\r\nfor every value of , we first \"remove\" the vertices with , then process\r\nthe queries). There is an issue that when we remove a vertex, it can\r\naffect the answer not only for its current parent, but also for the\r\nvertices that could be its parents, but are already deleted; to handle\r\nthis, instead of adding the values of the deleted vertex only to the\r\nvalues of its current parent, we perform an addition on the whole path\r\nfrom the vertex to the current parent (excluding the vertex itself).\r\nThis path addition can be performed with a Fenwick or Segment tree over\r\nthe Eulerian tour of the tree, and this yields a compexity of , though\r\nwith a high constant factor.\r\n"
}