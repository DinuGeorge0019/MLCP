{"link": "https://codeforces.com//contest/1606/problem/F", "problemId": "1163617", "problem_idx": "F", "shortId": "1606F", "contest_number": "1606", "problem_submissions": {"F": [133507404, 133507818, 133498109, 133510274, 133508292, 133516889, 133520516, 133515497, 133516080, 133502968, 134316313, 133499324, 134054804, 133588873, 133583029, 133581709], "D": [133486455, 133493884, 133513223, 133492283, 133485348, 133494162, 133496696, 133482809, 133492529, 133517460, 133476721, 133498136, 133495480, 135925509, 133485100, 133479592, 133499757, 133522973, 133486537, 133503209, 133499457], "E": [133463795, 133481392, 133471511, 133490729, 133490179, 133495042, 133479686, 133483637, 133491209, 133498277, 133483064, 133494409, 133480178, 133476474, 135922690, 133494013, 133498349, 133478322, 133477984, 133495608, 133473401, 133487605], "C": [133458872, 133464915, 133459336, 133460040, 133464064, 133462782, 133466153, 133471330, 133463944, 133471558, 133463840, 133462653, 133461264, 133462854, 133461230, 133467241, 133464884, 133472085, 133464159, 133466246], "B": [133458354, 133459359, 133457772, 133458154, 133459800, 133458862, 133459689, 133467167, 133459191, 133458183, 133459448, 133458263, 133464726, 133458679, 133458193, 133459842, 133457910, 133460625, 133459355, 133458301], "A": [133457621, 133458135, 133457507, 133457613, 133457801, 133457608, 133458264, 133457856, 133457610, 133457684, 133457591, 133457600, 133457598, 133457574, 133457611, 133457877, 133457514, 133458100, 133457524, 133457605]}, "name": "F. Tree Queries", "statement": "You are given a tree consisting of n vertices. Recall that a tree is an\r\nundirected connected acyclic graph. The given tree is rooted at the\r\nvertex 1.You have to process q queries. In each query, you are given a\r\nvertex of the tree v and an integer k.To process a query, you may delete\r\nany vertices from the tree in any order, except for the root and the\r\nvertex v. When a vertex is deleted, its children become the children of\r\nits parent. You have to process a query in such a way that maximizes the\r\nvalue of c(v) - m\r\ncdot k (where c(v) is the resulting number of children of the vertex v,\r\nand m is the number of vertices you have deleted). Print the maximum\r\npossible value you can obtain.The queries are independent: the changes\r\nyou make to the tree while processing a query don\u2019t affect the tree in\r\nother queries.\r\n", "solutions": ["#include<bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\ntemplate<typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nstruct node{\n\tint x,y;\n\tnode(int x=0,int y=0):x(x),y(y){}\n\tbool operator<(const node c)const{return 1ll*y*c.x<1ll*x*c.y;}\n\tbool operator>(const node c)const{return c<*this;}\n\tnode operator+(const node c)const{return node(x+c.x,y+c.y);}\n}val[200005],sum[200005];\n\nmt19937 mrand(1);\nint n,q,tot,ncnt;\nint ch[200005][2],siz[200005],v[400005],nxt[400005],h[200005],son[200005],sz[200005],rt[200005],ans[200005];\nvector<pii> qry[200005];\n\nvoid addedge(int x,int y){\n\tv[++tot]=y; nxt[tot]=h[x]; h[x]=tot;\n\tv[++tot]=x; nxt[tot]=h[y]; h[y]=tot;\n}\n\nvoid dfs1(int u,int fa){\n\tsz[u]=1;\n\tfor(int p=h[u];p;p=nxt[p]){\n\t\tif(v[p]==fa) continue;\n\t\tdfs1(v[p],u);\n\t\tsz[u]+=sz[v[p]];\n\t\tif(sz[v[p]]>sz[son[u]]) son[u]=v[p];\n\t}\n}\n\nvoid update(int u){\n\tsiz[u]=1+siz[ch[u][0]]+siz[ch[u][1]];\n\tsum[u]=val[u]+sum[ch[u][0]]+sum[ch[u][1]];\n}\n\nvoid split(int u,node k,int &x,int &y){\n\tif(!u) return (void)(x=y=0);\n\tif(!(val[u]<k)) x=u,split(ch[u][1],k,ch[x][1],y);\n\telse y=u,split(ch[u][0],k,x,ch[y][0]);\n\tupdate(u);\n}\n\nint merge(int x,int y){\n\tif(!x||!y) return x+y;\n\tif(mrand()%(siz[x]+siz[y])<siz[x]){\n\t\tch[x][1]=merge(ch[x][1],y); update(x);\n\t\treturn x;\n\t}\n\telse{\n\t\tch[y][0]=merge(x,ch[y][0]); update(y);\n\t\treturn y;\n\t}\n}\n\nvoid dfs3(int u,int t){\n\tif(!u) return;\n\tdfs3(ch[u][0],t);\n\tdfs3(ch[u][1],t);\n\tch[u][0]=ch[u][1]=0;\n\tupdate(u);\n\tint a,b;\n\tsplit(rt[t],val[u],a,b);\n\trt[t]=merge(merge(a,u),b);\n}\n\nint getlf(int u){\n\twhile(ch[u][0]) u=ch[u][0];\n\treturn u;\n}\n\nvoid trav(int u){\n\tif(!u) return;\n\ttrav(ch[u][0]);\n\tcout<<\"test \"<<val[u].x<<' '<<val[u].y<<endl;\n\ttrav(ch[u][1]);\n}\n\nvoid dfs2(int u,int fa){\n\tfor(int p=h[u];p;p=nxt[p]) if(v[p]!=fa&&v[p]!=son[u]) dfs2(v[p],u);\n\tint num=-1;\n\tif(son[u]) dfs2(son[u],u),rt[u]=rt[son[u]],num++;\n\tfor(int p=h[u];p;p=nxt[p]){\n\t\tif(v[p]==fa||v[p]==son[u]) continue;\n\t\tdfs3(rt[v[p]],u);\n\t\tnum++;\n\t}\n//\tcout<<\"#################### \"<<u<<' '<<th.x<<' '<<th.y<<endl;\n//\ttrav(rt[u]);\n\tint a,b;\n\tfor(auto r:qry[u]){\n\t\tnode tmp(1,r.fi);\n\t\tsplit(rt[u],tmp,a,b);\n\t\tans[r.se]=sum[a].y-1ll*r.fi*sum[a].x+num+1;\n\t\trt[u]=merge(a,b);\n\t}\n\tnode th(1,num);\n\twhile(siz[rt[u]]>=1){\n\t\tint tmp=getlf(rt[u]);\n\t\tif(th>val[tmp]) break;\n\t\tsplit(rt[u],val[tmp],a,b);\n\t\tth=th+val[a];\n\t\trt[u]=merge(merge(ch[a][0],ch[a][1]),b);\n\t}\n\tncnt++;\n\tval[ncnt]=sum[ncnt]=th,siz[ncnt]=1;\n\trt[u]=merge(ncnt,rt[u]);\n}\n\nint main(){\n\tn=readint();\n\tfor(int i=1;i<n;i++) addedge(readint(),readint());\n\tq=readint();\n\tfor(int i=1;i<=q;i++){\n\t\tint x=readint(),y=readint();\n\t\tqry[x].pb(mp(y,i));\n\t}\n\tdfs1(1,-1);\n\tdfs2(1,-1);\n\tfor(int i=1;i<=q;i++) printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["brute force", "dp", "trees"], "dificulty": "2800", "interactive": false}