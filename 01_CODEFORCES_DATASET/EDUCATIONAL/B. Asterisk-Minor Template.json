{
    "link": "https://codeforces.com//contest/1796/problem/B",
    "problemId": "1802546",
    "problem_idx": "B",
    "shortId": "1796B",
    "contest_number": "1796",
    "problem_submissions": {
        "F": [
            195363403,
            195358131,
            195479952,
            195352672,
            197311670,
            196155422,
            195754330
        ],
        "E": [
            195322604,
            195319205,
            195326482,
            195321452,
            195327641,
            195860691,
            195453420,
            195453193,
            195322745,
            195328001,
            195331101,
            195332636,
            195326730,
            195325672,
            195330089,
            195730772,
            195730423,
            195326388,
            195341037,
            195326008,
            195331716,
            195328756,
            195331573,
            195338613,
            195329663
        ],
        "D": [
            195301353,
            195304722,
            195305253,
            195303622,
            195309683,
            195303260,
            195314948,
            195309431,
            195312674,
            195316263,
            195314478,
            195311060,
            195310198,
            195308650,
            195308315,
            195293456,
            195319263,
            195305260,
            195544976,
            195315681
        ],
        "C": [
            195293384,
            195295362,
            195292646,
            195293592,
            195298098,
            195294172,
            195296742,
            195299256,
            195301143,
            195303080,
            195303361,
            195304837,
            195724689,
            195723906,
            195300890,
            195288215,
            195295041,
            195302705,
            195306906,
            195294076,
            195307764
        ],
        "B": [
            195288248,
            195289700,
            195287789,
            195287682,
            195290336,
            195286518,
            195290220,
            195290123,
            195290068,
            195287181,
            195292039,
            195293913,
            195289326,
            195284427,
            195288804,
            195305536,
            195289798,
            195287403,
            195298773
        ],
        "A": [
            195283882,
            195284135,
            195283927,
            195289942,
            195285318,
            195283838,
            195283735,
            195283820,
            195283931,
            195283631,
            195283664,
            195285369,
            195285859,
            195283473,
            195283857,
            195283713,
            195284138,
            195283860,
            195284027
        ]
    },
    "name": "B. Asterisk-Minor Template",
    "statement": "You are given two strings a and b, consisting of lowercase Latin\r\nletters.A template t is string, consisting of lowercase Latin letters\r\nand asterisks (character \u2019*\u2019). A template is called if the number of\r\nasterisks in it is less than or equal to the number of letters in it.A\r\nstring s is said to be matching a template t if you can replace each\r\nasterisk in t with a string of lowercase Latin letters (possibly, an\r\nempty string) so that it becomes equal to s.Find an template such that\r\nboth a and b match it, or report that such a template doesn\u2019t exist. If\r\nthere are multiple answers, print any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nint n,a[2000005];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tstring s,t;\n\t\tcin >> s >> t;\n\t\tif(s[0]==t[0])\n\t\t{\n\t\t\tcout << \"YES\\n\" << s[0] << \"*\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tif(s.back()==t.back())\n\t\t{\n\t\t\tcout << \"YES\\n\" << \"*\" << s.back() << \"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\tint flag=0;\n\t\tfor(int i=1;i<s.size();i++)\n\t\t{\n\t\t\tfor(int j=1;j<t.size();j++)\n\t\t\t{\n\t\t\t\tif(s.substr(i-1,2)==t.substr(j-1,2))\n\t\t\t\t{\n\t\t\t\t\tflag=1;\n\t\t\t\t\tcout << \"YES\\n\" << \"*\" << s.substr(i-1,2) << \"*\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t\tif(!flag) cout << \"NO\\n\";\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "strings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Asterisk-Minor Template.json",
    "editorial_link": "https://codeforces.com//blog/entry/113408",
    "editorial": "What\u00e2\u0080\u0099s the reason behind authors specifically asking for templates that\r\nhave less or equal asterisks than letters? Well, without that the\r\nproblem would be kind of trivial. A template \"\" is matched by every\r\nstring, so it would always work.Hmm, let\u00e2\u0080\u0099s try to make something similar\r\nto that template then. We basically have to find some part of that\r\noccurs in both strings that we can use letters on to get some freedom to\r\nuse asterisks.There are some easy cases. If the first letters of both\r\nstrings are the same, then the template can be that letter followed by\r\nan asterisk. There\u00e2\u0080\u0099s a symmetrical case for the last letter.By studying\r\nthe examples, you can also notice the final case: a common substring of\r\nboth strings of length at least two surrounded by two asterisks.\r\nMoreover, since we only use two asterisks, we can find a substring of\r\nlength exactly two (which always exists if a longer common substring\r\nexists).Turns out, that\u00e2\u0080\u0099s it. If a template exists, one of these three\r\nkinds also exists.This is not that hard to show. If the first two kinds\r\ndon\u00e2\u0080\u0099t work, then you have to use asterisks on both sides of the\r\ntemplate. In order for the template with asterisks on both sides to\r\nwork, there have to be adjacent letters in it at least once (otherwise,\r\nit\u00e2\u0080\u0099s like \"\", and there are more asterisks than letters). And since at\r\nleast one such substring exists, we can just remove everything other\r\nthan this substring and the asterisks on the sides.Overall complexity:\r\nper testcase.\r\n"
}