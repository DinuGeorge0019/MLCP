{
    "link": "https://codeforces.com//contest/1814/problem/B",
    "problemId": "1867157",
    "problem_idx": "B",
    "shortId": "1814B",
    "contest_number": "1814",
    "problem_submissions": {
        "F": [
            201036702,
            201037659,
            201028227,
            201050534,
            201005326,
            201050567,
            201051354,
            201158503,
            202793506,
            201087367,
            202961596,
            202961442,
            202961147,
            201054424,
            201057597,
            201057439,
            201061539
        ],
        "E": [
            201020903,
            201018973,
            201013610,
            201039745,
            201017818,
            201033040,
            201037281,
            201034750,
            201024677,
            201030462,
            201026865,
            201030498,
            201034907,
            201040830,
            201037552,
            201041417,
            201042340,
            201036940,
            201015059,
            201040959
        ],
        "D": [
            201007638,
            201011987,
            201038257,
            201026423,
            201158753,
            201158000,
            201029908,
            201043932,
            201052993,
            201045921,
            201082509,
            201058213,
            201035019,
            201016854,
            201013631,
            201010624,
            201014339,
            201022685,
            201018472,
            201019148,
            201025982,
            201024394,
            201027376,
            201024423,
            201027368,
            201021262,
            201025020,
            201019825,
            201029085,
            201044637,
            201027275
        ],
        "C": [
            200997961,
            201000063,
            201003769,
            201024541,
            201036517,
            201006380,
            201034351,
            200999416,
            201001849,
            201000732,
            201005802,
            201004502,
            201004247,
            201004311,
            201006996,
            201002331,
            201000424,
            200997419,
            201005850,
            201004743
        ],
        "B": [
            200988415,
            200991922,
            200990827,
            200995877,
            201038223,
            200997671,
            201032023,
            200991419,
            200988849,
            200991883,
            200998660,
            200995028,
            200998040,
            200993967,
            200992160,
            200993164,
            200991747,
            200987467,
            201004511,
            200997597
        ],
        "A": [
            200985126,
            200985107,
            200985078,
            200985613,
            201039035,
            200990896,
            201030957,
            200985096,
            200985148,
            200986607,
            200985454,
            200988595,
            200985783,
            200985667,
            200986043,
            200985871,
            200988700,
            200985284,
            201001220,
            200986768
        ]
    },
    "name": "B. Long Legs",
    "statement": "A robot is placed in a cell (0, 0) of an infinite grid. This robot has\r\nadjustable length legs. Initially, its legs have length 1.Let the robot\r\ncurrently be in the cell (x, y) and have legs of length m. In one move,\r\nit can perform one of the following three actions: jump into the cell\r\n(x + m, y); jump into the cell (x, y + m); increase the length of the\r\nlegs by 1, i. e. set it to m + 1. What\u2019s the smallest number of moves\r\nrobot has to make to reach a cell (a, b)?\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n\ta = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n\ta = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n\tvector<T> res;\n\tint ida = 0, idb = 0;\n\twhile (ida < a.size() || idb < b.size()) {\n\t\tif (idb == b.size()) {\n\t\t\tres.push_back(a[ida]); ida++;\n\t\t}\n\t\telse if (ida == a.size()) {\n\t\t\tres.push_back(b[idb]); idb++;\n\t\t}\n\t\telse {\n\t\t\tif (a[ida] < b[idb]) {\n\t\t\t\tres.push_back(a[ida]); ida++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres.push_back(b[idb]); idb++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n\trep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n\trep(i, v.size()) {\n\t\tif (i > 0)cout << \" \"; cout << v[i];\n\t}\n\tcout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n\tif (n < 0) {\n\t\tll res = mod_pow(x, -n, m);\n\t\treturn mod_pow(res, m - 2, m);\n\t}\n\tif (abs(x) >= m)x %= m;\n\tif (x < 0)x += m;\n\t//if (x == 0)return 0;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\n//mod should be <2^31\nstruct modint {\n\tint n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) {\n\t\tif (m < 0 || mod <= m) {\n\t\t\tm %= mod; if (m < 0)m += mod;\n\t\t}\n\t\tn = m;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\ta = abs(a); b = abs(b);\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n\tif (loc >= v.size())v.resize(loc + 1, 0);\n\tv[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n\tfill(isp + 2, isp + mn, true);\n\tfor (int i = 2; i < mn; i++) {\n\t\tif (!isp[i])continue;\n\t\tps.push_back(i);\n\t\tfor (int j = 2 * i; j < mn; j += i) {\n\t\t\tisp[j] = false;\n\t\t}\n\t}\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\tif (res == st.begin())return st.end();\n\tres--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n\tauto res = st.lower_bound(val);\n\treturn res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n\ta = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n\ta = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n\treturn { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n\ta = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n\treturn { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n\ta = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\nvoid solve() {\n\tint a, b; cin >> a >> b;\n\tint ans = mod;\n\tfor (int c = 1; c <= 200000; c++) {\n\t\tint cost = c - 1;\n\t\tcost += (a + c - 1) / c;\n\t\tcost += (b + c - 1) / c;\n\t\tchmin(ans, cost);\n\t}\n\tcout << ans << \"\\n\";\n}\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(12);\n\t//init_f();\n\t//init();\n\t//while(true)\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\t\tsolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Long Legs.json",
    "editorial_link": "https://codeforces.com//blog/entry/114854",
    "editorial": "Let\u00e2\u0080\u0099s fix the number of leg length increases we do. Let the final length\r\nbe . Notice that for all from to there is some time when the length is\r\nexactly . Thus, we can perform jumps of form or .What\u00e2\u0080\u0099s the jumping\r\nstrategy, then? Obviously, we can solve the problem independently for\r\nand . Consider . We would love to just make jumps of length as that\u00e2\u0080\u0099s\r\nthe maximum possible length. Unfortunately, that only works when is\r\ndivisible by . Otherwise, we are left with some remainder which is\r\nsmaller than . But we have already figured out how to jump to any value\r\nfrom to . So, that only adds another jump. You can say that the total\r\nnumber of jumps is .Same for . Finally, for a fixed , the answer is .The\r\nconstraints tell us that we are not allowed to iterate over all from to\r\n. It feels like huge will never be optimal, but let\u00e2\u0080\u0099s try to base our\r\nintuition on something.Try to limit the options by studying the formula.\r\nLet\u00e2\u0080\u0099s simplify. Assume and also get rid of the ceil. Not like that\r\nchanges the formula a lot. Now it becomes . We can see that when we\r\nincrease , becomes smaller and becomes larger. However, we care more\r\nabout how fast they become smaller and larger. You can just guess or\r\nwrite down the derivative explicitly and figure out that the first term\r\nshrinks faster than the second term grows until around for some constant\r\n(apparently, ). Thus, their sum decreases until then, then\r\nincreases.Thus, you can search for the best around or or . It doesn\u00e2\u0080\u0099t\r\nreally matter, since, for implementation, you can basically try all\r\nuntil around , which is safely enough.\r\n"
}