{
    "link": "https://codeforces.com//contest/1334/problem/G",
    "problemId": "590687",
    "problem_idx": "G",
    "shortId": "1334G",
    "contest_number": "1334",
    "problem_submissions": {
        "G": [
            76150604,
            76454180,
            76191944,
            76188027,
            76167647,
            76177375,
            76173628,
            76186408,
            76177963,
            76163688,
            76192725,
            76184456,
            76199963,
            76199932,
            76182086,
            76197235,
            76196570,
            76214003,
            76498225,
            76495336,
            76260338
        ],
        "F": [
            76137544,
            76454142,
            76145547,
            76157286,
            76163120,
            76164905,
            76178511,
            76167121,
            76165115,
            77917392,
            76145490,
            76152253,
            76160935,
            76165553,
            76165708,
            76168968,
            76174508,
            76168274,
            76170642,
            76172386,
            76176147
        ],
        "E": [
            76125664,
            76454103,
            76130620,
            76144771,
            76144664,
            76158374,
            76133358,
            76154175,
            76146278,
            77917431,
            76130418,
            76125237,
            76138118,
            76141034,
            76142668,
            76149616,
            76144057,
            76143238,
            76146704,
            76123897,
            76133227
        ],
        "D": [
            76117930,
            76454057,
            76121143,
            76124195,
            76129444,
            76121217,
            76145661,
            76143168,
            76138942,
            76118871,
            76134614,
            76125142,
            76129022,
            76126912,
            76131421,
            76134529,
            76131763,
            76126502,
            76140986,
            76147818
        ],
        "C": [
            76108518,
            76454007,
            76107934,
            76107462,
            76112664,
            76110005,
            76119790,
            76108604,
            76117844,
            76213964,
            76213679,
            76105910,
            76110649,
            76113576,
            76108183,
            76111773,
            76111557,
            76110114,
            76109227,
            76109093,
            76106723,
            76112412
        ],
        "B": [
            76102992,
            76453951,
            76102307,
            76102229,
            76104046,
            76104090,
            76113043,
            76104228,
            76113456,
            76102698,
            76104186,
            76104760,
            76102468,
            76104601,
            76103592,
            76102759,
            76103107,
            76101604,
            76101877,
            76102615
        ],
        "A": [
            76101170,
            76453913,
            76100742,
            76100982,
            76101188,
            76101149,
            76107978,
            76101072,
            76103065,
            76100866,
            76101471,
            76100923,
            76100719,
            76101105,
            76100817,
            76100705,
            76100882,
            76100750,
            76100773,
            76100924
        ]
    },
    "name": "G. Substring Search",
    "statement": "You are given a permutation p consisting of exactly 26 integers from 1\r\nto 26 (since it is a permutation, each integer from 1 to 26 occurs in p\r\nexactly once) and two strings s and t consisting of lowercase Latin\r\nletters.A substring t\u2019 of string t is an of string s if the following\r\nconditions are met: |t\u2019| = |s|; for each i\r\nin [1, |s|], either s_i = t\u2019_i, or p_{idx(s_i)} = idx(t\u2019_i), where\r\nidx(c) is the index of character c in Latin alphabet (idx(\r\ntext{a}) = 1, idx(\r\ntext{b}) = 2, idx(\r\ntext{z}) = 26). For example, if p_1 = 2, p_2 = 3, p_3 = 1, s =\r\ntext{abc}, t =\r\ntext{abcaaba}, then three substrings of t are occurences of s (they are\r\nt\u2019 =\r\ntext{abc}, t\u2019 =\r\ntext{bca} and t\u2019 =\r\ntext{aba}).For each substring of t having length equal to |s|, check if\r\nit is an of s.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int md = 998244353;\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n}\n\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) {\n    x += md;\n  }\n}\n\ninline int mul(int x, int y) {\n  return (long long) x * y % md;\n}\n\ninline int power(int x, int y) {\n  int res = 1;\n  for (; y; y >>= 1, x = mul(x, x)) {\n    if (y & 1) {\n      res = mul(res, x);\n    }\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) {\n    a += md;\n  }\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a;\n    swap(a, b);\n    u -= t * v;\n    swap(u, v);\n  }\n  if (u < 0) {\n    u += md;\n  }\n  return u;\n}\n\nnamespace ntt {\nint base = 1, root = -1, max_base = -1;\nvector<int> rev = {0, 1}, roots = {0, 1};\n\nvoid init() {\n  int temp = md - 1;\n  max_base = 0;\n  while (temp % 2 == 0) {\n    temp >>= 1;\n    ++max_base;\n  }\n  root = 2;\n  while (true) {\n    if (power(root, 1 << max_base) == 1 && power(root, 1 << max_base - 1) != 1) {\n      break;\n    }\n    ++root;\n  }\n}\n\nvoid ensure_base(int nbase) {\n  if (max_base == -1) {\n    init();\n  }\n  if (nbase <= base) {\n    return;\n  }\n  assert(nbase <= max_base);\n  rev.resize(1 << nbase);\n  for (int i = 0; i < 1 << nbase; ++i) {\n    rev[i] = rev[i >> 1] >> 1 | (i & 1) << nbase - 1;\n  }\n  roots.resize(1 << nbase);\n  while (base < nbase) {\n    int z = power(root, 1 << max_base - 1 - base);\n    for (int i = 1 << base - 1; i < 1 << base; ++i) {\n      roots[i << 1] = roots[i];\n      roots[i << 1 | 1] = mul(roots[i], z);\n    }\n    ++base;\n  }\n}\n\nvoid dft(vector<int> &a) {\n  int n = a.size(), zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; ++i) {\n    if (i < rev[i] >> shift) {\n      swap(a[i], a[rev[i] >> shift]);\n    }\n  }\n  for (int i = 1; i < n; i <<= 1) {\n    for (int j = 0; j < n; j += i << 1) {\n      for (int k = 0; k < i; ++k) {\n        int x = a[j + k], y = mul(a[j + k + i], roots[i + k]);\n        a[j + k] = (x + y) % md;\n        a[j + k + i] = (x + md - y) % md;\n      }\n    }\n  }\n}\n\nvector<int> multiply(vector<int> a, vector<int> b) {\n  int need = a.size() + b.size() - 1, nbase = 0;\n  while (1 << nbase < need) {\n    ++nbase;\n  }\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  a.resize(sz);\n  b.resize(sz);\n  bool equal = a == b;\n  dft(a);\n  if (equal) {\n    b = a;\n  } else {\n    dft(b);\n  }\n  int inv_sz = inv(sz);\n  for (int i = 0; i < sz; ++i) {\n    a[i] = mul(mul(a[i], b[i]), inv_sz);\n  }\n  reverse(a.begin() + 1, a.end());\n  dft(a);\n  a.resize(need);\n  return a;\n}\n\nvector<int> inverse(vector<int> a) {\n  int n = a.size(), m = n + 1 >> 1;\n  if (n == 1) {\n    return vector<int>(1, inv(a[0]));\n  } else {\n    vector<int> b = inverse(vector<int>(a.begin(), a.begin() + m));\n    int need = n << 1, nbase = 0;\n    while (1 << nbase < need) {\n      ++nbase;\n    }\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz);\n    b.resize(sz);\n    dft(a);\n    dft(b);\n    int inv_sz = inv(sz);\n    for (int i = 0; i < sz; ++i) {\n      a[i] = mul(mul(md + 2 - mul(a[i], b[i]), b[i]), inv_sz);\n    }\n    reverse(a.begin() + 1, a.end());\n    dft(a);\n    a.resize(n);\n    return a;\n  }\n}\n}\n\nusing ntt::multiply;\nusing ntt::inverse;\n\nvector<int>& operator += (vector<int> &a, const vector<int> &b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    add(a[i], b[i]);\n  }\n  return a;\n}\n\nvector<int> operator + (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c += b;\n}\n\nvector<int>& operator -= (vector<int> &a, const vector<int> &b) {\n  if (a.size() < b.size()) {\n    a.resize(b.size());\n  }\n  for (int i = 0; i < b.size(); ++i) {\n    sub(a[i], b[i]);\n  }\n  return a;\n}\n\nvector<int> operator - (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c -= b;\n}\n\nvector<int>& operator *= (vector<int> &a, const vector<int> &b) {\n  if (min(a.size(), b.size()) < 128) {\n    vector<int> c = a;\n    a.assign(a.size() + b.size() - 1, 0);\n    for (int i = 0; i < c.size(); ++i) {\n      for (int j = 0; j < b.size(); ++j) {\n        add(a[i + j], mul(c[i], b[j]));\n      }\n    }\n  } else {\n    a = multiply(a, b);\n  }\n  return a;\n}\n\nvector<int> operator * (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c *= b;\n}\n\nvector<int>& operator /= (vector<int> &a, const vector<int> &b) {\n  int n = a.size(), m = b.size();\n  if (n < m) {\n    a.clear();\n  } else {\n    vector<int> c = b;\n    reverse(a.begin(), a.end());\n    reverse(c.begin(), c.end());\n    c.resize(n - m + 1);\n    a *= inverse(c);\n    a.erase(a.begin() + n - m + 1, a.end());\n    reverse(a.begin(), a.end());\n  }\n  return a;\n}\n\nvector<int> operator / (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c /= b;\n}\n\nvector<int>& operator %= (vector<int> &a, const vector<int> &b) {\n  int n = a.size(), m = b.size();\n  if (n >= m) {\n    vector<int> c = (a / b) * b;\n    a.resize(m - 1);\n    for (int i = 0; i < m - 1; ++i) {\n      sub(a[i], c[i]);\n    }\n  }\n  return a;\n}\n\nvector<int> operator % (const vector<int> &a, const vector<int> &b) {\n  vector<int> c = a;\n  return c %= b;\n}\n\nvector<int> derivative(const vector<int> &a) {\n  int n = a.size();\n  vector<int> b(n - 1);\n  for (int i = 1; i < n; ++i) {\n    b[i - 1] = mul(a[i], i);\n  }\n  return b;\n}\n\nvector<int> primitive(const vector<int> &a) {\n  int n = a.size();\n  vector<int> b(n + 1), invs(n + 1);\n  for (int i = 1; i <= n; ++i) {\n    invs[i] = i == 1 ? 1 : mul(md - md / i, invs[md % i]);\n    b[i] = mul(a[i - 1], invs[i]);\n  }\n  return b;\n}\n\nvector<int> logarithm(const vector<int> &a) {\n  vector<int> b = primitive(derivative(a) * inverse(a));\n  b.resize(a.size());\n  return b;\n}\n\nvector<int> exponent(const vector<int> &a) {\n  vector<int> b(1, 1);\n  while (b.size() < a.size()) {\n    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    add(c[0], 1);\n    vector<int> old_b = b;\n    b.resize(b.size() << 1);\n    c -= logarithm(b);\n    c *= old_b;\n    for (int i = b.size() >> 1; i < b.size(); ++i) {\n      b[i] = c[i];\n    }\n  }\n  b.resize(a.size());\n  return b;\n}\n\nvector<int> power(const vector<int> &a, int m) {\n  int n = a.size(), p = -1;\n  vector<int> b(n);\n  for (int i = 0; i < n; ++i) {\n    if (a[i]) {\n      p = i;\n      break;\n    }\n  }\n  if (p == -1) {\n    b[0] = !m;\n    return b;\n  }\n  if ((long long) m * p >= n) {\n    return b;\n  }\n  int mu = power(a[p], m), di = inv(a[p]);\n  vector<int> c(n - m * p);\n  for (int i = 0; i < n - m * p; ++i) {\n    c[i] = mul(a[i + p], di);\n  }\n  c = logarithm(c);\n  for (int i = 0; i < n - m * p; ++i) {\n    c[i] = mul(c[i], m);\n  }\n  c = exponent(c);\n  for (int i = 0; i < n - m * p; ++i) {\n    b[i + m * p] = mul(c[i], mu);\n  }\n  return b;\n}\n\nvector<int> sqrt(const vector<int> &a) {\n  vector<int> b(1, 1);\n  while (b.size() < a.size()) {\n    vector<int> c(a.begin(), a.begin() + min(a.size(), b.size() << 1));\n    vector<int> old_b = b;\n    b.resize(b.size() << 1);\n    c *= inverse(b);\n    for (int i = b.size() >> 1; i < b.size(); ++i) {\n      b[i] = mul(c[i], md + 1 >> 1);\n    }\n  }\n  b.resize(a.size());\n  return b;\n}\n\nvector<int> multiply_all(int l, int r, vector<vector<int>> &all) {\n  if (l > r) {\n    return vector<int>();\n  } else if (l == r) {\n    return all[l];\n  } else {\n    int y = l + r >> 1;\n    return multiply_all(l, y, all) * multiply_all(y + 1, r, all);\n  }\n}\n\nvector<int> evaluate(const vector<int> &f, const vector<int> &x) {\n  int n = x.size();\n  if (!n) {\n    return vector<int>();\n  }\n  vector<vector<int>> up(n * 2);\n  for (int i = 0; i < n; ++i) {\n    up[i + n] = vector<int>{(md - x[i]) % md, 1};\n  }\n  for (int i = n - 1; i; --i) {\n    up[i] = up[i << 1] * up[i << 1 | 1];\n  }\n  vector<vector<int>> down(n * 2);\n  down[1] = f % up[1];\n  for (int i = 2; i < n * 2; ++i) {\n    down[i] = down[i >> 1] % up[i];\n  }\n  vector<int> y(n);\n  for (int i = 0; i < n; ++i) {\n    y[i] = down[i + n][0];\n  }\n  return y;\n}\n\nvector<int> interpolate(const vector<int> &x, const vector<int> &y) {\n  int n = x.size();\n  vector<vector<int>> up(n * 2);\n  for (int i = 0; i < n; ++i) {\n    up[i + n] = vector<int>{(md - x[i]) % md, 1};\n  }\n  for (int i = n - 1; i; --i) {\n    up[i] = up[i << 1] * up[i << 1 | 1];\n  }\n  vector<int> a = evaluate(derivative(up[1]), x);\n  for (int i = 0; i < n; ++i) {\n    a[i] = mul(y[i], inv(a[i]));\n  }\n  vector<vector<int>> down(n * 2);\n  for (int i = 0; i < n; ++i) {\n    down[i + n] = vector<int>(1, a[i]);\n  }\n  for (int i = n - 1; i; --i) {\n    down[i] = down[i << 1] * up[i << 1 | 1] + down[i << 1 | 1] * up[i << 1];\n  }\n  return down[1];\n}\n\nconst int N=201000;\nll val[1010],c[5][N],d[5][N],ss[N];\nint q,p[1010];\nchar s[N],t[N];\n\n\nint main() {\n\trep(i,0,26) val[i]=rnd(mod);\n\trep(i,0,26) {\n\t\tint q;\n\t\tscanf(\"%d\",&q);\n\t\tp[q-1]=i;\n\t}\n\tscanf(\"%s\",t);\n\tscanf(\"%s\",s);\n\tint n=strlen(s);\n\trep(i,0,n) {\n\t\tint id=s[i]-'a';\n\t\tll u=val[id],v=val[p[id]];\n\t\tc[4][i]=1;\n\t\tc[3][i]=(-2*u-2*v)%mod;\n\t\tc[2][i]=(u*u+4*u*v+v*v)%mod;\n\t\tc[1][i]=-2*u*v%mod*(u+v)%mod;\n\t\tc[0][i]=u*u%mod*v%mod*v%mod;\n\t}\n\trep(i,0,n) rep(j,0,5) if (c[j][i]<0) c[j][i]+=mod;\n\tint m=strlen(t);\n\trep(i,0,m) {\n\t\tll u=val[t[i]-'a'];\n\t\td[0][i]=1;\n\t\trep(x,1,5) d[x][i]=d[x-1][i]*u%mod;\n\t}\n\trep(x,0,5) {\n\t\treverse(d[x],d[x]+m);\n\t\tauto a=multiply(VI(d[x],d[x]+m),VI(c[x],c[x]+n));\n\t\trep(j,m-1,n) ss[j]=(ss[j]+a[j])%mod;\n\t}\n\trep(j,m-1,n) putchar(ss[j]==0?'1':'0');\n\tputs(\"\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "fft"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Substring Search.json",
    "editorial_link": "https://codeforces.com//blog/entry/75877",
    "editorial": "We will run two tests for each substring of we are interested in. If at\r\nleast one of them shows that the substring is not an occurence of , we\r\nprint , otherwise we print .The first test is fairly easy. The given\r\npermutation can be decomposed into cycles. Let\u00e2\u0080\u0099s replace each character\r\nwith the index of its cycle (in both strings) and check if each\r\nsubstring of is equal to after this replacement (for example, using\r\nregular KMP algorithm). If some substring is not equal to after the\r\nreplacement, then it is definitely not an occurence.The second test will\r\nhelp us distinguish the characters belonging to the same cycle. Let be\r\nsome cycle in our permutation (elements are listed in the order they\r\nappear in the cycle, so ). We will replace each character with a complex\r\nnumber in such a way that the case when they match are easily\r\ndistinguishable from the case when they don\u00e2\u0080\u0099t match. One of the ways to\r\ndo this is to replace with a complex number having magnitude equal to\r\nand argument equal to (if this character belongs to ) or to (if this\r\ncharacter belongs to ).How does this replacement help us checking the\r\noccurence? If we multiply the numbers for two matching characters, we\r\nget a complex number with argument equal to or to , and its real part\r\nwill be . In any other case, the real part of the resulting number will\r\nbe strictly less than , and the difference will be at least . So, if we\r\ncompute the value of for the -th substring of (where is the number that\r\nreplaced the character ), we can check if the real part of the result is\r\nclose to the value we would get if we matched with itself (and if the\r\ndifference is big enough, at least one pair of characters didn\u00e2\u0080\u0099t match).\r\nThe only case when this method fails is if we try to match characters\r\nfrom different cycles of the permutation, that\u00e2\u0080\u0099s why we needed the first\r\ntest.Overall, the first test can be done in using prefix function (or\r\nany other linear substring search algorithm), and the second test can be\r\ndone in , if we compute the aforementioned values for each substring\r\nusing FFT.\r\n"
}