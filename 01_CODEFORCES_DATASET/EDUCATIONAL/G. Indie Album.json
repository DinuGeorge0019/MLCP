{
    "link": "https://codeforces.com//contest/1207/problem/G",
    "problemId": "393977",
    "problem_idx": "G",
    "shortId": "1207G",
    "contest_number": "1207",
    "problem_submissions": {
        "G": [
            59304889,
            59306176,
            59301627,
            59302407,
            59304210,
            59305372,
            59299826,
            59307985,
            59309136,
            59355235,
            59305105,
            59306118,
            59301046,
            59312490,
            59309174,
            59287118,
            59310203,
            59295342,
            59301224,
            59539702,
            59539581,
            59351316
        ],
        "F": [
            59294259,
            59294479,
            59293703,
            59293849,
            59293275,
            59295696,
            59294933,
            59295843,
            59294771,
            59355160,
            59296347,
            59298285,
            59281377,
            59296537,
            59297200,
            59291269,
            59286364,
            59296630,
            59287709,
            59292729,
            59290075
        ],
        "E": [
            59292194,
            59292083,
            59291434,
            59290312,
            59295934,
            59293256,
            59291138,
            59291830,
            59292503,
            59355130,
            59293757,
            59294706,
            59287064,
            59293320,
            59294341,
            59301962,
            59302885,
            59297608,
            59313261,
            59287955,
            59288580
        ],
        "D": [
            59288834,
            59287831,
            59288996,
            59287685,
            59289737,
            59290739,
            59290294,
            59288360,
            59289950,
            59355097,
            59292036,
            59291781,
            72384113,
            59294418,
            59290806,
            59291351,
            59299257,
            59291468,
            59299192,
            59306695,
            59285530,
            59286504
        ],
        "C": [
            59285396,
            59284651,
            59285140,
            59282971,
            59284725,
            59287600,
            59288738,
            59284263,
            59285344,
            59354996,
            59286662,
            59287414,
            59304338,
            59287720,
            59292924,
            59296911,
            59299362,
            59300644,
            59304203,
            59281217,
            59283117
        ],
        "B": [
            59279519,
            59278225,
            59278842,
            59278682,
            59280115,
            59279180,
            59278245,
            59278492,
            59278908,
            59354975,
            59279326,
            59282036,
            59291564,
            59283101,
            59282410,
            59293321,
            59292638,
            59301723,
            59308496,
            59277604,
            59278398
        ],
        "A": [
            59275875,
            59276003,
            59275839,
            59276009,
            59276337,
            59276873,
            59279814,
            59276133,
            59276212,
            59354913,
            59276348,
            59277224,
            59276516,
            59275776,
            59279300,
            59292197,
            59276302,
            59302397,
            59275866,
            59275778,
            59276055
        ]
    },
    "name": "G. Indie Album",
    "statement": "Mishka’s favourite experimental indie band has recently dropped a new\r\nalbum! Songs of that album share one gimmick. Each name s_i is one of\r\nthe following types: 1 c a single lowercase Latin letter; 2 j c name s_j\r\n(1\r\nle j < i) with a single lowercase Latin letter appended to its end.\r\nSongs are numbered from 1 to n. It’s guaranteed that the first song is\r\nalways of type 1.Vova is rather interested in the new album but he\r\nreally doesn’t have the time to listen to it entirely. Thus he asks\r\nMishka some questions about it to determine if some song is worth\r\nlistening to. Questions have the following format: i t count the number\r\nof occurrences of string t in s_i (the name of the i-th song of the\r\nalbum) as a continuous substring, t consists only of lowercase Latin\r\nletters. Mishka doesn’t question the purpose of that information, yet he\r\nstruggles to provide it. Can you please help Mishka answer all Vova’s\r\nquestions?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nnamespace treeArr {\n    int sum[400010];\n    inline void add(int x, int k) {\n        for(; x <= 400000; x += x & -x) sum[x] += k;\n    }\n    inline int get(int x) {\n        int ans = 0;\n        for(; x; x -= x & -x) ans += sum[x];\n        return ans;\n    }\n}\nnamespace AC {\n    int son[400010][26], cnt;\n    int fail[400010];\n    vector<int> e[400010];\n    int dfn[400010], sze[400010];\n    int dfsnow;\n    inline int add(char *s) {\n        int now = 0;\n        for(int i = 0, n = strlen(s); i < n; i++) {\n            if(son[now][s[i] - 'a'] == 0) son[now][s[i] - 'a'] = ++cnt;\n            now = son[now][s[i] - 'a'];\n        }\n        return now;\n    }\n    inline int getans(int id) {\n        return treeArr :: get(dfn[id] + sze[id] - 1) - treeArr :: get(dfn[id] - 1);\n    }\n    inline void dfs(int now) {\n        dfn[now] = ++dfsnow;\n        sze[now] = 1;\n        for(auto i : e[now]) dfs(i), sze[now] += sze[i];\n    }\n    inline void build() {\n        queue<int> q;\n        for(int i = 0; i < 26; i++) if(son[0][i]) q.push(son[0][i]);\n        while(!q.empty()) {\n            int now = q.front();\n            q.pop();\n            e[fail[now]].push_back(now);\n            for(int i = 0; i < 26; i++) {\n                if(son[now][i]) fail[son[now][i]] = son[fail[now]][i], q.push(son[now][i]);\n                else son[now][i] = son[fail[now]][i];\n            }\n        }\n        dfs(0);\n    }\n    inline int f(int x, int k) {\n        return son[x][k - 'a'];\n    }\n}\nchar c[400010];\nint opt[400010];\nvector<int> son[400010];\nint ans[400010];\nvector<pair<int, int> > que[400010];\nvoid dfs(int now, int nowd) {\n    nowd = AC :: f(nowd, c[now]);\n    treeArr :: add(AC :: dfn[nowd], 1);\n    for(auto i : son[now]) dfs(i, nowd);\n    for(auto i : que[now]) {\n        ans[i.second] = AC :: getans(i.first);\n    }\n    treeArr :: add(AC :: dfn[nowd], -1);\n}\nchar s[400010];\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 1, fa; i <= n; i++) {\n        scanf(\"%d\", opt + i);\n        if(opt[i] == 2) scanf(\"%d\", &fa), son[fa].push_back(i);\n        scanf(\"%s\", c + i);\n    }\n    int m;\n    scanf(\"%d\", &m);\n    for(int i = 1; i <= m; i++) {\n        int id;\n        scanf(\"%d%s\", &id, s);\n        que[id].push_back(make_pair(AC :: add(s), i));\n    }\n    AC :: build();\n    for(int i = 1; i <= n; i++) if(opt[i] == 1) dfs(i, 0);\n    for(int i = 1; i <= m; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "hashing",
        "string suffix structures",
        "strings",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Indie Album.json",
    "editorial_link": "https://codeforces.com//blog/entry/69314",
    "editorial": "There is a common approach for the problem \"you are given a lot of\r\nstrings and texts, count the number of occurences of the strings in the\r\ntexts\" build an Aho-Corasick automaton on the given strings and somehow\r\nprocess the texts with it. Letâs see if it can handle this problem.The\r\nnames of the songs can be represented as a tree. We may build an\r\nAho-Corasick on the strings given in the queries, then try to input the\r\nnames of the album into the automaton character-by-character with DFS on\r\nthe aforementioned tree (feeding a character to the automaton when we\r\nenter a node, and reverting the automaton to the previous state when we\r\nleave that node). Suppose that when we are in the vertex corresponding\r\nto the -th song, the automaton is in state . If is a terminal state\r\ncorresponding to some string from the queries, it means that the string\r\nfrom the query is a suffix of the -th song. But some other strings can\r\nalso be the suffixes of the same song to find all such strings, we can\r\nstart ascending from the state to the root of Aho-Corasick automaton\r\nusing suffix links or dictionary links. Since suffix links can be\r\nrepresented as the edges of some rooted tree, then we can build some\r\ndata structure on this tree that allows adding an integer to all\r\nvertices on the path from the root to the given vertex (for example, we\r\ncan use Fenwick tree over Euler tour of the tree). Then, to check\r\nwhether some string from the query is a suffix of the song , we may add\r\nto all vertices on the path to state , and then check the value in the\r\nstate corresponding to .Okay, what about counting the occurences of in ?\r\nLetâs consider the path from the root to in the \"song tree\". Every\r\nvertex on this path corresponds to some prefix of the song , so we can\r\nadd on the path to state corresponding to some prefix, and then extract\r\nthe answer from the state corresponding to .In fact, thatâs all we have\r\nto do to obtain a solution. Build an automaton on strings from queries,\r\na tree of suffix links over this automaton, and a data structure on this\r\ntree; for each vertex of the song tree, store all queries to it. Then\r\nrun a DFS on the song tree. When we enter some vertex, input the\r\ncorresponding character into the automaton and add to all states from\r\nthe root of suffix link tree to the current state; when we have to\r\nprocess queries to the current vertex, extract the values from the data\r\nstructure; and when we leave a vertex, subtract from all states from the\r\nroot of suffix link tree to the current state, and revert to the\r\nprevious state.This solution has complexity of , where is the total\r\nlength of all strings in the input.\r\n",
    "hint": []
}