{"link": "https://codeforces.com//contest/1207/problem/G", "problemId": "393977", "problem_idx": "G", "shortId": "1207G", "contest_number": "1207", "problem_submissions": {"G": [59304889, 59306176, 59301627, 59302407, 59304210, 59305372, 59299826, 59307985, 59309136, 59355235, 59305105, 59306118, 59301046, 59312490, 59309174, 59287118, 59310203, 59295342, 59301224, 59539702, 59539581, 59351316], "F": [59294259, 59294479, 59293703, 59293849, 59293275, 59295696, 59294933, 59295843, 59294771, 59355160, 59296347, 59298285, 59281377, 59296537, 59297200, 59291269, 59286364, 59296630, 59287709, 59292729, 59290075], "E": [59292194, 59292083, 59291434, 59290312, 59295934, 59293256, 59291138, 59291830, 59292503, 59355130, 59293757, 59294706, 59287064, 59293320, 59294341, 59301962, 59302885, 59297608, 59313261, 59287955, 59288580], "D": [59288834, 59287831, 59288996, 59287685, 59289737, 59290739, 59290294, 59288360, 59289950, 59355097, 59292036, 59291781, 72384113, 59294418, 59290806, 59291351, 59299257, 59291468, 59299192, 59306695, 59285530, 59286504], "C": [59285396, 59284651, 59285140, 59282971, 59284725, 59287600, 59288738, 59284263, 59285344, 59354996, 59286662, 59287414, 59304338, 59287720, 59292924, 59296911, 59299362, 59300644, 59304203, 59281217, 59283117], "B": [59279519, 59278225, 59278842, 59278682, 59280115, 59279180, 59278245, 59278492, 59278908, 59354975, 59279326, 59282036, 59291564, 59283101, 59282410, 59293321, 59292638, 59301723, 59308496, 59277604, 59278398], "A": [59275875, 59276003, 59275839, 59276009, 59276337, 59276873, 59279814, 59276133, 59276212, 59354913, 59276348, 59277224, 59276516, 59275776, 59279300, 59292197, 59276302, 59302397, 59275866, 59275778, 59276055]}, "name": "G. Indie Album", "statement": "Mishka\u2019s favourite experimental indie band has recently dropped a new\r\nalbum! Songs of that album share one gimmick. Each name s_i is one of\r\nthe following types: 1\u00a0c a single lowercase Latin letter; 2\u00a0j\u00a0c name s_j\r\n(1\r\nle j < i) with a single lowercase Latin letter appended to its end.\r\nSongs are numbered from 1 to n. It\u2019s guaranteed that the first song is\r\nalways of type 1.Vova is rather interested in the new album but he\r\nreally doesn\u2019t have the time to listen to it entirely. Thus he asks\r\nMishka some questions about it to determine if some song is worth\r\nlistening to. Questions have the following format: i\u00a0t count the number\r\nof occurrences of string t in s_i (the name of the i-th song of the\r\nalbum) as a continuous substring, t consists only of lowercase Latin\r\nletters. Mishka doesn\u2019t question the purpose of that information, yet he\r\nstruggles to provide it. Can you please help Mishka answer all Vova\u2019s\r\nquestions?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nnamespace treeArr {\n    int sum[400010];\n    inline void add(int x, int k) {\n        for(; x <= 400000; x += x & -x) sum[x] += k;\n    }\n    inline int get(int x) {\n        int ans = 0;\n        for(; x; x -= x & -x) ans += sum[x];\n        return ans;\n    }\n}\nnamespace AC {\n    int son[400010][26], cnt;\n    int fail[400010];\n    vector<int> e[400010];\n    int dfn[400010], sze[400010];\n    int dfsnow;\n    inline int add(char *s) {\n        int now = 0;\n        for(int i = 0, n = strlen(s); i < n; i++) {\n            if(son[now][s[i] - 'a'] == 0) son[now][s[i] - 'a'] = ++cnt;\n            now = son[now][s[i] - 'a'];\n        }\n        return now;\n    }\n    inline int getans(int id) {\n        return treeArr :: get(dfn[id] + sze[id] - 1) - treeArr :: get(dfn[id] - 1);\n    }\n    inline void dfs(int now) {\n        dfn[now] = ++dfsnow;\n        sze[now] = 1;\n        for(auto i : e[now]) dfs(i), sze[now] += sze[i];\n    }\n    inline void build() {\n        queue<int> q;\n        for(int i = 0; i < 26; i++) if(son[0][i]) q.push(son[0][i]);\n        while(!q.empty()) {\n            int now = q.front();\n            q.pop();\n            e[fail[now]].push_back(now);\n            for(int i = 0; i < 26; i++) {\n                if(son[now][i]) fail[son[now][i]] = son[fail[now]][i], q.push(son[now][i]);\n                else son[now][i] = son[fail[now]][i];\n            }\n        }\n        dfs(0);\n    }\n    inline int f(int x, int k) {\n        return son[x][k - 'a'];\n    }\n}\nchar c[400010];\nint opt[400010];\nvector<int> son[400010];\nint ans[400010];\nvector<pair<int, int> > que[400010];\nvoid dfs(int now, int nowd) {\n    nowd = AC :: f(nowd, c[now]);\n    treeArr :: add(AC :: dfn[nowd], 1);\n    for(auto i : son[now]) dfs(i, nowd);\n    for(auto i : que[now]) {\n        ans[i.second] = AC :: getans(i.first);\n    }\n    treeArr :: add(AC :: dfn[nowd], -1);\n}\nchar s[400010];\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 1, fa; i <= n; i++) {\n        scanf(\"%d\", opt + i);\n        if(opt[i] == 2) scanf(\"%d\", &fa), son[fa].push_back(i);\n        scanf(\"%s\", c + i);\n    }\n    int m;\n    scanf(\"%d\", &m);\n    for(int i = 1; i <= m; i++) {\n        int id;\n        scanf(\"%d%s\", &id, s);\n        que[id].push_back(make_pair(AC :: add(s), i));\n    }\n    AC :: build();\n    for(int i = 1; i <= n; i++) if(opt[i] == 1) dfs(i, 0);\n    for(int i = 1; i <= m; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "hashing", "string suffix structures", "strings", "trees"], "dificulty": "2700", "interactive": false}