{
    "link": "https://codeforces.com//contest/1997/problem/D",
    "problemId": "2784497",
    "problem_idx": "D",
    "shortId": "1997D",
    "contest_number": "1997",
    "problem_submissions": {
        "F": [
            273554813,
            273562336,
            273555588,
            273558521,
            273558184,
            273555359,
            273562297,
            273565830,
            273546283,
            273544285,
            273566836,
            273566119,
            273585907,
            273568802,
            273555309,
            273574760,
            273588700,
            273578615,
            273575242,
            273588906
        ],
        "E": [
            273537014,
            273527320,
            273531772,
            273535164,
            273526322,
            273540324,
            273541553,
            273544138,
            273572699,
            273564384,
            273777832,
            273550008,
            273548972,
            273536881,
            273554636,
            273544552,
            273556209,
            273544842,
            273546282,
            273666737,
            273666189,
            273553954,
            273545375
        ],
        "D": [
            273513568,
            273513144,
            273513742,
            273512836,
            273510170,
            273516169,
            273515679,
            273515838,
            273510617,
            273513446,
            273517815,
            273525464,
            273518352,
            273521955,
            273529234,
            273520142,
            273512102,
            273520565,
            273515266,
            273520749
        ],
        "C": [
            273496813,
            273497815,
            273498571,
            273503315,
            273497876,
            273499195,
            273500860,
            273502791,
            273499347,
            273496485,
            273508798,
            273507268,
            273509198,
            273511156,
            273522873,
            273509562,
            273503505,
            273507797,
            273508832,
            273510628
        ],
        "B": [
            273490300,
            273489109,
            273490092,
            273494428,
            273492341,
            273491848,
            273492911,
            273494262,
            273492523,
            273491731,
            273501850,
            273497360,
            273496735,
            273504535,
            273502692,
            273496964,
            273493065,
            273497766,
            273504790,
            273497879
        ],
        "A": [
            273486630,
            273485994,
            273491236,
            273487968,
            273486132,
            273486581,
            273486579,
            273487757,
            273487599,
            273486090,
            273488578,
            273489964,
            273488719,
            273489029,
            273504662,
            273489452,
            273486034,
            273487994,
            273500770,
            273488432
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132154",
    "editorial": "We can clearly say that if some value can be obtained at the root, then\r\nany value from to can also be obtained. Using that fact, we can use\r\nbinary search to solve the problem.Let\u00e2\u0080\u0099s fix some value in binary search\r\nand check if it is possible to apply an operation from the statement\r\ntimes to the root. Let\u00e2\u0080\u0099s write the following recursive function: the\r\nfunction that checks whether it is possible to obtain at least at all\r\nvertices from the subtree of (including itself) simultaneously (i. e. we\r\nhad to make operations above the current vertex, can the subtree of\r\n\"support\" them?).Let the current state be , then there are three cases\r\nof transitions: is a leaf, then should hold; is not a leaf and , then\r\nthe vertex is ok, and we have to check its subtree (i. e. should be for\r\nall that are children of ). is not a leaf and , then we have to apply\r\nthe operation times to the vertex , and that adds an additional\r\nconstraint on the subtree of ; specifically, should be for all that are\r\nchildren of . Be careful with overflows: might grow exponentially, so\r\nyou should, for example, return from the function when becomes very\r\nlarge.When we check a single value of , this recursive function is\r\ncalled once for each vertex in the tree, so the total time complexity of\r\nthis solution is , where is an upper bound of the values of the array .\r\n",
    "name": "D. Maximize the Root",
    "statement": "You are given a rooted tree, consisting of n vertices. The vertices in\r\nthe tree are numbered from 1 to n, and the root is the vertex 1. The\r\nvalue a_i is written at the i-th vertex.You can perform the following\r\noperation any number of times (possibly zero): choose a vertex v ;\r\nincrease a_v by 1; and decrease a_u by 1 for all vertices u that are in\r\nthe subtree of v (except v itself). However, after each operation, the\r\nvalues on all vertices should be non-negative.Your task is to calculate\r\nthe maximum possible value written at the root using the aforementioned\r\noperation.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>//#define int li#define f first#define s second\u00a0using namespace std;using li = long long;using ld = long double;const int N = 2e5 + 5;const int INF = 1e9 + 7;\u00a0int a[N], dp[N];vector <int> g[N];\u00a0void dfs(int v){    if(g[v].empty())    {        dp[v] = a[v];        return;    }\u00a0    for(auto to:g[v])        dfs(to);\u00a0    int mn = INF;\u00a0    for(auto to:g[v])        mn = min(mn, dp[to]);\u00a0    dp[v] = min(mn, (mn + a[v]) / 2);\u00a0//    int L = 0, R = INF;////    while(R - L > 1)//    {//        int M = (L + R) / 2;////        li k = 0;//        bool F = 1;////        for(auto to:g[v])//        {//            if(dp[to] < M)//                F = 0;//            else k += dp[to] - M;//        }////        if(F && a[v] + k >= M)//            L = M;//        else R = M;//    }////    dp[v] = L;}\u00a0int32_t main(){    ios_base::sync_with_stdio(0);    cin.tie(0);\u00a0    int t;    cin >> t;\u00a0    while(t--)    {        int n;        cin >> n;\u00a0        for(int i = 0; i < n; i++)        {            a[i] = dp[i] = 0;            g[i].clear();        }\u00a0        for(int i = 0; i < n; i++)            cin >> a[i];\u00a0        vector <int> p(n);\u00a0        for(int i = 1; i < n; i++)        {            cin >> p[i];            p[i]--;\u00a0            g[p[i]].push_back(i);        }\u00a0        dfs(0);\u00a0        int ans = INF;\u00a0        for(auto to:g[0])            ans = min(ans, dp[to]);\u00a0        cout << ans + a[0] << \"\\n\";    }}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dfs and similar",
        "dp",
        "greedy",
        "trees"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Maximize the Root.json"
}