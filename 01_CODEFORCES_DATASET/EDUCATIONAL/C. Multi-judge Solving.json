{
    "link": "https://codeforces.com//contest/825/problem/C",
    "problemId": "114546",
    "problem_idx": "C",
    "shortId": "825C",
    "contest_number": "825",
    "problem_submissions": {
        "G": [
            28611826,
            28611356,
            28617070,
            28630000,
            28611377,
            28668357,
            28644356,
            28617410,
            28616887,
            115447701,
            28617449
        ],
        "F": [
            28607801,
            28609631,
            28607347,
            28609116,
            28609094,
            28607614,
            28608923,
            28607754,
            28610528,
            28609319,
            28614043,
            28612882,
            28614726,
            28613035,
            28614128,
            28617246,
            28608834
        ],
        "E": [
            28606236,
            28612183,
            28603943,
            28604761,
            28605629,
            28605699,
            28621023,
            28620710,
            28614410,
            28606910,
            28606445,
            28612588,
            28606404,
            28608319,
            28610978,
            28607253,
            28602716,
            28604390,
            28605864
        ],
        "D": [
            28601870,
            28604440,
            28602315,
            28603224,
            28602271,
            28603578,
            28602162,
            28602307,
            28605123,
            28604422,
            28602824,
            28605475,
            28605112,
            28601966,
            28604848,
            28601067,
            28602879,
            28603271,
            28602582
        ],
        "C": [
            28600566,
            28604558,
            28600573,
            28601511,
            28601329,
            28600992,
            28600584,
            28601117,
            28602961,
            28602487,
            28601481,
            28603635,
            28602536,
            28600048,
            28601839,
            28599960,
            28601178,
            28600725,
            28600385
        ],
        "B": [
            28599824,
            28602822,
            28599867,
            28599843,
            28600338,
            28600036,
            28599560,
            28600486,
            28599738,
            28600276,
            28600463,
            28602528,
            28601519,
            28610253,
            28599911,
            28599338,
            28600292,
            28600011,
            28599745
        ],
        "A": [
            28598954,
            28602676,
            28599093,
            28599010,
            28599148,
            28598936,
            28599534,
            28599292,
            28599020,
            28598945,
            28599332,
            28601537,
            28599412,
            28598882,
            28598949,
            28598917,
            28599099,
            28599150,
            28598894
        ]
    },
    "name": "C. Multi-judge Solving",
    "statement": "Makes solves problems on Decoforces and lots of other different online\r\njudges. Each problem is denoted by its difficulty a positive integer\r\nnumber. Difficulties are measured the same across all the judges (the\r\nproblem with difficulty on Decoforces is as hard as the problem with\r\ndifficulty on any other judge). Makes has chosen problems to solve on\r\nDecoforces with difficulties . He can solve these problems in arbitrary\r\norder. Though he can solve problem with difficulty only if he had\r\nalready solved some problem with difficulty (no matter on what online\r\njudge was it).With given conditions it\u2019s easy to see that Makes\r\nsometimes can\u2019t solve all the chosen problems, no matter what order he\r\nchooses. So he wants to solve some problems on other judges to finish\r\nsolving problems from his list. Makes can solve problems on any judge at\r\nany time, it isn\u2019t necessary to do problems from the chosen list one\r\nright after another.Makes doesn\u2019t have too much free time, so he asked\r\nyou to calculate the minimum number of problems he should solve on other\r\njudges in order to solve all the chosen problems from Decoforces.\r\n",
    "solutions": [
        "#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n\nvoid run(std::istream &in, std::ostream &out) {\n    int n; uint32_t k;\n    in >> n >> k;\n    std::vector<uint32_t> as(n);\n    for (int i = 0; i < n; i++) {\n        in >> as[i];\n    }\n    std::sort(as.begin(), as.end());\n    uint32_t cur = 2 * k;\n    int res = 0;\n    for (uint32_t v : as) {\n        while (v > cur) {\n            res++;\n            cur = cur * 2;\n        }\n        cur = std::max(cur, 2 * v);\n    }\n    out << res << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Multi-judge Solving.json",
    "editorial_link": "https://codeforces.com//blog/entry/53334",
    "editorial": "Obviously sorting the tasks by difficulty will always produce the most\r\noptimal order of solving. In that case ability to solve some task will\r\nmean ability to solve any task from to .Now let\u00e2\u0080\u0099s maintain the upper\r\nlimit of difficulty of problem Makes is able to solve. Right after\r\nsolving some problem it will be . Initially it\u00e2\u0080\u0099s just .Transition from\r\nto will then look like this. If the upper limit it greater or equal to\r\nthen we solve this problem and update the upper limit. Otherwise we will\r\nneed some problems from other judges. As our goal is to maximize the\r\nupper limit, the most optimal task to solve is the hardest possible. So\r\nyou should solve task with the difficulty of upper limit and update the\r\nlimit itself. Keep doing it until upper limit becomes grater or equal to\r\n.You will require no more then tasks from the other judges. By algorithm\r\nit\u00e2\u0080\u0099s easy to see that by solving task with difficulty we update upper\r\nlimit with the value . This function produces such a estimate.Overall\r\ncomplexity: .\r\n"
}