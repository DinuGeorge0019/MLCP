{
    "link": "https://codeforces.com//contest/652/problem/C",
    "problemId": "52870",
    "problem_idx": "C",
    "shortId": "652C",
    "contest_number": "652",
    "problem_submissions": {
        "F": [
            16928285,
            16930373,
            16931256,
            16970841,
            16961705,
            16935106,
            156953099,
            16939325,
            17157478,
            16976822,
            16929598
        ],
        "E": [
            16926440,
            16927126,
            16928485,
            16928041,
            16928079,
            16927963,
            16929010,
            16928885,
            16928945,
            16929000,
            16929278,
            16926493,
            16928821,
            16929439,
            16928127,
            16930840,
            16929731,
            16930544,
            16929622
        ],
        "D": [
            16923853,
            16925192,
            16926960,
            16924196,
            16924625,
            16925554,
            16925730,
            16924207,
            16926093,
            16926313,
            16925298,
            16926004,
            16926568,
            16924529,
            16926045,
            16925170,
            16925998,
            16927190,
            16926470
        ],
        "C": [
            16923132,
            16923717,
            16926036,
            16923304,
            16924095,
            16924304,
            16924230,
            16925378,
            16924383,
            16924805,
            16924428,
            16924018,
            16924971,
            16925484,
            16923795,
            16923653,
            16924997,
            16925262,
            16925278
        ],
        "B": [
            16922478,
            16922741,
            16925620,
            16922710,
            16922792,
            16922869,
            16923264,
            16922610,
            16922818,
            16923450,
            16923095,
            16923418,
            16923515,
            16923547,
            16922822,
            16922672,
            16922783,
            16923327,
            16924223
        ],
        "A": [
            16922372,
            16922446,
            16922797,
            16922454,
            16922532,
            16922643,
            16922693,
            16922430,
            16922460,
            16923027,
            16922810,
            16922924,
            16922740,
            16923101,
            16922457,
            16922433,
            16923996,
            16922614,
            16923536
        ]
    },
    "name": "C. Foe Pairs",
    "statement": "You are given a permutation of length . Also you are given foe pairs ().\r\nYour task is to count the number of different intervals () that do not\r\ncontain any foe pairs. So you shouldn\u2019t count intervals that contain at\r\nleast one foe pair in it (the positions and order of the values from the\r\nfoe pair are not important).Consider some example: and foe pairs are .\r\nThe interval is incorrect because it contains a foe pair . The interval\r\nis also incorrect because it contains two foe pairs and . But the\r\ninterval is correct because it doesn\u2019t contain any foe pair.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nVI p,invp;\nVI mupt;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n,m;\n  cin>>n>>m;\n  p.resize(n);\n  invp.resize(n);\n  forn(i,n){\n    cin>>p[i];\n    --p[i];\n    invp[p[i]]=i;\n  }\n  mupt=VI(n,n-1);\n  in ta,tb;\n  forn(z,m){\n    cin>>ta>>tb;\n    --ta;\n    --tb;\n    ta=invp[ta];\n    tb=invp[tb];\n    if(tb-1>=ta)\n      mupt[ta]=min(mupt[ta],tb-1);\n    if(ta-1>=tb)\n      mupt[tb]=min(mupt[tb],ta-1);\n  }\n  for(in i=n-2;i>=0;--i){\n    mupt[i]=min(mupt[i],mupt[i+1]);\n  }\n  in sm=0;\n  forn(i,n){\n    sm+=mupt[i]-i+1;\n  }\n  cout<<sm<<endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Foe Pairs.json",
    "editorial_link": "https://codeforces.com//blog/entry/43986",
    "editorial": "This is one of the problems suggested by Bayram Berdiyev bayram, Allanur\r\nShiriyev Allanur, Bekmyrat Atayev Bekmyrat.A. Let\u00e2\u0080\u0099s precompute for each\r\nvalue its position in permutation . It\u00e2\u0080\u0099s easy to do in linear time.\r\nConsider some foe pair (we may assume ). Let\u00e2\u0080\u0099s store for each value the\r\nleftmost position such that is a foe pair. Denote that value as . Now\r\nlet\u00e2\u0080\u0099s iterate over the array from right to left and maintain the\r\nposition of the maximal correct interval with the left end in the\r\ncurrent position . To maintain the value we should simply take the\r\nminimum with the value : . And finally we should increment the answer by\r\nthe value . C++ solution\r\n"
}