{"link": "https://codeforces.com//contest/1437/problem/G", "problemId": "775845", "problem_idx": "G", "shortId": "1437G", "contest_number": "1437", "problem_submissions": {"G": [96904215, 96908358, 96911556, 96933769, 96933754, 96933518, 96933473, 96933445, 96933414, 96933394, 96933374, 96932455, 96904310, 96918769, 96918726, 96918674, 96918569, 96915736, 96908201, 96875131, 106175814, 96910852, 96987761, 96907141, 96934887], "F": [96888983, 96900781, 96907021, 96914548, 96914009, 96904550, 96923575, 96889382, 96917076, 96892031, 96900189, 96901851, 96912014, 96916841, 96913488, 97559818, 96910656], "E": [96880914, 96882404, 96885840, 96932444, 96885328, 96892490, 96890860, 96896271, 96896163, 96888156, 96885346, 96887072, 96892577, 96896957, 96895240, 96898636, 97559735, 96897006], "D": [96875179, 96877608, 96875178, 96880944, 96885771, 96877805, 96898190, 96885975, 96876295, 96879122, 96877985, 96883085, 96879709, 96879615, 96881903, 97558972, 96886384], "C": [96871849, 96873242, 96871401, 96937777, 96917473, 96874581, 96876847, 96873952, 96902915, 96882435, 96874057, 96876339, 96874008, 96878071, 96874148, 96873187, 96875974, 97558809, 96872333], "B": [96868094, 96870116, 96868044, 96871520, 96869439, 96870069, 96905187, 96921093, 96871936, 96870828, 96870841, 96868971, 96868275, 96868652, 96869849, 97558720, 96868938], "A": [96867417, 96867598, 96867496, 96867654, 96867506, 96867568, 96906923, 96868396, 96867566, 96869874, 96869082, 96867617, 96867510, 96867621, 96867703, 97558428, 96867545]}, "name": "G. Death DBMS", "statement": "For the simplicity, let\u2019s say that the \"Death Note\" is a notebook that\r\nkills a person when their name is written in it.It\u2019s easy to kill with\r\nit, but it\u2019s pretty hard to keep track of people you haven\u2019t killed and\r\nstill plan to. You decided to make a \"Death Database Management System\"\r\na computer program that provides the easy access to the database of\r\npossible victims. Let me describe its specifications to you.Let\u2019s define\r\na victim entity: a victim has a name (not necessarily unique) that\r\nconsists only of lowercase Latin letters and an integer suspicion\r\nvalue.At the start of the program the user enters a list of n victim\r\nnames into a database, each suspicion value is set to 0.Then the user\r\nmakes queries of two types: 1\u00a0i\u00a0x set the suspicion value of the i-th\r\nvictim to x; 2\u00a0q given a string q find the maximum suspicion value of a\r\nvictim whose name is a contiguous substring of q. Just to remind you,\r\nthis program doesn\u2019t kill people, it only helps to search for the names\r\nto write down in an actual notebook. Thus, the list of the victims in\r\nthe database doesn\u2019t change throughout the queries.What are you waiting\r\nfor? Write that program now!\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nstruct SegTreeNode {\n\tint l, r;\n\tint val;\n\n\tSegTreeNode() : l(-1), r(-1), val(-1) {}\n\tSegTreeNode(int _l, int _r) : l(_l), r(_r), val(-1) {}\n};\nstruct SegmentTree {\n\tvector<SegTreeNode> tree;\n\tint L;\n\n\tSegmentTree() : tree(), L(-1) {}\n\tSegmentTree(int _L) {\n\t\tL = _L;\n\t\twhile(L & (L - 1)) L++;\n\t\ttree.resize(2 * L);\n\t\tfor (int i = 0; i < L; i++)\n\t\t\ttree[L + i] = SegTreeNode(i, i + 1);\n\t\tfor (int i = L - 1; i > 0; i--)\n\t\t\ttree[i] = SegTreeNode(tree[2 * i].l, tree[2 * i + 1].r);\n\t}\n\n\tvoid putInPoint(int v, int x) {\n\t\tv += L;\n\t\ttree[v].val = x;\n\t\twhile(v > 1) {\n\t\t\tv >>= 1;\n\t\t\ttree[v].val = max(tree[2 * v].val, tree[2 * v + 1].val);\n\t\t}\n\t}\n\tint getMax(int v, int l, int r) {\n\t\tif (l <= tree[v].l && tree[v].r <= r) return tree[v].val;\n\t\tif (l >= tree[v].r || tree[v].l >= r) return -1;\n\t\treturn max(getMax(2 * v, l, r), getMax(2 * v + 1, l, r));\n\t}\n};\n\nconst int N = 300300;\nconst int A = 26;\nint n, q;\nint go[N][A];\nint suffLink[N];\nint m;\nchar s[N];\nint a[N];\nint myVert[N];\nmultiset<int> setik[N];\nvector<int> g[N];\nint Q[N];\nint topQ;\nint sz[N];\nint info[N][2];\nint treeSz[N];\nint treePar[N];\nSegmentTree trees[N];\n\nvoid dfsSz(int v) {\n\tsz[v] = 1;\n\tfor (int u : g[v]) {\n\t\tdfsSz(u);\n\t\tsz[v] += sz[u];\n\t}\n}\n\nvoid dfsHLD(int v, int id, int p) {\n\tinfo[v][0] = id;\n\tinfo[v][1] = p;\n\ttreeSz[id] = max(treeSz[id], p + 1);\n\tint big = -1;\n\tfor (int u : g[v]) {\n\t\tif (big == -1 || sz[big] < sz[u])\n\t\t\tbig = u;\n\t}\n\tfor (int u : g[v]) {\n\t\tif (u == big) {\n\t\t\tdfsHLD(u, id, p + 1);\n\t\t} else {\n\t\t\ttreePar[m] = v;\n\t\t\tm++;\n\t\t\tdfsHLD(u, m - 1, 0);\n\t\t}\n\t}\n}\n\nvoid prepare() {\n\tdfsSz(0);\n\tm = 1;\n\ttreePar[0] = -1;\n\tdfsHLD(0, 0, 0);\n\tfor (int i = 0; i < m; i++)\n\t\ttrees[i] = SegmentTree(treeSz[i]);\n}\n\nvoid setVertex(int v, int x) {\n\tint id = info[v][0];\n\ttrees[id].putInPoint(info[v][1], x);\n}\nint getVertex(int v) {\n\tint ans = -1;\n\twhile(v != -1) {\n\t\tint id = info[v][0];\n\t\tans = max(ans, trees[id].getMax(1, 0, info[v][1] + 1));\n\t\tv = treePar[id];\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &q);\n\tm = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", s);\n\t\tint L = strlen(s);\n\t\tint v = 0;\n\t\tfor (int j = 0; j < L; j++) {\n\t\t\tint c = (int)(s[j] - 'a');\n\t\t\tif (go[v][c] == 0) go[v][c] = m++;\n\t\t\tv = go[v][c];\n\t\t}\n\t\tmyVert[i] = v;\n\t}\n\tQ[topQ++] = 0;\n\tsuffLink[0] = -1;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = Q[i];\n\t\tfor (int c = 0; c < A; c++) {\n\t\t\tif (go[v][c] == 0) continue;\n\t\t\tint u = go[v][c];\n\t\t\tint w = suffLink[v];\n\t\t\twhile(w != -1 && go[w][c] == 0) w = suffLink[w];\n\t\t\tif (w == -1)\n\t\t\t\tw = 0;\n\t\t\telse\n\t\t\t\tw = go[w][c];\n\t\t\tsuffLink[u] = w;\n\t\t\tg[w].push_back(u);\n\t\t\tQ[topQ++] = u;\n\t\t}\n\t}\n\tprepare();\n\tfor (int i = 0; i < n; i++) {\n\t\tint v = myVert[i];\n\t\tsetik[v].insert(0);\n\t\tsetVertex(v, 0);\n\t}\n\twhile(q--) {\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tif (t == 1) {\n\t\t\tint p, v, x;\n\t\t\tscanf(\"%d%d\", &p, &x);\n\t\t\tp--;\n\t\t\tv = myVert[p];\n\t\t\tsetik[v].erase(setik[v].find(a[p]));\n\t\t\ta[p] = x;\n\t\t\tsetik[v].insert(x);\n\t\t\tsetVertex(v, *setik[v].rbegin());\n\t\t} else {\n\t\t\tscanf(\"%s\", s);\n\t\t\tint L = strlen(s);\n\t\t\tint v = 0;\n\t\t\tint ans = -1;\n\t\t\tfor (int i = 0; i < L; i++) {\n\t\t\t\tint c = (int)(s[i] - 'a');\n\t\t\t\twhile(v != -1 && go[v][c] == 0) v = suffLink[v];\n\t\t\t\tif (v == -1)\n\t\t\t\t\tv = 0;\n\t\t\t\telse\n\t\t\t\t\tv = go[v][c];\n\t\t\t\tans = max(ans, getVertex(v));\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "string suffix structures", "strings", "trees"], "dificulty": "2600", "interactive": false}