{
    "link": "https://codeforces.com//contest/1680/problem/E",
    "problemId": "1398259",
    "problem_idx": "E",
    "shortId": "1680E",
    "contest_number": "1680",
    "problem_submissions": {
        "F": [
            157047850,
            157060684,
            157042836,
            157059615,
            157060798,
            158084238,
            157065404,
            157062967,
            157061917,
            157070522,
            157068911,
            157063520,
            157068892,
            157055321,
            157070359,
            157059828,
            157067724,
            157073079,
            157081810,
            157079385,
            157105181
        ],
        "E": [
            157041040,
            157049624,
            157047687,
            157040462,
            157036732,
            157047646,
            157052435,
            157048797,
            157052165,
            157051933,
            157052874,
            157059209,
            157046788,
            157045330,
            157056328,
            157052190,
            157048507,
            157050045,
            157051601,
            157048385
        ],
        "D": [
            157034306,
            157035182,
            157038681,
            157048294,
            158084226,
            157074494,
            157044699,
            157036339,
            157047488,
            157040348,
            157044725,
            157050170,
            157047151,
            157062708,
            157050690,
            157073571,
            157048489,
            157064425,
            157042063,
            157043656,
            157043396,
            157043910
        ],
        "C": [
            157027102,
            157026046,
            157029273,
            157029023,
            158084216,
            157023897,
            157025338,
            157028892,
            157029198,
            157031553,
            157033288,
            157030228,
            157028759,
            157029727,
            157032895,
            157036498,
            157043784,
            157026230,
            157030697,
            157031960,
            157038763
        ],
        "B": [
            157018674,
            157018124,
            157022874,
            157018932,
            157018732,
            157019545,
            157018987,
            157019892,
            157025559,
            157018220,
            157022589,
            157021909,
            157021994,
            157021310,
            157023912,
            157020972,
            157018915,
            157021224,
            157020613,
            157022918
        ],
        "A": [
            157018002,
            157017909,
            157018617,
            157017994,
            157017953,
            157018014,
            157018037,
            157018035,
            157019519,
            157017930,
            157031859,
            157018590,
            157019204,
            157018082,
            157018046,
            157018257,
            157017944,
            157018274,
            157018303,
            157018968
        ]
    },
    "name": "E. Moving Chips",
    "statement": "You are given a board of size 2\r\ntimes n (2 rows, n columns). Some cells of the board contain chips. The\r\nchip is represented as ”, and an empty space is represented as ”. It is\r\nguaranteed that there is at least one chip on the board.In one move, you\r\ncan choose chip and move it to any adjacent (by side) cell of the board\r\n(if this cell is inside the board). It means that if the chip is in the\r\nfirst row, you can move it left, right or down (but it shouldn’t leave\r\nthe board). Same, if the chip is in the second row, you can move it\r\nleft, right or up.If the chip moves to the cell with another chip, the\r\nchip in the destination cell disappears (i. e. our chip captures\r\nit).Your task is to calculate the number of moves required to leave one\r\nchip on the board.You have to answer t independent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<string> s(2);\n\tfor(string& x : s) cin >> x;\n\tvector<int> dp(4, 1e9);\n\tdp[3] = 0;\n\t// e1, e2, conn\n\tint last_cell = 0;\n\tint first_cell = -1;\n\tfor(int i = 0; i < n; i++){\n\t\tif(s[0][i] == '*' || s[1][i] == '*'){\n\t\t\tlast_cell = i;\n\t\t\tif(first_cell == -1) first_cell = i;\n\t\t}\n\t}\n\tfor(int i = first_cell; i <= last_cell; i++){\n\t\tvector<int> ndp(4, 1e9);\n\t\tfor(int g = 0; g < 4; g++){\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tif((g & a) == 0) continue;\n\t\t\t\tif(!(a & 1) && s[0][i] == '*') continue;\n\t\t\t\tif(!(a & 2) && s[1][i] == '*') continue;\n\t\t\t\tndp[a] = min(ndp[a], dp[g] + __builtin_popcount(a));\n\t\t\t}\n\t\t}\n\t\tdp = ndp;\n\t}\n\tint ans = 1e9;\n\tfor(int x : dp){\n\t\tans = min(ans, x);\n\t}\n\tcout << (ans - 1) << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Moving Chips.json",
    "editorial_link": "https://codeforces.com//blog/entry/102852",
    "editorial": "Firstly, I want to say a few words about the difficulty of this problem.\r\nTill the last moment, we didnât know easy to prove (and easy to write)\r\nsolutions, so we decided that this is a good problem E. But now we\r\nrealized it is a lot easier than we expected.Now, letâs talk about the\r\nsolution. At the beginning, letâs remove redundant columns from the\r\nbeginning and from the end (i. e. columns without chips) and change the\r\nvalue correspondingly. Now, let be if is â, and otherwise. This array\r\nneeded to make the implementation easier.Letâs calculate the dynamic\r\nprogramming , where is the index of the last processed column and is the\r\nnumber of the row where our chip is standing. This seems a bit\r\nsuspicious why we can calculate such a dynamic programming, so letâs\r\nexplain some things about it. It can be shown that in the optimal answer\r\nthere will be some column where the last move happens. And if the number\r\nof this column is then all chips to the left of will move only to the\r\nright and all chips to the right of will move only to the left.\r\nActually, we can always consider that is the last column. Consider paths\r\nof two chips that will survive till the last move. The first chip is to\r\nthe left of and will move only to the right, and the second one is to\r\nthe right of and will move only to the left. Then we can replicate the\r\npath of the second chip in the reverse order using the first chip. So\r\nthe second chip can stay still until the last move. In the optimal\r\nanswer, it is always better to have exactly one chip in the current\r\ncolumn, because moving two chips to the right is always worse than just\r\neat one of them and move the remaining one. Initial states of are except\r\nthe values of the first column. For the first column, and . The answer\r\nwill be .Okay, how to make transitions from ? For all from to , letâs\r\nconsider four cases: here we need one move to go to the next column and,\r\nprobably, one more move to delete the figure in the second row in the\r\ncolumn . So the transition seems like ; same as the previous transition,\r\n; because the cost of this transition is always (the distance between\r\nthese cells is ), we just go firstly to the right and then down (to\r\nensure that we eat the figure in the first row). So the transition is ;\r\nsame as the previous transition, . Time complexity: .\r\n",
    "hint": []
}