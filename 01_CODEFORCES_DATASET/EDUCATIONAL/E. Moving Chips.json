{"link": "https://codeforces.com//contest/1680/problem/E", "problemId": "1398259", "problem_idx": "E", "shortId": "1680E", "contest_number": "1680", "problem_submissions": {"F": [157047850, 157060684, 157042836, 157059615, 157060798, 158084238, 157065404, 157062967, 157061917, 157070522, 157068911, 157063520, 157068892, 157055321, 157070359, 157059828, 157067724, 157073079, 157081810, 157079385, 157105181], "E": [157041040, 157049624, 157047687, 157040462, 157036732, 157047646, 157052435, 157048797, 157052165, 157051933, 157052874, 157059209, 157046788, 157045330, 157056328, 157052190, 157048507, 157050045, 157051601, 157048385], "D": [157034306, 157035182, 157038681, 157048294, 158084226, 157074494, 157044699, 157036339, 157047488, 157040348, 157044725, 157050170, 157047151, 157062708, 157050690, 157073571, 157048489, 157064425, 157042063, 157043656, 157043396, 157043910], "C": [157027102, 157026046, 157029273, 157029023, 158084216, 157023897, 157025338, 157028892, 157029198, 157031553, 157033288, 157030228, 157028759, 157029727, 157032895, 157036498, 157043784, 157026230, 157030697, 157031960, 157038763], "B": [157018674, 157018124, 157022874, 157018932, 157018732, 157019545, 157018987, 157019892, 157025559, 157018220, 157022589, 157021909, 157021994, 157021310, 157023912, 157020972, 157018915, 157021224, 157020613, 157022918], "A": [157018002, 157017909, 157018617, 157017994, 157017953, 157018014, 157018037, 157018035, 157019519, 157017930, 157031859, 157018590, 157019204, 157018082, 157018046, 157018257, 157017944, 157018274, 157018303, 157018968]}, "name": "E. Moving Chips", "statement": "You are given a board of size 2\r\ntimes n (2 rows, n columns). Some cells of the board contain chips. The\r\nchip is represented as \u201d, and an empty space is represented as \u201d. It is\r\nguaranteed that there is at least one chip on the board.In one move, you\r\ncan choose chip and move it to any adjacent (by side) cell of the board\r\n(if this cell is inside the board). It means that if the chip is in the\r\nfirst row, you can move it left, right or down (but it shouldn\u2019t leave\r\nthe board). Same, if the chip is in the second row, you can move it\r\nleft, right or up.If the chip moves to the cell with another chip, the\r\nchip in the destination cell disappears (i. e. our chip captures\r\nit).Your task is to calculate the number of moves required to leave one\r\nchip on the board.You have to answer t independent test cases.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n;\n\tcin >> n;\n\tvector<string> s(2);\n\tfor(string& x : s) cin >> x;\n\tvector<int> dp(4, 1e9);\n\tdp[3] = 0;\n\t// e1, e2, conn\n\tint last_cell = 0;\n\tint first_cell = -1;\n\tfor(int i = 0; i < n; i++){\n\t\tif(s[0][i] == '*' || s[1][i] == '*'){\n\t\t\tlast_cell = i;\n\t\t\tif(first_cell == -1) first_cell = i;\n\t\t}\n\t}\n\tfor(int i = first_cell; i <= last_cell; i++){\n\t\tvector<int> ndp(4, 1e9);\n\t\tfor(int g = 0; g < 4; g++){\n\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\tif((g & a) == 0) continue;\n\t\t\t\tif(!(a & 1) && s[0][i] == '*') continue;\n\t\t\t\tif(!(a & 2) && s[1][i] == '*') continue;\n\t\t\t\tndp[a] = min(ndp[a], dp[g] + __builtin_popcount(a));\n\t\t\t}\n\t\t}\n\t\tdp = ndp;\n\t}\n\tint ans = 1e9;\n\tfor(int x : dp){\n\t\tans = min(ans, x);\n\t}\n\tcout << (ans - 1) << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"], "input": "", "output": "", "tags": ["bitmasks", "dp", "greedy"], "dificulty": "2000", "interactive": false}