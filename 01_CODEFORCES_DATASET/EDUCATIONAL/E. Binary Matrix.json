{"link": "https://codeforces.com//contest/884/problem/E", "problemId": "130891", "problem_idx": "E", "shortId": "884E", "contest_number": "884", "problem_submissions": {"F": [31808128, 31809259, 31810428, 31811126, 31807028, 31810125, 31808407, 31808014, 31873745, 31808068, 31810481, 70767801, 36469296, 36469289, 31909919, 31809387, 31822510, 31808175, 31811034], "E": [31805401, 31807388, 31807565, 31808478, 31804019, 31805975, 31805687, 31805755, 31841462, 31810079, 31810699, 31810217, 31811063, 31809732, 31810149], "D": [31802703, 31804699, 31804124, 31804641, 31808138, 31803343, 31802113, 31801774, 31802510, 31803536, 31804976, 31801949, 31805944, 31805607, 31803821, 31809103, 31803969, 31818412, 31806095], "C": [31800883, 31800607, 31802838, 31802069, 31799616, 31802362, 31800429, 31800236, 31800839, 31801291, 31801670, 31800496, 31801796, 31802338, 31801055, 31801861, 31801455, 31800685, 31802138], "B": [31799211, 31799036, 31801939, 31801321, 31801497, 31798756, 31799168, 31799265, 31799895, 31799341, 31799382, 31800133, 31800205, 31799009, 31800238, 31799378, 31799257, 31800274], "A": [31798352, 31798382, 31801358, 31800677, 31801116, 31798306, 31798460, 31798672, 31798979, 31798397, 31798744, 31798807, 31798611, 31798307, 31798790, 31798478, 31798275, 31799367]}, "name": "E. Binary Matrix", "statement": "You are given a matrix of size . Each element of the matrix is either 1\r\nor 0. You have to determine the number of connected components\r\nconsisting of 1\u2019s. Two cells belong to the same component if they have a\r\ncommon border, and both elements in these cells are 1\u2019s.\r\n", "solutions": ["#include <vector>\n#include <cstdio>\n#include <iterator>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <functional>\n#include <array>\n\n\nstruct Range\n{   \n    struct It {   int num, step; int operator*(){return num;} void operator++(){num += step;} bool operator!=(const It& other){return num != other.num;} };\n    Range(int ee):b(0),e(ee){}\n    Range(int bb, int ee):b(bb), e(ee){}\n    It begin(){return {b, (b < e? 1: -1)};}\n    It end(){return {e, 0};}\n    int b, e;\n};\n\ntemplate<typename T> inline T& UMAX(T& x, T y){if(x < y)x = y; return x;}\ntemplate<typename T> inline T& UMIN(T& x, T y){if(y < x)x = y; return x;}\ntemplate<typename T, typename... Args> struct ArithmiticPromotion { typedef decltype(T() + typename ArithmiticPromotion<Args...>::type()) type; };\ntemplate<typename T, typename U> struct ArithmiticPromotion<T, U> { typedef decltype(T() + U()) type; };\ntemplate<typename T> struct ArithmiticPromotion<T, T> { typedef T type; };\ntemplate<typename T> struct ArithmiticPromotion<T> { typedef T type; };\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MAX(T a, U b) { return a < b? b: a; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MAX(T a, Args... args) { return MAX(a, MAX(args...)); }\ntemplate<typename T, typename U> typename ArithmiticPromotion<T, U>::type MIN(T a, U b) { return a < b? a: b; }\ntemplate<typename T, typename... Args> typename ArithmiticPromotion<T, Args...>::type MIN(T a, Args... args) { return MIN(a, MIN(args...)); }\n\n\n\ntemplate<typename T> struct ScanfSpecifier{};\n#define DEF(T,V) template<> struct ScanfSpecifier<T>{static constexpr const char* value = V;};\nDEF(char*,\"%s\")DEF(int,\"%d\")DEF(double,\"%lf\")DEF(float,\"%f\")DEF(char,\"%c\")DEF(const char*,\"%s\")DEF(unsigned long,\"%lu\")DEF(unsigned int, \"%u\")DEF(long double, \"%Lf\")\n#ifdef _MSC_VER\nDEF(long long int,\"%I64d\")\n#else\nDEF(long long int,\"%lld\")\n#endif\n#undef DEF\ntemplate<typename T> int RD(T& arg){return std::scanf(ScanfSpecifier<T>::value, &arg);}\ntemplate<int S> int RD(char (&arg)[S]){return std::scanf(\"%s\", arg);}\nint RD(char* arg){return std::scanf(\"%s\", arg);}\ntemplate<> int RD<char>(char& arg){return std::scanf(\" %c\", &arg);}\ntemplate<typename T, typename... Args> int RD(T& arg1, Args&... args) {return RD(arg1) + RD(args...);}\ntemplate<typename T> T RD(){T ret; RD(ret); return ret;}\ntemplate<typename It> void RDV(It begin, It end) { while(begin != end) RD(*begin++); }\ntemplate<typename C> void RDV(C& c) {RDV(std::begin(c), std::end(c));}\ntemplate<typename T> void WT(T arg) {std::printf(ScanfSpecifier<T>::value, arg); }\ntemplate<typename T, typename U> void WT(std::pair<T, U> arg) {std::printf(\"(\"); WT(arg.first); std::printf(\", \"); WT(arg.second); std::printf(\")\");}\ntemplate<typename... Args> void WT(Args... args) { int alc = 0; int dummy[] = {((alc++? std::printf(\" \"): 0), WT(args), 0)...}; }\n\ntemplate<typename... Args> void WTL(Args... args) { WT(args...); std::printf(\"\\n\"); }\ntemplate<typename It> void WTV(It begin, It end) { int alc = 0; while(begin != end) (alc++? std::printf(\" \"): 0), WT(*begin++); }\ntemplate<typename C> void WTV(const C& c) {WTV(std::begin(c), std::end(c));}\ntemplate<typename It> void WTVL(It begin, It end) { WTV(begin, end); std::printf(\"\\n\"); }\ntemplate<typename C> void WTVL(const C& c) {WTVL(std::begin(c), std::end(c));}\n\n#define _M_VARGS_NUM_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define _M_VARGS_NUM(...) _M_VARGS_NUM_IMPL(__VA_ARGS__, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n#define _W1(_1) (#_1[0] == '\"' || #_1[0] == '\\''? WT(\"\", _1, \"\"): WT('[', #_1, '=', _1, ']'))\n#define _W2(_1, _2) (_W1(_1), _W1(_2))\n#define _W3(_1, _2, _3) (_W1(_1), _W2(_2, _3))\n#define _W4(_1, _2, _3, _4) (_W1(_1), _W3(_2, _3, _4))\n#define _W5(_1, _2, _3, _4, _5) (_W1(_1), _W4(_2, _3, _4, _5))\n#define _W6(_1, _2, _3, _4, _5, _6) (_W1(_1), _W5(_2, _3, _4, _5, _6))\n#define _W7(_1, _2, _3, _4, _5, _6, _7) (_W1(_1), _W6(_2, _3, _4, _5, _6, _7))\n#define _W8(_1, _2, _3, _4, _5, _6, _7, _8) (_W1(_1), _W7(_2, _3, _4, _5, _6, _7, _8))\n#define _WW_IMPL2(num, ...) _W ## num(__VA_ARGS__)\n#define _WW_IMPL(num, ...) _WW_IMPL2(num, __VA_ARGS__)\n#define WW(...) (std::printf(\"(%03d) \", __LINE__), _WW_IMPL(_M_VARGS_NUM(__VA_ARGS__), __VA_ARGS__), WTL(\"\"))\n\n\n\nnamespace XX\n{\n    template<typename... Datas>\n    struct UnionFind\n    {\n            struct Node:public Datas...\n            {\n                int _parent = -1;\n                void operator+=(Node& other) { int dummy[] = {(Datas::operator+=(other), 0)...}; }\n            };\n            UnionFind(int size = 0) :_data(size, Node()) {}\n\n            void resize(int size)\n            {\n                _data.resize(size, Node());\n            }\n\n            int size()\n            {\n                return _data.size();\n            }\n\n            Node& operator[](int idx) { return _data[(*this)(idx)]; }\n\n            int operator()(int n)\n            {\n                if(_data[n]._parent < 0)\n                    return n;\n                else\n                    return _data[n]._parent = (*this)(_data[n]._parent);\n            }\n\n            bool operator()(int a, int b)\n            {\n                int pa = (*this)(a), pb = (*this)(b);\n                if(pa == pb)\n                    return false;\n                else\n                {\n                    if(_data[pa]._parent == _data[pb]._parent)\n                        _data[pa]._parent--;\n                    else if(_data[pa]._parent > _data[pb]._parent)\n                        std::swap(pa, pb);\n\n                    _data[pa] += _data[pb];\n                    _data[pb]._parent = pa;\n                    return true;\n                }\n            }\n\n            std::vector<Node> _data;\n    };\n}\n\n\n\n\n\n\n\n\n//alias\n//for union/find\ntemplate<typename... Datas>\nusing UF = XX::UnionFind<Datas...>; \n//RD[L],RDV[L],WT[L],WTV[L] for i/o\nusing RG = Range;\n//template\n#include <vector>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long int ll;\n\nconst int R = 1 << 15;\nint last[R];\n\nstruct Data\n{\n    int num = 0;\n    void operator+=(Data&){}\n};\n\nint main()\n{\n    int ans = 0;\n    int N, M;\n    RD(N, M);\n    int now = 0;\n\n    for(int i: RG(N))\n    {\n        int buf[R] = {};\n        int pass[R] = {};\n\n        UF<Data> uf(M + 1);\n        int ex = 0;\n\n        for(int j: RG(M / 4))\n        {\n            char c;\n            RD(c);\n\n            if(c >= 'A')\n                c = c - 'A' + 10;\n            else\n                c -= '0';\n\n //           for(int k: RG(4))\n   //             WT(c >> (3 - k) & 1);\n            for(int k: RG(4))\n                if(c >> (3 - k) & 1)\n                {\n                    int pos = j * 4 + k;\n                    int id;\n                    if(last[pos])\n                        id = last[pos];\n                    else\n                        id = now + ++ex;\n\n                    buf[pos] = id;\n                    pass[id] = true;\n                    if(pos && buf[pos - 1])\n                        uf(buf[pos - 1], buf[pos]);\n                }\n        }\n\n//        WTL();\n\n        int alc = 0;\n        for(int j: RG(1, now + ex + 1))\n            if(!pass[j])\n                ans++;\n            else if(!uf[j].num)\n                uf[j].num = ++alc;\n\n        for(int j: RG(M))\n            if(buf[j])\n                last[j] = uf[buf[j]].num;\n            else\n                last[j] = 0;\n        now = alc;\n\n        //WTVL(last, last + M);\n    }\n\n    ans += now;\n\n    WTL(ans);\n\n\n}\n\n\n\n\n"], "input": "", "output": "", "tags": ["dsu"], "dificulty": "2500", "interactive": false}