{"link": "https://codeforces.com//contest/1312/problem/F", "problemId": "557982", "problem_idx": "F", "shortId": "1312F", "contest_number": "1312", "problem_submissions": {"G": [72824912, 72825940, 72832858, 72832125, 72830981, 72830579, 72827258, 72818410, 73118157, 72832195, 72826680, 72837006, 72831183, 72846291, 72845347, 72835299, 72834657, 72834166, 72836122, 72834407, 72826975, 72828977, 72837738, 72829233, 72828895, 72814710], "F": [72816196, 72815449, 72836440, 72835939, 72833544, 72818707, 72831850, 73118148, 72823917, 72821869, 72817848, 72823973, 72825602, 72821962, 72825661, 72827867, 72825004, 72836754, 72835570, 72830789, 72837405, 72824053, 72824708], "E": [72807538, 72806508, 72938781, 72938462, 72938238, 72849613, 72849474, 72839861, 72834168, 72811533, 72810583, 73118128, 72810138, 72811240, 72806275, 72810780, 72813492, 72813999, 72814345, 72819726, 72816559, 72814069, 72818755, 72815412, 72820356, 72810691, 72826172], "D": [72804418, 72803272, 72940991, 72940962, 72801330, 72805787, 73118118, 72807156, 72809073, 86477031, 72803786, 72808232, 72806322, 72805660, 72809462, 72812808, 72814419, 72810586, 72812917, 72812165, 72817006, 72832064, 72827740], "C": [72798692, 72799958, 72796730, 72804789, 73118106, 72800009, 72800362, 72797813, 72800910, 72799283, 72799712, 72801433, 72802442, 72813095, 72802040, 72808078, 72800616, 72812371, 72830092, 72828590], "B": [72793777, 72794214, 72793197, 72797455, 73118103, 72795859, 72796621, 72793808, 72794859, 72794981, 72794667, 72795692, 72795259, 72794528, 72797051, 72796632, 72795714, 72810192, 72793542, 72829098], "A": [72792172, 72792542, 72792143, 72792487, 73118076, 72793403, 72793192, 72792295, 72792118, 72792591, 72792492, 72792213, 72792502, 72792229, 72794177, 72793376, 72792458, 72809334, 72829278, 72829336]}, "name": "F. Attack on Red Kingdom", "statement": "The Red Kingdom is attacked by the White King and the Black King!The\r\nKingdom is guarded by n castles, the i-th castle is defended by a_i\r\nsoldiers. To conquer the Red Kingdom, the Kings have to eliminate all\r\nthe defenders. Each day the White King launches an attack on one of the\r\ncastles. Then, at night, the forces of the Black King attack a castle\r\n(possibly the same one). Then the White King attacks a castle, then the\r\nBlack King, and so on. The first attack is performed by the White\r\nKing.Each attack must target a castle with alive defender in it. There\r\nare three types of attacks: a decreases the number of defenders in the\r\ntargeted castle by x (or sets it to 0 if there are already less than x\r\ndefenders); an decreases the number of defenders in the targeted castle\r\nby y (or sets it to 0 if there are already less than y defenders); a\r\ndecreases the number of defenders in the targeted castle by z (or sets\r\nit to 0 if there are already less than z defenders). The can be launched\r\nat any valid target (at any castle with at least one soldier). However,\r\nthe cannot be launched if the had the same type, no matter when and by\r\nwhom it was launched. The same applies to the . A castle that was not\r\nattacked at all can be targeted by any type of attack.The King who\r\nlaunches the last attack will be glorified as the conqueror of the Red\r\nKingdom, so both Kings want to launch the last attack (and they are wise\r\nenough to find a strategy that allows them to do it no matter what are\r\nthe actions of their opponent, if such strategy exists). The White King\r\nis leading his first attack, and you are responsible for planning it.\r\nCan you calculate the number of possible options for the first attack\r\nthat allow the White King to launch the last attack? Each option for the\r\nfirst attack is represented by the targeted castle and the type of\r\nattack, and two options are different if the targeted castles or the\r\ntypes of attack are different.\r\n", "solutions": ["#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint tst;\nint n, x, y, z;\nconst int BUBEN = 1000;\nint dp[BUBEN][3];\nint val[3];\nbool ok[5];\nint calc() {\n    memset(dp, 0, sizeof dp);\n    for (int i = 0; i < BUBEN; i++) {\n        for (int j = 0; j < 3; j++) {\n            memset(ok, 0, sizeof ok);\n            if (i == 0) {\n                dp[i][j] = 0;\n                continue;\n            }\n            for (int p = 0; p < 3; p++) {\n                if (j == p && j != 0) continue;\n                int ni = max(0, i - val[p]);\n                ok[dp[ni][p]] = true;\n            }\n            while (ok[dp[i][j]]) dp[i][j]++;\n        }\n    }\n    for (int per = 1; 2 * per < BUBEN; per++) {\n        bool ok  = true;\n        for (int i = 100; i + per  < BUBEN; i++) {\n            if (!ok) break;\n            for (int j = 0; j < 3; j++) {\n                if (dp[i][j] != dp[i + per][j]) {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n        if (ok) return per;\n    }\n    return -1;\n}\nconst int maxN = 3 * (int)1e5 + 10;\nll a[maxN];\nvoid solve() {\n    cin >> n >> x >> y >> z;\n    val[0] = x; val[1] = y; val[2] = z;\n    int xr = 0;\n    int per = calc();\n    assert(per != -1);\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n        if (a[i] >= 1000) {\n            a[i] = a[i] % per + per * ((100 + per - 1) / per);\n        }\n        xr ^= dp[a[i]][0];\n    }\n    if (xr == 0) {\n        cout << 0 << '\\n';\n    }\n    else {\n        int cnt = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                if ((xr ^ dp[a[i]][0]) == dp[max(0LL, a[i] - val[j])][j]) cnt++;\n            }\n        }\n        assert(cnt);\n        cout << cnt << '\\n';\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> tst;\n    while (tst--) solve();\n    return 0;\n}"], "input": "", "output": "", "tags": ["games", "two pointers"], "dificulty": "2500", "interactive": false}