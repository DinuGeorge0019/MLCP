{
    "link": "https://codeforces.com//contest/1612/problem/G",
    "problemId": "1198241",
    "problem_idx": "G",
    "shortId": "1612G",
    "contest_number": "1612",
    "problem_submissions": {
        "F": [
            136454446,
            136443408,
            136448569,
            136447134,
            136456076,
            136455474,
            136456753,
            136447271,
            136463331,
            136457585,
            136451795,
            136455146,
            136466801,
            136458322,
            136466012,
            136470454,
            136470912,
            136437898,
            136449817
        ],
        "G": [
            136441097,
            136445642,
            136443193,
            136435909,
            136444442,
            136447874,
            136444457,
            136453773,
            136451816,
            136466000,
            136464894,
            136468423,
            136436868,
            136467114,
            136451881,
            136455169,
            136439762,
            136431665,
            136483294,
            136433577,
            136448604
        ],
        "E": [
            136432700,
            136437971,
            136478291,
            136437457,
            136451828,
            136439707,
            136440209,
            136458464,
            136439310,
            136440686,
            136441493,
            136444282,
            136445062,
            136445391,
            136571543,
            136452932,
            136447870,
            136444392,
            136446716,
            136451569,
            136449325,
            136458083,
            136453137,
            136438833
        ],
        "D": [
            136427875,
            136432221,
            136431776,
            136429717,
            136432159,
            136428903,
            136429714,
            136434455,
            136434329,
            136431021,
            136438170,
            136439001,
            136445408,
            136437693,
            136436906,
            136425598,
            136443833,
            136454774,
            136454860,
            136431686
        ],
        "C": [
            136427045,
            136429953,
            136429634,
            136424300,
            136429072,
            136425761,
            136426268,
            136430944,
            136430349,
            136427934,
            136434022,
            136430101,
            136430333,
            136432880,
            136433170,
            136439471,
            136433291,
            136452483,
            136456465,
            136428370
        ],
        "B": [
            136424559,
            136426931,
            136427614,
            136426640,
            136425629,
            136432355,
            136424153,
            136427726,
            136427375,
            136424825,
            136429445,
            136426911,
            136426490,
            136429175,
            136430275,
            136436731,
            136428475,
            136450629,
            136459018,
            136425566
        ],
        "A": [
            136423641,
            136423524,
            136423454,
            136423614,
            136423605,
            136434187,
            136423437,
            136423664,
            136423746,
            136423549,
            136423622,
            136423647,
            136423440,
            136424189,
            136425302,
            136430159,
            136424218,
            136448121,
            136459267,
            136423589
        ]
    },
    "name": "G. Max Sum Array",
    "statement": "You are given an array c = [c_1, c_2,\r\ndots, c_m]. An array a = [a_1, a_2,\r\ndots, a_n] is constructed in such a way that it consists of integers 1,\r\n2,\r\ndots, m, and for each i\r\nin [1,m], there are exactly c_i occurrences of integer i in a. So, the\r\nnumber of elements in a is exactly\r\nsum\r\nlimits_{i=1}^{m} c_i.Let\u2019s define for such array a the value f(a) as\r\nf(a) =\r\nsum_{\r\nsubstack{1\r\nle i < j\r\nle n\r\na_i = a_j}}{j - i}.In other words, f(a) is the total sum of distances\r\nbetween all pairs of equal elements.Your task is to calculate the\r\nmaximum possible value of f(a) and the number of arrays yielding the\r\nmaximum possible value of f(a). Two arrays are considered different, if\r\nelements at some position differ.\r\n",
    "solutions": [
        "// xtqqwq\n#include<bits/stdc++.h>\n\n#define pb push_back\n#define fi first\n#define se second\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int N=1000000,cys=1000000007;\nint n;\nll a[500005],s[2000005],fac[500005];\n\nint main(){\n\tn=readint();\n\tfor(int i=1;i<=n;i++) a[i]=readint();\n\tfor(int i=1;i<=n;i++) s[N-a[i]+1]++,s[N+a[i]+1]--;\n\tfor(int i=2;i<=N+N;i++) s[i]+=s[i-2];\n\tll now=0;\n\tfor(int i=1;i<=n;i++) now+=a[i];\n\tfac[0]=1;\n\tfor(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%cys;\n\tll ans=0,res=1;\n\tfor(int i=N+N;i>=0;i--){\n\t\tif(!s[i]) continue;\n\t\tll tmp=(now+now-s[i]+1)%cys*s[i]%cys*((cys+1)/2)%cys;\n\t\tans=(ans+tmp*((i-N)%cys+cys))%cys;\n\t\tres=res*fac[s[i]]%cys;\n\t\tnow-=s[i];\n\t}\n\tprintf(\"%lld %lld\\n\",ans,res);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "greedy",
        "sortings"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Max Sum Array.json",
    "editorial_link": "https://codeforces.com//blog/entry/97164",
    "editorial": "Firstly, let\u00e2\u0080\u0099s prove that at first and last positions of the most\r\nfrequent elements should be placed (but not necessary the same). WLOG,\r\nlet\u00e2\u0080\u0099s prove that for any . By contradiction, let\u00e2\u0080\u0099s be the smallest index\r\nsuch that . What happens if we swap them? Since is the first such index\r\nthen there are no for , so \"contribution\" of will increase by exactly .\r\nFrom the other side, contribution of consists of two parts: pairs with\r\nelements from and from . For all elements from decrease will be equal to\r\nand from elements in .So, the total decrease after moving to position\r\nequal to . The total difference in such case is equal to . So, our\r\nplacement is not optimal contradiction.Let\u00e2\u0080\u0099s suggest that there is\r\nexactly one with maximum . According to what we proved earlier, both and\r\nmust be equal to . Contribution of the first and last elements will be\r\nequal to: for pair and for each element () with we add for pairs and .\r\nSo, the total contribution of is equal to .Note that this contribution\r\nis independent of positions of other in the array , so that\u00e2\u0080\u0099s why we can\r\ncut first and last elements of and solve the task\r\nrecursively.Unfortunately, in the initial task we may have several with\r\nmaximum . But we in the similar manner can prove that the first (and\r\nlast) elements should be some permutation of . Now, let\u00e2\u0080\u0099s prove that any\r\npermutation of first and last elements is optimal.Suppose, positions of\r\nare () and (). Then the contribution of is equal to . The total\r\ncontribution of all is . This contribution doesn\u00e2\u0080\u0099t depend on chosen and\r\n, so any permutation of first elements and any permutation of last\r\nelements give optimal answer.As a result, the algorithm is following:\r\nFind all maximums in . If then any permutation of remaining elements has\r\n(there are such permutations). Otherwise, add to the total balance, and\r\nmultiply the number of variants by . Cut prefix and suffix by making for\r\neach (obviously, ) and repeat the whole process. We can implement the\r\nalgorithm fast if we keep the number of equal to each from to (). So the\r\ntotal complexity is .\r\n"
}