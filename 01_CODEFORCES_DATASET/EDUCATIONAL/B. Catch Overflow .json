{
    "link": "https://codeforces.com//contest/1175/problem/B",
    "problemId": "354214",
    "problem_idx": "B",
    "shortId": "1175B",
    "contest_number": "1175",
    "problem_submissions": {
        "E": [
            55152697,
            55143297,
            55144842,
            55149453,
            55145090,
            55152529,
            55156277,
            55145238,
            55141766,
            55151809,
            55150612,
            55150119,
            55150752,
            55156812,
            55152738,
            55154944,
            55150125,
            55154652,
            55158266,
            55163765
        ],
        "F": [
            55143004,
            55151795,
            55152215,
            55142312,
            55154601,
            55143715,
            55151506,
            55166103,
            55151247,
            55162817,
            55160160,
            55154302,
            55159983,
            55153216,
            55161466,
            55160616,
            55159270,
            55167756,
            76726554,
            55159045
        ],
        "D": [
            55137941,
            55140293,
            55140750,
            55145972,
            55139564,
            55144646,
            55138002,
            55141894,
            55136780,
            55138695,
            55141164,
            55144507,
            55139116,
            55139569,
            55142712,
            55138367,
            55143330,
            55142605,
            55147375,
            55147140
        ],
        "C": [
            55134609,
            55137594,
            55139019,
            55137598,
            55135791,
            55137314,
            55136601,
            55136692,
            55135046,
            55136312,
            55137446,
            55142893,
            55137610,
            55138266,
            55140998,
            55137003,
            55146366,
            55138295,
            55140586,
            55141407
        ],
        "B": [
            55132016,
            55133684,
            55136306,
            55134307,
            55133707,
            55134207,
            55135033,
            55133685,
            55171853,
            55133665,
            55137967,
            55138315,
            55133858,
            55138192,
            55135842,
            55133934,
            55137057,
            55134510,
            55135402,
            55137596
        ],
        "A": [
            55129715,
            55129741,
            55129684,
            55129658,
            55129917,
            55129679,
            55130628,
            55129791,
            55130186,
            55130042,
            55129731,
            55135937,
            55130056,
            55130398,
            55129926,
            55129655,
            55132057,
            55130203,
            55131132,
            55132516
        ],
        "G": [
            55169838,
            55219359,
            58237199,
            55161904,
            55163020
        ]
    },
    "name": "B. Catch Overflow ",
    "statement": "You are given a function f written in some basic language. The function\r\naccepts an integer value, which is immediately written into some\r\nvariable x. x is an integer variable and can be assigned values from 0\r\nto 2^{32}-1. The function contains three types of commands: for n for\r\nloop; end every command between \"for n\" and corresponding \"end\" is\r\nexecuted n times; add adds to x. After the execution of these commands,\r\nvalue of x is returned.Every \"for n\" is matched with \"end\", thus the\r\nfunction is guaranteed to be valid. \"for n\" can be immediately followed\r\nby \"end\".\"add\" command can be outside of any for loops.Notice that \"add\"\r\ncommands might overflow the value of x! It means that the value of x\r\nbecomes greater than 2^{32}-1 after some \"add\" command. Now you run f(0)\r\nand wonder if the resulting value of x is correct or some overflow made\r\nit incorrect.If overflow happened then output \"OVERFLOW!!!\", otherwise\r\nprint the resulting value of x.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconst ll MAXV = (1ll<<32);\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tll res = 0;\n\tvector<ll> stack = {1};\n\tfor (int i = 0; i < n; ++i) {\n\t\tstring str;\n\t\tcin >> str;\n\t\tif (str == \"add\") {\n\t\t\tres += stack.back();\n\t\t} else if (str == \"for\") {\n\t\t\tll k;\n\t\t\tcin >> k;\n\t\t\tstack.push_back(min(MAXV, k*stack.back()));\n\t\t} else if (str == \"end\") {\n\t\t\tstack.pop_back();\n\t\t}\n\t}\n\tif (res >= MAXV) cout << \"OVERFLOW!!!\\n\";\n\telse cout << res << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "expression parsing",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Catch Overflow .json",
    "editorial_link": "https://codeforces.com/blog/entry/67484",
    "editorial": "One can notice (or actually derive using some maths) that the answer is\r\nthe sum of products of nested for loops iterations for every \"add\"\r\ncommand.Let\u00e2\u0080\u0099s learn to simulate that in linear complexity. Maintain the\r\nstack of multipliers: on \"for \" push the top of stack multiplied by to\r\nthe stack, on \"end\" pop the last value, on \"add\" add the top of the\r\nstack to the answer.The problem, however, is the values are really\r\nlarge. Notice that once you add the value greater or equal to to the\r\nanswer, it immediately becomes \"OVERFLOW!!!\". Thus let\u00e2\u0080\u0099s push not the\r\nreal multiplier to the stack but min(multiplier, ). That way the maximum\r\nvalue you can achieve is about , which fits into the 64-bit\r\ninteger.Overall complexity: .\r\n"
}