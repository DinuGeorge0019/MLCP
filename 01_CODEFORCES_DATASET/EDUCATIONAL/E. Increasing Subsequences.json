{
    "link": "https://codeforces.com//contest/1922/problem/E",
    "problemId": "2433278",
    "problem_idx": "E",
    "shortId": "1922E",
    "contest_number": "1922",
    "problem_submissions": {
        "F": [
            242258354,
            242278276,
            242274562,
            242271525,
            242258097,
            242274599,
            242271507,
            242268588,
            242285652,
            242271581,
            242270540,
            242278542,
            242282333,
            242270699,
            242270119,
            242276867,
            242286431,
            242276715,
            242276487,
            242283192,
            242281108,
            242278860,
            242278983,
            242285548
        ],
        "E": [
            242241568,
            242225493,
            242242029,
            242279592,
            242237693,
            242231955,
            242236354,
            242245342,
            242255638,
            242244187,
            242239291,
            242260117,
            242249388,
            242249138,
            242239806,
            242257431,
            242256396,
            242263321,
            242231103,
            242254535,
            242253629,
            242270325
        ],
        "D": [
            242234045,
            242236857,
            242236461,
            242246467,
            242239405,
            242245547,
            242240299,
            242240756,
            242237650,
            242234866,
            242248459,
            242242872,
            242244162,
            242252228,
            242244373,
            242239696,
            242254494,
            242245049,
            242250144,
            242243755,
            242246758
        ],
        "C": [
            242227385,
            242230966,
            242228502,
            242224242,
            242227745,
            242228850,
            242229081,
            242228504,
            242227487,
            242227235,
            242229333,
            242232708,
            242229815,
            242234164,
            242230429,
            242229813,
            242239026,
            242239967,
            242231740,
            242235920
        ],
        "B": [
            242220641,
            242221058,
            242221110,
            242219955,
            242221311,
            242233194,
            242221713,
            242221320,
            242222042,
            242223201,
            242221647,
            242219752,
            242221561,
            242226204,
            242224089,
            242222658,
            242227596,
            242222002,
            242224729,
            242223236
        ],
        "A": [
            242219259,
            242219714,
            242223200,
            242219077,
            242219362,
            242220179,
            242219565,
            242219194,
            242219734,
            242219881,
            242219505,
            242219046,
            242219400,
            242221402,
            242220981,
            242220554,
            242223002,
            242219741,
            242219322,
            242220234
        ]
    },
    "name": "E. Increasing Subsequences",
    "statement": "Let’s recall that an increasing subsequence of the array a is a sequence\r\nthat can be obtained from it by removing some elements without changing\r\nthe order of the remaining elements, and the remaining elements are\r\nstrictly increasing (i. e a_{b_1} < a_{b_2} <\r\ndots < a_{b_k} and b_1 < b_2 <\r\ndots < b_k). Note that an empty subsequence is also increasing.You are\r\ngiven a positive integer X. Your task is to find an array of integers of\r\nlength , such that it has exactly X increasing subsequences, or report\r\nthat there is no such array. If there are several answers, you can print\r\nany of them.If two subsequences consist of the same elements, but\r\ncorrespond to different positions in the array, they are considered\r\ndifferent (for example, the array [2, 2] has two different subsequences\r\nequal to [2]).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"  // https://github.com/Heltion/debug.h/blob/main/debug.h\n#else\n#define debug(...) (void)417\n#endif\nusing i64 = int64_t;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ti += 1) {\n    i64 x;\n    cin >> x;\n    vector<i64> ans;\n    int a = -100, b = 100;\n    while (x > 1) {\n      if (x % 2 == 1) {\n        ans.push_back(a++);\n        x -= 1;\n      } else {\n        ans.push_back(b--);\n        x /= 2;\n      }\n    }\n    ranges::reverse(ans);\n    cout << ans.size() << \"\\n\";\n    for (int x : ans) { cout << x << \" \"; }\n    cout << \"\\n\";\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "constructive algorithms",
        "divide and conquer",
        "greedy",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Increasing Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/124890",
    "editorial": "Letâs consider one of the solutions for constructing the required\r\narray.Let array have increasing subsequences. If we add a new minimum to\r\nthe end of the array, the number of increasing subsequences in the new\r\narray equals (since the new element does not form increasing\r\nsubsequences with other elements, only subsequences consisting of this\r\nelement will be added). If we add a new maximum to the end of the array,\r\nthe number of increasing subsequences in the new array equals (since the\r\nnew element forms increasing subsequences with any other elements).Using\r\nthe above facts, letâs define a recursive function , which returns an\r\narray with exactly increasing subsequences. For an odd value of , (here\r\ndenotes adding an element to the end of the array); for an even value of\r\n, . Now we need to estimate the number of elements in the array obtained\r\nby this algorithm. Note that there cannot be two consecutive operations\r\nof the first type (), so every two operations, the value of decreases by\r\nat least two times. Thus, the size of the array satisfies the limit of .\r\n",
    "hint": []
}