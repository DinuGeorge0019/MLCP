{
    "link": "https://codeforces.com//contest/1494/problem/E",
    "problemId": "913254",
    "problem_idx": "E",
    "shortId": "1494E",
    "contest_number": "1494",
    "problem_submissions": {
        "F": [
            108939157,
            108939159,
            108941615,
            108940380,
            108936690,
            108949404,
            108939049,
            108976002,
            109259098,
            114355817,
            114300723,
            109105687,
            108952860
        ],
        "E": [
            108917863,
            108917179,
            108917875,
            108920789,
            108924713,
            108911681,
            108911479,
            108897566,
            108915498,
            108912071,
            108919266,
            108916392,
            108921553,
            108913575,
            108918608,
            108932427,
            108930755,
            108916943
        ],
        "D": [
            108912126,
            108910016,
            108906106,
            108913150,
            108917394,
            108924483,
            108905862,
            108906091,
            108907069,
            108901150,
            108912737,
            108909289,
            108909997,
            108901829,
            108912218,
            108906405,
            108912083
        ],
        "C": [
            108899963,
            108897106,
            108898254,
            108894965,
            108905337,
            108946028,
            108904267,
            108903529,
            108894912,
            108900440,
            108893773,
            108903235,
            108896270,
            108897186,
            108897145,
            108895547,
            108897140,
            108897478,
            108896885
        ],
        "B": [
            108887573,
            108887648,
            108887088,
            108887791,
            108891184,
            108886492,
            108887122,
            108892723,
            108887267,
            108886341,
            108887638,
            108889178,
            108889629,
            108886479,
            108887946,
            108888463,
            108886261
        ],
        "A": [
            108886097,
            108886134,
            108886049,
            108886041,
            108887001,
            108886021,
            108886051,
            108886176,
            108886040,
            108887099,
            108886184,
            108886195,
            108886220,
            108886015,
            108886138,
            108886325,
            108885985
        ]
    },
    "name": "E. A-Z Graph",
    "statement": "You are given a directed graph consisting of n vertices. Each directed\r\nedge (or arc) labeled with a single character. Initially, the graph is\r\nempty.You should process m queries with it. Each query is one of three\r\ntypes: \"\" add arc from u to v with label c. It\u2019s guaranteed that there\r\nis no arc (u, v) in the graph at this moment; \"\" erase arc from u to v.\r\nIt\u2019s guaranteed that the graph contains arc (u, v) at this moment; \"\"\r\nfind the sequence of k vertices v_1, v_2,\r\ndots, v_k such that there exist both routes v_1\r\nto v_2\r\nto\r\ndots\r\nto v_k and v_k\r\nto v_{k - 1}\r\nto\r\ndots\r\nto v_1 and if you write down characters along both routes you\u2019ll get the\r\nsame string. You can visit the same vertices any number of times.\r\n",
    "solutions": [
        "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nset<pair<int, int>> edges;\n\nmap<pair<int, int>, char> mapka;\n\nset<pair<int, int>> double_edges;\n\nset<pair<int, int>> good_double_edges;\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int n, m; cin>>n>>m;\n\n    while (m--)\n    {\n        string op; cin>>op;\n        if (op==\"+\")\n        {\n            int u, v; char c; cin>>u>>v>>c;\n            edges.insert(mp(u, v)); mapka[mp(u, v)] = c;\n            if (edges.count(mp(v, u)))\n            {\n                double_edges.insert(mp(min(u, v), max(u, v)));\n                if (mapka[mp(u, v)] == mapka[mp(v, u)]) good_double_edges.insert(mp(min(u, v), max(u, v)));\n            }\n        }\n        if (op==\"-\")\n        {\n            int u, v; cin>>u>>v; edges.erase(mp(u, v));\n\n            if (edges.count(mp(v, u)))\n            {\n                double_edges.erase(mp(min(u, v), max(u, v)));\n                if (mapka[mp(u, v)] == mapka[mp(v, u)]) good_double_edges.erase(mp(min(u, v), max(u, v)));\n            }\n\n        }\n        if (op==\"?\")\n        {\n            int k; cin>>k;\n            if (k%2)\n            {\n                if (double_edges.size()) cout<<\"YES\"<<endl; else cout<<\"NO\"<<endl;\n            }\n            else\n            {\n                if (good_double_edges.size()) cout<<\"YES\"<<endl; else cout<<\"NO\"<<endl;\n            }\n        }\n\n        /*cout<<\"ITERATION: \"<<endl;\n        for (auto it: double_edges) cout<<it.first<<' '<<it.second<<endl;*/\n\n    }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "graphs",
        "hashing"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. A-Z Graph.json",
    "editorial_link": "https://codeforces.com//blog/entry/88344",
    "editorial": "At first, if there should be both routes and then there are both arcs\r\nand , i. e. there should exist at least one pair that both arcs and are\r\npresent in the graph.Now, if is odd, and we have at least one pair then\r\nwe can simply create sequence . This sequence is a palindrome so,\r\nobviously, both routes generate the same string.If is even (or ), we can\r\nnote that in the sequence there is a middle arc and it should have the\r\nsame character as arc (since it\u00e2\u0080\u0099s a middle arc in reverse route ), i. e.\r\nthere should exist at least one pair that both arcs and are present in\r\nthe graph and have the same label.Now, if we have at least one such pair\r\nthen routes and generate the same one-letter strings.Since each arc is a\r\npart of at most one pair , we can just maintain two sets with pairs :\r\none for pairs with different labels and the other one for pairs with\r\nequal labels. If is odd, we check that at least one of the sets is not\r\nempty. If is even, we check that the second set is not empty.\r\n"
}