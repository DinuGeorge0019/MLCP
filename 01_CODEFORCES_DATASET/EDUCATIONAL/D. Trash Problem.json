{
    "link": "https://codeforces.com//contest/1418/problem/D",
    "problemId": "727426",
    "problem_idx": "D",
    "shortId": "1418D",
    "contest_number": "1418",
    "problem_submissions": {
        "F": [
            92827621,
            92992766,
            92847130,
            92847007,
            92846498,
            92840659,
            92838710,
            92837329,
            92835778,
            92821703,
            92839298,
            92833921,
            92885700,
            92870799,
            92830172,
            92989347,
            92845726
        ],
        "G": [
            92817256,
            93890104,
            93890054,
            93890004,
            93889956,
            93889783,
            93889650,
            93889392,
            93889084,
            93888189,
            93888010,
            93887834,
            93887831,
            93887519,
            93887334,
            93887004,
            93839244,
            93839240,
            93839237,
            93835786,
            93835763,
            93835704,
            93828053,
            93828000,
            92855419,
            92854972,
            92815447,
            92815164,
            92824652,
            92823576,
            92837977,
            92824758,
            92885721,
            92823789,
            92823462,
            92820493,
            92830232,
            93485501,
            92866692,
            92833116,
            92832754,
            92824217,
            92833610,
            92830510,
            92833625,
            92828988,
            92837204,
            92830405,
            92834428
        ],
        "A": [
            92809737,
            92851684,
            92804370,
            92802575,
            92799307,
            92799729,
            92800647,
            92885635,
            92800218,
            92800425,
            92802031,
            92799884,
            92800952,
            92799036,
            92800270,
            92799895,
            92801328,
            92799861,
            92800242,
            92800050,
            92800040,
            92801512
        ],
        "D": [
            92806930,
            92847621,
            92803255,
            92806570,
            92812108,
            92817724,
            92809504,
            92885678,
            92808863,
            92812638,
            92810774,
            92842221,
            92815078,
            92815207,
            92817058,
            92813567,
            92813334,
            92817631,
            92827883,
            92813906,
            92816619,
            92816135,
            92820186
        ],
        "E": [
            92805758,
            92809090,
            92809687,
            92815513,
            92824046,
            92816662,
            92885694,
            92814615,
            92816908,
            92930467,
            92820677,
            92822734,
            92822919,
            92819310,
            92822831,
            92824275,
            92815296,
            92836469,
            92823732,
            92819866,
            92826009
        ],
        "C": [
            92798839,
            92798564,
            92801110,
            92802769,
            92810140,
            92803375,
            92885666,
            92803075,
            92805736,
            92801242,
            92805901,
            92804239,
            92807896,
            92805622,
            92804878,
            92809071,
            92805265,
            92806697,
            92803772,
            92811897,
            92812555
        ],
        "B": [
            92797501,
            92797816,
            92799405,
            92798968,
            92805443,
            92800263,
            92885648,
            92799516,
            92803590,
            92799029,
            92802282,
            92800352,
            92804945,
            92826085,
            92800306,
            92804932,
            92801700,
            92803543,
            92799506,
            92808871,
            92806614
        ]
    },
    "name": "D. Trash Problem",
    "statement": "Vova decided to clean his room. The room can be represented as the\r\ncoordinate axis OX. There are n piles of trash in the room, coordinate\r\nof the i-th pile is the integer p_i. All piles have coordinates.Let’s\r\ndefine a as the following process. The goal of this process is to\r\ncollect the piles in different x coordinates. To achieve this goal, Vova\r\ncan do several (possibly, zero) moves. During one move, he can choose\r\nsome x and move from x to x+1 or x-1 using his broom. Note that he can’t\r\nchoose how many piles he will move.Also, there are two types of queries:\r\n0 x remove a pile of trash from the coordinate x. It is guaranteed that\r\nthere is a pile in the coordinate x at this moment. 1 x add a pile of\r\ntrash to the coordinate x. It is guaranteed that there is no pile in the\r\ncoordinate x at this moment. Note that it is possible that there are\r\nzero piles of trash in the room at some moment.Vova wants to know the\r\nnumber of moves he can spend if he wants to do a before any queries. He\r\nalso wants to know this number of moves after applying each query.\r\nQueries are applied in the given order. Note that the doesn’t actually\r\nhappen and doesn’t change the state of piles. It is only used to\r\ncalculate the number of moves.For better understanding, please read the\r\nsection below to see an explanation for the first example.\r\n",
    "solutions": [
        "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n//#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define int long long\n#define LL long long\n#define MP make_pair\n#define PB push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(),(x).end()\n#define SZ(x) ((int)(x).size())\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\ntypedef pair<int,int>PII;typedef vector<int>VI;typedef vector<PII>VII;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nconst int N=100005;\nint n,q;\nset<int>S;\nmultiset<int>T;\nvoid insert(int x){\n\tauto it=S.insert(x).fi;\n\tauto pre=it,nxt=it;\n\tif(it!=S.begin())--pre;\n\tif(it!=--S.end())++nxt;\n\tif(it!=S.begin()){\n\t\tT.insert(*it-*pre);\n\t}\n\tif(it!=--S.end()){\n\t\tT.insert(*nxt-*it);\n\t}\n\tif(it!=S.begin()&&it!=--S.end()){\n\t\tT.erase(T.find(*nxt-*pre));\n\t}\n}\nvoid erase(int x){\n\tauto it=S.lower_bound(x);\n\tauto pre=it,nxt=it;\n\tif(it!=S.begin())--pre;\n\tif(it!=--S.end())++nxt;\n\tif(it!=S.begin()){\n\t\tT.erase(T.find(*it-*pre));\n\t}\n\tif(it!=--S.end()){\n\t\tT.erase(T.find(*nxt-*it));\n\t}\n\tif(it!=S.begin()&&it!=--S.end()){\n\t\tT.insert(*nxt-*pre);\n\t}\n\tS.erase(it);\n}\nsigned main(){\n#ifdef xay5421\n\tfreopen(\"a.in\",\"r\",stdin);\n#endif\n\trd(n),rd(q);\n\trep(i,1,n){\n\t\tint x;rd(x);\n\t\tinsert(x);\n\t}\n\trep(_,0,q){\n\t\tif(_){\n\t\t\tint o,x;rd(o),rd(x);\n\t\t\tif(o==0){\n\t\t\t\terase(x);\n\t\t\t}else{\n\t\t\t\tinsert(x);\n\t\t\t}\n\t\t}\n\t\tif(SZ(S)<=2){\n\t\t\tputs(\"0\");\n\t\t}else{\n\t\t\tpt(*--S.end()-*S.begin()-*--T.end(),'\\n');\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Trash Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/82673",
    "editorial": "First, letâs understand that if we choose some subset of points , then\r\nit does not matter to which point we move it (inside the segment [)\r\nbecause the minimum number of moves will always be the same and it is\r\nequal to .Okay, we need to split all points into two subsets and collect\r\nall points of the first subset in some point inside it and the same with\r\nthe second subset. What can we notice? If we sort the points, itâs\r\nalways optimal to choose these subsets as segments. I.e. if the maximum\r\npoint of the first subset is , the minimum point of the second subset is\r\nand , we can swap them and decrease answers for both subsets.So, we need\r\nto cover all the points with two segments with the minimum total length.\r\nWhat is this length? It is . is the maximum distance between two\r\nconsecutive points (i.e. . So, we can solve the problem in without\r\nqueries. But how to deal with queries?Letâs maintain the set which\r\ncontains all points and the multiset (set with repetitions) that\r\nmaintains all gaps between two adjacent points. So, the answer is\r\nmaximum in the set of points minus minimum in the set of points minus\r\nmaximum in the multiset of lengths. How do we recalculate these sets\r\nbetween queries?If some point is removed, letâs find the maximum point\r\nless than (let it be ) and the minimum point greater than (let it be )\r\nin the current set of points. Both these points can be found in a\r\nlogarithmic time. Then we need to remove with from the multiset and add\r\nto the multiset (and, of course, remove from the set). If some point is\r\nadded, then we need to remove from the multiset and add with to the\r\nmultiset (and add to the set).So, we can process every query in time and\r\nthe total time complexity is .\r\n",
    "hint": []
}