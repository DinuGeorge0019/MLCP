{
    "link": "https://codeforces.com//contest/1437/problem/D",
    "problemId": "775842",
    "problem_idx": "D",
    "shortId": "1437D",
    "contest_number": "1437",
    "problem_submissions": {
        "G": [
            96904215,
            96908358,
            96911556,
            96933769,
            96933754,
            96933518,
            96933473,
            96933445,
            96933414,
            96933394,
            96933374,
            96932455,
            96904310,
            96918769,
            96918726,
            96918674,
            96918569,
            96915736,
            96908201,
            96875131,
            106175814,
            96910852,
            96987761,
            96907141,
            96934887
        ],
        "F": [
            96888983,
            96900781,
            96907021,
            96914548,
            96914009,
            96904550,
            96923575,
            96889382,
            96917076,
            96892031,
            96900189,
            96901851,
            96912014,
            96916841,
            96913488,
            97559818,
            96910656
        ],
        "E": [
            96880914,
            96882404,
            96885840,
            96932444,
            96885328,
            96892490,
            96890860,
            96896271,
            96896163,
            96888156,
            96885346,
            96887072,
            96892577,
            96896957,
            96895240,
            96898636,
            97559735,
            96897006
        ],
        "D": [
            96875179,
            96877608,
            96875178,
            96880944,
            96885771,
            96877805,
            96898190,
            96885975,
            96876295,
            96879122,
            96877985,
            96883085,
            96879709,
            96879615,
            96881903,
            97558972,
            96886384
        ],
        "C": [
            96871849,
            96873242,
            96871401,
            96937777,
            96917473,
            96874581,
            96876847,
            96873952,
            96902915,
            96882435,
            96874057,
            96876339,
            96874008,
            96878071,
            96874148,
            96873187,
            96875974,
            97558809,
            96872333
        ],
        "B": [
            96868094,
            96870116,
            96868044,
            96871520,
            96869439,
            96870069,
            96905187,
            96921093,
            96871936,
            96870828,
            96870841,
            96868971,
            96868275,
            96868652,
            96869849,
            97558720,
            96868938
        ],
        "A": [
            96867417,
            96867598,
            96867496,
            96867654,
            96867506,
            96867568,
            96906923,
            96868396,
            96867566,
            96869874,
            96869082,
            96867617,
            96867510,
            96867621,
            96867703,
            97558428,
            96867545
        ]
    },
    "name": "D. Minimal Height Tree",
    "statement": "Monocarp had a tree which consisted of n vertices and was rooted at\r\nvertex 1. He decided to study BFS (Breadth-first search), so he ran BFS\r\non his tree, starting from the root. BFS can be described by the\r\nfollowing pseudocode:a = [] # the order in which vertices were\r\nprocessedq = Queue()q.put(1) # place the root at the end of the\r\nqueuewhile not q.empty(): k = q.pop() # retrieve the first vertex from\r\nthe queue a.append(k) # append k to the end of the sequence in which\r\nvertices were visited for y in g[k]: # g[k] is the list of all children\r\nof vertex k, sorted in ascending order q.put(y)Monocarp was fascinated\r\nby BFS so much that, in the end, he lost his tree. Fortunately, he still\r\nhas a sequence of vertices, in which order vertices were visited by the\r\nBFS algorithm (the array from the pseudocode). Monocarp knows that each\r\nvertex was visited exactly once (since they were put and taken from the\r\nqueue exactly once). Also, he knows that all children of each vertex\r\nwere viewed .Monocarp knows that there are many trees (in the general\r\ncase) with the same visiting order a, so he doesn\u2019t hope to restore his\r\ntree. Monocarp is okay with any tree that . of a tree is the maximum\r\ndepth of the tree\u2019s vertices, and the depth of a vertex is the number of\r\nedges in the path from the root to it. For example, the depth of vertex\r\n1 is 0, since it\u2019s the root, and the depth of all root\u2019s children are\r\n1.Help Monocarp to find any tree with given visiting order a and minimum\r\nheight.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 200200;\nint n;\nint a[N];\nint b[N];\n\nvoid solve() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d\", &a[i]);\n\tb[0] = 1;\n\tint m = 1;\n\tint l = 1;\n\twhile(l < n) {\n\t\tint k = b[m - 1];\n\t\tb[m] = 0;\n\t\twhile(k > 0) {\n\t\t\tk--;\n\t\t\tif (l == n) continue;\n\t\t\tl++;\n\t\t\tb[m]++;\n\t\t\twhile(l < n && a[l] > a[l - 1]) {\n\t\t\t\tl++;\n\t\t\t\tb[m]++;\n\t\t\t}\n\t\t}\n\t\tm++;\n\t}\n\tprintf(\"%d\\n\", m - 1);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "graphs",
        "greedy",
        "shortest paths",
        "trees"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Minimal Height Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/84149",
    "editorial": "Due to the nature of BFS, the visiting order consists of several\r\nsegments: first goes root (has depth ), then all vertices with depth ,\r\nthen all vertices with depth and so on. Since any vertex of depth is a\r\nchild of vertex of depth , then it\u00e2\u0080\u0099s optimal to make the number of\r\nvertices with depth as many as possible, then make the number of\r\nvertices with depth as many as possible and so on.Since children of a\r\nvertex are viewed in ascending order and form a segment in visiting\r\norder then an arbitrary segment of visiting order can be children of the\r\nsame vertex iff elements in the segments are in ascending order.These\r\ntwo observations lead us to a greedy strategy: , then let\u00e2\u0080\u0099s find the\r\nmaximum that segment is in ascending order they will be the children of\r\nand the only vertices of depth . Next search the maximum such that\r\nsegment is in ascending order they will be the children of , and so on.\r\nIt\u00e2\u0080\u0099s easy to see that this strategy maximizes the number of vertices of\r\neach depth level, so minimize the height of the tree.\r\n"
}