{
    "link": "https://codeforces.com//contest/1359/problem/E",
    "problemId": "634676",
    "problem_idx": "E",
    "shortId": "1359E",
    "contest_number": "1359",
    "problem_submissions": {
        "C": [
            81997007,
            81727058,
            81734733,
            81730835,
            81740916,
            81747939,
            81729612,
            81737303,
            81737447,
            81741656,
            81752868,
            81776094,
            81761832,
            81724495,
            81746226,
            81738450,
            81730327,
            81729715,
            81731437,
            81744227,
            81733481
        ],
        "F": [
            81812419,
            81764295,
            81854273,
            81854109,
            81853958,
            81778328,
            81787414,
            81786228,
            81796920,
            81794151,
            81788283,
            81787937,
            81784721,
            81790808,
            81789636,
            81804129,
            81796060,
            81778353,
            81798275,
            105524321,
            105524094,
            105524008,
            81799361,
            81796754,
            81795964,
            81808154,
            81868467,
            205746151,
            205745147,
            140844519
        ],
        "D": [
            81739116,
            81744503,
            81735878,
            81749048,
            81740279,
            81749196,
            81744086,
            81743897,
            81754255,
            81762454,
            81758312,
            81744429,
            81728105,
            81726622,
            81721526,
            81737234,
            81738327,
            81737186,
            81731810,
            81739976
        ],
        "E": [
            81734306,
            81750721,
            81743059,
            81759597,
            81729601,
            81756849,
            81752573,
            81749938,
            81761248,
            81768636,
            81784969,
            81729272,
            81731972,
            81733967,
            81747782,
            81743404,
            81743235,
            81742828,
            81736556,
            81742484
        ],
        "B": [
            81716705,
            81725433,
            81718596,
            81720832,
            81719267,
            81716337,
            81719010,
            81727250,
            81721619,
            81746513,
            81720940,
            81767813,
            81716284,
            81717634,
            81717996,
            81719942,
            81719713,
            81719807,
            81718363,
            81718512
        ],
        "A": [
            81715063,
            81720474,
            81715122,
            81715707,
            81715255,
            81715098,
            81715727,
            81721547,
            81715498,
            81744191,
            81715755,
            81770964,
            81715068,
            81715226,
            81715093,
            81715532,
            81715578,
            81715424,
            81715396,
            81715264
        ]
    },
    "name": "E. Modular Stability",
    "statement": "We define x\r\nbmod y as the remainder of division of x by y (\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = 998244353;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nconst int maxN = 5e5 + 10;\nconst int maxK = 21;\nint fact[maxN], invfact[maxN], inv[maxN];\nint n, k;\nint cnk(int n, int k) {\n    return mult(fact[n], mult(invfact[k], invfact[n - k]));\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    fact[0] = invfact[0] = fact[1] = invfact[1] = inv[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n    cin >> n >> k;\n    int ans = 0;\n    for (int d = 1; d <= n; d++) {\n        int lft = n / d - 1;\n        if (lft < (k - 1)) continue;\n        ans = sum(ans, cnk(lft, k - 1));\n    }\n    cout << ans;\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "number theory"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Modular Stability.json",
    "editorial_link": "https://codeforces.com//blog/entry/78116",
    "editorial": "We claim that the array is stable if and only if all elements are\r\ndivisible by its minimum. The proof of this fact will be at the end of\r\nthe editorial.To calculate the number of stable arrays now, we need to\r\niterate on the minimum in the array and choose the remaining elements so\r\nthat they are multiples of it. If the minimum is , then the resulting\r\nelements should be divisible by . There are such numbers between and ,\r\nand we have to choose elements out of (since is already chosen). The\r\nnumber of ways to do it can be calculated by precomputing factorials\r\nmodulo , since it is a binomial coefficient.On the one hand, since , if\r\nall elements in the array are divisible by some element, nothing depends\r\non the order of these elements.On the other hand, suppose there exists\r\nan element such that it is not divisible by . Letâ€™s take and two\r\nfollowing reorders of the array : and . For the first array, we get ,\r\nwhich is non-zero; and for the second array, , so the result is zero.\r\n"
}