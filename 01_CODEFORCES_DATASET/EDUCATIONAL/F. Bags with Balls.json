{
    "link": "https://codeforces.com//contest/1716/problem/F",
    "problemId": "1494205",
    "problem_idx": "F",
    "shortId": "1716F",
    "contest_number": "1716",
    "problem_submissions": {
        "F": [
            166973182,
            166969763,
            166955726,
            166980503,
            166971153,
            166982692,
            166980605,
            166983476,
            166980127,
            166991091,
            166984328,
            174506735,
            166989832,
            166994539,
            166994104,
            167001346,
            166987296,
            166992176,
            167001598,
            166984678,
            166980048,
            166989609,
            166991438
        ],
        "E": [
            166965293,
            166978547,
            166976884,
            166972995,
            166981522,
            166965872,
            166976854,
            166973781,
            166987347,
            166978953,
            166992476,
            174506754,
            166979608,
            166979158,
            166999544,
            166982891,
            166981173,
            166992198,
            166994171,
            166998037,
            166985315
        ],
        "D": [
            166956573,
            166961021,
            166948324,
            166940829,
            166964589,
            166961790,
            166945640,
            166966226,
            166990484,
            166958577,
            166963786,
            166970823,
            166970282,
            166968378,
            166964318,
            166974075,
            166965600,
            166970563,
            166970355,
            166971544,
            166978778
        ],
        "C": [
            166949159,
            166950864,
            166972142,
            166963779,
            166956508,
            166957181,
            166966957,
            166958122,
            166972096,
            166974861,
            166961876,
            166963035,
            166961356,
            166959918,
            166967210,
            166954669,
            166964729,
            166960756,
            166967143,
            166974763
        ],
        "B": [
            166933142,
            166932739,
            166939087,
            166932145,
            166933138,
            166932019,
            166931348,
            166934835,
            166932251,
            166931312,
            166937500,
            166936523,
            166932821,
            166932877,
            166940841,
            166932031,
            166935420,
            166935573,
            166933744,
            166937079
        ],
        "A": [
            166930228,
            166930333,
            166931520,
            166930280,
            166930300,
            166930222,
            166930190,
            166930301,
            166930500,
            166930207,
            166932038,
            166930537,
            166930220,
            166930271,
            166933329,
            166930353,
            166930639,
            166930376,
            166930158,
            166931421
        ]
    },
    "name": "F. Bags with Balls",
    "statement": "There are n bags, each bag contains m balls with numbers from 1 to m.\r\nFor every i\r\nin [1, m], there is exactly one ball with number i in each bag.You have\r\nto take exactly one ball from each bag (all bags are different, so, for\r\nexample, taking the ball 1 from the first bag and the ball 2 from the\r\nsecond bag is not the same as taking the ball 2 from the first bag and\r\nthe ball 1 from the second bag). After that, you calculate the number of\r\nballs with numbers among the ones you have taken. Let the number of\r\nthese balls be F.Your task is to calculate the sum of F^k over all\r\npossible ways to take n balls, one from each bag.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\n\nconst int N = 2020;\nMint S[N][N];\nMint C[N];\nMint pw[N];\n\nvoid solve() {\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tC[0] = 1;\n\tfor (int i = 0; i < k; i++)\n\t\tC[i + 1] = C[i] * Mint(n - i);\n\tpw[0] = 1;\n\tpw[1] = Mint((m + 1) / 2) / Mint(m);\n\tfor (int i = 1; i < k; i++)\n\t\tpw[i + 1] = pw[i] * pw[1];\n\tMint ans = 0;\n\tfor (int p = 1; p <= k; p++)\n\t\tans += S[k][p] * C[p] * pw[p];\n\tans *= Mint(m).pow(n);\n\tprintf(\"%u\\n\", ans.x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tS[0][0] = 1;\n\tfor (int n = 1; n < N; n++)\n\t\tfor (int k = 1; k <= n; k++)\n\t\t\tS[n][k] = S[n - 1][k] * k + S[n - 1][k - 1];\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math",
        "number theory"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Bags with Balls.json",
    "editorial_link": "https://codeforces.com//blog/entry/105653",
    "editorial": "The main idea of this problem is to use a technique similar to\r\n\"contribution to the sum\". We will model the value of as the number of\r\ntuples , where each element is an index of a bag from which we have\r\ntaken an odd ball. Let be the number of ways to take balls from bags so\r\nthat all elements from tuple are indices of bags with odd balls; then,\r\nthe answer to the problem can be calculated as the sum of over all\r\npossible tuples .First of all, let\u00e2\u0080\u0099s obtain a solution in per test case.\r\nWe need to answer the following questions while designing a solution to\r\nthe problem: How do we calculate for a given tuple? How do we group\r\ntuples and iterate through them? The first question is not that\r\ndifficult. Every element from the tuple should be an index of a bag from\r\nwhich we have taken an odd ball; so, for every bag appearing in the\r\ntuple, we can take only a ball with odd number; but for every bag not\r\nappearing in the tuple, we can choose any ball. So, if the number of\r\nelements in a tuple is , then for the tuple can be calculated as .This\r\nactually gives as a hint for the answer to the second question: since\r\ndepends on the number of distinct elements in the tuple, let\u00e2\u0080\u0099s try to\r\ngroup the tuples according to the number of distinct elements in them.\r\nSo, the answer will be calculated as , where is the number of tuples\r\nwith exactly different elements.How do we calculate ? First of all, if ,\r\nthen is obviously . Otherwise, we can use the following recurrence: let\r\nbe the number of tuples of elements with distinct ones; then: if and ,\r\n(for a tuple with one element, there are ways to choose it); if and , ;\r\nif and , (there is only one distinct element, and it was already\r\nchosen); if and , (we either add an element which did not belong to the\r\ntuple, and there are ways to choose it, or we add an already existing\r\nelement, and there are ways to choose it). Obviously, this recurrence\r\ncan be calculated in with dynamic programming, so we get a solution in\r\nper test case.How do we speed this up? Let\u00e2\u0080\u0099s change the way we calculate\r\n. Instead of considering tuples with values from to , we will consider\r\nonly tuples where values are from to , and the first appearance of a\r\nvalue is only after the first appearance of the value . So, these tuples\r\nactually represent a way to split a set of integers into several\r\nsubsets; so they are the Stirling numbers of the second kind, and we can\r\ncalculate them in with dynamic programming outside of processing the\r\ntest cases.How do we calculate using these values? If we use distinct\r\nintegers as the elements of the tuple, there are ways to choose the\r\nfirst one, ways to choose the second one, etc. so , where is the\r\nStirling number of the second kind for the parameters and . We can\r\nmaintain the values of and while iterating on from to , and that gives\r\nus a way to solve the problem in per test case.Overall complexity: for\r\nprecalculation and per test case.\r\n"
}