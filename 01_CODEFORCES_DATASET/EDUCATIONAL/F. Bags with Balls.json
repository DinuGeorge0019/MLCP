{"link": "https://codeforces.com//contest/1716/problem/F", "problemId": "1494205", "problem_idx": "F", "shortId": "1716F", "contest_number": "1716", "problem_submissions": {"F": [166973182, 166969763, 166955726, 166980503, 166971153, 166982692, 166980605, 166983476, 166980127, 166991091, 166984328, 174506735, 166989832, 166994539, 166994104, 167001346, 166987296, 166992176, 167001598, 166984678, 166980048, 166989609, 166991438], "E": [166965293, 166978547, 166976884, 166972995, 166981522, 166965872, 166976854, 166973781, 166987347, 166978953, 166992476, 174506754, 166979608, 166979158, 166999544, 166982891, 166981173, 166992198, 166994171, 166998037, 166985315], "D": [166956573, 166961021, 166948324, 166940829, 166964589, 166961790, 166945640, 166966226, 166990484, 166958577, 166963786, 166970823, 166970282, 166968378, 166964318, 166974075, 166965600, 166970563, 166970355, 166971544, 166978778], "C": [166949159, 166950864, 166972142, 166963779, 166956508, 166957181, 166966957, 166958122, 166972096, 166974861, 166961876, 166963035, 166961356, 166959918, 166967210, 166954669, 166964729, 166960756, 166967143, 166974763], "B": [166933142, 166932739, 166939087, 166932145, 166933138, 166932019, 166931348, 166934835, 166932251, 166931312, 166937500, 166936523, 166932821, 166932877, 166940841, 166932031, 166935420, 166935573, 166933744, 166937079], "A": [166930228, 166930333, 166931520, 166930280, 166930300, 166930222, 166930190, 166930301, 166930500, 166930207, 166932038, 166930537, 166930220, 166930271, 166933329, 166930353, 166930639, 166930376, 166930158, 166931421]}, "name": "F. Bags with Balls", "statement": "There are n bags, each bag contains m balls with numbers from 1 to m.\r\nFor every i\r\nin [1, m], there is exactly one ball with number i in each bag.You have\r\nto take exactly one ball from each bag (all bags are different, so, for\r\nexample, taking the ball 1 from the first bag and the ball 2 from the\r\nsecond bag is not the same as taking the ball 2 from the first bag and\r\nthe ball 1 from the second bag). After that, you calculate the number of\r\nballs with numbers among the ones you have taken. Let the number of\r\nthese balls be F.Your task is to calculate the sum of F^k over all\r\npossible ways to take n balls, one from each bag.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\n\nconst int N = 2020;\nMint S[N][N];\nMint C[N];\nMint pw[N];\n\nvoid solve() {\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\tC[0] = 1;\n\tfor (int i = 0; i < k; i++)\n\t\tC[i + 1] = C[i] * Mint(n - i);\n\tpw[0] = 1;\n\tpw[1] = Mint((m + 1) / 2) / Mint(m);\n\tfor (int i = 1; i < k; i++)\n\t\tpw[i + 1] = pw[i] * pw[1];\n\tMint ans = 0;\n\tfor (int p = 1; p <= k; p++)\n\t\tans += S[k][p] * C[p] * pw[p];\n\tans *= Mint(m).pow(n);\n\tprintf(\"%u\\n\", ans.x);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tS[0][0] = 1;\n\tfor (int n = 1; n < N; n++)\n\t\tfor (int k = 1; k <= n; k++)\n\t\t\tS[n][k] = S[n - 1][k] * k + S[n - 1][k - 1];\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) solve();\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp", "math", "number theory"], "dificulty": "2500", "interactive": false}