{
    "link": "https://codeforces.com//contest/1766/problem/D",
    "problemId": "1690149",
    "problem_idx": "D",
    "shortId": "1766D",
    "contest_number": "1766",
    "problem_submissions": {
        "E": [
            184982392,
            184982173,
            184938042,
            184950686,
            184932260,
            184939673,
            184936898,
            184934396,
            184948204,
            184935811,
            184943315,
            184989151,
            184947057,
            184952057,
            184938439,
            184967483,
            187916344,
            184948513,
            184933180,
            184935854,
            184939624,
            184943840,
            184943132,
            184940980
        ],
        "F": [
            184949728,
            184939667,
            184976950,
            184964579,
            184958474,
            184962483,
            184966185,
            184957638,
            184969067,
            185089664,
            185089530,
            184977947,
            184997639,
            184973757,
            184966070,
            184960435,
            184974697,
            184966631,
            184990205,
            184997420
        ],
        "D": [
            184914984,
            184986868,
            184986781,
            184917638,
            184915781,
            184923898,
            184923871,
            184918405,
            184919375,
            184923813,
            184918585,
            184915933,
            184925192,
            184969262,
            184952734,
            184970967,
            184919304,
            184918923,
            184922752,
            184918317,
            184920694,
            184924980
        ],
        "C": [
            184909482,
            184913973,
            184911632,
            184918401,
            184916364,
            185395845,
            184914719,
            184914076,
            184920058,
            184913612,
            184913225,
            184921601,
            184918048,
            184950984,
            184973944,
            184914889,
            184913008,
            184914015,
            184915845,
            184914942,
            184915187
        ],
        "B": [
            184907198,
            184909422,
            184907991,
            184909353,
            184910422,
            184907995,
            184908723,
            184907965,
            184908129,
            184908832,
            184911921,
            184911885,
            184949263,
            184977162,
            184909079,
            184908305,
            184909027,
            184908934,
            184911337,
            184910448
        ],
        "A": [
            184906447,
            184906808,
            184906511,
            184906536,
            184906567,
            184906521,
            184906485,
            184906494,
            184906490,
            184992052,
            184907067,
            184906532,
            184906851,
            184947991,
            184978729,
            184906583,
            184906564,
            184906598,
            184906512,
            184906683,
            184906543
        ]
    },
    "name": "D. Lucky Chains",
    "statement": "Let’s name a pair of positive integers (x, y) if the greatest common\r\ndivisor of them is equal to 1 (\r\ngcd(x, y) = 1).Let’s define a induced by (x, y) as a sequence of pairs\r\n(x, y), (x + 1, y + 1), (x + 2, y + 2),\r\ndots, (x + k, y + k) for some integer k\r\nge 0. The of the chain is the number of pairs it consists of, or (k +\r\n1).Let’s name such chain if all pairs in the chain are lucky.You are\r\ngiven n pairs (x_i, y_i). Calculate for each pair the length of the\r\nlongest lucky chain induced by this pair. Note that if (x_i, y_i) is not\r\nlucky itself, the chain will have the length 0.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 10000000;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  vector<int> p(MAX, -1);\n  for (int i = 2; i < MAX; i++){\n    if (p[i] == -1){\n      for (int j = i * 2; j < MAX; j += i){\n        p[j] = i;\n      }\n    }\n  }\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++){\n    int x, y;\n    cin >> x >> y;\n    if (gcd(x, y) > 1){\n      cout << 0 << endl;\n    } else if (y == x + 1){\n      cout << -1 << endl;\n    } else {\n      int d = y - x;\n      vector<int> f;\n      while (p[d] != -1){\n        f.push_back(p[d]);\n        d /= p[d];\n      }\n      if (d > 1){\n        f.push_back(d);\n      }\n      sort(f.begin(), f.end());\n      f.erase(unique(f.begin(), f.end()), f.end());\n      int ans = MAX;\n      for (int a : f){\n        ans = min(ans, a - x % a);\n      }\n      cout << ans << \"\\n\";\n    }\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Lucky Chains.json",
    "editorial_link": "https://codeforces.com//blog/entry/110066",
    "editorial": "Suppose, . It means that is also divisible by , or is divisible by . And\r\nbackward: if , then is also divisible by , or is divisible by . Since is\r\ndivisible by and is divisible by , so . In other words, we proved that\r\n.Now, knowing the equivalence above, we can understand that we are\r\nlooking for the smallest such that . In other words, we are searching\r\nsuch that is divisible by some , where is some divisor of .The problem\r\nis that there are a handful of divisors for some . But we can note that\r\nwe can consider only divisors of : if and is composite then there is\r\nsome prime , thus .Itâs easy to prove that there are no more than prime\r\ndivisors of some . Now the question is how to find all these prime\r\ndivisors.Note that if you know only one prime divisor for each value\r\nfrom to , then you can find all prime divisors for all in . The prime\r\ndivisors are next: , ; , ; , ; and so on until . The final step is to\r\ncalculate a prime divisor for each value from to , where or . We can do\r\nit by slight modifications of Sieve of Eratosthenes: at the step, where\r\nyou have some prime and want to \"throw out\" all values , set for each\r\n(plus set ).As a result, we, firstly, calculate Sieve in and, secondly,\r\ncalculate answer for each pair in .Note that the input and output is\r\nlarge, so you should you tricks to speed up your input and output.\r\n",
    "hint": []
}