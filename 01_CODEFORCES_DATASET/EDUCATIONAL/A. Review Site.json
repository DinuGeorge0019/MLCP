{
    "link": "https://codeforces.com//contest/1511/problem/A",
    "problemId": "955212",
    "problem_idx": "A",
    "shortId": "1511A",
    "contest_number": "1511",
    "problem_submissions": {
        "F": [
            112840077,
            112828537,
            112827087,
            113002746,
            112851650,
            112835176,
            112837815,
            112833990,
            112833873,
            112824360,
            112844580,
            112864617,
            112862363,
            112847364,
            112866931,
            112854217,
            112847572,
            112854389,
            112862579,
            112845350
        ],
        "G": [
            112827572,
            112849564,
            114661033,
            114660887,
            114660767,
            114660706,
            114660307,
            114660076,
            114659999,
            114659915,
            112892560,
            112862384,
            112862341,
            112862288,
            112850067,
            112846404,
            112853880,
            112853846,
            112850825,
            112896875,
            112847874,
            113122868,
            112859368,
            112858002,
            112857690,
            112970481,
            112947065,
            112923272,
            112913505,
            113005183,
            112847551,
            112853638,
            112855715
        ],
        "E": [
            112819190,
            112811502,
            112809874,
            112818379,
            112809749,
            112819391,
            112816521,
            112812422,
            112824024,
            112811228,
            112816399,
            112821852,
            112825588,
            112822496,
            112814072,
            112820021,
            112829060,
            112824596
        ],
        "D": [
            112810190,
            112804690,
            112802519,
            112810990,
            112813483,
            112807233,
            112809814,
            112797395,
            112806426,
            112804268,
            112810141,
            112805389,
            112810319,
            112811043,
            112802328,
            112810501,
            112810922,
            112816639
        ],
        "C": [
            112798920,
            112798787,
            112796760,
            112804959,
            112800997,
            112799737,
            112805004,
            112792842,
            112799549,
            112797984,
            112795724,
            112796489,
            112801048,
            112802109,
            112797807,
            112801283,
            112801426,
            112804850
        ],
        "B": [
            112794609,
            112794368,
            112790815,
            112794707,
            112794954,
            112796065,
            112801022,
            112788437,
            112794356,
            112792946,
            112790545,
            112792316,
            112798211,
            112798547,
            112790397,
            112797545,
            112796307,
            112796695
        ],
        "A": [
            112787944,
            112786809,
            112787014,
            112786892,
            112787663,
            112788591,
            112791727,
            112786823,
            112788650,
            112788073,
            112786815,
            112787413,
            112786972,
            112791493,
            112787338,
            112792315,
            112786886,
            112787405
        ]
    },
    "name": "A. Review Site",
    "statement": "You are an upcoming movie director, and you have just released your\r\nfirst movie. You have also launched a simple review site with two\r\nbuttons to press upvote and downvote.However, the site is not so simple\r\non the inside. There are two servers, each with its separate counts for\r\nthe upvotes and the downvotes.n reviewers enter the site one by one.\r\nEach reviewer is one of the following types: type 1: a reviewer has\r\nwatched the movie, and they like it they press the upvote button; type\r\n2: a reviewer has watched the movie, and they dislike it they press the\r\ndownvote button; type 3: a reviewer hasnâ€™t watched the movie they look\r\nat the current number of upvotes and downvotes of the movie on the\r\nserver they are in and decide what button to press. If there are more\r\ndownvotes than upvotes, then a reviewer downvotes the movie. Otherwise,\r\nthey upvote the movie. Each reviewer votes on the movie exactly\r\nonce.Since you have two servers, you can actually manipulate the votes\r\nso that your movie gets as many upvotes as possible. When a reviewer\r\nenters a site, you know their type, and you can send them either to the\r\nfirst server or to the second one.What is the maximum total number of\r\nupvotes you can gather over both servers if you decide which server to\r\nsend each reviewer to?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  for (int tt = scan(); tt--;) {\n    int ans = 0;\n    for (int n = scan(); n--;) ans += scan() != 2;\n    cout << ans << '\\n';\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Review Site.json",
    "editorial_link": "https://codeforces.com//blog/entry/89634",
    "editorial": "Notice that the answer depends only on the number of the reviewers of\r\nthe third type who upvote the movie. Optimally we would want every\r\nsingle reviewer of the third type to upvote. We can achieve it with the\r\nfollowing construction: send all reviewers of the first type to the\r\nfirst server, all reviewers of the second type to the second server and\r\nall reviewers of the third type to the first server. Since there are no\r\ndownvotes on the first server, all reviewers of the third type will\r\nupvote.Thus, the answer is the total number of reviewers of the first\r\nand the third type.Overall complexity: per testcase.\r\n",
    "hint": []
}