{
    "link": "https://codeforces.com//contest/1767/problem/D",
    "problemId": "1697003",
    "problem_idx": "D",
    "shortId": "1767D",
    "contest_number": "1767",
    "problem_submissions": {
        "F": [
            185514153,
            185548652,
            185548569,
            185548494,
            185548166,
            185548104,
            185548070,
            185547990,
            185547931,
            185538816,
            185538731,
            185536681,
            185536510,
            185533881,
            185548043,
            185547524,
            185547405,
            187061027,
            188938985,
            188938874,
            188938733,
            188938538,
            188662943
        ],
        "E": [
            185496241,
            185503484,
            185495581,
            185501980,
            185500616,
            185536545,
            185506476,
            185505796,
            185502863,
            185502893,
            185509737,
            185509089,
            185503658,
            185500454,
            188653481,
            185507693,
            185510300,
            185512188,
            185507422,
            185511136,
            191847813,
            185508302
        ],
        "D": [
            185485689,
            185480567,
            185486073,
            185487205,
            185489767,
            185484058,
            185487337,
            185490632,
            185495647,
            185490973,
            185492256,
            185494935,
            185488073,
            185492422,
            185494405,
            185494252,
            185494078,
            185493034,
            185501838
        ],
        "C": [
            185476244,
            185474583,
            185478107,
            185476554,
            185481773,
            185476338,
            185483596,
            185484239,
            185478556,
            185481931,
            185485024,
            185484128,
            185481474,
            185482158,
            185486113,
            185484367,
            185484937,
            185482445,
            185483985
        ],
        "B": [
            185470025,
            185469866,
            185470325,
            185469767,
            185469743,
            185469974,
            185468835,
            185473229,
            185470539,
            185470117,
            185471331,
            185471042,
            185470304,
            185473480,
            185472801,
            185471018,
            185472578,
            185469524,
            185472904
        ],
        "A": [
            185468810,
            185468911,
            185468716,
            185468796,
            185468875,
            185468821,
            185471076,
            185576332,
            185469327,
            185470858,
            185468733,
            185468950,
            185468986,
            185469052,
            185468910,
            185469302,
            185469202,
            185470756,
            185472308,
            185469751
        ]
    },
    "name": "D. Playoff",
    "statement": "2^n teams participate in a playoff tournament. The tournament consists\r\nof 2^n - 1 games. They are held as follows: in the first phase of the\r\ntournament, the teams are split into pairs: team 1 plays against team 2,\r\nteam 3 plays against team 4, and so on (so, 2^{n-1} games are played in\r\nthat phase). When a team loses a game, it is eliminated, and each game\r\nresults in elimination of one team (there are no ties). After that, only\r\n2^{n-1} teams remain. If only one team remains, it is declared the\r\nchampion; otherwise, the second phase begins, where 2^{n-2} games are\r\nplayed: in the first one of them, the winner of the game \"1 vs 2\" plays\r\nagainst the winner of the game \"3 vs 4\", then the winner of the game \"5\r\nvs 6\" plays against the winner of the game \"7 vs 8\", and so on. This\r\nprocess repeats until only one team remains. The skill level of the i-th\r\nteam is p_i, where p is a permutation of integers 1, 2, ..., 2^n (a\r\npermutation is an array where each element from 1 to 2^n occurs exactly\r\nonce).You are given a string s which consists of n characters. These\r\ncharacters denote the results of games in each phase of the tournament\r\nas follows: if s_i is equal to , then during the i-th phase (the phase\r\nwith 2^{n-i} games), in each match, the team with the lower skill level\r\nwins; if s_i is equal to , then during the i-th phase (the phase with\r\n2^{n-i} games), in each match, the team with the higher skill level\r\nwins. Let\u2019s say that an integer x is if it is possible to find a\r\npermutation p such that the team with skill x wins the tournament. Find\r\nall winning integers.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = (1 << 18) + 7;\nint n;\nint dp[2][N];\nchar s[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tscanf(\" %s\", s);\n\treverse(s, s + n);\n\tdp[0][0] = 1;\n\tfor (int k = 0; k < n; k++) {\n\t\tfor (int i = 0; i <= (1 << (k + 1)); i++)\n\t\t\tdp[1][i] = 0;\n\t\tfor (int w = 0; w < (1 << k); w++) if (dp[0][w]) {\n\t\t\tint curW = w;\n\t\t\tint curL = (1 << k) - 1 - w;\n\t\t\tint l, r;\n\t\t\tif (s[k] == '0') {\n\t\t\t\tl = curL;\n\t\t\t\tr = 2 * curL;\n\t\t\t\tswap(l, r);\n\t\t\t\tl = (1 << (k + 1)) - 1 - l;\n\t\t\t\tr = (1 << (k + 1)) - 1 - r;\n\t\t\t} else {\n\t\t\t\tl = curW;\n\t\t\t\tr = 2 * curW;\n\t\t\t}\n\t\t\tdp[1][l]++;\n\t\t\tdp[1][r + 1]--;\n\t\t}\n\t\tint bal = 0;\n\t\tfor (int i = 0; i < (1 << (k + 1)); i++) {\n\t\t\tbal += dp[1][i];\n\t\t\tdp[0][i] = min(1, bal);\n\t\t}\n\t}\n\tfor (int i = (1 << n) - 1; i >= 0; i--) if (dp[0][i])\n\t\tprintf(\"%d \", (1 << n) - i);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Playoff.json",
    "editorial_link": "https://codeforces.com//blog/entry/110225",
    "editorial": "Firstly, let\u00e2\u0080\u0099s prove that the order of characters in is\r\ninterchangeable.Suppose we have a tournament of four teams with skills ,\r\n, and such that ; and this tournament has the form or . It\u00e2\u0080\u0099s easy to see\r\nthat and cannot be winners, since will be eliminated in the round with\r\ntype , and will be eliminated in the round with type . However, it\u00e2\u0080\u0099s\r\neasy to show that both with and with , and can be winners.Using this\r\nargument to matches that go during phases and (a group of two matches\r\nduring phase and a match during phase between the winners of those\r\nmatches can be considered a tournament with ), we can show that swapping\r\nand does not affect the possible winners of the tournament.So, suppose\r\nall phases of type happen before phases of type , there are phases of\r\ntype and phases of type (). teams will be eliminated in the first part\r\n(phases of type ), and the team with the lowest skill that wasn\u00e2\u0080\u0099t\r\neliminated in the first half will win the second half.It\u00e2\u0080\u0099s easy to see\r\nthat the teams with skills cannot pass through the first part of the\r\ntournament, since to pass the first part, a team has to be the strongest\r\nin its \"subtree\" of size .Furthermore, since the minimum of teams\r\npassing through the first half wins, the winner should have skill not\r\ngreater than the winner should have lower skill than at least teams, so\r\nteams with skills higher than cannot win.Okay, now all possible winners\r\nbelong to the segment . Let\u00e2\u0080\u0099s show that any integer from this segment\r\ncan be winning. Suppose , let\u00e2\u0080\u0099s construct the tournament in such a way\r\nthat only team with skill and teams with the highest skill pass through\r\nthe first part of the tournament (obviously, then team wins). There are\r\nindependent tournaments of size in the first part; let\u00e2\u0080\u0099s assign teams\r\nwith skills from to , and also the team to one of those tournaments; for\r\nall other tournaments, let\u00e2\u0080\u0099s assign the teams in such a way that exactly\r\none team from the highest ones competes in each of them. It\u00e2\u0080\u0099s easy to\r\nsee that the team will win its tournament, and every team from the\r\nhighest ones will win its tournament as well, so the second half will\r\ncontain only teams with skills and (and, obviously, will be the winner\r\nof this tournament).So, the answer to the problem is the segment of\r\nintegers .\r\n"
}