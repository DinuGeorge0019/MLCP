{
    "link": "https://codeforces.com//contest/1260/problem/F",
    "problemId": "482538",
    "problem_idx": "F",
    "shortId": "1260F",
    "contest_number": "1260",
    "problem_submissions": {
        "F": [
            65858730,
            65862568,
            66652397,
            66566066,
            66562444,
            66562321,
            66562191,
            66549616,
            66548423,
            66547174,
            66518194,
            66518036,
            66517620,
            66510535,
            66510382,
            66510329,
            66510272,
            66510123,
            66479420,
            66479366,
            66477381,
            66477286,
            66476986,
            66321512,
            66246571,
            66246300,
            66238302,
            66238072,
            66237291,
            66208821,
            66204798,
            66204686,
            66203676,
            66203473,
            66203066,
            66202735,
            66202708,
            66159751,
            66157778,
            66157649,
            66157618,
            66156988,
            65877182,
            65877041,
            65876947,
            65876872,
            65876803,
            65876438,
            65866876,
            66367088,
            65866080,
            65866251,
            65864285,
            65877636,
            65873623,
            65885023,
            66605734,
            66774965
        ],
        "E": [
            65846156,
            65847430,
            65837398,
            65853743,
            65845843,
            65855348,
            65845810,
            65888526,
            65846187,
            65841086,
            65850296,
            65842358,
            65848204,
            65850447,
            65852329,
            65852192,
            65851204,
            65854002,
            65852510
        ],
        "D": [
            65842916,
            65839945,
            65842733,
            65847161,
            65840341,
            65840171,
            65846096,
            65839274,
            65888522,
            65837646,
            65842330,
            65843302,
            65851742,
            65843499,
            65843987,
            65845327,
            65933516,
            65844977,
            65845445,
            65847585,
            65843731
        ],
        "C": [
            65833157,
            65835911,
            65834737,
            65835945,
            65833091,
            65840410,
            65832981,
            65888509,
            65833437,
            65830880,
            65835473,
            65834819,
            65835069,
            65838384,
            65834359,
            65834145,
            65837535,
            65834275,
            65835760
        ],
        "B": [
            65831075,
            65831703,
            65829870,
            65830692,
            65829912,
            65833299,
            65829889,
            65888498,
            65829702,
            65829574,
            65830168,
            65831336,
            65830234,
            65832147,
            65830305,
            65830813,
            65831299,
            65830442,
            65831731
        ],
        "A": [
            65829790,
            65829709,
            65829549,
            65829616,
            65829579,
            65830086,
            65829577,
            65888488,
            65829556,
            65829530,
            65829593,
            65829726,
            65829617,
            65830283,
            65829711,
            65829913,
            65830075,
            65829704,
            65830725
        ]
    },
    "name": "F. Colored Tree",
    "statement": "You\u2019re given a tree with n vertices. The color of the i-th vertex is\r\nh_{i}.The value of the tree is defined as\r\nsum\r\nlimits_{h_{i} = h_{j}, 1\r\nle i < j\r\nle n}{dis(i,j)}, where dis(i,j) is the number of edges on the shortest\r\npath between i and j. The color of each vertex is lost, you only\r\nremember that h_{i} can be any integer from [l_{i}, r_{i}](inclusive).\r\nYou want to calculate the sum of values of all trees meeting these\r\nconditions modulo 10^9 + 7 (the set of edges is fixed, but each color is\r\nunknown, so there are\r\nprod\r\nlimits_{i = 1}^{n} (r_{i} - l_{i} + 1) different trees).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int mod = 1e9 + 7;\nint n;\nint C[100005];\nvector<int> A[100005];\nvector<int> E[100005];\n\nll pw(ll x, ll p) {\n    if (p == 0) return 1;\n    if (p == 1) return x;\n    ll v = pw(x, p / 2);\n    v = v * v % mod;\n    if (p % 2 != 0) v = v * x % mod;\n    return v;\n}\n\nint sz[100005];\nint de[100005];\n\nvoid dfs1(int x, int p) {\n    sz[x] = 1;\n    for (int i : E[x]) {\n        if (i == p || de[i]) continue;\n        dfs1(i, x);\n        sz[x] += sz[i];\n    }\n}\n\nint dfs2(int x, int p, int n) {\n    for (int i : E[x]) {\n        if (i == p || de[i]) continue;\n        if (sz[i] > n / 2) return dfs2(i, x, n);\n    }\n    return x;\n}\n\nint D[100005][20];\nint G[100005][20];\n\nvoid dfs3(int x, int p, int s, int d, int g) {\n    D[x][d] = s;\n    G[x][d] = g;\n    for (int i : E[x]) {\n        if (i == p || de[i]) continue;\n        dfs3(i, x, s + 1, d, g);\n    }\n}\n\nint P[100005];\nint L[100005];\nll csum[100005];\nvector<ll> cisum[100005];\nll dsum[100005];\nvector<ll> disum[100005];\nint cent_decomp(int x, int d) {\n    dfs1(x, 0);\n    x = dfs2(x, 0, sz[x]);\n    L[x] = d;\n    D[x][d] = 0;\n    G[x][d] = 0;\n    cisum[x].push_back(0);\n    disum[x].push_back(0);\n    for (int i : E[x]) {\n        if (de[i]) continue;\n        dfs3(i, x, 1, d, cisum[x].size());\n        cisum[x].push_back(0);\n        disum[x].push_back(0);\n    }\n    de[x] = 1;\n    for (int i : E[x]) {\n        if (de[i]) continue;\n        P[cent_decomp(i, d + 1)] = x;\n    }\n    return x;\n}\n\nll query(int x, int t) {\n    ll ans = 0;\n    for (int c = x; c; c = P[c]) {\n        int d = L[c];\n        ll add = (ll)t * D[x][d] % mod;\n        ans += (csum[c] + mod - cisum[c][G[x][d]]) * add % mod;\n        ans += (dsum[c] + mod - disum[c][G[x][d]]) * t % mod;\n        csum[c] = (csum[c] + t) % mod;\n        cisum[c][G[x][d]] = (cisum[c][G[x][d]] + t) % mod;\n        dsum[c] = (dsum[c] + add) % mod;\n        disum[c][G[x][d]] = (disum[c][G[x][d]] + add) % mod;\n    }\n    return ans % mod;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    ll all = 1;\n    for (int i = 1; i <= n; i++) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        A[l].push_back(i);\n        A[r + 1].push_back(-i);\n        all = all * (r - l + 1) % mod;\n        C[i] = pw(r - l + 1, mod - 2);\n    }\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        E[u].push_back(v);\n        E[v].push_back(u);\n    }\n    cent_decomp(1, 0);\n    ll ans = 0, sum = 0;\n    for (int i = 1; i <= 100000; i++) {\n        for (int j : A[i]) {\n            if (j < 0) {\n                sum += query(-j, mod - C[-j]);\n            }\n            else {\n                sum += query(j, C[j]);\n            }\n        }\n        sum %= mod;\n        ans += sum;\n        ans %= mod;\n    }\n    printf(\"%lld\\n\", ans * all % mod);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Colored Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/71805",
    "editorial": "Let\u00e2\u0080\u0099s set the root as . Define as the lowest common ancestor of vertices\r\nand , as the depth of vertex . Obviously .The answer we want to\r\ncalculate is where represent all possible colorings of the tree.We can\r\nenumerate the color . For a fixed color , we need to calculate Let .\r\nAlso denote as a predicate which is true iff .Now our problem is how to\r\nmaintain this formula while enumerating the color . can be easily\r\nmaintained. For , we can add to all vertices in path to (for each\r\nexisting vertex ), and when new vertex is added, just calculate the sum\r\nof vertices on path from to , minus the contribution of vertex (because\r\nthere are vertices in the path to ), and multiply it . Similar operation\r\ncan be used to handle the situation when some vertex disappears. All of\r\nthis can be done with HLD.Overall it\u00e2\u0080\u0099s .\r\n"
}