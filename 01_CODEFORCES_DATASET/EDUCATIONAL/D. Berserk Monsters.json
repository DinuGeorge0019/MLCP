{
    "link": "https://codeforces.com//contest/1922/problem/D",
    "problemId": "2433277",
    "problem_idx": "D",
    "shortId": "1922D",
    "contest_number": "1922",
    "problem_submissions": {
        "F": [
            242258354,
            242278276,
            242274562,
            242271525,
            242258097,
            242274599,
            242271507,
            242268588,
            242285652,
            242271581,
            242270540,
            242278542,
            242282333,
            242270699,
            242270119,
            242276867,
            242286431,
            242276715,
            242276487,
            242283192,
            242281108,
            242278860,
            242278983,
            242285548
        ],
        "E": [
            242241568,
            242225493,
            242242029,
            242279592,
            242237693,
            242231955,
            242236354,
            242245342,
            242255638,
            242244187,
            242239291,
            242260117,
            242249388,
            242249138,
            242239806,
            242257431,
            242256396,
            242263321,
            242231103,
            242254535,
            242253629,
            242270325
        ],
        "D": [
            242234045,
            242236857,
            242236461,
            242246467,
            242239405,
            242245547,
            242240299,
            242240756,
            242237650,
            242234866,
            242248459,
            242242872,
            242244162,
            242252228,
            242244373,
            242239696,
            242254494,
            242245049,
            242250144,
            242243755,
            242246758
        ],
        "C": [
            242227385,
            242230966,
            242228502,
            242224242,
            242227745,
            242228850,
            242229081,
            242228504,
            242227487,
            242227235,
            242229333,
            242232708,
            242229815,
            242234164,
            242230429,
            242229813,
            242239026,
            242239967,
            242231740,
            242235920
        ],
        "B": [
            242220641,
            242221058,
            242221110,
            242219955,
            242221311,
            242233194,
            242221713,
            242221320,
            242222042,
            242223201,
            242221647,
            242219752,
            242221561,
            242226204,
            242224089,
            242222658,
            242227596,
            242222002,
            242224729,
            242223236
        ],
        "A": [
            242219259,
            242219714,
            242223200,
            242219077,
            242219362,
            242220179,
            242219565,
            242219194,
            242219734,
            242219881,
            242219505,
            242219046,
            242219400,
            242221402,
            242220981,
            242220554,
            242223002,
            242219741,
            242219322,
            242220234
        ]
    },
    "name": "D. Berserk Monsters",
    "statement": "Monocarp is playing a computer game (yet again). Guess what is he doing?\r\nThat’s right, killing monsters.There are n monsters in a row, numbered\r\nfrom 1 to n. The i-th monster has two parameters: attack value equal to\r\na_i and defense value equal to d_i. In order to kill these monsters,\r\nMonocarp put a berserk spell on them, so they’re attacking each other\r\ninstead of Monocarp’s character.The fight consists of n rounds. Every\r\nround, the following happens: first, every alive monster i deals a_i\r\ndamage to the alive monster to the left (if it exists) and the alive\r\nmonster to the right (if it exists); then, every alive monster j which\r\nreceived more than d_j damage dies. I. e. the j-th monster dies if and\r\nonly if its defense value d_j is than the total damage it received . For\r\neach round, calculate the number of monsters that will die during that\r\nround.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"  // https://github.com/Heltion/debug.h/blob/main/debug.h\n#else\n#define debug(...) (void)417\n#endif\nusing i64 = int64_t;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ti += 1) {\n    int n;\n    cin >> n;\n    vector<int> a(n), d(n);\n    for (int& ai : a) { cin >> ai; }\n    for (int& di : d) { cin >> di; }\n    set<int> alive, die;\n    for (int i = 0; i < n; i += 1) { alive.insert(i); }\n    for (int i = 0; i < n; i += 1) {\n      if ((i ? a[i - 1] : 0) + (i + 1 < n ? a[i + 1] : 0) > d[i]) {\n        die.insert(i);\n      }\n    }\n    for (int i = 0; i < n; i += 1) {\n      cout << die.size() << \" \";\n      set<int> to_die;\n      for (int x : die) { alive.erase(x); }\n      auto check = [&](auto it) {\n        if ((it != alive.begin() ? a[*prev(it)] : 0) +\n                (next(it) != alive.end() ? a[*next(it)] : 0) >\n            d[*it]) {\n          to_die.insert(*it);\n        }\n      };\n      for (int x : die) {\n        auto it = alive.lower_bound(x);\n        if (it != alive.end()) { check(it); };\n        if (it != alive.begin()) { check(prev(it)); };\n      }\n      to_die.swap(die);\n    }\n    cout << \"\\n\";\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "dsu",
        "implementation",
        "math"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Berserk Monsters.json",
    "editorial_link": "https://codeforces.com//blog/entry/124890",
    "editorial": "It is important to note that if during the -th round the -th monster did\r\nnot die and none of its alive neighbors died, then there is no point in\r\nchecking this monster in the -th round. Therefore, we can solve the\r\nproblem as follows: letâs maintain a list of candidates (those who can\r\ndie) for the current round; if the monster dies in the current round,\r\nthen add its neighbors to the list of candidates for the next\r\nround.Since killing a monster adds no more than candidates, the total\r\nsize of the candidate lists for all rounds does not exceed (since the\r\nsize of the list for the first round is equal to plus no more than for\r\neach killed monster). Therefore, we can simply iterate through these\r\nlists to check if the monster will be killed.The only problem left is\r\nfinding the alive neighbors of the monster (to check whether he is\r\nkilled or not during the round). This can be done by creating an ordered\r\nwith the indices of the monsters. allows us to remove the killed ones\r\nand find neighboring monsters in .Thus, the solution works in .\r\n",
    "hint": []
}