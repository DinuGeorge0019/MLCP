{"link": "https://codeforces.com//contest/1167/problem/G", "problemId": "344636", "problem_idx": "G", "shortId": "1167G", "contest_number": "1167", "problem_submissions": {"G": [54199521, 54201009, 54517594, 54222661, 54364012, 54215552, 54224700, 54210170, 54210125, 54210060, 54209496, 54208961, 54219271, 58247930], "F": [54189763, 54191560, 54188017, 54193815, 54198047, 54197721, 54195395, 54190513, 54198962, 54198980, 54197783, 54198116, 54209016, 54200221, 54197337, 54195561, 54196921, 54190680, 54201016, 54197503, 54199324], "E": [54187099, 54187335, 54196048, 54186318, 54187789, 54191563, 54192086, 54195810, 54191131, 54191667, 54192242, 54194803, 54192777, 54191266, 54189610, 54192694, 54196385, 54241812, 54208508, 54196237, 54192975, 54196282], "D": [54184655, 54183868, 54182601, 54254072, 54187816, 54183265, 54184958, 54187415, 54186508, 54185650, 54184214, 54187917, 54185330, 54215169, 54214062, 54213957, 54213940, 54212912, 54212894, 54186804, 54192578, 54182335, 54185963, 54184762, 54186406, 54188164, 54188808], "C": [54183325, 54182652, 54179797, 54181639, 54180270, 54183029, 54186018, 54184791, 54184638, 54183698, 54183060, 54181938, 54183556, 54183141, 54183089, 54180288, 54184423, 54183220, 54184555, 54185863, 54182921], "B": [54182048, 54181521, 54184836, 54179971, 54182085, 54181491, 54183487, 54185276, 54182631, 54181677, 54186071, 54182415, 54181445, 54182146, 54198453, 54183319, 54181503, 54182555, 54184235, 54186573], "A": [54178078, 54178458, 54177903, 54177871, 54177876, 54178109, 54178374, 54178382, 54178054, 54178274, 54179924, 54177952, 54177881, 54177926, 54178075, 54177978, 54177900, 54179121, 54179411, 54179558]}, "name": "G. Low Budget Inception", "statement": "So we got bored and decided to take our own guess at how would\r\n\"Inception\" production go if the budget for the film had been terribly\r\nlow.The first scene we remembered was the one that features the whole\r\ncity bending onto itself: It feels like it will require high CGI\r\nexpenses, doesn\u2019t it? Luckily, we came up with a similar-looking scene\r\nwhich was a tiny bit cheaper to make.Firstly, forget about 3D, that\u2019s\r\nhard and expensive! The city is now represented as a number line\r\n().Secondly, the city doesn\u2019t have to look natural at all. There are n\r\nbuildings on the line. Each building is a square 1\r\ntimes 1. Lower corners of building i are at integer points a_i and a_i +\r\n1 of the number line. Also the distance between any two neighbouring\r\nbuildings i and i + 1 doesn\u2019t exceed d (). Distance between some\r\nneighbouring buildings i and i + 1 is calculated from the lower right\r\ncorner of building i to the lower left corner of building i + 1.Finally,\r\ncurvature of the bend is also really hard to simulate! Let the bend at\r\nsome integer coordinate x be performed with the following algorithm.\r\nTake the ray from x to +\r\ninfty and all the buildings which are on this ray and start turning the\r\nray and the buildings counter-clockwise around point x. At some angle\r\nsome building will touch either another building or a part of the line.\r\nYou have to stop bending there (). The only thing left is to decide what\r\ninteger point x is the best to start bending around. Fortunately, we\u2019ve\r\nalready chosen m candidates to perform the bending.So, can you please\r\nhelp us to calculate terminal angle\r\nalpha_x for each bend x from our list of candidates?\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nusing ld=long double;\nconst ld pi=2*acosl(0);\n\nint n, d;\nll tab[nax];\n\nint q;\n\nld kont(int a)\n{\n\treturn atan(1.0/a);\n}\n\nld kont(int a, int b)\n{\n\tassert(abs(a-b)<=1);\n\treturn 2*kont(max(a, b));\n}\n\nvoid out(ld v)\n{\n\tprintf(\"%.11lf\\n\", (double)v);\n}\n\nvoid query()\n{\n\tll x;\n\tscanf(\"%lld\", &x);\n\tif (x==tab[0] || x==tab[n]+1)\n\t{\n\t\tout(pi/2);\n\t\treturn;\n\t}\n\tint bsa=1;\n\tint bsb=n-1;\n\twhile(bsa<bsb)\n\t{\n\t\tint bss=(bsa+bsb+2)>>1;\n\t\tif (x>tab[bss])\n\t\t\tbsa=bss;\n\t\telse\n\t\t\tbsb=bss-1;\n\t}\n\tint g=bsa;\n\tassert(x>tab[g] && x<=tab[g+1]);\n\tif (x==tab[g]+1 && x==tab[g+1])\n\t{\n\t\tout(pi);\n\t\treturn;\n\t}\n\tif (x==tab[g]+1 || x==tab[g+1])\n\t{\n\t\tout(pi/2);\n\t\treturn;\n\t}\n\tld wyn=kont(min(tab[g+1]-x, x-tab[g]-1));\n\tint a=g;\n\tint b=g+1;\n\tconst ll lim=min(tab[g+1]-x, x-tab[g]-1)*2+7;\n\twhile(a>0 && b<=n && tab[b]-x<=lim)\n\t{\n\t\tif (abs( (x-tab[a]-1)-(tab[b]-x) )<=1)\n\t\t\tbreak;\n\t\tif (x-tab[a]-1<tab[b]-x)\n\t\t\ta--;\n\t\telse\n\t\t\tb++;\n\t}\n\tif (a>=1 && b<=n && abs( (x-tab[a]-1)-(tab[b]-x) )<=1)\n\t\twyn=max(wyn, kont(x-tab[a]-1, tab[b]-x));\n\tout(wyn);\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &d);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &tab[i]);\n\tscanf(\"%d\", &q);\n\twhile(q--)\n\t\tquery();\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["brute force", "geometry"], "dificulty": "3100", "interactive": false}