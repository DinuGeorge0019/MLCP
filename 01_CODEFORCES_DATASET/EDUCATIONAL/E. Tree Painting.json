{
    "link": "https://codeforces.com//contest/1187/problem/E",
    "problemId": "365121",
    "problem_idx": "E",
    "shortId": "1187E",
    "contest_number": "1187",
    "problem_submissions": {
        "G": [
            56332310,
            56340989,
            56686103,
            56327820,
            56357942,
            56357893,
            56357546,
            56393615,
            56385554,
            56337872,
            56340206,
            56343105,
            56383525,
            56344635,
            56413429,
            56342762,
            56340438,
            56341811,
            56342716,
            56365621
        ],
        "F": [
            56329446,
            56334290,
            56324078,
            56328221,
            56327378,
            56337303,
            56342526,
            56331177,
            56340043,
            56336355,
            56334752,
            56336077,
            56336627,
            56360333
        ],
        "E": [
            56323030,
            56330456,
            56319363,
            56322371,
            56320247,
            56329005,
            56327923,
            56326133,
            56329409,
            56326249,
            56424958,
            56328252,
            56326656,
            56325346,
            56328882,
            56328436,
            56328661,
            56323830,
            56324440,
            56325389
        ],
        "D": [
            56321688,
            56327439,
            56325081,
            56328701,
            56323355,
            56322789,
            56358499,
            56324879,
            56323568,
            56320080,
            56323458,
            56413111,
            56325452,
            56541360,
            56321839,
            56320767,
            56323441
        ],
        "C": [
            56317291,
            56315455,
            56314711,
            56314827,
            56313223,
            56319121,
            56318984,
            56317025,
            56320070,
            56318484,
            56425545,
            56329379,
            56320274,
            56318352,
            56316738,
            56318754,
            56319277,
            56317240,
            56316893,
            56317391
        ],
        "B": [
            56314215,
            56313013,
            56312493,
            56311346,
            56311654,
            56315580,
            56313289,
            56312101,
            56313618,
            56315894,
            56313703,
            56315753,
            56314242,
            56313556,
            56315340,
            56314265,
            56313400,
            56314155,
            56314393
        ],
        "A": [
            56311354,
            56311017,
            56311059,
            56312444,
            56310978,
            56312306,
            56311272,
            56310955,
            56311255,
            56311625,
            56311777,
            56313786,
            56311277,
            56310994,
            56311316,
            56311426,
            56311025,
            56311856,
            56311363
        ]
    },
    "name": "E. Tree Painting",
    "statement": "You are given a tree (an undirected connected acyclic graph) consisting\r\nof n vertices. You are playing a game on this tree.Initially all\r\nvertices are white. On the first turn of the game you choose one vertex\r\nand paint it black. Then on each turn you choose a white vertex adjacent\r\n(connected by an edge) to black vertex and paint it black.Each time when\r\nyou choose a vertex (even during the first turn), you gain the number of\r\npoints equal to the size of the connected component consisting only of\r\nwhite vertices that contains the chosen vertex. The game ends when all\r\nvertices are painted black.Let\u2019s see the following example:Vertices 1\r\nand 4 are painted black already. If you choose the vertex 2, you will\r\ngain 4 points for the connected component consisting of vertices 2, 3, 5\r\nand 6. If you choose the vertex 9, you will gain 3 points for the\r\nconnected component consisting of vertices 7, 8 and 9.Your task is to\r\nmaximize the number of points you gain.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nvi graf[nax];\n\nint roz[nax];\n\nll wyn;\n\nvoid dfs1(int v, int oj)\n{\n\troz[v]=1;\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t\tcontinue;\n\t\tdfs1(i, v);\n\t\troz[v]+=roz[i];\n\t}\n}\n\nvoid dfs2(int v, int oj, ll s)\n{\n\twyn=max(wyn, s);\n\tfor (int i : graf[v])\n\t{\n\t\tif (i==oj)\n\t\t\tcontinue;\n\t\tdfs2(i, v, s-roz[i]+n-roz[i]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraf[a].push_back(b);\n\t\tgraf[b].push_back(a);\n\t}\n\tdfs1(1, 0);\n\tll s=0;\n\tfor (int i=1; i<=n; i++)\n\t\ts+=roz[i];\n\tdfs2(1, 0, s);\n\t\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Tree Painting.json",
    "editorial_link": "https://codeforces.com//blog/entry/68111",
    "editorial": "I should notice that there is much simpler idea and solution for this\r\nproblem without rerooting technique but I will try to explain rerooting\r\nas the main solution of this problem (it can be applied in many problems\r\nand this is just very simple example).What if the root of the tree is\r\nfixed? Then we can notice that the answer for a subtree can be\r\ncalculated as , where is the set of children of the vertex . The answer\r\non the problem for the fixed root will be .How can we calculate all\r\npossible values of for each root from to fast enough? We can apply\r\nrerooting! When we change the root of tree from the vertex to the vertex\r\n, we can notice that only four values will change: and . Firstly, we\r\nneed to cut the subtree of from the tree rooted at . Let\u00e2\u0080\u0099s subtract and\r\nfrom , then let\u00e2\u0080\u0099s change the size of the subtree of (subtract from it).\r\nNow we have the tree without the subtree of . Then we need to append as\r\na child of . Add to and add and to . Now we have as a root of the tree\r\nand can update the answer with . When we changes the root of the tree\r\nback from to , we just need to rollback all changes we made.So, overall\r\nidea is the following: calculate sizes of subtrees for some fixed root,\r\ncalculate dynamic programming for this root, run dfs which will reroot\r\nthe tree with any possible vertex and update the answer with the value\r\nof dynamic programming for each possible root.The code of function that\r\nreroots the tree seems like this: void dfs(int v, int p = -1) { ans =\r\nmax(ans, dp[v]); for (auto to : g[v]) { if (to == p) continue; dp[v] -=\r\ndp[to]; dp[v] -= siz[to]; siz[v] -= siz[to]; siz[to] += siz[v]; dp[to]\r\n+= siz[v]; dp[to] += dp[v]; dfs(to, v); dp[to] -= dp[v]; dp[to] -=\r\nsiz[v]; siz[to] -= siz[v]; siz[v] += siz[to]; dp[v] += siz[to]; dp[v] +=\r\ndp[to]; }}\r\n"
}