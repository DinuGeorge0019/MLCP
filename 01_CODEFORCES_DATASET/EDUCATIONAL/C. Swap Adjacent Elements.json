{
    "link": "https://codeforces.com//contest/920/problem/C",
    "problemId": "152863",
    "problem_idx": "C",
    "shortId": "920C",
    "contest_number": "920",
    "problem_submissions": {
        "G": [
            34852743,
            34853590,
            34854300,
            34853934,
            34856261,
            34853609,
            34857997,
            34854137,
            34863997,
            34863325,
            34845932,
            35124212,
            35123972,
            34865228,
            34854370,
            34856832,
            34844552,
            34869557,
            34855295,
            34853458,
            34855692,
            34852849,
            34855311,
            34861027,
            34859762
        ],
        "F": [
            34850786,
            34848482,
            34849125,
            34847410,
            34850587,
            34855922,
            34851634,
            34865588,
            34861253,
            34849345,
            35122442,
            34861362,
            34851005,
            34852570,
            34847838,
            34850627,
            34847445,
            34849654,
            34849272,
            34857704,
            34855104,
            34855630
        ],
        "E": [
            34849129,
            34851685,
            34845896,
            34844151,
            34856145,
            34852326,
            34847420,
            34858206,
            34852441,
            35117849,
            34858048,
            34856421,
            64420065,
            59900329,
            59900252,
            34850422,
            34851876,
            34846457,
            34850665,
            34846959,
            34846751,
            34850722,
            34850540,
            34853490
        ],
        "D": [
            34846246,
            34857983,
            34865210,
            34864920,
            34863172,
            34865887,
            34863373,
            34855083,
            34863045,
            34852180,
            34864800,
            34865039,
            34861962,
            34930637,
            34904017,
            34882639,
            34870887,
            34935056,
            34932865
        ],
        "C": [
            34843334,
            34845308,
            34844415,
            34853136,
            34845188,
            34848715,
            34849757,
            34845177,
            34857782,
            35115887,
            35115738,
            35114927,
            34846351,
            34860924,
            34843957,
            34863534,
            34843082,
            34844466,
            34843157,
            34844360,
            34846666,
            34847453,
            34846518
        ],
        "B": [
            34842856,
            34846490,
            34843649,
            34849908,
            34843576,
            34845185,
            34844678,
            34844108,
            34855655,
            35114208,
            34844457,
            34859635,
            34842933,
            34867088,
            34844653,
            34842667,
            34842611,
            34843316,
            34845332,
            34845365,
            34845176
        ],
        "A": [
            34842470,
            34844425,
            34842543,
            34843209,
            34842761,
            34843665,
            34842482,
            34842652,
            34854235,
            35113527,
            34842534,
            34843074,
            34842510,
            34864789,
            34842605,
            34842461,
            34842474,
            34849846,
            34842901,
            34843015,
            34842733
        ]
    },
    "name": "C. Swap Adjacent Elements",
    "statement": "You have an array consisting of integers. Each integer from to appears\r\nexactly once in this array.For some indices () it is possible to swap\r\n-th element with -th, for other indices it is not possible. You may\r\nperform any number of swapping operations any order. There is no limit\r\non the number of times you swap -th element with -th (if the position is\r\nnot forbidden).Can you make this array sorted in ascending order\r\nperforming some sequence of swapping operations?\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nint mx[200050];\nint mn[200050];\nint in[200050];\nchar u[200050];\nint main() {\n\tint N, i;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i <= N; i++) scanf(\"%d\", &in[i]);\n\tfor (i = 1; i <= N; i++) mx[i] = max(mx[i - 1], in[i]);\n\tmn[N + 1] = INF;\n\tfor (i = N; i >= 1; i--) mn[i] = min(mn[i + 1], in[i]);\n\n\tscanf(\"%s\", u + 1);\n\tfor (i = 1; i < N; i++) {\n\t\tif (u[i] == '1') continue;\n\t\tif (mx[i] > mn[i + 1]) return !printf(\"NO\\n\");\n\t}\n\treturn !printf(\"YES\\n\");\n}\n//*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "greedy",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Swap Adjacent Elements.json",
    "editorial_link": "https://codeforces.com/blog/entry/57516",
    "editorial": "Take a look at some pair such that and initial . It means that all the\r\nswaps from to should be allowed. Then itâs easy to notice that itâs\r\nenough to check only and as any other pair can be deducted from this.\r\nYou can precalc for each and prefix sums over the string of allowed\r\nswaps to check it in no time.Overall complexity: .\r\n",
    "hint": []
}