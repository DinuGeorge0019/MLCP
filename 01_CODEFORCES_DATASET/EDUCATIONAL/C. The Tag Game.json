{
    "link": "https://codeforces.com//contest/813/problem/C",
    "problemId": "108590",
    "problem_idx": "C",
    "shortId": "813C",
    "contest_number": "813",
    "problem_submissions": {
        "F": [
            27592959,
            27592462,
            27595859,
            27593693,
            27589826,
            27597032,
            27592495,
            27594242,
            27592969,
            27592265,
            27592101,
            27593647,
            27593448,
            27607698,
            27607690,
            27597005
        ],
        "D": [
            27591413,
            27596376,
            27595878,
            27592392,
            27596101,
            27595104,
            27676236,
            27675210,
            27591510,
            27603640,
            27593900,
            27624567,
            27624550,
            27624539,
            27628580,
            27593089,
            27592322,
            28282372,
            28281379
        ],
        "E": [
            27590671,
            27593775,
            27594164,
            27598623,
            27590165,
            27587725,
            27590977,
            27593884,
            27590632,
            27590190,
            27593976,
            27593899,
            27591757,
            27595354,
            27602821,
            27589094,
            27596364,
            27590212,
            27590714,
            27590708
        ],
        "C": [
            27586798,
            27589288,
            27588038,
            27588205,
            27585642,
            27587654,
            27587622,
            27598220,
            27588200,
            27597496,
            27586750,
            27587670,
            27588183,
            27589351,
            27598034,
            27587880,
            27588758,
            27588420,
            27587303,
            27587398,
            27597722,
            27588272
        ],
        "B": [
            27587426,
            27586981,
            27586763,
            27590844,
            27586387,
            27587082,
            27586616,
            27585981,
            27586358,
            27586732,
            27588430,
            27586365,
            27587378,
            27586643,
            27586207,
            27586121
        ],
        "A": [
            27586386,
            27585541,
            27587254,
            27590210,
            27585562,
            27585639,
            27585557,
            27585471,
            27585490,
            27585606,
            27586831,
            27585625,
            27586127,
            27585762,
            27585515,
            27585489,
            27585475
        ]
    },
    "name": "C. The Tag Game",
    "statement": "Alice got tired of playing the tag game by the usual rules so she\r\noffered Bob a little modification to it. Now the game should be played\r\non an undirected rooted tree of vertices. Vertex is the root of the\r\ntree.Alice starts at vertex and Bob starts at vertex (). The moves are\r\nmade in turns, Bob goes first. In one move one can either stay at the\r\ncurrent vertex or travel to the neighbouring one.The game ends when\r\nAlice goes to the same vertex where Bob is standing. Alice wants to\r\nminimize the total number of moves and Bob wants to maximize it.You\r\nshould write a program which will determine how many moves will the game\r\nlast.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define N 202020\nvector<int> v[ N ];\nint n , x , dep[ N ] , ans;\nvoid go( int now , int prt , int ndep ){\n  dep[ now ] = ndep;\n  for( int son : v[ now ] ){\n    if( son == prt ) continue;\n    go( son , now , ndep + 1 );\n  }\n}\nint bdr;\nvoid go2( int now , int prt ){\n  if( dep[ now ] <= bdr ) return;\n  ans = max( ans , dep[ now ] );\n  for( int son : v[ now ] ){\n    if( son == prt ) continue;\n    go2( son , now );\n  }\n}\nint main(){\n  cin >> n >> x;\n  for( int i = 1 ; i < n ; i ++ ){\n    int a , b; cin >> a >> b;\n    v[ a ].push_back( b );\n    v[ b ].push_back( a );\n  }\n  go( 1 , 1 , 0 );\n  bdr = dep[ x ] / 2;\n  go2( x , x );\n  printf( \"%d\\n\" , ans << 1 );\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. The Tag Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/52410",
    "editorial": "If you check some games then you will notice that the most optimal\r\nstrategy for Bob is always like this: Climb up for some steps (possibly\r\nzero) Go to the lowest vertex from it Stay in this vertex till the end\r\nThus letâs precalc the depth (the distance from the root) of the lowest\r\nvertex of each subtree (using dfs), distance from Aliceâs starting node\r\nand from Bobâs starting node to the vertex (again dfs/bfs).Now iterate\r\nover all vertices and check if Bob can reach this vertex earlier than\r\nAlice. If he can then update the answer with the lowest vertex that can\r\nbe reached from this one.The answer is doubled depth of the obtained\r\nlowest reachable vertex. That is the time which will take Alice to get\r\nthere.Overall complexity: .\r\n",
    "hint": []
}