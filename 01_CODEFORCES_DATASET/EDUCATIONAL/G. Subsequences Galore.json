{
    "link": "https://codeforces.com//contest/1620/problem/G",
    "problemId": "1233294",
    "problem_idx": "G",
    "shortId": "1620G",
    "contest_number": "1620",
    "problem_submissions": {
        "G": [
            139834723,
            139834630,
            139800025,
            139798720,
            139797780,
            139795833,
            139793177,
            139797195,
            139801753,
            139800125,
            139798252,
            139806590,
            139801965,
            139799470,
            139800885,
            139815133,
            139836989,
            139836961,
            139803234,
            139783937,
            139766371,
            139781791,
            198626640,
            139785516,
            139791910,
            139794593,
            139799506,
            139797098,
            139802371,
            139794714
        ],
        "E": [
            139834170,
            139768900,
            139778404,
            139777262,
            139781401,
            139780307,
            180264469,
            139772320,
            139783598,
            139787731,
            139788776,
            139795635,
            139801166,
            139803161,
            139771172,
            139772982,
            139775572,
            139777494,
            139781749,
            139783689,
            139782938,
            139773708
        ],
        "D": [
            139828795,
            139828599,
            139828445,
            139801175,
            139773916,
            139773661,
            139775200,
            139772309,
            139777532,
            139778435,
            139852816,
            139778132,
            139769927,
            139780286,
            139786796,
            139790402,
            139791529,
            139805624,
            139765400,
            139770581,
            139781836,
            139766109,
            139779076,
            139774566,
            139785166
        ],
        "F": [
            139826678,
            139786211,
            139791869,
            139787814,
            139791341,
            139788904,
            139814807,
            139811473,
            139818294,
            139801200,
            139837073,
            139811622,
            139810717,
            139801430,
            139908478,
            139834808,
            139830354
        ],
        "B": [
            139800559,
            139758636,
            139759221,
            139759228,
            139768929,
            139762743,
            139760389,
            139791856,
            139762557,
            139759423,
            139779986,
            139793644,
            139810932,
            139757813,
            139761675,
            139760955,
            139759416,
            139760977,
            139759368,
            139760377
        ],
        "C": [
            139765159,
            139765932,
            139765302,
            139774145,
            139773181,
            207683198,
            139765484,
            139764863,
            139771290,
            139772950,
            139784482,
            139796217,
            139807967,
            139762141,
            139766772,
            139767896,
            139775442,
            139767619,
            139767081,
            139780353
        ],
        "A": [
            139756564,
            139756597,
            139756503,
            139756739,
            139759409,
            139756692,
            139757881,
            139756729,
            139756611,
            139777143,
            139792512,
            139812388,
            139756396,
            139756654,
            139757129,
            139756551,
            139756903,
            139756439,
            139756571
        ]
    },
    "name": "G. Subsequences Galore",
    "statement": "For a sequence of strings [t_1, t_2,\r\ndots, t_m], let’s define the function f([t_1, t_2,\r\ndots, t_m]) as the number of different strings () that are subsequences\r\nof string t_i. f([]) = 0 (i. e. the number of such strings for an empty\r\nsequence is 0).You are given a sequence of strings [s_1, s_2,\r\ndots, s_n]. Every string in this sequence consists of lowercase Latin\r\nletters and is (i. e., each string begins with several (maybe zero)\r\ncharacters , then several (maybe zero) characters , ..., ends with\r\nseveral (maybe zero) characters ).For each of 2^n subsequences of [s_1,\r\ns_2,\r\ndots, s_n], calculate the value of the function f modulo 998244353.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    static const int SAVE_INV = int(1e6) + 5;\n    static _m_int save_inv[SAVE_INV];\n\n    static void prepare_inv() {\n        // Ensures that MOD is prime, which is necessary for the inverse algorithm below.\n        for (int64_t p = 2; p * p <= MOD; p += p % 2 + 1)\n            assert(MOD % p != 0);\n\n        save_inv[0] = 0;\n        save_inv[1] = 1;\n\n        for (int i = 2; i < SAVE_INV; i++)\n            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);\n    }\n\n    _m_int inv() const {\n        if (save_inv[1] == 0)\n            prepare_inv();\n\n        if (val < SAVE_INV)\n            return save_inv[val];\n\n        _m_int product = 1;\n        int v = val;\n\n        do {\n            product *= MOD - MOD / v;\n            v = MOD % v;\n        } while (v >= SAVE_INV);\n\n        return product * save_inv[v];\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\ntemplate<const int &MOD> _m_int<MOD> _m_int<MOD>::save_inv[_m_int<MOD>::SAVE_INV];\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\n// Does the inverse of `submask_sums`; returns the input that produces the given output.\ntemplate<typename T_out, typename T_in>\nvoid mobius_transform(int n, vector<T_in> &values) {\n    assert(int(values.size()) == 1 << n);\n\n    for (int i = 0; i < n; i++)\n        for (int base = 0; base < 1 << n; base += 1 << (i + 1))\n            for (int mask = base; mask < base + (1 << i); mask++)\n                values[mask + (1 << i)] -= values[mask];\n}\n\n\nconst int ALPHABET = 26;\nconst char MIN_CHAR = 'a';\nconst int S_MAX = 20005;\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N;\n    cin >> N;\n    vector<vector<uint16_t>> S(ALPHABET, vector<uint16_t>(N, 0));\n\n    for (int i = 0; i < N; i++) {\n        string str;\n        cin >> str;\n\n        for (auto &ch : str)\n            S[ch - MIN_CHAR][i]++;\n    }\n\n    vector<mod_int> dp(1 << N, 1);\n    dp[0] = 0;\n\n    for (int c = 0; c < ALPHABET; c++) {\n        vector<uint16_t> mins(1 << N, S_MAX);\n\n        for (int mask = 1; mask < 1 << N; mask++) {\n            int low = __builtin_ctz(mask);\n            mins[mask] = min(mins[mask ^ 1 << low], S[c][low]);\n            dp[mask] *= mins[mask] + 1;\n        }\n    }\n\n    mobius_transform<mod_int>(N, dp);\n\n    for (int mask = 1; mask < 1 << N; mask++)\n        if (__builtin_popcount(mask) % 2 == 0)\n            dp[mask] = -dp[mask];\n\n    vector<uint8_t> sums(1 << N, 0);\n    int64_t ans = 0;\n\n    for (int mask = 1; mask < 1 << N; mask++) {\n        int low = __builtin_ctz(mask);\n        sums[mask] = uint8_t(sums[mask ^ 1 << low] + low);\n        int k = __builtin_popcount(mask);\n        ans ^= int64_t(dp[mask]) * k * (k + sums[mask]);\n    }\n\n    cout << ans << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Subsequences Galore.json",
    "editorial_link": "https://codeforces.com//blog/entry/98061",
    "editorial": "For a string , letâs define its as the mask of bits, where -th bit is if\r\nand only if is a subsequence of . Letâs suppose we somehow calculate the\r\nnumber of strings for each , and we denote this as for a mask . How can\r\nwe use this information to find ? Suppose this set of strings is\r\nrepresented by a mask , then the strings which are included in are the\r\nstrings such that their characteristic mask has bitwise AND with equal\r\nto , i. e. these characteristic masks are submasks of . We can use SOS\r\nDP to calculate these sums of over submasks in .The only problem is how\r\nto calculate for every mask. Letâs analyze when a string is a\r\nsubsequence of a sorted string . The subsequence should be sorted as\r\nwell, and the number of occurrences of every character in a subsequence\r\nshould not exceed the number of occurrences of that character in . So,\r\nif there are characters in , characters in , and so on, then the number\r\nof its subsequences is .What about subsequences of every string from a\r\nset? These conditions on the number of occurrences should apply to every\r\nstring in the set, so, for each character, we can calculate the minimum\r\nnumber of occurrences of this character in each string of the set, add ,\r\nand multiply these numbers to get the number of strings that are\r\nsubsequences of each string in a set.These values can be calculated in\r\nfor all subsequences of using recursive approach. Can these numbers be\r\nused as ? Not so fast. Unfortunately, these values (letâs call them )\r\nare the numbers of subsequences of the chosen sets of strings, but we\r\nhave no information about the strings that are not included in the\r\nchosen set of strings. To handle it, we can use the following equation:\r\n, where means that is a submask of . To transform the values of into the\r\nvalues of , we can flip all bits in the masks (so is the sum of over all\r\nsubmasks of ), apply inverse SOS DP (also known as Mobius\r\ntransformation), and then flip all bits in the masks again. So, we found\r\na way to calculate all values of in , and we have already discussed what\r\nto do with them in the first paragraph of the editorial.The overall\r\ncomplexity of the solution is .\r\n",
    "hint": []
}