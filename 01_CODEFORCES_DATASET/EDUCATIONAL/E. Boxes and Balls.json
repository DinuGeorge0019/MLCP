{
    "link": "https://codeforces.com//contest/1845/problem/E",
    "problemId": "1986292",
    "problem_idx": "E",
    "shortId": "1845E",
    "contest_number": "1845",
    "problem_submissions": {
        "F": [
            211475859,
            211492939,
            211497555,
            211490825,
            211491595,
            211499186,
            211501170,
            211510297,
            211505215,
            211508507,
            211523706,
            211508142,
            211526813,
            211526845,
            211523227,
            211522513,
            211521610,
            211527973
        ],
        "E": [
            211462563,
            211461492,
            211471272,
            211472249,
            211480189,
            211485085,
            211477384,
            211480631,
            211479180,
            211479798,
            211487222,
            211476273,
            211646872,
            211490174,
            211488484,
            211525957,
            211524499,
            211523817,
            211482860,
            211491352,
            211488220,
            211483247,
            211483585,
            211488962,
            211482756,
            211497978
        ],
        "B": [
            211453598,
            211442082,
            211444910,
            211443511,
            211441772,
            211442686,
            211445493,
            211443115,
            211444001,
            211449977,
            211446525,
            211444666,
            211443749,
            211447761,
            211449897,
            211443106,
            211444760,
            211445575,
            211449630,
            211442921
        ],
        "D": [
            211450415,
            211448543,
            211458729,
            211462418,
            211460113,
            211454656,
            211463763,
            211469130,
            211470306,
            211471906,
            211459492,
            211645284,
            211472007,
            211475281,
            211467877,
            211468462,
            211468425,
            211461450,
            211463088,
            211470068,
            211462856
        ],
        "C": [
            211443935,
            211445016,
            211453965,
            211452711,
            211452512,
            211450213,
            211454682,
            211448771,
            211452473,
            211462596,
            211453195,
            211455269,
            211452431,
            211458111,
            211462223,
            211458912,
            211452900,
            211451834,
            211462935,
            211452522
        ],
        "A": [
            211441020,
            211441082,
            211441390,
            211441217,
            211441011,
            211441288,
            211441347,
            211441228,
            211442540,
            211441983,
            211441400,
            211441604,
            211441498,
            211442268,
            211443714,
            211441364,
            211441612,
            211441912,
            211442694,
            211441281
        ]
    },
    "name": "E. Boxes and Balls",
    "statement": "There are n boxes placed in a line. The boxes are numbered from 1 to n.\r\nSome boxes contain one ball inside of them, the rest are empty. At least\r\none box contains a ball and at least one box is empty.In one move, you\r\nchoose a box with a ball inside and an adjacent empty box and move the\r\nball from one box into another. Boxes i and i+1 for all i from 1 to n-1\r\nare considered adjacent to each other. Boxes 1 and n are .How many\r\ndifferent arrangements of balls exist after k moves are performed? Two\r\narrangements are considered different if there is at least one such box\r\nthat it contains a ball in one of them and doesn\u2019t contain a ball in the\r\nother one.Since the answer might be pretty large, print its remainder\r\nmodulo 10^9+7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nconst int p=1e9+7;\nconst int maxn=1705;\nconst int h=60;\nint dp[120][maxn];\nint dp2[120][maxn];\nint32_t main()\n{\n    ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n    int n,k;cin>>n>>k;\n    int a[n];for(int i=0;i<n;++i) cin>>a[i];\n    dp[h][0]=1;\n    for(int i=0;i<n;++i)\n    {\n        for(int bal=0;bal<120;++bal) for(int s=0;s<maxn;++s) dp2[bal][s]=0;\n        for(int bal=0;bal<120;++bal)\n        {\n            for(int s=0;s<=k;++s)\n            {\n                if(dp[bal][s])\n                {\n                    int bal1=bal-h;\n                    int u=dp[bal][s];\n                    if(a[i]==1)\n                    {\n                        dp2[bal+1][s+abs(bal1+1)]+=u;if(dp2[bal+1][s+abs(bal1+1)]>=p) dp2[bal+1][s+abs(bal1+1)]-=p;\n                        dp2[bal][s+abs(bal1)]+=u;if(dp2[bal][s+abs(bal1)]>=p) dp2[bal][s+abs(bal1)]-=p;\n                    }\n                    else\n                    {\n                        dp2[bal-1][s+abs(bal1-1)]+=u;if(dp2[bal-1][s+abs(bal1-1)]>=p) dp2[bal-1][s+abs(bal1-1)]-=p;\n                        dp2[bal][s+abs(bal1)]+=u;if(dp2[bal][s+abs(bal1)]>=p) dp2[bal][s+abs(bal1)]-=p;\n                    }\n                }\n            }\n        }\n        for(int bal=0;bal<120;++bal) for(int s=0;s<maxn;++s) dp[bal][s]=dp2[bal][s];\n    }\n    int res=0;for(int i=k%2;i<=k;i+=2) {res+=dp[h][i];if(res>=p) res-=p;}\n    cout<<res;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "implementation",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Boxes and Balls.json",
    "editorial_link": "https://codeforces.com//blog/entry/117791",
    "editorial": "Consider a harder problem. For each from to , what\u00e2\u0080\u0099s the number of\r\narrangements that have as the smallest number of operations needed that\r\nobtain them?That would help us solve the full problem. You just have to\r\nsum up the answer for such that they have the same parity as (since,\r\nonce the arrangement is obtained, you can perform two moves on it and\r\nchange nothing).Turns out, calculating the smallest number of operations\r\nfor a fixed arrangement is not that hard. Let the initial arrangement\r\nhave balls in boxes for some ; the fixed arrangement have balls in boxes\r\n. Then the first ball in the fixed arrangement has to come from the box\r\nof the first ball in the initial one. And so on. So the answer is at\r\nleast . That estimate can be achieved. Just move the balls one by one\r\nfrom left to right. So that amount is actually the smallest\r\npossible.That can lead to a dynamic programming solution. Following this\r\nconstruction, let be the number of ways to fill the first boxes with\r\nballs such that the smallest number of operations to move the first\r\nballs of the initial arrangement into their new boxes is . The\r\ntransitions are trivial. Either leave the -th (all -indexed) box empty\r\nand go to or put a ball into it and go to . The answer will be in for\r\nall of the same parity as . That solution is that is supposedly too much\r\n(although unfortunately can be squeezed if you try hard enough).That\r\nsolution has surprisingly little to do with the full one but gives us\r\nsome insight into the problem.For a faster solution, let\u00e2\u0080\u0099s change the\r\nway we calculate the smallest number of operations. What is exactly ?\r\nLet . Then on its path the ball crosses the spaces between boxes and ,\r\nand , so on until and . The amount is exactly .Thus, we could instead\r\ncalculate the number of balls that move across each space between the\r\nboxes along their paths and add up the values. Now it\u00e2\u0080\u0099s some sort of\r\nbalance. We could also denote balls going to the right as positive\r\nvalues and going to the left as negative values. Notice how if some ball\r\nmoves from a box to a box in the optimal construction, then there is no\r\nball that moves from to . Just because the balls never cross each other\r\npaths. So the absolute value of the balance is still what we have to add\r\nup.Intuitively, the value for space between boxes and is equal to the\r\nsigned difference between the initial number of balls to the left of it\r\nand the one in the current arrangement. If the numbers are different,\r\nthen we move exactly this amount of ball from one side to another.Now we\r\ncan pack it into another dynamic programming. Let be the number of ways\r\nto fill the first boxes, such that the current balance is and the\r\nsmallest number of operations to achieve that is .The transitions are\r\nthe following. If we place a ball into box , the balance changes to ( is\r\nwhether there was a ball in box initially) and gets added to . If we\r\ndon\u00e2\u0080\u0099t place a ball, the balance changes to and gets added to .Notice\r\nthat at the end the balance will be if and only if we placed as many\r\nboxes as there were initially. So, the answer will be in for all of the\r\nsame parity as .That solution is still and even worse in the way that\r\ncan range from to , doubling the runtime.However, notice how can\u00e2\u0080\u0099t\r\nchange by more than on each step. At the same time, always gets added to\r\n. Thus, to make equal to at the end, we would have to add to . And since\r\ncan\u00e2\u0080\u0099t exceed , actually can\u00e2\u0080\u0099t exceed (more or less ).So, that solution\r\ncan be optimized to by reducing the second dimension of the dynamic\r\nprogramming.In order to store values from to in an array, shift them up\r\nby . So the values become from to .In order to avoid memory, instead of\r\nstoring all layers of the dp, only store the current and the next one.\r\nThat will make it memory. Overall complexity: .\r\n"
}