{
    "link": "https://codeforces.com//contest/1511/problem/C",
    "problemId": "955214",
    "problem_idx": "C",
    "shortId": "1511C",
    "contest_number": "1511",
    "problem_submissions": {
        "F": [
            112840077,
            112828537,
            112827087,
            113002746,
            112851650,
            112835176,
            112837815,
            112833990,
            112833873,
            112824360,
            112844580,
            112864617,
            112862363,
            112847364,
            112866931,
            112854217,
            112847572,
            112854389,
            112862579,
            112845350
        ],
        "G": [
            112827572,
            112849564,
            114661033,
            114660887,
            114660767,
            114660706,
            114660307,
            114660076,
            114659999,
            114659915,
            112892560,
            112862384,
            112862341,
            112862288,
            112850067,
            112846404,
            112853880,
            112853846,
            112850825,
            112896875,
            112847874,
            113122868,
            112859368,
            112858002,
            112857690,
            112970481,
            112947065,
            112923272,
            112913505,
            113005183,
            112847551,
            112853638,
            112855715
        ],
        "E": [
            112819190,
            112811502,
            112809874,
            112818379,
            112809749,
            112819391,
            112816521,
            112812422,
            112824024,
            112811228,
            112816399,
            112821852,
            112825588,
            112822496,
            112814072,
            112820021,
            112829060,
            112824596
        ],
        "D": [
            112810190,
            112804690,
            112802519,
            112810990,
            112813483,
            112807233,
            112809814,
            112797395,
            112806426,
            112804268,
            112810141,
            112805389,
            112810319,
            112811043,
            112802328,
            112810501,
            112810922,
            112816639
        ],
        "C": [
            112798920,
            112798787,
            112796760,
            112804959,
            112800997,
            112799737,
            112805004,
            112792842,
            112799549,
            112797984,
            112795724,
            112796489,
            112801048,
            112802109,
            112797807,
            112801283,
            112801426,
            112804850
        ],
        "B": [
            112794609,
            112794368,
            112790815,
            112794707,
            112794954,
            112796065,
            112801022,
            112788437,
            112794356,
            112792946,
            112790545,
            112792316,
            112798211,
            112798547,
            112790397,
            112797545,
            112796307,
            112796695
        ],
        "A": [
            112787944,
            112786809,
            112787014,
            112786892,
            112787663,
            112788591,
            112791727,
            112786823,
            112788650,
            112788073,
            112786815,
            112787413,
            112786972,
            112791493,
            112787338,
            112792315,
            112786886,
            112787405
        ]
    },
    "name": "C. Yet Another Card Deck",
    "statement": "You have a card deck of n cards, numbered from top to bottom, i. e. the\r\ntop card has index 1 and bottom card index n. Each card has its color:\r\nthe i-th card has color a_i.You should process q queries. The j-th query\r\nis described by integer t_j. For each query you should: find the highest\r\ncard in the deck with color t_j, i. e. the card with minimum index;\r\nprint the position of the card you found; take the card and place it on\r\ntop of the deck.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#pragma region my_template\n\nstruct Rep {\n  struct I {\n    int i;\n    void operator++() { ++i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i < *o; }\n  };\n  const int l_, r_;\n  Rep(int l, int r) : l_(l), r_(r) {}\n  Rep(int n) : Rep(0, n) {}\n  I begin() const { return {l_}; }\n  I end() const { return {r_}; }\n};\nstruct Per {\n  struct I {\n    int i;\n    void operator++() { --i; }\n    int operator*() const { return i; }\n    bool operator!=(I o) const { return i > *o; }\n  };\n  const int l_, r_;\n  Per(int l, int r) : l_(l), r_(r) {}\n  Per(int n) : Per(0, n) {}\n  I begin() const { return {r_ - 1}; }\n  I end() const { return {l_ - 1}; }\n};\n\ntemplate <class F>\nstruct Fix : private F {\n  Fix(F f) : F(f) {}\n  template <class... Args>\n  decltype(auto) operator()(Args&&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class T = int>\nT scan() {\n  T res;\n  std::cin >> res;\n  return res;\n}\n\ntemplate <class T, class U = T>\nbool chmin(T& a, U&& b) {\n  return b < a ? a = std::forward<U>(b), true : false;\n}\ntemplate <class T, class U = T>\nbool chmax(T& a, U&& b) {\n  return a < b ? a = std::forward<U>(b), true : false;\n}\n\n#ifndef LOCAL\n#define DUMP(...) void(0)\ntemplate <int OnlineJudge, int Local>\nconstexpr int OjLocal = OnlineJudge;\n#endif\n\nusing namespace std;\n\n#define ALL(c) begin(c), end(c)\n\n#pragma endregion\n\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int n = scan();\n  int q = scan();\n  vector pos(50, n);\n  for (int i : Rep(n)) chmin(pos[scan() - 1], i);\n  while (q--) {\n    int t = scan() - 1;\n    cout << pos[t] + 1 << \" \\n\"[q == 0];\n    for (auto&& e : pos) e += e < pos[t];\n    pos[t] = 0;\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "implementation",
        "trees"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Yet Another Card Deck.json",
    "editorial_link": "https://codeforces.com//blog/entry/89634",
    "editorial": "Let\u00e2\u0080\u0099s look at one fixed color. When we search a card of such color, we\r\ntake the card with minimum index and after we place it on the top of the\r\ndeck it remains the one with minimum index.It means that for each color\r\nwe take and move the same card one card for each color. In other words,\r\nwe need to keep track of only cards, where is the number of colors ().\r\nAs a result, if is the position of a card of color then we can simulate\r\na query in the following way: for each color such that we increase by\r\none (since the card will move down) and then set . Complexity is .But,\r\nif we look closely, we may note that we don\u00e2\u0080\u0099t even need array . We can\r\nalmost manually find the first card of color and move it to the first\r\nposition either by series of swaps or, for example, using function\r\n(present in C++) and it will work fast.Why? Let\u00e2\u0080\u0099s look at one color .\r\nFor the first time it will cost operations to search the corresponding\r\ncard and move it to the position . But after that, at any moment of\r\ntime, the position of the card won\u00e2\u0080\u0099t exceed , since all cards before are\r\npairwise different (due to the nature of queries). So, all next moves\r\nthe color costs only time.As a result, the complexity of such almost\r\nnaive solution is .\r\n"
}