{
    "link": "https://codeforces.com//contest/1651/problem/D",
    "problemId": "1324099",
    "problem_idx": "D",
    "shortId": "1651D",
    "contest_number": "1651",
    "problem_submissions": {
        "C": [
            149173723,
            149105792,
            149117381,
            149152549,
            149106514,
            149108421,
            149108464,
            149108635,
            149109429,
            149110791,
            149109777,
            149108515,
            149109773,
            149111699,
            149114619,
            149106949,
            149113559,
            149129766
        ],
        "F": [
            149161364,
            149158834,
            149161121,
            149123303,
            149175934,
            149179491,
            191725924,
            149575413
        ],
        "E": [
            149139170,
            149130164,
            149147455,
            149137360,
            149140976,
            149145909,
            149141908,
            149139460,
            149147248,
            149148678,
            149156290,
            149148881,
            149154274,
            149143485,
            149163314,
            149138047,
            149159145
        ],
        "D": [
            149127559,
            149163309,
            149150118,
            149115060,
            149119439,
            149116468,
            149116651,
            149118386,
            149120734,
            149121740,
            149119776,
            149192081,
            149191968,
            149191879,
            149191841,
            149191815,
            149191600,
            149191163,
            149191124,
            149128435,
            149129157,
            149129578,
            149116059,
            149145989,
            149116064
        ],
        "B": [
            149098208,
            149096317,
            149154308,
            149094973,
            149099387,
            149095439,
            149099190,
            149096388,
            149097486,
            149098725,
            149098039,
            149097903,
            149102336,
            149093030,
            149096020,
            149099865,
            149101390
        ],
        "A": [
            149092351,
            149091868,
            149155144,
            149091621,
            149091628,
            149091655,
            149091686,
            149091765,
            149091751,
            149092326,
            149091819,
            149092231,
            149094932,
            149091603,
            149091630,
            149091669,
            149092684
        ]
    },
    "name": "D. Nearest Excluded Points",
    "statement": "You are given n distinct points on a plane. The coordinates of the i-th\r\npoint are (x_i, y_i).For each point i, find the nearest (in terms of\r\nManhattan distance) point with that is not among the given n points. If\r\nthere are multiple such points you can choose any of them.The Manhattan\r\ndistance between two points (x_1, y_1) and (x_2, y_2) is |x_1 - x_2| +\r\n|y_1 - y_2|.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 200011; \n\nvoid solve() {\n    int N; cin >> N;\n    vi X(N), Y(N);\n    F0R(i, N) cin >> X[i] >> Y[i];\n    set<pi> R[MX];\n    F0R(i, MX) {\n        R[i].ins({0, MX});\n    }\n    F0R(i, N) {\n        auto it = R[X[i]].lb({Y[i], MX+10});\n        it--;\n        pi cur = *it;\n        R[X[i]].erase(it);\n        if (cur.f != Y[i]) {\n            R[X[i]].ins({cur.f, Y[i] - 1});\n        }\n        if (cur.s != Y[i]) {\n            R[X[i]].ins({Y[i] + 1, cur.s});\n        }\n    }\n\n    F0R(i, N) {\n        int rx = -1, ry = -1;\n        int ans = MX*10;\n        F0R(j, MX) {\n            if (j >= ans) break;\n            vi cv = {X[i]-j, X[i]+j};\n            trav(a, cv) {\n                if (a < 0 || a >= MX) continue;\n                int c = -1;\n                auto it = R[a].lb({Y[i], MX+10});\n                it--;\n                if (it->s > Y[i]) {\n                    c = Y[i];\n                } else {\n                    c = it->s;\n                }\n                it++;\n                if (abs(c-Y[i]) > abs(it->f - Y[i])) c = it->f;\n                if (ckmin(ans, abs(c - Y[i]) + j)) {\n                    rx = a;\n                    ry = c;\n                }\n            }\n        }\n        cout << rx << \" \" << ry << nl;\n    }\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Nearest Excluded Points.json",
    "editorial_link": "https://codeforces.com//blog/entry/100796",
    "editorial": "Firstly, we can find answers for all points that are adjacent to at\r\nleast one point not from the set. The distance for such points is\r\nobviously (and this is the smallest possible answer we can get). On the\r\nnext iteration, we can set answers for all points that are adjacent to\r\npoints with found answers (because they donât have neighbors not from\r\nthe set, the distance for them is at least ). It doesnât matter which\r\npoint we will take, so if the point is adjacent to some point that have\r\nthe answer , we can set the answer for the point as the answer for the\r\npoint . We can repeat this process until we find answers for all points.\r\nIn terms of the code, this can be done by breadth first search (BFS). In\r\nother words, we set answers for the points that have the distance and\r\nthen push these answers to all adjacent points from the set in order of\r\nthe increasing distance until we find all the answers.Time complexity: .\r\n",
    "hint": []
}