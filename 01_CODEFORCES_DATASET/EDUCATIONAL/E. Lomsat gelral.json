{
    "link": "https://codeforces.com//contest/600/problem/E",
    "problemId": "41577",
    "problem_idx": "E",
    "shortId": "600E",
    "contest_number": "600",
    "problem_submissions": {
        "E": [
            14516781,
            14521796,
            14522661,
            14523717,
            30527329,
            14524644,
            14516280,
            14515812,
            14516214,
            14518451,
            14519071,
            14519248,
            14519280,
            14518850,
            14518744,
            14518295,
            14521024,
            14524030,
            14518640,
            14519985,
            14534724,
            14534675
        ],
        "D": [
            14515579,
            14519010,
            14518774,
            14521193,
            14533916,
            14533879,
            17533027,
            77083288,
            14526699,
            14520082
        ],
        "C": [
            14514280,
            14514611,
            14515088,
            14516246,
            14514489,
            14514198,
            14514520,
            14514586,
            14514814,
            14515845,
            14514811,
            14514852,
            14514847,
            14516022,
            14513813,
            14515214,
            14515296,
            14517008,
            14517583
        ],
        "B": [
            14513498,
            14513713,
            14514312,
            14515199,
            64489984,
            64489958,
            64437360,
            64437339,
            64437310,
            64437262,
            64437238,
            64437187,
            64356527,
            64356317,
            64356304,
            64356219,
            64356053,
            64356040,
            64356029,
            64355961,
            64355802,
            64355581,
            64355572,
            64355497,
            64355269,
            64355250,
            64355067,
            64355022,
            64355018,
            64355008,
            64354957,
            64354927,
            64354893,
            64354674,
            64354610,
            64354604,
            64354499,
            64354477,
            64354377,
            64354366,
            64354314,
            64354299,
            64354208,
            64354016,
            64353840,
            64353829,
            64353816,
            64353659,
            64353647,
            64353627,
            64353521,
            64353432,
            64353406,
            64353383,
            64353315,
            64353296,
            64352793,
            64352299,
            64352204,
            14513750,
            14513852,
            14513619,
            14513719,
            14513814,
            14513671,
            14513567,
            14513744,
            14513927,
            14514916,
            14513319,
            14514212,
            14514452,
            14514809,
            14515622
        ],
        "A": [
            14513396,
            14513543,
            14514079,
            14514797,
            14513623,
            14513416,
            14513555,
            14513558,
            14513502,
            14513418,
            14513548,
            14513680,
            14517095,
            14519574,
            14514382,
            14515226
        ],
        "F": [
            15165948,
            15165905,
            15165817,
            110063771,
            77143032,
            14560500
        ]
    },
    "name": "E. Lomsat gelral",
    "statement": "You are given a rooted tree with root in vertex . Each vertex is\r\ncoloured in some colour.Let\u2019s call colour dominating in the subtree of\r\nvertex if there are no other colours that appear in the subtree of\r\nvertex more times than colour . So it\u2019s possible that two or more\r\ncolours will be dominating in the subtree of some vertex.The subtree of\r\nvertex is the vertex and all other vertices that contains vertex in each\r\npath to the root.For each vertex find the sum of all dominating colours\r\nin the subtree of vertex .\r\n",
    "solutions": [
        "/*\nNight time, see the castles burning\nSmoke in the skies and tears in their eyes\nAs the world keeps turning\n\nSleep now, hear a distant thunder\nIt's far away at least for today\nClose your eyes and wonder\n\nSpring turns so quickly to summer\nSummer so quickly to fall\nIt seemed far away or it was yesterday\nWhen time didn't matter at all\n\nAnd then you met your winter\nWhile dancing with her daughters\nTill tired and cold, were much wiser than bold\nYou wait for tomorrow to call\n\nAll of your life you have waited alone for a Savior\nHe's not coming\nA carousel horse who is constantly lost\nStanding still but always running\n\nAnd all of those things that you needed so bad\nYou have found they mean nothing\nAnd, oh Lord, I'm coming home\n\nI'm searching through the haze\nThat's drifting through my mind\nStare in my looking glass\nAnd wonder who I'll find\n\nNo one would listen\nTo a man upon the water\nUntil they were old and their mountains of gold\nCouldn't buy any more time\n\nAll of your life you have waited alone for the Savior\nHe's not coming\nA carousel horse who is constantly lost\nStanding still but always running\n\nAnd all of those things that you needed so bad\nYou have found they mean nothing\nAnd, oh Lord, I'm coming home\n\nAll of your life you have waited alone for the Savior\nHe's not coming\nA carousel horse who is constantly lost\nStanding still but always running\n\nAnd all of those things that you needed so bad\nYou have found they mean nothing\nAnd, oh Lord, I'm coming home\nAnd, oh Lord, I'm coming home\nAnd, oh Lord, I'm coming\n*/\n\n//#pragma comment(linker, \"/STACK:16777216\")\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>  \n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <ctime> \n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n\n#define eps 1e-16\n#define M_PI 3.141592653589793\n#define bs 1000000007\n#define bsize 512\n\nconst int N = 200005;\n\nusing namespace std;\n\nint n;\nint c[N];\nmap<int, int> S[N];\nint w[N];\nint used[N];\nint mx[N];\nlong long cnt[N];\nvector<int> g[N];\nlong long ans[N];\n\nvoid run_merge(int a,int b)\n{\n\tif (S[w[a]].size()<S[w[b]].size())\n\t{\n\t\tswap(w[a],w[b]);\n\t}\n\tint id=w[a];\n\tmap<int, int>::iterator it;\n\t\n\tfor (it=S[w[b]].begin();it!=S[w[b]].end();it++)\n\t{\n\t\tint val=(*it).first;\n\t\tint amount=(*it).second;\n\t\tS[id][val]+=amount;\n\t\tif (S[id][val]>mx[id])\n\t\t{\n\t\t\tmx[id]=S[id][val];\n\t\t\tcnt[id]=0;\n\t\t}\n\t\tif (S[id][val]==mx[id])\n\t\t\tcnt[id]+=val;\n\t}\n}\n\nvoid dfs(int v)\n{\n\tused[v]=1;\n\tfor (int i=0;i<g[v].size();i++)\n\t{\n\t\tint to=g[v][i];\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tdfs(to);\n\t\trun_merge(v,to);\n\t}\n//\tcout<<v<<\" \"<<mx[w[v]]<<\" \"<<cnt[w[v]]<<endl;\n\tans[v]=cnt[w[v]];\n}\n\nint main(){\n\t//freopen(\"beavers.in\",\"r\",stdin);\n\t//freopen(\"beavers.out\",\"w\",stdout);\n\t//freopen(\"F:/in.txt\",\"r\",stdin);\n\t//freopen(\"F:/output.txt\",\"w\",stdout);\n\tios_base::sync_with_stdio(0);\n\t//cin.tie(0);\n\t\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tcin>>c[i];\n\t\tS[i][c[i]]=1;\n\t\tw[i]=i;\n\t\tmx[i]=1;\n\t\tcnt[i]=c[i];\n\t}\n\t\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\t\n\tdfs(1);\n\t\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (i>1)\n\t\t\tcout<<\" \";\n\t\tcout<<ans[i];\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "dsu",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Lomsat gelral.json",
    "editorial_link": "https://codeforces.com//blog/entry/21827",
    "editorial": "The name of this problem is anagram for \u00e2\u0080\u009dSmall to large\u00e2\u0080\u009d. There is a\r\nreason for that :-) The author solution for this problem uses the\r\nclassic technique for computing sets in tree. The simple solution is the\r\nfollowing: let\u00e2\u0080\u0099s find for each vertex the \u00e2\u0080\u009dmap<int, int>\u00e2\u0080\u009d the number of\r\noccurences for each colour, \u00e2\u0080\u009dset<pair<int, int>>\u00e2\u0080\u009d pairs the number of\r\noccurences and the colour, and the number the sum of most frequent\r\ncolours in subtree of . To find that firstly we should find the same\r\nthing for all childs of and then merge them to one. These solution is\r\ncorrect but too slow (it works in time). Let\u00e2\u0080\u0099s improve that solution:\r\nevery time when we want to merge two -s and let\u00e2\u0080\u0099s merge the smaller one\r\nto larger simply by iterating over all elements of the smaller one (this\r\nis the \u00e2\u0080\u009cSmall to large\u00e2\u0080\u009d). Let\u00e2\u0080\u0099s consider some vertex : every time when\r\nvertex will be moved from one to another the size of the new map will be\r\nat least two times larger. So each vertex can be moved not over than\r\ntimes. Each moving can be done in time. If we accumulate that values by\r\nall vertices then we get the complexity . I saw the solutions that\r\ndiffers from author\u00e2\u0080\u0099s but this technique can be used in a lot of other\r\nproblems.\r\n"
}