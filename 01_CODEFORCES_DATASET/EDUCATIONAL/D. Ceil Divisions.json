{
    "link": "https://codeforces.com//contest/1469/problem/D",
    "problemId": "847529",
    "problem_idx": "D",
    "shortId": "1469D",
    "contest_number": "1469",
    "problem_submissions": {
        "F": [
            102583473,
            102644474,
            102589987,
            102594210,
            102598891,
            102606787,
            102602998,
            102604144,
            102603740,
            102665234,
            102604943,
            102600529,
            102596981,
            102695061,
            102694126,
            102693059,
            102692990,
            102691774,
            102691554,
            102634847,
            102593976,
            102601060,
            102611713,
            102611193,
            102613178,
            102615015,
            102610571,
            133243413,
            102609965,
            102615327
        ],
        "E": [
            102573843,
            102644473,
            102578949,
            102577732,
            102585110,
            102591945,
            102586477,
            102582817,
            102595462,
            102579611,
            102664687,
            102648095,
            102648064,
            102594234,
            102584569,
            102634471,
            102624399,
            102623518,
            102608733,
            155214938,
            102768106,
            102593726,
            102593694,
            102597495,
            102592373,
            102595193,
            102588652,
            102589423,
            102593264
        ],
        "D": [
            102562850,
            102644472,
            102568881,
            102566821,
            102569601,
            102570954,
            102563048,
            102571352,
            102588415,
            102664675,
            102570617,
            102572568,
            102569075,
            102580450,
            102569951,
            102575804,
            102575811,
            102574711,
            102577038,
            102579322,
            102570202
        ],
        "C": [
            102552805,
            102644471,
            102555513,
            102554730,
            102555597,
            102558406,
            102554980,
            102553952,
            102556321,
            102664664,
            102560782,
            102559861,
            102555651,
            102570770,
            102554929,
            102563292,
            102558262,
            102561567,
            102566610,
            102569771,
            102557739
        ],
        "B": [
            102548072,
            102644469,
            102548784,
            102547413,
            102549611,
            102549952,
            102549039,
            102547745,
            102550684,
            102664647,
            102553929,
            102550781,
            102634199,
            102551181,
            102557688,
            102550308,
            102552089,
            102551269,
            102550296,
            102555698,
            102550742,
            102551593
        ],
        "A": [
            102546848,
            102644467,
            102547134,
            102546803,
            102547541,
            102546863,
            102546919,
            102546821,
            102547947,
            102664636,
            102549491,
            102548928,
            102547577,
            102555388,
            102547472,
            102548992,
            102546835,
            102546964,
            102551041,
            102547957,
            102549438
        ]
    },
    "name": "D. Ceil Divisions",
    "statement": "You have an array a_1, a_2,\r\ndots, a_n where a_i = i.In one step, you can choose two indices x and y\r\n(x\r\nneq y) and set a_x =\r\nleft\r\nlceil\r\nfrac{a_x}{a_y}\r\nright\r\nrceil (ceiling function).Your goal is to make array a consist of n - 1\r\nones and 1 two in no more than n + 5 steps. Note that you don’t have to\r\nminimize the number of steps.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int t;\n    std::cin >> t;\n    while (t--) {\n        int n;\n        std::cin >> n;\n        std::vector<std::pair<int, int>> ans;\n        while (n > 2) {\n            int s = std::ceil(std::sqrt(n));\n            for (int i = s + 1; i < n; ++i) {\n                ans.emplace_back(i, i + 1);\n            }\n            ans.emplace_back(n, s);\n            ans.emplace_back(n, s);\n            n = s;\n        }\n        std::cout << ans.size() << \"\\n\";\n        for (auto [x, y] : ans) {\n            std::cout << x << \" \" << y << \"\\n\";\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "math",
        "number theory"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Ceil Divisions.json",
    "editorial_link": "https://codeforces.com//blog/entry/86082",
    "editorial": "There are many different approaches. We will describe a pretty optimal\r\none.Letâs solve the problem recursively. Letâs say we need to process\r\nsegment . If , we donât need to do anything. Otherwise, . Letâs find the\r\nminimum such that .The chosen is convenient because it allows making\r\nequal to in two divisions (and itâs the minimum number of divisions to\r\nget rid of ). Now we can, firstly, make all equal to in one step (by\r\ndivision on ) and then make equal to with two divisions on .As a result,\r\nweâve spent operations and can solve our task recursively for . In\r\ntotal, we will spend and since the segments are like , ,... There will\r\nbe at most segments and operations are enough for .\r\n",
    "hint": []
}