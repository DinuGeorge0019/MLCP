{
    "link": "https://codeforces.com//contest/2043/problem/F",
    "problemId": "3103851",
    "problem_idx": "F",
    "shortId": "2043F",
    "contest_number": "2043",
    "problem_submissions": {
        "G": [
            298276621,
            298458376,
            298455954,
            298459741,
            298498128,
            298494225,
            298493989,
            298368643,
            298368617
        ],
        "F": [
            298243973,
            298258053,
            298242817,
            298260253,
            298257085,
            298250612,
            298241233,
            298252743,
            298266622,
            298254223,
            298258269,
            298270540,
            298270292,
            298270970,
            298272964,
            298350526,
            298284182,
            298276985,
            298272819,
            298283274,
            298421391,
            298417038,
            298257904
        ],
        "E": [
            298230325,
            298236565,
            298229495,
            298226934,
            298227308,
            298237122,
            298220698,
            298238215,
            298226770,
            298234499,
            298239196,
            298230091,
            298228297,
            298244169,
            298310355,
            298234798,
            298238168,
            298247710,
            298242187,
            298286367
        ],
        "D": [
            298219869,
            298216982,
            298222571,
            298218218,
            298213410,
            298224781,
            298213619,
            298219577,
            298216318,
            298221470,
            298226089,
            298219311,
            298219518,
            298230143,
            298226137,
            298226579,
            298229601,
            298224236,
            298231826
        ],
        "C": [
            298215825,
            298213305,
            298214855,
            298212674,
            298210052,
            298218770,
            298246686,
            298216835,
            298211668,
            298217178,
            298218473,
            298215699,
            298214498,
            298219482,
            298220559,
            298222653,
            298215672,
            298216539,
            298220531
        ],
        "B": [
            298205974,
            298203999,
            298204560,
            298204165,
            298201534,
            298206623,
            298209665,
            298205595,
            298204637,
            298205310,
            298207112,
            298207961,
            298204179,
            298210111,
            298210081,
            298211372,
            298204136,
            298203902,
            298209938
        ],
        "A": [
            298200061,
            298199218,
            298199258,
            298199378,
            298199175,
            298200132,
            298199984,
            298200407,
            298199812,
            298205860,
            298199259,
            298199630,
            298199502,
            298199251,
            298211149,
            298199244,
            298199260,
            298199390,
            298200087
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137801",
    "editorial": "Let\u00e2\u0080\u0099s recall the condition for the second player to win in the game of\r\n\"Nim\". The XOR of the sizes of the piles must be equal to . That is, we\r\nare asked to remove as many piles as possible so that the XOR becomes\r\n.Notice the following fact. Suppose there are piles of size on a\r\nsegment. If we remove an even number of piles, the XOR does not change.\r\nIf we remove an odd number, it changes by . Therefore, there is no point\r\nin keeping more than piles. If we keep piles, we can remove another\r\npiles, and it will not change anything at all.We will answer the queries\r\nindependently. Let\u00e2\u0080\u0099s find the count of each of the elements in the given\r\nsegment. For example, we can precompute how many times each element\r\nappears in each prefix.Now we can write the following dynamic\r\nprogramming solution. represents a pair of (maximum amount of removed\r\nelements, number of ways to remove that amount), where we have\r\nconsidered the first of the values, the current XOR among the\r\nnon-removed values is , and if at least one element is not removed and\r\notherwise.Let the amount of the current value be . From each state,\r\nthere are at most three transitions: remove all elements with that value\r\nway; keep element ways; keep elements ways. The base case is , the rest\r\nare filled with , for example. The final state is . If it\u00e2\u0080\u0099s equal to ,\r\nthere\u00e2\u0080\u0099s no answer.Since the XOR cannot exceed , the number of states in\r\nthe dynamic programming solution is . From each state, there are three\r\ntransitions, which fits within the time constraints.\r\n",
    "name": "F. Nim",
    "statement": "Recall the rules of the game \"Nim\". There are n piles of stones, where\r\nthe i-th pile initially contains some number of stones. Two players take\r\nturns choosing a non-empty pile and removing any positive (strictly\r\ngreater than 0) number of stones from it. The player unable to make a\r\nmove loses the game.You are given an array a, consisting of n integers.\r\nArtem and Ruslan decided to play Nim on segments of this array. Each of\r\nthe q rounds is defined by a segment (l_i, r_i), where the elements\r\na_{l_i}, a_{l_i+1},\r\ndots, a_{r_i} represent the sizes of the piles of stones.Before the game\r\nstarts, Ruslan can remove any number of piles from the chosen segment.\r\nHowever, at least , so in a single round he can remove at most (r_i -\r\nl_i) piles. He is allowed to remove 0 piles. After the removal, the game\r\nis played on the remaining piles within the segment.: the changes made\r\nin one round do not affect the original array or any other rounds.Ruslan\r\nwants to remove as many piles as possible so that Artem, who always\r\nmakes the first move, loses.For each round, determine: the maximum\r\nnumber of piles Ruslan can remove; the number of ways to choose the\r\nnumber of piles for removal. Two ways are considered different if there\r\nexists an index i such that the pile at index i is removed in one way\r\nbut not in the other. Since the number of ways can be large, output it\r\nmodulo 998\r\n,244\r\n,353.If Ruslan cannot ensure Artem\u2019s loss in a particular round, output\r\nfor that round.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ALL(x) begin(x), end(x)using namespace std;void file() {  freopen(\"1.in\", \"r\", stdin);  freopen(\"1.out\", \"w\", stdout);}using ll = long long;\u00a0const int kInf = 1e9;const int kMod = 998244353;void Add(int& x, int y) { ((x += y) >= kMod) && (x -= kMod); }\u00a0const int kN = 1e5 + 5, kV = 64;int n, q;array<int, kN> a;array<array<int, kN>, kV> pre;\u00a0struct Info {  int mn, c;  Info() { mn = kInf, c = 0; }  Info(int _mn, int _c) { mn = _mn, c = _c; }};array<array<Info, kV>, kV> dp;\u00a0Info operator + (Info x, Info y) {  if(x.mn == y.mn) return Add(x.c, y.c), x;  return (x.mn < y.mn) ? x : y;}\u00a0void Query(int l, int r) {  int len = r - l + 1;  array<int, kV> cnt;  for(int i = 0; i < kV; i++) {    cnt[i] = pre[i][r] - pre[i][l - 1];  }  if(cnt[0]) return void(cout << len - 1 << \" \" << cnt[0] << \"\\n\");  if(*max_element(ALL(cnt)) >= 2) {    ll sum = 0;    for(int i = 0; i < kV; i++) {      sum += (ll)cnt[i] * (cnt[i] - 1) / 2;    }    return void(cout << len - 2 << \" \" << sum % kMod << \"\\n\");  }  for(auto& k : dp) k.fill(Info());  for(int i = 1; i < kV; i++) {    if(!cnt[i]) { dp[i] = dp[i - 1]; continue; }    dp[i] = dp[i - 1];    dp[i][i] = dp[i][i] + Info(1, 1);    for(int j = 0; j < kV; j++) dp[i - 1][j].mn++;    for(int j = 0; j < kV; j++) {      dp[i][j] = dp[i][j] + dp[i - 1][i ^ j];    }  }  if(dp[kV - 1][0].mn == kInf) return void(cout << \"-1\\n\");  cout << len - dp[kV - 1][0].mn << \" \" << dp[kV - 1][0].c << \"\\n\";}\u00a0void Solve() {  cin >> n >> q;  for(int i = 1; i <= n; i++) cin >> a[i];  for(int i = 0; i < kV; i++) {    for(int j = 1; j <= n; j++) {      pre[i][j] = pre[i][j - 1] + (a[j] == i);    }  }  for(int l, r; q--; ) cin >> l >> r, Query(l, r);}\u00a0int main() {  // file();  ios::sync_with_stdio(0), cin.tie(0);  int T = 1;  // cin >> T;  while(T--) Solve();  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "combinatorics",
        "dp",
        "games",
        "greedy",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Nim.json"
}