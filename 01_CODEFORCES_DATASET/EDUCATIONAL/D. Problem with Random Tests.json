{
    "link": "https://codeforces.com//contest/1743/problem/D",
    "problemId": "1590319",
    "problem_idx": "D",
    "shortId": "1743D",
    "contest_number": "1743",
    "problem_submissions": {
        "G": [
            176744926,
            176752632,
            176765710,
            176759446,
            176826731,
            176825958,
            176825876,
            176825841,
            176825795,
            176825757,
            176777747,
            176767399,
            176787833,
            176794001,
            176793915,
            176793787,
            176793693,
            176793601,
            176793457,
            176793414,
            176793075,
            176792582,
            176790966,
            176790830,
            176790739,
            176790602,
            176790480,
            176790442,
            176790394,
            176877236,
            176797381,
            177041275
        ],
        "F": [
            176737097,
            176733706,
            176744244,
            176746662,
            176734362,
            176741223,
            176737910,
            176729577,
            176742322,
            176771541,
            176747634,
            176866127,
            176744359,
            176742533,
            176764904,
            176749314,
            176748844,
            176759565,
            176751246,
            176746192,
            176742294,
            176760205
        ],
        "E": [
            176732507,
            176757486,
            176736176,
            176739966,
            176749212,
            176748013,
            176727666,
            176739006,
            176729866,
            176763689,
            176763186,
            176762781,
            176756640,
            176764718,
            176740887,
            176756959,
            176787283,
            176742950,
            176761500,
            176766019,
            176770369,
            176749818
        ],
        "D": [
            176723746,
            176718140,
            176716615,
            176721411,
            176719450,
            176723698,
            176718782,
            176720745,
            176721715,
            176722102,
            176729581,
            176725500,
            176730292,
            176719597,
            176730936,
            176731941,
            176724207,
            176723731,
            176736911
        ],
        "C": [
            176716029,
            176704815,
            176706962,
            176708929,
            176705118,
            176704124,
            176715109,
            176705993,
            176708271,
            176707432,
            176707937,
            176714968,
            176710289,
            176708841,
            176705755,
            176710426,
            176713787,
            176707796,
            176708736,
            176710057
        ],
        "B": [
            176712751,
            176699478,
            176698683,
            176699488,
            176698322,
            176698046,
            176699875,
            176699384,
            176699501,
            176699739,
            176704430,
            176700303,
            176700238,
            176699124,
            176702452,
            176707386,
            176700133,
            176698867,
            176703708
        ],
        "A": [
            176712234,
            176698003,
            176697838,
            176697817,
            176697799,
            176697771,
            176697968,
            176697810,
            176698111,
            176698066,
            176699952,
            176697901,
            176698001,
            176697928,
            176699293,
            176697926,
            176697958,
            176697832,
            176698850
        ]
    },
    "name": "D. Problem with Random Tests",
    "statement": "You are given a string s consisting of n characters. Each character of s\r\nis either or .A substring of s is a contiguous subsequence of its\r\ncharacters.You have to choose two substrings of s (possibly\r\nintersecting, possibly the same, possibly non-intersecting just any two\r\nsubstrings). After choosing them, you calculate the value of the chosen\r\npair of substrings as follows: let s_1 be the first substring, s_2 be\r\nthe second chosen substring, and f(s_i) be the integer such that s_i is\r\nits binary representation (for example, if s_i is , f(s_i) = 26); the\r\nvalue is the of f(s_1) and f(s_2). Calculate the maximum possible value\r\nyou can get, and print it .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n;\n    std::cin >> n;\n    \n    std::string s;\n    std::cin >> s;\n    \n    if (s.find('1') == std::string::npos) {\n        std::cout << 0 << \"\\n\";\n        return 0;\n    }\n    \n    int a = s.find('1');\n    \n    if (s.substr(a).find('0') == std::string::npos) {\n        std::cout << s.substr(a) << \"\\n\";\n        return 0;\n    }\n    \n    int b = a + s.substr(a).find('0');\n    \n    auto ans = s;\n    \n    for (int i = 0; i <= b - a; i++) {\n        auto res = s;\n        for (int j = 0; j + i < n; j++) {\n            res[j + i] |= s[j];\n        }\n        ans = std::max(ans, res);\n    }\n    ans = ans.substr(ans.find('1'));\n    std::cout << ans << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "probabilities"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Problem with Random Tests.json",
    "editorial_link": "https://codeforces.com//blog/entry/108153",
    "editorial": "The first observation we need is that we can choose two prefixes of as\r\nthe substrings used in forming the results. This can be proved easily:\r\nsuppose we chose a substring which does not contain the leftmost\r\ncharacter of ; if we expand it to the left, the answer won\u00e2\u0080\u0099t become\r\nworse. So, it is optimal to choose two prefixes of as the\r\nsubstrings.Furthermore, one of these prefixes must be itself: if the\r\nleftmost index of is , the length of the answer won\u00e2\u0080\u0099t exceed , but the\r\nonly way to have a in the -th bit of the answer is to choose a prefix of\r\nwhere the -th character (from the right) is ; and there is only one such\r\nprefix of , which is itself.So, now we can solve the problem in try to\r\ncombine all prefixes of with itself, and choose the one that yields the\r\nbest answer. To speed this up, we need to somehow cut down on the number\r\nof prefixes of we check.Let\u00e2\u0080\u0099s look at the first block of \u00e2\u0080\u0099s in . The\r\nnext character after this block is ; since we take as one of the\r\nsubstring, in order to get instead of in the corresponding position of\r\nthe answer, we need to choose a prefix which has in that position. This\r\nrepresents one of the \u00e2\u0080\u0099s from the first block of \u00e2\u0080\u0099s, since only one of\r\nthem can shift to that position. So, we need to check only the prefixes\r\nsuch that, by using them, we shift some character from the first block\r\nto the position of the first after this block. Since the tests are\r\nrandom, the expected length of the first block of \u00e2\u0080\u0099s is (furthermore,\r\neven the probabiliy that its length is or bigger is about ), so the\r\nexpected number of prefixes we need to check is also . Thus, the\r\nexpected runtime of our solution is .\r\n"
}