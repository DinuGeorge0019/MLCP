{
    "link": "https://codeforces.com//contest/2086/problem/E",
    "problemId": "3306524",
    "problem_idx": "E",
    "shortId": "2086E",
    "contest_number": "2086",
    "problem_submissions": {
        "F": [
            313800473,
            313815107,
            313814871,
            313816809,
            313824037,
            313823800,
            313823595,
            313823290,
            313831013,
            313847963
        ],
        "E": [
            313778103,
            313768063,
            313796531,
            313772368,
            313776096,
            313773540,
            313775500,
            313777349,
            313773743,
            313773212,
            313777394,
            313774460,
            313780281,
            313777023,
            313779749,
            313779985,
            313789675,
            313782783,
            313780927
        ],
        "D": [
            313765839,
            313760163,
            313763413,
            313762506,
            313761667,
            313764480,
            313761919,
            313762403,
            313764311,
            313768000,
            313764673,
            313765244,
            313767408,
            313766701,
            313767208,
            313767620,
            313765113,
            313765919,
            313769446
        ],
        "C": [
            313762408,
            313757321,
            313759589,
            313757952,
            313757592,
            313758776,
            313758447,
            313758249,
            313761365,
            313762216,
            313760196,
            313762012,
            313758933,
            313763649,
            313761491,
            313762919,
            313757921,
            313761818
        ],
        "B": [
            313759878,
            313752573,
            313755779,
            313754646,
            313754713,
            313753530,
            313755287,
            313755649,
            313756220,
            313750845,
            313757002,
            313758471,
            313753446,
            313758811,
            313757915,
            313759796,
            313754670,
            313758593
        ],
        "A": [
            313747124,
            313744880,
            313745589,
            313744964,
            313745790,
            313744642,
            313747626,
            313744833,
            313745066,
            313744593,
            313747501,
            313747195,
            313744587,
            313748494,
            313746594,
            313746261,
            313746218,
            313744938
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141425",
    "editorial": "First, let’s see how many numbers less than or equal to exist. It turns\r\nout there are only of them, and based on some number , the next one can\r\nbe calculated using the formula .Then, we have to be able to quickly\r\ncalculate the for an arbitrary number . Since each subsequent number is\r\napproximately times larger than the previous one, intuitively, it seems\r\nlike a greedy algorithm should be optimal: for any number , we can\r\ndetermine its by subtracting the largest number that does not exceed ,\r\nuntil becomes .Let’s prove the correctness of the greedy\r\nalgorithm:Assume that is the smallest number for which the greedy\r\nalgorithm does not work, meaning that in the optimal decomposition of\r\ninto numbers, the largest number that does not exceed does not appear at\r\nall.If the greedy algorithm works for all numbers less than , then in\r\nthe decomposition of the number , there must be at least one number .\r\nAnd since can be decomposed greedily and will contain at least numbers ,\r\nwe will end up with at least numbers in the decomposition.Moreover,\r\nthere will be at least numbers in the decomposition because , which\r\nmeans it is also less than . Therefore, if the fifth number is , we\r\nsimply combine with to obtain ; otherwise, we decompose the fifth number\r\ninto smaller numbers plus , and we also combine this with to get .Thus,\r\nthe new decomposition of the number into numbers will have no more\r\nnumbers than the old one, but it will include the number the maximum\r\nnumber that does not exceed . This means that can be decomposed\r\ngreedily.We have reached a contradiction; therefore, the greedy\r\nalgorithm works for any positive number.Now, let’s express the greedy\r\ndecomposition of the number in a more convenient form. We will represent\r\nthe decomposition as a string of length consisting of digits, where the\r\n-th character will denote how many numbers are present in this\r\ndecomposition.Let’s take a closer look at what such a string might look\r\nlike: ; if , then for any , the character (this follows from the proof\r\nof the greedy algorithm). Moreover, any number generates a unique string\r\nof this form. This is very similar to representing a number in a new\r\nnumeric system, which we will call .In summary, the problem has been\r\nreduced to counting the number of numbers in the interval such that the\r\nsum of the digits in the numeral system equals . This is a standard\r\nproblem that can be solved using dynamic programming on digits. Instead\r\nof counting the suitable numbers in the interval , we will count the\r\nsuitable numbers in the intervals and and subtract the first from the\r\nsecond to get the answer. Let be the number of numbers in the interval\r\nsuch that: they have digits; the sum of the digits equals ; if the\r\nprefix of digits of the number is lexicographically greater than these\r\nnumbers, otherwise ; if there has not been a in the digits of these\r\nnumbers yet, otherwise . Transitions in this dynamic programming are not\r\nvery difficult they are basically appending a new digit at the end.The\r\ncomplexity of the solution is , if we estimate the number of numbers up\r\nto as .First, let’s prove that we can decompose numbers into zebra-like\r\nnumbers greedily, constantly subtracting the maximum zebra-like number\r\nwe can (the proof is the same as in the first solution).After that, we\r\nwill learn to calculate the following dynamic programming: the number of\r\nnumbers from to with a zebra value of exactly . The base states of the\r\ndynamic programming will be as follows: (since there are no numbers in\r\nthe interval); (since the number has a zebra value of ); for\r\n(similarly); for (numbers cannot have negative zebra value).\r\nAdditionally, the same can be done for greater than the number of\r\nzebra-like numbers multiplied by (since there cannot be more than\r\nidentical zebra-like numbers in the decomposition of a number). Okay,\r\nnow let’s consider the transitions in this dynamic programming. Suppose\r\nwe want to calculate . We find the largest zebra-like number that is\r\nless than . Then for all numbers from to , the maximum zebra number in\r\nthe decomposition is , and if we subtract it from them, we get the\r\ninterval of numbers from to . Therefore, .Intuitively, it seems that\r\nthere are not many states in this dynamic programming, so it can be\r\ncalculated \"lazily\", and we can store all already computed values in a .\r\nBut let’s prove this. will be on the order of , so let’s estimate the\r\nnumber of different values of that we will need. We will divide them\r\ninto two categories zebra-like numbers and all others.If is a zebra-like\r\nnumber, then the previous zebra number is . Therefore, . Thus, the\r\nstates where is a zebra-like number generate new states, and in total,\r\nthe states where is zebra-like and the states generated by them will\r\nrequire only different values of .If is not a zebra-like number, one of\r\nthe transitions leads to a state with a zebra-like number, and the other\r\ndoes not. That is, from each state, there is a \"chain\" of states with\r\nvalues of that are not zebra-like numbers, and the length of such a\r\nchain is (since every steps in the chain effectively take modulo some\r\nzebra-like number), so there will be a total of values of that are not\r\nzebra numbers.Thus, the total number of states in the dynamic\r\nprogramming will be , so the entire solution will work in for each test\r\ncase.\r\n",
    "name": "E. Zebra-like Numbers",
    "statement": "We call a positive integer if its binary representation has alternating\r\nbits up to the most significant bit, and the least significant bit is\r\nequal to 1. For example, the numbers 1, 5, and 21 are , as their binary\r\nrepresentations 1, 101, and 10101 meet the requirements, while the\r\nnumber 10 is not , as the least significant bit of its binary\r\nrepresentation 1010 is 0.We define the of a positive integer e as the\r\nminimum integer p such that e can be expressed as the sum of p numbers\r\n(possibly the same, possibly different)Given three integers l, r, and k,\r\ncalculate the number of integers x such that l\r\nle x\r\nle r and the of x equals k.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "greedy",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Zebra-like Numbers.json",
    "hint": []
}