{
    "link": "https://codeforces.com//contest/1902/problem/E",
    "problemId": "2362202",
    "problem_idx": "E",
    "shortId": "1902E",
    "contest_number": "1902",
    "problem_submissions": {
        "B": [
            235588094,
            235541813,
            235538695,
            235540200,
            235541986,
            235546581,
            235539624,
            235542221,
            235543196,
            235570763,
            235543003,
            235539161,
            235543236,
            235569611,
            235570026,
            235542153,
            235655407,
            235543168,
            235545066,
            235549273,
            235544565,
            235544393
        ],
        "D": [
            235587336,
            235552561,
            235553295,
            235563680,
            235553330,
            235555395,
            235568492,
            235559700,
            235568658,
            235567617,
            235560146,
            235561416,
            235554309,
            235551620,
            235562986,
            235561764,
            235586816,
            235566705,
            235566898,
            235564749,
            235564461
        ],
        "E": [
            235583583,
            235582606,
            235582050,
            235581289,
            235558586,
            235559098,
            235551541,
            235558190,
            235559848,
            235566108,
            235566192,
            235566094,
            235564789,
            235564113,
            235549751,
            235553064,
            235566369,
            235568437,
            235561807,
            235546129,
            235601857,
            235573551,
            235578412,
            235572635,
            235576054,
            235577219,
            235558759
        ],
        "F": [
            235562465,
            235568838,
            236129130,
            236129102,
            235556472,
            235565709,
            235569182,
            235561417,
            235572126,
            235555263,
            235543234,
            235574528,
            235579496,
            235582447,
            235591540,
            235554289,
            235597722,
            235587185,
            235557652,
            235580838,
            235744278,
            235581308,
            235591762,
            235592390
        ],
        "C": [
            235547363,
            235542973,
            235546654,
            235544681,
            235542274,
            235544554,
            235550388,
            235549932,
            235558653,
            235546403,
            235544913,
            235545913,
            235542697,
            235566604,
            235546411,
            235656040,
            235549867,
            235560184,
            235557908,
            235596779,
            235549641,
            235614612,
            235549186
        ],
        "A": [
            235534144,
            235534113,
            235534651,
            235534058,
            235534240,
            235534127,
            235534119,
            235534985,
            235553076,
            235538076,
            235534100,
            235534474,
            235534171,
            235570865,
            235534497,
            235654959,
            235535402,
            235534132,
            235535287,
            235538251,
            235534330
        ]
    },
    "name": "E. Collapsing Strings",
    "statement": "You are given n strings s_1, s_2,\r\ndots, s_n, consisting of lowercase Latin letters. Let |x| be the length\r\nof string x.Let a C(a, b) of two strings a and b be the following\r\noperation: if a is empty, C(a, b) = b; if b is empty, C(a, b) = a; if\r\nthe last letter of a is equal to the first letter of b, then C(a, b) =\r\nC(a_{1,|a|-1}, b_{2,|b|}), where s_{l,r} is the substring of s from the\r\nl-th letter to the r-th one; otherwise, C(a, b) = a + b, i. e. the\r\nconcatenation of two strings. Calculate\r\nsum\r\nlimits_{i=1}^n\r\nsum\r\nlimits_{j=1}^n |C(s_i, s_j)|.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n\nstruct Trie {\n    char a_init;\n    int D;\n    int INVALID = -1;\n    std::vector<std::vector<int>> child;\n    std::vector<int> par;\n\n    using T_NODE = int;\n    std::vector<T_NODE> v_info;\n\n    Trie(char a_init = 'a', int D = 26)\n        : a_init(a_init), D(D), child(1, std::vector<int>(D, INVALID)), par(1, -1), v_info(1) {}\n\n    int step(int now, char c) const {\n        if (now == INVALID) return INVALID;\n        return child.at(now).at(c - a_init);\n    }\n\n    int add_word(const std::string &str, T_NODE info) {\n        int now = 0;\n        for (auto &c : str) {\n            if (child[now][c - a_init] == INVALID) {\n                par.push_back(now);\n                child[now][c - a_init] = child.size();\n                child.emplace_back(D, INVALID);\n                v_info.resize(child.size());\n            }\n            now = child[now][c - a_init];\n        }\n        v_info[now] += info;\n        return now;\n    }\n};\n\n\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n\n    int N;\n    cin >> N;\n    vector<string> S(N);\n    for (auto &s : S) cin >> s;\n\n    Trie trie;\n    for (auto s : S) trie.add_word(s, 1);\n\n    for (int i = (int)trie.par.size() - 1; i; --i) trie.v_info.at(trie.par.at(i)) += trie.v_info.at(i);\n\n    long long ret = 0;\n    for (const auto &s : S) ret += (long long)s.size() * N * 2;\n\n    for (auto t : S) {\n        reverse(t.begin(), t.end());\n        int now = 0;\n        for (char c : t) {\n            now = trie.step(now, c);\n            if (now < 0) break;\n            ret -= trie.v_info.at(now) * 2;\n        }\n    }\n\n    cout << ret << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "strings",
        "trees"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Collapsing Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/122951",
    "editorial": "Letâs suppose that when we calculate the collapse of two strings and ,\r\nwe reverse the string first, so that instead of checking and removing\r\nthe last letters of , we do this to the first letters of . Then, , where\r\nis the longest common prefix of (the reversed version of ) and .Then the\r\nanswer to the problem becomes .We need some sort of data structure that\r\nallows us to store all strings and for every string , calculate the\r\ntotal LCP of it with all strings in the structure. There are many ways\r\nto implement it (hashing, suffix arrays, etc), but in our opinion, one\r\nof the most straightforward is using a trie.Build a trie on all strings\r\n. Then, for every vertex of the trie, calculate the number of strings\r\nthat end in the subtree of that vertex (you can maintain it while\r\nbuilding the trie: when you add a new string into it, increase this\r\nvalue by on every vertex you go through).If you want to find the of two\r\nstrings and using a trie, you can use the fact that it is equal to the\r\nnumber of vertices that are both on the path to and on the path to at\r\nthe same time (except for the root vertex). This method can be expanded\r\nto querying the sum of of a given string and all strings in the trie as\r\nfollows: try to find in the trie. While searching for it, you will\r\ndescend in the trie and go through vertices that represent prefixes of .\r\nFor every such prefix, you need the number of strings in the trie that\r\nhave the same prefix and it is equal to the number of strings ending in\r\nthe subtree of the corresponding vertex (which we already calculated).\r\nDonât forget that you shouldnât consider the root, since the root\r\nrepresents the empty prefix.This solution works in or , where is the\r\ntotal length of the strings given in the input and is the size of the\r\nalphabet.\r\n",
    "hint": []
}