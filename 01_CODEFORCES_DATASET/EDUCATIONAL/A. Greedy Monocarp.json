{
    "link": "https://codeforces.com//contest/2042/problem/A",
    "problemId": "3063459",
    "problem_idx": "A",
    "shortId": "2042A",
    "contest_number": "2042",
    "problem_submissions": {
        "E": [
            294423774,
            294419934,
            294425145,
            294427314,
            294461391,
            294454616,
            294469820,
            294456785,
            294473828,
            294432050,
            294452832,
            294430074,
            294720157,
            294431481,
            294468510,
            294470387,
            294430159
        ],
        "F": [
            294412520,
            294425551,
            294432280,
            294452436,
            294434993,
            294433145,
            294446063,
            294428799,
            294413717,
            294412873,
            294411042,
            294425120,
            294428614,
            294424117,
            294468671,
            294445770,
            294425722,
            294433551,
            294468661,
            294431992,
            294436625
        ],
        "D": [
            294403997,
            294407353,
            294409781,
            294414370,
            294407554,
            294410319,
            294417815,
            294419253,
            294437550,
            294410412,
            294413967,
            294418349,
            294411907,
            294402733,
            294411823,
            294409744,
            294417262,
            294417181,
            294415900
        ],
        "C": [
            294397589,
            294400380,
            294403833,
            294401565,
            294414063,
            294405958,
            294407677,
            294415266,
            294453518,
            294402202,
            294397037,
            294403746,
            294403563,
            294397148,
            294404737,
            294399098,
            294402722,
            294400450,
            294396822
        ],
        "B": [
            294394491,
            294397696,
            294398701,
            294393052,
            294393883,
            294395178,
            294398939,
            294412364,
            294455866,
            294393748,
            294393435,
            294395970,
            294392768,
            294392321,
            294399650,
            294391444,
            294395529,
            294395407,
            294392933
        ],
        "A": [
            294390734,
            294395467,
            294390153,
            294389939,
            294390115,
            294390408,
            294402923,
            294412466,
            294454482,
            294389870,
            294390174,
            294391619,
            294390031,
            294390265,
            294390266,
            294389845,
            294389856,
            294390624,
            294389907
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/136886",
    "editorial": "Consider several first chests that Monocarp will take before exceeding\r\nthe limit if we don\u00e2\u0080\u0099t add any coins; so, this will be the set of several\r\nlargest chests such that the sum of this set is , but if the next chest\r\nis taken, the sum would exceed .For this set, the minimum number of\r\ncoins that should be added is . We can add exactly that amount if we\r\nincrease the maximum element, the set of chests will include exactly the\r\nsame elements, but now their sum is equal to .Now we have to consider\r\nthe case where we add coins to some chest that is not the part of this\r\nset. Suppose Monocarp took some chest , which initially had coins, but\r\ndid not take chest , such that . In order for chest to be taken, its\r\nfinal value must be at least , as Monocarp selects the maximum chest\r\nfrom the available ones. Let\u00e2\u0080\u0099s suppose that coins were added to chest ,\r\nso that . However, instead, we could have increased chest to the value ,\r\nand this would require fewer coins, since . Thus, we have shown that it\r\nis not optimal to \"change\" the order of the chests, so we can always\r\nassume that Monocarp takes several chests that were the largest in the\r\noriginal order.\r\n",
    "name": "A. Greedy Monocarp",
    "statement": "There are n chests; the i-th chest initially contains a_i coins. For\r\neach chest, you can choose any non-negative (0 or greater) number of\r\ncoins to add to that chest, with one constraint: the total number of\r\ncoins in all chests must become .After you\u2019ve finished adding coins to\r\nthe chests, greedy Monocarp comes, who wants the coins. He will take the\r\nchests one by one, and since he is greedy, he will always choose the\r\nchest with the maximum number of coins. Monocarp will stop as soon as\r\nthe total number of coins in chests he takes is .You want Monocarp to\r\ntake as few coins as possible, so you have to add coins to the chests in\r\nsuch a way that, when Monocarp stops taking chests, he will have coins.\r\nCalculate the minimum number of coins you have to add.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"using namespace std;#define all(x) x.begin(),x.end()template<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << \" \" << p.second; }template<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { string sep; for (const T &x : v) os << sep << x, sep = \" \"; return os; }#ifdef LOCAL#include \"debug.h\"#else#define debug(...) 42#define ASSERT(...) 42#endiftypedef long long ll;typedef vector<int> vi;typedef vector<vi> vvi;typedef pair<int,int> pi;const int oo = 1e9;\u00a0void solve() {    int n,k; cin >> n >> k;    ll ans=0;    vi a(n);    for(auto& i : a) cin >> i;    sort(all(a));    reverse(all(a));    for(auto x : a) {        k-=x;        if(k<0) {            k+=x;            cout <<  k << '\\n';            return;        }    }    cout << k << '\\n';}\u00a0int main() {    ios_base::sync_with_stdio(false);    cin.tie(NULL);    int t; cin >> t;    while(t--) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "sortings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Greedy Monocarp.json"
}