{
    "link": "https://codeforces.com//contest/1455/problem/F",
    "problemId": "815719",
    "problem_idx": "F",
    "shortId": "1455F",
    "contest_number": "1455",
    "problem_submissions": {
        "E": [
            100080155,
            100079381,
            100078449,
            100069275,
            100012146,
            100015897,
            100022845,
            100016854,
            100016418,
            100020237,
            100020046,
            100028425,
            100029068,
            100034230,
            100029402,
            100051234,
            100023750,
            100021088,
            100056948,
            100056790,
            100027354,
            100027044,
            100024946,
            100025731
        ],
        "F": [
            100078450,
            100025388,
            100024460,
            100036395,
            100043068,
            100042389,
            100045529,
            100060216,
            100044226,
            100043456,
            100052099,
            100046594,
            100048576,
            103031134
        ],
        "D": [
            100078448,
            100005946,
            100008735,
            100010384,
            100011871,
            100006215,
            100010441,
            100013223,
            100016383,
            100022310,
            100014989,
            100021069,
            100012652,
            100006839,
            100007553,
            100009178,
            100010622,
            100017383
        ],
        "B": [
            100078446,
            99997720,
            100001458,
            100004151,
            99999328,
            99996708,
            100002292,
            99997258,
            100004647,
            100006268,
            100003306,
            100007106,
            100000261,
            99994951,
            99999396,
            99999653,
            100001010,
            99999631,
            100001869
        ],
        "G": [
            100042304,
            100034172,
            100133399,
            100133353,
            100129809,
            100466593,
            100055077,
            100046402,
            100109589,
            102917383,
            100053452
        ],
        "C": [
            100002522,
            100004461,
            100006266,
            100003366,
            100000366,
            100005398,
            100004212,
            100008763,
            100010135,
            100006377,
            100015174,
            100005740,
            99999911,
            100008765,
            100001216,
            100002465,
            100006020
        ],
        "A": [
            99993343,
            99993450,
            99994266,
            99993464,
            99993313,
            99995467,
            99993403,
            99995627,
            99997962,
            99993689,
            99993532,
            99993614,
            99993321,
            99993386,
            99994914,
            99994222,
            99993353
        ]
    },
    "name": "F. String and Operations",
    "statement": "You are given a string s consisting of n characters. These characters\r\nare among the first k lowercase letters of the Latin alphabet. You have\r\nto perform n operations with the string.During the i-th operation, you\r\ntake the character that the i-th position, and perform of the following\r\nactions with it: swap it with the previous character in the string (if\r\nit exists). This operation is represented as ; swap it with the next\r\ncharacter in the string (if it exists). This operation is represented as\r\n; cyclically change it to the previous character in the alphabet (\r\nbecomes , becomes , and so on; becomes the k-th letter of the Latin\r\nalphabet). This operation is represented as ; cyclically change it to\r\nthe next character in the alphabet ( becomes , becomes , and so on; the\r\nk-th letter of the Latin alphabet becomes ). This operation is\r\nrepresented as ; do nothing. This operation is represented as . For\r\nexample, suppose the initial string is , k = 20, and the sequence of\r\noperations is . Then the string is transformed as follows: the first\r\noperation is , so we change the underlined letter in to the next one in\r\nthe first 20 Latin letters, which is . The string is now ; the second\r\noperation is , so we swap the underlined letter with the next one in the\r\nstring . The string is now ; the third operation is , so we swap the\r\nunderlined letter with the previous one in the string (note that this is\r\nnow the 2-nd character of the string, but it was initially the 3-rd one,\r\nso the 3-rd operation is performed to it). The resulting string is ; the\r\nfourth operation is , so we change the underlined letter in to the\r\nprevious one in the first 20 Latin letters, which is . The string is now\r\n. The result of performing the sequence of operations is .Given the\r\nstring s and the value of k, find the lexicographically smallest string\r\nthat can be obtained after applying a sequence of operations to s.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int N, K;\n    string S;\n    cin >> N >> K >> S;\n\n    auto down = [&](char ch) -> char {\n        return ch == 'a' ? char('a' + K - 1) : char(ch - 1);\n    };\n\n    auto up = [&](char ch) -> char {\n        return ch == char('a' + K - 1) ? 'a' : char(ch + 1);\n    };\n\n    string dp, dp_gap;\n\n    for (int i = 0; i < N; i++) {\n        // Transitions from dp[i]\n        string next_dp = dp + min({S[i], down(S[i]), up(S[i])});\n        string next_dp_gap = dp + S[i];\n\n        if (i >= 1)\n            next_dp = min(next_dp, dp.substr(0, i - 1) + S[i] + dp.back());\n\n        // Transitions from dp_gap[i]\n        if (i >= 1)\n            next_dp = min(next_dp, dp_gap.substr(0, i - 1) + min({S[i], down(S[i]), up(S[i])}) + dp_gap.back());\n\n        if (i >= 2)\n            next_dp = min(next_dp, dp_gap.substr(0, i - 2) + S[i] + dp_gap.substr(i - 2));\n\n        next_dp = min(next_dp, dp_gap + S[i]);\n        swap(dp, next_dp);\n        swap(dp_gap, next_dp_gap);\n    }\n\n    cout << dp << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. String and Operations.json",
    "editorial_link": "https://codeforces.com//blog/entry/85186",
    "editorial": "The crucial observation that we have to make is that the character that\r\ninitially occupied the position cannot occupy the positions to the left\r\nof : we can shift some character two positions to the left using a\r\ncombination of operations , but we canât go any further. So, the prefix\r\nof the first characters of the resulting string can only be affected by\r\nthe prefix of the first characters of the initial string.Letâs use the\r\nfollowing dynamic programming to solve the problem: let be the that we\r\ncan obtain by applying operations to the first characters (that is, is\r\nthe answer to the problem if we consider only first characters of the\r\noriginal string).The transitions here are a bit tricky. If we apply the\r\noperation or to the character , then , where is the character we get\r\nwhen we apply the aforementioned operation to that character. is a bit\r\nmore complicated: we have to insert the character just before the last\r\ncharacter of .Modeling that we can apply the operation is likely the\r\nmost complex transition in our dynamic programming. First of all, we\r\ncanât just make an update to or , since it leads us to a situation where\r\nwe can still apply some operations to the prefix we have built. Instead,\r\nwe have to consider the operation we will be able to do with the\r\ncharacter . Using another operation is useless since the result is like\r\nperforming no operations with those two characters at all, so we have to\r\nconsider two options for operation with the -th character or (whichever\r\nis better), or . In the first case, we update by appending the resulting\r\ntwo characters to (the one that we get when we change , and the one that\r\ninitially was ). In the second case, things are a bit trickier, but\r\nstill not very complicated: the character that was moves two positions\r\nbackward, so it is inserted right before the last character of , and\r\nthen we append to the string we get.So, there are four transitions we\r\nhave to make: a transition from to that models the case when we apply or\r\nto the -th character; a transition from to that models the case when we\r\napply to the -th character; a transition from to to model the operations\r\nor ; a transition from to to model the operations . Overall complexity\r\nis but it can be improved to with some complicated data structures like\r\npersistent segment tree with hashes to compare strings and append\r\ncharacters to them in .\r\n",
    "hint": []
}