{"link": "https://codeforces.com//contest/1455/problem/F", "problemId": "815719", "problem_idx": "F", "shortId": "1455F", "contest_number": "1455", "problem_submissions": {"E": [100080155, 100079381, 100078449, 100069275, 100012146, 100015897, 100022845, 100016854, 100016418, 100020237, 100020046, 100028425, 100029068, 100034230, 100029402, 100051234, 100023750, 100021088, 100056948, 100056790, 100027354, 100027044, 100024946, 100025731], "F": [100078450, 100025388, 100024460, 100036395, 100043068, 100042389, 100045529, 100060216, 100044226, 100043456, 100052099, 100046594, 100048576, 103031134], "D": [100078448, 100005946, 100008735, 100010384, 100011871, 100006215, 100010441, 100013223, 100016383, 100022310, 100014989, 100021069, 100012652, 100006839, 100007553, 100009178, 100010622, 100017383], "B": [100078446, 99997720, 100001458, 100004151, 99999328, 99996708, 100002292, 99997258, 100004647, 100006268, 100003306, 100007106, 100000261, 99994951, 99999396, 99999653, 100001010, 99999631, 100001869], "G": [100042304, 100034172, 100133399, 100133353, 100129809, 100466593, 100055077, 100046402, 100109589, 102917383, 100053452], "C": [100002522, 100004461, 100006266, 100003366, 100000366, 100005398, 100004212, 100008763, 100010135, 100006377, 100015174, 100005740, 99999911, 100008765, 100001216, 100002465, 100006020], "A": [99993343, 99993450, 99994266, 99993464, 99993313, 99995467, 99993403, 99995627, 99997962, 99993689, 99993532, 99993614, 99993321, 99993386, 99994914, 99994222, 99993353]}, "name": "F. String and Operations", "statement": "You are given a string s consisting of n characters. These characters\r\nare among the first k lowercase letters of the Latin alphabet. You have\r\nto perform n operations with the string.During the i-th operation, you\r\ntake the character that the i-th position, and perform of the following\r\nactions with it: swap it with the previous character in the string (if\r\nit exists). This operation is represented as ; swap it with the next\r\ncharacter in the string (if it exists). This operation is represented as\r\n; cyclically change it to the previous character in the alphabet (\r\nbecomes , becomes , and so on; becomes the k-th letter of the Latin\r\nalphabet). This operation is represented as ; cyclically change it to\r\nthe next character in the alphabet ( becomes , becomes , and so on; the\r\nk-th letter of the Latin alphabet becomes ). This operation is\r\nrepresented as ; do nothing. This operation is represented as . For\r\nexample, suppose the initial string is , k = 20, and the sequence of\r\noperations is . Then the string is transformed as follows: the first\r\noperation is , so we change the underlined letter in to the next one in\r\nthe first 20 Latin letters, which is . The string is now ; the second\r\noperation is , so we swap the underlined letter with the next one in the\r\nstring . The string is now ; the third operation is , so we swap the\r\nunderlined letter with the previous one in the string (note that this is\r\nnow the 2-nd character of the string, but it was initially the 3-rd one,\r\nso the 3-rd operation is performed to it). The resulting string is ; the\r\nfourth operation is , so we change the underlined letter in to the\r\nprevious one in the first 20 Latin letters, which is . The string is now\r\n. The result of performing the sequence of operations is .Given the\r\nstring s and the value of k, find the lexicographically smallest string\r\nthat can be obtained after applying a sequence of operations to s.\r\n", "solutions": ["#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int N, K;\n    string S;\n    cin >> N >> K >> S;\n\n    auto down = [&](char ch) -> char {\n        return ch == 'a' ? char('a' + K - 1) : char(ch - 1);\n    };\n\n    auto up = [&](char ch) -> char {\n        return ch == char('a' + K - 1) ? 'a' : char(ch + 1);\n    };\n\n    string dp, dp_gap;\n\n    for (int i = 0; i < N; i++) {\n        // Transitions from dp[i]\n        string next_dp = dp + min({S[i], down(S[i]), up(S[i])});\n        string next_dp_gap = dp + S[i];\n\n        if (i >= 1)\n            next_dp = min(next_dp, dp.substr(0, i - 1) + S[i] + dp.back());\n\n        // Transitions from dp_gap[i]\n        if (i >= 1)\n            next_dp = min(next_dp, dp_gap.substr(0, i - 1) + min({S[i], down(S[i]), up(S[i])}) + dp_gap.back());\n\n        if (i >= 2)\n            next_dp = min(next_dp, dp_gap.substr(0, i - 2) + S[i] + dp_gap.substr(i - 2));\n\n        next_dp = min(next_dp, dp_gap + S[i]);\n        swap(dp, next_dp);\n        swap(dp_gap, next_dp_gap);\n    }\n\n    cout << dp << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"], "input": "", "output": "", "tags": ["dp", "greedy"], "dificulty": "2800", "interactive": false}