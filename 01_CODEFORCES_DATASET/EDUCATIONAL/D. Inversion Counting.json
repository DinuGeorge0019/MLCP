{
    "link": "https://codeforces.com//contest/911/problem/D",
    "problemId": "142498",
    "problem_idx": "D",
    "shortId": "911D",
    "contest_number": "911",
    "problem_submissions": {
        "F": [
            33730338,
            33736236,
            33729501,
            33733851,
            33737431,
            33736160,
            33727192,
            33731600,
            33738270,
            33731121,
            33731406,
            33727367,
            33728276,
            33726638,
            33731778,
            33732737,
            33730029,
            33731049,
            33829722,
            33829713,
            33734856
        ],
        "G": [
            33728994,
            33728318,
            33736310,
            33730624,
            33734693,
            33730072,
            33735518,
            33736927,
            33973095,
            33726198,
            33734145,
            33725486,
            33916145,
            33742312,
            33742380,
            33759087,
            33796642,
            33796567,
            76805271,
            33829935,
            33829896,
            33829810,
            33829610
        ],
        "E": [
            33722163,
            33722735,
            33725907,
            33726299,
            33730629,
            33721023,
            33733522,
            33726343,
            33733907,
            33718645,
            33736707,
            33723912,
            33723633,
            33723315,
            33722403,
            33726466,
            33724328,
            33722719,
            33725898
        ],
        "D": [
            33717830,
            33719177,
            33731193,
            33727114,
            33724269,
            33733276,
            33731713,
            33720741,
            33735525,
            33736390,
            33733900,
            33719447,
            33718488,
            33721217,
            33717781,
            33719325,
            33720612,
            33717555,
            33721885
        ],
        "C": [
            33716749,
            33717557,
            33718909,
            33717327,
            33726728,
            33731930,
            33730836,
            33718913,
            33730374,
            33721277,
            33735066,
            33717357,
            33719578,
            33716462,
            33717823,
            33718307,
            33715178,
            33719484
        ],
        "B": [
            33714368,
            33718005,
            33715412,
            33715624,
            33717403,
            33729431,
            33715928,
            33715342,
            33736651,
            33732506,
            33715356,
            33714796,
            33715837,
            33713865,
            33715844,
            33716072,
            33718139,
            33716208
        ],
        "A": [
            33713428,
            33714079,
            33713974,
            33713612,
            33713484,
            33713403,
            33728723,
            33713514,
            33713445,
            33735048,
            33731862,
            33714094,
            33713551,
            33713430,
            33713412,
            33713709,
            33713489,
            33714231,
            33713552
        ]
    },
    "name": "D. Inversion Counting",
    "statement": "A permutation of size is an array of size such that each integer from to\r\noccurs exactly once in this array. An inversion in a permutation is a\r\npair of indices such that and . For example, a permutation contains\r\ninversions: , , , .You are given a permutation of size and queries to\r\nit. Each query is represented by two indices and denoting that you have\r\nto reverse the segment of the permutation. For example, if and a query ,\r\nis applied, then the resulting permutation is .After each query you have\r\nto determine whether the number of inversions is odd or even.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#ifndef ONLINE_JUDGE\n# include <sys/time.h>\n# include <sys/resource.h>\n#endif\n\n/*** TEMPLATE CODE STARTS HERE ***/\n\n#ifndef M_PI\n#define M_PI 3.1415926535897932384626433832795028841971693993751\n#endif\n\nusing namespace std;\n\ntypedef vector<string> vs;\ntypedef long long ll;\ntypedef complex<double> pnt;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define RA(x) begin(x), end(x)\n#define FE(i, x) for (auto i = begin(x); i != end(x); ++i)\n#define SZ(x) ((ll) (x).size())\n\ntemplate<class T>\nvoid splitstr(const string &s, vector<T> &out)\n{\n    istringstream in(s);\n    out.clear();\n    copy(istream_iterator<T>(in), istream_iterator<T>(), back_inserter(out));\n}\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nstatic void redirect(int argc, const char **argv)\n{\n#ifndef ONLINE_JUDGE\n    struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_STACK, &rlim);\n#ifndef __SANITIZE_ADDRESS__\n    getrlimit(RLIMIT_DATA, &rlim);\n    rlim.rlim_cur = 256 * 1024 * 1024;\n    setrlimit(RLIMIT_DATA, &rlim);\n#endif\n#endif\n\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n    if (argc > 1)\n    {\n        static filebuf f;\n        f.open(argv[1], ios::in);\n        cin.rdbuf(&f);\n        if (!cin)\n        {\n            cerr << \"Failed to open '\" << argv[1] << \"'\" << endl;\n            exit(1);\n        }\n    }\n\n    if (argc > 2)\n    {\n        static filebuf f;\n        f.open(argv[2], ios::out | ios::trunc);\n        cout.rdbuf(&f);\n        if (!cout)\n        {\n            cerr << \"Failed to open '\" << argv[2] << \"'\" << endl;\n        }\n    }\n}\n\n/*** TEMPLATE CODE ENDS HERE */\n\nint main(int argc, const char **argv)\n{\n    redirect(argc, argv);\n    int N;\n    cin >> N;\n    vi a(N);\n    for (int i = 0; i < N; i++)\n        cin >> a[i];\n    int swap = 0;\n    for (int i = 0; i < N; i++)\n        for (int j = i + 1; j < N; j++)\n            if (a[i] > a[j])\n                swap++;\n    swap &= 1;\n    int M;\n    cin >> M;\n    for (int i = 0; i < M; i++)\n    {\n        int l, r;\n        cin >> l >> r;\n        ll s = r - l + 1;\n        ll c = s * (s - 1) / 2;\n        swap ^= c & 1;\n        cout << (swap ? \"odd\\n\" : \"even\\n\");\n    }\n\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "math"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Inversion Counting.json",
    "editorial_link": "https://codeforces.com/blog/entry/56771",
    "editorial": "Permutaion with one swap is called transposition. Any permutation can be\r\nexpressed as the composition (product) of transpositions. Simpler, you\r\ncan get any permutation from any other one of the same length by doing\r\nsome number of swaps. The sign of the permutation is the number of\r\ntranspositions needed to get it from the identity permutation. Luckily\r\n(not really, this is pure math, check out all proofs at wiki, e.g) the\r\nsign can also tell us the parity of inversion count. Now you can start\r\nwith computing parity of inversion count of the original permutation\r\n(naively, check all pairs of indices). Finally you can decompose queries\r\ninto swaps, any method will be ok. Like, you can swap and , then and and\r\nso on (this is swaps). Then parity of inversion count of the resulting\r\npermutation will change if you applied odd number of swaps.Overall\r\ncomplexity: .\r\n"
}