{
    "link": "https://codeforces.com//contest/1278/problem/D",
    "problemId": "498933",
    "problem_idx": "D",
    "shortId": "1278D",
    "contest_number": "1278",
    "problem_submissions": {
        "E": [
            67224918,
            67231614,
            67223912,
            67253812,
            67225741,
            67224871,
            67225251,
            67224253,
            67224097,
            67228073,
            67224351,
            67238384,
            67238891,
            67235763,
            67230622,
            67227930,
            67239651,
            67240882,
            67235370,
            67231237,
            67232624
        ],
        "F": [
            67220843,
            67234059,
            67225490,
            67229828,
            67232198,
            67228232,
            67234554,
            67236753,
            67235814,
            67235952,
            67222634,
            67222261,
            67233844,
            67234877,
            67233597,
            67235880,
            168626483,
            67236179,
            67239000,
            67242413,
            67234942
        ],
        "D": [
            67217029,
            67303164,
            67301866,
            67298063,
            67237371,
            67236431,
            67235408,
            67220294,
            67220865,
            67220608,
            67221489,
            67220476,
            67219646,
            67219320,
            67220067,
            67226705,
            67224401,
            67222526,
            67227114,
            67223817,
            67223367,
            67231531,
            67228179,
            67226295
        ],
        "C": [
            67214007,
            67214267,
            67217998,
            67216889,
            67218307,
            67216554,
            67216623,
            67215042,
            67215238,
            67217005,
            67217682,
            67215492,
            67219419,
            67219630,
            67218331,
            67220921,
            67220564,
            67238779
        ],
        "B": [
            67212862,
            67212809,
            67214461,
            67213367,
            67214581,
            67214399,
            67214511,
            67213321,
            67213424,
            67214716,
            67216187,
            67217236,
            67216491,
            67238990,
            67224941,
            67214356,
            67216320,
            67214479,
            67213910
        ],
        "A": [
            67212605,
            67233989,
            67212600,
            67213460,
            67212650,
            67212623,
            67213201,
            67212677,
            67212601,
            67212657,
            67213584,
            67212831,
            67213003,
            67213058,
            67213442,
            67213081,
            67213875,
            67213272,
            67212886
        ]
    },
    "name": "D. Segment Tree",
    "statement": "As the name of the task implies, you are asked to do some work with\r\nsegments and trees.Recall that a tree is a connected undirected graph\r\nsuch that there is exactly one simple path between every pair of its\r\nvertices.You are given n segments [l_1, r_1], [l_2, r_2],\r\ndots, [l_n, r_n], l_i < r_i for every i. It is guaranteed that all\r\nsegments\u2019 endpoints are integers, and all endpoints are unique there is\r\nno pair of segments such that they start in the same point, end in the\r\nsame point or one starts in the same point the other one ends.Let\u2019s\r\ngenerate a graph with n vertices from these segments. Vertices v and u\r\nare connected by an edge if and only if segments [l_v, r_v] and [l_u,\r\nr_u] intersect and neither of it lies fully inside the other one.For\r\nexample, pairs ([1, 3], [2, 4]) and ([5, 10], [3, 7]) will induce the\r\nedges but pairs ([1, 2], [3, 4]) and ([5, 7], [3, 10]) will\r\nnot.Determine if the resulting graph is a tree or not.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n;\nvector<P>vec;\nmap<int,int>M;\nvector<int>edge[500005];\nbool used[500005];\nvoid dfs(int v){\n\tif(used[v]) return ; used[v] = 1;\n\trep(i,edge[v].size()){\n\t\tint to = edge[v][i];\n\t\tif(!used[to]) dfs(to);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\trepn(i,n){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); vec.pb(P(a,b));\n\t}\n\tsort(vec.begin(),vec.end());\n\tint cnt = 0;\n\trep(i,n){\n\t\tfor(auto it=M.lower_bound(-vec[i].sc);it!=M.end();it++){\n\t\t\tint a = -1*(*it).fi;\n\t\t\tif(a < vec[i].fi) break;\n\t\t\tcnt++;\n\t\t\tif(cnt == n){\n\t\t\t\tputs(\"NO\"); return 0;\n\t\t\t}\n\t\t\tedge[i].pb((*it).sc);\n\t\t\tedge[(*it).sc].pb(i);\n\t\t\t//cout << (*it).sc << \" \" << i << endl;\n\t\t}\n\t\tM[-vec[i].sc] = i;\n\t}\n\tif(cnt != n-1) {puts(\"NO\"); return 0;}\n\tdfs(0);\n\trep(i,n){\n\t\tif(!used[i]){ puts(\"NO\"); return 0;}\n\t}\n\tputs(\"YES\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Segment Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/72330",
    "editorial": "The main idea of the solution is to find a linear number of\r\nintersections of segments.Intersections can be found with sweep line\r\napproach. We will maintain a set for the endpoints open segments. When\r\nwe add a segment, we find all segments which intersect with it that is,\r\nall segments that end earlier than it. Obviously, if the number of\r\nintersections are greater than , then the answer is \"\". So as soon as we\r\nfind intersections, we stop our algorithm.After that, it is necessary to\r\ncheck the connectivity of the resulting graph. You can use DFS or DSU to\r\ndo this.\r\n"
}