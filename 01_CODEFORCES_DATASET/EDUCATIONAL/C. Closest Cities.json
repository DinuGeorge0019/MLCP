{
    "link": "https://codeforces.com//contest/1922/problem/C",
    "problemId": "2433276",
    "problem_idx": "C",
    "shortId": "1922C",
    "contest_number": "1922",
    "problem_submissions": {
        "F": [
            242258354,
            242278276,
            242274562,
            242271525,
            242258097,
            242274599,
            242271507,
            242268588,
            242285652,
            242271581,
            242270540,
            242278542,
            242282333,
            242270699,
            242270119,
            242276867,
            242286431,
            242276715,
            242276487,
            242283192,
            242281108,
            242278860,
            242278983,
            242285548
        ],
        "E": [
            242241568,
            242225493,
            242242029,
            242279592,
            242237693,
            242231955,
            242236354,
            242245342,
            242255638,
            242244187,
            242239291,
            242260117,
            242249388,
            242249138,
            242239806,
            242257431,
            242256396,
            242263321,
            242231103,
            242254535,
            242253629,
            242270325
        ],
        "D": [
            242234045,
            242236857,
            242236461,
            242246467,
            242239405,
            242245547,
            242240299,
            242240756,
            242237650,
            242234866,
            242248459,
            242242872,
            242244162,
            242252228,
            242244373,
            242239696,
            242254494,
            242245049,
            242250144,
            242243755,
            242246758
        ],
        "C": [
            242227385,
            242230966,
            242228502,
            242224242,
            242227745,
            242228850,
            242229081,
            242228504,
            242227487,
            242227235,
            242229333,
            242232708,
            242229815,
            242234164,
            242230429,
            242229813,
            242239026,
            242239967,
            242231740,
            242235920
        ],
        "B": [
            242220641,
            242221058,
            242221110,
            242219955,
            242221311,
            242233194,
            242221713,
            242221320,
            242222042,
            242223201,
            242221647,
            242219752,
            242221561,
            242226204,
            242224089,
            242222658,
            242227596,
            242222002,
            242224729,
            242223236
        ],
        "A": [
            242219259,
            242219714,
            242223200,
            242219077,
            242219362,
            242220179,
            242219565,
            242219194,
            242219734,
            242219881,
            242219505,
            242219046,
            242219400,
            242221402,
            242220981,
            242220554,
            242223002,
            242219741,
            242219322,
            242220234
        ]
    },
    "name": "C. Closest Cities",
    "statement": "There are n cities located on the number line, the i-th city is in the\r\npoint a_i. The coordinates of the cities are given in ascending order,\r\nso a_1 < a_2 <\r\ndots < a_n.The distance between two cities x and y is equal to |a_x -\r\na_y|.For each city i, let’s define the city j as the city such that the\r\ndistance between i and j is not greater than the distance between i and\r\neach other city k. For example, if the cities are located in points [0,\r\n8, 12, 15, 20], then: the closest city to the city 1 is the city 2; the\r\nclosest city to the city 2 is the city 3; the closest city to the city 3\r\nis the city 4; the closest city to the city 4 is the city 3; the closest\r\ncity to the city 5 is the city 4. The cities are located in such a way\r\nthat for every city, the closest city is unique. For example, it is\r\nimpossible for the cities to be situated in points [1, 2, 3], since this\r\nwould mean that the city 2 has two closest cities (1 and 3, both having\r\ndistance 1).You can travel between cities. Suppose you are currently in\r\nthe city x. Then you can perform one of the following actions: travel to\r\nany other city y, paying |a_x - a_y| coins; travel to the city which is\r\nthe closest to x, paying 1 coin. You are given m queries. In each query,\r\nyou will be given two cities, and you have to calculate the minimum\r\nnumber of coins you have to spend to travel from one city to the other\r\ncity.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#include \"debug.h\"  // https://github.com/Heltion/debug.h/blob/main/debug.h\n#else\n#define debug(...) (void)417\n#endif\nusing i64 = int64_t;\nint main() {\n  cin.tie(nullptr)->sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n  int t;\n  cin >> t;\n  for (int ti = 0; ti < t; ti += 1) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int& ai : a) { cin >> ai; }\n    vector<int> b(n), c(n);\n    for (int i = 1; i < n; i += 1) {\n      if (i == 1 or a[i] - a[i - 1] < a[i - 1] - a[i - 2]) {\n        b[i] = a[i] - a[i - 1] - 1;\n      }\n      b[i] += b[i - 1];\n    }\n    for (int i = n - 2; i >= 0; i -= 1) {\n      if (i == n - 2 or a[i + 1] - a[i] < a[i + 2] - a[i + 1]) {\n        c[i] = a[i + 1] - a[i] - 1;\n      }\n      c[i] += c[i + 1];\n    }\n    int m;\n    cin >> m;\n    for (int i = 0, x, y; i < m; i += 1) {\n      cin >> x >> y;\n      x -= 1;\n      y -= 1;\n      int ans = abs(a[x] - a[y]);\n      cout << ans - (x < y ? b[y] - b[x] : c[y] - c[x]) << \"\\n\";\n    }\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Closest Cities.json",
    "editorial_link": "https://codeforces.com//blog/entry/124890",
    "editorial": "Important observation: the answer will not change if you are allowed to\r\nmove only to adjacent cities. It is true because if you move to a\r\nnon-adjacent city, you can split the path to that city into parts\r\nwithout increasing its cost. So, the shortest way from to (consider the\r\ncase ) is to move from city to city for coin if itâs possible or for if\r\nitâs not. Then move from city to city for coin if itâs possible, or for\r\ncoins if itâs not. And so on, until we reach the city .Now letâs\r\ncalculate two arrays: and . is equal to the minimum amount of coins to\r\nreach the city from city (from left to right), is equal to the minimum\r\namount of coins to reach the city from city (from right to left). Both\r\nof these arrays can be precalculated just like the arrays of prefix sums\r\nare calculated. For example, , , , and so on. Here, denotes the cheapest\r\nway to travel between two adjacent cities and .Then, the cheapest way\r\nbetween two cities and can be calculated in the same way as the sum on\r\nsubarray is calculated for the prefix sum array. There are two cases: If\r\nthen the answer is ; If then the answer is ;\r\n",
    "hint": []
}