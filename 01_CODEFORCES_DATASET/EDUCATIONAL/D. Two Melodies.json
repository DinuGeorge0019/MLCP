{
    "link": "https://codeforces.com//contest/813/problem/D",
    "problemId": "108591",
    "problem_idx": "D",
    "shortId": "813D",
    "contest_number": "813",
    "problem_submissions": {
        "F": [
            27592959,
            27592462,
            27595859,
            27593693,
            27589826,
            27597032,
            27592495,
            27594242,
            27592969,
            27592265,
            27592101,
            27593647,
            27593448,
            27607698,
            27607690,
            27597005
        ],
        "D": [
            27591413,
            27596376,
            27595878,
            27592392,
            27596101,
            27595104,
            27676236,
            27675210,
            27591510,
            27603640,
            27593900,
            27624567,
            27624550,
            27624539,
            27628580,
            27593089,
            27592322,
            28282372,
            28281379
        ],
        "E": [
            27590671,
            27593775,
            27594164,
            27598623,
            27590165,
            27587725,
            27590977,
            27593884,
            27590632,
            27590190,
            27593976,
            27593899,
            27591757,
            27595354,
            27602821,
            27589094,
            27596364,
            27590212,
            27590714,
            27590708
        ],
        "C": [
            27586798,
            27589288,
            27588038,
            27588205,
            27585642,
            27587654,
            27587622,
            27598220,
            27588200,
            27597496,
            27586750,
            27587670,
            27588183,
            27589351,
            27598034,
            27587880,
            27588758,
            27588420,
            27587303,
            27587398,
            27597722,
            27588272
        ],
        "B": [
            27587426,
            27586981,
            27586763,
            27590844,
            27586387,
            27587082,
            27586616,
            27585981,
            27586358,
            27586732,
            27588430,
            27586365,
            27587378,
            27586643,
            27586207,
            27586121
        ],
        "A": [
            27586386,
            27585541,
            27587254,
            27590210,
            27585562,
            27585639,
            27585557,
            27585471,
            27585490,
            27585606,
            27586831,
            27585625,
            27586127,
            27585762,
            27585515,
            27585489,
            27585475
        ]
    },
    "name": "D. Two Melodies",
    "statement": "Alice is a beginner composer and now she is ready to create another\r\nmasterpiece. And not even the single one but two at the same time! Alice\r\nhas a sheet with notes written on it. She wants to take two such\r\nnon-empty non-intersecting subsequences that both of them form a and sum\r\nof their lengths is maximal.Subsequence forms a melody when each two\r\nadjacent notes either differs by or are congruent modulo .You should\r\nwrite a program which will calculate maximum sum of lengths of such two\r\nnon-empty non-intersecting subsequences that both of them form a melody.\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 5140\nvoid build(){\n\n}\nint n , a[ N ];\nqueue<int> q[ 101010 ] , q2[ 7 ];\nvoid init(){\n  n = getint();\n  for( int i = 1 ; i <= n ; i ++ ){\n    a[ i ] = getint();\n    q[ a[ i ] ].push( i );\n    q2[ a[ i ] % 7 ].push( i );\n  }\n}\nint dp[ N ][ N ] , ans;\nint next( int vl , int rr ){\n  while( q[ vl ].size() and q[ vl ].front() <= rr )\n    q[ vl ].pop();\n  if( q[ vl ].empty() ) return -1;\n  return q[ vl ].front();\n}\nint next2( int vl , int rr ){\n  while( q2[ vl ].size() and q2[ vl ].front() <= rr )\n    q2[ vl ].pop();\n  if( q2[ vl ].empty() ) return -1;\n  return q2[ vl ].front();\n}\nvoid solve(){\n  ans = 2;\n  for( int i = 1 ; i <= n ; i ++ ){\n    for( int j = i + 1 ; j <= n ; j ++ )\n      dp[ i ][ j ] = 2;\n    dp[ 0 ][ i ] = 1;\n  }\n  for( int r = 1 ; r <= n ; r ++ )\n    for( int l = 0 ; l < r ; l ++ ){\n      if( dp[ l ][ r ] == 0 ) continue;\n      ans = max( ans , dp[ l ][ r ] );\n      {\n        if( l == 0 ){\n          for( int nxt = r + 1 ; nxt <= n ; nxt ++ )\n            dp[ r ][ nxt ] = max( dp[ r ][ nxt ] , dp[ l ][ r ] + 1 );\n        }else{\n          for( int dlt = -1 ; dlt <= 1 ; dlt += 2 ){\n            int nxt = next( a[ l ] + dlt , r );\n            if( nxt == -1 ) continue;\n            dp[ r ][ nxt ] = max( dp[ r ][ nxt ] , dp[ l ][ r ] + 1 );\n          }\n          int nxt = next2( a[ l ] % 7 , r );\n          if( nxt != -1 )\n            dp[ r ][ nxt ] = max( dp[ r ][ nxt ] , dp[ l ][ r ] + 1 );\n        }\n      }\n      {\n        for( int dlt = -1 ; dlt <= 1 ; dlt += 2 ){\n          int nxt = next( a[ r ] + dlt , r );\n          if( nxt == -1 ) continue;\n          dp[ l ][ nxt ] = max( dp[ l ][ nxt ] , dp[ l ][ r ] + 1 );\n        }\n        {\n          int nxt = next2( a[ r ] % 7 , r );\n          if( nxt != -1 )\n            dp[ l ][ nxt ] = max( dp[ l ][ nxt ] , dp[ l ][ r ] + 1 );\n        }\n        if( l == 0 ){\n          for( int nxt = r + 1 ; nxt <= n ; nxt ++ ){\n            if( a[ nxt ] % 7 == a[ r ] % 7 or\n                abs( a[ nxt ] - a[ r ] ) == 1 )\n            dp[ l ][ nxt ] = max( dp[ l ][ nxt ] , dp[ l ][ r ] + 1 );\n          }\n        }\n      }\n    }\n  cout << ans << endl;\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "flows"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Two Melodies.json",
    "editorial_link": "https://codeforces.com//blog/entry/52410",
    "editorial": "Let\u00e2\u0080\u0099s solve this problem with dynamic programming.Let be the maximum\r\nanswer if one melody finishes in note number and another melody in note\r\nnumber . and are -indexed; if one of them is , then the melody is\r\nempty.How shall we update ? First of all, we will update from previous\r\nvalues only if . If , then obviously answer is , and if , then we take\r\nthe answer for .Secondly, to avoid intersections, we will update only\r\nusing values of , where and . Why? Because if we update from some , and\r\n, then it can lead to some intersection (we can\u00e2\u0080\u0099t guarantee we didn\u00e2\u0080\u0099t\r\nuse in the first melody).How can we make fast updates? We will count\r\nfrom to . Then, while counting for some specific , we will maintain two\r\narrays: the maximum value of encountered so far where ; the maximum\r\nvalue of encountered so far where . So when we need to count , it will\r\nbe the maximum of four values: if we add a note which is congruent\r\nmodulo with the last one; if we add a note which is less by than the\r\nlast note; if we add a note which is greater by than the last note; if\r\nwe just start a melody. These values can be calculated in .\r\n"
}