{
    "link": "https://codeforces.com//contest/660/problem/C",
    "problemId": "54413",
    "problem_idx": "C",
    "shortId": "660C",
    "contest_number": "660",
    "problem_submissions": {
        "F": [
            17239364,
            17239205,
            17239755,
            17238017,
            32736003,
            32634422,
            17240355,
            17266440,
            17390273,
            17390239,
            17390167,
            17239067,
            17283949,
            17242419,
            28385899,
            17237899
        ],
        "E": [
            17237675,
            18655900,
            17236241,
            17236591,
            17240301,
            17237690,
            17235572,
            17235893,
            17238324,
            17238151,
            17239741,
            17240955,
            17239261,
            17238105,
            28384744,
            17238510,
            17241405,
            17239444,
            17239692
        ],
        "C": [
            17233149,
            17233742,
            17234548,
            17232545,
            17234726,
            17232794,
            17232880,
            17232362,
            17233050,
            17232479,
            17233218,
            17232540,
            17233780,
            17233237,
            17233749,
            17233672,
            17233999,
            17234257
        ],
        "D": [
            17232410,
            17234486,
            17232234,
            17233026,
            17235245,
            17233173,
            17233945,
            17233153,
            17235270,
            17235762,
            17234096,
            17244499,
            17244482,
            17233228,
            17234097,
            17233913,
            17234439,
            17234508,
            17394145,
            17235565,
            17235267
        ],
        "B": [
            17232075,
            17232491,
            17233215,
            17240579,
            17234008,
            17232211,
            17232270,
            17233552,
            17232203,
            17233514,
            17232306,
            17232154,
            17233087,
            17233547,
            17232582,
            17233079,
            17232801,
            17232756
        ],
        "A": [
            17231695,
            17231866,
            17231724,
            17231870,
            17233301,
            17231713,
            17231748,
            17231689,
            17231712,
            17231907,
            17231758,
            17231697,
            17231904,
            17231863,
            17232106,
            17232315,
            17231848,
            17231851
        ]
    },
    "name": "C. Hard Process",
    "statement": "You are given an array with elements. Each element of is either or\r\n.Let’s denote the length of the longest subsegment of consecutive\r\nelements in , consisting of only numbers one, as . You can change no\r\nmore than zeroes to ones to maximize .\r\n",
    "solutions": [
        "# include <cstdio>\n# include <set>\nusing namespace std;\nconst int MN = 3e5 + 44;\nint a[MN];\nint main()\n{\n\tint n, k;\n\tscanf(\"%d%d\", &n, &k);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tscanf(\"%d\", a + i);\n\t\ta[i] ^= 1;\n\t}\n\tint res = 0;\n\tint sum = 0;\n\tint h = 0;\n\tint l = 0, r = 0;\n\tfor (int t = 0; t < n; ++t)\n\t{\n\t\twhile (sum + a[h] <= k && h < n)\n\t\t{\n\t\t\tsum += a[h];\n\t\t\th++;\n\t\t}\n\t\tif (h - t > res)\n\t\t{\n\t\t\tres = h - t;\n\t\t\tl = t;\n\t\t\tr = h;\n\t\t}\n\t\tres = max(res, h - t);\n\t\tsum -= a[t];\n\t}\n\tprintf(\"%d\\n\", res);\n\tfor (int i = l; i < r; ++i)\n\t\ta[i] = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tprintf(\"%d \", 1 - a[i]);\n\tprintf(\"\\n\");\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp",
        "two pointers"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Hard Process.json",
    "editorial_link": "https://codeforces.com//blog/entry/44259",
    "editorial": "The problem was suggested by Mohammad Amin Raeisi Smaug. Letâs call the\r\nsegment good if it contains no more than zeroes. Note if segment is good\r\nthan the segment is also good. So we can use the method of two pointers:\r\nthe first pointer is and the second is . Letâs iterate over from the\r\nleft to the right and move while we can (to do that we should simply\r\nmaintain the number of zeroes in the current segment). C++ solution\r\n",
    "hint": []
}