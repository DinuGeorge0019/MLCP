{
    "link": "https://codeforces.com//contest/2026/problem/C",
    "problemId": "2985130",
    "problem_idx": "C",
    "shortId": "2026C",
    "contest_number": "2026",
    "problem_submissions": {
        "F": [
            288561266,
            289460762,
            288610204,
            288597833,
            288597166,
            288569834,
            288622486,
            288654341,
            288862318,
            289435066
        ],
        "E": [
            288532750,
            288648436,
            289460758,
            288538098,
            288522785,
            288536060,
            288547433,
            288544648,
            288565205,
            288561153,
            288562514,
            288560885,
            288560234,
            288562220,
            288569450,
            288563732,
            288565049,
            288562236,
            288561108,
            288565165,
            288569967
        ],
        "C": [
            288529378,
            288523247,
            288587507,
            288523790,
            288525729,
            288530332,
            288531829,
            288528175,
            288530132,
            288533395,
            288532265,
            288535389,
            288532312,
            288535104,
            288538148,
            288539384,
            288557011,
            288540483,
            288538281
        ],
        "D": [
            288525443,
            288532543,
            288578032,
            288532129,
            288536966,
            288541005,
            288544765,
            288551300,
            288551604,
            288547887,
            288547345,
            288554913,
            288553450,
            288546930,
            288552551,
            288553665,
            288542913,
            288552909,
            288551588
        ],
        "B": [
            288512906,
            288512626,
            288591954,
            288514323,
            288515612,
            288518687,
            288518565,
            288516062,
            288516991,
            288516923,
            288523730,
            288523890,
            288520786,
            288521682,
            288521503,
            288524297,
            288520697,
            288521668,
            288521796
        ],
        "A": [
            288510200,
            288515667,
            288594432,
            288510659,
            288510501,
            288510904,
            288511010,
            288517929,
            288511642,
            288510491,
            288516233,
            288511665,
            288510831,
            288512187,
            288514794,
            288512225,
            288511936,
            288512066,
            288512165
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135680",
    "editorial": "Consider the following solution: we iterate on the number of figures we\r\nget for free (let this number be ), and for each value of , we try to\r\ncheck if it is possible to get figures for free, and if it is, find the\r\nbest figures which we get for free.For a fixed value of , it is optimal\r\nto visit the shop exactly times: if we visit the shop more than times,\r\nthen during some visits, we buy only one figure instead of that, we can\r\nbuy figures from these visits during the last day, so there are no\r\nvisits during which we buy only one figure.It is quite obvious that if\r\nwe want to visit the shop times, we always can do it during the last\r\ndays with . Let the last days with be (from right to left, so ). It is\r\nimpossible to get a total discount of more than if we visit the shop\r\nonly times, since when we visit the shop on day , the maximum discount\r\nwe can get during that day is .Now suppose we canât get the figures for\r\nfree, but we can get some other set of figures () for free. Letâs show\r\nthat this is impossible. Consider the first such that : if , it means\r\nthat on some suffix of days (from day to day ), we visit the shop times.\r\nBut since are the last days when we visit the shop, then we canât visit\r\nthe shop times from day to day , so this is impossible; otherwise, if ,\r\nit means that during the day , we get some figure for free, but it is\r\nnot . Letâs get the figure for free during that day instead (swap the\r\nfigures and ). Using a finite number of such transformations, we can\r\nshow that we can get the figures for free. Now, for a fixed value of ,\r\nwe know which figures we should get for free. And if we increase the\r\nvalue of , our total discount increases as well. Letâs find the greatest\r\npossible with binary search, and we will get a solution working in .The\r\nonly thing thatâs left is checking that some value of is achievable. To\r\ndo it, we can mark the figures we try to get for free, and simulate the\r\nprocess, iterating the figures from left to right. If on some prefix,\r\nthe number of figures we want to get for free is greater than the number\r\nof figures we pay for, then it is impossible, since we canât find a\r\n\"match\" for every figure we want to get for free.\r\n",
    "name": "C. Action Figures",
    "statement": "There is a shop that sells action figures near Monocarp’s house. A new\r\nset of action figures will be released shortly; this set contains n\r\nfigures, the i-th figure costs i coins and is available for purchase\r\nfrom day i to day n.For each of the n days, Monocarp knows whether he\r\ncan visit the shop.Every time Monocarp visits the shop, he can buy any\r\nnumber of action figures which are sold in the shop (of course, he\r\ncannot buy an action figure that is not yet available for purchase). If\r\nMonocarp buys figures during the same day, he gets a discount equal to\r\nthe cost of figure he buys (in other words, he gets the most expensive\r\nof the figures he buys for free). Monocarp wants to buy one 1-st figure,\r\none 2-nd figure, ..., one n-th figure from the set. He cannot buy the\r\nsame figure twice. What is the minimum amount of money he has to spend?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>using namespace std; using ll = int64_t; void solve(){\tint N;\tcin >> N;\tstring S;\tcin >> S;\tset<int> avail;\tfor(int i = 0; i < N; i++) avail.insert(i);\tll save = 0;\tint free = 0;\tfor(int i = N-1; i >= 0; i--){\t\tif(S[i] == '1'){\t\t\tif(avail.size() >= free + 2){\t\t\t\tint r = *avail.rbegin();\t\t\t\tavail.erase(prev(avail.end()));\t\t\t\tfree++;\t\t\t\tsave += (r+1);\t\t\t}\t\t}\t\tif(avail.count(i) && free > 0){\t\t\tfree--;\t\t}\t\tavail.erase(i);\t}\tll tot = ll(N) * ll(N + 1) / 2;\tcout << tot - save << '\\n';} int main(){\tios_base::sync_with_stdio(false), cin.tie(nullptr);\tint T;\tcin >> T;\twhile(T--) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Action Figures.json",
    "hint": []
}