{
    "link": "https://codeforces.com//contest/1661/problem/F",
    "problemId": "1361832",
    "problem_idx": "F",
    "shortId": "1661F",
    "contest_number": "1661",
    "problem_submissions": {
        "F": [
            153187553,
            153195355,
            153198079,
            153192699,
            153208735,
            153197140,
            153204834,
            153209679,
            153216895,
            153192345,
            153209985,
            153215287,
            153214260,
            153206784,
            153181924,
            153187391,
            153499691
        ],
        "E": [
            153181602,
            153183458,
            153186252,
            153186023,
            153206034,
            153195940,
            153194023,
            153206147,
            153218775,
            153197839,
            153195670,
            153202578,
            153201319,
            153198707,
            153201518,
            153192938,
            153189205,
            153195957,
            153196511
        ],
        "D": [
            153174390,
            153174537,
            153175638,
            153174007,
            153176690,
            153176745,
            153185907,
            153182627,
            153178744,
            153172686,
            153190154,
            153190396,
            153190106,
            153210872,
            153207891,
            153175462,
            153176825,
            153177570,
            153175676
        ],
        "C": [
            153170138,
            153167530,
            153168248,
            153169048,
            153170259,
            153170541,
            153168119,
            153170774,
            153172726,
            153194437,
            153178130,
            153175287,
            153185061,
            153205419,
            153246548,
            153215381,
            153166182,
            153169099,
            153168642,
            153167758
        ],
        "B": [
            153162156,
            153162580,
            153161952,
            153162200,
            153164678,
            153162918,
            153163800,
            153162935,
            153167883,
            153164440,
            153162927,
            153168126,
            153181318,
            153200885,
            153216655,
            153161628,
            153165270,
            153163647,
            153161926
        ],
        "A": [
            153160994,
            153160951,
            153163491,
            153160922,
            153160942,
            153161262,
            153161508,
            153160985,
            153162410,
            153161094,
            153160862,
            153162511,
            153178823,
            153198439,
            153217630,
            153160910,
            153162727,
            153160959,
            153160858
        ]
    },
    "name": "F. Teleporters",
    "statement": "There are n+1 teleporters on a straight line, located in points 0, a_1,\r\na_2, a_3, ..., a_n. It’s possible to teleport from point x to point y if\r\nthere are teleporters in of those points, and it costs (x-y)^2\r\nenergy.You want to install some additional teleporters so that it is\r\npossible to get from the point 0 to the point a_n (possibly through some\r\nother teleporters) spending than m energy in total. Each teleporter you\r\ninstall must be located in an .What is the minimum number of teleporters\r\nyou have to install?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 1000000000000000000;\nlong long cost(int d, int cnt){\n  int q = d / cnt;\n  int r = d % cnt;\n  return (long long) q * q * (cnt - r) + (long long) (q + 1) * (q + 1) * r;\n}\nint main(){\n  int n;\n  cin >> n;\n  vector<int> a(n + 1);\n  a[0] = 0;\n  for (int i = 1; i <= n; i++){\n    cin >> a[i];\n  }\n  long long m;\n  cin >> m;\n  long long tv = 1, fv = INF;\n  while (fv - tv > 1){\n    long long mid = (tv + fv) / 2;\n    long long sum = 0;\n    for (int i = 0; i < n; i++){\n      long long d = a[i + 1] - a[i];\n      int tv2 = 1, fv2 = d + 1;\n      while (fv2 - tv2 > 1){\n        int mid2 = (tv2 + fv2) / 2;\n        long long x1 = cost(d, mid2 - 1);\n        long long x2 = cost(d, mid2);\n        if (x1 - x2 >= mid){\n          tv2 = mid2;\n        } else {\n          fv2 = mid2;\n        }\n      }\n      sum += cost(d, tv2);\n    }\n    if (sum <= m){\n      tv = mid;\n    } else {\n      fv = mid;\n    }\n  }\n  long long ans = 0;\n  long long sum = 0;\n  for (int i = 0; i < n; i++){\n    long long d = a[i + 1] - a[i];\n    int tv2 = 1, fv2 = d + 1;\n    while (fv2 - tv2 > 1){\n      int mid2 = (tv2 + fv2) / 2;\n      long long x1 = cost(d, mid2 - 1);\n      long long x2 = cost(d, mid2);\n      if (x1 - x2 > tv){\n        tv2 = mid2;\n      } else {\n        fv2 = mid2;\n      }\n    }\n    ans += tv2 - 1;\n    sum += cost(d, tv2);\n  }\n  ans += (sum - m + tv - 1) / tv;\n  cout << ans << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Teleporters.json",
    "editorial_link": "https://codeforces.com//blog/entry/101790",
    "editorial": "Initial portals divide the path from to into separate sections. If we\r\nplace a new portal between two given ones, it only affects the section\r\nbetween these two portals.Letâs suppose we want to place new portals\r\ninto a section of length . This will divide it into sections, and itâs\r\nquite easy to prove that these sections should be roughly equal in size\r\n(to prove it, we can show that if the sizes of two sections differ by\r\nmore than , the longer one can be shortened and the shorter one can be\r\nelongated so the sum of squares of their lengths decreases). So, a\r\nsection of length should be divided into sections of length and sections\r\nof length . Letâs denote the total energy cost of a section of length\r\ndivided by new portals as ; since we divide it in roughly equal parts,\r\nitâs easy to see thatThe key observation that we need to make now is\r\nthat ; i. e. if we add more portals to the same section, the energy cost\r\nchange from adding a new portal doesnât go up. Unfortunately, we canât\r\ngive a simple, strict proof of this fact, but we have faith and stress\r\n(this would be easy to prove if it was possible to place portals in\r\nnon-integer points, we could just analyze the derivative, but in integer\r\ncase, itâs way more difficult).Okay, what should we do with the fact\r\nthat for a section of length ? The main idea of the solution is binary\r\nsearch over the value of ; i. e., we use binary search to find the\r\nminimum possible change that a new portal would give us. Letâs say that\r\nwe want to check that using the portals that give the cost change is\r\nenough; then, for each section, we want to find the number of new\r\nportals such that , but ; we can use another binary search to do that.\r\nFor a fixed integer , we can calculate not only the number of new\r\nportals that we can add if the cost change for each portal should be at\r\nleast , but also the total cost of the path after these changes; letâs\r\ndenote as the total cost of the path if we place new portals until the\r\ncost change is less than , and is the number of portals we will place in\r\nthat case.We have to find the minimum value of such that . Now, it looks\r\nlike is the answer, but this solution gives WA on one of the sample\r\ntests. The key observation we are missing is that, for the value , we\r\ndonât have to add all of the portals that change the answer by ; we\r\nmight need only some of them. To calculate the answer, letâs compute\r\nfour values: ; ; ; . If we place portals and add new portals one by one,\r\nuntil the total cost becomes not greater than , the cost change from\r\neach new portal will be equal to (or just if we consider the fact that\r\nwe start using the portals which change the cost by ). So, we can easily\r\ncalculate how many more additional portals we need to add if we start\r\nfrom portals and cost .The total complexity of our solution is : we have\r\na binary search over the cost change for each new portal; and for a\r\nfixed cost change, to determine the number of portals we place in each\r\nsection, we run another binary search in every section separately.\r\n",
    "hint": []
}