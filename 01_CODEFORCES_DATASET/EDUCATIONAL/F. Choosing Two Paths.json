{"link": "https://codeforces.com//contest/1073/problem/F", "problemId": "243301", "problem_idx": "F", "shortId": "1073F", "contest_number": "1073", "problem_submissions": {"G": [44873257, 44854949, 44872747, 44857777, 44904113, 44992378, 44992266, 44905426, 44884903, 44945894, 44917741], "F": [44867029, 44865010, 44864483, 44871287, 44872814, 44868847, 44879071, 44874774, 44882300, 44882274, 44882259, 44904164, 45084744, 45695799, 44888299], "E": [44859477, 44871290, 44861403, 44863217, 44864294, 44859185, 44863995, 44861353, 44862909, 44862761, 44864156, 44861997, 44866321, 44865560, 44864610, 44864622, 44866506, 44866536, 44864718, 44867428], "D": [44857129, 44872779, 44856075, 44857988, 44858337, 44861164, 44866799, 44854399, 44858649, 44887677, 44857825, 44863255, 44857894, 44856716, 44859464, 44857349, 44858547, 44860520, 44859062, 44858058], "C": [44852935, 44867793, 44850047, 44853493, 44853830, 44872109, 44870370, 44851223, 44852821, 44887759, 44853381, 44855264, 44855099, 44853761, 44855656, 44859785, 44852765, 44856270, 44855283, 44855046], "B": [44847780, 44861886, 44847247, 44849026, 44846682, 44849066, 44868560, 44847702, 44847526, 44848456, 44847355, 44849516, 44847583, 44849338, 44847283, 44847620, 44847641, 44850429, 44848272], "A": [44846309, 44861253, 44846364, 44847286, 44846147, 44847332, 44867659, 44846213, 44846204, 44846510, 44846224, 44846724, 44846207, 44847114, 44846296, 44846271, 44846181, 44848595, 44846401]}, "name": "F. Choosing Two Paths", "statement": "You are given an undirected unweighted tree consisting of n vertices.An\r\nundirected tree is a connected undirected graph with n - 1 edges.Your\r\ntask is to choose two pairs of vertices of this tree (all the chosen\r\nvertices ) (x_1, y_1) and (x_2, y_2) in such a way that neither x_1 nor\r\ny_1 belong to the simple path from x_2 to y_2 and vice versa (neither\r\nx_2 nor y_2 should not belong to the simple path from x_1 to y_1).Among\r\nall possible ways to choose such pairs you have to choose one with the\r\nbetween paths from x_1 to y_1 and from x_2 to y_2. And among all such\r\npairs you have to choose one with the of these two paths.The length of\r\nthe path is the number of edges in it.The simple path is the path that\r\nvisits each vertex at most once.\r\n", "solutions": ["#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <tuple>\n\nusing namespace std;\n\nconst int N = 200000;\nint n;\nvector<int> g[N];\nint par[N];\nint cnt[N];\nbool lit[N];\nint dist[N];\nvector<pair<int, int>> box[N];\n\nint ansl;\nint ansu;\nint ansv;\n\nvoid dfs(int u, int p) {\n  par[u] = p;\n  for (int v : g[u]) if (v != p) {\n    cnt[u]++;\n    dfs(v, u);\n  }\n}\n\nvoid dfs2(int u, int p) {\n  for (int v : g[u]) if (v != p && !lit[v]) {\n    dist[v] = dist[u] + 1;\n    dfs2(v, u);\n  }\n}\n\nvoid dfs3(int u, int p, int d) {\n  if (d == 0) {\n    int l = box[u][0].first + box[u][1].first;\n    if (ansl < l) {\n      ansl = l;\n      ansu = box[u][0].second;\n      ansv = box[u][1].second;\n    }\n    return;\n  }\n  for (int v : g[u]) if (v != p && !lit[v]) {\n    dfs3(v, u, d - 1);\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; i++) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    u--;\n    v--;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  int r = 0;\n  for (int i = 0; i < n; i++) {\n    if (g[i].size() >= 3) {\n      r = i;\n    }\n  }\n  dfs(r, -1);\n  for (int i = 0; i < n; i++) {\n    if (cnt[i] == 0) {\n      lit[i] = true;\n      int k = par[i];\n      int len = 1;\n      while (cnt[k] == 1) {\n        len++;\n        lit[k] = true;\n        k = par[k];\n      }\n      box[k].emplace_back(len, i);\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    sort(box[i].rbegin(), box[i].rend());\n  }\n  dfs2(r, -1);\n  int u = max_element(dist, dist + n) - dist;\n  dist[u] = 0;\n  dfs2(u, -1);\n  vector<int> du(dist, dist + n);\n  int v = max_element(dist, dist + n) - dist;\n  dist[v] = 0;\n  dfs2(v, -1);\n  vector<int> dv(dist, dist + n);\n\n  int D = dv[u];\n\n  int cu, cv;\n  for (int i = 0; i < n; i++) {\n    if (du[i] == D / 2 && dv[i] == (D + 1) / 2) {\n      cu = i;\n    }\n   if (du[i] == (D + 1) / 2 && dv[i] == D / 2) {\n      cv = i;\n    }\n  }\n  if (u == v) {\n    cerr << \"A\" << endl;\n    printf(\"%d %d\\n\", box[u][0].second + 1, box[u][1].second + 1);\n    printf(\"%d %d\\n\", box[u][2].second + 1, box[u][3].second + 1);\n  } else if (cu == cv) {\n    cerr << \"B\" << endl;\n    vector<tuple<int, int, int>> a;\n    for (int v : g[cu]) if (!lit[v]) {\n      ansl = 0;\n      dfs3(v, cu, D / 2 - 1);\n      if (ansl > 0) {\n        a.emplace_back(ansl, ansu, ansv);\n      }\n    }\n    sort(a.rbegin(), a.rend());\n    printf(\"%d %d\\n\", get<1>(a[0]) + 1, get<1>(a[1]) + 1);\n    printf(\"%d %d\\n\", get<2>(a[0]) + 1, get<2>(a[1]) + 1);\n  } else {\n    cerr << \"C\" << endl;\n    vector<tuple<int, int, int>> a;\n    {\n      ansl = 0;\n      dfs3(cu, cv, (D - 1) / 2);\n      a.emplace_back(ansl, ansu, ansv);\n    }\n    {\n      ansl = 0;\n      dfs3(cv, cu, (D - 1) / 2);\n      a.emplace_back(ansl, ansu, ansv);\n    }\n    sort(a.rbegin(), a.rend());\n    printf(\"%d %d\\n\", get<1>(a[0]) + 1, get<1>(a[1]) + 1);\n    printf(\"%d %d\\n\", get<2>(a[0]) + 1, get<2>(a[1]) + 1);\n  }\n}\n\n"], "input": "", "output": "", "tags": ["dfs and similar", "dp", "greedy", "trees"], "dificulty": "2500", "interactive": false}