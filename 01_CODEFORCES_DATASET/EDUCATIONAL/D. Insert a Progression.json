{
    "link": "https://codeforces.com//contest/1671/problem/D",
    "problemId": "1376218",
    "problem_idx": "D",
    "shortId": "1671D",
    "contest_number": "1671",
    "problem_submissions": {
        "F": [
            154542143,
            154558308,
            154555068,
            154557074,
            154562560,
            154560412,
            154560334,
            154580455,
            154580066,
            154579893,
            154579534,
            154559391,
            154560455,
            154556037,
            154570936,
            154568652,
            154567294,
            154570123,
            154570095,
            154571694,
            154567547,
            154573773,
            154574629
        ],
        "E": [
            154528618,
            154523246,
            154538308,
            154531841,
            154536634,
            154537536,
            154534868,
            154536863,
            154540214,
            154537733,
            154537068,
            154539560,
            154544853,
            154541083,
            154543961,
            154546659,
            154540036,
            154543052
        ],
        "D": [
            154515283,
            154518590,
            154521489,
            154520458,
            154521403,
            154524920,
            154528513,
            154532728,
            154525208,
            154525643,
            154525793,
            154526566,
            154525948,
            154532548,
            154534260,
            154534156,
            154549567,
            154532508
        ],
        "C": [
            154510946,
            154513613,
            154516509,
            154516298,
            154514632,
            154518397,
            154518432,
            154511688,
            154514098,
            154517459,
            154516109,
            154520271,
            154520298,
            154520714,
            154518755,
            154518674,
            154516230,
            154526116
        ],
        "B": [
            154508972,
            154509429,
            154511794,
            154511150,
            154510866,
            154511702,
            154510603,
            154509631,
            154511147,
            154510842,
            154511266,
            154514390,
            154513321,
            154513559,
            154512703,
            154511916,
            154511617,
            154520025
        ],
        "A": [
            154508532,
            154508535,
            154508654,
            154509163,
            154508619,
            154508583,
            154508765,
            154508590,
            154508804,
            154509162,
            154508941,
            154509310,
            154508759,
            154508605,
            154508711,
            154508600,
            154508845,
            154516250
        ]
    },
    "name": "D. Insert a Progression",
    "statement": "You are given a sequence of n integers a_1, a_2,\r\ndots, a_n. You are also given x integers 1, 2,\r\ndots, x.You are asked to insert each of the extra integers into the\r\nsequence a. Each integer can be inserted at the beginning of the\r\nsequence, at the end of the sequence, or between any elements of the\r\nsequence.The score of the resulting sequence a\u2019 is the sum of absolute\r\ndifferences of adjacent elements in it\r\nleft(\r\nsum\r\nlimits_{i=1}^{n+x-1} |a\u2019_i - a\u2019_{i+1}|\r\nright).What is the smallest possible score of the resulting sequence a\u2019?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 22.04.2022 18:41:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, x;\n    cin >> n >> x;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    long long ans = 0;\n    for (int i = 0; i < n - 1; i++) {\n      ans += abs(a[i] - a[i + 1]);\n    }\n    {\n      int mn = (int) 1e9;\n      mn = min(mn, a[0] - 1);\n      mn = min(mn, a[n - 1] - 1);\n      for (int i = 0; i < n; i++) {\n        mn = min(mn, 2 * (a[i] - 1));\n      }\n      ans += mn;\n    }\n    int mx = *max_element(a.begin(), a.end());\n    if (mx < x) {\n      int mn = (int) 1e9;\n      mn = min(mn, x - a[0]);\n      mn = min(mn, x - a[n - 1]);\n      for (int i = 0; i < n; i++) {\n        mn = min(mn, 2 * (x - a[i]));\n      }\n      ans += mn;\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Insert a Progression.json",
    "editorial_link": "https://codeforces.com//blog/entry/102181",
    "editorial": "Observe the cost of inserting a single element. Notice that inserting\r\nany value between the minimum of the sequence and the maximum of the\r\nsequence is free.Why is this true? The argument is similar to the\r\nalgorithm of finding some such that for a continous function if you know\r\nsome such that and such that .As a more general idea, it\u00e2\u0080\u0099s free to\r\ninsert some value into a segment such that and (WLOG assume ). Let\u00e2\u0080\u0099s\r\nfind the position that is free. If , then you can insert between and ,\r\nsince it\u00e2\u0080\u0099s free. Otherwise, you can choose an arbitrary position . will\r\nbe either between and or between and (or both of them). Descend into the\r\none that holds to continue the search. Since the lenght decreases, at\r\nsome point you will reach the segment of length .How does that help?\r\nWell, you can insert somewhere, then insert somewhere. The rest of\r\ninsertions will be free.Now it\u00e2\u0080\u0099s an algorithmic problem. First, consider\r\nall options to insert both and between the same pair of elements. Next,\r\nassume you insert somewhere before . Iterate from left to right,\r\nmaintaning the lowest price to insert . Try to insert at the current\r\nposition and into the cheapest position before it. Then update the\r\nlowest price for inserting . After you finish, reverse the sequence and\r\nsolve the problem again that will be the same as inserting before\r\n.Overall complexity: per testcase.\r\n"
}