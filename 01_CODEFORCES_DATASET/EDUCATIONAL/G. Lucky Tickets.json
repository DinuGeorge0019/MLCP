{"link": "https://codeforces.com//contest/1096/problem/G", "problemId": "275414", "problem_idx": "G", "shortId": "1096G", "contest_number": "1096", "problem_submissions": {"E": [47642254, 47649536, 47653679, 47648526, 47652142, 47650532, 47647313, 47647929, 47648225, 47694278, 47661678, 47661672, 47660722, 47660711, 47660680, 47660618, 47660582, 47660120, 47656494, 47655953, 47657647, 47817653, 47648933, 47665496, 47659752], "F": [47639264, 47644997, 47642974, 47644488, 47645071, 47645827, 47642225, 47651889, 47635316, 47632710, 47640155, 47703351, 47703260, 47636058, 47646007, 47639902, 47642860, 47639982, 47644292, 47643281, 47642796], "G": [47638289, 47637580, 47634875, 47638768, 47640048, 47642247, 47630999, 47650309, 47660389, 47657262, 47654048, 47629119, 47636649, 47642830, 47708729, 47708522, 47703016, 47700940, 47672367, 47656352, 47640712, 47641093, 47648435, 47638969, 47687049, 47686924, 47686825, 47646867, 47636051, 47647716], "D": [47635471, 47633956, 47638959, 47636889, 47629667, 47638623, 47639300, 47633153, 47649242, 47638629, 47633639, 47630356, 47634376, 47631648, 47636547, 47634092, 47638812, 72047403, 47632964, 47638521], "C": [47633317, 47631680, 47629418, 47632179, 47634755, 47633350, 47643997, 47635493, 47651183, 47635153, 47632143, 47638363, 47631171, 47629984, 47635983, 47631947, 47634094, 47646109, 47636660], "B": [47631281, 47629817, 47632624, 47628290, 47637243, 47631678, 47637542, 47630349, 47652229, 47629170, 47629856, 47637300, 47629416, 47628505, 47627019, 47628065, 47630666, 94912172, 47637515, 47631993], "A": [47628887, 47626041, 47629759, 47624992, 47630193, 47627541, 47635962, 47626700, 47652441, 47625024, 47625341, 47625412, 47625492, 47624882, 47624919, 47624912, 47627405, 47625425, 47625087]}, "name": "G. Lucky Tickets", "statement": "All bus tickets in Berland have their numbers. A number consists of n\r\ndigits (n is even). Only k decimal digits d_1, d_2,\r\ndots, d_k can be used to form ticket numbers. If 0 is among these\r\ndigits, then numbers may have leading zeroes. For example, if n = 4 and\r\nonly digits 0 and 4 can be used, then 0000, 4004, 4440 are valid ticket\r\nnumbers, and 0002, 00, 44443 are not.A ticket is lucky if the sum of\r\nfirst n / 2 digits is equal to the sum of remaining n / 2 digits.\r\nCalculate the number of different lucky tickets in Berland. Since the\r\nanswer may be big, print it modulo 998244353.\r\n", "solutions": ["#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#define MAXN 100005\n#define INF 1000000000\n#define MOD 998244353\n#define F first\n#define S second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint n,k;\nconst double PI=acos(-1.0);\nnamespace fft\n{\n    struct num\n    {\n        double x,y;\n        num() {x=y=0;}\n        num(double x,double y):x(x),y(y){}\n    };\n    inline num operator+(num a,num b) {return num(a.x+b.x,a.y+b.y);}\n    inline num operator-(num a,num b) {return num(a.x-b.x,a.y-b.y);}\n    inline num operator*(num a,num b) {return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\n    inline num conj(num a) {return num(a.x,-a.y);}\n\n    int base=1;\n    vector<num> roots={{0,0},{1,0}};\n    vector<int> rev={0,1};\n    const double PI=acosl(-1.0);\n\n    void ensure_base(int nbase)\n    {\n        if(nbase<=base) return;\n        rev.resize(1<<nbase);\n        for(int i=0;i<(1<<nbase);i++)\n            rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));\n        roots.resize(1<<nbase);\n        while(base<nbase)\n        {\n            double angle=2*PI/(1<<(base+1));\n            for(int i=1<<(base-1);i<(1<<base);i++)\n            {\n                roots[i<<1]=roots[i];\n                double angle_i=angle*(2*i+1-(1<<base));\n                roots[(i<<1)+1]=num(cos(angle_i),sin(angle_i));\n            }\n            base++;\n        }\n    }\n\n    void fft(vector<num> &a,int n=-1)\n    {\n        if(n==-1) n=a.size();\n        assert((n&(n-1))==0);\n        int zeros=__builtin_ctz(n);\n        ensure_base(zeros);\n        int shift=base-zeros;\n        for(int i=0;i<n;i++)\n            if(i<(rev[i]>>shift))\n                swap(a[i],a[rev[i]>>shift]);\n        for(int k=1;k<n;k<<=1)\n        {\n            for(int i=0;i<n;i+=2*k)\n            {\n                for(int j=0;j<k;j++)\n                {\n                    num z=a[i+j+k]*roots[j+k];\n                    a[i+j+k]=a[i+j]-z;\n                    a[i+j]=a[i+j]+z;\n                }\n            }\n        }\n    }\n\n    vector<num> fa,fb;\n    \n    vector<int> multiply(vector<int> &a, vector<int> &b)\n    {\n        int need=a.size()+b.size()-1;\n        int nbase=0;\n        while((1<<nbase)<need) nbase++;\n        ensure_base(nbase);\n        int sz=1<<nbase;\n        if(sz>(int)fa.size()) fa.resize(sz);\n        for(int i=0;i<sz;i++)\n        {\n            int x=(i<(int)a.size()?a[i]:0);\n            int y=(i<(int)b.size()?b[i]:0);\n            fa[i]=num(x,y);\n        }\n        fft(fa,sz);\n        num r(0,-0.25/sz);\n        for(int i=0;i<=(sz>>1);i++)\n        {\n            int j=(sz-i)&(sz-1);\n            num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;\n            if(i!=j) fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;\n            fa[i]=z;\n        }\n        fft(fa,sz);\n        vector<int> res(need);\n        for(int i=0;i<need;i++) res[i]=fa[i].x+0.5;\n        return res;\n    }\n\n    vector<int> multiply_mod(vector<int> &a,vector<int> &b,int m,int eq=0)\n    {\n        int need=a.size()+b.size()-1;\n        int nbase=0;\n        while((1<<nbase)<need) nbase++;\n        ensure_base(nbase);\n        int sz=1<<nbase;\n        if(sz>(int)fa.size()) fa.resize(sz);\n        for(int i=0;i<(int)a.size();i++)\n        {\n            int x=(a[i]%m+m)%m;\n            fa[i]=num(x&((1<<15)-1),x>>15);\n        }\n        fill(fa.begin()+a.size(),fa.begin()+sz,num{0,0});\n        fft(fa,sz);\n        if(sz>(int)fb.size()) fb.resize(sz);\n        if(eq) copy(fa.begin(),fa.begin()+sz,fb.begin());\n        else\n        {\n            for(int i=0;i<(int)b.size();i++)\n            {\n                int x=(b[i]%m+m)%m;\n                fb[i]=num(x&((1<<15)-1),x>>15);\n            }\n            fill(fb.begin()+b.size(),fb.begin()+sz,num{0,0});\n            fft(fb,sz);\n        }\n        double ratio=0.25/sz;\n        num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);\n        for(int i=0;i<=(sz>>1);i++)\n        {\n            int j=(sz-i)&(sz-1);\n            num a1=(fa[i]+conj(fa[j]));\n            num a2=(fa[i]-conj(fa[j]))*r2;\n            num b1=(fb[i]+conj(fb[j]))*r3;\n            num b2=(fb[i]-conj(fb[j]))*r4;\n            if(i!=j)\n            {\n                num c1=(fa[j]+conj(fa[i]));\n                num c2=(fa[j]-conj(fa[i]))*r2;\n                num d1=(fb[j]+conj(fb[i]))*r3;\n                num d2=(fb[j]-conj(fb[i]))*r4;\n                fa[i]=c1*d1+c2*d2*r5;\n                fb[i]=c1*d2+c2*d1;\n            }\n            fa[j]=a1*b1+a2*b2*r5;\n            fb[j]=a1*b2+a2*b1;\n        }\n        fft(fa,sz);fft(fb,sz);\n        vector<int> res(need);\n        for(int i=0;i<need;i++)\n        {\n            ll aa=fa[i].x+0.5;\n            ll bb=fb[i].x+0.5;\n            ll cc=fa[i].y+0.5;\n            res[i]=(aa+((bb%m)<<15)+((cc%m)<<30))%m;\n        }\n        return res;\n    }\n    vector<int> square_mod(vector<int> &a,int m)\n    {\n        return multiply_mod(a,a,m,1);\n    }\n};\nvector<int> v;\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    v.resize(10,0);\n    for(int i=0;i<k;i++)\n    {\n        int x;\n        scanf(\"%d\",&x);\n        v[x]=1;\n    }\n    vector<int> ans;\n    ans.push_back(1);\n    int p=n/2;\n    while(p)\n    {\n        if(p&1) ans=fft::multiply_mod(ans,v,MOD);\n        v=fft::square_mod(v,MOD);\n        p>>=1;\n    }\n    int res=0;\n    for(auto t:ans) res=(res+1LL*t*t)%MOD;\n    printf(\"%d\\n\",res);\n    return 0;\n}\n\n"], "input": "", "output": "", "tags": ["divide and conquer", "dp", "fft"], "dificulty": "2400", "interactive": false}