{
    "link": "https://codeforces.com//contest/1476/problem/F",
    "problemId": "881707",
    "problem_idx": "F",
    "shortId": "1476F",
    "contest_number": "1476",
    "problem_submissions": {
        "G": [
            105913861,
            105944560,
            105939646,
            105923864,
            105934727,
            105937410,
            105935084
        ],
        "E": [
            105882617,
            105882778,
            105909929,
            105895535,
            105907314,
            105884522,
            105881576,
            105889515,
            105891029,
            105897702,
            105902043,
            105904102,
            105909138,
            105899391,
            105895913,
            105970659,
            105900322,
            105895017,
            105909435,
            105904890
        ],
        "D": [
            105872560,
            105872434,
            105872750,
            105874690,
            105888665,
            105869131,
            105875044,
            105876453,
            105878527,
            105868738,
            105873785,
            105878660,
            105867024,
            105887668,
            105877564,
            105874050,
            105886943,
            105878950,
            105887180
        ],
        "C": [
            105865233,
            105867141,
            105882799,
            105868688,
            105880463,
            105863560,
            105866932,
            105868909,
            105872012,
            105880982,
            105868535,
            105869296,
            105877911,
            105869813,
            105870709,
            105864538,
            105872343,
            105869274,
            105872286
        ],
        "B": [
            105854579,
            105853524,
            105854032,
            105858231,
            105859227,
            105853292,
            105853315,
            105856769,
            105859608,
            105859912,
            105854635,
            105856976,
            105853309,
            105859505,
            105858926,
            105855562,
            105860530,
            105853840,
            105860836
        ],
        "A": [
            105850622,
            105850650,
            105852722,
            105850820,
            105851490,
            105850582,
            105850685,
            105850741,
            105851248,
            105853267,
            105850773,
            105851638,
            105850636,
            105851230,
            105852640,
            105850665,
            105852244,
            105850634,
            105851161
        ],
        "F": [
            131696052,
            106171367
        ]
    },
    "name": "F. Lanterns",
    "statement": "There are n lanterns in a row. The lantern i is placed in position i and\r\nhas power equal to p_i.Each lantern can be directed to illuminate either\r\nsome lanterns to the left or some lanterns to the right. If the i-th\r\nlantern is turned to the left, it illuminates all such lanterns j that j\r\nin [i - p_i, i - 1]. Similarly, if it is turned to the right, it\r\nilluminates all such lanterns j that j\r\nin [i + 1, i + p_i].Your goal is to choose a direction for each lantern\r\nso each lantern is illuminated by at least one other lantern, or report\r\nthat it is impossible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep1(i, n) for (int i = 1; i < (n); ++i)\n#define rep1n(i, n) for (int i = 1; i <= (n); ++i)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define sz(a) (int)(a.size())\n#define each(x, a) for (auto &x : a)\n#define ar array\n#define vec vector\n#define f0r(a, b) for (int i = (a); i < (b); ++i)\n#define range(i, n) rep(i, n)\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing str = string;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\n\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vpi = vector<pair<int, int>>;\nusing vvi = vector<vi>;\n\nint Bit(int mask, int b) { return (mask >> b) & 1; }\n\ntemplate<class T>\nbool ckmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool ckmax(T &a, const T &b) {\n    if (b > a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T, class Fun = function<T(const T &, const T &)>>\nstruct SparseTable {\n    vector<vector<T>> sp;\n    Fun f;\n\n    SparseTable(vector<T> &a, const Fun &g) : f(g) {\n        int n = a.size();\n        int lg = __lg(n) + 1;\n        sp.resize(lg, vector<T>(n));\n        rep(i, n) sp[0][i] = a[i];\n        rep(j, lg - 1) {\n            rep(i, n) {\n                if (i + (1 << (j + 1)) > n) break;\n                sp[j + 1][i] = f(sp[j][i], sp[j][i + (1 << j)]);\n            }\n        }\n    }\n\n    // [l, r)\n    T get(int l, int r) {\n        int k = __lg(r - l);\n        return f(sp[k][l], sp[k][r - (1 << k)]);\n    }\n};\n\nvoid solve() {\n    int n;\n    cin >> n;\n    vi p(n);\n    rep(i, n) cin >> p[i];\n    vector<int> a(n);\n    rep(i, n) a[i] = p[i] + i;\n    SparseTable st(a, [&](const int &x, const int &y) { return max(x, y); });\n    //\n    vi dp(n + 1, -2);\n    vi pr(n + 1, -2);\n    vi tt(n + 1, -1);\n    dp[0] = -1;\n    rep(i, n) {\n        int value = dp[i];\n        if (i && p[i] && value + 1 >= i - p[i]) {\n            // to_left\n            int l;\n            {\n                int L = max(0, i - p[i]) - 2;\n                int R = i - 1;\n                if (L == -2) R = -1;\n                while (R - L > 1) {\n                    int mid = (L + R) / 2;\n                    if (dp[mid] + 1 >= i - p[i]) {\n                        R = mid;\n                    } else {\n                        L = mid;\n                    }\n                }\n                l = R + 1;\n            }\n            int r = i;\n            int mx;\n            if (l < r) {\n                mx = st.get(l, r);\n            } else {\n                mx = i - 1;\n            }\n            if (dp[i] < mx) {\n                dp[i] = mx;\n                pr[i] = 0;\n                tt[i] = l;\n            }\n        }\n        if (value >= i) {\n            if (dp[i] < i + p[i]) {\n                dp[i] = i + p[i];\n                pr[i] = 1;\n            }\n        }\n        dp[i + 1] = dp[i];\n        pr[i + 1] = 2;\n    }\n    if (dp[n] < n - 1) {\n        cout << \"NO\\n\";\n        return;\n    }\n    int f = n - 1;\n    str result;\n    while (f >= 0) {\n        if (pr[f] != 0) {\n            result += 'R';\n            f--;\n            continue;\n        }\n        result += 'L';\n        int to = tt[f];\n        f--;\n        while (f >= to) {\n            result += 'R';\n            f--;\n        }\n    }\n    cout << \"YES\\n\";\n    reverse(all(result));\n    cout << result << \"\\n\";\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    // cout << setprecision(20 - 7) << fixed;\n    int t = 1;\n    cin >> t;\n    range(i, t) {\n        solve();\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Lanterns.json",
    "editorial_link": "https://codeforces.com//blog/entry/87356",
    "editorial": "The main idea of the solution is to calculate the following dynamic\r\nprogramming: is the maximum prefix we can fully cover with first\r\nlanterns.Letâs look at how can we solve it in with this kind of dynamic\r\nprogramming. First of all, letâs write it forward. Which transitions\r\nfrom do we have? iterate on the lantern facing left that will cover the\r\nlantern . Let this lantern be . It should cover all lanterns in , so all\r\nlanterns from can be turned to the right (and we need a max query to\r\ndetermine the new covered prefix); if (lantern is already covered), we\r\ncan just extend the prefix by turning the -th lantern to the right. Note\r\nthat turning it to the right when it is not covered yet will be modeled\r\nby the first transition. It is obviously , how can we optimize it? Letâs\r\nwrite this dynamic programming backward. The second transition is\r\nchanged to backward dp easily, what about the first one? Suppose we want\r\nto turn some lantern to the left. Letâs iterate on the prefix that we\r\nwill \"connect\" to it; for this prefix, should be at least , and we\r\nupdate with the maximum of (since it is covered by lantern ) and the\r\nresult of max query on .In fact, we need only one such prefix the one\r\nwith the minimum among those which have . So, we build a minimum segment\r\ntree where each pair is interpreted as the value of in position , and\r\nwith min query on the suffix from we find this optimal prefix, from\r\nwhich we should update (and to update, we can use any DS that allows max\r\nqueries on segment in my solution, itâs another segment tree).\r\n",
    "hint": []
}