{
    "link": "https://codeforces.com//contest/837/problem/F",
    "problemId": "116712",
    "problem_idx": "F",
    "shortId": "837F",
    "contest_number": "837",
    "problem_submissions": {
        "G": [
            29167867,
            29168921,
            29171657,
            29211841,
            29211768,
            29194112,
            29194042,
            29194028,
            29175447,
            29168227,
            29172693,
            29172204,
            29166926,
            29165613,
            29171547,
            29173009,
            29190922,
            32561173,
            29172886,
            29172783,
            29172758,
            29172505,
            29172166
        ],
        "F": [
            29165055,
            29166362,
            29168864,
            29166638,
            29169357,
            29169429,
            29164558,
            29186836,
            29168655,
            29167876,
            29169339,
            29172957,
            29171060,
            29171284,
            29168929,
            29172401,
            29169905,
            29168071,
            29172819
        ],
        "E": [
            29162020,
            29163186,
            29165795,
            29163264,
            29164907,
            29165095,
            29162428,
            29167933,
            29164726,
            29164807,
            29166669,
            29167308,
            29166973,
            29172476,
            29166198,
            29169034,
            29165312,
            29163338,
            29169750
        ],
        "D": [
            29161276,
            29162239,
            29163430,
            29162397,
            29162640,
            29163863,
            29160761,
            29163799,
            29174585,
            29164816,
            29165533,
            29164344,
            29163361,
            29163790,
            29167229,
            30486037,
            29175514,
            29161500,
            29167261
        ],
        "C": [
            29160368,
            29160646,
            29161707,
            29160573,
            29161464,
            29161685,
            29160675,
            29160760,
            29162171,
            29161153,
            29162346,
            29163214,
            29163154,
            29161641,
            29165376,
            29161315,
            29160556,
            29163716
        ],
        "B": [
            29159633,
            29159893,
            29160590,
            29159654,
            29160221,
            29159770,
            29161534,
            29161149,
            29160418,
            29160903,
            29161228,
            29162604,
            29271569,
            29164321,
            29195260,
            29160168,
            29175059,
            29162325
        ],
        "A": [
            29158816,
            29158847,
            29159160,
            29160665,
            29159109,
            29158852,
            29159205,
            29159017,
            29158817,
            29158878,
            29159185,
            29161667,
            29158818,
            29158815,
            29159058,
            29159399
        ]
    },
    "name": "F. Prefix Sums",
    "statement": "Consider the function , where is an array of integers, which returns an\r\narray consisting of integers such that is equal to the sum of first\r\nelements of array ().You have an infinite sequence of arrays , where is\r\ngiven in the input, and for each . Also you have a positive integer .\r\nYou have to find minimum possible such that contains a number which is\r\nlarger or equal than .\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:1048576\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 3234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nll mymul(ll a, ll b) {\n\tif (a == 0 || b == 0) return 0;\n\tif (LL_INF / b < a) return LL_INF;\n\treturn min(LL_INF, a*b);\n}\n\nll C1[1050][1050];\nll C2[2200050][11];\nll C(ll a, ll b) {\n\tif (a <= 1000) return C1[a][b];\n\t\n\tif (b >= a / 2) b = a - b;\n\n\tif (b == 0) return 1;\n\tif (b == 1) return a;\n\tif (b == 2) return mymul(a, a - 1) / 2;\n\tif (a >= 2200000) return LL_INF;\n\tif (b <= 10) return C2[a][b];\n\telse return LL_INF;\n}\n\nll in[200050];\nint main() {\n\tint i, j;\n\tfor (i = 0; i <= 1000; i++) {\n\t\tC1[i][0] = C1[i][i] = 1;\n\t\tfor (j = 1; j < i; j++) C1[i][j] = min(C1[i - 1][j] + C1[i - 1][j - 1], LL_INF);\n\t}\n\tfor (i = 0; i <= 2200000; i++) {\n\t\tC2[i][0] = 1;\n\t\tif (i <= 10) C2[i][i] = 1;\n\t\tfor (j = 1; j < i && j <= 10; j++) C2[i][j] = min(C2[i - 1][j] + C2[i - 1][j - 1], LL_INF);\n\t}\n\n\tint N;\n\tll K;\n\tscanf(\"%d %lld\", &N, &K);\n\tint st = N;\n\tfor (i = 1; i <= N; i++) {\n\t\tscanf(\"%lld\", &in[i]);\n\t\tif (in[i] >= K) return !printf(\"0\\n\");\n\t\tif (in[i]) st = min(st, i);\n\t}\n\t\n\tll s = 1, e = LL_INF, m, r = LL_INF + 1;\n\tif (st < N - 2) e = 2000000;\n\n\twhile (s <= e) {\n\t\tm = (s + e) / 2;\n\n\t\tll v = 0;\n\t\tfor (i = 1; i <= N; i++) v = min(LL_INF, v + mymul(C(N - i + m - 1, m - 1), in[i]));\n\t\tif (v >= K) {\n\t\t\tr = m;\n\t\t\te = m - 1;\n\t\t}\n\t\telse s = m + 1;\n\t}\n\treturn !printf(\"%lld\\n\", r);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "combinatorics",
        "math",
        "matrices"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Prefix Sums.json",
    "editorial_link": "https://codeforces.com//blog/entry/53662",
    "editorial": "Letâs delete all zeroes from the beginning of the array; they wonât\r\naffect the answer. Also we will return an array of elements when\r\ncalculating prefix sums (sum of zero elements becomes a zero in the\r\nbeginning of the array, and so has to be removed).If the size of array\r\nis at least , then we will get after calculating only a few prefix sums,\r\nso we can use simple iteration. So now we have to obtain the solution in\r\ncase array has less than elements.If we remove zeroes from the beginning\r\nof each array, then , where is a matrix , if , otherwise . Then we can\r\nuse matrix exponentiation to check whether contains a number which is\r\nequal to or greater than , and we can use binary search to find the\r\nanswer. To avoid overflows, each time we get a number greater than , we\r\ncan set it to .\r\n",
    "hint": []
}