{
    "link": "https://codeforces.com//contest/1796/problem/E",
    "problemId": "1802549",
    "problem_idx": "E",
    "shortId": "1796E",
    "contest_number": "1796",
    "problem_submissions": {
        "F": [
            195363403,
            195358131,
            195479952,
            195352672,
            197311670,
            196155422,
            195754330
        ],
        "E": [
            195322604,
            195319205,
            195326482,
            195321452,
            195327641,
            195860691,
            195453420,
            195453193,
            195322745,
            195328001,
            195331101,
            195332636,
            195326730,
            195325672,
            195330089,
            195730772,
            195730423,
            195326388,
            195341037,
            195326008,
            195331716,
            195328756,
            195331573,
            195338613,
            195329663
        ],
        "D": [
            195301353,
            195304722,
            195305253,
            195303622,
            195309683,
            195303260,
            195314948,
            195309431,
            195312674,
            195316263,
            195314478,
            195311060,
            195310198,
            195308650,
            195308315,
            195293456,
            195319263,
            195305260,
            195544976,
            195315681
        ],
        "C": [
            195293384,
            195295362,
            195292646,
            195293592,
            195298098,
            195294172,
            195296742,
            195299256,
            195301143,
            195303080,
            195303361,
            195304837,
            195724689,
            195723906,
            195300890,
            195288215,
            195295041,
            195302705,
            195306906,
            195294076,
            195307764
        ],
        "B": [
            195288248,
            195289700,
            195287789,
            195287682,
            195290336,
            195286518,
            195290220,
            195290123,
            195290068,
            195287181,
            195292039,
            195293913,
            195289326,
            195284427,
            195288804,
            195305536,
            195289798,
            195287403,
            195298773
        ],
        "A": [
            195283882,
            195284135,
            195283927,
            195289942,
            195285318,
            195283838,
            195283735,
            195283820,
            195283931,
            195283631,
            195283664,
            195285369,
            195285859,
            195283473,
            195283857,
            195283713,
            195284138,
            195283860,
            195284027
        ]
    },
    "name": "E. Colored Subgraphs",
    "statement": "Monocarp has a tree, consisting of n vertices.He is going to select some\r\nvertex r and perform the following operations on each vertex v from 1 to\r\nn: set d_v equal to the distance from v to r (the number of edges on the\r\nshortest path); color v some color. A coloring satisfies two conditions:\r\nfor each pair of vertices of the same color (v, u), there exists a path\r\nfrom v to u that only visits vertices of the same color; for each pair\r\nof vertices of the same color (v, u), d_v\r\nneq d_u. Note that Monocarp can choose any amount of different colors he\r\nwants to use.For each used color, he then counts the number of vertices\r\nof this color. The of the tree is the minimum of these numbers.What can\r\nbe the maximum cost of the tree?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define mod 998244353\n#define int long long\nusing namespace std;\nvector<int> e[200005];\nint f[200005],FA[200005];\nmultiset<int> S,sf[200005];\nint ans;\nvoid mv(int u,int v)\n{\n\tif(f[u]==f[v]+1)\n\t{\n\t\tif(sf[u].size()>1)\n\t\t{\n\t\t\tf[u]=(*++sf[u].begin())+1;\n\t\t\tS.erase(S.find(f[u]-1));\n\t\t}\n\t\telse f[u]=1;\n\t}\n\telse S.erase(S.find(f[v]));\n\tsf[u].erase(sf[u].find(f[v]));\n\tFA[u]=v,FA[v]=0;\n\tsf[v].insert(f[u]);\n\tif(*sf[v].begin()==f[u])\n\t{\n\t\tif(sf[v].size()>1)\n\t\t\tS.insert(*++sf[v].begin());\n\t}\n\telse S.insert(f[u]);\n\tf[v]=(*sf[v].begin())+1;\n}\nvoid dfs2(int u,int fa)\n{\n\tif(S.size()) ans=max(ans,min(f[u],*S.begin()));\n\telse ans=max(ans,f[u]);\n\tfor(auto v:e[u])\n\t{\n\t\tif(v==fa) continue;\n\t\tmv(u,v),dfs2(v,u),mv(v,u);\n\t}\n}\nvoid dfs1(int u,int fa)\n{\n\tFA[u]=fa;\n\tvector<int> ss;\n\tfor(auto v:e[u])\n\t\tif(v!=fa) dfs1(v,u),ss.push_back(f[v]);\n\tsort(ss.begin(),ss.end());\n\tif(ss.size()) f[u]=ss[0]+1;\n\telse f[u]=1;\n\tfor(auto t:ss) sf[u].insert(t);\n\tfor(int i=1;i<ss.size();i++) S.insert(ss[i]);\n}\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tcin >> T;\n\twhile(T--)\n\t{\n\t\tS.clear();\n\t\tint n;\n\t\tcin >> n;\n\t\tfor(int i=0;i<=n;i++) e[i].clear(),sf[i].clear(),f[i]=0;\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tint u,v;\n\t\t\tcin >> u >> v;\n\t\t\te[u].push_back(v);\n\t\t\te[v].push_back(u);\n\t\t}\n\t\tans=0;\n\t\tdfs1(1,0);\n\t/*\tfor(int i=1;i<=n;i++) cout << f[i] << \" \";\n\t\tcout << \"\\n\";\n\t\tmv(1,2);\n\t\tfor(int i=1;i<=n;i++) cout << f[i] << \" \";\n\t\tcout << \"\\n\";*/\n\t\tdfs2(1,0);\n\t\tcout << ans << \"\\n\";\n\t}\n\treturn 0;\n}\n/*\n1\n4\n1 2\n2 3\n3 4\n*/"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "games",
        "greedy",
        "trees"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Colored Subgraphs.json",
    "editorial_link": "https://codeforces.com//blog/entry/113408",
    "editorial": "Letâs start by choosing a vertex naively. Iterate over all vertices and\r\ntry each of them.Root the tree by and observe what the conditions\r\nbecome. for each is just the depth of each vertex. Well, then the only\r\ncase, when the connected subgraph of vertices of the same color has all\r\nvalues of distinct, is when they form a vertical path in the tree.So the\r\nproblem becomes the following. Split the tree into some vertical paths\r\nin such a way that the shortest path is as long as possible.Letâs try\r\ngreedy, I guess. Start the paths from the leaves and propagate them up.\r\nConsider some vertex with at least two children. All children have some\r\npaths leading up to them. Weâd love to continue them all with , but we\r\ncanât do that. We can only continue one path and cut the rest. Pretty\r\neasy to see that the path to continue is the shortest path available.\r\nItâs at least as optimal as any other path.Do that from the lowest\r\nvertices up, and you got yourself a working greedy. Also donât forget to\r\nstop all paths in root, since you canât continue any of them further\r\nup.Letâs make this greedy more formal. Every time we update the answer\r\nis with a path that is: the shortest in every vertex lower than the\r\ncurrent one; not the shortest in the current one. So we want to\r\npropagate the shortest child up and update the answer with the remaining\r\nchildren. Updating the answer means just taking the minimum of values.\r\nThus, we can actually ignore all children except the second shortest in\r\neach vertex. Just donât forget to treat the root properly.Now we can\r\nactually solve the problem in for a fixed . You can just find two\r\nminimums in each vertex. Well, now that we can solve the problem for a\r\nsingle root, letâs try rerooting to solve for all of them. There are\r\nsolutions in but I found the solution in the neatest. The constraints\r\nare low enough to allow it.For each vertex, maintain a multiset of\r\nlengths of vertical paths from its children. I chose to store nothing in\r\nthe leaves that only makes the implementation cleaner. In order to\r\nupdate the vertex from its child, you can take the minimum element in\r\nthe childâs set and add to it. If itâs empty (the child is a leaf),\r\nreturn .Additionally, store a multiset of the second minimums of all\r\nvertices that have at least two children.In order to update the answer\r\nwith the current root, find the minimum of that multiset and the\r\nshortest path from the root.To achieve , you will probably have to\r\neither store prefix and suffix second minimums over children of each\r\nvertex or store three shortest paths in it. It is kind of messy but it\r\nshould still perform better.Overall complexity: or per testcase.\r\n",
    "hint": []
}