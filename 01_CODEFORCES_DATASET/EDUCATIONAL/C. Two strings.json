{
    "link": "https://codeforces.com//contest/762/problem/C",
    "problemId": "90124",
    "problem_idx": "C",
    "shortId": "762C",
    "contest_number": "762",
    "problem_submissions": {
        "F": [
            24128800,
            24127287,
            24131448,
            24128833,
            24128590
        ],
        "E": [
            24122771,
            24123546,
            24117007,
            24124444,
            24127665,
            24127353,
            24122694,
            24124867,
            24128194,
            24130174,
            24129986,
            24129967,
            24127255,
            24123944,
            24123747,
            24128463,
            24126253,
            24117536,
            24126607
        ],
        "D": [
            24120216,
            24117937,
            24120594,
            24123699,
            24120899,
            24122923,
            24125654,
            24122077,
            24124440,
            24123437,
            24124479,
            24129845,
            64773611,
            24129570,
            24127415,
            24125478,
            24129569,
            24125183,
            24124387,
            24117686
        ],
        "C": [
            24117649,
            24115665,
            24118684,
            24120038,
            24118048,
            24119412,
            24117040,
            24153774,
            24117580,
            24118699,
            24120548,
            24119249,
            24120443,
            24120966,
            24122719,
            24122392,
            24134825,
            24118679
        ],
        "B": [
            24115242,
            24114275,
            24114874,
            24121323,
            24115338,
            24115218,
            24114366,
            24115078,
            24114616,
            24115065,
            24117965,
            24115815,
            24115613,
            24116743,
            24116439,
            24116970,
            24124581,
            24115154,
            24114842
        ],
        "A": [
            24113787,
            24113769,
            24113819,
            24114373,
            24113802,
            24113840,
            24113765,
            24113864,
            24113822,
            24115779,
            24114962,
            24114446,
            24113882,
            24114350,
            24114566,
            24114001,
            24114912,
            24113931,
            24113786
        ]
    },
    "name": "C. Two strings",
    "statement": "You are given two strings and . You have to remove the minimum possible\r\nnumber of (standing one after another) characters from string in such a\r\nway that it becomes a subsequence of string . It can happen that you\r\nwill not need to remove any characters at all, or maybe you will have to\r\nremove all of the characters from and make it empty.Subsequence of\r\nstring is any such string that can be obtained by erasing zero or more\r\ncharacters () from string .\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 202020\nvoid build(){\n\n}\nchar a[ N ] , b[ N ];\nint la , lb;\nvoid init(){\n  scanf( \"%s\" , a + 1 );\n  la = strlen( a + 1 );\n  scanf( \"%s\" , b + 1 );\n  lb = strlen( b + 1 );\n}\nint ndl[ N ] , ndr[ N ];\nvoid solve(){\n  int ptr = 1;\n  for( int i = 1 ; i <= lb ; i ++ ){\n    while( ptr <= la && a[ ptr ] != b[ i ] ) ptr ++;\n    ndl[ i ] = ptr;\n    if( ptr <= la ) ptr ++;\n  }\n  ptr = la;\n  for( int i = lb ; i >= 1 ; i -- ){\n    while( ptr > 0 && a[ ptr ] != b[ i ] ) ptr --;\n    ndr[ i ] = ptr;\n    if( ptr > 0 ) ptr --;\n  }\n  int ans = N , al = -1 , ar = -1;\n  for( int i = 1 ; i <= lb ; i ++ ){\n    if( ndl[ i ] <= la ){\n      if( lb - i < ans ){\n        ans = lb - i;\n        al = i; ar = lb + 1;\n      }\n    }\n    if( ndr[ i ] > 0 ){\n      if( i - 1 < ans ){\n        ans = i - 1;\n        al = 0; ar = i;\n      }\n    }\n  }\n  for( int pl = 0 , pr = 1 ; pr <= lb ; pr ++ ){\n    if( ndr[ pr ] == 0 ) continue;\n    while( pl + 1 < pr && ndl[ pl + 1 ] < ndr[ pr ] ) pl ++;\n    int bye = pr - pl - 1;\n    if( bye < ans ){\n      ans = bye;\n      al = pl; ar = pr;\n    }\n  }\n  if( ans == N )\n    puts( \"-\" );\n  else{\n    for( int i = 1 ; i <= al ; i ++ ) putchar( b[ i ] );\n    for( int i = ar ; i <= lb ; i ++ ) putchar( b[ i ] );\n    puts( \"\" );\n  }\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "hashing",
        "strings",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Two strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/50010",
    "editorial": "Try thinking not about erasing a substring from B, but rather picking some number of characters (possibly zero) from the left, and some from the right.\n\n???????\nTwo pointers\n\n???????\nFor every prefix of B, count how big of a prefix of A you will require. Call these values p[i]. Put infinity in the cells where even whole A is not enough.\n\nSame for every suffix of B count the length of the required suffix of A. Call these values s[i].\n\nNow try increasing the length of prefix of B, while decreasing the length of the suffix until p[pref_len] + s[suf_len] is less or equal to the length of A.",
    "hint": []
}