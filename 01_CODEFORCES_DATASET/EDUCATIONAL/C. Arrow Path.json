{
    "link": "https://codeforces.com//contest/1948/problem/C",
    "problemId": "2532315",
    "problem_idx": "C",
    "shortId": "1948C",
    "contest_number": "1948",
    "problem_submissions": {
        "G": [
            251472376,
            251497915,
            251480984,
            251480163,
            251489959,
            251467292,
            251485648,
            251500573,
            251486197,
            251512722,
            251521639,
            251480657,
            251509802,
            251528428,
            251520218,
            251515719,
            251959006,
            251871508,
            251537711,
            251535946,
            251529016,
            251516034,
            251533510,
            251533892
        ],
        "E": [
            251455000,
            251464649,
            251452268,
            251480095,
            251460808,
            251464897,
            251506007,
            251480198,
            251478117,
            251501414,
            251479798,
            251486494,
            251498878,
            251484347,
            251486715,
            251474115,
            251485874,
            251484195,
            251499420
        ],
        "F": [
            251446403,
            251454570,
            251464038,
            251471618,
            251471081,
            251484983,
            251475462,
            251495125,
            251493237,
            251458734,
            251522756,
            251503819,
            251513774,
            251502504,
            251506031,
            251513492,
            251502955,
            251521827,
            251479729
        ],
        "D": [
            251428147,
            251500203,
            251431497,
            251439266,
            251434727,
            251440547,
            251446816,
            251446867,
            251456743,
            251442045,
            251470051,
            251447446,
            251460726,
            251467120,
            251467499,
            251465257,
            251451922,
            251465519,
            251467189,
            251458845
        ],
        "C": [
            251425049,
            251426495,
            251431074,
            251427750,
            251427491,
            251433261,
            251437529,
            251439503,
            251431968,
            251453203,
            251439755,
            251452383,
            251446018,
            251457382,
            251439370,
            251471934,
            251459502,
            251461525,
            251447180
        ],
        "B": [
            251421706,
            251420680,
            251422950,
            251421537,
            251420205,
            251424082,
            251426365,
            251440040,
            251423639,
            251430207,
            251430125,
            251435004,
            251430108,
            251439531,
            251427186,
            251441008,
            251448490,
            251446251,
            251436268
        ],
        "A": [
            251419288,
            251417353,
            251417664,
            251417432,
            251417471,
            251418376,
            251419094,
            251418141,
            251417555,
            251419693,
            251424986,
            251423459,
            251419168,
            251420360,
            251418645,
            251426543,
            251449327,
            251430256,
            251427243
        ]
    },
    "name": "C. Arrow Path",
    "statement": "There is a grid, consisting of 2 rows and n columns. The rows are\r\nnumbered from 1 to 2 from top to bottom. The columns are numbered from 1\r\nto n from left to right. Each cell of the grid contains an arrow\r\npointing either to the left or to the right. No arrow points outside the\r\ngrid.There is a robot that starts in a cell (1, 1). Every second, the\r\nfollowing two actions happen one after another: Firstly, the robot moves\r\nleft, right, down or up (); then it moves along the arrow that is placed\r\nin the current cell (the cell it ends up after its move). Your task is\r\nto determine whether the robot can reach the cell (2, n).\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 15.03.2024 10:35:58\n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<string> s(2);\n    cin >> s[0] >> s[1];\n    vector<vector<int>> was(2, vector<int>(n, 0));\n    was[0][0] = 1;\n    vector<pair<int, int>> que;\n    que.emplace_back(0, 0);\n    for (int it = 0; it < int(que.size()); it++) {\n      auto [i, j] = que[it];\n      for (int di = -1; di <= 1; di++) {\n        for (int dj = -1; dj <= 1; dj++) {\n          if (di * di + dj * dj == 1) {\n            int ni = i + di;\n            int nj = j + dj;\n            if (ni >= 0 && nj >= 0 && ni < 2 && nj < n) {\n              nj += (s[ni][nj] == '<' ? -1 : 1);\n              if (!was[ni][nj]) {\n                que.emplace_back(ni, nj);\n                was[ni][nj] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    cout << (was[1][n - 1] ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "dp",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Arrow Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/127182",
    "editorial": "There are multiple different approaches to this problem. We will\r\ndescribe a couple of them.The key observation for this problem that\r\nworks for all these approaches is that, since we never skip a move and\r\nnever try to move outside the grid, we can split the cells into two\r\ngroups: if the sum of coordinates of the cell is even (we will call it\r\n\"even cell\"), we can end up in such a cell only after moving along the\r\narrow (only after the second action during each second); otherwise, if\r\nthe sum of coordinates of the cell is odd (we will call it \"odd cell\"),\r\nwe can end up in such a cell only after making a move on our own (only\r\nafter the first action during each second). Each movement leads us from\r\none of these groups to the other group, that\u00e2\u0080\u0099s why we always visit even\r\ncells after the second action and odd cells after the first action\r\nduring each second.. Create a graph where each cell is represented by a\r\nvertex; if this is an even cell, then the robot can choose any direction\r\nfrom it, so we add directed arcs from it into all adjacent cells. If\r\nthis is an odd cell, then the robot will be forced to move along the\r\narrow in that cell, so we add only one directed arc from the\r\ncorresponding vertex. Then we check if the vertex representing (2, n) is\r\nreachable from the vertex representing (1, 1) via DFS or BFS.. We can\r\ntry searching for a pattern that \"blocks\" our robot, i. e. does not let\r\nit advance further. If there are two adjacent by angle cells, which both\r\nhave arrows leading to the left, then every path of the robot will pass\r\nthrough at least one of them; and every time it goes through one of\r\nthem, it will be forced to the left. So any pair of odd -type cells\r\nwhich share an angle (i. e. are on the same diagonal) means that the\r\nanswer is . Otherwise, we can show that the answer is yes; the proof is\r\nbased on the fact that for every even cell, either the cell in the same\r\ncolumn or the cell to the right will contain an arrow leading to the\r\nright, so we can always go forward.\r\n"
}