{"link": "https://codeforces.com//contest/1902/problem/C", "problemId": "2362200", "problem_idx": "C", "shortId": "1902C", "contest_number": "1902", "problem_submissions": {"B": [235588094, 235541813, 235538695, 235540200, 235541986, 235546581, 235539624, 235542221, 235543196, 235570763, 235543003, 235539161, 235543236, 235569611, 235570026, 235542153, 235655407, 235543168, 235545066, 235549273, 235544565, 235544393], "D": [235587336, 235552561, 235553295, 235563680, 235553330, 235555395, 235568492, 235559700, 235568658, 235567617, 235560146, 235561416, 235554309, 235551620, 235562986, 235561764, 235586816, 235566705, 235566898, 235564749, 235564461], "E": [235583583, 235582606, 235582050, 235581289, 235558586, 235559098, 235551541, 235558190, 235559848, 235566108, 235566192, 235566094, 235564789, 235564113, 235549751, 235553064, 235566369, 235568437, 235561807, 235546129, 235601857, 235573551, 235578412, 235572635, 235576054, 235577219, 235558759], "F": [235562465, 235568838, 236129130, 236129102, 235556472, 235565709, 235569182, 235561417, 235572126, 235555263, 235543234, 235574528, 235579496, 235582447, 235591540, 235554289, 235597722, 235587185, 235557652, 235580838, 235744278, 235581308, 235591762, 235592390], "C": [235547363, 235542973, 235546654, 235544681, 235542274, 235544554, 235550388, 235549932, 235558653, 235546403, 235544913, 235545913, 235542697, 235566604, 235546411, 235656040, 235549867, 235560184, 235557908, 235596779, 235549641, 235614612, 235549186], "A": [235534144, 235534113, 235534651, 235534058, 235534240, 235534127, 235534119, 235534985, 235553076, 235538076, 235534100, 235534474, 235534171, 235570865, 235534497, 235654959, 235535402, 235534132, 235535287, 235538251, 235534330]}, "name": "C. Insert and Equalize", "statement": "You are given an integer array a_1, a_2,\r\ndots, a_n, all its elements are distinct.First, you are asked to insert\r\none more integer a_{n+1} into this array. a_{n+1} should not be equal to\r\nany of a_1, a_2,\r\ndots, a_n.Then, you will have to make all elements of the array equal.\r\nAt the start, you choose a integer x (x > 0). In one operation, you add\r\nx to exactly one element of the array. .What\u2019s the smallest number of\r\noperations it can take you to make all elements equal, after you choose\r\na_{n+1} and x?\r\n", "solutions": ["#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <forward_list>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <optional>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\nusing lint = long long;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(nullptr), ios::sync_with_stdio(false), cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate <typename T> bool chmax(T &m, const T q) { return m < q ? (m = q, true) : false; }\ntemplate <typename T> bool chmin(T &m, const T q) { return m > q ? (m = q, true) : false; }\nconst std::vector<std::pair<int, int>> grid_dxs{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\nint floor_lg(long long x) { return x <= 0 ? -1 : 63 - __builtin_clzll(x); }\ntemplate <class T1, class T2> T1 floor_div(T1 num, T2 den) { return (num > 0 ? num / den : -((-num + den - 1) / den)); }\ntemplate <class T1, class T2> std::pair<T1, T2> operator+(const std::pair<T1, T2> &l, const std::pair<T1, T2> &r) { return std::make_pair(l.first + r.first, l.second + r.second); }\ntemplate <class T1, class T2> std::pair<T1, T2> operator-(const std::pair<T1, T2> &l, const std::pair<T1, T2> &r) { return std::make_pair(l.first - r.first, l.second - r.second); }\ntemplate <class T> std::vector<T> sort_unique(std::vector<T> vec) { sort(vec.begin(), vec.end()), vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec; }\ntemplate <class T> int arglb(const std::vector<T> &v, const T &x) { return std::distance(v.begin(), std::lower_bound(v.begin(), v.end(), x)); }\ntemplate <class T> int argub(const std::vector<T> &v, const T &x) { return std::distance(v.begin(), std::upper_bound(v.begin(), v.end(), x)); }\ntemplate <class IStream, class T> IStream &operator>>(IStream &is, std::vector<T> &vec) { for (auto &v : vec) is >> v; return is; }\n\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::vector<T> &vec);\ntemplate <class OStream, class T, size_t sz> OStream &operator<<(OStream &os, const std::array<T, sz> &arr);\ntemplate <class OStream, class T, class TH> OStream &operator<<(OStream &os, const std::unordered_set<T, TH> &vec);\ntemplate <class OStream, class T, class U> OStream &operator<<(OStream &os, const pair<T, U> &pa);\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::deque<T> &vec);\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::set<T> &vec);\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::multiset<T> &vec);\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::unordered_multiset<T> &vec);\ntemplate <class OStream, class T, class U> OStream &operator<<(OStream &os, const std::pair<T, U> &pa);\ntemplate <class OStream, class TK, class TV> OStream &operator<<(OStream &os, const std::map<TK, TV> &mp);\ntemplate <class OStream, class TK, class TV, class TH> OStream &operator<<(OStream &os, const std::unordered_map<TK, TV, TH> &mp);\ntemplate <class OStream, class... T> OStream &operator<<(OStream &os, const std::tuple<T...> &tpl);\n\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::vector<T> &vec) { os << '['; for (auto v : vec) os << v << ','; os << ']'; return os; }\ntemplate <class OStream, class T, size_t sz> OStream &operator<<(OStream &os, const std::array<T, sz> &arr) { os << '['; for (auto v : arr) os << v << ','; os << ']'; return os; }\ntemplate <class... T> std::istream &operator>>(std::istream &is, std::tuple<T...> &tpl) { std::apply([&is](auto &&... args) { ((is >> args), ...);}, tpl); return is; }\ntemplate <class OStream, class... T> OStream &operator<<(OStream &os, const std::tuple<T...> &tpl) { os << '('; std::apply([&os](auto &&... args) { ((os << args << ','), ...);}, tpl); return os << ')'; }\ntemplate <class OStream, class T, class TH> OStream &operator<<(OStream &os, const std::unordered_set<T, TH> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::deque<T> &vec) { os << \"deq[\"; for (auto v : vec) os << v << ','; os << ']'; return os; }\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::set<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <class OStream, class T> OStream &operator<<(OStream &os, const std::unordered_multiset<T> &vec) { os << '{'; for (auto v : vec) os << v << ','; os << '}'; return os; }\ntemplate <class OStream, class T, class U> OStream &operator<<(OStream &os, const std::pair<T, U> &pa) { return os << '(' << pa.first << ',' << pa.second << ')'; }\ntemplate <class OStream, class TK, class TV> OStream &operator<<(OStream &os, const std::map<TK, TV> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\ntemplate <class OStream, class TK, class TV, class TH> OStream &operator<<(OStream &os, const std::unordered_map<TK, TV, TH> &mp) { os << '{'; for (auto v : mp) os << v.first << \"=>\" << v.second << ','; os << '}'; return os; }\n#ifdef HITONANODE_LOCAL\nconst string COLOR_RESET = \"\\033[0m\", BRIGHT_GREEN = \"\\033[1;32m\", BRIGHT_RED = \"\\033[1;31m\", BRIGHT_CYAN = \"\\033[1;36m\", NORMAL_CROSSED = \"\\033[0;9;37m\", RED_BACKGROUND = \"\\033[1;41m\", NORMAL_FAINT = \"\\033[0;2m\";\n#define dbg(x) std::cerr << BRIGHT_CYAN << #x << COLOR_RESET << \" = \" << (x) << NORMAL_FAINT << \" (L\" << __LINE__ << \") \" << __FILE__ << COLOR_RESET << std::endl\n#define dbgif(cond, x) ((cond) ? std::cerr << BRIGHT_CYAN << #x << COLOR_RESET << \" = \" << (x) << NORMAL_FAINT << \" (L\" << __LINE__ << \") \" << __FILE__ << COLOR_RESET << std::endl : std::cerr)\n#else\n#define dbg(x) ((void)0)\n#define dbgif(cond, x) ((void)0)\n#endif\n\nlint solve() {\n    int N;\n    cin >> N;\n    vector<lint> A(N);\n    cin >> A;\n    dbg(A);\n    {\n        lint lo = *min_element(ALL(A));\n        for (auto &x : A) x -= lo;\n    }\n    if (N == 1) return 1;\n\n    sort(ALL(A));\n    int g = 0;\n    for (int a : A) g = std::gcd(g, abs(a - A.front()));\n    for (auto &x : A) x /= g;\n    dbg(A);\n\n    lint ans = 1LL << 60;\n\n    REP(_, 2) {\n\n        int mex = 0;\n        for (int a : A) {\n            if (a == mex) mex++;\n            else if (a > mex) break;\n        }\n\n        if (_ == 1) {\n            chmin(ans, accumulate(ALL(A), 0LL) + mex);\n            chmin(ans, accumulate(ALL(A), 0LL) + (lint)A.size());\n        }\n\n        lint hi = A.back();\n        for (auto &x : A) x = hi - x;\n        reverse(ALL(A));\n    }\n\n    return ans;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        cout << solve() << '\\n';\n        // cout << (solve() ? \"YES\" : \"NO\") << '\\n';\n    }\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "greedy", "math", "number theory"], "dificulty": "1300", "interactive": false}