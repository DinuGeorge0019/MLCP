{
    "link": "https://codeforces.com//contest/2004/problem/F",
    "problemId": "2817829",
    "problem_idx": "F",
    "shortId": "2004F",
    "contest_number": "2004",
    "problem_submissions": {
        "G": [
            276630607,
            276630835,
            276815301,
            276813223,
            276730941,
            276730940,
            276730938,
            276730196,
            276706226,
            276673537,
            276671208,
            276669707,
            276668079,
            276666673,
            276663824,
            276631973,
            276650398,
            276654199,
            276671978,
            276667171,
            276655191,
            276675324,
            276673836,
            276665927,
            276659967,
            276686801,
            276659848,
            276661339,
            276663400,
            276678317,
            276675734,
            276609503,
            276603609,
            276603860,
            276684871
        ],
        "F": [
            276600783,
            276603077,
            276690058,
            276689698,
            276688969,
            276684111,
            276683838,
            276611637,
            276612991,
            276625645,
            276618158,
            276605423,
            276629515,
            276618667,
            276611221,
            276649582,
            276637411,
            276625639,
            276636840,
            276618197,
            276636099,
            276599811,
            276607522
        ],
        "E": [
            276589802,
            276596867,
            276580257,
            276593952,
            276589935,
            276605205,
            276593092,
            276591124,
            276594409,
            276599244,
            276591466,
            276615953,
            276611658,
            276612000,
            276628960,
            276614801,
            276589234,
            276686929,
            276608676
        ],
        "D": [
            276578166,
            276582738,
            276570547,
            276586689,
            276576622,
            276593734,
            276592482,
            276576486,
            276578199,
            276577214,
            276576531,
            276589387,
            276598254,
            276598480,
            276637507,
            276646335,
            276573014,
            276574212
        ],
        "C": [
            276568096,
            276566732,
            276560637,
            276568151,
            276566161,
            276564826,
            276568270,
            276565609,
            276576360,
            276566803,
            276562944,
            276571325,
            276570770,
            276579007,
            276640458,
            276649705,
            276564151,
            276563159
        ],
        "B": [
            276564489,
            276561786,
            276554466,
            276562035,
            276558846,
            276558446,
            276562561,
            276560684,
            276559360,
            276563127,
            276557878,
            276566849,
            276563790,
            276573781,
            276643281,
            276652367,
            276559066,
            276557843
        ],
        "A": [
            276550095,
            276553218,
            276549966,
            276550401,
            276550699,
            276550217,
            276553657,
            276550131,
            276549961,
            276555386,
            276550038,
            276550361,
            276550391,
            276551777,
            276644857,
            276653734,
            276550010,
            276550451
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132790",
    "editorial": "To begin with, let\u00e2\u0080\u0099s find out how to solve the problem for a single\r\nsubarray in linear time.If equal numbers are at both ends, we can remove\r\nthem and reduce the problem to a smaller size (thus, we have decreased\r\nthe length of the array by in operations, or by if there is only one\r\nelement). Otherwise, we have to do something with one of these numbers:\r\neither merge the smaller one with its neighbor or split the larger one.\r\nIt can be shown that it doesn\u00e2\u0080\u0099t matter which of these actions we take,\r\nso let\u00e2\u0080\u0099s split the larger of the two numbers at the ends in such a way\r\nthat the numbers at the ends become equal, and then we can remove the\r\nequal numbers at the ends (thus, we reduce the length of the array by in\r\noperation). In this case, the answer for the array depends on the number\r\nof situations where the ends of the array have equal numbers and the\r\nnumber of situations where they are different.Now let\u00e2\u0080\u0099s understand how\r\nto quickly calculate how many times, when processing a subarray, we\r\nencounter a situation where the ends have equal numbers. After removing\r\nthese equal numbers at the ends, we obtain a subarray such that numbers\r\nwith equal sums have been removed from the prefix and suffix compared to\r\nthe original subarray.We can determine how many such subarrays can be\r\nobtained from the original one by removing a prefix and a suffix with\r\nequal sums. For this, we can use prefix sums. Let the prefix sum at the\r\nbeginning of the segment be , and at the end be . If we remove a prefix\r\nand a suffix with sum , the sums become and . At the same time, the sum\r\nfor the smaller subarray remains the same. Therefore, for each such\r\nsubarray that results from the situation \"the elements on the right and\r\nleft were equal, we removed them\" the sum is the same as that of the\r\noriginal segment.To calculate the number of shorter segments with the\r\nsame sum for each segment, we can iterate through all segments in order\r\nof increasing length and store in a map the count of subarrays with each\r\nsum . This leads us to solve the problem in .\r\n",
    "name": "F. Make a Palindrome",
    "statement": "You are given an array a consisting of n integers.Let the function f(b)\r\nreturn the minimum number of operations needed to make an array b a\r\npalindrome. The operations you can make are: choose two adjacent\r\nelements b_i and b_{i+1}, remove them, and replace them with a single\r\nelement equal to (b_i + b_{i + 1}); or choose an element b_i > 1, remove\r\nit, and replace it with two positive integers x and y (x > 0 and y > 0)\r\nsuch that x + y = b_i. For example, from an array b=[2, 1, 3], you can\r\nobtain the following arrays in one operation: [1, 1, 1, 3], [2, 1, 1,\r\n2], [3, 3], [2, 4], or [2, 1, 2, 1].Calculate\r\ndisplaystyle\r\nleft(\r\nsum_{1\r\nle l\r\nle r\r\nle n}{f(a[l..r])}\r\nright), where a[l..r] is the subarray of a from index l to index r,\r\ninclusive. In other words, find the sum of the values of the function f\r\nfor all subarrays of the array a.\r\n",
    "solutions": [
        "#line 1 \"library/my_template.hpp\"#if defined(LOCAL)#include <my_template_compiled.hpp>#else\u00a0// https://mirror.codeforces.com/blog/entry/96344#pragma GCC optimize(\"Ofast,unroll-loops\")// \u3044\u307e\u306e CF \u3060\u3068\u3053\u308c\u5165\u308c\u308b\u3068\u52d5\u304b\u306a\u3044\uff1f// #pragma GCC target(\"avx2,popcnt\")\u00a0#include <bits/stdc++.h>\u00a0using namespace std;\u00a0using ll = long long;using u32 = unsigned int;using u64 = unsigned long long;using i128 = __int128;using u128 = unsigned __int128;using f128 = __float128;\u00a0template <class T>constexpr T infty = 0;template <>constexpr int infty<int> = 1'010'000'000;template <>constexpr ll infty<ll> = 2'020'000'000'000'000'000;template <>constexpr u32 infty<u32> = infty<int>;template <>constexpr u64 infty<u64> = infty<ll>;template <>constexpr i128 infty<i128> = i128(infty<ll>) * 2'000'000'000'000'000'000;template <>constexpr double infty<double> = infty<ll>;template <>constexpr long double infty<long double> = infty<ll>;\u00a0using pi = pair<ll, ll>;using vi = vector<ll>;template <class T>using vc = vector<T>;template <class T>using vvc = vector<vc<T>>;template <class T>using vvvc = vector<vvc<T>>;template <class T>using vvvvc = vector<vvvc<T>>;template <class T>using vvvvvc = vector<vvvvc<T>>;template <class T>using pq = priority_queue<T>;template <class T>using pqg = priority_queue<T, vector<T>, greater<T>>;\u00a0#define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))#define vvvv(type, name, a, b, c, ...) \\  vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__))))\u00a0// https://trap.jp/post/1224/#define FOR1(a) for (ll _ = 0; _ < ll(a); ++_)#define FOR2(i, a) for (ll i = 0; i < ll(a); ++i)#define FOR3(i, a, b) for (ll i = a; i < ll(b); ++i)#define FOR4(i, a, b, c) for (ll i = a; i < ll(b); i += (c))#define FOR1_R(a) for (ll i = (a)-1; i >= ll(0); --i)#define FOR2_R(i, a) for (ll i = (a)-1; i >= ll(0); --i)#define FOR3_R(i, a, b) for (ll i = (b)-1; i >= ll(a); --i)#define overload4(a, b, c, d, e, ...) e#define overload3(a, b, c, d, ...) d#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)#define FOR_R(...) overload3(__VA_ARGS__, FOR3_R, FOR2_R, FOR1_R)(__VA_ARGS__)\u00a0#define FOR_subset(t, s) for (ll t = (s); t >= 0; t = (t == 0 ? -1 : (t - 1) & (s)))#define all(x) x.begin(), x.end()#define len(x) ll(x.size())#define elif else if\u00a0#define eb emplace_back#define mp make_pair#define mt make_tuple#define fi first#define se second\u00a0#define stoi stoll\u00a0int popcnt(int x) { return __builtin_popcount(x); }int popcnt(u32 x) { return __builtin_popcount(x); }int popcnt(ll x) { return __builtin_popcountll(x); }int popcnt(u64 x) { return __builtin_popcountll(x); }int popcnt_mod_2(int x) { return __builtin_parity(x); }int popcnt_mod_2(u32 x) { return __builtin_parity(x); }int popcnt_mod_2(ll x) { return __builtin_parityll(x); }int popcnt_mod_2(u64 x) { return __builtin_parityll(x); }// (0, 1, 2, 3, 4) -> (-1, 0, 1, 1, 2)int topbit(int x) { return (x == 0 ? -1 : 31 - __builtin_clz(x)); }int topbit(u32 x) { return (x == 0 ? -1 : 31 - __builtin_clz(x)); }int topbit(ll x) { return (x == 0 ? -1 : 63 - __builtin_clzll(x)); }int topbit(u64 x) { return (x == 0 ? -1 : 63 - __builtin_clzll(x)); }// (0, 1, 2, 3, 4) -> (-1, 0, 1, 0, 2)int lowbit(int x) { return (x == 0 ? -1 : __builtin_ctz(x)); }int lowbit(u32 x) { return (x == 0 ? -1 : __builtin_ctz(x)); }int lowbit(ll x) { return (x == 0 ? -1 : __builtin_ctzll(x)); }int lowbit(u64 x) { return (x == 0 ? -1 : __builtin_ctzll(x)); }\u00a0template <typename T>T floor(T a, T b) {  return a / b - (a % b && (a ^ b) < 0);}template <typename T>T ceil(T x, T y) {  return floor(x + y - 1, y);}template <typename T>T bmod(T x, T y) {  return x - y * floor(x, y);}template <typename T>pair<T, T> divmod(T x, T y) {  T q = floor(x, y);  return {q, x - q * y};}\u00a0template <typename T, typename U>T SUM(const vector<U> &A) {  T sm = 0;  for (auto &&a: A) sm += a;  return sm;}\u00a0#define MIN(v) *min_element(all(v))#define MAX(v) *max_element(all(v))#define LB(c, x) distance((c).begin(), lower_bound(all(c), (x)))#define UB(c, x) distance((c).begin(), upper_bound(all(c), (x)))#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end()), x.shrink_to_fit()\u00a0template <typename T>T POP(deque<T> &que) {  T a = que.front();  que.pop_front();  return a;}template <typename T>T POP(pq<T> &que) {  T a = que.top();  que.pop();  return a;}template <typename T>T POP(pqg<T> &que) {  T a = que.top();  que.pop();  return a;}template <typename T>T POP(vc<T> &que) {  T a = que.back();  que.pop_back();  return a;}\u00a0template <typename F>ll binary_search(F check, ll ok, ll ng, bool check_ok = true) {  if (check_ok) assert(check(ok));  while (abs(ok - ng) > 1) {    auto x = (ng + ok) / 2;    (check(x) ? ok : ng) = x;  }  return ok;}template <typename F>double binary_search_real(F check, double ok, double ng, int iter = 100) {  FOR(iter) {    double x = (ok + ng) / 2;    (check(x) ? ok : ng) = x;  }  return (ok + ng) / 2;}\u00a0template <class T, class S>inline bool chmax(T &a, const S &b) {  return (a < b ? a = b, 1 : 0);}template <class T, class S>inline bool chmin(T &a, const S &b) {  return (a > b ? a = b, 1 : 0);}\u00a0// ? \u306f -1vc<int> s_to_vi(const string &S, char first_char) {  vc<int> A(S.size());  FOR(i, S.size()) { A[i] = (S[i] != '?' ? S[i] - first_char : -1); }  return A;}\u00a0template <typename T, typename U>vector<T> cumsum(vector<U> &A, int off = 1) {  int N = A.size();  vector<T> B(N + 1);  FOR(i, N) { B[i + 1] = B[i] + A[i]; }  if (off == 0) B.erase(B.begin());  return B;}\u00a0// stable sorttemplate <typename T>vector<int> argsort(const vector<T> &A) {  vector<int> ids(len(A));  iota(all(ids), 0);  sort(all(ids), [&](int i, int j) { return (A[i] == A[j] ? i < j : A[i] < A[j]); });  return ids;}\u00a0// A[I[0]], A[I[1]], ...template <typename T>vc<T> rearrange(const vc<T> &A, const vc<int> &I) {  vc<T> B(len(I));  FOR(i, len(I)) B[i] = A[I[i]];  return B;}\u00a0template <typename T, typename... Vectors>void concat(vc<T> &first, const Vectors &... others) {  vc<T> &res = first;  (res.insert(res.end(), others.begin(), others.end()), ...);}#endif#line 1 \"library/other/io.hpp\"#define FASTIO#include <unistd.h>\u00a0// https://judge.yosupo.jp/submission/21623namespace fastio {static constexpr uint32_t SZ = 1 << 17;char ibuf[SZ];char obuf[SZ];char out[100];// pointer of ibuf, obufuint32_t pil = 0, pir = 0, por = 0;\u00a0struct Pre {  char num[10000][4];  constexpr Pre() : num() {    for (int i = 0; i < 10000; i++) {      int n = i;      for (int j = 3; j >= 0; j--) {        num[i][j] = n % 10 | '0';        n /= 10;      }    }  }} constexpr pre;\u00a0inline void load() {  memcpy(ibuf, ibuf + pil, pir - pil);  pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);  pil = 0;  if (pir < SZ) ibuf[pir++] = '\\n';}\u00a0inline void flush() {  fwrite(obuf, 1, por, stdout);  por = 0;}\u00a0void rd(char &c) {  do {    if (pil + 1 > pir) load();    c = ibuf[pil++];  } while (isspace(c));}\u00a0void rd(string &x) {  x.clear();  char c;  do {    if (pil + 1 > pir) load();    c = ibuf[pil++];  } while (isspace(c));  do {    x += c;    if (pil == pir) load();    c = ibuf[pil++];  } while (!isspace(c));}\u00a0template <typename T>void rd_real(T &x) {  string s;  rd(s);  x = stod(s);}\u00a0template <typename T>void rd_integer(T &x) {  if (pil + 100 > pir) load();  char c;  do    c = ibuf[pil++];  while (c < '-');  bool minus = 0;  if constexpr (is_signed<T>::value || is_same_v<T, i128>) {    if (c == '-') { minus = 1, c = ibuf[pil++]; }  }  x = 0;  while ('0' <= c) { x = x * 10 + (c & 15), c = ibuf[pil++]; }  if constexpr (is_signed<T>::value || is_same_v<T, i128>) {    if (minus) x = -x;  }}\u00a0void rd(int &x) { rd_integer(x); }void rd(ll &x) { rd_integer(x); }void rd(i128 &x) { rd_integer(x); }void rd(u32 &x) { rd_integer(x); }void rd(u64 &x) { rd_integer(x); }void rd(u128 &x) { rd_integer(x); }void rd(double &x) { rd_real(x); }void rd(long double &x) { rd_real(x); }void rd(f128 &x) { rd_real(x); }\u00a0template <class T, class U>void rd(pair<T, U> &p) {  return rd(p.first), rd(p.second);}template <size_t N = 0, typename T>void rd_tuple(T &t) {  if constexpr (N < std::tuple_size<T>::value) {    auto &x = std::get<N>(t);    rd(x);    rd_tuple<N + 1>(t);  }}template <class... T>void rd(tuple<T...> &tpl) {  rd_tuple(tpl);}\u00a0template <size_t N = 0, typename T>void rd(array<T, N> &x) {  for (auto &d: x) rd(d);}template <class T>void rd(vc<T> &x) {  for (auto &d: x) rd(d);}\u00a0void read() {}template <class H, class... T>void read(H &h, T &... t) {  rd(h), read(t...);}\u00a0void wt(const char c) {  if (por == SZ) flush();  obuf[por++] = c;}void wt(const string s) {  for (char c: s) wt(c);}void wt(const char *s) {  size_t len = strlen(s);  for (size_t i = 0; i < len; i++) wt(s[i]);}\u00a0template <typename T>void wt_integer(T x) {  if (por > SZ - 100) flush();  if (x < 0) { obuf[por++] = '-', x = -x; }  int outi;  for (outi = 96; x >= 10000; outi -= 4) {    memcpy(out + outi, pre.num[x % 10000], 4);    x /= 10000;  }  if (x >= 1000) {    memcpy(obuf + por, pre.num[x], 4);    por += 4;  } else if (x >= 100) {    memcpy(obuf + por, pre.num[x] + 1, 3);    por += 3;  } else if (x >= 10) {    int q = (x * 103) >> 10;    obuf[por] = q | '0';    obuf[por + 1] = (x - q * 10) | '0';    por += 2;  } else    obuf[por++] = x | '0';  memcpy(obuf + por, out + outi + 4, 96 - outi);  por += 96 - outi;}\u00a0template <typename T>void wt_real(T x) {  ostringstream oss;  oss << fixed << setprecision(15) << double(x);  string s = oss.str();  wt(s);}\u00a0void wt(int x) { wt_integer(x); }void wt(ll x) { wt_integer(x); }void wt(i128 x) { wt_integer(x); }void wt(u32 x) { wt_integer(x); }void wt(u64 x) { wt_integer(x); }void wt(u128 x) { wt_integer(x); }void wt(double x) { wt_real(x); }void wt(long double x) { wt_real(x); }void wt(f128 x) { wt_real(x); }\u00a0template <class T, class U>void wt(const pair<T, U> val) {  wt(val.first);  wt(' ');  wt(val.second);}template <size_t N = 0, typename T>void wt_tuple(const T t) {  if constexpr (N < std::tuple_size<T>::value) {    if constexpr (N > 0) { wt(' '); }    const auto x = std::get<N>(t);    wt(x);    wt_tuple<N + 1>(t);  }}template <class... T>void wt(tuple<T...> tpl) {  wt_tuple(tpl);}template <class T, size_t S>void wt(const array<T, S> val) {  auto n = val.size();  for (size_t i = 0; i < n; i++) {    if (i) wt(' ');    wt(val[i]);  }}template <class T>void wt(const vector<T> val) {  auto n = val.size();  for (size_t i = 0; i < n; i++) {    if (i) wt(' ');    wt(val[i]);  }}\u00a0void print() { wt('\\n'); }template <class Head, class... Tail>void print(Head &&head, Tail &&... tail) {  wt(head);  if (sizeof...(Tail)) wt(' ');  print(forward<Tail>(tail)...);}\u00a0// gcc expansion. called automaticall after main.void __attribute__((destructor)) _d() { flush(); }} // namespace fastiousing fastio::read;using fastio::print;using fastio::flush;\u00a0#if defined(LOCAL)#define SHOW(...) SHOW_IMPL(__VA_ARGS__, SHOW6, SHOW5, SHOW4, SHOW3, SHOW2, SHOW1)(__VA_ARGS__)#define SHOW_IMPL(_1, _2, _3, _4, _5, _6, NAME, ...) NAME#define SHOW1(x) print(#x, \"=\", (x)), flush()#define SHOW2(x, y) print(#x, \"=\", (x), #y, \"=\", (y)), flush()#define SHOW3(x, y, z) print(#x, \"=\", (x), #y, \"=\", (y), #z, \"=\", (z)), flush()#define SHOW4(x, y, z, w) print(#x, \"=\", (x), #y, \"=\", (y), #z, \"=\", (z), #w, \"=\", (w)), flush()#define SHOW5(x, y, z, w, v) print(#x, \"=\", (x), #y, \"=\", (y), #z, \"=\", (z), #w, \"=\", (w), #v, \"=\", (v)), flush()#define SHOW6(x, y, z, w, v, u) print(#x, \"=\", (x), #y, \"=\", (y), #z, \"=\", (z), #w, \"=\", (w), #v, \"=\", (v), #u, \"=\", (u)), flush()#else#define SHOW(...)#endif\u00a0#define INT(...)   \\  int __VA_ARGS__; \\  read(__VA_ARGS__)#define LL(...)   \\  ll __VA_ARGS__; \\  read(__VA_ARGS__)#define U32(...)   \\  u32 __VA_ARGS__; \\  read(__VA_ARGS__)#define U64(...)   \\  u64 __VA_ARGS__; \\  read(__VA_ARGS__)#define STR(...)      \\  string __VA_ARGS__; \\  read(__VA_ARGS__)#define CHAR(...)   \\  char __VA_ARGS__; \\  read(__VA_ARGS__)#define DBL(...)      \\  double __VA_ARGS__; \\  read(__VA_ARGS__)\u00a0#define VEC(type, name, size) \\  vector<type> name(size);    \\  read(name)#define VV(type, name, h, w)                     \\  vector<vector<type>> name(h, vector<type>(w)); \\  read(name)\u00a0void YES(bool t = 1) { print(t ? \"YES\" : \"NO\"); }void NO(bool t = 1) { YES(!t); }void Yes(bool t = 1) { print(t ? \"Yes\" : \"No\"); }void No(bool t = 1) { Yes(!t); }void yes(bool t = 1) { print(t ? \"yes\" : \"no\"); }void no(bool t = 1) { yes(!t); }#line 3 \"main.cpp\"\u00a0void solve() {  LL(N);  VEC(ll, A, N);  A = cumsum<ll>(A);\u00a0  ll ANS = 0;  // FOR(L, N) FOR(R, L + 1, N + 1) {  //   ll ans = R - L - 1;  //   FOR(a, L + 1, R) {  //     if (A[L] + A[R] == 2 * A[a]) --ans;  //   }  //   FOR(a, L + 1, R) {  //     FOR(b, a + 1, R) {  //       if (A[L] + A[R] == A[a] + A[b]) ans -= 2;  //     }  //   }  //   ANS += ans;  //   SHOW(L, R, ans);  // }  FOR(L, N) FOR(R, L + 1, N + 1) { ANS += R - L - 1; }  FOR(L, N) FOR(R, L + 1, N + 1) {    ll x = A[L] + A[R];    if (x % 2 != 0) continue;    if (binary_search(all(A), x / 2)) --ANS;  }\u00a0  map<ll, int> MP;  FOR(a, N + 1) FOR(b, a + 1, N + 1) {    ll x = A[a] + A[b];    ANS -= 2 * MP[x];    MP[x]++;  }\u00a0  print(ANS);}\u00a0signed main() {  INT(T);  FOR(T) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Make a Palindrome.json"
}