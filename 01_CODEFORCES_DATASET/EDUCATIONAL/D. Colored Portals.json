{
    "link": "https://codeforces.com//contest/2004/problem/D",
    "problemId": "2817827",
    "problem_idx": "D",
    "shortId": "2004D",
    "contest_number": "2004",
    "problem_submissions": {
        "G": [
            276630607,
            276630835,
            276815301,
            276813223,
            276730941,
            276730940,
            276730938,
            276730196,
            276706226,
            276673537,
            276671208,
            276669707,
            276668079,
            276666673,
            276663824,
            276631973,
            276650398,
            276654199,
            276671978,
            276667171,
            276655191,
            276675324,
            276673836,
            276665927,
            276659967,
            276686801,
            276659848,
            276661339,
            276663400,
            276678317,
            276675734,
            276609503,
            276603609,
            276603860,
            276684871
        ],
        "F": [
            276600783,
            276603077,
            276690058,
            276689698,
            276688969,
            276684111,
            276683838,
            276611637,
            276612991,
            276625645,
            276618158,
            276605423,
            276629515,
            276618667,
            276611221,
            276649582,
            276637411,
            276625639,
            276636840,
            276618197,
            276636099,
            276599811,
            276607522
        ],
        "E": [
            276589802,
            276596867,
            276580257,
            276593952,
            276589935,
            276605205,
            276593092,
            276591124,
            276594409,
            276599244,
            276591466,
            276615953,
            276611658,
            276612000,
            276628960,
            276614801,
            276589234,
            276686929,
            276608676
        ],
        "D": [
            276578166,
            276582738,
            276570547,
            276586689,
            276576622,
            276593734,
            276592482,
            276576486,
            276578199,
            276577214,
            276576531,
            276589387,
            276598254,
            276598480,
            276637507,
            276646335,
            276573014,
            276574212
        ],
        "C": [
            276568096,
            276566732,
            276560637,
            276568151,
            276566161,
            276564826,
            276568270,
            276565609,
            276576360,
            276566803,
            276562944,
            276571325,
            276570770,
            276579007,
            276640458,
            276649705,
            276564151,
            276563159
        ],
        "B": [
            276564489,
            276561786,
            276554466,
            276562035,
            276558846,
            276558446,
            276562561,
            276560684,
            276559360,
            276563127,
            276557878,
            276566849,
            276563790,
            276573781,
            276643281,
            276652367,
            276559066,
            276557843
        ],
        "A": [
            276550095,
            276553218,
            276549966,
            276550401,
            276550699,
            276550217,
            276553657,
            276550131,
            276549961,
            276555386,
            276550038,
            276550361,
            276550391,
            276551777,
            276644857,
            276653734,
            276550010,
            276550451
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/132790",
    "editorial": "If cities and have a common portal, then the cost of the path is\r\n.Otherwise, we have to move from city to some intermediate city . Itâs\r\nimportant to note that the type of city should be different from the\r\ntype of city . Otherwise, we could skip city and go directly from to the\r\nnext city in the path. Since the type of city doesnât match the type of\r\ncity , it must have a common portal with city . Therefore, the optimal\r\npath look like this: . Additional cities wonât decrease the cost of the\r\npath.Now we have to figure out how to choose city to minimize the cost\r\nof the path. Without loss of generality, letâs say that . Then there are\r\nthree possible locations for city : , then the cost of the path is ; ,\r\nthen the cost of the path is ; , then the cost of the path is . It is\r\neasy to see that in each case, to minimize the cost of the path, we\r\nshould choose as close to as possible.Letâs define two arrays: the index\r\nof the nearest city to the left of with type , and similarly the index\r\nof the nearest city to the right of with type .Then the answer to the\r\nproblem is the minimum value among and for all types for which there are\r\ncommon portals with cities and .\r\n",
    "name": "D. Colored Portals",
    "statement": "There are n cities located on a straight line. The cities are numbered\r\nfrom 1 to n.Portals are used to move between cities. There are 4 colors\r\nof portals: blue, green, red, and yellow. Each city has portals of two\r\ndifferent colors. You can move from city i to city j if they have\r\nportals of the same color (for example, you can move between a\r\n\"blue-red\" city and a \"blue-green\" city). This movement costs |i-j|\r\ncoins.Your task is to answer q independent queries: calculate the\r\nminimum cost to move from city x to city y.\r\n",
    "solutions": [
        "#line 1 \"library/my_template.hpp\"#if defined(LOCAL)#include <my_template_compiled.hpp>#else // https://mirror.codeforces.com/blog/entry/96344#pragma GCC optimize(\"Ofast,unroll-loops\")// いまの CF だとこれ入れると動かない？// #pragma GCC target(\"avx2,popcnt\") #include <bits/stdc++.h> using namespace std; using ll = long long;using u32 = unsigned int;using u64 = unsigned long long;using i128 = __int128;using u128 = unsigned __int128;using f128 = __float128; template <class T>constexpr T infty = 0;template <>constexpr int infty<int> = 1'010'000'000;template <>constexpr ll infty<ll> = 2'020'000'000'000'000'000;template <>constexpr u32 infty<u32> = infty<int>;template <>constexpr u64 infty<u64> = infty<ll>;template <>constexpr i128 infty<i128> = i128(infty<ll>) * 2'000'000'000'000'000'000;template <>constexpr double infty<double> = infty<ll>;template <>constexpr long double infty<long double> = infty<ll>; using pi = pair<ll, ll>;using vi = vector<ll>;template <class T>using vc = vector<T>;template <class T>using vvc = vector<vc<T>>;template <class T>using vvvc = vector<vvc<T>>;template <class T>using vvvvc = vector<vvvc<T>>;template <class T>using vvvvvc = vector<vvvvc<T>>;template <class T>using pq = priority_queue<T>;template <class T>using pqg = priority_queue<T, vector<T>, greater<T>>; #define vv(type, name, h, ...) vector<vector<type>> name(h, vector<type>(__VA_ARGS__))#define vvv(type, name, h, w, ...) vector<vector<vector<type>>> name(h, vector<vector<type>>(w, vector<type>(__VA_ARGS__)))#define vvvv(type, name, a, b, c, ...) \\  vector<vector<vector<vector<type>>>> name(a, vector<vector<vector<type>>>(b, vector<vector<type>>(c, vector<type>(__VA_ARGS__)))) // https://trap.jp/post/1224/#define FOR1(a) for (ll _ = 0; _ < ll(a); ++_)#define FOR2(i, a) for (ll i = 0; i < ll(a); ++i)#define FOR3(i, a, b) for (ll i = a; i < ll(b); ++i)#define FOR4(i, a, b, c) for (ll i = a; i < ll(b); i += (c))#define FOR1_R(a) for (ll i = (a)-1; i >= ll(0); --i)#define FOR2_R(i, a) for (ll i = (a)-1; i >= ll(0); --i)#define FOR3_R(i, a, b) for (ll i = (b)-1; i >= ll(a); --i)#define overload4(a, b, c, d, e, ...) e#define overload3(a, b, c, d, ...) d#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)#define FOR_R(...) overload3(__VA_ARGS__, FOR3_R, FOR2_R, FOR1_R)(__VA_ARGS__) #define FOR_subset(t, s) for (ll t = (s); t >= 0; t = (t == 0 ? -1 : (t - 1) & (s)))#define all(x) x.begin(), x.end()#define len(x) ll(x.size())#define elif else if #define eb emplace_back#define mp make_pair#define mt make_tuple#define fi first#define se second #define stoi stoll int popcnt(int x) { return __builtin_popcount(x); }int popcnt(u32 x) { return __builtin_popcount(x); }int popcnt(ll x) { return __builtin_popcountll(x); }int popcnt(u64 x) { return __builtin_popcountll(x); }int popcnt_mod_2(int x) { return __builtin_parity(x); }int popcnt_mod_2(u32 x) { return __builtin_parity(x); }int popcnt_mod_2(ll x) { return __builtin_parityll(x); }int popcnt_mod_2(u64 x) { return __builtin_parityll(x); }// (0, 1, 2, 3, 4) -> (-1, 0, 1, 1, 2)int topbit(int x) { return (x == 0 ? -1 : 31 - __builtin_clz(x)); }int topbit(u32 x) { return (x == 0 ? -1 : 31 - __builtin_clz(x)); }int topbit(ll x) { return (x == 0 ? -1 : 63 - __builtin_clzll(x)); }int topbit(u64 x) { return (x == 0 ? -1 : 63 - __builtin_clzll(x)); }// (0, 1, 2, 3, 4) -> (-1, 0, 1, 0, 2)int lowbit(int x) { return (x == 0 ? -1 : __builtin_ctz(x)); }int lowbit(u32 x) { return (x == 0 ? -1 : __builtin_ctz(x)); }int lowbit(ll x) { return (x == 0 ? -1 : __builtin_ctzll(x)); }int lowbit(u64 x) { return (x == 0 ? -1 : __builtin_ctzll(x)); } template <typename T>T floor(T a, T b) {  return a / b - (a % b && (a ^ b) < 0);}template <typename T>T ceil(T x, T y) {  return floor(x + y - 1, y);}template <typename T>T bmod(T x, T y) {  return x - y * floor(x, y);}template <typename T>pair<T, T> divmod(T x, T y) {  T q = floor(x, y);  return {q, x - q * y};} template <typename T, typename U>T SUM(const vector<U> &A) {  T sm = 0;  for (auto &&a: A) sm += a;  return sm;} #define MIN(v) *min_element(all(v))#define MAX(v) *max_element(all(v))#define LB(c, x) distance((c).begin(), lower_bound(all(c), (x)))#define UB(c, x) distance((c).begin(), upper_bound(all(c), (x)))#define UNIQUE(x) sort(all(x)), x.erase(unique(all(x)), x.end()), x.shrink_to_fit() template <typename T>T POP(deque<T> &que) {  T a = que.front();  que.pop_front();  return a;}template <typename T>T POP(pq<T> &que) {  T a = que.top();  que.pop();  return a;}template <typename T>T POP(pqg<T> &que) {  T a = que.top();  que.pop();  return a;}template <typename T>T POP(vc<T> &que) {  T a = que.back();  que.pop_back();  return a;} template <typename F>ll binary_search(F check, ll ok, ll ng, bool check_ok = true) {  if (check_ok) assert(check(ok));  while (abs(ok - ng) > 1) {    auto x = (ng + ok) / 2;    (check(x) ? ok : ng) = x;  }  return ok;}template <typename F>double binary_search_real(F check, double ok, double ng, int iter = 100) {  FOR(iter) {    double x = (ok + ng) / 2;    (check(x) ? ok : ng) = x;  }  return (ok + ng) / 2;} template <class T, class S>inline bool chmax(T &a, const S &b) {  return (a < b ? a = b, 1 : 0);}template <class T, class S>inline bool chmin(T &a, const S &b) {  return (a > b ? a = b, 1 : 0);} // ? は -1vc<int> s_to_vi(const string &S, char first_char) {  vc<int> A(S.size());  FOR(i, S.size()) { A[i] = (S[i] != '?' ? S[i] - first_char : -1); }  return A;} template <typename T, typename U>vector<T> cumsum(vector<U> &A, int off = 1) {  int N = A.size();  vector<T> B(N + 1);  FOR(i, N) { B[i + 1] = B[i] + A[i]; }  if (off == 0) B.erase(B.begin());  return B;} // stable sorttemplate <typename T>vector<int> argsort(const vector<T> &A) {  vector<int> ids(len(A));  iota(all(ids), 0);  sort(all(ids), [&](int i, int j) { return (A[i] == A[j] ? i < j : A[i] < A[j]); });  return ids;} // A[I[0]], A[I[1]], ...template <typename T>vc<T> rearrange(const vc<T> &A, const vc<int> &I) {  vc<T> B(len(I));  FOR(i, len(I)) B[i] = A[I[i]];  return B;} template <typename T, typename... Vectors>void concat(vc<T> &first, const Vectors &... others) {  vc<T> &res = first;  (res.insert(res.end(), others.begin(), others.end()), ...);}#endif#line 1 \"library/other/io.hpp\"#define FASTIO#include <unistd.h> // https://judge.yosupo.jp/submission/21623namespace fastio {static constexpr uint32_t SZ = 1 << 17;char ibuf[SZ];char obuf[SZ];char out[100];// pointer of ibuf, obufuint32_t pil = 0, pir = 0, por = 0; struct Pre {  char num[10000][4];  constexpr Pre() : num() {    for (int i = 0; i < 10000; i++) {      int n = i;      for (int j = 3; j >= 0; j--) {        num[i][j] = n % 10 | '0';        n /= 10;      }    }  }} constexpr pre; inline void load() {  memcpy(ibuf, ibuf + pil, pir - pil);  pir = pir - pil + fread(ibuf + pir - pil, 1, SZ - pir + pil, stdin);  pil = 0;  if (pir < SZ) ibuf[pir++] = '\\n';} inline void flush() {  fwrite(obuf, 1, por, stdout);  por = 0;} void rd(char &c) {  do {    if (pil + 1 > pir) load();    c = ibuf[pil++];  } while (isspace(c));} void rd(string &x) {  x.clear();  char c;  do {    if (pil + 1 > pir) load();    c = ibuf[pil++];  } while (isspace(c));  do {    x += c;    if (pil == pir) load();    c = ibuf[pil++];  } while (!isspace(c));} template <typename T>void rd_real(T &x) {  string s;  rd(s);  x = stod(s);} template <typename T>void rd_integer(T &x) {  if (pil + 100 > pir) load();  char c;  do    c = ibuf[pil++];  while (c < '-');  bool minus = 0;  if constexpr (is_signed<T>::value || is_same_v<T, i128>) {    if (c == '-') { minus = 1, c = ibuf[pil++]; }  }  x = 0;  while ('0' <= c) { x = x * 10 + (c & 15), c = ibuf[pil++]; }  if constexpr (is_signed<T>::value || is_same_v<T, i128>) {    if (minus) x = -x;  }} void rd(int &x) { rd_integer(x); }void rd(ll &x) { rd_integer(x); }void rd(i128 &x) { rd_integer(x); }void rd(u32 &x) { rd_integer(x); }void rd(u64 &x) { rd_integer(x); }void rd(u128 &x) { rd_integer(x); }void rd(double &x) { rd_real(x); }void rd(long double &x) { rd_real(x); }void rd(f128 &x) { rd_real(x); } template <class T, class U>void rd(pair<T, U> &p) {  return rd(p.first), rd(p.second);}template <size_t N = 0, typename T>void rd_tuple(T &t) {  if constexpr (N < std::tuple_size<T>::value) {    auto &x = std::get<N>(t);    rd(x);    rd_tuple<N + 1>(t);  }}template <class... T>void rd(tuple<T...> &tpl) {  rd_tuple(tpl);} template <size_t N = 0, typename T>void rd(array<T, N> &x) {  for (auto &d: x) rd(d);}template <class T>void rd(vc<T> &x) {  for (auto &d: x) rd(d);} void read() {}template <class H, class... T>void read(H &h, T &... t) {  rd(h), read(t...);} void wt(const char c) {  if (por == SZ) flush();  obuf[por++] = c;}void wt(const string s) {  for (char c: s) wt(c);}void wt(const char *s) {  size_t len = strlen(s);  for (size_t i = 0; i < len; i++) wt(s[i]);} template <typename T>void wt_integer(T x) {  if (por > SZ - 100) flush();  if (x < 0) { obuf[por++] = '-', x = -x; }  int outi;  for (outi = 96; x >= 10000; outi -= 4) {    memcpy(out + outi, pre.num[x % 10000], 4);    x /= 10000;  }  if (x >= 1000) {    memcpy(obuf + por, pre.num[x], 4);    por += 4;  } else if (x >= 100) {    memcpy(obuf + por, pre.num[x] + 1, 3);    por += 3;  } else if (x >= 10) {    int q = (x * 103) >> 10;    obuf[por] = q | '0';    obuf[por + 1] = (x - q * 10) | '0';    por += 2;  } else    obuf[por++] = x | '0';  memcpy(obuf + por, out + outi + 4, 96 - outi);  por += 96 - outi;} template <typename T>void wt_real(T x) {  ostringstream oss;  oss << fixed << setprecision(15) << double(x);  string s = oss.str();  wt(s);} void wt(int x) { wt_integer(x); }void wt(ll x) { wt_integer(x); }void wt(i128 x) { wt_integer(x); }void wt(u32 x) { wt_integer(x); }void wt(u64 x) { wt_integer(x); }void wt(u128 x) { wt_integer(x); }void wt(double x) { wt_real(x); }void wt(long double x) { wt_real(x); }void wt(f128 x) { wt_real(x); } template <class T, class U>void wt(const pair<T, U> val) {  wt(val.first);  wt(' ');  wt(val.second);}template <size_t N = 0, typename T>void wt_tuple(const T t) {  if constexpr (N < std::tuple_size<T>::value) {    if constexpr (N > 0) { wt(' '); }    const auto x = std::get<N>(t);    wt(x);    wt_tuple<N + 1>(t);  }}template <class... T>void wt(tuple<T...> tpl) {  wt_tuple(tpl);}template <class T, size_t S>void wt(const array<T, S> val) {  auto n = val.size();  for (size_t i = 0; i < n; i++) {    if (i) wt(' ');    wt(val[i]);  }}template <class T>void wt(const vector<T> val) {  auto n = val.size();  for (size_t i = 0; i < n; i++) {    if (i) wt(' ');    wt(val[i]);  }} void print() { wt('\\n'); }template <class Head, class... Tail>void print(Head &&head, Tail &&... tail) {  wt(head);  if (sizeof...(Tail)) wt(' ');  print(forward<Tail>(tail)...);} // gcc expansion. called automaticall after main.void __attribute__((destructor)) _d() { flush(); }} // namespace fastiousing fastio::read;using fastio::print;using fastio::flush; #if defined(LOCAL)#define SHOW(...) SHOW_IMPL(__VA_ARGS__, SHOW6, SHOW5, SHOW4, SHOW3, SHOW2, SHOW1)(__VA_ARGS__)#define SHOW_IMPL(_1, _2, _3, _4, _5, _6, NAME, ...) NAME#define SHOW1(x) print(#x, \"=\", (x)), flush()#define SHOW2(x, y) print(#x, \"=\", (x), #y, \"=\", (y)), flush()#define SHOW3(x, y, z) print(#x, \"=\", (x), #y, \"=\", (y), #z, \"=\", (z)), flush()#define SHOW4(x, y, z, w) print(#x, \"=\", (x), #y, \"=\", (y), #z, \"=\", (z), #w, \"=\", (w)), flush()#define SHOW5(x, y, z, w, v) print(#x, \"=\", (x), #y, \"=\", (y), #z, \"=\", (z), #w, \"=\", (w), #v, \"=\", (v)), flush()#define SHOW6(x, y, z, w, v, u) print(#x, \"=\", (x), #y, \"=\", (y), #z, \"=\", (z), #w, \"=\", (w), #v, \"=\", (v), #u, \"=\", (u)), flush()#else#define SHOW(...)#endif #define INT(...)   \\  int __VA_ARGS__; \\  read(__VA_ARGS__)#define LL(...)   \\  ll __VA_ARGS__; \\  read(__VA_ARGS__)#define U32(...)   \\  u32 __VA_ARGS__; \\  read(__VA_ARGS__)#define U64(...)   \\  u64 __VA_ARGS__; \\  read(__VA_ARGS__)#define STR(...)      \\  string __VA_ARGS__; \\  read(__VA_ARGS__)#define CHAR(...)   \\  char __VA_ARGS__; \\  read(__VA_ARGS__)#define DBL(...)      \\  double __VA_ARGS__; \\  read(__VA_ARGS__) #define VEC(type, name, size) \\  vector<type> name(size);    \\  read(name)#define VV(type, name, h, w)                     \\  vector<vector<type>> name(h, vector<type>(w)); \\  read(name) void YES(bool t = 1) { print(t ? \"YES\" : \"NO\"); }void NO(bool t = 1) { YES(!t); }void Yes(bool t = 1) { print(t ? \"Yes\" : \"No\"); }void No(bool t = 1) { Yes(!t); }void yes(bool t = 1) { print(t ? \"yes\" : \"no\"); }void no(bool t = 1) { yes(!t); }#line 3 \"main.cpp\" void solve() {  LL(N, Q);  vvc<int> dat(16);  vc<int> A(N);  FOR(i, N) {    STR(S);    ll a = 0;    for (auto& ch: S) {      if (ch == 'B') a |= 1;      if (ch == 'R') a |= 2;      if (ch == 'G') a |= 4;      if (ch == 'Y') a |= 8;    }    A[i] = a;  }  FOR(i, N) dat[A[i]].eb(i);   auto solve = [&](ll a, ll b) -> void {    if (A[a] & A[b]) { return print(abs(a - b)); }    ll ANS = infty<ll>;    FOR(s, 16) {      if (popcnt(s) == 2 && (A[a] & s) && (A[b] & s)) {        ll p = LB(dat[s], a);        FOR(k, p - 3, p + 4) {          if (!(0 <= k && k < len(dat[s]))) continue;          ll x = dat[s][k];          ll ans = 0;          ans += abs(x - a);          ans += abs(x - b);          chmin(ANS, ans);        }      }    }    if (ANS == infty<ll>) ANS = -1;    print(ANS);  };   FOR(Q) {    LL(a, b);    --a, --b;    solve(a, b);  }} signed main() {  INT(T);  FOR(T) solve();}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "data structures",
        "graphs",
        "greedy",
        "implementation",
        "shortest paths"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Colored Portals.json",
    "hint": []
}