{
    "link": "https://codeforces.com//contest/1721/problem/C",
    "problemId": "1521726",
    "problem_idx": "C",
    "shortId": "1721C",
    "contest_number": "1721",
    "problem_submissions": {
        "F": [
            169847425,
            169855093,
            169874051,
            169859751,
            169871554,
            169869426,
            169892039,
            169866057,
            169866260,
            169879985,
            169882444,
            169880200,
            169868972,
            169943924,
            169887978,
            169882264,
            169879150,
            169868978,
            169868554,
            169884451,
            169886386,
            169884169,
            169836583,
            169890280,
            169889729
        ],
        "E": [
            169825445,
            169831576,
            169846355,
            169845815,
            169845247,
            169849940,
            170071212,
            169840961,
            169843652,
            169842409,
            169855809,
            169853200,
            169849055,
            169861077,
            169848556,
            169841458,
            169835951,
            169859126,
            169853059,
            169861299,
            169890819,
            169860030,
            169851763,
            169839234
        ],
        "D": [
            169816642,
            169857780,
            169827464,
            169828353,
            169825938,
            169823055,
            169827534,
            169839208,
            169826501,
            169831272,
            169830277,
            169840516,
            169830590,
            169829045,
            169820762,
            169829319,
            169841817,
            169849956,
            169828079,
            169855346,
            169832685
        ],
        "C": [
            169812006,
            169821873,
            169865515,
            169815093,
            169818535,
            169828842,
            169823304,
            169816953,
            169821336,
            169818460,
            169821914,
            169817547,
            169822314,
            169825383,
            169842253,
            169820059,
            169823503,
            169835000,
            169824388,
            169861925,
            169815457
        ],
        "B": [
            169804991,
            169810857,
            169806854,
            169811441,
            169813569,
            169810575,
            169808902,
            169808903,
            169811401,
            169810906,
            169807229,
            169812143,
            169813395,
            169807352,
            169812235,
            169815520,
            169825227,
            169814779,
            169864673,
            169808536
        ],
        "A": [
            169804030,
            169804283,
            169861742,
            169804044,
            169806500,
            169805484,
            169806996,
            169804568,
            169805103,
            169805093,
            169804586,
            169804045,
            169804642,
            169805849,
            169804015,
            169804388,
            169808577,
            169817992,
            169808806,
            169866242,
            169804342
        ]
    },
    "name": "C. Min-Max Array Transformation",
    "statement": "You are given an array a_1, a_2,\r\ndots, a_n, which is sorted in non-descending order. You decided to\r\nperform the following steps to create array b_1, b_2,\r\ndots, b_n: Create an array d consisting of n arbitrary integers. Set b_i\r\n= a_i + d_i for each b_i. Sort the array b in non-descending order. You\r\nare given the resulting array b. For each index i, calculate what is the\r\nminimum and maximum possible value of d_i you can choose in order to get\r\nthe given array b.Note that the minimum (maximum) d_i-s are of each\r\nother, i. e. they can be obtained from different possible arrays d.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    for (int i = 0, j = 0; i < n; i++) {\n        while (b[j] < a[i]) {\n            j++;\n        }\n        std::cout << b[j] - a[i] << \" \\n\"[i == n - 1];\n    }\n    \n    for (int i = 0, j = 0; i < n; i++) {\n        j = std::max(j, i);\n        while (j + 1 < n && a[j + 1] <= b[j]) {\n            j++;\n        }\n        std::cout << b[j] - a[i] << \" \\n\"[i == n - 1];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Min-Max Array Transformation.json",
    "editorial_link": "https://codeforces.com//blog/entry/106416",
    "editorial": "For the start, letâs note that for each . Otherwise, there is no way to\r\nget from .Firstly, letâs calculate for each . Since all then is always\r\ngreater or equal than you get it from. So, the minimum would come from\r\nlowest that still . Since is sorted, we can find such with in .Letâs\r\nprove that we can build such that transforms to we found earlier. Letâs\r\njust make for ; for and . Itâs easy to see that all are non-negative, so\r\nsuch is valid.Now, letâs calculate . Suppose, we transform to for some .\r\nItâs not hard to prove that the \"proving\" array may be constructed in\r\nthe similar way: for ; for and .In order to build such array , you need\r\nfor each . In other words, if there is some position such that and you\r\ncanât choose such that . It means that we can iterate in descending\r\norder and just keep track of leftmost with . Then, is equal to (or if\r\nthere are no such ).The resulting complexity is because of the first\r\npart. But it can be optimized to if we use two pointers instead of .\r\n",
    "hint": []
}