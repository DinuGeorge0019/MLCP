{
    "link": "https://codeforces.com//contest/1728/problem/E",
    "problemId": "1534226",
    "problem_idx": "E",
    "shortId": "1728E",
    "contest_number": "1728",
    "problem_submissions": {
        "F": [
            171415471,
            171408709,
            171477755,
            171477598,
            171800837,
            171602685,
            171508405,
            171615612,
            171428158,
            171416710,
            171516704
        ],
        "G": [
            171401437,
            171423625,
            171401320,
            171405459,
            171408910,
            171400855,
            171410753,
            171399735,
            171425286,
            171424973,
            171424864,
            171421363,
            171409384,
            171429440,
            171419291,
            171421745,
            171401911,
            171420331,
            171494040,
            171406232,
            171419649,
            171415822,
            171442989,
            171426124,
            171423998,
            171422898,
            171422786,
            171419842
        ],
        "E": [
            171378857,
            171391875,
            171380622,
            171383139,
            171380478,
            171390287,
            171381329,
            171385138,
            171384190,
            171396093,
            171392841,
            171388311,
            171403618,
            171390049,
            171393452,
            171494181,
            171455206,
            171419342,
            171391692,
            171398313,
            171393739,
            171428155,
            171396053,
            171400068
        ],
        "D": [
            171364431,
            171379034,
            171368807,
            171365018,
            171370163,
            171375547,
            171369467,
            171380229,
            171364084,
            171374772,
            171368217,
            171377453,
            171410355,
            171379812,
            171386430,
            171377364,
            171385449,
            171375075,
            171380828,
            171376969
        ],
        "C": [
            171356021,
            171355657,
            171354790,
            171355489,
            171357376,
            171364423,
            171358552,
            171371507,
            171356927,
            171358656,
            171358481,
            171361890,
            171364747,
            171361193,
            171494234,
            171359234,
            171364539,
            171370274,
            171358915,
            171369689,
            171370585
        ],
        "B": [
            171350944,
            171350546,
            171350225,
            171351747,
            171353484,
            171350234,
            171353700,
            171367743,
            171353076,
            171355275,
            171352643,
            171355734,
            171359875,
            171351546,
            171353658,
            171357176,
            171361933,
            171353420,
            171361436,
            171361759
        ],
        "A": [
            171346435,
            171346486,
            171346382,
            171346456,
            171348074,
            171346466,
            171346859,
            171352332,
            171346599,
            171349231,
            171346445,
            171346558,
            171348949,
            171346594,
            171346485,
            171349162,
            171347108,
            171346675,
            171346628,
            171349812
        ]
    },
    "name": "E. Red-Black Pepper",
    "statement": "Monocarp is going to host a party for his friends. He prepared n dishes\r\nand is about to serve them. First, he has to add some powdered pepper to\r\neach of them otherwise, the dishes will be pretty tasteless.The i-th\r\ndish has two values a_i and b_i its tastiness with red pepper added or\r\nblack pepper added, respectively. Monocarp won’t add both peppers to any\r\ndish, won’t add any pepper multiple times, and won’t leave any dish\r\nwithout the pepper added.Before adding the pepper, Monocarp should first\r\npurchase the said pepper in some shop. There are m shops in his local\r\narea. The j-th of them has packages of red pepper sufficient for x_j\r\nservings and packages of black pepper sufficient for y_j\r\nservings.Monocarp goes to exactly one shop, purchases multiple\r\n(possibly, zero) packages of each pepper in such a way that . More\r\nformally, if he purchases x red pepper packages and y black pepper\r\npackages, then x and y should be non-negative and x\r\ncdot x_j + y\r\ncdot y_j should be equal to n.For each shop, determine the maximum total\r\ntastiness of the dishes after Monocarp buys pepper packages only in this\r\nshop and adds the pepper to the dishes. If it’s impossible to purchase\r\nthe packages in the said way, print .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < '-')\n\t\t;\n\tif (c == '-') {\n\t\tint x = gc - '0';\n\t\twhile (gc >= '0') x = x * 10 + c - '0';\n\t\treturn -x;\n\t}\n\tint x = c - '0';\n\twhile (gc >= '0') x = x * 10 + c - '0';\n\treturn x;\n}\n#undef gc\n\nconst int N = 3e5 + 5;\n\nint a[N], b[N], t[N];\nlong long s[N];\nint n, m;\n\nint exgcd(int a, int b, int& x, int& y) {\n\tif (b == 0) {\n\t\tx = 1;\n\t\ty = 0;\n\t\treturn a;\n\t}\n\tint d = exgcd(b, a % b, y, x);\n\ty -= a / b * x;\n\treturn d;\n}\n\nint main() {\n#ifdef local\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tn = read();\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = read(), b[i] = read();\n\t\ts[0] += b[i];\n\t\tt[i] = a[i] - b[i];\n\t}\n\tsort(t + 1, t + n + 1);\n\treverse(t + 1, t + n + 1);\n\tfor (int i = 1; i <= n; i++) s[i] = s[i - 1] + t[i];\n\tm = read();\n\tfor (int i = 1; i <= m; i++) {\n\t\tint a = read(), b = read(), x, y;\n\t\tint d = exgcd(a, b, x, y);\n\t\tint step = b / d;\n\t\tx = (1ll * x * (n / d) % step + step) % step;\n\t\tif (1ll * x * a > n || n % d != 0) {\n\t\t\tprintf(\"-1\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tlong long len = 1ll * step * a;\n\t\tx *= a;\n\t\tint l = 1, r = (n - x) / len, ans = 0;\n\t\twhile (l <= r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (s[x + mid * len] > s[x + (mid - 1) * len])\n\t\t\t\tans = mid, l = mid + 1;\n\t\t\telse\n\t\t\t\tr = mid - 1;\n\t\t}\n\t\tprintf(\"%lld\\n\", s[x + ans * len]);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Red-Black Pepper.json",
    "editorial_link": "https://codeforces.com//blog/entry/106805",
    "editorial": "Letâs start by learning how to answer a query all red pepper and black\r\npepper options are available.Letâs iterate over all options to put the\r\npeppers and choose the maximum of them. First, letâs use the red pepper\r\nfor all dishes. Now we want to select some of them to use black pepper\r\ninstead of red pepper. Which ones do we choose? When we switch from the\r\nred pepper to the black pepper, the total tastiness changes by for the\r\n-th dish. They are completely independent of each other, so we want to\r\nchoose largest of these values.Let be the sequence of values of in a\r\nnon-increasing order.Thus, black peppers will yield the result of . We\r\ncan answer a query by looking for a maximum in the sequence.Now consider\r\nan arbitrary query. Let be all options for the amount of available black\r\npeppers for the query. Naively, we could iterate over all of them and\r\nchoose the maximum one.However, notice an interesting thing about the\r\nsequence of the answers. By definition, it is non-strictly convex. In\r\nparticular, one idea that can be extracted from this is the following.\r\nFind the position of an arbitrary maximum in this sequence. Then\r\neverything to the left of is is non-increasing. Everything to the right\r\nof it is non-increasing.Thus, for a query, itâs enough to consider only\r\ntwo options: the one closest to the maximum from the left and from the\r\nright.Now we only have to learn how to get these options fast enough.\r\nFor a query we want to solve whatâs called a diophantine equation . An\r\narbitrary solution can be obtained by using extended Euclid algorithm.\r\nLet it be some . Then we would want to check the answer for black\r\npeppers. The amount of solutions to the equation is either infinite or\r\nzero. If itâs infinite, all solutions will be of the form for any\r\ninteger . Remember that not all the solutions will be in a range\r\n.Finally, find the two solutions that are the closest to the maximum,\r\ncheck that they are in the range and print the best answer of\r\nthem.Overall complexity: .\r\n",
    "hint": []
}