{
    "link": "https://codeforces.com//contest/1606/problem/E",
    "problemId": "1163616",
    "problem_idx": "E",
    "shortId": "1606E",
    "contest_number": "1606",
    "problem_submissions": {
        "F": [
            133507404,
            133507818,
            133498109,
            133510274,
            133508292,
            133516889,
            133520516,
            133515497,
            133516080,
            133502968,
            134316313,
            133499324,
            134054804,
            133588873,
            133583029,
            133581709
        ],
        "D": [
            133486455,
            133493884,
            133513223,
            133492283,
            133485348,
            133494162,
            133496696,
            133482809,
            133492529,
            133517460,
            133476721,
            133498136,
            133495480,
            135925509,
            133485100,
            133479592,
            133499757,
            133522973,
            133486537,
            133503209,
            133499457
        ],
        "E": [
            133463795,
            133481392,
            133471511,
            133490729,
            133490179,
            133495042,
            133479686,
            133483637,
            133491209,
            133498277,
            133483064,
            133494409,
            133480178,
            133476474,
            135922690,
            133494013,
            133498349,
            133478322,
            133477984,
            133495608,
            133473401,
            133487605
        ],
        "C": [
            133458872,
            133464915,
            133459336,
            133460040,
            133464064,
            133462782,
            133466153,
            133471330,
            133463944,
            133471558,
            133463840,
            133462653,
            133461264,
            133462854,
            133461230,
            133467241,
            133464884,
            133472085,
            133464159,
            133466246
        ],
        "B": [
            133458354,
            133459359,
            133457772,
            133458154,
            133459800,
            133458862,
            133459689,
            133467167,
            133459191,
            133458183,
            133459448,
            133458263,
            133464726,
            133458679,
            133458193,
            133459842,
            133457910,
            133460625,
            133459355,
            133458301
        ],
        "A": [
            133457621,
            133458135,
            133457507,
            133457613,
            133457801,
            133457608,
            133458264,
            133457856,
            133457610,
            133457684,
            133457591,
            133457600,
            133457598,
            133457574,
            133457611,
            133457877,
            133457514,
            133458100,
            133457524,
            133457605
        ]
    },
    "name": "E. Arena",
    "statement": "There are n heroes fighting in the arena. Initially, the i-th hero has\r\na_i health points.The fight in the arena takes place in several rounds.\r\nAt the beginning of each round, each alive hero deals 1 damage to all\r\nother heroes. Hits of all heroes occur simultaneously. Heroes whose\r\nhealth is less than 1 at the end of the round are considered killed.If\r\nexactly 1 hero remains alive after a certain round, then he is declared\r\nthe winner. Otherwise, there is no winner.Your task is to calculate the\r\nnumber of ways to choose the initial health points for each hero a_i,\r\nwhere 1\r\nle a_i\r\nle x, so that there is no winner of the fight. The number of ways can be\r\nvery large, so print it modulo 998244353. Two ways are considered\r\ndifferent if at least one hero has a different amount of health. For\r\nexample, [1, 2, 1] and [2, 1, 1] are different.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntemplate<typename T> bool chkmax(T &x,T y){return x<y?x=y,1:0;}\ntemplate<typename T> bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n\nint readint(){\n\tint x=0,f=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\nconst int cys=998244353;\nint n,x;\nll pw[505][505],C[505][505],d[505][505];\n\nll mod(ll x){return x>=cys?x-cys:x;}\n\nint main(){\n\tn=readint(); x=readint();\n\tfor(int i=1;i<=x;i++){\n\t\tpw[i][0]=1;\n\t\tfor(int j=1;j<=n;j++) pw[i][j]=pw[i][j-1]*i%cys;\n\t}\n\tfor(int i=0;i<=n;i++) C[i][0]=1;\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=i;j++) C[i][j]=mod(C[i-1][j]+C[i-1][j-1]);\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int j=1;j<=x;j++){\n\t\t\tif(j<=i-1){\n\t\t\t\td[i][j]=pw[j][i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k=0;k<=i;k++){\n\t\t\t\tif(k==i-1) continue;\n\t\t\t\tif(k==i) d[i][j]=(d[i][j]+pw[i-1][k])%cys;\n\t\t\t\telse d[i][j]=(d[i][j]+C[i][k]*pw[i-1][k]%cys*d[i-k][j-i+1])%cys;\n\t\t\t}\n//\t\t\tcout<<\"test \"<<i<<' '<<j<<' '<<d[i][j]<<endl;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",d[n][x]);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Arena.json",
    "editorial_link": "https://codeforces.com//blog/entry/96454",
    "editorial": "Let\u00e2\u0080\u0099s calculate the following dynamic programming the number of ways to\r\nchoose the initial health if there are heroes still alive, and they\r\nalready received damage. Let\u00e2\u0080\u0099s iterate over the number of heroes that\r\nwill survive after the next round. Then we have to make a transition to\r\nthe state , where (the minimum of the maximum allowed health and plus\r\nthe damage done in this round). It remains to understand with what\r\ncoefficient we should make this transition in dynamic programming. This\r\ncoefficient is equal to the number of ways to choose which of the living\r\nheroes will die in this round multiplied by the number of ways to choose\r\nhealth for these heroes (because their health is greater than so that\r\nthey are still alive at the moment, but not more than so that they are\r\nguaranteed to die in this round). Of course, we don\u00e2\u0080\u0099t make any\r\ntransitions from the states where , since they represent the fights that\r\nhave already finished.The answer is the sum of all for every .\r\n"
}