{
    "link": "https://codeforces.com//contest/845/problem/G",
    "problemId": "119177",
    "problem_idx": "G",
    "shortId": "845G",
    "contest_number": "845",
    "problem_submissions": {
        "F": [
            29662191,
            29658691,
            29662577,
            29662557,
            29659271,
            29663949,
            29653306,
            29665823,
            29656869,
            29668298
        ],
        "E": [
            29659390,
            29664188,
            29664063,
            29663215,
            29663046,
            29661461,
            29660552,
            29653793,
            29658574,
            29655087,
            29668158,
            29670073,
            29664054,
            35903704,
            29673169,
            29656703
        ],
        "G": [
            29653058,
            29648925,
            29654997,
            29656636,
            29656923,
            29653301,
            29656155,
            29657485,
            29658552,
            29655006,
            29655066,
            29653896,
            29654510,
            29655977,
            29654363,
            29657005,
            29659307
        ],
        "D": [
            29651798,
            29653616,
            29652569,
            29653638,
            29650642,
            29655985,
            29652243,
            29654023,
            29657108,
            29650588,
            29651844,
            29650739,
            29653419,
            29656251,
            29652823,
            29652595,
            29655002,
            29652809,
            29650646
        ],
        "C": [
            29648829,
            29651383,
            29648358,
            29648061,
            29648669,
            29648794,
            29648303,
            29648671,
            29648937,
            29648455,
            29648984,
            29648127,
            29648921,
            29649045,
            29649074,
            29650613,
            29649296,
            29649747,
            29649146
        ],
        "B": [
            29648130,
            29650436,
            29648956,
            29647280,
            29647747,
            29647255,
            29647572,
            29647971,
            29647530,
            29648013,
            29647504,
            29647868,
            29647800,
            29648160,
            29648934,
            29648366,
            29648191,
            29646728
        ],
        "A": [
            29647342,
            29649692,
            29646643,
            29646523,
            29646782,
            29646497,
            29646493,
            29646476,
            29646501,
            29647201,
            29646463,
            29646669,
            29646500,
            29646893,
            29647910,
            29647098,
            29646857,
            29647624
        ]
    },
    "name": "G. Shortest Path Problem ",
    "statement": "You are given an undirected graph with weighted edges. The length of\r\nsome path between two vertices is the bitwise xor of weights of all\r\nedges belonging to this path (if some edge is traversed more than once,\r\nthen it is included in bitwise xor the same number of times). You have\r\nto find the minimum length of path between vertex and vertex .\r\n",
    "solutions": [
        "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN=100005;\nvector<pair<int,ll> > e[MAXN];\nvector<ll> base;\nvoid add(ll x)\n{\n    for(int i=0;i<(int)base.size();i++)\n        x=min(x,x^base[i]);\n    if(x)base.push_back(x);\n}\nint vis[MAXN];\nll t[MAXN];\nvoid dfs(int u,ll now)\n{\n    vis[u]=1,t[u]=now;\n    for(int i=0;i<(int)e[u].size();i++)\n    {\n        int v=e[u][i].first;\n        if(vis[v])add(now^e[u][i].second^t[v]);\n        else dfs(v,now^e[u][i].second);\n    }\n}\nint main()\n{\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++)\n    {\n        int x,y;\n        ll w;\n        scanf(\"%d%d%lld\",&x,&y,&w);\n        e[x].push_back(make_pair(y,w));\n        e[y].push_back(make_pair(x,w));\n    }\n    dfs(1,0);\n    for(int i=0;i<(int)base.size();i++)\n        t[n]=min(t[n],t[n]^base[i]);\n    return 0*printf(\"%lld\\n\",t[n]);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Shortest Path Problem .json",
    "editorial_link": "https://codeforces.com//blog/entry/53986",
    "editorial": "Let\u00e2\u0080\u0099s find some path from to . Let its length be , then the answer to\r\nthe problem can be represented as , where is the total length of some\r\nset of cycles in the graph (they can be disconnected; it doesn\u00e2\u0080\u0099t matter\r\nbecause we can traverse the whole graph and return to the starting\r\nvertex with cost ).Let\u00e2\u0080\u0099s treat each cycle\u00e2\u0080\u0099s cost as a vector where is\r\nthe -th bit in binary representation of cycle\u00e2\u0080\u0099s cost. We can use\r\nGaussian elimination to find the independent set of vectors that\r\ngenerates all these vectors. To do this, let\u00e2\u0080\u0099s build any spanning tree\r\nof the graph, and then for any edge not belonging to the spanning tree\r\nwe can try to add to the independent set ( is the length of the path\r\nfrom the root to in the spanning tree). When trying to add some vector,\r\nwe firstly need to check if it can be represented as a combination of\r\nsome vectors from the set, and only if it\u00e2\u0080\u0099s impossible, then we add it\r\nto the set. The number of vectors in the set won\u00e2\u0080\u0099t exceed , so we can\r\nuse Gaussian elimination to check if the vector is a combination of\r\nelements from the set.Then, after we found the basis, let\u00e2\u0080\u0099s build the\r\nanswer greedily from the most significant bit to the least: we will\r\ncheck if we can set the current bit so it is equal to the corresponding\r\nbit of , while maintaining all the previous bit. To check it, we also\r\ncan use Gaussian elimination.\r\n"
}