{
    "link": "https://codeforces.com//contest/797/problem/F",
    "problemId": "103033",
    "problem_idx": "F",
    "shortId": "797F",
    "contest_number": "797",
    "problem_submissions": {
        "F": [
            26392422,
            26393656,
            26389980,
            26393053,
            26392770,
            26393200,
            26401058,
            26400600,
            26393845,
            26538858,
            26399564,
            26404933
        ],
        "E": [
            26384593,
            26386641,
            26387413,
            26384179,
            26390646,
            26385085,
            26384145,
            26385218,
            26385422,
            26383237,
            26385301,
            26385048,
            26387123,
            26383986,
            26385186,
            26383971,
            26385690,
            26386757,
            26387505
        ],
        "D": [
            26383853,
            26385506,
            26386518,
            26386869,
            26388006,
            26386076,
            26386759,
            26387198,
            26384655,
            26384909,
            26400699,
            26386910,
            26386839,
            26385859,
            26386865,
            26387340,
            26385970,
            26387551,
            26388539,
            26386426
        ],
        "C": [
            26382881,
            26383936,
            26385046,
            26385741,
            26385840,
            26383373,
            26384974,
            26383476,
            26383055,
            26382583,
            26383371,
            26383953,
            26383269,
            26383187,
            26384315,
            26382972,
            26384647,
            26385000,
            26382428
        ],
        "B": [
            26382061,
            26382225,
            26383108,
            26384548,
            26383123,
            26382179,
            26382430,
            26382528,
            26381992,
            26382016,
            26382484,
            26382716,
            26382235,
            26382138,
            26382837,
            26382347,
            26382410,
            26382477,
            26381988
        ],
        "A": [
            26381703,
            26381847,
            26382576,
            26383357,
            26382358,
            26381775,
            26381835,
            26381732,
            26381711,
            26381736,
            26381944,
            26381723,
            26381696,
            26381784,
            26381802,
            26381687,
            26381777,
            26381801,
            26381706
        ]
    },
    "name": "F. Mice and Holes",
    "statement": "One day Masha came home and noticed mice in the corridor of her flat. Of\r\ncourse, she shouted loudly, so scared mice started to run to the holes\r\nin the corridor.The corridor can be represeted as a numeric axis with\r\nmice and holes on it. th mouse is at the coordinate , and th hole at\r\ncoordinate . th hole has enough room for mice, so not more than mice can\r\nenter this hole.What is the minimum sum of distances that mice have to\r\ngo through so that they all can hide in the holes? If th mouse goes to\r\nthe hole , then its distance is .Print the minimum sum of distances.\r\n",
    "solutions": [
        "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n#include <complex>\n\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool smin(T &a, const T &b)   { return a > b ? a = b : a;    }\ntemplate<typename T> inline bool smax(T &a, const T &b)   { return a < b ? a = b : a;    }\n\ntypedef long long LL;\nconst int N = (int) 5005, mod = (int) 0;\nint a[N], pos[N], p[N], c[N];\nlong long sum[N];\npair<int, int> sr[N];\nlong long get(int hole, int l, int r) {\n\tint m = pos[hole];\n\tif (l < m && m < r) {\n\t\treturn get(hole, l, m) + get(hole, m, r);\n\t}\n\tif (r <= m) {\n\t\treturn (r - l) * (long long) p[hole] - (sum[r] - sum[l]);\n\t} else if (l >= m) {\n\t\treturn sum[r] - sum[l] - (r - l) * (long long) p[hole];\n\t}\n\tassert(0);\n\n}\nlong long odp[N], dp[N];\nint dq[N];\nvoid solve(int hole, int ul, int ur, int optl, int optr) {\n\tif (ur - ul <= 0) return;\n\tint h = 0;\n\tint t = 0;\n\tdp[0] = 0;\n\tdq[t++] = 0;\n\tfor (int j = 1; j <= ur; ++j) {\n\t\twhile (t - h > 0 && j - dq[h] > c[hole]) ++h;\n\t\twhile (t - h > 0 && odp[j] <= odp[dq[t - 1]] + get(hole, dq[t - 1], j)) --t;\n\t\tdq[t++] = j;\n\t\tdp[j] = odp[dq[h]] + get(hole, dq[h], j);\n\t\t//best = min(odp[j + 1], best + abs(p[hole] - a[j]));\n\t}\n/*\tint m = ul + ur >> 1;\n\tint opt = optl;\n\tdp[m] = 1e18;\n\tfor (int j = optl; j <= min(optr, m); ++j) {\n\t\tif (m - j > c[hole]) continue;\n\t\tlong long nwcost = odp[j] + get(hole, j, m);\n\t\tif (nwcost <= dp[m]) {\n\t\t\tdp[m] = nwcost;\n\t\t\topt = j;\n\t\t}\n\t}\n\tsolve(hole, ul, m, optl, opt);\n\tsolve(hole, m + 1, ur, opt, optr); */\n}\nint32_t main() {\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int j = 0; j < n; ++j) {\n\t\tcin >> a[j];\n\t}\n\tsort(a, a + n);\n\tfor (int j = 0; j < n; ++j)\n\t\tsum[j + 1] = sum[j] + a[j];\n\tint ss = 0;\n\tfor (int j = 0; j < m; ++j) {\n\t\tcin >> sr[j].first >> sr[j].second;\n\t\tss += sr[j].second;\n\t}\n\tsort(sr, sr + m);\n\tfor (int j = 0; j < m; ++j) {\n\t\tp[j] = sr[j].first, c[j] = sr[j].second;\n\t\tint &pt = pos[j];\n\t\twhile (a[pt] <= p[j]) ++pt;\n\t}\n\tif (ss < n) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tmemset(dp, 63, sizeof dp);\n\tdp[0] = 0;\n\tfor (int j = 0; j < m; ++j) {\n\t\tmemcpy(odp, dp, sizeof dp);\n\t\tmemset(dp, 0, sizeof dp);\n\t\tsolve(j, 0, n + 1, 0, n);\n\t}\n\tcout << dp[n] << endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Mice and Holes.json",
    "editorial_link": "https://codeforces.com//blog/entry/51588",
    "editorial": "This problem can be solved using dynamic programming. Let be the answer\r\nfor first holes and mice.If the constraints were smaller, then we could\r\ncalculate it in just trying to update by all values of where and\r\ncalculating the cost to transport all mice from the segment to th\r\nhole.To calculate this in , we will use a deque maintaining the minimum\r\n(or a queue implemented on two stacks, for example). We iterate on and\r\nupdate all the values of with the help of this deque: for each index we\r\ninsert a value in the deque equal to , where is the total distance\r\nrequired to move first mice to hole . Updating the value is just\r\nextracting the minimum and adding this to it. Don\u00e2\u0080\u0099t forget to delete\r\nvalues from the deque to ensure that we don\u00e2\u0080\u0099t send too much mice to the\r\nhole.Time complexity: .\r\n"
}