{
    "link": "https://codeforces.com//contest/792/problem/C",
    "problemId": "100426",
    "problem_idx": "C",
    "shortId": "792C",
    "contest_number": "792",
    "problem_submissions": {
        "F": [
            25853903,
            25865237
        ],
        "E": [
            25848693,
            25847349,
            25847865,
            25848336,
            25849755,
            25879304,
            25850910,
            25852379,
            25850927,
            25851533,
            25846730,
            25852220,
            25853726,
            25852467,
            25850303,
            25850709,
            25864381,
            25958829
        ],
        "D": [
            25844822,
            25845472,
            25845024,
            25845925,
            25845207,
            25846638,
            25846685,
            25844772,
            25847053,
            25844370,
            25847875,
            25846005,
            25849330,
            25846978,
            25848700,
            25846288,
            25847259,
            25846482,
            25845802
        ],
        "C": [
            25843667,
            25844426,
            25843057,
            25844653,
            25843502,
            25843226,
            25845206,
            25847034,
            25852877,
            25845288,
            25853718,
            25845444,
            25844045,
            25846780,
            25853037,
            25847850,
            25843767,
            25844267,
            25844868,
            25843846
        ],
        "B": [
            25841582,
            25841630,
            25841112,
            25842707,
            25841353,
            25841339,
            25842555,
            25842111,
            25842036,
            25841205,
            25844104,
            25841963,
            25843854,
            25843428,
            25846396,
            25841879,
            25841715,
            25842437,
            25841499
        ],
        "A": [
            25840740,
            25840467,
            25840502,
            25840643,
            25840525,
            25840508,
            25840842,
            25840507,
            25840672,
            25840477,
            25843123,
            25840669,
            25840725,
            25840826,
            25845885,
            25840646,
            25840520,
            25840707,
            25840777
        ]
    },
    "name": "C. Divide by Three",
    "statement": "A positive integer number is written on a blackboard. It consists of not\r\nmore than digits. You have to transform it into a number by erasing some\r\nof the digits, and you want to erase as few digits as possible.The\r\nnumber is called beautiful if it consists of at least one digit, doesn’t\r\nhave leading zeroes and is a multiple of . For example, , , are\r\nbeautiful numbers, and , , are not.Write a program which for the given\r\nwill find a beautiful number such that can be transformed into this\r\nnumber by erasing as few digits as possible. You can erase an arbitraty\r\nset of digits. For example, they don’t have to go one after another in\r\nthe number .If it’s impossible to obtain a beautiful number, print . If\r\nthere are multiple answers, print any of them.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nstring s;\n\nvector<string> vv;\n\nstring tr(string s) {\n\tint now = 0;\n\twhile (now + 1 < s.size() && s[now] == '0')\n\t\t++now;\n\treturn s.substr(now);\n}\n\nint main() {\n\tcin >> s;\n\tint sum = 0;\n\tfor (int i = 0; i < s.size(); ++i)\n\t\tsum += (s[i] - '0');\n\tsum %= 3;\n\tif (sum != 0) {\n\t\tfor (int i = s.size() - 1; i >= 0; --i) {\n\t\t\tif ((s[i] - '0') % 3 == sum) {\n\t\t\t\tstring t = s.substr(0, i) + s.substr(i + 1);\n\t\t\t\tt = tr(t);\n\t\t\t\tif (!t.empty())\n\t\t\t\t\tvv.push_back(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint p1 = -1;\n\t\tfor (int i = s.size() - 1; i >= 0; --i) {\n\t\t\tif ((s[i] - '0') % 3 == 0)\n\t\t\t\tcontinue;\n\t\t\tif ((s[i] - '0') % 3 == sum)\n\t\t\t\tcontinue;\n\t\t\tif (p1 == -1) {\n\t\t\t\tp1 = i;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring t = s.substr(0, i) + s.substr(i + 1, p1 - i - 1) + s.substr(p1 + 1);\n\t\t\tt = tr(t);\n\t\t\tif (!t.empty())\n\t\t\t\tvv.push_back(t);\n\t\t\tbreak;\n\t\t}\n\t}\n\telse {\n\t\ts = tr(s);\n\t\tif (!s.empty())\n\t\t\tvv.push_back(s);\n\t}\n\tstring ans = \"\";\n\tfor (string t: vv)\n\t\tif (t.size() > ans.size())\n\t\t\tans = t;\n\tif (ans.empty())\n\t\tcout << -1 << \"\\n\";\n\telse\n\t\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Divide by Three.json",
    "editorial_link": "https://codeforces.com//blog/entry/51254",
    "editorial": "Letâs declare a function which takes number as a string and erases\r\nminimal number of digits in substring from -nd to last character to\r\nobtain beautiful number.Note that if the answer for given string exists,\r\nthen this function will erase no more than digits. If the number is\r\ndivisible by then sum of its digits is also divisible by . So here are\r\nthe only options for the function: Sum of digits is already equal to\r\nmodulo . Thus you donât have to erase any digits. There exists such a\r\ndigit that equals sum modulo . Then you just have to erase this digit.\r\nAll of the digits are neither divisible by , nor equal to sum modulo .\r\nSo two of such digits will sum up to number, which equals sum modulo ( ,\r\n). Let positions of non-zero numbers be . Then you can easily see that\r\nits enough to check only three function outputs: on substrings , . We\r\nimply that all digits to the left of the taken non-zero digit are\r\nerased. As we can erase no more than digits, these options will cover\r\nall the cases.If there exists no answer for any of substrings, than you\r\nneed to check if the number contains it will be answer in that case. If\r\nthere is no , then answer is .Otherwise the answer is the function\r\noutput of maximal length.Overall complexity: .\r\n",
    "hint": []
}