{
    "link": "https://codeforces.com//contest/1494/problem/D",
    "problemId": "913253",
    "problem_idx": "D",
    "shortId": "1494D",
    "contest_number": "1494",
    "problem_submissions": {
        "F": [
            108939157,
            108939159,
            108941615,
            108940380,
            108936690,
            108949404,
            108939049,
            108976002,
            109259098,
            114355817,
            114300723,
            109105687,
            108952860
        ],
        "E": [
            108917863,
            108917179,
            108917875,
            108920789,
            108924713,
            108911681,
            108911479,
            108897566,
            108915498,
            108912071,
            108919266,
            108916392,
            108921553,
            108913575,
            108918608,
            108932427,
            108930755,
            108916943
        ],
        "D": [
            108912126,
            108910016,
            108906106,
            108913150,
            108917394,
            108924483,
            108905862,
            108906091,
            108907069,
            108901150,
            108912737,
            108909289,
            108909997,
            108901829,
            108912218,
            108906405,
            108912083
        ],
        "C": [
            108899963,
            108897106,
            108898254,
            108894965,
            108905337,
            108946028,
            108904267,
            108903529,
            108894912,
            108900440,
            108893773,
            108903235,
            108896270,
            108897186,
            108897145,
            108895547,
            108897140,
            108897478,
            108896885
        ],
        "B": [
            108887573,
            108887648,
            108887088,
            108887791,
            108891184,
            108886492,
            108887122,
            108892723,
            108887267,
            108886341,
            108887638,
            108889178,
            108889629,
            108886479,
            108887946,
            108888463,
            108886261
        ],
        "A": [
            108886097,
            108886134,
            108886049,
            108886041,
            108887001,
            108886021,
            108886051,
            108886176,
            108886040,
            108887099,
            108886184,
            108886195,
            108886220,
            108886015,
            108886138,
            108886325,
            108885985
        ]
    },
    "name": "D. Dogeforces",
    "statement": "The Dogeforces company has k employees. Each employee, except for\r\nlower-level employees, has at least 2 subordinates. Lower-level\r\nemployees have no subordinates. Each employee, except for the head of\r\nthe company, has exactly one direct supervisor. The head of the company\r\nis a direct or indirect supervisor of all employees. It is known that in\r\nDogeforces, each supervisor receives a salary strictly more than all his\r\nsubordinates.The full structure of the company is a secret, but you know\r\nthe number of lower-level employees and for each pair of lower-level\r\nemployees, the salary of their common supervisor is known (if there are\r\nseveral such supervisors, then the supervisor with the minimum salary).\r\nYou have to restore the structure of the company.\r\n",
    "solutions": [
        "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\n/*struct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    vector<int> value;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        value[v] = 0;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            value[v]^=value[parent[v]];\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b, int w) {\n        find_set(a);\n        find_set(b);\n\n        w^=value[a]; w^=value[b];\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            value[b] = w;\n            sz[a] += sz[b];\n        }\n    }\n\n    int val(int v)\n    {\n        find_set(v); return value[v];\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        value.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};*/\n\nint n;\nvector<vector<int>> a;\n\nvector<pair<int, int>> edges;\n\n\nvector<int> vals;\nint idx;\n\n\nint solve(vector<int> cur)\n{\n\n    //cout<<\"Solving for: \"; for (auto it: cur) cout<<it<<' '; cout<<endl;\n\n    if (cur.size()==1)\n    {\n        vals[cur[0]] = a[cur[0]][cur[0]];\n        return cur[0];\n    }\n\n    int maxx = 0;\n    int k = cur.size();\n    for (int i = 0; i<k; i++)\n        for (int j = 0; j<k; j++) maxx = max(maxx, a[cur[i]][cur[j]]);\n\n    vals.push_back(maxx);\n\n    int cur_idx = idx;\n    idx++;\n\n\n    vector<vector<int>> vecs;\n    for (auto it: cur)\n    {\n        bool found = false;\n        for (auto &vec: vecs)\n        {\n            if (a[vec.back()][it] < maxx)\n            {\n                found = true; vec.push_back(it); break;\n            }\n        }\n        if (!found)\n        {\n            vecs.push_back({it});\n        }\n    }\n\n    for (auto vec: vecs)\n    {\n        int son_idx = solve(vec);\n        edges.push_back(mp(son_idx, cur_idx));\n    }\n\n\n    return cur_idx;\n\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    cin>>n;\n\n    idx = n;\n    vals.resize(n);\n\n    a = vector<vector<int>>(n, vector<int>(n));\n    for (int i = 0; i<n; i++)\n    {\n        for (int j = 0; j<n; j++) cin>>a[i][j];\n    }\n\n    vector<int> guys(n); for (int i = 0; i<n; i++) guys[i] = i;\n\n    int root = solve(guys);\n\n    cout<<vals.size()<<endl;\n    for (auto it: vals) cout<<it<<' ';\n    cout<<endl;\n    cout<<root+1<<endl;\n    for (auto it: edges) cout<<it.first+1<<' '<<it.second+1<<endl;\n\n\n\n\n\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dsu",
        "greedy",
        "sortings",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Dogeforces.json",
    "editorial_link": "https://codeforces.com//blog/entry/88344",
    "editorial": "We can solve the problem recursively from the root to the leaves. Letâs\r\nmaintain a list of leaf indices for the current subtree. If the list\r\nsize is equal to , then we can stop our recursion. Otherwise, we have to\r\nfind the value of the root of the current subtree and split all leaves\r\nbetween child nodes. The root value is the maximum value of among all\r\npairs belonging to a subtree (since the current root has at least child\r\nnodes, there is a pair of leaves for which the current root is the least\r\ncommon ancestor). If the value of the least common ancestor of the\r\nleaves and () is less than the value of the current root then and belong\r\nto the same child of the root. Using this fact, we can split all the\r\nleaves between the child nodes and then restore the subtrees for them\r\nrecursively.\r\n",
    "hint": []
}