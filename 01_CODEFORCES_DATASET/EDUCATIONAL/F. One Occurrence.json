{
    "link": "https://codeforces.com//contest/1000/problem/F",
    "problemId": "193659",
    "problem_idx": "F",
    "shortId": "1000F",
    "contest_number": "1000",
    "problem_submissions": {
        "G": [
            39718562,
            39719543,
            39731044,
            39745353
        ],
        "E": [
            39714455,
            39714380,
            39711396,
            39717344,
            39715216,
            39714198,
            39717274,
            39714849,
            39716315,
            39710033,
            39719087,
            39714919,
            39717269,
            39719314,
            39715149,
            39718067,
            39717227,
            39715819,
            39716698,
            39714956
        ],
        "F": [
            39713460,
            39707084,
            39730558,
            39730512,
            39730296,
            39730270,
            39730256,
            39730239,
            39730221,
            39730211,
            39730154,
            39730127,
            39730113,
            39730102,
            39730087,
            39730070,
            39730054,
            39730038,
            39730029,
            39715353,
            39714587,
            39718375,
            39717776,
            39709495,
            39717288,
            39718275,
            39707695,
            39714904,
            39719561,
            39715859,
            39716309,
            41303353,
            41303333,
            39722296,
            39721263,
            39713335,
            39715356,
            39718313,
            39720559,
            39710578
        ],
        "D": [
            39712036,
            39711284,
            39709815,
            39710348,
            39711331,
            39711469,
            39714291,
            39712438,
            39711322,
            39711986,
            39710186,
            39711296,
            39710596,
            39711080,
            39713011,
            39710269,
            39712921,
            39714356,
            39714670,
            39711775
        ],
        "C": [
            39709789,
            39708273,
            39708437,
            39708497,
            39707490,
            39709711,
            39711470,
            39710285,
            39709663,
            39712657,
            39707054,
            39709385,
            39707981,
            39708400,
            39708339,
            39708579,
            39711654,
            39712280,
            39711950,
            39712277
        ],
        "B": [
            39708786,
            39709741,
            39707292,
            39706954,
            39708573,
            39707999,
            39708997,
            39708329,
            39708450,
            39715462,
            39712282,
            39720742,
            39715883,
            39713342,
            39706846,
            39709837,
            39709912,
            39706999,
            39710604,
            39710245,
            39709682,
            39713043
        ],
        "A": [
            39706953,
            39704546,
            39704256,
            39704278,
            39704401,
            39705070,
            39705301,
            39704306,
            39704491,
            39713520,
            39705360,
            39704298,
            39704641,
            39704487,
            39704983,
            39705096,
            39704429,
            39704776,
            39705211,
            39713228
        ]
    },
    "name": "F. One Occurrence",
    "statement": "You are given an array a consisting of n integers, and q queries to it.\r\ni-th query is denoted by two integers l_i and r_i. For each query, you\r\nhave to find integer that occurs in the subarray of a from index l_i to\r\nindex r_i (a subarray is a contiguous subsegment of an array). For\r\nexample, if a = [1, 1, 2, 3, 2, 4], then for query (l_i = 2, r_i = 6)\r\nthe subarray we are interested in is [1, 2, 3, 2, 4], and possible\r\nanswers are 1, 3 and 4; for query (l_i = 1, r_i = 2) the subarray we are\r\ninterested in is [1, 1], and there is no such element that occurs\r\nexactly once.Can you answer all of the queries?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, \"r\", stdin );\n#define fout(s) freopen( s, \"w\", stdout );\n\nconst long long N = 500500;\nconst long long Q = 2e18;\nconst long long mod = 998244353;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nint a[N];\nint l[N];\nint r[N];\nint ans[N];\nint used[N];\npair < int, int > t[4 * N];\n\nvoid upd(int x, int l, int r, int g, int y)\n{\n        if(l == r){\n                t[x] = {y, a[l]};\n                return;\n        }\n        int m = (l + r) / 2;\n        if(g <= m){\n                upd(x * 2, l, m, g, y);\n        }\n        else{\n                upd(x * 2 + 1, m + 1, r, g, y);\n        }\n        t[x] = max(t[x * 2], t[x * 2 + 1]);\n}\n\npair < int, int > get(int x, int l, int r, int tl, int tr)\n{\n        if(tl > tr){\n                return {0, 0};\n        }\n        if(l == tl && r == tr){\n                return t[x];\n        }\n        int m = (l + r) / 2;\n        return max(get(x * 2, l, m, tl, min(m, tr)), get(x * 2 + 1, m + 1, r, max(m + 1, tl), tr));\n}\n\nvoid solve()\n{\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                cin >> a[i];\n                l[i] = used[a[i]];\n                used[a[i]] = i;\n        }\n        for(int i = 1; i < N; i++){\n                used[i] = n + 1;\n        }\n        vector < pair < int, pair < int, int > > > v;\n        for(int i = n; i >= 1; i--){\n                r[i] = used[a[i]];\n                used[a[i]] = i;\n                v.push_back({l[i], {r[i], i}});\n        }\n        sort(v.begin(), v.end());\n        int q;\n        cin >> q;\n        vector < pair < int, pair < int, int > > > qu;\n        for(int i = 1; i <= q; i++){\n                int l, r;\n                cin >> l >> r;\n                qu.push_back({l, {r, i}});\n        }\n        sort(qu.begin(), qu.end());\n        int h = 0;\n        for(auto p: qu){\n                while(h < v.size() && v[h].fi < p.fi){\n                        upd(1, 1, n, v[h].se.se, v[h].se.fi);\n                        h++;\n                }\n                auto g = get(1, 1, n, p.fi, p.se.fi);\n                if(g.fi > p.se.fi){\n                        ans[p.se.se] = g.se;\n                }\n        }\n        for(int i = 1; i <= q; i++){\n                cout << ans[i] << \"\\n\";\n        }\n}\n\nbool mtest = false; int main()\n{\n        //fin(\"input.txt\");\n        //fout(\"output.txt\");\n        //fin(\"island.in\");\n        //fout(\"island.out\");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. One Occurrence.json",
    "editorial_link": "https://codeforces.com/blog/entry/60288",
    "editorial": "Suppose all queries have the same right border . Then the answer for the\r\nquery can be some integer such that the last occurence of on the prefix\r\nof the array is inside the segment, but the second to last occurence is\r\noutside the segment (or even does not exist). More formally, let be the\r\nmaximum index such that and (or if there is no such ); the answer to the\r\nquery is some number such that and (and is the rightmost occurence of in\r\nthe segment ). For a fixed right border , we can build a segment tree\r\nwhich for every index such that is the rightmost occurence of on stores\r\nthe value of ; and if we query minimum on the segment in such tree, we\r\ncan try to find the answer. Let the position of minimum be . If , then\r\ncan be the answer; otherwise there is no answer.But this is too slow\r\nsince we can\u00e2\u0080\u0099t afford to build a segment tree for every possible value\r\nof . There are two methods how to deal with this problem: you may sort\r\nall queries by their right borders and maintain the segment tree while\r\nshifting the right border (when going from to , we have to update the\r\nvalues in the positions and ), or we may use a persistent segment tree\r\nand get an online solution.We tried to eliminate solutions using Mo\u00e2\u0080\u0099s\r\nalgorithm, but in fact it\u00e2\u0080\u0099s possible to squeeze some implementations of\r\nit into TL. There are two optimizations that might help there. When\r\ndividing the elements into blocks, we may sort the first block in the\r\nascending order of right borders, the second in descending, the third in\r\nascending order again, and so on. And also it\u00e2\u0080\u0099s possible to obtain a\r\nMo-based solution with worst case complexity of if we maintain the set\r\nof possible answers using sqrt decomposition on it.\r\n"
}