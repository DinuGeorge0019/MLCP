{"link": "https://codeforces.com//contest/1841/problem/D", "problemId": "1962593", "problem_idx": "D", "shortId": "1841D", "contest_number": "1841", "problem_submissions": {"F": [209441446, 209449956, 209447296, 209453943, 209449863, 209446444, 209454347, 209678776, 209452092, 209454468, 209458945, 209453449, 209451716, 209465466, 209464638, 209461720, 209460276, 209459819, 209458504, 209458152, 209453975, 209486469, 209486319, 209486054, 209459375, 209456147, 209463444, 209466329, 209466771, 209609259, 209462972, 209467839, 209463203], "E": [209420520, 209430600, 209434973, 209427885, 209438551, 209434946, 209433065, 209431302, 209443745, 209434541, 209438545, 209438034, 209444420, 209422689, 209420477, 209458913, 209440856, 209447420, 209460885, 209429843], "D": [209412776, 209418240, 209420286, 209421079, 209475842, 209428591, 209423202, 209420942, 209417076, 209424719, 209423326, 209425276, 209464164, 209425284, 209430127, 209413537, 209411059, 209426861, 209442988, 209439319, 209441486, 209421279], "C": [209400973, 209405174, 209401188, 209410862, 209415662, 209408968, 209409562, 209408253, 209414636, 209413637, 209410942, 209421138, 209419542, 209405503, 209431667, 209409468, 209421971, 209433784, 209431914, 209416091], "B": [209395303, 209394968, 209391532, 209391351, 209395229, 209393535, 209397133, 209392667, 209405342, 209396380, 209399455, 209465838, 209465126, 209398959, 209401067, 209395449, 209398643, 209399436, 209394778, 209404496, 209407644, 209470007], "A": [209388179, 209388192, 209387876, 209387947, 209389004, 209388221, 209388559, 209388171, 209393927, 209405420, 209388257, 209389054, 209391461, 209401864, 209387894, 209390233, 209387972, 209392823, 209407382, 209389297]}, "name": "D. Pairs of Segments", "statement": "Two segments [l_1, r_1] and [l_2, r_2] intersect if there exists at\r\nleast one x such that l_1\r\nle x\r\nle r_1 and l_2\r\nle x\r\nle r_2.An array of segments [[l_1, r_1], [l_2, r_2],\r\ndots, [l_k, r_k]] is called if k is even, and is possible to split the\r\nelements of this array into\r\nfrac{k}{2} pairs in such a way that: every element of the array belongs\r\nto exactly one of the pairs; segments in each pair intersect with each\r\nother; segments in different pairs do not intersect. For example, the\r\narray [[2, 4], [9, 12], [2, 4], [7, 7], [10, 13], [6, 8]] is beautiful,\r\nsince it is possible to form 3 pairs as follows: the first element of\r\nthe array (segment [2, 4]) and the third element of the array (segment\r\n[2, 4]); the second element of the array (segment [9, 12]) and the fifth\r\nelement of the array (segment [10, 13]); the fourth element of the array\r\n(segment [7, 7]) and the sixth element of the array (segment [6, 8]). As\r\nyou can see, the segments in each pair intersect, and no segments from\r\ndifferent pairs intersect.You are given an array of n segments [[l_1,\r\nr_1], [l_2, r_2],\r\ndots, [l_n, r_n]]. You have to remove the minimum possible number of\r\nelements from this array so that the resulting array is beautiful.\r\n", "solutions": ["#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << \" \"; cout << v[i];\n    }\n    cout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\nint cnt[4005][4005];\nvoid solve() {\n    int n; cin >> n;\n    vector<int> l(n), r(n);\n    rep(i, n) {\n        cin >> l[i] >> r[i]; r[i]++;\n    }\n    vector<int> vx;\n    rep(i, n) {\n        vx.push_back(l[i]);\n        vx.push_back(r[i]);\n    }\n    sort(all(vx));\n    vx.erase(unique(all(vx)), vx.end());\n    rep(i, n) {\n        l[i] = lower_bound(all(vx), l[i]) - vx.begin();\n        r[i] = lower_bound(all(vx), r[i]) - vx.begin();\n    }\n    int sz = vx.size();\n    rep(i, sz)Rep(j, i+1, sz) {\n        cnt[i][j] = 0;\n    }\n    rep(i, n)Rep(j, i + 1, n) {\n        int le = max(l[i], l[j]);\n        int ri = min(r[i], r[j]);\n        if (le < ri) {\n            le = min(l[i], l[j]);\n            ri = max(r[i], r[j]);\n            cnt[le][ri]++;\n            //cout << \"hello\\n\";\n            //cout << le << \" \" << ri << \"\\n\";\n        }\n    }\n    rep(i, sz) {\n        Rep(j, i + 1, sz) {\n            if (j + 1 < sz)cnt[i][j + 1] += cnt[i][j];\n        }\n    }\n    rep(j, sz) {\n        per(i, j) {\n            if (i > 0)cnt[i - 1][j] += cnt[i][j];\n        }\n    }\n    vector<int> dp(sz);\n    rep(i, sz) {\n        Rep(j, i + 1, sz) {\n            int val = dp[i];\n            if (cnt[i][j] > 0)val += 2;\n            chmax(dp[j], val);\n        }\n    }\n    //cout << cnt[0][1] << \"\\n\";\n    //coutarray(dp);\n    int ans = n - dp.back();\n    cout << ans << \"\\n\";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "greedy", "sortings", "two pointers"], "dificulty": "2000", "interactive": false}