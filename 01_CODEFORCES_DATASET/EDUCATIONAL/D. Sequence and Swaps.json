{
    "link": "https://codeforces.com//contest/1455/problem/D",
    "problemId": "815717",
    "problem_idx": "D",
    "shortId": "1455D",
    "contest_number": "1455",
    "problem_submissions": {
        "E": [
            100080155,
            100079381,
            100078449,
            100069275,
            100012146,
            100015897,
            100022845,
            100016854,
            100016418,
            100020237,
            100020046,
            100028425,
            100029068,
            100034230,
            100029402,
            100051234,
            100023750,
            100021088,
            100056948,
            100056790,
            100027354,
            100027044,
            100024946,
            100025731
        ],
        "F": [
            100078450,
            100025388,
            100024460,
            100036395,
            100043068,
            100042389,
            100045529,
            100060216,
            100044226,
            100043456,
            100052099,
            100046594,
            100048576,
            103031134
        ],
        "D": [
            100078448,
            100005946,
            100008735,
            100010384,
            100011871,
            100006215,
            100010441,
            100013223,
            100016383,
            100022310,
            100014989,
            100021069,
            100012652,
            100006839,
            100007553,
            100009178,
            100010622,
            100017383
        ],
        "B": [
            100078446,
            99997720,
            100001458,
            100004151,
            99999328,
            99996708,
            100002292,
            99997258,
            100004647,
            100006268,
            100003306,
            100007106,
            100000261,
            99994951,
            99999396,
            99999653,
            100001010,
            99999631,
            100001869
        ],
        "G": [
            100042304,
            100034172,
            100133399,
            100133353,
            100129809,
            100466593,
            100055077,
            100046402,
            100109589,
            102917383,
            100053452
        ],
        "C": [
            100002522,
            100004461,
            100006266,
            100003366,
            100000366,
            100005398,
            100004212,
            100008763,
            100010135,
            100006377,
            100015174,
            100005740,
            99999911,
            100008765,
            100001216,
            100002465,
            100006020
        ],
        "A": [
            99993343,
            99993450,
            99994266,
            99993464,
            99993313,
            99995467,
            99993403,
            99995627,
            99997962,
            99993689,
            99993532,
            99993614,
            99993321,
            99993386,
            99994914,
            99994222,
            99993353
        ]
    },
    "name": "D. Sequence and Swaps",
    "statement": "You are given a sequence a consisting of n integers a_1, a_2,\r\ndots, a_n, and an integer x. Your task is to make the sequence a sorted\r\n(it is considered sorted if the condition a_1\r\nle a_2\r\nle a_3\r\nle\r\ndots\r\nle a_n holds).To make the sequence sorted, you may perform the following\r\noperation any number of times you want (possibly zero): choose an\r\ninteger i such that 1\r\nle i\r\nle n and a_i > x, and swap the values of a_i and x.For example, if a =\r\n[0, 2, 3, 5, 4], x = 1, the following sequence of operations is\r\npossible: choose i = 2 (it is possible since a_2 > x), then a = [0, 1,\r\n3, 5, 4], x = 2; choose i = 3 (it is possible since a_3 > x), then a =\r\n[0, 1, 2, 5, 4], x = 3; choose i = 4 (it is possible since a_4 > x),\r\nthen a = [0, 1, 2, 3, 4], x = 5. Calculate the minimum number of\r\noperations you have to perform so that a becomes sorted, or report that\r\nit is impossible.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int N, X;\n    cin >> N >> X;\n    vector<int> A(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    int last = -1;\n\n    for (int i = 0; i < N - 1; i++)\n        if (A[i] > A[i + 1])\n            last = i;\n\n    int ops = 0;\n\n    for (int i = 0; i <= last; i++)\n        if (A[i] > X) {\n            ops++;\n            swap(A[i], X);\n        }\n\n    if (!is_sorted(A.begin(), A.end()))\n        ops = -1;\n\n    cout << ops << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "greedy",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Sequence and Swaps.json",
    "editorial_link": "https://codeforces.com//blog/entry/85186",
    "editorial": "The main fact that allows us to solve this problem is that the value of\r\nalways increases after swaps, and since the resulting sequence should be\r\nsorted, the indices of elements we swap with also increase.This\r\nobservation is actually enough for us to implement a dynamic programming\r\nsolution of the form \"dp_{i, j} is the minimum number of actions we have\r\nto perform to reach the following situation: the last integer we swapped\r\nwith was , and the current value of is \". Depending on your\r\nimplementation, it works either in or in .But there exists a much\r\nsimpler to code greedy solution: scan the array from left to right until\r\nit is sorted, and find the first element such that we can apply the\r\noperation to it (and apply that operation to it). Implementing it in or\r\neven in is easy, but proving it is a bit harder. The key fact that is\r\nrequired to prove it is that if we can apply an operation to some\r\nposition, but don\u00e2\u0080\u0099t do it and instead apply this operation to some\r\nposition to the right of that one, the elements on these two positions\r\nare no longer sorted (if we can apply the operation to some position ,\r\nthen , but if we apply the operation to position instead, then after it\r\n). Since we can\u00e2\u0080\u0099t go backward, the resulting array cannot be sorted by\r\nany means that\u00e2\u0080\u0099s why we can\u00e2\u0080\u0099t skip elements in this greedy solution.\r\n"
}