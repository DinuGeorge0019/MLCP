{"link": "https://codeforces.com//contest/1728/problem/G", "problemId": "1534228", "problem_idx": "G", "shortId": "1728G", "contest_number": "1728", "problem_submissions": {"F": [171415471, 171408709, 171477755, 171477598, 171800837, 171602685, 171508405, 171615612, 171428158, 171416710, 171516704], "G": [171401437, 171423625, 171401320, 171405459, 171408910, 171400855, 171410753, 171399735, 171425286, 171424973, 171424864, 171421363, 171409384, 171429440, 171419291, 171421745, 171401911, 171420331, 171494040, 171406232, 171419649, 171415822, 171442989, 171426124, 171423998, 171422898, 171422786, 171419842], "E": [171378857, 171391875, 171380622, 171383139, 171380478, 171390287, 171381329, 171385138, 171384190, 171396093, 171392841, 171388311, 171403618, 171390049, 171393452, 171494181, 171455206, 171419342, 171391692, 171398313, 171393739, 171428155, 171396053, 171400068], "D": [171364431, 171379034, 171368807, 171365018, 171370163, 171375547, 171369467, 171380229, 171364084, 171374772, 171368217, 171377453, 171410355, 171379812, 171386430, 171377364, 171385449, 171375075, 171380828, 171376969], "C": [171356021, 171355657, 171354790, 171355489, 171357376, 171364423, 171358552, 171371507, 171356927, 171358656, 171358481, 171361890, 171364747, 171361193, 171494234, 171359234, 171364539, 171370274, 171358915, 171369689, 171370585], "B": [171350944, 171350546, 171350225, 171351747, 171353484, 171350234, 171353700, 171367743, 171353076, 171355275, 171352643, 171355734, 171359875, 171351546, 171353658, 171357176, 171361933, 171353420, 171361436, 171361759], "A": [171346435, 171346486, 171346382, 171346456, 171348074, 171346466, 171346859, 171352332, 171346599, 171349231, 171346445, 171346558, 171348949, 171346594, 171346485, 171349162, 171347108, 171346675, 171346628, 171349812]}, "name": "G. Illumination", "statement": "Consider a segment [0, d] of the coordinate line. There are n lanterns\r\nand m points of interest in this segment.For each lantern, you can\r\nchoose its power an integer between 0 and d (inclusive). A lantern with\r\ncoordinate x illuminates the point of interest with coordinate y if |x -\r\ny| is less than or equal to the power of the lantern.A way to choose the\r\npower values for all lanterns is considered if every point of interest\r\nis illuminated by at least one lantern.You have to process q queries.\r\nEach query is represented by one integer f_i. To answer the i-th query,\r\nyou have to: add a lantern on coordinate f_i; calculate the number of\r\nvalid ways to assign power values to all lanterns, and print it modulo\r\n998244353; remove the lantern you just added.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < '-')\n\t\t;\n\tif (c == '-') {\n\t\tint x = gc - '0';\n\t\twhile (gc >= '0') x = x * 10 + c - '0';\n\t\treturn -x;\n\t}\n\tint x = c - '0';\n\twhile (gc >= '0') x = x * 10 + c - '0';\n\treturn x;\n}\n#undef gc\n\nconst int P = 998244353;\n\nint add(int x, int y) {\n\tif (x + y >= P) return x + y - P;\n\treturn x + y;\n}\n\nint sub(int x, int y) {\n\tif (x < y) return x - y + P;\n\treturn x - y;\n}\n\nint mul(int x, int y) { return 1ull * x * y % P; }\n\nint fpow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t\ty >>= 1;\n\t\tx = mul(x, x);\n\t}\n\treturn ans;\n}\n\ninline void upd(int& x, int y) { x = add(x, y); }\n\nconst int N = 3e5 + 5;\n\nint ans[N], p[N], a[25], c[25][25], v[25][25];\nint d, n, m, q;\n\nint getpos(int x) {\n\tint ans = 0;\n\twhile (ans < m && a[ans + 1] <= x) ++ans;\n\treturn ans;\n}\n\nint main() {\n#ifdef local\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\td = read();\n\tn = read();\n\tm = read();\n\tfor (int i = 1; i <= n; i++) p[i] = read();\n\tfor (int i = 1; i <= m; i++) a[i] = read();\n\tsort(a + 1, a + m + 1);\n\tfor (int l = 0; l <= m + 1; l++) {\n\t\tfor (int r = l; r <= m + 1; r++) c[l][r] = 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint pos = getpos(p[i]);\n\t\tfor (int l = 0; l <= pos; l++) {\n\t\t\tfor (int r = pos + 1; r <= m + 1; r++) {\n\t\t\t\tint lim = d + 1;\n\t\t\t\tif (l != 0) lim = min(lim, p[i] - a[l]);\n\t\t\t\tif (r != m + 1) lim = min(lim, a[r] - p[i]);\n\t\t\t\tc[l][r] = mul(c[l][r], lim);\n\t\t\t\t// fprintf(stderr, \"c[%d][%d] = %d, lim = %d\\n\", l, r, c[l][r], lim);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tint now = 1, las = 0;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tnow = mul(now, c[las][j + 1]);\n\t\t\t\tlas = j + 1;\n\t\t\t}\n\t\t}\n\t\tnow = mul(now, c[las][m + 1]);\n\t\tlas = 0;\n\t\tif (__builtin_popcount(i) & 1) now = sub(0, now);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tupd(v[las][j + 1], now);\n\t\t\t\tlas = j + 1;\n\t\t\t}\n\t\t}\n\t\tupd(v[las][m + 1], now);\n\t}\n\tfor (int x = 1; x <= d - 1; x++) {\n\t\tint pos = getpos(x);\n\t\tfor (int l = 0; l <= pos; l++) {\n\t\t\tfor (int r = pos + 1; r <= m + 1; r++) {\n\t\t\t\tint lim = d + 1;\n\t\t\t\tif (l != 0) lim = min(lim, x - a[l]);\n\t\t\t\tif (r != m + 1) lim = min(lim, a[r] - x);\n\t\t\t\tupd(ans[x], mul(lim, v[l][r]));\n\t\t\t}\n\t\t}\n\t}\n\tq = read();\n\twhile (q--) {\n\t\tint x = read();\n\t\tprintf(\"%d\\n\", ans[x]);\n\t}\n}"], "input": "", "output": "", "tags": ["binary search", "bitmasks", "brute force", "combinatorics", "dp", "math", "two pointers"], "dificulty": "2700", "interactive": false}