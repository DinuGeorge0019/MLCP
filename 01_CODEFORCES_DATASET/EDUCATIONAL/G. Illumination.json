{
    "link": "https://codeforces.com//contest/1728/problem/G",
    "problemId": "1534228",
    "problem_idx": "G",
    "shortId": "1728G",
    "contest_number": "1728",
    "problem_submissions": {
        "F": [
            171415471,
            171408709,
            171477755,
            171477598,
            171800837,
            171602685,
            171508405,
            171615612,
            171428158,
            171416710,
            171516704
        ],
        "G": [
            171401437,
            171423625,
            171401320,
            171405459,
            171408910,
            171400855,
            171410753,
            171399735,
            171425286,
            171424973,
            171424864,
            171421363,
            171409384,
            171429440,
            171419291,
            171421745,
            171401911,
            171420331,
            171494040,
            171406232,
            171419649,
            171415822,
            171442989,
            171426124,
            171423998,
            171422898,
            171422786,
            171419842
        ],
        "E": [
            171378857,
            171391875,
            171380622,
            171383139,
            171380478,
            171390287,
            171381329,
            171385138,
            171384190,
            171396093,
            171392841,
            171388311,
            171403618,
            171390049,
            171393452,
            171494181,
            171455206,
            171419342,
            171391692,
            171398313,
            171393739,
            171428155,
            171396053,
            171400068
        ],
        "D": [
            171364431,
            171379034,
            171368807,
            171365018,
            171370163,
            171375547,
            171369467,
            171380229,
            171364084,
            171374772,
            171368217,
            171377453,
            171410355,
            171379812,
            171386430,
            171377364,
            171385449,
            171375075,
            171380828,
            171376969
        ],
        "C": [
            171356021,
            171355657,
            171354790,
            171355489,
            171357376,
            171364423,
            171358552,
            171371507,
            171356927,
            171358656,
            171358481,
            171361890,
            171364747,
            171361193,
            171494234,
            171359234,
            171364539,
            171370274,
            171358915,
            171369689,
            171370585
        ],
        "B": [
            171350944,
            171350546,
            171350225,
            171351747,
            171353484,
            171350234,
            171353700,
            171367743,
            171353076,
            171355275,
            171352643,
            171355734,
            171359875,
            171351546,
            171353658,
            171357176,
            171361933,
            171353420,
            171361436,
            171361759
        ],
        "A": [
            171346435,
            171346486,
            171346382,
            171346456,
            171348074,
            171346466,
            171346859,
            171352332,
            171346599,
            171349231,
            171346445,
            171346558,
            171348949,
            171346594,
            171346485,
            171349162,
            171347108,
            171346675,
            171346628,
            171349812
        ]
    },
    "name": "G. Illumination",
    "statement": "Consider a segment [0, d] of the coordinate line. There are n lanterns\r\nand m points of interest in this segment.For each lantern, you can\r\nchoose its power an integer between 0 and d (inclusive). A lantern with\r\ncoordinate x illuminates the point of interest with coordinate y if |x -\r\ny| is less than or equal to the power of the lantern.A way to choose the\r\npower values for all lanterns is considered if every point of interest\r\nis illuminated by at least one lantern.You have to process q queries.\r\nEach query is represented by one integer f_i. To answer the i-th query,\r\nyou have to: add a lantern on coordinate f_i; calculate the number of\r\nvalid ways to assign power values to all lanterns, and print it modulo\r\n998244353; remove the lantern you just added.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < '-')\n\t\t;\n\tif (c == '-') {\n\t\tint x = gc - '0';\n\t\twhile (gc >= '0') x = x * 10 + c - '0';\n\t\treturn -x;\n\t}\n\tint x = c - '0';\n\twhile (gc >= '0') x = x * 10 + c - '0';\n\treturn x;\n}\n#undef gc\n\nconst int P = 998244353;\n\nint add(int x, int y) {\n\tif (x + y >= P) return x + y - P;\n\treturn x + y;\n}\n\nint sub(int x, int y) {\n\tif (x < y) return x - y + P;\n\treturn x - y;\n}\n\nint mul(int x, int y) { return 1ull * x * y % P; }\n\nint fpow(int x, int y) {\n\tint ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = mul(ans, x);\n\t\ty >>= 1;\n\t\tx = mul(x, x);\n\t}\n\treturn ans;\n}\n\ninline void upd(int& x, int y) { x = add(x, y); }\n\nconst int N = 3e5 + 5;\n\nint ans[N], p[N], a[25], c[25][25], v[25][25];\nint d, n, m, q;\n\nint getpos(int x) {\n\tint ans = 0;\n\twhile (ans < m && a[ans + 1] <= x) ++ans;\n\treturn ans;\n}\n\nint main() {\n#ifdef local\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\td = read();\n\tn = read();\n\tm = read();\n\tfor (int i = 1; i <= n; i++) p[i] = read();\n\tfor (int i = 1; i <= m; i++) a[i] = read();\n\tsort(a + 1, a + m + 1);\n\tfor (int l = 0; l <= m + 1; l++) {\n\t\tfor (int r = l; r <= m + 1; r++) c[l][r] = 1;\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tint pos = getpos(p[i]);\n\t\tfor (int l = 0; l <= pos; l++) {\n\t\t\tfor (int r = pos + 1; r <= m + 1; r++) {\n\t\t\t\tint lim = d + 1;\n\t\t\t\tif (l != 0) lim = min(lim, p[i] - a[l]);\n\t\t\t\tif (r != m + 1) lim = min(lim, a[r] - p[i]);\n\t\t\t\tc[l][r] = mul(c[l][r], lim);\n\t\t\t\t// fprintf(stderr, \"c[%d][%d] = %d, lim = %d\\n\", l, r, c[l][r], lim);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < (1 << m); i++) {\n\t\tint now = 1, las = 0;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tnow = mul(now, c[las][j + 1]);\n\t\t\t\tlas = j + 1;\n\t\t\t}\n\t\t}\n\t\tnow = mul(now, c[las][m + 1]);\n\t\tlas = 0;\n\t\tif (__builtin_popcount(i) & 1) now = sub(0, now);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif ((i >> j) & 1) {\n\t\t\t\tupd(v[las][j + 1], now);\n\t\t\t\tlas = j + 1;\n\t\t\t}\n\t\t}\n\t\tupd(v[las][m + 1], now);\n\t}\n\tfor (int x = 1; x <= d - 1; x++) {\n\t\tint pos = getpos(x);\n\t\tfor (int l = 0; l <= pos; l++) {\n\t\t\tfor (int r = pos + 1; r <= m + 1; r++) {\n\t\t\t\tint lim = d + 1;\n\t\t\t\tif (l != 0) lim = min(lim, x - a[l]);\n\t\t\t\tif (r != m + 1) lim = min(lim, a[r] - x);\n\t\t\t\tupd(ans[x], mul(lim, v[l][r]));\n\t\t\t}\n\t\t}\n\t}\n\tq = read();\n\twhile (q--) {\n\t\tint x = read();\n\t\tprintf(\"%d\\n\", ans[x]);\n\t}\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "combinatorics",
        "dp",
        "math",
        "two pointers"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Illumination.json",
    "editorial_link": "https://codeforces.com//blog/entry/106805",
    "editorial": "Letâs start without the queries. How to calculate the number of ways for\r\nthe given lanterns?First, itâs much easier to calculate the number of\r\nbad ways some point of interest is not illuminated. If at least one\r\npoint of interest is not illuminated, then all lanterns have power lower\r\nthan the distance from them to this point of interest. More importantly,\r\nitâs less than . Thus, the number of good ways is minus the number of\r\nbad ways.Letâs use inclusion-exclusion. For a mask of non-illuminated\r\npoints of interest, letâs calculate the number of ways to assign the\r\npowers to the lanterns in such a way that at least these points of\r\ninterest are not illuminated. All other points can be either illuminated\r\nor not. Letâs call it . With the values for all masks, the answer is the\r\nsum of over all masks.How to calculate the value for the mask? First,\r\nletâs do it in for each mask. Each lantern can have any power from to\r\nthe distance to the closest point of interest inside the mask\r\nnon-inclusive. Thus, we can iterate over the lanterns and find the\r\nclosest point to each of them, then multiply the number of ways for all\r\nlanterns.Letâs calculate it the other way around. Initialize the answers\r\nfor the masks with . Then iterate over the lantern and the point of\r\ninterest that will be the closest non-illuminated one to this lantern.\r\nLet the distance between them be some value . Which masks will this pair\r\naffect? Let the lantern be to the right of that point of interest. The\r\nopposite can be handled similarly.All points to the left of the chosen\r\npoint can be in either state. All points between the chosen one and the\r\nlantern must be illuminated. All points to the right of the lantern and\r\nwith distance smaller than must also be illumunated. All point to the\r\nright of these can be in either state. Thus, the masks look like\r\n\"**..**1000..000**..**\", where 1 denotes the chosen non-illuminated\r\npoint.All masks that correspond to this template will be multiplied by .\r\nYou have to be careful when there are two points of interest with the\r\nsame distance to some lantern one to the left of it and one to the right\r\nof it. In particular, in one case, you should force illumination on all\r\npoints with distance . In another case, you should force illumination on\r\nall points with distance .How to multiply fast enough? Weâll use a\r\ntechnique called sum-over-subsets. Letâs express the template in terms\r\nof submasks. For a template \"***100000***\", all submasks of\r\n\"111100000111\" will be multiplied by . However, we accidentally\r\nmultiplied masks of form \"***000000***\" too. Letâs cancel them by\r\ndividing the submasks of \"111000000111\" by . Record all multiplications\r\nfor all pairs, them force push them into submasks with sum-over-subsets\r\n(well, product-over-subsets in this case :)).Now we have the values of\r\nfor all masks in basically , give or take the time to find the points\r\nthat must be forced illuminated (extra from lower_bound or two pointers,\r\nwhich is not really faster).Now for the queries. How does the answer\r\nchange after an extra lantern is added? Again, letâs iterate over the\r\nclosest point of interest and find the mask template. All masks\r\ncorresponding to this template will get multiplied by . Thus, the answer\r\nwill change by the sum of values of these masks, multiplied by ,\r\nincluding the inclusion-exclusion coefficient. How to handle that? Well,\r\nyet another sum-over-subsets. Just collect the sum of values over the\r\nsubmasks beforehand and use these during the query. That gives us an per\r\nquery.Overall complexity: .\r\n",
    "hint": []
}