{
    "link": "https://codeforces.com//contest/616/problem/C",
    "problemId": "45346",
    "problem_idx": "C",
    "shortId": "616C",
    "contest_number": "616",
    "problem_submissions": {
        "F": [
            15300786,
            15299144,
            15300407,
            15308014,
            15298659,
            15302230,
            15343881,
            15307137,
            15302999,
            15320984,
            15302125,
            15301613,
            15302389,
            16304774
        ],
        "E": [
            15294336,
            15296370,
            15296055,
            15299653,
            15294693,
            15294203,
            15295924,
            15295314,
            15296974,
            15298724,
            15298421,
            15296783,
            15296993,
            15297669,
            15298444,
            15297290,
            15298438,
            15297005,
            15297742,
            15294191,
            15296949
        ],
        "D": [
            15292434,
            15293329,
            15294173,
            15292753,
            15307747,
            15291461,
            15292962,
            15291869,
            15293349,
            15311532,
            15309884,
            15290895,
            15292938,
            15291478,
            15291995,
            15292322,
            15292029,
            15294220,
            15293485,
            15292134,
            15291999,
            15296150,
            15292776
        ],
        "C": [
            15291423,
            15291977,
            15292603,
            15292078,
            15290640,
            15291851,
            15293736,
            15291941,
            15292201,
            15291847,
            15290459,
            15291357,
            15293820,
            15291327,
            15293027,
            15292213,
            15291382,
            15291194,
            15291415,
            15291744
        ],
        "B": [
            15289897,
            15289576,
            15290149,
            15290568,
            15289808,
            15289641,
            15290425,
            15289878,
            15289727,
            15289729,
            15289456,
            15290134,
            15289943,
            15289714,
            15290242,
            15290500,
            15289857,
            15289675,
            15289746,
            15290000
        ],
        "A": [
            15289459,
            15289308,
            15289551,
            15290016,
            15289415,
            15289340,
            15289832,
            15289405,
            15289403,
            15289339,
            15289246,
            15289704,
            15289544,
            15307602,
            15289399,
            15289609,
            15325750,
            15289995,
            15289432,
            15289359,
            15289427,
            15289492
        ]
    },
    "name": "C. The Labyrinth",
    "statement": "You are given a rectangular field of cells. Each cell is either empty or\r\nimpassable (contains an obstacle). Empty cells are marked with \u201d,\r\nimpassable cells are marked with \u201d. Let\u2019s call two empty cells if they\r\nshare a side.Let\u2019s call a any non-extendible set of cells such that any\r\ntwo of them are connected by the path of adjacent cells. It is a typical\r\nwell-known definition of a connected component.For each impassable cell\r\nimagine that it is an empty cell (all other cells remain unchanged) and\r\nfind the size (the number of cells) of the connected component which\r\ncontains . You should do it for each impassable cell independently.The\r\nanswer should be printed as a matrix with rows and columns. The -th\r\nsymbol of the -th row should be \"\" if the cell is empty at the start.\r\nOtherwise the -th symbol of the -th row should contain the only digit -\r\nthe answer modulo . The matrix should be printed without any spaces.To\r\nmake your output faster it is recommended to build the output as an\r\narray of strings having length and print it as a sequence of lines. It\r\nwill be much faster than writing character-by-character.As input/output\r\ncan reach huge size it is recommended to use fast input/output methods:\r\nfor example, prefer to use instead of in C++, prefer to use instead of\r\nin .\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef double ld;\n\nusing namespace std;\n\nconst int MAXN = 1010;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nchar arr[MAXN][MAXN];\nchar ans[MAXN][MAXN];\nint cl[MAXN][MAXN];\nint n, m;\nint cc[MAXN * MAXN];\n\n\nvoid dfs(int x, int y, int c) {\n\tcl[x][y] = c;\n\t++cc[c];\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint x2 = x + dx[i];\n\t\tint y2 = y + dy[i];\n\t\tif (x2 < 0 || y2 < 0 || x2 >= n || y2 >= m)\n\t\t\tcontinue;\n\t\tif (arr[x2][y2] != '.' || cl[x2][y2] != -1)\n\t\t\tcontinue;\n\t\tdfs(x2, y2, c);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < n; ++i)\n\t\tscanf(\" %s\", arr[i]);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tcl[i][j] = -1;\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j)\n\t\t\tif (cl[i][j] == -1 && arr[i][j] == '.')\n\t\t\t\tdfs(i, j, cnt), cnt++;\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif (arr[i][j] == '.')\n\t\t\t\tans[i][j] = '.';\n\t\t\telse {\n\t\t\t\tvector<int> vv;\n\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\tint x2 = i + dx[k];\n\t\t\t\t\tint y2 = j + dy[k];\n\t\t\t\t\tif (x2 < 0 || y2 < 0 || x2 >= n || y2 >= m)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (arr[x2][y2] != '.')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvv.push_back(cl[x2][y2]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tint aa = 1;\n\t\t\t\tsort(vv.begin(), vv.end());\n\t\t\t\tvv.resize(unique(vv.begin(), vv.end()) - vv.begin());\n\t\t\t\tfor (auto it: vv)\n\t\t\t\t\taa += cc[it];\n\t\t\t\taa %= 10;\n\t\t\t\tans[i][j] = (char)('0' + aa);\n\t\t\t}\n\t\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tprintf(\"%s\\n\", ans[i]);\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. The Labyrinth.json",
    "editorial_link": "https://codeforces.com//blog/entry/22712",
    "editorial": "Let\u00e2\u0080\u0099s enumerate all the connected components, store their sizes and for\r\neach empty cell store the number of it\u00e2\u0080\u0099s component. It can be done with\r\na single dfs. Now the answer for some impassable cell is equal to one\r\nplus the sizes of all different adjacent connected components. Adjacent\r\nmeans the components of cells adjacent to the current impassable cell\r\n(in general case each unpassable cell has four adjacent cells). C++\r\nsolution Complexity: .\r\n"
}