{
    "link": "https://codeforces.com//contest/1476/problem/D",
    "problemId": "881705",
    "problem_idx": "D",
    "shortId": "1476D",
    "contest_number": "1476",
    "problem_submissions": {
        "G": [
            105913861,
            105944560,
            105939646,
            105923864,
            105934727,
            105937410,
            105935084
        ],
        "E": [
            105882617,
            105882778,
            105909929,
            105895535,
            105907314,
            105884522,
            105881576,
            105889515,
            105891029,
            105897702,
            105902043,
            105904102,
            105909138,
            105899391,
            105895913,
            105970659,
            105900322,
            105895017,
            105909435,
            105904890
        ],
        "D": [
            105872560,
            105872434,
            105872750,
            105874690,
            105888665,
            105869131,
            105875044,
            105876453,
            105878527,
            105868738,
            105873785,
            105878660,
            105867024,
            105887668,
            105877564,
            105874050,
            105886943,
            105878950,
            105887180
        ],
        "C": [
            105865233,
            105867141,
            105882799,
            105868688,
            105880463,
            105863560,
            105866932,
            105868909,
            105872012,
            105880982,
            105868535,
            105869296,
            105877911,
            105869813,
            105870709,
            105864538,
            105872343,
            105869274,
            105872286
        ],
        "B": [
            105854579,
            105853524,
            105854032,
            105858231,
            105859227,
            105853292,
            105853315,
            105856769,
            105859608,
            105859912,
            105854635,
            105856976,
            105853309,
            105859505,
            105858926,
            105855562,
            105860530,
            105853840,
            105860836
        ],
        "A": [
            105850622,
            105850650,
            105852722,
            105850820,
            105851490,
            105850582,
            105850685,
            105850741,
            105851248,
            105853267,
            105850773,
            105851638,
            105850636,
            105851230,
            105852640,
            105850665,
            105852244,
            105850634,
            105851161
        ],
        "F": [
            131696052,
            106171367
        ]
    },
    "name": "D. Journey",
    "statement": "There are n + 1 cities, numbered from 0 to n. n roads connect these\r\ncities, the i-th road connects cities i - 1 and i (i\r\nin [1, n]).Each road has a direction. The directions are given by a\r\nstring of n characters such that each character is either or . If the\r\ni-th character is , it means that the i-th road initially goes from the\r\ncity i to the city i - 1; otherwise it goes from the city i - 1 to the\r\ncity i.A traveler would like to visit as many cities of this country as\r\npossible. Initially, they will choose some city to start their journey\r\nfrom. Each day, the traveler go from the city where they currently are\r\nto a neighboring city using one of the roads, and they can go along a\r\nroad only if it is directed in the same direction they are going; i. e.,\r\nif a road is directed from city i to the city i + 1, it is possible to\r\ntravel from i to i + 1, but not from i + 1 to i. After the traveler\r\nmoves to a neighboring city, roads change their directions . If the\r\ntraveler cannot go from their current city to a neighboring city, their\r\njourney ends; it is also possible to end the journey whenever the\r\ntraveler wants to.The goal of the traveler is to visit as many different\r\ncities as possible (they can visit a city multiple times, but only the\r\nfirst visit is counted). For each city i, calculate the maximum number\r\nof different cities the traveler can visit during if they start in the\r\ncity i.\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\nusing namespace std;\n//dengyaotriangle!\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);\n    int t;\n    cin>>t;\n    while(t--){\n        int n;\n        cin>>n;\n        string s;\n        cin>>s;\n        vector<int> ll(n),lr(n);\n        ll[0]=1;\n        for(int i=1;i<n;i++){\n            if(s[i]==s[i-1])ll[i]=1;\n            else ll[i]=ll[i-1]+1;\n        }\n        lr[n-1]=1;\n        for(int i=n-2;i>=0;i--){\n            if(s[i]==s[i+1])lr[i]=1;\n            else lr[i]=lr[i+1]+1;\n        }\n        for(int i=0;i<=n;i++){\n            int ans=1;\n            if(i)ans+=s[i-1]=='L'?ll[i-1]:0;\n            if(i!=n)ans+=s[i]=='R'?lr[i]:0;\n            cout<<ans<<' ';\n        }\n        cout<<'\\n';\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "dsu",
        "implementation"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Journey.json",
    "editorial_link": "https://codeforces.com//blog/entry/87356",
    "editorial": "There are two key observations to this problem: after each pair of\r\nmoves, the directions go back to the original ones; after each move, we\r\ncan immediately go back (and combining these observations, we can derive\r\nthat if we go from city to some other city , we can always go back). One\r\nof the solutions we can write using these observations is to build an\r\nundirected graph on vertices. Each vertex represents a pair , where is\r\nthe city we are currently staying in, and is the number of moves we\r\nmade, modulo . Since each move is to a neighboring city, each vertex is\r\nunreachable from , and vice versa. And since we can always go back, and\r\neach pair of steps doesnât change the directions, this graph is actually\r\nan undirected one. So, we can find the connected components of this\r\ngraph using DFS/BFS/DSU, and for each city , print the size of the\r\ncomponent the vertex belongs to.Another solution is to find the leftmost\r\nand the rightmost city reachable from each city. For example, finding\r\nthe leftmost reachable city can be done with the following dynamic\r\nprogramming: let be the leftmost city reachable from . Then, if we canât\r\ngo left from , ; if we can make only one step to the left from , ; and\r\nif we can make two steps, we can take the answer from the city : . The\r\nsame approach can be used to calculate the rightmost reachable city.\r\n",
    "hint": []
}