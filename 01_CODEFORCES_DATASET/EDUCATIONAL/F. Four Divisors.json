{
    "link": "https://codeforces.com//contest/665/problem/F",
    "problemId": "55556",
    "problem_idx": "F",
    "shortId": "665F",
    "contest_number": "665",
    "problem_submissions": {
        "F": [
            35437149,
            27600620,
            27600570,
            27600365,
            207086930,
            17511081,
            17511048,
            17408931,
            17465318,
            17465113,
            17465105,
            17421220,
            17419616,
            17419504,
            17407442
        ],
        "E": [
            17404108,
            17403997,
            17404019,
            17404185,
            17404405,
            17405241,
            17404852,
            17406609,
            17403872,
            17404958,
            17406585,
            17405102,
            17402241,
            17404889,
            17406152,
            17407503,
            17407294,
            17402667,
            17407651,
            17402391
        ],
        "D": [
            17402746,
            17402888,
            17403061,
            17402886,
            17403632,
            17402659,
            17403180,
            17402538,
            17403092,
            17404017,
            17402765,
            17404460,
            17403586,
            17404039,
            17404874,
            17597162,
            17597147,
            17405860,
            17404856,
            17403614,
            17402947,
            17403487
        ],
        "B": [
            17402058,
            17402143,
            17401985,
            17401812,
            17402480,
            17401996,
            17402111,
            17401950,
            17401883,
            17402289,
            17402172,
            17404614,
            17405448,
            17402800,
            17402279,
            17402724,
            17403040,
            17404322,
            17403505,
            17404527
        ],
        "C": [
            17401652,
            17401814,
            17402423,
            17402078,
            17401921,
            17401528,
            17401657,
            17401538,
            17402228,
            17402780,
            17401867,
            17401866,
            17401442,
            17401822,
            17401577,
            17403531,
            17403479,
            17401483,
            17404073,
            17401636,
            17404128
        ],
        "A": [
            17401480,
            17401614,
            17401638,
            17401502,
            17401615,
            17401450,
            17401531,
            17402688,
            17401495,
            17401597,
            17401511,
            17401510,
            17405192,
            17401618,
            17401993,
            17401713,
            17402074,
            17402469,
            17404975,
            17408296,
            17406598
        ]
    },
    "name": "F. Four Divisors",
    "statement": "If an integer is divisible by another integer , then is called the\r\ndivisor of .For example: has positive divisors. They are , , , , and\r\n.Let s define a function number of integers between and (inclusive)\r\nwhich has exactly four positive divisors.Between and only the integers ,\r\nand has exactly four positive divisors. So, .You are given an integer .\r\nYou have to calculate .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nstruct Primes\n{\n\tvector <ll> w, dp;\n\tint gdz(ll v)\n\t{\n\t\tif (v<=w.back()/v)\n\t\t\treturn v-1;\n\t\treturn w.size()-w.back()/v;\n\t}\n\tll pi(ll n)\n\t{\n\t\tfor (ll i=1; i*i<=n; i++)\n\t\t{\n\t\t\tw.push_back(i);\n\t\t\tif ((n/i)!=i)\n\t\t\t\tw.push_back(n/i);\n\t\t}\n\t\tsort(w.begin(), w.end());\n\t\tfor (ll i : w)\n\t\t\tdp.push_back(i-1);\n\t\tfor (ll i=1; (i+1)*(i+1)<=n; i++)\n\t\t{\n\t\t\tif (dp[i]==dp[i-1])\n\t\t\t\tcontinue;\n\t\t\tfor (int j=(int)w.size()-1; w[j]>=(i+1)*(i+1); j--)\n\t\t\t\tdp[j]-=dp[gdz(w[j]/(i+1))]-dp[i-1];\n\t\t}\n\t\treturn dp.back();\n\t}\n};\n\nlong long wyn;\n\nvoid brut(long long n)\n{\n\tint lim=1000*1000;\n\tint sito[lim+7];\n\tlong long ret=0;\n\tfor (int i=1; i<=lim; i++)\n\t\tsito[i]=0;\n\tPrimes janusz;\n\tjanusz.pi(n);\n\tvector <long long> pier;\n\tfor (int i=2; i<=lim; i++)\n\t{\n\t\tif (sito[i])\n\t\t\tcontinue;\n\t\tpier.push_back(i);\n\t\tlong long v=i;\n\t\tv*=i;\n\t\tv*=i;\n\t\tif (v<=n)\n\t\t\twyn++;\n\t\tfor (int j=2*i; j<=lim; j+=i)\n\t\t\tsito[j]=1;\n\t}\n\tint odj=0;\n\tfor (int i=2; i<=lim; i++)\n\t{\n\t\tif (sito[i])\n\t\t\tcontinue;\n\t\tlong long v=i;\n\t\tv*=i;\n\t\tif (v<=n)\n\t\t{\n\t\t\tint bsa=0;\n\t\t\tint bsb=pier.size();\n\t\t\tint bss;\n\t\t\twhile(bsa<bsb)\n\t\t\t{\n\t\t\t\tbss=(bsa+bsb)>>1;\n\t\t\t\tif (pier[bss]*pier[bss]>(n/i))\n\t\t\t\t\tbsb=bss;\n\t\t\t\telse\n\t\t\t\t\tbsa=bss+1;\n\t\t\t}\n\t\t\todj++;\n\t\t\twyn+=janusz.dp[janusz.gdz(n/i)]-odj;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tlong long n;\n\tscanf(\"%lld\", &n);\n\tbrut(n);\n\tprintf(\"%lld\\n\", wyn);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "math",
        "number theory",
        "sortings",
        "two pointers"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Four Divisors.json",
    "editorial_link": "https://codeforces.com//blog/entry/44466",
    "editorial": "The editorial for this problem is a little modification of the materials\r\nfrom the lecture of Mikhail Tikhomirov Endagorion of the autumn of 2015\r\nin Moscow Institute of Physics and Technology. Thanks a lot to\r\nEndagorion for that materials. Easy to see that only the numbers of the\r\nform and (for different prime ) have exactly four positive divisors. We\r\ncan easily count the numbers of the form in , where is the number from\r\nthe problem statement. Now let and be the number of primes from to .\r\nLet\u00e2\u0080\u0099s iterate over all the values . Easy to see that . So for fixed we\r\nshould increase the answer by the value . So the task is ot to find the\r\nnumber of primes not exceeding , for all . Denote the -th prime number.\r\nDenote the number of such that , and all prime divisors of are at least\r\n(note that 1 is counted in all , since the set of its prime divisors is\r\nempty). satisfy a simple recurrence: (since = 2) , hence Let be the\r\nsmallest prime greater than . Then (by definition, the first summand\r\naccounts for all the primes not less than ). If we evaluate the\r\nrecurrence straightforwardly, all the reachable states will be of the\r\nform . We can also note that if and are both greater than , then . Thus,\r\nfor each it makes sense to keep only values of . Instead of evaluating\r\nall DP states straightforwardly, we perform a two-step process: Choose .\r\nRun recursive evaluation of . If we want to compute a state with ,\r\nmemorize the query \u00e2\u0080\u009ccount the numbers not exceeding with all prime\r\ndivisors at least \u00e2\u0080\u009d. Answer all the queries off-line: compute the sieve\r\nfor numbers up to , then sort all numbers by the smallest prime divisor.\r\nNow all queries can be answered using RSQ structure. Store all the\r\nanswers globally. Run recurisive evaluation of yet again. If we want to\r\ncompute a state with , then we must have preprocessed a query for this\r\nstate, so take it from the global set of answers. The performance of\r\nthis approach relies heavily on the number of queries we have to\r\npreprocess. Statement. . Proof: Each state we have to preprocess is\r\nobtained by following a transition from some greater state. It follows\r\nthat doesn\u00e2\u0080\u0099t exceed the total number of states for . The preprocessing\r\nof queries can be done in , and it is the heaviest part of the\r\ncomputation. Choosing optimal , we obtain the complexity . C++ solution\r\n"
}