{
    "link": "https://codeforces.com//contest/1036/problem/G",
    "problemId": "216423",
    "problem_idx": "G",
    "shortId": "1036G",
    "contest_number": "1036",
    "problem_submissions": {
        "G": [
            42635175,
            42627436,
            42635430,
            42626359,
            42737989,
            42717556,
            42717524,
            42717521,
            42651041,
            42700940,
            42700625,
            54263107,
            42638239,
            42625046,
            42815013
        ],
        "B": [
            42631894,
            42635568,
            42631049,
            42642897,
            42640457,
            42621960,
            42628162,
            42621741,
            42621550,
            42618797,
            42623868,
            42633347,
            42620322,
            42622448,
            42641969,
            42624721,
            42635114,
            42625827,
            42628122,
            42634984,
            42644768
        ],
        "F": [
            42629280,
            42634265,
            42627972,
            42642001,
            42641962,
            42630707,
            42634470,
            42717490,
            42631938,
            42631850,
            42631382,
            42631058,
            42629288,
            42629020,
            42633820,
            42633355,
            42631044,
            42636476,
            42635060,
            42629290,
            42636959,
            42643700,
            42637023,
            42633474,
            42641007
        ],
        "E": [
            42626026,
            42624301,
            42644046,
            42634366,
            42634335,
            42634205,
            42630482,
            42637851,
            42633450,
            42641281,
            42638561,
            42638638,
            42639628,
            42642761,
            42644666,
            42649447,
            42648312,
            42643498,
            42631013,
            42635443,
            42642733,
            42645034,
            42634920
        ],
        "D": [
            42623581,
            42621638,
            42636628,
            42635516,
            42624651,
            42622909,
            42625901,
            42624230,
            42627616,
            42623027,
            42622706,
            42628513,
            42629952,
            42622220,
            42628717,
            42631816,
            42630498,
            42632680,
            42629722,
            42643211
        ],
        "C": [
            42622041,
            42620587,
            42639507,
            42636945,
            42623531,
            42620800,
            42624388,
            42623206,
            42625364,
            42621712,
            81464229,
            42620946,
            42626482,
            42628744,
            42619137,
            42627629,
            42632962,
            42629275,
            42630870,
            42627504,
            42631469
        ],
        "A": [
            42617741,
            42628137,
            42620189,
            42640915,
            42619770,
            42617799,
            42621837,
            42618858,
            42617734,
            42618440,
            42617898,
            42617724,
            42617895,
            42631014,
            42618014,
            42635499,
            42624408,
            42620380,
            42619824
        ]
    },
    "name": "G. Sources and Sinks",
    "statement": "You are given an acyclic directed graph, consisting of n vertices and m\r\nedges. The graph contains no multiple edges and no self-loops.The vertex\r\nis called a if it has no incoming edges. The vertex is called a if it\r\nhas no outgoing edges. These definitions imply that some vertices can be\r\nboth source and sink.The number of sources in the given graph is equal\r\nto the number of sinks in it, and each of these numbers doesn\u2019t exceed\r\n20.The following algorithm is applied to the graph: if the graph has no\r\nsources and sinks then quit; choose arbitrary source s, arbitrary sink\r\nt, add an edge from t to s to the graph and go to step 1 (that operation\r\npops s out of sources and t out of sinks). Note that s and t may be the\r\nsame vertex, then a self-loop is added. At the end you check if the\r\ngraph becomes strongly connected (that is, any vertex is reachable from\r\nany other vertex).Your task is to check that the graph becomes strongly\r\nconnected no matter the choice of sources and sinks on the second step\r\nof the algorithm.\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add(LL _x, LL _y, LL _mod=mod7){\n  _x+=_y;\n  return _x>=_mod ? _x-_mod : _x;\n}\ninline LL sub(LL _x, LL _y, LL _mod=mod7){\n  _x-=_y;\n  return _x<0 ? _x+_mod : _x;\n}\ninline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  _x*=_y;\n  return _x>=_mod ? _x%_mod : _x;\n}\nLL mypow(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 1LL;\n  LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=mul(_ret, _a, _mod);\n  return _ret;\n}\nLL mymul(LL _a, LL _x, LL _mod){\n  if(_x == 0) return 0LL;\n  LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  if(_x & 1) _ret=add(_ret, _a, _mod);\n  return _ret;\n}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nconst int N=(1<<20);\nvoid build(){\n\n}\nint n, m, od[N], id[N];\nvector<int> v[N];\nint oid[N], iid[N], tot;\nvoid init(){\n  n=getint();\n  m=getint();\n  while(m--){\n    int ui=getint();\n    int vi=getint();\n    od[ui]++;\n    id[vi]++;\n    v[ui].push_back(vi);\n  }\n  int _oid=0, _iid=0;\n  for(int i=1; i<=n; i++){\n    if(od[i]==0) oid[i]=_oid++;\n    else oid[i]=-1;\n    if(id[i]==0) iid[i]=_iid++;\n    else iid[i]=-1;\n  }\n  tot=_oid;\n}\nconst int K=20;\nint to[K], tg[N], stmp;\nvoid go(int st, int now){\n  tg[now]=stmp;\n  if(oid[now] >= 0)\n    to[st]|=(1<<oid[now]);\n  for(int nxt: v[now]){\n    if(tg[nxt] == stmp) continue;\n    go(st, nxt);\n  }\n}\nint msk[1<<K], cb[1<<K];\nvoid solve(){\n  for(int i=1; i<=n; i++)\n    if(iid[i] >= 0){\n      ++stmp;\n      go(iid[i], i);\n    }\n  for(int i=1; i<(1<<tot); i++)\n    cb[i]=cb[i>>1]+(i&1);\n  bool win=false;\n  for(int i=1; i<(1<<tot) and not win; i++){\n    for(int j=0; j<tot; j++)\n      if((i >> j) & 1)\n        msk[i]=msk[i^(1<<j)]|to[j];\n    if(i < (1<<tot)-1){\n      if(cb[i] == cb[msk[i]])\n        win=true;\n    }\n  }\n  puts(win?\"NO\":\"YES\");\n}\nint main(){\n  build();\n  //__ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dfs and similar"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Sources and Sinks.json",
    "editorial_link": "https://codeforces.com/blog/entry/61727",
    "editorial": "Since the graph is acyclic, then for every vertex there exists a path to\r\nsome sink, and to every vertex there exists a path from some source. So\r\nour problem can be reduced to the following: check that after running\r\nour algorithm, all vertices from the initial set of sources and sinks\r\nbelong to the same strongly connected component. Let be the number of\r\nsources (or sinks) in the initial graph.First of all, let\u00e2\u0080\u0099s run DFS (or\r\nany other graph traversal) from every source to form a set of reachable\r\nsinks for every source. This part of solution has complexity of .If is\r\nsome set of sources of the original graph, let be the set of sinks such\r\nthat every sink from is reachable from at least one source from . It\u00e2\u0080\u0099s\r\neasy to see that there exists some set such that , and , then the answer\r\nis if we connected the sinks from with the sources from , then any sink\r\nnot belonging to would be unreachable from any sink belonging to .\r\nChecking every possible set can be done in or in .Let\u00e2\u0080\u0099s prove that there\r\nis no such set , then the answer is . Let be an arbitrary sink of the\r\noriginal graph. Also, if is some set of sinks, let be the set of sources\r\ncontaining every source directly connected to some sink from . We can\r\nuse mathematical induction to prove that every source and every sink is\r\nreachable from in the resulting graph: Initially we state that is\r\nreachable from (quite obvious); If there is a set of sinks reachable\r\nfrom , then either (and the whole graph is reachable from ), or the\r\nnumber of sinks reachable from is at least , so some set of sinks is\r\nreachable from . So in fact checking every possible subset of sources is\r\nenough.\r\n"
}