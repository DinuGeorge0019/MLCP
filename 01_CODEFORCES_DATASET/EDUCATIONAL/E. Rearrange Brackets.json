{"link": "https://codeforces.com//contest/1821/problem/E", "problemId": "1887931", "problem_idx": "E", "shortId": "1821E", "contest_number": "1821", "problem_submissions": {"F": [202874134, 202859904, 202858229, 202861559, 202872887, 202859974, 202856919, 202868327, 202882475, 202876779, 202870359, 202879197, 202869342, 202883580, 202880852, 203770664, 202876913, 202876748, 202875057, 202875004, 202878771, 202874220, 202869665], "E": [202851078, 202851207, 202852651, 202845029, 202854281, 202869953, 202852432, 202850529, 202858695, 202849198, 202862275, 202850037, 202856111, 202863740, 202868777, 202865633, 202858626, 202863992, 202876455], "D": [202839910, 202837788, 202840967, 202837261, 202846749, 202839594, 202843601, 202842780, 202848113, 202843851, 202849914, 202836012, 202848152, 202848821, 202851217, 202856400, 202848668, 202853904, 202847149], "C": [202829555, 202830560, 202832642, 202830912, 202836849, 202832172, 202834957, 202827979, 202831432, 202832058, 202834744, 202833738, 202834719, 202831454, 202838345, 202836024, 202839448, 202842531, 202836507], "B": [202826167, 202826238, 202826386, 202826297, 202828596, 202827059, 202829521, 202825674, 202826732, 202829400, 202829530, 202825769, 202828359, 202826421, 202828754, 202830182, 202834397, 202837813, 202832744], "A": [202824330, 202824182, 202824201, 202824170, 202825451, 202824300, 202825020, 202824095, 202824581, 202824237, 202824979, 202824089, 202824602, 202824298, 202824347, 202824916, 202826157, 202824991, 202825871]}, "name": "E. Rearrange Brackets", "statement": "A regular bracket sequence is a bracket sequence that can be transformed\r\ninto a correct arithmetic expression by inserting characters \"\" and \"\"\r\nbetween the original characters of the sequence. For example: bracket\r\nsequences \"\" and \"\" are regular (the resulting expressions are: \"\" and\r\n\"\"); bracket sequences \"\", \"\" and \"\" are not. You are given a regular\r\nbracket sequence. In one move, you can remove a pair of brackets such\r\nthat the left one is an opening bracket and the right one is a closing\r\nbracket. Then concatenate the resulting parts without changing the\r\norder. The cost of this move is the number of brackets to the right of\r\nthe right bracket of this pair.The of the regular bracket sequence is\r\nthe smallest total cost of the moves required to make the sequence\r\nempty.Actually, you are not removing any brackets. Instead, you are\r\ngiven a regular bracket sequence and an integer k. You can perform the\r\nfollowing operation : extract some bracket from the sequence and insert\r\nit back at any position (between any two brackets, at the start or at\r\nthe end; possibly, at the same place it was before). After all\r\noperations are performed, the bracket sequence has to be regular. What\r\nis the smallest possible of the resulting regular bracket sequence?\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[2][7][7][7];\nll rui[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        int K;cin>>K;\n        string S;cin>>S;\n        int N=si(S);\n        for(int i=0;i<=N;i++){\n            rui[i]=0;\n        }\n        \n        for(int s=0;s<2;s++) for(int j=0;j<=K;j++) for(int k=0;k<=K;k++) for(int l=0;l<=K;l++) dp[s][j][k][l]=INF;\n        \n        for(int i=1;i<=N;i++){\n            rui[i]=rui[i-1];\n            if(S[i-1]=='(') rui[i]++;\n            if(S[i-1]==')') rui[i]--;\n        }\n        \n        dp[0][0][0][0]=0;\n        \n        for(int i=0;i<=N;i++){\n            int s=i&1,t=s^1;\n            for(int al=0;al<=K;al++){\n                for(int a=K;a>=0;a--){\n                    for(int b=K;b>=0;b--){\n                        if(dp[s][al][a][b]==INF) continue;\n                        ll d=rui[i]-a+b;\n                        if(i<N){\n                            chmin(dp[t][al+1][a+(S[i]=='(')][b+(S[i]==')')],dp[s][al][a][b]);\n                            if(S[i]=='('){\n                                chmin(dp[t][al][a][b],dp[s][al][a][b]+d);\n                            }\n                            if(S[i]==')'){\n                                if(d>=1) chmin(dp[t][al][a][b],dp[s][al][a][b]);\n                            }\n                        }\n                        \n                        if(a){\n                            chmin(dp[s][al][a-1][b],dp[s][al][a][b]+d);\n                        }\n                        if(b&&d>=1){\n                            chmin(dp[s][al][a][b-1],dp[s][al][a][b]);\n                        }\n                    }\n                }\n            }\n            if(i==N) break;\n            for(int al=0;al<=K;al++){\n                for(int a=K;a>=0;a--){\n                    for(int b=K;b>=0;b--){\n                        dp[s][al][a][b]=INF;\n                    }\n                }\n            }\n        }\n        \n        ll ans=INF;\n        \n        for(int al=0;al<=K;al++){\n            chmin(ans,dp[N&1][al][0][0]);\n        }\n        \n        cout<<ans<<\"\\n\";\n    }\n}\n"], "input": "", "output": "", "tags": ["brute force", "dp", "greedy", "sortings", "strings"], "dificulty": "2100", "interactive": false}