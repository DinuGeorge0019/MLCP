{
    "link": "https://codeforces.com//contest/1821/problem/E",
    "problemId": "1887931",
    "problem_idx": "E",
    "shortId": "1821E",
    "contest_number": "1821",
    "problem_submissions": {
        "F": [
            202874134,
            202859904,
            202858229,
            202861559,
            202872887,
            202859974,
            202856919,
            202868327,
            202882475,
            202876779,
            202870359,
            202879197,
            202869342,
            202883580,
            202880852,
            203770664,
            202876913,
            202876748,
            202875057,
            202875004,
            202878771,
            202874220,
            202869665
        ],
        "E": [
            202851078,
            202851207,
            202852651,
            202845029,
            202854281,
            202869953,
            202852432,
            202850529,
            202858695,
            202849198,
            202862275,
            202850037,
            202856111,
            202863740,
            202868777,
            202865633,
            202858626,
            202863992,
            202876455
        ],
        "D": [
            202839910,
            202837788,
            202840967,
            202837261,
            202846749,
            202839594,
            202843601,
            202842780,
            202848113,
            202843851,
            202849914,
            202836012,
            202848152,
            202848821,
            202851217,
            202856400,
            202848668,
            202853904,
            202847149
        ],
        "C": [
            202829555,
            202830560,
            202832642,
            202830912,
            202836849,
            202832172,
            202834957,
            202827979,
            202831432,
            202832058,
            202834744,
            202833738,
            202834719,
            202831454,
            202838345,
            202836024,
            202839448,
            202842531,
            202836507
        ],
        "B": [
            202826167,
            202826238,
            202826386,
            202826297,
            202828596,
            202827059,
            202829521,
            202825674,
            202826732,
            202829400,
            202829530,
            202825769,
            202828359,
            202826421,
            202828754,
            202830182,
            202834397,
            202837813,
            202832744
        ],
        "A": [
            202824330,
            202824182,
            202824201,
            202824170,
            202825451,
            202824300,
            202825020,
            202824095,
            202824581,
            202824237,
            202824979,
            202824089,
            202824602,
            202824298,
            202824347,
            202824916,
            202826157,
            202824991,
            202825871
        ]
    },
    "name": "E. Rearrange Brackets",
    "statement": "A regular bracket sequence is a bracket sequence that can be transformed\r\ninto a correct arithmetic expression by inserting characters \"\" and \"\"\r\nbetween the original characters of the sequence. For example: bracket\r\nsequences \"\" and \"\" are regular (the resulting expressions are: \"\" and\r\n\"\"); bracket sequences \"\", \"\" and \"\" are not. You are given a regular\r\nbracket sequence. In one move, you can remove a pair of brackets such\r\nthat the left one is an opening bracket and the right one is a closing\r\nbracket. Then concatenate the resulting parts without changing the\r\norder. The cost of this move is the number of brackets to the right of\r\nthe right bracket of this pair.The of the regular bracket sequence is\r\nthe smallest total cost of the moves required to make the sequence\r\nempty.Actually, you are not removing any brackets. Instead, you are\r\ngiven a regular bracket sequence and an integer k. You can perform the\r\nfollowing operation : extract some bracket from the sequence and insert\r\nit back at any position (between any two brackets, at the start or at\r\nthe end; possibly, at the same place it was before). After all\r\noperations are performed, the bracket sequence has to be regular. What\r\nis the smallest possible of the resulting regular bracket sequence?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=998244353,MAX=200005;\nconst ll INF=1LL<<60;\n\nll dp[2][7][7][7];\nll rui[MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int Q;cin>>Q;\n    while(Q--){\n        int K;cin>>K;\n        string S;cin>>S;\n        int N=si(S);\n        for(int i=0;i<=N;i++){\n            rui[i]=0;\n        }\n        \n        for(int s=0;s<2;s++) for(int j=0;j<=K;j++) for(int k=0;k<=K;k++) for(int l=0;l<=K;l++) dp[s][j][k][l]=INF;\n        \n        for(int i=1;i<=N;i++){\n            rui[i]=rui[i-1];\n            if(S[i-1]=='(') rui[i]++;\n            if(S[i-1]==')') rui[i]--;\n        }\n        \n        dp[0][0][0][0]=0;\n        \n        for(int i=0;i<=N;i++){\n            int s=i&1,t=s^1;\n            for(int al=0;al<=K;al++){\n                for(int a=K;a>=0;a--){\n                    for(int b=K;b>=0;b--){\n                        if(dp[s][al][a][b]==INF) continue;\n                        ll d=rui[i]-a+b;\n                        if(i<N){\n                            chmin(dp[t][al+1][a+(S[i]=='(')][b+(S[i]==')')],dp[s][al][a][b]);\n                            if(S[i]=='('){\n                                chmin(dp[t][al][a][b],dp[s][al][a][b]+d);\n                            }\n                            if(S[i]==')'){\n                                if(d>=1) chmin(dp[t][al][a][b],dp[s][al][a][b]);\n                            }\n                        }\n                        \n                        if(a){\n                            chmin(dp[s][al][a-1][b],dp[s][al][a][b]+d);\n                        }\n                        if(b&&d>=1){\n                            chmin(dp[s][al][a][b-1],dp[s][al][a][b]);\n                        }\n                    }\n                }\n            }\n            if(i==N) break;\n            for(int al=0;al<=K;al++){\n                for(int a=K;a>=0;a--){\n                    for(int b=K;b>=0;b--){\n                        dp[s][al][a][b]=INF;\n                    }\n                }\n            }\n        }\n        \n        ll ans=INF;\n        \n        for(int al=0;al<=K;al++){\n            chmin(ans,dp[N&1][al][0][0]);\n        }\n        \n        cout<<ans<<\"\\n\";\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "sortings",
        "strings"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Rearrange Brackets.json",
    "editorial_link": "https://codeforces.com//blog/entry/115296",
    "editorial": "First, let\u00e2\u0080\u0099s define the cost of an RBS a bit clearer. The absolute\r\nsmallest cost of removing each pair of brackets is the number of bracket\r\npairs it\u00e2\u0080\u0099s inside of. That can actually be achieved just remove the\r\npairs right to left (according to the positions of the opening brackets\r\nin pairs). So you can instead say that the total cost is the sum of\r\nbalance values after all closing brackets. Or before all opening\r\nbrackets these are actually the same.From that, we can code a classic\r\ndp. Imagine we are not moving brackets, but instead doing that in two\r\nseparate movements: put a bracket in some buffer and place it in the\r\nstring. We\u00e2\u0080\u0099d love to use the smallest answer if we processed brackets,\r\nopening brackets are in the buffer, closing brackets in the buffer and\r\nare performed. Sadly, that doesn\u00e2\u0080\u0099t really allow moving brackets to the\r\nleft, since you would have to first place the bracket, then put in it\r\nthe buffer. Does that actually break anything? Apparently, no. You can\r\nmake these buffer states from to , and think of negative values as\r\ntaking a loan. These states are enough to determine the current balance\r\nof the string. Thus, enough to both update the states and check if the\r\nstring stops being an RBS after placing a closing bracket. Overall\r\ncomplexity: . We can do it faster, but our proof isn\u00e2\u0080\u0099t that\r\nconvincing.Start by showing that there exists an optimal answer such\r\nthat each move leaves the sequence an RBS. Consider a sequence of moves\r\nthat ends up being an RBS. First, you can basically rearrange the moves\r\n(maybe adjusting the exact positions is required). Second, there exists\r\na move that, performed first, leaves an RBS. Make it and propagate the\r\nproof. You can show that such a move exists by studying some cases. Then\r\nI found it more intuitive to switch to another representation you can\r\nlook at the forest induced by the bracket sequence. The roots of the\r\ntrees in it are the topmost opening and closing brackets of the RBS.\r\nTheir children are the inner topmost brackets for each of them, and so\r\non. With that representation, the answer is actually the sum of depths\r\nof all vertices.Now for the moves. Let\u00e2\u0080\u0099s move an opening bracket to the\r\nright. We won\u00e2\u0080\u0099t move it after its corresponding closing bracket to not\r\nbreak an RBS. How will it change the tree? It will turn some children of\r\nthe corresponding vertex into the children of its parent. Thus, it will\r\ndecrease their depths by one, and the depths of their descendants as\r\nwell. How about to the left? That will turn some children of its parent\r\ninto its own children, increasing their depths (and the depths of their\r\ndescendants) by one. Similar analysis can be performed for the closing\r\nbrackets. The claim is that, in the optimal answer, you should only move\r\nopening brackets and only to the right. Then they decrease the answer\r\nindependently of each other. It\u00e2\u0080\u0099s pretty clear that the best position to\r\nmove each bracket to is as much to the right as possible place it next\r\nto its respective closing bracket. That will decrease the answer by the\r\nsize of the subtree (excluding the vertex itself).Finally, we want to\r\nchoose vertices that have the largest sum of their subtrees. That can be\r\njust done greedily pick largest ones.You don\u00e2\u0080\u0099t have to build the tree\r\nexplicitly for that the size of the subtree is half of the number of\r\nbrackets between an opening bracket and a corresponding closing one. So,\r\neverything can be processed with a stack.Overall complexity: or .\r\n"
}