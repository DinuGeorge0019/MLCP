{"link": "https://codeforces.com//contest/1473/problem/G", "problemId": "864975", "problem_idx": "G", "shortId": "1473G", "contest_number": "1473", "problem_submissions": {"G": [104324184, 104387693, 104338182, 104349212, 104348798, 104346480, 104390780, 104390610, 104390495, 104389764, 104383982, 104383801, 104346655, 104341001, 104315264, 104352224, 104352185, 104375589, 104397435, 104397194, 104376606, 104352690, 104352754, 104352534, 104398919, 104398235, 104330024], "F": [104316672, 104314197, 104321921, 104322437, 104324528, 104322986, 104314395, 104317108, 104322022, 104311306, 136810058, 104327481, 104330457, 104324027, 104334280, 104334405, 104340043, 104329360, 104332558], "E": [104307026, 104303673, 104306129, 104311187, 104320601, 104327879, 104304639, 104302012, 104310767, 104318435, 104314089, 104313021, 104316783, 104313523, 104318767, 104312111, 104314876, 104327257, 104303395], "D": [104300616, 104298125, 104298419, 104305187, 104310558, 104332950, 104295784, 104297395, 104304904, 104298645, 104306694, 104301645, 104305953, 104307851, 104307522, 104307146, 104309694, 104303434, 104321617], "C": [104297127, 104291328, 104310275, 104297010, 104300137, 104335806, 104289962, 104291239, 104299846, 104320575, 104299422, 104297141, 104307584, 104296827, 104299646, 104301166, 104302797, 104297015, 104316440], "B": [104289189, 104283439, 104284166, 104288050, 104287625, 104337404, 104283726, 104283807, 104286751, 104285766, 104285844, 104292438, 104285398, 104287974, 104288404, 104287047, 104293072, 104288614, 104287425], "A": [104282920, 104280323, 104280823, 104280333, 104281130, 104338367, 104280298, 104280342, 104281217, 104281168, 104280838, 104286833, 104280557, 104280439, 104281300, 104280646, 104289104, 104281489, 104280913]}, "name": "G. Tiles", "statement": "Consider a road consisting of several rows. Each row is divided into\r\nseveral rectangular tiles, and all tiles in the same row are equal. The\r\nfirst row contains exactly one rectangular tile. Look at the picture\r\nbelow which shows how the tiles are arranged.The road is constructed as\r\nfollows: the first row consists of 1 tile; then a_1 rows follow; each of\r\nthese rows contains 1 tile greater than the previous row; then b_1 rows\r\nfollow; each of these rows contains 1 tile less than the previous row;\r\nthen a_2 rows follow; each of these rows contains 1 tile greater than\r\nthe previous row; then b_2 rows follow; each of these rows contains 1\r\ntile less than the previous row; ... then a_n rows follow; each of these\r\nrows contains 1 tile greater than the previous row; then b_n rows\r\nfollow; each of these rows contains 1 tile less than the previous row.\r\nAn example of the road with n = 2, a_1 = 4, b_1 = 2, a_2 = 2, b_2 = 3.\r\nRows are arranged from left to right. You start from the only tile in\r\nthe first row and want to reach the last row (any tile of it). From your\r\ncurrent tile, you can move to any tile in the next row which touches\r\nyour current tile.Calculate the number of different paths from the first\r\nrow to the last row. Since it can be large, print it modulo 998244353.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing u32 = unsigned;\nconstexpr int P = 998244353;\nstd::vector<int> rev, roots{0, 1};\nint power(int a, int b) {\n    int res = 1;\n    for (; b; b >>= 1, a = 1ll * a * a % P)\n        if (b & 1)\n            res = 1ll * res * a % P;\n    return res;\n}\nvoid dft(std::vector<int> &a) {\n    int n = a.size();\n    if (int(rev.size()) != n) {\n        int k = __builtin_ctz(n) - 1;\n        rev.resize(n);\n        for (int i = 0; i < n; ++i)\n            rev[i] = rev[i >> 1] >> 1 | (i & 1) << k;\n    }\n    for (int i = 0; i < n; ++i)\n        if (rev[i] < i)\n            std::swap(a[i], a[rev[i]]);\n    if (int(roots.size()) < n) {\n        int k = __builtin_ctz(roots.size());\n        roots.resize(n);\n        while ((1 << k) < n) {\n            int e = power(3, (P - 1) >> (k + 1));\n            for (int i = 1 << (k - 1); i < (1 << k); ++i) {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = 1ll * roots[i] * e % P;\n            }\n            ++k;\n        }\n    }\n    for (int k = 1; k < n; k *= 2) {\n        for (int i = 0; i < n; i += 2 * k) {\n            for (int j = 0; j < k; ++j) {\n                int u = a[i + j];\n                int v = 1ll * a[i + j + k] * roots[k + j] % P;\n                int x = u + v;\n                if (x >= P)\n                    x -= P;\n                a[i + j] = x;\n                x = u - v;\n                if (x < 0)\n                    x += P;\n                a[i + j + k] = x;\n            }\n        }\n    }\n}\nvoid idft(std::vector<int> &a) {\n    int n = a.size();\n    std::reverse(a.begin() + 1, a.end());\n    dft(a);\n    int inv = power(n, P - 2);\n    for (int i = 0; i < n; ++i)\n        a[i] = 1ll * a[i] * inv % P;\n}\nstruct Poly {\n    std::vector<int> a;\n    Poly() {}\n    Poly(int a0) {\n        if (a0)\n            a = {a0};\n    }\n    Poly(const std::vector<int> &a1) : a(a1) {\n        while (!a.empty() && !a.back())\n            a.pop_back();\n    }\n    int size() const {\n        return a.size();\n    }\n    int operator[](int idx) const {\n        if (idx < 0 || idx >= size())\n            return 0;\n        return a[idx];\n    }\n    Poly mulxk(int k) const {\n        auto b = a;\n        b.insert(b.begin(), k, 0);\n        return Poly(b);\n    }\n    Poly modxk(int k) const {\n        k = std::min(k, size());\n        return Poly(std::vector<int>(a.begin(), a.begin() + k));\n    }\n    Poly divxk(int k) const {\n        if (size() <= k)\n            return Poly();\n        return Poly(std::vector<int>(a.begin() + k, a.end()));\n    }\n    friend Poly operator+(const Poly a, const Poly &b) {\n        std::vector<int> res(std::max(a.size(), b.size()));\n        for (int i = 0; i < int(res.size()); ++i) {\n            res[i] = a[i] + b[i];\n            if (res[i] >= P)\n                res[i] -= P;\n        }\n        return Poly(res);\n    }\n    friend Poly operator-(const Poly a, const Poly &b) {\n        std::vector<int> res(std::max(a.size(), b.size()));\n        for (int i = 0; i < int(res.size()); ++i) {\n            res[i] = a[i] - b[i];\n            if (res[i] < 0)\n                res[i] += P;\n        }\n        return Poly(res);\n    }\n    friend Poly operator*(Poly a, Poly b) {\n        int sz = 1, tot = a.size() + b.size() - 1;\n        while (sz < tot)\n            sz *= 2;\n        a.a.resize(sz);\n        b.a.resize(sz);\n        dft(a.a);\n        dft(b.a);\n        for (int i = 0; i < sz; ++i)\n            a.a[i] = 1ll * a[i] * b[i] % P;\n        idft(a.a);\n        return Poly(a.a);\n    }\n    Poly &operator+=(Poly b) {\n        return (*this) = (*this) + b;\n    }\n    Poly &operator-=(Poly b) {\n        return (*this) = (*this) - b;\n    }\n    Poly &operator*=(Poly b) {\n        return (*this) = (*this) * b;\n    }\n    Poly deriv() const {\n        if (a.empty())\n            return Poly();\n        std::vector<int> res(size() - 1);\n        for (int i = 0; i < size() - 1; ++i)\n            res[i] = 1ll * (i + 1) * a[i + 1] % P;\n        return Poly(res);\n    }\n    Poly integr() const {\n        if (a.empty())\n            return Poly();\n        std::vector<int> res(size() + 1);\n        for (int i = 0; i < size(); ++i)\n            res[i + 1] = 1ll * a[i] * power(i + 1, P - 2) % P;\n        return Poly(res);\n    }\n    Poly inv(int m) const {\n        Poly x(power(a[0], P - 2));\n        int k = 1;\n        while (k < m) {\n            k *= 2;\n            x = (x * (2 - modxk(k) * x)).modxk(k);\n        }\n        return x.modxk(m);\n    }\n    Poly log(int m) const {\n        return (deriv() * inv(m)).integr().modxk(m);\n    }\n    Poly exp(int m) const {\n        Poly x(1);\n        int k = 1;\n        while (k < m) {\n            k *= 2;\n            x = (x * (1 - x.log(k) + modxk(k))).modxk(k);\n        }\n        return x.modxk(m);\n    }\n    Poly sqrt(int m) const {\n        Poly x(1);\n        int k = 1;\n        while (k < m) {\n            k *= 2;\n            x = (x + (modxk(k) * x.inv(k)).modxk(k)) * ((P + 1) / 2);\n        }\n        return x.modxk(m);\n    }\n    Poly mulT(Poly b) const {\n        if (b.size() == 0)\n            return Poly();\n        int n = b.size();\n        std::reverse(b.a.begin(), b.a.end());\n        return ((*this) * b).divxk(n - 1);\n    }\n    std::vector<int> eval(std::vector<int> x) const {\n        if (size() == 0)\n            return std::vector<int>(x.size(), 0);\n        const int n = std::max(int(x.size()), size());\n        std::vector<Poly> q(4 * n);\n        std::vector<int> ans(x.size());\n        x.resize(n);\n        std::function<void(int, int, int)> build = [&](int p, int l, int r) {\n            if (r - l == 1) {\n                q[p] = std::vector<int>{1, (P - x[l]) % P};\n            } else {\n                int m = (l + r) / 2;\n                build(2 * p, l, m);\n                build(2 * p + 1, m, r);\n                q[p] = q[2 * p] * q[2 * p + 1];\n            }\n        };\n        build(1, 0, n);\n        std::function<void(int, int, int, const Poly &)> work = [&](int p, int l, int r, const Poly &num) {\n            if (r - l == 1) {\n                if (l < int(ans.size()))\n                    ans[l] = num[0];\n            } else {\n                int m = (l + r) / 2;\n                work(2 * p, l, m, num.mulT(q[2 * p + 1]).modxk(m - l));\n                work(2 * p + 1, m, r, num.mulT(q[2 * p]).modxk(r - m));\n            }\n        };\n        work(1, 0, n, mulT(q[1].inv(n)));\n        return ans;\n    }\n};\nconstexpr int N = 2e5;\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n;\n    std::cin >> n;\n    std::vector<int> dp{1};\n    int tot = 0;\n    std::vector<int> fac(N + 1), invFac(N + 1);\n    fac[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        fac[i] = i64(fac[i - 1]) * i % P;\n    }\n    invFac[N] = power(fac[N], P - 2);\n    for (int i = N; i > 0; i--) {\n        invFac[i - 1] = i64(invFac[i]) * i % P;\n    }\n    auto binom = [&](int n, int m) -> int {\n        if (m < 0 || n < m) {\n            return 0;\n        }\n        return i64(fac[n]) * invFac[m] % P * invFac[n - m] % P;\n    };\n    for (int i = 0; i < n; i++) {\n        int a, b;\n        std::cin >> a >> b;\n        int ntot = tot + a - b;\n        std::vector<int> g(tot + ntot + 1);\n        for (int j = -tot; j <= ntot; j++) {\n            g[j + tot] = binom(a + b, b + j);\n        }\n        auto f = Poly(dp) * Poly(g);\n        dp.resize(ntot + 1);\n        for (int j = 0; j <= ntot; j++) {\n            dp[j] = f[j + tot];\n        }\n        tot = ntot;\n    }\n    int ans = 0;\n    for (auto x : dp) {\n        ans = (ans + x) % P;\n    }\n    std::cout << ans << \"\\n\";\n    return 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "dp", "fft", "math"], "dificulty": "2800", "interactive": false}