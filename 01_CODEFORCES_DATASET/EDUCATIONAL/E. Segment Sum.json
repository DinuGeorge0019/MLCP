{
    "link": "https://codeforces.com//contest/1073/problem/E",
    "problemId": "243300",
    "problem_idx": "E",
    "shortId": "1073E",
    "contest_number": "1073",
    "problem_submissions": {
        "G": [
            44873257,
            44854949,
            44872747,
            44857777,
            44904113,
            44992378,
            44992266,
            44905426,
            44884903,
            44945894,
            44917741
        ],
        "F": [
            44867029,
            44865010,
            44864483,
            44871287,
            44872814,
            44868847,
            44879071,
            44874774,
            44882300,
            44882274,
            44882259,
            44904164,
            45084744,
            45695799,
            44888299
        ],
        "E": [
            44859477,
            44871290,
            44861403,
            44863217,
            44864294,
            44859185,
            44863995,
            44861353,
            44862909,
            44862761,
            44864156,
            44861997,
            44866321,
            44865560,
            44864610,
            44864622,
            44866506,
            44866536,
            44864718,
            44867428
        ],
        "D": [
            44857129,
            44872779,
            44856075,
            44857988,
            44858337,
            44861164,
            44866799,
            44854399,
            44858649,
            44887677,
            44857825,
            44863255,
            44857894,
            44856716,
            44859464,
            44857349,
            44858547,
            44860520,
            44859062,
            44858058
        ],
        "C": [
            44852935,
            44867793,
            44850047,
            44853493,
            44853830,
            44872109,
            44870370,
            44851223,
            44852821,
            44887759,
            44853381,
            44855264,
            44855099,
            44853761,
            44855656,
            44859785,
            44852765,
            44856270,
            44855283,
            44855046
        ],
        "B": [
            44847780,
            44861886,
            44847247,
            44849026,
            44846682,
            44849066,
            44868560,
            44847702,
            44847526,
            44848456,
            44847355,
            44849516,
            44847583,
            44849338,
            44847283,
            44847620,
            44847641,
            44850429,
            44848272
        ],
        "A": [
            44846309,
            44861253,
            44846364,
            44847286,
            44846147,
            44847332,
            44867659,
            44846213,
            44846204,
            44846510,
            44846224,
            44846724,
            44846207,
            44847114,
            44846296,
            44846271,
            44846181,
            44848595,
            44846401
        ]
    },
    "name": "E. Segment Sum",
    "statement": "You are given two integers l and r (l\r\nle r). Your task is to calculate the sum of numbers from l to r\r\n(including l and r) such that each number contains k different digits,\r\nand print this sum modulo 998244353.For example, if k = 1 then you have\r\nto calculate all numbers from l to r such that each number is formed\r\nusing only one digit. For l = 10, r = 50 the answer is 11 + 22 + 33 + 44\r\n= 110.\r\n",
    "solutions": [
        "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nstruct mint {\n  int n;\n  mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator+(mint a, mint b) { return (a.n += b.n) >= mod ? a.n - mod : a.n; }\nmint operator-(mint a, mint b) { return (a.n -= b.n) < 0 ? a.n + mod : a.n; }\nmint operator*(mint a, mint b) { return 1LL * a.n * b.n % mod; }\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\nostream &operator<<(ostream &o, mint a) { return o << a.n; }\n\nmint dp[20][2][2][2][1 << 10];\nmint dp2[20][2][2][2][1 << 10];\n\nint popcnt(int n) {\n  int res = 0;\n  while (n > 0) {\n    res++;\n    n &= n - 1;\n  }\n  return res;\n}\n\nint main() {\n  string L, R;\n  int K;\n  cin >> L >> R >> K;\n  while (L.size() < R.size()) L = '0' + L;\n  while (L.size() > R.size()) R = '0' + R;\n  int n = L.size();\n  dp[0][0][0][0][0] = 1;\n  dp2[0][0][0][0][0] = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2; j++) {\n      for (int k = 0; k < 2; k++) {\n        for (int l = 0; l < 2; l++) {\n          for (int m = 0; m < 1 << 10; m++) {\n            int x = j ? 0 : L[i] - '0';\n            int y = k ? 9 : R[i] - '0';\n            for (int d = x; d <= y; d++) {\n              int mm = l == 0 && d == 0 ? 0 : (m | 1 << d);\n              dp[i + 1][j || d > x][k || d < y][l || d != 0][mm] += dp[i][j][k][l][m];\n              dp2[i + 1][j || d > x][k || d < y][l || d != 0][mm] += dp2[i][j][k][l][m] * 10 + dp[i][j][k][l][m] * d;\n            }\n          }\n        }\n      }\n    }\n  }\n  mint ans;\n  for (int j = 0; j < 2; j++) {\n    for (int k = 0; k < 2; k++) {\n      for (int m = 0; m < 1 << 10; m++) {\n        if (popcnt(m) <= K) {\n          ans += dp2[n][j][k][1][m];\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Segment Sum.json",
    "editorial_link": "https://codeforces.com/blog/entry/62742",
    "editorial": "Letâs calculate the answer as the sum of suitable numbers in range minus\r\nthe sum of suitable numbers in range . Now our problem is to calculate\r\nthe sum of suitable numbers in range .The main approach for problem is\r\ndigit DP. Letâs calculate two dynamic programmings and . means that now\r\nwe are at the -th digit of the number (at the digit corresponding to ,\r\nwhere is the decimal length of a number), is a binary mask describing\r\ndigits we already use and equals if the current prefix of number we\r\ntrying to obtain is the same as the prefix of number (otherwise equals\r\n).So what means ? It means the count of numbers (in general, not numbers\r\nbut their prefixes) in range of length without leading zeroes\r\ncorresponding to this state. So what the point of this DP? Its point is\r\nhelping us to calculate the main DP, , which means the sum of numbers\r\n(in general, not numbers but their prefixes) in range of length without\r\nleading zeroes corresponding to this state.How do we calculate the\r\nanswer? Firstly, let be the length of . Let be the function calculating\r\nthe sum of numbers from to containing at most different digits. How to\r\ncalculate it? Let be the sum of numbers from to containing at most\r\ndifferent digits and having length exactly . Then seems to be pretty\r\neasy: for each length from to add to the answer . And the last step is\r\nto add to the answer .How to calculate dynamic programmings? Initially,\r\nall states are zeroes (excluding , which is ).Firstly, letâs calculate .\r\nAfter calculating it we can calculate in almost the same way. Letâs\r\niterate over all possible lengths and over all possible masks. Let the\r\ncurrent state is . Then letâs iterate over next digit we will place in\r\nthis number and place it. If then otherwise . The transition is pretty\r\neasy: . There is the bitwise operation. For transitions are almost the\r\nsame expect the restrictions on digit we place and the state we update.\r\nIf we now at the position with mask and then the current digit of is .\r\nThen letâs iterate over next digit: if otherwise . The transition is\r\nalso easy: .After calculating the previous DP we can calculate . All the\r\nprocess is the same as in the previous dynamic programming expect the\r\nvalue we will add in transitions. In the previous DP this value was\r\nequal , in the current DP this value equals to . Donât forget to\r\ncalculate it modulo !So after calculating all the values of DPs, what is\r\nthe answer for ? It is for all masks with at most bits.Iâm pretty sure\r\nthat there is another way to avoid leading zeroes in calculating these\r\nDPs but this one is very straight-forward and simple.\r\n",
    "hint": []
}