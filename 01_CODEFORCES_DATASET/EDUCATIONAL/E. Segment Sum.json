{"link": "https://codeforces.com//contest/1073/problem/E", "problemId": "243300", "problem_idx": "E", "shortId": "1073E", "contest_number": "1073", "problem_submissions": {"G": [44873257, 44854949, 44872747, 44857777, 44904113, 44992378, 44992266, 44905426, 44884903, 44945894, 44917741], "F": [44867029, 44865010, 44864483, 44871287, 44872814, 44868847, 44879071, 44874774, 44882300, 44882274, 44882259, 44904164, 45084744, 45695799, 44888299], "E": [44859477, 44871290, 44861403, 44863217, 44864294, 44859185, 44863995, 44861353, 44862909, 44862761, 44864156, 44861997, 44866321, 44865560, 44864610, 44864622, 44866506, 44866536, 44864718, 44867428], "D": [44857129, 44872779, 44856075, 44857988, 44858337, 44861164, 44866799, 44854399, 44858649, 44887677, 44857825, 44863255, 44857894, 44856716, 44859464, 44857349, 44858547, 44860520, 44859062, 44858058], "C": [44852935, 44867793, 44850047, 44853493, 44853830, 44872109, 44870370, 44851223, 44852821, 44887759, 44853381, 44855264, 44855099, 44853761, 44855656, 44859785, 44852765, 44856270, 44855283, 44855046], "B": [44847780, 44861886, 44847247, 44849026, 44846682, 44849066, 44868560, 44847702, 44847526, 44848456, 44847355, 44849516, 44847583, 44849338, 44847283, 44847620, 44847641, 44850429, 44848272], "A": [44846309, 44861253, 44846364, 44847286, 44846147, 44847332, 44867659, 44846213, 44846204, 44846510, 44846224, 44846724, 44846207, 44847114, 44846296, 44846271, 44846181, 44848595, 44846401]}, "name": "E. Segment Sum", "statement": "You are given two integers l and r (l\r\nle r). Your task is to calculate the sum of numbers from l to r\r\n(including l and r) such that each number contains k different digits,\r\nand print this sum modulo 998244353.For example, if k = 1 then you have\r\nto calculate all numbers from l to r such that each number is formed\r\nusing only one digit. For l = 10, r = 50 the answer is 11 + 22 + 33 + 44\r\n= 110.\r\n", "solutions": ["#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int mod = 998244353;\n\nstruct mint {\n  int n;\n  mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator+(mint a, mint b) { return (a.n += b.n) >= mod ? a.n - mod : a.n; }\nmint operator-(mint a, mint b) { return (a.n -= b.n) < 0 ? a.n + mod : a.n; }\nmint operator*(mint a, mint b) { return 1LL * a.n * b.n % mod; }\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\nostream &operator<<(ostream &o, mint a) { return o << a.n; }\n\nmint dp[20][2][2][2][1 << 10];\nmint dp2[20][2][2][2][1 << 10];\n\nint popcnt(int n) {\n  int res = 0;\n  while (n > 0) {\n    res++;\n    n &= n - 1;\n  }\n  return res;\n}\n\nint main() {\n  string L, R;\n  int K;\n  cin >> L >> R >> K;\n  while (L.size() < R.size()) L = '0' + L;\n  while (L.size() > R.size()) R = '0' + R;\n  int n = L.size();\n  dp[0][0][0][0][0] = 1;\n  dp2[0][0][0][0][0] = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2; j++) {\n      for (int k = 0; k < 2; k++) {\n        for (int l = 0; l < 2; l++) {\n          for (int m = 0; m < 1 << 10; m++) {\n            int x = j ? 0 : L[i] - '0';\n            int y = k ? 9 : R[i] - '0';\n            for (int d = x; d <= y; d++) {\n              int mm = l == 0 && d == 0 ? 0 : (m | 1 << d);\n              dp[i + 1][j || d > x][k || d < y][l || d != 0][mm] += dp[i][j][k][l][m];\n              dp2[i + 1][j || d > x][k || d < y][l || d != 0][mm] += dp2[i][j][k][l][m] * 10 + dp[i][j][k][l][m] * d;\n            }\n          }\n        }\n      }\n    }\n  }\n  mint ans;\n  for (int j = 0; j < 2; j++) {\n    for (int k = 0; k < 2; k++) {\n      for (int m = 0; m < 1 << 10; m++) {\n        if (popcnt(m) <= K) {\n          ans += dp2[n][j][k][1][m];\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\n"], "input": "", "output": "", "tags": ["bitmasks", "combinatorics", "dp", "math"], "dificulty": "2300", "interactive": false}