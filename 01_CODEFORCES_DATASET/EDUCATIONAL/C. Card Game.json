{
    "link": "https://codeforces.com//contest/1739/problem/C",
    "problemId": "1559865",
    "problem_idx": "C",
    "shortId": "1739C",
    "contest_number": "1739",
    "problem_submissions": {
        "F": [
            173982711,
            173969607,
            173981022,
            173986288,
            173992146,
            173980539,
            173991072,
            173980378,
            173978555,
            174245795,
            174000933,
            173993564,
            173995270,
            173994662,
            173995645,
            173994787,
            173991035,
            173995175,
            173975986,
            173996342,
            173995107,
            173986566
        ],
        "E": [
            173962909,
            173976378,
            173969496,
            173967080,
            173967227,
            173969366,
            173969799,
            173988104,
            173970277,
            173983172,
            173983299,
            173978308,
            173974083,
            173979712,
            173983159,
            173980060,
            173986740,
            173979502,
            173967920
        ],
        "D": [
            173953446,
            173954284,
            173959501,
            173953114,
            173950233,
            173963545,
            173960383,
            173950745,
            173966040,
            173950883,
            173962543,
            173951795,
            173957703,
            173966024,
            173951939,
            173967693,
            173958723,
            173974529,
            173956732
        ],
        "C": [
            173946487,
            173945498,
            173949713,
            174075655,
            174075624,
            173946209,
            173940986,
            173958498,
            173954556,
            173955135,
            173961377,
            173958964,
            173957077,
            173960274,
            173951680,
            173958743,
            173985617,
            173961155,
            173949432,
            173968872,
            173953205
        ],
        "B": [
            173936382,
            173937044,
            173937069,
            173935458,
            173935314,
            173943298,
            173937530,
            173935389,
            173954918,
            173937400,
            173937767,
            173940608,
            173940106,
            173945520,
            173936795,
            173941470,
            173938759,
            173964539,
            173936543
        ],
        "A": [
            173934470,
            173935151,
            173934498,
            173934222,
            173934344,
            173939803,
            173934700,
            173934286,
            173952986,
            173934928,
            173934527,
            173936084,
            173935340,
            173938305,
            173937802,
            173937555,
            173935130,
            173963081,
            173934367
        ]
    },
    "name": "C. Card Game",
    "statement": "Consider a game with n cards (n is even). Each card has a number written\r\non it, between 1 and n. All numbers on the cards are different. We say\r\nthat a card with number x is stronger than a card with number y if x >\r\ny.Two players, Alex and Boris, play this game. In the beginning, each of\r\nthem receives exactly\r\nfrac{n}{2} cards, so each card belongs to exactly one player. Then, they\r\ntake turns. Alex goes first, then Boris, then Alex again, and so on.On a\r\nplayer’s turn, he must play of his cards. Then, if the opponent doesn’t\r\nhave any cards than the card played, the opponent loses, and the game\r\nends. Otherwise, the opponent has to play a stronger card (exactly one\r\ncard as well). These two cards are removed from the game, and the turn\r\nends. If there are no cards left, the game ends in a draw; otherwise\r\nit’s the opponent’s turn.Consider all possible ways to distribute the\r\ncards between two players, so that each of them receives exactly half of\r\nthe cards. You have to calculate three numbers: the number of ways to\r\ndistribute the cards so that Alex wins; the number of ways to distribute\r\nthe cards so that Boris wins; the number of ways to distribute the cards\r\nso that the game ends in a draw. You may assume that both players play\r\noptimally (i. e. if a player can win no matter how his opponent plays,\r\nhe wins). Two ways to distribute the cards are different if there is at\r\nleast one card such that, in one of these ways, it is given to Alex, and\r\nin the other way, it is given to Boris.For example, suppose n = 4, Alex\r\nreceives the cards [2, 3], and Boris receives the cards [1, 4]. Then the\r\ngame may go as follows: if Alex plays the card 2, then Boris has to\r\nrespond with the card 4. Then, Alex’s turn ends, and Boris’ turn starts.\r\nBoris has only one card left, which is 1; he plays it, and Alex responds\r\nwith the card 3. So, the game ends in a draw; if Alex plays the card 3,\r\nthen Boris has to respond with the card 4. Then, Alex’s turn ends, and\r\nBoris’ turn starts. Boris has only one card left, which is 1; he plays\r\nit, and Alex responds with the card 2. So, the game ends in a draw. So,\r\nin this case, the game ends in a draw.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\ntemplate <long long mod>\nstruct modular {\n    long long value;\n    modular(long long x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n    modular& operator+=(const modular& other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(const modular& other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(const modular& other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(const modular& other) {\n        long long a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            long long t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    friend modular operator+(const modular& lhs, const modular& rhs) { return modular(lhs) += rhs; }\n    friend modular operator-(const modular& lhs, const modular& rhs) { return modular(lhs) -= rhs; }\n    friend modular operator*(const modular& lhs, const modular& rhs) { return modular(lhs) *= rhs; }\n    friend modular operator/(const modular& lhs, const modular& rhs) { return modular(lhs) /= rhs; }\n    modular& operator++() { return *this += 1; }\n    modular& operator--() { return *this -= 1; }\n    modular operator++(int) {\n        modular res(*this);\n        *this += 1;\n        return res;\n    }\n    modular operator--(int) {\n        modular res(*this);\n        *this -= 1;\n        return res;\n    }\n    modular operator-() const { return modular(-value); }\n    bool operator==(const modular& rhs) const { return value == rhs.value; }\n    bool operator!=(const modular& rhs) const { return value != rhs.value; }\n    bool operator<(const modular& rhs) const { return value < rhs.value; }\n};\ntemplate <long long mod>\nstring to_string(const modular<mod>& x) {\n    return to_string(x.value);\n}\ntemplate <long long mod>\nostream& operator<<(ostream& stream, const modular<mod>& x) {\n    return stream << x.value;\n}\ntemplate <long long mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n}\n\nconstexpr long long mod = 998244353;\nusing mint = modular<mod>;\n\nmint power(mint a, long long n) {\n    mint res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res *= a;\n        }\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\n\nvector<mint> fact(1, 1);\nvector<mint> finv(1, 1);\n\nmint C(int n, int k) {\n    if (n < k || k < 0) {\n        return mint(0);\n    }\n    while ((int) fact.size() < n + 1) {\n        fact.emplace_back(fact.back() * (int) fact.size());\n        finv.emplace_back(mint(1) / fact.back());\n    }\n    return fact[n] * finv[k] * finv[n - k];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while (tt--) {\n        int n;\n        cin >> n;\n        mint a = 0, b = 0;\n        for (int i = 1; i <= n / 2; i++) {\n            if (i % 2 == 1) {\n                a += C(2 * i - 1, i);\n                b += C(2 * i - 2, i);\n            } else {\n                a += C(2 * i - 2, i);\n                b += C(2 * i - 1, i);\n            }\n        }\n        if (n % 4 == 0) {\n            swap(a, b);\n        }\n        cout << a << \" \" << b << \" \" << 1 << '\\n';\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "constructive algorithms",
        "dp",
        "games"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Card Game.json",
    "editorial_link": "https://codeforces.com//blog/entry/107461",
    "editorial": "The example tests suggest that there is only one possible distribution\r\nwith a draw. Letâs find out why it is so. We will use a process similar\r\nto induction/recursion to distribute the cards between the two players\r\nso that the game ends in a draw: suppose Alex receives the card . Then\r\nhe wins since he can play it immediately. So, for the game to result in\r\na draw, Boris must receive the card . suppose Boris receives the card .\r\nThen he wins since he also has the card , he can use it to answer any\r\nfirst move of Alex, and then win the game by playing . So, for the game\r\nto result in a draw, Alex must receive the card . suppose Boris receives\r\nthe card . Then he wins since he also has the card : if Alex plays the\r\ncard , Boris responds with and then plays ; if Alex plays some other\r\ncard, Boris responds with and the plays . So, for the game to result in\r\na draw, Alex must receive the card . and so on. In fact, if Alex\r\nreceives the card and Boris receives the card , Alex must play the card\r\nor something equivalent to it on the first move, and Boris must respond\r\nwith the card , so we can consider the game without these two cards with\r\nthe roles swapped.So, if we consider the distribution of cards as a\r\nstring with characters and , where denotes the card belonging to Alex,\r\nand denotes the card belonging to Boris, and the -th character of the\r\nstring represents the card , the only possible distribution for the draw\r\nis But thereâs more to this string representation of the distribution of\r\ncards: the first character that is different from this pattern denotes\r\nthe winner; if the first different character is in the draw distribution\r\nand in the distribution we consider, the winner is Boris; otherwise, the\r\nwinner is Alex.This may lead us to the following ways to count the\r\nnumber of possible distributions which win/lose for Alex: we can use\r\ndynamic programming of the form , where is the number of characters we\r\nused, is the number of characters we used, and is , or depending on\r\nwhether our string coincides with the draw string (), differs from it in\r\na way that Alex wins (), or differs from it in a way that Boris wins ();\r\nthe actual value of must be the number of ways to reach this state of\r\ndynamic programming. The answer then is stored in the states of the form\r\n. or we can use combinatorics: letâs iterate on the length of the prefix\r\nthat is common in the draw string and in the string representing the\r\ndistribution of cards, and then count the number of ways to distribute\r\nthe remaining characters with a binomial coefficient. To calculate the\r\nbinomial coefficients, we can use one of the following methods: Pascalâs\r\ntriangle, precalculating factorials and modular inverses to then, or\r\ncalculating factorials with big integers in Java or Python.\r\n",
    "hint": []
}