{"link": "https://codeforces.com//contest/1739/problem/C", "problemId": "1559865", "problem_idx": "C", "shortId": "1739C", "contest_number": "1739", "problem_submissions": {"F": [173982711, 173969607, 173981022, 173986288, 173992146, 173980539, 173991072, 173980378, 173978555, 174245795, 174000933, 173993564, 173995270, 173994662, 173995645, 173994787, 173991035, 173995175, 173975986, 173996342, 173995107, 173986566], "E": [173962909, 173976378, 173969496, 173967080, 173967227, 173969366, 173969799, 173988104, 173970277, 173983172, 173983299, 173978308, 173974083, 173979712, 173983159, 173980060, 173986740, 173979502, 173967920], "D": [173953446, 173954284, 173959501, 173953114, 173950233, 173963545, 173960383, 173950745, 173966040, 173950883, 173962543, 173951795, 173957703, 173966024, 173951939, 173967693, 173958723, 173974529, 173956732], "C": [173946487, 173945498, 173949713, 174075655, 174075624, 173946209, 173940986, 173958498, 173954556, 173955135, 173961377, 173958964, 173957077, 173960274, 173951680, 173958743, 173985617, 173961155, 173949432, 173968872, 173953205], "B": [173936382, 173937044, 173937069, 173935458, 173935314, 173943298, 173937530, 173935389, 173954918, 173937400, 173937767, 173940608, 173940106, 173945520, 173936795, 173941470, 173938759, 173964539, 173936543], "A": [173934470, 173935151, 173934498, 173934222, 173934344, 173939803, 173934700, 173934286, 173952986, 173934928, 173934527, 173936084, 173935340, 173938305, 173937802, 173937555, 173935130, 173963081, 173934367]}, "name": "C. Card Game", "statement": "Consider a game with n cards (n is even). Each card has a number written\r\non it, between 1 and n. All numbers on the cards are different. We say\r\nthat a card with number x is stronger than a card with number y if x >\r\ny.Two players, Alex and Boris, play this game. In the beginning, each of\r\nthem receives exactly\r\nfrac{n}{2} cards, so each card belongs to exactly one player. Then, they\r\ntake turns. Alex goes first, then Boris, then Alex again, and so on.On a\r\nplayer\u2019s turn, he must play of his cards. Then, if the opponent doesn\u2019t\r\nhave any cards than the card played, the opponent loses, and the game\r\nends. Otherwise, the opponent has to play a stronger card (exactly one\r\ncard as well). These two cards are removed from the game, and the turn\r\nends. If there are no cards left, the game ends in a draw; otherwise\r\nit\u2019s the opponent\u2019s turn.Consider all possible ways to distribute the\r\ncards between two players, so that each of them receives exactly half of\r\nthe cards. You have to calculate three numbers: the number of ways to\r\ndistribute the cards so that Alex wins; the number of ways to distribute\r\nthe cards so that Boris wins; the number of ways to distribute the cards\r\nso that the game ends in a draw. You may assume that both players play\r\noptimally (i. e. if a player can win no matter how his opponent plays,\r\nhe wins). Two ways to distribute the cards are different if there is at\r\nleast one card such that, in one of these ways, it is given to Alex, and\r\nin the other way, it is given to Boris.For example, suppose n = 4, Alex\r\nreceives the cards [2, 3], and Boris receives the cards [1, 4]. Then the\r\ngame may go as follows: if Alex plays the card 2, then Boris has to\r\nrespond with the card 4. Then, Alex\u2019s turn ends, and Boris\u2019 turn starts.\r\nBoris has only one card left, which is 1; he plays it, and Alex responds\r\nwith the card 3. So, the game ends in a draw; if Alex plays the card 3,\r\nthen Boris has to respond with the card 4. Then, Alex\u2019s turn ends, and\r\nBoris\u2019 turn starts. Boris has only one card left, which is 1; he plays\r\nit, and Alex responds with the card 2. So, the game ends in a draw. So,\r\nin this case, the game ends in a draw.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\ntemplate <long long mod>\nstruct modular {\n    long long value;\n    modular(long long x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n    modular& operator+=(const modular& other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(const modular& other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(const modular& other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(const modular& other) {\n        long long a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            long long t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    friend modular operator+(const modular& lhs, const modular& rhs) { return modular(lhs) += rhs; }\n    friend modular operator-(const modular& lhs, const modular& rhs) { return modular(lhs) -= rhs; }\n    friend modular operator*(const modular& lhs, const modular& rhs) { return modular(lhs) *= rhs; }\n    friend modular operator/(const modular& lhs, const modular& rhs) { return modular(lhs) /= rhs; }\n    modular& operator++() { return *this += 1; }\n    modular& operator--() { return *this -= 1; }\n    modular operator++(int) {\n        modular res(*this);\n        *this += 1;\n        return res;\n    }\n    modular operator--(int) {\n        modular res(*this);\n        *this -= 1;\n        return res;\n    }\n    modular operator-() const { return modular(-value); }\n    bool operator==(const modular& rhs) const { return value == rhs.value; }\n    bool operator!=(const modular& rhs) const { return value != rhs.value; }\n    bool operator<(const modular& rhs) const { return value < rhs.value; }\n};\ntemplate <long long mod>\nstring to_string(const modular<mod>& x) {\n    return to_string(x.value);\n}\ntemplate <long long mod>\nostream& operator<<(ostream& stream, const modular<mod>& x) {\n    return stream << x.value;\n}\ntemplate <long long mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n}\n\nconstexpr long long mod = 998244353;\nusing mint = modular<mod>;\n\nmint power(mint a, long long n) {\n    mint res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res *= a;\n        }\n        a *= a;\n        n >>= 1;\n    }\n    return res;\n}\n\nvector<mint> fact(1, 1);\nvector<mint> finv(1, 1);\n\nmint C(int n, int k) {\n    if (n < k || k < 0) {\n        return mint(0);\n    }\n    while ((int) fact.size() < n + 1) {\n        fact.emplace_back(fact.back() * (int) fact.size());\n        finv.emplace_back(mint(1) / fact.back());\n    }\n    return fact[n] * finv[k] * finv[n - k];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while (tt--) {\n        int n;\n        cin >> n;\n        mint a = 0, b = 0;\n        for (int i = 1; i <= n / 2; i++) {\n            if (i % 2 == 1) {\n                a += C(2 * i - 1, i);\n                b += C(2 * i - 2, i);\n            } else {\n                a += C(2 * i - 2, i);\n                b += C(2 * i - 1, i);\n            }\n        }\n        if (n % 4 == 0) {\n            swap(a, b);\n        }\n        cout << a << \" \" << b << \" \" << 1 << '\\n';\n    }\n    return 0;\n}"], "input": "", "output": "", "tags": ["combinatorics", "constructive algorithms", "dp", "games"], "dificulty": "1500", "interactive": false}