{
    "link": "https://codeforces.com//contest/1613/problem/F",
    "problemId": "1209366",
    "problem_idx": "F",
    "shortId": "1613F",
    "contest_number": "1613",
    "problem_submissions": {
        "F": [
            137662460,
            137680102,
            137669930,
            137680388,
            137676481,
            137689054,
            137677544,
            137670783,
            137684225,
            137683109,
            137695659,
            137689822,
            137678272,
            137672898,
            137688331,
            137700851,
            137691450,
            137776678,
            137775393,
            137689226,
            137689675,
            137703031
        ],
        "E": [
            137655072,
            137656585,
            137663380,
            137661012,
            137661380,
            137660230,
            137663524,
            137662766,
            137664563,
            137669185,
            137669422,
            137670709,
            137669302,
            137681566,
            137674305,
            137665393,
            137678462,
            137670584,
            137679435,
            137664635
        ],
        "D": [
            137646881,
            137645109,
            137652424,
            137648321,
            137652518,
            137652740,
            137657211,
            137653818,
            137651858,
            137656413,
            137653916,
            137656694,
            137657143,
            137657455,
            137659528,
            137655936,
            137665693,
            137656041,
            137646478,
            137655272
        ],
        "C": [
            137634971,
            137635045,
            137641150,
            137632004,
            137642031,
            137634798,
            137639433,
            137636954,
            137638798,
            137636121,
            137638972,
            137644414,
            137635322,
            137642182,
            137647281,
            137639264,
            137643162,
            137637445,
            137634607,
            137639818
        ],
        "B": [
            137631052,
            137629986,
            137635688,
            137629262,
            137630431,
            137630193,
            137632384,
            137630955,
            137634981,
            137632132,
            137632097,
            137637773,
            137629234,
            137636896,
            137636754,
            137634314,
            137635536,
            137633727,
            137630130,
            137635595
        ],
        "A": [
            137628660,
            137628698,
            137630882,
            137628467,
            137628655,
            137628608,
            137630089,
            137628835,
            137631891,
            137629156,
            137628914,
            137629328,
            137628519,
            137632470,
            137630776,
            137629772,
            137629039,
            137628924,
            137628505,
            137630736
        ]
    },
    "name": "F. Tree Coloring",
    "statement": "You are given a rooted tree consisting of n vertices numbered from 1 to\r\nn. The root of the tree is the vertex 1.You have to color all vertices\r\nof the tree into n colors (also numbered from 1 to n) so that there is\r\nexactly one vertex for each color. Let c_i be the color of vertex i, and\r\np_i be the parent of vertex i in the rooted tree. The coloring is\r\nconsidered beautiful if there is no vertex k (k > 1) such that c_k =\r\nc_{p_k} - 1, i. e. no vertex such that its color is less than the color\r\nof its parent by .Calculate the number of beautiful colorings, and print\r\nit modulo 998244353.\r\n",
    "solutions": [
        "\n#include <bits/stdc++.h>\n\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n#define imie(x) #x << \": \" << x\n\nusing namespace std;\n\ntemplate <uint32_t base>\nstruct Montgomery {\n\tusing i32 = int32_t;\n\tusing u32 = uint32_t;\n\tusing u64 = uint64_t;\n\n\tstatic constexpr u32 mod() {\n\t\treturn base;\n\t}\n\n\tstatic constexpr u32 np = []() {\n\t\tu32 x = base;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tx *= 2u - base * x;\n\t\t}\n\t\treturn -x;\n\t}();\n\tstatic constexpr u32 r2 = -(u64)(base) % base;\n\n\tstatic_assert(base < (1u << 30));\n\tstatic_assert(base * np + 1 == 0);\n\n\tstatic u32 reduce(u64 x) {\n\t\treturn (x + (u64)((u32)x * np) * base) >> 32;\n\t}\n\n\tu32 x;\n\tMontgomery(): x(0) {}\n\tconstexpr Montgomery(long long y): x(y ? reduce((u64)(y % base + base) * r2) : 0) {}\n\n\tMontgomery& operator +=(const Montgomery& ot) {\n\t\tif ((i32)(x += ot.x - 2 * base) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator -=(const Montgomery& ot) {\n\t\tif ((i32)(x -= ot.x) < 0) {\n\t\t\tx += 2 * base;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator *=(const Montgomery& ot) {\n\t\tx = reduce((u64)x * ot.x);\n\t\treturn *this;\n\t}\n\n\tMontgomery& operator /=(const Montgomery& ot) {\n\t\treturn *this *= ot.inverse();\n\t}\n\n\tfriend Montgomery operator +(Montgomery a, const Montgomery& b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator -(Montgomery a, const Montgomery& b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator *(Montgomery a, const Montgomery& b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\n\tfriend Montgomery operator /(Montgomery a, const Montgomery& b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\n\tMontgomery operator -() const {\n\t\treturn Montgomery() - *this;\n\t}\n\n\tu32 get() const {\n\t\tu32 res = reduce(x);\n\t\treturn res < base ? res : res - base;\n\t}\n\n\tu32 operator ()() const {\n\t\treturn get();\n\t}\n\n\tMontgomery inverse() const {\n\t\treturn pow(base - 2);\n\t}\n\n\tMontgomery pow(int64_t p) const {\n\t\tif (p < 0) {\n\t\t\treturn pow(-p).inverse();\n\t\t}\n\t\tMontgomery res = 1;\n\t\tMontgomery a = *this;\n\t\twhile (p) {\n\t\t\tif (p & 1) {\n\t\t\t\tres *= a;\n\t\t\t}\n\t\t\tp >>= 1;\n\t\t\ta *= a;\n\t\t}\n\t\treturn res;\n\t}\n\n\tfriend istream& operator >>(istream& istr, Montgomery& m) {\n\t\tlong long x;\n\t\tistr >> x;\n\t\tm = Montgomery(x);\n\t\treturn istr;\n\t}\n\n\tfriend ostream& operator <<(ostream& ostr, const Montgomery& m) {\n\t\treturn ostr << m.get();\n\t}\n\n\tbool operator ==(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) == (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\tbool operator !=(const Montgomery& ot) const {\n\t\treturn (x >= base ? x - base : x) != (ot.x >= base ? ot.x - base : ot.x);\n\t}\n\n\texplicit operator int64_t() const {\n\t\treturn x;\n\t}\n\n\texplicit operator bool() const {\n\t\treturn x;\n\t}\n};\n\n\n\n\ntemplate <typename outer_type, typename inner_type, int N>\nclass IFFT {\npublic:\n\tusing Poly = vector<outer_type>;\n\n\tIFFT(): initialized_(false) {}\n\n\t~IFFT() {}\n\n\tvirtual Poly multiply(Poly a, Poly b) {\n\t\tif ((int)a.size() > N / 2 || (int)b.size() > N / 2) {\n\t\t\tPoly result(a.size() + b.size() - 1);\n\t\t\tconst int low_len = (max(a.size(), b.size()) + 1) / 2;\n\t\t\tPoly a_low(a.begin(), min(a.begin() + low_len, a.end()));\n\t\t\tPoly a_high(min(a.begin() + low_len, a.end()), a.end());\n\t\t\tPoly b_low(b.begin(), min(b.begin() + low_len, b.end()));\n\t\t\tPoly b_high(min(b.begin() + low_len, b.end()), b.end());\n\n\t\t\tauto tmp = multiply(a_low, b_low);\n\t\t\tfor (int i = 0; i < (int)tmp.size(); ++i) {\n\t\t\t\tresult[i] += tmp[i];\n\t\t\t\tif (low_len + i < (int)result.size()) {\n\t\t\t\t\tresult[low_len + i] -= tmp[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp = multiply(a_high, b_high);\n\t\t\tfor (int i = 0; i < (int)tmp.size(); ++i) {\n\t\t\t\tresult[2 * low_len + i] += tmp[i];\n\t\t\t\tif (low_len + i < (int)result.size()) {\n\t\t\t\t\tresult[low_len + i] -= tmp[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < (int)a_high.size(); ++i) {\n\t\t\t\ta_low[i] += a_high[i];\n\t\t\t}\n\t\t\tfor (int i = 0; i < (int)b_high.size(); ++i) {\n\t\t\t\tb_low[i] += b_high[i];\n\t\t\t}\n\t\t\ttmp = multiply(a_low, b_low);\n\t\t\tfor (int i = 0; i < (int)tmp.size(); ++i) {\n\t\t\t\tresult[low_len + i] += tmp[i];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tint n = 1;\n\t\twhile (n < (int)a.size() || n < (int)b.size()) {\n\t\t\tn *= 2;\n\t\t}\n\t\tvector<inner_type> ar(n + n), br(n + n);\n\t\tif constexpr (is_convertible_v<outer_type, inner_type>) {\n\t\t\tcopy(all(a), ar.begin());\n\t\t\tcopy(all(b), br.begin());\n\t\t} else {\n\t\t\tthrow runtime_error(\"please, implement your own child multiply function\");\n\t\t}\n\t\tfft(ar);\n\t\tfft(br);\n\t\tfor (int i = 0; i < (int)ar.size(); ++i) {\n\t\t\tar[i] *= br[i];\n\t\t}\n\t\tifft(ar);\n\t\tPoly res((int)a.size() + (int)b.size() - 1);\n\t\tassert(res.size() <= ar.size());\n\t\tif constexpr (is_convertible_v<inner_type, outer_type>) {\n\t\t\tcopy_n(ar.begin(), res.size(), res.begin());\n\t\t} else {\n\t\t\tthrow runtime_error(\"please, implement your own child multiply function\");\n\t\t}\n\t\treturn res;\n\t}\n\n\tvirtual Poly square(const Poly& a) {\n\t\tint n = 1;\n\t\twhile (n < (int)a.size()) {\n\t\t\tn *= 2;\n\t\t}\n\t\tvector<inner_type> ar(n + n);\n\t\tif constexpr (is_convertible_v<outer_type, inner_type>) {\n\t\t\tcopy(all(a), ar.begin());\n\t\t} else {\n\t\t\tthrow runtime_error(\"please, implement your own child square function\");\n\t\t}\n\t\tfft(ar);\n\t\tfor (int i = 0; i < (int)ar.size(); ++i) {\n\t\t\tar[i] *= ar[i];\n\t\t}\n\t\tifft(ar);\n\t\tPoly res((int)a.size() + (int)a.size() - 1);\n\t\tassert(res.size() <= ar.size());\n\t\tif constexpr (is_convertible_v<inner_type, outer_type>) {\n\t\t\tcopy_n(ar.begin(), res.size(), res.begin());\n\t\t} else {\n\t\t\tthrow runtime_error(\"please, implement your own child square function\");\n\t\t}\n\t\treturn res;\n\t}\n\n\tPoly inverse(const Poly& a, int prec) {\n\t\tassert(!a.empty());\n\t\tassert(a[0] != 0);\n\t\tPoly b = {1 / a[0]};\n\t\tfor (int len = 1; len < prec; len *= 2) {\n\t\t\tauto tmp = multiply(b, b);\n\t\t\tif ((int)tmp.size() > prec) {\n\t\t\t\ttmp.resize(prec);\n\t\t\t}\n\t\t\ttmp = multiply(tmp, Poly{a.begin(), a.begin() + min(2 * len, (int)a.size())});\n\t\t\ttmp.resize(2 * len);\n\t\t\tfor (int i = 0; i < len; ++i) {\n\t\t\t\ttmp[i] = b[i] + b[i] - tmp[i];\n\t\t\t\ttmp[len + i] = -tmp[len + i];\n\t\t\t}\n\t\t\tb.swap(tmp);\n\t\t}\n\t\tb.resize(prec);\n\t\treturn b;\n\t}\n\n\tPoly derivative(Poly a) {\n\t\tif (a.empty()) {\n\t\t\treturn a;\n\t\t}\n\t\ta.erase(a.begin());\n\t\tfor (int i = 0; i < (int)a.size(); ++i) {\n\t\t\ta[i] *= i + 1;\n\t\t}\n\t\treturn a;\n\t}\n\n\tPoly primitive(Poly a) {\n\t\ta.insert(a.begin(), 0);\n\t\tfor (int i = 1; i < (int)a.size(); ++i) {\n\t\t\ta[i] /= i;\n\t\t}\n\t\treturn a;\n\t}\n\n\tPoly log(const Poly& a, int prec) {\n\t\tassert(!a.empty());\n\t\tassert(a[0] == 1);\n\t\tauto res = primitive(multiply(derivative(a), inverse(a, prec)));\n\t\tres.resize(prec);\n\t\treturn res;\n\t}\n\n\tPoly exp(const Poly& a, int prec) {\n\t\tassert(!a.empty());\n\t\tassert(a[0] == 0);\n\t\tPoly b = {1};\n\t\tfor (int len = 1; len < prec; len *= 2) {\n\t\t\tauto tmp = Poly{a.begin(), a.begin() + min(2 * len, (int)a.size())};\n\t\t\ttmp.resize(2 * len);\n\t\t\ttmp[0] += 1;\n\t\t\tauto l = log(b, 2 * len);\n\t\t\tfor (int i = 0; i < 2 * len; ++i) {\n\t\t\t\ttmp[i] -= l[i];\n\t\t\t}\n\t\t\tb = multiply(tmp, b);\n\t\t\tb.resize(2 * len);\n\t\t}\n\t\tb.resize(prec);\n\t\treturn b;\n\t}\n\n\tpair<Poly, Poly> divmod(Poly a, Poly b) {\n\t\tassert(!b.empty());\n\t\tassert(b.back() != 0);\n\t\tif (a.size() < b.size()) {\n\t\t\treturn {{0}, a};\n\t\t}\n\t\treverse(all(a));\n\t\treverse(all(b));\n\t\tauto q = inverse(b, a.size() - b.size() + 1);\n\t\tq = multiply(a, q);\n\t\tq.resize(a.size() - b.size() + 1);\n\t\treverse(all(q));\n\t\treverse(all(a));\n\t\treverse(all(b));\n\t\tPoly r(b.size() - 1);\n\t\tauto bq = multiply(b, q);\n\t\tfor (int i = 0; i < (int)r.size(); ++i) {\n\t\t\tr[i] = a[i] - bq[i];\n\t\t}\n\t\treturn {q, r};\n\t}\n\n\tstruct ProductTree {\n\t\tint n;\n\t\tvector<Poly> a;\n\t\tvector<outer_type> x;\n\t\tIFFT* owner;\n\n\t\tProductTree(const vector<outer_type>& _x, IFFT* that): x(_x), owner(that) {\n\t\t\tn = 1;\n\t\t\twhile (n < (int)x.size()) {\n\t\t\t\tn *= 2;\n\t\t\t}\n\t\t\ta.resize(n + n);\n\t\t\touter_type one{1};\n\t\t\tfor (int i = 0; i < (int)x.size(); ++i) {\n\t\t\t\ta[n + i] = {-x[i], one};\n\t\t\t}\n\t\t\tfor (int i = n - 1; i > 0; --i) {\n\t\t\t\tif (a[2 * i].empty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (a[2 * i + 1].empty()) {\n\t\t\t\t\ta[i] = a[2 * i];\n\t\t\t\t} else {\n\t\t\t\t\ta[i] = owner->multiply(a[2 * i], a[2 * i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst Poly& top() {\n\t\t\treturn a[1];\n\t\t}\n\n\t\tvoid rec_multipoint(int v, int l, int r, Poly p, vector<outer_type>& ans) {\n\t\t\tif (l >= (int)x.size()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tp = owner->divmod(p, a[v]).second;\n\t\t\tif (r <= l + 64) {\n\t\t\t\tfor (int i = l; i < r && i < (int)x.size(); ++i) {\n\t\t\t\t\touter_type& res = ans[i] = 0;\n\t\t\t\t\tfor (int j = (int)p.size() - 1; j >= 0; --j) {\n\t\t\t\t\t\tres = res * x[i] + p[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint m = (l + r) / 2;\n\t\t\trec_multipoint(v + v, l, m, p, ans);\n\t\t\trec_multipoint(v + v + 1, m, r, p, ans);\n\t\t}\n\n\t\tvector<outer_type> multipoint(const Poly& p) {\n\t\t\tvector<outer_type> ans(x.size());\n\t\t\trec_multipoint(1, 0, n, p, ans);\n\t\t\treturn ans;\n\t\t}\n\t};\n\n\tPoly multipoint(Poly p, const vector<outer_type>& x) {\n\t\tProductTree tree(x, this);\n\t\treturn multipoint(tree, p);\n\t}\n\n\tPoly interpolate(const vector<outer_type>& x, const vector<outer_type>& y) {\n\t\tProductTree tree(x, this);\n\t\tauto denom = tree.multipoint(derivative(tree.top()));\n\t\tauto inter = [&](const auto& self, int v, int l, int r) -> Poly {\n\t\t\tif (l >= (int)x.size()) {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t\tif (l + 1 == r) {\n\t\t\t\treturn {y[l] / denom[l]};\n\t\t\t}\n\t\t\tint m = (l + r) / 2;\n\t\t\tauto left = self(self, v + v, l, m);\n\t\t\tauto right = self(self, v + v + 1, m, r);\n\t\t\tif (right.empty()) {\n\t\t\t\treturn left;\n\t\t\t}\n\t\t\tleft = multiply(left, tree.a[v + v + 1]);\n\t\t\tright = multiply(right, tree.a[v + v]);\n\t\t\tif (left.size() < right.size()) {\n\t\t\t\tleft.resize(right.size());\n\t\t\t}\n\t\t\tfor (int i = 0; i < (int)right.size(); ++i) {\n\t\t\t\tleft[i] += right[i];\n\t\t\t}\n\t\t\treturn left;\n\t\t};\n\t\treturn inter(inter, 1, 0, tree.n);\n\t}\n\nprotected:\n\tstatic constexpr int L = 31 - __builtin_clz(N);\n\tstatic_assert(!(N & (N - 1)));\n\tvector<inner_type> angles;\n\tvector<int> bitrev;\n\tbool initialized_;\n\n\tvoid initialize() {\n\t\tfill_angles();\n\t\tfill_bitrev();\n\t\tinitialized_ = true;\n\t}\n\n\tvirtual void fill_angles() = 0;\n\n\tvoid fill_bitrev() {\n\t\tbitrev.assign(N, 0);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < L; ++j) {\n\t\t\t\tbitrev[i] = (bitrev[i] << 1) | !!(i & (1 << j));\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid butterfly(vector<inner_type>& a) {\n\t\tif (!initialized_) {\n\t\t\tinitialize();\n\t\t}\n\t\tconst int n = a.size();\n\t\tassert(!(n & (n - 1)));\n\t\tconst int l = __builtin_ctz(n);\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint j = revbit(i, l);\n\t\t\tif (j > i) {\n\t\t\t\tswap(a[i], a[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint revbit(int num, int len) const {\n\t\treturn bitrev[num] >> (L - len);\n\t}\n\n\tvirtual void fft(vector<inner_type>& a) {\n\t\tif (!initialized_) {\n\t\t\tinitialize();\n\t\t}\n\n\t\tconst int n = a.size();\n\t\tassert(!(n & (n - 1)));\n\t\tbutterfly(a);\n\n\t\tfor (int len = 1; len < n; len *= 2) {\n\t\t\tfor (int start = 0; start < n; start += 2 * len) {\n\t\t\t\tfor (int i = 0; i < len; ++i) {\n\t\t\t\t\tconst auto w = angles[N / 2 / len * i];\n\t\t\t\t\tconst auto x = a[start + i], y = a[start + len + i] * w;\n\t\t\t\t\ta[start + i] = x + y;\n\t\t\t\t\ta[start + len + i] = x - y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid ifft(vector<inner_type>& a) {\n\t\tfft(a);\n\t\touter_type to_div = outer_type(1) / a.size();\n\t\tfor (auto& x : a) {\n\t\t\tx *= to_div;\n\t\t}\n\t\treverse(1 + all(a));\n\t}\n};\n// #include \"modular.h\"\n\ntemplate <int mod, int N = (1 << __builtin_ctz(mod - 1))>\nclass NTT : public IFFT<Montgomery<mod>, Montgomery<mod>, N> {\n\tusing Mint = Montgomery<mod>;\nprotected:\n\tvoid fill_angles() {\n\t\tvector<int> primes;\n\t\tfor (int x = mod - 1, p = 2; x > 1; ++p) {\n\t\t\tif (p * p > x) {\n\t\t\t\tprimes.push_back(x);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (x % p == 0) {\n\t\t\t\tprimes.push_back(p);\n\t\t\t\twhile (x % p == 0) {\n\t\t\t\t\tx /= p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto isPrimitiveRoot = [&](Mint g) {\n\t\t\tfor (int p : primes) {\n\t\t\t\tif (g.pow(mod / p) == 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tint g = 2;\n\t\twhile (!isPrimitiveRoot(g)) {\n\t\t\t++g;\n\t\t}\n\t\tg = Mint(g).pow(mod / N).get();\n\n\t\tthis->angles.assign(N, 1);\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tthis->angles[i] = this->angles[i - 1] * g;\n\t\t}\n\t\tassert(this->angles.back() * g == 1);\n\t}\n\n\tvoid ntt(vector<Mint>& a) {\n\t\tfft(a);\n\t}\n};\n\n\ntemplate <int mod>\nstruct InvfactStuff {\n\tusing Mint = Montgomery<mod>;\n\n\tint n;\n\tvector<Mint> inv, fact, invfact;\n\n\texplicit InvfactStuff(int _n): n(_n + 1), inv(_n + 1, 1), fact(_n + 1, 1), invfact(_n + 1, 1) {\n\t\tfor (int i = 2; i < n; ++i) {\n\t\t\tinv[i] = -inv[mod % i] * (mod / i);\n\t\t\tfact[i] = fact[i - 1] * i;\n\t\t\tinvfact[i] = invfact[i - 1] * inv[i];\n\t\t}\n\t}\n\n\tMint C(int n, int k) const {\n\t\tif (k < 0 || k > n) {\n\t\t\treturn 0;\n\t\t}\n\t\tassert(n < this->n);\n\t\treturn fact[n] * invfact[k] * invfact[n - k];\n\t}\n\n\tMint binom(int n, int k) const {\n\t\treturn C(n, k);\n\t}\n\n\tMint factorial(int n) const {\n\t\tassert(n < this->n);\n\t\treturn fact[n];\n\t}\n\n\tMint inverse_factorial(int n) const {\n\t\tassert(n < this->n);\n\t\treturn invfact[n];\n\t}\n\n\tMint inverse(int n) const {\n\t\tassert(n < this->n);\n\t\treturn inv[n];\n\t}\n\n\tMint falling(int n, int k) const {\n\t\tif (k > n) {\n\t\t\treturn 0;\n\t\t}\n\t\tassert(n < this->n);\n\t\treturn fact[n] * invfact[n - k];\n\t}\n};\n\ntemplate <typename Func>\nvoid rec_pythagorean(long long x, long long y, long long z, long long n, const Func& f) {\n\tif (z > n) {\n\t\treturn;\n\t}\n\tf(x, y, z);\n\trec_pythagorean(\n\t\t1 * x - 2 * y + 2 * z,\n\t\t2 * x - 1 * y + 2 * z,\n\t\t2 * x - 2 * y + 3 * z,\n\t\tn, f);\n\trec_pythagorean(\n\t\t1 * x + 2 * y + 2 * z,\n\t\t2 * x + 1 * y + 2 * z,\n\t\t2 * x + 2 * y + 3 * z,\n\t\tn, f);\n\trec_pythagorean(\n\t\t-1 * x + 2 * y + 2 * z,\n\t\t-2 * x + 1 * y + 2 * z,\n\t\t-2 * x + 2 * y + 3 * z,\n\t\tn, f);\n}\n\ntemplate <typename Func>\nvoid for_all_pythagorean_triples(long long n, const Func& f) {\n\trec_pythagorean(3, 4, 5, n, f);\n}\n\n#define all(x) (x).begin(), (x).end()\n#define itn int\n#define make_unique(x) sort((x).begin(), (x).end()); (x).erase(unique((x).begin(), (x).end()), (x).end())\n\n\ninline int nxt() {\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\nconstexpr int mod = 998'244'353;\nusing Mint = Montgomery<mod>;\n\nNTT<mod, (1 << 20)> ntt;\n\nconst int N = 255'555;\nvector<int> a[N];\nint deg[N];\n\nvoid dfs(int v, int p) {\n\tfor (int x : a[v]) {\n\t\tif (x == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tdeg[v] += 1;\n\t\tdfs(x, v);\n\t}\n}\n\nusing Poly = vector<Mint>;\n\nPoly calc(const vector<Poly>& ps, int l, int r) {\n\tif (r == l + 1) {\n\t\treturn ps[l];\n\t} else {\n\t\tconst int m = (l + r) / 2;\n\t\treturn ntt.multiply(calc(ps, l, m), calc(ps, m, r));\n\t}\n}\n\nvoid solve() {\n\tint n = nxt();\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\tdfs(0, 0);\n\tvector<Poly> ps;\n\tfor (int i = 0; i < n; ++i) {\n\t\tps.push_back({1, -deg[i]});\n\t}\n\tPoly p = calc(ps, 0, n);\n\tInvfactStuff<mod> stuff(n);\n\tMint ans = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tans += p[i] * stuff.factorial(n - i);\n\t}\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint t = 1; // nxt();\n\twhile (t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "fft"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Tree Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/97467",
    "editorial": "When a problem asks us to calculate the number of combinatorial objects\r\nthat meet some constraints, we can sometimes use inclusion-exclusion\r\nformula. Let\u00e2\u0080\u0099s try to apply it in this problem.We could use constraints\r\nthat should not be violated. The -th constraint is formulated as\r\nfollows: (there will be a constraint of this type for each ). Suppose we\r\nviolated of these constraints (and have chosen which constraints to\r\nviolate), then the number of colorings that meet these violations is\r\n(for vertices, the colors on them depend on some other independent\r\nvertices, so we can assign only colors for independent vertices). So,\r\nthe answer can be calculated as follows: ,where is the number of ways to\r\nchoose constraints to violate.One initial guess how to calculate is that\r\n, as it would be calculated in other, more usual inclusion-exclusion\r\nproblems. Unfortunately, in this problem, the constraints we violate are\r\nnot independent. For example, if a vertex has several sons, we can\r\nviolate the constraint only on at most one edge leading from a vertex to\r\nits son simultaneously, we cannot violate two or more such\r\nconstraints.Let\u00e2\u0080\u0099s take care of this issue as follows: we can write a\r\ndynamic programming of the form is the number of ways to process first\r\nvertices of the tree and choose exactly edges leading from these nodes\r\nto their sons so that no vertex has more than one edge leading to its\r\nsons chosen. Then, is exactly the number of ways to choose edges in the\r\ntree so that no vertex has more than one chosen edge leading to its\r\nsons, and that will be equal to .We can calculate this dynamic\r\nprogramming in a knapsack fashion in , but it is too slow. Instead,\r\nlet\u00e2\u0080\u0099s optimize this knapsack DP with FFT: for each vertex , introduce a\r\npolynomial , where is the number of children of the vertex .\r\nCoefficients of this polynomial for the first vertex are the values of ;\r\ncoefficients of the product of this polynomial with the polynomial for\r\nthe second vertex are the values of , and so on; to obtain the values of\r\n, we have to multiply all these polynomials, and using FFT +\r\ndivide-and-conquer, we can do it in .\r\n"
}