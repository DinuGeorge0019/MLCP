{
    "link": "https://codeforces.com//contest/1389/problem/F",
    "problemId": "686127",
    "problem_idx": "F",
    "shortId": "1389F",
    "contest_number": "1389",
    "problem_submissions": {
        "F": [
            88348682,
            88338153,
            88328943,
            88335897,
            88333690,
            88373314,
            88373278,
            88339376,
            88563610,
            88324437,
            88323357,
            90193331,
            88370216,
            88338670,
            88346193,
            88335414,
            88340450,
            88343043,
            88354834,
            88350683,
            88354635,
            88351121,
            88341928,
            88353006,
            88617212,
            88617191,
            88616644,
            88339094
        ],
        "G": [
            88341915,
            88358421,
            88361866,
            88360257,
            88360333,
            88361126,
            88563627,
            88370757,
            88366719,
            88625823,
            88368266
        ],
        "E": [
            88316360,
            88314884,
            88313039,
            88320696,
            88327221,
            88331067,
            88563585,
            88316358,
            88316429,
            88316758,
            88324617,
            88315489,
            88322575,
            88325697,
            88318058,
            88335501,
            88333747,
            88335296,
            88331670,
            88336084,
            88330920
        ],
        "D": [
            88313541,
            88323588,
            88322172,
            88317239,
            88320907,
            88324683,
            88563559,
            88313756,
            88311946,
            88313492,
            88320253,
            88324924,
            88317796,
            88320516,
            88314433,
            88325709,
            88322521,
            88323822,
            88326845,
            88325546,
            88326242
        ],
        "C": [
            88305803,
            88306793,
            88305781,
            88311961,
            88313905,
            88313498,
            88563542,
            88308288,
            88306505,
            88301578,
            88306622,
            88310987,
            88310892,
            88306012,
            88305081,
            88310508,
            88309198,
            88313956,
            88307817,
            88312102,
            88315317
        ],
        "B": [
            88302673,
            88302689,
            88302324,
            88309761,
            88336897,
            88305352,
            88563516,
            88305445,
            88304272,
            88310119,
            88303921,
            88308221,
            88312057,
            88313228,
            88301014,
            88307222,
            88306963,
            88309964,
            88398537,
            88306205,
            88308367,
            88311740
        ],
        "A": [
            88294762,
            88294889,
            88294798,
            88296225,
            88294786,
            88295833,
            88563453,
            88295598,
            88294725,
            88294981,
            88294767,
            88294779,
            88295244,
            88294853,
            88294700,
            88297412,
            88295036,
            88299886,
            88294845,
            88296400,
            88294879
        ]
    },
    "name": "F. Bicolored Segments",
    "statement": "You are given n segments [l_1, r_1], [l_2, r_2],\r\ndots, [l_n, r_n]. Each segment has one of two colors: the i-th segment’s\r\ncolor is t_i.Let’s call a pair of segments i and j if the following two\r\nconditions are met: t_i\r\nne t_j; the segments [l_i, r_i] and [l_j, r_j] intersect, embed or\r\ntouch, i. e. there exists an integer x such that x\r\nin [l_i, r_i] and x\r\nin [l_j, r_j]. Calculate the maximum number of segments that can be\r\nselected from the given ones, so that there is no pair among the\r\nselected ones.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 1 << 19;\nstruct Node {\n\tint l, r;\n\tint val;\n\tint addAll;\n\n\tNode() : l(-1), r(-1), val(0), addAll(0) {}\n\tNode(int _l, int _r) : l(_l), r(_r), val(0), addAll(0) {}\n\n\tvoid add(int x) {\n\t\tval += x;\n\t\taddAll += x;\n\t}\n};\nNode tree[2][2 * N + 5];\n\nvoid build() {\n\tfor (int k = 0; k < 2; k++) {\n\t\tfor (int i = 0; i < N; i++)\n\t\t\ttree[k][N + i] = Node(i, i + 1);\n\t\tfor (int i = N - 1; i > 0; i--)\n\t\t\ttree[k][i] = Node(tree[k][2 * i].l, tree[k][2 * i + 1].r);\n\t}\n}\nvoid push(int k, int v) {\n\tfor (int u = 2 * v; u < 2 * v + 2; u++) {\n\t\ttree[k][u].add(tree[k][v].addAll);\n\t}\n\ttree[k][v].addAll = 0;\n}\nvoid update(int k, int v) {\n\ttree[k][v].val = max(tree[k][2 * v].val, tree[k][2 * v + 1].val);\n}\n\nvoid setPoint(int k, int v, int p, int x) {\n\tif (p < tree[k][v].l || tree[k][v].r <= p) return;\n\tif (v >= N) {\n\t\ttree[k][v].val = max(tree[k][v].val, x);\n\t\treturn;\n\t}\n\tpush(k, v);\n\tfor (int u = 2 * v; u < 2 * v + 2; u++)\n\t\tsetPoint(k, u, p, x);\n\tupdate(k, v);\n}\nvoid addSegm(int k, int v, int l, int r, int x) {\n\tif (l <= tree[k][v].l && tree[k][v].r <= r) {\n\t\ttree[k][v].add(x);\n\t\treturn;\n\t}\n\tif (l >= tree[k][v].r || tree[k][v].l >= r) return;\n\tpush(k, v);\n\tfor (int u = 2 * v; u < 2 * v + 2; u++)\n\t\taddSegm(k, u, l, r, x);\n\tupdate(k, v);\n}\nint getMax(int k, int v, int l, int r) {\n\tif (l <= tree[k][v].l && tree[k][v].r <= r) return tree[k][v].val;\n\tif (l >= tree[k][v].r || tree[k][v].l >= r) return 0;\n\tpush(k, v);\n\treturn max(getMax(k, 2 * v, l, r), getMax(k, 2 * v + 1, l, r));\n}\n\nint n;\nint seg[N][3];\nint xs[N];\nint xsSz;\nvector<pii> a[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tbuild();\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &seg[i][0], &seg[i][1], &seg[i][2]);\n\t\tseg[i][2]--;\n\t\txs[xsSz++] = seg[i][0];\n\t\txs[xsSz++] = seg[i][1];\n\t}\n\txs[xsSz++] = -1;\n\tsort(xs, xs + xsSz);\n\txsSz = unique(xs, xs + xsSz) - xs;\n\tfor (int i = 0; i < n; i++) {\n\t\tint l = lower_bound(xs, xs + xsSz, seg[i][0]) - xs;\n\t\tint r = lower_bound(xs, xs + xsSz, seg[i][1]) - xs;\n\t\tint t = seg[i][2];\n\t\ta[r].push_back(mp(l, t));\n\t}\n\tint ans = 0;\n\tfor (int x = 0; x < xsSz; x++) {\n\t\tfor (pii s : a[x]) {\n\t\t\taddSegm(s.second, 1, 0, s.first, 1);\n\t\t}\n\t\tfor (int t = 0; t < 2; t++) {\n\t\t\tint val = getMax(t, 1, 0, x);\n\t\t\tans = max(ans, val);\n\t\t\tsetPoint(t ^ 1, 1, x, val);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp",
        "graph matchings",
        "sortings"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Bicolored Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/80809",
    "editorial": "There are two approaches to this problem. Most of the participants of\r\nthe round got AC by implementing dynamic programming with data\r\nstructures such as segment tree, but I will describe another solution\r\nwhich is much easier to code.Letâs consider a graph where each vertex\r\nrepresents a segment, and two vertices are connected by an edge if the\r\ncorresponding segments compose a bad pair.Since each bad pair is formed\r\nby two segments of different colors, the graph is bipartite. The problem\r\nasks us to find the maximum independent set, and in bipartite graphs,\r\nthe size of the independent set is equal to , where is the number of\r\nvertices, and is the size of the maximum matching.The only thing thatâs\r\nleft is finding the maximum matching. Letâs use event processing\r\napproach to do it: for each segment, create two events \"the segment\r\nbegins\" and \"the segment ends\". While processing the events, maintain\r\nthe currently existing segments in two sets (grouped by their colors and\r\nsorted by the time they end). When a segment ends, letâs try to match it\r\nwith some segment of the opposite color and itâs quite obvious that we\r\nshould choose a segment with the minimum to form a pair.Overall, this\r\nsolution runs in .\r\n",
    "hint": []
}