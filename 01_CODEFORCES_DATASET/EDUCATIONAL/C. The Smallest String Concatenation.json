{
    "link": "https://codeforces.com//contest/632/problem/C",
    "problemId": "50145",
    "problem_idx": "C",
    "shortId": "632C",
    "contest_number": "632",
    "problem_submissions": {
        "F": [
            16449954,
            16449774,
            16448025,
            16447543,
            16474130,
            16447469,
            16465805,
            16465734,
            16449676,
            16449356,
            16449961,
            16450068,
            16557410,
            16449769,
            16450214,
            16449702,
            16464012
        ],
        "E": [
            16447028,
            16449753,
            16445979,
            16453840,
            16453803,
            16448350,
            16447568,
            16449040,
            16605043,
            16448762,
            16447224,
            16448913,
            16449761,
            128072075,
            44908882,
            16457507
        ],
        "D": [
            16446074,
            16445153,
            16444353,
            16454357,
            16446366,
            16445038,
            16445634,
            16444742,
            16453325,
            16445984,
            16447854,
            16446133,
            16445283,
            16446954,
            16447982,
            16445318,
            16444664,
            16445724
        ],
        "C": [
            16444421,
            16444120,
            16443606,
            16443645,
            16445009,
            16444221,
            16444738,
            16443779,
            16445075,
            16444107,
            16445524,
            16449207,
            16450843,
            16448580,
            16448209,
            16447449,
            16444580,
            16444579,
            16443960,
            16444153,
            24720150,
            24720135
        ],
        "B": [
            16443783,
            16443777,
            16443815,
            16443887,
            16444524,
            16444113,
            16444187,
            16451169,
            16443637,
            16443942,
            16443903,
            16444676,
            16444341,
            16444136,
            16444765,
            16447115,
            16444024,
            16443821,
            16443819
        ],
        "A": [
            16443584,
            16443594,
            16443558,
            16443577,
            16443765,
            16443750,
            16443746,
            16445513,
            16443626,
            16443702,
            16443955,
            16443808,
            16443676,
            16444067,
            16446687,
            16443663,
            16443559,
            16443628
        ]
    },
    "name": "C. The Smallest String Concatenation",
    "statement": "You\u2019re given a list of strings . You\u2019d like to concatenate them together\r\nin some order such that the resulting string would be lexicographically\r\nsmallest.Given the list of strings, output the lexicographically\r\nsmallest concatenation.\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nstring s[60000];\n\nbool cmp(const string& a, const string& b) {\n\treturn (a + b) < (b + a);\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> s[i];\n\tsort(s, s + n, cmp);\n\tfor (int i = 0; i < n; ++i)\n\t\tcout << s[i];\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "sortings",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. The Smallest String Concatenation.json",
    "editorial_link": "https://codeforces.com//blog/entry/43493",
    "editorial": "The problem was suggested by Lewin Gan Lewin. The proof of the\r\ntransitivity also belongs to him. Let\u00e2\u0080\u0099s sort all the strings by\r\ncomparator and concatenate them. Let\u00e2\u0080\u0099s prove that it\u00e2\u0080\u0099s the optimal\r\nanswer. Let that operator be transitive (so if ). Consider an optimal\r\nanswer with two strings in reverse order by that operator. Because of\r\nthe transitivity of operator we can assume that pair of strings are\r\nneighbouring. But then we can swap them and get the better answer. Let\u00e2\u0080\u0099s\r\nprove the transitivity of operator. Consider the strings as the -base\r\nnumbers. Then the relation equivalent to . The last is simply the\r\nrelation between real numbers. So we proved the transitivity of the\r\nrelation . C++ solution by me. Python solution by Lewin. Complexity: ,\r\nwhere is the maximal string length.\r\n"
}