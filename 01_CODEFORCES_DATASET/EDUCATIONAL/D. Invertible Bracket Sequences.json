{
    "link": "https://codeforces.com//contest/1976/problem/D",
    "problemId": "2672920",
    "problem_idx": "D",
    "shortId": "1976D",
    "contest_number": "1976",
    "problem_submissions": {
        "F": [
            263314410,
            263323534,
            263323690,
            263325512,
            263334653,
            263331007,
            263325411,
            263343899,
            263340351,
            263335929,
            263326828,
            263332991,
            263341073,
            263348258,
            263349127,
            263349457,
            263346381,
            263355969,
            263347175,
            263342030
        ],
        "E": [
            263305882,
            263313991,
            263310881,
            263312246,
            263315063,
            263311135,
            263313445,
            263315175,
            263343942,
            263328216,
            263320417,
            263320641,
            263323277,
            263324951,
            263331673,
            263329104,
            263324699,
            263325555,
            263316314,
            263328040,
            263331822
        ],
        "C": [
            263292519,
            263287752,
            263288751,
            263286876,
            263284054,
            263285532,
            263285507,
            263293215,
            263285305,
            263285884,
            263286170,
            263285744,
            263298002,
            263303206,
            263289650,
            263291396,
            263291844,
            263302664,
            263303154,
            263303039,
            263301515
        ],
        "D": [
            263292311,
            263298587,
            263366307,
            263299064,
            263295271,
            263295241,
            263295262,
            263303840,
            263298130,
            263292787,
            263298290,
            263306115,
            263312088,
            263291555,
            263300847,
            263305912,
            263364926,
            263302707,
            263310976,
            263298729,
            263311543,
            263313366
        ],
        "B": [
            263272017,
            263272271,
            263275878,
            263272612,
            263272889,
            263274173,
            263277739,
            263274170,
            263273861,
            263276359,
            263274099,
            263279892,
            263280435,
            263273730,
            263275861,
            263277331,
            263275586,
            263274544,
            263272648,
            263279232
        ],
        "A": [
            263268782,
            263268834,
            263269741,
            263268999,
            263269168,
            263269203,
            263269867,
            263269889,
            263269156,
            263268775,
            263269596,
            263270510,
            263268758,
            263268826,
            263268756,
            263270814,
            263269912,
            263269509,
            263268983,
            263270469
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129992",
    "editorial": "Let\u00e2\u0080\u0099s define as the number of characters \u00e2\u0080\u009d minus the number of\r\ncharacters \u00e2\u0080\u009d if we consider a prefix of length .The bracket sequence is\r\nregular if both of the following conditions holds: there is no index\r\nsuch that ; , where is the length of the sequence. Using that fact, we\r\ncan say that the substring is \"good\" if both of the following conditions\r\nholds: should hold for all in , otherwise that would lead to the\r\nnegative balance after inverting the substring; , otherwise that would\r\nlead to after inverting substring. There are many solutions that are\r\nbased on these two facts. Let\u00e2\u0080\u0099s consider one of them.Let\u00e2\u0080\u0099s iterate over\r\nthe right bound of the substring (denote it as ). According to the\r\nsecond condition, , therefore, we can maintain a map that stores the\r\nnumber of positions for each balance value. But, unfortunately, not all\r\nsuch left borders form a good substring because of the first condition.\r\nLuckily, it is easy to fix, if the current balance and there is balance\r\nin the map such that , we can remove all its occurrences from the map\r\n(i. e. remove the key from the map). This fix works because the current\r\nposition lies between the left border (which we store in the map) and\r\nthe potential right border, and the current balance is too high (which\r\nviolates the first condition).So, we get a solution that works in .\r\n",
    "name": "D. Invertible Bracket Sequences",
    "statement": "A regular bracket sequence is a bracket sequence that can be transformed\r\ninto a correct arithmetic expression by inserting characters \u201d and \u201d\r\nbetween the original characters of the sequence. For example: bracket\r\nsequences \"\" and \"\" are regular (the resulting expressions are: \"\" and\r\n\"\"); bracket sequences \"\", \"\" and \"\" are not. Let\u2019s define the of the\r\nbracket sequence as follows: replace all brackets \u201d with \u201d, and vice\r\nversa (all brackets \u201d with \u201d). For example, strings \"\" and \"\" are\r\ninverses of each other.You are given a regular bracket sequence s.\r\nCalculate the number of pairs of integers (l,r) (1\r\nle l\r\nle r\r\nle |s|) such that if you replace the substring of s from the l-th\r\ncharacter to the r-th character (inclusive) with its inverse, s will\r\nstill be a regular bracket sequence.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;\u00a0void solve() {    std::string s;    std::cin >> s;        const int n = s.size();        std::vector<int> pre(n + 1);    for (int i = 0; i < n; i++) {        pre[i + 1] = pre[i] + (s[i] == '(' ? 1 : -1);    }        std::set<int> high;    std::vector<std::vector<int>> vec(n + 1);    for (int i = 0; i <= n; i++) {        vec[pre[i]].push_back(i);    }    i64 ans = 0;    for (int i = n, j = n; i >= 0; i--) {        while (j > 2 * i) {            for (auto x : vec[j]) {                high.insert(x);            }            j--;        }        int cnt = 1;        for (int k = 1; k < vec[i].size(); k++) {            auto it = high.lower_bound(vec[i][k - 1]);            if (it != high.end() && *it < vec[i][k]) {                cnt = 0;            }            ans += cnt;            cnt++;        }    }    std::cout << ans << \"\\n\";}\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "combinatorics",
        "data structures",
        "divide and conquer",
        "implementation",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Invertible Bracket Sequences.json"
}