{
    "link": "https://codeforces.com//contest/1499/problem/G",
    "problemId": "928255",
    "problem_idx": "G",
    "shortId": "1499G",
    "contest_number": "1499",
    "problem_submissions": {
        "F": [
            110357719,
            110358460,
            110349173,
            110358016,
            110369330,
            110363127,
            110361036,
            110362817,
            110367470,
            110357203,
            110369171,
            110368211,
            110370268,
            110366091,
            110355624,
            110365992,
            110369429,
            110370266,
            110365656
        ],
        "E": [
            110348041,
            110354549,
            110362433,
            110350437,
            110347357,
            110357359,
            110349011,
            110357563,
            110354502,
            110352211,
            110355950,
            110358510,
            110361861,
            110360330,
            110370250,
            110360561,
            110360403,
            110361550,
            110357936
        ],
        "D": [
            110338625,
            110339185,
            110410334,
            110410318,
            110410229,
            110342082,
            110340758,
            110337901,
            110434363,
            110434311,
            110432471,
            110432456,
            110384121,
            110347999,
            110344468,
            110349024,
            110347133,
            110346694,
            110345990,
            110348574,
            110343676,
            110346592,
            110347088,
            110350111,
            110350771,
            110350595,
            110349856
        ],
        "C": [
            110333651,
            110331021,
            110334430,
            110335594,
            110331843,
            110335775,
            110331846,
            110336227,
            110336058,
            110339413,
            110333925,
            110337781,
            110335754,
            110338528,
            110342766,
            110337144,
            110339220,
            110337699,
            110337911
        ],
        "B": [
            110328704,
            110327182,
            110329276,
            110330310,
            110327534,
            110329852,
            110327723,
            110329207,
            110329841,
            110333664,
            110328875,
            110331182,
            110328187,
            110334069,
            110334004,
            110328671,
            110331437,
            110330565,
            110331774
        ],
        "A": [
            110326019,
            110325991,
            110326313,
            110326005,
            110325865,
            110325899,
            110325997,
            110326125,
            110326016,
            110326091,
            110326392,
            110325908,
            110325927,
            110326243,
            110325858,
            110326228,
            110326284,
            110326209,
            110326298
        ],
        "G": [
            110573818,
            110399277,
            112155486,
            110386520,
            110388825
        ]
    },
    "name": "G. Graph Coloring",
    "statement": "You are given a bipartite graph consisting of n_1 vertices in the first\r\npart, n_2 vertices in the second part, and m edges, numbered from 1 to\r\nm. You have to color each edge into one of two colors, red and blue. You\r\nhave to minimize the following value:\r\nsum\r\nlimits_{v\r\nin V} |r(v) - b(v)|, where V is the set of vertices of the graph, r(v)\r\nis the number of red edges incident to v, and b(v) is the number of blue\r\nedges incident to v.Sounds classical and easy, right? Well, you have to\r\nprocess q queries of the following format: 1 v_1 v_2 add a new edge\r\nconnecting the vertex v_1 of the first part with the vertex v_2 of the\r\nsecond part. This edge gets a new index as follows: the first added edge\r\ngets the index m + 1, the second m + 2, and so on. After adding the\r\nedge, you have to print the of the current optimal coloring (if there\r\nare multiple optimal colorings, print the of any of them). ; 2 print the\r\noptimal coloring of the graph with the same you printed while processing\r\nthe previous query. The query of this type will only be asked after a\r\nquery of type 1, and there will be at most 10 queries of this type. If\r\nthere are multiple optimal colorings corresponding to this , print any\r\nof them. Note that if an edge was red or blue in some coloring, it may\r\nchange its color in next colorings.The of the coloring is calculated as\r\nfollows: let R be the set of indices of red edges, then the is (\r\nsum\r\nlimits_{i\r\nin R} 2^i)\r\nbmod 998244353.Note that you should solve the problem in mode. It means\r\nthat you canâ€™t read the whole input at once. You can read each query\r\nonly after writing the answer for the last query. Use functions in and\r\nin languages after each writing in your program.\r\n",
    "solutions": [
        "#line 1 \"a.cpp\"\n#include<cstdio>\n#include<vector>\nusing namespace std;\n#line 2 \"/home/kotatsugame/library/tool/FastIO.cpp\"\n#include<cctype>\n#include<string>\nconst int buffer_size=1<<20;\n//input\nint rd_char()\n{\n\tstatic char buf[buffer_size];\n\tstatic int l=buffer_size,r=buffer_size;\n\tif(l==r&&r==buffer_size)\n\t{\n\t\tr=fread(buf,sizeof(char),1<<20,stdin);\n\t\tl=0;\n\t}\n\tif(l==r)return EOF;\n\treturn buf[l++];\n}\nunsigned int rd_uint()\n{\n\tint c;\n\tunsigned int x=0;\n\twhile('0'<=(c=rd_char()))x=x*10+c-'0';\n\treturn x;\n}\nint rd_int()\n{\n\tbool neg=false;\n\tint c=rd_char();\n\tlong long x=0;\n\tif(c=='-')neg=true;\n\telse x=c-'0';\n\twhile('0'<=(c=rd_char()))x=x*10+c-'0';\n\treturn neg?-x:x;\n}\nunsigned long long rd_ull()\n{\n\tint c;\n\tunsigned long long x=0;\n\twhile('0'<=(c=rd_char()))x=x*10+c-'0';\n\treturn x;\n}\nlong long rd_ll()\n{\n\tbool neg=false;\n\tint c=rd_char();\n\tlong long x=0;\n\tif(c=='-')neg=true;\n\telse x=c-'0';\n\twhile('0'<=(c=rd_char()))x=x*10+c-'0';\n\treturn neg?-x:x;\n}\nstring rd_str()\n{\n\tstring ret;\n\tint c;\n\twhile((c=rd_char())!='\\n'&&c!=' '&&c!=EOF)ret+=c;\n\treturn ret;\n}\n//output\nstruct writer_struct{\n\tchar buf[buffer_size];\n\tint l=0;\n\t~writer_struct(){fwrite(buf,sizeof(char),l,stdout);}\n}writer;\nvoid flush()\n{\n\tfwrite(writer.buf,sizeof(char),writer.l,stdout);\n\twriter.l=0;\n}\nvoid wt(char c)\n{\n\tif(writer.l==buffer_size)\n\t{\n\t\tfwrite(writer.buf,sizeof(char),buffer_size,stdout);\n\t\twriter.l=0;\n\t}\n\twriter.buf[writer.l++]=c;\n}\nvoid wt(unsigned int x)\n{\n\tif(x==0)wt('0');\n\telse\n\t{\n\t\tchar f[10];\n\t\tint sz=0;\n\t\twhile(x)\n\t\t{\n\t\t\tf[sz++]=x%10+'0';\n\t\t\tx/=10;\n\t\t}\n\t\twhile(sz)wt(f[--sz]);\n\t}\n}\nvoid wt(int x)\n{\n\tif(x<0)wt('-'),x=-x;\n\twt((unsigned int)x);\n}\nvoid wt(unsigned long long x)\n{\n\tif(x==0)wt('0');\n\telse\n\t{\n\t\tchar f[20];\n\t\tint sz=0;\n\t\twhile(x)\n\t\t{\n\t\t\tf[sz++]=x%10+'0';\n\t\t\tx/=10;\n\t\t}\n\t\twhile(sz)wt(f[--sz]);\n\t}\n}\nvoid wt(long long x)\n{\n\tif(x<0)wt('-'),x=-x;\n\twt((unsigned long long)x);\n}\nvoid wt(const char*s){while(*s!='\\0')wt(*s++);}\nvoid wt(const string&s){for(char c:s)wt(c);}\n#line 5 \"a.cpp\"\nconst long long mod=998244353;\nint N1,N2,M;\nint pr[4<<17],hs[4<<17],hn[4<<17],pe[4<<17],pc[4<<17];\nint ai[4<<17][2];\nint ans,eh=1,id;\nvector<int>es;\nbool usd[4<<17];\nvoid adj(int ei,vector<int>&a,int j)\n{\n\tint pei=-1;\n\tint cnt=0;\n\twhile(ei!=-1)\n\t{\n\t\tusd[ei]=true;\n\t\tif(cnt==j)a.push_back(ei);\n\t\tint tei=ei;\n\t\tif(pei==ai[ei][0])ei=ai[ei][1];\n\t\telse ei=ai[ei][0];\n\t\tpei=tei;\n\t\tcnt=1-cnt;\n\t}\n}\nvoid add(int ei,int ni)\n{\n\tif(ai[ei][0]==-1)ai[ei][0]=ni;\n\telse ai[ei][1]=ni;\n}\nvoid add_edge(int u,int v)\n{\n\tid++;\n\tai[id][0]=ai[id][1]=-1;\n\tv+=N1;\n\teh=eh*2%mod;\n\tif(pr[u]!=-1)\n\t{\n\t\tif(pr[v]!=-1)\n\t\t{\n\t\t\tif(pr[v]==u&&pr[u]==v)\n\t\t\t{\n\t\t\t\tif(pc[u]==0)\n\t\t\t\t{\n\t\t\t\t\tadj(pe[u],es,0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tes.push_back(id);\n\t\t\t\t\tadj(pe[u],es,1);\n\t\t\t\t\tans=(ans+eh)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(pc[u]!=pc[v])\n\t\t\t\t{\n\t\t\t\t\tint rv=pr[v];\n\t\t\t\t\tpc[v]=1-pc[v];\n\t\t\t\t\tpc[rv]=1-pc[rv];\n\t\t\t\t\tans=(ans+mod-hn[v])%mod;\n\t\t\t\t\thn[v]=hn[rv]=(hs[v]-hn[v]+mod)%mod;\n\t\t\t\t\tans=(ans+hn[v])%mod;\n\t\t\t\t}\n\t\t\t\tint ru=pr[u],rv=pr[v];\n\t\t\t\tpr[ru]=rv;pr[rv]=ru;\n\t\t\t\ths[ru]=hs[rv]=((hs[ru]+hs[rv])%mod+eh)%mod;\n\t\t\t\thn[ru]=hn[rv]=(hn[ru]+hn[rv])%mod;\n\t\t\t\tif(pc[u]==1)\n\t\t\t\t{\n\t\t\t\t\thn[ru]=hn[rv]=(hn[ru]+eh)%mod;\n\t\t\t\t\tans=(ans+eh)%mod;\n\t\t\t\t}\n\t\t\t\tadd(pe[u],id);\n\t\t\t\tadd(id,pe[u]);\n\t\t\t\tadd(pe[v],id);\n\t\t\t\tadd(id,pe[v]);\n\t\t\t}\n\t\t\tpr[u]=pr[v]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint ru=pr[u];\n\t\t\tpr[ru]=v;\n\t\t\ths[ru]=(hs[ru]+eh)%mod;\n\t\t\tif(pc[u]==1)\n\t\t\t{\n\t\t\t\thn[ru]=(hn[ru]+eh)%mod;\n\t\t\t\tans=(ans+eh)%mod;\n\t\t\t}\n\t\t\tpr[u]=-1;\n\t\t\tpr[v]=ru;\n\t\t\ths[v]=hs[ru];\n\t\t\thn[v]=hn[ru];\n\t\t\tpe[v]=id;\n\t\t\tpc[v]=1-pc[u];\n\t\t\tadd(pe[u],id);\n\t\t\tadd(id,pe[u]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(pr[v]!=-1)\n\t\t{\n\t\t\tint rv=pr[v];\n\t\t\tpr[rv]=u;\n\t\t\ths[rv]=(hs[rv]+eh)%mod;\n\t\t\tif(pc[v]==1)\n\t\t\t{\n\t\t\t\thn[rv]=(hn[rv]+eh)%mod;\n\t\t\t\tans=(ans+eh)%mod;\n\t\t\t}\n\t\t\tpr[v]=-1;\n\t\t\tpr[u]=rv;\n\t\t\ths[u]=hs[rv];\n\t\t\thn[u]=hn[rv];\n\t\t\tpe[u]=id;\n\t\t\tpc[u]=1-pc[v];\n\t\t\tadd(pe[v],id);\n\t\t\tadd(id,pe[v]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpr[u]=v;\n\t\t\tpr[v]=u;\n\t\t\ths[u]=hs[v]=eh;\n\t\t\thn[u]=hn[v]=eh;\n\t\t\tpe[u]=pe[v]=id;\n\t\t\tpc[u]=pc[v]=0;\n\t\t\tans=(ans+eh)%mod;\n\t\t}\n\t}\n}\nmain()\n{\n\tscanf(\"%d%d%d\",&N1,&N2,&M);\n\tfor(int i=0;i<N1+N2;i++)pr[i]=-1;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tu--,v--;\n\t\tadd_edge(u,v);\n\t}\n\tint Q;\n\tscanf(\"%d\",&Q);\n\tfor(int ccc=0;ccc<Q;ccc++)\n\t{\n\t\tint t;scanf(\"%d\",&t);\n\t\tif(t==1)\n\t\t{\n\t\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\t\tu--,v--;\n\t\t\tadd_edge(u,v);\n\t\t\twt(ans);\n\t\t\twt('\\n');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<int>ret=es;\n\t\t\tfor(int i=0;i<=id;i++)usd[i]=false;\n\t\t\tfor(int i=0;i<N1+N2;i++)if(pr[i]!=-1&&!usd[pe[i]])\n\t\t\t{\n\t\t\t\tadj(pe[i],ret,pc[i]);\n\t\t\t}\n\t\t\twt((unsigned int)ret.size());\n\t\t\tfor(int id:ret)wt(' '),wt(id);\n\t\t\twt('\\n');\n\t\t}\n\t\tflush();\n\t\tfflush(stdout);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "graphs",
        "interactive"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Graph Coloring.json",
    "editorial_link": "https://codeforces.com//blog/entry/88812",
    "editorial": "LetÃ¢Â€Â™s split all edges of the graph into several paths and cycles (each\r\nedge will belong to exactly one path or cycle). Each path and each cycle\r\nwill be colored in an alternating way: the first edge will be red, the\r\nsecond blue, the third red, and so on (or vice versa). Since the graph\r\nis bipartite, each cycle can be colored in an alternating way. The main\r\nidea of the solution is to add the edges one by one, maintain the\r\nstructure of cycles and paths, and make sure that for each vertex, at\r\nmost one path starts/ends in it. If we are able to maintain this\r\ninvariant, then the value of for every vertex will be minimum possible\r\neach cycle going through a vertex covers an even number of edges\r\nincident to it (half of them will be red, half of them will be blue);\r\nso, if the degree of a vertex is odd, one path will have this vertex as\r\nan endpoint, and ; otherwise, it wonÃ¢Â€Â™t be an endpoint of any path, so\r\n.Okay, how do we maintain this structure? LetÃ¢Â€Â™s add edges one by one\r\n(even the original edges of the graph) and rebuild the structure in\r\nonline mode. For each vertex, we will maintain the indices of the paths\r\nthat have this vertex as an endpoint. If some vertex has or more paths\r\nas its endpoints, we can choose two of them and link them together.\r\nWhenever we add an edge from to , we just create a new path and check if\r\nwe can link together some paths that have or as their endpoints.How do\r\nwe link the paths together? If we try to link a path with itself, it\r\nmeans that we try to close a cycle and when we do it, we just forget\r\nabout the resulting cycle, its structure wonÃ¢Â€Â™t change in future queries.\r\nWhen we link a path with some other path, we might need to reverse\r\nand/or repaint the paths before merging them into one. There are (at\r\nleast) two possible data structures we can use to do this: either an\r\nimplicit-key treap that supports reversing and repainting; or a deque\r\nwith small-to-large merging: whenever we try to link two paths together,\r\nwe repaint and/or reverse the smaller one. Both of those methods give a\r\nsolution in or , depending on your implementation. The model solution\r\nuses deques and small-to-large merging.\r\n",
    "hint": []
}