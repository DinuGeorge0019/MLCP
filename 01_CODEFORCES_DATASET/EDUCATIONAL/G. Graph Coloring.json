{"link": "https://codeforces.com//contest/1499/problem/G", "problemId": "928255", "problem_idx": "G", "shortId": "1499G", "contest_number": "1499", "problem_submissions": {"F": [110357719, 110358460, 110349173, 110358016, 110369330, 110363127, 110361036, 110362817, 110367470, 110357203, 110369171, 110368211, 110370268, 110366091, 110355624, 110365992, 110369429, 110370266, 110365656], "E": [110348041, 110354549, 110362433, 110350437, 110347357, 110357359, 110349011, 110357563, 110354502, 110352211, 110355950, 110358510, 110361861, 110360330, 110370250, 110360561, 110360403, 110361550, 110357936], "D": [110338625, 110339185, 110410334, 110410318, 110410229, 110342082, 110340758, 110337901, 110434363, 110434311, 110432471, 110432456, 110384121, 110347999, 110344468, 110349024, 110347133, 110346694, 110345990, 110348574, 110343676, 110346592, 110347088, 110350111, 110350771, 110350595, 110349856], "C": [110333651, 110331021, 110334430, 110335594, 110331843, 110335775, 110331846, 110336227, 110336058, 110339413, 110333925, 110337781, 110335754, 110338528, 110342766, 110337144, 110339220, 110337699, 110337911], "B": [110328704, 110327182, 110329276, 110330310, 110327534, 110329852, 110327723, 110329207, 110329841, 110333664, 110328875, 110331182, 110328187, 110334069, 110334004, 110328671, 110331437, 110330565, 110331774], "A": [110326019, 110325991, 110326313, 110326005, 110325865, 110325899, 110325997, 110326125, 110326016, 110326091, 110326392, 110325908, 110325927, 110326243, 110325858, 110326228, 110326284, 110326209, 110326298], "G": [110573818, 110399277, 112155486, 110386520, 110388825]}, "name": "G. Graph Coloring", "statement": "You are given a bipartite graph consisting of n_1 vertices in the first\r\npart, n_2 vertices in the second part, and m edges, numbered from 1 to\r\nm. You have to color each edge into one of two colors, red and blue. You\r\nhave to minimize the following value:\r\nsum\r\nlimits_{v\r\nin V} |r(v) - b(v)|, where V is the set of vertices of the graph, r(v)\r\nis the number of red edges incident to v, and b(v) is the number of blue\r\nedges incident to v.Sounds classical and easy, right? Well, you have to\r\nprocess q queries of the following format: 1 v_1 v_2 add a new edge\r\nconnecting the vertex v_1 of the first part with the vertex v_2 of the\r\nsecond part. This edge gets a new index as follows: the first added edge\r\ngets the index m + 1, the second m + 2, and so on. After adding the\r\nedge, you have to print the of the current optimal coloring (if there\r\nare multiple optimal colorings, print the of any of them). ; 2 print the\r\noptimal coloring of the graph with the same you printed while processing\r\nthe previous query. The query of this type will only be asked after a\r\nquery of type 1, and there will be at most 10 queries of this type. If\r\nthere are multiple optimal colorings corresponding to this , print any\r\nof them. Note that if an edge was red or blue in some coloring, it may\r\nchange its color in next colorings.The of the coloring is calculated as\r\nfollows: let R be the set of indices of red edges, then the is (\r\nsum\r\nlimits_{i\r\nin R} 2^i)\r\nbmod 998244353.Note that you should solve the problem in mode. It means\r\nthat you can\u2019t read the whole input at once. You can read each query\r\nonly after writing the answer for the last query. Use functions in and\r\nin languages after each writing in your program.\r\n", "solutions": ["#line 1 \"a.cpp\"\n#include<cstdio>\n#include<vector>\nusing namespace std;\n#line 2 \"/home/kotatsugame/library/tool/FastIO.cpp\"\n#include<cctype>\n#include<string>\nconst int buffer_size=1<<20;\n//input\nint rd_char()\n{\n\tstatic char buf[buffer_size];\n\tstatic int l=buffer_size,r=buffer_size;\n\tif(l==r&&r==buffer_size)\n\t{\n\t\tr=fread(buf,sizeof(char),1<<20,stdin);\n\t\tl=0;\n\t}\n\tif(l==r)return EOF;\n\treturn buf[l++];\n}\nunsigned int rd_uint()\n{\n\tint c;\n\tunsigned int x=0;\n\twhile('0'<=(c=rd_char()))x=x*10+c-'0';\n\treturn x;\n}\nint rd_int()\n{\n\tbool neg=false;\n\tint c=rd_char();\n\tlong long x=0;\n\tif(c=='-')neg=true;\n\telse x=c-'0';\n\twhile('0'<=(c=rd_char()))x=x*10+c-'0';\n\treturn neg?-x:x;\n}\nunsigned long long rd_ull()\n{\n\tint c;\n\tunsigned long long x=0;\n\twhile('0'<=(c=rd_char()))x=x*10+c-'0';\n\treturn x;\n}\nlong long rd_ll()\n{\n\tbool neg=false;\n\tint c=rd_char();\n\tlong long x=0;\n\tif(c=='-')neg=true;\n\telse x=c-'0';\n\twhile('0'<=(c=rd_char()))x=x*10+c-'0';\n\treturn neg?-x:x;\n}\nstring rd_str()\n{\n\tstring ret;\n\tint c;\n\twhile((c=rd_char())!='\\n'&&c!=' '&&c!=EOF)ret+=c;\n\treturn ret;\n}\n//output\nstruct writer_struct{\n\tchar buf[buffer_size];\n\tint l=0;\n\t~writer_struct(){fwrite(buf,sizeof(char),l,stdout);}\n}writer;\nvoid flush()\n{\n\tfwrite(writer.buf,sizeof(char),writer.l,stdout);\n\twriter.l=0;\n}\nvoid wt(char c)\n{\n\tif(writer.l==buffer_size)\n\t{\n\t\tfwrite(writer.buf,sizeof(char),buffer_size,stdout);\n\t\twriter.l=0;\n\t}\n\twriter.buf[writer.l++]=c;\n}\nvoid wt(unsigned int x)\n{\n\tif(x==0)wt('0');\n\telse\n\t{\n\t\tchar f[10];\n\t\tint sz=0;\n\t\twhile(x)\n\t\t{\n\t\t\tf[sz++]=x%10+'0';\n\t\t\tx/=10;\n\t\t}\n\t\twhile(sz)wt(f[--sz]);\n\t}\n}\nvoid wt(int x)\n{\n\tif(x<0)wt('-'),x=-x;\n\twt((unsigned int)x);\n}\nvoid wt(unsigned long long x)\n{\n\tif(x==0)wt('0');\n\telse\n\t{\n\t\tchar f[20];\n\t\tint sz=0;\n\t\twhile(x)\n\t\t{\n\t\t\tf[sz++]=x%10+'0';\n\t\t\tx/=10;\n\t\t}\n\t\twhile(sz)wt(f[--sz]);\n\t}\n}\nvoid wt(long long x)\n{\n\tif(x<0)wt('-'),x=-x;\n\twt((unsigned long long)x);\n}\nvoid wt(const char*s){while(*s!='\\0')wt(*s++);}\nvoid wt(const string&s){for(char c:s)wt(c);}\n#line 5 \"a.cpp\"\nconst long long mod=998244353;\nint N1,N2,M;\nint pr[4<<17],hs[4<<17],hn[4<<17],pe[4<<17],pc[4<<17];\nint ai[4<<17][2];\nint ans,eh=1,id;\nvector<int>es;\nbool usd[4<<17];\nvoid adj(int ei,vector<int>&a,int j)\n{\n\tint pei=-1;\n\tint cnt=0;\n\twhile(ei!=-1)\n\t{\n\t\tusd[ei]=true;\n\t\tif(cnt==j)a.push_back(ei);\n\t\tint tei=ei;\n\t\tif(pei==ai[ei][0])ei=ai[ei][1];\n\t\telse ei=ai[ei][0];\n\t\tpei=tei;\n\t\tcnt=1-cnt;\n\t}\n}\nvoid add(int ei,int ni)\n{\n\tif(ai[ei][0]==-1)ai[ei][0]=ni;\n\telse ai[ei][1]=ni;\n}\nvoid add_edge(int u,int v)\n{\n\tid++;\n\tai[id][0]=ai[id][1]=-1;\n\tv+=N1;\n\teh=eh*2%mod;\n\tif(pr[u]!=-1)\n\t{\n\t\tif(pr[v]!=-1)\n\t\t{\n\t\t\tif(pr[v]==u&&pr[u]==v)\n\t\t\t{\n\t\t\t\tif(pc[u]==0)\n\t\t\t\t{\n\t\t\t\t\tadj(pe[u],es,0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tes.push_back(id);\n\t\t\t\t\tadj(pe[u],es,1);\n\t\t\t\t\tans=(ans+eh)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(pc[u]!=pc[v])\n\t\t\t\t{\n\t\t\t\t\tint rv=pr[v];\n\t\t\t\t\tpc[v]=1-pc[v];\n\t\t\t\t\tpc[rv]=1-pc[rv];\n\t\t\t\t\tans=(ans+mod-hn[v])%mod;\n\t\t\t\t\thn[v]=hn[rv]=(hs[v]-hn[v]+mod)%mod;\n\t\t\t\t\tans=(ans+hn[v])%mod;\n\t\t\t\t}\n\t\t\t\tint ru=pr[u],rv=pr[v];\n\t\t\t\tpr[ru]=rv;pr[rv]=ru;\n\t\t\t\ths[ru]=hs[rv]=((hs[ru]+hs[rv])%mod+eh)%mod;\n\t\t\t\thn[ru]=hn[rv]=(hn[ru]+hn[rv])%mod;\n\t\t\t\tif(pc[u]==1)\n\t\t\t\t{\n\t\t\t\t\thn[ru]=hn[rv]=(hn[ru]+eh)%mod;\n\t\t\t\t\tans=(ans+eh)%mod;\n\t\t\t\t}\n\t\t\t\tadd(pe[u],id);\n\t\t\t\tadd(id,pe[u]);\n\t\t\t\tadd(pe[v],id);\n\t\t\t\tadd(id,pe[v]);\n\t\t\t}\n\t\t\tpr[u]=pr[v]=-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint ru=pr[u];\n\t\t\tpr[ru]=v;\n\t\t\ths[ru]=(hs[ru]+eh)%mod;\n\t\t\tif(pc[u]==1)\n\t\t\t{\n\t\t\t\thn[ru]=(hn[ru]+eh)%mod;\n\t\t\t\tans=(ans+eh)%mod;\n\t\t\t}\n\t\t\tpr[u]=-1;\n\t\t\tpr[v]=ru;\n\t\t\ths[v]=hs[ru];\n\t\t\thn[v]=hn[ru];\n\t\t\tpe[v]=id;\n\t\t\tpc[v]=1-pc[u];\n\t\t\tadd(pe[u],id);\n\t\t\tadd(id,pe[u]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(pr[v]!=-1)\n\t\t{\n\t\t\tint rv=pr[v];\n\t\t\tpr[rv]=u;\n\t\t\ths[rv]=(hs[rv]+eh)%mod;\n\t\t\tif(pc[v]==1)\n\t\t\t{\n\t\t\t\thn[rv]=(hn[rv]+eh)%mod;\n\t\t\t\tans=(ans+eh)%mod;\n\t\t\t}\n\t\t\tpr[v]=-1;\n\t\t\tpr[u]=rv;\n\t\t\ths[u]=hs[rv];\n\t\t\thn[u]=hn[rv];\n\t\t\tpe[u]=id;\n\t\t\tpc[u]=1-pc[v];\n\t\t\tadd(pe[v],id);\n\t\t\tadd(id,pe[v]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpr[u]=v;\n\t\t\tpr[v]=u;\n\t\t\ths[u]=hs[v]=eh;\n\t\t\thn[u]=hn[v]=eh;\n\t\t\tpe[u]=pe[v]=id;\n\t\t\tpc[u]=pc[v]=0;\n\t\t\tans=(ans+eh)%mod;\n\t\t}\n\t}\n}\nmain()\n{\n\tscanf(\"%d%d%d\",&N1,&N2,&M);\n\tfor(int i=0;i<N1+N2;i++)pr[i]=-1;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\tu--,v--;\n\t\tadd_edge(u,v);\n\t}\n\tint Q;\n\tscanf(\"%d\",&Q);\n\tfor(int ccc=0;ccc<Q;ccc++)\n\t{\n\t\tint t;scanf(\"%d\",&t);\n\t\tif(t==1)\n\t\t{\n\t\t\tint u,v;scanf(\"%d%d\",&u,&v);\n\t\t\tu--,v--;\n\t\t\tadd_edge(u,v);\n\t\t\twt(ans);\n\t\t\twt('\\n');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvector<int>ret=es;\n\t\t\tfor(int i=0;i<=id;i++)usd[i]=false;\n\t\t\tfor(int i=0;i<N1+N2;i++)if(pr[i]!=-1&&!usd[pe[i]])\n\t\t\t{\n\t\t\t\tadj(pe[i],ret,pc[i]);\n\t\t\t}\n\t\t\twt((unsigned int)ret.size());\n\t\t\tfor(int id:ret)wt(' '),wt(id);\n\t\t\twt('\\n');\n\t\t}\n\t\tflush();\n\t\tfflush(stdout);\n\t}\n}\n"], "input": "", "output": "", "tags": ["data structures", "graphs", "interactive"], "dificulty": "3100", "interactive": false}