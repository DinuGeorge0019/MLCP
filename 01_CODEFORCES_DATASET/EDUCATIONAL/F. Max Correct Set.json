{
    "link": "https://codeforces.com//contest/1463/problem/F",
    "problemId": "836006",
    "problem_idx": "F",
    "shortId": "1463F",
    "contest_number": "1463",
    "problem_submissions": {
        "F": [
            101559554,
            101581978,
            101567286,
            101577708,
            101580696,
            101680102,
            101680098,
            101605801,
            101605564,
            101602968,
            101602931,
            101594909,
            101594099,
            102434679,
            101661639,
            101713126,
            101711433,
            101812801
        ],
        "E": [
            101543691,
            101541624,
            101550722,
            101542275,
            101561956,
            101542640,
            101551028,
            101551947,
            101553418,
            101552115,
            101553474,
            101556641,
            101557969,
            101556648,
            101554530,
            101557890,
            101556692,
            101561428,
            101553035
        ],
        "D": [
            101533227,
            101528710,
            101537667,
            101530458,
            101531312,
            101543635,
            101536909,
            101536759,
            101540131,
            101537456,
            101542046,
            101537094,
            101540598,
            101539288,
            101544433,
            101525965,
            101526650,
            101536306,
            101544222
        ],
        "C": [
            101526320,
            101520150,
            101529141,
            101525986,
            101523000,
            101525367,
            101530714,
            101526273,
            102544695,
            101524853,
            101531194,
            101530250,
            101529215,
            101530504,
            101529471,
            101533604,
            101540078,
            101541782,
            101523573,
            101536896
        ],
        "B": [
            101518923,
            101515147,
            101518366,
            101516293,
            101513263,
            101522496,
            101520454,
            101515435,
            101517061,
            101515098,
            101516483,
            101522667,
            101516542,
            101515577,
            101515224,
            101517780,
            101517682,
            101515176,
            101521789
        ],
        "A": [
            101515277,
            101512560,
            101513602,
            101512825,
            101512593,
            101512667,
            101513802,
            101512900,
            101514221,
            101512986,
            101513229,
            101513515,
            101512759,
            101512530,
            101512877,
            101514648,
            101514992,
            101512816,
            101514556
        ]
    },
    "name": "F. Max Correct Set",
    "statement": "Let’s call the set of positive integers S if the following two\r\nconditions are met: S\r\nsubseteq\r\n{1, 2,\r\ndots, n\r\n}; if a\r\nin S and b\r\nin S, then |a-b|\r\nneq x and |a-b|\r\nneq y. For the given values n, x, and y, you have to find the maximum\r\nsize of the set.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target (\"sse4\")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nvoid expr() {\n\tint n, x, y; cin >> n >> x >> y;\n\tfor (x = 1; x <= 22; x++)for (y = 1; y <= 22; y++) {\n\t\tvector<bool> used(101);\n\t\tfor (int i = 1; i <= 100; i++) {\n\t\t\tused[i] = true;\n\t\t\tif (i - x >= 0 && used[i - x])used[i] = false;\n\t\t\tif (i - y >= 0 && used[i - y])used[i] = false;\n\t\t}\n\t\tint cyc = x + y;\n\t\tint ans = 1;\n\t\trep1(i, cyc) {\n\t\t\tif (used[i] != used[i + cyc]) {\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t}\n\t\tcout << x << \" \" << y << \" \" << ans << \"\\n\";\n\t}\n}\nbool used[100];\nvoid solve() {\n\tint n, x, y; cin >> n >> x >> y;\n\tint d = x + y;\n\tint d1 = d / 2;\n\tint d2 = d - d1;\n\tint c = n / d;\n\tint r = n % d;\n\tvector<int> val(1 << d2,0);\n\trep(i, (1 << d2)) {\n\t\tbool valid = true;\n\t\trep(j, d2)used[j] = false;\n\t\trep(j, d2) {\n\t\t\tif (i & (1 << j))used[j] = true;\n\t\t}\n\t\trep(j, d2)if(used[j]) {\n\t\t\tif (j - x >= 0 && used[j - x])valid = false;\n\t\t\tif (j - y >= 0 && used[j - y])valid = false;\n\t\t}\n\t\tif (!valid)continue;\n\t\tint num = 0;\n\t\trep(j, d2)if (used[j])num++;\n\t\tint sum = num * c;\n\t\trep(j, d2)if (j + d1 < r && used[j])sum++;\n\t\tval[i] = sum;\n\t}\n\trep(i, (1 << d2))rep(j, d2)if (i & (1 << j)) {\n\t\tval[i] = max(val[i], val[i ^ (1 << j)]);\n\t}\n\tint ans = 0;\n\trep(i, (1 << d1)) {\n\t\tbool valid = true;\n\t\trep(j, d1)used[j] = false;\n\t\trep(j, d1)if (i & (1 << j))used[j] = true;\n\t\trep(j, d1)if(used[j]) {\n\t\t\tif (j - x >= 0 && used[j - x])valid = false;\n\t\t\tif (j - y >= 0 && used[j - y])valid = false;\n\t\t}\n\t\tif (!valid)continue;\n\t\tint ban = 0;\n\t\trep(j, d1)if (used[j]) {\n\t\t\tif (j + x >= d1&&j+x<d) {\n\t\t\t\tban |= (1 << j + x - d1);\n\t\t\t}\n\t\t\tif (j + y >= d1 && j + y < d) {\n\t\t\t\tban |= (1 << j + y - d1);\n\t\t\t}\n\t\t}\n\t\tban = (1 << d2) - 1 - ban;\n\n\t\tint num = 0; rep(j, d1)if (used[j])num++;\n\t\tint sum = num * c;\n\t\trep(j, d1)if (used[j])if (j < r)sum++;\n\t\t\n\t\tans = max(ans, sum + val[ban]);\n\t}\n\tcout << ans << \"\\n\";\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dp",
        "math"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Max Correct Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/85707",
    "editorial": "The key idea of the task is to prove that there is an optimal answer\r\nwhere the chosen elements in has a period equal to . Letâs work with\r\ninstead of .Firstly, letâs prove that if weâve chosen correct set in\r\ninterval then if we take all then set will be corect as well. By\r\ncontradiction: suppose we have (), then () or () contradiction.It means\r\nthat if we take the correct set in interval we can create a periodic\r\nanswer by copying this interval several times.Next, letâs prove that\r\nthere is an optimal periodic answer. Letâs look at any optimal answer\r\nand its indicator vector (binary vector of length where iff is in the\r\nset). Let .Letâs split the vector in intervals: . The -st, -rd, -th...\r\nsegments have length and -nd, -th,... segments have length . If we\r\nchoose any two consecutive segments its total length will be equal to\r\nand we can use it to make periodic answer by replacing all length\r\nsegments with the chosen one and segments with the other one.We can\r\nprove that we can always find such two consecutive segments that the\r\ninduced answer will be greater or equal to the initial one. If we create\r\nvector where is equal to the sum of in the -th segment, then the task is\r\nequivalent to finding and such that replacing all by and all by wonât\r\ndecrease array sum. The proof is down below.Now, since the answer is\r\nperiodical, taking element () is equivalent to taking all elements , so\r\nfor each we can calc the number of integers with the same remainder. And\r\nfor each we either take it or not.So we can write , where is the maximum\r\nsum if we processed elements and last elements are described by mask .\r\nWe start with and, when look at the -th element, either take it (if we\r\ncan) or skip it.Time complexity is .==========Letâs prove that for any\r\narray we can find pair such that replacing all with and all with wonât\r\ndecrease the total sum.Letâs define and . Letâs make array , where and .\r\nThe meaning behind is how changes the total sum if we replace\r\ncorresponding elements by .Note, that finding a good pair is equivalent\r\nto finding . Also, note that and analogically, .Letâs prove by\r\ncontradiction: suppose that for any . Letâs look at . But from the other\r\nside, we know that , , ..., , so , otherwise will be negative.In the\r\nsame way, since , , ..., , then . Analogically we can prove that each ,\r\nbut contradiction. So, there is always a pair , i. e. a pair .\r\n",
    "hint": []
}