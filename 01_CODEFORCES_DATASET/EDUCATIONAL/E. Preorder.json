{
    "link": "https://codeforces.com//contest/1671/problem/E",
    "problemId": "1376219",
    "problem_idx": "E",
    "shortId": "1671E",
    "contest_number": "1671",
    "problem_submissions": {
        "F": [
            154542143,
            154558308,
            154555068,
            154557074,
            154562560,
            154560412,
            154560334,
            154580455,
            154580066,
            154579893,
            154579534,
            154559391,
            154560455,
            154556037,
            154570936,
            154568652,
            154567294,
            154570123,
            154570095,
            154571694,
            154567547,
            154573773,
            154574629
        ],
        "E": [
            154528618,
            154523246,
            154538308,
            154531841,
            154536634,
            154537536,
            154534868,
            154536863,
            154540214,
            154537733,
            154537068,
            154539560,
            154544853,
            154541083,
            154543961,
            154546659,
            154540036,
            154543052
        ],
        "D": [
            154515283,
            154518590,
            154521489,
            154520458,
            154521403,
            154524920,
            154528513,
            154532728,
            154525208,
            154525643,
            154525793,
            154526566,
            154525948,
            154532548,
            154534260,
            154534156,
            154549567,
            154532508
        ],
        "C": [
            154510946,
            154513613,
            154516509,
            154516298,
            154514632,
            154518397,
            154518432,
            154511688,
            154514098,
            154517459,
            154516109,
            154520271,
            154520298,
            154520714,
            154518755,
            154518674,
            154516230,
            154526116
        ],
        "B": [
            154508972,
            154509429,
            154511794,
            154511150,
            154510866,
            154511702,
            154510603,
            154509631,
            154511147,
            154510842,
            154511266,
            154514390,
            154513321,
            154513559,
            154512703,
            154511916,
            154511617,
            154520025
        ],
        "A": [
            154508532,
            154508535,
            154508654,
            154509163,
            154508619,
            154508583,
            154508765,
            154508590,
            154508804,
            154509162,
            154508941,
            154509310,
            154508759,
            154508605,
            154508711,
            154508600,
            154508845,
            154516250
        ]
    },
    "name": "E. Preorder",
    "statement": "You are given a rooted tree of 2^n - 1 vertices. Every vertex of this\r\ntree has either 0 children, or 2 children. All leaves of this tree have\r\nthe same distance from the root, and for every non-leaf vertex, one of\r\nits children is the left one, and the other child is the right one.\r\nFormally, you are given a .The vertices of the tree are numbered in the\r\nfollowing order: the root has index 1; if a vertex has index x, then its\r\nleft child has index 2x, and its right child has index 2x+1. Every\r\nvertex of the tree has a letter written on it, either or . Let\u2019s define\r\nthe character on the vertex x as s_x.Let the of some vertex x be defined\r\nin the following way: if the vertex x is a leaf, then the of x be\r\nconsisting of only one character s_x; otherwise, the of x is s_x +\r\nf(l_x) + f(r_x), where + operator defines concatenation of strings,\r\nf(l_x) is the of the left child of x, and f(r_x) is the of the right\r\nchild of x. The of the tree is the of its root.You have to calculate the\r\nnumber of different strings that can be obtained as the of the given\r\ntree, if you are allowed to perform the following operation any number\r\nof times before constructing the of the tree: choose any non-leaf vertex\r\nx, and swap its children (so, the left child becomes the right one, and\r\nvice versa).\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 22.04.2022 18:45:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  string s;\n  cin >> s;\n  Mint ans = 1;\n  function<string(int)> Dfs = [&](int v) {\n    if (2 * v + 1 >= (int) s.size()) {\n      return (string) \"\" + s[v];\n    }\n    auto x = Dfs(2 * v + 1);\n    auto y = Dfs(2 * v + 2);\n    if (x != y) {\n      ans *= 2;\n    }\n    if (x > y) {\n      swap(x, y);\n    }\n    return (string) \"\" + s[v] + x + y;\n  };\n  Dfs(0);\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "divide and conquer",
        "dp",
        "dsu",
        "hashing",
        "sortings",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Preorder.json",
    "editorial_link": "https://codeforces.com//blog/entry/102181",
    "editorial": "In terms of preorder strings, the operation \"swap two children of some\r\nvertex\" means \"swap two substrings of equal length in some specific\r\nlocation\". This operation can be inverted by applying it an additional\r\ntime, so for every positive integer , all of the strings of length are\r\nsplit into equivalence classes in such a way that two strings from the\r\nsame class can be transformed into each other, and two strings from\r\ndifferent classes cannot. For each vertex, the set of its possible\r\npreorder strings is one of these classes.Let\u00e2\u0080\u0099s calculate the answer for\r\nthe problem recursively: let be the number of preorder strings for the\r\nvertex . For a leaf, the number of its preorder strings is . For a\r\nvertex with children and , one of the two holds: if the equivalence\r\nclass for vertex is different from the equivalence class for vertex ,\r\nthen we have to pick a string from the class of vertex , pick a string\r\nfrom the class of vertex , and choose the order in which we take them.\r\nSo, ; if the equivalence class for is the same as the equivalence class\r\nfor , then swapping and doesn\u00e2\u0080\u0099t do anything, so we pick a string from\r\nthe equivalence class of , and then a string from the equivalence class\r\nof . So, . The only thing we don\u00e2\u0080\u0099t know is how to determine if two\r\nvertices represent the same equivalence class. The model solution uses\r\nhashing for this, but there\u00e2\u0080\u0099s a much simpler method: for each vertex ,\r\nlet be the lexicographically smallest string that can be a preorder\r\nstring of . If a vertex has children and , then , and we can calculate\r\nthese strings recursively since the total length is each of characters\r\nwill be present in strings.\r\n"
}