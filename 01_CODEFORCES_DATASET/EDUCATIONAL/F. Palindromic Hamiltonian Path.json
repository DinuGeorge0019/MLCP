{
    "link": "https://codeforces.com//contest/1569/problem/F",
    "problemId": "1103184",
    "problem_idx": "F",
    "shortId": "1569F",
    "contest_number": "1569",
    "problem_submissions": {
        "F": [
            128266355,
            128271363,
            128276594,
            128274140,
            128277636,
            128276419,
            128239230,
            128386349,
            128320123
        ],
        "E": [
            128250268,
            128256767,
            128246439,
            128253452,
            128257933,
            128258504,
            128255293,
            128254536,
            128252116,
            128261192,
            128578023,
            128259291,
            128263798,
            128266969,
            128259594,
            128258410,
            128275140,
            128271709,
            128263862,
            128264259
        ],
        "D": [
            128235337,
            128235527,
            128231804,
            128235402,
            128242825,
            128262573,
            128235767,
            128236235,
            128236769,
            128233977,
            128578016,
            128240282,
            128241897,
            128232635,
            128238819,
            128243586,
            128233606,
            128230968,
            128243956,
            128245831
        ],
        "C": [
            128220989,
            128228983,
            128226656,
            128226748,
            128234279,
            128264995,
            128226270,
            128225854,
            128229844,
            128225694,
            128578004,
            128230030,
            128228479,
            128225884,
            128230468,
            128226610,
            128225551,
            128233122,
            128232240,
            128234418
        ],
        "B": [
            128217208,
            128223439,
            128220536,
            128221217,
            128228682,
            128267165,
            128220994,
            128220572,
            128221551,
            128221442,
            128577996,
            128221801,
            128220084,
            128221194,
            128224466,
            128232979,
            128220020,
            128224325,
            128224652,
            128224175
        ],
        "A": [
            128212769,
            128212941,
            128213029,
            128212974,
            128213857,
            128267874,
            128212779,
            128212821,
            128212915,
            128213233,
            128577977,
            128213929,
            128212944,
            128212794,
            128212959,
            128213921,
            128212839,
            128214062,
            128216496,
            128214843
        ]
    },
    "name": "F. Palindromic Hamiltonian Path",
    "statement": "You are given a simple undirected graph with n vertices, n is even. You\r\nare going to write a letter on each vertex. Each letter should be one of\r\nthe first k letters of the Latin alphabet.A path in the graph is called\r\nHamiltonian if it visits each vertex exactly once. A string is called\r\npalindromic if it reads the same from left to right and from right to\r\nleft. A path in the graph is called palindromic if the letters on the\r\nvertices in it spell a palindromic string without changing the order.A\r\nstring of length n is good if: each letter is one of the first k\r\nlowercase Latin letters; if you write the i-th letter of the string on\r\nthe i-th vertex of the graph, there will exist a palindromic Hamiltonian\r\npath in the graph. Note that the path doesn\u2019t necesserily go through the\r\nvertices in order 1, 2,\r\ndots, n.Count the number of good strings.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 13; \n\nint N, M, K;\nll ans = 0;\nvi color, match;\nvi cc[MX];\nint nc = 0;\nset<vi> okMatches;\nll numWays[MX];\nbool graph[MX][MX];\n\n\nbool goMatch(int p) {\n    if (p == N) {\n        if (okMatches.count(match)) { \n            ans += numWays[nc];\n            return true;\n        }\n        return false;\n    }\n    if (match[p] != -1) {\n        return goMatch(p+1); \n    }\n\n    trav(a, cc[color[p]]) {\n        if (a == p || match[a] != -1) continue;\n        match[a] = p; match[p] = a;\n        if (goMatch(p+1)) return true;\n        match[p] = -1; match[a] = -1;\n    }\n    return false;\n    \n}\n\nvoid goColor(int p) {\n    if (p == N) {\n        F0R(i, nc) if (sz(cc[i])%2) return;\n        match = vi(N, -1);\n        goMatch(0);\n        return;\n    }\n    int onc = nc;\n    F0R(i, onc+1) {\n        ckmax(nc, i+1);\n        color[p] = i;\n        cc[i].pb(p);\n        goColor(p+1);\n        cc[i].pop_back();\n    }\n    nc = onc;\n}\n\nvoid initMatch(int p) {\n    if (p == N) {\n        //dbg(match);\n        //check if hamiltonian path\n        vector<vi> pairs;\n        F0R(i, N) {\n            if (i < match[i]) {\n                pairs.pb({i, match[i]});\n            }\n        }\n        bool ok[N/2][N/2]; F0R(i, N/2) F0R(j, N/2) ok[i][j] = false;\n        F0R(i, N/2) {\n            F0R(j, N/2) {\n                F0R(a, 2) {\n                    F0R(b, 2) {\n                        if (graph[pairs[i][a]][pairs[j][b]] && graph[pairs[i][1-a]][pairs[j][1-b]]) { \n                            ok[i][j] = true;\n                            /*if (i == j) {\n                                dbg(i, pairs[i]);\n                            }*/\n                        }\n                        if (i == j && graph[pairs[i][a]][pairs[j][b]]) {\n                            ok[i][j] = true;\n                            //dbg(i, pairs[i]);\n                        }\n                    }\n                }\n            }\n        }\n        vi perm; F0R(i, sz(pairs)) perm.pb(i);\n        do {\n            bool val = true;\n            F0R(i, N/2 - 1) if (!ok[perm[i]][perm[i+1]]) val = false;\n            if (!ok[perm[0]][perm[0]]) val = false;\n            if (val) {\n                //dbg(match, perm);\n                okMatches.ins(match); return;\n            }\n        } while (next_permutation(all(perm)));\n\n        return;\n    }\n    if (match[p] != -1) {\n        initMatch(p+1); return;\n    }\n\n    FOR(a, p+1, N) {\n        if (a == p || match[a] != -1) continue;\n        match[a] = p; match[p] = a;\n        initMatch(p+1);\n        match[p] = -1; match[a] = -1;\n    }\n}\n\nvoid solve() {\n    cin >> N >> M >> K;\n    numWays[0] = 1;\n    FOR(i, 1, MX) numWays[i] = numWays[i-1] * (K-i+1);\n    F0R(i, M) {\n        int X, Y; cin >> X >> Y; X--; Y--;\n        graph[X][Y] = true;\n        graph[Y][X] = true;\n    }\n    match = vi(N, -1);\n    color = vi(N);\n    initMatch(0);\n    goColor(0);\n    cout << ans << nl;\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n\n    int T = 1;\n//    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dfs and similar",
        "dp",
        "graphs",
        "hashing"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Palindromic Hamiltonian Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/94721",
    "editorial": "Let\u00e2\u0080\u0099s start with making some implications from the low\r\nconstraints.What\u00e2\u0080\u0099s the upper estimate on the number of answers? . Too\r\nhigh, let\u00e2\u0080\u0099s think of a better one. Using some combinatorics, we can\r\nnormalize the answers in such a way that there are at most -th Bell\u00e2\u0080\u0099s\r\nnumber of them. The method basically defines the components of equal\r\nletters. Given a string, we write down the letters in it in the order\r\nthey appear for the first time in the string and rename the first of\r\nthem to \u00e2\u0080\u009d, the second one to \u00e2\u0080\u009d and so on. Only possible answers already.\r\nHmm, but we should also have an even amount of each letter. That is the\r\nabsolute lowest estimate, and it\u00e2\u0080\u0099s equal to about .What does it exactly\r\nmean for a string to be good? There exists a path such that: there\u00e2\u0080\u0099s a\r\npair of equal letters that occupy the -st and the -th vertex in the\r\npath, a pair on the -nd and -th and so on.So for each of possible\r\nanswers, we want to determine if there\u00e2\u0080\u0099s a way to split the groups of\r\nequal letters into pairs of equal letters such that there exists a path\r\nthrough these pairs. Such a path would mean building a palindrome from\r\ninside out.A quick estimation on a number of splittings into pairs. The\r\nfirst letter can be matched against other letters, the first among the\r\nunmatched ones against other letters and so on. Thus, it\u00e2\u0080\u0099s equal to .For\r\neach splitting into pairs, we can determine if there exists a path. That\r\nis a straightforward dynamic programming similar to a usual hamiltonian\r\npath search. It stores a mask of visited and the last visited pair. For\r\na transition, you want to either go from the first vertex of one pair to\r\nthe first vertex of another one and from the second to the second, or\r\nthe other way around. That would take for each splitting.The only thing\r\nleft is to propagate the results from the splitting into pairs to\r\nsplitting into even sized components of equal letters. A splitting into\r\npairs is a splitting into components of size . Let that be a base case\r\nfor the dp. For every splitting into components, find a component of\r\nsize at least (we still have to split it into pairs) and separate it\r\ninto a component of size (a pair) and the rest of the component.\r\nMoreover, a pair can always be chosen in such a way that one of its\r\nelements is the first element of the component. So there are states and\r\nat most transitions from each of them.Maybe there\u00e2\u0080\u0099s a more convenient\r\nway to store the states, but the one I found to be fast enough is\r\nhashing the state into a base- integer (since there are no more than\r\ncomponents, numbered through ) and storing it in a map/hashmap.\r\n"
}