{
    "link": "https://codeforces.com//contest/1175/problem/F",
    "problemId": "354218",
    "problem_idx": "F",
    "shortId": "1175F",
    "contest_number": "1175",
    "problem_submissions": {
        "E": [
            55152697,
            55143297,
            55144842,
            55149453,
            55145090,
            55152529,
            55156277,
            55145238,
            55141766,
            55151809,
            55150612,
            55150119,
            55150752,
            55156812,
            55152738,
            55154944,
            55150125,
            55154652,
            55158266,
            55163765
        ],
        "F": [
            55143004,
            55151795,
            55152215,
            55142312,
            55154601,
            55143715,
            55151506,
            55166103,
            55151247,
            55162817,
            55160160,
            55154302,
            55159983,
            55153216,
            55161466,
            55160616,
            55159270,
            55167756,
            76726554,
            55159045
        ],
        "D": [
            55137941,
            55140293,
            55140750,
            55145972,
            55139564,
            55144646,
            55138002,
            55141894,
            55136780,
            55138695,
            55141164,
            55144507,
            55139116,
            55139569,
            55142712,
            55138367,
            55143330,
            55142605,
            55147375,
            55147140
        ],
        "C": [
            55134609,
            55137594,
            55139019,
            55137598,
            55135791,
            55137314,
            55136601,
            55136692,
            55135046,
            55136312,
            55137446,
            55142893,
            55137610,
            55138266,
            55140998,
            55137003,
            55146366,
            55138295,
            55140586,
            55141407
        ],
        "B": [
            55132016,
            55133684,
            55136306,
            55134307,
            55133707,
            55134207,
            55135033,
            55133685,
            55171853,
            55133665,
            55137967,
            55138315,
            55133858,
            55138192,
            55135842,
            55133934,
            55137057,
            55134510,
            55135402,
            55137596
        ],
        "A": [
            55129715,
            55129741,
            55129684,
            55129658,
            55129917,
            55129679,
            55130628,
            55129791,
            55130186,
            55130042,
            55129731,
            55135937,
            55130056,
            55130398,
            55129926,
            55129655,
            55132057,
            55130203,
            55131132,
            55132516
        ],
        "G": [
            55169838,
            55219359,
            58237199,
            55161904,
            55163020
        ]
    },
    "name": "F. The Number of Subpermutations",
    "statement": "You have an array a_1, a_2,\r\ndots, a_n. Let’s call some subarray a_l, a_{l + 1},\r\ndots , a_r of this array a if it contains all integers from 1 to r-l+1\r\nexactly once. For example, array a = [2, 2, 1, 3, 2, 3, 1] contains 6\r\nsubarrays which are subpermutations: [a_2\r\ndots a_3], [a_2\r\ndots a_4], [a_3\r\ndots a_3], [a_3\r\ndots a_5], [a_5\r\ndots a_7], [a_7\r\ndots a_7].You are asked to calculate the number of subpermutations.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <map>\nusing namespace std;\nusing ll = long long;\n\nstruct SegTree {\n\tconst int INF = 1e9;\n\tvector<pair<int, int>> max_vc;\n\tvector<int> add;\n\tint h = 1;\n\n\tpair<int, int> combine(pair<int, int> a, pair<int, int> b) {\n\t\tif (a.first == b.first) return {a.first, a.second + b.second};\n\t\telse return max(a, b);\n\t}\n\tvoid push(int i) {\n\t\tmax_vc[i].first += add[i];\n\t\tif (i < h) {\n\t\t\tadd[2*i] += add[i];\n\t\t\tadd[2*i+1] += add[i];\n\t\t}\n\t\tadd[i] = 0;\n\t}\n\n\tSegTree(int n, int v) {\n\t\twhile(h < n) h <<= 1;\n\t\tmax_vc.resize(2*h, {v, 1});\n\t\tadd.resize(2*h, 0);\n\t\tfor (int i = h-1; i > 0; --i) max_vc[i] = combine(max_vc[2*i], max_vc[2*i+1]);\n\t}\n\n\tvoid recAdd(int a, int b, int v, int i, int ia, int ib) {\n\t\tpush(i);\n\t\tif (ib < a || b < ia) return;\n\t\tif (a <= ia && ib <= b) {\n\t\t\tadd[i] += v;\n\t\t\tpush(i);\n\t\t} else {\n\t\t\tint im = (ia + ib) >> 1;\n\t\t\trecAdd(a, b, v, 2*i, ia, im);\n\t\t\trecAdd(a, b, v, 2*i+1, im+1, ib);\n\t\t\tmax_vc[i] = combine(max_vc[2*i], max_vc[2*i+1]);\n\t\t}\n\t}\n\n\tpair<int, int> recGet(int a, int b, int i, int ia, int ib) {\n\t\tpush(i);\n\t\tif (ib < a || b < ia) return {-INF, 0};\n\t\tif (a <= ia && ib <= b) return max_vc[i];\n\t\tint im = (ia + ib) >> 1;\n\t\treturn combine(recGet(a, b, 2*i, ia, im), recGet(a, b, 2*i+1, im+1, ib));\n\t}\n\n\tvoid addInt(int a, int b, int v) {\n\t\trecAdd(a, b, v, 1, 0, h-1);\n\t}\n\tpair<int, int> getInt(int a, int b) {\n\t\treturn recGet(a, b, 1, 0, h-1);\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t// Must have max == len == active\n\t// active <= max, len\n\t// 2*active - max - len <= 0\n\n\t// Move end of current interval. Keep only last occurence of value alive\n\t// Store in each position active_[i,a] - max(x_[i, a])\n\t// These values are always <= 0 since only unique values are active. So we can just count the number of\n\t// zeroes in the range to find answer.\n\n\tint n;\n\tcin >> n;\n\tSegTree seg(n, 0);\n\tvector<pair<int, int>> maxes;\n\tmap<int, int> prevs; // Previous occurrences of numbers\n\n\tll res = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a;\n\t\tcin >> a;\n\n\t\tif (prevs.find(a) != prevs.end()) {\n\t\t\tint p = prevs[a];\n\t\t\tseg.addInt(p+1, i, 2);\n\t\t} else {\n\t\t\tseg.addInt(0, i, 2);\n\t\t}\n\t\tseg.addInt(0, i, -1); // Len\n\n\t\tprevs[a] = i;\n\n\t\tseg.addInt(i, i, -a);\n\t\tpair<int, int> maxes_add = {a, i};\n\t\twhile((! maxes.empty()) && (maxes.back().first <= a)) {\n\t\t\tseg.addInt(maxes.back().second, maxes_add.second - 1, -(a - maxes.back().first));\n\t\t\tmaxes_add.second = maxes.back().second;\n\t\t\tmaxes.pop_back();\n\t\t}\n\t\tmaxes.push_back(maxes_add);\n\n\t\tpair<int, int> sub = seg.getInt(0, i);\n\t\tif (sub.first == 0) res += sub.second;\n\t}\n\tcout << res << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "divide and conquer",
        "hashing",
        "math"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. The Number of Subpermutations.json",
    "editorial_link": "https://codeforces.com/blog/entry/67484",
    "editorial": "At first, letâs represent permutations in the next form. We assign to\r\nall numbers from to random 128-bit strings, so the -th number gets the\r\nstring . Then the permutation of length can be hashed as , where is\r\nbitwise exclusive OR (for example, ). This representation is convenient\r\nbecause if we have two sets of numbers with a total number of elements\r\nequal to (letâs represent them as and , ), we can easily check whether\r\ntheir union is a permutation of length (condition must be hold). Letâs\r\ndenote as .Now letâs iterate over position such that and calculate the\r\nnumber of permutations that contain this element. To do it, letâs\r\niterate over the right boundary and suppose, that maximum element of\r\npermutation (and its length at the same time) is one of positions . If\r\nitâs true, then the subpermutation should be on the positions . And to\r\ncheck that this segment is a subpermutation we should just compare and\r\n.Thus, we will calculate all permutations in which the position of the\r\nmaximum is to the right of the position of the . To calculate all\r\npermutations we need to reverse array and repeat this algorithm, and\r\nthen add the number of ones in the array .\r\n",
    "hint": []
}