{
    "link": "https://codeforces.com//contest/1187/problem/F",
    "problemId": "365122",
    "problem_idx": "F",
    "shortId": "1187F",
    "contest_number": "1187",
    "problem_submissions": {
        "G": [
            56332310,
            56340989,
            56686103,
            56327820,
            56357942,
            56357893,
            56357546,
            56393615,
            56385554,
            56337872,
            56340206,
            56343105,
            56383525,
            56344635,
            56413429,
            56342762,
            56340438,
            56341811,
            56342716,
            56365621
        ],
        "F": [
            56329446,
            56334290,
            56324078,
            56328221,
            56327378,
            56337303,
            56342526,
            56331177,
            56340043,
            56336355,
            56334752,
            56336077,
            56336627,
            56360333
        ],
        "E": [
            56323030,
            56330456,
            56319363,
            56322371,
            56320247,
            56329005,
            56327923,
            56326133,
            56329409,
            56326249,
            56424958,
            56328252,
            56326656,
            56325346,
            56328882,
            56328436,
            56328661,
            56323830,
            56324440,
            56325389
        ],
        "D": [
            56321688,
            56327439,
            56325081,
            56328701,
            56323355,
            56322789,
            56358499,
            56324879,
            56323568,
            56320080,
            56323458,
            56413111,
            56325452,
            56541360,
            56321839,
            56320767,
            56323441
        ],
        "C": [
            56317291,
            56315455,
            56314711,
            56314827,
            56313223,
            56319121,
            56318984,
            56317025,
            56320070,
            56318484,
            56425545,
            56329379,
            56320274,
            56318352,
            56316738,
            56318754,
            56319277,
            56317240,
            56316893,
            56317391
        ],
        "B": [
            56314215,
            56313013,
            56312493,
            56311346,
            56311654,
            56315580,
            56313289,
            56312101,
            56313618,
            56315894,
            56313703,
            56315753,
            56314242,
            56313556,
            56315340,
            56314265,
            56313400,
            56314155,
            56314393
        ],
        "A": [
            56311354,
            56311017,
            56311059,
            56312444,
            56310978,
            56312306,
            56311272,
            56310955,
            56311255,
            56311625,
            56311777,
            56313786,
            56311277,
            56310994,
            56311316,
            56311426,
            56311025,
            56311856,
            56311363
        ]
    },
    "name": "F. Expected Square Beauty",
    "statement": "Let x be an array of integers x = [x_1, x_2,\r\ndots, x_n]. Let’s define B(x) as a minimal size of a partition of x into\r\nsubsegments such that all elements in each subsegment are equal. For\r\nexample, B([3, 3, 6, 1, 6, 6, 6]) = 4 using next partition: [3, 3\r\n|\r\n6\r\n|\r\n1\r\n|\r\n6, 6, 6].Now you don’t have any exact values of x, but you know that x_i\r\ncan be any integer value from [l_i, r_i] (l_i\r\nle r_i) uniformly at random. All x_i are independent.Calculate expected\r\nvalue of (B(x))^2, or E((B(x))^2). It’s guaranteed that the expected\r\nvalue can be represented as rational fraction\r\nfrac{P}{Q} where (P, Q) = 1, so print the value P\r\ncdot Q^{-1}\r\nmod 10^9 + 7.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst ll mod=1000*1000*1000+7;\n\nint n;\n\nll l[nax];\nll r[nax];\n\nll zm2, zm;\n\nll tu[nax];\n\nll dlu[nax];\n\nll dziel(ll a, ll b)\n{\n\t//~ debug() << a << \" \" << b;\n\ta%=mod;\n\tb%=mod;\n\tll wyk=mod-2;\n\twhile(wyk)\n\t{\n\t\tif (wyk&1)\n\t\t\ta=(a*b)%mod;\n\t\tb=(b*b)%mod;\n\t\twyk>>=1;\n\t}\n\treturn a;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &l[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%lld\", &r[i]);\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tll wsz=(r[i]-l[i]+1)*(r[i+1]-l[i+1]+1)%mod;\n\t\tll dob=0;\n\t\tll a=max(l[i], l[i+1]);\n\t\tll b=min(r[i], r[i+1]);\n\t\tif (a<=b)\n\t\t\tdob=b-a+1;\n\t\tdlu[i]=dob;\n\t\tll x=dziel(mod+wsz-dob, wsz);\n\t\tzm=(zm+x)%mod;\n\t\ttu[i]=x;\n\t}\n\tll s=0;\n\t//~ debug() << range(tu+1, tu+1+n);\n\tfor (int i=2; i<=n; i++)\n\t{\n\t\tzm2=(zm2+tu[i]*s)%mod;\n\t\ts=(s+tu[i-1])%mod;\n\t}\n\tfor (int i=1; i+2<=n; i++)\n\t{\n\t\tll wsz=(r[i]-l[i]+1)*(r[i+1]-l[i+1]+1)%mod*(r[i+2]-l[i+2]+1)%mod;\n\t\tll a=max(l[i], l[i+1]);\n\t\tll b=min(r[i], r[i+1]);\n\t\ta=max(a, l[i+2]);\n\t\tb=min(b, r[i+2]);\n\t\t//~ debug() << imie(wsz);\n\t\t//~ debug() << imie(dlu[i]*(r[i+2]-l[i+2]+1));\n\t\t//~ debug() << imie(dlu[i+1]*(r[i]-l[i]+1));\n\t\t//~ debug() << imie(max(0LL, b-a+1));\n\t\tzm2+=dziel(wsz-dlu[i]*(r[i+2]-l[i+2]+1)-dlu[i+1]*(r[i]-l[i]+1)+max(0LL, b-a+1), wsz);\n\t\tzm2%=mod;\n\t\tzm2+=mod;\n\t\tzm2%=mod;\n\t}\n\t\n\tdebug() << imie(zm);\n\tdebug() << imie(zm2);\n\t\n\tzm2=(zm2*2+zm)%mod;\n\t\n\tprintf(\"%lld\\n\", (zm2+2*zm+1)%mod);\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Expected Square Beauty.json",
    "editorial_link": "https://codeforces.com//blog/entry/68111",
    "editorial": "As usual with tasks on an expected value, letâs denote as indicator\r\nfunction: if and otherwise; . Then we can note that . Now we can make\r\nsome transformations: .Now weâd like to make some casework: if ( and\r\narenât consecutive) then and are independent, thatâs why ; if then ;\r\nneed further investigation. For the simplicity letâs transform segment\r\nto by increasing .Letâs denote as the probability that : and . Letâs\r\ndenote . In result, .The final observation is the following: is equal to\r\nthe probability that and and can be calculated by inclusion-exclusion\r\nprinciple: , where .In result, and can be calculated in time.\r\n",
    "hint": []
}