{
    "link": "https://codeforces.com//contest/1366/problem/E",
    "problemId": "646803",
    "problem_idx": "E",
    "shortId": "1366E",
    "contest_number": "1366",
    "problem_submissions": {
        "F": [
            83447668,
            83448434,
            83444622,
            83426763,
            83441574,
            83428280,
            83460965,
            83423891,
            83442353,
            83757770,
            83445090,
            83429919,
            83438895,
            83437207,
            83492622,
            83492442,
            83474062,
            83453556,
            83447806
        ],
        "G": [
            83429184,
            83428882,
            83457684,
            83412158,
            83433864,
            83437984,
            83494857,
            83757790,
            83510645,
            83444271,
            83455262,
            83440823,
            83444943,
            83578671,
            83450093
        ],
        "E": [
            83398532,
            83418602,
            83409360,
            83402434,
            83412489,
            83410962,
            83757722,
            83418361,
            83408316,
            83407997,
            83427080,
            83413277,
            83416924,
            83424580,
            83418188,
            83406625,
            83420403,
            83421638
        ],
        "D": [
            83393167,
            83406995,
            83402251,
            83397827,
            83397479,
            83404641,
            83397199,
            83402779,
            83757690,
            83407778,
            83401287,
            83402226,
            83406676,
            83407995,
            83406280,
            83407838,
            83409402,
            83421660,
            83414839,
            83414935
        ],
        "C": [
            83390782,
            83401605,
            83394916,
            83391593,
            83392337,
            83394149,
            83393867,
            83397548,
            83757664,
            83394207,
            83391231,
            83395559,
            83398133,
            83401855,
            83400985,
            83402206,
            83402544,
            83397821,
            83396193,
            83400630
        ],
        "B": [
            83389935,
            83490415,
            83397273,
            83390226,
            83389902,
            83389999,
            83390997,
            83390624,
            83757653,
            83390343,
            83389925,
            83392810,
            83391891,
            83392040,
            83392753,
            83394886,
            83392865,
            83391554,
            83391226,
            83391686
        ],
        "A": [
            83389637,
            83390640,
            83389645,
            83389626,
            83389634,
            83389655,
            83389755,
            83757620,
            83389748,
            83389663,
            83390083,
            83389875,
            83389821,
            83390216,
            83392108,
            83390187,
            83390121,
            83389679,
            83389858
        ]
    },
    "name": "E. Two Arrays",
    "statement": "You are given two arrays a_1, a_2,\r\ndots , a_n and b_1, b_2,\r\ndots , b_m. Array b is sorted in ascending order (b_i < b_{i + 1} for\r\neach i from 1 to m - 1).You have to divide the array a into m\r\nconsecutive subarrays so that, for each i from 1 to m, the minimum on\r\nthe i-th subarray is equal to b_i. Note that each element belongs to\r\nexactly one subarray, and they are formed in such a way: the first\r\nseveral elements of a compose the first subarray, the next several\r\nelements of a compose the second subarray, and so on.For example, if a =\r\n[12, 10, 20, 20, 25, 30] and b = [10, 20, 30] then there are two good\r\npartitions of array a: [12, 10, 20], [20, 25], [30]; [12, 10], [20, 20,\r\n25], [30]. You have to calculate the number of ways to divide the array\r\na. Since the number can be pretty large print it modulo .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tfriend modnum inv(const modnum& m) { return m.inv(); }\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tfriend modnum neg(const modnum& m) { return m.neg(); }\n\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\ntemplate <typename T> T pow(T a, long long b) {\n\tassert(b >= 0);\n\tT r = 1; while (b) { if (b & 1) r *= a; b >>= 1; a *= a; } return r;\n}\n\nusing num = modnum<998244353>;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> a(n), b(m);\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\tfor(int i = 0; i < m; i++) cin >> b[i];\n\tfor(int i = n-1; i > 0; i--) a[i-1] = min(a[i-1], a[i]);\n\tif(a[0] != b[0]){\n\t\tcout << 0 << '\\n';\n\t\treturn 0;\n\t}\n\tmap<int,int> where;\n\tfor(int i = 0; i < m; i++){\n\t\twhere[b[i]] = i;\n\t}\n\tvector<num> dp(m);\n\tdp[0] = 1;\n\tfor(int r : a){\n\t\tif(!where.count(r)) continue;\n\t\tr = where[r];\n\t\tif(r == 0) continue;\n\t\tdp[r] += dp[r-1];\n\t}\n\tcout << dp.back() << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "combinatorics",
        "constructive algorithms",
        "dp",
        "two pointers"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Two Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/78735",
    "editorial": "At first, letâs reverse arrays and . Now array is sorted in descending\r\norder.Now letâs find minimum index such that . If there is no such index\r\nor if then the answer is (because minimum on any prefix of array will\r\nnever be equal to ).Otherwise, letâs find the minimum index such that .\r\nIf there is no such index or if then the answer is . Also letâs find the\r\nminimum index such that (it canât be greater than ). The first subarray\r\nstarts in position and ends in any position (because if it ends in\r\nposition or further, then the minimum in the first subarray is greater\r\nthan ). So there are ways to split subarrays and .A similar approach can\r\nbe used to calculate the number of ways to split the second and third\r\nsubarrays and, so on.After all, you have to check that minimum in the\r\nlast subarray is equal to (otherwise the answer is ).\r\n",
    "hint": []
}