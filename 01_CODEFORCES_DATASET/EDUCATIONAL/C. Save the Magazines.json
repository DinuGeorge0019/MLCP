{
    "link": "https://codeforces.com//contest/1743/problem/C",
    "problemId": "1590318",
    "problem_idx": "C",
    "shortId": "1743C",
    "contest_number": "1743",
    "problem_submissions": {
        "G": [
            176744926,
            176752632,
            176765710,
            176759446,
            176826731,
            176825958,
            176825876,
            176825841,
            176825795,
            176825757,
            176777747,
            176767399,
            176787833,
            176794001,
            176793915,
            176793787,
            176793693,
            176793601,
            176793457,
            176793414,
            176793075,
            176792582,
            176790966,
            176790830,
            176790739,
            176790602,
            176790480,
            176790442,
            176790394,
            176877236,
            176797381,
            177041275
        ],
        "F": [
            176737097,
            176733706,
            176744244,
            176746662,
            176734362,
            176741223,
            176737910,
            176729577,
            176742322,
            176771541,
            176747634,
            176866127,
            176744359,
            176742533,
            176764904,
            176749314,
            176748844,
            176759565,
            176751246,
            176746192,
            176742294,
            176760205
        ],
        "E": [
            176732507,
            176757486,
            176736176,
            176739966,
            176749212,
            176748013,
            176727666,
            176739006,
            176729866,
            176763689,
            176763186,
            176762781,
            176756640,
            176764718,
            176740887,
            176756959,
            176787283,
            176742950,
            176761500,
            176766019,
            176770369,
            176749818
        ],
        "D": [
            176723746,
            176718140,
            176716615,
            176721411,
            176719450,
            176723698,
            176718782,
            176720745,
            176721715,
            176722102,
            176729581,
            176725500,
            176730292,
            176719597,
            176730936,
            176731941,
            176724207,
            176723731,
            176736911
        ],
        "C": [
            176716029,
            176704815,
            176706962,
            176708929,
            176705118,
            176704124,
            176715109,
            176705993,
            176708271,
            176707432,
            176707937,
            176714968,
            176710289,
            176708841,
            176705755,
            176710426,
            176713787,
            176707796,
            176708736,
            176710057
        ],
        "B": [
            176712751,
            176699478,
            176698683,
            176699488,
            176698322,
            176698046,
            176699875,
            176699384,
            176699501,
            176699739,
            176704430,
            176700303,
            176700238,
            176699124,
            176702452,
            176707386,
            176700133,
            176698867,
            176703708
        ],
        "A": [
            176712234,
            176698003,
            176697838,
            176697817,
            176697799,
            176697771,
            176697968,
            176697810,
            176698111,
            176698066,
            176699952,
            176697901,
            176698001,
            176697928,
            176699293,
            176697926,
            176697958,
            176697832,
            176698850
        ]
    },
    "name": "C. Save the Magazines",
    "statement": "Monocarp has been collecting rare magazines for quite a while, and now\r\nhe has decided to sell them. He distributed the magazines between n\r\nboxes, arranged in a row. The i-th box contains a_i magazines. Some of\r\nthe boxes are covered with lids, others are not. Suddenly it started to\r\nrain, and now Monocarp has to save as many magazines from the rain as\r\npossible. To do this, he can move the lids between boxes as follows: if\r\nthe i-th box was covered with a lid initially, he can either move the\r\nlid from the i-th box to the box (i-1) (if it exists), or keep the lid\r\non the i-th box. You may assume that Monocarp can move the lids\r\ninstantly at the same moment, and no lid can be moved more than once. If\r\na box will be covered with a lid after Monocarp moves the lids, the\r\nmagazines in it will be safe from the rain; otherwise they will soak.You\r\nhave to calculate the maximum number of magazines Monocarp can save from\r\nthe rain.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::string s;\n    std::cin >> s;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    for (int i = 0, j = -1; i < n; i++) {\n        if (s[i] == '0') {\n            j = i;\n        } else if (j >= 0 && a[i] < a[j]) {\n            std::swap(s[i], s[j]);\n            j = i;\n        }\n    }\n    \n    i64 ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (s[i] == '1') {\n            ans += a[i];\n        }\n    }\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dp",
        "greedy"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Save the Magazines.json",
    "editorial_link": "https://codeforces.com//blog/entry/108153",
    "editorial": "Letâs process the boxes from left to right.Consider the first box. If it\r\nhas a lid, then you can just add the number of magazines in it to the\r\nanswer and forget about this box. To be exact, proceed to solve the\r\nproblem with the first box removed.If it doesnât have a lid, then look\r\nat the next box. If it doesnât have a lid too, then this box can never\r\nbe covered. Remove it and proceed further.If the next box has a lid,\r\nthen look at the next one. Again, if it doesnât have a lid, then these\r\ntwo first boxes are solved independently of everything else. You can\r\ncover exactly one of them. Choose the bigger one and remove them both.To\r\npropagate the argument, letâs derive a pattern. First, thereâs a box\r\nwithout a lid. Then some number of boxes with lids in a row. Then a box\r\nwithout a lid again. Among the first box and the box with lids, you can\r\nchoose exactly one to not be covered. However, that can be any one of\r\nthem. The best box to be left uncovered is the one with the smallest\r\nnumber of magazines in it.Thus, the solution is the following. As long\r\nas the first box has a lid, keep removing the first box and adding it to\r\nthe answer. Then, as long as there are boxes left, take the first box\r\nand the largest number of consecutive boxes with lids after it (that\r\nnumber might be zero). On that segment, find the minimum value and the\r\nsum. Add the sum minus the minimum to the answer, remove the entire\r\nsegment.The removals can be done explicitly with a queue or just a\r\nreversed vector or implicitly with maintaining a pointer to the first\r\nnon-removed box.Overall complexity: .\r\n",
    "hint": []
}