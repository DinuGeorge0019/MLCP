{
    "link": "https://codeforces.com//contest/1598/problem/G",
    "problemId": "1138076",
    "problem_idx": "G",
    "shortId": "1598G",
    "contest_number": "1598",
    "problem_submissions": {
        "G": [
            131442050,
            131445550,
            131474021,
            131733851,
            189236477,
            131533150,
            131521436,
            131521173,
            131520806,
            131458159
        ],
        "F": [
            131413919,
            131426175,
            131419948,
            131424974,
            131423465,
            131425512,
            131426044,
            131429617,
            131434101,
            131424856,
            131429061,
            135925566,
            131432789,
            131436462,
            131426160,
            131433379,
            131432739,
            131442015,
            131426352,
            131438575
        ],
        "E": [
            131409216,
            131417508,
            131411965,
            131416590,
            131414689,
            131417539,
            131419673,
            131417908,
            131417850,
            131413609,
            131419666,
            131418620,
            131426224,
            131434401,
            131422338,
            131425095,
            131423673,
            131432059,
            131428300
        ],
        "D": [
            131405446,
            131408232,
            131403803,
            131406730,
            131406693,
            131408831,
            131409679,
            131411498,
            131409766,
            131431099,
            131412818,
            131410917,
            131408763,
            131411240,
            131414979,
            131418536,
            131414491,
            131405913,
            131414013,
            131411546
        ],
        "C": [
            131402318,
            131402805,
            131401746,
            131403276,
            131404307,
            131403297,
            131407011,
            131405600,
            131402882,
            131404574,
            131406244,
            131405518,
            131403235,
            131406335,
            131403809,
            131404263,
            131402426,
            131410937,
            131406878
        ],
        "B": [
            131399659,
            131401435,
            131400062,
            131400441,
            131401570,
            131401020,
            131401164,
            131404218,
            131400433,
            131402267,
            131404703,
            131402822,
            131405775,
            131403060,
            131401809,
            131401389,
            131400640,
            131406015,
            131403932
        ],
        "A": [
            131398034,
            131398273,
            131398102,
            131398196,
            131398135,
            131398297,
            131398147,
            131400227,
            131399230,
            131398720,
            131400611,
            131612251,
            131398353,
            131399540,
            131399744,
            131398269,
            131398178,
            131398070,
            131401090,
            131399096
        ]
    },
    "name": "G. The Sum of Good Numbers",
    "statement": "Let’s call a positive integer if there is no digit in its decimal\r\nrepresentation.For an array of a numbers a, one found out that the sum\r\nof some two neighboring elements is equal to x (i.e. x = a_i + a_{i + 1}\r\nfor some i). x had turned out to be a number as well.Then the elements\r\nof the array a were written out one after another without separators\r\ninto one string s. For example, if a = [12, 5, 6, 133], then s =\r\n1256133.You are given a string s and a number x. Your task is to\r\ndetermine the positions in the string that correspond to the adjacent\r\nelements of the array that have sum x. If there are several possible\r\nanswers, you can print any of them.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 10.10.2021 12:49:55       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  friend const Type& abs(const Modular& x) { return x.value; }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename V, typename U>\n  friend V& operator>>(V& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n  return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, long long>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n\n/*vector<Mint> fact(1, 1);\nvector<Mint> inv_fact(1, 1);\n\nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}*/\n\ntemplate <typename T>\nvector<int> z_function(int n, const T &s) {\n  vector<int> z(n, n);\n  int l = 0, r = 0;\n  for (int i = 1; i < n; i++) {\n    z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {\n      z[i]++;\n    }\n    if (i + z[i] - 1 > r) {\n      l = i;\n      r = i + z[i] - 1;\n    }\n  }\n  return z;\n}\n\ntemplate <typename T>\nvector<int> z_function(const T &s) {\n  return z_function((int) s.size(), s);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  string s_;\n  cin >> s_;\n  string x_;\n  cin >> x_;\n  int n = (int) s_.size();\n  int m = (int) x_.size();\n  vector<int> s(n);\n  for (int i = 0; i < n; i++) {\n    s[i] = (int) (s_[i] - '0');\n  }\n  vector<int> x(m);\n  for (int i = 0; i < m; i++) {\n    x[i] = (int) (x_[i] - '0');\n  }\n  vector<int> seq = x;\n  seq.insert(seq.end(), s.begin(), s.end());\n  auto z = z_function(seq);\n  auto Check = [&](int l1, int r1, int l2, int r2) {\n    int i = r1;\n    int j = r2;\n    int c = 0;\n    for (int q = m - 1; q >= 0; q--) {\n      if (i >= l1) {\n        c += s[i];\n        i -= 1;\n      }\n      if (j >= l2) {\n        c += s[j];\n        j -= 1;\n      }\n      int nc = 0;\n      if (c >= 10) {\n        c -= 10;\n        nc = 1;\n      }\n      if (x[q] != c) {\n        return;\n      }\n      c = nc;\n    }\n    if (c != 0 || i >= l1 || j >= l2) {\n      return;\n    }\n    cout << l1 + 1 << \" \" << r1 + 1 << '\\n';\n    cout << l2 + 1 << \" \" << r2 + 1 << '\\n';\n    exit(0);\n  };\n  {\n    mt19937 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n    while (true) {\n      md = (int) 1e8 + rng() % (int) 9e8;\n      bool pr = true;\n      for (int i = 2; i * i <= md; i++) {\n        if (md % i == 0) {\n          pr = false;\n          break;\n        }\n      }\n      if (pr) {\n        break;\n      }\n    }\n  }\n  vector<Mint> p10(n + 1);\n  p10[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    p10[i] = p10[i - 1] * 10;\n  }\n  Mint inv_10 = 1 / Mint(10);\n  vector<Mint> inv_p10(n + 1);\n  inv_p10[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    inv_p10[i] = inv_p10[i - 1] * inv_10;\n  }\n  vector<Mint> suf(n + 1);\n  for (int i = n - 1; i >= 0; i--) {\n    suf[i] = suf[i + 1] + p10[n - 1 - i] * s[i];\n  }\n  vector<pair<int, int>> all_suf(n + 1);\n  for (int i = 0; i <= n; i++) {\n    all_suf[i] = make_pair(suf[i](), i);\n  }\n  sort(all_suf.begin(), all_suf.end());\n/*  vector<Mint> pref(n + 1);\n  for (int i = 0; i < n; i++) {\n    pref[i + 1] = pref[i] * 10 + s[i];\n  }\n  vector<pair<int, int>> all_pref(n + 1);\n  for (int i = 0; i <= n; i++) {\n    all_pref[i] = make_pair(pref[i](), i);\n  }\n  sort(all_pref.begin(), all_pref.end());*/\n  Mint x_val = 0;\n  for (int i = 0; i < m; i++) {\n    x_val = x_val * 10 + x[i];\n  }\n  for (int k = m; k >= m - 1 && k >= 1; k--) {\n    for (int i = 0; i <= n - k; i++) {\n      Mint me = (suf[i] - suf[i + k]) * inv_p10[n - (i + k)];\n      Mint goal = x_val - me;\n      { // pref[j] - pref[i + k] * p10[j - (i + k)] == goal\n        // pref[j] * inv_p10[j] - pref[i + k] * inv_p10[i + k] == goal * inv_p10[j]\n        // (suf[i + k] - suf[j]) * inv_p10[n - j] == goal\n        // (suf[i + k] - suf[j]) * inv_p10[n - j] + (suf[i] - suf[i + k]) * inv_p10[n - (i + k)] == x_val\n        // sad...\n        auto Test = [&](int len) {\n          if (len >= 1 && len <= m) {\n            int j = i + k + len;\n            if (j <= n) {\n              if ((suf[i + k] - suf[j]) * inv_p10[n - j] == goal) {\n                Check(i, i + k - 1, i + k, j - 1);\n              }\n            }\n          }\n        };\n        if (k == m - 1) {\n          Test(m - 1);\n          Test(m);\n        } else {\n          int match = min(m, z[m + i]);\n          Test(m - match);\n          Test(m - match - 1);\n        }\n      }\n      { // (suf[j] - suf[i]) * inv_p10[n - i] == goal\n        Mint needle = goal * p10[n - i] + suf[i];\n        auto it = lower_bound(all_suf.begin(), all_suf.end(), make_pair(needle(), -1));\n        while (it != all_suf.end() && it->first == needle) {\n          int j = it->second;\n          if (j < i && i - j <= m) {\n            Check(j, i - 1, i, i + k - 1);\n          }\n          ++it;\n        }\n      }\n    }\n  }\n  assert(false);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "hashing",
        "math",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. The Sum of Good Numbers.json",
    "editorial_link": "https://codeforces.com//blog/entry/95890",
    "editorial": "Letâs denote as the largest of the terms of the sum, and is the smaller\r\none.Consider cases: or .If , then . So we need to find two consecutive\r\nsubstrings of length such that if we convert these substrings into\r\nintegers, their sum is equal to .If , let be the largest common prefix\r\nof and if we consider them as strings. Then or . So it is necessary to\r\ncheck only these two cases, and whether goes before or after (in the\r\nstring ).Thus, we have reduced the number of variants where the\r\nsubstrings for and are located to . It remains to consider how to\r\nquickly check whether the selected substrings are suitable. To do this,\r\nyou can use hashes (preferably with several random modules).\r\n",
    "hint": []
}