{
    "link": "https://codeforces.com//contest/2025/problem/B",
    "problemId": "2948772",
    "problem_idx": "B",
    "shortId": "2025B",
    "contest_number": "2025",
    "problem_submissions": {
        "G": [
            285888128,
            285968165,
            285968156,
            285968149,
            285968144,
            285897832,
            285920810,
            285910851,
            285909011,
            285930826,
            285929850,
            285925790,
            285926690,
            285922742,
            285921341,
            285927635,
            285927533,
            285927378,
            285927290,
            285927201,
            285926718,
            285927241,
            285924989,
            299831833,
            286121442
        ],
        "F": [
            285868426,
            285875834,
            285881666,
            285895954,
            285888111,
            285886401,
            285885303,
            285891958,
            285893731,
            285892263,
            285879653,
            285886660,
            285891778,
            285886231,
            285896708,
            285895437,
            285887128,
            285901645,
            285898009,
            285911413,
            285909168
        ],
        "E": [
            285859957,
            285867757,
            285870223,
            285876387,
            285873807,
            285876494,
            285872556,
            285873708,
            285881956,
            285870423,
            285874469,
            285878077,
            285869033,
            285872685,
            285876656,
            285892958,
            285888168,
            285880850,
            285877703,
            285879472
        ],
        "C": [
            285855265,
            285848963,
            285851041,
            285855836,
            285849335,
            285851254,
            285854960,
            285854181,
            285864164,
            285852009,
            285850624,
            285853432,
            285850248,
            285850107,
            285852412,
            285937663,
            285937269,
            285852480,
            285853757,
            285856229,
            285852397,
            285853481
        ],
        "D": [
            285854273,
            285858071,
            285858183,
            285867921,
            285860641,
            285863810,
            285864716,
            285864881,
            285873876,
            285863514,
            285859817,
            285865001,
            285869981,
            285860140,
            285866304,
            285941352,
            285868260,
            285864450,
            285868121,
            285865847,
            285869499
        ],
        "B": [
            285844312,
            285844368,
            285843910,
            285848590,
            285844872,
            285845275,
            285846752,
            285845703,
            285858394,
            285844772,
            285844563,
            285847140,
            285845401,
            285845320,
            285848121,
            285848201,
            285847162,
            285850578,
            285846812,
            285847900
        ],
        "A": [
            285841954,
            285841960,
            285842031,
            285842286,
            285842224,
            285842066,
            285842261,
            285842191,
            285843710,
            285842044,
            285842146,
            285842134,
            285841991,
            285842021,
            285846906,
            285842091,
            285842126,
            285842764,
            285842102,
            285842266
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/135173",
    "editorial": "In order to solve the task, just try to generate values and find a\r\npattern. The pattern is easy: for all .The last step is to calculate\r\nfast enough. For example, we can precalculate all powers of two in some\r\narray as for all and print the necessary values when asked.Proof:\r\n",
    "name": "B. Binomial Coefficients, Kind Of",
    "statement": "Recently, akshiM met a task that needed binomial coefficients to solve.\r\nHe wrote a code he usually does that looked like this: for (int n = 0; n\r\n< N; n++) { // loop over n from 0 to N-1 (inclusive) C[n][0] = 1;\r\nC[n][n] = 1; for (int k = 1; k < n; k++) // loop over k from 1 to n-1\r\n(inclusive) C[n][k] = C[n][k - 1] + C[n - 1][k - 1]; }Unfortunately, he\r\nmade an error, since the right formula is the following: C[n][k] = C[n -\r\n1][k] + C[n - 1][k - 1]But his team member keblidA is interested in\r\nvalues that were produced using the wrong formula. Please help him to\r\ncalculate these coefficients for t various pairs (n_i, k_i). Note that\r\nthey should be calculated according to the first (wrong) formula.Since\r\nvalues C[n_i][k_i] may be too large, print them modulo 10^9 + 7.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\u00a0using i64 = long long;using u64 = unsigned long long;using u32 = unsigned;// TODO: Dynamic ModInt\u00a0template<typename T>constexpr T power(T a, u64 b) {    T res {1};    for (; b != 0; b /= 2, a *= a) {        if (b % 2 == 1) {            res *= a;        }    }    return res;}\u00a0template<u32 P>constexpr u32 mulMod(u32 a, u32 b) {    return 1ULL * a * b % P;}\u00a0template<u64 P>constexpr u64 mulMod(u64 a, u64 b) {    u64 res = a * b - u64(1.L * a * b / P - 0.5L) * P;    res %= P;    return res;}\u00a0template<typename U, U P>requires std::unsigned_integral<U>struct ModIntBase {public:    constexpr ModIntBase() : x(0) {}        template<typename T>    requires std::integral<T>    constexpr ModIntBase(T x_) : x(norm(x_ % T {P})) {}        constexpr static U norm(U x) {        if ((x >> (8 * sizeof(U) - 1) & 1) == 1) {            x += P;        }        if (x >= P) {            x -= P;        }        return x;    }        constexpr U val() const {        return x;    }        constexpr ModIntBase operator-() const {        ModIntBase res;        res.x = norm(P - x);        return res;    }        constexpr ModIntBase inv() const {        return power(*this, P - 2);    }        constexpr ModIntBase &operator*=(const ModIntBase &rhs) & {        x = mulMod<P>(x, rhs.val());        return *this;    }        constexpr ModIntBase &operator+=(const ModIntBase &rhs) & {        x = norm(x + rhs.x);        return *this;    }        constexpr ModIntBase &operator-=(const ModIntBase &rhs) & {        x = norm(x - rhs.x);        return *this;    }        constexpr ModIntBase &operator/=(const ModIntBase &rhs) & {        return *this *= rhs.inv();    }        friend constexpr ModIntBase operator*(ModIntBase lhs, const ModIntBase &rhs) {        lhs *= rhs;        return lhs;    }        friend constexpr ModIntBase operator+(ModIntBase lhs, const ModIntBase &rhs) {        lhs += rhs;        return lhs;    }        friend constexpr ModIntBase operator-(ModIntBase lhs, const ModIntBase &rhs) {        lhs -= rhs;        return lhs;    }        friend constexpr ModIntBase operator/(ModIntBase lhs, const ModIntBase &rhs) {        lhs /= rhs;        return lhs;    }        friend constexpr std::ostream &operator<<(std::ostream &os, const ModIntBase &a) {        return os << a.val();    }        friend constexpr bool operator==(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() == rhs.val();    }        friend constexpr bool operator!=(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() != rhs.val();    }        friend constexpr bool operator<(ModIntBase lhs, ModIntBase rhs) {        return lhs.val() < rhs.val();    }    private:    U x;};\u00a0template<u32 P>using ModInt = ModIntBase<u32, P>;\u00a0template<u64 P>using ModInt64 = ModIntBase<u64, P>;\u00a0constexpr u32 P = 1000000007;using Z = ModInt<P>;\u00a0int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        for (int i = 0; i < t; i++) {        int n;        std::cin >> n;    }    for (int i = 0; i < t; i++) {        int k;        std::cin >> k;        std::cout << power(Z(2), k) << \"\\n\";    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Binomial Coefficients, Kind Of.json"
}