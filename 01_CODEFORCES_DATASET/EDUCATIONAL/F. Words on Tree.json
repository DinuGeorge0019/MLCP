{
    "link": "https://codeforces.com//contest/1657/problem/F",
    "problemId": "1339156",
    "problem_idx": "F",
    "shortId": "1657F",
    "contest_number": "1657",
    "problem_submissions": {
        "F": [
            150503115,
            150499453,
            150509321,
            150511905,
            150517571,
            150521311,
            150511942,
            150512719,
            150504329,
            150515960,
            150512240,
            150519562,
            150516193,
            150522557,
            150517792,
            150525082,
            150521099,
            150526532,
            150498258
        ],
        "E": [
            150486345,
            150490802,
            150491754,
            150496559,
            150501319,
            150488737,
            150492757,
            150496033,
            150497203,
            150502682,
            150498901,
            150493901,
            150495208,
            150499778,
            150499542,
            150491019,
            150503092,
            150493803,
            150498682
        ],
        "D": [
            150478088,
            150483562,
            150484230,
            150485188,
            150483314,
            150482900,
            150485882,
            150491440,
            150494087,
            150489766,
            150493543,
            150488170,
            150502719,
            150493520,
            150493571,
            150497861,
            150497439,
            150487471,
            150503395
        ],
        "C": [
            150470574,
            150477398,
            150472059,
            150473115,
            150473331,
            150472319,
            150476196,
            150478092,
            150490090,
            150480365,
            150484688,
            150478395,
            150476845,
            150477792,
            150483257,
            150480052,
            150480944,
            150481904,
            150506549
        ],
        "B": [
            150466899,
            150465684,
            150465706,
            150466831,
            150467217,
            150466293,
            150467748,
            150486194,
            150467057,
            150470591,
            150468677,
            150466989,
            150468064,
            150466642,
            150468045,
            150467383,
            150467499,
            150468669
        ],
        "A": [
            150464865,
            150464773,
            150464769,
            150464812,
            150465126,
            150464939,
            150464906,
            150472446,
            150464866,
            150467928,
            150466097,
            150464791,
            150464960,
            150464872,
            150464833,
            150465034,
            150465120,
            150470046
        ]
    },
    "name": "F. Words on Tree",
    "statement": "You are given a tree consisting of n vertices, and q triples (x_i, y_i,\r\ns_i), where x_i and y_i are integers from 1 to n, and s_i is a string\r\n.You want to write a lowercase Latin letter on each vertex in such a way\r\nthat, for each of q given triples, at least one of the following\r\nconditions holds: if you write out the letters on the vertices on the\r\nsimple path from x_i to y_i in the order they appear on this path, you\r\nget the string s_i; if you write out the letters on the vertices on the\r\nsimple path from y_i to x_i in the order they appear on this path, you\r\nget the string s_i. Find any possible way to write a letter on each\r\nvertex to meet these constraints, or report that it is impossible.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 400400;\nint n, m;\nvector<int> T[N];\nvector<pii> g[N];\nint h[N], par[N];\nvector<int> path[N];\nstring str[N];\nint sz[N];\nchar cc[N][2];\nvector<int> a[N][2];\nint col[N];\nstring ans;\n\nvoid Fail() {\n\tcout << \"NO\\n\";\n\texit(0);\n}\n\nvoid dfsTree(int v, int p) {\n\tpar[v] = p;\n\tfor (int u : T[v]) if (u != p) {\n\t\th[u] = h[v] + 1;\n\t\tdfsTree(u, v);\n\t}\n}\nvector<int> getPath(int v, int u) {\n\tvector<int> p1, p2;\n\twhile(v != u) {\n\t\tif (h[v] > h[u]) {\n\t\t\tp1.push_back(v);\n\t\t\tv = par[v];\n\t\t} else {\n\t\t\tp2.push_back(u);\n\t\t\tu = par[u];\n\t\t}\n\t}\n\tp1.push_back(v);\n\treverse(all(p2));\n\tfor (int x : p2) p1.push_back(x);\n\treturn p1;\n}\n\nvoid myBan(int v) {\n\tint c = 0;\n\tif (v < 0) {\n\t\tc = 1;\n\t\tv = -v;\n\t}\n\tif (col[v] == -1) col[v] = c ^ 1;\n\tif (col[v] == c) Fail();\n}\nvoid addEdge(int v, int u) {\n\tint c = 0;\n\tif (v < 0) {\n\t\tv = -v;\n\t\tc ^= 1;\n\t}\n\tif (u < 0) {\n\t\tu = -u;\n\t\tc ^= 1;\n\t}\n\tg[v].push_back(mp(u, c));\n\tg[u].push_back(mp(v, c));\n}\nvoid dfsCol(int v) {\n\tfor (pii e : g[v]) {\n\t\tint u = e.first;\n\t\tint c = col[v] ^ e.second;\n\t\tif (col[u] == -1) {\n\t\t\tcol[u] = c;\n\t\t\tdfsCol(u);\n\t\t} else {\n\t\t\tif (col[u] != c) Fail();\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tfor (int i = 1; i < n; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tT[v].push_back(u);\n\t\tT[u].push_back(v);\n\t}\n\tdfsTree(1, 0);\n\tfor (int i = 1; i <= m; i++)\n\t\tcol[i] = -1;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tpath[i] = getPath(v, u);\n\t\tcin >> str[i];\n\t\tassert((int)path[i].size() == (int)str[i].size());\n\t\tfor (int j = 0; j < (int)path[i].size(); j++) {\n\t\t\tv = path[i][j];\n\t\t\tchar c1 = str[i][j], c2 = str[i][(int)path[i].size() - 1 - j];\n\t\t\tif (c1 == c2) {\n\t\t\t\tif (sz[v] == 0) {\n\t\t\t\t\tsz[v] = 1;\n\t\t\t\t\tcc[v][0] = c1;\n\t\t\t\t} else {\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\twhile(cc[v][pos] != c1 && pos < sz[v]) pos++;\n\t\t\t\t\tif (pos == sz[v]) Fail();\n\t\t\t\t\tfor (int p = 0; p < sz[v]; p++) if (p != pos)\n\t\t\t\t\t\tfor (int x : a[v][p])\n\t\t\t\t\t\t\tmyBan(x);\n\t\t\t\t\tcc[v][0] = cc[v][pos];\n\t\t\t\t\ta[v][0] = a[v][pos];\n\t\t\t\t\tsz[v] = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (sz[v] == 0) {\n\t\t\t\t\tsz[v] = 2;\n\t\t\t\t\tcc[v][0] = c1;\n\t\t\t\t\ta[v][0].push_back(i);\n\t\t\t\t\tcc[v][1] = c2;\n\t\t\t\t\ta[v][1].push_back(-i);\n\t\t\t\t} else {\n\t\t\t\t\tbool ok1 = false;\n\t\t\t\t\tbool ok2 = false;\n\t\t\t\t\tint pos = 0;\n\t\t\t\t\twhile(pos < sz[v]) {\n\t\t\t\t\t\tif (cc[v][pos] == c1) {\n\t\t\t\t\t\t\ta[v][pos].push_back(i);\n\t\t\t\t\t\t\tok1 = true;\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t} else if (cc[v][pos] == c2) {\n\t\t\t\t\t\t\ta[v][pos].push_back(-i);\n\t\t\t\t\t\t\tok2 = true;\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (int x : a[v][pos])\n\t\t\t\t\t\t\t\tmyBan(x);\n\t\t\t\t\t\t\tfor (int p = pos + 1; p < sz[v]; p++) {\n\t\t\t\t\t\t\t\tcc[v][p - 1] = cc[v][p];\n\t\t\t\t\t\t\t\ta[v][p - 1] = a[v][p];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsz[v]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ok1) myBan(i);\n\t\t\t\t\tif (!ok2) myBan(-i);\n\t\t\t\t\tassert(sz[v] > 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int v = 1; v <= n; v++)\n\t\tfor (int p = 0; p < sz[v]; p++) if (!a[v][p].empty()) {\n\t\t\tint x = a[v][p][0];\n\t\t\tfor (int y : a[v][p])\n\t\t\t\taddEdge(x, y);\n\t\t}\n\tfor (int v = 1; v <= m; v++) if (col[v] != -1)\n\t\tdfsCol(v);\n\tfor (int v = 1; v <= m; v++) if (col[v] == -1) {\n\t\tcol[v] = 0;\n\t\tdfsCol(v);\n\t}\n\tans.resize(n);\n\tfor (int i = 0; i < n; i++)\n\t\tans[i] = 'a';\n\tfor (int v = 1; v <= m; v++) {\n\t\tif (col[v] == 1) {\n\t\t\treverse(all(path[v]));\n\t\t}\n\t\tfor (int i = 0; i < (int)path[v].size(); i++)\n\t\t\tans[path[v][i] - 1] = str[v][i];\n\t}\n\tcout << \"YES\\n\" << ans << \"\\n\";\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "2-sat",
        "dfs and similar",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Words on Tree.json",
    "editorial_link": "https://codeforces.com//blog/entry/101161",
    "editorial": "Let\u00e2\u0080\u0099s design a naive solution first. For each of the given triples, we\r\nhave two options: either write the string on the tree in the order from\r\nto , or in reverse order. Some options conflict with each other. So, we\r\ncan treat this problem as an instance of 2-SAT: create a variable for\r\neach of the given strings, which is true if the string is not reversed,\r\nand false if it is reversed; find all conflicting pairs of options and\r\nthen run the usual algorithm for solving 2-SAT.Unfortunately, the number\r\nof conflicting pairs can be up to , so we need to improve this solution.\r\nLet\u00e2\u0080\u0099s introduce a variable for each vertex of the tree which will define\r\nthe character we write on it. At first, it looks like we can\u00e2\u0080\u0099t use these\r\nvariables in 2-SAT, since the number of possible characters is , not .\r\nBut if a vertex is covered by at least one path in a triple, then there\r\nare only two possible characters we can write in this vertex: either the\r\ncharacter which will land on this position if we write the string from\r\nto , or the character on the opposite position in the string . And,\r\nobviously, if a vertex is not covered by any triple, we can write any\r\ncharacter on it.Okay, now for each vertex , we have two options for a\r\ncharacter: and . Let the variable be true if we write on vertex , and\r\nfalse if we write . Also, for each triple , let\u00e2\u0080\u0099s introduce a variable\r\nwhich is true if the string is written from to , and false if it is\r\nwritten in reversed order. If the vertex is the -th one on the path from\r\nto , then we should add the following constraints in our 2-SAT: if , we\r\nneed a constraint \"NOT OR NOT \"; if , we need a constraint \" OR NOT \";\r\nif , we need a constraint \"NOT OR \"; if , we need a constraint \" OR \".\r\nThus, we add at most constraints in our 2-SAT. The only thing we haven\u00e2\u0080\u0099t\r\ndiscussed is how to actually restore each path from to ; this can be\r\ndone either with any fast algorithm that finds LCA, or by searching for\r\nLCA \"naively\" by ascending from one of those vertices until we arrive at\r\nthe ancestor of another vertex; this approach will visit at most\r\nvertices.Overall, this solution runs in .\r\n"
}