{
    "link": "https://codeforces.com//contest/1257/problem/D",
    "problemId": "470639",
    "problem_idx": "D",
    "shortId": "1257D",
    "contest_number": "1257",
    "problem_submissions": {
        "D": [
            65057118,
            65056815,
            64811909,
            64812228,
            64902701,
            64852999,
            64814000,
            64812775,
            64810546,
            64816528,
            64811860,
            64815149,
            64813583,
            64859190,
            64812263,
            64833625,
            64835681,
            64837730,
            64812160,
            64814684,
            64816849,
            64813089,
            64816979,
            64819402,
            64816732
        ],
        "C": [
            65056409,
            64806576,
            64805235,
            64806785,
            64807190,
            64804696,
            64807450,
            64806032,
            64809153,
            64805479,
            64859181,
            64806083,
            64833699,
            64837249,
            64838553,
            64806562,
            64809106,
            64808660,
            64805745,
            64806256,
            64807560,
            64807194
        ],
        "G": [
            64897847,
            64897831,
            64897799,
            64897485,
            64897435,
            64897360,
            64897323,
            64897206,
            64897135,
            64897132,
            64832008,
            64834753,
            64834055,
            65121895,
            65107512,
            65106890,
            64896695,
            64896568,
            64824847,
            64838006,
            64831302,
            64827437,
            64838916,
            64835759,
            64897295,
            64843586,
            64835359,
            64859234,
            64838704,
            65758026,
            65701826,
            64838221,
            64811892,
            64819153,
            64825152,
            64845699,
            211233713
        ],
        "E": [
            64865638,
            64865598,
            64816641,
            64819423,
            64857985,
            64831912,
            64817543,
            64814313,
            64819647,
            64817584,
            64819210,
            64817767,
            64859197,
            64814324,
            64824835,
            64832464,
            64832777,
            64820509,
            64818561,
            64820860,
            64817451,
            64823687,
            64821709,
            64824423
        ],
        "F": [
            64821055,
            64823926,
            64819069,
            64824118,
            64836060,
            64833509,
            64822156,
            64828427,
            64823151,
            64859227,
            64836114,
            64824755,
            64828355,
            64829448,
            64829060,
            64827403,
            64826552,
            64828456,
            64828341,
            64826098,
            64830812
        ],
        "B": [
            64802390,
            64803311,
            64804526,
            64804462,
            64802487,
            64804783,
            64803616,
            64806366,
            64802273,
            64859169,
            64803153,
            64833735,
            64838243,
            64839005,
            64803686,
            64806451,
            64806108,
            64802622,
            64803655,
            64803331,
            64803958
        ],
        "A": [
            64800956,
            64800953,
            64801859,
            64801038,
            64800918,
            64800975,
            64800962,
            64803138,
            64800908,
            64859160,
            64801089,
            64833779,
            64838753,
            64839327,
            64800961,
            64801572,
            64801191,
            64800917,
            64801440,
            64800919,
            64801087
        ]
    },
    "name": "D. Yet Another Monster Killing Problem",
    "statement": "You play a computer game. In this game, you lead a party of m heroes,\r\nand you have to clear a dungeon with n monsters. Each monster is\r\ncharacterized by its power a_i. Each hero is characterized by his power\r\np_i and endurance s_i.The heroes clear the dungeon day by day. In the\r\nbeginning of each day, you choose a hero (exactly one) who is going to\r\nenter the dungeon this day.When the hero enters the dungeon, he is\r\nchallenged by the first monster which was not defeated during the\r\nprevious days (so, if the heroes have already defeated k monsters, the\r\nhero fights with the monster k + 1). When the hero fights the monster,\r\nthere are two possible outcomes: if the monster’s power is strictly\r\ngreater than the hero’s power, the hero retreats from the dungeon. The\r\ncurrent day ends; otherwise, the monster is defeated. After defeating a\r\nmonster, the hero either continues fighting with the next monster or\r\nleaves the dungeon. He leaves the dungeon either if he has already\r\ndefeated the number of monsters equal to his endurance during this day\r\n(so, the i-th hero cannot defeat more than s_i monsters during each\r\nday), or if all monsters are defeated otherwise, he fights with the next\r\nmonster. When the hero leaves the dungeon, the current day ends.Your\r\ngoal is to defeat the last monster. What is the minimum number of days\r\nthat you need to achieve your goal? Each day you have to use exactly one\r\nhero; it is possible that some heroes don’t fight the monsters at all.\r\nEach hero can be used arbitrary number of times.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nnamespace IO {\n    const int BUFFER_SIZE = 1 << 15;\n\n    char input_buffer[BUFFER_SIZE];\n    int input_pos = 0, input_len = 0;\n\n    char output_buffer[BUFFER_SIZE];\n    int output_pos = 0;\n\n    char number_buffer[100];\n    uint8_t lookup[100];\n\n    void _update_input_buffer() {\n        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);\n        input_pos = 0;\n\n        if (input_len == 0)\n            input_buffer[0] = EOF;\n    }\n\n    inline char next_char(bool advance = true) {\n        if (input_pos >= input_len)\n            _update_input_buffer();\n\n        return input_buffer[advance ? input_pos++ : input_pos];\n    }\n\n    template<typename T>\n    inline void read_int(T &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == '-')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - '0');\n        } while (isdigit(next_char(false)));\n\n        if (negative)\n            number = -number;\n    }\n\n    template<typename T, typename... Args>\n    inline void read_int(T &number, Args &... args) {\n        read_int(number);\n        read_int(args...);\n    }\n\n    void _flush_output() {\n        fwrite(output_buffer, sizeof(char), output_pos, stdout);\n        output_pos = 0;\n    }\n\n    inline void write_char(char c) {\n        if (output_pos == BUFFER_SIZE)\n            _flush_output();\n\n        output_buffer[output_pos++] = c;\n    }\n\n    template<typename T>\n    inline void write_int(T number, char after = '\\0') {\n        if (number < 0) {\n            write_char('-');\n            number = -number;\n        }\n\n        int length = 0;\n\n        while (number >= 10) {\n            uint8_t lookup_value = lookup[number % 100];\n            number /= 100;\n            number_buffer[length++] = (lookup_value & 15) + '0';\n            number_buffer[length++] = (lookup_value >> 4) + '0';\n        }\n\n        if (number != 0 || length == 0)\n            write_char(number + '0');\n\n        for (int i = length - 1; i >= 0; i--)\n            write_char(number_buffer[i]);\n\n        if (after)\n            write_char(after);\n    }\n\n    void init() {\n        // Make sure _flush_output() is called at the end of the program.\n        bool exit_success = atexit(_flush_output) == 0;\n        assert(exit_success);\n\n        for (int i = 0; i < 100; i++)\n            lookup[i] = (i / 10 << 4) + i % 10;\n    }\n}\n\n\nvoid solve_case() {\n    int N, M;\n    IO::read_int(N);\n    vector<int> A(N);\n    vector<int> best_power(N + 1, 0);\n\n    for (auto &a : A)\n        IO::read_int(a);\n\n    IO::read_int(M);\n\n    for (int i = 0; i < M; i++) {\n        int p, s;\n        IO::read_int(p, s);\n        best_power[s] = max(best_power[s], p);\n    }\n\n    for (int s = N - 1; s >= 0; s--)\n        best_power[s] = max(best_power[s], best_power[s + 1]);\n\n    if (*max_element(A.begin(), A.end()) > best_power[0]) {\n        IO::write_int(-1, '\\n');\n        return;\n    }\n\n    int start = 0, days = 0;\n\n    while (start < N) {\n        int monsters = 0, maximum = 0;\n\n        while (start + monsters < N) {\n            maximum = max(maximum, A[start + monsters]);\n\n            if (best_power[monsters + 1] >= maximum)\n                monsters++;\n            else\n                break;\n        }\n\n        start += monsters;\n        days++;\n    }\n\n    IO::write_int(days, '\\n');\n}\n\nint main() {\n    IO::init();\n\n    int T;\n    IO::read_int(T);\n\n    while (T-- > 0)\n        solve_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "dp",
        "greedy",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Yet Another Monster Killing Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/71434",
    "editorial": "At first, lets precalc array ; is equal to maximum hero power whose\r\nendurance is greater than or equal to . Now letâs notice that every day\r\nitâs profitable for as to kill as many monster as possible. Remains to\r\nunderstand how to calculate it.Suppose that we already killed monsters.\r\nIf then answer is , because we canât kill the -th monster. Otherwise we\r\ncan kill at least monsters. All we have to do it increase the value\r\nuntil conditions holds. After calculating the value we just move to the\r\nnext day with killed monsters.\r\n",
    "hint": []
}