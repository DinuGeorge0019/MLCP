{
    "link": "https://codeforces.com//contest/1861/problem/F",
    "problemId": "2187866",
    "problem_idx": "F",
    "shortId": "1861F",
    "contest_number": "1861",
    "problem_submissions": {
        "F": [
            221319232,
            221334797,
            221343700,
            221334746,
            221435327
        ],
        "E": [
            221294949,
            221294627,
            221307083,
            221304545,
            221289987,
            221293214,
            221302482,
            221312615,
            221307967,
            221303480,
            221309861,
            221307296,
            221307859,
            221320123,
            221304501,
            221805824,
            221308535,
            221309691,
            221307994,
            221314449,
            221316461
        ],
        "D": [
            221289547,
            221296942,
            221291864,
            221307784,
            221293468,
            221297421,
            221296816,
            221288510,
            221291806,
            221295562,
            221296430,
            221296186,
            221290647,
            221296713,
            221298445,
            221297975,
            221298865,
            221297626,
            221298343
        ],
        "C": [
            221285558,
            221285843,
            221287563,
            221293257,
            221282816,
            221283475,
            221287126,
            221284366,
            221286970,
            221291172,
            221290155,
            221290726,
            221290133,
            221287629,
            221289108,
            221291690,
            221291845,
            221290307,
            221291196,
            221291877
        ],
        "B": [
            221280891,
            221279490,
            221280612,
            221282637,
            221278148,
            221277443,
            221280003,
            221278598,
            221281862,
            221281453,
            221282384,
            221284462,
            221279905,
            221283500,
            221283423,
            221284241,
            221280164,
            221284009,
            221283159
        ],
        "A": [
            221277133,
            221276828,
            221277503,
            221276971,
            221276729,
            221276717,
            221276917,
            221276888,
            221277198,
            221278164,
            221278677,
            221280809,
            221276797,
            221278399,
            221277159,
            221277434,
            221276991,
            221278067,
            221276850
        ]
    },
    "name": "F. Four Suits",
    "statement": "The game of Berland poker is played as follows. There are n+1 people: n\r\nplayers, numbered from 1 to n, and the dealer. The dealer has a deck\r\nwhich contains cards of four different suits (the number of cards of\r\neach suit ); the number of cards in the deck is divisible by n. The\r\ndealer gives all cards to the players, so that .After the cards are\r\ndealt, every player chooses one of four suits (independently) and\r\ndiscards all cards from their hand which do not belong to their chosen\r\nsuit. The winner of the game is the player with the maximum number of\r\ncards left in their hand. The number of points the winner receives is\r\nx - y, where x is the number of cards in the winner\u2019s hand, and y is the\r\nmaximum number of cards among all players; everyone else receives 0\r\npoints. Note that it means that , everyone receives 0 points.Since every\r\nplayer wants to maximize their odds to win, .Monocarp is the dealer. He\r\nhas already given some cards to the players; the i-th player received\r\na_{i,j} cards of suit j. Note that . Monocarp has b_1, b_2, b_3, b_4\r\ncards of suit 1, 2, 3, 4 respectively left in his deck. He has to give\r\nthem to the players so that, after all cards are dealt, every player has\r\nthe same number of cards.For each player, calculate the maximum number\r\nof points they can receive among all ways to deal the remaining cards\r\naccording to the rules of the game.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\n\nint n;\n\nll tab[nax][4];\nll jesz[4];\n\nll pref[nax][4];\nll suf[nax][4];\n\nll wsu[4];\n\nmap<ll,pll> mapa[16];\n\nll musze[4];\n\npll operator +(pll a, pll b)\n{\n\treturn {a.first+b.first, a.second+b.second};\n}\n\nll sufit(ll a, ll b)\n{\n\treturn (a+b-1)/b;\n}\n\nll kazdy;\n\nint check(int v, ll uniego, ll lim)\n{\n\tfor (int i=0; i<4; i++)\n\t\tif (pref[v-1][i]>lim || suf[v+1][i]>lim)\n\t\t\treturn 0;\n\tll wsz=0;\n\tfor (int j=0; j<4; j++)\n\t\twsz+=tab[v][j];\n\tfor (int i=1; i<16; i++)\n\t{\n\t\tauto it=mapa[i].upper_bound(lim);\n\t\tit--;\n\t\tpll wez=(*it).second;\n\t\tint mno=__builtin_popcount(i);\n\t\t\n\t\tll tu=0;\n\t\tfor (int l=0; l<4; l++)\n\t\t\tif (i&(1<<l))\n\t\t\t\ttu+=tab[v][l];\n\t\tll ogr=kazdy-wsz;\n\t\t\n\t\twez.second-=min(mno*lim-tu, ogr);\n\t\t\n\t\tll potrz=0;\n\t\tfor (int j=0; j<4; j++)\n\t\t\tif (i&(1<<j))\n\t\t\t\tpotrz+=musze[j];\n\t\tif (wez.first*lim+wez.second+uniego<potrz)\n\t\t{\n\t\t\t//~ if (v==1)\n\t\t\t//~ {\n\t\t\t\t//~ debug() << imie(uniego) << imie(lim) << imie(wez) << imie(potrz) << imie(i);\n\t\t\t//~ }\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tscanf(\"%lld\", &tab[i][j]);\n\tfor (int i=0; i<4; i++)\n\t\tscanf(\"%lld\", &jesz[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tpref[i][j]=max(pref[i-1][j], tab[i][j]);\n\tfor (int i=n; i; i--)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tsuf[i][j]=max(suf[i+1][j], tab[i][j]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\twsu[j]+=tab[i][j];\n\t\n\tfor (int i=0; i<4; i++)\n\t\tkazdy+=jesz[i]+wsu[i];\n\tassert(!(kazdy%n));\n\tkazdy/=n;\n\t\n\t//~ debug() << imie(kazdy);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll wsz=0;\n\t\tfor (int j=0; j<4; j++)\n\t\t\twsz+=tab[i][j];\n\t\tfor (int j=1; j<16; j++)\n\t\t{\n\t\t\tll tu=0;\n\t\t\tfor (int l=0; l<4; l++)\n\t\t\t\tif (j&(1<<l))\n\t\t\t\t\ttu+=tab[i][l];\n\t\t\tll ogr=kazdy-wsz;\n\t\t\tint mno=__builtin_popcount(j);\n\t\t\tmapa[j][0]=mapa[j][0]+pll{mno, -tu};\n\t\t\tll cel=sufit(ogr+tu, mno);\n\t\t\t//~ if (j==1)\n\t\t\t\t//~ debug() << i << \" \" << j << \" \" << cel << \" \" << mno << \" \" << tu << \" \" << ogr;\n\t\t\tmapa[j][cel]=mapa[j][cel]+pll{-mno, tu+ogr};\n\t\t}\n\t}\n\t\n\tfor (int i=1; i<16; i++)\n\t{\n\t\tpll s={0, 0};\n\t\tfor (auto j : mapa[i])\n\t\t{\n\t\t\ts=s+j.second;\n\t\t\tmapa[i][j.first]=s;\n\t\t}\n\t\t//~ debug() << i << \" \" << mapa[i];\n\t}\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll res=0;\n\t\tfor (int j=0; j<4; j++)\n\t\t\twsu[j]-=tab[i][j];\n\t\tll chce=kazdy;\n\t\tfor (int j=0; j<4; j++)\n\t\t\tchce-=tab[i][j];\n\t\tfor (int j=0; j<4; j++)\n\t\t{\n\t\t\tll x=min(chce, jesz[j]);\n\t\t\tfor (int l=0; l<4; l++)\n\t\t\t\tmusze[l]=jesz[l];\n\t\t\t\n\t\t\tll gora=tab[i][j]+x;\n\t\t\tmusze[j]-=x;\n\t\t\t\n\t\t\tint spoko=1;\n\t\t\tfor (int l=0; l<4; l++)\n\t\t\t\tif (pref[i-1][l]>=gora || suf[i+1][l]>=gora)\n\t\t\t\t\tspoko=0;\n\t\t\tif (!spoko)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tll bsa=0;\n\t\t\tll bsb=gora;\n\t\t\twhile(bsa<bsb)\n\t\t\t{\n\t\t\t\tll bss=(bsa+bsb)>>1;\n\t\t\t\tif (check(i, chce-x, bss))\n\t\t\t\t\tbsb=bss;\n\t\t\t\telse\n\t\t\t\t\tbsa=bss+1;\n\t\t\t}\n\t\t\tres=max(res, gora-bsa);\n\t\t}\n\t\t\n\t\tfor (int j=0; j<4; j++)\n\t\t\twsu[j]+=tab[i][j];\n\t\tprintf(\"%lld \", res);\n\t\t//~ printf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "flows",
        "greedy"
    ],
    "dificulty": "3200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Four Suits.json",
    "editorial_link": "https://codeforces.com//blog/entry/119964",
    "editorial": "As far as I am concerned, fully greedy solutions don\u00e2\u0080\u0099t work in this\r\nproblem. However, we can try employing some greedy ideas.First of all,\r\nlet\u00e2\u0080\u0099s calculate how many cards each player should receive. I will call\r\nit for the -th player.Suppose we want to maximize the answer for the -th\r\nplayer. Let\u00e2\u0080\u0099s iterate on the suit for which that player will have the\r\nmaximum number of cards. We can assign as many cards of suit as possible\r\nfrom the deck to the -th player: suppose we have given a card of suit to\r\nanother player, and a card of another suit to the -th player. If we\r\nexchange them, the answer won\u00e2\u0080\u0099t become worse.Okay, now we want to find\r\nthe minimum possible maximum number of cards (after the players discard\r\nsome of their cards) that the other players can have. Let\u00e2\u0080\u0099s suppose it\u00e2\u0080\u0099s\r\n. There should be a way to assign the remaining cards from the deck so\r\nthat every player gets exactly cards, and no player has more than cards\r\nin any suit (except for the -th player).The good thing is that if it\u00e2\u0080\u0099s\r\npossible to assign cards for some value of , it\u00e2\u0080\u0099s also possible for .\r\nSo, we can find this with binary search.Now we have to solve the\r\nfollowing problem: check if there exists an assignment of cards from the\r\ndeck for a particular . We can model it using maximum flow: create a\r\nnetwork with a source, sink, a vertex for every player except for , and\r\na vertex for every suit; for every suit, create a directed edge from the\r\nsource to that suit with capacity equal to the number of cards of that\r\nsuit left in the deck (don\u00e2\u0080\u0099t forget that we greedily assigned some cards\r\nto the -th player!); for every player except , create a directed edge\r\nfrom that player to the sink with capacity equal to ; for every suit and\r\nevery player except , create a directed edge from the suit to the player\r\nwith capacity equal to the maximum number of cards of that suit the\r\nplayer can receive; check that the maximum flow in this network\r\nsaturates all edges going into the sink (i. e. is equal to the sum of\r\nfor all players except the -th one). However, simply building this\r\nnetwork is too slow, let alone finding the maximum flow in it. We need\r\nsomething faster.If you\u00e2\u0080\u0099re thinking about using Hall\u00e2\u0080\u0099s theorem, then\r\nunfortunately, it doesn\u00e2\u0080\u0099t work since it cannot handle the constraint on\r\n. But you\u00e2\u0080\u0099re thinking in the right direction.Let\u00e2\u0080\u0099s try to find the\r\nminimum cut in this network. To do this, iterate on the of the suits\r\nthat will be in the set in the minimum cut, add the capacities of other\r\nsuits to the value of the cut, and for every player, determine if it\u00e2\u0080\u0099s\r\nbetter to have them in the set or in the set of the cut. The key thing\r\nis that . Let the number of suits in the mask be , and the total number\r\nof cards the -th player has from those suits be . The total capacity of\r\nall edges going into the -th player that we need to cut is , and the\r\ncapacity of the outgoing edge is . So, the value the -th player adds to\r\nthe cut is , and we need to compute the sum of these values for all\r\nplayers (except for the player ) efficiently.This is basically the\r\noutline of the solution. Now the implementation part follows. To be\r\nhonest, I think that the model solution is a bit too complicated, some\r\nsolutions I\u00e2\u0080\u0099ve seen during the contest are shorter and cleaner. But I\r\nwill explain it nevertheless.For every and every value of , let\u00e2\u0080\u0099s try to\r\nfind the sum of over all players. To do this, for every player, find the\r\nmaximum value of such that is less than . For the value of not greater\r\nthan this value, the player adds to the cut; for greater values, the\r\nplayer adds . Both of those are linear functions, and for every , we can\r\ncompute the sum of those linear functions for all players using\r\ndifference arrays. I calculate these sums of linear functions in all\r\nvalues of up to , because there might be situations when a player has\r\nmore than cards of a particular suit.That way, when we want to compute\r\nthe minimum cut for the -th player, chosen mask of suits and the value\r\nof , we can use the already computed sum of those functions to find the\r\ntotal value all players add to the cut, and then subtract the value that\r\nthe -th player added (since we need to discard that player from the\r\nnetwork).The rest of the implementation is fairly straightforward, you\r\ncan see the reference code for details (I hope I commented it well\r\nenough). One final note: when choosing the left border for binary\r\nsearch, I compute the maximum number of cards among all suits that the\r\nother players have, to make sure that I don\u00e2\u0080\u0099t choose the value of that\r\nleads to edges having negative capacity in the network. But I think it\u00e2\u0080\u0099s\r\nnot actually required, so you can try discarding it from the\r\nsolution.The model implementation works in something like for\r\nprecalculation of linear functions plus for actually solving the\r\nproblem, where is the maximum number of cards of a particular suit a\r\nplayer can have ().\r\n"
}