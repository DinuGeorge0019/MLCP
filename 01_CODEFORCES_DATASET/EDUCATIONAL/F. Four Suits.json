{"link": "https://codeforces.com//contest/1861/problem/F", "problemId": "2187866", "problem_idx": "F", "shortId": "1861F", "contest_number": "1861", "problem_submissions": {"F": [221319232, 221334797, 221343700, 221334746, 221435327], "E": [221294949, 221294627, 221307083, 221304545, 221289987, 221293214, 221302482, 221312615, 221307967, 221303480, 221309861, 221307296, 221307859, 221320123, 221304501, 221805824, 221308535, 221309691, 221307994, 221314449, 221316461], "D": [221289547, 221296942, 221291864, 221307784, 221293468, 221297421, 221296816, 221288510, 221291806, 221295562, 221296430, 221296186, 221290647, 221296713, 221298445, 221297975, 221298865, 221297626, 221298343], "C": [221285558, 221285843, 221287563, 221293257, 221282816, 221283475, 221287126, 221284366, 221286970, 221291172, 221290155, 221290726, 221290133, 221287629, 221289108, 221291690, 221291845, 221290307, 221291196, 221291877], "B": [221280891, 221279490, 221280612, 221282637, 221278148, 221277443, 221280003, 221278598, 221281862, 221281453, 221282384, 221284462, 221279905, 221283500, 221283423, 221284241, 221280164, 221284009, 221283159], "A": [221277133, 221276828, 221277503, 221276971, 221276729, 221276717, 221276917, 221276888, 221277198, 221278164, 221278677, 221280809, 221276797, 221278399, 221277159, 221277434, 221276991, 221278067, 221276850]}, "name": "F. Four Suits", "statement": "The game of Berland poker is played as follows. There are n+1 people: n\r\nplayers, numbered from 1 to n, and the dealer. The dealer has a deck\r\nwhich contains cards of four different suits (the number of cards of\r\neach suit ); the number of cards in the deck is divisible by n. The\r\ndealer gives all cards to the players, so that .After the cards are\r\ndealt, every player chooses one of four suits (independently) and\r\ndiscards all cards from their hand which do not belong to their chosen\r\nsuit. The winner of the game is the player with the maximum number of\r\ncards left in their hand. The number of points the winner receives is\r\nx - y, where x is the number of cards in the winner\u2019s hand, and y is the\r\nmaximum number of cards among all players; everyone else receives 0\r\npoints. Note that it means that , everyone receives 0 points.Since every\r\nplayer wants to maximize their odds to win, .Monocarp is the dealer. He\r\nhas already given some cards to the players; the i-th player received\r\na_{i,j} cards of suit j. Note that . Monocarp has b_1, b_2, b_3, b_4\r\ncards of suit 1, 2, 3, 4 respectively left in his deck. He has to give\r\nthem to the players so that, after all cards are dealt, every player has\r\nthe same number of cards.For each player, calculate the maximum number\r\nof points they can receive among all ways to deal the remaining cards\r\naccording to the rules of the game.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=100*1007;\n\nint n;\n\nll tab[nax][4];\nll jesz[4];\n\nll pref[nax][4];\nll suf[nax][4];\n\nll wsu[4];\n\nmap<ll,pll> mapa[16];\n\nll musze[4];\n\npll operator +(pll a, pll b)\n{\n\treturn {a.first+b.first, a.second+b.second};\n}\n\nll sufit(ll a, ll b)\n{\n\treturn (a+b-1)/b;\n}\n\nll kazdy;\n\nint check(int v, ll uniego, ll lim)\n{\n\tfor (int i=0; i<4; i++)\n\t\tif (pref[v-1][i]>lim || suf[v+1][i]>lim)\n\t\t\treturn 0;\n\tll wsz=0;\n\tfor (int j=0; j<4; j++)\n\t\twsz+=tab[v][j];\n\tfor (int i=1; i<16; i++)\n\t{\n\t\tauto it=mapa[i].upper_bound(lim);\n\t\tit--;\n\t\tpll wez=(*it).second;\n\t\tint mno=__builtin_popcount(i);\n\t\t\n\t\tll tu=0;\n\t\tfor (int l=0; l<4; l++)\n\t\t\tif (i&(1<<l))\n\t\t\t\ttu+=tab[v][l];\n\t\tll ogr=kazdy-wsz;\n\t\t\n\t\twez.second-=min(mno*lim-tu, ogr);\n\t\t\n\t\tll potrz=0;\n\t\tfor (int j=0; j<4; j++)\n\t\t\tif (i&(1<<j))\n\t\t\t\tpotrz+=musze[j];\n\t\tif (wez.first*lim+wez.second+uniego<potrz)\n\t\t{\n\t\t\t//~ if (v==1)\n\t\t\t//~ {\n\t\t\t\t//~ debug() << imie(uniego) << imie(lim) << imie(wez) << imie(potrz) << imie(i);\n\t\t\t//~ }\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tscanf(\"%lld\", &tab[i][j]);\n\tfor (int i=0; i<4; i++)\n\t\tscanf(\"%lld\", &jesz[i]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tpref[i][j]=max(pref[i-1][j], tab[i][j]);\n\tfor (int i=n; i; i--)\n\t\tfor (int j=0; j<4; j++)\n\t\t\tsuf[i][j]=max(suf[i+1][j], tab[i][j]);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=0; j<4; j++)\n\t\t\twsu[j]+=tab[i][j];\n\t\n\tfor (int i=0; i<4; i++)\n\t\tkazdy+=jesz[i]+wsu[i];\n\tassert(!(kazdy%n));\n\tkazdy/=n;\n\t\n\t//~ debug() << imie(kazdy);\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll wsz=0;\n\t\tfor (int j=0; j<4; j++)\n\t\t\twsz+=tab[i][j];\n\t\tfor (int j=1; j<16; j++)\n\t\t{\n\t\t\tll tu=0;\n\t\t\tfor (int l=0; l<4; l++)\n\t\t\t\tif (j&(1<<l))\n\t\t\t\t\ttu+=tab[i][l];\n\t\t\tll ogr=kazdy-wsz;\n\t\t\tint mno=__builtin_popcount(j);\n\t\t\tmapa[j][0]=mapa[j][0]+pll{mno, -tu};\n\t\t\tll cel=sufit(ogr+tu, mno);\n\t\t\t//~ if (j==1)\n\t\t\t\t//~ debug() << i << \" \" << j << \" \" << cel << \" \" << mno << \" \" << tu << \" \" << ogr;\n\t\t\tmapa[j][cel]=mapa[j][cel]+pll{-mno, tu+ogr};\n\t\t}\n\t}\n\t\n\tfor (int i=1; i<16; i++)\n\t{\n\t\tpll s={0, 0};\n\t\tfor (auto j : mapa[i])\n\t\t{\n\t\t\ts=s+j.second;\n\t\t\tmapa[i][j.first]=s;\n\t\t}\n\t\t//~ debug() << i << \" \" << mapa[i];\n\t}\n\t\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll res=0;\n\t\tfor (int j=0; j<4; j++)\n\t\t\twsu[j]-=tab[i][j];\n\t\tll chce=kazdy;\n\t\tfor (int j=0; j<4; j++)\n\t\t\tchce-=tab[i][j];\n\t\tfor (int j=0; j<4; j++)\n\t\t{\n\t\t\tll x=min(chce, jesz[j]);\n\t\t\tfor (int l=0; l<4; l++)\n\t\t\t\tmusze[l]=jesz[l];\n\t\t\t\n\t\t\tll gora=tab[i][j]+x;\n\t\t\tmusze[j]-=x;\n\t\t\t\n\t\t\tint spoko=1;\n\t\t\tfor (int l=0; l<4; l++)\n\t\t\t\tif (pref[i-1][l]>=gora || suf[i+1][l]>=gora)\n\t\t\t\t\tspoko=0;\n\t\t\tif (!spoko)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tll bsa=0;\n\t\t\tll bsb=gora;\n\t\t\twhile(bsa<bsb)\n\t\t\t{\n\t\t\t\tll bss=(bsa+bsb)>>1;\n\t\t\t\tif (check(i, chce-x, bss))\n\t\t\t\t\tbsb=bss;\n\t\t\t\telse\n\t\t\t\t\tbsa=bss+1;\n\t\t\t}\n\t\t\tres=max(res, gora-bsa);\n\t\t}\n\t\t\n\t\tfor (int j=0; j<4; j++)\n\t\t\twsu[j]+=tab[i][j];\n\t\tprintf(\"%lld \", res);\n\t\t//~ printf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "bitmasks", "flows", "greedy"], "dificulty": "3200", "interactive": false}