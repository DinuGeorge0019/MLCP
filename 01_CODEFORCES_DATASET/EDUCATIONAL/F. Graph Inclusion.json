{
    "link": "https://codeforces.com//contest/2069/problem/F",
    "problemId": "3213451",
    "problem_idx": "F",
    "shortId": "2069F",
    "contest_number": "2069",
    "problem_submissions": {
        "E": [
            306720227,
            306703455,
            306762040,
            306709414,
            306720479,
            306710204,
            306717271,
            306714232,
            306713491,
            306717023,
            306719634,
            306716305,
            306717171,
            306715546,
            306713534,
            307552024,
            306752930,
            306724477,
            306721728,
            306718615,
            306718992,
            306726971,
            306725677
        ],
        "F": [
            306709347,
            306728258,
            306727520,
            306728135,
            306741225,
            306726966,
            306744015,
            306732116,
            306739032,
            306855146,
            306737313,
            306730256,
            306733511,
            306743505,
            306725225,
            306745953,
            306762587,
            306739080,
            306745663,
            306744259,
            306729975,
            306736187,
            306742000
        ],
        "D": [
            306694099,
            306695545,
            306695100,
            306694667,
            306690359,
            306701386,
            306701212,
            306696826,
            306697964,
            306697288,
            306699133,
            306704039,
            306702795,
            306701942,
            306702458,
            306700726,
            306707761,
            306704425,
            306708530,
            306707972
        ],
        "C": [
            306685465,
            306686684,
            306687348,
            306684235,
            306683606,
            306688263,
            306688039,
            306687329,
            306856369,
            306685918,
            306688691,
            306688112,
            306685819,
            306691359,
            306688654,
            306686865,
            306692320,
            306691352,
            306695398,
            306686441,
            306689890
        ],
        "B": [
            306681829,
            306682850,
            306682972,
            306680572,
            306680880,
            306682298,
            306683281,
            306682689,
            306856172,
            306681142,
            306684519,
            306683738,
            306681106,
            306703816,
            306682841,
            306682588,
            306685491,
            306683927,
            306691965,
            306683224,
            306685776
        ],
        "A": [
            306678234,
            306678240,
            306678194,
            306678094,
            306678179,
            306678115,
            306678333,
            306678481,
            306855634,
            306678273,
            306679166,
            306678389,
            306678130,
            306680446,
            306678338,
            306678258,
            306678871,
            306678235,
            306687347,
            306679141,
            306678310
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/139774",
    "editorial": "First, let’s understand how to solve the problem without queries (given\r\ntwo graphs and , add the minimum number of edges to so that it includes\r\ngraph ), and then we’ll deal with query processing.Let’s understand what\r\nit means for graph to . This means that some component of graph is not a\r\nsubset of any component of graph that is, there exist two vertices\r\n(let’s call them and ) that belong to the same component in graph , but\r\ndo not belong to the same component in graph .If this happens, let’s\r\nconnect vertices and with an edge in graph , and then try to find such a\r\npair of vertices again. We will continue doing this until it turns out\r\nthat there is no such pair of vertices. After that, graph will include\r\ngraph .Let’s take a look at what kind of graph we have obtained. The\r\nfollowing holds for it: if two vertices and are in the same component\r\neither in graph or in graph (or in both of these graphs), then they are\r\nin the same component in the resulting graph (note that the reverse is\r\nnot necessarily true). This means that the partition of this graph into\r\ncomponents will be the same as if we constructed a graph that has edges\r\nfrom both graphs and , and partitioned it into components. Thus, for\r\ngraph to include graph , we need to make its components match those of\r\nthe union of graphs and .Since the union of graphs and includes graph ,\r\nit is sufficient for us to count the number of components in graph and\r\nin the union, and the difference between these two numbers will be\r\nexactly the number of edges we need to add to graph for its components\r\nto coincide with the components of the union.Now let’s deal with the\r\nqueries. We need to maintain two graphs ( and the union), add/remove\r\nedges, and compute the number of components in the graphs. Moreover, all\r\nqueries can be read from the very beginning and then processed (the\r\nproblem can be solved offline). This means we can use the Dynamic\r\nConnectivity Offline technique. Below is a description of this\r\ntechnique.First, for each edge in each graph, we will identify all\r\nsegments of queries when this edge exists (that is, such segments that\r\nthe edge exists from query to query ). In total, there will be such\r\nsegments.We will build a segment tree with leaves, where each leaf\r\ncorresponds to a certain query. Each segment that we have identified can\r\nbe split into segments corresponding to the vertices of the segment tree\r\n(similarly to how a segment tree splits any query on a segment into\r\nvertices). We will add information of the form \"this edge exists\r\nthroughout this segment\" to the corresponding vertices.Now our task is\r\nthe following: for each query, form the graph so that it contains only\r\nedges existing during that query. Each query corresponds to one of the\r\nleaves of the segment tree, and the edges that exist at that moment are\r\nthe edges stored in the vertices on the path to that leaf of the segment\r\ntree. Thus, now for each leaf of the segment tree, we need to form a\r\npartition of the graph into components if the graph contains exactly\r\nthose edges that are on the path from the root to that leaf.To do this,\r\nwe can recursively traverse the segment tree. When we visit vertex , we\r\nwill do the following: add all edges stored in vertex of the segment\r\ntree; if vertex has children, recursively visit the children; if vertex\r\nhas no children, then it is a leaf of the segment tree, and the graph is\r\ncurrently in such a state that we can find the answer to the\r\ncorresponding query (the graph contains all edges that exist at that\r\nmoment); before returning from vertex , \"rollback\" all changes we made\r\nin it. We need a data structure that can add an edge to the graph and\r\nrollback the last changes. The simplest option for such a structure is a\r\nDSU with rollbacks. We will write a standard DSU with a rank heuristic,\r\nbut (it does not combine well with rollbacks). Each time we make a\r\nchange in the DSU, we will remember which values we changed and what was\r\nstored there before (look at the function in the model solution to\r\nunderstand how to implement this most simply). Since we use only one DSU\r\nheuristic, adding one edge will take and, accordingly, rolling back an\r\nedge will also take .In total, we have segments of edge existence, each\r\nof which is split by the segment tree into segments, so the total number\r\nof edge addition operations will be , and the entire solution will work\r\nin .\r\n",
    "name": "F. Graph Inclusion",
    "statement": "A connected component of an undirected graph is defined as a set of\r\nvertices S of this graph such that: for every pair of vertices (u, v) in\r\nS, there exists a path between vertices u and v; there is no vertex\r\noutside S that has a path to a vertex within S. For example, the graph\r\nin the picture below has three components:\r\n{1, 3, 7, 8\r\n},\r\n{2\r\n},\r\n{4, 5, 6\r\n}. We say that graph A graph B if every component of graph B is a subset\r\nof some component of graph A.You are given two graphs, A and B, both\r\nconsisting of n vertices numbered from 1 to n. Initially, there are no\r\nedges in the graphs. You must process queries of two types: add an edge\r\nto one of the graphs; remove an edge from one of the graphs. After each\r\nquery, you have to calculate the minimum number of edges that have to be\r\nadded to A so that A includes B, and print it. Note that you don’t\r\nactually add these edges, you just calculate their number.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dsu",
        "graphs"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Graph Inclusion.json",
    "hint": []
}