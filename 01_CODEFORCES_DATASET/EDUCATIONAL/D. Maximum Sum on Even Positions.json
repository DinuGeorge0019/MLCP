{
    "link": "https://codeforces.com//contest/1373/problem/D",
    "problemId": "657373",
    "problem_idx": "D",
    "shortId": "1373D",
    "contest_number": "1373",
    "problem_submissions": {
        "F": [
            85069466,
            85013919,
            85003216,
            85004527,
            85017380,
            85006414,
            85013443,
            85009359,
            85034855,
            85024344,
            85027318,
            85021209,
            85169119,
            85034898,
            85023023,
            85025050,
            85021057,
            85011972,
            85013310,
            85009397,
            85086450,
            85048971,
            85105442,
            85026023,
            85034574
        ],
        "G": [
            85018688,
            85013794,
            85023274,
            85029274,
            85027188,
            85026875,
            85025205,
            85031642,
            85033493,
            85060324,
            85029140,
            85035646,
            85035445,
            85030303,
            85169123,
            85031978,
            85034028,
            85038006,
            85044469,
            85037568,
            85029439,
            85040658,
            85105410,
            85055846,
            85052926,
            85051925,
            85051272,
            85044699
        ],
        "E": [
            84999770,
            85000250,
            85000769,
            85016220,
            85003055,
            85022007,
            85003196,
            85014929,
            85009060,
            85051465,
            85015459,
            85015122,
            85013600,
            85169037,
            85015655,
            85012581,
            85027850,
            85004717,
            85029830,
            85050882,
            85062787,
            85017522,
            85010450,
            85023419
        ],
        "D": [
            84989194,
            84988897,
            84987666,
            84989409,
            84993779,
            84995810,
            84995168,
            84988737,
            84989555,
            84996435,
            84994778,
            85169112,
            84993838,
            84996979,
            84999087,
            84988720,
            84993282,
            84997221,
            84991423,
            84994984,
            85005381
        ],
        "C": [
            84985114,
            84983803,
            84984904,
            84985027,
            84987964,
            84987787,
            84988785,
            84985367,
            84985891,
            84989713,
            84990559,
            85169107,
            84990269,
            84988468,
            84994211,
            84985714,
            84988231,
            84989967,
            84987837,
            84989263,
            84994345
        ],
        "B": [
            84983530,
            84983359,
            84983895,
            84983713,
            84984272,
            84984923,
            84984729,
            84983954,
            84983931,
            84986620,
            85051946,
            84984732,
            85169102,
            84984725,
            84984153,
            84984773,
            84984191,
            84984894,
            84984839,
            84984490,
            84985320,
            84987225
        ],
        "A": [
            84983369,
            84984629,
            84983633,
            84983428,
            84983600,
            84983500,
            84983426,
            84983406,
            84983552,
            84983668,
            84986837,
            85168973,
            84983414,
            84983504,
            84983712,
            85163611,
            84983517,
            84983932,
            84983627,
            84984784,
            84983882,
            84985111
        ]
    },
    "name": "D. Maximum Sum on Even Positions",
    "statement": "You are given an array a consisting of n integers. Indices of the array\r\nstart from zero (i. e. the first element is a_0, the second one is a_1,\r\nand so on).You can reverse subarray (continuous subsegment) of this\r\narray. Recall that the subarray of a with borders l and r is a[l; r] =\r\na_l, a_{l + 1},\r\ndots, a_{r}.Your task is to reverse such a subarray that the sum of\r\nelements on positions of the resulting array is (i. e. the sum of\r\nelements a_0, a_2,\r\ndots, a_{2k} for integer k =\r\nlfloor\r\nfrac{n-1}{2}\r\nrfloor should be maximum possible).You have to answer t independent test\r\ncases.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n \nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int T; cin >> T;\n    while(T--) {\n        int N; cin >> N;\n        vl A(N); F0R(i, N) cin >> A[i];\n        ll P = 0;\n        ll pre[N+1];\n        pre[0] = 0;\n        ll lo2 = 0;\n        ll lo1 = 1e15;\n        ll ans = 0;\n        F0R(i, N) {\n            if (i % 2 == 0) {\n                P += A[i];\n                pre[i+1] = pre[i] - A[i];\n            } else {\n                pre[i+1] = pre[i] + A[i];\n            }\n            if ((i+1) % 2) {\n                ckmin(lo1, pre[i+1]);\n                ckmax(ans, pre[i+1] - lo1);\n            } else {\n                ckmin(lo2, pre[i+1]);\n                ckmax(ans, pre[i+1] - lo2);\n            }\n\n        }\n//        cout << P << \" \" << pre[N] << nl;\n\n        cout << ans+P << nl;\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "dp",
        "greedy",
        "implementation"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Maximum Sum on Even Positions.json",
    "editorial_link": "https://codeforces.com//blog/entry/79376",
    "editorial": "Firstly, we can notice that the reverse of of odd length subarray does\r\nnothing because it doesnât change parities of indices of affected\r\nelements. Secondly, we can consider the reverse of the subarray of\r\nlength as reverses of subarrays of length (i.e. it doesnât matter for us\r\nhow exactly the subarray will be reversed, we can only consider changing\r\nparities).Now, there are two ways: the first one is smart and the second\r\none is dynamic programming.Consider the first way. Calculate the initial\r\nsum of elements on even positions . Then letâs create two arrays and .\r\nThere is for all from to and is for all from to . Elements of the first\r\narray deonte the profit if we reverse the subarray tarting from the even\r\nposition, and elemnts of the second array denote the profit if we\r\nreverse the subarray starting from the odd position. Now we need to find\r\nthe subarray with the maximum sum in both arrays (this will maximize\r\noverall profit) and add this value to to get the answer. This problem\r\ncan be solved easily: consider the sum of the subarray as the difference\r\nof two prefix sums . To maximize it, consider all right borders and\r\nminimize the value . Iterate over all positions of the array,\r\nmaintaining the current prefix sum and the minimum prefix sum we meet .\r\nUpdate , then update and then update the answer with the value .And the\r\nsecond way is authorâs solution and it is dynamic programming. This idea\r\ncan be transformed to solve such problems in which you need to apply\r\nsome function to some small number of subsegments (of course, under some\r\nconstraints on functions). State of our dynamic programming is where and\r\n. denotes the answer on the prefix of length if we didnât start\r\nreversing the subarray, denotes the answer if we started reversing the\r\nsubarray but didnât end it and denotes the answer if we ended reversing\r\nthe subarray. Transitions are pretty easy: ; ; . The value is just a\r\nternary if statement. If is true then return otherwise return .The\r\nanswer is .Time complexity with both approaches is .\r\n",
    "hint": []
}