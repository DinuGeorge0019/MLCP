{
    "link": "https://codeforces.com//contest/1279/problem/F",
    "problemId": "504278",
    "problem_idx": "F",
    "shortId": "1279F",
    "contest_number": "1279",
    "problem_submissions": {
        "E": [
            67737947,
            67733364,
            67730576,
            67739828,
            67742536,
            67737172,
            67724903,
            67736976,
            67729524,
            67727105,
            67747837,
            67731683,
            67732984,
            67748535,
            67744932
        ],
        "F": [
            67737545,
            67718265,
            67764598,
            67761358,
            67761175,
            67737082,
            67725475,
            67770261,
            67748335,
            67724855,
            67743206,
            67734760,
            67745652,
            67744739,
            67715547,
            67721155,
            67752838,
            67725507,
            67753025,
            67734101,
            67763755,
            67725445,
            67752215,
            67728799,
            67734922,
            67753488
        ],
        "D": [
            67712365,
            67710004,
            67715225,
            67711743,
            67720035,
            67741233,
            67733656,
            67738820,
            67706683,
            67710710,
            67712344,
            67716189,
            67712742,
            67717775,
            67716646,
            67717595,
            67717233,
            67714949,
            67709766
        ],
        "C": [
            67708271,
            67707793,
            67712401,
            67706993,
            67715784,
            67738909,
            67733706,
            67739694,
            67710632,
            67708442,
            67708816,
            67712768,
            67706695,
            67710203,
            67712897,
            67713466,
            67711730,
            67709788,
            67706084
        ],
        "B": [
            67703572,
            67702979,
            67708187,
            67704555,
            67708809,
            67737826,
            67733752,
            67740661,
            67706039,
            67703968,
            67706335,
            67709187,
            67703627,
            67705748,
            67708508,
            67710463,
            67705061,
            67706427,
            67703535
        ],
        "A": [
            67701146,
            67701133,
            67701117,
            67701163,
            67704539,
            67735636,
            67733784,
            67741171,
            67702120,
            67701143,
            67701243,
            67701332,
            67701184,
            67701399,
            67702929,
            67702323,
            67701558,
            67701229,
            67701070
        ]
    },
    "name": "F. New Year and Handle Change",
    "statement": "New Year is getting near. So it’s time to change handles on codeforces.\r\nMishka wants to change his handle but in such a way that people would\r\nnot forget who he is.To make it work, he only allowed to change letters\r\ncase. More formally, during handle change he can choose any segment of\r\nhis handle [i; i + l - 1] and apply or to all letters of his handle on\r\nthis segment (more fomally, replace all uppercase letters with\r\ncorresponding lowercase or vice versa). The length l is fixed for all\r\nchanges.Because it is not allowed to change codeforces handle too often,\r\nMishka can perform at most k such operations. What is the value of\r\nmin(lower, upper) (where lower is the number of lowercase letters, and\r\nupper is the number of uppercase letters) can be obtained after optimal\r\nsequence of changes?\r\n",
    "solutions": [
        "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n \nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n, k, l;\n  cin >> n >> k >> l;\n  string s;\n  cin >> s;\n  vector <int> ret;\n  for (auto c : s) {\n    if ('a' <= c && c <= 'z') ret.push_back(0);\n    else ret.push_back(1);\n  }\n  const ll inf = (ll) (1e18) + 7;\n  ll ans = n;\n  for (int t = 0; t < 2; t++) {\n    auto f = [&] (int m) {\n      vector <pair <ll, int> > dp(n, make_pair(inf, 0));\n      for (int i = 0; i < n; i++) {\n        {\n          auto go = (i >= l ? dp[i - l] : make_pair(0ll, 0));\n          go.first += m;\n          go.second++;\n          dp[i] = min(dp[i], go);\n        }\n        {\n          auto go = (i > 0 ? dp[i - 1] : make_pair(0ll, 0));\n          go.first += ret[i];\n          dp[i] = min(dp[i], go);\n        }\n      }\n      return dp[n - 1];\n    };\n    if (f(0).second <= k) {\n      ans = min(ans, f(0).first);\n    } else {\n      int l = 0, r = n + 228;\n      while (l < r - 1) {\n        int mid = (l + r) / 2;\n        if (f(mid).second <= k) {\n          r = mid;\n        } else {\n          l = mid;\n        }\n      }\n      auto go = f(r);\n      ans = min(ans, go.first - r * (ll) k);\n    }\n    for (int &x : ret) {\n      x ^= 1;\n    }\n  }\n  cout << ans << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "dp"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. New Year and Handle Change.json",
    "editorial_link": "https://codeforces.com//blog/entry/72577",
    "editorial": "Letâs simplify the problem a bit: we need either to minimize the number\r\nof lowercase letters or to minimize the number of uppercase letters.\r\nBoth variants can be described by the following model: we have a binary\r\narray where if is in the correct case and otherwise. We can do at most\r\noperations \"set on the segment \" and weâd like to minimize the total sum\r\nof .At first, letâs start with a solution which is pretty slow but\r\ncorrect. Let be the minimum sum of the prefix such that operations was\r\nalready applied on it.In order to calculate this somehow efficiently, we\r\nneed to understand that itâs optimal to avoid intersections of segments\r\nof applied operations so we can further specify the state of with the\r\nfollowing: all applied operations have their right borders . Itâs easy\r\nto specify the transitions: we either apply set operation on and relax\r\nwith or not and relax with .It still so weâd like to optimize it more\r\nand we can do it using the \"lambda-optimization\" i. e. \"aliens trick\".\r\nHere we will try to describe what \"aliens trick\" is and the \"features\"\r\nof its application on the discrete calculations.In general, \"aliens\r\ntrick\" allows you to get rid of the restriction on the total number of\r\noperations applied to the array (sometimes itâs the number of segments\r\nin the partition of the array) by replacing it with the binary search of\r\nthe value connected to it. The is the cost of using the operation (or\r\nthe cost to use one more segment in the partition). In other words, we\r\ncan use as many operations as we want but we need to pay for each of\r\nthem. Often, we can calculate the answer without the restriction faster.\r\nThe main restriction of the using this dp-optimization is the following\r\n(in case of the discrete model): consider the answer for the fixed , or\r\n. If we look at the function it should be \"somewhat convex\", i.e (or,\r\nsometimes, ) for all possible .Letâs look at the answers of the modified\r\nversion of the problem (with cost for each used operation) as function .\r\nItâs easy to prove that and itâs also \"somewhat convex\" for a fixed (as\r\na sum of convex functions). But, more important, it has the following\r\nproperty: let be the position where the is the minimum possible. It can\r\nbe proven (from the convex property) that .This property leads to the\r\nsolution: binary search while keeping track of the , i. e. find the\r\nminimum that . But there are several problems related to the discrete\r\norigin of the problem: The is not unique. In general case, there is a\r\nsegment where the minimum can be achieved. But there is still a property\r\nthat and . So we need to ensure that we will always find either minimum\r\nsuch or maximum such . The second problem comes from the first one.\r\nThere are situations when . It creates a problem in the next situation:\r\nsuppose the binary search finished with ; the and . But we need to use\r\nexactly operations, what to do? Using float values will not help, so we\r\ndonât need them (so weâll use usual integer bs). Suppose we minimized\r\nthe then we can show that or, in other words, . So we can claim that we\r\ncalculated the value not only for but also for . In the end, if we can\r\nefficiently calculate and for the fixed , then we can binary search ,\r\nextract and claim that the .Finally, letâs discuss, how to calculate and\r\nfor a fixed . Since is just a minimum cost and the is the minimum number\r\nof operations with such cost. We can calculate it by simplifying our\r\nstarting . (Remember, the cost is calculated in a next way: for each\r\nremaining in we pay and for each used operation we pay ).Let , where is\r\nminimum cost on the prefix of length and is minimum number of operations\r\ncan be achieved. Then the transitions are almost the same: we either let\r\nbe and relax with or start new operation and relax with . The result is\r\npair .Some additional information: we should carefully choose the\r\nborders of the binary search: we should choose the left border so itâs\r\noptimal to use operation whenever we can (usually, or ). And we should\r\nchoose the right border so itâs never optimal to use even one operation\r\n(usually more than the maximum possible answer).The total complexity is\r\n.P. S.: We donât have the strict proof that the is convex, but we have\r\nfaith and stress. Weâd appreciate it if someone would share the proof in\r\nthe comment section.\r\n",
    "hint": []
}