{
    "link": "https://codeforces.com//contest/1837/problem/C",
    "problemId": "1937911",
    "problem_idx": "C",
    "shortId": "1837C",
    "contest_number": "1837",
    "problem_submissions": {
        "F": [
            207194085,
            207203613,
            207207682,
            207213171,
            207211865,
            207210824,
            207211176,
            207318425,
            207318356,
            207219269,
            207223400,
            207222112,
            207230081,
            209182293,
            207218386,
            207220953,
            207230258,
            207229992,
            207230774,
            207219053,
            207217652,
            207234599,
            207241428,
            207217300
        ],
        "E": [
            207188119,
            207194518,
            207187724,
            207193975,
            207201887,
            207200866,
            207200402,
            207204477,
            207201158,
            207203473,
            207202659,
            209182421,
            207206918,
            207295603,
            207295577,
            207295208,
            207212525,
            207205450,
            207220600,
            207221757,
            207209332,
            207208536,
            207213556,
            207215245,
            207197679
        ],
        "B": [
            207173438,
            207165428,
            207164196,
            207176139,
            207175678,
            207167732,
            207174974,
            207163573,
            207171463,
            207163877,
            207175371,
            207164199,
            207166728,
            209182537,
            207176961,
            207175758,
            207169369,
            207163934,
            207178400,
            207163937,
            207176249,
            207171837,
            207164338,
            207177413,
            207185470
        ],
        "D": [
            207172764,
            207180689,
            207175489,
            207169386,
            207180603,
            207183437,
            207177453,
            207182367,
            207184812,
            207187481,
            207183382,
            209182475,
            207187168,
            207187553,
            207189679,
            207186480,
            207191942,
            207180382,
            207189882,
            207187720,
            207180792
        ],
        "C": [
            207163791,
            207169258,
            207167268,
            207163200,
            207171135,
            207167990,
            207163968,
            207163247,
            207171084,
            207177546,
            207172770,
            209182511,
            207171094,
            207178509,
            207179374,
            207167154,
            207173221,
            207169406,
            207177662,
            207172590,
            207173505
        ],
        "A": [
            207156762,
            207156505,
            207156456,
            207156409,
            207157257,
            207156929,
            207156537,
            207156398,
            207156432,
            207157333,
            207156686,
            209182570,
            207157924,
            207157341,
            207156863,
            207156455,
            207156545,
            207156506,
            207157325,
            207156712,
            207156556
        ]
    },
    "name": "C. Best Binary String",
    "statement": "You are given a string s consisting of the characters , and/or . Let\u2019s\r\ncall it a .Let\u2019s say that the binary string (a string where each\r\ncharacter is either or ) the if you can replace each character with or\r\n(for each character, the choice is independent) so that the strings\r\nbecome equal. For example, matches , but doesn\u2019t match , , or .Let\u2019s\r\ndefine the of the binary string as the minimum number of operations of\r\nthe form \"reverse an arbitrary contiguous substring of the string\"\r\nrequired to sort the string in non-descending order.You have to find a\r\nbinary string with the minimum possible cost among those that match the\r\ngiven pattern. If there are multiple answers, print any of them.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    string s;\n    cin >> s;\n    int N = s.size();\n    s = \"0\" + s + \"1\";\n    vector<int> p;\n    for (int j = 1; j < N + 2; j++){\n      if (s[j] == '?'){\n        s[j] = s[j - 1];\n      }\n    }\n    for (int j = 1; j <= N; j++){\n      cout << s[j];\n    }\n    cout << endl;\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Best Binary String.json",
    "editorial_link": "https://codeforces.com//blog/entry/116752",
    "editorial": "First of all, let\u00e2\u0080\u0099s try solving an easier problem suppose we have a\r\nbinary string, how many operations of the form \"reverse a substring\" do\r\nwe have to perform so that it is sorted? To solve this problem, we need\r\nto consider substrings of the form in the string (i. e. situations when\r\na zero immediately follows a one). Sorted binary strings should not\r\ncontain any such substrings, so our goal is to reduce the number of such\r\nstrings to zero.Let\u00e2\u0080\u0099s try to analyze how can we reduce the number of\r\nsubstrings equal to by reversing a substring. Suppose that we want to\r\n\"remove\" a particular substring from the string without causing any new\r\nones to appear. We can reverse the substring that consists of the block\r\nof ones and the block of zeroes adjacent to each other; that way, after\r\nreversing the substring, these two blocks will be swapped; the block of\r\nzeroes will either merge with the block of zeroes to the left, or move\r\nto the beginning of the string; the block of ones will either merge with\r\nthe block of ones to the right, or move to the end of the string. For\r\nexample, if, in the string , you reverse the substring from the -rd to\r\nthe -th position, you get , and you reduce the number of substrings by\r\none.What if we want to reduce this number by more than one in just one\r\noperation? Unfortunately, this is impossible. Suppose we want to affect\r\ntwo substrings with one reverse operation. There will be a substring\r\nbetween them, so, after reversing, it will turn into , and we\u00e2\u0080\u0099ll reduce\r\nthe number of substrings only by one. The same when we try to affect\r\nthree, four or more substrings . So, we can reduce the number of\r\nsubstrings only by one in one operation. So, the answer to the problem\r\n\"count the number of operations required to sort the binary string\" is\r\njust the number of substrings .Okay, back to the original problem. Now\r\nwe want to replace every question mark so that the resulting string\r\ncontains as few substrings as possible. You can use dynamic programming\r\nof the form the minimum number of substrings if we considered first\r\ncharacters of the string and the last of them was . Or you can try the\r\nfollowing greedy instead: go through the string from left to right, and\r\nwhenever you encounter a question mark, replace it with the same\r\ncharacter as the previous character in the string (if the string begins\r\nwith a question mark, it should be replaced with ). That way, you will\r\ncreate as few \"blocks\" of characters as possible, so the number of times\r\nwhen a block of \u00e2\u0080\u0099s changes into a block of \u00e2\u0080\u0099s will be as small as\r\npossible.\r\n"
}