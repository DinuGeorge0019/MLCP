{"link": "https://codeforces.com//contest/1837/problem/C", "problemId": "1937911", "problem_idx": "C", "shortId": "1837C", "contest_number": "1837", "problem_submissions": {"F": [207194085, 207203613, 207207682, 207213171, 207211865, 207210824, 207211176, 207318425, 207318356, 207219269, 207223400, 207222112, 207230081, 209182293, 207218386, 207220953, 207230258, 207229992, 207230774, 207219053, 207217652, 207234599, 207241428, 207217300], "E": [207188119, 207194518, 207187724, 207193975, 207201887, 207200866, 207200402, 207204477, 207201158, 207203473, 207202659, 209182421, 207206918, 207295603, 207295577, 207295208, 207212525, 207205450, 207220600, 207221757, 207209332, 207208536, 207213556, 207215245, 207197679], "B": [207173438, 207165428, 207164196, 207176139, 207175678, 207167732, 207174974, 207163573, 207171463, 207163877, 207175371, 207164199, 207166728, 209182537, 207176961, 207175758, 207169369, 207163934, 207178400, 207163937, 207176249, 207171837, 207164338, 207177413, 207185470], "D": [207172764, 207180689, 207175489, 207169386, 207180603, 207183437, 207177453, 207182367, 207184812, 207187481, 207183382, 209182475, 207187168, 207187553, 207189679, 207186480, 207191942, 207180382, 207189882, 207187720, 207180792], "C": [207163791, 207169258, 207167268, 207163200, 207171135, 207167990, 207163968, 207163247, 207171084, 207177546, 207172770, 209182511, 207171094, 207178509, 207179374, 207167154, 207173221, 207169406, 207177662, 207172590, 207173505], "A": [207156762, 207156505, 207156456, 207156409, 207157257, 207156929, 207156537, 207156398, 207156432, 207157333, 207156686, 209182570, 207157924, 207157341, 207156863, 207156455, 207156545, 207156506, 207157325, 207156712, 207156556]}, "name": "C. Best Binary String", "statement": "You are given a string s consisting of the characters , and/or . Let\u2019s\r\ncall it a .Let\u2019s say that the binary string (a string where each\r\ncharacter is either or ) the if you can replace each character with or\r\n(for each character, the choice is independent) so that the strings\r\nbecome equal. For example, matches , but doesn\u2019t match , , or .Let\u2019s\r\ndefine the of the binary string as the minimum number of operations of\r\nthe form \"reverse an arbitrary contiguous substring of the string\"\r\nrequired to sort the string in non-descending order.You have to find a\r\nbinary string with the minimum possible cost among those that match the\r\ngiven pattern. If there are multiple answers, print any of them.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    string s;\n    cin >> s;\n    int N = s.size();\n    s = \"0\" + s + \"1\";\n    vector<int> p;\n    for (int j = 1; j < N + 2; j++){\n      if (s[j] == '?'){\n        s[j] = s[j - 1];\n      }\n    }\n    for (int j = 1; j <= N; j++){\n      cout << s[j];\n    }\n    cout << endl;\n  }\n}"], "input": "", "output": "", "tags": ["constructive algorithms", "greedy"], "dificulty": "1000", "interactive": false}