{"link": "https://codeforces.com//contest/893/problem/F", "problemId": "135516", "problem_idx": "F", "shortId": "893F", "contest_number": "893", "problem_submissions": {"D": [32587846, 32584166, 32584580, 32587450, 32584069, 32583060, 32588853, 32589858, 32585182, 32590659, 32586485, 32589315, 32591783, 32597332, 32598552, 32591926, 32591314, 32591378, 32595633, 32593677], "F": [32587029, 32588564, 32633440, 32633411, 32600577, 32591730, 32591080, 32593455, 32595872, 32596856, 32595308, 32598298, 32597321, 32596161, 32595895, 32587274, 32617128, 32590562, 32596152, 32592069, 32595471, 32597133, 32631856, 32597548, 32597501, 32596510, 32594100, 32588288], "E": [32582663, 32585881, 32587039, 32583891, 32589038, 32590654, 32590403, 32589458, 32590147, 32585649, 32586443, 32598380, 32591576, 32589935, 32595163, 32587306, 32598292, 32632299, 32631834, 32597903, 32592050, 32595887], "C": [32580222, 32581731, 32579674, 32581061, 32582009, 32580473, 32581974, 32581755, 32582911, 32582779, 32581570, 32581398, 32580526, 32582157, 32582935, 32581251, 32583782, 32581776, 32581603, 32588827], "B": [32579038, 32579297, 32579032, 32580119, 32580362, 32579253, 32579828, 32580254, 32581551, 32581638, 32580169, 32580423, 32579209, 32580529, 32581182, 32578812, 32582642, 32580448, 32580061, 32587514], "A": [32578761, 32578814, 32578771, 32578835, 32579027, 32578799, 32578920, 32578996, 32579962, 32580679, 32579419, 32579406, 32579609, 32579237, 32580280, 32579180, 32578788, 32579540, 32578923, 32586994]}, "name": "F. Subtree Minimum Query", "statement": "You are given a rooted tree consisting of vertices. Each vertex has a\r\nnumber written on it; number is written on vertex .Let\u2019s denote as the\r\ndistance between vertices and in the tree (that is, the number of edges\r\nin the shortest path from to ). Also let\u2019s denote the of vertex as the\r\nset of vertices such that both these conditions are met: is an ancestor\r\nof (every vertex is an ancestor of itself); . You are given queries to\r\nthe tree. -th query is represented by two numbers and , and the answer\r\nto this query is the minimum value of among such vertices such that\r\nbelongs to -blocked subtree of .Write a program that would process these\r\nqueries quickly!.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << \"\\n\"; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nstruct Vertex {\n\tint level;\n\tint val;\n\n\tVertex() {}\n\tVertex(int l, int v): level(l), val(v) {}\n\n\tbool operator <(const Vertex& ot) const {\n\t\treturn level < ot.level;\n\t}\n};\n\nconst int INF = 1e9 + 10;\n\nstruct SegTree {\n\tint n;\n\tvector<vector<Vertex>> a;\n\tvector<vector<int>> res;\n\n\tSegTree(const vector<int>& level, const vector<int>& vals) {\n\t\tn = 1;\n\t\twhile (n < (int)level.size()) {\n\t\t\tn *= 2;\n\t\t}\n\t\ta.resize(n + n);\n\t\tres.resize(n + n);\n\t\tfor (int i = 0; i < (int)level.size(); ++i) {\n\t\t\ta[n + i] = {{level[i], vals[i]}};\n\t\t\tres[n + i] = {INF, vals[i]};\n\t\t}\n\t\tfor (int i = n - 1; i > 0; --i) {\n\t\t\ta[i].resize(a[i + i].size() + a[i + i + 1].size());\n\t\t\tmerge(all(a[i + i]), all(a[i + i + 1]), a[i].begin());\n\t\t\tres[i].resize(a[i].size() + 1, INF);\n\t\t\tfor (int j = 0; j < (int)a[i].size(); ++j) {\n\t\t\t\tres[i][j + 1] = min(res[i][j], a[i][j].val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint _get(int v, int l1, int r1, int l, int r, int maxk) {\n\t\tif (l >= r1 || l1 >= r) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (l <= l1 && r >= r1) {\n\t\t\tint idx = lower_bound(all(a[v]), Vertex(maxk + 1, 0)) - a[v].begin();\n\t\t\treturn res[v][idx];\n\t\t}\n\t\tint mid = (l1 + r1) / 2;\n\t\treturn min(_get(v + v, l1, mid, l, r, maxk),\n\t\t\t\t   _get(v + v + 1, mid, r1, l, r, maxk));\n\t}\n\n\tint get(int l, int r, int maxk) {\n\t\treturn _get(1, 0, n, l, r, maxk);\n\t}\n};\n\nconst int N = 111111;\nint tin[N], tout[N], level[N];\nint timer = 0;\nvector<int> a[N];\nint val[N];\nvector<int> levels, vals;\n\nvoid dfs(int v, int p = -1) {\n\ttin[v] = timer++;\n\tlevels.push_back(level[v]);\n\tvals.push_back(val[v]);\n\tfor (int x : a[v]) {\n\t\tif (x == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tlevel[x] = level[v] + 1;\n\t\tdfs(x, v);\n\t}\n\ttout[v] = timer;\n}\n\nint main() {\n\tint n = nxt(), root = nxt() - 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tval[i] = nxt();\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\n\tdfs(root);\n\n\tSegTree tree(levels, vals);\n\tint q = nxt();\n\tint last = 0;\n\twhile (q--) {\n\t\tint p1 = nxt(), p2 = nxt();\n\t\tint x = (p1 + last) % n;\n\t\tint k = (p2 + last) % n;\n\n\t\tlast = tree.get(tin[x], tout[x], level[x] + k);\n\t\tprintf(\"%d\\n\", last);\n\t}\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "trees"], "dificulty": "2300", "interactive": false}