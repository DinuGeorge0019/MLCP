{
    "link": "https://codeforces.com//contest/893/problem/F",
    "problemId": "135516",
    "problem_idx": "F",
    "shortId": "893F",
    "contest_number": "893",
    "problem_submissions": {
        "D": [
            32587846,
            32584166,
            32584580,
            32587450,
            32584069,
            32583060,
            32588853,
            32589858,
            32585182,
            32590659,
            32586485,
            32589315,
            32591783,
            32597332,
            32598552,
            32591926,
            32591314,
            32591378,
            32595633,
            32593677
        ],
        "F": [
            32587029,
            32588564,
            32633440,
            32633411,
            32600577,
            32591730,
            32591080,
            32593455,
            32595872,
            32596856,
            32595308,
            32598298,
            32597321,
            32596161,
            32595895,
            32587274,
            32617128,
            32590562,
            32596152,
            32592069,
            32595471,
            32597133,
            32631856,
            32597548,
            32597501,
            32596510,
            32594100,
            32588288
        ],
        "E": [
            32582663,
            32585881,
            32587039,
            32583891,
            32589038,
            32590654,
            32590403,
            32589458,
            32590147,
            32585649,
            32586443,
            32598380,
            32591576,
            32589935,
            32595163,
            32587306,
            32598292,
            32632299,
            32631834,
            32597903,
            32592050,
            32595887
        ],
        "C": [
            32580222,
            32581731,
            32579674,
            32581061,
            32582009,
            32580473,
            32581974,
            32581755,
            32582911,
            32582779,
            32581570,
            32581398,
            32580526,
            32582157,
            32582935,
            32581251,
            32583782,
            32581776,
            32581603,
            32588827
        ],
        "B": [
            32579038,
            32579297,
            32579032,
            32580119,
            32580362,
            32579253,
            32579828,
            32580254,
            32581551,
            32581638,
            32580169,
            32580423,
            32579209,
            32580529,
            32581182,
            32578812,
            32582642,
            32580448,
            32580061,
            32587514
        ],
        "A": [
            32578761,
            32578814,
            32578771,
            32578835,
            32579027,
            32578799,
            32578920,
            32578996,
            32579962,
            32580679,
            32579419,
            32579406,
            32579609,
            32579237,
            32580280,
            32579180,
            32578788,
            32579540,
            32578923,
            32586994
        ]
    },
    "name": "F. Subtree Minimum Query",
    "statement": "You are given a rooted tree consisting of vertices. Each vertex has a\r\nnumber written on it; number is written on vertex .Let’s denote as the\r\ndistance between vertices and in the tree (that is, the number of edges\r\nin the shortest path from to ). Also let’s denote the of vertex as the\r\nset of vertices such that both these conditions are met: is an ancestor\r\nof (every vertex is an ancestor of itself); . You are given queries to\r\nthe tree. -th query is represented by two numbers and , and the answer\r\nto this query is the minimum value of among such vertices such that\r\nbelongs to -blocked subtree of .Write a program that would process these\r\nqueries quickly!.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define itn int\n#define all(x) (x).begin(), (x).end()\n#define make_unique(x) sort(all((x))); (x).resize(unique(all((x))) - (x).begin())\n\n#ifdef ONLINE_JUDGE\n\tinline int pidorand() {\n\t\treturn ((rand() & 32767) << 15) | (rand() & 32767);\n\t}\n\t#define rand pidorand\n#endif\t// ONLINE_JUDGE\n\n#ifdef OLBOEB\n\t#define return std::cerr << __FUNCTION__ << \"\\n\"; return\n#endif  // OLBOEB\n\nusing namespace std;\n\ninline int nxt() {\n\tint x;\n\tscanf(\"%d\", &x);\n\treturn x;\n}\n\nstruct Vertex {\n\tint level;\n\tint val;\n\n\tVertex() {}\n\tVertex(int l, int v): level(l), val(v) {}\n\n\tbool operator <(const Vertex& ot) const {\n\t\treturn level < ot.level;\n\t}\n};\n\nconst int INF = 1e9 + 10;\n\nstruct SegTree {\n\tint n;\n\tvector<vector<Vertex>> a;\n\tvector<vector<int>> res;\n\n\tSegTree(const vector<int>& level, const vector<int>& vals) {\n\t\tn = 1;\n\t\twhile (n < (int)level.size()) {\n\t\t\tn *= 2;\n\t\t}\n\t\ta.resize(n + n);\n\t\tres.resize(n + n);\n\t\tfor (int i = 0; i < (int)level.size(); ++i) {\n\t\t\ta[n + i] = {{level[i], vals[i]}};\n\t\t\tres[n + i] = {INF, vals[i]};\n\t\t}\n\t\tfor (int i = n - 1; i > 0; --i) {\n\t\t\ta[i].resize(a[i + i].size() + a[i + i + 1].size());\n\t\t\tmerge(all(a[i + i]), all(a[i + i + 1]), a[i].begin());\n\t\t\tres[i].resize(a[i].size() + 1, INF);\n\t\t\tfor (int j = 0; j < (int)a[i].size(); ++j) {\n\t\t\t\tres[i][j + 1] = min(res[i][j], a[i][j].val);\n\t\t\t}\n\t\t}\n\t}\n\n\tint _get(int v, int l1, int r1, int l, int r, int maxk) {\n\t\tif (l >= r1 || l1 >= r) {\n\t\t\treturn INF;\n\t\t}\n\t\tif (l <= l1 && r >= r1) {\n\t\t\tint idx = lower_bound(all(a[v]), Vertex(maxk + 1, 0)) - a[v].begin();\n\t\t\treturn res[v][idx];\n\t\t}\n\t\tint mid = (l1 + r1) / 2;\n\t\treturn min(_get(v + v, l1, mid, l, r, maxk),\n\t\t\t\t   _get(v + v + 1, mid, r1, l, r, maxk));\n\t}\n\n\tint get(int l, int r, int maxk) {\n\t\treturn _get(1, 0, n, l, r, maxk);\n\t}\n};\n\nconst int N = 111111;\nint tin[N], tout[N], level[N];\nint timer = 0;\nvector<int> a[N];\nint val[N];\nvector<int> levels, vals;\n\nvoid dfs(int v, int p = -1) {\n\ttin[v] = timer++;\n\tlevels.push_back(level[v]);\n\tvals.push_back(val[v]);\n\tfor (int x : a[v]) {\n\t\tif (x == p) {\n\t\t\tcontinue;\n\t\t}\n\t\tlevel[x] = level[v] + 1;\n\t\tdfs(x, v);\n\t}\n\ttout[v] = timer;\n}\n\nint main() {\n\tint n = nxt(), root = nxt() - 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tval[i] = nxt();\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint u = nxt() - 1, v = nxt() - 1;\n\t\ta[u].push_back(v);\n\t\ta[v].push_back(u);\n\t}\n\n\tdfs(root);\n\n\tSegTree tree(levels, vals);\n\tint q = nxt();\n\tint last = 0;\n\twhile (q--) {\n\t\tint p1 = nxt(), p2 = nxt();\n\t\tint x = (p1 + last) % n;\n\t\tint k = (p2 + last) % n;\n\n\t\tlast = tree.get(tin[x], tout[x], level[x] + k);\n\t\tprintf(\"%d\\n\", last);\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "trees"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Subtree Minimum Query.json",
    "editorial_link": "https://codeforces.com//blog/entry/55989",
    "editorial": "The main idea is to use a two-dimensional data structure: one dimension\r\nis depth of vertices, and other dimension is the time we entered a\r\nvertex during DFS.Model solution uses sparse table for these purposes.\r\nFirst of all, letâs renumerate the vertices so we can handle them\r\neasier. We run DFS from the root and then sort the vertices by their\r\ndepth (and if depths are equal, by time we entered them in DFS). Then we\r\nrenumerate vertices in this sorted order.We need to denote some\r\nfunctions in order to continue: depth of vertex in the tree; the time we\r\nentered during DFS; the time we left during DFS. For each depth we can\r\nstore a sorted array of vertices belonging do this depth. This will\r\nallow us to build an auxiliary sparse table , where is such vertex that:\r\n; ; is minimal among all vertices that meet first two conditions. We\r\nalso need a second sparse table , where is iff: ; ; is minimal among all\r\nvertices that meet first two conditions. These sparse tables can be\r\nbuilt using binary search in arrays we created for depths.Okay, why do\r\nwe need them? To create a third sparse table that will process the\r\nqueries themselves: the minimum value of among vertices such that\r\nbelongs to -blocked subtree of some vertex with index included in . This\r\ntable can be built backwards with the help of auxiliary tables.So, how\r\ndo we answer the queries? We need to look at the binary representation\r\nof and do something like binary lifting (but descending the tree instead\r\nof ascending) and maintain the leftmost and the rightmost vertices on\r\ncurrent depth which belong to the subtree we are interested in (and make\r\nqueries to on the segment between these two vertices).This solution\r\nworks in , but, unfortunately (or fortunately to some participants), we\r\nmade the time limit too high so the structures that require time to\r\nprocess each query, such as two-dimensional segment trees, might also\r\nget AC.\r\n",
    "hint": []
}