{
    "link": "https://codeforces.com//contest/837/problem/D",
    "problemId": "116710",
    "problem_idx": "D",
    "shortId": "837D",
    "contest_number": "837",
    "problem_submissions": {
        "G": [
            29167867,
            29168921,
            29171657,
            29211841,
            29211768,
            29194112,
            29194042,
            29194028,
            29175447,
            29168227,
            29172693,
            29172204,
            29166926,
            29165613,
            29171547,
            29173009,
            29190922,
            32561173,
            29172886,
            29172783,
            29172758,
            29172505,
            29172166
        ],
        "F": [
            29165055,
            29166362,
            29168864,
            29166638,
            29169357,
            29169429,
            29164558,
            29186836,
            29168655,
            29167876,
            29169339,
            29172957,
            29171060,
            29171284,
            29168929,
            29172401,
            29169905,
            29168071,
            29172819
        ],
        "E": [
            29162020,
            29163186,
            29165795,
            29163264,
            29164907,
            29165095,
            29162428,
            29167933,
            29164726,
            29164807,
            29166669,
            29167308,
            29166973,
            29172476,
            29166198,
            29169034,
            29165312,
            29163338,
            29169750
        ],
        "D": [
            29161276,
            29162239,
            29163430,
            29162397,
            29162640,
            29163863,
            29160761,
            29163799,
            29174585,
            29164816,
            29165533,
            29164344,
            29163361,
            29163790,
            29167229,
            30486037,
            29175514,
            29161500,
            29167261
        ],
        "C": [
            29160368,
            29160646,
            29161707,
            29160573,
            29161464,
            29161685,
            29160675,
            29160760,
            29162171,
            29161153,
            29162346,
            29163214,
            29163154,
            29161641,
            29165376,
            29161315,
            29160556,
            29163716
        ],
        "B": [
            29159633,
            29159893,
            29160590,
            29159654,
            29160221,
            29159770,
            29161534,
            29161149,
            29160418,
            29160903,
            29161228,
            29162604,
            29271569,
            29164321,
            29195260,
            29160168,
            29175059,
            29162325
        ],
        "A": [
            29158816,
            29158847,
            29159160,
            29160665,
            29159109,
            29158852,
            29159205,
            29159017,
            29158817,
            29158878,
            29159185,
            29161667,
            29158818,
            29158815,
            29159058,
            29159399
        ]
    },
    "name": "D. Round Subset",
    "statement": "Let\u2019s call the of the number the number of zeros to which it ends.You\r\nhave an array of numbers. You need to choose a subset of exactly numbers\r\nso that the of the product of the selected numbers will be maximum\r\npossible.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:1048576\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 1234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\nint dp[205][8010];\nint tdp[205][8010];\nint in[205][2];\nint main() {\n\tint N, K, i, j, k;\n\tscanf(\"%d %d\", &N, &K);\n\tfor (i = 1; i <= N; i++) {\n\t\tll t;\n\t\tscanf(\"%lld\", &t);\n\t\twhile (t % 2 == 0) {\n\t\t\tin[i][0]++;\n\t\t\tt /= 2;\n\t\t}\n\t\twhile (t % 5 == 0) {\n\t\t\tin[i][1]++;\n\t\t\tt /= 5;\n\t\t}\n\t}\n\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) dp[i][j] = -INF;\n\tdp[0][0] = 0;\n\tfor (i = 1; i <= N; i++) {\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) tdp[j][k] = dp[j][k];\n\t\tfor (j = 0; j < K; j++) {\n\t\t\tfor (k = 0; k <= 8000; k++) {\n\t\t\t\tint j2 = j + 1, k2 = k + in[i][1];\n\t\t\t\tif (k2 <= 8000) tdp[j2][k2] = max(tdp[j2][k2], dp[j][k] + in[i][0]);\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j <= K; j++) for (k = 0; k <= 8000; k++) dp[j][k] = tdp[j][k];\n\t}\n\n\tint ans = 0;\n\tfor (i = 0; i <= K; i++) for (j = 0; j <= 8000; j++) ans = max(ans, min(j, dp[i][j]));\n\treturn !printf(\"%d\\n\", ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Round Subset.json",
    "editorial_link": "https://codeforces.com//blog/entry/53662",
    "editorial": "Let\u00e2\u0080\u0099s use dynamic programming to solve this task.Obviously, the of the\r\nnumber is determined by minimum of powers of and in the number. Let be\r\nthe maximal power of in the number and be the maximal power of .Let be\r\nthe maximum amount of twos we can collect by checking first numbers,\r\ntaking of them with total power of five equal to . It is usually called\r\n\"the knapsack problem\".There are two types of transitions. You can\r\neither take current element or skip it: The answer will be maximum of\r\nfor every . Also keeping this many states can cause ML, the first\r\ndimension should be stored in two layers and recalced on the fly.Overall\r\ncomplexity: .\r\n"
}