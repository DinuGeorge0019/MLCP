{"link": "https://codeforces.com//contest/1400/problem/G", "problemId": "709189", "problem_idx": "G", "shortId": "1400G", "contest_number": "1400", "problem_submissions": {"D": [91063958, 91019003, 90921157, 90924583, 91129094, 90921742, 90924518, 90925405, 90924228, 90928527, 90927053, 90928008, 90921390, 90926754, 90926098, 90923479, 90932560, 90927207, 90928111, 90927601, 90927240], "E": [91063322, 90999997, 90927958, 90932635, 91129112, 90933891, 90932788, 90935094, 90929091, 90933541, 90984689, 90938941, 90934180, 90924023, 90933282, 90933092, 92294796, 92121423, 90928722, 90927143, 91007103, 90937273, 90935595, 90936018, 90937203, 90931579], "A": [90999219, 90908018, 90908383, 91129044, 90908056, 90908072, 90909135, 90908276, 90908322, 90909230, 90908179, 90908024, 90908751, 90908160, 90908096, 90908554, 90910364, 90910969, 90908122, 90909588], "G": [90977154, 90944389, 90958977, 91129247, 90953059, 90965280, 90969288, 90980892, 90974551, 90962476, 90980693, 90948619, 90945807, 90946996, 90945319, 90958148, 90949510, 90964852, 90966663], "F": [90977148, 90956838, 90944290, 91129137, 90963414, 90954565, 90943343, 90954552, 90955511, 90976453, 90961680, 90961250, 91019872, 91482375, 91348176, 90960811, 91338009, 90994292], "B": [90918673, 90916748, 91129051, 90911853, 90914978, 90917579, 90917952, 90918236, 90916691, 90916458, 90913884, 90919126, 90919862, 90914960, 90914966, 90919061, 90921310, 90914836, 90917699], "C": [90915688, 90920946, 91129078, 90918859, 90921028, 90921919, 90921370, 90923530, 90922399, 90921710, 90918731, 90923624, 90923408, 90918967, 90930451, 90922773, 90925808, 90920451, 90924212]}, "name": "G. Mercenaries", "statement": "Polycarp plays a (yet another!) strategic computer game. In this game,\r\nhe leads an army of mercenaries.Polycarp wants to gather his army for a\r\nquest. There are n mercenaries for hire, and the army should consist of\r\nsome subset of them.The i-th mercenary can be chosen if the number of\r\nchosen mercenaries is not less than l_i (otherwise he deems the quest to\r\nbe doomed) and not greater than r_i (he doesn\u2019t want to share the\r\ntrophies with too many other mercenaries). Furthermore, m pairs of\r\nmercenaries hate each other and cannot be chosen for the same quest. How\r\nmany subsets does Polycarp need to consider? In other words, calculate\r\nthe number of non-empty subsets of mercenaries such that the size of\r\nthis subset belongs to [l_i, r_i] for each chosen mercenary, and there\r\nare no two mercenaries in the subset that hate each other.The answer may\r\nbe large, so calculate it modulo 998244353.\r\n", "solutions": ["#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(uint64_t v) {\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    _m_int(int v) : _m_int(int64_t(v)) {}\n    _m_int(unsigned v) : _m_int(uint64_t(v)) {}\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator unsigned() const { return val; }\n    explicit operator int64_t() const { return val; }\n    explicit operator uint64_t() const { return val; }\n    explicit operator double() const { return val; }\n    explicit operator long double() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    friend bool operator==(const _m_int &a, const _m_int &b) { return a.val == b.val; }\n    friend bool operator!=(const _m_int &a, const _m_int &b) { return a.val != b.val; }\n    friend bool operator<(const _m_int &a, const _m_int &b) { return a.val < b.val; }\n    friend bool operator>(const _m_int &a, const _m_int &b) { return a.val > b.val; }\n    friend bool operator<=(const _m_int &a, const _m_int &b) { return a.val <= b.val; }\n    friend bool operator>=(const _m_int &a, const _m_int &b) { return a.val >= b.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 998244353;\nusing mod_int = _m_int<MOD>;\n\n\nvector<mod_int> inv, factorial, inv_factorial;\nint prepared_maximum = -1;\n\nvoid prepare_factorials(int64_t maximum) {\n    static int prepare_calls = 0;\n\n    if (prepare_calls++ == 0) {\n        // Make sure MOD is prime, which is necessary for the inverse algorithm below.\n        for (int p = 2; p * p <= MOD; p += p % 2 + 1)\n            assert(MOD % p != 0);\n\n        inv = {0, 1};\n        factorial = inv_factorial = {1, 1};\n        prepared_maximum = 1;\n    }\n\n    if (maximum > prepared_maximum) {\n        inv.resize(maximum + 1);\n        factorial.resize(maximum + 1);\n        inv_factorial.resize(maximum + 1);\n\n        for (int i = prepared_maximum + 1; i <= maximum; i++) {\n            inv[i] = inv[MOD % i] * (MOD - MOD / i);\n            factorial[i] = i * factorial[i - 1];\n            inv_factorial[i] = inv[i] * inv_factorial[i - 1];\n        }\n\n        prepared_maximum = int(maximum);\n    }\n}\n\nmod_int choose(int64_t n, int64_t r) {\n    if (r < 0 || r > n) return 0;\n    return factorial[n] * inv_factorial[r] * inv_factorial[n - r];\n}\n\nmod_int inv_choose(int64_t n, int64_t r) {\n    assert(0 <= r && r <= n);\n    return inv_factorial[n] * factorial[r] * factorial[n - r];\n}\n\nmod_int permute(int64_t n, int64_t r) {\n    if (r < 0 || r > n) return 0;\n    return factorial[n] * inv_factorial[n - r];\n}\n\nmod_int inv_permute(int64_t n, int64_t r) {\n    assert(0 <= r && r <= n);\n    return inv_factorial[n] * factorial[n - r];\n}\n\nstruct union_find {\n    // When data[x] < 0, x is a root and -data[x] is its tree size. When data[x] >= 0, data[x] is x's parent.\n    vector<int> data;\n    int components = 0;\n\n    union_find(int n = -1) {\n        if (n >= 0)\n            init(n);\n    }\n\n    void init(int n) {\n        data.assign(n + 1, -1);\n        components = n;\n    }\n\n    int find(int x) {\n        return data[x] < 0 ? x : data[x] = find(data[x]);\n    }\n\n    int get_size(int x) {\n        return -data[find(x)];\n    }\n\n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n\n        if (x == y)\n            return false;\n\n        if (-data[x] < -data[y])\n            swap(x, y);\n\n        data[x] += data[y];\n        data[y] = x;\n        components--;\n        return true;\n    }\n};\n\n\nint N, M;\nvector<int> L, R;\nvector<vector<int>> adj;\nvector<vector<int>> components;\nvector<vector<vector<int>>> component_dp;\n// vector<int> which_component;\n\nbool edge_exists(int a, int b) {\n    return binary_search(adj[a].begin(), adj[a].end(), b);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    cin >> N >> M;\n    prepare_factorials(N);\n    L.resize(N);\n    R.resize(N);\n\n    for (int i = 0; i < N; i++)\n        cin >> L[i] >> R[i];\n\n    adj.assign(N, {});\n    union_find UF(N);\n\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        UF.unite(a, b);\n    }\n\n    for (int i = 0; i < N; i++)\n        sort(adj[i].begin(), adj[i].end());\n\n    for (int root = 0; root < N; root++)\n        if (UF.find(root) == root && UF.get_size(root) > 1) {\n            vector<int> component;\n\n            for (int i = 0; i < N; i++)\n                if (UF.find(i) == root)\n                    component.push_back(i);\n\n            components.push_back(component);\n        }\n\n    // which_component.assign(N, -1);\n\n    // for (int c = 0; c < int(components.size()); c++)\n    //     for (int x : components[c])\n    //         which_component[x] = c;\n\n    component_dp.assign(components.size(), {});\n\n    for (int c = 0; c < int(components.size()); c++) {\n        auto &component = components[c];\n        auto &dp = component_dp[c];\n        int C = int(component.size());\n        vector<vector<bool>> bad(C, vector<bool>(C, false));\n\n        for (int i = 0; i < C; i++)\n            for (int j = i + 1; j < C; j++)\n                bad[i][j] = edge_exists(component[i], component[j]);\n\n        dp.assign(1 << C, vector<int>(C + 1, 0));\n\n        for (int mask = 0; mask < 1 << C; mask++) {\n            bool works = true;\n\n            for (int i = 0; i < C && works; i++)\n                if (mask >> i & 1)\n                    for (int j = i + 1; j < C && works; j++)\n                        if ((mask >> j & 1) && bad[i][j])\n                            works = false;\n\n            if (works)\n                dp[mask][__builtin_popcount(mask)] = 1;\n        }\n\n        for (int bit = 0; bit < C; bit++)\n            for (int mask = 0; mask < 1 << C; mask++)\n                if ((mask >> bit & 1) == 0)\n                    for (int i = 0; i < C; i++)\n                        dp[mask | 1 << bit][i] += dp[mask][i];\n\n        dbg(dp);\n    }\n\n    vector<int> freq(N + 2, 0);\n\n    for (int i = 0; i < N; i++) {\n        freq[L[i]]++;\n        freq[R[i] + 1]--;\n    }\n\n    for (int i = 1; i <= N; i++)\n        freq[i] += freq[i - 1];\n\n    mod_int answer = 0;\n\n    for (int num = 1; num <= N; num++) {\n        int merc = freq[num];\n        vector<mod_int> knapsack(2 * M + 1, 0);\n        knapsack[0] = 1;\n        int in_component = 0;\n\n        for (int c = 0; c < int(components.size()); c++) {\n            auto &component = components[c];\n            int C = int(component.size());\n            int mask = 0;\n\n            for (int i = 0; i < C; i++)\n                if (L[component[i]] <= num && num <= R[component[i]])\n                    mask |= 1 << i;\n\n            in_component += __builtin_popcount(mask);\n\n            for (int count = M - 1; count >= 0; count--)\n                for (int add = 1; add <= C; add++)\n                    knapsack[count + add] += knapsack[count] * component_dp[c][mask][add];\n        }\n\n        for (int have = 0; have <= M; have++)\n            answer += knapsack[have] * choose(merc - in_component, num - have);\n    }\n\n    cout << answer << '\\n';\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "brute force", "combinatorics", "dp", "dsu", "math", "two pointers"], "dificulty": "2600", "interactive": false}