{
    "link": "https://codeforces.com//contest/1681/problem/B",
    "problemId": "1408803",
    "problem_idx": "B",
    "shortId": "1681B",
    "contest_number": "1681",
    "problem_submissions": {
        "E": [
            158182756,
            158181599,
            158189245,
            158201402,
            158212176,
            158209977,
            158197244,
            158200543,
            158207419,
            158195422,
            158212507,
            158201688,
            158217615,
            158236025,
            158203326,
            158213610,
            158220340,
            158209570,
            158222642,
            158202788
        ],
        "D": [
            158169620,
            158166339,
            158168627,
            158176540,
            158180183,
            158179810,
            158175614,
            158171745,
            158169793,
            158171043,
            158176143,
            158179351,
            158198071,
            158177219,
            158193904,
            158184952,
            158187520,
            158180354,
            158208785
        ],
        "F": [
            158163420,
            158197514,
            158198216,
            158189118,
            158175678,
            158193941,
            158204936,
            158208270,
            158190074,
            158203305,
            158200335,
            158211270,
            158186690,
            158250369,
            158237153,
            158219180,
            158187046,
            158203102,
            158220096,
            158206596,
            158220727
        ],
        "C": [
            158154298,
            158157033,
            158157275,
            158158888,
            158161011,
            158157520,
            158164047,
            158162763,
            158158338,
            158166846,
            158162496,
            158167443,
            158168946,
            158167710,
            158166768,
            158169766,
            158168157,
            158169965,
            158164354
        ],
        "B": [
            158153598,
            158154121,
            158153990,
            158154166,
            158155404,
            158154059,
            158159057,
            158156022,
            158154367,
            158163137,
            158157819,
            158159126,
            158157005,
            158167777,
            158160391,
            158158841,
            158161305,
            158161887,
            158159104
        ],
        "A": [
            158153541,
            158153617,
            158153597,
            158153653,
            158153683,
            158153631,
            158155593,
            158153768,
            158153633,
            158155729,
            158155747,
            158154711,
            158154019,
            158167893,
            158153987,
            158154332,
            158156617,
            158157260,
            158154882
        ]
    },
    "name": "B. Card Trick",
    "statement": "Monocarp has just learned a new card trick, and can\u2019t wait to present it\r\nto you. He shows you the entire deck of n cards. You see that the values\r\nof cards from the topmost to the bottommost are integers a_1, a_2,\r\ndots, a_n, and all values are different.Then he asks you to shuffle the\r\ndeck m times. With the j-th shuffle, you should take b_j topmost cards\r\nand move them under the remaining (n - b_j) cards without changing the\r\norder.And then, using some magic, Monocarp tells you the topmost card of\r\nthe deck. However, you are not really buying that magic. You tell him\r\nthat you know the topmost card yourself. Can you surprise Monocarp and\r\ntell him the topmost card before he shows it?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 23.05.2022 18:36:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    int m;\n    cin >> m;\n    vector<long long> b(m);\n    for (int i = 0; i < m; i++) {\n      cin >> b[i];\n    }\n    long long s = accumulate(b.begin(), b.end(), 0LL);\n    cout << a[s % n] << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Card Trick.json",
    "editorial_link": "https://codeforces.com//blog/entry/103163",
    "editorial": "The easiest way to solve to problem is probably to see the resemblense\r\nof a shuffle operation to an std::rotate function. So you can obtain the\r\nfinal deck by applying cyclic shifts of the deck by , then and so\r\non.Since the shifts are cyclic, it doesn\u00e2\u0080\u0099t matter if you shift by or by\r\nor by for any non-negative . The result will be the same. Thus, you can\r\ncalculate the sum of rotations you apply, and subtract , until it\r\nbecomes less than . That is taking it modulo .Finally, after rotating a\r\nsequence by some , the -th element of it (-indexed) becomes the first\r\none. Thus, you just want to print the ()-th element of .Overall\r\ncomplexity: per testcase.\r\n"
}