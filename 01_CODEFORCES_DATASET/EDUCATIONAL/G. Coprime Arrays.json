{
    "link": "https://codeforces.com//contest/915/problem/G",
    "problemId": "146474",
    "problem_idx": "G",
    "shortId": "915G",
    "contest_number": "915",
    "problem_submissions": {
        "G": [
            34149372,
            34145802,
            34144917,
            34149940,
            34145497,
            34145091,
            34146841,
            34133578,
            34140368,
            34156614,
            34136642,
            34149433,
            34141049,
            34151857,
            34143141,
            34142291,
            34153795,
            34152031,
            34149642
        ],
        "F": [
            34141740,
            34141911,
            34142659,
            34144461,
            34139648,
            34150037,
            34135451,
            34135325,
            34136765,
            34139507,
            34185912,
            34185895,
            34185884,
            34144212,
            34147801,
            34138374,
            34149691,
            34145676,
            34149957
        ],
        "E": [
            34139509,
            34136671,
            34139993,
            34142857,
            34141594,
            34143243,
            34138759,
            34150868,
            34131224,
            34145365,
            34144825,
            34146415,
            34139658,
            34148670,
            34147938,
            34144847,
            34142409,
            34147934,
            34152612
        ],
        "D": [
            34136912,
            34138946,
            34136834,
            34138837,
            34134917,
            34139148,
            34142081,
            34147574,
            34141584,
            34140548,
            34136477,
            34136703,
            34136486,
            34145522,
            34138909,
            34138016,
            34141644,
            34141385,
            34135263
        ],
        "C": [
            34133179,
            34132160,
            34132616,
            34134296,
            34131528,
            34132656,
            34145969,
            34144943,
            34139362,
            34131971,
            34135532,
            34132111,
            34166504,
            34134375,
            34134967,
            34134748,
            34132949,
            34134607,
            34133338
        ],
        "B": [
            34129725,
            34129567,
            34129784,
            34132321,
            34130243,
            34147501,
            34142325,
            34138326,
            34132523,
            34157084,
            34130697,
            34130455,
            34131022,
            34130794,
            34158518,
            34130482
        ],
        "A": [
            34127694,
            34127702,
            34127886,
            34130517,
            34127730,
            34147894,
            34141073,
            34137409,
            34128096,
            34127668,
            34127948,
            34127873,
            34127723,
            34128273,
            34128083,
            34127880
        ]
    },
    "name": "G. Coprime Arrays",
    "statement": "Let\u2019s call an array of size iff , where is the greatest common divisor\r\nof the arguments.You are given two numbers and . For each () you have to\r\ndetermine the number of arrays of size such that for every () . Since\r\nthe answers can be very large, you have to calculate them modulo .\r\n",
    "solutions": [
        "#define _CRT_SECURE_NO_DEPRECATE\n#pragma comment(linker, \"/STACK:167772160000\")\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <stdio.h>\n#include <cstdlib>\n#include <stdlib.h>\n#include <string>\n#include <list>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <iomanip>\n#include <queue>\n#include <deque>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <assert.h>\n#include <functional>\n#include <climits>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\n//typedef uint64_t ull;\n//typedef std::pair<long double,long double> pdd;\n#define for8(i) for( i = 1; i<=8; i++)\n#define fori(N)          for(int i = 0; i<(N); i++)\n#define forj(N)         for(int j = 0; j<(N); j++)\n#define fork(N)         for(int k = 0; k<(N); k++)\n#define forl(N)         for(int l = 0; l<(N); l++)\n#define ford(N)         for(int d = 0; d<(N); d++)\n#define fori1(N)          for(int i = 1; i<=(N); i++)\n#define forj1(N)         for(int j = 1; j<=(N); j++)\n#define fork1(N)         for(int k = 1; k<=(N); k++)\n#define ford1(N)         for(int d = 1; d<=(N); d++)\n#define PI (2*asin(1))\n#define read(n) scanf(\"%d\", &n);\n#define read2(n, m) scanf(\"%d%d\", &n, &m);\n#define readll(n) scanf(\"%I64d\", &n);\n#define mp make_pair\nconst ll mod = 1000000007;\nconst int maxn = 2100000;\nvector<int>divisors[maxn];\nll power(ll a, ll b) {\n\tll res = 1;\n\twhile (b > 0) {\n\t\tif (b % 2 == 1)\n\t\t\tres = (res*a) % mod;\n\t\tb /= 2;\n\t\ta = (a*a) % mod;\n\t}\n\treturn res;\n}\n\nll multip[maxn];\nll takenIn[maxn];\nbool isPrime[maxn];\nll powers[maxn];\nint main()\n{\n\tios::sync_with_stdio(false); cin.tie(0);\n#if defined(_DEBUG) || defined(_RELEASE)\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tint n, k; cin >> n >> k;\n\tswap(n, k);\n\tfori1(n)multip[i] = -1;\n\tmultip[1] = 0;\n\tll totalAns = 0;\n\tfori1(n)powers[i] = power(i, k);\n\tfori1(n)isPrime[i] = true;\n\tisPrime[1] = false;\n\tfori1(n) {\n\t\tif (multip[i] == 0)continue;\n\t\tif (isPrime[i])\n\t\t\tmultip[i] *= -1;\n\t\tfor (int j = i * 2; j <= n; j += i) {\n\t\t\tif (isPrime[i] && j % ((ll)i*i) == 0) {\n\t\t\t\tmultip[j] = 0;\n\t\t\t}\n\t\t\t//if(multip[i] != 0)\n\t\t\tdivisors[j].push_back(i);\n\t\t\tif(isPrime[i])\n\t\t\t\tisPrime[j] = false;\n\t\t\tif (isPrime[i])\n\t\t\t\tmultip[j] *= -1;\n\t\t}\n\t}\n\tll curAns = 0;\n\tfori1(n) {\n\t\tfor (auto x : divisors[i]) {\n\t\t\tcurAns -= multip[x] * takenIn[x];\n\t\t\ttakenIn[x] = powers[i/x];\n\t\t\tcurAns += multip[x] * takenIn[x];\n\t\t\tcurAns %= mod;\n\t\t}\n\t\ttakenIn[i] = 1;\n\t\tcurAns += multip[i]*1;\n\t\tll cur = powers[i] - curAns;\n\t\tcur %= mod;\n\t\tcur += mod;\n\t\tcur %= mod;\n\t\tcur ^= i;\n\t\tcur %= mod;\n\t\ttotalAns += cur;\n\t}\n\ttotalAns %= mod;\n\tcout << totalAns;\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Coprime Arrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/57123",
    "editorial": "For a fixed upper bound , this is a well-known problem that can be\r\nsolved using inclusion-exclusion:Let\u00e2\u0080\u0099s denote by the number of arrays\r\nwith elements in range such that is divisible by . Obviously, . With the\r\nhelp of inclusion-exclusion formula we can prove that the number of\r\narrays with is the sum of the following values over all possible sets :\r\n, where is some set of prime numbers (possibly an empty set), and is the\r\nproduct of all elements in the set. in this formula denotes the number\r\nof arrays such that their is divisible by every number from set\r\n.However, the number of such sets is infinite, so we need to use the\r\nfact that if . With the help of this fact, we can rewrite the sum over\r\nevery set in such a way: , where is if there is no any set of prime\r\nnumbers such that , if this set exists, and the sign is determined by\r\nthe size of ( if is even, otherwise ).An easier way to denote and\r\ncalculate is the following (by the way, it is called M bius function):,\r\nif there is some prime number p such that . Otherwise , where is the\r\nnumber of primes in the factorization of .Okay, so we found a solution\r\nfor one upper bound , it\u00e2\u0080\u0099s . How can we calculate it for every from to\r\n?Suppose we have calculated all values of for some and we want to\r\nrecalculate them for . The important fact is that these values change\r\n(and thus need recalculation) only for the numbers such that . So if we\r\nrecalculate only these values (and each recalculation can be done in\r\ntime if we precompute the for every ), then we will have to do only\r\nrecalculations overall.\r\n"
}