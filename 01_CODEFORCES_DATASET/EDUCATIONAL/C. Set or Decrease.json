{
    "link": "https://codeforces.com//contest/1622/problem/C",
    "problemId": "1242579",
    "problem_idx": "C",
    "shortId": "1622C",
    "contest_number": "1622",
    "problem_submissions": {
        "F": [
            140796824,
            140798013,
            140806008,
            140808778,
            140806009,
            140805051,
            140814076,
            140828348,
            140819179,
            140855589,
            140855586,
            140839728,
            140839370,
            140821060,
            140807144,
            140812999,
            140804188,
            140824231,
            140824165,
            140822940,
            140804052,
            140823222,
            140819745,
            140824560,
            140857950,
            140834838,
            140832376,
            140829343,
            140828751,
            140828269,
            140827798
        ],
        "E": [
            140765216,
            140779319,
            140785115,
            140782340,
            140780692,
            140780184,
            140838345,
            140780973,
            140780107,
            140783378,
            140789562,
            140786801,
            140785714,
            140786518,
            140775048,
            140770202,
            140781928,
            140783559,
            140781100,
            140785123,
            140785377,
            140784613
        ],
        "D": [
            140761526,
            140770308,
            140773276,
            140775500,
            140776032,
            140771575,
            140837879,
            140773697,
            140780198,
            140777190,
            140779965,
            140773920,
            140787545,
            140769780,
            140775729,
            140849022,
            140772131,
            140772048,
            140774887,
            140775893,
            140779501,
            140776197
        ],
        "C": [
            140756712,
            140763210,
            140766719,
            140766708,
            140766349,
            140764400,
            140762686,
            140760355,
            140768706,
            140766328,
            140766600,
            140768126,
            140759456,
            140764367,
            140761869,
            140765074,
            140766561,
            140767346,
            140764755,
            140763284,
            140767658
        ],
        "B": [
            140752335,
            140756349,
            140756665,
            140761975,
            140757886,
            140760857,
            140757453,
            140753171,
            140760768,
            140761439,
            140759017,
            140757918,
            140754004,
            140754798,
            140756955,
            140757416,
            140757531,
            140759831,
            140758370,
            140759772
        ],
        "A": [
            140751413,
            140751825,
            140751782,
            140754411,
            140752339,
            140751676,
            140751944,
            140751415,
            140752483,
            140751783,
            140754865,
            140752090,
            140751540,
            140751564,
            140751671,
            140751951,
            140752002,
            140751977,
            140751451,
            140754316
        ]
    },
    "name": "C. Set or Decrease",
    "statement": "You are given an integer array a_1, a_2,\r\ndots, a_n and integer k.In one step you can either choose some index i\r\nand decrease a_i by one (make a_i = a_i - 1); or choose two indices i\r\nand j and set a_i equal to a_j (make a_i = a_j). What is the minimum\r\nnumber of steps you need to make the sum of array\r\nsum\r\nlimits_{i=1}^{n}{a_i}\r\nle k? (You are allowed to make values of array negative).\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 27.12.2021 17:38:21       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    long long k;\n    cin >> n >> k;\n    vector<long long> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    sort(a.begin(), a.end());\n    vector<long long> pref(n + 1);\n    for (int i = 0; i < n; i++) {\n      pref[i + 1] = pref[i] + a[i];\n    }\n    long long ans = (long long) 9e18;\n    for (int t = 0; t <= n - 1; t++) {\n      long long sum = pref[n - t] + a[0] * t;\n      long long cur = t;\n      if (sum > k) {\n        long long diff = sum - k;\n        cur += (diff + t) / (t + 1);\n      }\n      ans = min(ans, cur);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "brute force",
        "greedy",
        "sortings"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Set or Decrease.json",
    "editorial_link": "https://codeforces.com//blog/entry/98453",
    "editorial": "First, we can prove that the optimal way to perform operations is first,\r\ndecrease the minimum value several (maybe, zero) times, then take\r\nseveral (maybe, zero) maximums and make them equal to the minimum value.\r\nThe proof consists of several steps: Prove that first, we make\r\ndecreases, only then sets: if some is done after some then if there were\r\nno modification of then you can just move earlier. Otherwise, there were\r\n, and you can replace (... , ...) with (... , ...). We demonstrated how\r\nto move decrease operations before set operations. Prove that itâs\r\noptimal to decrease only one element : instead of decreasing by and by\r\n(where ), we can decrease by and replace all with . Itâs optimal to\r\ndecrease the minimum element it follows from proof of previous step. If\r\nwe make set operations, itâs optimal to set minimum value to maximum\r\nelements should be obvious. To use the strategy, weâll firstly sort\r\narray in non-decreasing order. In this case, weâll decrease by and\r\nperform set to elements . The question is: how to minimize value of\r\n?Note, that (since setting the same position multiple times has no\r\nsense). Letâs iterate over all possible values of and determine the\r\nminimum needed.The resulting array will consists of . Letâs say that\r\n(and all can be precomputed beforehand). Then the sum of array will\r\nbecome , and we need or, since we need minimum possible , Using the\r\nformula above, we can for each () calculate minimum required. But to be\r\naccurate, value may be negative, and, usually in programming languages,\r\ninteger division for negative returns instead of .There is an\r\nalternative solution: note that if , then . Note that if then resulting\r\nvalue of is in and there are at most possible value for . So, you can\r\niterate over all possible and for each calculate minimum required either\r\nwith binary search or two pointers.\r\n",
    "hint": []
}