{"link": "https://codeforces.com//contest/1197/problem/E", "problemId": "376706", "problem_idx": "E", "shortId": "1197E", "contest_number": "1197", "problem_submissions": {"E": [57531154, 57527419, 57524743, 57530013, 57536981, 57526074, 57537246, 57517565, 57532671, 57531296, 57535739, 57533494, 57533139, 57532015, 57531974, 57534465, 57537214, 57536595, 57532983, 57537941], "F": [57526205, 57536510, 57543227, 57542356, 57545070, 57550429, 57543354, 57546681, 57528127, 57549295, 57552678, 57550308, 57548615, 57551319, 57581907, 57549488, 57548121, 57552168, 57768625, 57596008], "D": [57517769, 57521167, 57531349, 57521225, 57523524, 57536466, 57530751, 57531287, 57521039, 57522693, 57521081, 57524029, 57524614, 57523599, 57524677, 65550218, 65550195, 57524514, 57523363, 57524805, 57525867, 57524276], "C": [57514645, 57521161, 57515560, 57517240, 57519467, 57517149, 57517926, 57531832, 57516648, 57519324, 57516744, 57516779, 57517866, 57515185, 57519335, 57518781, 57516998, 57518983, 57516506, 57517063], "B": [57513686, 57521152, 57513883, 57515172, 57516705, 57515562, 57515187, 57532696, 57515047, 57517088, 57514854, 57515032, 57514991, 57513966, 57514537, 57515780, 57514347, 57514964, 57514669, 57515319], "A": [57513085, 57521143, 57513101, 57513203, 57513756, 57513671, 57513230, 57532141, 57513274, 57513512, 57513153, 57513271, 57513173, 57513091, 57513126, 57513220, 57513223, 57513310, 57513141, 57513251]}, "name": "E. Culture Code", "statement": "There are famous Russian nesting dolls named matryoshkas sold in one of\r\nthe souvenir stores nearby, and you\u2019d like to buy several of them. The\r\nstore has n different matryoshkas. Any matryoshka is a figure of volume\r\nout_i with an empty space inside of volume in_i (of course, out_i >\r\nin_i).You don\u2019t have much free space inside your bag, but, fortunately,\r\nyou know that matryoshkas can be nested one inside another. Formally,\r\nlet\u2019s call a set of matryoshkas if we can rearrange dolls in such a way,\r\nthat the first doll can be nested inside the second one, the second doll\r\ninside the third one and so on. Matryoshka i can be nested inside\r\nmatryoshka j if out_i\r\nle in_j. So only the last doll will take space inside your bag.Let\u2019s\r\ncall of a nested set of dolls as a total volume of empty space inside\r\nthis structure. Obviously, it\u2019s equal to in_{i_1} + (in_{i_2} -\r\nout_{i_1}) + (in_{i_3} - out_{i_2}) +\r\ndots + (in_{i_k} - out_{i_{k-1}}), where i_1, i_2, ..., i_k are the\r\nindices of the chosen dolls in the order they are nested in each\r\nother.Finally, let\u2019s call a nested subset of the given sequence as if\r\nthere isn\u2019t any doll from the sequence that can be added to the nested\r\nsubset without breaking its nested property.You want to buy many\r\nmatryoshkas, so you should choose a nested subset to buy it. But you\r\nwill be disappointed if too much space in your bag will be wasted, so\r\nyou want to choose a big enough subset so that its is minimum possible\r\namong all big enough subsets. Now you wonder, how many different nested\r\nsubsets meet these conditions (they are big enough, and there is no big\r\nenough subset such that its extra space is less than the extra space of\r\nthe chosen subset). Two subsets are considered different if there exists\r\nat least one index i such that one of the subsets contains the i-th\r\ndoll, and another subset doesn\u2019t.Since the answer can be large, print it\r\nmodulo 10^9 + 7.\r\n", "solutions": ["#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int MOD = (int)1e9 + 7;\nint add(int x, int y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\n\npii merge(pii x, pii y) {\n\tpii res = min(x, y);\n\tres.second = 0;\n\tif (res.first == x.first) res.second = add(res.second, x.second);\n\tif (res.first == y.first) res.second = add(res.second, y.second);\n\treturn res;\n}\n\nconst int N = 400400;\nint n;\npii dp[N];\nint a[N][2];\n\nstruct Event {\n\tint t, x, id;\n\n\tEvent() : t(), x(), id() {}\n\tEvent(int _t, int _x, int _id) : t(_t), x(_x), id(_id) {}\n\n\tbool operator < (const Event &e) const {\n\t\tif (x != e.x) return x > e.x;\n\t\treturn t < e.t;\n\t}\n};\nEvent ev[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &a[i][1], &a[i][0]);\n\t\tev[2 * i] = Event(0, a[i][0], i);\n\t\tev[2 * i + 1] = Event(1, a[i][1], i);\n\t}\n\tsort(ev, ev + 2 * n);\n\tfor (int i = 0; i < n; i++)\n\t\tdp[i] = mp(MOD, 0);\n\tpii cur = mp(MOD, 0);\n\tfor (int i = 0; i < 2 * n; i++) {\n\t\tif (ev[i].t == 0) {\n\t\t\tcur = merge(cur, dp[ev[i].id]);\n\t\t} else {\n\t\t\tif (cur.first == MOD) {\n\t\t\t\tdp[ev[i].id] = mp(a[ev[i].id][0], 1);\n\t\t\t} else {\n\t\t\t\tpii w = cur;\n\t\t\t\tw.first -= a[ev[i].id][1] - a[ev[i].id][0];\n\t\t\t\tdp[ev[i].id] = w;\n\t\t\t}\n\t\t}\n\t}\n\tcur = mp(MOD, 0);\n\tfor (int i = 0; i < n; i++)\n\t\tcur = merge(cur, dp[i]);\n\tprintf(\"%d\\n\", cur.second);\n\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "combinatorics", "data structures", "dp", "shortest paths", "sortings"], "dificulty": "2300", "interactive": false}