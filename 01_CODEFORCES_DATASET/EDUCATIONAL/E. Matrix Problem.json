{"link": "https://codeforces.com//contest/1913/problem/E", "problemId": "2387091", "problem_idx": "E", "shortId": "1913E", "contest_number": "1913", "problem_submissions": {"F": [237765417, 237786045, 237798410, 237793751, 237794290, 237782267, 237795023, 237800140, 237807937, 237810699, 237812614, 249487858, 249487734, 237811339, 237810034, 237786173, 237918310, 238095706, 238317726, 238317705, 238317604, 238062834, 238062445, 237828170], "E": [237747038, 237760786, 237768219, 237770076, 237769118, 237750176, 237762212, 237777254, 237781408, 237770526, 237770804, 237785103, 237769588, 237762037, 237767968, 237768315, 237776019, 237777315, 237775619], "D": [237741941, 237751825, 237754635, 237754576, 237759161, 237795697, 237798473, 237753926, 237756867, 237764842, 237762933, 237761396, 237809126, 237799893, 237754034, 237759987, 237761087, 237760420, 237755829, 237761290], "C": [237735693, 237739173, 237740092, 237741221, 237739010, 237738520, 237799594, 237738193, 237740375, 237744478, 237744080, 237745844, 237762290, 237803855, 237741083, 237740358, 237744813, 237743742, 237745330, 237745113], "B": [237734023, 237735619, 237736194, 237737923, 237736443, 237735162, 237800569, 237735958, 237737285, 237740748, 237737318, 237739744, 237743140, 237806408, 237735801, 237736968, 237740846, 237738174, 237741145, 237740499], "A": [237733399, 237733472, 237733545, 237733680, 237733544, 237733357, 237734167, 237733513, 237734405, 237733701, 237733822, 237734094, 237807435, 237733584, 237733737, 237733530, 237733681, 237735085, 237733871]}, "name": "E. Matrix Problem", "statement": "You are given a matrix a, consisting of n rows by m columns. Each\r\nelement of the matrix is equal to 0 or 1.You can perform the following\r\noperation any number of times (possibly zero): choose an element of the\r\nmatrix and replace it with either 0 or 1.You are also given two arrays A\r\nand B (of length n and m respectively). After you perform the\r\noperations, the matrix should satisfy the following conditions: the\r\nnumber of ones in the i-th row of the matrix should be exactly A_i for\r\nevery i\r\nin [1, n]. the number of ones in the j-th column of the matrix should be\r\nexactly B_j for every j\r\nin [1, m]. Calculate the minimum number of operations you have to\r\nperform.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 18.12.2023 09:46:05       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\n#include <bits/extc++.h>\n\ntemplate <typename T, typename C>\nclass MCMF {\n public:\n  static constexpr T eps = (T) 1e-9;\n\n  struct edge {\n    int from;\n    int to;\n    T c;\n    T f;\n    C cost;\n  };\n\n  int n;\n  vector<vector<int>> g;\n  vector<edge> edges;\n  vector<C> d;\n  vector<C> pot;\n  __gnu_pbds::priority_queue<pair<C, int>> q;\n  vector<typename decltype(q)::point_iterator> its;\n  vector<int> pe;\n  const C INF_C = numeric_limits<C>::max() / 2;\n\n  explicit MCMF(int n_) : n(n_), g(n), d(n), pot(n, 0), its(n), pe(n) {}\n\n  int add(int from, int to, T forward_cap, T backward_cap, C edge_cost) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    assert(forward_cap >= 0 && backward_cap >= 0);\n    int id = static_cast<int>(edges.size());\n    g[from].push_back(id);\n    edges.push_back({from, to, forward_cap, 0, edge_cost});\n    g[to].push_back(id + 1);\n    edges.push_back({to, from, backward_cap, 0, -edge_cost});\n    return id;\n  }\n\n  void expath(int st) {\n    fill(d.begin(), d.end(), INF_C);\n    q.clear();\n    fill(its.begin(), its.end(), q.end());\n    its[st] = q.push({pot[st], st});\n    d[st] = 0;\n    while (!q.empty()) {\n      int i = q.top().second;\n      q.pop();\n      its[i] = q.end();\n      for (int id : g[i]) {\n        const edge &e = edges[id];\n        int j = e.to;\n        if (e.c - e.f > eps && d[i] + e.cost < d[j]) {\n          d[j] = d[i] + e.cost;\n          pe[j] = id;\n          if (its[j] == q.end()) {\n            its[j] = q.push({pot[j] - d[j], j});\n          } else {\n            q.modify(its[j], {pot[j] - d[j], j});\n          }\n        }\n      }\n    }\n    swap(d, pot);\n  }\n   \n  pair<T, C> max_flow_min_cost(int st, int fin) {\n    T flow = 0;\n    C cost = 0;\n    bool ok = true;\n    for (auto& e : edges) {\n      if (e.c - e.f > eps && e.cost + pot[e.from] - pot[e.to] < 0) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) {\n      expath(st);\n    } else {\n      vector<int> deg(n, 0);\n      for (int i = 0; i < n; i++) {\n        for (int eid : g[i]) {\n          auto& e = edges[eid];\n          if (e.c - e.f > eps) {\n            deg[e.to] += 1;\n          }\n        }\n      }\n      vector<int> que;\n      for (int i = 0; i < n; i++) {\n        if (deg[i] == 0) {\n          que.push_back(i);\n        }\n      }\n      for (int b = 0; b < (int) que.size(); b++) {\n        for (int eid : g[que[b]]) {\n          auto& e = edges[eid];\n          if (e.c - e.f > eps) {\n            deg[e.to] -= 1;\n            if (deg[e.to] == 0) {\n              que.push_back(e.to);\n            }\n          }\n        }\n      }\n      fill(pot.begin(), pot.end(), INF_C);\n      pot[st] = 0;\n      if (static_cast<int>(que.size()) == n) {\n        for (int v : que) {\n          if (pot[v] < INF_C) {\n            for (int eid : g[v]) {\n              auto& e = edges[eid];\n              if (e.c - e.f > eps) {\n                if (pot[v] + e.cost < pot[e.to]) {\n                  pot[e.to] = pot[v] + e.cost;\n                  pe[e.to] = eid;\n                }\n              }\n            }\n          }\n        }\n      } else {\n        que.assign(1, st);\n        vector<bool> in_queue(n, false);\n        in_queue[st] = true;\n        for (int b = 0; b < (int) que.size(); b++) {\n          int i = que[b];\n          in_queue[i] = false;\n          for (int id : g[i]) {\n            const edge &e = edges[id];\n            if (e.c - e.f > eps && pot[i] + e.cost < pot[e.to]) {\n              pot[e.to] = pot[i] + e.cost;\n              pe[e.to] = id;\n              if (!in_queue[e.to]) {\n                que.push_back(e.to);\n                in_queue[e.to] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    while (pot[fin] < INF_C) {\n      T push = numeric_limits<T>::max();\n      int v = fin;\n      while (v != st) {\n        const edge &e = edges[pe[v]];\n        push = min(push, e.c - e.f);\n        v = e.from;\n      }\n      v = fin;\n      while (v != st) {\n        edge &e = edges[pe[v]];\n        e.f += push;\n        edge &back = edges[pe[v] ^ 1];\n        back.f -= push;\n        v = e.from;\n      }\n      flow += push;\n      cost += push * pot[fin];\n      expath(st);\n    }\n    return {flow, cost};\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  MCMF<int, int> g(n + m + 2);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) {\n      int x;\n      cin >> x;\n      ans += x;\n      g.add(i, n + j, 1, 0, x == 1 ? -1 : 1);\n    }\n  }\n  vector<int> a(n);\n  vector<int> ea(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n    ea[i] = g.add(n + m, i, a[i], 0, 0);\n  }\n  vector<int> b(m);\n  vector<int> eb(m);\n  for (int i = 0; i < m; i++) {\n    cin >> b[i];\n    eb[i] = g.add(n + i, n + m + 1, b[i], 0, 0);\n  }\n  auto res = g.max_flow_min_cost(n + m, n + m + 1);\n  for (int i = 0; i < n; i++) {\n    if (g.edges[ea[i]].f != a[i]) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    if (g.edges[eb[i]].f != b[i]) {\n      cout << -1 << '\\n';\n      return 0;\n    }\n  }\n  ans += res.second;\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["flows", "graphs"], "dificulty": "2400", "interactive": false}