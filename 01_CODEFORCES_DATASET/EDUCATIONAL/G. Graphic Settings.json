{"link": "https://codeforces.com//contest/863/problem/G", "problemId": "123497", "problem_idx": "G", "shortId": "863G", "contest_number": "863", "problem_submissions": {"F": [30585747, 30587406, 30587581, 30586987, 30589318, 30588386, 30614835, 30589226, 30587748, 30588069, 30589138, 30588637, 30589602, 30588953, 30587113, 30590006, 30591128, 30589525, 30591328], "E": [30584826, 30584892, 30586722, 30586370, 30585856, 30586447, 30586390, 30586258, 30587809, 30586316, 30587721, 30587855, 30587775, 30588242, 30587782, 30587403, 30589806], "D": [30584161, 30582889, 30583896, 30584983, 30584514, 30599512, 30585431, 30584907, 30584911, 30586408, 30585496, 30586610, 30586374, 30584958, 30587183, 30584596, 30585231, 30587520], "C": [30583486, 30584324, 30585366, 30584169, 30583738, 30584504, 30584405, 30584037, 30585386, 30584778, 30585657, 30585045, 30584141, 30586261, 30586674, 30591722, 30586154], "B": [30581979, 30583463, 30582674, 30582188, 30582199, 30582158, 30582064, 30582238, 30582609, 30582456, 30582868, 30582784, 30582689, 30582852, 30583217, 30606326, 30582212, 30582335], "A": [30581619, 30581704, 30581695, 30581653, 30581650, 30786677, 30581665, 30581657, 30581629, 30581763, 30581628, 30581791, 30581663, 30581713, 30581800, 30581819, 30581630, 30581694], "G": [57430904, 30596090]}, "name": "G. Graphic Settings", "statement": "Recently Ivan bought a new computer. Excited, he unpacked it and\r\ninstalled his favourite game. With his old computer Ivan had to choose\r\nthe worst possible graphic settings (because otherwise the framerate\r\nwould be really low), but now he wants to check, maybe his new computer\r\ncan perform well even with the best possible graphics?There are graphics\r\nparameters in the game. -th parameter can be set to any positive integer\r\nfrom to , and initially is set to (). So there are different\r\ncombinations of parameters. Ivan can increase or decrease any of these\r\nparameters by ; after that the game will be restarted with new\r\nparameters (and Ivan will have the opportunity to check chosen\r\ncombination of parameters).Ivan wants to try all possible combinations.\r\nAlso he wants to return to the initial settings after trying all\r\ncombinations, because he thinks that initial settings can be somehow\r\nbest suited for his hardware. But Ivan doesn\u2019t really want to make a lot\r\nof restarts.So he wants you to tell the following: If there exists a way\r\nto make exactly changes (each change either decreases or increases some\r\nparameter by ) to try all possible combinations and return to initial\r\ncombination, then Ivan wants to know this way. Otherwise, if there\r\nexists a way to make exactly changes to try all possible combinations\r\n(including the initial one), then Ivan wants to know this way. Help Ivan\r\nby showing him the way to change parameters!\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n    friend bool operator<(const modular& a, const modular& b) { return a.val < b.val; }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint m,p=1;\nvi a, b;\nvector<vector<vi>> rect;\nvector<vi> res;\n\nint dist(vi a, vi b) {\n\tint ret = 0;\n\tF0R(i,sz(a)) ret += abs(a[i]-b[i]);\n\treturn ret;\n}\n\nvoid gen(vi a, vi b) {\n\tassert(dist(a,b) == 1);\n\tF0R(i,sz(a)) if (a[i] != b[i]) {\n\t\tif (a[i] < b[i]) ps(\"inc \"+to_string(i+1));\n\t\telse ps(\"dec \"+to_string(i+1));\n\t}\n}\n\nvoid fin() {\n\tif (!sz(res)) {\n\t\tps(\"No\");\n\t\texit(0);\n\t}\n\t// ps(\"HUH\",sz(res)); exit(0);\n\t// ps(\"HUH\",res,sz(res),p); exit(0);\n\tassert(sz(res) == p);\n\tif (dist(res[0],res.back()) == 1) {\n\t\tps(\"Cycle\");\n\t} else {\n\t\tps(\"Path\");\n\t}\n\tF0R(i,sz(res)-1) gen(res[i],res[i+1]);\n\tif (dist(res[0],res.back()) == 1) gen(res.back(),res[0]);\n\texit(0);\n}\n\nint sum(vi v) {\n\tint res = 0;\n\ttrav(t,v) res += t;\n\treturn res;\n}\n\nvector<vector<vi>> nex(vector<vector<vi>> a, int x) {\n\tvector<vector<vi>> A;\n\tF0Rd(i,sz(a)) A.pb(a[i]);\n\ttrav(i0,A) trav(i1,i0) i1[x] ++;\n\treturn A;\n}\n\nvpi cyc(int a, int b) {\n\tif (a%2 == 1) {\n\t\tauto z = cyc(b,a);\n\t\ttrav(t,z) swap(t.f,t.s);\n\t\treturn z;\n\t}\n\tvpi res;\n\tF0R(i,a) res.pb({i,0});\n\tF0Rd(i,a) {\n\t\tif (i&1) {\n\t\t\tFOR(j,1,b) res.pb({i,j});\n\t\t} else {\n\t\t\tFORd(j,1,b) res.pb({i,j});\n\t\t}\n\t}\n\treturn res;\n}\n\nvpi getPath(int x, int y) {\n\tif (x%2==1) {\n\t\tvpi res;\n\t\tFORd(i,1,x+1) {\n\t\t\tif ((x-i)%2 == 0) {\n\t\t\t\tF0Rd(j,y+1) res.pb({i,j});\n\t\t\t} else {\n\t\t\t\tF0R(j,y+1) res.pb({i,j});\n\t\t\t}\n\t\t}\n\t\tF0R(j,sz(rect[0])) res.pb({0,j});\n\t\tFORd(j,y+1,sz(rect[0])) {\n\t\t\tif ((sz(rect[0])-1-j)%2 == 0) {\n\t\t\t\tFOR(i,1,sz(rect)) res.pb({i,j});\n\t\t\t} else {\n\t\t\t\tFORd(i,1,sz(rect)) res.pb({i,j});\n\t\t\t}\n\t\t}\n\t\tFORd(i,x+1,sz(rect)) {\n\t\t\tif (i%2 == 0) {\n\t\t\t\tF0Rd(j,y+1) res.pb({i,j});\n\t\t\t} else {\n\t\t\t\tF0R(j,y+1) res.pb({i,j});\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t} else {\n\t\tif (x == 0) {\n\t\t\tauto v = getPath(sz(rect)-1-x,y);\n\t\t\ttrav(t,v) t.f = sz(rect)-1-t.f;\n\t\t\treturn v;\n\t\t}\n\t\tif (y == sz(rect[0])-1) {\n\t\t\tauto v = getPath(x,sz(rect[0])-1-y);\n\t\t\ttrav(t,v) t.s = sz(rect[0])-1-t.s;\n\t\t\treturn v;\n\t\t}\n\t\tvpi res;\n\t\tF0Rd(j,y+1) res.pb({x,j});\n\t\tF0Rd(i,x) res.pb({i,0});\n\t\tFOR(j,1,y+1) {\n\t\t\tif (j&1) {\n\t\t\t\tF0R(i,x) res.pb({i,j});\n\t\t\t} else {\n\t\t\t\tF0Rd(i,x) res.pb({i,j});\n\t\t\t}\n\t\t}\n\t\tFOR(j,y+1,sz(rect[0])) res.pb({0,j});\n\t\tFOR(i,1,x+1) {\n\t\t\tif (i%2 == 0) {\n\t\t\t\tFOR(j,y+1,sz(rect[0])) res.pb({i,j});\n\t\t\t} else {\n\t\t\t\tFORd(j,y+1,sz(rect[0])) res.pb({i,j});\n\t\t\t}\n\t\t}\n\t\t// ps(\"HA\",res); exit(0);\n\t\tif (x != sz(rect)-1) {\n\t\t\tF0Rd(j,sz(rect[0])) res.pb({x+1,j});\n\t\t\tF0R(j,sz(rect[0])) {\n\t\t\t\tif (j%2 == 0) {\n\t\t\t\t\tFOR(i,x+2,sz(rect)) res.pb({i,j});\n\t\t\t\t} else {\n\t\t\t\t\tFORd(i,x+2,sz(rect)) res.pb({i,j});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nvoid check(int a, int b, vpi v) {\n\tif (v[0] != mp(a,b)) {\n\t\tps(a,b,sz(rect),sz(rect[0])); ps(v); \n\t\texit(0);\n\t}\n\tset<pi> S;\n\ttrav(t,v) {\n\t\tif (t.f < 0 || t.f >= sz(rect) || t.s < 0 || t.s >= sz(rect[0]) || S.count(t)) {\n\t\tps(a,b,sz(rect),sz(rect[0])); ps(v); \n\t\t\texit(0);\n\t\t}\n\t\tS.insert(t);\n\t}\n\tif (sz(S) != sz(rect)*sz(rect[0])) {\n\t\tps(a,b,sz(rect),sz(rect[0])); ps(v);\n\t\texit(0);\n\t}\n\tF0R(i,sz(v)-1) if (abs(v[i].f-v[i+1].f)+abs(v[i].s-v[i+1].s) != 1) {\n\t\tps(a,b,sz(rect),sz(rect[0])); ps(v);\n\t\texit(0);\n\t}\n}\n\nint main() {\n\t/*for (int i = 3; i <= 9; i += 2) for (int j = 3; j <= 9; j += 2) {\n\t\trect.rsz(i); rect[0].rsz(j);\n\t\t// check(2,0,getPath(2,0));\n\t\tF0R(I,i) F0R(J,j) if ((I+J)%2 == 0) check(I,J,getPath(I,J));\n\t}\n\texit(0);*/\n    setIO(); re(m); \n    a.rsz(m), b.rsz(m); re(a,b);\n    trav(t,a) p *= t;\n    if (p&1) if (sum(b)%2 != sum(a)%2) fin();\n    if (m == 1) {\n    \tif (b[0] == 1) { \n    \t\tF0R(i,a[0]) {\n    \t\t\tres.pb(b);\n    \t\t\tb[0] ++;\n    \t\t}\n    \t} else if (b[0] == a[0]) {\n    \t\tF0R(i,a[0]) {\n    \t\t\tres.pb(b);\n    \t\t\tb[0] --;\n    \t\t}\n    \t} \n    \tfin();\n    }\n    rect.rsz(a[0]);\n    F0R(i,a[0]) {\n    \trect[i].rsz(a[1]);\n    \tF0R(j,a[1]) {\n    \t\trect[i][j] = {i+1,j+1};\n    \t\twhile (sz(rect[i][j]) < m) rect[i][j].pb(1);\n    \t}\n    }\n    FOR(i,2,m) {\n    \tvector<vector<vi>> tmp[a[i]];\n    \ttmp[0] = rect;\n    \tFOR(j,1,a[i]) tmp[j] = nex(tmp[j-1],i);\n    \trect.clear();\n    \tF0R(j,a[i]) trav(t,tmp[j]) rect.pb(t);\n    }\n    // trav(t,rect) ps(t);\n    // ps(\"HUH\",rect);\n    if (p%2 == 0) { // gen cycle\n    \tvpi v = cyc(sz(rect),sz(rect[0]));\n    \t// ps(\"HUH\",v); exit(0);\n    \ttrav(t,v) res.pb(rect[t.f][t.s]);\n    \trotate(res.begin(),find(all(res),b),res.end());\n    \tfin();\n    } \n    pi ind = {-1,-1};\n    F0R(i,sz(rect)) F0R(j,sz(rect[0])) if (rect[i][j] == b) ind = {i,j};\n    assert(ind != mp(-1,-1) && (ind.f+ind.s)%2 == 0);\n    vpi v = getPath(ind.f,ind.s);\n    trav(t,v) res.pb(rect[t.f][t.s]);\n    fin();\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"], "input": "", "output": "", "tags": [], "dificulty": "3200", "interactive": false}