{
    "link": "https://codeforces.com//contest/652/problem/F",
    "problemId": "52873",
    "problem_idx": "F",
    "shortId": "652F",
    "contest_number": "652",
    "problem_submissions": {
        "F": [
            16928285,
            16930373,
            16931256,
            16970841,
            16961705,
            16935106,
            156953099,
            16939325,
            17157478,
            16976822,
            16929598
        ],
        "E": [
            16926440,
            16927126,
            16928485,
            16928041,
            16928079,
            16927963,
            16929010,
            16928885,
            16928945,
            16929000,
            16929278,
            16926493,
            16928821,
            16929439,
            16928127,
            16930840,
            16929731,
            16930544,
            16929622
        ],
        "D": [
            16923853,
            16925192,
            16926960,
            16924196,
            16924625,
            16925554,
            16925730,
            16924207,
            16926093,
            16926313,
            16925298,
            16926004,
            16926568,
            16924529,
            16926045,
            16925170,
            16925998,
            16927190,
            16926470
        ],
        "C": [
            16923132,
            16923717,
            16926036,
            16923304,
            16924095,
            16924304,
            16924230,
            16925378,
            16924383,
            16924805,
            16924428,
            16924018,
            16924971,
            16925484,
            16923795,
            16923653,
            16924997,
            16925262,
            16925278
        ],
        "B": [
            16922478,
            16922741,
            16925620,
            16922710,
            16922792,
            16922869,
            16923264,
            16922610,
            16922818,
            16923450,
            16923095,
            16923418,
            16923515,
            16923547,
            16922822,
            16922672,
            16922783,
            16923327,
            16924223
        ],
        "A": [
            16922372,
            16922446,
            16922797,
            16922454,
            16922532,
            16922643,
            16922693,
            16922430,
            16922460,
            16923027,
            16922810,
            16922924,
            16922740,
            16923101,
            16922457,
            16922433,
            16923996,
            16922614,
            16923536
        ]
    },
    "name": "F. Ants on a Circle",
    "statement": "ants are on a circle of length . An ant travels one unit of distance per\r\none unit of time. Initially, the ant number is located at the position\r\nand is facing in the direction (which is either or ). Positions are\r\nnumbered in counterclockwise order starting from some point. Positions\r\nof the all ants are distinct.All the ants move simultaneously, and\r\nwhenever two ants touch, they will both switch their directions. Note\r\nthat it is possible for an ant to move in some direction for a half of a\r\nunit of time and in opposite direction for another half of a unit of\r\ntime.Print the positions of the ants after time units.\r\n",
    "solutions": [
        "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nvector<pair<in,in> > antp;\nVI endv;\nin m;\nin nr(in a){\n  a%=m;\n  if(a<0)\n    a+=m;\n  return a;\n}\nVI res;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  in n,t;\n  cin>>n>>m>>t;\n  antp.resize(n);\n  char d;\n  res.resize(n);\n  in totm=0;\n  forn(i,n){\n    cin>>antp[i].first;\n    antp[i].second=i;\n    cin>>d;\n    if(d=='L'){\n      totm-=t;\n      totm%=n*m;\n      endv.PB(nr(antp[i].first-t));\n    }\n    else{\n      totm+=t;\n      totm%=n*m;\n      endv.PB(nr(antp[i].first+t));\n    }\n  }\n  totm%=n*m;\n  if(totm<0)\n    totm+=n*m;\n  sort(all(antp));\n  sort(all(endv));\n  forn(i,n)\n    totm+=antp[i].first;\n  forn(i,n)\n    totm-=endv[i];\n  totm%=n*m;\n  if(totm<0)\n    totm+=n*m;\n  assert(totm%m==0);\n  in cc=totm/m;\n  forv(i,antp)\n    res[antp[i].second]=endv[(i+cc)%n];\n  forv(i,res)\n    cout<<(res[i]==0?m:res[i])<<\" \";\n  cout<<endl;\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Ants on a Circle.json",
    "editorial_link": "https://codeforces.com//blog/entry/43986",
    "editorial": "The problem was suggested by Lewin Gan Lewin. The first observation: if\r\nall the ants are indistinguishable we can consider that there are no\r\ncollisions and all the ants are passing one through another. So we can\r\neasily determine the final positions of all the ants, but we canât say\r\nwhich ant will be in which position. The second observation: the\r\nrelative order of the ants will be the same all the time. So to solve\r\nthe problem we should only find the position of one ant after seconds.\r\nLetâs solve that problem in the following way: Consider the positions of\r\nall the ants after time units. Easy to see that by the first observation\r\nall the positions of the ants will left the same, but the order will be\r\ndifferent (we will have some cyclic shift of the ants). If we find that\r\ncyclic shift we can apply it times. After that we will have only time\r\nunits. So the problem now is to model the process for the one ant with\r\nand time units. Note that in that time interval the fixed ant will have\r\nno more than two collisions with each other ant. So if we model the\r\nprocess with ignoring all collisions except the ones that include the\r\nfixed ant, we will have no more than collisions. Letâs model that\r\nprocess with two queues for the ants going to the left and to the right.\r\nEach time we should take the first ant in the queue with opposite\r\ndirection, process the collision and add that ant to the end of the\r\nother queue. Hint: you will have a problem when the fixed ant can be in\r\ntwo different positions at the end, but itâs easy to fix with doing the\r\nsame with the next ant. C++ solutionconst int N = 300300;int n, m; li t;\r\npair<pair<int, char>, int> a[N];bool read() { if (!(cin >> n >> m >> t))\r\nreturn false; forn(i, n) { assert(scanf(\"\r\n",
    "hint": []
}