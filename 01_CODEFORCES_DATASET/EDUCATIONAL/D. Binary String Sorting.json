{
    "link": "https://codeforces.com//contest/1809/problem/D",
    "problemId": "1839364",
    "problem_idx": "D",
    "shortId": "1809D",
    "contest_number": "1809",
    "problem_submissions": {
        "G": [
            198800857,
            198819538,
            198819377,
            198819202,
            198818781,
            198818684,
            198816759,
            198811816,
            198806762,
            198815231,
            198818773,
            198822181,
            198828608,
            198822299,
            203672607,
            208381746,
            198835108,
            198831844,
            198829525,
            198853349,
            198853245
        ],
        "F": [
            198786104,
            198791363,
            198796885,
            198804709,
            198810152,
            198814173,
            198809216,
            198791415,
            198800965,
            198804541,
            198830839,
            198809769,
            198804908,
            198811366,
            198815172,
            198805151,
            198812101,
            198817151,
            198808903,
            198814662
        ],
        "E": [
            198775336,
            198782430,
            198786246,
            199182668,
            198794243,
            198792695,
            198792300,
            198799038,
            198776769,
            198784470,
            198788708,
            198793376,
            198789791,
            198792668,
            198843793,
            198805320,
            198800053,
            198802037,
            198804412,
            198800677,
            198799758
        ],
        "D": [
            198768775,
            198772012,
            198776224,
            198777641,
            198882283,
            198777443,
            198779801,
            198782367,
            198766389,
            198769656,
            198777387,
            198777057,
            198779683,
            198776616,
            198772288,
            198785016,
            198783361,
            198781028,
            198791791,
            198778758
        ],
        "C": [
            198764545,
            198765840,
            198768929,
            198772658,
            198770321,
            198766724,
            198776128,
            198761542,
            198765111,
            198760078,
            198766275,
            198773341,
            198769090,
            198764454,
            198770468,
            198769676,
            198767761,
            198771860,
            198780776
        ],
        "B": [
            198760964,
            198755413,
            198762260,
            198758056,
            198766256,
            198759317,
            198761525,
            198757070,
            198756430,
            198755376,
            198758155,
            198765573,
            198760583,
            198758103,
            198766309,
            198762187,
            198761139,
            198766037,
            198760442
        ],
        "A": [
            198757842,
            198756487,
            198756930,
            198755206,
            198755963,
            198755170,
            198755335,
            198755127,
            198755119,
            198756462,
            198755191,
            198755804,
            198757456,
            198755555,
            198757141,
            198756133,
            198756023,
            198760810,
            198755407
        ]
    },
    "name": "D. Binary String Sorting",
    "statement": "You are given a binary string s consisting of only characters and/or\r\n.You can perform several operations on this string (possibly zero).\r\nThere are two types of operations: choose two consecutive elements and\r\nswap them. In order to perform this operation, you pay 10^{12} coins;\r\nchoose any element from the string and remove it. In order to perform\r\nthis operation, you pay 10^{12}+1 coins. Your task is to calculate the\r\nminimum number of coins required to sort the string s in non-decreasing\r\norder (i. e. transform s so that s_1\r\nle s_2\r\nle\r\ndots\r\nle s_m, where m is the length of the string after applying all\r\noperations). An empty string is also considered sorted in non-decreasing\r\norder.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 X = 1E12;\nconstexpr i64 inf = 1E18;\n\nvoid update(i64 &a, i64 b) {\n    if (a > b) {\n        a = b;\n    }\n}\n\nvoid solve() {\n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    \n    std::vector dp(n + 1, std::array<i64, 2>{inf, inf});\n    dp[0][0] = 0;\n    for (int i = 0; i < n; i++) {\n        for (int x = 0; x < 2; x++) {\n            if (s[i] - '0' >= x) {\n                update(dp[i + 1][s[i] - '0'], dp[i][x]);\n            }\n            update(dp[i + 1][x], dp[i][x] + X + 1);\n            if (i + 1 < n && x <= s[i + 1] - '0' && s[i + 1] <= s[i]) {\n                update(dp[i + 2][s[i] - '0'], dp[i][x] + X);\n            }\n        }\n    }\n    std::cout << std::min(dp[n][0], dp[n][1]) << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Binary String Sorting.json",
    "editorial_link": "https://codeforces.com//blog/entry/114300",
    "editorial": "Note that the price of operations is much greater than the difference\r\nbetween them. Therefore, first of all, we have to minimize the number of\r\noperations, and then maximize the number of operations of the first\r\ntype.Swapping two elements if at least one of them will be deleted later\r\nis not optimal. Therefore, first let\u00e2\u0080\u0099s delete some elements of the\r\nstring, and then sort the remaining elements using swaps. The number of\r\nswaps for sorting is equal to the number of inversions (i. e. the number\r\nof pairs such that and ). From here we can notice that if the number of\r\ninversions is greater than , then there is an element that produces at\r\nleast inversions. So it is more profitable for us to remove it, to\r\nminimize the number of operations.From the above we get that the number\r\nof operations of the first type is at most . If all operations are only\r\nof the second type, then we need to find a subsequence of the maximum\r\nlength of the form . To do this, we can iterate over the number of zeros\r\nthat we include in the final string, and then add the number of ones\r\nfrom the remaining suffix of the string (that goes after the fixed\r\nnumber of zeros). If there is an operation of the first type, then it is\r\nenough to iterate over the pair that creates the inversion, to the left\r\nof it take all zeros, and to the right of it take all ones (you can\r\nnotice that in fact it is enough to iterate over only a pair of\r\nneighboring elements of the string).\r\n"
}