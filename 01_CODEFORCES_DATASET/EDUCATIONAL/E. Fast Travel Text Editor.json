{"link": "https://codeforces.com//contest/1860/problem/E", "problemId": "2169701", "problem_idx": "E", "shortId": "1860E", "contest_number": "1860", "problem_submissions": {"F": [219298549, 219320447, 219349019, 219323121, 219334429, 219337442, 219335056, 219339341, 219339231, 219349246, 219345811, 219439688, 219439045, 219356857, 219353864, 219402976, 219353456, 219351823], "E": [219277150, 219281408, 219287269, 219300383, 219293770, 219301781, 219289069, 219306188, 219288291, 219288789, 219301050, 219298191, 219305638, 219306388, 219300992, 219313680, 219301529, 219309490, 219305863, 219309540, 219307800], "D": [219271388, 219273923, 219270716, 219286342, 219405254, 219345669, 219344552, 219277413, 219284438, 219280247, 219290826, 219278202, 219277998, 219274616, 219275328, 219282484, 219281832, 219279471, 219288325, 219282155, 219284217, 219287012, 219287888], "C": [219264168, 219264568, 219266116, 219265339, 219269044, 219276912, 219269876, 219279690, 219266598, 219268637, 219263040, 219261658, 219264629, 219267625, 219267964, 219267177, 219271968, 219274243, 219264405, 219273316], "B": [219260635, 219258799, 219260447, 219259349, 219260950, 219267717, 219262012, 219271581, 219260726, 219261008, 219259442, 219257734, 219259759, 219262401, 219260169, 219259084, 219263649, 219264522, 219272480, 219264690], "A": [219257237, 219257029, 219257674, 219257720, 219257171, 219258923, 219257078, 219260398, 219257258, 219257446, 219257236, 219256961, 219257126, 219257819, 219257229, 219257120, 219257449, 219257142, 219257016, 219258968]}, "name": "E. Fast Travel Text Editor", "statement": "You are given a string s, consisting of lowercase Latin letters.There\u2019s\r\na cursor, initially placed between two adjacent letters of the string.\r\nThe cursor can\u2019t be placed before the first or after the last letter.In\r\none move, you can perform one of three actions: move a cursor one\r\nposition to the left (if that doesn\u2019t place it before the first letter);\r\nmove a cursor one position to the right (if that doesn\u2019t place it after\r\nthe last letter); let x be the letter immediately to the left of the\r\ncursor, and y be the letter immediately to the right of the cursor.\r\nChoose any pair of letters in the string such that the of them is x and\r\nthe of them is y, and move the cursor to the position between these two\r\nletters. You are asked m queries. In each query, you are given two\r\nintegers f and t, which correspond to two valid positions of the cursor\r\nin the string. In response to the query, you have to calculate the\r\nminimum number of operations required to move the cursor from position f\r\nto position t.\r\n", "solutions": ["#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    \n    std::vector<int> p[26][26];\n    for (int i = 0; i < n - 1; i++) {\n        p[s[i] - 'a'][s[i + 1] - 'a'].push_back(i);\n    }\n    \n    std::vector dis(26, std::vector(26, std::vector(n - 1, -1)));\n    for (int a = 0; a < 26; a++) {\n        for (int b = 0; b < 26; b++) {\n            if (!p[a][b].empty()) {\n                std::queue<int> q;\n                bool vis[26][26] {};\n                vis[a][b] = true;\n                for (auto i : p[a][b]) {\n                    dis[a][b][i] = 0;\n                    q.push(i);\n                }\n                \n                while (!q.empty()) {\n                    int x = q.front();\n                    q.pop();\n                    \n                    if (x > 0 && dis[a][b][x - 1] == -1) {\n                        dis[a][b][x - 1] = dis[a][b][x] + 1;\n                        q.push(x - 1);\n                    }\n                    if (x < n - 2 && dis[a][b][x + 1] == -1) {\n                        dis[a][b][x + 1] = dis[a][b][x] + 1;\n                        q.push(x + 1);\n                    }\n                    \n                    int l = s[x] - 'a', r = s[x + 1] - 'a';\n                    if (!vis[l][r]) {\n                        vis[l][r] = true;\n                        for (auto i : p[l][r]) {\n                            if (dis[a][b][i] == -1) {\n                                dis[a][b][i] = dis[a][b][x] + 1;\n                                q.push(i);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    int m;\n    std::cin >> m;\n    \n    for (int i = 0; i < m; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        x--, y--;\n        \n        int ans = std::abs(x - y);\n        for (int a = 0; a < 26; a++) {\n            for (int b = 0; b < 26; b++) {\n                if (!p[a][b].empty()) {\n                    ans = std::min(ans, dis[a][b][x] + dis[a][b][y] + 1);\n                }\n            }\n        }\n        std::cout << ans << \"\\n\";\n    }\n    \n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "graphs", "shortest paths"], "dificulty": "2400", "interactive": false}