{
    "link": "https://codeforces.com//contest/1373/problem/G",
    "problemId": "657376",
    "problem_idx": "G",
    "shortId": "1373G",
    "contest_number": "1373",
    "problem_submissions": {
        "F": [
            85069466,
            85013919,
            85003216,
            85004527,
            85017380,
            85006414,
            85013443,
            85009359,
            85034855,
            85024344,
            85027318,
            85021209,
            85169119,
            85034898,
            85023023,
            85025050,
            85021057,
            85011972,
            85013310,
            85009397,
            85086450,
            85048971,
            85105442,
            85026023,
            85034574
        ],
        "G": [
            85018688,
            85013794,
            85023274,
            85029274,
            85027188,
            85026875,
            85025205,
            85031642,
            85033493,
            85060324,
            85029140,
            85035646,
            85035445,
            85030303,
            85169123,
            85031978,
            85034028,
            85038006,
            85044469,
            85037568,
            85029439,
            85040658,
            85105410,
            85055846,
            85052926,
            85051925,
            85051272,
            85044699
        ],
        "E": [
            84999770,
            85000250,
            85000769,
            85016220,
            85003055,
            85022007,
            85003196,
            85014929,
            85009060,
            85051465,
            85015459,
            85015122,
            85013600,
            85169037,
            85015655,
            85012581,
            85027850,
            85004717,
            85029830,
            85050882,
            85062787,
            85017522,
            85010450,
            85023419
        ],
        "D": [
            84989194,
            84988897,
            84987666,
            84989409,
            84993779,
            84995810,
            84995168,
            84988737,
            84989555,
            84996435,
            84994778,
            85169112,
            84993838,
            84996979,
            84999087,
            84988720,
            84993282,
            84997221,
            84991423,
            84994984,
            85005381
        ],
        "C": [
            84985114,
            84983803,
            84984904,
            84985027,
            84987964,
            84987787,
            84988785,
            84985367,
            84985891,
            84989713,
            84990559,
            85169107,
            84990269,
            84988468,
            84994211,
            84985714,
            84988231,
            84989967,
            84987837,
            84989263,
            84994345
        ],
        "B": [
            84983530,
            84983359,
            84983895,
            84983713,
            84984272,
            84984923,
            84984729,
            84983954,
            84983931,
            84986620,
            85051946,
            84984732,
            85169102,
            84984725,
            84984153,
            84984773,
            84984191,
            84984894,
            84984839,
            84984490,
            84985320,
            84987225
        ],
        "A": [
            84983369,
            84984629,
            84983633,
            84983428,
            84983600,
            84983500,
            84983426,
            84983406,
            84983552,
            84983668,
            84986837,
            85168973,
            84983414,
            84983504,
            84983712,
            85163611,
            84983517,
            84983932,
            84983627,
            84984784,
            84983882,
            84985111
        ]
    },
    "name": "G. Pawns",
    "statement": "You are given a chessboard consisting of n rows and n columns. Rows are\r\nnumbered from bottom to top from 1 to n. Columns are numbered from left\r\nto right from 1 to n. The cell at the intersection of the x-th column\r\nand the y-th row is denoted as (x, y). Furthermore, the k-th column is a\r\nspecial column. Initially, the board is empty. There are m changes to\r\nthe board. During the i-th change one pawn is added or removed from the\r\nboard. The current board is good if we can move all pawns to the special\r\ncolumn by the followings rules: Pawn in the cell (x, y) can be moved to\r\nthe cell (x, y + 1), (x - 1, y + 1) or (x + 1, y + 1); You can make as\r\nmany such moves as you like; Pawns can not be moved outside the\r\nchessboard; Each cell can not contain more than one pawn. The current\r\nboard may not always be good. To fix it, you can add new rows to the\r\nboard. New rows are added at the top, i. e. they will have numbers n+1,\r\nn+2, n+3,\r\ndots.After each of m changes, print one integer the minimum number of\r\nrows which you have to add to make the board good.\r\n",
    "solutions": [
        "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n\nconst ll identity = 0;\nconst ll SZ = 131072*4;\n\nll sum[2*SZ], lazy[2*SZ];\n\nll combine(ll A, ll B) {\n    return max(A, B);\n}\n\nll combineUpd(ll A, ll B) {\n    return A+B;\n}\n\nvoid push(int index, ll L, ll R) {\n    sum[index] = combineUpd(sum[index], lazy[index]);\n    if (L != R) lazy[2*index] = combineUpd(lazy[2*index], lazy[index]), lazy[2*index+1] = combineUpd(lazy[2*index+1], lazy[index]);\n    lazy[index] = identity;\n}\n\nvoid pull(int index) {\n    sum[index] = combine(sum[2*index], sum[2*index+1]);\n}\n\nll query(int lo, int hi, int index = 1, ll L = 0, ll R = SZ-1) {\n    push(index, L, R);\n    if (lo > R || L > hi) return 0;\n    if (lo <= L && R <= hi) return sum[index];\n\n    int M = (L+R) / 2;\n    return combine(query(lo, hi, 2*index, L, M), query(lo, hi, 2*index+1, M+1, R));\n}\n\nvoid update(int lo, int hi, ll increase, int index = 1, ll L = 0, ll R = SZ-1) {\n    push(index, L, R);\n    if (hi < L || R < lo) return;\n    if (lo <= L && R <= hi) {\n        lazy[index] = increase;\n        push(index, L, R);\n        return;\n    }\n\n    int M = (L+R) / 2;\n    update(lo, hi, increase, 2*index, L, M); update(lo, hi, increase, 2*index+1, M+1, R);\n    pull(index);\n}\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int N, K, M; cin >> N >> K >> M;\n\n    F0R(i, 2*SZ) sum[i] = 0, lazy[i] = 0;\n\n    F0R(i, 2*SZ) {\n        update(i, i, i);\n    }\n\n    set<pi> S;\n    priority_queue<pair<int, pi> > q;\n    F0R(i, M) {\n        int A, B; cin >> A >> B;\n        int cur = B + abs(K - A);\n\n        if (S.count({A, B})) {\n            S.erase({A, B});\n            update(0, cur, -1);\n        } else {\n            S.ins({A, B});\n            update(0, cur, 1);\n            q.push({cur, {A, B}});\n        }\n\n        while (!q.empty() && !S.count(q.top().s)) {\n            q.pop();\n        }\n        if (q.empty()) {\n            cout << 0 << nl;\n        } else {\n            cout << max(query(0, q.top().f) - N-1, 0ll) << nl;\n        }\n    }\n\t\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "greedy"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Pawns.json",
    "editorial_link": "https://codeforces.com//blog/entry/79376",
    "editorial": "For each pawn with initial position there exists a minimum index of row\r\nsuch that the pawn can reach the cell , but cannot reach the cell . It\u00e2\u0080\u0099s\r\neasy to see that . In the resulting configuration, this pawn can occupy\r\nthe cell , , or any other cell having .Suppose the board consists of\r\nrows. For each row, the number of rows above it should be not less than\r\nthe number of pawns that occupy the cells above it (that is, having\r\ngreater than the index of that row) because, if this condition is not\r\nfulfilled, we can\u00e2\u0080\u0099t assign each pawn a unique cell. If we denote the\r\nnumber of pawns that should go strictly above the -th row as , then for\r\nevery row, the condition must be met.To prove that this condition is\r\nsufficient, we may, for example, use Hall\u00e2\u0080\u0099s theorem. Okay, now what\r\nabout finding the minimum satisfying it? Let\u00e2\u0080\u0099s initially set to , and\r\nfor each row maintain the value of the minimum number of rows we have to\r\nadd to our board so that the condition for the row is met (we also have\r\nto maintain this value for auxiliary rows from to , since some pawns\r\ncannot fit in the initial board at all). Finding the minimum value we\r\nhave to add to equals finding the maximum of all these values on some\r\nprefix (we don\u00e2\u0080\u0099t need to look at the values on some rows with large\r\nindices, if there are no pawns after them, so we need a maximum query on\r\nthe segment , where is the maximum index among all pawns); and when a\r\npawn is added or removed, we should add or to all values on some suffix.\r\nA segment tree with lazy propagation will do the trick, solving the\r\nproblem for us in .\r\n"
}