{
    "link": "https://codeforces.com//contest/1680/problem/D",
    "problemId": "1398258",
    "problem_idx": "D",
    "shortId": "1680D",
    "contest_number": "1680",
    "problem_submissions": {
        "F": [
            157047850,
            157060684,
            157042836,
            157059615,
            157060798,
            158084238,
            157065404,
            157062967,
            157061917,
            157070522,
            157068911,
            157063520,
            157068892,
            157055321,
            157070359,
            157059828,
            157067724,
            157073079,
            157081810,
            157079385,
            157105181
        ],
        "E": [
            157041040,
            157049624,
            157047687,
            157040462,
            157036732,
            157047646,
            157052435,
            157048797,
            157052165,
            157051933,
            157052874,
            157059209,
            157046788,
            157045330,
            157056328,
            157052190,
            157048507,
            157050045,
            157051601,
            157048385
        ],
        "D": [
            157034306,
            157035182,
            157038681,
            157048294,
            158084226,
            157074494,
            157044699,
            157036339,
            157047488,
            157040348,
            157044725,
            157050170,
            157047151,
            157062708,
            157050690,
            157073571,
            157048489,
            157064425,
            157042063,
            157043656,
            157043396,
            157043910
        ],
        "C": [
            157027102,
            157026046,
            157029273,
            157029023,
            158084216,
            157023897,
            157025338,
            157028892,
            157029198,
            157031553,
            157033288,
            157030228,
            157028759,
            157029727,
            157032895,
            157036498,
            157043784,
            157026230,
            157030697,
            157031960,
            157038763
        ],
        "B": [
            157018674,
            157018124,
            157022874,
            157018932,
            157018732,
            157019545,
            157018987,
            157019892,
            157025559,
            157018220,
            157022589,
            157021909,
            157021994,
            157021310,
            157023912,
            157020972,
            157018915,
            157021224,
            157020613,
            157022918
        ],
        "A": [
            157018002,
            157017909,
            157018617,
            157017994,
            157017953,
            157018014,
            157018037,
            157018035,
            157019519,
            157017930,
            157031859,
            157018590,
            157019204,
            157018082,
            157018046,
            157018257,
            157017944,
            157018274,
            157018303,
            157018968
        ]
    },
    "name": "D. Dog Walking",
    "statement": "You are walking with your dog, and now you are at the promenade. The\r\npromenade can be represented as an infinite line. Initially, you are in\r\nthe point 0 with your dog. You decided to give some freedom to your dog,\r\nso you untied her and let her run for a while. Also, you watched what\r\nyour dog is doing, so you have some writings about how she ran. During\r\nthe i-th minute, the dog position changed from her previous position by\r\nthe value a_i (it means, that the dog ran for a_i meters during the i-th\r\nminute). If a_i is positive, the dog ran a_i meters to the right,\r\notherwise (if a_i is negative) she ran a_i meters to the left.During\r\nsome minutes, you were chatting with your friend, so you don\u2019t have\r\nwritings about your dog movement during these minutes. These values a_i\r\nequal zero.You want your dog to return to you after the end of the walk,\r\nso the destination point of the dog after n minutes 0.Now you are\r\nwondering: what is the maximum possible number of different of the line\r\nyour dog could visit on her way, if you replace every 0 with some\r\ninteger from -k to k (and your dog return to 0 after the walk)? The dog\r\nvisits an integer point if she runs through that point or reaches in it\r\nat the end of any minute. Point 0 is always visited by the dog, since\r\nshe is initially there.If the dog cannot return to the point 0 after n\r\nminutes regardless of the integers you place, print .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = int64_t;\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint n;\n\tll k;\n\tcin >> n >> k;\n\tk *= 2;\n\tvector<ll> a(n);\n\tfor(ll& x : a){\n\t\tcin >> x;\n\t\tx *= 2;\n\t}\n\tll zeros = 0;\n\tll sum = 0;\n\tfor(ll x : a){\n\t\tif(x == 0) zeros++;\n\t\tsum += x;\n\t}\n\tif(abs(sum) > k * zeros){\n\t\tcout << -1 << '\\n';\n\t\texit(0);\n\t}\n\tll plus = (-sum + k * zeros) / 2;\n\tll minus = (+sum + k * zeros) / 2;\n\tassert(plus >= 0 && minus >= 0);\n\tll best = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tvector<ll> b = a;\n\t\trotate(b.begin(), b.begin() + i, b.end());\n\t\tll plus_used = plus;\n\t\tll cur = 0;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(b[j] != 0){\n\t\t\t\tcur += b[j];\n\t\t\t\tbest = max(best, abs(cur));\n\t\t\t} else {\n\t\t\t\tll f = min(k, plus_used);\n\t\t\t\tplus_used -= f;\n\t\t\t\tcur += f - (k - f);\n\t\t\t\tbest = max(best, abs(cur));\n\t\t\t\tbest = max(best, abs(cur));\n\t\t\t}\n\t\t}\n\t}\n\tcout << (best / 2 + 1) << '\\n';\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "greedy",
        "math"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Dog Walking.json",
    "editorial_link": "https://codeforces.com//blog/entry/102852",
    "editorial": "Consider every cyclic shift of the array . Suppose that now the array\r\nstarts from the position (the first element is and the last element is\r\n). Assume that before the position our dog reached her minimum possible\r\nposition and now the minimum position will not change. So our problem is\r\nto fill all zeros in the array in such a way that the maximum prefix sum\r\nof is the maximum possible and the total sum of is zero.For simplicity,\r\nconsider the array which is the -th cyclic shift of (i. e. the first\r\nelement is , the second element is , and so on). Let\u00e2\u0080\u0099s iterate from left\r\nto right and maintain the current sum of the array . Let this variable\r\nbe . Now, when we meet , we should replace it with the maximum possible\r\nvalue we can (because in such a way we will increase the maximum number\r\nof prefix sums). Let be the number of zeros in starting from the\r\nposition . This value can be calculated in advance in for every cyclic\r\nshift using suffix sums. Then the segment of positions we can have at\r\nthe end is and we want to place the maximum possible value in in such a\r\nway that this remaining segment (with addition of our current element)\r\nwill cover . This maximum value equals . If becomes less than then this\r\ncyclic shift is invalid, and we should skip it. Otherwise, let\u00e2\u0080\u0099s add to\r\nand proceed. If there are no values , then we placed anything\r\ncorrectly.Now can just simulate the movements of our dog to find the\r\nanswer for the current cyclic shift. But there are cases when do not\r\ncontain zeros, so these cases should be handled somehow (I just checked\r\nthat after simulation we returned to ). If we returned to , we can\r\nupdate the answer as the difference between the maximum and the minimum\r\npositions plus one. If there is no valid cyclic shift, then the answer\r\nis .Time complexity: .\r\n"
}