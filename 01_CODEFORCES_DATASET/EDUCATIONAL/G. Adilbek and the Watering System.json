{
    "link": "https://codeforces.com//contest/1238/problem/G",
    "problemId": "434111",
    "problem_idx": "G",
    "shortId": "1238G",
    "contest_number": "1238",
    "problem_submissions": {
        "G": [
            62148377,
            62150345,
            62148994,
            62146428,
            62171195,
            62152430,
            62150450,
            62151715,
            63077598,
            62153399,
            62153961,
            62326923,
            62163873,
            62157710,
            63252631
        ],
        "C": [
            62139579,
            62128875,
            62134212,
            62149084,
            62171152,
            62131518,
            62131617,
            62138927,
            62130356,
            62145335,
            62127646,
            62128518,
            62127470,
            62128489,
            62132928,
            62130729,
            62130656,
            62131114,
            62129400,
            62129293,
            62129389,
            62141737
        ],
        "F": [
            62135057,
            62143199,
            62146057,
            62137636,
            62171175,
            62141888,
            62144431,
            62147441,
            62144667,
            62133761,
            62136545,
            62139411,
            62133600,
            62138749,
            62143755,
            62143321,
            62145892,
            62144865,
            62148327,
            62148901,
            62145390
        ],
        "E": [
            62130371,
            62135558,
            62133197,
            62133178,
            62171181,
            62138707,
            62138998,
            71444053,
            62143394,
            62142446,
            62126207,
            62132191,
            62134744,
            62139465,
            62131237,
            62138771,
            62335532,
            62136799,
            62138459,
            62139760,
            62138816,
            62133466,
            62139306,
            62136690
        ],
        "D": [
            62130325,
            62130011,
            62129721,
            62133154,
            62171155,
            62134587,
            62136980,
            62133511,
            62142844,
            62150513,
            62130499,
            62130138,
            62131294,
            62128520,
            62132339,
            62134000,
            62132013,
            62132252,
            62131248,
            62131658,
            62131164
        ],
        "B": [
            62124194,
            62124712,
            62125813,
            62133117,
            62171147,
            62134676,
            62126226,
            62125252,
            62142403,
            62146274,
            62123866,
            62124453,
            62125991,
            62125432,
            62124476,
            62123794,
            62126146,
            62127228,
            62126305,
            62123963,
            62127931,
            62125892
        ],
        "A": [
            62120855,
            62121082,
            62121998,
            62121600,
            62171137,
            62121874,
            62120946,
            62121255,
            62120923,
            62120856,
            62121293,
            62121013,
            62121176,
            62120783,
            62120942,
            62121012,
            62121072,
            62121136,
            62121767,
            62121527
        ]
    },
    "name": "G. Adilbek and the Watering System",
    "statement": "Adilbek has to water his garden. He is going to do it with the help of a\r\ncomplex watering system: he only has to deliver water to it, and the\r\nmechanisms will do all the remaining job.The watering system consumes\r\none liter of water per minute (if there is no water, it is not working).\r\nIt can hold no more than c liters. Adilbek has already poured c_0 liters\r\nof water into the system. He is going to start watering the garden right\r\nnow and water it for m minutes, and the watering system should contain\r\nat least one liter of water at the beginning of the i-th minute (for\r\nevery i from 0 to m - 1).Now Adilbek wonders what he will do if the\r\nwatering system runs out of water. He called n his friends and asked\r\nthem if they are going to bring some water. The i-th friend answered\r\nthat he can bring no more than a_i liters of water; he will arrive at\r\nthe beginning of the t_i-th minute and pour all the water he has into\r\nthe system (if the system cannot hold such amount of water, the excess\r\nwater is poured out); and then he will ask Adilbek to pay b_i dollars\r\nfor each liter of water he has brought. You may assume that if a friend\r\narrives at the beginning of the t_i-th minute and the system runs out of\r\nwater at the beginning of the same minute, the friend pours his water\r\nfast enough so that the system does not stop working.Of course, Adilbek\r\ndoes not want to pay his friends, but he has to water the garden. So he\r\nhas to tell his friends how much water should they bring. Formally,\r\nAdilbek wants to choose n integers k_1, k_2, ..., k_n in such a way\r\nthat: if each friend i brings exactly k_i liters of water, then the\r\nwatering system works during the whole time required to water the\r\ngarden; the sum\r\nsum\r\nlimits_{i = 1}^{n} k_i b_i is minimum possible. Help Adilbek to\r\ndetermine the minimum amount he has to pay his friends or determine that\r\nAdilbek not able to water the garden for m minutes.You have to answer q\r\nindependent queries.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\nconst int N = 500005;\n\nint n, m, c, w, t, a, b, q, cur;\n\nstruct SNode {\n    int c;\n    mutable int w;\n\n    SNode(int _c = 0, int _w = 0) : c(_c), w(_w) {}\n\n    inline bool operator<(const SNode &oth) const {\n        return c < oth.c;\n    }\n};\nvector<pair<int, SNode>> ve;\nmultiset<SNode> se;\n\nlong long solve() {\n    long long ans = 0;\n    ve.clear();\n    se.clear();\n    cin >> n >> m >> c >> cur;\n    ve.push_back({0, SNode(0, cur)});\n    ve.push_back({m, SNode(0, c)});\n    while (n--) {\n        cin >> t >> a >> b;\n        ve.push_back({t, SNode(b, a)});\n    }\n    sort(ve.begin(), ve.end());\n    se.insert(SNode(0, cur));\n    for (int i = 1; i < ve.size(); i++) {\n        int tim = ve[i].fi - ve[i - 1].fi;\n        cur -= tim;\n        if (cur < 0) {\n            return -1;\n        }\n        while (tim > 0) {\n            if (se.begin()->w <= tim) {\n                tim -= se.begin()->w;\n                se.erase(se.begin());\n            } else {\n                se.begin()->w -= tim;\n                tim = 0;\n            }\n        }\n        SNode add = ve[i].se;\n        if (add.w <= c - cur) {\n            se.insert(add);\n            cur += add.w;\n            ans += 1LL * add.w * add.c;\n        } else {\n            se.insert(SNode(add.c, c - cur));\n            ans += 1LL * add.c * (c - cur);\n            add.w -= c - cur;\n            cur = c;\n            while (prev(se.end())->c > add.c && add.w > 0) {\n                auto rep = prev(se.end());\n                if (rep->w <= add.w) {\n                    int w = rep->w;\n                    ans -= 1LL * rep->c * w;\n                    ans += 1LL * add.c * w;\n                    se.erase(rep);\n                    se.insert(SNode(add.c, w));\n                    add.w -= w;\n                } else {\n                    int w = add.w;\n                    ans -= 1LL * rep->c * w;\n                    ans += 1LL * add.c * w;\n                    rep->w -= w;\n                    se.insert(add);\n                    break;\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> q;\n    while (q--) {\n        cout << solve() << '\\n';\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "sortings"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Adilbek and the Watering System.json",
    "editorial_link": "https://codeforces.com//blog/entry/70450",
    "editorial": "Despite the fact that statement sounds like some dp or flow, the actual\r\nsolution is pretty greedy.Let\u00e2\u0080\u0099s iterate over all minutes Adilbek has to\r\nwater at and maintain the cheapest liters he can obtain to this minute.\r\nLet this be some structure which stores data in form (price for 1 liter,\r\ntotal volume Adilbek can buy for this price). Pairs will be sorted by\r\nthe price of a liter. The most convenient structure for that might be a\r\nC++ map, for example.When moving to the next minute, pop the cheapest\r\nliter out of this structure and add it to the answer.If that minute some\r\nfriend comes, then push his water to the structure: if the total updated\r\nvolume in the structure is greater than , then pop the most expensive\r\nleft-overs out of it so that the structure holds no more than liters\r\ntotal. That prevents out solution to fill the watering system over its\r\ncapacity.The main idea for why this greedy strategy works is that it\u00e2\u0080\u0099s\r\nnever optimal to take not the cheapest liter because a liter of that\r\nprice or cheaper will still be available in the future minutes.Note that\r\nbetween each pairs of adjacent coming friends basically nothing happens.\r\nThus you can find the time between them and pop that number of cheapest\r\nliters right away instead of iterating minute by minute.Overall\r\ncomplexity: per query.\r\n"
}