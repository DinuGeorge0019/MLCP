{
    "link": "https://codeforces.com//contest/1051/problem/C",
    "problemId": "222359",
    "problem_idx": "C",
    "shortId": "1051C",
    "contest_number": "1051",
    "problem_submissions": {
        "F": [
            43140779,
            43140701,
            43140521,
            43144878,
            43149555,
            43136128,
            43135754,
            43146222,
            43141081,
            43140208,
            43140886,
            43148136,
            43125606,
            43139391,
            43143179,
            43180670,
            43137698,
            43132665,
            43136422,
            43137213,
            43136215,
            43152919,
            43140345
        ],
        "E": [
            43135788,
            43135396,
            43135166,
            43144968,
            43139384,
            43145873,
            43148036,
            43133440,
            43138040,
            43130161,
            43150071,
            43172602,
            43169210,
            43138739,
            43141483,
            43140870
        ],
        "D": [
            43122761,
            43123321,
            43124505,
            43127072,
            43131033,
            43132900,
            43131873,
            43120016,
            43141171,
            43141877,
            43118771,
            109385219,
            43126836,
            43129621,
            43130021,
            43126148,
            43128304,
            43128721,
            43127454,
            43124199,
            43127027
        ],
        "C": [
            43120001,
            43120557,
            43121091,
            43122279,
            43123187,
            43129372,
            43126529,
            43136659,
            43142859,
            43145151,
            43120361,
            43120848,
            43124838,
            43124502,
            43122781,
            43124340,
            43124338,
            43124203,
            43121537,
            43122507
        ],
        "B": [
            43118265,
            43118662,
            43118894,
            43119173,
            43118548,
            43118066,
            43121653,
            43137307,
            43143272,
            43145683,
            43118005,
            43118512,
            43121090,
            43120908,
            43119605,
            43119200,
            43119726,
            43119810,
            43118546,
            43119160
        ],
        "A": [
            43118136,
            43118310,
            43118532,
            43118569,
            43120138,
            43261343,
            43119567,
            43119846,
            43140090,
            43144863,
            43147178,
            43123917,
            43118256,
            43120404,
            43119598,
            43118824,
            43118544,
            43118365,
            43118914,
            43118324,
            43118586
        ],
        "G": [
            43151141,
            43245454
        ]
    },
    "name": "C. Vasya and Multisets",
    "statement": "Vasya has a multiset s consisting of n integer numbers. Vasya calls some\r\nnumber x nice if it appears in the multiset exactly once. For example,\r\nmultiset\r\n{1, 1, 2, 3, 3, 3, 4\r\n} contains nice numbers 2 and 4.Vasya wants to split multiset s into two\r\nmultisets a and b in such a way that the quantity of nice numbers in\r\nmultiset a would be the same as the quantity of nice numbers in multiset\r\nb (the quantity of numbers to appear exactly once in multiset a and the\r\nquantity of numbers to appear exactly once in multiset b).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[101];\nint cnt[101];\nstring S;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) {\n\t\tcin>>A[i];\n\t\tcnt[A[i]]++;\n\t}\n\tint n1=0,n3=0;\n\tFOR(i,101) {\n\t\tif(A[i]==1) n1++;\n\t\tif(A[i]>=3) n3++;\n\t}\n\t\n\t\n\tS.resize(N);\n\tx=0;\n\tFOR(i,N) if(cnt[A[i]]==1) {\n\t\tS[i]='A'+x;\n\t\tx^=1;\n\t}\n\t\n\tFOR(i,N) if(x==1 && cnt[A[i]]>=3) {\n\t\tS[i]='B';\n\t\tx=0;\n\t}\n\tif(x) return _P(\"NO\\n\");\n\tFOR(i,N) if(S[i]==0) S[i]='A';\n\t\n\tcout<<\"YES\"<<endl;\n\tcout<<S<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Vasya and Multisets.json",
    "editorial_link": "https://codeforces.com//blog/entry/61969",
    "editorial": "Write down all the numbers, which appear exactly once, let there be of\r\nthem. If is even, put the first of them into the first multiset and put\r\nthe other into the second multiset. All the other numbers (which appear\r\nmore than once) also go into the first multiset. The only nice numbers\r\nwill be the initial , thus the answer is valid.If is odd and there is no\r\nnumber to appear more than twice, then the answer is \"\", as all the\r\nnumbers to appear exactly twice don\u00e2\u0080\u0099t change the difference of the\r\namounts of the nice numbers at all. If there is a number to appear more\r\nthan twice (let it be ), then let\u00e2\u0080\u0099s firstly add of the numbers to appear\r\nexactly once to the first multiset, add others of them to the second\r\nmultiset. Then the first occurrence of goes to the second multiset and\r\nall the other numbers go to the first multiset. It\u00e2\u0080\u0099s easy to notice that\r\nmultisets will contain equal number of the nice numbers after all the\r\npartitioning.\r\n"
}