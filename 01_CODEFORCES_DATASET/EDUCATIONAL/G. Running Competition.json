{
    "link": "https://codeforces.com//contest/1398/problem/G",
    "problemId": "699507",
    "problem_idx": "G",
    "shortId": "1398G",
    "contest_number": "1398",
    "problem_submissions": {
        "G": [
            89915963,
            89919649,
            89969541,
            89969478,
            89969399,
            89923373,
            89932796,
            89925690,
            89932477,
            89942517,
            89940456,
            89939176,
            89934894,
            89934457,
            89937693,
            89934633,
            89938319,
            89937371,
            89998747,
            89998438,
            89941918,
            89943420,
            89938418,
            89962347,
            89937826,
            91732579,
            91721537,
            91721531,
            91720040,
            91720007,
            91719903,
            89956129,
            89955780,
            89942074,
            89938585,
            89944168
        ],
        "F": [
            89912067,
            89913917,
            89970425,
            89946897,
            89910497,
            89907909,
            89921580,
            89925827,
            89926930,
            89927249,
            89928492,
            89920424,
            90033370,
            89917113,
            89932855,
            89933064,
            89929161,
            89924362,
            89920121,
            89940340,
            89933347,
            89929042
        ],
        "E": [
            89905047,
            89908543,
            89968389,
            89916074,
            89918608,
            89913134,
            89918941,
            89911745,
            89920728,
            89917154,
            89930653,
            89930795,
            89916495,
            89920330,
            89922316,
            89913338,
            89912908,
            89934884,
            89919511,
            89915904
        ],
        "D": [
            89896202,
            89894262,
            89927478,
            89895466,
            89894434,
            89904634,
            89907380,
            89898375,
            89898000,
            89898904,
            89895538,
            89900457,
            89898646,
            89893142,
            89905486,
            89900465,
            89900312,
            89902255,
            89897637
        ],
        "C": [
            89885830,
            89883985,
            89884334,
            89886727,
            89888686,
            89890331,
            89887777,
            89891076,
            89887912,
            89887655,
            89893333,
            89888198,
            89884415,
            89891205,
            89886744,
            89888315,
            89893476,
            89886675
        ],
        "B": [
            89882536,
            89880929,
            89882045,
            89882783,
            89885320,
            89885640,
            89884725,
            89881741,
            89883376,
            89882325,
            89890179,
            89884220,
            89880525,
            89887877,
            89881688,
            89882767,
            89889537,
            89882098
        ],
        "A": [
            89878857,
            89878683,
            89924676,
            89879194,
            89878701,
            89878764,
            89880470,
            89880388,
            89879912,
            89878682,
            89878924,
            89878750,
            89886185,
            89879017,
            89878663,
            89880890,
            89878758,
            89878853,
            89884879,
            89878791
        ]
    },
    "name": "G. Running Competition",
    "statement": "A running competition is going to be held soon. The stadium where the\r\ncompetition will be held can be represented by several segments on the\r\ncoordinate plane: two horizontal segments: one connecting the points (0,\r\n0) and (x, 0), the other connecting the points (0, y) and (x, y); n + 1\r\nvertical segments, numbered from 0 to n. The i-th segment connects the\r\npoints (a_i, 0) and (a_i, y); 0 = a_0 < a_1 < a_2 <\r\ndots < a_{n - 1} < a_n = x. For example, here is a picture of the\r\nstadium with x = 10, y = 5, n = 3 and a = [0, 3, 5, 10]: A is a route\r\nthat goes along the segments, starts and finishes at the same point, and\r\nnever intersects itself (the only two points of a lap that coincide are\r\nits starting point and ending point). The length of a lap is a total\r\ndistance travelled around it. For example, the red route in the picture\r\nrepresenting the stadium is a lap of length 24.The competition will be\r\nheld in q stages. The i-th stage has length l_i, and the organizers want\r\nto choose a lap for each stage such that the length of the lap is a .\r\nThe organizers don\u2019t want to choose short laps for the stages, so for\r\neach stage, they want to find the maximum possible length of a suitable\r\nlap.Help the organizers to calculate the maximum possible lengths of the\r\nlaps for the stages! In other words, for every l_i, find the maximum\r\npossible integer L such that l_i\r\nbmod L = 0, and there exists a lap of length L.If it is impossible to\r\nchoose such a lap then print -1.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\ntemplate<unsigned mod=998244353>struct mint {\n   unsigned val;\n   static unsigned get_mod(){return mod;}\n   unsigned inv() const{\n      int tmp,a=val,b=mod,x=1,y=0;\n      while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n      if(x<0)x+=mod; return x;\n   }\n   mint():val(0){}\n   mint(ll x):val(x>=0?x%mod:mod+(x%mod)){}\n   mint pow(ll t){mint res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;}return res;}\n   mint& operator+=(const mint& x){if((val+=x.val)>=mod)val-=mod;return *this;}\n   mint& operator-=(const mint& x){if((val+=mod-x.val)>=mod)val-=mod; return *this;}\n   mint& operator*=(const mint& x){val=ll(val)*x.val%mod; return *this;}\n   mint& operator/=(const mint& x){val=ll(val)*x.inv()%mod; return *this;}\n   mint operator+(const mint& x)const{return mint(*this)+=x;}\n   mint operator-(const mint& x)const{return mint(*this)-=x;}\n   mint operator*(const mint& x)const{return mint(*this)*=x;}\n   mint operator/(const mint& x)const{return mint(*this)/=x;}\n   bool operator==(const mint& x)const{return val==x.val;}\n   bool operator!=(const mint& x)const{return val!=x.val;}\n};\ntemplate<unsigned mod=998244353>struct factorial {\n   using Mint=mint<mod>;\n   vector<Mint> Fact, Finv;\npublic:\n   factorial(int maxx){\n      Fact.resize(maxx+1),Finv.resize(maxx+1); Fact[0]=Mint(1); rep(i,0,maxx)Fact[i+1]=Fact[i]*(i+1);\n      Finv[maxx]=Mint(1)/Fact[maxx]; rrep(i,maxx,0)Finv[i-1]=Finv[i]*i;\n   }\n   Mint fact(int n,bool inv=0){if(inv)return Finv[n];else return Fact[n];}\n   Mint nPr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[n-r];}\n   Mint nCr(int n,int r){if(n<0||n<r||r<0)return Mint(0);else return Fact[n]*Finv[r]*Finv[n-r];}\n};\nusing Mint=mint<>;\n\nvector<int> rt,irt;\ntemplate<unsigned mod=998244353>void init(int lg=21){\n   using Mint=mint<mod>; Mint prt=2;\n   while(prt.pow(mod>>1).val==1)prt+=1;\n   rt.resize(1<<lg,1); irt.resize(1<<lg,1);\n   rep(w,0,lg){\n      int mask=(1<<w)-1,t=Mint(-1).val>>w;\n      Mint g=prt.pow(t),ig=prt.pow(mod-1-t);\n      rep(i,0,mask){\n         rt[mask+i+1]=(g*rt[mask+i]).val;\n         irt[mask+i+1]=(ig*irt[mask+i]).val;\n      }\n   }\n}\n\ntemplate<unsigned mod=998244353>struct FPS{\n   using Mint=mint<mod>; vector<Mint> f;\n   FPS():f({1}){}\n   FPS(int _n):f(_n){}\n   FPS(vector<Mint> _f):f(_f){}\n   Mint& operator[](const int i){return f[i];}\n   Mint eval(Mint x){\n      Mint res,w=1;\n      for(Mint v:f)res+=w*v,w*=x; return res;\n   }\n   FPS inv()const{\n      assert(f[0]!=0); int n=f.size();\n      FPS res(n); res.f[0]=f[0].inv();\n      for(int k=1;k<n;k<<=1){\n         FPS g(k*2),h(k*2);\n         rep(i,0,min(k*2,n))g[i]=f[i]; rep(i,0,k)h[i]=res[i];\n         g.ntt(); h.ntt(); rep(i,0,k*2)g[i]*=h[i]; g.ntt(1);\n         rep(i,0,k)g[i]=0,g[i+k]*=-1;\n         g.ntt(); rep(i,0,k*2)g[i]*=h[i]; g.ntt(1);\n         rep(i,k,min(k*2,n))res[i]=g[i];\n      } return res;\n   }\n   void ntt(bool inv=0){\n        int n=f.size(); if(n==1)return;\n        if(inv){\n            for(int i=1;i<n;i<<=1){\n                for(int j=0;j<n;j+=i*2){\n                    rep(k,0,i){\n                        f[i+j+k]*=irt[i*2-1+k];\n                        const Mint tmp=f[j+k]-f[i+j+k];\n                        f[j+k]+=f[i+j+k]; f[i+j+k]=tmp;\n                    }\n                }\n            }\n            Mint mul=Mint(n).inv(); rep(i,0,n)f[i]*=mul;\n        }else{\n            for(int i=n>>1;i;i>>=1){\n                for(int j=0;j<n;j+=i*2){\n                    rep(k,0,i){\n                        const Mint tmp=f[j+k]-f[i+j+k];\n                        f[j+k]+=f[i+j+k]; f[i+j+k]=tmp*rt[i*2-1+k];\n                    }\n                }\n            }\n        }\n   }\n   FPS operator+(const FPS& g)const{return FPS(*this)+=g;}\n   FPS operator-(const FPS& g)const{return FPS(*this)-=g;}\n   FPS operator*(const FPS& g)const{return FPS(*this)*=g;}\n   template<class T>FPS operator*(T t)const{return FPS(*this)*=t;}\n   FPS operator/(const FPS& g)const{return FPS(*this)/=g;}\n   template<class T>FPS operator/(T t)const{return FPS(*this)/=t;}\n   FPS operator%(const FPS& g)const{return FPS(*this)%=g;}\n   FPS& operator+=(FPS g){\n      if(g.f.size()>f.size())f.resize(g.f.size());\n      rep(i,0,g.f.size())f[i]+=g[i]; return *this;\n   }\n   FPS& operator-=(FPS g){\n      if(g.f.size()>f.size())f.resize(g.f.size());\n      rep(i,0,g.f.size())f[i]-=g[i]; return *this;\n   }\n   FPS& operator*=(FPS g){\n      int m=f.size()+g.f.size()-1,n=1; while(n<m)n<<=1;\n      f.resize(n); g.f.resize(n);\n      ntt(); g.ntt(); rep(i,0,n)f[i]*=g[i]; \n      ntt(1); f.resize(m); return *this;\n   }\n   template<class T>FPS& operator*=(T t){for(Mint x:f)x*=t; return *this;}\n   FPS& operator/=(FPS g){\n      if(g.f.size()>f.size())return *this=FPS({0});\n      reverse(ALL(f)); reverse(ALL(g.f));\n      int n=f.size()-g.f.size()+1;\n      f.resize(n); g.f.resize(n); FPS mul=g.inv();\n      *this*=mul; f.resize(n); reverse(ALL(f)); return *this;\n   }\n   template<class T>FPS& operator/=(T t){for(Mint x:f)x/=t; return *this;}\n   FPS& operator%=(FPS g){\n      *this-=*this/g*g;\n      while(!f.empty()&&f.back()==0)f.pop_back();\n      return *this;\n   }\n   FPS sqrt(){\n      int n=f.size(); FPS res(1); res[0]=1;\n      for(int k=1;k<n;k<<=1){\n         FPS ff=*this; res.f.resize(k*2);\n         res+=ff/res; res/=2;\n      } res.f.resize(n); return res;\n   }\n   FPS diff(){\n      FPS res=*this; rep(i,0,res.f.size()-1)res[i]=res[i+1]*(i+1);\n      res.f.pop_back(); return res;\n   }\n   FPS inte(){\n      FPS res=*this; res.f.push_back(0);\n      rrep(i,res.f.size()-1,0)res[i]=res[i-1]/i;\n      res[0]=0; return res;\n   }\n   FPS log(){\n      assert(f[0]==1); FPS res=diff()*inv(); \n      res.f.resize(f.size()-1); res=res.inte(); return res;\n   }\n   FPS exp(){\n      assert(f[0]==0); int m=f.size(),n=1; while(n<m)n<<=1;\n      f.resize(n); FPS d=diff(),res(n); vector<FPS> pre;\n      for(int k=n;k;k>>=1){\n         FPS g=d; g.f.resize(k);\n         g.ntt(); pre.push_back(g);\n      }\n      auto dfs=[&](auto dfs,int l,int r,int dep)->void{\n         if(r-l==1){if(l>0)res[l]/=l; return;}\n         int m=(l+r)>>1; dfs(dfs,l,m,dep+1);\n         FPS g(r-l); rep(i,0,m-l)g[i]=res[l+i];\n         g.ntt(); rep(i,0,r-l)g[i]*=pre[dep][i]; g.ntt(1);\n         rep(i,m,r)res[i]+=g[i-l-1]; dfs(dfs,m,r,dep+1);\n      }; res[0]=1; dfs(dfs,0,n,0); res.f.resize(m); return res;\n   }\n};//need to initialize\n\nint n,t; int a[1010000];\nint cnt[501000]={};\nfactorial<> fact(501000);\nMint inv[501000];\n\nFPS<> substituteXplus(FPS<> A, Mint w) {\n   int n = (int)A.f.size();\n   for (int i = 0; i < n; i++)\n      A[i] *= fact.fact(i, 0);\n   vector<Mint> B(n);\n   Mint pw = 1;\n   for (int i = 0; i < n; i++) {\n      B[i] = pw * fact.fact(i, 1);\n      pw *= w;\n   }\n   reverse(all(B));\n   FPS<> C = A * FPS<>(B);\n   B = C.f;\n   rotate(B.begin(), B.begin() + n - 1, B.end());\n   B.resize(n);\n   for (int i = 0; i < n; i++)\n      B[i] *= fact.fact(i, 1);\n   return FPS<>(B);\n}\n/*\n   CALL INIT !!!\n*/\n\nconst int N = 500500;\nbool good[N];\nint ans[N];\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tinit();\n\n\tint n, x, y;\n\tscanf(\"%d%d%d\", &n, &x, &y);\n\tvector<Mint> a(x + 1);\n\tn++;\n\tfor (int i = 0; i <= x; i++)\n\t\ta[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint z;\n\t\tscanf(\"%d\", &z);\n\t\ta[z] = 1;\n\t}\n\tvector<Mint> b = a;\n\treverse(all(b));\n\tFPS<> c = FPS<>(a) * FPS<>(b);\n\n\tfor (int i = 1; i <= x; i++)\n\t\tif (c[x + i].val != 0)\n\t\t\tgood[y + i] = 1;\n\n\tfor (int i = 0; i < N; i++)\n\t\tans[i] = -1;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (!good[i]) continue;\n\t\tfor (int j = i; j < N; j += i)\n\t\t\tans[j] = 2 * i;\n\t}\n\n\tint q;\n\tscanf(\"%d\", &q);\n\twhile(q--) {\n\t\tint z;\n\t\tscanf(\"%d\", &z);\n\t\tz /= 2;\n\t\tprintf(\"%d \", ans[z]);\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "fft",
        "math",
        "number theory"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Running Competition.json",
    "editorial_link": "https://codeforces.com//blog/entry/81506",
    "editorial": "First of all, let\u00e2\u0080\u0099s find all possible lengths of the laps (after doing\r\nthat, we can just check every divisor of to find the maximum possible\r\nlength of a lap for a given query). A lap is always a rectangle you\r\ncan\u00e2\u0080\u0099t construct a lap without using any vertical segments or using an\r\nodd number of vertical segments, and if you try to use or more vertical\r\nsegments, you can\u00e2\u0080\u0099t go back to the point where you started because both\r\nhorizontal segments are already partially visited. So, a lap is a\r\nrectangle bounded by two vertical segments; and if we use vertical\r\nsegments and , the perimeter of this rectangle is .Let\u00e2\u0080\u0099s find all values\r\nthat can be represented as . A naive approach will be too slow, we have\r\nto speed it up somehow. Let\u00e2\u0080\u0099s build an array of numbers where ( is some\r\ninteger greater than ). Each number that can be represented as can also\r\nbe represented as , so we have to find all possible sums of two elements\r\nbelonging to different arrays.The key observation here is that, if and\r\nare small, we can treat each array as a polynomial: let , and similarly,\r\n. Let\u00e2\u0080\u0099s look at the product of that polynomials. The coefficient for is\r\nnon-zero if and only if there exist and such that , so finding all\r\npossible sums (and all possible differences) can be reduced to\r\nmultiplying two polynomials, which can be done faster than using\r\nKaratsuba\u00e2\u0080\u0099s algorithm or FFT.\r\n"
}