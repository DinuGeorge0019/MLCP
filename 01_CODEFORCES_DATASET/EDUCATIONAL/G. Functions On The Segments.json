{
    "link": "https://codeforces.com//contest/837/problem/G",
    "problemId": "116713",
    "problem_idx": "G",
    "shortId": "837G",
    "contest_number": "837",
    "problem_submissions": {
        "G": [
            29167867,
            29168921,
            29171657,
            29211841,
            29211768,
            29194112,
            29194042,
            29194028,
            29175447,
            29168227,
            29172693,
            29172204,
            29166926,
            29165613,
            29171547,
            29173009,
            29190922,
            32561173,
            29172886,
            29172783,
            29172758,
            29172505,
            29172166
        ],
        "F": [
            29165055,
            29166362,
            29168864,
            29166638,
            29169357,
            29169429,
            29164558,
            29186836,
            29168655,
            29167876,
            29169339,
            29172957,
            29171060,
            29171284,
            29168929,
            29172401,
            29169905,
            29168071,
            29172819
        ],
        "E": [
            29162020,
            29163186,
            29165795,
            29163264,
            29164907,
            29165095,
            29162428,
            29167933,
            29164726,
            29164807,
            29166669,
            29167308,
            29166973,
            29172476,
            29166198,
            29169034,
            29165312,
            29163338,
            29169750
        ],
        "D": [
            29161276,
            29162239,
            29163430,
            29162397,
            29162640,
            29163863,
            29160761,
            29163799,
            29174585,
            29164816,
            29165533,
            29164344,
            29163361,
            29163790,
            29167229,
            30486037,
            29175514,
            29161500,
            29167261
        ],
        "C": [
            29160368,
            29160646,
            29161707,
            29160573,
            29161464,
            29161685,
            29160675,
            29160760,
            29162171,
            29161153,
            29162346,
            29163214,
            29163154,
            29161641,
            29165376,
            29161315,
            29160556,
            29163716
        ],
        "B": [
            29159633,
            29159893,
            29160590,
            29159654,
            29160221,
            29159770,
            29161534,
            29161149,
            29160418,
            29160903,
            29161228,
            29162604,
            29271569,
            29164321,
            29195260,
            29160168,
            29175059,
            29162325
        ],
        "A": [
            29158816,
            29158847,
            29159160,
            29160665,
            29159109,
            29158852,
            29159205,
            29159017,
            29158817,
            29158878,
            29159185,
            29161667,
            29158818,
            29158815,
            29159058,
            29159399
        ]
    },
    "name": "G. Functions On The Segments",
    "statement": "You have an array of functions.The function () is characterized by\r\nparameters: and take values: , if . , if . , if . There are queries.\r\nEach query is determined by numbers , and . For a query with number (),\r\nyou need to calculate the sum of all where . The value of is calculated\r\nas follows: mod , where is the answer to the query with number . The\r\nvalue of equals if .\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:1048576\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n#define rf(x) (x)=0;while(*p<48)p++;while(47<*p)(x)=((x)<<3)+((x)<<1)+(*p++&15);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\ntypedef tuple <int, int, int> t3;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000009;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 3234567890123456789ll;\nconst db PI = acos(-1);\nconst db EPS = 1e-8;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<(n);i++)\n\npll operator + (pll a, pll b) {\n\treturn pll(a.first + b.first, a.second + b.second);\n}\n\nint nc = 1;\nint son[6000000][2];\npll val[6000000];\nint update(int st, int en, int p, int n, pll v) {\n\tif (st == en) {\n\t\tnc++;\n\t\tval[nc] = v;\n\t\treturn nc;\n\t}\n\tint nn = ++nc;\n\tson[nn][0] = son[n][0], son[nn][1] = son[n][1];\n\tint mi = (st + en) / 2;\n\tif (p <= mi) son[nn][0] = update(st, mi, p, son[n][0], v);\n\telse son[nn][1] = update(mi + 1, en, p, son[n][1], v);\n\tval[nn] = val[son[nn][0]] + val[son[nn][1]];\n\treturn nn;\n}\npll getsum(int st, int en, int S, int E, int n) {\n\tif (n == 0) return pll(0, 0);\n\tif (st > en) return pll(0, 0);\n\tif (st == S && en == E) return val[n];\n\n\tint M = (S + E) / 2;\n\treturn getsum(st, min(en, M), S, M, son[n][0]) + getsum(max(st, M + 1), en, M + 1, E, son[n][1]);\n}\n\nll in[300050][3];\nint u[300050];\nint R[300050];\nint main() {\n\tint N, i;\n\tscanf(\"%d\", &N);\n\tfor (i = 1; i <= N; i++) {\n\t\tint x1, x2, y1, a, b, y2;\n\t\tscanf(\"%d %d %d %d %d %d\", &x1, &x2, &y1, &a, &b, &y2);\n\t\tin[3 * i - 2][0] = 0, in[3 * i - 2][1] = 0, in[3 * i - 2][2] = y1;\n\t\tin[3 * i - 1][0] = x1 + 1, in[3 * i - 1][1] = a, in[3 * i - 1][2] = b - y1;\n\t\tin[3 * i][0] = x2 + 1, in[3 * i][1] = -a, in[3 * i][2] = -b + y2;\n\t}\n\tfor (i = 1; i <= 3 * N; i++) u[i] = i;\n\tsort(u + 1, u + 3 * N + 1, [](int a, int b) {\n\t\treturn in[a][0] < in[b][0];\n\t});\n\n\tint p = 1;\n\tfor (i = 0; i <= 300000; i++) {\n\t\tR[i] = 1;\n\t\tif (i) R[i] = R[i - 1];\n\t\twhile (p <= 3 * N) {\n\t\t\tint t = u[p];\n\t\t\tif (in[t][0] > i) break;\n\t\t\tR[i] = update(1, IT_MAX, t, R[i], pll(in[t][1], in[t][2]));\n\t\t\tp++;\n\t\t}\n\t}\n\n\tint Q;\n\tll last = 0;\n\tscanf(\"%d\", &Q);\n\twhile (Q--) {\n\t\tint l, r;\n\t\tll x;\n\t\tscanf(\"%d %d %lld\", &l, &r, &x);\n\t\tx = (x + last) % 1000000000;\n\n\t\tll nx = min(x, 300000ll);\n\t\tpll u = getsum(3 * l - 2, 3 * r, 1, IT_MAX, R[nx]);\n\t\tlast = u.first * x + u.second;\n\t\tprintf(\"%lld\\n\", last);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Functions On The Segments.json",
    "editorial_link": "https://codeforces.com//blog/entry/53662",
    "editorial": "Let\u00e2\u0080\u0099s build a data structure that allows us to find sum of functions on\r\nsome prefix. The answer to the query can be obviously obtained using two\r\nanswers on prefixes.We will use some persistent data structure that\r\nhandles prefix sum queries persistent segment tree, for example. We will\r\nactually use two different structures: let the sum of functions in some\r\npoint be ; one structure will allow us to find , and another one will\r\nallow us to find .Obviously, for prefix of length both and are equal to\r\n. Then when we advance from prefix of length to prefix of length , we do\r\nthe following: in the structure that handles we add in position and add\r\nin position , so it is added only on segment . The same approach can be\r\nused to find : add in position , add in position and add in position .\r\nAnd to get the value in point on some prefix, we just make a prefix sum\r\nquery to the corresponding structure.\r\n"
}