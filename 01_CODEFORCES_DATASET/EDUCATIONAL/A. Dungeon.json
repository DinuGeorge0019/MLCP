{
    "link": "https://codeforces.com//contest/1463/problem/A",
    "problemId": "836001",
    "problem_idx": "A",
    "shortId": "1463A",
    "contest_number": "1463",
    "problem_submissions": {
        "F": [
            101559554,
            101581978,
            101567286,
            101577708,
            101580696,
            101680102,
            101680098,
            101605801,
            101605564,
            101602968,
            101602931,
            101594909,
            101594099,
            102434679,
            101661639,
            101713126,
            101711433,
            101812801
        ],
        "E": [
            101543691,
            101541624,
            101550722,
            101542275,
            101561956,
            101542640,
            101551028,
            101551947,
            101553418,
            101552115,
            101553474,
            101556641,
            101557969,
            101556648,
            101554530,
            101557890,
            101556692,
            101561428,
            101553035
        ],
        "D": [
            101533227,
            101528710,
            101537667,
            101530458,
            101531312,
            101543635,
            101536909,
            101536759,
            101540131,
            101537456,
            101542046,
            101537094,
            101540598,
            101539288,
            101544433,
            101525965,
            101526650,
            101536306,
            101544222
        ],
        "C": [
            101526320,
            101520150,
            101529141,
            101525986,
            101523000,
            101525367,
            101530714,
            101526273,
            102544695,
            101524853,
            101531194,
            101530250,
            101529215,
            101530504,
            101529471,
            101533604,
            101540078,
            101541782,
            101523573,
            101536896
        ],
        "B": [
            101518923,
            101515147,
            101518366,
            101516293,
            101513263,
            101522496,
            101520454,
            101515435,
            101517061,
            101515098,
            101516483,
            101522667,
            101516542,
            101515577,
            101515224,
            101517780,
            101517682,
            101515176,
            101521789
        ],
        "A": [
            101515277,
            101512560,
            101513602,
            101512825,
            101512593,
            101512667,
            101513802,
            101512900,
            101514221,
            101512986,
            101513229,
            101513515,
            101512759,
            101512530,
            101512877,
            101514648,
            101514992,
            101512816,
            101514556
        ]
    },
    "name": "A. Dungeon",
    "statement": "You are playing a new computer game in which you have to fight monsters.\r\nIn a dungeon you are trying to clear, you met three monsters; the first\r\nof them has a health points, the second has b health points, and the\r\nthird has c.To kill the monsters, you can use a cannon that, when fired,\r\ndeals 1 damage to the selected monster. Every 7-th (i. e. shots with\r\nnumbers 7, 14, 21 etc.) cannon shot is and deals 1 damage to monsters,\r\nnot just one of them. If some monster’s current amount of health points\r\nis 0, it can’t be targeted by a regular shot and does not receive damage\r\nfrom an shot.You want to pass the dungeon beautifully, i. e., kill all\r\nthe monsters with the same shot (i. e. after some shot, the health\r\npoints of each of the monsters should become equal to 0 ). Each shot\r\nmust hit a monster, i. e. each shot deals damage to at least one\r\nmonster.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target (\"sse4\")\n\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acosl(-1.0);\n\nll mod_pow(ll x, ll n, ll m = mod) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nvoid solve() {\n\tint h[3]; rep(i, 3)cin >> h[i];\n\tint mi = mod;\n\trep(i, 3)mi = min(mi, h[i]);\n\tint dec = 0;\n\trep(i, 3)dec += h[i] - mi;\n\tif (dec % 3) {\n\t\tcout << \"NO\\n\"; return;\n\t}\n\tint cur = mi;\n\twhile (dec % 6) {\n\t\tdec+=3; cur--;\n\t}\n\tint rest = cur - dec / 6;\n\tif (rest < 0||rest%3) {\n\t\tcout << \"NO\\n\"; return;\n\t}\n\telse {\n\t\tcout << \"YES\\n\";\n\t}\n}\n\nsigned main() {\n\t//ios::sync_with_stdio(false);\n\t//cin.tie(0);\n\t//cout << fixed << setprecision(15);\n\t//init_f();\n\t//init();\n\t//expr();\n\tint t; cin >> t; rep(i, t)\n\tsolve();\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Dungeon.json",
    "editorial_link": "https://codeforces.com//blog/entry/85707",
    "editorial": "Note that for every shots, we deal a total of units of damage. Since we\r\nwant to kill all the monsters with a shot which index is divisible by ,\r\nletâs denote the number of shots as . In this case, a total of units of\r\ndamage must be dealt, hence (if the result of the division is not an\r\ninteger, then there is no answer). Since each monster will receive at\r\nleast units of damage (with shots), the health of each monster must be\r\nat least . If the two conditions described above are met, then the\r\nremaining shots can always be distributed in the desired way.\r\n",
    "hint": []
}