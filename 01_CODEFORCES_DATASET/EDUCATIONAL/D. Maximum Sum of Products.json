{
    "link": "https://codeforces.com//contest/1519/problem/D",
    "problemId": "971589",
    "problem_idx": "D",
    "shortId": "1519D",
    "contest_number": "1519",
    "problem_submissions": {
        "C": [
            114616470,
            114551329,
            114551180,
            114564495,
            114550309,
            114552694,
            114547702,
            114548020,
            114553618,
            114563241,
            114559641,
            114555665,
            114557042,
            114556787,
            114554939,
            114556558,
            114555376,
            114549327,
            114552625,
            114552238,
            114554684,
            114559315
        ],
        "F": [
            114613463,
            114611288,
            114604337,
            114598897,
            114611467,
            114680142,
            114636104,
            114635840
        ],
        "E": [
            114607966,
            114580590,
            114575288,
            114583294,
            114570654,
            114566689,
            114580490,
            114581344,
            114581275,
            114584747,
            114587745,
            114586133,
            114587347,
            114590609,
            114592573,
            114589054,
            114601871,
            114596259,
            114594317,
            114625207,
            114625166,
            114600206,
            114595857
        ],
        "D": [
            114555495,
            114555902,
            114567847,
            114556972,
            114556567,
            114552424,
            114552771,
            114561234,
            114544188,
            114558776,
            114560835,
            114564971,
            114561515,
            114561300,
            114565333,
            114554107,
            114558569,
            114558286,
            114563876,
            114568526
        ],
        "B": [
            114542697,
            114545137,
            114558022,
            114545565,
            114550455,
            114542163,
            114542842,
            114545295,
            114550992,
            114551627,
            114546744,
            114549467,
            114548090,
            114544402,
            114547969,
            114543205,
            114546111,
            114545907,
            114546890,
            114546969
        ],
        "A": [
            114541604,
            114541862,
            114551019,
            114541996,
            114541593,
            114541608,
            114541607,
            114541640,
            114546683,
            114543589,
            114543013,
            114543817,
            114542361,
            114541678,
            114541836,
            114541598,
            114541959,
            114541646,
            114541768,
            114542287
        ]
    },
    "name": "D. Maximum Sum of Products",
    "statement": "You are given two integer arrays a and b of length n.You can reverse\r\nsubarray (continuous subsegment) of the array a. Your task is to reverse\r\nsuch a subarray that the sum\r\nsum\r\nlimits_{i=1}^n a_i\r\ncdot b_i is .\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N;\n    cin >> N;\n    vector<int64_t> A(N), B(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    for (auto &b : B)\n        cin >> b;\n\n    int64_t total = 0;\n\n    for (int i = 0; i < N; i++)\n        total += A[i] * B[i];\n\n    int64_t best = total;\n\n    for (int center = 0; center < N; center++) {\n        int64_t current = total;\n\n        for (int x = center - 1, y = center + 1; x >= 0 && y < N; x--, y++) {\n            current -= A[x] * B[x] + A[y] * B[y];\n            current += A[x] * B[y] + A[y] * B[x];\n            best = max(best, current);\n        }\n    }\n\n    for (int between = 0; between < N - 1; between++) {\n        int64_t current = total;\n\n        for (int x = between, y = between + 1; x >= 0 && y < N; x--, y++) {\n            current -= A[x] * B[x] + A[y] * B[y];\n            current += A[x] * B[y] + A[y] * B[x];\n            best = max(best, current);\n        }\n    }\n\n    cout << best << '\\n';\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "dp",
        "implementation",
        "math",
        "two pointers"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Maximum Sum of Products.json",
    "editorial_link": "https://codeforces.com//blog/entry/90212",
    "editorial": "The naive approach is to iterate over and , reverse the subsegment of\r\nthe array and calculate the answer. But this solution is too slow and\r\nworks in .Instead, we can iterate over the center of the reversed\r\nsegment and its length. If the current segment is , and we want to go to\r\n, then the answer for the subsegment will increase by . It remains to\r\nadd the answer for and , but without reversion, this is easy to do if\r\nyou pre-calculate the prefix sums of the values .\r\n",
    "hint": []
}