{
    "link": "https://codeforces.com//contest/1156/problem/F",
    "problemId": "338453",
    "problem_idx": "F",
    "shortId": "1156F",
    "contest_number": "1156",
    "problem_submissions": {
        "A": [
            53639029,
            53626152,
            53625678,
            53630793,
            53625404,
            53614352,
            53623128,
            53628986,
            53624721,
            53623695,
            53625017,
            53634723,
            53624542,
            53628079,
            53633627,
            53624437,
            53623236,
            53629488,
            53623966,
            53615060
        ],
        "B": [
            53637891,
            53617977,
            53617293,
            53625525,
            53620909,
            53621377,
            53618385,
            53633927,
            53620068,
            53619804,
            53621825,
            53614635,
            53623085,
            53633560,
            53636498,
            53618667,
            53619022,
            53619496,
            53620680,
            53624386
        ],
        "C": [
            53636621,
            53619670,
            53619150,
            53614135,
            53617663,
            53625504,
            53624957,
            53661619,
            53635201,
            53626601,
            53622201,
            53615675,
            53635681,
            53619089,
            53620360,
            53614001,
            53620016,
            53634903,
            53620881,
            53615566,
            53626189
        ],
        "G": [
            53635130,
            53641842,
            53954352,
            53641770,
            203176755,
            53643379
        ],
        "D": [
            53620605,
            53623897,
            53623535,
            53629070,
            53631245,
            53633026,
            53629459,
            53616004,
            53628435,
            53632954,
            53632904,
            53620339,
            53632312,
            53623609,
            53618157,
            53629146,
            53629263,
            53627644,
            53629790,
            53630995
        ],
        "F": [
            53617719,
            53632417,
            53636572,
            53634637,
            53627300,
            53636941,
            53634698,
            53625519,
            53635307,
            53636482,
            53636370,
            53630747,
            53636740,
            53635472,
            53633389,
            53637182,
            53632117,
            53637419,
            53635743,
            53636158
        ],
        "E": [
            53614077,
            53629771,
            53629915,
            53618247,
            53637367,
            53630569,
            53631126,
            53661599,
            53620934,
            53631115,
            53629004,
            53629934,
            53625980,
            53630101,
            53619260,
            53627891,
            53632780,
            53621624,
            53634838,
            53638304,
            53634716
        ]
    },
    "name": "F. Card Bag",
    "statement": "You have a bag which contains n cards. There is a number written on each\r\ncard; the number on i-th card is a_i.You are playing the following game.\r\nDuring each turn, you choose and remove a random card from the bag (all\r\ncards that are still left inside the bag are chosen equiprobably).\r\nNothing else happens during the first turn but during the next turns,\r\nafter removing a card (let the number on it be x), you compare it with\r\nthe card that was removed during the previous turn (let the number on it\r\nbe y). Possible outcomes are: if x < y, the game ends and you lose; if x\r\n= y, the game ends and you win; if x > y, the game continues. If there\r\nare no cards left in the bag, you lose. You have to calculate the\r\nprobability of winning in this game. It can be shown that it is in the\r\nform of\r\nfrac{P}{Q} where P and Q are non-negative integers and Q\r\nneq 0, P\r\nle Q. Output the value of P\r\ncdot Q^{ 1}  (mod    998244353).\r\n",
    "solutions": [
        "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 5000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\n//const int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n;\n    cin >> n;\n    int cnt[n];\n    fill(cnt, cnt + n, 0);\n    rep(i, 0, n) {\n        int x;\n        cin >> x;\n        cnt[x - 1]++;\n    }\n    ll pref[n + 1];\n    pref[0] = 1;\n    rep(i, 1, n + 1) {\n        pref[i] = pref[i - 1] * (n - (i - 1)) % MOD;\n    }\n    rep(i, 0, n + 1) {\n        pref[i] = rev(pref[i]);\n    }\n    ll dp[n + 1];\n    fill(dp, dp + n + 1, 0);\n    dp[0] = 1;\n    int ans = 0;\n    rep(i, 0, n) {\n        if (cnt[i] >= 2) {\n            rep(b, 0, n + 1) {\n                if (dp[b] == 0) {\n                    continue;\n                }\n                ans = (ans + dp[b] * cnt[i] % MOD * (cnt[i] - 1) % MOD * pref[b + 2]) % MOD;\n            }\n        }\n        repb(b, n - 1, -1) {\n            dp[b + 1] = (dp[b + 1] + dp[b] * cnt[i]) % MOD;\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math",
        "probabilities"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Card Bag.json",
    "editorial_link": "https://codeforces.com/blog/entry/66827",
    "editorial": "Letâs solve the problem by dynamic programming.Let be the probability of\r\nwinning if the last taken card has number on it and the number of taken\r\ncards is .We win immediately next turn if we take card with number on\r\nit. The probability of this is , where is number of cards with .Also we\r\ncan win if we take a greater card next turn.We take a card with number\r\nwith probability , with number with probability , and so on. The\r\nprobability of winning in this case will be and respectively. So the\r\nprobability of winning for is ) = ).Therefore, all we need is to\r\nmaintain the sum while calculating our dynamic programming.\r\n",
    "hint": []
}