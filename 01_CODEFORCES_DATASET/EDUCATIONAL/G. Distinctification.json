{
    "link": "https://codeforces.com//contest/1051/problem/G",
    "problemId": "222363",
    "problem_idx": "G",
    "shortId": "1051G",
    "contest_number": "1051",
    "problem_submissions": {
        "F": [
            43140779,
            43140701,
            43140521,
            43144878,
            43149555,
            43136128,
            43135754,
            43146222,
            43141081,
            43140208,
            43140886,
            43148136,
            43125606,
            43139391,
            43143179,
            43180670,
            43137698,
            43132665,
            43136422,
            43137213,
            43136215,
            43152919,
            43140345
        ],
        "E": [
            43135788,
            43135396,
            43135166,
            43144968,
            43139384,
            43145873,
            43148036,
            43133440,
            43138040,
            43130161,
            43150071,
            43172602,
            43169210,
            43138739,
            43141483,
            43140870
        ],
        "D": [
            43122761,
            43123321,
            43124505,
            43127072,
            43131033,
            43132900,
            43131873,
            43120016,
            43141171,
            43141877,
            43118771,
            109385219,
            43126836,
            43129621,
            43130021,
            43126148,
            43128304,
            43128721,
            43127454,
            43124199,
            43127027
        ],
        "C": [
            43120001,
            43120557,
            43121091,
            43122279,
            43123187,
            43129372,
            43126529,
            43136659,
            43142859,
            43145151,
            43120361,
            43120848,
            43124838,
            43124502,
            43122781,
            43124340,
            43124338,
            43124203,
            43121537,
            43122507
        ],
        "B": [
            43118265,
            43118662,
            43118894,
            43119173,
            43118548,
            43118066,
            43121653,
            43137307,
            43143272,
            43145683,
            43118005,
            43118512,
            43121090,
            43120908,
            43119605,
            43119200,
            43119726,
            43119810,
            43118546,
            43119160
        ],
        "A": [
            43118136,
            43118310,
            43118532,
            43118569,
            43120138,
            43261343,
            43119567,
            43119846,
            43140090,
            43144863,
            43147178,
            43123917,
            43118256,
            43120404,
            43119598,
            43118824,
            43118544,
            43118365,
            43118914,
            43118324,
            43118586
        ],
        "G": [
            43151141,
            43245454
        ]
    },
    "name": "G. Distinctification",
    "statement": "Suppose you are given a sequence S of k pairs of integers (a_1, b_1),\r\n(a_2, b_2),\r\ndots, (a_k, b_k).You can perform the following operations on it: Choose\r\nsome position i and a_i by 1. That can be performed only if there exists\r\nat least one such position j that i\r\nne j and a_i = a_j. The cost of this operation is b_i; Choose some\r\nposition i and a_i by 1. That can be performed only if there exists at\r\nleast one such position j that a_i = a_j + 1. The cost of this operation\r\nis -b_i. Each operation can be performed arbitrary number of times\r\n(possibly zero).Let f(S) be minimum possible x such that there exists a\r\nsequence of operations with total cost x, after which all a_i from S are\r\npairwise distinct. You are given a sequence P consisting of n pairs of\r\nintegers (a_1, b_1), (a_2, b_2),\r\ndots, (a_n, b_n). All b_i are pairwise distinct. Let P_i be the sequence\r\nconsisting of the first i pairs of P. Your task is to calculate the\r\nvalues of f(P_1), f(P_2),\r\ndots, f(P_n).\r\n",
    "solutions": [
        "#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4\")\n\n#define _CRT_SECURE_NO_WARNINGS\n# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_map>\n# include <unordered_set>\n\n//#ifdef LOCAL0000\n//# include <opencv2/core/core.hpp>\n//# include <opencv2/highgui/highgui.hpp>\n//# include <opencv2/imgproc/imgproc.hpp>\n//#endif\n\nusing namespace std;\n\n#define VA_NUM_ARGS(...) VA_NUM_ARGS_IMPL_((0,__VA_ARGS__, 6,5,4,3,2,1))\n#define VA_NUM_ARGS_IMPL_(tuple) VA_NUM_ARGS_IMPL tuple\n#define VA_NUM_ARGS_IMPL(_0,_1,_2,_3,_4,_5,_6,N,...) N\n#define macro_dispatcher(macro, ...) macro_dispatcher_(macro, VA_NUM_ARGS(__VA_ARGS__))\n#define macro_dispatcher_(macro, nargs) macro_dispatcher__(macro, nargs)\n#define macro_dispatcher__(macro, nargs) macro_dispatcher___(macro, nargs)\n#define macro_dispatcher___(macro, nargs) macro ## nargs\n#define DBN1(a)           cerr<<#a<<\"=\"<<(a)<<\"\\n\"\n#define DBN2(a,b)         cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\"\\n\"\n#define DBN3(a,b,c)       cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\"\\n\"\n#define DBN4(a,b,c,d)     cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\", \"<<#d<<\"=\"<<(d)<<\"\\n\"\n#define DBN5(a,b,c,d,e)   cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\", \"<<#d<<\"=\"<<(d)<<\", \"<<#e<<\"=\"<<(e)<<\"\\n\"\n#define DBN6(a,b,c,d,e,f) cerr<<#a<<\"=\"<<(a)<<\", \"<<#b<<\"=\"<<(b)<<\", \"<<#c<<\"=\"<<(c)<<\", \"<<#d<<\"=\"<<(d)<<\", \"<<#e<<\"=\"<<(e)<<\", \"<<#f<<\"=\"<<(f)<<\"\\n\"\n#define DBN(...) macro_dispatcher(DBN, __VA_ARGS__)(__VA_ARGS__)\n#define DA(a,n) cerr<<#a<<\"=[\"; printarray(a,n); cerr<<\"]\\n\"\n#define DAR(a,n,s) cerr<<#a<<\"[\"<<s<<\"-\"<<n-1<<\"]=[\"; printarray(a,n,s); cerr<<\"]\\n\"\n\n#ifdef _MSC_VER\n#define PREFETCH(ptr, rw, level) ((void)0)\n#else\n#define PREFETCH(ptr, rw, level) __builtin_prefetch(ptr, rw, level)\n#endif\n\n#if defined _MSC_VER\n#define ASSUME(condition) ((void)0)\n#define __restrict\n#elif defined __clang__\n#define ASSUME(condition)       __builtin_assume(condition)\n#elif defined __GNUC__\n[[noreturn]] __attribute__((always_inline)) inline void undefinedBehaviour() {}\n#define ASSUME(condition)       ((condition) ? true : (undefinedBehaviour(), false))\n#endif\n\n#ifdef LOCAL\n#define CURTIME() cerr << clock() * 1.0 / CLOCKS_PER_SEC << endl\n#else\n#define CURTIME()\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vll;\ntypedef int itn;\n\ntemplate<class T1, class T2, class T3>\nstruct triple{ T1 a; T2 b; T3 c; triple() : a(T1()), b(T2()), c(T3()) {}; triple(T1 _a, T2 _b, T3 _c) :a(_a), b(_b), c(_c){} };\ntemplate<class T1, class T2, class T3>\nbool operator<(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a<t2.a;else if(t1.b!=t2.b)return t1.b<t2.b;else return t1.c<t2.c;}\ntemplate<class T1, class T2, class T3>\nbool operator>(const triple<T1,T2,T3>&t1,const triple<T1,T2,T3>&t2){if(t1.a!=t2.a)return t1.a>t2.a;else if(t1.b!=t2.b)return t1.b>t2.b;else return t1.c>t2.c;}\n#define tri triple<int,int,int>\n#define trll triple<ll,ll,ll>\n\n#define FI(n) for(int i=0;i<(n);++i)\n#define FJ(n) for(int j=0;j<(n);++j)\n#define FK(n) for(int k=0;k<(n);++k)\n#define FL(n) for(int l=0;l<(n);++l)\n#define FQ(n) for(int q=0;q<(n);++q)\n#define FOR(i,a,b) for(int i = (a), __e = (int) (b); i < __e; ++i)\n#define all(a) std::begin(a), std::end(a)\n#define reunique(v) v.resize(std::unique(v.begin(), v.end()) - v.begin())\n\n#define sqr(x) ((x) * (x))\n#define sqrt(x) sqrt(1.0 * (x))\n#define pow(x, n) pow(1.0 * (x), n)\n\n#define COMPARE(obj) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b)\n#define COMPARE_BY(obj, field) [&](const std::decay_t<decltype(obj)>& a, const std::decay_t<decltype(obj)>& b) { return a.field < b.field; }\n\n#define checkbit(n, b) (((n) >> (b)) & 1)\n#define setbit(n, b) ((n) | (static_cast<std::decay<decltype(n)>::type>(1) << (b)))\n#define removebit(n, b) ((n) & ~(static_cast<std::decay<decltype(n)>::type>(1) << (b)))\n#define flipbit(n, b) ((n) ^ (static_cast<std::decay<decltype(n)>::type>(1) << (b)))\ninline int countBits(uint v){v=v-((v>>1)&0x55555555);v=(v&0x33333333)+((v>>2)&0x33333333);return((v+(v>>4)&0xF0F0F0F)*0x1010101)>>24;}\ninline int countBits(ull v){uint t=v>>32;uint p=(v & ((1ULL << 32) - 1)); return countBits(t) + countBits(p); }\ninline int countBits(ll v){return countBits((ull)v); }\ninline int countBits(int v){return countBits((uint)v); }\nunsigned int reverseBits(uint x){ x = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1)); x = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2)); x = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4)); x = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8)); return((x >> 16) | (x << 16)); }\ntemplate<class T> inline int sign(T x){ return x > 0 ? 1 : x < 0 ? -1 : 0; }\ninline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); }\nconstexpr ll power(ll x, int p) { return p == 0 ? 1 : (x * power(x, p - 1)); }\ntemplate<class T>\ninline bool inRange(const T& val, const T& min, const T& max) { return min <= val && val <= max; }\n//template<class T1, class T2, class T3> T1 inline clamp(T1 x, const T2& a, const T3& b) { if (x < a) return a; else if (x > b) return b; else return x; }\nunsigned long long rdtsc() { unsigned long long ret = 0;\n#ifdef __clang__\n    return __builtin_readcyclecounter();\n#endif\n#ifndef _MSC_VER\n    asm volatile(\"rdtsc\" : \"=A\" (ret) : :);\n#endif\n    return ret; }\n// Fast IO ********************************************************************************************************\nconst int __BS = 4096;\nstatic char __bur[__BS + 16], *__er = __bur + __BS, *__ir = __er;\ntemplate<class T = int> T readInt() {\n    auto c = [&]() { if (__ir == __er) std::fill(__bur, __bur + __BS, 0), cin.read(__bur, __BS), __ir = __bur; };\n    c(); while (*__ir && (*__ir < '0' || *__ir > '9') && *__ir != '-') ++__ir; c();\n    bool m = false; if (*__ir == '-') ++__ir, c(), m = true;\n    T r = 0; while (*__ir >= '0' && *__ir <= '9') r = r * 10 + *__ir - '0', ++__ir, c();\n    ++__ir; return m ? -r : r;\n}\nstring readString() {\n    auto c = [&]() { if (__ir == __er) std::fill(__bur, __bur + __BS, 0), cin.read(__bur, __BS), __ir = __bur; };\n    string r; c(); while (*__ir && isspace(*__ir)) ++__ir, c();\n    while (!isspace(*__ir)) r.push_back(*__ir), ++__ir, c();\n    ++__ir; return r;\n}\nchar readChar() {\n    auto c = [&]() { if (__ir == __er) std::fill(__bur, __bur + __BS, 0), cin.read(__bur, __BS), __ir = __bur; };\n    c(); while (*__ir && isspace(*__ir)) ++__ir, c(); return *__ir++;\n}\nstatic char __buw[__BS + 20], *__iw = __buw, *__ew = __buw + __BS;\ntemplate<class T>\nvoid writeInt(T x, char endc = '\\n') {\n    if (x < 0) *__iw++ = '-', x = -x; if (x == 0) *__iw++ = '0';\n    char* s = __iw;\n    while (x) { T t = x / 10; char c = x - 10 * t + '0'; *__iw++ = c; x = t; }\n    char* f = __iw - 1; while (s < f) swap(*s, *f), ++s, --f;\n    if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw;\n    if (endc) { *__iw++ = endc; }\n}\ntemplate<class T>\nvoid writeStr(const T& str) {\n    int i = 0; while (str[i]) { *__iw++ = str[i++]; if (__iw > __ew) cout.write(__buw, __iw - __buw), __iw = __buw; }\n}\nstruct __FL__ { ~__FL__() { if (__iw != __buw) cout.write(__buw, __iw - __buw); } };\nstatic __FL__ __flushVar__;\n\n//STL output *****************************************************************************************************\n#define TT1 template<class T>\n#define TT1T2 template<class T1, class T2>\n#define TT1T2T3 template<class T1, class T2, class T3>\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p);\nTT1 ostream& operator << (ostream& os, const vector<T>& v);\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, const multiset<T1, T2>&v);\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v);\nTT1T2T3 ostream& operator << (ostream& os, const map<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const multimap<T1, T2, T3>& v);\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t);\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v);\nTT1T2 ostream& operator << (ostream& os, const pair<T1, T2>& p){ return os <<\"(\"<<p.first<<\", \"<< p.second<<\")\"; }\nTT1 ostream& operator << (ostream& os, const vector<T>& v){       bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\ntemplate<class T, size_t N> ostream& operator << (ostream& os, const array<T, N>& v) {     bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, const set<T1, T2>&v){    bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, const multiset<T1,T2>&v){bool f=1;os<<\"[\";for(auto& i : v) { if (!f)os << \", \";os<<i;f=0;}return os << \"]\"; }\nTT1T2T3 ostream& operator << (ostream& os, const map<T1,T2,T3>& v){ bool f = 1; os << \"[\"; for (auto& ii : v) { if (!f)os << \", \"; os << \"(\" << ii.first << \" -> \" << ii.second << \") \"; f = 0; }return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, const multimap<T1, T2>& v){ bool f = 1; os << \"[\"; for (auto& ii : v) { if (!f)os << \", \"; os << \"(\" << ii.first << \" -> \" << ii.second << \") \"; f = 0; }return os << \"]\"; }\nTT1T2 ostream& operator << (ostream& os, priority_queue<T1, T2> v) { bool f = 1; os << \"[\"; while (!v.empty()) { auto x = v.top(); v.pop(); if (!f) os << \", \"; f = 0; os << x; } return os << \"]\"; }\nTT1T2T3 ostream& operator << (ostream& os, const triple<T1, T2, T3>& t){ return os << \"(\" << t.a << \", \" << t.b << \", \" << t.c << \")\"; }\nTT1T2 void printarray(const T1& a, T2 sz, T2 beg = 0){ for (T2 i = beg; i<sz; i++) cout << a[i] << \" \"; cout << endl; }\n\n//STL input *****************************************************************************************************\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t);\nTT1T2 inline istream& operator >> (istream& os, pair<T1, T2>& p) { return os >> p.first >> p.second; }\nTT1 inline istream& operator >> (istream& os, vector<T>& v) {\n    if (v.size()) for (T& t : v) os >> t; else {\n        string s; T obj; while (s.empty()) {getline(os, s); if (!os) return os;}\n        stringstream ss(s); while (ss >> obj) v.push_back(obj);\n    }\n    return os;\n}\nTT1T2T3 inline istream& operator >> (istream& os, triple<T1, T2, T3>& t) { return os >> t.a >> t.b >> t.c; }\n\n//Pair magic *****************************************************************************************************\n#define PT1T2 pair<T1, T2>\nTT1T2 inline PT1T2 operator+(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first + p2.first, p1.second + p2.second); }\nTT1T2 inline PT1T2& operator+=(PT1T2 &p1 , const PT1T2 &p2) { p1.first += p2.first, p1.second += p2.second; return p1; }\nTT1T2 inline PT1T2 operator-(const PT1T2 &p1 , const PT1T2 &p2) { return PT1T2(p1.first - p2.first, p1.second - p2.second); }\nTT1T2 inline PT1T2& operator-=(PT1T2 &p1 , const PT1T2 &p2) { p1.first -= p2.first, p1.second -= p2.second; return p1; }\n\n#undef TT1\n#undef TT1T2\n#undef TT1T2T3\n\n#define FREIN(FILE) freopen(FILE, \"rt\", stdin)\n#define FREOUT(FILE) freopen(FILE, \"wt\", stdout)\n#ifdef LOCAL\n#define BEGIN_PROFILE(idx, name) int profileIdx = idx; profileName[profileIdx] = name; totalTime[profileIdx] -= rdtsc() / 1e3;\n#define END_PROFILE totalTime[profileIdx] += rdtsc() / 1e3; totalCount[profileIdx]++;\n#else\n#define BEGIN_PROFILE(idx, name)\n#define END_PROFILE\n#endif\n\nconst int USUAL_MOD = 1000000007;\ntemplate<class T> inline void normmod(T &x, T m = USUAL_MOD) { x %= m; if (x < 0) x += m; }\ntemplate<class T1, class T2> inline T2 summodfast(T1 x, T1 y, T2 m = USUAL_MOD) { T2 res = x + y; if (res >= m) res -= m; return res; }\ntemplate<class T1, class T2, class T3 = int> inline void addmodfast(T1 &x, T2 y, T3 m = USUAL_MOD) { x += y; if (x >= m) x -= m; }\ntemplate<class T1, class T2, class T3 = int> inline void submodfast(T1 &x, T2 y, T3 m = USUAL_MOD) { x -= y; if (x < 0) x += m; }\ninline ll mulmod(ll x, ll n, ll m){ x %= m; n %= m; ll r = x * n - ll(ld(x)*ld(n) / ld(m)) * m; while (r < 0) r += m; while (r >= m) r -= m; return r; }\ninline ll powmod(ll x, ll n, ll m){ ll r = 1; normmod(x, m); while (n){ if (n & 1) r *= x; x *= x; r %= m; x %= m; n /= 2; }return r; }\ninline ll powmulmod(ll x, ll n, ll m) { ll res = 1; normmod(x, m); while (n){ if (n & 1)res = mulmod(res, x, m); x = mulmod(x, x, m); n /= 2; } return res; }\ntemplate<class T> inline T gcd(T a, T b) { while (b) { T t = a % b; a = b; b = t; } return a; }\ntemplate<class T>\nT fast_gcd(T u, T v) {\n    int shl = 0; while ( u && v && u != v) { T eu = u & 1; u >>= eu ^ 1; T ev = v & 1; v >>= ev ^ 1;\n        shl += (~(eu | ev) & 1); T d = u & v & 1 ? (u + v) >> 1 : 0; T dif = (u - v) >> (sizeof(T) * 8 - 1); u -= d & ~dif; v -= d & dif;\n    } return std::max(u, v) << shl;\n}\n\ninline ll lcm(ll a, ll b){ return a / gcd(a, b) * b; }\ntemplate<class T> inline T gcd(T a, T b, T c){ return gcd(gcd(a, b), c); }\nll gcdex(ll a, ll b, ll& x, ll& y) {\n    if (!a) { x = 0; y = 1; return b; }\n    ll y1; ll d = gcdex(b % a, a, y, y1); x = y1 - (b / a) * y;\n    return d;\n}\ntemplate<class T> bool isPrime(T x) { if (x <= 4 || x % 2 == 0 || x % 3 == 0) return x == 2 || x == 3;\n    for (T i = 5; i * i <= x; i += 6) if (x % i == 0 || x % (i + 2) == 0) return 0; return 1; }\nbool millerRabin(long long n) {\n    if (n <= 1000) return isPrime(n);\n    long long s = n - 1; int t = 0; while (s % 2 == 0) s /= 2, ++t;\n    for (int a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) { if (!(a %= n)) return true;\n        long long f = powmulmod(a, s, n); if (f == 1 || f == n - 1) continue;\n        for (int i = 1; i < t; ++i) if ((f = mulmod(f, f, n)) == n - 1) goto nextp;\n        return false; nextp:;\n    } return true;\n}\n\n// Useful constants\n\n//int some_primes[7] = {24443, 100271, 1000003, 1000333, 5000321, 98765431,\n#define T9          1000000000\n#define T18         1000000000000000000LL\n#define INF         1011111111\n#define LLINF       1000111000111000111LL\n#define mod         1000000007\n#define fftmod      998244353\n#define EPS         (double)1e-10\n#define PI          3.14159265358979323846264\n#define link        asaxlajrewqwe\n#define rank        wahayawehasdakw\n//*************************************************************************************\n\n\nint32_t solve();\nint32_t main(int argc, char** argv) {\n    ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef LOCAL\n    FREIN(\"input.txt\");\n//    FREOUT(\"out.txt\");\n#endif\n    return solve();\n}\n\nstruct Node {\n    ll sum;\n    int cnt;\n    Node *lp, *rp;\n};\nNode nodes[202020 * 32];\nvector<Node*> nodePool;\nvoid delNode(Node* node) {\n    nodePool.push_back(node);\n}\nNode* newNode() {\n    if (!nodePool.empty()) {\n        auto res = nodePool.back();\n        nodePool.pop_back();\n        res->sum = 0;\n        res->cnt = 0;\n        res->lp = nullptr;\n        res->rp = nullptr;\n        return res;\n    }\n    static Node* lastn = nodes;\n    return lastn++;\n}\nvoid add(Node *&cur, int l, int r, int b) {\n    if (!cur) {\n        cur = newNode();\n    }\n    cur->cnt++;\n    cur->sum += b;\n    if (l != r) {\n        int m = (l + r) / 2;\n        if (b <= m) {\n            add(cur->lp, l, m, b);\n        } else {\n            add(cur->rp, m + 1, r, b);\n        }\n    }\n}\npair<ll, int> getSum(Node* cur, int l, int r, int b) {\n    if (!cur || l > b) return {0, 0};\n    if (r <= b) return {cur->sum, cur->cnt};\n    int m = (l + r) / 2;\n    return getSum(cur->lp, l, m, b) + getSum(cur->rp, m + 1, r, b);\n}\nvoid print(Node *cur, int l, int r, int a) {\n    if (!cur) return;\n    if (l == r) {\n        cout << \"(\" << a << \",\" << cur->sum << \"), \";\n    } else {\n        int m = (l + r) / 2;\n        print(cur->rp, m + 1, r, a);\n        a += cur->rp ? cur->rp->cnt : 0;\n        print(cur->lp, l, m, a);\n    }\n}\nll ans = 0;\nint n;\nstruct Tree {\n    int fromA;\n    int toA;\n    Node *root = nullptr;\n    void insert(int a, int b) {\n        if (!root) {\n            fromA = a;\n            toA = a;\n            add(root, 1, n, b);\n            return;\n        }\n        auto p = getSum(root, 1, n, b);\n        if (a < fromA) {\n            --fromA;\n            ans -= root->sum;\n        } else {\n            ++toA;\n        }\n        add(root, 1, n, b);\n        int where = toA - p.second;\n        ans += p.first;\n        ans -= b * 1LL * (a - where);\n    }\n    int size() {\n        return root ? root->cnt : 0;\n    }\n};\ntemplate<bool order>\nvoid mergeTo(Node *cur, int l, int r, int a, Tree& where) {\n    if (!cur) return;\n    if (l == r) {\n        where.insert(a, (int)cur->sum);\n    } else {\n        int m = (l + r) / 2;\n        if (order) {\n            mergeTo<order>(cur->lp, l, m, a, where);\n            a -= cur->lp ? cur->lp->cnt : 0;\n            mergeTo<order>(cur->rp, m + 1, r, a, where);\n        } else {\n            mergeTo<order>(cur->rp, m + 1, r, a, where);\n            a += cur->rp ? cur->rp->cnt : 0;\n            mergeTo<order>(cur->lp, l, m, a, where);\n        }\n    }\n    delNode(cur);\n}\nbool operator<(const Tree &t1, const Tree& t2) {\n    return t1.fromA < t2.fromA;\n}\nTree merge(Tree a, Tree b) {\n    if (a.size() > b.size()) {\n        mergeTo<0>(b.root, 1, n, b.fromA, a);\n        return a;\n    } else {\n        mergeTo<1>(a.root, 1, n, a.toA, b);\n        return b;\n    }\n}\npii p[202002];\nint solve() {\n    cin >> n;\n    set<Tree> s;\n    FI(n) {\n        int a, b;\n        cin >> a >> b;\n        Tree t;\n        t.insert(a, b);\n        while (true) {\n            auto it = s.lower_bound(t);\n            if (it != s.end() && it->fromA <= t.toA + 1) {\n                auto tree = *it;\n                s.erase(it);\n                t = merge(t, tree);\n            } else if (it != s.begin() && (--it)->toA >= t.fromA - 1) {\n                auto tree = *it;\n                s.erase(it);\n                t = merge(tree, t);\n            } else {\n                s.insert(t);\n                break;\n            }\n        }\n        cout << ans << '\\n';\n    }\n    \n    return 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "greedy"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Distinctification.json",
    "editorial_link": "https://codeforces.com//blog/entry/61969",
    "editorial": "Letâs firstly try to come up with some naive solution.Suppose we have a\r\nlist and want to calculate for it. Letâs sort this list, comparing the\r\npairs by their values of , and then process them one-by-one. We will\r\ndivide this list into some parts (we will call them ) with the following\r\nprocess: when processing the first pair in the sorted order, letâs\r\niterate on the next pairs (also in the sorted order) and add them to the\r\nfirst pairâs component until the following condition is met: , where is\r\nthe index of the first pair we added, and is the index of the pair we\r\nare currently trying to add to âs component (remember that we consider\r\nall these pairs in the sorted order).What is the meaning of this\r\ncondition? means that the number of pairs between and (including these\r\ntwo) is not less that the number of integers in and while this condition\r\nis met, we can use the first operation in order to make a pair having\r\nfor every . And the first time when the condition is met, we obviously\r\ncannot \"expand\" the segment in such a way. It means that the -value of\r\nwill always be greater than -value of , and wonât belong to the same\r\ncomponent with (and will start creating its own component instead).These\r\ncomponents we form have one special property. Suppose we \"expanded\" the\r\ncomponent so that there are no two equal values of in it. Then we may\r\nreorder the pairs in this component as we wish (to do so, we may\r\n\"contract\" the component using the second operation, and then \"expand\"\r\nit again). Of course, the best course of action is to sort the pairs in\r\nthe component by their values of in descending order. After doing this\r\nfor every component, we will obtain an optimal configuration such that\r\nall values of are distinct, and itâs easy to calculate the answer.Okay,\r\nnow we need to do it fast. The following will help us: DSU; Some\r\nimplicit logarithmic data structure (the operations we need are \"count\r\nthe sum of elements less than \" and \"count the number of elements\r\ngreater than \"; your implementation might use other operations);\r\nSmall-to-large merging. DSU will help us maintain the components. A data\r\nstructre will be built for each component containing the values of in\r\nit; it will help us to maintain the sum of , where is the optimal index\r\nof in this component. Depending on your implementation, you may or may\r\nnot need to store the minimum value of in the component. When inserting\r\nsome element having into some component, the elements having donât\r\nchange their position, the new element will be added right after them,\r\nand the remaining elements will be shifted to the right; so the sum of\r\ncan be maintained if we query the number of elements greater than and\r\nthe sum of elements less than .Okay, but we still donât know how we\r\ncreate the components and how we determine if two components are to\r\nmerge. We will keep these components in \"expanded\" form; that is, when\r\nprocessing a pair , letâs find the leftmost unoccupied position after\r\n(or , if it is not occupied) and occupy it with the new pair, creating a\r\nnew component for it. If the newly occupied index is , letâs try to\r\nmerge new component with components occupying and (if there are any); to\r\nmerge two components, do the required operations in DSU and unite the\r\ndata structures built in these components with small-to-large method.All\r\nthis works in , the most time-consuming part is merging the data\r\nstructures.\r\n",
    "hint": []
}