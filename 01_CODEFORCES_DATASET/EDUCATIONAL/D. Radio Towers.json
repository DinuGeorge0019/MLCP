{
    "link": "https://codeforces.com//contest/1452/problem/D",
    "problemId": "802107",
    "problem_idx": "D",
    "shortId": "1452D",
    "contest_number": "1452",
    "problem_submissions": {
        "F": [
            98942480,
            98939437,
            98940434,
            106494164,
            106494140,
            98942341,
            98945383,
            98935697,
            98927001,
            98944945,
            98934044,
            98976764,
            99270253
        ],
        "E": [
            98926708,
            98926305,
            98923150,
            98930994,
            98926114,
            98927253,
            98926662,
            99001021,
            98943947,
            99042260,
            98926234,
            98930834,
            98943700,
            98921374,
            98925742,
            98930269,
            98929950,
            98918489,
            98928745,
            98929548
        ],
        "D": [
            98906301,
            98909937,
            98915472,
            98909763,
            98919427,
            98912085,
            99000804,
            98903628,
            98909739,
            98911723,
            98911927,
            98913556,
            98901042,
            98908884,
            98907045,
            98910263,
            98910231,
            98913804,
            98909129
        ],
        "C": [
            98899318,
            98901635,
            98905651,
            98903381,
            98906519,
            98900085,
            98896987,
            98906559,
            98901684,
            98905788,
            98906611,
            98898047,
            98901391,
            98899348,
            98900377,
            98902439,
            98902965,
            98898261
        ],
        "B": [
            98897777,
            98898220,
            98901029,
            98900303,
            98904013,
            98898005,
            99000726,
            99000688,
            98978607,
            98898951,
            98904401,
            98905057,
            98908639,
            98904166,
            98896699,
            98898174,
            98897853,
            98902989,
            98899546,
            98900510,
            98903751
        ],
        "A": [
            98895449,
            98895686,
            98896660,
            98896462,
            98897246,
            98895467,
            98895360,
            98896351,
            100779606,
            98895507,
            98904547,
            98896942,
            98895363,
            98895604,
            98895575,
            98895460,
            98903659,
            98895637,
            98896531
        ],
        "G": [
            99251139,
            98943421,
            99550385,
            99358496,
            99358463,
            99358399,
            99296629,
            99296419,
            99053359,
            99052180,
            98944458,
            98945555,
            99287849
        ]
    },
    "name": "D. Radio Towers",
    "statement": "There are n + 2 towns located on a coordinate line, numbered from 0 to\r\nn + 1. The i-th town is located at the point i.You build a radio tower\r\nin each of the towns 1, 2,\r\ndots, n with probability\r\nfrac{1}{2} (these events are independent). After that, you want to set\r\nthe signal power on each tower to some integer from 1 to n (signal\r\npowers are not necessarily the same, but also not necessarily\r\ndifferent). The signal from a tower located in a town i with signal\r\npower p reaches every city c such that |c - i| < p.After building the\r\ntowers, you want to choose signal powers in such a way that: towns 0 and\r\nn + 1 don’t get any signal from the radio towers; towns 1, 2,\r\ndots, n get signal from one radio tower each. For example, if n = 5, and\r\nyou have built the towers in towns 2, 4 and 5, you may set the signal\r\npower of the tower in town 2 to 2, and the signal power of the towers in\r\ntowns 4 and 5 to 1. That way, towns 0 and n + 1 don’t get the signal\r\nfrom any tower, towns 1, 2 and 3 get the signal from the tower in town\r\n2, town 4 gets the signal from the tower in town 4, and town 5 gets the\r\nsignal from the tower in town 5.Calculate the probability that, after\r\nbuilding the towers, you will have a way to set signal powers to meet\r\nall constraints.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 998244353;\n\nint N;\nll X = (MOD + 1) / 2;\n\nint main() {\n\tscanf(\"%d\", &N);\n\tif(N == 1) { printf(\"%lld\\n\", X); return 0; }\n\tll a = X, b = 1;\n\tll t;\n\tfor(int i = 2; i <= N; i++) {\n\t\tt = a * X % MOD;\n\t\tb = (t + b * X % MOD * X) % MOD;\n\t\tswap(a, b);\n\t}\n\tprintf(\"%lld\\n\", t);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "1600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Radio Towers.json",
    "editorial_link": "https://codeforces.com//blog/entry/84847",
    "editorial": "The crucial observation is that when the positions of towers are fixed,\r\nthe way to set their signal powers is unique if it exists. Thatâs\r\nbecause the first tower should have its signal power exactly equal to\r\nthe required to cover all towns before it, the second tower should have\r\nsignal power exactly equal to the required to cover all towns before it\r\nthat werenât covered by the first one, and so on. So letâs count the\r\nnumber of ways to cover all towns, and then divide it by .Covering all\r\ntowns can be expressed as splitting into the sum of several positive odd\r\nintegers. It can be calculated with dynamic programming with prefix\r\nsums, but we can also prove that the number of ways to split is exactly\r\nthe -th integer in the Fibonacci sequence as follows (this proof uses\r\nmathematical induction): for , itâs quite obvious; for and , letâs\r\niterate on the length of the last segment. We have to sum ; ; ; , and so\r\non, until we get ; for and , letâs iterate on the length of the last\r\nsegment, and add to result since we can cover everything with a single\r\nsegment. So, this is . , , and so on. So, the answer to the problem is\r\n.The last thing we have to consider is that we have to print a fraction\r\nmodulo . Since is a prime, using Fermat little theorem, we can calculate\r\nas . Exponentiation must be done with some fast algorithm (for example,\r\nbinary exponentiation).Note: itâs common in problems requiring to\r\ncalculate something modulo some prime number to have problems with\r\noverflow in intermediate calculations or some other issues when we\r\nforget to take the result of some expression modulo . I recommend using\r\neither special addition/multiplication/exponentiation functions that\r\nalways take the result modulo (an example how to write and use them can\r\nbe viewed in the model solution), or a special modular integer data\r\nstructure with overloaded operators that you have to implement by\r\nyourself.\r\n",
    "hint": []
}