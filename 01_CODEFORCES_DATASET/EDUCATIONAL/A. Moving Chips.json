{
    "link": "https://codeforces.com//contest/1923/problem/A",
    "problemId": "2492664",
    "problem_idx": "A",
    "shortId": "1923A",
    "contest_number": "1923",
    "problem_submissions": {
        "F": [
            247927445,
            247926735,
            247941699,
            247942342,
            247957925,
            247930359,
            247950515,
            247952641,
            247961910,
            247957616,
            247954803,
            247957462,
            247965318,
            247958101,
            247966724,
            247961269,
            247975649,
            247970780
        ],
        "E": [
            247910260,
            247907637,
            247944549,
            247918053,
            247922522,
            247916787,
            247955209,
            247923339,
            247906437,
            247924189,
            247923801,
            247924733,
            247919146,
            247919411,
            247915457,
            248010348,
            247930116,
            247913617,
            247921891,
            247928453
        ],
        "D": [
            247906663,
            247903362,
            247909256,
            247913572,
            247912411,
            247905740,
            247917150,
            247917832,
            247911096,
            247917233,
            247917212,
            247913338,
            247913589,
            247931525,
            247913875,
            247917151,
            247917274,
            247912599
        ],
        "C": [
            247899621,
            247896441,
            247899387,
            247904054,
            247903940,
            247899293,
            247903341,
            247912953,
            247900198,
            247901509,
            247906201,
            247902190,
            247904629,
            247901902,
            247905627,
            247901567,
            247905304,
            247903364
        ],
        "B": [
            247895420,
            247893401,
            247895016,
            247899339,
            247899002,
            247894634,
            247896319,
            247907358,
            247897312,
            247896352,
            247897008,
            247896401,
            247900980,
            247897119,
            247897848,
            247898814,
            247898339,
            247898930
        ],
        "A": [
            247893064,
            247892642,
            247892787,
            247894650,
            247893381,
            247892909,
            247892866,
            247905142,
            247893155,
            247893038,
            247892799,
            247892722,
            247896270,
            247892907,
            247893359,
            247893598,
            247893062,
            247896053
        ]
    },
    "name": "A. Moving Chips",
    "statement": "There is a ribbon divided into n cells, numbered from 1 to n from left\r\nto right. Each cell either contains a chip or is free.You can perform\r\nthe following operation any number of times (possibly zero): choose a\r\nchip and move it to the . You can choose any chip that you want,\r\nprovided that there is at least one free cell to the left of it. When\r\nyou move the chip, the cell where it was before the operation becomes\r\nfree.Your goal is to move the chips in such a way that . What is the\r\nminimum number of operations you have to perform?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    int l = 0, r = n - 1;\n    while (a[l] == 0) {\n        l++;\n    }\n    while (a[r] == 0) {\n        r--;\n    }\n    int ans = std::count(a.begin() + l, a.begin() + r, 0);\n    std::cout << ans << \"\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Moving Chips.json",
    "editorial_link": "https://codeforces.com//blog/entry/126339",
    "editorial": "Denote the position of the leftmost chip as , the position of the\r\nrightmost chip as , and the number of chips as .Having all chips in one\r\nblock without free spaces means that we need to reach the situation when\r\n. Since is always met (the situation when is when the chips are packed\r\nas close as possible), we need to decrease the value of as fast as\r\npossible.There are two approaches to do it. One is to try decreasing\r\nevery time; i. e. let\u00e2\u0080\u0099s code a greedy solution that always applies an\r\noperation to the current rightmost chip. This is actually one of the\r\ncorrect solutions to the problem.But if we prove it, we can design an\r\neasier solution. Whenever we apply an operation on any chip other than\r\nthe rightmost chip, the value of does not decrease (we either don\u00e2\u0080\u0099t\r\nchange and at all, or decrease ). But whenever we apply an operation on\r\nthe rightmost chip, decreases by exactly (the new rightmost chip will be\r\nin position either it is present there before the operation, or it will\r\nbe moved there from ). So, only applying the operations to the rightmost\r\nchip decreases , and it always decreases by exactly no matter what. So,\r\nthe answer to the problem is actually .\r\n"
}