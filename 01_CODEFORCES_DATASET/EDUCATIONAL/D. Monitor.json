{
    "link": "https://codeforces.com//contest/846/problem/D",
    "problemId": "121000",
    "problem_idx": "D",
    "shortId": "846D",
    "contest_number": "846",
    "problem_submissions": {
        "F": [
            30108156,
            30107162,
            30106647,
            30108328,
            30107786,
            30107476,
            30108023,
            30105549,
            30105678,
            30108397,
            30109633,
            30109280,
            30109385,
            30107975,
            30110238,
            30108732,
            30108760,
            30110164
        ],
        "E": [
            30107342,
            30108640,
            30109160,
            30110715,
            30110194,
            30109970,
            30108774,
            30110412,
            30109505,
            30110880,
            30108739,
            30110755,
            30111630,
            30111870,
            30111911,
            30111723,
            30113425,
            30111880
        ],
        "D": [
            30105892,
            30106073,
            30106673,
            30106266,
            30106933,
            30108722,
            30106872,
            30105786,
            30108926,
            30106473,
            30106803,
            30107029,
            30107512,
            30108104,
            30109714,
            30108207,
            30110001,
            30111074,
            30108770
        ],
        "C": [
            30105238,
            30104755,
            30105662,
            30105293,
            30106309,
            30106223,
            30104825,
            30107791,
            30105043,
            30105080,
            30106115,
            30105906,
            30106686,
            30106808,
            30107246,
            30107701,
            30107036,
            30107208
        ],
        "B": [
            30103719,
            30103777,
            30104242,
            30103580,
            30104340,
            30105094,
            30103843,
            30104470,
            30103928,
            30103957,
            30104536,
            30104441,
            30104836,
            30104758,
            30104309,
            30105851,
            30104847,
            30105774
        ],
        "A": [
            30103161,
            30103232,
            30103250,
            30103170,
            30103456,
            30103369,
            30103168,
            30103235,
            30103196,
            30103253,
            30103176,
            30103313,
            30103584,
            30103300,
            30103249,
            30104174,
            30103638,
            30104542
        ]
    },
    "name": "D. Monitor",
    "statement": "Recently Luba bought a monitor. Monitor is a rectangular matrix of size\r\n. But then she started to notice that some pixels cease to work\r\nproperly. Luba thinks that the monitor will become broken the first\r\nmoment when it contains a square consisting entirely of broken pixels.\r\nShe knows that pixels are already broken, and for each of them she knows\r\nthe moment when it stopped working. Help Luba to determine when the\r\nmonitor became broken (or tell that it’s still not broken even after all\r\npixels stopped working).\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define N 514\n#define Q (N * N)\nint n , m , k , q , x[ Q ] , y[ Q ] , t[ Q ];\nint s[ N ][ N ] , c[ N ][ N ];\nbool broken( int cur ){\n  for( int i = 0 ; i <= n ; i ++ )\n    for( int j = 0 ; j <= m ; j ++ )\n      c[ i ][ j ] = 0;\n  for( int i = 0 ; i < q ; i ++ )\n    if( t[ i ] <= cur )\n      c[ x[ i ] ][ y[ i ] ] = 1;\n  for( int i = 1 ; i <= n ; i ++ )\n    for( int j = 1 ; j <= m ; j ++ )\n      if( c[ i ][ j ] ){\n        s[ i ][ j ] = min( s[ i - 1 ][ j ] ,\n                           min( s[ i ][ j - 1 ] , s[ i - 1 ][ j - 1 ] ) ) + 1;\n        if( s[ i ][ j ] >= k )\n          return true;\n      }else\n        s[ i ][ j ] = 0;\n  return false;\n}\nint main(){\n  cin >> n >> m >> k >> q;\n  for( int i = 0 ; i < q ; i ++ )\n    cin >> x[ i ] >> y[ i ] >> t[ i ];\n  int bl = 0 , br = 1000000000 , ba = -1;\n  while( bl <= br ){\n    int bmid = (bl + br) >> 1;\n    if( broken( bmid ) ) ba = bmid , br = bmid - 1;\n    else bl = bmid + 1;\n  }\n  cout << ba << endl;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Monitor.json",
    "editorial_link": "https://codeforces.com//blog/entry/54357",
    "editorial": "At first letâs sort broken pixels in non-descending order by times they\r\nappear.Obviously, if the first broken pixels make monitor broken, pixel\r\nwonât fix it.Thus, binary search on answer will work. Letâs search for\r\nthe first moment in time when the monitor becomes broken. The function\r\nto check if in some moment monitor is broken looks the following way.As\r\nwe want to check if there is a submatrix of size , which consists only\r\nof broken pixels, letâs precalc the array of partial sums , is the\r\nnumber of broken pixels on submatrix from to . is calculated as ( if is\r\nbroken pixel, otherwise) . Sum on submatrix of size then looks like\r\n.Check all possible and from to and find out if there exists submatrix\r\nwith sum equal to .Overall complexity: .\r\n",
    "hint": []
}