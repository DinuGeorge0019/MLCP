{
    "link": "https://codeforces.com//contest/2086/problem/C",
    "problemId": "3306522",
    "problem_idx": "C",
    "shortId": "2086C",
    "contest_number": "2086",
    "problem_submissions": {
        "F": [
            313800473,
            313815107,
            313814871,
            313816809,
            313824037,
            313823800,
            313823595,
            313823290,
            313831013,
            313847963
        ],
        "E": [
            313778103,
            313768063,
            313796531,
            313772368,
            313776096,
            313773540,
            313775500,
            313777349,
            313773743,
            313773212,
            313777394,
            313774460,
            313780281,
            313777023,
            313779749,
            313779985,
            313789675,
            313782783,
            313780927
        ],
        "D": [
            313765839,
            313760163,
            313763413,
            313762506,
            313761667,
            313764480,
            313761919,
            313762403,
            313764311,
            313768000,
            313764673,
            313765244,
            313767408,
            313766701,
            313767208,
            313767620,
            313765113,
            313765919,
            313769446
        ],
        "C": [
            313762408,
            313757321,
            313759589,
            313757952,
            313757592,
            313758776,
            313758447,
            313758249,
            313761365,
            313762216,
            313760196,
            313762012,
            313758933,
            313763649,
            313761491,
            313762919,
            313757921,
            313761818
        ],
        "B": [
            313759878,
            313752573,
            313755779,
            313754646,
            313754713,
            313753530,
            313755287,
            313755649,
            313756220,
            313750845,
            313757002,
            313758471,
            313753446,
            313758811,
            313757915,
            313759796,
            313754670,
            313758593
        ],
        "A": [
            313747124,
            313744880,
            313745589,
            313744964,
            313745790,
            313744642,
            313747626,
            313744833,
            313745066,
            313744593,
            313747501,
            313747195,
            313744587,
            313748494,
            313746594,
            313746261,
            313746218,
            313744938
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141425",
    "editorial": "Let’s take a closer look at how the operation works:Suppose we have a\r\nmissing number , we know that the final permutation must contain this\r\nnumber, and the only place we can put the number is position . However,\r\nif we place the number there, we might lose , which also needs to be\r\nplaced in the final permutation, and the only place we can put it is\r\nposition , but we might again lose some number, and so on. This process\r\nwill end when we place a number in the position of an already missing\r\nnumber.This process can be implemented either recursively or\r\niteratively, and we are only interested in the set of positions we need\r\nto fix.Let’s denote the set of all positions to be fixed as . Then we\r\ncan observe the following: if the current query is contained in , then\r\nthe union of the sets of fixable positions for and is equal to . If the\r\nquery is not contained in , then it adds some positions to the set\r\n.Based on this observation, we can write a solution. I will outline the\r\nmain points of the solution: we maintain the set ; when the query comes\r\nwith that is contained in , we do nothing and simply output the size of\r\nthe set ; when the query comes with that is not contained in , then we\r\nadd all the positions that are necessary to fix the array if is missing,\r\nand output the size of the set . The final implementation may have a\r\ncomplexity of or .\r\n",
    "name": "C. Disappearing Permutation",
    "statement": "A permutation of integers from 1 to n is an array of size n where each\r\ninteger from 1 to n appears exactly once.You are given a permutation p\r\nof integers from 1 to n. You have to process n queries. During the i-th\r\nquery, you replace p_{d_i} with 0. Each element is replaced with 0\r\nexactly once. The changes made in the queries are saved, that is, after\r\nthe i-th query, all integers p_{d_1}, p_{d_2},\r\ndots, p_{d_i} are zeroes.After each query, you have to find the minimum\r\nnumber of operations required to the array; in other words, to transform\r\nthe current array into any permutation of integers from 1 to n (possibly\r\ninto the original permutation p, possibly into some other\r\npermutation).The operation you can perform to fix the array is the\r\nfollowing one: choose the integer i from 1 to n, replace the i-th\r\nelement of the array . Note that the answer for each query is calculated\r\nindependently, meaning you do not actually apply any operations, just\r\ncalculate the minimum number of operations.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "dp",
        "dsu",
        "graphs",
        "greedy",
        "implementation"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Disappearing Permutation.json"
}