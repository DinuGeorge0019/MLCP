{
    "link": "https://codeforces.com//contest/1976/problem/B",
    "problemId": "2672918",
    "problem_idx": "B",
    "shortId": "1976B",
    "contest_number": "1976",
    "problem_submissions": {
        "F": [
            263314410,
            263323534,
            263323690,
            263325512,
            263334653,
            263331007,
            263325411,
            263343899,
            263340351,
            263335929,
            263326828,
            263332991,
            263341073,
            263348258,
            263349127,
            263349457,
            263346381,
            263355969,
            263347175,
            263342030
        ],
        "E": [
            263305882,
            263313991,
            263310881,
            263312246,
            263315063,
            263311135,
            263313445,
            263315175,
            263343942,
            263328216,
            263320417,
            263320641,
            263323277,
            263324951,
            263331673,
            263329104,
            263324699,
            263325555,
            263316314,
            263328040,
            263331822
        ],
        "C": [
            263292519,
            263287752,
            263288751,
            263286876,
            263284054,
            263285532,
            263285507,
            263293215,
            263285305,
            263285884,
            263286170,
            263285744,
            263298002,
            263303206,
            263289650,
            263291396,
            263291844,
            263302664,
            263303154,
            263303039,
            263301515
        ],
        "D": [
            263292311,
            263298587,
            263366307,
            263299064,
            263295271,
            263295241,
            263295262,
            263303840,
            263298130,
            263292787,
            263298290,
            263306115,
            263312088,
            263291555,
            263300847,
            263305912,
            263364926,
            263302707,
            263310976,
            263298729,
            263311543,
            263313366
        ],
        "B": [
            263272017,
            263272271,
            263275878,
            263272612,
            263272889,
            263274173,
            263277739,
            263274170,
            263273861,
            263276359,
            263274099,
            263279892,
            263280435,
            263273730,
            263275861,
            263277331,
            263275586,
            263274544,
            263272648,
            263279232
        ],
        "A": [
            263268782,
            263268834,
            263269741,
            263268999,
            263269168,
            263269203,
            263269867,
            263269889,
            263269156,
            263268775,
            263269596,
            263270510,
            263268758,
            263268826,
            263268756,
            263270814,
            263269912,
            263269509,
            263268983,
            263270469
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129992",
    "editorial": "Letâs fix the index of the element to be copied (denote it as ). For all\r\nother elements of the array, the number of required operations is for\r\nall .Consider the case when (similar to the case when ). There are three\r\npossible relative location of the desired element : if , you can proceed\r\nas follows: copy -th element, increase to and increase to , then the\r\nnumber of operations is equal to ; if , you can proceed as follows:\r\nincrease to , copy it, and keep increasing to , then the number of\r\noperations is equal to ; if , you can proceed as follows: increase to ,\r\ncopy -th element, and increase to , then the number of operations is\r\nequal to . As you can see, regardless of the case, is also added to the\r\nanswer. So the answer looks like this: plus some extra operations to get\r\n. That extra value is equal to the minimum value of over all indices ,\r\nwhere is equal to or or depending on the cases described above.\r\n",
    "name": "B. Increase Decrease Copy",
    "statement": "You are given two integer arrays: array a of length n and array b of\r\nlength n+1.You can perform the following operations any number of times\r\nin any order: choose any element of the array a and increase it by 1;\r\nchoose any element of the array a and decrease it by 1; choose any\r\nelement of the array a, copy it and append the copy to the end of the\r\narray a. Your task is to calculate the minimum number of aforementioned\r\noperations (possibly zero) required to transform the array a into the\r\narray b. It can be shown that under the constraints of the problem, it\r\nis always possible.\r\n",
    "solutions": [
        "#include <bits/stdc++.h> using i64 = long long; void solve() {    int n;    std::cin >> n;        std::vector<int> a(n), b(n + 1);    for (int i = 0; i < n; i++) {        std::cin >> a[i];    }    for (int i = 0; i <= n; i++) {        std::cin >> b[i];    }        i64 ans = 1E9;    for (int i = 0; i < n; i++) {        ans = std::min<int>(ans, std::abs(a[i] - b[n]));        ans = std::min<int>(ans, std::abs(b[i] - b[n]));        if (std::min(a[i], b[i]) <= b[n] && b[n] <= std::max(a[i], b[i])) {            ans = 0;        }    }    for (int i = 0; i < n; i++) {        ans += std::abs(a[i] - b[i]);    }    std::cout << ans + 1 << \"\\n\";} int main() {    std::ios::sync_with_stdio(false);    std::cin.tie(nullptr);        int t;    std::cin >> t;        while (t--) {        solve();    }        return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Increase Decrease Copy.json",
    "hint": []
}