{
    "link": "https://codeforces.com//contest/1000/problem/C",
    "problemId": "193656",
    "problem_idx": "C",
    "shortId": "1000C",
    "contest_number": "1000",
    "problem_submissions": {
        "G": [
            39718562,
            39719543,
            39731044,
            39745353
        ],
        "E": [
            39714455,
            39714380,
            39711396,
            39717344,
            39715216,
            39714198,
            39717274,
            39714849,
            39716315,
            39710033,
            39719087,
            39714919,
            39717269,
            39719314,
            39715149,
            39718067,
            39717227,
            39715819,
            39716698,
            39714956
        ],
        "F": [
            39713460,
            39707084,
            39730558,
            39730512,
            39730296,
            39730270,
            39730256,
            39730239,
            39730221,
            39730211,
            39730154,
            39730127,
            39730113,
            39730102,
            39730087,
            39730070,
            39730054,
            39730038,
            39730029,
            39715353,
            39714587,
            39718375,
            39717776,
            39709495,
            39717288,
            39718275,
            39707695,
            39714904,
            39719561,
            39715859,
            39716309,
            41303353,
            41303333,
            39722296,
            39721263,
            39713335,
            39715356,
            39718313,
            39720559,
            39710578
        ],
        "D": [
            39712036,
            39711284,
            39709815,
            39710348,
            39711331,
            39711469,
            39714291,
            39712438,
            39711322,
            39711986,
            39710186,
            39711296,
            39710596,
            39711080,
            39713011,
            39710269,
            39712921,
            39714356,
            39714670,
            39711775
        ],
        "C": [
            39709789,
            39708273,
            39708437,
            39708497,
            39707490,
            39709711,
            39711470,
            39710285,
            39709663,
            39712657,
            39707054,
            39709385,
            39707981,
            39708400,
            39708339,
            39708579,
            39711654,
            39712280,
            39711950,
            39712277
        ],
        "B": [
            39708786,
            39709741,
            39707292,
            39706954,
            39708573,
            39707999,
            39708997,
            39708329,
            39708450,
            39715462,
            39712282,
            39720742,
            39715883,
            39713342,
            39706846,
            39709837,
            39709912,
            39706999,
            39710604,
            39710245,
            39709682,
            39713043
        ],
        "A": [
            39706953,
            39704546,
            39704256,
            39704278,
            39704401,
            39705070,
            39705301,
            39704306,
            39704491,
            39713520,
            39705360,
            39704298,
            39704641,
            39704487,
            39704983,
            39705096,
            39704429,
            39704776,
            39705211,
            39713228
        ]
    },
    "name": "C. Covered Points Count",
    "statement": "You are given n segments on a coordinate line; each endpoint of every\r\nsegment has integer coordinates. Some segments can degenerate to points.\r\nSegments can intersect with each other, be nested in each other or even\r\ncoincide.Your task is the following: for every k\r\nin [1..n], calculate the number of points with integer coordinates such\r\nthat the number of segments that cover these points equals k. A segment\r\nwith endpoints l_i and r_i covers point x if and only if l_i\r\nle x\r\nle r_i.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define fin(s) freopen( s, \"r\", stdin );\n#define fout(s) freopen( s, \"w\", stdout );\n\nconst long long N = 200100;\nconst long long Q = 2e18;\nconst long long mod = 1e9 + 7;\nconst long long MAGIC = 30;\n\nusing namespace std;\n\nint n;\nlong long d[N];\nvector < pair < long long, int > > v;\n\nvoid solve()\n{\n        cin >> n;\n        for(int i = 1; i <= n; i++){\n                long long l, r;\n                cin >> l >> r;\n                v.push_back({l, 1});\n                v.push_back({r + 1, -1});\n        }\n        sort(v.begin(), v.end());\n        long long cnt = 0;\n        for(int i = 0; i < v.size(); i++){\n                cnt += v[i].se;\n                if(i + 1 < v.size() && v[i].fi != v[i + 1].fi){\n                        d[cnt] += v[i + 1].fi - v[i].fi;\n                }\n        }\n        for(int i = 1; i <= n; i++){\n                cout << d[i] << \" \";\n        }\n}\n\nbool mtest = false; int main()\n{\n        //fin(\"input.txt\");\n        //fout(\"output.txt\");\n        //fin(\"island.in\");\n        //fout(\"island.out\");\n        ios_base::sync_with_stdio(0);\n        int TE = 1;\n        if(mtest)\n                cin >> TE;\n        while(TE--)\n                solve();\n        return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "implementation",
        "sortings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Covered Points Count.json",
    "editorial_link": "https://codeforces.com/blog/entry/60288",
    "editorial": "This problem with small coordinates can be solved using partial sums and\r\nsome easy counting. Letâs carry an array , where will be equal to the\r\nnumber of segments that cover the point with coordinate . How to\r\ncalculate in ?For each segment () letâs add to and to . Now build on\r\nthis array prefix sums and notice that equals the number of segments\r\nthat cover the point with coordinate . Then will be equal to . All the\r\nanswers can be calculated in in total. So the total complexity of this\r\nsolution is .But in our problem it is too slow to build an entire array\r\n. So what should we do? It is obvious that if any coordinate is not\r\nequals some or some then . So we do not need carry all the positions\r\nexplicitly. Letâs carry all and in some logarithmic data structure or\r\nletâs use the coordinate compression method.The coordinate compression\r\nmethod allows us to transform the set of big sparse objects to the set\r\nof small compressed objects maintaining the relative order. In our\r\nproblems letâs make the following things: push all and in vector , sort\r\nthis vector, keep only unique values and then use the position of\r\nelements in vector instead of original value (any position can be found\r\nin by binary search or standard methods as in C++).So the first part of\r\nthe solution works in . Answer can be calculated using almost the same\r\napproach as in solution to this problem with small coordinates. But now\r\nwe know that between two adjacent elements and there is exactly points\r\nwith answer equals to . So if we will iterate over all pairs of the\r\nadjacent elements and and add to the , we will calculate all the answers\r\nin .So the total complexity of the solution is .\r\n",
    "hint": []
}