{
    "link": "https://codeforces.com//contest/1697/problem/C",
    "problemId": "1427642",
    "problem_idx": "C",
    "shortId": "1697C",
    "contest_number": "1697",
    "problem_submissions": {
        "F": [
            160316028,
            160335271,
            160331836,
            160345509,
            160346300,
            160344663,
            160340959,
            160455567,
            160365066,
            160450918
        ],
        "E": [
            160306724,
            160317216,
            160317720,
            160323985,
            160325271,
            160325964,
            160354419,
            160319599,
            160322353,
            160325146,
            160325548,
            160320808,
            160330194,
            160331332,
            160324375,
            160329677,
            160325210,
            160439973,
            160435649,
            160435501,
            160334542,
            160334158
        ],
        "D": [
            160297103,
            160308079,
            160308707,
            160309184,
            160311087,
            160315683,
            160304446,
            160307456,
            160306088,
            160309775,
            160310589,
            160312120,
            160309909,
            160314751,
            160306875,
            160306002,
            160313672,
            160319695,
            160308549
        ],
        "C": [
            160289797,
            160295599,
            160301341,
            160300167,
            160298909,
            160307057,
            160312096,
            160291233,
            160293256,
            160294510,
            160299611,
            160297247,
            160296258,
            160299415,
            160296418,
            160293099,
            160299382,
            160299241,
            160297402
        ],
        "B": [
            160279508,
            160282090,
            160301342,
            160292066,
            160285118,
            160283650,
            160284312,
            160283738,
            160281629,
            160287785,
            160284110,
            160279928,
            160285652,
            160285722,
            160282180,
            160283286,
            160288457,
            160284205,
            160285201
        ],
        "A": [
            160279237,
            160279338,
            160286569,
            160289515,
            160279504,
            160279374,
            160279443,
            160279381,
            160279282,
            160282067,
            160279274,
            160279241,
            160281284,
            160279454,
            160279294,
            160279242,
            160281815,
            160279598,
            160280937
        ]
    },
    "name": "C. awoo's Favorite Problem",
    "statement": "You are given two strings s and t, both of length n. Each character in\r\nboth string is ”, ” or ”.In one move, you can perform one of the\r\nfollowing actions: choose an occurrence of \"\" in s and replace it with\r\n\"\"; choose an occurrence of \"\" in s and replace it with \"\". You are\r\nallowed to perform an arbitrary amount of moves (possibly, zero). Can\r\nyou change string s to make it equal to string t?\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 12.06.2022 18:37:06       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    string s, t;\n    cin >> s >> t;\n    vector<int> ns(1, 0);\n    vector<int> nt(1, 0);\n    string cs, ct;\n    for (int i = 0; i < n; i++) {\n      if (s[i] != 'b') {\n        cs += s[i];\n        ns.push_back(0);\n      } else {\n        ns.back() += 1;\n      }\n      if (t[i] != 'b') {\n        ct += t[i];\n        nt.push_back(0);\n      } else {\n        nt.back() += 1;\n      }\n    }\n    int sum = 0;\n    bool ok = true;\n    if (cs == ct) {\n      for (int i = 0; i < (int) ns.size() - 1; i++) {\n        sum += ns[i] - nt[i];\n        if (sum > 0 && cs[i] == 'a') {\n          ok = false;\n          break;\n        }\n        if (sum < 0 && cs[i] == 'c') {\n          ok = false;\n          break;\n        }\n      }\n    }\n    cout << (ok && cs == ct ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "constructive algorithms",
        "data structures",
        "greedy",
        "implementation",
        "strings",
        "two pointers"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. awoo's Favorite Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/103835",
    "editorial": "First, check that the counts of all letters are the same in both\r\nstrings.Then consider the following restatement of the moves. The\r\nletters â in the string are stationary. Letters â and â, however, move\r\naround the string. The move of the first type moves a letter â to the\r\nright. The move of the second type moves a letter â to the left.Notice\r\nthat letters â and â can never swap with each other. Thus, if you remove\r\nall letters â from both strings, the remaining strings should be the\r\nsame.Again, since letters â and â can never swap with each other, you\r\ncan deduce where each of these letters should end up after the swaps.\r\nThe first letter â{a}â in should be on the position of the first letter\r\nâ in and so on.After that, we recall that âs can only move to the right\r\nand âs can only move to the left. Thus, we check that the -th occurrence\r\nof â in is to the left or equal to the -th occurrences of â in and vice\r\nversa for âs.Finally, we can see that this is a sufficient condition.\r\nEasy to show by construction: you can just fix the positions one after\r\nanother left to right.Overall complexity: per testcase.\r\n",
    "hint": []
}