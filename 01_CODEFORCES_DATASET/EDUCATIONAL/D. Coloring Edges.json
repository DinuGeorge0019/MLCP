{
    "link": "https://codeforces.com//contest/1217/problem/D",
    "problemId": "404646",
    "problem_idx": "D",
    "shortId": "1217D",
    "contest_number": "1217",
    "problem_submissions": {
        "F": [
            60119255,
            60118536,
            60117179,
            60112264,
            60128130,
            60127503,
            60126918,
            60123155,
            60108293,
            60125049,
            60146948,
            60128055,
            60130824,
            60133706,
            60133628,
            60133577,
            60133431,
            60148111,
            60128465,
            60130939,
            60194071,
            60161365,
            60161338,
            60161260,
            60133265,
            60131839
        ],
        "E": [
            60105066,
            60116418,
            60106390,
            60121938,
            60108304,
            60146942,
            60108305,
            60105389,
            60107537,
            60103856,
            60133910,
            60133496,
            60106424,
            60108802,
            60109228,
            60105208,
            60109038,
            60113612,
            60109155,
            60108937,
            60108739,
            60185912,
            60121211,
            60119745
        ],
        "D": [
            60093380,
            60096462,
            60101910,
            60101769,
            60146935,
            60099412,
            60094151,
            60095526,
            60100622,
            60098634,
            60099130,
            60111816,
            60100421,
            60093903,
            60100608,
            60099424,
            60113888,
            60106298,
            60107083
        ],
        "C": [
            60088873,
            60091347,
            60096256,
            60097679,
            60146931,
            60089815,
            60086473,
            60091850,
            60090230,
            60091598,
            60096228,
            60090577,
            60097512,
            60091408,
            60091681,
            60095632,
            60094356,
            60083533,
            60095174
        ],
        "B": [
            60085129,
            60084473,
            60090224,
            60089598,
            60146927,
            60087277,
            60084144,
            60085003,
            60086682,
            60087576,
            60086106,
            60085538,
            60094264,
            60087892,
            60094300,
            60089353,
            60089039,
            60094083,
            60086577
        ],
        "A": [
            60083114,
            60082761,
            60084492,
            60083647,
            60146918,
            60083293,
            60082871,
            60082868,
            60082958,
            60082935,
            60083622,
            60083726,
            60084591,
            60083527,
            60083900,
            60086802,
            60083832,
            60082824,
            60083536
        ]
    },
    "name": "D. Coloring Edges",
    "statement": "You are given a directed graph with n vertices and m directed edges\r\nwithout self-loops or multiple edges.Let\u2019s denote the k-coloring of a\r\ndigraph as following: you color each edge in one of k colors. The\r\nk-coloring is if and only if there no cycle formed by edges of same\r\ncolor.Find a good k-coloring of given digraph with minimum possible k.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/05, 23:56:24\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nint deg[5001];\nvector<int> redge[5001];\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<int> ans;\n    for (int i = 1; i <= m; ++i) {\n        int x, y;\n        cin >> x >> y;\n        ans.push_back((x < y) + 1);\n        ++deg[x];\n        redge[y].push_back(x);\n    }\n    vector<int> st;\n    for (int i = 1; i <= n; ++i) {\n        if (deg[i] == 0) st.push_back(i);\n    }\n    for (int i = 0; i < st.size(); ++i) {\n        int x = st[i];\n        for (int j : redge[x]) {\n            if (--deg[j] == 0) st.push_back(j);\n        }\n    }\n    if (st.size() < n) {\n        printf(\"2\\n\");\n        for (int i : ans) printf(\"%d \", i);\n    }\n    else {\n        printf(\"1\\n\");\n        for (int i = 0; i < m; ++i) printf(\"1 \");\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Coloring Edges.json",
    "editorial_link": "https://codeforces.com//blog/entry/69605",
    "editorial": "Let\u00e2\u0080\u0099s run dfs on the graph and color all \"back edges\" ( is back edge if\r\nthere is a path from to by edges from dfs tree) in black and all other\r\nedges in white. It can be proven that any cycle will have at least one\r\nwhite edge and at least black edge. Moreover each back edge connected\r\nwith at least one cycle (path from to and back edge). So the coloring we\r\ngot is exactly the answer.How to prove that any cycle have at least one\r\nedge of both colors? Let\u00e2\u0080\u0099s look only at edges from dfs trees. We can\r\nalways renumerate vertices in such way that index of parent is bigger\r\nthan the index of any its child . We can process and assign with minimal\r\nfree number after we processed all its children.Now we can note that for\r\nany white edge (not only tree edge) condition holds (because of\r\nproperties of dfs: forward edges are obvious; cross edge becomes cross\r\nbecause dfs at first processed vertex and after that, so ). And for each\r\nback edge it\u00e2\u0080\u0099s true that . Since any cycle have both and situations,\r\nprofit!\r\n"
}