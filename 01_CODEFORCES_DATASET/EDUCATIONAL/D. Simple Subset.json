{
    "link": "https://codeforces.com//contest/665/problem/D",
    "problemId": "55554",
    "problem_idx": "D",
    "shortId": "665D",
    "contest_number": "665",
    "problem_submissions": {
        "F": [
            35437149,
            27600620,
            27600570,
            27600365,
            207086930,
            17511081,
            17511048,
            17408931,
            17465318,
            17465113,
            17465105,
            17421220,
            17419616,
            17419504,
            17407442
        ],
        "E": [
            17404108,
            17403997,
            17404019,
            17404185,
            17404405,
            17405241,
            17404852,
            17406609,
            17403872,
            17404958,
            17406585,
            17405102,
            17402241,
            17404889,
            17406152,
            17407503,
            17407294,
            17402667,
            17407651,
            17402391
        ],
        "D": [
            17402746,
            17402888,
            17403061,
            17402886,
            17403632,
            17402659,
            17403180,
            17402538,
            17403092,
            17404017,
            17402765,
            17404460,
            17403586,
            17404039,
            17404874,
            17597162,
            17597147,
            17405860,
            17404856,
            17403614,
            17402947,
            17403487
        ],
        "B": [
            17402058,
            17402143,
            17401985,
            17401812,
            17402480,
            17401996,
            17402111,
            17401950,
            17401883,
            17402289,
            17402172,
            17404614,
            17405448,
            17402800,
            17402279,
            17402724,
            17403040,
            17404322,
            17403505,
            17404527
        ],
        "C": [
            17401652,
            17401814,
            17402423,
            17402078,
            17401921,
            17401528,
            17401657,
            17401538,
            17402228,
            17402780,
            17401867,
            17401866,
            17401442,
            17401822,
            17401577,
            17403531,
            17403479,
            17401483,
            17404073,
            17401636,
            17404128
        ],
        "A": [
            17401480,
            17401614,
            17401638,
            17401502,
            17401615,
            17401450,
            17401531,
            17402688,
            17401495,
            17401597,
            17401511,
            17401510,
            17405192,
            17401618,
            17401993,
            17401713,
            17402074,
            17402469,
            17404975,
            17408296,
            17406598
        ]
    },
    "name": "D. Simple Subset",
    "statement": "A tuple of positive integers is called simple if for all pairs of\r\npositive integers (), is a prime.You are given an array with positive\r\nintegers (not necessary distinct). You want to find a simple subset of\r\nthe array with the maximum size.A prime number (or a prime) is a natural\r\nnumber greater than that has no positive divisors other than and\r\nitself.Letâ€™s define a subset of the array as a tuple that can be\r\nobtained from by removing some (possibly all) elements of it.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint n=2000000;\n\nint tab[1007];\n\nint sito[2000007];\n\nint ile;\n\nvector <int> ter;\n\nvector <int> opty;\nint optyj;\n\nint czy;\n\nvoid rek(int v)\n{\n    czy=1;\n    for (int i=0; i<ter.size(); i++)\n    {\n        if (sito[ter[i]+1])\n        {\n            czy=0;\n        }\n    }\n    if (ter.size()+czy*ile>opty.size()+optyj)\n    {\n        opty=ter;\n        optyj=czy*ile;\n    }\n    if (v==n+1 || ter.size()==2)\n    return;\n    rek(v+1);\n    czy=1;\n    for (int i=0; i<ter.size(); i++)\n    {\n        if (sito[ter[i]+tab[v]])\n        {\n            czy=0;\n        }\n    }\n    if (czy)\n    {\n        ter.push_back(tab[v]);\n        rek(v+1);\n        ter.pop_back();\n    }\n}\n\nint main()\n{\n    for (int i=2; i<=n; i++)\n    {\n        if (!sito[i])\n        {\n            for (int j=i*2; j<=n; j+=i)\n            {\n                sito[j]=1;\n            }\n        }\n    }\n    scanf(\"%d\", &n);\n    for (int i=1; i<=n; i++)\n    {\n        scanf(\"%d\", &tab[i]);\n    }\n    sort(tab+1, tab+1+n);\n    reverse(tab+1, tab+1+n);\n    while(n && tab[n]==1)\n    {\n        ile++;\n        n--;\n    }\n    rek(1);\n    printf(\"%d\\n\", (int)opty.size()+optyj);\n    for (int i=0; i<opty.size(); i++)\n    printf(\"%d \", opty[i]);\n    for (int i=1; i<=optyj; i++)\n    printf(\"1 \");\n    printf(\"\\n\");\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Simple Subset.json",
    "editorial_link": "https://codeforces.com//blog/entry/44466",
    "editorial": "The problem was suggested by Zi Song Yeoh zscoder. Consider the subset\r\nthat is the answer to the problem. Let be the arbitrary three elements\r\nfrom and let no more than one of them is equal to . By the pigeonhole\r\nprinciple two of three elements from have the same parity. So we have\r\ntwo integers with even sum and only one of them is equal to , so their\r\nsum is also greater than . So the subset is not simple. In this way\r\nconsists of only two numbers greater than one (with a prime sum) or\r\nconsists of some number of ones and also maybe other value , so that is\r\na prime. We can simply process the first case in time. The second case\r\ncan be processed in linear time. Also we should choose the best answer\r\nfrom that two. To check the value of order for primality in time we can\r\nuse the simple or the linear Eratosthenes sieve. C++ solution\r\n",
    "hint": []
}