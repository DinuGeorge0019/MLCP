{"link": "https://codeforces.com//contest/1681/problem/F", "problemId": "1408807", "problem_idx": "F", "shortId": "1681F", "contest_number": "1681", "problem_submissions": {"E": [158182756, 158181599, 158189245, 158201402, 158212176, 158209977, 158197244, 158200543, 158207419, 158195422, 158212507, 158201688, 158217615, 158236025, 158203326, 158213610, 158220340, 158209570, 158222642, 158202788], "D": [158169620, 158166339, 158168627, 158176540, 158180183, 158179810, 158175614, 158171745, 158169793, 158171043, 158176143, 158179351, 158198071, 158177219, 158193904, 158184952, 158187520, 158180354, 158208785], "F": [158163420, 158197514, 158198216, 158189118, 158175678, 158193941, 158204936, 158208270, 158190074, 158203305, 158200335, 158211270, 158186690, 158250369, 158237153, 158219180, 158187046, 158203102, 158220096, 158206596, 158220727], "C": [158154298, 158157033, 158157275, 158158888, 158161011, 158157520, 158164047, 158162763, 158158338, 158166846, 158162496, 158167443, 158168946, 158167710, 158166768, 158169766, 158168157, 158169965, 158164354], "B": [158153598, 158154121, 158153990, 158154166, 158155404, 158154059, 158159057, 158156022, 158154367, 158163137, 158157819, 158159126, 158157005, 158167777, 158160391, 158158841, 158161305, 158161887, 158159104], "A": [158153541, 158153617, 158153597, 158153653, 158153683, 158153631, 158155593, 158153768, 158153633, 158155729, 158155747, 158154711, 158154019, 158167893, 158153987, 158154332, 158156617, 158157260, 158154882]}, "name": "F. Unique Occurrences", "statement": "You are given a tree, consisting of n vertices. Each edge has an integer\r\nvalue written on it.Let f(v, u) be the number of values that appear on\r\nthe edges of a simple path between vertices v and u.Calculate the sum of\r\nf(v, u) over all pairs of vertices v and u such that 1\r\nle v < u\r\nle n.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 23.05.2022 18:44:02       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<pair<int, int>>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    --a; --b; --c;\n    g[c].emplace_back(a, b);\n  }\n  vector<int> p(n);\n  iota(p.begin(), p.end(), 0);\n  vector<int> sz(n, 1);\n  vector<pair<int, int>> ops;\n  auto Get = [&](int i) {\n    while (i != p[i]) {\n      i = p[i];\n    }\n    return i;\n  };\n  auto Unite = [&](int i, int j) {\n    i = Get(i);\n    j = Get(j);\n    if (i != j) {\n      if (sz[i] > sz[j]) {\n        swap(i, j);\n      }\n      ops.emplace_back(i, p[i]);\n      p[i] = j;\n      ops.emplace_back(~j, sz[j]);\n      sz[j] += sz[i];\n    }\n  };\n  auto Rollback = [&](int T) {\n    while ((int) ops.size() > T) {\n      int i = ops.back().first;\n      int j = ops.back().second;\n      ops.pop_back();\n      if (i >= 0) {\n        p[i] = j;\n      } else {\n        sz[~i] = j;\n      }\n    }\n  };\n  long long ans = 0;\n  function<void(int, int)> Dfs = [&](int l, int r) {\n    if (l == r) {\n      for (auto& p : g[l]) {\n        int x = Get(p.first);\n        int y = Get(p.second);\n        ans += (long long) sz[x] * sz[y];\n      }\n      return;\n    }\n    int mid = (l + r) >> 1;\n    {\n      int save = (int) ops.size();\n      bool fail = false;\n      for (int i = mid + 1; i <= r; i++) {\n        for (auto& p : g[i]) {\n          Unite(p.first, p.second);\n        }\n      }\n      Dfs(l, mid);\n      Rollback(save);\n    }\n    {\n      int save = (int) ops.size();\n      bool fail = false;\n      for (int i = l; i <= mid; i++) {\n        for (auto& p : g[i]) {\n          Unite(p.first, p.second);\n        }\n      }\n      Dfs(mid + 1, r);\n      Rollback(save);\n    }\n  };\n  Dfs(0, n - 1);\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "dfs and similar", "divide and conquer", "dp", "dsu", "trees"], "dificulty": "2300", "interactive": false}