{"link": "https://codeforces.com//contest/1194/problem/F", "problemId": "372220", "problem_idx": "F", "shortId": "1194F", "contest_number": "1194", "problem_submissions": {"E": [57460080, 57035519, 57036170, 57036063, 57128801, 57128706, 57128697, 57128659, 57128612, 57128540, 57128243, 57128111, 57036122, 57038525, 57047818, 57039795, 57039479, 57042294, 57040196, 57036224, 57042239, 57040076, 57104697, 57102024, 57101946, 57062641, 57042300, 57042350, 57042204, 57055044, 57053556, 57046934, 57046549, 57042532], "A": [57046342, 57022752, 57022576, 57022542, 57022673, 57022779, 57022508, 57024885, 57022776, 57023918, 57022665, 57023995, 57022524, 57022685, 57028419, 57027614, 57022718, 57022691, 57023076, 57024152], "B": [57046133, 57024457, 57023825, 57024116, 57024620, 57026379, 57024611, 57023215, 57025344, 57025498, 57024993, 57026889, 57024968, 57025445, 57030710, 57029529, 57024907, 57024604, 57025406, 57027222], "C": [57045626, 57025890, 57026227, 57026533, 57026651, 57028509, 57026843, 57027145, 57026992, 57027849, 57027432, 57029395, 57027548, 57028521, 57032512, 57032102, 57027763, 57027180, 57027134, 57031699], "G": [57044495, 57124672, 57083729, 57083446, 57083302, 57051811, 144563243, 57059946, 57059836, 57059526, 57059380, 57058688, 57057384, 66619078, 66618958, 66618872, 57059217, 57080922, 57079990, 57079590, 57079506, 99043474, 99036226], "F": [57028516, 57040353, 57042500, 57037960, 57127884, 57047571, 57045756, 57041898, 57051035, 57048196, 57045806, 57053225, 57047719, 57051194, 57063470, 57052822, 57047382, 57051062, 57040128, 57052740, 57051156, 57053947, 57051969], "D": [57026382, 57028806, 57032441, 57028933, 57029747, 57030899, 57031250, 57031182, 57036191, 57030939, 57039325, 57034516, 57033749, 57033063, 57035777, 57036535, 57031217, 57033511, 57038656, 57037146]}, "name": "F. Crossword Expert", "statement": "Today Adilbek is taking his probability theory test. Unfortunately, when\r\nAdilbek arrived at the university, there had already been a long queue\r\nof students wanting to take the same test. Adilbek has estimated that he\r\nwill be able to start the test only T seconds after coming. Fortunately,\r\nAdilbek can spend time without revising any boring theorems or formulas.\r\nHe has an app on this smartphone which contains n Japanese crosswords to\r\nsolve. Adilbek has decided to solve them all one by one in the order\r\nthey are listed in the app, without skipping any crossword. For each\r\ncrossword, a number t_i is given that represents the time it takes an\r\naverage crossword expert to solve this crossword (the time is given in\r\nseconds).Adilbek is a true crossword expert, but, unfortunately, he is\r\nsometimes unlucky in choosing the way to solve the crossword. So, it\r\ntakes him either t_i seconds or t_i + 1 seconds to solve the i-th\r\ncrossword, equiprobably (with probability\r\nfrac{1}{2} he solves the crossword in exactly t_i seconds, and with\r\nprobability\r\nfrac{1}{2} he has to spend an additional second to finish the\r\ncrossword). All these events are independent.After T seconds pass (or\r\nafter solving the last crossword, if he manages to do it in less than T\r\nseconds), Adilbek closes the app (if he finishes some crossword at the\r\nsame moment, that crossword is considered solved; otherwise Adilbek does\r\nnot finish solving the current crossword at all). He thinks it would be\r\nan interesting probability theory problem to calculate E the expected\r\nnumber of crosswords he will be able to solve completely. Can you\r\ncalculate it? Recall that the expected value of a discrete random\r\nvariable is the probability-weighted average of all possible values in\r\nthis problem it means that the expected value of the number of solved\r\ncrosswords can be calculated as E =\r\nsum\r\nlimits_{i = 0}^{n} i p_i, where p_i is the probability that Adilbek will\r\nsolve exactly i crosswords. We can represent E as rational fraction\r\nfrac{P}{Q} with Q > 0. To give the answer, you should print P\r\ncdot Q^{-1}\r\nbmod (10^9 + 7).\r\n", "solutions": ["#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    modular(const ll& v) { \n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    \n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular pow(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\ntemplate<int SZ> struct Combo {\n    mi smallInv[SZ], fac[SZ], ifac[SZ]; \n    vpi factors; vi cnt[SZ];\n\n    void genInv() {\n        if (sz(factors) == 1 && factors[0].s == 1) {\n            F0R(i,2) smallInv[i] = i;\n            FOR(i,2,SZ) { // use only O(SZ) operations for MOD a prime\n                int x = (MOD+i-1)/i;\n                smallInv[i] = smallInv[i*x-MOD]*x;\n            }\n        } else {\n            F0R(i,SZ) {\n                int x = invGeneral(i,MOD);\n                if (x == -1) smallInv[i] = 0;\n                else smallInv[i] = x;\n            }\n        }\n    }\n    \n    void init() {\n        // factors = factor(MOD); \n        factors = {{MOD,1}}; \n        genInv(); cnt[0] = vi(sz(factors)); fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ) {\n            cnt[i] = cnt[i-1]; int I = i;\n            F0R(j,sz(factors)) while (I % factors[j].f == 0)\n                I /= factors[j].f, cnt[i][j] ++;\n            fac[i] = fac[i-1]*I; ifac[i] = ifac[i-1]*smallInv[I];\n        }\n    }\n\n    mi comb(int a, int b) {\n        if (a < b || b < 0) return 0;\n        auto tmp = fac[a]*ifac[b]*ifac[a-b];\n        F0R(i,sz(factors)) {\n            int t = cnt[a][i]-cnt[a-b][i]-cnt[b][i];\n            tmp *= pow(mi(factors[i].f),t);\n        }\n        return tmp;\n    }\n};\n\nCombo<MX> C;\n\nint n;\nll T;\n\nint main() {\n    setIO(); C.init();\n    re(n,T);\n    vl t(n); re(t);\n    mi ans = 0, sum = 1;\n    int r = 0;\n    F0R(i,n) {\n    \tT -= t[i]; if (T < 0) break;\n    \tsum = 2*sum-C.comb(i,r);\n    \twhile (r < min((ll)i+1,T)) {\n    \t\tsum += C.comb(i+1,++r);\n    \t}\n    \twhile (r > T) {\n    \t\tsum -= C.comb(i+1,r--);\n    \t}\n    \tans += sum/pow(mi(2),i+1);\n    }\n    ps(ans);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"], "input": "", "output": "", "tags": ["combinatorics", "dp", "number theory", "probabilities", "two pointers"], "dificulty": "2400", "interactive": false}