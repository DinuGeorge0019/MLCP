{
    "link": "https://codeforces.com//contest/1175/problem/E",
    "problemId": "354217",
    "problem_idx": "E",
    "shortId": "1175E",
    "contest_number": "1175",
    "problem_submissions": {
        "E": [
            55152697,
            55143297,
            55144842,
            55149453,
            55145090,
            55152529,
            55156277,
            55145238,
            55141766,
            55151809,
            55150612,
            55150119,
            55150752,
            55156812,
            55152738,
            55154944,
            55150125,
            55154652,
            55158266,
            55163765
        ],
        "F": [
            55143004,
            55151795,
            55152215,
            55142312,
            55154601,
            55143715,
            55151506,
            55166103,
            55151247,
            55162817,
            55160160,
            55154302,
            55159983,
            55153216,
            55161466,
            55160616,
            55159270,
            55167756,
            76726554,
            55159045
        ],
        "D": [
            55137941,
            55140293,
            55140750,
            55145972,
            55139564,
            55144646,
            55138002,
            55141894,
            55136780,
            55138695,
            55141164,
            55144507,
            55139116,
            55139569,
            55142712,
            55138367,
            55143330,
            55142605,
            55147375,
            55147140
        ],
        "C": [
            55134609,
            55137594,
            55139019,
            55137598,
            55135791,
            55137314,
            55136601,
            55136692,
            55135046,
            55136312,
            55137446,
            55142893,
            55137610,
            55138266,
            55140998,
            55137003,
            55146366,
            55138295,
            55140586,
            55141407
        ],
        "B": [
            55132016,
            55133684,
            55136306,
            55134307,
            55133707,
            55134207,
            55135033,
            55133685,
            55171853,
            55133665,
            55137967,
            55138315,
            55133858,
            55138192,
            55135842,
            55133934,
            55137057,
            55134510,
            55135402,
            55137596
        ],
        "A": [
            55129715,
            55129741,
            55129684,
            55129658,
            55129917,
            55129679,
            55130628,
            55129791,
            55130186,
            55130042,
            55129731,
            55135937,
            55130056,
            55130398,
            55129926,
            55129655,
            55132057,
            55130203,
            55131132,
            55132516
        ],
        "G": [
            55169838,
            55219359,
            58237199,
            55161904,
            55163020
        ]
    },
    "name": "E. Minimal Segment Cover",
    "statement": "You are given n intervals in form [l; r] on a number line.You are also\r\ngiven m queries in form [x; y]. What is the minimal number of intervals\r\nyou have to take so that every point () from x to y is covered by at\r\nleast one of them? If you can\u2019t choose intervals so that every point\r\nfrom x to y is covered, then print for that query.\r\n",
    "solutions": [
        "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nconst int INF = (int)1e9 + 7;\n\n// Finds last with value <= val\ntemplate<class T>\nint bins(const vector<T>& vec, T val) {\n\tint low = -1;\n\tint high = (int)vec.size() - 1;\n\twhile(low != high) {\n\t\tint mid = (low + high + 1) >> 1;\n\t\tif (vec[mid] <= val) low = mid;\n\t\telse high = mid - 1;\n\t}\n\treturn low;\n}\n\nconst int H = 18;\nconst int N = 1<<H;\nint nxt[N][H];\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t// Optimal to pick interval with a <= x, with maximum b\n\t// Find for every interval the best next interval. Do jump array.\n\t// Remove useless intervals for easy handling\n\n\tint n, q;\n\tcin >> n >> q;\n\n\tvector<pair<int, int>> vec(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tvec[i] = {a, -b};\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor (int i = 0; i < n; ++i) vec[i].second *= -1;\n\t\n\t// Remove useless intervals\n\tint r = 0;\n\tfor (int i = 0; i+r < n; ++i) {\n\t\tswap(vec[i], vec[i+r]);\n\t\tif (i > 0 && vec[i-1].second >= vec[i].second) {\n\t\t\t++r;\n\t\t\t--i;\n\t\t}\n\t}\n\tn -= r;\n\tvec.resize(n);\n\n\t// for (auto pr : vec) cout << pr.first << ' ' << pr.second << \"; \"; cout << endl;\n\n\t// Find next intervals\n\tfor (int i = 0; i < n; ++i) {\n\t\tnxt[i][0] = bins(vec, {vec[i].second, INF});\n\t}\n\tfor (int h = 1; h < H; ++h) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tnxt[i][h] = nxt[nxt[i][h-1]][h-1];\n\t\t}\n\t}\n\n\tfor (int qi = 0; qi < q; ++qi) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tint i = bins(vec, {x, INF});\n\t\tint res = -1;\n\t\tif (i != -1) {\n\t\t\tres = 1;\n\t\t\tfor (int h = H-1; h >= 0; --h) {\n\t\t\t\tint j = nxt[i][h];\n\t\t\t\tif (vec[j].second < y) {\n\t\t\t\t\tres += (1<<h);\n\t\t\t\t\ti = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vec[i].second < y) {\n\t\t\t\t++res;\n\t\t\t\ti = nxt[i][0];\n\t\t\t}\n\t\t\tif (vec[i].second < y) res = -1;\n\t\t}\n\t\tcout << res << '\\n';\n\t}\n}\n\n\n\n\n\n\n\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "divide and conquer",
        "dp",
        "greedy",
        "implementation",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Minimal Segment Cover.json",
    "editorial_link": "https://codeforces.com/blog/entry/67484",
    "editorial": "Let\u00e2\u0080\u0099s take a look at a naive approach at first.That approach is greedy.\r\nLet\u00e2\u0080\u0099s find such an interval which starts to the left or at and ends as\r\nmuch to the right as possible. Set to its right border. Continue until\r\neither no interval can be found or is reached.The proof basically goes\r\nlike this. Let there be some smaller set of intervals which cover the\r\nquery, these can be sorted by left border (obviously their left borders\r\nare pairwise distinct). Compare that set to the greedy one, take a look\r\nat the first position where best set\u00e2\u0080\u0099s interval has his less than the\r\ngreedy set\u00e2\u0080\u0099s . You can see that choosing interval greedily will still\r\nallow to have the rest of best set intervals, making the greedy choice\r\noptimal.Let\u00e2\u0080\u0099s implement it in . For each position from to you can\r\nprecalculate the index of such an interval that it starts to the left or\r\nat this position and ends as much to the right as possible. To do this\r\nsort all intervals by their left border, then iterate over positions,\r\nwhile maintaining the maximum right border achieved by intervals\r\nstarting to the left or at the current position. The query is now\r\nstraightforward.Now there are two main ways to optimize it.You can do it\r\nbinary lifting style: for each interval (or position) precalculate the\r\nindex of the interval taken last after taking intervals greedily and use\r\nthis data to answer queries in .You can also do it path compression\r\nstyle. Let\u00e2\u0080\u0099s process the queries in the increasing order of their right\r\nborders. Now do greedy algorithm but for each interval you use remember\r\nthe index of the last reached interval. Now the part with answering\r\nqueries is in total because each interval will be jumped from no more\r\nthan once.Overall complexity: / .\r\n"
}