{
    "link": "https://codeforces.com//contest/1766/problem/B",
    "problemId": "1690147",
    "problem_idx": "B",
    "shortId": "1766B",
    "contest_number": "1766",
    "problem_submissions": {
        "E": [
            184982392,
            184982173,
            184938042,
            184950686,
            184932260,
            184939673,
            184936898,
            184934396,
            184948204,
            184935811,
            184943315,
            184989151,
            184947057,
            184952057,
            184938439,
            184967483,
            187916344,
            184948513,
            184933180,
            184935854,
            184939624,
            184943840,
            184943132,
            184940980
        ],
        "F": [
            184949728,
            184939667,
            184976950,
            184964579,
            184958474,
            184962483,
            184966185,
            184957638,
            184969067,
            185089664,
            185089530,
            184977947,
            184997639,
            184973757,
            184966070,
            184960435,
            184974697,
            184966631,
            184990205,
            184997420
        ],
        "D": [
            184914984,
            184986868,
            184986781,
            184917638,
            184915781,
            184923898,
            184923871,
            184918405,
            184919375,
            184923813,
            184918585,
            184915933,
            184925192,
            184969262,
            184952734,
            184970967,
            184919304,
            184918923,
            184922752,
            184918317,
            184920694,
            184924980
        ],
        "C": [
            184909482,
            184913973,
            184911632,
            184918401,
            184916364,
            185395845,
            184914719,
            184914076,
            184920058,
            184913612,
            184913225,
            184921601,
            184918048,
            184950984,
            184973944,
            184914889,
            184913008,
            184914015,
            184915845,
            184914942,
            184915187
        ],
        "B": [
            184907198,
            184909422,
            184907991,
            184909353,
            184910422,
            184907995,
            184908723,
            184907965,
            184908129,
            184908832,
            184911921,
            184911885,
            184949263,
            184977162,
            184909079,
            184908305,
            184909027,
            184908934,
            184911337,
            184910448
        ],
        "A": [
            184906447,
            184906808,
            184906511,
            184906536,
            184906567,
            184906521,
            184906485,
            184906494,
            184906490,
            184992052,
            184907067,
            184906532,
            184906851,
            184947991,
            184978729,
            184906583,
            184906564,
            184906598,
            184906512,
            184906683,
            184906543
        ]
    },
    "name": "B. Notepad ",
    "statement": "You want to type the string s, consisting of n lowercase Latin letters,\r\nusing your favorite text editor Notepad#.Notepad# supports two kinds of\r\noperations: append any letter of the string; copy a substring of an\r\nalready typed string and paste this substring of the string. Can you\r\ntype string s in than n operations?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int t;\n  cin >> t;\n  for (int i = 0; i < t; i++){\n    int n;\n    cin >> n;\n    string s;\n    cin >> s;\n    set<string> st;\n    bool ok = false;\n    for (int j = 0; j < n - 1; j++){\n      if (st.count(s.substr(j, 2)) == 1){\n        ok = true;\n      }\n      if (j >= 1){\n        st.insert(s.substr(j - 1, 2));\n      }\n    }\n    if (ok){\n      cout << \"YES\" << endl;\n    } else {\n      cout << \"NO\" << endl;\n    }\n  }\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Notepad .json",
    "editorial_link": "https://codeforces.com//blog/entry/110066",
    "editorial": "Why does the problem ask us only to check if we can do less than\r\noperations instead of just asking the minimum amount? That must be\r\nmaking the problem easier, so letâs focus our attention on that.What if\r\nit was instead of ? Well, then the problem would be trivial. You can\r\ntype the word letter by letter and be done in operations. So we only\r\nhave to save one operation. In order to save at least one operation, we\r\nhave to use the copy operation and copy more than one character in\r\nthat.Letâs take a closer look at any of the copy operations we do.\r\nBasically, it has to be a substring that has at least two\r\nnon-intersection occurrences in the string. Thus, if the string has any\r\nsubstring that has length at least two that appears at least twice in\r\nthe string, we can copy it, and the answer will be \"\".Thatâs still not\r\nenough to solve the problem weâd have to check all substrings, which is\r\n.Letâs think further. Imagine we found a substring that works. Let it\r\nhave length . Notice how you can remove its last character, obtaining a\r\nsubstring of length , and it will still occure in the same set of\r\npositions (possibly, even more occurrences will be found). Remove\r\ncharacters until the substring has length . Thus, if any appropriate\r\nsubstring exists, an appropriate substring of length also\r\nexists.Finally, we can check if there exists a substring of length that\r\nappears at least twice in the string so that the occurrences are at\r\nleast apart. That can be done with a set/hashset or a map/hashmap. Some\r\nimplementations might require careful handling of the substrings of kind\r\n\"\", \"\" and similar.Overall complexity: or per testcase.\r\n",
    "hint": []
}