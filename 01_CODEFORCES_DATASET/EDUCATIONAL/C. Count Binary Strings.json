{
    "link": "https://codeforces.com//contest/1767/problem/C",
    "problemId": "1697002",
    "problem_idx": "C",
    "shortId": "1767C",
    "contest_number": "1767",
    "problem_submissions": {
        "F": [
            185514153,
            185548652,
            185548569,
            185548494,
            185548166,
            185548104,
            185548070,
            185547990,
            185547931,
            185538816,
            185538731,
            185536681,
            185536510,
            185533881,
            185548043,
            185547524,
            185547405,
            187061027,
            188938985,
            188938874,
            188938733,
            188938538,
            188662943
        ],
        "E": [
            185496241,
            185503484,
            185495581,
            185501980,
            185500616,
            185536545,
            185506476,
            185505796,
            185502863,
            185502893,
            185509737,
            185509089,
            185503658,
            185500454,
            188653481,
            185507693,
            185510300,
            185512188,
            185507422,
            185511136,
            191847813,
            185508302
        ],
        "D": [
            185485689,
            185480567,
            185486073,
            185487205,
            185489767,
            185484058,
            185487337,
            185490632,
            185495647,
            185490973,
            185492256,
            185494935,
            185488073,
            185492422,
            185494405,
            185494252,
            185494078,
            185493034,
            185501838
        ],
        "C": [
            185476244,
            185474583,
            185478107,
            185476554,
            185481773,
            185476338,
            185483596,
            185484239,
            185478556,
            185481931,
            185485024,
            185484128,
            185481474,
            185482158,
            185486113,
            185484367,
            185484937,
            185482445,
            185483985
        ],
        "B": [
            185470025,
            185469866,
            185470325,
            185469767,
            185469743,
            185469974,
            185468835,
            185473229,
            185470539,
            185470117,
            185471331,
            185471042,
            185470304,
            185473480,
            185472801,
            185471018,
            185472578,
            185469524,
            185472904
        ],
        "A": [
            185468810,
            185468911,
            185468716,
            185468796,
            185468875,
            185468821,
            185471076,
            185576332,
            185469327,
            185470858,
            185468733,
            185468950,
            185468986,
            185469052,
            185468910,
            185469302,
            185469202,
            185470756,
            185472308,
            185469751
        ]
    },
    "name": "C. Count Binary Strings",
    "statement": "You are given an integer n. You have to calculate the number of binary\r\n(consisting of characters and/or ) strings s meeting the following\r\nconstraints.For every pair of integers (i, j) such that 1\r\nle i\r\nle j\r\nle n, an integer a_{i,j} is given. It imposes the following constraint\r\non the string s_i s_{i+1} s_{i+2}\r\ndots s_j: if a_{i,j} = 1, all characters in s_i s_{i+1} s_{i+2}\r\ndots s_j should be the same; if a_{i,j} = 2, there should be at least\r\ntwo different characters in s_i s_{i+1} s_{i+2}\r\ndots s_j; if a_{i,j} = 0, there are no additional constraints on the\r\nstring s_i s_{i+1} s_{i+2}\r\ndots s_j. Count the number of binary strings s of length n meeting the\r\naforementioned constraints. Since the answer can be large, print it\r\nmodulo 998244353.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\n\nconst uint MOD = 998244353;\ntemplate<uint mod = MOD> struct mint { // 1000000007  1000000009\n\tuint x;\n\n\tmint() : x(0) {}\n\tmint(ll _x) {\n\t\t_x %= mod;\n\t\tif (_x < 0) _x += mod;\n\t\tx = _x;\n\t}\n\n\tmint& operator += (const mint &a) {\n\t\tx += a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator -= (const mint &a) {\n\t\tx += mod - a.x;\n\t\tif (x >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator *= (const mint &a) {\n\t\tx = (ull)x * a.x % mod;\n\t\treturn *this;\n\t}\n\tmint pow(ll pw) const {\n\t\tmint res = 1;\n\t\tmint cur = *this;\n\t\twhile(pw) {\n\t\t\tif (pw & 1) res *= cur;\n\t\t\tcur *= cur;\n\t\t\tpw >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv() const {\n\t\tassert(x != 0);\n\t\tuint t = x;\n\t\tuint res = 1;\n\t\twhile(t != 1) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn res;\n\t}\n\tmint& operator /= (const mint &a) {\n\t\treturn *this *= a.inv();\n\t}\n\tmint operator + (const mint &a) const {\n\t\treturn mint(*this) += a;\n\t}\n\tmint operator - (const mint &a) const {\n\t\treturn mint(*this) -= a;\n\t}\n\tmint operator * (const mint &a) const {\n\t\treturn mint(*this) *= a;\n\t}\n\tmint operator / (const mint &a) const {\n\t\treturn mint(*this) /= a;\n\t}\n\n\tbool sqrt(mint &res) const {\n\t\tif (mod == 2 || x == 0) {\n\t\t\tres = *this;\n\t\t\treturn true;\n\t\t}\n\t\tif (pow((mod - 1) / 2) != 1) return false;\n\t\tif (mod % 4 == 3) {\n\t\t\tres = pow((mod + 1) / 4);\n\t\t\treturn true;\n\t\t}\n\t\tint pw = (mod - 1) / 2;\n\t\tint K = 30;\n\t\twhile((1 << K) > pw) K--;\n\t\twhile(true) {\n\t\t\tmint t = myRand(mod);\n\t\t\tmint a = 0, b = 0, c = 1;\n\t\t\tfor (int k = K; k >= 0; k--) {\n\t\t\t\ta = b * b;\n\t\t\t\tb = b * c * 2;\n\t\t\t\tc = c * c + a * *this;\n\t\t\t\tif (((pw >> k) & 1) == 0) continue;\n\t\t\t\ta = b;\n\t\t\t\tb = b * t + c;\n\t\t\t\tc = c * t + a * *this;\n\t\t\t}\n\t\t\tif (b == 0) continue;\n\t\t\tc -= 1;\n\t\t\tc *= mint() - b.inv();\n\t\t\tif (c * c == *this) {\n\t\t\t\tres = c;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tassert(false);\n\t}\n\n\tbool operator == (const mint &a) const {\n\t\treturn x == a.x;\n\t}\n\tbool operator != (const mint &a) const {\n\t\treturn x != a.x;\n\t}\n\tbool operator < (const mint &a) const {\n\t\treturn x < a.x;\n\t}\n};\ntemplate<uint mod = MOD> struct Factorials {\n\tusing Mint = mint<mod>;\n\tvector<Mint> f, fi;\n\n\tFactorials() : f(), fi() {}\n\tFactorials(int n) {\n\t\tn += 10;\n\t\tf = vector<Mint>(n);\n\t\tfi = vector<Mint>(n);\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i] = f[i - 1] * i;\n\t\tfi[n - 1] = f[n - 1].inv();\n\t\tfor (int i = n - 1; i > 0; i--)\n\t\t\tfi[i - 1] = fi[i] * i;\n\t}\n\n\tMint C(int n, int k) {\n\t\tif (k < 0 || k > n) return 0;\n\t\treturn f[n] * fi[k] * fi[n - k];\n\t}\n};\ntemplate<uint mod = MOD> struct Powers {\n\tusing Mint = mint<mod>;\n\tvector<Mint> p, pi;\n\n\tPowers() : p(), pi() {}\n\tPowers(int n, Mint x) {\n\t\tn += 10;\n\t\tif (x == 0) {\n\t\t\tp = vector<Mint>(n);\n\t\t\tp[0] = 1;\n\t\t} else {\n\t\t\tp = vector<Mint>(n);\n\t\t\tpi = vector<Mint>(n);\n\t\t\tp[0] = pi[0] = 1;\n\t\t\tMint xi = x.inv();\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tp[i] = p[i - 1] * x;\n\t\t\t\tpi[i] = pi[i - 1] * xi;\n\t\t\t}\n\t\t}\n\t}\n\n\tMint pow(int n) {\n\t\tif (n >= 0)\n\t\t\treturn p[n];\n\t\telse\n\t\t\treturn pi[-n];\n\t}\n};\ntemplate<uint mod = MOD> struct Inverses {\n\tusing Mint = mint<mod>;\n\tvector<Mint> ii;\n\n\tInverses() : ii() {}\n\tInverses(int n) {\n\t\tn += 10;\n\t\tii = vector<Mint>(n);\n\t\tii[1] = 1;\n\t\tfor (int x = 2; x < n; x++)\n\t\t\tii[x] = Mint() - ii[mod % x] * (mod / x);\n\t}\n\n\tMint inv(Mint x) {\n\t\tassert(x != 0);\n\t\tuint t = x.x;\n\t\tuint res = 1;\n\t\twhile(t >= (int)ii.size()) {\n\t\t\tuint z = mod / t;\n\t\t\tres = (ull)res * (mod - z) % mod;\n\t\t\tt = mod - t * z;\n\t\t}\n\t\treturn ii[t] * res;\n\t}\n};\nusing Mint = mint<>;\n\n\nconst int N = 111;\nMint dp[N];\nbool eq[N];\nbool hasDiff[N][N];\nint n;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tif (x == 0) continue;\n\t\t\tif (x == 1) {\n\t\t\t\tfor (int k = i + 1; k < j; k++)\n\t\t\t\t\teq[k] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\thasDiff[i][j] = 1;\n\t\t}\n\tfor (int len = 1; len < n; len++)\n\t\tfor (int l = 0; l + len <= n; l++) if (hasDiff[l][l + len]) {\n\t\t\tif (l > 0) hasDiff[l - 1][l + len] = 1;\n\t\t\tif (l + len < n) hasDiff[l][l + len + 1] = 1;\n\t\t}\n\tdp[0] = 2;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (!eq[j] && !hasDiff[i][j])\n\t\t\t\tdp[j] += dp[i];\n\t\t}\n\tprintf(\"%u\\n\", dp[n].x);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dp"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Count Binary Strings.json",
    "editorial_link": "https://codeforces.com//blog/entry/110225",
    "editorial": "Suppose we build the string from left to right, and when we place the\r\n-th character, we ensure that all substrings are valid. What do we need\r\nto know in order to calculate the number of different characters in the\r\nstring ending with the -th character?Suppose the character is . Let\u00e2\u0080\u0099s\r\ntry going to the left of it. The string from to will have the same\r\ncharacters; but if there is at least one character before the -th\r\nposition, the string will have two different characters. What about the\r\nstrings in the middle? The string will contain different characters if\r\nand only if there is at least one in (since is ), so we are actually\r\ninterested in the position of the last character before .The same logic\r\napplies if the character is : we are only interested in the position of\r\nthe last before , and it is enough to check if all substrings ending\r\nwith the -th character are violated.What if when we choose the -th\r\ncharacter, we violate some substring that doesn\u00e2\u0080\u0099t end in the -th\r\nposition? Well, you could also check that... or you could just ignore\r\nit. Actually, it doesn\u00e2\u0080\u0099t matter if this happens because it means that\r\nthe substring that is violated ends in some position ; and we will check\r\nit when placing the -th character.So, the solution can be formulated\r\nwith the following dynamic programming: let be the number of ways to\r\nchoose the first characters of the string so that the last character\r\ndifferent from was (or if there was no such character), and all the\r\nconstraints on the substrings ending no later than position are\r\nsatisfied. The transitions are simple: you either place the same\r\ncharacter as the last one (going from to ), or a different character\r\n(going from to ); and when you place a character, you check all the\r\nconstraints on the substrings ending with the -th position. Note that\r\nthe state is actually represented by two strings: and .This solution\r\nworks in , although or implementations are also possible.\r\n"
}