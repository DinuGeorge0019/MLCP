{"link": "https://codeforces.com//contest/1140/problem/G", "problemId": "317590", "problem_idx": "G", "shortId": "1140G", "contest_number": "1140", "problem_submissions": {"G": [51711380, 51715425, 51701961, 51723677, 51713161, 51826208, 51725702, 51751383, 51751094, 51871694], "E": [51707475, 51698157, 51710451, 51699057, 51698619, 51700718, 51698345, 51703686, 51826592, 51711304, 51706757, 51709505, 51702992, 51711975, 51716308, 51694918, 51707265, 51699848, 51701075, 51700169, 51701450], "F": [51700190, 51704937, 51708125, 51707572, 51715636, 51713154, 51709309, 51745229, 51724116, 51717194, 51826549, 51704389, 51714714, 51719425, 51719809, 51889038, 51888545, 51716543, 51712779, 51717719, 51719576, 51772442, 51734097, 51801995, 52594541, 52594485], "D": [51692897, 51692552, 51711200, 51692355, 51691890, 51695018, 51693289, 51690531, 51826633, 51691126, 51688766, 51694582, 51696697, 51687330, 51696460, 51700363, 51702095, 51691157, 51691573, 51691854, 51693356], "C": [51691812, 51690406, 51711880, 51691405, 51690720, 51691755, 51691383, 51689446, 51826659, 51690305, 51696638, 51692263, 51691635, 51692542, 51695004, 51699456, 51696505, 51690289, 51689951, 51689550, 51688775], "B": [51689841, 51689192, 51712746, 51689822, 51689241, 51688933, 51689569, 51688189, 51826766, 51688939, 51690552, 51689048, 51689939, 51691885, 51692884, 51696524, 51689978, 51688514, 51688185, 51688344, 51690712], "A": [51687668, 51687221, 51713210, 51688333, 51687348, 51687390, 51687760, 51687210, 51826788, 51687239, 51687778, 51687499, 51688125, 51688099, 51687757, 51687342, 51688091, 51687317, 51687203, 51687474, 51687413]}, "name": "G. Double Tree", "statement": "You are given a special undirected graph. It consists of 2n vertices\r\nnumbered from 1 to 2n. The following properties hold for the graph:\r\nthere are exactly 3n-2 edges in the graph: n edges connect vertices\r\nhaving odd numbers with vertices having even numbers, n - 1 edges\r\nconnect vertices having odd numbers with each other, and n - 1 edges\r\nconnect vertices having even numbers with each other; for each edge (u,\r\nv) between a pair of vertices with odd numbers, there exists an edge\r\n(u + 1, v + 1), and vice versa; for each odd number u\r\nin [1, 2n - 1], there exists an edge (u, u + 1); the graph is connected;\r\nmoreover, if we delete all vertices with even numbers from it, and all\r\nedges incident to them, the graph will become a tree (the same applies\r\nto deleting odd vertices).So, the graph can be represented as two trees\r\nhaving the same structure, and n edges connecting each vertex of the\r\nfirst tree to the corresponding vertex of the second tree.Edges of the\r\ngraph are weighted. The length of some simple path in the graph is the\r\nsum of weights of traversed edges.You are given q queries to this graph;\r\nin each query, you are asked to compute the length of the shortest path\r\nbetween some pair of vertices in this graph. Can you answer all of the\r\nqueries?\r\n", "solutions": ["#include<bits/stdc++.h>\nusing namespace std;\n#define li long long\n#define gc getchar()\n#define pc putchar\n//char buf[100000],*buff = buf + 100000;\n//#define gc (buff == buf + 100000 ? (fread(buf,1,100000,stdin),buff = buf) : 0,*buff++)\ninline li read(){\n\tli x = 0,y = 0,c = gc;\n\twhile(!isdigit(c)) y = c,c = gc;\n\twhile(isdigit(c)) x = x * 10 + (c ^ '0'),c = gc;\n\treturn y == '-' ? -x : x;\n}\ninline void print(li x){\n\tif(x < 0) pc('-'),x = -x;\n\tif(x >= 10) print(x / 10);\n\tpc(x % 10 + '0');\n}\nint n,m;\nli a[600010],b[600010];\nstruct edge{\n\tint to,nxt;\n\tli v1,v2;\n}e[600010];\nint cnt = 1,fir[600010];\ninline void ins(int u,int v,li w,li x){\n\te[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;e[cnt].v1 = w;e[cnt].v2 = x;\n\te[++cnt].to = u;e[cnt].nxt = fir[v];fir[v] = cnt;e[cnt].v1 = w;e[cnt].v2 = x;\n}\nint fa[600010],f[600010],l[600010],r[600010],wz[600010],ed[600010],nw;\nbool c[600010];\n#define inf 987654321987654321ll\nli pp[600010][2][2];\nli d1[600010],d2[600010],v1[600010],v2[600010];\nli t[1200010],d[1200010];\n#define ls q << 1\n#define rs q << 1 | 1\n#define ln ls,l,mid\n#define rn rs,mid + 1,r\n#define md int mid = l + r >> 1\ninline void psc(int q){\n\tif(!d[q]) return;\n\tt[ls] += d[q];d[ls] += d[q];\n\tt[rs] += d[q];d[rs] += d[q];\n\td[q] = 0;\n}\ninline void xg(int q,int l,int r,int al,int ar,li x){\n\tif(al > ar) return;\n\tif(l >= al && r <= ar){\n\t\tt[q] += x;d[q] += x;\n\t\treturn;\n\t}\n\tpsc(q);md;\n\tif(mid >= al) xg(ln,al,ar,x);\n\tif(mid < ar) xg(rn,al,ar,x);\n\tt[q] = min(t[ls],t[rs]);\n}\ninline void dfs(int q){\n\twz[q] = ++nw;\n\txg(1,1,n,wz[q],wz[q],d1[q] + d2[q] + a[q]);\n\tfor(int i = fir[q];i;i = e[i].nxt) if(e[i].to != fa[q]){\n\t\tfa[e[i].to] = q;\n\t\tint tmp = n + (i >> 1);\n\t\tf[tmp] = q;f[e[i].to] = tmp;\n\t\tpp[tmp][0][1] = pp[tmp][1][0] = inf;pp[tmp][0][0] = v1[tmp] = e[i].v1;pp[tmp][1][1] = v2[tmp] = e[i].v2;\n\t\td1[e[i].to] = d1[q] + e[i].v1;\n\t\td2[e[i].to] = d2[q] + e[i].v2;\n\t\tdfs(e[i].to);\n\t}\n\ted[q] = nw;\n}\ninline void dfs2(int q){\n\tb[q] = t[1];\n\tfor(int i = fir[q];i;i = e[i].nxt) if(e[i].to != fa[q]){\n\t\txg(1,1,n,wz[e[i].to],ed[e[i].to],-e[i].v1 - e[i].v2);\n\t\txg(1,1,n,1,wz[e[i].to] - 1,e[i].v1 + e[i].v2);\n\t\txg(1,1,n,ed[e[i].to] + 1,n,e[i].v1 + e[i].v2);\n\t\tdfs2(e[i].to);\n\t\txg(1,1,n,wz[e[i].to],ed[e[i].to],e[i].v1 + e[i].v2);\n\t\txg(1,1,n,1,wz[e[i].to] - 1,-e[i].v1 - e[i].v2);\n\t\txg(1,1,n,ed[e[i].to] + 1,n,-e[i].v1 - e[i].v2);\n\t}\n}\ninline bool is(int q){\n    return l[f[q]] != q && r[f[q]] != q;\n}\nli tpp[2][2];\ninline void ud(int q){\n    if(q <= n){\n    \tpp[q][0][0] = pp[q][1][1] = 0;\n    \tpp[q][0][1] = pp[q][1][0] = b[q];\n\t}\n\telse{\n\t\tpp[q][0][1] = pp[q][1][0] = inf;\n\t\tpp[q][0][0] = v1[q];pp[q][1][1] = v2[q];\n\t}\n    if(l[q]){\n    \ttpp[0][0] = min(pp[l[q]][0][0] + pp[q][0][0],pp[l[q]][0][1] + pp[q][1][0]);\n    \ttpp[0][1] = min(pp[l[q]][0][0] + pp[q][0][1],pp[l[q]][0][1] + pp[q][1][1]);\n    \ttpp[1][0] = min(pp[l[q]][1][0] + pp[q][0][0],pp[l[q]][1][1] + pp[q][1][0]);\n    \ttpp[1][1] = min(pp[l[q]][1][0] + pp[q][0][1],pp[l[q]][1][1] + pp[q][1][1]);\n    \tmemcpy(pp[q],tpp,sizeof(pp[q]));\n\t}\n    if(r[q]){\n    \ttpp[0][0] = min(pp[q][0][0] + pp[r[q]][0][0],pp[q][0][1] + pp[r[q]][1][0]);\n    \ttpp[0][1] = min(pp[q][0][0] + pp[r[q]][0][1],pp[q][0][1] + pp[r[q]][1][1]);\n    \ttpp[1][0] = min(pp[q][1][0] + pp[r[q]][0][0],pp[q][1][1] + pp[r[q]][1][0]);\n    \ttpp[1][1] = min(pp[q][1][0] + pp[r[q]][0][1],pp[q][1][1] + pp[r[q]][1][1]);\n    \tmemcpy(pp[q],tpp,sizeof(pp[q]));\n\t}\n}\ninline void rv(int q){\n    c[q] ^= 1;swap(l[q],r[q]);\n    swap(pp[q][0][1],pp[q][1][0]);\n}\ninline void ps(int q){\n    if(!c[q]) return;\n    if(l[q]) rv(l[q]);\n    if(r[q]) rv(r[q]);\n    c[q] = 0;\n}\ninline void ro(int q){\n    int p = f[q];\n    if(l[f[p]] == p) l[f[p]] = q;\n    else if(r[f[p]] == p) r[f[p]] = q;\n    f[q] = f[p];f[p] = q;\n    if(l[p] == q){\n        l[p] = r[q];r[q] = p;\n        if(l[p]) f[l[p]] = p;\n    }\n    else{\n        r[p] = l[q];l[q] = p;\n        if(r[p]) f[r[p]] = p;\n    }\n    if(is(q)) memcpy(pp[q],pp[p],sizeof(pp[q]));\n    ud(p);\n}\ninline void gx(int q){\n    if(!is(q)) gx(f[q]);\n    ps(q);\n}\ninline void sp(int q){\n    gx(q);\n    while(!is(q)){\n        int p = f[q];\n        if(!is(p)){\n            if((l[f[p]] == p) ^ (l[p] == q)) ro(q);\n            else ro(p);\n        }\n        ro(q);\n    }\n}\ninline void ac(int q){\n    int p = 0;\n    while(q){\n        sp(q);r[q] = p;ud(q);p = q;q = f[q];\n    }\n}\ninline void mk(int q){\n    ac(q);sp(q);rv(q);\n}\ninline void si(int u,int v){\n    mk(u);ac(v);sp(v);\n}\nint main(){\n\tint i,j,u,v;\n\tli w,x;\n\tn = read();\n\tfor(i = 1;i <= n;++i) a[i] = read();\n\tfor(i = 1;i < n;++i){\n\t\tu = read();v = read();w = read();x = read();ins(u,v,w,x);\n\t}\n\tdfs(1);\n\tdfs2(1);\n\tfor(i = 1;i <= n;++i) pp[i][0][1] = pp[i][1][0] = b[i];\n\tm = read();\n\tfor(i = 1;i <= m;++i){\n\t\tu = read() + 1;v = read() + 1;\n\t\tsi(u >> 1,v >> 1);\n\t\tprint(pp[v >> 1][u & 1][v & 1]);pc('\\n');\n\t}\n\treturn 0;\n}"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "shortest paths", "trees"], "dificulty": "2700", "interactive": false}