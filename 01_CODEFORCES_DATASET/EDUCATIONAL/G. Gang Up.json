{"link": "https://codeforces.com//contest/1187/problem/G", "problemId": "365123", "problem_idx": "G", "shortId": "1187G", "contest_number": "1187", "problem_submissions": {"G": [56332310, 56340989, 56686103, 56327820, 56357942, 56357893, 56357546, 56393615, 56385554, 56337872, 56340206, 56343105, 56383525, 56344635, 56413429, 56342762, 56340438, 56341811, 56342716, 56365621], "F": [56329446, 56334290, 56324078, 56328221, 56327378, 56337303, 56342526, 56331177, 56340043, 56336355, 56334752, 56336077, 56336627, 56360333], "E": [56323030, 56330456, 56319363, 56322371, 56320247, 56329005, 56327923, 56326133, 56329409, 56326249, 56424958, 56328252, 56326656, 56325346, 56328882, 56328436, 56328661, 56323830, 56324440, 56325389], "D": [56321688, 56327439, 56325081, 56328701, 56323355, 56322789, 56358499, 56324879, 56323568, 56320080, 56323458, 56413111, 56325452, 56541360, 56321839, 56320767, 56323441], "C": [56317291, 56315455, 56314711, 56314827, 56313223, 56319121, 56318984, 56317025, 56320070, 56318484, 56425545, 56329379, 56320274, 56318352, 56316738, 56318754, 56319277, 56317240, 56316893, 56317391], "B": [56314215, 56313013, 56312493, 56311346, 56311654, 56315580, 56313289, 56312101, 56313618, 56315894, 56313703, 56315753, 56314242, 56313556, 56315340, 56314265, 56313400, 56314155, 56314393], "A": [56311354, 56311017, 56311059, 56312444, 56310978, 56312306, 56311272, 56310955, 56311255, 56311625, 56311777, 56313786, 56311277, 56310994, 56311316, 56311426, 56311025, 56311856, 56311363]}, "name": "G. Gang Up", "statement": "The leader of some very secretive organization has decided to invite all\r\nother members to a meeting. All members of the organization live in the\r\nsame town which can be represented as n crossroads connected by m\r\ntwo-directional streets. The meeting will be held in the leader\u2019s house\r\nnear the crossroad 1. There are k members of the organization invited to\r\nthe meeting; i-th of them lives near the crossroad a_i. All members of\r\nthe organization receive the message about the meeting at the same\r\nmoment and start moving to the location where the meeting is held. In\r\nthe beginning of each minute each person is located at some crossroad.\r\nHe or she can either wait a minute at this crossroad, or spend a minute\r\nto walk from the current crossroad along some street to another\r\ncrossroad (obviously, it is possible to start walking along the street\r\nonly if it begins or ends at the current crossroad). In the beginning of\r\nthe first minute each person is at the crossroad where he or she lives.\r\nAs soon as a person reaches the crossroad number 1, he or she\r\nimmediately comes to the leader\u2019s house and attends the\r\nmeeting.Obviously, the leader wants all other members of the\r\norganization to come up as early as possible. But, since the\r\norganization is very secretive, the leader does not want to attract much\r\nattention. Let\u2019s denote the of the leader as follows initially the\r\ndiscontent is 0; whenever a person reaches the crossroad number 1, the\r\ndiscontent of the leader increases by c\r\ncdot x, where c is some fixed constant, and x is the number of minutes\r\nit took the person to reach the crossroad number 1; whenever x members\r\nof the organization walk , dx^2 is added to the discontent, where d is\r\nsome fixed constant. This is not cumulative: for example, if two persons\r\nare walking along the same street in the same direction at the same\r\nmoment, then 4d is added to the discontent, not 5d. Before sending a\r\nmessage about the meeting, the leader can tell each member of the\r\norganization which path they should choose and where they should wait.\r\nHelp the leader to establish a plan for every member of the organization\r\nso they all reach the crossroad 1, and the discontent is minimized.\r\n", "solutions": ["//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\nconst int mag=150;\n\nstruct MinCost {\n\tstruct kra {\n\t\tint cel, *prze1, *prze2;\n\t\tll koszt;\n\t};\n\tint n=0, zr, uj;\n\tconst ll inf=1e9;\n\tvector <vector <kra>> graf;\n\tvector <int> bylo, aktu;\n\tvector <ll> odl, pamodl;\n\tvoid vert(int v) {\n\t\tif (v>n) {\n\t\t\tn=v;\n\t\t\tgraf.resize(n);\n\t\t\tbylo.resize(n);\n\t\t\taktu.resize(n);\n\t\t\todl.resize(n);\n\t\t\tpamodl.resize(n);\n\t\t}\n\t}\n\tvoid add_edge(int v, int u, int prze, ll koszt) {\n\t\tvert(v+1); vert(u+1);\n\t\tkra ret1{u, new int(prze), new int(0), koszt};\n\t\tkra ret2{v, ret1.prze2, ret1.prze1, -koszt};\n\t\tgraf[v].push_back(ret1);\n\t\tgraf[u].push_back(ret2);\n\t}\n\tvoid spfa() {\n\t\tfor (int i=0; i<n; i++) {\n\t\t\taktu[i]=1;\n\t\t\tpamodl[i]=inf;\n\t\t}\n\t\taktu[zr]=pamodl[zr]=0;\n\t\tqueue <int> kol;\n\t\tkol.push(zr);\n\t\twhile(!kol.empty()) {\n\t\t\tint v=kol.front();\n\t\t\tkol.pop();\n\t\t\tif (aktu[v])\n\t\t\t\tcontinue;\n\t\t\taktu[v]=1;\n\t\t\tfor (kra i : graf[v]) {\n\t\t\t\tif (*i.prze1 && pamodl[v]+i.koszt<pamodl[i.cel]) {\n\t\t\t\t\tpamodl[i.cel]=pamodl[v]+i.koszt;\n\t\t\t\t\taktu[i.cel]=0;\n\t\t\t\t\tkol.push(i.cel);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid dij() {\n\t\tfor (int i=0; i<n; i++)\n\t\t\todl[i]=inf;\n\t\tpriority_queue < pair <ll,int> > dijks;\n\t\tdijks.push({0, zr});\n\t\twhile(!dijks.empty()) {\n\t\t\tll dis=-dijks.top().first;\n\t\t\tint v=dijks.top().second;\n\t\t\tdijks.pop();\n\t\t\tif (odl[v]!=inf)\n\t\t\t\tcontinue;\n\t\t\todl[v]=pamodl[v]+dis;\n\t\t\tfor (auto j : graf[v])\n\t\t\t\tif ((*j.prze1) && odl[j.cel]==inf)\n\t\t\t\t\tdijks.push({-(dis+pamodl[v]-pamodl[j.cel]+j.koszt), j.cel});\n\t\t}\n\t}\n\tint dfs(int v) {\n\t\tif (v==uj)\n\t\t\treturn 1;\n\t\tbylo[v]=1;\n\t\tfor (int i=0; i<(int)graf[v].size(); i++) {\n\t\t\tif (!bylo[graf[v][i].cel] && (*graf[v][i].prze1) &&\n\t\t\todl[v]+graf[v][i].koszt==odl[graf[v][i].cel] && dfs(graf[v][i].cel)) {\n\t\t\t\t(*graf[v][i].prze1)--;\n\t\t\t\t(*graf[v][i].prze2)++;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpair <int,ll> flow(int zrzr, int ujuj) {\n\t\tzr=zrzr; uj=ujuj;\n\t\tvert(zr+1); vert(uj+1);\n\t\t//~ spfa();\n\t\tpair <int,ll> ret{0, 0};\n\t\twhile(1) {\n\t\t\t//~ dij();\n\t\t\tspfa();\n\t\t\todl=pamodl;\n\t\t\tfor (int i=0; i<n; i++)\n\t\t\t\tbylo[i]=0;\n\t\t\tif (!dfs(zr))\n\t\t\t\tbreak;\n\t\t\tret.first++;\n\t\t\tret.second+=odl[uj];\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n\nint n, m, k, c, d;\n\nint main()\n{\n\tscanf(\"%d%d%d%d%d\", &n, &m, &k, &c, &d);\n\tMinCost janusz;\n\tint zr=mag*n+1;\n\tfor (int i=0; i<mag; i++)\n\t\tjanusz.add_edge(i*n+1, 0, k, 0);\n\tfor (int i=0; i+1<mag; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tjanusz.add_edge(i*n+j, (i+1)*n+j, k, c);\n\tfor (int i=1; i<=k; i++)\n\t{\n\t\tint x;\n\t\tscanf(\"%d\", &x);\n\t\tjanusz.add_edge(zr, x, 1, 0);\n\t}\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tfor (int h=0; h<2; h++)\n\t\t{\n\t\t\tfor (int j=0; j+1<mag; j++)\n\t\t\t\tfor (int l=1; l<=k; l++)\n\t\t\t\t\tjanusz.add_edge(j*n+a, (j+1)*n+b, 1, (2*l-1)*d+c);\n\t\t\tswap(a, b);\n\t\t}\n\t}\n\tauto wez=janusz.flow(zr, 0);\n\tassert(wez.first==k);\n\tprintf(\"%lld\\n\", wez.second);\n\treturn 0;\n}\n"], "input": "", "output": "", "tags": ["flows", "graphs"], "dificulty": "2500", "interactive": false}