{"link": "https://codeforces.com//contest/1841/problem/E", "problemId": "1962594", "problem_idx": "E", "shortId": "1841E", "contest_number": "1841", "problem_submissions": {"F": [209441446, 209449956, 209447296, 209453943, 209449863, 209446444, 209454347, 209678776, 209452092, 209454468, 209458945, 209453449, 209451716, 209465466, 209464638, 209461720, 209460276, 209459819, 209458504, 209458152, 209453975, 209486469, 209486319, 209486054, 209459375, 209456147, 209463444, 209466329, 209466771, 209609259, 209462972, 209467839, 209463203], "E": [209420520, 209430600, 209434973, 209427885, 209438551, 209434946, 209433065, 209431302, 209443745, 209434541, 209438545, 209438034, 209444420, 209422689, 209420477, 209458913, 209440856, 209447420, 209460885, 209429843], "D": [209412776, 209418240, 209420286, 209421079, 209475842, 209428591, 209423202, 209420942, 209417076, 209424719, 209423326, 209425276, 209464164, 209425284, 209430127, 209413537, 209411059, 209426861, 209442988, 209439319, 209441486, 209421279], "C": [209400973, 209405174, 209401188, 209410862, 209415662, 209408968, 209409562, 209408253, 209414636, 209413637, 209410942, 209421138, 209419542, 209405503, 209431667, 209409468, 209421971, 209433784, 209431914, 209416091], "B": [209395303, 209394968, 209391532, 209391351, 209395229, 209393535, 209397133, 209392667, 209405342, 209396380, 209399455, 209465838, 209465126, 209398959, 209401067, 209395449, 209398643, 209399436, 209394778, 209404496, 209407644, 209470007], "A": [209388179, 209388192, 209387876, 209387947, 209389004, 209388221, 209388559, 209388171, 209393927, 209405420, 209388257, 209389054, 209391461, 209401864, 209387894, 209390233, 209387972, 209392823, 209407382, 209389297]}, "name": "E. Fill the Matrix", "statement": "There is a square matrix, consisting of n rows and n columns of cells,\r\nboth numbered from 1 to n. The cells are colored white or black. Cells\r\nfrom 1 to a_i are black, and cells from a_i+1 to n are white, in the\r\ni-th column.You want to place m integers in the matrix, from 1 to m.\r\nThere are two rules: each cell should contain at most one integer; black\r\ncells should not contain integers. The of the matrix is the number of\r\nsuch j that j+1 is written in the same row, in the next column as j (in\r\nthe neighbouring cell to the right).What\u2019s the maximum possible beauty\r\nof the matrix?\r\n", "solutions": ["#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << \" \"; cout << v[i];\n    }\n    cout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\ntemplate<typename T>\nstruct SegT {\nprivate:\n    int sz; vector<T> node;\n    T init_c;\n    function<T(T, T)> f;\npublic:\n    SegT(vector<T> v, T _init_c, function<T(T, T)> _f) {\n        init_c = _init_c; f = _f;\n        int n = v.size();\n        sz = 1;\n        while (sz < n)sz *= 2;\n        node.resize(2 * sz - 1, init_c);\n        rep(i, n) {\n            node[i + sz - 1] = v[i];\n        }\n        per(i, sz - 1) {\n            node[i] = f(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n    SegT(int n, T _init_c, function<T(T, T)> _f) {\n        init_c = _init_c; f = _f;\n        sz = 1;\n        while (sz < n)sz *= 2;\n        node.resize(2 * sz - 1, init_c);\n    }\n    void update(int k, T a) {\n        k += sz - 1;\n        node[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            node[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n        }\n    }\n    T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0)r = sz;\n        if (r <= a || b <= l)return init_c;\n        else if (a <= l && r <= b)return node[k];\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return f(vl, vr);\n        }\n    }\n    //k\u4ee5\u4e0a\u3067f(x,node[y+sz-1])\u3092true\u306b\u3059\u308b\u3088\u3046\u306a\u6700\u5c0f\u306ey\n    int searchloc(int le, T x, function<bool(T, T)> comp) {\n        int  k = le + sz - 1;\n        if (comp(x, node[k]))return le;\n        x = f(x, node[k]);\n        while (k > 0) {\n            int mem = k;\n            k = (k - 1) / 2;\n            if (2 * k + 1 == mem) {\n                if (comp(x, node[2 * k + 2])) {\n                    k = 2 * k + 2; break;\n                }\n                x = f(x, node[2 * k + 2]);\n            }\n        }\n        if (k == 0)return sz;\n        while (k < sz - 1) {\n            if (comp(x, node[2 * k + 1])) {\n                k = 2 * k + 1;\n            }\n            else {\n                x = f(x, node[2 * k + 1]);\n                k = 2 * k + 2;\n            }\n        }\n        return k - (sz - 1);\n    }\n\n};\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    rep(i, n)cin >> a[i];\n    auto f = [&](P a, P b) {\n        return max(a, b);\n    };\n    vector<P> ori(n);\n    rep(i, n)ori[i] = { a[i],i };\n    SegT<P> st(ori, { -1,-1 }, f);\n    vector<P> ps;\n    function<void(int, int, int)> dfs = [&](int l, int r, int d) {\n        if (l >= r)return;\n        P p = st.query(l, r);\n        int m = p.second;\n        if (a[m] < d) {\n            ps.push_back({ r - l,d - a[m] });\n        }\n        dfs(l, m, a[m]);\n        dfs(m + 1, r, a[m]);\n    };\n    dfs(0, n, n);\n    sort(all(ps), greater<P>());\n    ll ans = 0;\n    ll k; cin >> k;\n    rep(i, ps.size()) {\n        ll c = ps[i].second;\n        ll len = ps[i].first;\n        if (k <= c*len) {\n            ll d = k / len;\n            ans += (len - 1) * d;\n            ll r = k % len;\n            if (r > 0)ans += r - 1;\n            break;\n        }\n        else {\n            ans += (len - 1) * c;\n            k -= c * len;\n        }\n    }\n    //cout << \"ans is \";\n    cout << ans << \"\\n\";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "greedy", "math"], "dificulty": "2200", "interactive": false}