{
    "link": "https://codeforces.com//contest/1841/problem/E",
    "problemId": "1962594",
    "problem_idx": "E",
    "shortId": "1841E",
    "contest_number": "1841",
    "problem_submissions": {
        "F": [
            209441446,
            209449956,
            209447296,
            209453943,
            209449863,
            209446444,
            209454347,
            209678776,
            209452092,
            209454468,
            209458945,
            209453449,
            209451716,
            209465466,
            209464638,
            209461720,
            209460276,
            209459819,
            209458504,
            209458152,
            209453975,
            209486469,
            209486319,
            209486054,
            209459375,
            209456147,
            209463444,
            209466329,
            209466771,
            209609259,
            209462972,
            209467839,
            209463203
        ],
        "E": [
            209420520,
            209430600,
            209434973,
            209427885,
            209438551,
            209434946,
            209433065,
            209431302,
            209443745,
            209434541,
            209438545,
            209438034,
            209444420,
            209422689,
            209420477,
            209458913,
            209440856,
            209447420,
            209460885,
            209429843
        ],
        "D": [
            209412776,
            209418240,
            209420286,
            209421079,
            209475842,
            209428591,
            209423202,
            209420942,
            209417076,
            209424719,
            209423326,
            209425276,
            209464164,
            209425284,
            209430127,
            209413537,
            209411059,
            209426861,
            209442988,
            209439319,
            209441486,
            209421279
        ],
        "C": [
            209400973,
            209405174,
            209401188,
            209410862,
            209415662,
            209408968,
            209409562,
            209408253,
            209414636,
            209413637,
            209410942,
            209421138,
            209419542,
            209405503,
            209431667,
            209409468,
            209421971,
            209433784,
            209431914,
            209416091
        ],
        "B": [
            209395303,
            209394968,
            209391532,
            209391351,
            209395229,
            209393535,
            209397133,
            209392667,
            209405342,
            209396380,
            209399455,
            209465838,
            209465126,
            209398959,
            209401067,
            209395449,
            209398643,
            209399436,
            209394778,
            209404496,
            209407644,
            209470007
        ],
        "A": [
            209388179,
            209388192,
            209387876,
            209387947,
            209389004,
            209388221,
            209388559,
            209388171,
            209393927,
            209405420,
            209388257,
            209389054,
            209391461,
            209401864,
            209387894,
            209390233,
            209387972,
            209392823,
            209407382,
            209389297
        ]
    },
    "name": "E. Fill the Matrix",
    "statement": "There is a square matrix, consisting of n rows and n columns of cells,\r\nboth numbered from 1 to n. The cells are colored white or black. Cells\r\nfrom 1 to a_i are black, and cells from a_i+1 to n are white, in the\r\ni-th column.You want to place m integers in the matrix, from 1 to m.\r\nThere are two rules: each cell should contain at most one integer; black\r\ncells should not contain integers. The of the matrix is the number of\r\nsuch j that j+1 is written in the same row, in the next column as j (in\r\nthe neighbouring cell to the right).What’s the maximum possible beauty\r\nof the matrix?\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\n#include<array>\n#include<chrono>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\n//ll mod = 1;\nconstexpr ll mod = 998244353;\n//constexpr ll mod = 1000000007;\nconst int mod17 = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\n\nusing ld = long double;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-10;\nconst ld pi = acosl(-1.0);\n\ntemplate<typename T>\nvoid chmin(T& a, T b) {\n    a = min(a, b);\n}\ntemplate<typename T>\nvoid chmax(T& a, T b) {\n    a = max(a, b);\n}\ntemplate<typename T>\nvector<T> vmerge(vector<T>& a, vector<T>& b) {\n    vector<T> res;\n    int ida = 0, idb = 0;\n    while (ida < a.size() || idb < b.size()) {\n        if (idb == b.size()) {\n            res.push_back(a[ida]); ida++;\n        }\n        else if (ida == a.size()) {\n            res.push_back(b[idb]); idb++;\n        }\n        else {\n            if (a[ida] < b[idb]) {\n                res.push_back(a[ida]); ida++;\n            }\n            else {\n                res.push_back(b[idb]); idb++;\n            }\n        }\n    }\n    return res;\n}\ntemplate<typename T>\nvoid cinarray(vector<T>& v) {\n    rep(i, v.size())cin >> v[i];\n}\ntemplate<typename T>\nvoid coutarray(vector<T>& v) {\n    rep(i, v.size()) {\n        if (i > 0)cout << \" \"; cout << v[i];\n    }\n    cout << \"\\n\";\n}\nll mod_pow(ll x, ll n, ll m = mod) {\n    if (n < 0) {\n        ll res = mod_pow(x, -n, m);\n        return mod_pow(res, m - 2, m);\n    }\n    if (abs(x) >= m)x %= m;\n    if (x < 0)x += m;\n    //if (x == 0)return 0;\n    ll res = 1;\n    while (n) {\n        if (n & 1)res = res * x % m;\n        x = x * x % m; n >>= 1;\n    }\n    return res;\n}\n//mod should be <2^31\nstruct modint {\n    int n;\n    modint() :n(0) { ; }\n    modint(ll m) {\n        if (m < 0 || mod <= m) {\n            m %= mod; if (m < 0)m += mod;\n        }\n        n = m;\n    }\n    operator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nbool operator<(modint a, modint b) { return a.n < b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= (int)mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += (int)mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n    if (n == 0)return modint(1);\n    modint res = (a * a) ^ (n / 2);\n    if (n % 2)res = res * a;\n    return res;\n}\n\nll inv(ll a, ll p) {\n    return (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nmodint operator/=(modint& a, modint b) { a = a / b; return a; }\nconst int max_n = 1 << 20;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n    fact[0] = modint(1);\n    for (int i = 0; i < max_n - 1; i++) {\n        fact[i + 1] = fact[i] * modint(i + 1);\n    }\n    factinv[max_n - 1] = modint(1) / fact[max_n - 1];\n    for (int i = max_n - 2; i >= 0; i--) {\n        factinv[i] = factinv[i + 1] * modint(i + 1);\n    }\n}\nmodint comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[b] * factinv[a - b];\n}\nmodint combP(int a, int b) {\n    if (a < 0 || b < 0 || a < b)return 0;\n    return fact[a] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n    a = abs(a); b = abs(b);\n    if (a < b)swap(a, b);\n    while (b) {\n        ll r = a % b; a = b; b = r;\n    }\n    return a;\n}\ntemplate<typename T>\nvoid addv(vector<T>& v, int loc, T val) {\n    if (loc >= v.size())v.resize(loc + 1, 0);\n    v[loc] += val;\n}\n/*const int mn = 2000005;\nbool isp[mn];\nvector<int> ps;\nvoid init() {\n    fill(isp + 2, isp + mn, true);\n    for (int i = 2; i < mn; i++) {\n        if (!isp[i])continue;\n        ps.push_back(i);\n        for (int j = 2 * i; j < mn; j += i) {\n            isp[j] = false;\n        }\n    }\n}*/\n\n//[,val)\ntemplate<typename T>\nauto prev_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    if (res == st.begin())return st.end();\n    res--; return res;\n}\n\n//[val,)\ntemplate<typename T>\nauto next_itr(set<T>& st, T val) {\n    auto res = st.lower_bound(val);\n    return res;\n}\nusing mP = pair<modint, modint>;\nmP operator+(mP a, mP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nmP operator+=(mP& a, mP b) {\n    a = a + b; return a;\n}\nmP operator-(mP a, mP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nmP operator-=(mP& a, mP b) {\n    a = a - b; return a;\n}\nLP operator+(LP a, LP b) {\n    return { a.first + b.first,a.second + b.second };\n}\nLP operator+=(LP& a, LP b) {\n    a = a + b; return a;\n}\nLP operator-(LP a, LP b) {\n    return { a.first - b.first,a.second - b.second };\n}\nLP operator-=(LP& a, LP b) {\n    a = a - b; return a;\n}\n\nmt19937 mt(time(0));\n\nconst string drul = \"DRUL\";\nstring senw = \"SENW\";\n//DRUL,or SENW\n//int dx[4] = { 1,0,-1,0 };\n//int dy[4] = { 0,1,0,-1 };\n\n//-----------------------------------------\n\ntemplate<typename T>\nstruct SegT {\nprivate:\n    int sz; vector<T> node;\n    T init_c;\n    function<T(T, T)> f;\npublic:\n    SegT(vector<T> v, T _init_c, function<T(T, T)> _f) {\n        init_c = _init_c; f = _f;\n        int n = v.size();\n        sz = 1;\n        while (sz < n)sz *= 2;\n        node.resize(2 * sz - 1, init_c);\n        rep(i, n) {\n            node[i + sz - 1] = v[i];\n        }\n        per(i, sz - 1) {\n            node[i] = f(node[2 * i + 1], node[2 * i + 2]);\n        }\n    }\n    SegT(int n, T _init_c, function<T(T, T)> _f) {\n        init_c = _init_c; f = _f;\n        sz = 1;\n        while (sz < n)sz *= 2;\n        node.resize(2 * sz - 1, init_c);\n    }\n    void update(int k, T a) {\n        k += sz - 1;\n        node[k] = a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            node[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n        }\n    }\n    T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0)r = sz;\n        if (r <= a || b <= l)return init_c;\n        else if (a <= l && r <= b)return node[k];\n        else {\n            T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return f(vl, vr);\n        }\n    }\n    //k以上でf(x,node[y+sz-1])をtrueにするような最小のy\n    int searchloc(int le, T x, function<bool(T, T)> comp) {\n        int  k = le + sz - 1;\n        if (comp(x, node[k]))return le;\n        x = f(x, node[k]);\n        while (k > 0) {\n            int mem = k;\n            k = (k - 1) / 2;\n            if (2 * k + 1 == mem) {\n                if (comp(x, node[2 * k + 2])) {\n                    k = 2 * k + 2; break;\n                }\n                x = f(x, node[2 * k + 2]);\n            }\n        }\n        if (k == 0)return sz;\n        while (k < sz - 1) {\n            if (comp(x, node[2 * k + 1])) {\n                k = 2 * k + 1;\n            }\n            else {\n                x = f(x, node[2 * k + 1]);\n                k = 2 * k + 2;\n            }\n        }\n        return k - (sz - 1);\n    }\n\n};\nvoid solve() {\n    int n; cin >> n;\n    vector<int> a(n);\n    rep(i, n)cin >> a[i];\n    auto f = [&](P a, P b) {\n        return max(a, b);\n    };\n    vector<P> ori(n);\n    rep(i, n)ori[i] = { a[i],i };\n    SegT<P> st(ori, { -1,-1 }, f);\n    vector<P> ps;\n    function<void(int, int, int)> dfs = [&](int l, int r, int d) {\n        if (l >= r)return;\n        P p = st.query(l, r);\n        int m = p.second;\n        if (a[m] < d) {\n            ps.push_back({ r - l,d - a[m] });\n        }\n        dfs(l, m, a[m]);\n        dfs(m + 1, r, a[m]);\n    };\n    dfs(0, n, n);\n    sort(all(ps), greater<P>());\n    ll ans = 0;\n    ll k; cin >> k;\n    rep(i, ps.size()) {\n        ll c = ps[i].second;\n        ll len = ps[i].first;\n        if (k <= c*len) {\n            ll d = k / len;\n            ans += (len - 1) * d;\n            ll r = k % len;\n            if (r > 0)ans += r - 1;\n            break;\n        }\n        else {\n            ans += (len - 1) * c;\n            k -= c * len;\n        }\n    }\n    //cout << \"ans is \";\n    cout << ans << \"\\n\";\n}\n\n\n\n\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    //cout << fixed << setprecision(10);\n    //init_f();\n    //init();\n    //while(true)\n    //expr();\n    int t; cin >> t; rep(i, t)\n    solve();\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "math"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Fill the Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/117262",
    "editorial": "Notice that the rows of the matrix are basically independent. When we\r\nfill the matrix with integers, the values from the rows are just added\r\ntogether. Moreover, in a single row, the segments of white cells\r\nseparated by black cells are also independent in the same way.And how to\r\nsolve the problem for one segment of white cells? Obviously, put the\r\nnumbers one after another. Placing a non-zero amount of integers will\r\nyield the result of . Thus, the answer is , where is the number of used\r\nsegments. We know that the sum of is just . So it becomes . So, the\r\nproblem asks us to minimize the number of used segments.In order to use\r\nthe smallest number of segments, we should pick the longest ones. We\r\nonly have to find them.In the worst case, there are segments of white\r\ncells in the matrix. However, we can store them in a compressed form.\r\nSince their lengths are from to , we can calculate how many segments of\r\neach length there are.Look at the matrix from the bottom to the top.\r\nFirst, there are some fully white rows. Then some black cell appears and\r\nsplits the segment of length into two segments. Maybe more if there are\r\nmore black cells in that row. After that the split segments behave\r\nindependently of each other.Letâs record these intervals of rows each\r\nsegment exists at. So, let some segment exist from row to row . What\r\ndoes that mean? This segment appeared because of some split at row . At\r\nrow , some black cell appeared that split the segment in parts. If we\r\nknew the for the segment, we couldâve saved the information about it\r\nduring the event at row .So, we need a data structure that can support\r\nthe following operations: find a segment that covers cell ; erase a\r\nsegment; insert a segment. Additionally, that data structure should\r\nstore a value associated with a segment. Thus, letâs use a map. For a\r\nsegment, which is a pair of integers, store another integer the\r\nbottommost row this segment exists.Make events for each column . Sort\r\nthem and process in a non-increasing order. During the processing of the\r\nevent, find the segment this black cell splits. Save the information\r\nabout this segment. Then remove it and add two new segments (or less if\r\nsome are empty): the one to the left and the one to the right.At the\r\nend, for each length from to , we will have the number of segments of\r\nsuch length. In order to fill them with integers, start with the longest\r\nsegments and use as many of each length as possible. So, while having\r\nmore integers to place and segments of length , you can use of segments.\r\nOverall complexity: per testcase.\r\n",
    "hint": []
}