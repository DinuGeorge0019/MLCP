{
    "link": "https://codeforces.com//contest/1334/problem/E",
    "problemId": "590685",
    "problem_idx": "E",
    "shortId": "1334E",
    "contest_number": "1334",
    "problem_submissions": {
        "G": [
            76150604,
            76454180,
            76191944,
            76188027,
            76167647,
            76177375,
            76173628,
            76186408,
            76177963,
            76163688,
            76192725,
            76184456,
            76199963,
            76199932,
            76182086,
            76197235,
            76196570,
            76214003,
            76498225,
            76495336,
            76260338
        ],
        "F": [
            76137544,
            76454142,
            76145547,
            76157286,
            76163120,
            76164905,
            76178511,
            76167121,
            76165115,
            77917392,
            76145490,
            76152253,
            76160935,
            76165553,
            76165708,
            76168968,
            76174508,
            76168274,
            76170642,
            76172386,
            76176147
        ],
        "E": [
            76125664,
            76454103,
            76130620,
            76144771,
            76144664,
            76158374,
            76133358,
            76154175,
            76146278,
            77917431,
            76130418,
            76125237,
            76138118,
            76141034,
            76142668,
            76149616,
            76144057,
            76143238,
            76146704,
            76123897,
            76133227
        ],
        "D": [
            76117930,
            76454057,
            76121143,
            76124195,
            76129444,
            76121217,
            76145661,
            76143168,
            76138942,
            76118871,
            76134614,
            76125142,
            76129022,
            76126912,
            76131421,
            76134529,
            76131763,
            76126502,
            76140986,
            76147818
        ],
        "C": [
            76108518,
            76454007,
            76107934,
            76107462,
            76112664,
            76110005,
            76119790,
            76108604,
            76117844,
            76213964,
            76213679,
            76105910,
            76110649,
            76113576,
            76108183,
            76111773,
            76111557,
            76110114,
            76109227,
            76109093,
            76106723,
            76112412
        ],
        "B": [
            76102992,
            76453951,
            76102307,
            76102229,
            76104046,
            76104090,
            76113043,
            76104228,
            76113456,
            76102698,
            76104186,
            76104760,
            76102468,
            76104601,
            76103592,
            76102759,
            76103107,
            76101604,
            76101877,
            76102615
        ],
        "A": [
            76101170,
            76453913,
            76100742,
            76100982,
            76101188,
            76101149,
            76107978,
            76101072,
            76103065,
            76100866,
            76101471,
            76100923,
            76100719,
            76101105,
            76100817,
            76100705,
            76100882,
            76100750,
            76100773,
            76100924
        ]
    },
    "name": "E. Divisor Paths",
    "statement": "You are given a positive integer D. Let’s build the following graph from\r\nit: each vertex is a divisor of D (not necessarily prime, 1 and D itself\r\nare also included); two vertices x and y (x > y) have an undirected edge\r\nbetween them if x is divisible by y and\r\nfrac x y is a prime; the weight of an edge is the number of divisors of\r\nx that are not divisors of y. For example, here is the graph for D=12:\r\nEdge (4,12) has weight 3 because 12 has divisors [1,2,3,4,6,12] and 4\r\nhas divisors [1,2,4]. Thus, there are 3 divisors of 12 that are not\r\ndivisors of 4 [3,6,12].There is no edge between 3 and 2 because 3 is not\r\ndivisible by 2. There is no edge between 12 and 3 because\r\nfrac{12}{3}=4 is not a prime.Let the length of the path between some\r\nvertices v and u in the graph be the total weight of edges on it. For\r\nexample, path [(1, 2), (2, 6), (6, 12), (12, 4), (4, 2), (2, 6)] has\r\nlength 1+2+2+3+1+2=11. The empty path has length 0.So the shortest path\r\nbetween two vertices v and u is the path that has the minimal possible\r\nlength.Two paths a and b are different if there is either a different\r\nnumber of edges in them or there is a position i such that a_i and b_i\r\nare different edges.You are given q queries of the following form: v u\r\ncalculate the between vertices v and u. The answer for each query might\r\nbe large so print it modulo 998244353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=998244353;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\ntypedef pair<ll,ll> PLL;\nnamespace Factor {\n\tconst int N=1010000;\n\tll C,fac[10010],n,mut,a[1001000];\n\tint T,cnt,i,l,prime[N],p[N],psize,_cnt;\n\tll _e[100],_pr[100];\n\tvector<ll> d;\n\tinline ll mul(ll a,ll b,ll p) {\n\t\tif (p<=1000000000) return a*b%p;\n\t\telse if (p<=1000000000000ll) return (((a*(b>>20)%p)<<20)+(a*(b&((1<<20)-1))))%p;\n\t\telse {\n\t\t\tll d=(ll)floor(a*(long double)b/p+0.5);\n\t\t\tll ret=(a*b-d*p)%p;\n\t\t\tif (ret<0) ret+=p;\n\t\t\treturn ret;\n\t\t}\n\t}\n\tvoid prime_table(){\n\t\tint i,j,tot,t1;\n\t\tfor (i=1;i<=psize;i++) p[i]=i;\n\t\tfor (i=2,tot=0;i<=psize;i++){\n\t\t\tif (p[i]==i) prime[++tot]=i;\n\t\t\tfor (j=1;j<=tot && (t1=prime[j]*i)<=psize;j++){\n\t\t\t\tp[t1]=prime[j];\n\t\t\t\tif (i%prime[j]==0) break;\n\t\t\t}\n\t\t}\n\t}\n\tvoid init(int ps) {\n\t\tpsize=ps;\n\t\tprime_table();\n\t}\n\tll powl(ll a,ll n,ll p) {\n\t\tll ans=1;\n\t\tfor (;n;n>>=1) {\n\t\t\tif (n&1) ans=mul(ans,a,p);\n\t\t\ta=mul(a,a,p);\n\t\t}\n\t\treturn ans;\n\t}\n\tbool witness(ll a,ll n) {\n\t\tint t=0;\n\t\tll u=n-1;\n\t\tfor (;~u&1;u>>=1) t++;\n\t\tll x=powl(a,u,n),_x=0;\n\t\tfor (;t;t--) {\n\t\t\t_x=mul(x,x,n);\n\t\t\tif (_x==1 && x!=1 && x!=n-1) return 1;\n\t\t\tx=_x;\n\t\t}\n\t\treturn _x!=1;\n\t}\n\tbool miller(ll n) {\n\t\tif (n<2) return 0;\n\t\tif (n<=psize) return p[n]==n;\n\t\tif (~n&1) return 0;\n\t\tfor (int j=0;j<=7;j++) if (witness(rand()%(n-1)+1,n)) return 0;\n\t\treturn 1;\n\t}\n\tll gcd(ll a,ll b) {\n\t\tll ret=1;\n\t\twhile (a!=0) {\n\t\t\tif ((~a&1) && (~b&1)) ret<<=1,a>>=1,b>>=1;\n\t\t\telse if (~a&1) a>>=1; else if (~b&1) b>>=1;\n\t\t\telse {\n\t\t\t\tif (a<b) swap(a,b);\n\t\t\t\ta-=b;\n\t\t\t}\n\t\t}\n\t\treturn ret*b;\n\t}\n\tll rho(ll n) {\n\t\tfor (;;) {\n\t\t\tll X=rand()%n,Y,Z,T=1,*lY=a,*lX=lY;\n\t\t\tint tmp=20;\n\t\t\tC=rand()%10+3;\n\t\t\tX=mul(X,X,n)+C;*(lY++)=X;lX++;\n\t\t\tY=mul(X,X,n)+C;*(lY++)=Y;\n\t\t\tfor(;X!=Y;) {\n\t\t\t\tll t=X-Y+n;\n\t\t\t\tZ=mul(T,t,n);\n\t\t\t\tif(Z==0) return gcd(T,n);\n\t\t\t\ttmp--;\n\t\t\t\tif (tmp==0) {\n\t\t\t\t\ttmp=20;\n\t\t\t\t\tZ=gcd(Z,n);\n\t\t\t\t\tif (Z!=1 && Z!=n) return Z;\n\t\t\t\t}\n\t\t\t\tT=Z;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tY=*(lY++)=mul(Y,Y,n)+C;\n\t\t\t\tX=*(lX++);\n\t\t\t}\n\t\t}\n\t}\n\tvoid _factor(ll n) {\n\t\tfor (int i=0;i<cnt;i++) {\n\t\t\tif (n%fac[i]==0) n/=fac[i],fac[cnt++]=fac[i];}\n\t\tif (n<=psize) {\n\t\t\tfor (;n!=1;n/=p[n]) fac[cnt++]=p[n];\n\t\t\treturn;\n\t\t}\n\t\tif (miller(n)) fac[cnt++]=n;\n\t\telse {\n\t\t\tll x=rho(n);\n\t\t\t_factor(x);_factor(n/x);\n\t\t}\n\t}\n\tvoid dfs(ll x,int dep) {\n\t\tif (dep==_cnt) d.pb(x);\n\t\telse {\n\t\t\tdfs(x,dep+1);\n\t\t\tfor (int i=1;i<=_e[dep];i++) dfs(x*=_pr[dep],dep+1);\n\t\t}\n\t}\n\tvoid norm() {\n\t\tsort(fac,fac+cnt);\n\t\t_cnt=0;\n\t\trep(i,0,cnt) if (i==0||fac[i]!=fac[i-1]) _pr[_cnt]=fac[i],_e[_cnt++]=1;\n\t\t\telse _e[_cnt-1]++;\n\t}\n\tvector<ll> getd() {\n\t\td.clear();\n\t\tdfs(1,0);\n\t\treturn d;\n\t}\n\tvector<ll> factor(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\treturn getd();\n\t}\n\tvector<PLL> factorG(ll n) {\n\t\tcnt=0;\n\t\t_factor(n);\n\t\tnorm();\n\t\tvector<PLL> d;\n\t\trep(i,0,_cnt) d.pb(mp(_pr[i],_e[i]));\n\t\treturn d;\n\t}\n\tbool is_primitive(ll a,ll p) {\n\t\tassert(miller(p));\n\t\tvector<PLL> D=factorG(p-1);\n\t\trep(i,0,SZ(D)) if (powl(a,(p-1)/D[i].fi,p)==1) return 0;\n\t\treturn 1;\n\t}\n}\n\nll d,fac[1010],fnv[1010];\nvector<PLL> x;\nint q;\nll way(ll u,ll v) {\n\tll f=1;\n\tint s=0;\n\trep(i,0,SZ(x)) {\n\t\tint p=0,q=0;\n\t\twhile (u%x[i].fi==0) u/=x[i].fi,p++;\n\t\twhile (v%x[i].fi==0) v/=x[i].fi,q++;\n\t\tf=f*fnv[abs(p-q)]%mod;\n\t\ts+=abs(p-q);\n\t}\n\tf=f*fac[s]%mod;\n\treturn f;\n}\nint main() {\n\tFactor::init(100000);\n\tfac[0]=fnv[0]=1;\n\trep(i,1,1000) fac[i]=fac[i-1]*i%mod,fnv[i]=powmod(fac[i],mod-2);\n\tscanf(\"%lld\",&d);\n\tx=Factor::factorG(d);\n\tsort(all(x));\n\tscanf(\"%d\",&q);\n\trep(i,0,q) {\n\t\tll u,v;\n\t\tscanf(\"%lld%lld\",&u,&v);\n\t\tll w=gcd(u,v);\n\t\tll f=way(u,w)*way(v,w)%mod;\n\t\tprintf(\"%lld\\n\",f);\n\t}\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "graphs",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Divisor Paths.json",
    "editorial_link": "https://codeforces.com//blog/entry/75877",
    "editorial": "Letâs define the semantics of moving along the graph. On each step the\r\ncurrent number is either multiplied by some prime or divided by it.I\r\nclaim that the all shortest paths from to always go through . Moreover,\r\nthe vertex numbers on the path first only decrease until and only\r\nincrease after it.Letâs watch what happens to the divisors list on these\r\npaths. At first, all the divisors of that are not divisors of are\r\nremoved from the list. Now we reach gcd and we start adding the divisors\r\nof that are missing from the list. The length of the path is this total\r\nnumber of changes to the list. That shows us that these paths are the\r\nshortest by definition.If we ever take a turn off that path, we either\r\nwill add some divisor that we will need to remove later or remove some\r\ndivisor that we will need to add later. That makes the length of the\r\npath not optimal.Now letâs learn to calculate the number of paths. The\r\nparts before gcd and after it will be calculated separately, the answer\r\nis the product of answers for both parts.How many paths are there to\r\ngcd? Well, letâs divide by , that will give us the primes that should be\r\nremoved from . You can remove them in any order because the length of\r\nthe path is always the same. That is just the number of their\r\npermutations with repetitions (you might also know that formula as\r\nmultinomial coefficient).The number of paths from to is calculated the\r\nsame way.To find the primes in you can factorize beforehand and only\r\niterate over the primes of .Overall complexity: .\r\n",
    "hint": []
}