{
    "link": "https://codeforces.com//contest/2069/problem/D",
    "problemId": "3213449",
    "problem_idx": "D",
    "shortId": "2069D",
    "contest_number": "2069",
    "problem_submissions": {
        "E": [
            306720227,
            306703455,
            306762040,
            306709414,
            306720479,
            306710204,
            306717271,
            306714232,
            306713491,
            306717023,
            306719634,
            306716305,
            306717171,
            306715546,
            306713534,
            307552024,
            306752930,
            306724477,
            306721728,
            306718615,
            306718992,
            306726971,
            306725677
        ],
        "F": [
            306709347,
            306728258,
            306727520,
            306728135,
            306741225,
            306726966,
            306744015,
            306732116,
            306739032,
            306855146,
            306737313,
            306730256,
            306733511,
            306743505,
            306725225,
            306745953,
            306762587,
            306739080,
            306745663,
            306744259,
            306729975,
            306736187,
            306742000
        ],
        "D": [
            306694099,
            306695545,
            306695100,
            306694667,
            306690359,
            306701386,
            306701212,
            306696826,
            306697964,
            306697288,
            306699133,
            306704039,
            306702795,
            306701942,
            306702458,
            306700726,
            306707761,
            306704425,
            306708530,
            306707972
        ],
        "C": [
            306685465,
            306686684,
            306687348,
            306684235,
            306683606,
            306688263,
            306688039,
            306687329,
            306856369,
            306685918,
            306688691,
            306688112,
            306685819,
            306691359,
            306688654,
            306686865,
            306692320,
            306691352,
            306695398,
            306686441,
            306689890
        ],
        "B": [
            306681829,
            306682850,
            306682972,
            306680572,
            306680880,
            306682298,
            306683281,
            306682689,
            306856172,
            306681142,
            306684519,
            306683738,
            306681106,
            306703816,
            306682841,
            306682588,
            306685491,
            306683927,
            306691965,
            306683224,
            306685776
        ],
        "A": [
            306678234,
            306678240,
            306678194,
            306678094,
            306678179,
            306678115,
            306678333,
            306678481,
            306855634,
            306678273,
            306679166,
            306678389,
            306678130,
            306680446,
            306678338,
            306678258,
            306678871,
            306678235,
            306687347,
            306679141,
            306678310
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/139774",
    "editorial": "I will describe a solution in . It is possible to solve the problem in\r\nwith careful implementation of two pointers method, but is more\r\nintuitive and easier to understand, in my opinion.First, while the first\r\ncharacter of the string is equal to the last character of the string,\r\nlet’s get rid of both of them it’s pretty obvious we shouldn’t touch\r\nthem.After that, we get a string for which the first character is not\r\nequal to the last character. At least one of them should be changed so,\r\nthe substring we need to shuffle is either a prefix or a suffix of the\r\nstring. Suppose the string we shuffle is a prefix (if we need to shuffle\r\na suffix, we’ll check it by reversing the string and trying to shuffle a\r\nprefix of the reversed string).Suppose that, by shuffling a prefix of\r\nlength , we get the answer. Then, by shuffling a prefix of length , we\r\nwill also be able to make the string a palindrome. It means that the\r\nshortest possible length of the prefix we need to shuffle can be found\r\nwith binary search.In our binary search, we need to check whether we can\r\nmake the string a palindrome by shuffling the prefix of certain length.\r\nLet’s check it in by verifying the following two conditions: for every\r\npair such that , at least one of the characters should be changed, so it\r\nshould belong to the prefix; for every character from to , let’s\r\ncalculate the number of pairs where this character should fill both\r\npositions (i. e. the number of pairs where at least one of the\r\ncharacters is equal to and is not affected by our shuffle). This number\r\nof pairs should not exceed the number of pairs of character in the whole\r\nstring, otherwise we won’t have enough occurrences of to fill all these\r\npairs of positions. It’s obvious that these two conditions are\r\nnecessary, but we can prove that they are sufficient: if both of them\r\nhold, we have enough characters to fill all pairs of positions where we\r\nneed a fixed character, and all the remaining pairs of positions can be\r\nfilled by any remaining pairs of characters (the input is guaranteed to\r\nhave an even number of every character, so it’s always possible to split\r\nall characters into pairs).So, we need to check if some substring is a\r\npossible answer times, and every such check can be done in . Thus, our\r\nsolution works in .\r\n",
    "name": "D. Palindrome Shuffle",
    "statement": "You are given a string s consisting of lowercase Latin letters.You can\r\nperform the following operation with the string s: choose a contiguous\r\nsubstring (possibly empty) of s and shuffle it (reorder the characters\r\nin the substring as you wish).Recall that a palindrome is a string that\r\nreads the same way from the first character to the last and from the\r\nlast character to the first. For example, the strings , , , are\r\npalindromes, but the strings , , are not.Your task is to determine the\r\nminimum possible length of the substring on which the aforementioned\r\noperation must be performed in order to convert the given string s into\r\na palindrome.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "hashing",
        "strings",
        "two pointers"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Palindrome Shuffle.json"
}