{
    "link": "https://codeforces.com//contest/1452/problem/B",
    "problemId": "802105",
    "problem_idx": "B",
    "shortId": "1452B",
    "contest_number": "1452",
    "problem_submissions": {
        "F": [
            98942480,
            98939437,
            98940434,
            106494164,
            106494140,
            98942341,
            98945383,
            98935697,
            98927001,
            98944945,
            98934044,
            98976764,
            99270253
        ],
        "E": [
            98926708,
            98926305,
            98923150,
            98930994,
            98926114,
            98927253,
            98926662,
            99001021,
            98943947,
            99042260,
            98926234,
            98930834,
            98943700,
            98921374,
            98925742,
            98930269,
            98929950,
            98918489,
            98928745,
            98929548
        ],
        "D": [
            98906301,
            98909937,
            98915472,
            98909763,
            98919427,
            98912085,
            99000804,
            98903628,
            98909739,
            98911723,
            98911927,
            98913556,
            98901042,
            98908884,
            98907045,
            98910263,
            98910231,
            98913804,
            98909129
        ],
        "C": [
            98899318,
            98901635,
            98905651,
            98903381,
            98906519,
            98900085,
            98896987,
            98906559,
            98901684,
            98905788,
            98906611,
            98898047,
            98901391,
            98899348,
            98900377,
            98902439,
            98902965,
            98898261
        ],
        "B": [
            98897777,
            98898220,
            98901029,
            98900303,
            98904013,
            98898005,
            99000726,
            99000688,
            98978607,
            98898951,
            98904401,
            98905057,
            98908639,
            98904166,
            98896699,
            98898174,
            98897853,
            98902989,
            98899546,
            98900510,
            98903751
        ],
        "A": [
            98895449,
            98895686,
            98896660,
            98896462,
            98897246,
            98895467,
            98895360,
            98896351,
            100779606,
            98895507,
            98904547,
            98896942,
            98895363,
            98895604,
            98895575,
            98895460,
            98903659,
            98895637,
            98896531
        ],
        "G": [
            99251139,
            98943421,
            99550385,
            99358496,
            99358463,
            99358399,
            99296629,
            99296419,
            99053359,
            99052180,
            98944458,
            98945555,
            99287849
        ]
    },
    "name": "B. Toy Blocks",
    "statement": "You are asked to watch your nephew who likes to play with toy blocks in\r\na strange way.He has n boxes and the i-th box has a_i blocks. His game\r\nconsists of two steps: he chooses an arbitrary box i; he tries to move\r\nblocks from the i-th box to other boxes. If he can make the same number\r\nof blocks in each of n - 1 other boxes then he will be happy, otherwise,\r\nwill be sad. Note that your nephew can only move the blocks from the\r\nchosen box to the other boxes; he cannot move blocks from the other\r\nboxes.You don’t want to make your nephew sad, so you decided to put\r\nseveral extra blocks into some boxes in such a way that no matter which\r\nbox i he chooses he won’t be sad. What is the minimum number of extra\r\nblocks you need to put?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n\tint tc; scanf(\"%d\", &tc);\n\twhile(tc--) {\n\t\tint mx = 0;\n\t\tll s = 0;\n\t\tint N; scanf(\"%d\", &N);\n\t\tfor(int i = 1; i <= N; i++) {\n\t\t\tint a; scanf(\"%d\", &a);\n\t\t\ts += a; mx = max(mx, a);\n\t\t}\n\n\t\tll k = (s + N - 2) / (N - 1);\n\t\tif(mx > k) printf(\"%lld\\n\", (ll)mx * (N - 1) - s);\n\t\telse printf(\"%lld\\n\", k * (N - 1) - s);\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Toy Blocks.json",
    "editorial_link": "https://codeforces.com//blog/entry/84847",
    "editorial": "Since nephew emptying the box heâs chosen and wants to make all other\r\nbox equal then it means that at least the of all array should be\r\ndivisible by and the number of blocks in each other box should be at\r\nleast (ceiling function).On the other side, since nephew chooses (not\r\nyou), then he can choose a box which is a maximum , and since he makes\r\nempty the only box , then the final number in each other block should be\r\nat least .In total, the resulting number of blocks in each of other\r\nboxes should be at least and we need to add at least elements to the\r\ninitial array. We can always reach this lower bound if we will put each\r\nblock in the box with the current minimum number of blocks.\r\n",
    "hint": []
}