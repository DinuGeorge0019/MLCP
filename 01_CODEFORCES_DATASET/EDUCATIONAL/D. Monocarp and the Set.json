{
    "link": "https://codeforces.com//contest/1886/problem/D",
    "problemId": "2254332",
    "problem_idx": "D",
    "shortId": "1886D",
    "contest_number": "1886",
    "problem_submissions": {
        "F": [
            227397695,
            227398300,
            228261037,
            228260268,
            228197178
        ],
        "E": [
            227362679,
            227384483,
            227364120,
            227375327,
            227373174,
            227378169,
            227374021,
            227374447,
            227379620,
            227374460,
            227376543,
            227384694,
            227379424,
            227380143,
            227385403,
            227378825,
            227381936,
            227382749,
            227399178,
            227387227
        ],
        "D": [
            227353655,
            227357179,
            227354694,
            227357584,
            227358464,
            227358468,
            227358349,
            227362290,
            227362059,
            227356663,
            227359799,
            227363314,
            227364815,
            227364540,
            227348253,
            227359972,
            227351995,
            227364703,
            227363479,
            227364505
        ],
        "C": [
            227350420,
            227354094,
            227350822,
            227351738,
            227353206,
            227352928,
            227352755,
            227358100,
            227355646,
            227353873,
            227356426,
            227357990,
            228289531,
            227359928,
            227359265,
            227363015,
            227354512,
            227347330,
            227360346,
            227356740,
            227359383
        ],
        "B": [
            227345467,
            227345695,
            227345097,
            227345886,
            227347778,
            227347034,
            227345776,
            227346855,
            227347299,
            227344500,
            227348328,
            227348902,
            227344888,
            227345167,
            227353779,
            227346134,
            227384569,
            227355313,
            227346381,
            227345209
        ],
        "A": [
            227342113,
            227340918,
            227341455,
            227340893,
            227341201,
            227341171,
            227340846,
            227340875,
            227341099,
            227340925,
            227340854,
            227342810,
            227341042,
            227341115,
            227341596,
            227341490,
            227340923,
            227349667,
            227341619,
            227341191
        ]
    },
    "name": "D. Monocarp and the Set",
    "statement": "Monocarp has n numbers 1, 2,\r\ndots, n and a set (initially empty). He adds his numbers to this set n\r\ntimes in some order. During each step, he adds a new number (which has\r\nnot been present in the set before). In other words, the sequence of\r\nadded numbers is a permutation of length n.Every time Monocarp adds an\r\nelement into the set , he writes out a character: if the element\r\nMonocarp is trying to insert becomes the maximum element in the set,\r\nMonocarp writes out the character ; if the element Monocarp is trying to\r\ninsert becomes the minimum element in the set, Monocarp writes out the\r\ncharacter ; if none of the above, Monocarp writes out the character .\r\nYou are given a string s of n-1 characters, which represents the\r\ncharacters written out by Monocarp (in the order he wrote them out). You\r\nhave to process m queries to the string. Each query has the following\r\nformat: i c replace s_i with the character c. Both before processing the\r\nqueries and after each query, you have to calculate the number of\r\ndifferent ways to order the integers 1, 2, 3,\r\ndots, n such that, if Monocarp inserts the integers into the set in that\r\norder, he gets the string s. Since the answers might be large, print\r\nthem modulo 998244353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = i64(1E18) + 9;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 998244353;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        m = std::min(m, Z::getMod() - 1);\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, m;\n    std::cin >> n >> m;\n    n--;\n    \n    Z ans = 1;\n    std::string s;\n    std::cin >> s;\n    \n    for (int i = 1; i < n; i++) {\n        if (s[i] == '?') {\n            ans *= i;\n        }\n    }\n    \n    auto query = [&]() {\n        if (s[0] == '?') {\n            std::cout << 0 << \"\\n\";\n        } else {\n            std::cout << ans << \"\\n\";\n        }\n    };\n    \n    query();\n    while (m--) {\n        int x;\n        char y;\n        std::cin >> x >> y;\n        x--;\n        if (x && s[x] == '?') {\n            ans *= comb.inv(x);\n        }\n        s[x] = y;\n        if (x && y == '?') {\n            ans *= x;\n        }\n        query();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Monocarp and the Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/121255",
    "editorial": "The key observation to this problem is that it\u00e2\u0080\u0099s much easier to consider\r\nthe process in reverse. Suppose Monocarp has a set of integers , and\r\nstarts removing elements from it one by one. During the -th deletion, if\r\nis , he removes the minimum element; if is , he removes the maximum\r\nelement; and if is , he removes any element which is neither the minimum\r\nnor the maximum.If you consider the process backwards, it\u00e2\u0080\u0099s quite easy\r\nto see that it doesn\u00e2\u0080\u0099t actually matter which numbers are present in the\r\nset; we are interested only in their quantity. So, for each action, we\r\ncan choose an element to remove independently: if is or , there is only\r\none way, otherwise, there are ways, where is the number of elements in\r\nthe set (for the -th deletion operation, it is ).So, the answer to the\r\nproblem is the product of for every character that is equal to .To\r\nrecalculate the answer efficiently when you change a character, you can\r\nuse one of the following options: build a segment tree with operation\r\n\"product on segment modulo \"; or use modular inverse to maintain\r\ndivision operations. Note that sometimes you have to \"divide by zero\",\r\ni. e. remove the zero from the product (when changes from to another\r\ncharacter); to handle it, you can store the product for every from to ,\r\nand explicitly multiply it by before printing when is .\r\n"
}