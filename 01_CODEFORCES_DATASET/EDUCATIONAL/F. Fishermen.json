{
    "link": "https://codeforces.com//contest/1728/problem/F",
    "problemId": "1534227",
    "problem_idx": "F",
    "shortId": "1728F",
    "contest_number": "1728",
    "problem_submissions": {
        "F": [
            171415471,
            171408709,
            171477755,
            171477598,
            171800837,
            171602685,
            171508405,
            171615612,
            171428158,
            171416710,
            171516704
        ],
        "G": [
            171401437,
            171423625,
            171401320,
            171405459,
            171408910,
            171400855,
            171410753,
            171399735,
            171425286,
            171424973,
            171424864,
            171421363,
            171409384,
            171429440,
            171419291,
            171421745,
            171401911,
            171420331,
            171494040,
            171406232,
            171419649,
            171415822,
            171442989,
            171426124,
            171423998,
            171422898,
            171422786,
            171419842
        ],
        "E": [
            171378857,
            171391875,
            171380622,
            171383139,
            171380478,
            171390287,
            171381329,
            171385138,
            171384190,
            171396093,
            171392841,
            171388311,
            171403618,
            171390049,
            171393452,
            171494181,
            171455206,
            171419342,
            171391692,
            171398313,
            171393739,
            171428155,
            171396053,
            171400068
        ],
        "D": [
            171364431,
            171379034,
            171368807,
            171365018,
            171370163,
            171375547,
            171369467,
            171380229,
            171364084,
            171374772,
            171368217,
            171377453,
            171410355,
            171379812,
            171386430,
            171377364,
            171385449,
            171375075,
            171380828,
            171376969
        ],
        "C": [
            171356021,
            171355657,
            171354790,
            171355489,
            171357376,
            171364423,
            171358552,
            171371507,
            171356927,
            171358656,
            171358481,
            171361890,
            171364747,
            171361193,
            171494234,
            171359234,
            171364539,
            171370274,
            171358915,
            171369689,
            171370585
        ],
        "B": [
            171350944,
            171350546,
            171350225,
            171351747,
            171353484,
            171350234,
            171353700,
            171367743,
            171353076,
            171355275,
            171352643,
            171355734,
            171359875,
            171351546,
            171353658,
            171357176,
            171361933,
            171353420,
            171361436,
            171361759
        ],
        "A": [
            171346435,
            171346486,
            171346382,
            171346456,
            171348074,
            171346466,
            171346859,
            171352332,
            171346599,
            171349231,
            171346445,
            171346558,
            171348949,
            171346594,
            171346485,
            171349162,
            171347108,
            171346675,
            171346628,
            171349812
        ]
    },
    "name": "F. Fishermen",
    "statement": "There are n fishermen who have just returned from a fishing trip. The\r\ni-th fisherman has caught a fish of size a_i.The fishermen will choose\r\nsome order in which they are going to tell the size of the fish they\r\ncaught (the order is just a permutation of size n). However, they are\r\nnot entirely honest, and they may \"increase\" the size of the fish they\r\nhave caught.Formally, suppose the chosen order of the fishermen is [p_1,\r\np_2, p_3,\r\ndots, p_n]. Let b_i be the value which the i-th fisherman in the order\r\nwill tell to the other fishermen. The values b_i are chosen as follows:\r\nthe first fisherman in the order just honestly tells the actual size of\r\nthe fish he has caught, so b_1 = a_{p_1}; every other fisherman wants to\r\ntell a value that is than the value told by the previous fisherman, and\r\nis divisible by the size of the fish that the fisherman has caught. So,\r\nfor i > 1, b_i is the smallest integer that is both than b_{i-1} and\r\na_{p_i}. For example, let n = 7, a = [1, 8, 2, 3, 2, 2, 3]. If the\r\nchosen order is p = [1, 6, 7, 5, 3, 2, 4], then: b_1 = a_{p_1} = 1; b_2\r\nis the smallest integer divisible by 2 and greater than 1, which is 2;\r\nb_3 is the smallest integer divisible by 3 and greater than 2, which is\r\n3; b_4 is the smallest integer divisible by 2 and greater than 3, which\r\nis 4; b_5 is the smallest integer divisible by 2 and greater than 4,\r\nwhich is 6; b_6 is the smallest integer divisible by 8 and greater than\r\n6, which is 8; b_7 is the smallest integer divisible by 3 and greater\r\nthan 8, which is 9. You have to choose the order of fishermen in a way\r\nthat yields the minimum possible\r\nsum\r\nlimits_{i=1}^{n} b_i.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid chmin(T& x, const T& y) {\n\tif (x > y) x = y;\n}\ntemplate<typename T>\nvoid chmax(T& x, const T& y) {\n\tif (x < y) x = y;\n}\ntypedef int64_t s64;\ntypedef uint64_t u64;\ntypedef uint32_t u32;\ntypedef pair<int, int> pii;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define per(i, r, l) for (int i = r; i >= l; --i)\n#define rep0(i, l, r) for (int i = l; i < r; ++i)\n#define gc (c = getchar())\nchar readc() {\n\tchar c;\n\twhile (isspace(gc))\n\t\t;\n\treturn c;\n}\nint read() {\n\tchar c;\n\twhile (gc < '-')\n\t\t;\n\tif (c == '-') {\n\t\tint x = gc - '0';\n\t\twhile (gc >= '0') x = x * 10 + c - '0';\n\t\treturn -x;\n\t}\n\tint x = c - '0';\n\twhile (gc >= '0') x = x * 10 + c - '0';\n\treturn x;\n}\n#undef gc\n\nconst int N = 1005;\n\nunordered_map<int, int> match, tmp, pre, vis;\nint a[N];\nint n, len;\nlong long ans;\n\nint dfs(int u) {\n\tvis[u] = 1;\n\tint minn = 1e9;\n\tfor (int i = u;; i += u) {\n\t\tif (!match.count(i)) {\n\t\t\tpre[i] = u;\n\t\t\tminn = min(minn, i);\n\t\t\tbreak;\n\t\t}\n\t\tif (!vis.count(match[i])) {\n\t\t\tpre[i] = u;\n\t\t\ttmp[match[i]] = i;\n\t\t\tminn = min(minn, dfs(match[i]));\n\t\t}\n\t}\n\treturn minn;\n}\n\nint main() {\n#ifdef local\n\tfreopen(\"1.in\", \"r\", stdin);\n#endif\n\tn = read();\n\tfor (int i = 1; i <= n; i++) {\n\t\ta[i] = read();\n\t\tlen = 0;\n\t\ttmp.clear();\n\t\tpre.clear();\n\t\tvis.clear();\n\t\tint ret = dfs(a[i]);\n\t\tans += ret;\n\t\twhile (ret) {\n\t\t\tmatch[ret] = pre[ret];\n\t\t\tret = tmp[pre[ret]];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graph matchings",
        "greedy"
    ],
    "dificulty": "3100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Fishermen.json",
    "editorial_link": "https://codeforces.com//blog/entry/106805",
    "editorial": "Suppose we have fixed some order of fishermen and calculated the values\r\nof . Then, we have the following constraints on : all values of are\r\npairwise distinct; for every , divides . Not every possible array\r\nmeeting these constraints can be achieved with some order of fishermen,\r\nbut we can show that if we choose an array with the among the arrays\r\nmeeting these two constraints, there exists an ordering of fishermen\r\nwhich yields this array . The proof is simple suppose the ordering of\r\nfishermen is the following one: the first fisherman is the one with\r\nminimum , the second one the one with the second minimum , and so on.\r\nItâs obvious that if we generate the values of according to this order,\r\nthey wonât be greater than the values in the array we have chosen. And\r\nif some value is less than the value in the chosen array , it means that\r\nwe havenât chosen the array with the minimum possible sum. So, we can\r\nrephrase the problem as the following one: for each , choose the value\r\nof so that it is divisible by , all are distinct, and their sum is\r\nminimized.Using the pigeonhole principle, we can show that for every ,\r\nwe need to consider only the values of among . So, we can formulate the\r\nproblem as an instance of the weighted bipartite matching: build a graph\r\nwith two parts, where the left part contains nodes representing the\r\nvalues of , the right part represents the values of the form where , and\r\nthere exists an edge between a vertex in the left part representing the\r\nnumber and a vertex in the right part representing the number with cost\r\nif and only if for some integer . .Okay, now we need to solve this\r\nweighted matching problem, but how? The number of vertices is , and the\r\nnumber of edges is as well, so mincost flow will run in or , which is\r\ntoo much. Instead, we can notice that the cost of the edges incident to\r\nthe same vertex in the right part is the same, so we can swap the parts\r\nof the graph, sort the vertices of the new left part (representing the\r\nnumbers ) according to their costs, and run the classical Kuhnâs\r\nalgorithm in sorted order. Kuhnâs algorithm in its original\r\nimplementation will always match a vertex if it is possible, so it\r\nobtains the minimum total cost for the matching if we do it in sorted\r\norder.But this is still ! What should we do? Well, there are some\r\nimplementations of Kuhnâs algorithm which can run on graphs of size\r\nabout (sometimes even ). Why canât we use one of these? Unfortunately, .\r\nFor example, greedy initialization of matching wonât work. So we need to\r\nchoose optimizations carefully.The model solution uses the following\r\noptimization of Kuhnâs algorithm: . With this optimization, Kuhnâs\r\nalgorithm works in , where is the size of the maximum matching, is the\r\nnumber of edges, and is the number of vertices. So, this results in a\r\nsolution with complexity of .I think itâs possible to show that some\r\nother optimizations of Kuhn can also work, but the one I described is\r\nenough.\r\n",
    "hint": []
}