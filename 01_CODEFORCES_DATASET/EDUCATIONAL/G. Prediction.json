{
    "link": "https://codeforces.com//contest/1809/problem/G",
    "problemId": "1839367",
    "problem_idx": "G",
    "shortId": "1809G",
    "contest_number": "1809",
    "problem_submissions": {
        "G": [
            198800857,
            198819538,
            198819377,
            198819202,
            198818781,
            198818684,
            198816759,
            198811816,
            198806762,
            198815231,
            198818773,
            198822181,
            198828608,
            198822299,
            203672607,
            208381746,
            198835108,
            198831844,
            198829525,
            198853349,
            198853245
        ],
        "F": [
            198786104,
            198791363,
            198796885,
            198804709,
            198810152,
            198814173,
            198809216,
            198791415,
            198800965,
            198804541,
            198830839,
            198809769,
            198804908,
            198811366,
            198815172,
            198805151,
            198812101,
            198817151,
            198808903,
            198814662
        ],
        "E": [
            198775336,
            198782430,
            198786246,
            199182668,
            198794243,
            198792695,
            198792300,
            198799038,
            198776769,
            198784470,
            198788708,
            198793376,
            198789791,
            198792668,
            198843793,
            198805320,
            198800053,
            198802037,
            198804412,
            198800677,
            198799758
        ],
        "D": [
            198768775,
            198772012,
            198776224,
            198777641,
            198882283,
            198777443,
            198779801,
            198782367,
            198766389,
            198769656,
            198777387,
            198777057,
            198779683,
            198776616,
            198772288,
            198785016,
            198783361,
            198781028,
            198791791,
            198778758
        ],
        "C": [
            198764545,
            198765840,
            198768929,
            198772658,
            198770321,
            198766724,
            198776128,
            198761542,
            198765111,
            198760078,
            198766275,
            198773341,
            198769090,
            198764454,
            198770468,
            198769676,
            198767761,
            198771860,
            198780776
        ],
        "B": [
            198760964,
            198755413,
            198762260,
            198758056,
            198766256,
            198759317,
            198761525,
            198757070,
            198756430,
            198755376,
            198758155,
            198765573,
            198760583,
            198758103,
            198766309,
            198762187,
            198761139,
            198766037,
            198760442
        ],
        "A": [
            198757842,
            198756487,
            198756930,
            198755206,
            198755963,
            198755170,
            198755335,
            198755127,
            198755119,
            198756462,
            198755191,
            198755804,
            198757456,
            198755555,
            198757141,
            198756133,
            198756023,
            198760810,
            198755407
        ]
    },
    "name": "G. Prediction",
    "statement": "Consider a tournament with n participants. The rating of the i-th\r\nparticipant is a_i.The tournament will be organized as follows. First of\r\nall, organizers will assign each participant an index from 1 to n. All\r\nindices will be unique. Let p_i be the participant who gets the index\r\ni.Then, n-1 games will be held. In the first game, participants p_1 and\r\np_2 will play. In the second game, the winner of the first game will\r\nplay against p_3. In the third game, the winner of the second game will\r\nplay against p_4, and so on in the last game, the winner of the (n-2)-th\r\ngame will play against p_n.Monocarp wants to predict the results of all\r\nn-1 games (of course, he will do the prediction only after the indices\r\nof the participants are assigned). He knows for sure that, when two\r\nparticipants with ratings x and y play, and |x - y| > k, the participant\r\nwith the higher rating wins. But if |x - y|\r\nle k, any of the two participants may win.Among all n! ways to assign\r\nthe indices to participants, calculate the number of ways to do this so\r\nthat Monocarp can predict the results of n-1 games. Since the answer can\r\nbe large, print it modulo 998244353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nconstexpr T power(T a, i64 b) {\n    T res = 1;\n    for (; b; b /= 2, a *= a) {\n        if (b % 2) {\n            res *= a;\n        }\n    }\n    return res;\n}\n\nconstexpr i64 mul(i64 a, i64 b, i64 p) {\n    i64 res = a * b - i64(1.L * a * b / p) * p;\n    res %= p;\n    if (res < 0) {\n        res += p;\n    }\n    return res;\n}\ntemplate<i64 P>\nstruct MLong {\n    i64 x;\n    constexpr MLong() : x{} {}\n    constexpr MLong(i64 x) : x{norm(x % getMod())} {}\n    \n    static i64 Mod;\n    constexpr static i64 getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(i64 Mod_) {\n        Mod = Mod_;\n    }\n    constexpr i64 norm(i64 x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr i64 val() const {\n        return x;\n    }\n    explicit constexpr operator i64() const {\n        return x;\n    }\n    constexpr MLong operator-() const {\n        MLong res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MLong inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MLong &operator*=(MLong rhs) & {\n        x = mul(x, rhs.x, getMod());\n        return *this;\n    }\n    constexpr MLong &operator+=(MLong rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator-=(MLong rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MLong &operator/=(MLong rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MLong operator*(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MLong operator+(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MLong operator-(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MLong operator/(MLong lhs, MLong rhs) {\n        MLong res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MLong &a) {\n        i64 v;\n        is >> v;\n        a = MLong(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MLong &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MLong lhs, MLong rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MLong lhs, MLong rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\ni64 MLong<0LL>::Mod = 1;\n\ntemplate<int P>\nstruct MInt {\n    int x;\n    constexpr MInt() : x{} {}\n    constexpr MInt(i64 x) : x{norm(x % getMod())} {}\n    \n    static int Mod;\n    constexpr static int getMod() {\n        if (P > 0) {\n            return P;\n        } else {\n            return Mod;\n        }\n    }\n    constexpr static void setMod(int Mod_) {\n        Mod = Mod_;\n    }\n    constexpr int norm(int x) const {\n        if (x < 0) {\n            x += getMod();\n        }\n        if (x >= getMod()) {\n            x -= getMod();\n        }\n        return x;\n    }\n    constexpr int val() const {\n        return x;\n    }\n    explicit constexpr operator int() const {\n        return x;\n    }\n    constexpr MInt operator-() const {\n        MInt res;\n        res.x = norm(getMod() - x);\n        return res;\n    }\n    constexpr MInt inv() const {\n        assert(x != 0);\n        return power(*this, getMod() - 2);\n    }\n    constexpr MInt &operator*=(MInt rhs) & {\n        x = 1LL * x * rhs.x % getMod();\n        return *this;\n    }\n    constexpr MInt &operator+=(MInt rhs) & {\n        x = norm(x + rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator-=(MInt rhs) & {\n        x = norm(x - rhs.x);\n        return *this;\n    }\n    constexpr MInt &operator/=(MInt rhs) & {\n        return *this *= rhs.inv();\n    }\n    friend constexpr MInt operator*(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res *= rhs;\n        return res;\n    }\n    friend constexpr MInt operator+(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res += rhs;\n        return res;\n    }\n    friend constexpr MInt operator-(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res -= rhs;\n        return res;\n    }\n    friend constexpr MInt operator/(MInt lhs, MInt rhs) {\n        MInt res = lhs;\n        res /= rhs;\n        return res;\n    }\n    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {\n        i64 v;\n        is >> v;\n        a = MInt(v);\n        return is;\n    }\n    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {\n        return os << a.val();\n    }\n    friend constexpr bool operator==(MInt lhs, MInt rhs) {\n        return lhs.val() == rhs.val();\n    }\n    friend constexpr bool operator!=(MInt lhs, MInt rhs) {\n        return lhs.val() != rhs.val();\n    }\n};\n\ntemplate<>\nint MInt<0>::Mod = 1;\n\ntemplate<int V, int P>\nconstexpr MInt<P> CInv = MInt<P>(V).inv();\n\nconstexpr int P = 998244353;\nusing Z = MInt<P>;\n\nstruct Comb {\n    int n;\n    std::vector<Z> _fac;\n    std::vector<Z> _invfac;\n    std::vector<Z> _inv;\n    \n    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}\n    Comb(int n) : Comb() {\n        init(n);\n    }\n    \n    void init(int m) {\n        if (m <= n) return;\n        _fac.resize(m + 1);\n        _invfac.resize(m + 1);\n        _inv.resize(m + 1);\n        \n        for (int i = n + 1; i <= m; i++) {\n            _fac[i] = _fac[i - 1] * i;\n        }\n        _invfac[m] = _fac[m].inv();\n        for (int i = m; i > n; i--) {\n            _invfac[i - 1] = _invfac[i] * i;\n            _inv[i] = _invfac[i] * _fac[i - 1];\n        }\n        n = m;\n    }\n    \n    Z fac(int m) {\n        if (m > n) init(2 * m);\n        return _fac[m];\n    }\n    Z invfac(int m) {\n        if (m > n) init(2 * m);\n        return _invfac[m];\n    }\n    Z inv(int m) {\n        if (m > n) init(2 * m);\n        return _inv[m];\n    }\n    Z binom(int n, int m) {\n        if (n < m || m < 0) return 0;\n        return fac(n) * invfac(m) * invfac(n - m);\n    }\n} comb;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, k;\n    std::cin >> n >> k;\n    \n    std::vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::vector<int> p(n);\n    for (int i = 0, j = 0; i < n; i++) {\n        while (a[i] - a[j] > k) {\n            j++;\n        }\n        p[i] = j;\n    }\n    \n    std::vector<Z> dp(n);\n    std::vector<Z> sum(n + 1);\n    for (int i = 0; i < n; i++) {\n        Z val = 0;\n        val += comb.fac(n - 1) * comb.invfac(n - p[i] - 1);\n        val += sum[p[i]] * comb.invfac(n - p[i] - 1);\n        if (p[i] < i) {\n            if (i == n - 1) {\n                val = 0;\n            } else {\n                val *= comb.fac(n - p[i] - 2) * comb.invfac(n - i - 2);\n            }\n        }\n        \n        dp[i] = val;\n        if (i < n - 1) {\n            sum[i + 1] = sum[i] + dp[i] * comb.fac(n - i - 2);\n        }\n    }\n    \n    std::cout << dp[n - 1] << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "math"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Prediction.json",
    "editorial_link": "https://codeforces.com//blog/entry/114300",
    "editorial": "We need some sort of better criterion other than \"all matches can be\r\npredicted\" first. Suppose the ratings of the participants are in the\r\norder of their indices. Then, if all games are predictable, the -th game\r\nshould be won by the participant with the rating equal to ; and in the\r\n-th game, they will play against the participant with rating . So, in\r\norder for each game to be predictable, . This is the criterion we will\r\nuse.So, we will try to count the number of orderings meeting this\r\ncondition. One very important observation we need to make is that, if we\r\nremove several participants with the lowest ratings from the ordering,\r\nthat ordering still satisfies the condition (for each element, either\r\nthe prefix before it is removed completely, or the maximum on it is\r\nunchanged). So, this allows us to construct the correct ordering by\r\nplacing the sportsmen from the maximum rating to the minimum rating, and\r\nmaking sure that on every step, the order stays correct.Okay. Let\u00e2\u0080\u0099s\r\nreverse the ratings array, and try to write the following dynamic\r\nprogramming: is the number of correct orderings of the first sportsmen\r\n(the highest-rated sportsmen, since we reversed the ratings array).\r\nLet\u00e2\u0080\u0099s try to place the next sportsman. We run into the following issue:\r\nfor some orderings of the first sportsmen, it is possible to place the\r\nnext one anywhere (these orderings are where the first sportsman in the\r\nordering doesn\u00e2\u0080\u0099t conflict with the sportsman we are trying to place);\r\nbut for other orderings, some positions might be forbidden. And to keep\r\ntrack of which positions are forbidden, and for which sportsmen, we\r\nprobably need some additional states for the dynamic programming, which\r\nwe don\u00e2\u0080\u0099t really want to since states is probably the most we can\r\nallow.Okay, so let\u00e2\u0080\u0099s avoid this issue entirely. We don\u00e2\u0080\u0099t like the\r\norderings where the next sportsman can\u00e2\u0080\u0099t be placed anywhere, so let\u00e2\u0080\u0099s\r\nfind a way to \"ignore\" them: discard the previous definition of . Now,\r\nlet is the number of correct orderings of the highest-rated sportsmen ;\r\nwhen we place the next sportsman, in case it becomes the first element\r\nand conflicts with some of the elements we haven\u00e2\u0080\u0099t placed yet, . So,\r\nthis leads to the following transitions in the dynamic programming: if\r\nwe place the -th sportsman on any position other than the first one,\r\nthere are ways to do it, and we transition from to ; otherwise, if we\r\nplace the -th sportsman on the first position, let be the last sportsman\r\n\"conflicting\" with the sportsman . Let\u00e2\u0080\u0099s try placing all sportsmen from\r\nto before placing the sportsman . They cannot be placed on the first\r\nposition (otherwise they will conflict either with each other or with\r\nthe sportsman ), so the first one can be placed in ways, the second one\r\nin ways, and so on; this product can be easily calculated in by\r\npreparing factorials and inverse factorials. So, then we transition from\r\nto . There is a special case in our dynamic programming. It should start\r\nwith , but what if the -st sportsman conflicts with someone? Then the\r\nordering of the first sportsmen is incorrect. In this case, the answer\r\nis since the -st and the -nd sportsmen are conflicting.Overall\r\ncomplexity of this solution is or depending on your implementation.\r\n"
}