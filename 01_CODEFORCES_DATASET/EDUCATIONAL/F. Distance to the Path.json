{
    "link": "https://codeforces.com//contest/1749/problem/F",
    "problemId": "1596427",
    "problem_idx": "F",
    "shortId": "1749F",
    "contest_number": "1749",
    "problem_submissions": {
        "F": [
            177196926,
            177193969,
            177197845,
            177198119,
            177206430,
            177210873,
            177199785,
            177210774,
            177202230,
            177192913,
            177192213,
            177200070,
            177205944,
            177170394,
            177182862,
            177215270,
            177215844,
            177215523,
            177215051
        ],
        "E": [
            177175453,
            177181859,
            177173202,
            177167666,
            177181787,
            177187486,
            177182981,
            177191658,
            177182011,
            177191907,
            177180248,
            177184144,
            177194645,
            177180352,
            177179743,
            177190262,
            177179802,
            177185905,
            177189289,
            177181499
        ],
        "D": [
            177160734,
            177165684,
            177163670,
            177160708,
            177168035,
            177167597,
            177159805,
            177163272,
            177173571,
            177176783,
            177165402,
            177190745,
            177201885,
            177169012,
            177171922,
            177163620,
            177167442,
            177171641,
            177173186,
            177176099
        ],
        "C": [
            177153350,
            177154933,
            177150750,
            177151409,
            177156559,
            177158501,
            177150569,
            177150769,
            177164991,
            177159801,
            177155722,
            177194758,
            177205203,
            177156409,
            177150026,
            177153467,
            177161017,
            177156613,
            177158578,
            177157179
        ],
        "B": [
            177148010,
            177147226,
            177145824,
            177144459,
            177148401,
            177151190,
            177144790,
            177144751,
            177149472,
            177152803,
            177150420,
            177196545,
            177209340,
            177148820,
            177144521,
            177146740,
            177154433,
            177150579,
            177148916,
            177150562
        ],
        "A": [
            177143584,
            177143989,
            177143613,
            177143436,
            177144016,
            177147398,
            177143479,
            177143419,
            177143476,
            177149821,
            177206375,
            177197200,
            177210312,
            177145598,
            177143407,
            177143819,
            177150081,
            177145044,
            177144026,
            177143706
        ]
    },
    "name": "F. Distance to the Path",
    "statement": "You are given a tree consisting of n vertices. Initially, each vertex\r\nhas a value 0.You need to perform m queries of two types: You are given\r\na vertex index v. Print the value of the vertex v. You are given two\r\nvertex indices u and v and values k and d (d\r\nle 20). You need to add k to the value of each vertex such that the\r\ndistance from that vertex to the path from u to v is less than or equal\r\nto d. The between two vertices x and y is equal to the number of on the\r\npath from x to y. For example, the distance from x to x itself is equal\r\nto 0.The distance from the vertex v to some path from x to y is equal to\r\nthe minimum among distances from v to any vertex on the path from x to\r\ny.\r\n",
    "solutions": [
        "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv=\" \"){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv=\" \"){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<\" \";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<\" \";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<\" \";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<\" \";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<\"[\"<<z.first<<\"]=\"<<z.second<<\",\";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\ntemplate<typename T>\nstruct HLD{\n  using D=long long;\n  int n;\n  vector<int>sz;//\u90e8\u5206\u6728\u30b5\u30a4\u30ba\n  vector<D>dep;\n  vector<int>par;\n  vector<int>head;\n  Graph<T> &g;//\u96a3\u63a5\u30ea\u30b9\u30c8\n  vector<edge<T>>edges;//\u30c7\u30fc\u30bf\u69cb\u9020\u306b\u4e57\u305b\u308bedge\u5217\n  vector<int>in,out;//[in,out)\u3067\u90e8\u5206\u6728\u3001[ina,inb]\u3067a~b\u306e\u30d1\u30b9(a\u304c\u4e0a)\n  vector<int>comp;//\u9023\u7d50\u6210\u5206\u306e\u6839\n  //in\u306f\u9802\u70b9\u306eindex\u3092\u8868\u3059\u3002\u307e\u305f\u3001edge\u5217\u306e\u4e0b\u5074\u306e\u9802\u70b9\u3067\u3042\u308b\n  HLD(Graph<T> &g,int r=-1):g(g),n(g.size()){\n    hld_build(r);\n  }\n  void hld_build(int root = -1){\n    in.assign(n,-1);out.assign(n,-1);dep.assign(n,0);\n    par.assign(n,-1);head.assign(n,-1);sz.assign(n,-1);comp.assign(n,-1);\n    edges.assign(n,edge<T>());\n    if(root == -1){//\u6839\u304c\u3069\u3053\u3067\u3082\u826f\u3044\u5834\u5408(\u68ee\u3067\u3082\u53ef)\n      for(int i=0;i<n;i++){\n        if(sz[i] == -1){\n          head[i] = i;\n          dfs_sz(i, 0, i);\n          dfs_hld(i);\n        }\n      }\n    }\n    else{\n      head[root] = root;\n      dfs_sz(root, 0, root);\n      dfs_hld(root);\n    }\n  }\n  void dfs_sz(int k, D d,int r){\n    sz[k] = 1;\n    comp[k] = r;\n\tdep[k] = d;\n    for(auto &e: g[k]){\n      if(e.to == par[k])continue;\n      par[e.to] = k;\n      dfs_sz(e.to, d+e.cost, r);\n      sz[k] += sz[e.to];\n      if(sz[e.to] > sz[g[k][0].to])swap(e, g[k][0]);\n    }\n  }\n  int time = 0;\n  void dfs_hld(int k){\n    in[k] = time++;\n    for(auto e:g[k]){\n      if(e.to == par[k])continue;\n      head[e.to] = (e.to == g[k][0].to ? head[k]: e.to);\n      edges[time] = e;\n      dfs_hld(e.to);\n    }\n    out[k] = time;\n  }\n  int lca(int p,int q){\n    while(1){\n      if(in[p] < in[q])swap(p,q);\n      if(head[p] == head[q])return q;\n      p = par[head[p]];\n    }\n  }\n  vector<pair<int,int>>query_path(int p,int q,bool isEdge){\n    int r=lca(p,q);\n    vector<pair<int,int>>ret;\n    for(int i=0;i<2;i++){\n      if(i == 1)swap(p,q);\n      while(1){\n        if(isEdge&&p==r)break;\n        if(head[p]==head[r]){\n          ret.emplace_back(in[r]+(isEdge?1:i),in[p]+1);\n          break;\n        }\n        ret.emplace_back(in[head[p]],in[p]+1);\n        p = par[head[p]];\n      }\n    }\n    return ret;\n  }\n  vector<vector<pair<int,int>>>query_order_path(int p,int q,bool isEdge){\n\t//\u975e\u53ef\u63db\u30af\u30a8\u30ea\u7528\u3001\u914d\u52170\u3092\u9806\u756a\u3092\u53cd\u8ee2\u3057\u305f\u30c7\u30fc\u30bf\u69cb\u9020\u306b\u3001\u914d\u52171\u3092\u901a\u5e38\u306e\u30c7\u30fc\u30bf\u69cb\u9020\u306b\n    vector<vector<pair<int,int>>>ret(2);\n    int r=lca(p,q);\n    for(int i=0;i<2;i++){\n      if(i == 1)swap(p,q);\n      while(1){\n        if(isEdge&&p==r)break;\n        if(head[p]==head[r]){\n          if(i==0) ret[i].emplace_back(n-(in[p]+1),n-(in[r]+(isEdge?1:i)));\n          else ret[i].emplace_back(in[r]+(isEdge?1:i),in[p]+1);\n          break;\n        }\n        if(i==0) ret[i].emplace_back(n-(in[p]+1),n-(in[head[p]]));\n        else ret[i].emplace_back(in[head[p]],in[p]+1);\n        p = par[head[p]];\n      }\n    }\n    reverse(ret[1].begin(), ret[1].end());\n    return ret;\n  }\n  pair<int,int>query_subtree(int p,bool isEdge){\n    return make_pair(in[p]+isEdge,out[p]);\n  }\n  //u\u306ev\u65b9\u5411\u306e\u5b50 \u5b50\u5b6b\u95a2\u4fc2\u306f\u524d\u3082\u3063\u3066\u78ba\u8a8d\u3059\u308b\u3053\u3068(in,out\u3092\u898b\u308b)\n  int child(int u,int v){\n    while(1){\n      if(head[u]==head[v]){\n        v=g[u][0].to;\n        break;\n      }\n      v=head[v];\n      if(par[v]==u)break;\n      v=par[v];\n    }\n    return v;\n  }\n  //u\u3092v\u65b9\u5411\u306b\u4e00\u3064\u9032\u3081\u305f\u9802\u70b9\n  int move(int u,int v){\n    assert(u!=v);\n    if(in[u]<in[v]&&in[v]<out[u])return child(u,v);\n    else return par[u];\n  }\n  D dist(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n  vector<int>rev_in;\n  int climb(int u,int k){\n    if(rev_in.empty()){\n      rev_in.resize(n);\n      for(int i=0;i<n;i++)rev_in[in[i]]=i;\n    }\n    int nd=max<int>(dep[u]-k, 0);\n    while(dep[u]>nd){\n      if(dep[head[u]]>nd){\n        u=par[head[u]];\n      }\n      else{\n        u=rev_in[in[head[u]]+nd-dep[head[u]]];\n      }\n    }\n    return u;\n  }\n  int jump(int from,int to, int k){\n    int r = lca(from, to);\n    int d1 = dep[from] - dep[r];\n    int d2 = dep[to] - dep[r];\n    if(d1 + d2 < k)return -1;\n    else if(k <= d1)return climb(from, k);\n    else return climb(to, d1 + d2 - k); \n  }\n  template<typename I>\n  Graph<T>lca_tree(vector<I>&v){\n    auto compare=[&](int x,int y){return in[x]<in[y];};\n    sort(v.begin(),v.end(),compare);\n    int sz1=v.size();\n    for(int i=0;i<sz1-1;i++)v.push_back(lca(v[i],v[i+1]));\n    sort(v.begin(),v.end(),compare);\n    v.erase(unique(v.begin(),v.end()),v.end());\n    int sz2=v.size();\n    Graph<T>ret(sz2);\n    stack<int>st;\n    for(int i=0;i<sz2;i++){\n      while(!st.empty()&&out[v[st.top()]]<=in[v[i]])st.pop();\n      if(!st.empty()){\n        ret[st.top()].emplace_back(i,dep[v[i]]-dep[v[st.top()]]);\n        ret[i].emplace_back(st.top(),dep[v[i]]-dep[v[st.top()]]);\n      }\n      st.push(i);\n    }\n    return ret;\n  }\n};\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    n++;\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  //[l,r)\n  void add(ll l,ll r,T w){\n\tif(l>=r)return;\n    add(l,w);add(r,-w);\n  }\n  T sum(ll a){//[0,a)\n\t  if(a<=0)return 0;\n    T ret = 0;\n    for(ll i=a;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  //[a,b)\n  T sum(ll a,ll b){return a>=b?0:sum(b)-sum(a);}\n  T operator[](ll pos){\n    return sum(0,pos+1);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n-1;i++){\n      if(i!=0)cout<<\" \";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  int n;cin>>n;\n  int sz=20;\n  vector<BIT<ll>>bit(sz+1,BIT<ll>(n+1));\n  auto g=readGraph<int>(n,n-1);\n  HLD hld(g);\n  auto s=vec(sz+1,n,0LL);\n  int q;cin>>q;\n  while(q--){\n    int type;cin>>type;\n    if(type==1){\n      int v;cin>>v;v--;\n      int cl=0;\n      ll ret=0;\n      while(v!=-1&&cl<=sz){\n        if(v==0){\n          rep(i,cl,sz+1){\n            ret+=bit[i][hld.in[0]];\n            //cout<<i spa bit[i][hld.in[0]] spa \"bit\"<<endl;\n            ret+=s[i][0];\n          }\n        }\n        else{\n          ret+=bit[cl][hld.in[v]];\n          ret+=s[cl][v];\n          if(cl+1<=sz)ret+=s[cl+1][v];\n        }\n        cl++;\n        v=hld.par[v];\n      }\n      cout<<ret<<endl;\n    }\n    else{\n      int u,v,k,d;cin>>u>>v>>k>>d;u--;v--;\n      int r=hld.lca(u,v);\n      for(auto z:{u,v}){\n        if(z!=r){\n          auto tmp=hld.query_path(hld.move(r,z),z,false);\n          //cout<<z spa r spa hld.move(r,z)<<endl;\n          for(auto z:tmp){\n            //cout<<\"hld\" spa z.fi spa z.se<<endl;\n            bit[d].add(z.fi,z.se,k);\n          }\n        }\n      }\n      while(r!=-1&&d>=0){\n        s[d][r]+=k;\n        d--;\n        r=hld.par[r];\n      }\n    }\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dfs and similar",
        "trees"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Distance to the Path.json",
    "editorial_link": "https://codeforces.com//blog/entry/108269",
    "editorial": "For the purpose of solving the task, let\u00e2\u0080\u0099s choose some root in the tree\r\nand introduce another operation to the tree: add to all vertices that\r\nare in the subtree of the given vertex and on the distance from . For\r\nexample, if , it\u00e2\u0080\u0099s itself or if then it\u00e2\u0080\u0099s all children of .Let\u00e2\u0080\u0099s be the\r\nparent of vertex , , and so on (). So, how to perform this operation?\r\nInstead of adding to all vertices in the subtree, we can add only to the\r\nvertex . And when we need to get the answer for some vertex , we will\r\nget it from .Of course, since there are different -s, we\u00e2\u0080\u0099ll create\r\ndifferent arrays for each possible . So, the answer for the vertex will\r\nbe equal to .Now, let\u00e2\u0080\u0099s discuss how to use the introduced operation to\r\nperform the given one. We can make the given operation \" \" using ours in\r\nthe following way: Let\u00e2\u0080\u0099s find using any standard algorithm (binary\r\nlifting, for example). Let\u00e2\u0080\u0099s split all affected vertices in three\r\ngroups: subtrees of path ( inclusive, exclusive), subtrees of path and\r\nsubtrees of path . Note that in such way all affected vertices belong to\r\nat least one group. Let\u00e2\u0080\u0099s look at group of path . The lowest vertices\r\nare on distance from , the next \"level\" are on distance from , the next\r\n\"level\" are on distance from and so on. The last \"level\" we\u00e2\u0080\u0099ll consider\r\nin this group is the vertices in the subtree of the on distance from it.\r\nIn such a way, all we need to do is add to all on the path from . The\r\ngroup of the path is handled in the same way. What\u00e2\u0080\u0099s left? It\u00e2\u0080\u0099s vertices\r\nin subtree of on distances ; in subtree of on distances ; in subtree of\r\non distances ; in subtree of on distance . Note that vertices in subtree\r\nof on distance are included in vertices in subtree of on distance .\r\nAnalogically, vertices on distance from are included in vertices on\r\ndistance from .Moreover, vertices on distance from are included in \"\r\nfrom \" that are included in \" from \" and so on. In other words, all we\r\nneed to proccess are vertices: in subtree of on distances and , in\r\nsubtree of on distances and , in subtree of on distances and . In total,\r\nit\u00e2\u0080\u0099s at most operations: \"add to some vertex \". As a result, all we need\r\nto do is add on path from to some ancestor of ; add in some vertex (can\r\nbe done as operation on path ); ask value in some vertex . We can do all\r\nof these operations in using Fenwick tree (BIT) on -s and -s (we can get\r\nfrom binary lifting). So the first statement operation will work in time\r\nand the second one also in .In total, complexity is time and space.P.S.:\r\nthe second operation can be further optimized to , but it\u00e2\u0080\u0099s not really\r\nnecessary.\r\n"
}