{
    "link": "https://codeforces.com//contest/1167/problem/D",
    "problemId": "344633",
    "problem_idx": "D",
    "shortId": "1167D",
    "contest_number": "1167",
    "problem_submissions": {
        "G": [
            54199521,
            54201009,
            54517594,
            54222661,
            54364012,
            54215552,
            54224700,
            54210170,
            54210125,
            54210060,
            54209496,
            54208961,
            54219271,
            58247930
        ],
        "F": [
            54189763,
            54191560,
            54188017,
            54193815,
            54198047,
            54197721,
            54195395,
            54190513,
            54198962,
            54198980,
            54197783,
            54198116,
            54209016,
            54200221,
            54197337,
            54195561,
            54196921,
            54190680,
            54201016,
            54197503,
            54199324
        ],
        "E": [
            54187099,
            54187335,
            54196048,
            54186318,
            54187789,
            54191563,
            54192086,
            54195810,
            54191131,
            54191667,
            54192242,
            54194803,
            54192777,
            54191266,
            54189610,
            54192694,
            54196385,
            54241812,
            54208508,
            54196237,
            54192975,
            54196282
        ],
        "D": [
            54184655,
            54183868,
            54182601,
            54254072,
            54187816,
            54183265,
            54184958,
            54187415,
            54186508,
            54185650,
            54184214,
            54187917,
            54185330,
            54215169,
            54214062,
            54213957,
            54213940,
            54212912,
            54212894,
            54186804,
            54192578,
            54182335,
            54185963,
            54184762,
            54186406,
            54188164,
            54188808
        ],
        "C": [
            54183325,
            54182652,
            54179797,
            54181639,
            54180270,
            54183029,
            54186018,
            54184791,
            54184638,
            54183698,
            54183060,
            54181938,
            54183556,
            54183141,
            54183089,
            54180288,
            54184423,
            54183220,
            54184555,
            54185863,
            54182921
        ],
        "B": [
            54182048,
            54181521,
            54184836,
            54179971,
            54182085,
            54181491,
            54183487,
            54185276,
            54182631,
            54181677,
            54186071,
            54182415,
            54181445,
            54182146,
            54198453,
            54183319,
            54181503,
            54182555,
            54184235,
            54186573
        ],
        "A": [
            54178078,
            54178458,
            54177903,
            54177871,
            54177876,
            54178109,
            54178374,
            54178382,
            54178054,
            54178274,
            54179924,
            54177952,
            54177881,
            54177926,
            54178075,
            54177978,
            54177900,
            54179121,
            54179411,
            54179558
        ]
    },
    "name": "D. Bicolored RBS",
    "statement": "A string is called if it does not contain any characters other than \"\"\r\nand \"\". A bracket sequence is called (shortly, RBS) if it is possible to\r\nobtain correct arithmetic expression by inserting characters \"\" and \"\"\r\ninto this sequence. For example, \"\", \"\" and \"\" are RBS and \"\" and \"\" are\r\nnot.We can see that each opening bracket in RBS is paired with some\r\nclosing bracket, and, using this fact, we can define of the RBS as\r\nmaximum number of bracket pairs, such that the 2-nd pair lies inside the\r\n1-st one, the 3-rd one inside the 2-nd one and so on. For example,\r\nnesting depth of \"\" is 0, \"\" is 1 and \"\" is 3.Now, you are given RBS s\r\nof even length n. You should color each bracket of s into one of two\r\ncolors: red or blue. Bracket sequence r, consisting only of red\r\nbrackets, should be RBS, and bracket sequence, consisting only of blue\r\nbrackets b, should be RBS. Any of them can be empty. You are not allowed\r\nto reorder characters in s, r or b. No brackets can be left\r\nuncolored.Among all possible variants you should choose one that of r\u2019s\r\nand b\u2019s nesting depth. If there are multiple solutions you can print any\r\nof them.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nint n;\n\nchar wcz[nax];\n\nint b;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%s\", wcz+1);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tif (wcz[i]=='(')\n\t\t{\n\t\t\tb++;\n\t\t\tprintf(\"%d\", (b&1));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\", (b&1));\n\t\t\tb--;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "1500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Bicolored RBS.json",
    "editorial_link": "https://codeforces.com/blog/entry/67058",
    "editorial": "Let be nested depth of RBS . There is an interesting fact that . From\r\nthe other side we can always reach equation using some approaches.Let\u00e2\u0080\u0099s\r\nlook at prefix of length of string . Let be number of opening bracket in\r\nthe prefix, number of closing brackets. Then we can define balance of\r\nthe -th prefix of as .The author\u00e2\u0080\u0099s approach is next: Let\u00e2\u0080\u0099s define of\r\npair of brackets (matched in natural way) as , where is position of\r\nopening bracket of this pair. Then we will color in red all pairs with\r\neven level and in blue with odd level. Proof of :It can be shown that\r\nand exists such that .After any coloring of we can define number of\r\nopening/closing red (blue) brackets of -th prefix of as () and ()\r\nrespectively. Since and , then Finally,\r\n"
}