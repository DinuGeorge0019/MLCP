{
    "link": "https://codeforces.com//contest/1795/problem/G",
    "problemId": "1785703",
    "problem_idx": "G",
    "shortId": "1795G",
    "contest_number": "1795",
    "problem_submissions": {
        "G": [
            193868249,
            193922126,
            193880640,
            193880242,
            193879883,
            193877939,
            193892319,
            193909416,
            193909281,
            193909039,
            193908855,
            193907982,
            193907256,
            193907116,
            193905885,
            193905428,
            193895936,
            193894919,
            193900585,
            193900447,
            193900331,
            193900021,
            193895212,
            193901119,
            193897399,
            194065980,
            193895350,
            193897364,
            193910352,
            193909678,
            193877594,
            193901310,
            193900708,
            193909774,
            193909664,
            193908826,
            193902609,
            193895098,
            193898582,
            193887169,
            193989778,
            193903191,
            193906575,
            193901677
        ],
        "E": [
            193858484,
            193864061,
            193860485,
            193866472,
            193870118,
            193881494,
            193869535,
            193877440,
            194065966,
            193867450,
            193873381,
            193864290,
            193872060,
            193880762,
            193876051,
            193901176,
            193882421,
            193899122,
            193881276,
            193885055
        ],
        "F": [
            193849592,
            193871412,
            193870619,
            193880295,
            193883585,
            193866256,
            193887756,
            193901053,
            193899102,
            193887184,
            194065972,
            193879792,
            193887970,
            193889897,
            193889600,
            193879424,
            193886027,
            193888430,
            193890811,
            193880065,
            193894847,
            193891841
        ],
        "D": [
            193842483,
            193853701,
            193849666,
            193849500,
            193854093,
            193850355,
            193858853,
            193853243,
            194065953,
            193855818,
            193855956,
            193852941,
            193856134,
            193845600,
            193859844,
            193851729,
            193849114,
            193866588,
            193860778,
            193855517
        ],
        "C": [
            193840570,
            193847474,
            193846113,
            193844888,
            193847932,
            193844693,
            193851549,
            193846559,
            194065943,
            193849210,
            193849704,
            193847867,
            193849903,
            193858596,
            193851945,
            193847688,
            193845368,
            193860332,
            193855373,
            193849162
        ],
        "B": [
            193839119,
            193839637,
            193839480,
            193839407,
            193839832,
            193839202,
            193842405,
            193840503,
            194065925,
            193843321,
            193841514,
            193841857,
            193840539,
            193848293,
            193839850,
            193839356,
            193839529,
            193847088,
            193842717,
            193840388
        ],
        "A": [
            193838910,
            193838985,
            193838946,
            193838908,
            193839007,
            193838901,
            193840204,
            193839189,
            194065914,
            193839222,
            193839386,
            193882631,
            193839087,
            193843666,
            193841139,
            193839086,
            193838960,
            193838928,
            193845036,
            193840156,
            193838911
        ]
    },
    "name": "G. Removal Sequences",
    "statement": "You are given a simple undirected graph, consisting of n vertices and m\r\nedges. The vertices are numbered from 1 to n. The i-th vertex has a\r\nvalue a_i written on it.You will be removing vertices from that graph.\r\nYou are allowed to remove vertex i only if its degree is equal to a_i.\r\nWhen a vertex is removed, all edges incident to it are also removed,\r\nthus, decreasing the degree of adjacent non-removed vertices.A valid\r\nsequence of removals is a permutation p_1, p_2,\r\ndots, p_n (1\r\nle p_i\r\nle n) such that the i-th vertex to be removed is p_i, and every removal\r\nis allowed.A pair (x, y) of vertices is if there exist two valid\r\nsequences of removals such that x is removed before y in one of them and\r\ny is removed before x in the other one.Count the number of pairs (x, y)\r\nsuch that x < y.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.02.2023 19:05:48       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i];\n    }\n    vector<vector<int>> g(n);\n    for (int i = 0; i < m; i++) {\n      int x, y;\n      cin >> x >> y;\n      --x; --y;\n      g[x].push_back(y);\n      g[y].push_back(x);\n    }\n    vector<vector<int>> go(n);\n    vector<int> deg(n);\n    for (int i = 0; i < n; i++) {\n      deg[i] = (int) g[i].size();\n    }\n    vector<bool> alive(n, true);\n    vector<int> seq(n);\n    set<int> s;\n    for (int i = 0; i < n; i++) {\n      if (deg[i] == a[i]) {\n        s.insert(i);\n      }\n    }\n    for (int it = 0; it < n; it++) {\n      int v = *s.begin();\n      seq[it] = v;\n      s.erase(v);\n      alive[v] = false;\n      for (int u : g[v]) {\n        if (alive[u]) {\n          go[v].push_back(u);\n          deg[u] -= 1;\n          if (deg[u] == a[u]) {\n            s.insert(u);\n          }\n        }\n      }\n    }\n    long long ans = (long long) n * (n + 1) / 2;\n    for (int b = 0; b < n; b += 64) {\n      vector<unsigned long long> mask(n);\n      const unsigned long long one = 1;\n      for (int i = b; i < b + 64 && i < n; i++) {\n        mask[i] |= (one << (i - b));\n      }\n      for (int it = 0; it < n; it++) {\n        int i = seq[it];\n        for (int u : go[i]) {\n          mask[u] |= mask[i];\n        }\n      }\n      for (int i = 0; i < n; i++) {\n        ans -= __builtin_popcountll(mask[i]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "dfs and similar",
        "graphs"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Removal Sequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/112963",
    "editorial": "Letâs consider what the sequence of removals looks like in general. We\r\nwill base some intuition on a fact that at least one valid sequence is\r\nguaranteed to exist.Remove all vertices that have their degree correct\r\nfrom the start at once. There surely be such vertices, since a valid\r\nsequence would have to start with some of them.Notice that there canât\r\nbe any adjacent vertices among them. If there were, we wouldnât be able\r\nto remove such a pair regardless of the order we choose, since removing\r\none of them makes another oneâs degree too low.Now remove the vertices\r\nthat just got their degrees correct from removing the first layer. Once\r\nagain, these must exist (if the graph is not empty yet), because\r\notherwise any valid sequence would get stuck.Process until nothing is\r\nleft.This algorithm is basically a bfs, and you can implement it like\r\none.Note that each vertex becomes available to be removed only after a\r\ncertain subset of its neighbours is removed. No matter what order you\r\nchoose to remove the vertices in, these vertices will always be the\r\nsame.Huh, so for each vertex, some of its neighbours have to be removed\r\nbefore it, and the rest have to be removed after it (since otherwise,\r\nthe degree of that vertex will become too low). That actually means that\r\nour graph is not as undirected as it seemed. We can direct each edge\r\nfrom a vertex that is removed before the other.This makes a valid\r\nsequence of removals just a topological sort of that directed graph. So\r\na pair is nice if there exist two topological orders such that and go\r\none before another in them.We can make a bold but perfectly reasonable\r\nguess about all nice pairs. A pair is nice if neither of and are\r\nreachable from each other.The necessity of this condition is obvious.\r\nLetâs show sufficiency.Letâs show the construction such that goes before\r\n. To remove , we first have to remove all vertices that have edges to .\r\nTo remove them, we have to remove vertices with edge to them. And so on.\r\nBasically, to remove , we have to remove all vertices that are reachable\r\nfrom on the transposed directed graph. Since is not reachable from , it\r\ndoesnât have to be removed before . So we can first remove all the\r\nrequired vertices, then remove , then continue removing vertices until\r\nwe are able to remove .By switching and in the description of that\r\nconstruction, we can obtain the construction for before .Thus, we\r\nreduced the problem to a rather well-known one. Calculate the number of\r\nreachable pairs of vertices in a directed graph.As far as I know, itâs\r\nnot known to be solvable in sub-quadratic time. And we are not given a\r\nspecific graph. Yes, itâs obviously acyclic, but turns out every acyclic\r\ngraph can be made into a test for this problem. You just have to make\r\nequal to the number of the outgoing edges for each .Somehow we are still\r\ngiven vertices and edges.If you are more familiar with that problem, you\r\nmight know that you can use bitset to solve it. In particular, let be a\r\nbitset such that if if reachable from . Then you can initialize for all\r\nvertices and propagate the knowledge in reverse topological order by\r\napplying for all edges .Unfortunately, that requires memory, and bits is\r\nover a gigabyte.Letâs use of my favorite tricks to make a solution with\r\nmemory and the same complexity. Man, I love that trick. Process vertices\r\nin batches of . Letâs calculate which vertices can reach vertices from\r\nto . The algorithm is basically the same. For each vertex, store a\r\nsmaller bitset of size (also known as an unsigned long long). Initialize\r\nthe bitset for vertices from the batch and propagate the same way for\r\nall vertices. Now just add up the number of ones in each bitset\r\n(__builtin_popcountll). Proceed to the next batch.That makes it\r\niterations of a algorithm. This might require some constant\r\noptimizations. In particular, I suggest not to use dfs inside the\r\niteration, since the recursion makes it really slow. You might iterate\r\nover a vertex in reverse topological order and its outgoing edges. Or,\r\nwhich is way faster, unroll that graph into a list of edges and iterate\r\nover it directly.\r\n",
    "hint": []
}