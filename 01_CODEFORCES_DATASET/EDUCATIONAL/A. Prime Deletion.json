{
    "link": "https://codeforces.com//contest/1861/problem/A",
    "problemId": "2187861",
    "problem_idx": "A",
    "shortId": "1861A",
    "contest_number": "1861",
    "problem_submissions": {
        "F": [
            221319232,
            221334797,
            221343700,
            221334746,
            221435327
        ],
        "E": [
            221294949,
            221294627,
            221307083,
            221304545,
            221289987,
            221293214,
            221302482,
            221312615,
            221307967,
            221303480,
            221309861,
            221307296,
            221307859,
            221320123,
            221304501,
            221805824,
            221308535,
            221309691,
            221307994,
            221314449,
            221316461
        ],
        "D": [
            221289547,
            221296942,
            221291864,
            221307784,
            221293468,
            221297421,
            221296816,
            221288510,
            221291806,
            221295562,
            221296430,
            221296186,
            221290647,
            221296713,
            221298445,
            221297975,
            221298865,
            221297626,
            221298343
        ],
        "C": [
            221285558,
            221285843,
            221287563,
            221293257,
            221282816,
            221283475,
            221287126,
            221284366,
            221286970,
            221291172,
            221290155,
            221290726,
            221290133,
            221287629,
            221289108,
            221291690,
            221291845,
            221290307,
            221291196,
            221291877
        ],
        "B": [
            221280891,
            221279490,
            221280612,
            221282637,
            221278148,
            221277443,
            221280003,
            221278598,
            221281862,
            221281453,
            221282384,
            221284462,
            221279905,
            221283500,
            221283423,
            221284241,
            221280164,
            221284009,
            221283159
        ],
        "A": [
            221277133,
            221276828,
            221277503,
            221276971,
            221276729,
            221276717,
            221276917,
            221276888,
            221277198,
            221278164,
            221278677,
            221280809,
            221276797,
            221278399,
            221277159,
            221277434,
            221276991,
            221278067,
            221276850
        ]
    },
    "name": "A. Prime Deletion",
    "statement": "A number is a positive integer that has exactly two different positive\r\ndivisors: 1 and the integer itself. For example, 2, 3, 13 and 101 are\r\nprime numbers; 1, 4, 6 and 42 are not.You are given a sequence of digits\r\nfrom 1 to 9, in which .You are allowed to do the following operation :\r\nchoose any digit from the sequence and delete it. Your goal is to obtain\r\na sequence which represents a prime number. Note that you cannot reorder\r\nthe digits in the sequence.Print the resulting sequence, or report that\r\nit is impossible to perform the operations so that the resulting\r\nsequence is a prime number.\r\n",
    "solutions": [
        "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC target (\"avx2\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=1000*1007;\n\nchar wcz[nax];\n\nvoid test()\n{\n\tscanf(\"%s\", wcz+1);\n\tfor (int i=1; 1; i++)\n\t{\n\t\tif (wcz[i]=='1')\n\t\t{\n\t\t\tprintf(\"17\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (wcz[i]=='7')\n\t\t{\n\t\t\tprintf(\"71\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--)\n\t\ttest();\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Prime Deletion.json",
    "editorial_link": "https://codeforces.com//blog/entry/119964",
    "editorial": "There are many possible approaches to this problem.For example, you\r\ncould use brute force to solve it: iterate on every integer from , check\r\nthat it is a prime number by iterating on its divisors, and check that\r\nit appears as a subsequence in the given digit sequence. If you find the\r\nanswer, break the loop and print the number you found.But that\u00e2\u0080\u0099s a bit\r\nlengthy to code. Let\u00e2\u0080\u0099s try something different.We can try looking for a\r\nsmall set of primes such that at least one of the primes from that set\r\nappears in the given sequence. Let\u00e2\u0080\u0099s try short primes, they are easier\r\nto work with.If there exist two prime numbers of length consisting of\r\ndigits and , one of them is , and the other of them is , then one of\r\nthem will definitely appear in our sequence. If comes earlier than ,\r\nthen appears in the sequence, otherwise it\u00e2\u0080\u0099s .Thankfully, it\u00e2\u0080\u0099s possible\r\nto find these two primes. For example, you can use and ; one of them\r\nwill definitely appear in the sequence.So, the easiest solution is to\r\nfind whether is earlier than in the sequence. If is earlier, then is the\r\nanswer, otherwise it\u00e2\u0080\u0099s .\r\n"
}