{
    "link": "https://codeforces.com//contest/1783/problem/E",
    "problemId": "1728814",
    "problem_idx": "E",
    "shortId": "1783E",
    "contest_number": "1783",
    "problem_submissions": {
        "G": [
            188483896,
            188470188,
            188490778,
            188491718,
            188493113,
            188527457,
            188526933,
            188518837,
            188481313
        ],
        "F": [
            188457991,
            188459741,
            188468922,
            188473664,
            188468205,
            188471208,
            188461540,
            188473366,
            188477664,
            188473046,
            188489629,
            188473873,
            188484171,
            188480546,
            188485471,
            188484623,
            188483301,
            188466307,
            188469985,
            188485060
        ],
        "E": [
            188452364,
            188453897,
            188463917,
            188466624,
            188459377,
            188459968,
            188455446,
            188466225,
            188471180,
            188466814,
            188462880,
            188467584,
            188467423,
            188462700,
            188463311,
            188503353,
            188474118,
            188475092,
            188461623,
            188502886,
            188463602,
            188475668
        ],
        "D": [
            188448529,
            188449082,
            188455318,
            188454045,
            188455437,
            188454808,
            188471673,
            188459878,
            188455664,
            188459984,
            188457996,
            188455008,
            188460084,
            188450967,
            188459128,
            188456144,
            188459103,
            188459237,
            188463185
        ],
        "C": [
            188443311,
            188439911,
            188447553,
            188445874,
            188449689,
            188446252,
            188448135,
            188452418,
            188447924,
            188450344,
            188449627,
            188448578,
            188449959,
            188467122,
            188452277,
            188450824,
            188449810,
            188450396,
            188451763,
            188456895
        ],
        "B": [
            188434637,
            188433902,
            188440591,
            188436845,
            188440180,
            188437731,
            188434593,
            188440675,
            188439917,
            188436694,
            188436264,
            188437707,
            188438645,
            188437659,
            188440538,
            188439980,
            188442461,
            188440519,
            188465336,
            188436451
        ],
        "A": [
            188432373,
            188432255,
            188432618,
            188432523,
            188433063,
            188432771,
            188432273,
            188433871,
            188432631,
            188433273,
            188432881,
            188432854,
            188433005,
            188432822,
            188435678,
            188432922,
            188432552,
            188432977,
            188432291,
            188432577
        ]
    },
    "name": "E. Game of the Year",
    "statement": "Monocarp and Polycarp are playing a computer game. This game features n\r\nbosses for the playing to kill, numbered from 1 to n.They will fight\r\nboss the following way: Monocarp makes k attempts to kill the boss;\r\nPolycarp makes k attempts to kill the boss; Monocarp makes k attempts to\r\nkill the boss; Polycarp makes k attempts to kill the boss; ... Monocarp\r\nkills the i-th boss on a_i-th attempt. Polycarp kills the i-th boss on\r\nb_i-th attempt. After one of them kills the i-th boss, they move on to\r\nthe (i+1)-st boss. The attempt counters reset for both of them. Once one\r\nof them kills the n-th boss, the game ends.Find all values of k from 1\r\nto n such that Monocarp kills .\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    \n    std::vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    for (int i = 0; i < n; i++) {\n        std::cin >> b[i];\n    }\n    \n    std::vector<int> d(n + 1);\n    for (int i = 0; i < n; i++) {\n        if (a[i] > b[i]) {\n            d[b[i]]++;\n            d[a[i]]--;\n        }\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        d[i] += d[i - 1];\n    }\n    \n    std::vector<int> ans;\n    for (int k = 1; k <= n; k++) {\n        int ok = 1;\n        for (int i = k; i <= n; i += k) {\n            if (d[i]) {\n                ok = 0;\n                break;\n            }\n        }\n        if (ok) ans.push_back(k);\n    }\n    \n    std::cout << ans.size() << \"\\n\";\n    for (auto x : ans) {\n        std::cout << x << \" \\n\"[x == ans.back()];\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "data structures",
        "math",
        "number theory"
    ],
    "dificulty": "2300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Game of the Year.json",
    "editorial_link": "https://codeforces.com//blog/entry/111194",
    "editorial": "Consider some value of . When is it included in the answer? When\r\nMonocarp spends a lower or an equal amount of \"blocks\" of attempts than\r\nPolycarp for killing every boss.Formally, for all from to .Let\u00e2\u0080\u0099s reverse\r\nthis condition. is not in the answer if there exists such from to that .\r\nSo, there exists at least one value between and . Let\u00e2\u0080\u0099s call it . Now\r\nit\u00e2\u0080\u0099s . I set the and signs arbitrarily, just so that it shows that such\r\na value exists. You can\u00e2\u0080\u0099t put both or both , because that will accept\r\nvalues or at least values, respectively.Would be cool if we could\r\nmultiply everything by and it still worked. Is it completely impossible,\r\nthough? Take a look at . What it says is that there exists a multiple of\r\nbetween and . A multiple of is a number that\u00e2\u0080\u0099s the last in each \"block\"\r\nof attempts (the block of value that are rounded up the same). Turns\r\nout, this is what we are looking for already. Right after the multiple\r\nof , the new block starts. Thus, we are wrong we our signs. It should be\r\nis in the block after , so it requires more blocks of attempts.So for to\r\nnot be included in the answer, there should exist at least one such that\r\nthere exists a multiple of in the half-interval .That is pretty easy to\r\nimplement. For each , calculate the number of half-intervals that cover\r\n. I think this is called delta-encoding. Iterate over all half-intervals\r\nand make two updates for each one: increment by on position and\r\ndecrement by on position . Then make a prefix sum over these updates.\r\nNow the value in the -th position tells you the number of half-intervals\r\nthat cover .To check a particular value of , iterate over all multiples\r\nof and check that none are covered by half-intervals. It\u00e2\u0080\u0099s known that\r\nthe total number of multiples over all numbers from to is .Overall\r\ncomplexity: per testcase.\r\n"
}