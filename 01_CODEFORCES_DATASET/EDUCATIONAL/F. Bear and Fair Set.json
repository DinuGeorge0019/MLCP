{
    "link": "https://codeforces.com//contest/628/problem/F",
    "problemId": "48834",
    "problem_idx": "F",
    "shortId": "628F",
    "contest_number": "628",
    "problem_submissions": {
        "F": [
            16211421,
            16211567,
            16211169,
            16208042,
            16208527,
            16211299,
            16220786,
            16205726,
            16251882,
            16212235,
            16209081,
            16210918,
            16211253
        ],
        "E": [
            16209151,
            16209513,
            16209798,
            16210303,
            16210389,
            16210209,
            16207914,
            16208921,
            16208930,
            16210016,
            16208755,
            16210104,
            16210071,
            16211325,
            16211040,
            16210904,
            16210538,
            16209234,
            16210698,
            16210531,
            16214256
        ],
        "D": [
            16206627,
            16206845,
            16206086,
            16207092,
            16208100,
            16205719,
            16205288,
            16206076,
            16260286,
            16206980,
            16206584,
            16206673,
            16206619,
            16207592,
            16206640,
            16380499,
            16206826,
            16207654
        ],
        "C": [
            16204024,
            16203998,
            16203984,
            16204943,
            16204160,
            16203580,
            16204456,
            16203644,
            16203472,
            16204820,
            16204285,
            16204239,
            16203927,
            16204552,
            16204730,
            16203693,
            16204713,
            16204672
        ],
        "B": [
            16203509,
            16203431,
            16203495,
            16204395,
            16203326,
            16203172,
            16204023,
            16203232,
            16203233,
            16204126,
            16203462,
            16203612,
            16203325,
            16203859,
            16203731,
            16203308,
            16203766,
            16203989
        ],
        "A": [
            16203031,
            16203135,
            16203205,
            16203772,
            16203048,
            16203023,
            16203022,
            16203045,
            16203001,
            16203771,
            16203077,
            16203193,
            16203044,
            16203133,
            16203132,
            16203092,
            16203204,
            16203389
        ]
    },
    "name": "F. Bear and Fair Set",
    "statement": "Limak is a grizzly bear. He is big and dreadful. You were chilling in\r\nthe forest when you suddenly met him. It’s very unfortunate for you. He\r\nwill eat all your cookies unless you can demonstrate your mathematical\r\nskills. To test you, Limak is going to give you a puzzle to solve.It’s a\r\nwell-known fact that Limak, as every bear, owns a set of numbers. You\r\nknow some information about the set: The elements of the set are\r\ndistinct positive integers. The number of elements in the set is . The\r\nnumber is divisible by . All elements are between and , inclusive: bears\r\ndon’t know numbers greater than . For each in , the set contains exactly\r\nelements that give remainder when divided by . (That is, there are\r\nelements divisible by , elements of the form , elements of the form ,\r\nand so on.) Limak smiles mysteriously and gives you hints about his set.\r\nThe -th hint is the following sentence: \"If you only look at elements\r\nthat are between and , inclusive, you will find exactly such elements in\r\nmy set.\"In a moment Limak will tell you the actual puzzle, but something\r\ndoesn’t seem right... That smile was very strange. You start to think\r\nabout a possible reason. Maybe Limak cheated you? Or is he a fair\r\ngrizzly bear?Given , , and hints, check whether Limak can be fair, i.e.\r\nthere exists at least one set satisfying the given conditions. If it’s\r\npossible then print ”\". Otherwise, print ”\".\r\n",
    "solutions": [
        "#ifdef __GNUC__\n#pragma GCC target(\"sse4,avx\")\n#endif\n#include <immintrin.h>\n#include <algorithm>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <cstdint>\n#include <numeric>\n#include <array>\n\nstruct LinearProblem {\n  std::array<int, 5> s;\n  int q;\n};\n\nvoid run(std::istream& in, std::ostream& out) {\n  int n, b, q;\n  in >> n >> b >> q;\n  std::vector<std::pair<int, int>> queries(q);\n  for (int i = 0; i < q; i++) {\n    in >> queries[i].first >> queries[i].second;\n  }\n  queries.emplace_back(b, n);\n  queries.emplace_back(0, 0);\n  std::sort(queries.begin(), queries.end());\n  std::vector<LinearProblem> problems;\n  for (int i = 0; i + 1 < queries.size(); i++) {\n    if (queries[i].first == queries[i + 1].first) {\n      if (queries[i].second != queries[i + 1].second) {\n        out << \"unfair\" << std::endl;\n        return;\n      }\n    }\n    if (queries[i].second > queries[i + 1].second) {\n      out << \"unfair\" << std::endl;\n      return;\n    }\n    if (queries[i+1].second - queries[i].second > queries[i+1].first - queries[i].first) {\n      out << \"unfair\" << std::endl;\n      return;\n    }\n    LinearProblem s;\n    s.q = queries[i + 1].second - queries[i].second;\n    s.s.fill(0);\n    for (int j = queries[i].first + 1; j <= queries[i + 1].first; j++) {\n      s.s[j % 5]++;\n    }\n    problems.push_back(s);\n  }\n  for (int mask = 1; mask < 32; mask++) {\n    std::vector<int> good;\n    std::vector<int> bad;\n    for (int i = 0; i < 5; i++) {\n      if ((mask >> i) & 1) {\n        good.push_back(i);\n      } else {\n        bad.push_back(i);\n      }\n    }\n    int target = good.size() * (n / 5);\n    int minSum = 0;\n    int maxSum = 0;\n    for (LinearProblem& s : problems) {\n      int minValue = s.q;\n      for (int idx : bad) {\n        minValue -= s.s[idx];\n      }\n      minSum += std::max(0, minValue);\n      int maxValue = 0;\n      for (int idx : good) {\n        maxValue += s.s[idx];\n      }\n      maxSum += std::min(s.q, maxValue);\n    }\n    if (target < minSum || target > maxSum) {\n      out << \"unfair\" << std::endl;\n      return;\n    }\n  }\n  out << \"fair\" << std::endl;\n}\n\nint main() {\n  std::cin.sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  run(std::cin, std::cout);\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "flows",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Bear and Fair Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/43203",
    "editorial": "The problem was suggested and prepared by Kamil Debowski Errichto. He\r\nalso wrote the editorial. At the beginning, to make things simpler, we\r\nshould add a query (hint) with , and then sort queries by . Sorted\r\nqueries (hints) divide interval into disjoint intervals. For each\r\ninterval we know how many elements should be there. Letâs build a graph\r\nand find a max flow there. The answer is \"YES\" only if the flow is .\r\nEach vertex from should be connected with the source by an edge with\r\ncapacity . Each vertex from should be connected with the sink by an edge\r\nwith capacity equal to the size of the interval. Between each vertex\r\nfrom and from should be an edge with capacity equal to the number of\r\nnumbers in the interval , giving remainder when divided by . You can\r\nalso use see that itâs similar to finding matching. In fact, we can use\r\nthe Hallâs marriage theorem. For each of sets of vertices from (sets of\r\nremainders) iterate over intervals and count how many numbers we can\r\ntake from with remainders from the fixed set of remainders. The\r\nimplementation with the Hallâs theorem: C++ solution. Complexity: . In\r\nour problem .\r\n",
    "hint": []
}