{
    "link": "https://codeforces.com//contest/873/problem/D",
    "problemId": "127822",
    "problem_idx": "D",
    "shortId": "873D",
    "contest_number": "873",
    "problem_submissions": {
        "F": [
            31249155,
            31246074,
            31247917,
            31248578,
            31249388,
            31249158,
            31251415,
            31251584,
            31250733,
            31288783,
            31250579,
            31245985,
            31253356,
            31247757,
            31248728,
            31247477,
            31250335,
            50573188,
            31250325,
            31251280
        ],
        "E": [
            31248134,
            31249919,
            31252439,
            31251022,
            31250865,
            31249737,
            31252775,
            31249136,
            31250580,
            31253627,
            31288769,
            31253029,
            31255710,
            31253949,
            31251510,
            31251487,
            31250360,
            31262356,
            31249482,
            31279947,
            31254652
        ],
        "D": [
            31245980,
            31247767,
            31247101,
            31246043,
            31246748,
            31245415,
            31247268,
            112870619,
            31246541,
            31245811,
            31246941,
            31288779,
            31248218,
            31249255,
            31247717,
            31246658,
            31251512,
            31244912,
            31245095,
            31246576,
            31246214,
            31247900
        ],
        "C": [
            31244661,
            31246346,
            31244654,
            31244959,
            31244457,
            31244670,
            31245105,
            31244159,
            31244863,
            31245509,
            31247509,
            31245175,
            31252048,
            31251951,
            31245641,
            31244103,
            31244492,
            31244705,
            31245349
        ],
        "B": [
            31243795,
            31244797,
            31243640,
            31244221,
            31243588,
            31243630,
            251388248,
            206107056,
            102945786,
            102945751,
            31243439,
            31243368,
            31243788,
            31244097,
            31246401,
            31243794,
            31252944,
            31252443,
            31243336,
            31243339,
            31243565,
            31243646,
            31244189
        ],
        "A": [
            31242945,
            31244304,
            31243017,
            31243228,
            31242934,
            31243184,
            31242993,
            31242977,
            31243012,
            31243412,
            31244065,
            31243098,
            31243193,
            31252560,
            31242943,
            31242939,
            31243039,
            31243390
        ]
    },
    "name": "D. Merge Sort",
    "statement": "Merge sort is a well-known sorting algorithm. The main function that\r\nsorts the elements of array with indices from can be implemented as\r\nfollows: If the segment is already sorted in non-descending order (that\r\nis, for any such that ), then end the function call; Let ; Call ; Call ;\r\nMerge segments and , making the segment sorted in non-descending order.\r\nThe merge algorithm doesn\u2019t call any other functions. The array in this\r\nproblem is -indexed, so to sort the whole array, you need to call .The\r\nnumber of calls of function is very important, so Ivan has decided to\r\ncalculate it while sorting the array. For example, if , then there will\r\nbe call of , which will check that the array is sorted and then end. If\r\n, then the number of calls is : first of all, you call , which then sets\r\nand calls and , which do not perform any recursive calls because\r\nsegments and are sorted.Ivan has implemented the program that counts the\r\nnumber of calls, but now he needs to test it. To do this, he needs to\r\nfind an array such that is a permutation of size (that is, the number of\r\nelements in is , and every integer number from can be found in this\r\narray), and the number of calls when sorting the array is exactly .Help\r\nIvan to find an array he wants!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nconst int nmax = 100500;\n\nint dp[nmax];\n\nvector<int> ans;\nbool ok = true;\n\nvoid solve(int lf, int rg, int k, int a, int b) {\n\tif (k == 1) {\n\t\tfor (int i = lf; i <= rg; ++i) {\n\t\t\tans[i] = a + (i - lf);\n\t\t}\n\t\treturn;\n\t}\n\tif (k <= 2) {\n\t\tok = false;\n\t\treturn;\n\t}\n\tint l = lf, r = rg + 1;\n\tint m = (l + r) >> 1;\n\t--k;\n\tif (dp[m - l] + 1 >= k) {\n\t\tsolve(lf, m - 1, k - 1, a + rg - m + 1, b);\n\t\tfor (int i = m; i <= rg; ++i) {\n\t\t\tans[i] = a + (i - m);\n\t\t}\n\t} else {\n\t\tk -= dp[m - l];\n\t\tsolve(lf, m - 1, dp[m - l], a + rg - m + 1, b);\n\t\tsolve(m, rg, k, a, a + rg - m);\n\t}\n}\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(\"input.txt\");\n\t//ofstream cout(\"output.txt\");\n\n\tdp[1] = 1;\n\tfor (int n = 2; n < nmax; ++n) {\n\t\tint l = 0, r = n;\n\t\tint m = (l + r) >> 1;\n\t\tdp[n] = 1 + dp[m - l] + dp[r - m];\n\t}\n\n\tint n, k;\n\tcin >> n >> k;\n\tif (dp[n] < k) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tans.resize(n);\n\tsolve(0, n - 1, k, 1, n);\n\n\tif (!ok) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << \"\\n\";\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "divide and conquer"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Merge Sort.json",
    "editorial_link": "https://codeforces.com//blog/entry/55171",
    "editorial": "First of all, if is even, then there is no solution, since the number of\r\ncalls is always odd (one call in the beginning, and each call makes\r\neither or recursive calls).Then, if is odd, let\u00e2\u0080\u0099s try to start with a\r\nsorted permutation and try to \"unsort\" it. Let\u00e2\u0080\u0099s make a function that\r\nwill do it. When we \"unsort\" a segment, we can either keep it sorted (if\r\nwe already made enough calls), or make it non-sorted and then call and ,\r\nif we need more calls. When we make a segment non-sorted, it\u00e2\u0080\u0099s better to\r\nkeep its both halves sorted; an easy way to handle this is to swap two\r\nmiddle element.It\u00e2\u0080\u0099s easy to see that the number of calls is equal to the\r\nnumber of calls to sort the resulting permutation, so we can use this\r\napproach to try getting exactly calls.\r\n"
}