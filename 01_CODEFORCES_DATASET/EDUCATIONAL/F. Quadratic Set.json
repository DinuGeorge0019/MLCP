{"link": "https://codeforces.com//contest/1622/problem/F", "problemId": "1242582", "problem_idx": "F", "shortId": "1622F", "contest_number": "1622", "problem_submissions": {"F": [140796824, 140798013, 140806008, 140808778, 140806009, 140805051, 140814076, 140828348, 140819179, 140855589, 140855586, 140839728, 140839370, 140821060, 140807144, 140812999, 140804188, 140824231, 140824165, 140822940, 140804052, 140823222, 140819745, 140824560, 140857950, 140834838, 140832376, 140829343, 140828751, 140828269, 140827798], "E": [140765216, 140779319, 140785115, 140782340, 140780692, 140780184, 140838345, 140780973, 140780107, 140783378, 140789562, 140786801, 140785714, 140786518, 140775048, 140770202, 140781928, 140783559, 140781100, 140785123, 140785377, 140784613], "D": [140761526, 140770308, 140773276, 140775500, 140776032, 140771575, 140837879, 140773697, 140780198, 140777190, 140779965, 140773920, 140787545, 140769780, 140775729, 140849022, 140772131, 140772048, 140774887, 140775893, 140779501, 140776197], "C": [140756712, 140763210, 140766719, 140766708, 140766349, 140764400, 140762686, 140760355, 140768706, 140766328, 140766600, 140768126, 140759456, 140764367, 140761869, 140765074, 140766561, 140767346, 140764755, 140763284, 140767658], "B": [140752335, 140756349, 140756665, 140761975, 140757886, 140760857, 140757453, 140753171, 140760768, 140761439, 140759017, 140757918, 140754004, 140754798, 140756955, 140757416, 140757531, 140759831, 140758370, 140759772], "A": [140751413, 140751825, 140751782, 140754411, 140752339, 140751676, 140751944, 140751415, 140752483, 140751783, 140754865, 140752090, 140751540, 140751564, 140751671, 140751951, 140752002, 140751977, 140751451, 140754316]}, "name": "F. Quadratic Set", "statement": "Let\u2019s call a set of positive integers a_1, a_2,\r\ndots, a_k if the product of the factorials of its elements is a square\r\nof an integer, i. e.\r\nprod\r\nlimits_{i=1}^{k} a_i! = m^2, for some integer m.You are given a positive\r\ninteger n.Your task is to find a subset of a set 1, 2,\r\ndots, n of maximum size. If there are multiple answers, print any of\r\nthem.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 27.12.2021 18:29:33       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  auto Print = [&](vector<int> rem) {\n    vector<bool> use(n + 1, true);\n    for (int x : rem) {\n      assert(1 <= x && x <= n && use[x]);\n      use[x] = false;\n    }\n    vector<int> res;\n    for (int i = 1; i <= n; i++) {\n      if (use[i]) {\n        res.push_back(i);\n      }\n    }\n    cout << res.size() << '\\n';\n    for (int i = 0; i < (int) res.size(); i++) {\n      if (i > 0) {\n        cout << \" \";\n      }\n      cout << res[i];\n    }\n    cout << '\\n';\n  };\n  vector<int> p(n + 1);\n  iota(p.begin(), p.end(), 0);\n  for (int i = 2; i <= n; i++) {\n    if (p[i] == i) {\n      for (int j = i + i; j <= n; j += i) {\n        if (p[j] == j) {\n          p[j] = i;\n        }\n      }\n    }\n  }\n  mt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n  vector<unsigned long long> c(n + 1);\n  for (int i = 2; i <= n; i++) {\n    if (p[i] == i) {\n      c[i] = rng();\n    }\n  }\n  vector<unsigned long long> num(n + 1);\n  num[1] = 0;\n  for (int i = 2; i <= n; i++) {\n    num[i] = num[i / p[i]] ^ c[p[i]];\n  }\n  vector<unsigned long long> f(n + 1);\n  f[1] = 0;\n  for (int i = 2; i <= n; i++) {\n    f[i] = f[i - 1] ^ num[i];\n  }\n  unsigned long long all = 0;\n  for (int i = 1; i <= n; i++) {\n    all ^= f[i];\n  }\n  if (all == 0) {\n    Print({});\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (all == f[i]) {\n      Print({i});\n      return 0;\n    }\n  }\n  vector<pair<unsigned long long, int>> ps(n);\n  for (int i = 1; i <= n; i++) {\n    ps[i - 1] = make_pair(f[i], i);\n  }\n  sort(ps.begin(), ps.end());\n  for (int i = 1; i <= n; i++) {\n    auto need = all ^ f[i];\n    auto it = lower_bound(ps.begin(), ps.end(), make_pair(need, -1));\n    if (it != ps.end() && it->first == need) {\n      Print({i, it->second});\n      return 0;\n    }\n  }\n  assert(n % 2 == 1);\n  all ^= f[n];\n  for (int i = 1; i <= n - 1; i++) {\n    auto need = all ^ f[i];\n    auto it = lower_bound(ps.begin(), ps.end(), make_pair(need, -1));\n    if (it != ps.end() && it->first == need && it->second < n) {\n      Print({i, it->second, n});\n      return 0;\n    }\n  }\n  assert(false);\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["constructive algorithms", "hashing", "math", "number theory"], "dificulty": "2900", "interactive": false}