{
    "link": "https://codeforces.com//contest/1622/problem/F",
    "problemId": "1242582",
    "problem_idx": "F",
    "shortId": "1622F",
    "contest_number": "1622",
    "problem_submissions": {
        "F": [
            140796824,
            140798013,
            140806008,
            140808778,
            140806009,
            140805051,
            140814076,
            140828348,
            140819179,
            140855589,
            140855586,
            140839728,
            140839370,
            140821060,
            140807144,
            140812999,
            140804188,
            140824231,
            140824165,
            140822940,
            140804052,
            140823222,
            140819745,
            140824560,
            140857950,
            140834838,
            140832376,
            140829343,
            140828751,
            140828269,
            140827798
        ],
        "E": [
            140765216,
            140779319,
            140785115,
            140782340,
            140780692,
            140780184,
            140838345,
            140780973,
            140780107,
            140783378,
            140789562,
            140786801,
            140785714,
            140786518,
            140775048,
            140770202,
            140781928,
            140783559,
            140781100,
            140785123,
            140785377,
            140784613
        ],
        "D": [
            140761526,
            140770308,
            140773276,
            140775500,
            140776032,
            140771575,
            140837879,
            140773697,
            140780198,
            140777190,
            140779965,
            140773920,
            140787545,
            140769780,
            140775729,
            140849022,
            140772131,
            140772048,
            140774887,
            140775893,
            140779501,
            140776197
        ],
        "C": [
            140756712,
            140763210,
            140766719,
            140766708,
            140766349,
            140764400,
            140762686,
            140760355,
            140768706,
            140766328,
            140766600,
            140768126,
            140759456,
            140764367,
            140761869,
            140765074,
            140766561,
            140767346,
            140764755,
            140763284,
            140767658
        ],
        "B": [
            140752335,
            140756349,
            140756665,
            140761975,
            140757886,
            140760857,
            140757453,
            140753171,
            140760768,
            140761439,
            140759017,
            140757918,
            140754004,
            140754798,
            140756955,
            140757416,
            140757531,
            140759831,
            140758370,
            140759772
        ],
        "A": [
            140751413,
            140751825,
            140751782,
            140754411,
            140752339,
            140751676,
            140751944,
            140751415,
            140752483,
            140751783,
            140754865,
            140752090,
            140751540,
            140751564,
            140751671,
            140751951,
            140752002,
            140751977,
            140751451,
            140754316
        ]
    },
    "name": "F. Quadratic Set",
    "statement": "Let\u2019s call a set of positive integers a_1, a_2,\r\ndots, a_k if the product of the factorials of its elements is a square\r\nof an integer, i. e.\r\nprod\r\nlimits_{i=1}^{k} a_i! = m^2, for some integer m.You are given a positive\r\ninteger n.Your task is to find a subset of a set 1, 2,\r\ndots, n of maximum size. If there are multiple answers, print any of\r\nthem.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 27.12.2021 18:29:33       \n**/\n#undef _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  auto Print = [&](vector<int> rem) {\n    vector<bool> use(n + 1, true);\n    for (int x : rem) {\n      assert(1 <= x && x <= n && use[x]);\n      use[x] = false;\n    }\n    vector<int> res;\n    for (int i = 1; i <= n; i++) {\n      if (use[i]) {\n        res.push_back(i);\n      }\n    }\n    cout << res.size() << '\\n';\n    for (int i = 0; i < (int) res.size(); i++) {\n      if (i > 0) {\n        cout << \" \";\n      }\n      cout << res[i];\n    }\n    cout << '\\n';\n  };\n  vector<int> p(n + 1);\n  iota(p.begin(), p.end(), 0);\n  for (int i = 2; i <= n; i++) {\n    if (p[i] == i) {\n      for (int j = i + i; j <= n; j += i) {\n        if (p[j] == j) {\n          p[j] = i;\n        }\n      }\n    }\n  }\n  mt19937_64 rng((unsigned int) chrono::steady_clock::now().time_since_epoch().count());\n  vector<unsigned long long> c(n + 1);\n  for (int i = 2; i <= n; i++) {\n    if (p[i] == i) {\n      c[i] = rng();\n    }\n  }\n  vector<unsigned long long> num(n + 1);\n  num[1] = 0;\n  for (int i = 2; i <= n; i++) {\n    num[i] = num[i / p[i]] ^ c[p[i]];\n  }\n  vector<unsigned long long> f(n + 1);\n  f[1] = 0;\n  for (int i = 2; i <= n; i++) {\n    f[i] = f[i - 1] ^ num[i];\n  }\n  unsigned long long all = 0;\n  for (int i = 1; i <= n; i++) {\n    all ^= f[i];\n  }\n  if (all == 0) {\n    Print({});\n    return 0;\n  }\n  for (int i = 1; i <= n; i++) {\n    if (all == f[i]) {\n      Print({i});\n      return 0;\n    }\n  }\n  vector<pair<unsigned long long, int>> ps(n);\n  for (int i = 1; i <= n; i++) {\n    ps[i - 1] = make_pair(f[i], i);\n  }\n  sort(ps.begin(), ps.end());\n  for (int i = 1; i <= n; i++) {\n    auto need = all ^ f[i];\n    auto it = lower_bound(ps.begin(), ps.end(), make_pair(need, -1));\n    if (it != ps.end() && it->first == need) {\n      Print({i, it->second});\n      return 0;\n    }\n  }\n  assert(n % 2 == 1);\n  all ^= f[n];\n  for (int i = 1; i <= n - 1; i++) {\n    auto need = all ^ f[i];\n    auto it = lower_bound(ps.begin(), ps.end(), make_pair(need, -1));\n    if (it != ps.end() && it->first == need && it->second < n) {\n      Print({i, it->second, n});\n      return 0;\n    }\n  }\n  assert(false);\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "hashing",
        "math",
        "number theory"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Quadratic Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/98453",
    "editorial": "A good start to solve the problem would be to check the answers for\r\nsmall values of . One can see that the answers (the sizes of the maximum\r\nsubsets) are not much different from itself, or rather not less than .\r\nLet\u00e2\u0080\u0099s try to prove that this is true for all .Consider is even. Let ,\r\nlet\u00e2\u0080\u0099s see what the product is equal to if we take all the numbers from\r\nto .From here we can see that for even the answer is at least , because\r\nwe can delete and the product of the remaining factorials will be the\r\nsquare of an integer, for odd the answer is at least , because we can\r\ndelete and .It remains to prove that the answer is at least for odd .\r\nThis is easy to do, because the answer for is not less than the answer\r\nfor minus , because we can delete and solve the task with a smaller\r\nvalue. Moreover, it can be seen from the previous arguments that the\r\nanswer can only be for , and we already know that in this case one of\r\nthe correct answers is to remove the factorials .It remains to learn how\r\nto check whether it is possible to remove or numbers so that the\r\nremaining product of factorials is the square of an integer.To do this,\r\nwe can use XOR hashes. Let\u00e2\u0080\u0099s assign each prime number a random -bit\r\nnumber. For composite numbers, the hash is equal to the XOR of hashes of\r\nall its prime divisors from factorization. Thus, if some prime is\r\nincluded in the number an even number of times, it will not affect the\r\nvalue of the hash, which is what we need. The hash of the product of two\r\nnumbers is equal to the XOR of the hashes of these numbers. Let\u00e2\u0080\u0099s denote\r\nthe hash function as .Using the above, let\u00e2\u0080\u0099s calculate for all from to ,\r\nas well as for all from to , this is easy to do, because . We will also\r\nstore a map . Let\u00e2\u0080\u0099s calculate the hash and denote it as . It remains to\r\nconsider the following cases: if , then the current product is already\r\nthe square of an integer; for an answer of size , we have to check that\r\nthere exists such a that . To find such , let\u00e2\u0080\u0099s check whether the map\r\ncontains ; for an answer of size , we have to check that there are such\r\nand that . To do this, iterate over , and then check whether map\r\ncontains ; otherwise, the answer is , and there is an answer, where all\r\nnumbers except are taken.\r\n"
}