{"link": "https://codeforces.com//contest/1175/problem/G", "problemId": "354219", "problem_idx": "G", "shortId": "1175G", "contest_number": "1175", "problem_submissions": {"E": [55152697, 55143297, 55144842, 55149453, 55145090, 55152529, 55156277, 55145238, 55141766, 55151809, 55150612, 55150119, 55150752, 55156812, 55152738, 55154944, 55150125, 55154652, 55158266, 55163765], "F": [55143004, 55151795, 55152215, 55142312, 55154601, 55143715, 55151506, 55166103, 55151247, 55162817, 55160160, 55154302, 55159983, 55153216, 55161466, 55160616, 55159270, 55167756, 76726554, 55159045], "D": [55137941, 55140293, 55140750, 55145972, 55139564, 55144646, 55138002, 55141894, 55136780, 55138695, 55141164, 55144507, 55139116, 55139569, 55142712, 55138367, 55143330, 55142605, 55147375, 55147140], "C": [55134609, 55137594, 55139019, 55137598, 55135791, 55137314, 55136601, 55136692, 55135046, 55136312, 55137446, 55142893, 55137610, 55138266, 55140998, 55137003, 55146366, 55138295, 55140586, 55141407], "B": [55132016, 55133684, 55136306, 55134307, 55133707, 55134207, 55135033, 55133685, 55171853, 55133665, 55137967, 55138315, 55133858, 55138192, 55135842, 55133934, 55137057, 55134510, 55135402, 55137596], "A": [55129715, 55129741, 55129684, 55129658, 55129917, 55129679, 55130628, 55129791, 55130186, 55130042, 55129731, 55135937, 55130056, 55130398, 55129926, 55129655, 55132057, 55130203, 55131132, 55132516], "G": [55169838, 55219359, 58237199, 55161904, 55163020]}, "name": "G. Yet Another Partiton Problem", "statement": "You are given array a_1, a_2,\r\ndots, a_n. You need to split it into k subsegments (so every element is\r\nincluded in exactly one subsegment).The weight of a subsegment a_l,\r\na_{l+1},\r\ndots, a_r is equal to (r - l + 1)\r\ncdot\r\nmax\r\nlimits_{l\r\nle i\r\nle r}(a_i). The weight of a partition is a total weight of all its\r\nsegments.Find the partition of minimal weight.\r\n", "solutions": ["#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n, k;\nconst int maxN = 2 * (int)1e4 + 100;\nvector < pair < ll, ll > > cht[4 * maxN];\nstruct pt{\n    ll x, y;\n    pt(ll _x, ll _y) {\n        x = _x;\n        y = _y;\n    }\n    pt() {}\n};\nvector < pt > all[4 * maxN];\nbool del(const pt& x, const pt& y, const pt& z) {\n    return (y.y - x.y) * (x.x - z.x) <= (z.y - x.y) * (x.x - y.x);\n}\nvoid add(ll x, ll y, vector < pt >& vec) {\n    pt nw(x, y);\n    while (vec.size() >= 2 && del(vec[vec.size() - 1], vec[vec.size() - 2], nw)) {\n        vec.pop_back();\n    }\n    vec.push_back(nw);\n}\nll get(const pt& a, ll y) {\n    return (a.x * y + a.y);\n}\nconst ll INF = 2 * (ll)1e18;\nll get(ll x, vector < pt >& vec) {\n    if (vec.empty()) return -INF;\n    int l = 0;\n    int r = vec.size() - 1;\n    while (r - l > 1) {\n        int m = (l + r) / 2;\n        if (get(vec[m], x) > get(vec[m + 1], x)) {\n            r = m;\n        }\n        else l = m;\n    }\n    return max(get(vec[r], x), get(vec[l], x));\n}\nvoid add(int v, int tl, int tr, int l, int r, pair < ll, ll >& who) {\n    if (tl == l &&  tr == r) {\n        cht[v].push_back(who);\n        return;\n    }\n    int tm = (tl + tr) / 2;\n    if (r <= tm) {\n        add(v + v, tl, tm, l, r, who);\n    }\n    else if (l > tm) {\n        add(v + v + 1, tm + 1, tr, l, r, who);\n    }\n    else {\n        add(v + v, tl, tm, l, tm, who);\n        add(v + v + 1, tm + 1, tr, tm + 1, r, who);\n    }\n}\nvoid ch() {\n    for (int i = 1; i <= 4 * n; i++) {\n        cht[i].clear();\n        all[i].clear();\n    }\n}\nvoid build(int v, int tl, int tr) {\n    sort(cht[v].begin(), cht[v].end());\n    reverse(cht[v].begin(), cht[v].end());\n    for (auto t : cht[v]) {\n        add(-t.first, -t.second, all[v]);\n    }\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        build(v + v, tl, tm);\n        build(v + v + 1, tm + 1, tr);\n    }\n}\nll get(int v, int tl, int tr, int pos, ll val) {\n    ll f1 = -get(val, all[v]);\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm) f1 = min(f1, get(v + v, tl, tm, pos, val));\n        else f1 = min(f1, get(v + v + 1, tm + 1, tr, pos, val));\n    }\n    return f1;\n}\n\n\nll dp[maxN];\nint a[maxN];\nint nxt[maxN];\nll coefs[maxN];\n\nvector < pt > lines[4 * maxN];\npair < ll, ll > ss[4 * maxN];\nvoid build2(int v, int tl, int tr) {\n    vector < pair < ll, ll > > all;\n    for (int i = tl; i <= tr; i++) {\n        all.push_back(ss[i]);\n    }\n    sort(all.begin(), all.end());\n    reverse(all.begin(), all.end());\n    for (auto it : all) {\n        add(-it.first, -it.second, lines[v]);\n    }\n    int tm = (tl + tr) / 2;\n    if (tl != tr) {\n        build2(v + v, tl, tm);\n        build2(v + v + 1, tm + 1, tr);\n    }\n}\nll get_val(int v, int tl, int tr, int l, int r, ll val) {\n    if (tl == l && tr == r) {\n        return -get(val, lines[v]);\n    }\n    int tm = (tl + tr) / 2;\n    if (r <= tm) return get_val(v + v, tl, tm, l, r, val);\n    else if (l > tm) return get_val(v + v + 1, tm + 1, tr, l, r, val);\n    else {\n        return min(get_val(v + v, tl, tm, l, tm, val), get_val(v + v + 1, tm + 1, tr, tm + 1, r, val));\n    }\n}\nint en[maxN];\nvoid solve() {\n    vector < pair < int, int > > st;\n    st.push_back(make_pair(1e9, 0));\n    for (int i = 1; i <= 4 * n; i++) lines[i].clear();\n    for (int i = 1; i <= n; i++) {\n        ss[i] = make_pair(-(i - 1), dp[i - 1]);\n    }\n    build2(1, 1, n);\n    for (int i = 1; i <= n; i++) {\n        while (make_pair(a[i], i) > st.back()) {\n            st.pop_back();\n        }\n        nxt[i] = st.back().second;\n        st.push_back(make_pair(a[i], i));\n    }\n    for (int i = 1; i <= n; i++) {\n        coefs[i] = get_val(1, 1, n, nxt[i] + 1, i, a[i]);\n    }\n    ch();\n    st.clear();\n    st.push_back(make_pair(1e9, 0));\n    //cout << \" Here\" << endl;\n    for (int i = 1; i <= n; i++) {\n        while (make_pair(a[i], i) > st.back()) {\n            en[st.back().second] = i - 1;\n            st  .pop_back();\n        }\n        st.push_back(make_pair(a[i], i));\n    }\n    while (!st.empty()) {\n        en[st.back().second] = n;\n        st.pop_back();\n    }\n    //cout << \" Here\" << endl;\n    for (int i = 1; i <= n; i++) {\n        pair < ll, ll > tt = make_pair(a[i], coefs[i]);\n        add(1, 1, n, i, en[i], tt);\n    }\n    build(1, 1, n);\n    dp[0] = 1e9;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = get(1, 1, n, i, i);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = (ll)1e9;\n    }\n    for (int i = 0; i < k; i++) {\n        solve();\n    }\n    cout << dp[n];\n    return 0;\n}"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "dp", "geometry", "two pointers"], "dificulty": "3000", "interactive": false}