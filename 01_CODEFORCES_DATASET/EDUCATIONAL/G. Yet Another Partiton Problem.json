{
    "link": "https://codeforces.com//contest/1175/problem/G",
    "problemId": "354219",
    "problem_idx": "G",
    "shortId": "1175G",
    "contest_number": "1175",
    "problem_submissions": {
        "E": [
            55152697,
            55143297,
            55144842,
            55149453,
            55145090,
            55152529,
            55156277,
            55145238,
            55141766,
            55151809,
            55150612,
            55150119,
            55150752,
            55156812,
            55152738,
            55154944,
            55150125,
            55154652,
            55158266,
            55163765
        ],
        "F": [
            55143004,
            55151795,
            55152215,
            55142312,
            55154601,
            55143715,
            55151506,
            55166103,
            55151247,
            55162817,
            55160160,
            55154302,
            55159983,
            55153216,
            55161466,
            55160616,
            55159270,
            55167756,
            76726554,
            55159045
        ],
        "D": [
            55137941,
            55140293,
            55140750,
            55145972,
            55139564,
            55144646,
            55138002,
            55141894,
            55136780,
            55138695,
            55141164,
            55144507,
            55139116,
            55139569,
            55142712,
            55138367,
            55143330,
            55142605,
            55147375,
            55147140
        ],
        "C": [
            55134609,
            55137594,
            55139019,
            55137598,
            55135791,
            55137314,
            55136601,
            55136692,
            55135046,
            55136312,
            55137446,
            55142893,
            55137610,
            55138266,
            55140998,
            55137003,
            55146366,
            55138295,
            55140586,
            55141407
        ],
        "B": [
            55132016,
            55133684,
            55136306,
            55134307,
            55133707,
            55134207,
            55135033,
            55133685,
            55171853,
            55133665,
            55137967,
            55138315,
            55133858,
            55138192,
            55135842,
            55133934,
            55137057,
            55134510,
            55135402,
            55137596
        ],
        "A": [
            55129715,
            55129741,
            55129684,
            55129658,
            55129917,
            55129679,
            55130628,
            55129791,
            55130186,
            55130042,
            55129731,
            55135937,
            55130056,
            55130398,
            55129926,
            55129655,
            55132057,
            55130203,
            55131132,
            55132516
        ],
        "G": [
            55169838,
            55219359,
            58237199,
            55161904,
            55163020
        ]
    },
    "name": "G. Yet Another Partiton Problem",
    "statement": "You are given array a_1, a_2,\r\ndots, a_n. You need to split it into k subsegments (so every element is\r\nincluded in exactly one subsegment).The weight of a subsegment a_l,\r\na_{l+1},\r\ndots, a_r is equal to (r - l + 1)\r\ncdot\r\nmax\r\nlimits_{l\r\nle i\r\nle r}(a_i). The weight of a partition is a total weight of all its\r\nsegments.Find the partition of minimal weight.\r\n",
    "solutions": [
        "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n, k;\nconst int maxN = 2 * (int)1e4 + 100;\nvector < pair < ll, ll > > cht[4 * maxN];\nstruct pt{\n    ll x, y;\n    pt(ll _x, ll _y) {\n        x = _x;\n        y = _y;\n    }\n    pt() {}\n};\nvector < pt > all[4 * maxN];\nbool del(const pt& x, const pt& y, const pt& z) {\n    return (y.y - x.y) * (x.x - z.x) <= (z.y - x.y) * (x.x - y.x);\n}\nvoid add(ll x, ll y, vector < pt >& vec) {\n    pt nw(x, y);\n    while (vec.size() >= 2 && del(vec[vec.size() - 1], vec[vec.size() - 2], nw)) {\n        vec.pop_back();\n    }\n    vec.push_back(nw);\n}\nll get(const pt& a, ll y) {\n    return (a.x * y + a.y);\n}\nconst ll INF = 2 * (ll)1e18;\nll get(ll x, vector < pt >& vec) {\n    if (vec.empty()) return -INF;\n    int l = 0;\n    int r = vec.size() - 1;\n    while (r - l > 1) {\n        int m = (l + r) / 2;\n        if (get(vec[m], x) > get(vec[m + 1], x)) {\n            r = m;\n        }\n        else l = m;\n    }\n    return max(get(vec[r], x), get(vec[l], x));\n}\nvoid add(int v, int tl, int tr, int l, int r, pair < ll, ll >& who) {\n    if (tl == l &&  tr == r) {\n        cht[v].push_back(who);\n        return;\n    }\n    int tm = (tl + tr) / 2;\n    if (r <= tm) {\n        add(v + v, tl, tm, l, r, who);\n    }\n    else if (l > tm) {\n        add(v + v + 1, tm + 1, tr, l, r, who);\n    }\n    else {\n        add(v + v, tl, tm, l, tm, who);\n        add(v + v + 1, tm + 1, tr, tm + 1, r, who);\n    }\n}\nvoid ch() {\n    for (int i = 1; i <= 4 * n; i++) {\n        cht[i].clear();\n        all[i].clear();\n    }\n}\nvoid build(int v, int tl, int tr) {\n    sort(cht[v].begin(), cht[v].end());\n    reverse(cht[v].begin(), cht[v].end());\n    for (auto t : cht[v]) {\n        add(-t.first, -t.second, all[v]);\n    }\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        build(v + v, tl, tm);\n        build(v + v + 1, tm + 1, tr);\n    }\n}\nll get(int v, int tl, int tr, int pos, ll val) {\n    ll f1 = -get(val, all[v]);\n    if (tl != tr) {\n        int tm = (tl + tr) / 2;\n        if (pos <= tm) f1 = min(f1, get(v + v, tl, tm, pos, val));\n        else f1 = min(f1, get(v + v + 1, tm + 1, tr, pos, val));\n    }\n    return f1;\n}\n\n\nll dp[maxN];\nint a[maxN];\nint nxt[maxN];\nll coefs[maxN];\n\nvector < pt > lines[4 * maxN];\npair < ll, ll > ss[4 * maxN];\nvoid build2(int v, int tl, int tr) {\n    vector < pair < ll, ll > > all;\n    for (int i = tl; i <= tr; i++) {\n        all.push_back(ss[i]);\n    }\n    sort(all.begin(), all.end());\n    reverse(all.begin(), all.end());\n    for (auto it : all) {\n        add(-it.first, -it.second, lines[v]);\n    }\n    int tm = (tl + tr) / 2;\n    if (tl != tr) {\n        build2(v + v, tl, tm);\n        build2(v + v + 1, tm + 1, tr);\n    }\n}\nll get_val(int v, int tl, int tr, int l, int r, ll val) {\n    if (tl == l && tr == r) {\n        return -get(val, lines[v]);\n    }\n    int tm = (tl + tr) / 2;\n    if (r <= tm) return get_val(v + v, tl, tm, l, r, val);\n    else if (l > tm) return get_val(v + v + 1, tm + 1, tr, l, r, val);\n    else {\n        return min(get_val(v + v, tl, tm, l, tm, val), get_val(v + v + 1, tm + 1, tr, tm + 1, r, val));\n    }\n}\nint en[maxN];\nvoid solve() {\n    vector < pair < int, int > > st;\n    st.push_back(make_pair(1e9, 0));\n    for (int i = 1; i <= 4 * n; i++) lines[i].clear();\n    for (int i = 1; i <= n; i++) {\n        ss[i] = make_pair(-(i - 1), dp[i - 1]);\n    }\n    build2(1, 1, n);\n    for (int i = 1; i <= n; i++) {\n        while (make_pair(a[i], i) > st.back()) {\n            st.pop_back();\n        }\n        nxt[i] = st.back().second;\n        st.push_back(make_pair(a[i], i));\n    }\n    for (int i = 1; i <= n; i++) {\n        coefs[i] = get_val(1, 1, n, nxt[i] + 1, i, a[i]);\n    }\n    ch();\n    st.clear();\n    st.push_back(make_pair(1e9, 0));\n    //cout << \" Here\" << endl;\n    for (int i = 1; i <= n; i++) {\n        while (make_pair(a[i], i) > st.back()) {\n            en[st.back().second] = i - 1;\n            st  .pop_back();\n        }\n        st.push_back(make_pair(a[i], i));\n    }\n    while (!st.empty()) {\n        en[st.back().second] = n;\n        st.pop_back();\n    }\n    //cout << \" Here\" << endl;\n    for (int i = 1; i <= n; i++) {\n        pair < ll, ll > tt = make_pair(a[i], coefs[i]);\n        add(1, 1, n, i, en[i], tt);\n    }\n    build(1, 1, n);\n    dp[0] = 1e9;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = get(1, 1, n, i, i);\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> k;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    dp[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = (ll)1e9;\n    }\n    for (int i = 0; i < k; i++) {\n        solve();\n    }\n    cout << dp[n];\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dp",
        "geometry",
        "two pointers"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Yet Another Partiton Problem.json",
    "editorial_link": "https://codeforces.com/blog/entry/67484",
    "editorial": "Important note: the author solution is using both linear Convex hull\r\ntrick and persistent Li Chao tree. As mentioned in commentaries,\r\napplying the Divide-and-Conquer technique can help get rid of Li Chao\r\ntree. More about both structures you can read in this article.Let\u00e2\u0080\u0099s try\r\nto write standard dp we can come up with (arrays will be 0-indexed). Let\r\nbe the minimal weight if we splitted prefix of length in subsegments.\r\nThen we can calculate it as: [1]. Maximums on segments are inconvenient,\r\nlet\u00e2\u0080\u0099s try to group segments by the value of . So, we can find such\r\nsequence of borders , where for each . In other words, and is the\r\nclosest from the left position, where . Note, that we can maintain this\r\nsequence with stack of maximums.Ok, then for each interval equation [1]\r\ntransforms to: Why did we use variables and ? Because there are two\r\nproblems: is needed because we iterate over and can\u00e2\u0080\u0099t recalculate\r\neverything; is needed because sequence is changing over time, so do the\r\n. But what we can already see: we can maintain for each segment Convex\r\nhull with linear functions so we can take in logarithmic time. Moreover,\r\nwe can store values in other Convex hull to take minimum over all\r\nsegments in logarithmic time.The problems arise when we try modificate\r\nstructures while iterating . Fortunately, segments change not at random,\r\nbut according to stack of maximums. So all we should handle are: to\r\nmerge segment on top of the stack with current segment (in case when );\r\nto erase segment on top of the stack along with its value ; to insert\r\nnew segment on top of the stack along with its value . To handle the\r\nthird type is easy, since all Convex hulls can insert elements. There\r\nwill be at most such operations on a single layer and we can ask value\r\nin and insert a line with .To handle the second type is harder, but\r\npossible, since we can make Convex hull persistent and store its\r\nversions in the stack. Persistent Convex hull persistent Li Chao tree.\r\nThere will be also operations in total and they cost us .To handle the\r\nfirst type is trickiest part. Note, that all line coefficients of one\r\nconvex hull are strictly lower than all line coefficients of the other.\r\nSo, we can use linear Convex hulls to make insertions to back in\r\namortized . But to merge efficiently, we should use Small-to-Large\r\ntechnique, that\u00e2\u0080\u0099s why we should be able also push front in , and,\r\nmoreover, still be able to ask minimum in . And here comes the hack in\r\nC++, which can push/pop front/back in amortized and also have random\r\naccess iterator to make binary search possible. So, each element of\r\nevery segment will be transfered times with cost of amortized on a\r\nsingle layer .In the end, result complexity is . Space complexity is .\r\n"
}