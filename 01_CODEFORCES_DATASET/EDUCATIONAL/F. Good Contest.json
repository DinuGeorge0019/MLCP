{
    "link": "https://codeforces.com//contest/1295/problem/F",
    "problemId": "526705",
    "problem_idx": "F",
    "shortId": "1295F",
    "contest_number": "1295",
    "problem_submissions": {
        "F": [
            69765027,
            69766931,
            69774700,
            69768602,
            69856768,
            69855408,
            69855407,
            69855207,
            69795000,
            69794801,
            69794791,
            69780998,
            70134503,
            69764574,
            69774965,
            69768972,
            69767605,
            69764218,
            69774776,
            69773934,
            69777915,
            69775661,
            69780279,
            69776002,
            69772429,
            69771368,
            69777730,
            69779043
        ],
        "E": [
            69754267,
            69756231,
            69750419,
            69758264,
            75026655,
            75026651,
            75026616,
            75026614,
            75026605,
            75026602,
            69861069,
            69860763,
            69796506,
            69751804,
            70134450,
            69755652,
            69754935,
            69757172,
            69759455,
            69762033,
            69761392,
            69761807,
            69764886,
            69763394,
            69762971,
            69754925,
            69778394,
            69762618,
            69760940
        ],
        "D": [
            69749184,
            69749435,
            69737870,
            69746208,
            69740901,
            70134431,
            69750756,
            69745336,
            69774454,
            69751512,
            69748972,
            69748437,
            69750220,
            69755333,
            69757518,
            69754451,
            69753242,
            69748833,
            69755501,
            69757780,
            69749229
        ],
        "C": [
            69746419,
            69745530,
            69752829,
            69744855,
            69859631,
            69859619,
            69742998,
            70134418,
            69749557,
            69743909,
            69747578,
            69746709,
            69752867,
            69746601,
            69749344,
            69748626,
            69749455,
            69751397,
            69746966,
            69748635,
            69750189,
            69746738
        ],
        "B": [
            69741160,
            69740703,
            69739974,
            69739609,
            69792992,
            69737452,
            70134357,
            69742495,
            69740938,
            69745005,
            69743434,
            69743024,
            69740858,
            69742897,
            69742450,
            69742512,
            69742639,
            69740406,
            69745732,
            69757660,
            69746475,
            69745760,
            69745145,
            69742911,
            69741321,
            69742736,
            69741570
        ],
        "A": [
            69736925,
            69736449,
            69735963,
            69735937,
            69793731,
            69735857,
            70134345,
            69737467,
            69736037,
            69735902,
            69737776,
            69735865,
            69736131,
            69736841,
            69736251,
            69735843,
            69740300,
            69744873,
            69735945,
            69738318,
            69752292
        ]
    },
    "name": "F. Good Contest",
    "statement": "An online contest will soon be held on ForceCoders, a large competitive\r\nprogramming platform. The authors have prepared n problems; and since\r\nthe platform is very popular, 998244351 coder from all over the world is\r\ngoing to solve them.For each problem, the authors estimated the number\r\nof people who would solve it: for the i-th problem, the number of\r\naccepted solutions will be between l_i and r_i, inclusive.The creator of\r\nForceCoders uses different criteria to determine if the contest is good\r\nor bad. One of these criteria is the number of inversions in the problem\r\norder. An inversion is a pair of problems (x, y) such that x is located\r\nearlier in the contest (x < y), but the number of accepted solutions for\r\ny is greater.Obviously, both the creator of ForceCoders and the authors\r\nof the contest want the contest to be good. Now they want to calculate\r\nthe probability that there will be inversions in the problem order,\r\nassuming that for each problem i, any number of accepted solutions for\r\nit (between l_i and r_i) is equally probable, and all these numbers are\r\nindependent.\r\n",
    "solutions": [
        "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 105;\nconst int MOD = 998244353;\n\nint qpow(int base, int e) {\n    int ret = 1;\n    for (; e; e >>= 1) {\n        if (e & 1) {\n            ret = (LL) ret * base % MOD;\n        }\n        base = (LL) base * base % MOD;\n    }\n    return ret;\n}\n\nvoid iadd(int &dp, const int &val) {\n    dp += val;\n    if (dp >= MOD) {\n        dp -= MOD;\n    }\n}\n\nvoid ladd(int &dp, const LL &val) {\n    dp = (dp + val) % MOD;\n}\n\nint inv[N];\n\nvoid prep_inv() {\n    inv[0] = 1;\n    for (unsigned i = 1; i < N; ++i) {\n        inv[i] = (LL) inv[i - 1] * qpow(i, MOD - 2) % MOD;\n    }\n}\n\nint comb(int l, int n) {\n    if (!n) return 1;\n    int ret = (LL) inv[n] * qpow(l, MOD - 1 - n) % MOD;\n    for (int i = 0; i < n; ++i) {\n        ret = (LL) ret * (l + i) % MOD;\n    }\n    return ret;\n}\n\nint n, l[N], r[N];\nint f[N][N][N];\n\nint main() {\n    prep_inv();\n    n = read();\n    vector<int> vc = {-1};\n    for (int i = 0; i < n; ++i) {\n        l[i] = read();\n        r[i] = read() + 1;\n        vc.emplace_back(l[i]);\n        vc.emplace_back(r[i]);\n    }\n    reverse(l, l + n);\n    reverse(r, r + n);\n    sort(vc.begin(), vc.end());\n    vc.erase(unique(vc.begin(), vc.end()), vc.end());\n    int segs = (int) vc.size() - 1;\n    f[0][0][0] = 1;\n    for (int i = 0; i < n; ++i) {\n        int sum = 0;\n        for (int id = 0; id < segs; ++id) {\n            int lb = vc[id], rb = vc[id + 1];\n            if (l[i] <= lb && rb <= r[i]) {\n                int prob = min(rb, r[i]) - max(lb, l[i]);\n                f[i + 1][id][1] = (LL) sum * prob % MOD;\n                for (int j = 1; j < n; ++j) {\n                    f[i + 1][id][j + 1] = (LL) f[i][id][j] * prob % MOD;\n                }\n            }\n            for (int j = 0; j < n; ++j) {\n                if (f[i][id][j]) {\n                    if (id) {\n                        ladd(sum, (LL) f[i][id][j] * comb(rb - lb, j));\n                    } else {\n                        ladd(sum, f[i][id][j]);\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i < segs; ++i) {\n        int len = vc[i + 1] - vc[i];\n        for (int j = 1; j <= n; ++j) {\n            ladd(ans, (LL) f[n][i][j] * comb(len, j));\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        ans = (LL) ans * qpow(r[i] - l[i], MOD - 2) % MOD;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "probabilities"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Good Contest.json",
    "editorial_link": "https://codeforces.com//blog/entry/73467",
    "editorial": "The naive solution is dynamic programming: let be the probability that\r\nthe first problems don\u00e2\u0080\u0099t have any inversions, and the -th one got\r\naccepted solutions. Let\u00e2\u0080\u0099s somehow speed it up. For convenience, I will\r\nmodify the variable denoting the maximum number of accepted solutions\r\nfor each problem: , ; and I will also reverse the problem order, so that\r\nwe don\u00e2\u0080\u0099t want the number of solutions to decrease from problem to\r\nproblem.We know that , if , and otherwise. Let\u00e2\u0080\u0099s divide the whole\r\nsegment between and into segments with the values of and and analyse the\r\nbehavior of values on each such segment.Let . If we consider the\r\nbehavior of on some segment we got, we can prove by induction that it is\r\na polynomial of degree not exceeding .All that is left is to carefully\r\ncalculate and maintain these polynomials on segments. The main thing we\r\nwill use to calculate the polynomials is interpolation. To transition\r\nfrom to , we will consider each segment separately, calculate the first\r\nseveral values of on each segment (we need to calculate the sum fast, if\r\nis a polynomial, this can also be done with interpolation), and then\r\ninterpolate it on the whole segment.This is actually slow (we have to\r\ninterpolate at least polynomials) and not easy to write. Let\u00e2\u0080\u0099s consider\r\na better solution.We will use combinatoric approach: instead of\r\ncalculating probabilities, we will count all the non-descending\r\nsequences such that , and divide it by the number of all sequences\r\nwithout the non-descending condition (that is just ).Let\u00e2\u0080\u0099s again divide\r\ninto segments using the points , , and enumerate these segments from\r\nleft to right. If there are two neighboring values and , they either\r\nbelong to the same segment, or the segment belongs to is to the right of\r\nthe segment belongs to.We could try to write the following dynamic\r\nprogramming solution: is the number of non-descending prefixes of the\r\nsequence such that there are elements in the prefix, and the last one\r\nbelongs to segment . It\u00e2\u0080\u0099s easy to model transitions from to where , but\r\nwe don\u00e2\u0080\u0099t know how to model the transition to .Let\u00e2\u0080\u0099s get rid of them\r\naltogether! We will introduce an additional constraint in our dynamic\r\nprogramming: is the number of prefixes of the sequence of length . The\r\ntransitions in this dynamic programming are different: we iterate on the\r\nnumber of elements belonging to the next segment and transition into (if\r\npossible). Calculating the number of ways to take elements from an\r\ninterval in sorted order can be reduced to calculating the number of\r\nways to compose as the sum of non-negative summands (order matters). We\r\nshould be able to calculate binomial coefficients with fairly large and\r\nnot so large , but that\u00e2\u0080\u0099s not really hard if we use the formula .\r\n"
}