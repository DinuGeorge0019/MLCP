{"link": "https://codeforces.com//contest/1036/problem/F", "problemId": "216422", "problem_idx": "F", "shortId": "1036F", "contest_number": "1036", "problem_submissions": {"G": [42635175, 42627436, 42635430, 42626359, 42737989, 42717556, 42717524, 42717521, 42651041, 42700940, 42700625, 54263107, 42638239, 42625046, 42815013], "B": [42631894, 42635568, 42631049, 42642897, 42640457, 42621960, 42628162, 42621741, 42621550, 42618797, 42623868, 42633347, 42620322, 42622448, 42641969, 42624721, 42635114, 42625827, 42628122, 42634984, 42644768], "F": [42629280, 42634265, 42627972, 42642001, 42641962, 42630707, 42634470, 42717490, 42631938, 42631850, 42631382, 42631058, 42629288, 42629020, 42633820, 42633355, 42631044, 42636476, 42635060, 42629290, 42636959, 42643700, 42637023, 42633474, 42641007], "E": [42626026, 42624301, 42644046, 42634366, 42634335, 42634205, 42630482, 42637851, 42633450, 42641281, 42638561, 42638638, 42639628, 42642761, 42644666, 42649447, 42648312, 42643498, 42631013, 42635443, 42642733, 42645034, 42634920], "D": [42623581, 42621638, 42636628, 42635516, 42624651, 42622909, 42625901, 42624230, 42627616, 42623027, 42622706, 42628513, 42629952, 42622220, 42628717, 42631816, 42630498, 42632680, 42629722, 42643211], "C": [42622041, 42620587, 42639507, 42636945, 42623531, 42620800, 42624388, 42623206, 42625364, 42621712, 81464229, 42620946, 42626482, 42628744, 42619137, 42627629, 42632962, 42629275, 42630870, 42627504, 42631469], "A": [42617741, 42628137, 42620189, 42640915, 42619770, 42617799, 42621837, 42618858, 42617734, 42618440, 42617898, 42617724, 42617895, 42631014, 42618014, 42635499, 42624408, 42620380, 42619824]}, "name": "F. Relatively Prime Powers", "statement": "Consider some positive integer x. Its prime factorization will be of\r\nform x = 2^{k_1}\r\ncdot 3^{k_2}\r\ncdot 5^{k_3}\r\ncdot\r\ndotsLet\u2019s call x if the greatest common divisor of the sequence k_1,\r\nk_2,\r\ndots is equal to 1. For example, numbers 5 = 5^1, 12 = 2^2\r\ncdot 3, 72 = 2^3\r\ncdot 3^2 are and numbers 8 = 2^3 (GCD = 3), 2500 = 2^2\r\ncdot 5^4 (GCD = 2) are not.Count the number of integers from 2 to n.Each\r\ntestcase contains several values of n, for each of them you are required\r\nto solve the problem separately.\r\n", "solutions": ["// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst LL mod7=1000000007LL;\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\n//inline LL add(LL _x, LL _y, LL _mod=mod7){\n  //_x+=_y;\n  //return _x>=_mod ? _x-_mod : _x;\n//}\n//inline LL sub(LL _x, LL _y, LL _mod=mod7){\n  //_x-=_y;\n  //return _x<0 ? _x+_mod : _x;\n//}\n//inline LL mul(LL _x, LL _y ,LL _mod=mod7){\n  //_x*=_y;\n  //return _x>=_mod ? _x%_mod : _x;\n//}\n//LL mypow(LL _a, LL _x, LL _mod){\n  //if(_x == 0) return 1LL;\n  //LL _ret = mypow(mul(_a, _a, _mod), _x>>1, _mod);\n  //if(_x & 1) _ret=mul(_ret, _a, _mod);\n  //return _ret;\n//}\n//LL mymul(LL _a, LL _x, LL _mod){\n  //if(_x == 0) return 0LL;\n  //LL _ret = mymul(add(_a, _a, _mod), _x>>1, _mod);\n  //if(_x & 1) _ret=add(_ret, _a, _mod);\n  //return _ret;\n//}\nvoid sleep(double sec = 1021){\n  clock_t s = clock();\n  while(clock() - s < CLOCKS_PER_SEC * sec);\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\nconst int N=100;\nint mu[ N ] , p_tbl[ N ];\nvector<int> primes;\nvoid build(){\n  mu[ 1 ] = p_tbl[ 1 ] = 1;\n  for( int i = 2 ; i < N ; i ++ ){\n    if( !p_tbl[ i ] ){\n      p_tbl[ i ] = i;\n      primes.push_back( i );\n      mu[ i ] = -1;\n    }\n    for( int p : primes ){\n      int x = i * p;\n      if( x >= N ) break;\n      p_tbl[ x ] = p;\n      mu[ x ] = -mu[ i ];\n      if( i % p == 0 ){\n        mu[ x ] = 0;\n        break;\n      }\n    }\n  }\n}\nconst LL inf=2e18;\ninline LL mmul(LL a, LL b){\n  if(!a or !b) return 0;\n  if(a<inf/b) return a*b;\n  return inf;\n}\ninline LL mpow(LL a, LL b){\n  LL ret=1;\n  while(b){\n    if(b&1) ret=mmul(ret, a);\n    a=mmul(a, a);\n    b>>=1;\n  }\n  return ret;\n}\nLL n;\nvoid init(){\n  n=getint();\n}\nLL cnt[60];\nvoid solve(){\n  for(int i=0; i<60; i++) cnt[i]=0;\n  cnt[1]=n-1;\n  for(int i=2; i<60; i++){\n    LL cand=cnt[i-1]+1;\n    if(cand <= 10){\n      while(mpow(cand, i) > n) cand--;\n      if(cand < 2) break;\n      cnt[i]=cand-1;\n      continue;\n    }\n    cand=powl(n, 1./i);\n    while(mpow(cand, i) <= n) cand++;\n    cand--;\n    cnt[i]=cand-1;\n\n    //LL bl=2, br=cnt[i-1]+1, ba=-1;\n    //while(bl <= br){\n      //LL bmid=(bl+br)>>1;\n      //if(mpow(bmid, i) <= n) ba=bmid, bl=bmid+1;\n      //else br=bmid-1;\n    //}\n    //if(ba == -1) break;\n    //cnt[i]=ba-1;\n  }\n  //(int i=2; i<60; i++)\n    //if(cnt[i])\n      //printf(\"%d %lld\\n\", i, cnt[i]);\n  //for(int i=59; i>=2; i--)\n    //for(int j=i+i; j<60; j+=i)\n      //cnt[i]-=cnt[j];\n  LL ans=n-1;\n  //for(int i=2; i<60; i++) ans-=cnt[i];\n  for(int i=2; i<60; i++)\n    ans+=cnt[i]*mu[i];\n  //for(int i=2; i<60; i++)\n    //if(cnt[i])\n      //printf(\"%d %lld\\n\", i, cnt[i]);\n  printf(\"%lld\\n\", ans);\n}\nint main(){\n  build();\n  __ = getint();\n  while(__ --){\n    init();\n    solve();\n  }\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "math", "number theory"], "dificulty": "2400", "interactive": false}