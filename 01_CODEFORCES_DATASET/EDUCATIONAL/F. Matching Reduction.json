{
    "link": "https://codeforces.com//contest/1721/problem/F",
    "problemId": "1521729",
    "problem_idx": "F",
    "shortId": "1721F",
    "contest_number": "1721",
    "problem_submissions": {
        "F": [
            169847425,
            169855093,
            169874051,
            169859751,
            169871554,
            169869426,
            169892039,
            169866057,
            169866260,
            169879985,
            169882444,
            169880200,
            169868972,
            169943924,
            169887978,
            169882264,
            169879150,
            169868978,
            169868554,
            169884451,
            169886386,
            169884169,
            169836583,
            169890280,
            169889729
        ],
        "E": [
            169825445,
            169831576,
            169846355,
            169845815,
            169845247,
            169849940,
            170071212,
            169840961,
            169843652,
            169842409,
            169855809,
            169853200,
            169849055,
            169861077,
            169848556,
            169841458,
            169835951,
            169859126,
            169853059,
            169861299,
            169890819,
            169860030,
            169851763,
            169839234
        ],
        "D": [
            169816642,
            169857780,
            169827464,
            169828353,
            169825938,
            169823055,
            169827534,
            169839208,
            169826501,
            169831272,
            169830277,
            169840516,
            169830590,
            169829045,
            169820762,
            169829319,
            169841817,
            169849956,
            169828079,
            169855346,
            169832685
        ],
        "C": [
            169812006,
            169821873,
            169865515,
            169815093,
            169818535,
            169828842,
            169823304,
            169816953,
            169821336,
            169818460,
            169821914,
            169817547,
            169822314,
            169825383,
            169842253,
            169820059,
            169823503,
            169835000,
            169824388,
            169861925,
            169815457
        ],
        "B": [
            169804991,
            169810857,
            169806854,
            169811441,
            169813569,
            169810575,
            169808902,
            169808903,
            169811401,
            169810906,
            169807229,
            169812143,
            169813395,
            169807352,
            169812235,
            169815520,
            169825227,
            169814779,
            169864673,
            169808536
        ],
        "A": [
            169804030,
            169804283,
            169861742,
            169804044,
            169806500,
            169805484,
            169806996,
            169804568,
            169805103,
            169805093,
            169804586,
            169804045,
            169804642,
            169805849,
            169804015,
            169804388,
            169808577,
            169817992,
            169808806,
            169866242,
            169804342
        ]
    },
    "name": "F. Matching Reduction",
    "statement": "You are given a bipartite graph with n_1 vertices in the first part, n_2\r\nvertices in the second part, and m edges. The maximum matching in this\r\ngraph is the maximum possible (by size) subset of edges of this graph\r\nsuch that no vertex is incident to more than one chosen edge.You have to\r\nprocess two types of queries to this graph: 1 remove the number of\r\nvertices from this graph so that the size of the maximum matching gets\r\nreduced , and print the vertices that you have removed. Then, find any\r\nmaximum matching in this graph and print the sum of indices of edges\r\nbelonging to this matching; 2 query of this type will be asked only\r\nafter a query of type 1. As the answer to this query, you have to print\r\nthe edges forming the maximum matching you have chosen in the previous\r\nquery. Note that you should solve the problem in mode. It means that you\r\ncan’t read the whole input at once. You can read each query only after\r\nwriting the answer for the last query. Use functions in and in languages\r\nafter each writing in your program.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nstruct Flow {\n    const int n;\n    struct Edge {\n        int to;\n        T cap;\n        Edge(int to, T cap) : to(to), cap(cap) {}\n    };\n    std::vector<Edge> e;\n    std::vector<std::vector<int>> g;\n    std::vector<int> cur, h;\n    Flow(int n) : n(n), g(n) {}\n    \n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        std::queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            const int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                auto [v, c] = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t) {\n                        return true;\n                    }\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    \n    T dfs(int u, int t, T f) {\n        if (u == t) {\n            return f;\n        }\n        auto r = f;\n        for (int &i = cur[u]; i < int(g[u].size()); ++i) {\n            const int j = g[u][i];\n            auto [v, c] = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                auto a = dfs(v, t, std::min(r, c));\n                e[j].cap -= a;\n                e[j ^ 1].cap += a;\n                r -= a;\n                if (r == 0) {\n                    return f;\n                }\n            }\n        }\n        return f - r;\n    }\n    void addEdge(int u, int v, T c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    T maxFlow(int s, int t) {\n        T ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, std::numeric_limits<T>::max());\n        }\n        return ans;\n    }\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int nx, ny, m, q;\n    std::cin >> nx >> ny >> m >> q;\n    const int N = nx + ny;\n    \n    Flow<int> flow(nx + ny + 2);\n    const int S = nx + ny, T = S + 1;\n    std::vector<int> x(m), y(m);\n    for (int i = 0; i < m; i++) {\n        std::cin >> x[i] >> y[i];\n        x[i]--, y[i]--;\n        flow.addEdge(x[i], nx + y[i], 2);\n    }\n    for (int i = 0; i < nx; i++) {\n        flow.addEdge(S, i, 1);\n    }\n    for (int i = 0; i < ny; i++) {\n        flow.addEdge(nx + i, T, 1);\n    }\n    \n    int M = flow.maxFlow(S, T);\n    i64 sum = 0;\n    std::vector<int> e(N, -1);\n    for (int i = 0; i < m; i++) {\n        if (flow.e[2 * i].cap == 1) {\n            e[x[i]] = e[y[i] + nx] = i;\n            sum += i + 1;\n        }\n    }\n    \n    std::vector<int> cut(N);\n    std::vector<int> seq;\n    for (int i = 0; i < N; i++) {\n        cut[i] = (flow.h[i] == -1);\n        if ((i < nx && cut[i]) || (i >= nx && !cut[i])) {\n            seq.push_back(i);\n        }\n    }\n    \n    while (q--) {\n        int o;\n        std::cin >> o;\n        \n        if (o == 1) {\n            int u = seq.back();\n            seq.pop_back();\n            \n            std::cout << 1 << \"\\n\";\n            if (u < nx) {\n                std::cout << u + 1 << \"\\n\";\n            } else {\n                std::cout << -(u - nx + 1) << \"\\n\";\n            }\n            int j = e[u];\n            sum -= j + 1;\n            e[x[j]] = e[y[j] + nx] = -1;\n            std::cout << sum << std::endl;\n            M--;\n        } else {\n            std::cout << M << \"\\n\";\n            for (int i = 0; i < nx; i++) {\n                if (e[i] != -1) {\n                    std::cout << e[i] + 1 << \" \";\n                }\n            }\n            std::cout << std::endl;\n        }\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "dfs and similar",
        "flows",
        "graph matchings",
        "graphs",
        "interactive"
    ],
    "dificulty": "2800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Matching Reduction.json",
    "editorial_link": "https://codeforces.com//blog/entry/106416",
    "editorial": "Letâs start by finding the maximum matching in the given graph. Since\r\nthe constraints are pretty big, you need something fast. The model\r\nsolution converts the matching problem into a flow network and uses\r\nDinic to find the matching in , but something like heavily optimized\r\nKuhnâs algorithm can also work.Okay, then what about finding the minimum\r\npossible number of vertices to delete in order to reduce the maximum\r\nmatching? We claim that it is always enough to remove one vertex, and\r\nthe proof will also provide a way to quickly search for such\r\nvertices.Letâs recall that the size of the maximum matching is equal to\r\nthe size of the minimum vertex cover . So, we will try to find a way to\r\nreduce the minimum vertex cover by , and itâs actually pretty easy just\r\nremove any vertex belonging to the vertex cover; itâs obvious that it\r\nreduces the vertex cover by , and the maximum matching by as well. So,\r\nwe can find the minimum vertex cover in the graph using the standard\r\nalgorithm to convert the MM into MVC (or, if youâre using Dinic to find\r\nthe maximum matching, you can represent the minimum vertex cover as the\r\nminimum cut problem), and for each query of type , just take a vertex\r\nfrom the vertex cover we found.Now the only thing thatâs left is\r\ndiscussing how to maintain the structure of the maximum matching in the\r\ngraph. In fact, itâs quite easy: on the one hand, since we remove the\r\nvertices belonging to the minimum vertex cover, every edge (including\r\nthe edges from the matching) will be incident to one of the vertices we\r\nwill remove; on the other hand, due to the definition of the maximum\r\nmatching, there is no vertex that is incident to two or more edges from\r\nthe maximum matching; so, every vertex from the vertex cover has exactly\r\none edge from the maximum matching that is incident to it, and when we\r\nremove a vertex, we can simply remove the corresponding edge from the\r\nmaximum matching. So, the only thing we need to do is to maintain which\r\nedge from the matching corresponds to which vertex from the minimum\r\nvertex cover, and it will allow us to maintain the structure of the\r\nmaximum matching and since these \"pairs\" donât change when we remove a\r\nvertex, it is enough to get this information right after we have\r\nconstructed the maximum matching in the given graph; we wonât need to\r\nrebuild it.\r\n",
    "hint": []
}