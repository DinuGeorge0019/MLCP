{
    "link": "https://codeforces.com//contest/1156/problem/C",
    "problemId": "338450",
    "problem_idx": "C",
    "shortId": "1156C",
    "contest_number": "1156",
    "problem_submissions": {
        "A": [
            53639029,
            53626152,
            53625678,
            53630793,
            53625404,
            53614352,
            53623128,
            53628986,
            53624721,
            53623695,
            53625017,
            53634723,
            53624542,
            53628079,
            53633627,
            53624437,
            53623236,
            53629488,
            53623966,
            53615060
        ],
        "B": [
            53637891,
            53617977,
            53617293,
            53625525,
            53620909,
            53621377,
            53618385,
            53633927,
            53620068,
            53619804,
            53621825,
            53614635,
            53623085,
            53633560,
            53636498,
            53618667,
            53619022,
            53619496,
            53620680,
            53624386
        ],
        "C": [
            53636621,
            53619670,
            53619150,
            53614135,
            53617663,
            53625504,
            53624957,
            53661619,
            53635201,
            53626601,
            53622201,
            53615675,
            53635681,
            53619089,
            53620360,
            53614001,
            53620016,
            53634903,
            53620881,
            53615566,
            53626189
        ],
        "G": [
            53635130,
            53641842,
            53954352,
            53641770,
            203176755,
            53643379
        ],
        "D": [
            53620605,
            53623897,
            53623535,
            53629070,
            53631245,
            53633026,
            53629459,
            53616004,
            53628435,
            53632954,
            53632904,
            53620339,
            53632312,
            53623609,
            53618157,
            53629146,
            53629263,
            53627644,
            53629790,
            53630995
        ],
        "F": [
            53617719,
            53632417,
            53636572,
            53634637,
            53627300,
            53636941,
            53634698,
            53625519,
            53635307,
            53636482,
            53636370,
            53630747,
            53636740,
            53635472,
            53633389,
            53637182,
            53632117,
            53637419,
            53635743,
            53636158
        ],
        "E": [
            53614077,
            53629771,
            53629915,
            53618247,
            53637367,
            53630569,
            53631126,
            53661599,
            53620934,
            53631115,
            53629004,
            53629934,
            53625980,
            53630101,
            53619260,
            53627891,
            53632780,
            53621624,
            53634838,
            53638304,
            53634716
        ]
    },
    "name": "C. Match Points",
    "statement": "You are given a set of points x_1, x_2, ..., x_n on the number line.Two\r\npoints i and j can be matched with each other if the following\r\nconditions hold: neither i nor j is matched with any other point; |x_i -\r\nx_j|\r\nge z. What is the maximum number of pairs of points you can match with\r\neach other?\r\n",
    "solutions": [
        "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n, z;\n    cin >> n >> z;\n    int a[n];\n    rep(i, 0, n) {\n        cin >> a[i];\n    }\n    sort(a, a + n);\n    int l = 0, r = n / 2 + 1, mid;\n    while (r - l > 1) {\n        mid = (l + r) / 2;\n        bool ok = true;\n        rep(i, 0, mid) {\n            if (a[n - mid + i] - a[i] < z) {\n                ok = false;\n            }\n        }\n        ok ? l = mid : r = mid;\n    }\n    cout << l << \"\\n\";\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "sortings",
        "ternary search",
        "two pointers"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Match Points.json",
    "editorial_link": "https://codeforces.com/blog/entry/66827",
    "editorial": "Let\u00e2\u0080\u0099s denote the points that have greater coordinates in their matched\r\npairs as -points, and the points that have smaller coordinates as\r\n-points.Suppose we have an -point that has smaller coordinate than some\r\n-point. Then we can \"swap\" them, and the answer won\u00e2\u0080\u0099t become worse.\r\nAlso, if some -point has smaller coordinate than some point that doesn\u00e2\u0080\u0099t\r\nbelong to any pair, or some -point has greater coordinate than some\r\npoint that doesn\u00e2\u0080\u0099t belong to any pair, we can swap them too. So, if the\r\nanswer is , we choose leftmost points as -points, and rightmost ones as\r\n-points.For a fixed value of , it\u00e2\u0080\u0099s easy to see that we should match the\r\nleftmost -point with the leftmost -point, the second -point with the\r\nsecond -point, and so on, in order to maximize the minimum distance in a\r\npair. This fact allows us to check whether it is possible to construct\r\nat least pairs, and we can use binary search to compute the answer to\r\nthe problem.\r\n"
}