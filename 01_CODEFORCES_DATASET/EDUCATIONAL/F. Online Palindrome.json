{
    "link": "https://codeforces.com//contest/2086/problem/F",
    "problemId": "3306525",
    "problem_idx": "F",
    "shortId": "2086F",
    "contest_number": "2086",
    "problem_submissions": {
        "F": [
            313800473,
            313815107,
            313814871,
            313816809,
            313824037,
            313823800,
            313823595,
            313823290,
            313831013,
            313847963
        ],
        "E": [
            313778103,
            313768063,
            313796531,
            313772368,
            313776096,
            313773540,
            313775500,
            313777349,
            313773743,
            313773212,
            313777394,
            313774460,
            313780281,
            313777023,
            313779749,
            313779985,
            313789675,
            313782783,
            313780927
        ],
        "D": [
            313765839,
            313760163,
            313763413,
            313762506,
            313761667,
            313764480,
            313761919,
            313762403,
            313764311,
            313768000,
            313764673,
            313765244,
            313767408,
            313766701,
            313767208,
            313767620,
            313765113,
            313765919,
            313769446
        ],
        "C": [
            313762408,
            313757321,
            313759589,
            313757952,
            313757592,
            313758776,
            313758447,
            313758249,
            313761365,
            313762216,
            313760196,
            313762012,
            313758933,
            313763649,
            313761491,
            313762919,
            313757921,
            313761818
        ],
        "B": [
            313759878,
            313752573,
            313755779,
            313754646,
            313754713,
            313753530,
            313755287,
            313755649,
            313756220,
            313750845,
            313757002,
            313758471,
            313753446,
            313758811,
            313757915,
            313759796,
            313754670,
            313758593
        ],
        "A": [
            313747124,
            313744880,
            313745589,
            313744964,
            313745790,
            313744642,
            313747626,
            313744833,
            313745066,
            313744593,
            313747501,
            313747195,
            313744587,
            313748494,
            313746594,
            313746261,
            313746218,
            313744938
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/141425",
    "editorial": "From the problem statement, it can be understood that at each step, when\r\nwe have an odd number of characters, the string must be a palindrome,\r\nsince the length of the string is not provided. Therefore, we need to\r\ncome up with a strategy for swaps to ensure this condition is met.The\r\nfirst thought is to try a brute-force approach of the following\r\nkind:When the current step is odd (i.e., ), let’s obtain the next\r\ncharacter , add it to the end of , and perform some swap. After this,\r\ntwo conditions must be satisfied: if we then add the character \"\", the\r\nstring can be turned into a palindrome with no more than one swap; if we\r\nthen add the character \"\", the string can be turned into a palindrome\r\nwith no more than one swap. If the step is even, let’s obtain the next\r\ncharacter , add it to the end of , and perform a swap so that becomes a\r\npalindrome.If we try to submit this solution, we will get , as there can\r\nbe situations where both conditions for the odd step are not satisfied\r\nsimultaneously. This is due to the fact that we allow the construction\r\nof any palindromes.Based on this, we conclude that any palindrome is not\r\nsuitable for us, and we need to maintain some template palindrome. The\r\nmost challenging part of this problem is to find such a template.Next, I\r\nwill describe how the template should look: if there is more than one\r\nletter \"\", then we place the letter \"\" as the first and last character;\r\nif there is more than one letter \"\", then we place the letter \"\" as the\r\nsecond and second-to-last character; if there is more than one letter\r\n\"\", then we place the letter \"\" as the third and third-to-last\r\ncharacter; we alternate this way while possible; then we fill all paired\r\npositions with the letter that has more than one left; the center is\r\nfilled unambiguously. All palindromes that start with the letter \"\" and\r\nhave the same form are also suitable for us. For example, the following\r\nstrings fit the template: \"\"; \"\"; \"\"; \"\"; For this template, there are\r\ntransitions (i.e., swaps such that from a template of length we can\r\ntransition to a template of length by adding any possible pair of\r\ncharacters), however, deriving them manually is quite complicated, as\r\nthere are many situations.However, this can be added to our brute-force\r\napproach for the odd step. Once again, here’s how it will look: obtain\r\nthe next character from the input; iterate through a pair of characters\r\nin the string that we want to swap; for each iterated pair, consider two\r\nvariants of the second incoming character. Check if we can obtain the\r\nexpected template from the current string with no more than one swap;\r\nthis can be checked unambiguously with a linear pass through the string\r\nand the expected template, looking at the differing positions; if for\r\nthe checked permutation we can transition to the template with any next\r\nletter, then we perform that permutation. For the even step, we can\r\nsimply find the necessary swap in a linear manner.Thus, the asymptotic\r\ncomplexity of this solution is .As an appendix, I will list examples of\r\ntransitions by pairs of characters in the template: \"\" + \"\" \"\"; \"\" + \"\"\r\n\"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\"\r\n\"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\"\r\n\"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\"\r\n\"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\" \"\"; \"\" + \"\"\r\n\"\"; \"\" + \"\" \"\";\r\n",
    "name": "F. Online Palindrome",
    "statement": "The jury has a string s consisting of lowercase Latin letters. The\r\nfollowing constraints apply to this string: the string has an odd length\r\nthat does not exceed 99; the string consists only of the characters \"\"\r\nand \"\". There is also a string t, which is initially empty. Then, |s|\r\nsteps happen. During the i-th step, the following events occur: first,\r\nthe jury tells you the character s_i and appends it to the end of the\r\nstring t; then, you may swap any two characters in t, or do nothing.\r\nYour task is to ensure that after the |s|-th step, the string t is a\r\npalindrome.\r\n",
    "solutions": [],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "interactive"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Online Palindrome.json"
}