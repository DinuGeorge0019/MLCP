{"link": "https://codeforces.com//contest/1093/problem/G", "problemId": "270228", "problem_idx": "G", "shortId": "1093G", "contest_number": "1093", "problem_submissions": {"F": [47064317, 47066369, 47072013, 47063078, 47070194, 47066599, 47069818, 47071658, 47069736, 47073345, 47066962, 47067247, 47069530, 47073606, 47073395, 47061796, 47063002, 47067085, 47069647], "E": [47059940, 47175053, 47174990, 47174965, 47060977, 47054377, 47057431, 47053669, 47071310, 47064501, 47060021, 47063571, 47051018, 47060722, 47054485, 47099037, 47099010, 47054662, 47065797, 47074158, 47051089, 47074689, 47067318, 47063903, 47063526, 47063507, 47058046, 47058483], "G": [47051449, 47054318, 47060619, 47069286, 47064176, 47054294, 47058010, 47064582, 47059658, 47045741, 47069865, 47071490, 47044907, 47068431, 47054907, 47076907, 47070943, 47045135, 47052551, 47065756, 47061805, 47064972], "D": [47046394, 47048590, 47050157, 47049421, 47048833, 47047771, 47051232, 47049608, 47047579, 47056236, 47052390, 47047717, 47060889, 47049097, 47062998, 47068801, 47069194, 47070905, 47050207, 47053679], "C": [47043859, 47045338, 47046257, 47046095, 47044608, 47045282, 47047834, 47047265, 47045573, 47053477, 47049038, 47043947, 47058752, 47044937, 47064718, 47070147, 233878752, 233878357, 233877672, 233874035, 47071603, 47073360, 47045788, 47044965], "B": [47041242, 47042516, 47041777, 47042122, 47042500, 47043090, 47044535, 47044930, 47041021, 47051714, 47043546, 47041074, 47056563, 47042532, 47063756, 47070397, 47070118, 47071889, 47042554, 47041254], "A": [47040802, 47041248, 47040853, 47040900, 47040739, 47042123, 47040939, 47043340, 47040729, 47052191, 47041112, 47040744, 47075234, 47055833, 47041119, 47063989, 47070741, 47069623, 47071501, 47041275, 47040765]}, "name": "G. Multidimensional Queries", "statement": "You are given an array a of n points in k-dimensional space. Let the\r\ndistance between two points a_x and a_y be\r\nsum\r\nlimits_{i = 1}^{k} |a_{x, i} - a_{y, i}| (it is also known as Manhattan\r\ndistance).You have to process q queries of the following two types: 1 i\r\nb_1 b_2 ... b_k set i-th element of a to the point (b_1, b_2,\r\ndots, b_k); 2 l r find the maximum distance between two points a_i and\r\na_j, where l\r\nle i, j\r\nle r.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\nconst int inf = 1e9;\n\nnamespace segtree {\n    struct data {\n        vector<int> x, y;\n        data() {}\n        data(int sz) {\n            x.resize(sz, -inf);\n            y.resize(sz, +inf);\n        }\n        data(const vector<int> &p) {\n            int k = (int)p.size();\n            x.resize(1 << k, -inf);\n            y.resize(1 << k, +inf);\n            for (int i = 0; i < (1 << k); ++i) {\n                int s = 0;\n                for (int j = 0; j < k; ++j) {\n                    if (i >> j & 1) s += p[j];\n                    else s -= p[j];\n                }\n                x[i] = max(x[i], s);\n                y[i] = min(y[i], s);\n            }\n        }\n        data operator+(const data &d) const {\n            data res(x.size());\n            for (int i = 0; i < (int)x.size(); ++i) {\n                res.x[i] = max(res.x[i], x[i]);\n                res.x[i] = max(res.x[i], d.x[i]);\n                res.y[i] = min(res.y[i], y[i]);\n                res.y[i] = min(res.y[i], d.y[i]);\n            }\n            return res;\n        }\n    }; \n    data st[maxn * 4];\n    void build(int l, int r, const vector<vector<int>> &p, int o = 0) {\n        if (r - l == 1) return st[o] = data(p[l]), void();\n        build(l, (l + r) >> 1, p, o * 2 + 1);\n        build((l + r) >> 1, r, p, o * 2 + 2);\n        st[o] = st[o * 2 + 1] + st[o * 2 + 2];\n    }\n    void modify(int l, int r, int z, const vector<int> &p, int o = 0) {\n        if (r - l == 1) return st[o] = data(p), void();\n        if (z < (l + r) >> 1) modify(l, (l + r) >> 1, z, p, o * 2 + 1);\n        else modify((l + r) >> 1, r, z, p, o * 2 + 2);\n        st[o] = st[o * 2 + 1] + st[o * 2 + 2];\n    }\n    data query(int l, int r, int ql, int qr, int o = 0) {\n        if (l >= ql && r <= qr) return st[o];\n        if (qr <= (l + r) >> 1) return query(l, (l + r) >> 1, ql, qr, o * 2 + 1);\n        if (ql >= (l + r) >> 1) return query((l + r) >> 1, r, ql, qr, o * 2 + 2);\n        return query(l, (l + r) >> 1, ql, qr, o * 2 + 1) +\n               query((l + r) >> 1, r, ql, qr, o * 2 + 2);\n    } \n}\n\nint main() {\n    int n, k; scanf(\"%d%d\", &n, &k);\n    vector<vector<int>> p(n);\n    for (int i = 0; i < n; ++i) {\n        p[i].resize(k);\n        for (int j = 0; j < k; ++j) scanf(\"%d\", &p[i][j]);\n    }\n    segtree::build(0, n, p);\n    int q; scanf(\"%d\", &q);\n    while (q--) {\n        int t; scanf(\"%d\", &t);\n        if (t == 1) {\n            int z; vector<int> p(k);\n            scanf(\"%d\", &z); z--;\n            for (int i = 0; i < k; ++i) scanf(\"%d\", &p[i]);\n            segtree::modify(0, n, z, p);\n        } else {\n            int l, r; scanf(\"%d%d\", &l, &r);\n            segtree::data res = segtree::query(0, n, l - 1, r);\n            int ans = 0;\n            for (int i = 0; i < (1 << k); ++i) ans = max(ans, res.x[i] - res.y[i]);\n            printf(\"%d\\n\", ans);\n        }\n    }\n}\n"], "input": "", "output": "", "tags": ["bitmasks", "data structures"], "dificulty": "2300", "interactive": false}