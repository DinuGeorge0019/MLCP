{
    "link": "https://codeforces.com//contest/1455/problem/E",
    "problemId": "815718",
    "problem_idx": "E",
    "shortId": "1455E",
    "contest_number": "1455",
    "problem_submissions": {
        "E": [
            100080155,
            100079381,
            100078449,
            100069275,
            100012146,
            100015897,
            100022845,
            100016854,
            100016418,
            100020237,
            100020046,
            100028425,
            100029068,
            100034230,
            100029402,
            100051234,
            100023750,
            100021088,
            100056948,
            100056790,
            100027354,
            100027044,
            100024946,
            100025731
        ],
        "F": [
            100078450,
            100025388,
            100024460,
            100036395,
            100043068,
            100042389,
            100045529,
            100060216,
            100044226,
            100043456,
            100052099,
            100046594,
            100048576,
            103031134
        ],
        "D": [
            100078448,
            100005946,
            100008735,
            100010384,
            100011871,
            100006215,
            100010441,
            100013223,
            100016383,
            100022310,
            100014989,
            100021069,
            100012652,
            100006839,
            100007553,
            100009178,
            100010622,
            100017383
        ],
        "B": [
            100078446,
            99997720,
            100001458,
            100004151,
            99999328,
            99996708,
            100002292,
            99997258,
            100004647,
            100006268,
            100003306,
            100007106,
            100000261,
            99994951,
            99999396,
            99999653,
            100001010,
            99999631,
            100001869
        ],
        "G": [
            100042304,
            100034172,
            100133399,
            100133353,
            100129809,
            100466593,
            100055077,
            100046402,
            100109589,
            102917383,
            100053452
        ],
        "C": [
            100002522,
            100004461,
            100006266,
            100003366,
            100000366,
            100005398,
            100004212,
            100008763,
            100010135,
            100006377,
            100015174,
            100005740,
            99999911,
            100008765,
            100001216,
            100002465,
            100006020
        ],
        "A": [
            99993343,
            99993450,
            99994266,
            99993464,
            99993313,
            99995467,
            99993403,
            99995627,
            99997962,
            99993689,
            99993532,
            99993614,
            99993321,
            99993386,
            99994914,
            99994222,
            99993353
        ]
    },
    "name": "E. Four Points",
    "statement": "You are given four different integer points p_1, p_2, p_3 and p_4 on\r\nmathit{XY} grid.In one step you can choose one of the points p_i and\r\nmove it in one of four directions by one. In other words, if you have\r\nchosen point p_i = (x, y) you can move it to (x, y + 1), (x, y - 1),\r\n(x + 1, y) or (x - 1, y).Your goal to move points in such a way that\r\nthey will form a square with sides parallel to\r\nmathit{OX} and\r\nmathit{OY} axes (a square with side 0 is allowed).What is the minimum\r\nnumber of steps you need to make such a square?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nconst int64_t XY_MAX = int(1e9) + 5;\n\nvoid run_case() {\n    auto get_median = [](array<int64_t, 4> &X) {\n        nth_element(X.begin(), X.begin() + 1, X.end());\n        return X[1];\n    };\n\n    auto evaluate = [&](array<int64_t, 4> CX, array<int64_t, 4> CY, int64_t len) {\n        CX[1] -= len; CX[3] -= len;\n        CY[2] -= len; CY[3] -= len;\n        int64_t X_median = get_median(CX);\n        int64_t Y_median = get_median(CY);\n        int64_t value = 0;\n\n        for (int i = 0; i < 4; i++)\n            value += abs(CX[i] - X_median) + abs(CY[i] - Y_median);\n\n        return value;\n    };\n\n    auto get_choices = [](array<int64_t, 2> low, array<int64_t, 2> high) -> array<int64_t, 2> {\n        sort(low.begin(), low.end());\n        sort(high.begin(), high.end());\n        return {high[1] - low[0], high[0] - low[1]};\n    };\n\n    array<int64_t, 4> X, Y;\n\n    for (int i = 0; i < 4; i++)\n        cin >> X[i] >> Y[i];\n\n    array<int, 4> perm = {0, 1, 2, 3};\n    int64_t best = XY_MAX * XY_MAX;\n\n    do {\n        array<int64_t, 4> CX, CY;\n\n        for (int i = 0; i < 4; i++) {\n            CX[i] = X[perm[i]];\n            CY[i] = Y[perm[i]];\n        }\n\n        array<int64_t, 2> x_choices = get_choices({CX[0], CX[2]}, {CX[1], CX[3]});\n        array<int64_t, 2> y_choices = get_choices({CY[0], CY[1]}, {CY[2], CY[3]});\n        array<int64_t, 4> choices = {x_choices[0], x_choices[1], y_choices[0], y_choices[1]};\n        int64_t len = max<int64_t>(get_median(choices), 0);\n        best = min(best, evaluate(CX, CY, len));\n    } while (next_permutation(perm.begin(), perm.end()));\n\n    cout << best << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "flows",
        "geometry",
        "greedy",
        "implementation",
        "math",
        "ternary search"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Four Points.json",
    "editorial_link": "https://codeforces.com//blog/entry/85186",
    "editorial": "Let\u00e2\u0080\u0099s discuss two approaches to this problem. Firstly, let\u00e2\u0080\u0099s think that\r\nwe choose not four destination points but four lines on which sides of\r\nthe square lie. It\u00e2\u0080\u0099s two vertical lines with coordinates and and two\r\nhorizontal lines and (of course, ). is to note that either both and\r\ncoincide with some -s and coincide with one of or both and coincide with\r\nsome -s and coincide with one . Since we know the side of the square\r\n(from or ) and one point It\u00e2\u0080\u0099s easy to construct other points of the\r\nsquare and find the minimum total distance by iterating all\r\npermutations. This approach needs around operations and work around one\r\nsecond if written accurately. is more clever and faster. Let\u00e2\u0080\u0099s assign a\r\nrole for each point which vertex of the final square this will be:\r\nleft-bottom, left-top, right-bottom or right-top. There will be such\r\nassignments. For simplicity let\u00e2\u0080\u0099s say that the left-bottom vertex is ,\r\nleft-top is , right-bottom is and right-top is .If we rewrite our total\r\ndistance formulas, we can note that instead of summing the distance\r\nbetween points, we can sum the distance from lines to the points which\r\nshould lie on it. In other words, we can calculate the answer as Let\u00e2\u0080\u0099s\r\nlook at the left side . If then the total distance is always and has\r\nit\u00e2\u0080\u0099s optimal segment of values. Analogically, also has it\u00e2\u0080\u0099s optimal\r\nsegment of values .Since we can choose as any value in its segment and\r\nas any value in its segment then the possible distance (the side of the\r\nsquare) also forms a segment of possible values (let\u00e2\u0080\u0099s name it as ) and\r\ncan be calculated with pretty easy formula.On the other hand, we can do\r\nthe same with horizontal sides and compute the segment of optimal side\r\nlength in the same manner.Now, if and intersects then we can choose such\r\nside length that lies in both and and optimal for both vertical sides\r\nand horizontal sides. Otherwise, without loss of generality, and if we\r\nchoose we need to pay extra \"fee\" since we out of it means that the\r\nchosen is greater than optimal , so we need to choose, for example,\r\noutside . And we need to pay for each step outside of this segment.In\r\nother words, the answer for a fixed permutation is\r\n"
}