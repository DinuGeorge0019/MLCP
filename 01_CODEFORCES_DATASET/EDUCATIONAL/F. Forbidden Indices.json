{"link": "https://codeforces.com//contest/873/problem/F", "problemId": "127824", "problem_idx": "F", "shortId": "873F", "contest_number": "873", "problem_submissions": {"F": [31249155, 31246074, 31247917, 31248578, 31249388, 31249158, 31251415, 31251584, 31250733, 31288783, 31250579, 31245985, 31253356, 31247757, 31248728, 31247477, 31250335, 50573188, 31250325, 31251280], "E": [31248134, 31249919, 31252439, 31251022, 31250865, 31249737, 31252775, 31249136, 31250580, 31253627, 31288769, 31253029, 31255710, 31253949, 31251510, 31251487, 31250360, 31262356, 31249482, 31279947, 31254652], "D": [31245980, 31247767, 31247101, 31246043, 31246748, 31245415, 31247268, 112870619, 31246541, 31245811, 31246941, 31288779, 31248218, 31249255, 31247717, 31246658, 31251512, 31244912, 31245095, 31246576, 31246214, 31247900], "C": [31244661, 31246346, 31244654, 31244959, 31244457, 31244670, 31245105, 31244159, 31244863, 31245509, 31247509, 31245175, 31252048, 31251951, 31245641, 31244103, 31244492, 31244705, 31245349], "B": [31243795, 31244797, 31243640, 31244221, 31243588, 31243630, 251388248, 206107056, 102945786, 102945751, 31243439, 31243368, 31243788, 31244097, 31246401, 31243794, 31252944, 31252443, 31243336, 31243339, 31243565, 31243646, 31244189], "A": [31242945, 31244304, 31243017, 31243228, 31242934, 31243184, 31242993, 31242977, 31243012, 31243412, 31244065, 31243098, 31243193, 31252560, 31242943, 31242939, 31243039, 31243390]}, "name": "F. Forbidden Indices", "statement": "You are given a string consisting of lowercase Latin letters. Some\r\nindices in this string are marked as .You want to find a string such\r\nthat the value of is maximum possible, where is the number of occurences\r\nof in such that these occurences end in non-forbidden indices. So, for\r\nexample, if is , is and index is forbidden, then because there are three\r\noccurences of in (starting in indices , and ), but one of them (starting\r\nin index ) ends in a forbidden index.Calculate the maximum possible\r\nvalue of you can get.\r\n", "solutions": ["#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nstruct node {\n\tint link;\n\tint len;\n\tmap<char, int> to;\n\tint good;\n\tnode() : link(-1), len(0), good(0) {}\n};\n\nvector<node> t;\nint last = 0;\n\nvoid add(char c, int flag) {\n\tint curr = sz(t);\n\tt.pb(node());\n\tt[curr].len = t[last].len + 1;\n\tt[curr].good = flag;\n\tint p = last;\n\twhile (p != -1) {\n\t\tif (!t[p].to.count(c)) {\n\t\t\tt[p].to[c] = curr;\n\t\t\tp = t[p].link;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p == -1) {\n\t\tt[curr].link = 0;\n\t\tlast = curr;\n\t\treturn;\n\t}\n\tint q = t[p].to[c];\n\tif (t[q].len == t[p].len + 1) {\n\t\tt[curr].link = q;\n\t\tlast = curr;\n\t\treturn;\n\t}\n\tint clone = sz(t);\n\tt.pb(node());\n\tt[clone].to = t[q].to;\n\tt[clone].len = t[p].len + 1;\n\tt[clone].link = t[q].link;\n\twhile (p != -1) {\n\t\tif (t[p].to.count(c) && t[p].to[c] == q) {\n\t\t\tt[p].to[c] = clone;\n\t\t\tp = t[p].link;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tt[q].link = t[curr].link = clone;\n\tlast = curr;\n}\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(\"input.txt\");\n\t//ofstream cout(\"output.txt\");\n\n\tt.pb(node());\n\tint n;\n\tcin >> n;\n\n\tstring a, b;\n\tcin >> a >> b;\n\tfor (int i = 0; i < n; ++i) {\n\t\tadd(a[i], (b[i] == '0'));\n\t}\n\n\tvector<int> ord;\n\tfor (int i = 1; i < sz(t); ++i) {\n\t\tord.pb(i);\n\t}\n\tsort(all(ord), [&] (int a, int b) {\n\t\treturn t[a].len > t[b].len;\n\t});\n\tfor (int v : ord) {\n\t\tt[t[v].link].good += t[v].good;\n\t}\n\n\tll ans = 0;\n\tfor (int v = 1; v < sz(t); ++v) {\n\t\tans = max(ans, ll(t[v].good) * ll(t[v].len));\n\t}\n\tcout << ans << \"\\n\";\n\n}"], "input": "", "output": "", "tags": ["dsu", "string suffix structures", "strings"], "dificulty": "2400", "interactive": false}