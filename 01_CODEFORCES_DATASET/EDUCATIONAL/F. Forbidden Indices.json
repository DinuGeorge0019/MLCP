{
    "link": "https://codeforces.com//contest/873/problem/F",
    "problemId": "127824",
    "problem_idx": "F",
    "shortId": "873F",
    "contest_number": "873",
    "problem_submissions": {
        "F": [
            31249155,
            31246074,
            31247917,
            31248578,
            31249388,
            31249158,
            31251415,
            31251584,
            31250733,
            31288783,
            31250579,
            31245985,
            31253356,
            31247757,
            31248728,
            31247477,
            31250335,
            50573188,
            31250325,
            31251280
        ],
        "E": [
            31248134,
            31249919,
            31252439,
            31251022,
            31250865,
            31249737,
            31252775,
            31249136,
            31250580,
            31253627,
            31288769,
            31253029,
            31255710,
            31253949,
            31251510,
            31251487,
            31250360,
            31262356,
            31249482,
            31279947,
            31254652
        ],
        "D": [
            31245980,
            31247767,
            31247101,
            31246043,
            31246748,
            31245415,
            31247268,
            112870619,
            31246541,
            31245811,
            31246941,
            31288779,
            31248218,
            31249255,
            31247717,
            31246658,
            31251512,
            31244912,
            31245095,
            31246576,
            31246214,
            31247900
        ],
        "C": [
            31244661,
            31246346,
            31244654,
            31244959,
            31244457,
            31244670,
            31245105,
            31244159,
            31244863,
            31245509,
            31247509,
            31245175,
            31252048,
            31251951,
            31245641,
            31244103,
            31244492,
            31244705,
            31245349
        ],
        "B": [
            31243795,
            31244797,
            31243640,
            31244221,
            31243588,
            31243630,
            251388248,
            206107056,
            102945786,
            102945751,
            31243439,
            31243368,
            31243788,
            31244097,
            31246401,
            31243794,
            31252944,
            31252443,
            31243336,
            31243339,
            31243565,
            31243646,
            31244189
        ],
        "A": [
            31242945,
            31244304,
            31243017,
            31243228,
            31242934,
            31243184,
            31242993,
            31242977,
            31243012,
            31243412,
            31244065,
            31243098,
            31243193,
            31252560,
            31242943,
            31242939,
            31243039,
            31243390
        ]
    },
    "name": "F. Forbidden Indices",
    "statement": "You are given a string consisting of lowercase Latin letters. Some\r\nindices in this string are marked as .You want to find a string such\r\nthat the value of is maximum possible, where is the number of occurences\r\nof in such that these occurences end in non-forbidden indices. So, for\r\nexample, if is , is and index is forbidden, then because there are three\r\noccurences of in (starting in indices , and ), but one of them (starting\r\nin index ) ends in a forbidden index.Calculate the maximum possible\r\nvalue of you can get.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define pb push_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef double ld;\ntypedef pair<ll, ll> pll;\n\nstruct node {\n\tint link;\n\tint len;\n\tmap<char, int> to;\n\tint good;\n\tnode() : link(-1), len(0), good(0) {}\n};\n\nvector<node> t;\nint last = 0;\n\nvoid add(char c, int flag) {\n\tint curr = sz(t);\n\tt.pb(node());\n\tt[curr].len = t[last].len + 1;\n\tt[curr].good = flag;\n\tint p = last;\n\twhile (p != -1) {\n\t\tif (!t[p].to.count(c)) {\n\t\t\tt[p].to[c] = curr;\n\t\t\tp = t[p].link;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p == -1) {\n\t\tt[curr].link = 0;\n\t\tlast = curr;\n\t\treturn;\n\t}\n\tint q = t[p].to[c];\n\tif (t[q].len == t[p].len + 1) {\n\t\tt[curr].link = q;\n\t\tlast = curr;\n\t\treturn;\n\t}\n\tint clone = sz(t);\n\tt.pb(node());\n\tt[clone].to = t[q].to;\n\tt[clone].len = t[p].len + 1;\n\tt[clone].link = t[q].link;\n\twhile (p != -1) {\n\t\tif (t[p].to.count(c) && t[p].to[c] == q) {\n\t\t\tt[p].to[c] = clone;\n\t\t\tp = t[p].link;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tt[q].link = t[curr].link = clone;\n\tlast = curr;\n}\n\nint main() {\n\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\n\t//ifstream cin(\"input.txt\");\n\t//ofstream cout(\"output.txt\");\n\n\tt.pb(node());\n\tint n;\n\tcin >> n;\n\n\tstring a, b;\n\tcin >> a >> b;\n\tfor (int i = 0; i < n; ++i) {\n\t\tadd(a[i], (b[i] == '0'));\n\t}\n\n\tvector<int> ord;\n\tfor (int i = 1; i < sz(t); ++i) {\n\t\tord.pb(i);\n\t}\n\tsort(all(ord), [&] (int a, int b) {\n\t\treturn t[a].len > t[b].len;\n\t});\n\tfor (int v : ord) {\n\t\tt[t[v].link].good += t[v].good;\n\t}\n\n\tll ans = 0;\n\tfor (int v = 1; v < sz(t); ++v) {\n\t\tans = max(ans, ll(t[v].good) * ll(t[v].len));\n\t}\n\tcout << ans << \"\\n\";\n\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dsu",
        "string suffix structures",
        "strings"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Forbidden Indices.json",
    "editorial_link": "https://codeforces.com//blog/entry/55171",
    "editorial": "This problem can be solved with different suffix structures. Model\r\nsolution uses suffix array.First of all, let\u00e2\u0080\u0099s reverse , so for we will\r\ncount only occurences that start in non-forbidden indices.Then, if there\r\nis at least one non-forbidden index, there are two cases: , then the\r\nbest option to choose is to use a suffix which begins in the leftmost\r\n(after reversing ) non-forbidden index. , then is the longest common\r\nprefix of some two suffixes of . Let\u00e2\u0080\u0099s build a suffix array, then\r\ncalculate the LCP array. Then recall the fact that a LCP of two suffixes\r\nis the minimum on the segment of LCP array between these two suffixes,\r\nso we can use a common stack algorithm that will for each LCP find the\r\nsegment of suffixes such that this LCP is a prefix of these suffixes (to\r\ndo this, for each element of LCP array we find the largest segment such\r\nthat this element is minimal on that segment), and then we can use\r\nprefix sums to find the number of non-forbidden suffixes such that\r\nchosen LCP is a prefix of this suffix (and so calculate easily for each\r\nLCP).\r\n"
}