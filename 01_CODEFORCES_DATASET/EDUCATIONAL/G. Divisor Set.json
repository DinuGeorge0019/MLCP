{
    "link": "https://codeforces.com//contest/1257/problem/G",
    "problemId": "470642",
    "problem_idx": "G",
    "shortId": "1257G",
    "contest_number": "1257",
    "problem_submissions": {
        "D": [
            65057118,
            65056815,
            64811909,
            64812228,
            64902701,
            64852999,
            64814000,
            64812775,
            64810546,
            64816528,
            64811860,
            64815149,
            64813583,
            64859190,
            64812263,
            64833625,
            64835681,
            64837730,
            64812160,
            64814684,
            64816849,
            64813089,
            64816979,
            64819402,
            64816732
        ],
        "C": [
            65056409,
            64806576,
            64805235,
            64806785,
            64807190,
            64804696,
            64807450,
            64806032,
            64809153,
            64805479,
            64859181,
            64806083,
            64833699,
            64837249,
            64838553,
            64806562,
            64809106,
            64808660,
            64805745,
            64806256,
            64807560,
            64807194
        ],
        "G": [
            64897847,
            64897831,
            64897799,
            64897485,
            64897435,
            64897360,
            64897323,
            64897206,
            64897135,
            64897132,
            64832008,
            64834753,
            64834055,
            65121895,
            65107512,
            65106890,
            64896695,
            64896568,
            64824847,
            64838006,
            64831302,
            64827437,
            64838916,
            64835759,
            64897295,
            64843586,
            64835359,
            64859234,
            64838704,
            65758026,
            65701826,
            64838221,
            64811892,
            64819153,
            64825152,
            64845699,
            211233713
        ],
        "E": [
            64865638,
            64865598,
            64816641,
            64819423,
            64857985,
            64831912,
            64817543,
            64814313,
            64819647,
            64817584,
            64819210,
            64817767,
            64859197,
            64814324,
            64824835,
            64832464,
            64832777,
            64820509,
            64818561,
            64820860,
            64817451,
            64823687,
            64821709,
            64824423
        ],
        "F": [
            64821055,
            64823926,
            64819069,
            64824118,
            64836060,
            64833509,
            64822156,
            64828427,
            64823151,
            64859227,
            64836114,
            64824755,
            64828355,
            64829448,
            64829060,
            64827403,
            64826552,
            64828456,
            64828341,
            64826098,
            64830812
        ],
        "B": [
            64802390,
            64803311,
            64804526,
            64804462,
            64802487,
            64804783,
            64803616,
            64806366,
            64802273,
            64859169,
            64803153,
            64833735,
            64838243,
            64839005,
            64803686,
            64806451,
            64806108,
            64802622,
            64803655,
            64803331,
            64803958
        ],
        "A": [
            64800956,
            64800953,
            64801859,
            64801038,
            64800918,
            64800975,
            64800962,
            64803138,
            64800908,
            64859160,
            64801089,
            64833779,
            64838753,
            64839327,
            64800961,
            64801572,
            64801191,
            64800917,
            64801440,
            64800919,
            64801087
        ]
    },
    "name": "G. Divisor Set",
    "statement": "You are given an integer x represented as a product of n its divisors\r\np_1\r\ncdot p_2,\r\ncdot\r\nldots\r\ncdot p_n. Let S be the set of positive integer divisors of x (including\r\n1 and x itself).We call a set of integers D if (and only if) there is no\r\npair a\r\nin D, b\r\nin D such that a\r\nne b and a divides b.Find a subset of S with maximum possible size.\r\nSince the answer can be large, print the size of the subset modulo\r\n998244353.\r\n",
    "solutions": [
        "#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <limits>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nnamespace IO {\n    const int BUFFER_SIZE = 1 << 15;\n\n    char input_buffer[BUFFER_SIZE];\n    int input_pos = 0, input_len = 0;\n\n    void _update_input_buffer() {\n        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);\n        input_pos = 0;\n\n        if (input_len == 0)\n            input_buffer[0] = EOF;\n    }\n\n    inline char next_char(bool advance = true) {\n        if (input_pos >= input_len)\n            _update_input_buffer();\n\n        return input_buffer[advance ? input_pos++ : input_pos];\n    }\n\n    template<typename T>\n    inline void read_int(T &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == '-')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - '0');\n        } while (isdigit(next_char(false)));\n\n        if (negative)\n            number = -number;\n    }\n\n    template<typename T, typename... Args>\n    inline void read_int(T &number, Args &... args) {\n        read_int(number);\n        read_int(args...);\n    }\n}\n\nconst int MOD = 998244353;\n\nstruct mod_int {\n    int val;\n\n    mod_int(long long v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = v;\n    }\n\n    static int mod_inv(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const {\n        return val;\n    }\n\n    mod_int& operator+=(const mod_int &other) {\n        val += other.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n\n    mod_int& operator-=(const mod_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return x % m;\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit integer.\n        unsigned x_high = x >> 32, x_low = (unsigned) x;\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    mod_int& operator*=(const mod_int &other) {\n        val = fast_mod((uint64_t) val * other.val);\n        return *this;\n    }\n\n    mod_int& operator/=(const mod_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend mod_int operator+(const mod_int &a, const mod_int &b) { return mod_int(a) += b; }\n    friend mod_int operator-(const mod_int &a, const mod_int &b) { return mod_int(a) -= b; }\n    friend mod_int operator*(const mod_int &a, const mod_int &b) { return mod_int(a) *= b; }\n    friend mod_int operator/(const mod_int &a, const mod_int &b) { return mod_int(a) /= b; }\n\n    mod_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    mod_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    mod_int operator++(int) { mod_int before = *this; ++*this; return before; }\n    mod_int operator--(int) { mod_int before = *this; --*this; return before; }\n\n    mod_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const mod_int &other) const { return val == other.val; }\n    bool operator!=(const mod_int &other) const { return val != other.val; }\n\n    mod_int inv() const {\n        return mod_inv(val);\n    }\n\n    mod_int pow(long long p) const {\n        assert(p >= 0);\n        mod_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            a *= a;\n            p >>= 1;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &stream, const mod_int &m) {\n        return stream << m.val;\n    }\n};\n\nnamespace NTT {\n    vector<mod_int> roots = {0, 1};\n    vector<int> bit_reverse;\n    int max_size = -1;\n    mod_int root;\n\n    bool is_power_of_two(int n) {\n        return (n & (n - 1)) == 0;\n    }\n\n    int round_up_power_two(int n) {\n        while (n & (n - 1))\n            n = (n | (n - 1)) + 1;\n\n        return max(n, 1);\n    }\n\n    // Given n (a power of two), finds k such that n == 1 << k.\n    int get_length(int n) {\n        assert(is_power_of_two(n));\n        return __builtin_ctz(n);\n    }\n\n    // Rearranges the indices to be sorted by lowest bit first, then second lowest, etc., rather than highest bit first.\n    // This makes even-odd div-conquer much easier.\n    void bit_reorder(int n, vector<mod_int> &values) {\n        if ((int) bit_reverse.size() != n) {\n            bit_reverse.assign(n, 0);\n            int length = get_length(n);\n\n            for (int i = 0; i < n; i++)\n                bit_reverse[i] = (bit_reverse[i >> 1] >> 1) + ((i & 1) << (length - 1));\n        }\n\n        for (int i = 0; i < n; i++)\n            if (i < bit_reverse[i])\n                swap(values[i], values[bit_reverse[i]]);\n    }\n\n    void find_root() {\n        max_size = 1 << __builtin_ctz(MOD - 1);\n        root = 2;\n\n        // Find a max_size-th primitive root of MOD.\n        while (!(root.pow(max_size) == 1 && root.pow(max_size / 2) != 1))\n            root++;\n    }\n\n    void prepare_roots(int n) {\n        if (max_size < 0)\n            find_root();\n\n        assert(n <= max_size);\n\n        if ((int) roots.size() >= n)\n            return;\n\n        int length = get_length(roots.size());\n        roots.resize(n);\n\n        // The roots array is set up such that for a given power of two n >= 2, roots[n / 2] through roots[n - 1] are\n        // the first half of the n-th primitive roots of MOD.\n        while (1 << length < n) {\n            // z is a 2^(length + 1)-th primitive root of MOD.\n            mod_int z = root.pow(max_size >> (length + 1));\n\n            for (int i = 1 << (length - 1); i < 1 << length; i++) {\n                roots[2 * i] = roots[i];\n                roots[2 * i + 1] = roots[i] * z;\n            }\n\n            length++;\n        }\n    }\n\n    void fft_iterative(int N, vector<mod_int> &values) {\n        assert(is_power_of_two(N));\n        prepare_roots(N);\n        bit_reorder(N, values);\n\n        for (int n = 1; n < N; n *= 2)\n            for (int start = 0; start < N; start += 2 * n)\n                for (int i = 0; i < n; i++) {\n                    mod_int even = values[start + i];\n                    mod_int odd = values[start + n + i] * roots[n + i];\n                    values[start + n + i] = even - odd;\n                    values[start + i] = even + odd;\n                }\n    }\n\n    const int FFT_CUTOFF = 150;\n\n    vector<mod_int> mod_multiply(vector<mod_int> left, vector<mod_int> right) {\n        int n = left.size();\n        int m = right.size();\n\n        // Brute force when either n or m is small enough.\n        if (min(n, m) < FFT_CUTOFF) {\n            const uint64_t ULL_BOUND = numeric_limits<uint64_t>::max() - (uint64_t) MOD * MOD;\n            vector<uint64_t> result(n + m - 1, 0);\n\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < m; j++) {\n                    result[i + j] += (uint64_t) ((int) left[i]) * ((int) right[j]);\n\n                    if (result[i + j] > ULL_BOUND)\n                        result[i + j] %= MOD;\n                }\n\n            for (uint64_t &x : result)\n                if (x >= MOD)\n                    x %= MOD;\n\n            return vector<mod_int>(result.begin(), result.end());\n        }\n\n        int N = round_up_power_two(n + m - 1);\n        left.resize(N);\n        right.resize(N);\n\n        bool equal = left == right;\n        fft_iterative(N, left);\n\n        if (equal)\n            right = left;\n        else\n            fft_iterative(N, right);\n\n        mod_int inv_N = mod_int(N).inv();\n\n        for (int i = 0; i < N; i++)\n            left[i] *= right[i] * inv_N;\n\n        reverse(left.begin() + 1, left.end());\n        fft_iterative(N, left);\n        left.resize(n + m - 1);\n        return left;\n    }\n\n    vector<mod_int> mod_power(const vector<mod_int> &v, int exponent) {\n        assert(exponent >= 0);\n        vector<mod_int> result = {1};\n\n        if (exponent == 0)\n            return result;\n\n        for (int k = 31 - __builtin_clz(exponent); k >= 0; k--) {\n            result = mod_multiply(result, result);\n\n            if (exponent >> k & 1)\n                result = mod_multiply(result, v);\n        }\n\n        return result;\n    }\n\n    vector<mod_int> mod_multiply_all(const vector<vector<mod_int>> &polynomials) {\n        if (polynomials.empty())\n            return {1};\n\n        struct compare_size {\n            bool operator()(const vector<mod_int> &x, const vector<mod_int> &y) {\n                return x.size() > y.size();\n            }\n        };\n\n        priority_queue<vector<mod_int>, vector<vector<mod_int>>, compare_size> pq(polynomials.begin(), polynomials.end());\n\n        while (pq.size() > 1) {\n            vector<mod_int> a = pq.top(); pq.pop();\n            vector<mod_int> b = pq.top(); pq.pop();\n            pq.push(mod_multiply(a, b));\n        }\n\n        return pq.top();\n    }\n}\n\n\nint main() {\n    int N;\n    IO::read_int(N);\n    vector<int> P(N);\n\n    for (int &p : P)\n        IO::read_int(p);\n\n    sort(P.begin(), P.end());\n    vector<int> freq(N + 1, 0);\n\n    for (int i = 0, j = 0; i < N; i = j) {\n        while (j < N && P[i] == P[j])\n            j++;\n\n        freq[j - i]++;\n    }\n\n    vector<vector<mod_int>> polynomials;\n\n    for (int e = 1; e <= N; e++)\n        if (freq[e] > 0) {\n            vector<mod_int> poly(e + 1, 1);\n            polynomials.push_back(NTT::mod_power(poly, freq[e]));\n        }\n\n    vector<mod_int> product = NTT::mod_multiply_all(polynomials);\n    cout << product[N / 2] << '\\n';\n}\n   "
    ],
    "input": "",
    "output": "",
    "tags": [
        "divide and conquer",
        "fft",
        "greedy",
        "math",
        "number theory"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Divisor Set.json",
    "editorial_link": "https://codeforces.com//blog/entry/71434",
    "editorial": "The problem consists of two parts: what do we want to calculate and how\r\nto calculate it?What do we want to calculate? There are several ways to\r\nfigure it out. At first, you could have met this problem before and all\r\nyou need is to remember a solution.At second, you can come up with the\r\nsolution in a purely theoretical way Hasse diagram can help with it\r\ngreatly. Letâs define as the number of primes in prime factorization of\r\n. For example, and . If you look at Hasse diagram of you can see that\r\nall divisors with lies on level . If is divisible by then so all\r\ndivisors on the same level donât divide each other. Moreover, the\r\ndiagram somehow symmetrical about its middle level and sizes of levels\r\nare increasing while moving to the middle. It gives us an idea that the\r\nanswer is the size of the middle level, i.e. the number of divisors with\r\n.The final way is just to brute force the answers for small -s and find\r\nthe sequence in OEIS with name A096825, where the needed formulas are\r\ndescribed.The second step is to calculate the number of divisors with .\r\nSuppose we have distinct primes and the number of occurences of is equal\r\nto . Then we need to calculate pretty standard knapsack problem where\r\nyou need to calculate number of ways to choose subset of size where you\r\ncan take each up to times. Or, formally, number of vectors with and\r\n.Calculating the answer using will lead to time limit, so we need to\r\nmake the following transformation. Letâs build for each a polynomial .\r\nNow the answer is just a coefficient before in product . Note, that the\r\nproduct has degree , so we can multiply polynomials efficiently with\r\ninteger FFT in the special order to acquire time complexity.There\r\nseveral ways to choose the order of multiplications. At first, you can,\r\nat each step, choose two polynomials with the lowest degree and multiply\r\nthem. At second, you can use the divide-and-conquer technique by\r\ndividing the current segment in two with pretty same total degrees. At\r\nthird, you can also use D-n-C but divide the segment at halves and, it\r\nseems still to be in total.What about the proof of the solution? Thanks\r\nto tyrion__ for the link at the article:\r\nhttps://pure.tue.nl/ws/files/4373475/597494.pdf.The result complexity is\r\ntime and space (if carefully written). Note, that the hidden constant in\r\ninteger FFT is pretty high and highly depends on the implementation, so\r\nitâs possible for poor implementations not to pass the time limit.\r\n",
    "hint": []
}