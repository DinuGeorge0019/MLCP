{"link": "https://codeforces.com//contest/1279/problem/E", "problemId": "504277", "problem_idx": "E", "shortId": "1279E", "contest_number": "1279", "problem_submissions": {"E": [67737947, 67733364, 67730576, 67739828, 67742536, 67737172, 67724903, 67736976, 67729524, 67727105, 67747837, 67731683, 67732984, 67748535, 67744932], "F": [67737545, 67718265, 67764598, 67761358, 67761175, 67737082, 67725475, 67770261, 67748335, 67724855, 67743206, 67734760, 67745652, 67744739, 67715547, 67721155, 67752838, 67725507, 67753025, 67734101, 67763755, 67725445, 67752215, 67728799, 67734922, 67753488], "D": [67712365, 67710004, 67715225, 67711743, 67720035, 67741233, 67733656, 67738820, 67706683, 67710710, 67712344, 67716189, 67712742, 67717775, 67716646, 67717595, 67717233, 67714949, 67709766], "C": [67708271, 67707793, 67712401, 67706993, 67715784, 67738909, 67733706, 67739694, 67710632, 67708442, 67708816, 67712768, 67706695, 67710203, 67712897, 67713466, 67711730, 67709788, 67706084], "B": [67703572, 67702979, 67708187, 67704555, 67708809, 67737826, 67733752, 67740661, 67706039, 67703968, 67706335, 67709187, 67703627, 67705748, 67708508, 67710463, 67705061, 67706427, 67703535], "A": [67701146, 67701133, 67701117, 67701163, 67704539, 67735636, 67733784, 67741171, 67702120, 67701143, 67701243, 67701332, 67701184, 67701399, 67702929, 67702323, 67701558, 67701229, 67701070]}, "name": "E. New Year Permutations", "statement": ".A permutation of length n is an array of n integers such that every\r\ninteger from 1 to n appears in it exactly once. An element y of\r\npermutation p is reachable from element x if x = y, or p_x = y, or\r\np_{p_x} = y, and so on. The of a permutation p is defined as follows:\r\nfirstly, we have a permutation p, all elements of which are , and an\r\nempty list l. Then we do the following: while there is at least one\r\nelement in p, we find the leftmost such element, list all elements that\r\nare reachable from it , mark all of these elements, then cyclically\r\nshift the list of those elements so that the maximum appears at the\r\nfirst position, and add this list of l. After all elements are marked, l\r\nis the result of this decomposition.For example, if we want to build a\r\ndecomposition of p = [5, 4, 2, 3, 1, 7, 8, 6], we do the following:\r\ninitially p = [5, 4, 2, 3, 1, 7, 8, 6] (bold elements are marked), l =\r\n[]; the leftmost unmarked element is 5; 5 and 1 are reachable from it,\r\nso the list we want to shift is [5, 1]; there is no need to shift it,\r\nsince maximum is already the first element; p = [\r\ntextbf{5}, 4, 2, 3,\r\ntextbf{1}, 7, 8, 6], l = [[5, 1]]; the leftmost unmarked element is 4,\r\nthe list of reachable elements is [4, 2, 3]; the maximum is already the\r\nfirst element, so there\u2019s no need to shift it; p = [\r\ntextbf{5},\r\ntextbf{4},\r\ntextbf{2},\r\ntextbf{3},\r\ntextbf{1}, 7, 8, 6], l = [[5, 1], [4, 2, 3]]; the leftmost unmarked\r\nelement is 7, the list of reachable elements is [7, 8, 6]; we have to\r\nshift it, so it becomes [8, 6, 7]; p = [\r\ntextbf{5},\r\ntextbf{4},\r\ntextbf{2},\r\ntextbf{3},\r\ntextbf{1},\r\ntextbf{7},\r\ntextbf{8},\r\ntextbf{6}], l = [[5, 1], [4, 2, 3], [8, 6, 7]]; all elements are marked,\r\nso [[5, 1], [4, 2, 3], [8, 6, 7]] is the result. The of a permutation is\r\ndefined as follows: we build the decomposition of this permutation; then\r\nwe sort all lists in decomposition in ascending order of the first\r\nelements (we don\u2019t swap the elements in these lists, only the lists\r\nthemselves); then we concatenate the lists into one list which becomes a\r\nnew permutation. For example, the of p = [5, 4, 2, 3, 1, 7, 8, 6] is\r\nbuilt as follows: the decomposition is [[5, 1], [4, 2, 3], [8, 6, 7]];\r\nafter sorting the decomposition, it becomes [[4, 2, 3], [5, 1], [8, 6,\r\n7]]; [4, 2, 3, 5, 1, 8, 6, 7] is the result of the transformation. We\r\ncall a permutation if the result of its transformation is the same as\r\nthe permutation itself. For example, [4, 3, 1, 2, 8, 5, 6, 7] is a good\r\npermutation; and [5, 4, 2, 3, 1, 7, 8, 6] is bad, since the result of\r\ntransformation is [4, 2, 3, 5, 1, 8, 6, 7].Your task is the following:\r\ngiven n and k, find the k-th (lexicographically) good permutation of\r\nlength n.\r\n", "solutions": ["#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n \nusing namespace std;\n \ntypedef long long ll;\n \n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n \nconst int N =50;\nint dsu[N];\n \nint get(int v) {\n  if (v == dsu[v]) {\n    return v;\n  } else {\n    return dsu[v] = get(dsu[v]);\n  }\n}\n \nvoid uni(int u, int v) {\n  dsu[get(u)] = get(v);\n}\n \nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  auto solve = [&] () {\n    int n;\n    ll k;\n    cin >> n >> k;\n    vector <ll> fact(n + 1);\n    fact[0] = 1;\n    ll lim = k + (ll) (1e18);\n    auto mul = [&] (ll a, ll b) {\n      if (a * (long double) b <= lim)\n        return a * b;\n      else\n        return lim;\n    };\n    for (int i = 1; i <= n; i++) {\n      fact[i] = mul(fact[i - 1], i);\n    }\n    vector <ll> decomps(n + 1);\n    vector <ll> values(n + 1);\n    for (int i = 1; i <= n; i++) {\n      if (i == 1) {\n        values[i] = 1;\n      } else {\n        values[i] = fact[i - 2];\n      }\n    }\n    decomps[0] = 1;\n    for (int i = 1; i <= n; i++) {\n      for (int j = 0; j < i; j++) {\n        decomps[i] += mul(decomps[j], values[i - j]);\n        decomps[i] = min(decomps[i], lim);\n      }\n    }\n    k--;\n    if (decomps[n] <= k) {\n      cout << -1 << '\\n';\n      return;\n    }\n    auto gen_cyclic = [&] (int len, ll id, int shift) {\n      for (int i = 0; i < len; i++) {\n        dsu[i] = i;\n      }\n      set <int> q;\n      int pths = len - 1;\n      vector <int> ans;\n      for (int i = 0; i < len; i++) {\n        if (i == 0) {\n          q.insert(len - 1);\n          uni(i, len - 1);\n          ans.push_back(len - 1);\n        } else {\n          for (int j = 0; j < len; j++) {\n            if (!q.count(j) && (get(i) != get(j) || i == len - 1)) {\n              int go = pths;\n              if (values[go] <= id) {\n                id -= values[go];\n              } else {\n                pths--;\n                ans.push_back(j);\n                q.insert(j);\n                uni(i, j);\n                break;\n              }\n            }\n          }\n        }\n      }\n      for (int x : ans) {\n        cout << shift + x + 1 << ' ';\n      }\n    };\n    int x = 0;\n    while (x < n) {\n      for (int len = 1; len <= n - x; len++) {\n        ll value = mul(values[len], decomps[n - x - len]);\n        if (value <= k) {\n          k -= value;\n        } else {\n          ll go = k / decomps[n - x - len];\n          gen_cyclic(len, go, x);\n          k %= decomps[n - x - len];\n          x += len;\n          break;\n        }\n      }\n    }\n    cout << '\\n';\n  };\n  int t;\n  cin >> t;\n  while (t--) {\n    solve();\n  }\n}\n"], "input": "", "output": "", "tags": ["combinatorics", "dp"], "dificulty": "2700", "interactive": false}