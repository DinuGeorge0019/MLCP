{"link": "https://codeforces.com//contest/1661/problem/D", "problemId": "1361830", "problem_idx": "D", "shortId": "1661D", "contest_number": "1661", "problem_submissions": {"F": [153187553, 153195355, 153198079, 153192699, 153208735, 153197140, 153204834, 153209679, 153216895, 153192345, 153209985, 153215287, 153214260, 153206784, 153181924, 153187391, 153499691], "E": [153181602, 153183458, 153186252, 153186023, 153206034, 153195940, 153194023, 153206147, 153218775, 153197839, 153195670, 153202578, 153201319, 153198707, 153201518, 153192938, 153189205, 153195957, 153196511], "D": [153174390, 153174537, 153175638, 153174007, 153176690, 153176745, 153185907, 153182627, 153178744, 153172686, 153190154, 153190396, 153190106, 153210872, 153207891, 153175462, 153176825, 153177570, 153175676], "C": [153170138, 153167530, 153168248, 153169048, 153170259, 153170541, 153168119, 153170774, 153172726, 153194437, 153178130, 153175287, 153185061, 153205419, 153246548, 153215381, 153166182, 153169099, 153168642, 153167758], "B": [153162156, 153162580, 153161952, 153162200, 153164678, 153162918, 153163800, 153162935, 153167883, 153164440, 153162927, 153168126, 153181318, 153200885, 153216655, 153161628, 153165270, 153163647, 153161926], "A": [153160994, 153160951, 153163491, 153160922, 153160942, 153161262, 153161508, 153160985, 153162410, 153161094, 153160862, 153162511, 153178823, 153198439, 153217630, 153160910, 153162727, 153160959, 153160858]}, "name": "D. Progressions Covering", "statement": "You are given two arrays: an array a consisting of n zeros and an array\r\nb consisting of n integers.You can apply the following operation to the\r\narray a an arbitrary number of times: choose some subsegment of a of\r\nlength k and add the arithmetic progression 1, 2,\r\nldots, k to this subsegment i. e. add 1 to the first element of the\r\nsubsegment, 2 to the second element, and so on. The chosen subsegment\r\nshould be inside the borders of the array a (i.e., if the left border of\r\nthe chosen subsegment is l, then the condition 1\r\nle l\r\nle l + k - 1\r\nle n should be satisfied). Note that the progression added is always 1,\r\n2,\r\nldots, k but not the k, k - 1,\r\nldots, 1 or anything else (i.e., the leftmost element of the subsegment\r\nalways increases by 1, the second element always increases by 2 and so\r\non).Your task is to find the possible number of operations required to\r\nsatisfy the condition a_i\r\nge b_i for each i from 1 to n. Note that the condition a_i\r\nge b_i should be satisfied for all elements at once.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  int n, k;\n  cin >> n >> k;\n  vector<long long> b(n);\n  for (int i = 0; i < n; i++){\n    cin >> b[i];\n  }\n  reverse(b.begin(), b.end());\n  vector<long long> imos_a(n + 1, 0), imos_b(n + 1, 0);\n  long long ans = 0;\n  for (int i = 0; i <= n - k; i++){\n    b[i] -= imos_a[i] * i + imos_b[i];\n    if (b[i] > 0){\n      long long cnt = (b[i] + k - 1) / k;\n      ans += cnt;\n      imos_a[i] -= cnt;\n      imos_a[i + k] += cnt;\n      imos_b[i] += cnt * (k + i);\n      imos_b[i + k] -= cnt * (k + i);\n    }\n    imos_a[i + 1] += imos_a[i];\n    imos_b[i + 1] += imos_b[i];\n  }\n  long long mx = 0;\n  for (int i = n - k + 1; i < n; i++){\n    b[i] -= imos_a[i] * i + imos_b[i];\n    if (b[i] > 0){\n      mx = max(mx, (b[i] + n - i - 1) / (n - i));\n    }\n    imos_a[i + 1] += imos_a[i];\n    imos_b[i + 1] += imos_b[i];\n  }\n  cout << ans + mx << endl;\n}"], "input": "", "output": "", "tags": ["data structures", "greedy"], "dificulty": "1900", "interactive": false}