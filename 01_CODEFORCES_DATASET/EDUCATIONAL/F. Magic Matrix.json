{
    "link": "https://codeforces.com//contest/632/problem/F",
    "problemId": "50148",
    "problem_idx": "F",
    "shortId": "632F",
    "contest_number": "632",
    "problem_submissions": {
        "F": [
            16449954,
            16449774,
            16448025,
            16447543,
            16474130,
            16447469,
            16465805,
            16465734,
            16449676,
            16449356,
            16449961,
            16450068,
            16557410,
            16449769,
            16450214,
            16449702,
            16464012
        ],
        "E": [
            16447028,
            16449753,
            16445979,
            16453840,
            16453803,
            16448350,
            16447568,
            16449040,
            16605043,
            16448762,
            16447224,
            16448913,
            16449761,
            128072075,
            44908882,
            16457507
        ],
        "D": [
            16446074,
            16445153,
            16444353,
            16454357,
            16446366,
            16445038,
            16445634,
            16444742,
            16453325,
            16445984,
            16447854,
            16446133,
            16445283,
            16446954,
            16447982,
            16445318,
            16444664,
            16445724
        ],
        "C": [
            16444421,
            16444120,
            16443606,
            16443645,
            16445009,
            16444221,
            16444738,
            16443779,
            16445075,
            16444107,
            16445524,
            16449207,
            16450843,
            16448580,
            16448209,
            16447449,
            16444580,
            16444579,
            16443960,
            16444153,
            24720150,
            24720135
        ],
        "B": [
            16443783,
            16443777,
            16443815,
            16443887,
            16444524,
            16444113,
            16444187,
            16451169,
            16443637,
            16443942,
            16443903,
            16444676,
            16444341,
            16444136,
            16444765,
            16447115,
            16444024,
            16443821,
            16443819
        ],
        "A": [
            16443584,
            16443594,
            16443558,
            16443577,
            16443765,
            16443750,
            16443746,
            16445513,
            16443626,
            16443702,
            16443955,
            16443808,
            16443676,
            16444067,
            16446687,
            16443663,
            16443559,
            16443628
        ]
    },
    "name": "F. Magic Matrix",
    "statement": "You\u2019re given a matrix of size .Let\u2019s call the matrix with nonnegative\r\nelements magic if it is symmetric (so ), and for all triples . Note that\r\ndo not need to be distinct.Determine if the matrix is magic.As the\r\ninput/output can reach very huge size it is recommended to use fast\r\ninput/output methods: for example, prefer to use instead of in C++,\r\nprefer to use instead of in .\r\n",
    "solutions": [
        "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <ctime>\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\nll P;\nconst ll M1 = 1000000007;\nconst ll M2 = 1000000009;\nint n;\nint a[2510][2510];\nint b[2510 * 2510];\nint vvc = 0;\nint vv[3500000];\nll pw1[2510];\nll pw2[2510];\n\n\nbool cmp(int x, int y) {\n\treturn b[x] > b[y];\n}\n\nstruct hs {\n\tll a, b;\n\tbool operator==(const hs& x) {\n\t\treturn a == x.a && b == x.b;\n\t}\n};\n\n\nhs hsh[2510];\n\nvoid add(int x, int y, int a) {\n\thsh[x].a += pw1[y] * a;\n\thsh[x].a %= M1;\n\thsh[x].b += pw2[y] * a;\n\thsh[x].b %= M2;\n}\n\nint main() {\n\tsrand(time(NULL));\n\tP = rand() % (1000000000 - 100000000) + 10000000;\n\tscanf(\"%d\", &n);\n\tpw1[0] = 1;\n\tpw2[0] = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tpw1[i + 1] = (pw1[i] * P) % M1;\n\t\tpw2[i + 1] = (pw2[i] * P) % M2;\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j)\n\t\t\tscanf(\"%d\", &a[i][j]), b[i * n + j] = a[i][j];\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (a[i][j] != a[j][i]) {\n\t\t\t\tcout << \"NOT MAGIC\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (a[i][i] != 0) {\n\t\t\t\tcout << \"NOT MAGIC\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = i + 1; j < n; ++j)\n\t\t\tvv[vvc++] = i * n + j;\n\n\tsort(vv, vv + vvc, cmp);\n\t\n\tint cnt = 1;\n\tint lst = 0;\n\tfor (int i = 0; i < vvc; ++i) {\n\t\tint x = vv[i] / n;\n\t\tint y = vv[i] % n;\n\t\tif (!(hsh[x] == hsh[y])) {\n\t\t\tcout << \"NOT MAGIC\\n\";\n\t\t\treturn 0;\n\t\t}\n\t\tif (i == vvc - 1 || b[vv[i]] != b[vv[i + 1]]) {\n\t\t\tfor (int j = lst; j <= i; ++j) {\n\t\t\t\tint x = vv[j] / n;\n\t\t\t\tint y = vv[j] % n;\n\t\t\t\tadd(x, y, cnt);\n\t\t\t\tadd(y, x, cnt);\n\t\t\t}\n\t\t\t++cnt;\n\t\t\tlst = i + 1;\n\t\t}\n\t}\n\n\tcout << \"MAGIC\\n\";\n\n\treturn 0;\n}\n\n\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "divide and conquer",
        "graphs",
        "matrices",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Magic Matrix.json",
    "editorial_link": "https://codeforces.com//blog/entry/43493",
    "editorial": "The problem was suggested by Lewin Gan Lewin. The solution and proof\r\nalso belongs to him. Consider the undirected complete graph with nodes,\r\nwith an edge between nodes with cost . Let denote the minimum possible\r\nvalue of the max edge of a path from to . We know that by definition. If\r\nthe matrix is magic, we can choose arbitrary such that by repeating\r\ninvocations of the inequality given. Also, you can show that if this\r\ninequality is satisfied, then the matrix is magic (by choosing an and\r\narbitrary). So, this shows that the matrix is magic if and only if .\r\nThus, combining with , we have . We need a fast way to compute for all\r\npairs . This can be computed as the MST, as the path in the MST\r\nminimizes the max edge between all pairs of nodes. So, the algorithm\r\nworks as follows. First, find the MST on the complete graph. Then, the\r\nmatrix is magic if and only if the max edge on the path between in the\r\nMST is exactly equal to . Also you shouldn\u00e2\u0080\u0099t forget to check symmetry of\r\nthe matrix and diagonal for zeros. P.S.: Unfortunately we couldn\u00e2\u0080\u0099t\r\nincrease the value in this problem: the tests already had the size about\r\n67MB and they couldn\u00e2\u0080\u0099t be given with generator. So most of the users who\r\nsolved this problem uses bitset-s. The complexity of their solution is ,\r\nwhere or . C++ solution, binary lifts by me. Java solution by Lewin.\r\nComplexity: or .\r\n"
}