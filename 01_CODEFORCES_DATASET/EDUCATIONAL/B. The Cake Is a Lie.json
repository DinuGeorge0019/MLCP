{
    "link": "https://codeforces.com//contest/1519/problem/B",
    "problemId": "971587",
    "problem_idx": "B",
    "shortId": "1519B",
    "contest_number": "1519",
    "problem_submissions": {
        "C": [
            114616470,
            114551329,
            114551180,
            114564495,
            114550309,
            114552694,
            114547702,
            114548020,
            114553618,
            114563241,
            114559641,
            114555665,
            114557042,
            114556787,
            114554939,
            114556558,
            114555376,
            114549327,
            114552625,
            114552238,
            114554684,
            114559315
        ],
        "F": [
            114613463,
            114611288,
            114604337,
            114598897,
            114611467,
            114680142,
            114636104,
            114635840
        ],
        "E": [
            114607966,
            114580590,
            114575288,
            114583294,
            114570654,
            114566689,
            114580490,
            114581344,
            114581275,
            114584747,
            114587745,
            114586133,
            114587347,
            114590609,
            114592573,
            114589054,
            114601871,
            114596259,
            114594317,
            114625207,
            114625166,
            114600206,
            114595857
        ],
        "D": [
            114555495,
            114555902,
            114567847,
            114556972,
            114556567,
            114552424,
            114552771,
            114561234,
            114544188,
            114558776,
            114560835,
            114564971,
            114561515,
            114561300,
            114565333,
            114554107,
            114558569,
            114558286,
            114563876,
            114568526
        ],
        "B": [
            114542697,
            114545137,
            114558022,
            114545565,
            114550455,
            114542163,
            114542842,
            114545295,
            114550992,
            114551627,
            114546744,
            114549467,
            114548090,
            114544402,
            114547969,
            114543205,
            114546111,
            114545907,
            114546890,
            114546969
        ],
        "A": [
            114541604,
            114541862,
            114551019,
            114541996,
            114541593,
            114541608,
            114541607,
            114541640,
            114546683,
            114543589,
            114543013,
            114543817,
            114542361,
            114541678,
            114541836,
            114541598,
            114541959,
            114541646,
            114541768,
            114542287
        ]
    },
    "name": "B. The Cake Is a Lie",
    "statement": "There is a n\r\ntimes m grid. You are standing at cell (1, 1) and your goal is to finish\r\nat cell (n, m).You can move to the neighboring cells to the right or\r\ndown. In other words, suppose you are standing at cell (x, y). You can:\r\nmove right to the cell (x, y + 1) it costs x burles; move down to the\r\ncell (x + 1, y) it costs y burles. Can you reach cell (n, m) spending k\r\nburles?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int64_t N, M, K;\n    cin >> N >> M >> K;\n    cout << (K == N * M - 1 ? \"YES\" : \"NO\") << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp",
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. The Cake Is a Lie.json",
    "editorial_link": "https://codeforces.com//blog/entry/90212",
    "editorial": "Note that whichever path you choose, the total cost will be the same. If\r\nyou know that the cost is the same, then it\u00e2\u0080\u0099s not hard to calculate it.\r\nIt\u00e2\u0080\u0099s equal to . So the task is to check: is equal to or not.The constant\r\ncost may be proved by induction on : for cost is . For a fixed , there\r\nare only two last steps you can make: either from with cost : the total\r\ncost is or from with cost : the total cost is . So, whichever path you\r\nchoose, the total cost is the same.\r\n"
}