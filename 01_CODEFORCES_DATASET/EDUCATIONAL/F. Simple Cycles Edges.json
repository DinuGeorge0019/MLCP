{"link": "https://codeforces.com//contest/962/problem/F", "problemId": "173207", "problem_idx": "F", "shortId": "962F", "contest_number": "962", "problem_submissions": {"G": [37172159, 83380479, 37224207], "F": [37161607, 37156639, 37157368, 37160858, 37168373, 37163241, 37162662, 37165808, 37164621, 37171463, 37169577, 37166104, 37163342, 37173342, 37165989, 37161726, 37173135, 37178620], "E": [37153541, 37151735, 37153606, 37152970, 37152043, 37166043, 37160792, 37170495, 37160553, 37168665, 37158596, 37163761, 37162634, 37170755, 37158513, 37157137, 37165223, 37172878, 37170948, 37159083, 37152437], "D": [37152390, 37151214, 37151627, 37153937, 37156427, 37155745, 37155575, 37154679, 37154153, 37157155, 37157760, 37157154, 37160470, 37158892, 37157799, 37158412, 37156233, 37151441], "C": [37150680, 37149822, 37150471, 37152075, 37154129, 37152922, 37153000, 37151382, 37151999, 37153115, 37152133, 37154853, 37152337, 37154136, 37153887, 37154222, 37150166], "B": [37148859, 37148433, 37150807, 37150329, 37150353, 37151339, 37150005, 37149509, 37149604, 37150809, 37150669, 37150725, 37163838, 37150528, 37151572, 37173974, 37149032], "A": [37147366, 37147343, 37147362, 37147371, 37147659, 37147394, 37147434, 37147365, 37147570, 37147605, 37147447, 37147530, 37147430, 37147619, 37147410, 37174371, 37147400]}, "name": "F. Simple Cycles Edges", "statement": "You are given an undirected graph, consisting of n vertices and m edges.\r\nThe graph does not necessarily connected. Guaranteed, that the graph\r\ndoes not contain multiple edges (more than one edges between a pair of\r\nvertices) or loops (edges from a vertex to itself).A cycle in a graph is\r\ncalled a simple, if it contains each own vertex exactly once. So simple\r\ncycle doesn\u2019t allow to visit a vertex more than once in a\r\ncycle.Determine the edges, which belong to simple cycle.\r\n", "solutions": ["#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<double,double> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntemplate<int SZ> struct BCC {\n    int N, ti = 0;\n    vi adj[SZ];\n    int disc[SZ], low[SZ], comp[SZ], par[SZ];\n    vector<vpi> fin;\n    vpi st, bridge;\n    \n    void addEdge(int u, int v) {\n        adj[u].pb(v), adj[v].pb(u);\n    }\n    \n    void BCCutil(int u) {\n        disc[u] = low[u] = ti++;\n        int child = 0;\n        \n        for (int i: adj[u]) if (i != par[u]) {\n            if (disc[i] == -1) {\n                child ++; par[i] = u;\n                st.pb({u,i});\n                BCCutil(i);\n                low[u] = min(low[u],low[i]);\n                \n                if (disc[u] < low[i]) {\n                    bridge.pb({u,i});\n                }\n                \n                if ((disc[u] == 0 && child > 1) || (disc[u] != 0 && disc[u] <= low[i])) { // articulation point!\n                    vector<pi> tmp;\n                    while (st.back() != mp(u,i)) tmp.pb(st.back()), st.pop_back();\n                    tmp.pb(st.back()), st.pop_back();\n                    fin.pb(tmp);\n                }\n            } else if (disc[i] < disc[u]) {\n                low[u] = min(low[u],disc[i]);\n                st.pb({u,i});\n            }\n        }\n    }\n    \n    void bcc() {\n        FOR(i,1,N+1) par[i] = disc[i] = low[i] = -1;\n        FOR(i,1,N+1) if (disc[i] == -1) {\n            BCCutil(i);\n            if (sz(st)) fin.pb(st);\n            st.clear();\n        }\n    }\n};\n\nBCC<MX> B;\nbool visit[MX];\nvi ans;\nset<int> cedge;\nmap<pi,int> bri, M;\nint numVert;\n\nvoid dfs(int ind) {\n    if (visit[ind]) return;\n    visit[ind] = 1; numVert ++;\n    for (int i: B.adj[ind]) if (!bri.count({ind,i}))  {\n        dfs(i);\n        cedge.insert(M[{ind,i}]);\n    }\n}\n\nint n,m;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    B.N = n;\n    FOR(i,1,m+1) {\n        int a,b; cin >> a >> b;\n        M[{a,b}] = M[{b,a}] = i;\n        B.addEdge(a,b);\n    }\n    B.bcc();\n    for (auto a: B.fin) {\n        set<int> cur; for (auto b: a) cur.insert(b.f), cur.insert(b.s);\n        if (sz(cur) == sz(a)) {\n            for (auto z: a) ans.pb(M[z]);\n        }\n    }\n    sort(all(ans));\n    cout << sz(ans) << \"\\n\";\n    for (int i: ans) cout << i << \" \";\n}\n\n// read the question correctly (is y a vowel?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"], "input": "", "output": "", "tags": ["dfs and similar", "graphs", "trees"], "dificulty": "2400", "interactive": false}