{
    "link": "https://codeforces.com//contest/962/problem/F",
    "problemId": "173207",
    "problem_idx": "F",
    "shortId": "962F",
    "contest_number": "962",
    "problem_submissions": {
        "G": [
            37172159,
            83380479,
            37224207
        ],
        "F": [
            37161607,
            37156639,
            37157368,
            37160858,
            37168373,
            37163241,
            37162662,
            37165808,
            37164621,
            37171463,
            37169577,
            37166104,
            37163342,
            37173342,
            37165989,
            37161726,
            37173135,
            37178620
        ],
        "E": [
            37153541,
            37151735,
            37153606,
            37152970,
            37152043,
            37166043,
            37160792,
            37170495,
            37160553,
            37168665,
            37158596,
            37163761,
            37162634,
            37170755,
            37158513,
            37157137,
            37165223,
            37172878,
            37170948,
            37159083,
            37152437
        ],
        "D": [
            37152390,
            37151214,
            37151627,
            37153937,
            37156427,
            37155745,
            37155575,
            37154679,
            37154153,
            37157155,
            37157760,
            37157154,
            37160470,
            37158892,
            37157799,
            37158412,
            37156233,
            37151441
        ],
        "C": [
            37150680,
            37149822,
            37150471,
            37152075,
            37154129,
            37152922,
            37153000,
            37151382,
            37151999,
            37153115,
            37152133,
            37154853,
            37152337,
            37154136,
            37153887,
            37154222,
            37150166
        ],
        "B": [
            37148859,
            37148433,
            37150807,
            37150329,
            37150353,
            37151339,
            37150005,
            37149509,
            37149604,
            37150809,
            37150669,
            37150725,
            37163838,
            37150528,
            37151572,
            37173974,
            37149032
        ],
        "A": [
            37147366,
            37147343,
            37147362,
            37147371,
            37147659,
            37147394,
            37147434,
            37147365,
            37147570,
            37147605,
            37147447,
            37147530,
            37147430,
            37147619,
            37147410,
            37174371,
            37147400
        ]
    },
    "name": "F. Simple Cycles Edges",
    "statement": "You are given an undirected graph, consisting of n vertices and m edges.\r\nThe graph does not necessarily connected. Guaranteed, that the graph\r\ndoes not contain multiple edges (more than one edges between a pair of\r\nvertices) or loops (edges from a vertex to itself).A cycle in a graph is\r\ncalled a simple, if it contains each own vertex exactly once. So simple\r\ncycle doesnâ€™t allow to visit a vertex more than once in a\r\ncycle.Determine the edges, which belong to simple cycle.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<double,double> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\n\ntemplate<int SZ> struct BCC {\n    int N, ti = 0;\n    vi adj[SZ];\n    int disc[SZ], low[SZ], comp[SZ], par[SZ];\n    vector<vpi> fin;\n    vpi st, bridge;\n    \n    void addEdge(int u, int v) {\n        adj[u].pb(v), adj[v].pb(u);\n    }\n    \n    void BCCutil(int u) {\n        disc[u] = low[u] = ti++;\n        int child = 0;\n        \n        for (int i: adj[u]) if (i != par[u]) {\n            if (disc[i] == -1) {\n                child ++; par[i] = u;\n                st.pb({u,i});\n                BCCutil(i);\n                low[u] = min(low[u],low[i]);\n                \n                if (disc[u] < low[i]) {\n                    bridge.pb({u,i});\n                }\n                \n                if ((disc[u] == 0 && child > 1) || (disc[u] != 0 && disc[u] <= low[i])) { // articulation point!\n                    vector<pi> tmp;\n                    while (st.back() != mp(u,i)) tmp.pb(st.back()), st.pop_back();\n                    tmp.pb(st.back()), st.pop_back();\n                    fin.pb(tmp);\n                }\n            } else if (disc[i] < disc[u]) {\n                low[u] = min(low[u],disc[i]);\n                st.pb({u,i});\n            }\n        }\n    }\n    \n    void bcc() {\n        FOR(i,1,N+1) par[i] = disc[i] = low[i] = -1;\n        FOR(i,1,N+1) if (disc[i] == -1) {\n            BCCutil(i);\n            if (sz(st)) fin.pb(st);\n            st.clear();\n        }\n    }\n};\n\nBCC<MX> B;\nbool visit[MX];\nvi ans;\nset<int> cedge;\nmap<pi,int> bri, M;\nint numVert;\n\nvoid dfs(int ind) {\n    if (visit[ind]) return;\n    visit[ind] = 1; numVert ++;\n    for (int i: B.adj[ind]) if (!bri.count({ind,i}))  {\n        dfs(i);\n        cedge.insert(M[{ind,i}]);\n    }\n}\n\nint n,m;\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    B.N = n;\n    FOR(i,1,m+1) {\n        int a,b; cin >> a >> b;\n        M[{a,b}] = M[{b,a}] = i;\n        B.addEdge(a,b);\n    }\n    B.bcc();\n    for (auto a: B.fin) {\n        set<int> cur; for (auto b: a) cur.insert(b.f), cur.insert(b.s);\n        if (sz(cur) == sz(a)) {\n            for (auto z: a) ans.pb(M[z]);\n        }\n    }\n    sort(all(ans));\n    cout << sz(ans) << \"\\n\";\n    for (int i: ans) cout << i << \" \";\n}\n\n// read the question correctly (is y a vowel?)\n// look out for SPECIAL CASES (n=1?) and overflow (ll vs int?)"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dfs and similar",
        "graphs",
        "trees"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Simple Cycles Edges.json",
    "editorial_link": "https://codeforces.com//blog/entry/58869",
    "editorial": "To solve this problem, it is good to know about .Briefly, in the graph\r\nit is easy to select such a minimal set of cycles that any other cycle\r\ncan be obtained as XOR of some subset of cycles from . This set is also\r\ncalled the fundamental set of cycles. To find it in a connected graph,\r\nyou can find any carcass and, alternately, independently add to this\r\ncarcass each of the edges that are not entered into it. When each such\r\nedge is added to the carcass, its cycle closes. The set of these cycles\r\nis a fundamental set of cycles. Thus, if the graph is connected, then\r\nthe size of the fundamental set of cycles is exactly .It is easy to see\r\nthat if an edge belongs to exactly one cycle from the fundamental set of\r\ncycles, then it belongs to exactly one simple cycle.We solve the problem\r\nindependently for each connected component. For a connected component,\r\nit finds its carcass by a search in depth, and each edge that does not\r\nenter the search tree into the depth will close a cycle. We only take\r\ninto account those cycles that do not intersect along the edges. We\r\nshould print only them in the form of a set of edges.If the carcass was\r\nbuilt with a search in depth, then each cycle represents a path from the\r\nvertex to the child (plus the reverse edge). Thus, the problem now is: a\r\nset of pairs of vertices (a vertex and its descendant) that specify a\r\nset of paths from top to bottom is given in the tree. It is required to\r\nselect those paths that do not intersect with any other paths from this\r\nset.To find such ways quickly it is possible with help of DSU (system of\r\nnon-intersecting subsets) on paths. On the edge, you should store the -1\r\nmark or the path number to which it belongs. When passing the edges\r\nwithout marking, it should be marked by this path. When passing an edge\r\nwith a mark, it is necessary to merge two paths into the DSU, because\r\nthey intersect. After processing the path, for all the vertices of the\r\npath, the ancestor should be reassign to the top vertex of the path.\r\nBecause if we do not make this we will repeatedly go through the same\r\npath.Using the following code, we find for each vertex its depth in the\r\ndepth search tree and all the back edges (an array ):void dfs(int u, int\r\npu, int d) { dep[u] = d; color[u] = 1; p[u] = pu; for (int v: g[u]) { if\r\n(v == pu) continue; if (p[v] == -1) dfs(v, u, d + 1); else if (color[v]\r\n== 1) be.push_back({u, v}); } color[u] = 2;}Using the following code, we\r\nprocess all paths (actually cycles), merging the intersecting ones.pp =\r\np;k = be.size();for (int i = 0; i < k; i++) { int x = be[i].first;\r\nvector<int> path; while (dep[x] > dep[be[i].second]) {\r\npath.push_back(x); if (index[x] == -1) index[x] = i; else unite(i,\r\nindex[x]); // DSU x = p[x]; } for (auto j: path) p[j] =\r\nbe[i].second;}Let it is an original array of ancestors in depth search\r\ntree (because array has been changed by the code above). Now, it is\r\nsufficient to the answer to take such paths plus the corresponding\r\nreverse edge that do not intersect with others (that is, the size of the\r\nDSU component is 1):vector<int> sizes(k);for (int i = 0; i < k; i++)\r\nsizes[leader(i)]++;set<int> result;for (int i = 0; i < be.size(); i++)\r\nif (sizes[i] == 1) { result.insert(e[{be[i]}]); int x = be[i].first;\r\nwhile (x != be[i].second) { result.insert(e[{x, pp[x]}]); x = pp[x]; }\r\n}This problem has another solution, based on the allocation of the\r\ndoubly connected components with the help of the corresponding linear\r\nalgorithm.\r\n",
    "hint": []
}