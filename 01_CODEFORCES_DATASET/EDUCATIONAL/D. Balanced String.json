{
    "link": "https://codeforces.com//contest/1860/problem/D",
    "problemId": "2169700",
    "problem_idx": "D",
    "shortId": "1860D",
    "contest_number": "1860",
    "problem_submissions": {
        "F": [
            219298549,
            219320447,
            219349019,
            219323121,
            219334429,
            219337442,
            219335056,
            219339341,
            219339231,
            219349246,
            219345811,
            219439688,
            219439045,
            219356857,
            219353864,
            219402976,
            219353456,
            219351823
        ],
        "E": [
            219277150,
            219281408,
            219287269,
            219300383,
            219293770,
            219301781,
            219289069,
            219306188,
            219288291,
            219288789,
            219301050,
            219298191,
            219305638,
            219306388,
            219300992,
            219313680,
            219301529,
            219309490,
            219305863,
            219309540,
            219307800
        ],
        "D": [
            219271388,
            219273923,
            219270716,
            219286342,
            219405254,
            219345669,
            219344552,
            219277413,
            219284438,
            219280247,
            219290826,
            219278202,
            219277998,
            219274616,
            219275328,
            219282484,
            219281832,
            219279471,
            219288325,
            219282155,
            219284217,
            219287012,
            219287888
        ],
        "C": [
            219264168,
            219264568,
            219266116,
            219265339,
            219269044,
            219276912,
            219269876,
            219279690,
            219266598,
            219268637,
            219263040,
            219261658,
            219264629,
            219267625,
            219267964,
            219267177,
            219271968,
            219274243,
            219264405,
            219273316
        ],
        "B": [
            219260635,
            219258799,
            219260447,
            219259349,
            219260950,
            219267717,
            219262012,
            219271581,
            219260726,
            219261008,
            219259442,
            219257734,
            219259759,
            219262401,
            219260169,
            219259084,
            219263649,
            219264522,
            219272480,
            219264690
        ],
        "A": [
            219257237,
            219257029,
            219257674,
            219257720,
            219257171,
            219258923,
            219257078,
            219260398,
            219257258,
            219257446,
            219257236,
            219256961,
            219257126,
            219257819,
            219257229,
            219257120,
            219257449,
            219257142,
            219257016,
            219258968
        ]
    },
    "name": "D. Balanced String",
    "statement": "You are given a binary string s (a binary string is a string consisting\r\nof characters and/or ).Let\u2019s call a binary string if the number of\r\nsubsequences (the number of indices i and j such that 1\r\nle i < j\r\nle n, s_i=0 and s_j=1) equals to the number of subsequences (the number\r\nof indices k and l such that 1\r\nle k < l\r\nle n, s_k=1 and s_l=0) in it.For example, the string is balanced,\r\nbecause both the number of subsequences and the number of subsequences\r\nare equal to 6. On the other hand, is not balanced, because the number\r\nof subsequences is 1, but the number of subsequences is 5. You can\r\nperform the following operation any number of times: choose two\r\ncharacters in s and swap them. Your task is to calculate the minimum\r\nnumber of operations to make the string s balanced.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr int inf = 1E9;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    std::string s;\n    std::cin >> s;\n    \n    int n = s.size();\n    \n    int c1 = std::count(s.begin(), s.end(), '1'), c0 = n - c1;\n    \n    int need = (n * (n - 1) / 2 - c0 * (c0 - 1) / 2 + c1 * (c1 - 1) / 2) / 2;\n    \n    std::vector dp(c1 + 1, std::vector<int>(need + 1, inf));\n    dp[0][0] = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = c1 - 1; j >= 0; j--) {\n            for (int k = 0; k + i <= need; k++) {\n                dp[j + 1][k + i] = std::min(dp[j + 1][k + i], dp[j][k] + (s[i] == '0'));\n            }\n        }\n    }\n    std::cout << dp[c1][need] << \"\\n\";\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "dp"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Balanced String.json",
    "editorial_link": "https://codeforces.com//blog/entry/119504",
    "editorial": "Let\u00e2\u0080\u0099s calculate the following dynamic programming: the minimum number of\r\nchanges in string if we consider only first characters of it, the number\r\nof characters on that prefix is , and the number of subsequences on that\r\nprefix is equal to .The transitions are pretty simple. Let\u00e2\u0080\u0099s look at the\r\ntransitions according to the character we are trying to place at the\r\nnext position: if it is , then there is transition from the state to the\r\nstate and the value of depends on (the value stays the same if , and\r\nincreases by otherwise); if it is , then there is transition from the\r\nstate to the state , and the value of depends on (the value stays the\r\nsame if and increases by otherwise). So, this dynamic programming works\r\nin .It remains us to get the answer to the problem from that dynamic\r\nprogramming. It is stored in , where is equal to the number of\r\ncharacters in the string , and (because the number of subsequences\r\nshould be equal to the number of subsequences ). But our dynamic\r\nprogramming stores the number of changes in the string, and the problems\r\nasks for the minimum number of swaps. However, we can easily get it from\r\nthe value. Since the amounts of zeroes and ones are fixed in the string,\r\nthen the number of changes from to equals to the number of changes from\r\nto and we can pair them up. So, the answer to the problem is the half of\r\nthe value.\r\n"
}