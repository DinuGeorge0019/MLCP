{
    "link": "https://codeforces.com//contest/1680/problem/B",
    "problemId": "1398256",
    "problem_idx": "B",
    "shortId": "1680B",
    "contest_number": "1680",
    "problem_submissions": {
        "F": [
            157047850,
            157060684,
            157042836,
            157059615,
            157060798,
            158084238,
            157065404,
            157062967,
            157061917,
            157070522,
            157068911,
            157063520,
            157068892,
            157055321,
            157070359,
            157059828,
            157067724,
            157073079,
            157081810,
            157079385,
            157105181
        ],
        "E": [
            157041040,
            157049624,
            157047687,
            157040462,
            157036732,
            157047646,
            157052435,
            157048797,
            157052165,
            157051933,
            157052874,
            157059209,
            157046788,
            157045330,
            157056328,
            157052190,
            157048507,
            157050045,
            157051601,
            157048385
        ],
        "D": [
            157034306,
            157035182,
            157038681,
            157048294,
            158084226,
            157074494,
            157044699,
            157036339,
            157047488,
            157040348,
            157044725,
            157050170,
            157047151,
            157062708,
            157050690,
            157073571,
            157048489,
            157064425,
            157042063,
            157043656,
            157043396,
            157043910
        ],
        "C": [
            157027102,
            157026046,
            157029273,
            157029023,
            158084216,
            157023897,
            157025338,
            157028892,
            157029198,
            157031553,
            157033288,
            157030228,
            157028759,
            157029727,
            157032895,
            157036498,
            157043784,
            157026230,
            157030697,
            157031960,
            157038763
        ],
        "B": [
            157018674,
            157018124,
            157022874,
            157018932,
            157018732,
            157019545,
            157018987,
            157019892,
            157025559,
            157018220,
            157022589,
            157021909,
            157021994,
            157021310,
            157023912,
            157020972,
            157018915,
            157021224,
            157020613,
            157022918
        ],
        "A": [
            157018002,
            157017909,
            157018617,
            157017994,
            157017953,
            157018014,
            157018037,
            157018035,
            157019519,
            157017930,
            157031859,
            157018590,
            157019204,
            157018082,
            157018046,
            157018257,
            157017944,
            157018274,
            157018303,
            157018968
        ]
    },
    "name": "B. Robots",
    "statement": "There is a field divided into n rows and m columns. Some cells are empty\r\n(denoted as ), other cells contain robots (denoted as ).You can send a\r\ncommand to at the same time. The command can be of one of the four\r\ntypes: move up; move right; move down; move left. When you send a\r\ncommand, attempt to take one step in the direction you picked. If a\r\nrobot tries to move outside the field, it explodes; otherwise, moves to\r\nan adjacent cell in the chosen direction.You can send as many commands\r\nas you want (possibly, zero), in any order. Your goal is to make at\r\nleast one robot reach the upper left corner of the field. Can you do\r\nthis without forcing any of the robots to explode?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nvoid solve(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<string> s(n);\n\tfor(string& x : s) cin >> x;\n\tint rx = -1, ry = -1;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < m; j++){\n\t\t\tif(s[i][j] == 'E') continue;\n\t\t\tif(rx == -1){\n\t\t\t\trx = i;\n\t\t\t\try = j;\n\t\t\t}\n\t\t\tif(i < rx || j < ry){\n\t\t\t\tcout << \"NO\" << '\\n';\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"YES\" << '\\n';\n}\n\nint main(){\n\tios_base::sync_with_stdio(false), cin.tie(nullptr);\n\tint T;\n\tcin >> T;\n\twhile(T--) solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "implementation"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Robots.json",
    "editorial_link": "https://codeforces.com//blog/entry/102852",
    "editorial": "Let\u00e2\u0080\u0099s assume that the rows are numbered from to from top to bottom, and\r\ncolumns are numbered from to from left to right. If there is no robot in\r\nthe cell initially, we have to perform several moves up and/or left. If\r\nthe first row with at least one robot is the -th row, then we can make\r\nat most steps up (and we should do at least steps up, since otherwise\r\nthere will me no robot in the upper row). Similarly, if the first column\r\nwith at least one robot is the -th column, then we can make at most\r\nsteps to the left (and we should do at least steps to the left, since\r\notherwise there will me no robot in the leftmost column).Now there are\r\ntwo possible solutions, both starting with finding and : we afterwards\r\neither simulate moves up and moves to the left and check that everything\r\nis fine, or just check that there is a robot in the cell (since only\r\nthis robot can end up in ).\r\n"
}