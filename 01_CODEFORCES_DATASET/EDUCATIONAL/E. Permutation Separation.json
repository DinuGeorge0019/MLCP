{
    "link": "https://codeforces.com//contest/1295/problem/E",
    "problemId": "526704",
    "problem_idx": "E",
    "shortId": "1295E",
    "contest_number": "1295",
    "problem_submissions": {
        "F": [
            69765027,
            69766931,
            69774700,
            69768602,
            69856768,
            69855408,
            69855407,
            69855207,
            69795000,
            69794801,
            69794791,
            69780998,
            70134503,
            69764574,
            69774965,
            69768972,
            69767605,
            69764218,
            69774776,
            69773934,
            69777915,
            69775661,
            69780279,
            69776002,
            69772429,
            69771368,
            69777730,
            69779043
        ],
        "E": [
            69754267,
            69756231,
            69750419,
            69758264,
            75026655,
            75026651,
            75026616,
            75026614,
            75026605,
            75026602,
            69861069,
            69860763,
            69796506,
            69751804,
            70134450,
            69755652,
            69754935,
            69757172,
            69759455,
            69762033,
            69761392,
            69761807,
            69764886,
            69763394,
            69762971,
            69754925,
            69778394,
            69762618,
            69760940
        ],
        "D": [
            69749184,
            69749435,
            69737870,
            69746208,
            69740901,
            70134431,
            69750756,
            69745336,
            69774454,
            69751512,
            69748972,
            69748437,
            69750220,
            69755333,
            69757518,
            69754451,
            69753242,
            69748833,
            69755501,
            69757780,
            69749229
        ],
        "C": [
            69746419,
            69745530,
            69752829,
            69744855,
            69859631,
            69859619,
            69742998,
            70134418,
            69749557,
            69743909,
            69747578,
            69746709,
            69752867,
            69746601,
            69749344,
            69748626,
            69749455,
            69751397,
            69746966,
            69748635,
            69750189,
            69746738
        ],
        "B": [
            69741160,
            69740703,
            69739974,
            69739609,
            69792992,
            69737452,
            70134357,
            69742495,
            69740938,
            69745005,
            69743434,
            69743024,
            69740858,
            69742897,
            69742450,
            69742512,
            69742639,
            69740406,
            69745732,
            69757660,
            69746475,
            69745760,
            69745145,
            69742911,
            69741321,
            69742736,
            69741570
        ],
        "A": [
            69736925,
            69736449,
            69735963,
            69735937,
            69793731,
            69735857,
            70134345,
            69737467,
            69736037,
            69735902,
            69737776,
            69735865,
            69736131,
            69736841,
            69736251,
            69735843,
            69740300,
            69744873,
            69735945,
            69738318,
            69752292
        ]
    },
    "name": "E. Permutation Separation",
    "statement": "You are given a permutation p_1, p_2,\r\ndots , p_n (an array where each integer from 1 to n appears exactly\r\nonce). The weight of the i-th element of this permutation is a_i.At\r\nfirst, you separate your permutation into two sets prefix and suffix.\r\nMore formally, the first set contains elements p_1, p_2,\r\ndots , p_k, the second p_{k+1}, p_{k+2},\r\ndots , p_n, where 1\r\nle k < n.After that, you may move elements between sets. The operation\r\nyou are allowed to do is to choose some element of the first set and\r\nmove it to the second set, or vice versa (move from the second set to\r\nthe first). You have to pay a_i dollars to move the element p_i.Your\r\ngoal is to make it so that each element of the first set is less than\r\neach element of the second set. Note that if one of the sets is empty,\r\nthis condition is met.For example, if p = [3, 1, 2] and a = [7, 1, 4],\r\nthen the optimal strategy is: separate p into two parts [3, 1] and [2]\r\nand then move the 2-element into first set (it costs 4). And if p = [3,\r\n5, 1, 6, 2, 4], a = [9, 1, 9, 9, 1, 9], then the optimal strategy is:\r\nseparate p into two parts [3, 5, 1] and [6, 2, 4], and then move the\r\n2-element into first set (it costs 1), and 5-element into second set (it\r\nalso costs 1).Calculate the minimum number of dollars you have to spend.\r\n",
    "solutions": [
        "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 2e5 + 5;\nconst size_t V = N << 2;\n\n#define lc(x) ((x) << 1)\n#define rc(x) ((x) << 1 | 1)\n\nLL val[V], tag[V];\n\nvoid pushup(int x) {\n    val[x] = min(val[lc(x)], val[rc(x)]);\n}\n\nvoid update(int x, LL v) {\n    val[x] += v;\n    tag[x] += v;\n}\n\nvoid pushdown(int x) {\n    if (tag[x]) {\n        update(lc(x), tag[x]);\n        update(rc(x), tag[x]);\n        tag[x] = 0;\n    }\n}\n\nvoid modify(int x, int tl, int tr, int l, int r, LL v) {\n    if (tl >= r || tr <= l) return;\n    if (l <= tl && tr <= r) {\n        return update(x, v);\n    }\n    pushdown(x);\n    int mid = (tl + tr) >> 1;\n    modify(lc(x), tl, mid, l, r, v);\n    modify(rc(x), mid, tr, l, r, v);\n    pushup(x);\n}\n\nint p[N], a[N];\n\nint main() {\n    int n = read();\n    generate_n(p, n, read);\n    generate_n(a, n, read);\n    for (int i = 0; i < n; ++i) {\n        modify(1, 0, n + 1, p[i], n + 1, a[i]);\n    }\n    LL ans = 1e18;\n    for (int i = 0; i + 1 < n; ++i) {\n        modify(1, 0, n + 1, p[i], n + 1, -a[i]);\n        modify(1, 0, n + 1, 0, p[i], a[i]);\n        ans = min(ans, val[1]);\n    }\n    cout << ans;\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Permutation Separation.json",
    "editorial_link": "https://codeforces.com//blog/entry/73467",
    "editorial": "\"All elements in the left set smaller than all elements in the right\r\nset\" means that there is such value that all elements from the first set\r\nless than and all elements from the second set are more or equal to . So\r\nletâs make a sweep line on from to while trying to maintain all answers\r\nfor each prefix .Letâs maintain for each the total cost to make sets\r\n\"good\" if we split the permutation on sets and in such way that after\r\ntransformations all elements in the first set less than . Itâs easy to\r\nsee that the total cost is equal to sum of weights where and and where\r\nand .So what will happen if we increase by ? Letâs define the position\r\nof as . For each we donât need to move to the second set anymore, so we\r\nshould make . On the other hand, for each we need to move from the\r\nsecond set to the first one now, so we should make .The answer will be\r\nequal to the . It means that we should handle two operations: add some\r\nvalue on the segment and ask minimum on the segment. So we can store all\r\nin pretty standart Segment Tree with \"add on segment\" and \"minimum on\r\nsegment\" while iterating over . So the total complexity is .\r\n",
    "hint": []
}