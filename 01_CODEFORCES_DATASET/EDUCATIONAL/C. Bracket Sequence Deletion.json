{
    "link": "https://codeforces.com//contest/1657/problem/C",
    "problemId": "1339153",
    "problem_idx": "C",
    "shortId": "1657C",
    "contest_number": "1657",
    "problem_submissions": {
        "F": [
            150503115,
            150499453,
            150509321,
            150511905,
            150517571,
            150521311,
            150511942,
            150512719,
            150504329,
            150515960,
            150512240,
            150519562,
            150516193,
            150522557,
            150517792,
            150525082,
            150521099,
            150526532,
            150498258
        ],
        "E": [
            150486345,
            150490802,
            150491754,
            150496559,
            150501319,
            150488737,
            150492757,
            150496033,
            150497203,
            150502682,
            150498901,
            150493901,
            150495208,
            150499778,
            150499542,
            150491019,
            150503092,
            150493803,
            150498682
        ],
        "D": [
            150478088,
            150483562,
            150484230,
            150485188,
            150483314,
            150482900,
            150485882,
            150491440,
            150494087,
            150489766,
            150493543,
            150488170,
            150502719,
            150493520,
            150493571,
            150497861,
            150497439,
            150487471,
            150503395
        ],
        "C": [
            150470574,
            150477398,
            150472059,
            150473115,
            150473331,
            150472319,
            150476196,
            150478092,
            150490090,
            150480365,
            150484688,
            150478395,
            150476845,
            150477792,
            150483257,
            150480052,
            150480944,
            150481904,
            150506549
        ],
        "B": [
            150466899,
            150465684,
            150465706,
            150466831,
            150467217,
            150466293,
            150467748,
            150486194,
            150467057,
            150470591,
            150468677,
            150466989,
            150468064,
            150466642,
            150468045,
            150467383,
            150467499,
            150468669
        ],
        "A": [
            150464865,
            150464773,
            150464769,
            150464812,
            150465126,
            150464939,
            150464906,
            150472446,
            150464866,
            150467928,
            150466097,
            150464791,
            150464960,
            150464872,
            150464833,
            150465034,
            150465120,
            150470046
        ]
    },
    "name": "C. Bracket Sequence Deletion",
    "statement": "You are given a bracket sequence consisting of n characters \u201d and/or \u2019.\r\nYou perform several operations with it.During one operation, you choose\r\nthe prefix of this string (some amount of first characters of the\r\nstring) that is and remove it from the string.The prefix is considered\r\nif one of the following two conditions is satisfied: this prefix is a\r\nregular bracket sequence; this prefix is a palindrome of length . A\r\nbracket sequence is called regular if it is possible to obtain a correct\r\narithmetic expression by inserting characters \u201d and \u201d into this\r\nsequence. For example, sequences , and are regular, while , and are\r\nnot.The bracket sequence is called palindrome if it reads the same back\r\nand forth. For example, the bracket sequences , and are palindromes,\r\nwhile bracket sequences , and are not palindromes.You stop performing\r\nthe operations when it\u2019s not possible to find a prefix. Your task is to\r\nfind the number of operations you will perform on the given string and\r\nthe number of remaining characters in the string.You have to answer t\r\nindependent test cases.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\n#include <array>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) {fprintf(stderr, __VA_ARGS__);fflush(stderr);}\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst int N = 500500;\nchar s[N];\nint n;\n\nvoid solve() {\n\tscanf(\"%d %s\", &n, s);\n\tint ans = 0;\n\tint p = 0;\n\twhile(p + 2 <= n) {\n\t\tif (s[p] == '(') {\n\t\t\tans++;\n\t\t\tp += 2;\n\t\t} else {\n\t\t\tint q = p;\n\t\t\tp++;\n\t\t\twhile(p < n && s[p] == '(') p++;\n\t\t\tif (p == n) {\n\t\t\t\tp = q;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp++;\n\t\t\tans++;\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\", ans, n - p);\n}\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t--) {\n\t\tsolve();\n\t}\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "greedy",
        "implementation"
    ],
    "dificulty": "1200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Bracket Sequence Deletion.json",
    "editorial_link": "https://codeforces.com//blog/entry/101161",
    "editorial": "Consider the first character of the string. If it is \u00e2\u0080\u009d, then we can\r\nremove the first two characters of the string and continue (because the\r\nprefix of length will be either a palindrome or a regular bracket\r\nsequence). If the first character of the string is \u00e2\u0080\u009d then this is a bad\r\ncase. Of course, the regular bracket sequence can\u00e2\u0080\u0099t start with \u00e2\u0080\u009d, so\r\nthis prefix should be a palindrome. And what is the shortest palindrome\r\nwe can get with the first character \u00e2\u0080\u009d? It is the closing bracket \u00e2\u0080\u009d, then\r\nsome (possibly, zero) amount of opening brackets \u00e2\u0080\u009d, and another one\r\nclosing bracket. We can see that we can\u00e2\u0080\u0099t find a palindrome shorter than\r\nthis one because we have to find a pair for the first character. So, if\r\nthe first character of the string is \u00e2\u0080\u009d, then we just remove anything\r\nuntil the next character \u00e2\u0080\u009d inclusive. To not remove any characters\r\nexplicitly, we can just use pointers instead. And the last thing is to\r\ncarefully handle cases when we can\u00e2\u0080\u0099t do any operations.\r\n"
}