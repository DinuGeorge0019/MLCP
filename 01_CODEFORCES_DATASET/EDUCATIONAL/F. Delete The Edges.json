{"link": "https://codeforces.com//contest/1494/problem/F", "problemId": "913255", "problem_idx": "F", "shortId": "1494F", "contest_number": "1494", "problem_submissions": {"F": [108939157, 108939159, 108941615, 108940380, 108936690, 108949404, 108939049, 108976002, 109259098, 114355817, 114300723, 109105687, 108952860], "E": [108917863, 108917179, 108917875, 108920789, 108924713, 108911681, 108911479, 108897566, 108915498, 108912071, 108919266, 108916392, 108921553, 108913575, 108918608, 108932427, 108930755, 108916943], "D": [108912126, 108910016, 108906106, 108913150, 108917394, 108924483, 108905862, 108906091, 108907069, 108901150, 108912737, 108909289, 108909997, 108901829, 108912218, 108906405, 108912083], "C": [108899963, 108897106, 108898254, 108894965, 108905337, 108946028, 108904267, 108903529, 108894912, 108900440, 108893773, 108903235, 108896270, 108897186, 108897145, 108895547, 108897140, 108897478, 108896885], "B": [108887573, 108887648, 108887088, 108887791, 108891184, 108886492, 108887122, 108892723, 108887267, 108886341, 108887638, 108889178, 108889629, 108886479, 108887946, 108888463, 108886261], "A": [108886097, 108886134, 108886049, 108886041, 108887001, 108886021, 108886051, 108886176, 108886040, 108887099, 108886184, 108886195, 108886220, 108886015, 108886138, 108886325, 108885985]}, "name": "F. Delete The Edges", "statement": "You are given an undirected connected graph consisting of n vertices and\r\nm edges. Your goal is to destroy all edges of the given graph.You may\r\nchoose any vertex as the starting one and begin walking from it along\r\nthe edges. When you walk along an edge, you destroy it. Obviously, you\r\ncannot walk along an edge if it is destroyed.You can perform the\r\noperation at most once during your walk, and this operation can only be\r\nperformed when you are at some vertex (you cannot perform it while\r\ntraversing an edge). After the , the edges you go through are deleted in\r\nthe following way: the first edge after the is not destroyed, the second\r\none is destroyed, the third one is not destroyed, the fourth one is\r\ndestroyed, and so on. You cannot switch back to the original mode, and\r\nyou don\u2019t have to perform this operation if you don\u2019t want to.Can you\r\ndestroy all the edges of the given graph?\r\n", "solutions": ["#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\ntypedef tree<\n        int,\n        null_type,\n        less<int>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n#define mp make_pair\n\n\nconst int MOD =  998244353;\n\nint mul(int a, int b) {\n    return (1LL * a * b) % MOD;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+MOD-b);\n    if (s>=MOD) s-=MOD;\n    return s;\n}\n\nint po(int a, ll deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, MOD-2);\n}\n\n\nmt19937 rnd(time(0));\n\n/*\nconst int LIM = 1e6 + 5;\n\nvector<int> facs(LIM), invfacs(LIM);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<LIM; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[LIM-1] = inv(facs[LIM-1]);\n    for (int i = LIM-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    if (n<0 || k<0) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}*/\n\n\nstruct DSU\n{\n    vector<int> sz;\n    vector<int> parent;\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        else\n        {\n            auto par = find_set(parent[v]);\n            parent[v] = par;\n            return par;\n        }\n    }\n\n    void union_sets(int a, int b) {\n        find_set(a);\n        find_set(b);\n\n        a = find_set(a);\n        b = find_set(b);\n\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU (int n)\n    {\n        parent.resize(n);\n        sz.resize(n);\n        for (int i = 0; i<n; i++) make_set(i);\n    }\n};\n\nvector<vector<bool>> adj;\nvector<vector<int>> G;\n\n\n\nvector<int> solve(vector<vector<int>> g)\n{\n    int n = g.size();\n\n    vector<int> deg(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j)\n            deg[i] += g[i][j];\n    }\n\n    int first = 0;\n    while (first < n && !deg[first])\n        ++first;\n\n\n    int v1 = -1, v2 = -1;\n    bool bad = false;\n    for (int i = 0; i < n; ++i) {\n        if (deg[i] & 1) {\n            if (v1 == -1)\n                v1 = i;\n            else if (v2 == -1)\n                v2 = i;\n            else\n                bad = true;\n        }\n    }\n\n    if (v1 != -1)\n        ++g[v1][v2], ++g[v2][v1];\n\n    stack<int> st;\n    st.push(first);\n    vector<int> res;\n    while (!st.empty()) {\n        int v = st.top();\n        int i;\n        for (i = 0; i < n; ++i)\n            if (g[v][i])\n                break;\n        if (i == n) {\n            res.push_back(v);\n            st.pop();\n        } else {\n            --g[v][i];\n            --g[i][v];\n            st.push(i);\n        }\n    }\n\n    if (v1 != -1) {\n        for (size_t i = 0; i + 1 < res.size(); ++i) {\n            if ((res[i] == v1 && res[i + 1] == v2) ||\n                (res[i] == v2 && res[i + 1] == v1)) {\n                vector<int> res2;\n                for (size_t j = i + 1; j < res.size(); ++j)\n                    res2.push_back(res[j]);\n                for (size_t j = 1; j <= i; ++j)\n                    res2.push_back(res[j]);\n                res = res2;\n                break;\n            }\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (g[i][j])\n                bad = true;\n        }\n    }\n\n    return res;\n}\n\n\n\n\n\n\n\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int n, m; cin>>n>>m;\n\n    adj = vector<vector<bool>>(n, vector<bool>(n));\n\n    G.resize(n);\n    for (int i = 0; i<m; i++)\n    {\n        int u, v; cin>>u>>v; u--; v--;\n        G[u].push_back(v); G[v].push_back(u);\n        adj[u][v] = true; adj[v][u] = true;\n    }\n\n    vector<int> odd;\n    for (int i = 0; i<n; i++) if (G[i].size()%2) odd.push_back(i);\n\n    for (int root = 0; root<n; root++)\n    {\n        vector<int> odd1;\n        for (auto it: odd) if (it!=root) odd1.push_back(it);\n\n        if (odd1.size()==0) odd1.push_back(n);\n\n        for (auto miss: odd1)\n        {\n            bool check = true;\n            for (auto it: odd1) if (it!=miss)\n            {\n                if (!adj[root][it])\n                {\n                    check = false; break;\n                }\n            }\n            if (!check) continue;\n\n            set<pair<int, int>> banned_edges;\n            for (auto it: odd1) if (it!=miss) banned_edges.insert(mp(root, it));\n\n            DSU dsu(n);\n\n            for (int i = 0; i<n; i++)\n                for (auto v: G[i])\n                {\n                    if (banned_edges.count(mp(i, v)) || banned_edges.count(mp(v, i))) continue;\n                    dsu.union_sets(i, v);\n                }\n\n\n            map<int, int> cnt_roots;\n            for (int i = 0; i<n; i++) cnt_roots[dsu.find_set(i)]++;\n\n            vector<int> szs;\n            for (auto it: cnt_roots) szs.push_back(it.second);\n            sort(szs.begin(), szs.end());\n            if (szs.size()>=2 && szs[szs.size()-2]>=2) check = false;\n\n            if (!check) continue;\n\n\n            vector<vector<int>> g(n, vector<int>(n));\n\n            for (int i = 0; i<n; i++)\n                for (auto v: G[i])\n                {\n                    if (banned_edges.count(mp(i, v)) || banned_edges.count(mp(v, i))) continue;\n                    g[i][v] = 1;\n                }\n\n            auto path = solve(g);\n\n            if (path[0]==root) reverse(path.begin(), path.end());\n\n            if (path.back()!=root)\n            {\n                int len = path.size();\n                int pos = 0;\n                while (path[pos]!=root) pos++;\n\n                vector<int> path1;\n                for (int i = pos; pos<len; len++) path1.push_back(path[i]);\n                for (int i = 1; i<=pos; i++) path1.push_back(path[i]);\n                path = path1;\n            }\n\n\n            path.push_back(-2);\n            for (auto it: odd1) if (it!=miss)\n            {\n                path.push_back(it); path.push_back(root);\n            }\n\n            cout<<path.size()<<endl; for (auto it: path) cout<<it+1<<' ';\n            return 0;\n\n        }\n\n    }\n\n    cout<<0;\n\n}\n"], "input": "", "output": "", "tags": ["brute force", "constructive algorithms", "dfs and similar", "graphs", "implementation"], "dificulty": "2900", "interactive": false}