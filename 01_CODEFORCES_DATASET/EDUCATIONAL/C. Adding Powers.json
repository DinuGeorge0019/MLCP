{
    "link": "https://codeforces.com//contest/1312/problem/C",
    "problemId": "557979",
    "problem_idx": "C",
    "shortId": "1312C",
    "contest_number": "1312",
    "problem_submissions": {
        "G": [
            72824912,
            72825940,
            72832858,
            72832125,
            72830981,
            72830579,
            72827258,
            72818410,
            73118157,
            72832195,
            72826680,
            72837006,
            72831183,
            72846291,
            72845347,
            72835299,
            72834657,
            72834166,
            72836122,
            72834407,
            72826975,
            72828977,
            72837738,
            72829233,
            72828895,
            72814710
        ],
        "F": [
            72816196,
            72815449,
            72836440,
            72835939,
            72833544,
            72818707,
            72831850,
            73118148,
            72823917,
            72821869,
            72817848,
            72823973,
            72825602,
            72821962,
            72825661,
            72827867,
            72825004,
            72836754,
            72835570,
            72830789,
            72837405,
            72824053,
            72824708
        ],
        "E": [
            72807538,
            72806508,
            72938781,
            72938462,
            72938238,
            72849613,
            72849474,
            72839861,
            72834168,
            72811533,
            72810583,
            73118128,
            72810138,
            72811240,
            72806275,
            72810780,
            72813492,
            72813999,
            72814345,
            72819726,
            72816559,
            72814069,
            72818755,
            72815412,
            72820356,
            72810691,
            72826172
        ],
        "D": [
            72804418,
            72803272,
            72940991,
            72940962,
            72801330,
            72805787,
            73118118,
            72807156,
            72809073,
            86477031,
            72803786,
            72808232,
            72806322,
            72805660,
            72809462,
            72812808,
            72814419,
            72810586,
            72812917,
            72812165,
            72817006,
            72832064,
            72827740
        ],
        "C": [
            72798692,
            72799958,
            72796730,
            72804789,
            73118106,
            72800009,
            72800362,
            72797813,
            72800910,
            72799283,
            72799712,
            72801433,
            72802442,
            72813095,
            72802040,
            72808078,
            72800616,
            72812371,
            72830092,
            72828590
        ],
        "B": [
            72793777,
            72794214,
            72793197,
            72797455,
            73118103,
            72795859,
            72796621,
            72793808,
            72794859,
            72794981,
            72794667,
            72795692,
            72795259,
            72794528,
            72797051,
            72796632,
            72795714,
            72810192,
            72793542,
            72829098
        ],
        "A": [
            72792172,
            72792542,
            72792143,
            72792487,
            73118076,
            72793403,
            72793192,
            72792295,
            72792118,
            72792591,
            72792492,
            72792213,
            72792502,
            72792229,
            72794177,
            72793376,
            72792458,
            72809334,
            72829278,
            72829336
        ]
    },
    "name": "C. Adding Powers",
    "statement": "Suppose you are performing the following algorithm. There is an array\r\nv_1, v_2,\r\ndots, v_n filled with zeroes at start. The following operation is\r\napplied to the array several times at i-th step (0-indexed) you can:\r\neither choose position pos (1\r\nle pos\r\nle n) and increase v_{pos} by k^i; or not choose any position and skip\r\nthis step. You can choose how the algorithm would behave on each step\r\nand when to stop it. The question is: can you make array v equal to the\r\ngiven array a (v_j = a_j for each j) after some step?\r\n",
    "solutions": [
        "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 65;\nbool ok[maxN][maxN];\nint k;\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    int tst;\n    cin >> tst;\n    while (tst--) {\n        int n;\n        cin >> n >> k;\n        memset(ok, 0, sizeof ok);\n        bool can = true;\n        for (int i = 1; i <= n; i++) {\n            ll x;\n            cin >> x;\n            for (int pos = 0; pos < maxN; pos++) {\n                int t = x % k;\n                x /= k;\n                if (t > 1) {\n                    can = false;\n                }\n                else if (t == 1) {\n                    if (ok[pos][t]) can = false;\n                    ok[pos][t] = true;\n                }\n            }\n        }\n        if (can) cout << \"YES\\n\";\n        else cout << \"NO\\n\";\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "greedy",
        "implementation",
        "math",
        "number theory",
        "ternary search"
    ],
    "dificulty": "1400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Adding Powers.json",
    "editorial_link": "https://codeforces.com//blog/entry/74640",
    "editorial": "This is the solution that doesn\u00e2\u0080\u0099t involve masks. Let\u00e2\u0080\u0099s reverse the\r\nprocess and try to get all zeroes from the array : since all we can\r\nstart from maximum .The key idea: since then there should be no more\r\nthan one position such that and we should decrease it by . Now we can\r\ndecrease by and repeat the same process.If at any step there are at\r\nleast two or as result, we won\u00e2\u0080\u0099t get array filled with then there is no\r\nway to build the array .\r\n"
}