{
    "link": "https://codeforces.com//contest/1027/problem/G",
    "problemId": "209494",
    "problem_idx": "G",
    "shortId": "1027G",
    "contest_number": "1027",
    "problem_submissions": {
        "G": [
            41777591,
            41794075,
            41789651,
            41795096,
            41939341,
            41938165,
            41796137,
            42098879,
            42133042
        ],
        "E": [
            41771294,
            41773308,
            41779379,
            41769311,
            41773946,
            41775704,
            41772136,
            41773355,
            41779847,
            41781989,
            41784347,
            41777571,
            41784573,
            41777063,
            41778773,
            41776995,
            41786639,
            41778631,
            41778849,
            41779109
        ],
        "F": [
            41768065,
            41785375,
            41776031,
            41777064,
            64515193,
            41778051,
            41781324,
            41779089,
            41778653,
            41776480,
            41776867,
            41774399,
            41778108,
            41783735,
            41779480,
            41782813,
            41784214,
            42675272,
            42673408,
            41785662,
            41778618,
            41786449,
            41792717,
            41792403,
            41790072,
            41787559,
            41785600
        ],
        "D": [
            41766114,
            41769377,
            41772019,
            41765799,
            41768093,
            41767980,
            41769938,
            41769777,
            41767951,
            41766660,
            41768756,
            41770224,
            41770243,
            41773173,
            41773790,
            41772403,
            41773900,
            41774900,
            41773430,
            41773585
        ],
        "C": [
            41765079,
            41766031,
            41768208,
            41764342,
            41765993,
            41765549,
            41767982,
            41768445,
            41764158,
            41772730,
            41766169,
            41767810,
            41767876,
            41767390,
            41770932,
            41768551,
            41769543,
            41768596,
            41768222,
            41768699,
            41769864,
            41769626
        ],
        "B": [
            41762630,
            41763189,
            41765301,
            41762037,
            41763563,
            41762756,
            41764132,
            41765033,
            41765562,
            41762467,
            41763527,
            41764762,
            41763245,
            41763720,
            41763112,
            41766236,
            41764943,
            41765112,
            41765051,
            41766842
        ],
        "A": [
            41761297,
            41761064,
            41763316,
            41761011,
            41761231,
            41761105,
            41761008,
            41761632,
            41761600,
            41761296,
            41761079,
            41761346,
            41761160,
            41761251,
            41761159,
            41761563,
            41761142,
            41761529,
            41761274,
            41764617
        ]
    },
    "name": "G. X-mouse in the Campus",
    "statement": "The campus has m rooms numbered from 0 to m - 1. Also the x-mouse lives\r\nin the campus. The x-mouse is not just a mouse: each second x-mouse\r\nmoves from room i to the room i\r\ncdot x\r\nmod{m} (in fact, it teleports from one room to another since it doesn\u2019t\r\nvisit any intermediate room). Starting position of the x-mouse is\r\nunknown.You are responsible to catch the x-mouse in the campus, so you\r\nare guessing about minimum possible number of traps (one trap in one\r\nroom) you need to place. You are sure that if the x-mouse enters a\r\ntrapped room, it immediately gets caught.And the only observation you\r\nmade is\r\ntext{GCD} (x, m) = 1.\r\n",
    "solutions": [
        "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define mp make_pair\n\nconst ll B = (ll)1e4;\nll mult(ll x, ll y, ll mod) {\n\tif (y == 0) return 0;\n\treturn (mult(x, y / B, mod) * B + x * (y % B)) % mod;\n}\nll bin_pow(ll x, ll p, ll mod) {\n\tif (p == 0) return 1 % mod;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1, mod), mod);\n\treturn bin_pow(mult(x, x, mod), p / 2, mod);\n}\n\nll gcd(ll x, ll y) {\n\treturn y == 0 ? x : gcd(y, x % y);\n}\nll lcm(ll x, ll y) {\n\treturn x * (y / gcd(x, y));\n}\n\nconst int N = 50;\nint n;\nll P[N][2];\nll a[N][N][2];\n\nvector<pll> factorize(ll m) {\n\tvector<pll> res;\n\tfor (ll y = 2; y * y <= m; y++) {\n\t\tif (m % y) continue;\n\t\tres.push_back(mp(y, 0LL));\n\t\twhile(m % y == 0) {\n\t\t\tres.back().second++;\n\t\t\tm /= y;\n\t\t}\n\t\tn++;\n\t}\n\tif (m > 1) {\n\t\tres.push_back(mp(m, 1LL));\n\t}\n\treturn res;\n}\n\nll ans;\nvoid brute(int pos, ll PP, ll Q) {\n//\teprintf(\"brute %d %lld %lld\\n\", pos, PP, Q);\n\tif (pos == n) {\n\t\tans += PP / Q;\n\t\treturn;\n\t}\n\tfor (int i = 0; i <= P[pos][1]; i++) {\n\t\tbrute(pos + 1, PP * a[pos][i][0], lcm(Q, a[pos][i][1]));\n\t}\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tll m, x;\n\tcin >> m >> x;\n\n\tvector<pll> q = factorize(m);\n\tn = (int)q.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP[i][0] = q[i].first;\n\t\tP[i][1] = q[i].second;\n\t}\n\n//\teprintf(\"%d\\n\", n);\n//\tfor (int i = 0; i < n; i++)\n//\t\teprintf(\"%lld %lld\\n\", P[i][0], P[i][1]);\n//\treturn 0;\n\n\tans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tll mod = 1;\n\t\tq = factorize(P[i][0] - 1);\n\t\tfor (int pw = 0; pw <= P[i][1]; pw++) {\n\t\t\tif (pw == 0) {\n\t\t\t\ta[i][pw][0] = a[i][pw][1] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmod *= P[i][0];\n\t\t\tll cur = mod - mod / P[i][0];\n\t\t\tfor (int j = 0; j < (int)q.size(); j++) {\n\t\t\t\tfor (int k = 0; k < q[j].second; k++) {\n\t\t\t\t\tll ncur = cur / q[j].first;\n\t\t\t\t\tif (bin_pow(x, ncur, mod) != 1) break;\n\t\t\t\t\tcur = ncur;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < pw - 1; k++) {\n\t\t\t\tll ncur = cur / P[i][0];\n\t\t\t\tif (bin_pow(x, ncur, mod) != 1) break;\n\t\t\t\tcur = ncur;\n\t\t\t}\n\t\t\ta[i][pw][0] = mod - mod / P[i][0];\n\t\t\ta[i][pw][1] = cur;\n\t\t}\n\t}\n\tbrute(0, 1, 1);\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "math",
        "number theory"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. X-mouse in the Campus.json",
    "editorial_link": "https://codeforces.com//blog/entry/61311",
    "editorial": "Some notes:At first, there is since (lets define as ). That means that\r\nfor each there is exactly one that . So if we look at this problem as\r\nthe graph then it consists of cycles (consider loops as cycles of length\r\none). So we need to know number of cycles in this graph.At second, since\r\n, and and . So all can be divided in groups by its . And we can\r\ncalculate number of cylces in each group independently.Let fix some\r\nequal to . All numbers such that can be represented as and . Number of\r\nsuch equals to . Moreover . Here we can shift from , and to , and .In\r\nresult we need for each calculate number of cycles created by from\r\nnumbers , that and . Lets set .Next step is to find minimal such that ,\r\nlet\u00e2\u0080\u0099s name it order of or . Then for each if then and , so each cycle\r\nwill have length equal to and number of cycles will be equal to .Last\r\nstep is calculate for each . There is a fact that so can try to iterate\r\nover all divisors of and check by binary exponentiation (It seems as but\r\nit\u00e2\u0080\u0099s faster and author\u00e2\u0080\u0099s version work around 2 seconds. It doesn\u00e2\u0080\u0099t pass\r\nbut somebody can write better). But we\u00e2\u0080\u0099ll speed it up. Let . So we can\r\nindependently for each find its minimal power such that . We can just\r\niterate over all and since .Some words about finding its factorization\r\ndiffers from factorization of just by lowering degrees of primes and\r\nadding factorizations of some . But we can manually find factorization\r\nof with memorization (or even without it) since .So our steps are next:\r\nfactorize , recursively iterate over all divisors of , find and , and\r\nadd to the answer .Result complexity is .And the last note is how to\r\nmultiply modulo . You can use binary multiplification which will give\r\nyou extra what is not critically in this task (in C++, of course). Or\r\nyou can use multiplification from hashes, which will work with 64 bit\r\ndouble, since it\u00e2\u0080\u0099s only .\r\n"
}