{
    "link": "https://codeforces.com//contest/1217/problem/F",
    "problemId": "404648",
    "problem_idx": "F",
    "shortId": "1217F",
    "contest_number": "1217",
    "problem_submissions": {
        "F": [
            60119255,
            60118536,
            60117179,
            60112264,
            60128130,
            60127503,
            60126918,
            60123155,
            60108293,
            60125049,
            60146948,
            60128055,
            60130824,
            60133706,
            60133628,
            60133577,
            60133431,
            60148111,
            60128465,
            60130939,
            60194071,
            60161365,
            60161338,
            60161260,
            60133265,
            60131839
        ],
        "E": [
            60105066,
            60116418,
            60106390,
            60121938,
            60108304,
            60146942,
            60108305,
            60105389,
            60107537,
            60103856,
            60133910,
            60133496,
            60106424,
            60108802,
            60109228,
            60105208,
            60109038,
            60113612,
            60109155,
            60108937,
            60108739,
            60185912,
            60121211,
            60119745
        ],
        "D": [
            60093380,
            60096462,
            60101910,
            60101769,
            60146935,
            60099412,
            60094151,
            60095526,
            60100622,
            60098634,
            60099130,
            60111816,
            60100421,
            60093903,
            60100608,
            60099424,
            60113888,
            60106298,
            60107083
        ],
        "C": [
            60088873,
            60091347,
            60096256,
            60097679,
            60146931,
            60089815,
            60086473,
            60091850,
            60090230,
            60091598,
            60096228,
            60090577,
            60097512,
            60091408,
            60091681,
            60095632,
            60094356,
            60083533,
            60095174
        ],
        "B": [
            60085129,
            60084473,
            60090224,
            60089598,
            60146927,
            60087277,
            60084144,
            60085003,
            60086682,
            60087576,
            60086106,
            60085538,
            60094264,
            60087892,
            60094300,
            60089353,
            60089039,
            60094083,
            60086577
        ],
        "A": [
            60083114,
            60082761,
            60084492,
            60083647,
            60146918,
            60083293,
            60082871,
            60082868,
            60082958,
            60082935,
            60083622,
            60083726,
            60084591,
            60083527,
            60083900,
            60086802,
            60083832,
            60082824,
            60083536
        ]
    },
    "name": "F. Forced Online Queries Problem",
    "statement": "You are given an undirected graph with n vertices numbered from 1 to n.\r\nInitially there are no edges.You are asked to perform some queries on\r\nthe graph. Let last be the answer to the latest query of the second\r\ntype, it is set to 0 before the first such query. Then the queries are\r\nthe following: 1\u00a0x\u00a0y (1\r\nle x, y\r\nle n, x\r\nne y) add an undirected edge between the vertices (x + last - 1)\u00a0mod\u00a0n +\r\n1 and (y + last - 1)\u00a0mod\u00a0n + 1 if it doesn\u2019t exist yet, otherwise remove\r\nit; 2\u00a0x\u00a0y (1\r\nle x, y\r\nle n, x\r\nne y) check if there exists a path between the vertices (x + last -\r\n1)\u00a0mod\u00a0n + 1 and (y + last - 1)\u00a0mod\u00a0n + 1, which goes only through\r\ncurrently existing edges, and set last to 1 if so and 0 otherwise. Good\r\nluck!\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/06, 00:30:55\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nconst int B = 1000;\nint n, m;\nint T[200001];\nint X[200001];\nint Y[200001];\nvector<pii> es;\n\nint par[200001];\nint find(int x) {\n    if (par[x]) return par[x] = find(par[x]);\n    return x;\n}\n\nbool merge(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return 0;\n    par[y] = x;\n    return 1;\n}\n\nint last;\nvector<int> edge[200001];\nbool vis[200001];\n\nvoid dfs(int x, bool ch) {\n    vis[x] = ch;\n    for (int i : edge[x]) {\n        if (vis[i] == ch) continue;\n        dfs(i, ch);\n    }\n}\n\nvoid solve(int st, int ed) {\n    for (int i = 1; i <= n; ++i) {\n        par[i] = 0;\n    }\n    vector<pii> ch;\n    for (int i = st; i <= ed; ++i) {\n        if (T[i] == 1) {\n            int x = X[i], y = Y[i];\n            if (x > y) swap(x, y);\n            ch.emplace_back(x, y);\n            x = x % n + 1;\n            y = y % n + 1;\n            if (x > y) swap(x, y);\n            ch.emplace_back(x, y);\n        }\n    }\n    sort(ch.begin(), ch.end());\n    vector<int> in(ch.size());\n    for (pii i : es) {\n        auto it = lower_bound(ch.begin(), ch.end(), i);\n        if (it != ch.end() && *it == i) continue;\n        merge(i.fs, i.se);\n    }\n    vector<int> er;\n    for (pii i : es) {\n        if (i.fs > i.se) swap(i.fs, i.se);\n        auto it = lower_bound(ch.begin(), ch.end(), i);\n        if (it == ch.end() || *it != i) continue;\n        in[it - ch.begin()] = 1;\n        int x = find(i.fs);\n        int y = find(i.se);\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n        er.push_back(x);\n        er.push_back(y);\n    }\n    for (int i = st; i <= ed; ++i) {\n        if (T[i] == 1) {\n            int x = X[i], y = Y[i];\n            if (last) {\n                x = x % n + 1;\n                y = y % n + 1;\n            }\n            if (x > y) swap(x, y);\n            int j = lower_bound(ch.begin(), ch.end(), pii(x, y)) - ch.begin();\n            x = find(x);\n            y = find(y);\n            if (in[j]) {\n                edge[x].erase(find(edge[x].begin(), edge[x].end(), y));\n                edge[y].erase(find(edge[y].begin(), edge[y].end(), x));\n            }\n            else {\n                edge[x].push_back(y);\n                edge[y].push_back(x);\n                er.push_back(x);\n                er.push_back(y);\n            }\n            in[j] ^= 1;\n        }\n        else {\n            int x = X[i], y = Y[i];\n            if (last) {\n                x = x % n + 1;\n                y = y % n + 1;\n            }\n            x = find(x);\n            y = find(y);\n            dfs(x, 1);\n            last = vis[y];\n            dfs(x, 0);\n            printf(\"%d\", last);\n        }\n    }\n    for (int i : er) edge[i].clear();\n    vector<pii> nxt;\n    for (pii i : es) {\n        if (i.fs > i.se) swap(i.fs, i.se);\n        auto it = lower_bound(ch.begin(), ch.end(), i);\n        if (it != ch.end() && *it == i) {\n            if (in[it - ch.begin()] == 0) continue;\n            in[it - ch.begin()] = 0;\n        }\n        nxt.push_back(i);\n    }\n    for (int i = 0; i < ch.size(); ++i) {\n        if (in[i]) nxt.push_back(ch[i]);\n    }\n    swap(es, nxt);\n    sort(es.begin(), es.end());\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; ++i) {\n        cin >> T[i] >> X[i] >> Y[i];\n    }\n    for (int it = 0; it < B; ++it) {\n        int st = it * B + 1;\n        int ed = min((it + 1) * B, m);\n        if (st > ed) break;\n        solve(st, ed);\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "dsu",
        "graphs",
        "trees"
    ],
    "dificulty": "2600",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Forced Online Queries Problem.json",
    "editorial_link": "https://codeforces.com//blog/entry/69605",
    "editorial": "The problem directly tells you do solve some kind of Dynamic\r\nConnectivity Problem. You could use the online approach with Link-Cut\r\nTree if you\u00e2\u0080\u0099d had its implementation beforehand. There is also a nice\r\nmodification to the solution of the offline version of DCP (check out\r\nthe comment).I\u00e2\u0080\u0099d tell the solution which is probably the easiest to come\r\nup with and to code.Let\u00e2\u0080\u0099s recall the sqrt-optimization method of solving\r\nDCP. Process blocks of queries of size one at a time. Split the edges\r\ninto two groups: The edges which were added on queries before the block\r\nand aren\u00e2\u0080\u0099t touched by the queries in the block; the edges modified by\r\nthe queries in the block. The first type of edges can be added to the\r\ngraph before the block processing starts. You can use DSU for that. The\r\nsecond type contains no more than edges. Maintain the list of those of\r\nthem which exist in the graph. On each ask query add them to graph, then\r\ndelete them. This can be done explicitly by doing DFS only over these\r\nedges and the vertices which correspond to the connected components on\r\nthe edges of the first type. Implicitly doing DSU merges for these edges\r\nand rolling them back is a viable option as well (costs extra log factor\r\nbut has lower constant).It\u00e2\u0080\u0099s easy to see that it isn\u00e2\u0080\u0099t hard to modify\r\nthis solution to our problem. Let\u00e2\u0080\u0099s define the edges of the first type\r\nmore generally: the edges which were added on queries before the block\r\nand touched by the queries in the block. So neither from the add query,\r\nnor could be of the first type. Now there might be edges of the second\r\ntype in the list. However, that doesn\u00e2\u0080\u0099t make the complexity any\r\nworse.Process block the same way, rebuild the DSU with the edges of the\r\nfirst type every queries.The overall complexity can be if you use DFS or\r\nif you use DSU (notice how the rebuild is and the query is and set the\r\nsize of the block so that these parts are about the same).\r\n"
}