{"link": "https://codeforces.com//contest/1217/problem/F", "problemId": "404648", "problem_idx": "F", "shortId": "1217F", "contest_number": "1217", "problem_submissions": {"F": [60119255, 60118536, 60117179, 60112264, 60128130, 60127503, 60126918, 60123155, 60108293, 60125049, 60146948, 60128055, 60130824, 60133706, 60133628, 60133577, 60133431, 60148111, 60128465, 60130939, 60194071, 60161365, 60161338, 60161260, 60133265, 60131839], "E": [60105066, 60116418, 60106390, 60121938, 60108304, 60146942, 60108305, 60105389, 60107537, 60103856, 60133910, 60133496, 60106424, 60108802, 60109228, 60105208, 60109038, 60113612, 60109155, 60108937, 60108739, 60185912, 60121211, 60119745], "D": [60093380, 60096462, 60101910, 60101769, 60146935, 60099412, 60094151, 60095526, 60100622, 60098634, 60099130, 60111816, 60100421, 60093903, 60100608, 60099424, 60113888, 60106298, 60107083], "C": [60088873, 60091347, 60096256, 60097679, 60146931, 60089815, 60086473, 60091850, 60090230, 60091598, 60096228, 60090577, 60097512, 60091408, 60091681, 60095632, 60094356, 60083533, 60095174], "B": [60085129, 60084473, 60090224, 60089598, 60146927, 60087277, 60084144, 60085003, 60086682, 60087576, 60086106, 60085538, 60094264, 60087892, 60094300, 60089353, 60089039, 60094083, 60086577], "A": [60083114, 60082761, 60084492, 60083647, 60146918, 60083293, 60082871, 60082868, 60082958, 60082935, 60083622, 60083726, 60084591, 60083527, 60083900, 60086802, 60083832, 60082824, 60083536]}, "name": "F. Forced Online Queries Problem", "statement": "You are given an undirected graph with n vertices numbered from 1 to n.\r\nInitially there are no edges.You are asked to perform some queries on\r\nthe graph. Let last be the answer to the latest query of the second\r\ntype, it is set to 0 before the first such query. Then the queries are\r\nthe following: 1\u00a0x\u00a0y (1\r\nle x, y\r\nle n, x\r\nne y) add an undirected edge between the vertices (x + last - 1)\u00a0mod\u00a0n +\r\n1 and (y + last - 1)\u00a0mod\u00a0n + 1 if it doesn\u2019t exist yet, otherwise remove\r\nit; 2\u00a0x\u00a0y (1\r\nle x, y\r\nle n, x\r\nne y) check if there exists a path between the vertices (x + last -\r\n1)\u00a0mod\u00a0n + 1 and (y + last - 1)\u00a0mod\u00a0n + 1, which goes only through\r\ncurrently existing edges, and set last to 1 if so and 0 otherwise. Good\r\nluck!\r\n", "solutions": ["#include <bits/stdc++.h>\n#define fs first\n#define se second\n#define y0 qwertyuiop\n#define y1 asdfghjkl\n\n/*\nAuthor : Tropical_maid\nCreated : 2019/09/06, 00:30:55\n*/\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\n\nconst int B = 1000;\nint n, m;\nint T[200001];\nint X[200001];\nint Y[200001];\nvector<pii> es;\n\nint par[200001];\nint find(int x) {\n    if (par[x]) return par[x] = find(par[x]);\n    return x;\n}\n\nbool merge(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return 0;\n    par[y] = x;\n    return 1;\n}\n\nint last;\nvector<int> edge[200001];\nbool vis[200001];\n\nvoid dfs(int x, bool ch) {\n    vis[x] = ch;\n    for (int i : edge[x]) {\n        if (vis[i] == ch) continue;\n        dfs(i, ch);\n    }\n}\n\nvoid solve(int st, int ed) {\n    for (int i = 1; i <= n; ++i) {\n        par[i] = 0;\n    }\n    vector<pii> ch;\n    for (int i = st; i <= ed; ++i) {\n        if (T[i] == 1) {\n            int x = X[i], y = Y[i];\n            if (x > y) swap(x, y);\n            ch.emplace_back(x, y);\n            x = x % n + 1;\n            y = y % n + 1;\n            if (x > y) swap(x, y);\n            ch.emplace_back(x, y);\n        }\n    }\n    sort(ch.begin(), ch.end());\n    vector<int> in(ch.size());\n    for (pii i : es) {\n        auto it = lower_bound(ch.begin(), ch.end(), i);\n        if (it != ch.end() && *it == i) continue;\n        merge(i.fs, i.se);\n    }\n    vector<int> er;\n    for (pii i : es) {\n        if (i.fs > i.se) swap(i.fs, i.se);\n        auto it = lower_bound(ch.begin(), ch.end(), i);\n        if (it == ch.end() || *it != i) continue;\n        in[it - ch.begin()] = 1;\n        int x = find(i.fs);\n        int y = find(i.se);\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n        er.push_back(x);\n        er.push_back(y);\n    }\n    for (int i = st; i <= ed; ++i) {\n        if (T[i] == 1) {\n            int x = X[i], y = Y[i];\n            if (last) {\n                x = x % n + 1;\n                y = y % n + 1;\n            }\n            if (x > y) swap(x, y);\n            int j = lower_bound(ch.begin(), ch.end(), pii(x, y)) - ch.begin();\n            x = find(x);\n            y = find(y);\n            if (in[j]) {\n                edge[x].erase(find(edge[x].begin(), edge[x].end(), y));\n                edge[y].erase(find(edge[y].begin(), edge[y].end(), x));\n            }\n            else {\n                edge[x].push_back(y);\n                edge[y].push_back(x);\n                er.push_back(x);\n                er.push_back(y);\n            }\n            in[j] ^= 1;\n        }\n        else {\n            int x = X[i], y = Y[i];\n            if (last) {\n                x = x % n + 1;\n                y = y % n + 1;\n            }\n            x = find(x);\n            y = find(y);\n            dfs(x, 1);\n            last = vis[y];\n            dfs(x, 0);\n            printf(\"%d\", last);\n        }\n    }\n    for (int i : er) edge[i].clear();\n    vector<pii> nxt;\n    for (pii i : es) {\n        if (i.fs > i.se) swap(i.fs, i.se);\n        auto it = lower_bound(ch.begin(), ch.end(), i);\n        if (it != ch.end() && *it == i) {\n            if (in[it - ch.begin()] == 0) continue;\n            in[it - ch.begin()] = 0;\n        }\n        nxt.push_back(i);\n    }\n    for (int i = 0; i < ch.size(); ++i) {\n        if (in[i]) nxt.push_back(ch[i]);\n    }\n    swap(es, nxt);\n    sort(es.begin(), es.end());\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n    for (int i = 1; i <= m; ++i) {\n        cin >> T[i] >> X[i] >> Y[i];\n    }\n    for (int it = 0; it < B; ++it) {\n        int st = it * B + 1;\n        int ed = min((it + 1) * B, m);\n        if (st > ed) break;\n        solve(st, ed);\n    }\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures", "divide and conquer", "dsu", "graphs", "trees"], "dificulty": "2600", "interactive": false}