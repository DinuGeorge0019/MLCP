{
    "link": "https://codeforces.com//contest/961/problem/G",
    "problemId": "171418",
    "problem_idx": "G",
    "shortId": "961G",
    "contest_number": "961",
    "problem_submissions": {
        "G": [
            36970557,
            36961677,
            36955373,
            36966255,
            36968767,
            36972374,
            36973392,
            36957451,
            36991516,
            36977772,
            37364242,
            37112264,
            37103114
        ],
        "F": [
            36962483,
            58125816,
            58125730,
            36966139,
            36964087,
            37005545,
            36970234,
            36973408,
            36969033,
            36991746,
            37364493,
            37112764
        ],
        "E": [
            36956673,
            36957355,
            36966375,
            36957711,
            36958527,
            36964823,
            36966940,
            36964605,
            36962819,
            36970706,
            36966486,
            36958105,
            36958693,
            36959772,
            36960024,
            36961569,
            36960764,
            36960481,
            36957668,
            36960105
        ],
        "D": [
            36955388,
            36956052,
            36969754,
            36955080,
            36956362,
            36961025,
            36963713,
            36962592,
            36966993,
            36973138,
            36969906,
            36956687,
            36956700,
            36954860,
            36958377,
            36958046,
            36957936,
            36957484,
            36960554,
            36961499
        ],
        "C": [
            36953672,
            36954711,
            36971159,
            36953758,
            36954957,
            36955003,
            36960223,
            36959774,
            36965066,
            36959731,
            36967876,
            36954453,
            36954510,
            36957051,
            36956228,
            36956460,
            36956413,
            36954603,
            36954325,
            36955697
        ],
        "B": [
            36952423,
            36952593,
            36971775,
            36952372,
            36952637,
            36953362,
            36954152,
            36957455,
            36960770,
            36955533,
            36967266,
            36952701,
            36952953,
            36954148,
            36953570,
            36952980,
            36953956,
            36952386,
            36952552,
            36953095
        ],
        "A": [
            36951806,
            36951845,
            36972158,
            36951809,
            36951933,
            36951849,
            36952464,
            36956565,
            36959860,
            36954250,
            36966810,
            36951886,
            36952011,
            36951975,
            36952180,
            36951811,
            36952978,
            36951822,
            36951814,
            36951906
        ]
    },
    "name": "G. Partitions",
    "statement": "You are given a set of elements indexed from to . The weight of -th\r\nelement is . The weight of some subset of a given set is denoted as .\r\nThe weight of some partition of a given set into subsets is (recall that\r\na partition of a given set is a set of its subsets such that every\r\nelement of the given set belongs to exactly one subset in\r\npartition).Calculate the sum of weights of all partitions of a given set\r\ninto exactly subsets, and print it modulo . Two partitions are\r\nconsidered different iff there exist two elements and such that they\r\nbelong to the same set in one of the partitions, and to different sets\r\nin another partition.\r\n",
    "solutions": [
        "#include <stdio.h>\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <limits.h>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string.h>\n#include <string>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#pragma warning(disable:4996)\n#pragma comment(linker, \"/STACK:336777216\")\nusing namespace std;\n\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#define ldb ldouble\n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nint MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n#define szz(x) (int)(x).size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define Se second\n#define Fi first\n\nll mul_inv(ll a, ll b = MOD) {\n\tll t1 = a, t2 = b, t3;\n\tll v1 = 1, v2 = 0, v3;\n\twhile (t2 != 1) {\n\t\tll x = t1 / t2;\n\t\tt3 = t1 - x*t2;\n\t\tv3 = v1 - x*v2;\n\t\tt1 = t2, t2 = t3;\n\t\tv1 = v2, v2 = v3;\n\t}\n\treturn (v2 + b) % b;\n}\nll mypow(ll a, ll b) {\n\tif (b < 0) return 0;\n\tll rv = 1;\n\twhile (b) {\n\t\tif (b % 2) rv = (rv*a) % MOD;\n\t\ta = a*a%MOD;\n\t\tb /= 2;\n\t}\n\treturn rv;\n}\n\nll F[200050];\nll Finv[200050];\n\nll in[200050];\nint main() {\n\tll i, j;\n\tF[0] = 1;\n\tfor (i = 1; i <= 200000; i++) F[i] = F[i - 1] * i % MOD;\n\tfor (i = 0; i <= 200000; i++) Finv[i] = mul_inv(F[i]);\n\n\tint N, K;\n\tscanf(\"%d %d\", &N, &K);\n\tfor (i = 1; i <= N; i++) scanf(\"%lld\", &in[i]);\n\n\tll a1 = 0;\n\tfor (i = 0; i < K; i++) {\n\t\tll v1 = F[K - 1];\n\t\tv1 = v1 * Finv[i] % MOD;\n\t\tv1 = v1 * Finv[K - 1 - i] % MOD;\n\n\t\tll v2 = mypow(K - i, N - 1);\n\t\tv2 += mypow(K - i, N - 2) * (N - 1) % MOD;\n\t\tv1 = v1 * v2 % MOD;\n\t\tif (i % 2) a1 = (a1 - v1) % MOD;\n\t\telse a1 = (a1 + v1) % MOD;\n\t}\n\ta1 = (a1 + MOD) % MOD;\n\ta1 = a1 * Finv[K-1] % MOD;\n\n\tll a2 = 0;\n\tfor (i = 1; i <= N; i++) a2 = (a2 + in[i]) % MOD;\n\treturn !printf(\"%lld\\n\", a1*a2%MOD);\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "math",
        "number theory"
    ],
    "dificulty": "2700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\G. Partitions.json",
    "editorial_link": "https://codeforces.com//blog/entry/58743",
    "editorial": "Letâs look at some facts. At first, the answer is the sum of weights\r\ntaken with some coefficients . So, itâs enough to calculate those\r\ncoefficients.Then can be calculated by iterating on the size of the\r\nsubset containing -th element: , where is the number of partitions of\r\nset with elements into nonempty subsets with one subset of fixed size\r\nwhere belongs.This solution is still quite slow, so the next fact is: if\r\ntwo elements and belong to the same subset, then \"increases\" the\r\ncoefficient before . So for each element we can iterate over all\r\nelements which will lie in one subset with . In other words, . is the\r\nnumber of ways to divide set with elements into subsets in such a way\r\nthat elements and wil lie in one subset. can be calculated using\r\nStirling numbers of the second kind: let be the number of partitions of\r\nset with elements into non-empty subsets. If then , else we just merge\r\nand into one element and let .Final formula is . And the answer is\r\n.Counting Stirling numbers can be done with inclusion-exclusion\r\nprinciple or by searching Wiki: .Resulting complexity is .\r\n",
    "hint": []
}