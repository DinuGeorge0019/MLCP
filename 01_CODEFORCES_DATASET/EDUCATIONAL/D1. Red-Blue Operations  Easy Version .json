{
    "link": "https://codeforces.com//contest/1832/problem/D1",
    "problemId": "1919534",
    "problem_idx": "D1",
    "shortId": "1832D1",
    "contest_number": "1832",
    "problem_submissions": {
        "F": [
            205612816,
            205618187,
            205616065,
            205615360,
            205612997,
            205612699,
            205616615,
            205704621,
            205757584,
            205930525,
            205621852,
            205621757
        ],
        "E": [
            205588370,
            205576685,
            205587590,
            205562791,
            205578695,
            205581418,
            205576017,
            205588938,
            205587310,
            205585791,
            205594909,
            205587637,
            205568079,
            205590489,
            205592123,
            205595293,
            205581468,
            205598039,
            205585624
        ],
        "D1": [
            205582572,
            205571409,
            205573052,
            205565935,
            205571345,
            205569679,
            205567398,
            205577948,
            205578327,
            205578690,
            205578885,
            205573631,
            205580478,
            205584975,
            205584642,
            205576123,
            205577262,
            205587661,
            205590424,
            205578991,
            205594286
        ],
        "D2": [
            205582469,
            205571220,
            205573149,
            205573248,
            205571140,
            205587711,
            205587841,
            205578108,
            205578462,
            205578510,
            205604647,
            205579021,
            205580354,
            205589204,
            205584769,
            205584072,
            205587751,
            205599151,
            205586621,
            205599536
        ],
        "C": [
            205557102,
            205556400,
            205556488,
            205552484,
            205557070,
            205556143,
            205558460,
            205557880,
            205559387,
            205559279,
            205557942,
            205559043,
            205556434,
            205554797,
            205556994,
            205564356,
            205564037,
            205562522,
            205562917
        ],
        "B": [
            205552451,
            205550855,
            205551794,
            205549640,
            205552032,
            205552318,
            205551056,
            205550768,
            205554849,
            205551853,
            205553247,
            205555210,
            205553102,
            205550776,
            205552302,
            205556686,
            205557181,
            205553564,
            205556320
        ],
        "A": [
            205549496,
            205548656,
            205548697,
            205548635,
            205548771,
            205548615,
            205548617,
            205548590,
            205549420,
            205548691,
            205549006,
            205548793,
            205548840,
            205548603,
            205548831,
            205550263,
            205548997,
            205555130,
            205552258
        ]
    },
    "name": "D1. Red-Blue Operations  Easy Version ",
    "statement": ".You are given an array, consisting of n integers. Initially, all\r\nelements are red.You can apply the following operation to the array\r\nmultiple times. During the i-th operation, you select an element of the\r\narray; then: if the element is red, it increases by i and becomes blue;\r\nif the element is blue, it decreases by i and becomes red. The\r\noperations are numbered from 1, i. e. during the first operation some\r\nelement is changed by 1 and so on.You are asked q queries of the\r\nfollowing form: given an integer k, what can the largest minimum in the\r\narray be if you apply k operations to it? Note that the operations don’t\r\naffect the array between queries, all queries are asked on the initial\r\narray a.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\n\nconstexpr i64 inf = 1E18;\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int n, q;\n    std::cin >> n >> q;\n    \n    std::vector<i64> a(n);\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    \n    std::sort(a.begin(), a.end());\n    \n    std::vector<i64> f(n + 1, inf);\n    for (int i = 0; i < n; i++) {\n        f[i + 1] = std::min(f[i] + 1, a[i] + 1);\n    }\n    \n    i64 sum = std::accumulate(a.begin(), a.end(), 0LL);\n    while (q--) {\n        i64 k;\n        std::cin >> k;\n        \n        if (k < n) {\n            std::cout << std::min(f[k], a[k]) << \" \";\n        } else {\n            i64 ans;\n            i64 s = sum;\n            if ((k - n) % 2 == 0) {\n                ans = f[n] + k - n;\n                s += 1LL * n * (k + k - n + 1) / 2 - (k - n) / 2;\n            } else {\n                ans = std::min(a[n - 1], f[n - 1] + k - (n - 1));\n                s += 1LL * (n - 1) * (k + k - n + 2) / 2 - (k - n + 1) / 2;\n            }\n            ans = std::min(1LL * ans, s >= 0 ? s / n : (s - n + 1) / n);\n            std::cout << ans << \" \";\n        }\n    }\n    std::cout << \"\\n\";\n    \n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "greedy",
        "implementation",
        "math"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D1. Red-Blue Operations  Easy Version .json",
    "editorial_link": "https://codeforces.com//blog/entry/116454",
    "editorial": "Letâs try applying the operation to a single element multiple times. You\r\ncan see that when you apply an operation an odd number of times, the\r\nelement always gets larger. Alternatively, applying an operation an even\r\namount of times always makes it smaller (or equal in case of ). Thus,\r\ngenerally, we would want to apply an odd number of operations to as many\r\nelements as we can.Letâs start by investigating an easy case: . Since\r\nthere are so few operations, you can avoid subtracting from any element\r\nat all. Just one operation to each of elements. Which elements should\r\nget this operation? Obviously, smallest elements. If you donât pick at\r\nleast one of them, itâll remain as the minimum of the array. If you do,\r\nthe minimum will get larger than any of them. Another greedy idea is\r\nwhere to apply each operation to. We should add to the minimum element,\r\nto the second minimum and so on. You can show that it is always optimal\r\nby contradiction.What if ? Then we have to subtract from some elements.\r\nFirst, recognize that thereâs no more than one element that will become\r\nsmaller in the optimal answer. Consider an answer where at least two\r\nelements get smaller and move the later operation from one to another.\r\nNow both of them become larger.Moreover, for parity reasons, if , you\r\ncan increase all elements. Otherwise, you have to decrease exactly\r\none.Another greedy idea. You somewhat want the pair of operations\r\n(increase, decrease) to change the element as small as possible. In\r\nparticular, you can always make the change equal to . To show it, you\r\ncan look at some decreasing operation such that an increasing operation\r\ngoes right before it and they are applied to different elements. You can\r\nswap them. They remain the same types. However, both elements get only\r\nlarger. In the end, all adjacent increasing and decreasing operations go\r\nto the same element.Now, letâs think of the answer as the following\r\nsequence: adjacent pairs of (increase, decrease) and the separate\r\nincrease operations that are applied no more than once to each element.\r\nSince all blocks do , only the values in the lone increase operations\r\naffect the answer value. Obviously, we would want these lone increases\r\nto be , where is the number of changed elements ( or ). Once again, you\r\ncan show that you can always rearrange the operations to obtain\r\nthat.Finally, the answer looks like this: add to the minimum, to the\r\nsecond minimum, to the maximum or the second maximum depending on the\r\nparity. Before that, add to some elements. Since we know where to apply\r\nthe last operations, letâs apply them first. Then we want to apply âs to\r\nmake the minimum as large as possible. Well, we should always apply it\r\nto the current maximum. First, the minimum would remain as the original\r\nminimum. Then all elements will become equal to it at some point. Then\r\nwe will be spreading the âs equally among the elements. So every\r\nadditional operations, the minimum will be decreasing by .For the easy\r\nversion, you can simulate this process. Sort the array, apply the last\r\nincrease operations, find the minimum and the sum of the array, then\r\ncalculate the result based on that. Let . Let . Then the first\r\noperations of will not change the minimum. The rest operations will\r\ndecrease it by every operations. So it will get decreased by .Overall\r\ncomplexity: .\r\n",
    "hint": []
}