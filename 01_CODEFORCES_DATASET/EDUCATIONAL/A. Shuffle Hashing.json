{
    "link": "https://codeforces.com//contest/1278/problem/A",
    "problemId": "498930",
    "problem_idx": "A",
    "shortId": "1278A",
    "contest_number": "1278",
    "problem_submissions": {
        "E": [
            67224918,
            67231614,
            67223912,
            67253812,
            67225741,
            67224871,
            67225251,
            67224253,
            67224097,
            67228073,
            67224351,
            67238384,
            67238891,
            67235763,
            67230622,
            67227930,
            67239651,
            67240882,
            67235370,
            67231237,
            67232624
        ],
        "F": [
            67220843,
            67234059,
            67225490,
            67229828,
            67232198,
            67228232,
            67234554,
            67236753,
            67235814,
            67235952,
            67222634,
            67222261,
            67233844,
            67234877,
            67233597,
            67235880,
            168626483,
            67236179,
            67239000,
            67242413,
            67234942
        ],
        "D": [
            67217029,
            67303164,
            67301866,
            67298063,
            67237371,
            67236431,
            67235408,
            67220294,
            67220865,
            67220608,
            67221489,
            67220476,
            67219646,
            67219320,
            67220067,
            67226705,
            67224401,
            67222526,
            67227114,
            67223817,
            67223367,
            67231531,
            67228179,
            67226295
        ],
        "C": [
            67214007,
            67214267,
            67217998,
            67216889,
            67218307,
            67216554,
            67216623,
            67215042,
            67215238,
            67217005,
            67217682,
            67215492,
            67219419,
            67219630,
            67218331,
            67220921,
            67220564,
            67238779
        ],
        "B": [
            67212862,
            67212809,
            67214461,
            67213367,
            67214581,
            67214399,
            67214511,
            67213321,
            67213424,
            67214716,
            67216187,
            67217236,
            67216491,
            67238990,
            67224941,
            67214356,
            67216320,
            67214479,
            67213910
        ],
        "A": [
            67212605,
            67233989,
            67212600,
            67213460,
            67212650,
            67212623,
            67213201,
            67212677,
            67212601,
            67212657,
            67213584,
            67212831,
            67213003,
            67213058,
            67213442,
            67213081,
            67213875,
            67213272,
            67212886
        ]
    },
    "name": "A. Shuffle Hashing",
    "statement": "Polycarp has built his own web service. Being a modern web service it\r\nincludes login feature. And that always implies password security\r\nproblems.Polycarp decided to store the hash of the password, generated\r\nby the following algorithm: take the password p, consisting of lowercase\r\nLatin letters, and shuffle the letters randomly in it to obtain p\u2019 (p\u2019\r\ncan still be equal to p); generate two random strings, consisting of\r\nlowercase Latin letters, s_1 and s_2 (any of these strings can be\r\nempty); the resulting hash h = s_1 + p\u2019 + s_2, where addition is string\r\nconcatenation. For example, let the password p = \"\". Then p\u2019 can be\r\nequal to \"\". Random strings s1 = \"\" and s2 = \"\". Then h = \"\".Note that\r\nno letters could be deleted or added to p to obtain p\u2019, only the order\r\ncould be changed.Now Polycarp asks you to help him to implement the\r\npassword check module. Given the password p and the hash h, check that h\r\ncan be the hash for the password p.Your program should answer t\r\nindependent test cases.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nvoid solve(){\n\tstring s,t;\n\tcin >> s >> t;\n\tSORT(s);\n\trep(i,t.size()){\n\t\tif(i+s.size()-1 >= t.size()) break;\n\t\tstring S = \"\";\n\t\tfor(int j=i;j<i+s.size();j++)S.pb(t[j]);\n\t\tSORT(S);\n\t\tif(s == S) {puts(\"YES\"); return;}\n\t}\n\tputs(\"NO\");\n}\nint main(){\n\tint t; cin >> t;\n\twhile(t--)solve();\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "strings"
    ],
    "dificulty": "1000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Shuffle Hashing.json",
    "editorial_link": "https://codeforces.com//blog/entry/72330",
    "editorial": "The general idea of the solution is to check that string contains some\r\nsubstring which is a permutation of . The constraints were so low you\r\ncould do it with any algorithm, even per test case could pass.The most\r\nstraightforward way was to iterate over the substring of , sort it and\r\ncheck if it\u00e2\u0080\u0099s equal to sorted. That\u00e2\u0080\u0099s .Next you could notice than only\r\nsubstrings of length matter and shave another off the complexity to get\r\n.After that you might remember that the size of the alphabet is pretty\r\nlow. And one string is a permutation of another one if the amounts of\r\nletters \u00e2\u0080\u0099a\u00e2\u0080\u0099, letters \u00e2\u0080\u0099b\u00e2\u0080\u0099 and so on in them are equal. So you can\r\nprecalculate array , where is equal to the amount of the -th letter of\r\nthe alphabet in . Calculating this array for substrings will be each, so\r\nthat makes it .Then notice how easy it is to recalculate the letter\r\ncounts going from some substring to . Just subtract from the amount of\r\nthe -th letter and add to the amount of the -th letter. Comparing two\r\narray every time will still lead to , though.The final optimization is\r\nto maintain the boolean array such that means that is equal to the\r\ncurrent value of of the substring. You are updating just two values of\r\non each step, thus only two values of might change. You want all the\r\nvalues to be , so keep the number of values in that array and say \"\" if\r\nthat number is equal to . That finally makes the solution per test case.\r\n"
}