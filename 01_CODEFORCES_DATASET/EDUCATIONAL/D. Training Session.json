{
    "link": "https://codeforces.com//contest/1598/problem/D",
    "problemId": "1138073",
    "problem_idx": "D",
    "shortId": "1598D",
    "contest_number": "1598",
    "problem_submissions": {
        "G": [
            131442050,
            131445550,
            131474021,
            131733851,
            189236477,
            131533150,
            131521436,
            131521173,
            131520806,
            131458159
        ],
        "F": [
            131413919,
            131426175,
            131419948,
            131424974,
            131423465,
            131425512,
            131426044,
            131429617,
            131434101,
            131424856,
            131429061,
            135925566,
            131432789,
            131436462,
            131426160,
            131433379,
            131432739,
            131442015,
            131426352,
            131438575
        ],
        "E": [
            131409216,
            131417508,
            131411965,
            131416590,
            131414689,
            131417539,
            131419673,
            131417908,
            131417850,
            131413609,
            131419666,
            131418620,
            131426224,
            131434401,
            131422338,
            131425095,
            131423673,
            131432059,
            131428300
        ],
        "D": [
            131405446,
            131408232,
            131403803,
            131406730,
            131406693,
            131408831,
            131409679,
            131411498,
            131409766,
            131431099,
            131412818,
            131410917,
            131408763,
            131411240,
            131414979,
            131418536,
            131414491,
            131405913,
            131414013,
            131411546
        ],
        "C": [
            131402318,
            131402805,
            131401746,
            131403276,
            131404307,
            131403297,
            131407011,
            131405600,
            131402882,
            131404574,
            131406244,
            131405518,
            131403235,
            131406335,
            131403809,
            131404263,
            131402426,
            131410937,
            131406878
        ],
        "B": [
            131399659,
            131401435,
            131400062,
            131400441,
            131401570,
            131401020,
            131401164,
            131404218,
            131400433,
            131402267,
            131404703,
            131402822,
            131405775,
            131403060,
            131401809,
            131401389,
            131400640,
            131406015,
            131403932
        ],
        "A": [
            131398034,
            131398273,
            131398102,
            131398196,
            131398135,
            131398297,
            131398147,
            131400227,
            131399230,
            131398720,
            131400611,
            131612251,
            131398353,
            131399540,
            131399744,
            131398269,
            131398178,
            131398070,
            131401090,
            131399096
        ]
    },
    "name": "D. Training Session",
    "statement": "Monocarp is the coach of the Berland State University programming teams.\r\nHe decided to compose a problemset for a training session for his\r\nteams.Monocarp has n problems that none of his students have seen yet.\r\nThe i-th problem has a topic a_i (an integer from 1 to n) and a\r\ndifficulty b_i (an integer from 1 to n). All problems are different,\r\nthat is, there are no two tasks that have the same topic and difficulty\r\nat the same time.Monocarp decided to select exactly 3 problems from n\r\nproblems for the problemset. The problems should satisfy of two\r\nconditions (possibly, both): the topics of all three selected problems\r\nare different; the difficulties of all three selected problems are\r\ndifferent. Your task is to determine the number of ways to select three\r\nproblems for the problemset.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 10.10.2021 12:13:12       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> a(n), b(n);\n    for (int i = 0; i < n; i++) {\n      cin >> a[i] >> b[i];\n      --a[i]; --b[i];\n    }\n    vector<int> ca(n), cb(n);\n    for (int i = 0; i < n; i++) {\n      ca[a[i]] += 1;\n      cb[b[i]] += 1;\n    }\n    long long ans = (long long) n * (n - 1) * (n - 2) / 6;\n    for (int i = 0; i < n; i++) {\n      ans -= (long long) (ca[a[i]] - 1) * (cb[b[i]] - 1);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "data structures",
        "geometry",
        "implementation",
        "math"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Training Session.json",
    "editorial_link": "https://codeforces.com//blog/entry/95890",
    "editorial": "There are many different ways to solve this problem, but, in my opinion,\r\nthe easiest one is to count all possible triples and subtract the number\r\nof bad triples.The first part is easy the number of ways to choose\r\nelements out of is just . The second part is a bit tricky.What does it\r\nmean that the conditions in the statements are not fulfilled? There is a\r\npair of problems with equal difficulty, and there is a pair of problems\r\nwith the same topic. Since all problems in the input are different, it\r\nmeans that every bad triple has the following form: i. e. there exists a\r\nproblem such that it shares the difficulty with one of the other two\r\nproblems, and the topic with the remaining problem of the triple.This\r\nobservation allows us to calculate the number of bad triples as follows:\r\nwe will iterate on the \"central\" problem (the one that shares the topic\r\nwith the second problem and the difficulty with the third problem). If\r\nwe pick as the \"central\" problem, we need to choose the other two.\r\nCounting ways to choose the other problems is easy if we precalculate\r\nthe number of problems for each topic/difficulty: let be the number of\r\nproblems with topic , and be the number of problems with difficulty ;\r\nthen, if we pick the problem as the \"central one\", there are ways to\r\nchoose a problem that shares the topic with it, and ways to choose a\r\nproblem that has the same difficulty so, we have to subtract from the\r\nanswer for every problem .\r\n"
}