{
    "link": "https://codeforces.com//contest/665/problem/E",
    "problemId": "55555",
    "problem_idx": "E",
    "shortId": "665E",
    "contest_number": "665",
    "problem_submissions": {
        "F": [
            35437149,
            27600620,
            27600570,
            27600365,
            207086930,
            17511081,
            17511048,
            17408931,
            17465318,
            17465113,
            17465105,
            17421220,
            17419616,
            17419504,
            17407442
        ],
        "E": [
            17404108,
            17403997,
            17404019,
            17404185,
            17404405,
            17405241,
            17404852,
            17406609,
            17403872,
            17404958,
            17406585,
            17405102,
            17402241,
            17404889,
            17406152,
            17407503,
            17407294,
            17402667,
            17407651,
            17402391
        ],
        "D": [
            17402746,
            17402888,
            17403061,
            17402886,
            17403632,
            17402659,
            17403180,
            17402538,
            17403092,
            17404017,
            17402765,
            17404460,
            17403586,
            17404039,
            17404874,
            17597162,
            17597147,
            17405860,
            17404856,
            17403614,
            17402947,
            17403487
        ],
        "B": [
            17402058,
            17402143,
            17401985,
            17401812,
            17402480,
            17401996,
            17402111,
            17401950,
            17401883,
            17402289,
            17402172,
            17404614,
            17405448,
            17402800,
            17402279,
            17402724,
            17403040,
            17404322,
            17403505,
            17404527
        ],
        "C": [
            17401652,
            17401814,
            17402423,
            17402078,
            17401921,
            17401528,
            17401657,
            17401538,
            17402228,
            17402780,
            17401867,
            17401866,
            17401442,
            17401822,
            17401577,
            17403531,
            17403479,
            17401483,
            17404073,
            17401636,
            17404128
        ],
        "A": [
            17401480,
            17401614,
            17401638,
            17401502,
            17401615,
            17401450,
            17401531,
            17402688,
            17401495,
            17401597,
            17401511,
            17401510,
            17405192,
            17401618,
            17401993,
            17401713,
            17402074,
            17402469,
            17404975,
            17408296,
            17406598
        ]
    },
    "name": "E. Beautiful Subarrays",
    "statement": "One day, ZS the Coder wrote down an array of integers with elements .A\r\nsubarray of the array is a sequence for some integers such that . ZS the\r\nCoder thinks that a subarray of is beautiful if the bitwise xor of all\r\nthe elements in the subarray is at least .Help ZS the Coder find the\r\nnumber of beautiful subarrays of !\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\n\nint tab[1000007];\n\nint l;\n\nint dzie[40000007][2];\nint ile[40000007];\n\nint d=32;\n\nint p1, p2;\n\nvector <int> vv;\nvector <int> kk;\n\nlong long wyn;\n\nvoid daj(int v)\n{\n    vv.clear();\n    for (int i=1; i<=d; i++)\n    {\n        vv.push_back(v&1);\n        v>>=1;\n    }\n    reverse(vv.begin(), vv.end());\n}\n\nvoid wrzu(int v)\n{\n    daj(v);\n    vector <int> scie;\n    scie.push_back(0);\n    for (int i=0; i<d; i++)\n    {\n        if (!dzie[scie.back()][vv[i]])\n        {\n            l++;\n            dzie[scie.back()][vv[i]]=l;\n        }\n        p1=dzie[scie.back()][vv[i]];\n        scie.push_back(p1);\n    }\n    for (int i=0; i<scie.size(); i++)\n    {\n        ile[scie[i]]++;\n    }\n}\n\ninline void dod(int v)\n{\n    if (v)\n    wyn+=ile[v];\n}\n\nvoid rob(int v)\n{\n    daj(v);\n    int u=0;\n    for (int i=0; i<d; i++)\n    {\n        if (kk[i])\n        {\n            if (!dzie[u][vv[i]^1])\n            {\n                l++;\n                dzie[u][vv[i]^1]=l;\n            }\n            u=dzie[u][vv[i]^1];\n        }\n        else\n        {\n            dod(dzie[u][vv[i]^1]);\n            if (!dzie[u][vv[i]])\n            {\n                l++;\n                dzie[u][vv[i]]=l;\n            }\n            u=dzie[u][vv[i]];\n        }\n    }\n    dod(u);\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n    daj(k);\n    kk=vv;\n    for (int i=1; i<=n; i++)\n    {\n        scanf(\"%d\", &tab[i]);\n    }\n    for (int i=1; i<=n; i++)\n    {\n        tab[i]^=tab[i-1];\n    }\n    for (int i=1; i<=n; i++)\n    {\n        wrzu(tab[i-1]);\n        rob(tab[i]);\n    }\n    printf(\"%lld\\n\", wyn);\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "divide and conquer",
        "strings",
        "trees"
    ],
    "dificulty": "2100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Beautiful Subarrays.json",
    "editorial_link": "https://codeforces.com//blog/entry/44466",
    "editorial": "The problem was suggested by Zi Song Yeoh zscoder. The sign is used for\r\nthe binary operation for bitwise exclusive or. Let be the xor of the\r\nfirst elements on the prefix of . Then the interval is beautiful if .\r\nLetâs iterate over from to and consider the values as the binary\r\nstrings. On each iteration we should increase the answer by the value\r\nthe number of numbers () so . To do that we can use the trie data\r\nstructure. Letâs store in the trie all the values for . Besides the\r\nstructure of the trie we should also store in each vertex the number of\r\nleaves in the subtree of that vertex (it can be easily done during\r\nadding of each binary string). To calculate the value letâs go down by\r\nthe trie from the root. Letâs accumulate the value equals to the xor of\r\nthe prefix of the value with the already passed in the trie path. Let\r\nthe current bit in be equal to and be the depth of the current vertex in\r\nthe trie. If the number then we can increase by the number of leaves in\r\nvertex , because all the leaves in the subtree of tha vertex correspond\r\nto the values that for sure gives . After that we should go down in the\r\nsubtree . Otherwise if then we should simply go down to the subtree and\r\nrecalculate the value . C++ solution\r\n",
    "hint": []
}