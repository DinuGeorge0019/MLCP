{"link": "https://codeforces.com//contest/1569/problem/C", "problemId": "1103181", "problem_idx": "C", "shortId": "1569C", "contest_number": "1569", "problem_submissions": {"F": [128266355, 128271363, 128276594, 128274140, 128277636, 128276419, 128239230, 128386349, 128320123], "E": [128250268, 128256767, 128246439, 128253452, 128257933, 128258504, 128255293, 128254536, 128252116, 128261192, 128578023, 128259291, 128263798, 128266969, 128259594, 128258410, 128275140, 128271709, 128263862, 128264259], "D": [128235337, 128235527, 128231804, 128235402, 128242825, 128262573, 128235767, 128236235, 128236769, 128233977, 128578016, 128240282, 128241897, 128232635, 128238819, 128243586, 128233606, 128230968, 128243956, 128245831], "C": [128220989, 128228983, 128226656, 128226748, 128234279, 128264995, 128226270, 128225854, 128229844, 128225694, 128578004, 128230030, 128228479, 128225884, 128230468, 128226610, 128225551, 128233122, 128232240, 128234418], "B": [128217208, 128223439, 128220536, 128221217, 128228682, 128267165, 128220994, 128220572, 128221551, 128221442, 128577996, 128221801, 128220084, 128221194, 128224466, 128232979, 128220020, 128224325, 128224652, 128224175], "A": [128212769, 128212941, 128213029, 128212974, 128213857, 128267874, 128212779, 128212821, 128212915, 128213233, 128577977, 128213929, 128212944, 128212794, 128212959, 128213921, 128212839, 128214062, 128216496, 128214843]}, "name": "C. Jury Meeting", "statement": "n people gathered to hold a jury meeting of the upcoming competition,\r\nthe i-th member of the jury came up with a_i tasks, which they want to\r\nshare with each other.First, the jury decides on the order which they\r\nwill follow while describing the tasks. Let that be a permutation p of\r\nnumbers from 1 to n (an array of size n where each integer from 1 to n\r\noccurs exactly once).Then the discussion goes as follows: If a jury\r\nmember p_1 has some tasks left to tell, then they tell one task to\r\nothers. Otherwise, they are skipped. If a jury member p_2 has some tasks\r\nleft to tell, then they tell one task to others. Otherwise, they are\r\nskipped. ... If a jury member p_n has some tasks left to tell, then they\r\ntell one task to others. Otherwise, they are skipped. If there are still\r\nmembers with tasks left, then the process repeats from the start.\r\nOtherwise, the discussion ends. A permutation p is nice if none of the\r\njury members tell two or more of their own tasks in a row. Count the\r\nnumber of nice permutations. The answer may be really large, so print it\r\nmodulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include \"bits/stdc++.h\"\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate<class T> using pq = priority_queue<T>;\ntemplate<class T> using pqg = priority_queue<T, vector<T>, greater<T>>;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a,x) for (auto& a : x)\n#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n\ntemplate<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; }\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nvoid __print(int x) {cerr << x;}\nvoid __print(long x) {cerr << x;}\nvoid __print(long long x) {cerr << x;}\nvoid __print(unsigned x) {cerr << x;}\nvoid __print(unsigned long x) {cerr << x;}\nvoid __print(unsigned long long x) {cerr << x;}\nvoid __print(float x) {cerr << x;}\nvoid __print(double x) {cerr << x;}\nvoid __print(long double x) {cerr << x;}\nvoid __print(char x) {cerr << '\\'' << x << '\\'';}\nvoid __print(const char *x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(const string &x) {cerr << '\\\"' << x << '\\\"';}\nvoid __print(bool x) {cerr << (x ? \"true\" : \"false\");}\n\ntemplate<typename T, typename V>\nvoid __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}\ntemplate<typename T>\nvoid __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}\nvoid _print() {cerr << \"]\\n\";}\ntemplate <typename T, typename... V>\nvoid _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}\n#ifdef DEBUG\n#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;\n#else\n#define dbg(x...)\n#endif\n\n\nconst int MOD = 998244353;\nconst char nl = '\\n';\nconst int MX = 200001; \n\n\nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n    mi operator++(int) { mi temp; temp.v = v++; return temp; }\n    mi operator--(int) { mi temp; temp.v = v--; return temp; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvoid __print(mi X) {\n    cout << X.v;\n}\nmi facs[MX];\nmi facInvs[MX];\n\nmi choose(mi _a, mi _b) {\n    ll a = (ll) _a, b = (ll) _b;\n\tif (b > a) return 0;\n\tif (a < 0) return 0;\n\tif (b < 0) return 0;\n    mi cur = facs[a];\n    cur = cur * facInvs[b];\n    cur = cur * facInvs[a-b];\n    return cur;\n}\n\nvoid initFacs() {\n\tfacs[0] = 1;\n\tFOR(i, 1, MX) {\n\t\tfacs[i] = (facs[i-1] * i);\n\t}\n    facInvs[MX - 1] = inv(facs[MX-1]);\n    F0Rd(i, MX-1) {\n        facInvs[i] = facInvs[i+1] * (i+1);\n    }\n}\nvoid solve() {\n    int N; cin >> N;\n    vi A(N); F0R(i, N) cin >> A[i];\n    sort(all(A));\n    if (A[N-1] == A[N-2]) {\n        cout << facs[N] << nl;\n    } else if (A[N-1] - 2 >= A[N-2]) {\n        cout << 0 << nl;\n    } else {\n        int cnt = 0;\n        F0R(i, N) if (A[i] == A[N-2]) cnt++;\n        cout << facs[N] * cnt * inv(mi(cnt+1)) << nl;\n    }\n\n}\n \nint main() {\n    cin.tie(0)->sync_with_stdio(0); \n    cin.exceptions(cin.failbit);\n    initFacs();\n    int T = 1;\n    cin >> T;\n    while(T--) {\n        solve();\n    }\n\n\treturn 0;\n}\n\n\n"], "input": "", "output": "", "tags": ["combinatorics", "math"], "dificulty": "1500", "interactive": false}