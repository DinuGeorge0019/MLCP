{
    "link": "https://codeforces.com//contest/1860/problem/F",
    "problemId": "2169702",
    "problem_idx": "F",
    "shortId": "1860F",
    "contest_number": "1860",
    "problem_submissions": {
        "F": [
            219298549,
            219320447,
            219349019,
            219323121,
            219334429,
            219337442,
            219335056,
            219339341,
            219339231,
            219349246,
            219345811,
            219439688,
            219439045,
            219356857,
            219353864,
            219402976,
            219353456,
            219351823
        ],
        "E": [
            219277150,
            219281408,
            219287269,
            219300383,
            219293770,
            219301781,
            219289069,
            219306188,
            219288291,
            219288789,
            219301050,
            219298191,
            219305638,
            219306388,
            219300992,
            219313680,
            219301529,
            219309490,
            219305863,
            219309540,
            219307800
        ],
        "D": [
            219271388,
            219273923,
            219270716,
            219286342,
            219405254,
            219345669,
            219344552,
            219277413,
            219284438,
            219280247,
            219290826,
            219278202,
            219277998,
            219274616,
            219275328,
            219282484,
            219281832,
            219279471,
            219288325,
            219282155,
            219284217,
            219287012,
            219287888
        ],
        "C": [
            219264168,
            219264568,
            219266116,
            219265339,
            219269044,
            219276912,
            219269876,
            219279690,
            219266598,
            219268637,
            219263040,
            219261658,
            219264629,
            219267625,
            219267964,
            219267177,
            219271968,
            219274243,
            219264405,
            219273316
        ],
        "B": [
            219260635,
            219258799,
            219260447,
            219259349,
            219260950,
            219267717,
            219262012,
            219271581,
            219260726,
            219261008,
            219259442,
            219257734,
            219259759,
            219262401,
            219260169,
            219259084,
            219263649,
            219264522,
            219272480,
            219264690
        ],
        "A": [
            219257237,
            219257029,
            219257674,
            219257720,
            219257171,
            219258923,
            219257078,
            219260398,
            219257258,
            219257446,
            219257236,
            219256961,
            219257126,
            219257819,
            219257229,
            219257120,
            219257449,
            219257142,
            219257016,
            219258968
        ]
    },
    "name": "F. Evaluate RBS",
    "statement": "You are given 2n tuples of values (a, b, c), where a and b are positive\r\nintegers and c is a bracket \u201d or \u201d. Exactly n tuples have c = \u201d and the\r\nother n tuples have c = \u201d.You are asked to choose two positive values x\r\nand y (x > 0 and y > 0; ) and sort the tuples in the increasing value of\r\na\r\ncdot x + b\r\ncdot y. If several tuples have the same value, you can place them in any\r\norder among themselves.Is it possible to choose such x and y that taking\r\nbrackets c from the tuples in the resulting order produces a regular\r\nbracket sequence?\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\n\nusing i64 = long long;\ntemplate<class T>\nstruct Point {\n    T x;\n    T y;\n    Point(T x_ = 0, T y_ = 0) : x(x_), y(y_) {}\n    \n    template<class U>\n    operator Point<U>() {\n        return Point<U>(U(x), U(y));\n    }\n    Point &operator+=(Point p) & {\n        x += p.x;\n        y += p.y;\n        return *this;\n    }\n    Point &operator-=(Point p) & {\n        x -= p.x;\n        y -= p.y;\n        return *this;\n    }\n    Point &operator*=(T v) & {\n        x *= v;\n        y *= v;\n        return *this;\n    }\n    Point &operator/=(T v) & {\n        x /= v;\n        y /= v;\n        return *this;\n    }\n    Point operator-() const {\n        return Point(-x, -y);\n    }\n    friend Point operator+(Point a, Point b) {\n        return a += b;\n    }\n    friend Point operator-(Point a, Point b) {\n        return a -= b;\n    }\n    friend Point operator*(Point a, T b) {\n        return a *= b;\n    }\n    friend Point operator/(Point a, T b) {\n        return a /= b;\n    }\n    friend Point operator*(T a, Point b) {\n        return b *= a;\n    }\n    friend bool operator==(Point a, Point b) {\n        return a.x == b.x && a.y == b.y;\n    }\n    friend std::istream &operator>>(std::istream &is, Point &p) {\n        return is >> p.x >> p.y;\n    }\n    friend std::ostream &operator<<(std::ostream &os, Point p) {\n        return os << \"(\" << p.x << \", \" << p.y << \")\";\n    }\n};\n\ntemplate<class T>\nT dot(Point<T> a, Point<T> b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ntemplate<class T>\nT cross(Point<T> a, Point<T> b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ntemplate<class T>\nT square(Point<T> p) {\n    return dot(p, p);\n}\n\ntemplate<class T>\ndouble length(Point<T> p) {\n    return std::sqrt(double(square(p)));\n}\n\nlong double length(Point<long double> p) {\n    return std::sqrt(square(p));\n}\n\ntemplate<class T>\nPoint<T> normalize(Point<T> p) {\n    return p / length(p);\n}\n\ntemplate<class T>\nstruct Line {\n    Point<T> a;\n    Point<T> b;\n    Line(Point<T> a_ = Point<T>(), Point<T> b_ = Point<T>()) : a(a_), b(b_) {}\n};\n\ntemplate<class T>\nPoint<T> rotate(Point<T> a) {\n    return Point(-a.y, a.x);\n}\n\ntemplate<class T>\nint sgn(Point<T> a) {\n    return a.y > 0 || (a.y == 0 && a.x > 0) ? 1 : -1;\n}\n\ntemplate<class T>\nbool pointOnLineLeft(Point<T> p, Line<T> l) {\n    return cross(l.b - l.a, p - l.a) > 0;\n}\n\ntemplate<class T>\nPoint<T> lineIntersection(Line<T> l1, Line<T> l2) {\n    return l1.a + (l1.b - l1.a) * (cross(l2.b - l2.a, l1.a - l2.a) / cross(l2.b - l2.a, l1.a - l1.b));\n}\n\ntemplate<class T>\nbool pointOnSegment(Point<T> p, Line<T> l) {\n    return cross(p - l.a, l.b - l.a) == 0 && std::min(l.a.x, l.b.x) <= p.x && p.x <= std::max(l.a.x, l.b.x)\n        && std::min(l.a.y, l.b.y) <= p.y && p.y <= std::max(l.a.y, l.b.y);\n}\n\ntemplate<class T>\nbool pointInPolygon(Point<T> a, std::vector<Point<T>> p) {\n    int n = p.size();\n    for (int i = 0; i < n; i++) {\n        if (pointOnSegment(a, Line(p[i], p[(i + 1) % n]))) {\n            return true;\n        }\n    }\n    \n    int t = 0;\n    for (int i = 0; i < n; i++) {\n        auto u = p[i];\n        auto v = p[(i + 1) % n];\n        if (u.x < a.x && v.x >= a.x && pointOnLineLeft(a, Line(v, u))) {\n            t ^= 1;\n        }\n        if (u.x >= a.x && v.x < a.x && pointOnLineLeft(a, Line(u, v))) {\n            t ^= 1;\n        }\n    }\n    \n    return t == 1;\n}\n\n// 0 : not intersect\n// 1 : strictly intersect\n// 2 : overlap\n// 3 : intersect at endpoint\ntemplate<class T>\nstd::tuple<int, Point<T>, Point<T>> segmentIntersection(Line<T> l1, Line<T> l2) {\n    if (std::max(l1.a.x, l1.b.x) < std::min(l2.a.x, l2.b.x)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    if (std::min(l1.a.x, l1.b.x) > std::max(l2.a.x, l2.b.x)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    if (std::max(l1.a.y, l1.b.y) < std::min(l2.a.y, l2.b.y)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    if (std::min(l1.a.y, l1.b.y) > std::max(l2.a.y, l2.b.y)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    if (cross(l1.b - l1.a, l2.b - l2.a) == 0) {\n        if (cross(l1.b - l1.a, l2.a - l1.a) != 0) {\n            return {0, Point<T>(), Point<T>()};\n        } else {\n            auto maxx1 = std::max(l1.a.x, l1.b.x);\n            auto minx1 = std::min(l1.a.x, l1.b.x);\n            auto maxy1 = std::max(l1.a.y, l1.b.y);\n            auto miny1 = std::min(l1.a.y, l1.b.y);\n            auto maxx2 = std::max(l2.a.x, l2.b.x);\n            auto minx2 = std::min(l2.a.x, l2.b.x);\n            auto maxy2 = std::max(l2.a.y, l2.b.y);\n            auto miny2 = std::min(l2.a.y, l2.b.y);\n            Point<T> p1(std::max(minx1, minx2), std::max(miny1, miny2));\n            Point<T> p2(std::min(maxx1, maxx2), std::min(maxy1, maxy2));\n            if (!pointOnSegment(p1, l1)) {\n                std::swap(p1.y, p2.y);\n            }\n            if (p1 == p2) {\n                return {3, p1, p2};\n            } else {\n                return {2, p1, p2};\n            }\n        }\n    }\n    auto cp1 = cross(l2.a - l1.a, l2.b - l1.a);\n    auto cp2 = cross(l2.a - l1.b, l2.b - l1.b);\n    auto cp3 = cross(l1.a - l2.a, l1.b - l2.a);\n    auto cp4 = cross(l1.a - l2.b, l1.b - l2.b);\n    \n    if ((cp1 > 0 && cp2 > 0) || (cp1 < 0 && cp2 < 0) || (cp3 > 0 && cp4 > 0) || (cp3 < 0 && cp4 < 0)) {\n        return {0, Point<T>(), Point<T>()};\n    }\n    \n    Point p = lineIntersection(l1, l2);\n    if (cp1 != 0 && cp2 != 0 && cp3 != 0 && cp4 != 0) {\n        return {1, p, p};\n    } else {\n        return {3, p, p};\n    }\n}\n\ntemplate<class T>\nbool segmentInPolygon(Line<T> l, std::vector<Point<T>> p) {\n    int n = p.size();\n    if (!pointInPolygon(l.a, p)) {\n        return false;\n    }\n    if (!pointInPolygon(l.b, p)) {\n        return false;\n    }\n    for (int i = 0; i < n; i++) {\n        auto u = p[i];\n        auto v = p[(i + 1) % n];\n        auto w = p[(i + 2) % n];\n        auto [t, p1, p2] = segmentIntersection(l, Line(u, v));\n        \n        if (t == 1) {\n            return false;\n        }\n        if (t == 0) {\n            continue;\n        }\n        if (t == 2) {\n            if (pointOnSegment(v, l) && v != l.a && v != l.b) {\n                if (cross(v - u, w - v) > 0) {\n                    return false;\n                }\n            }\n        } else {\n            if (p1 != u && p1 != v) {\n                if (pointOnLineLeft(l.a, Line(v, u))\n                    || pointOnLineLeft(l.b, Line(v, u))) {\n                    return false;\n                }\n            } else if (p1 == v) {\n                if (l.a == v) {\n                    if (pointOnLineLeft(u, l)) {\n                        if (pointOnLineLeft(w, l)\n                            && pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    } else {\n                        if (pointOnLineLeft(w, l)\n                            || pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    }\n                } else if (l.b == v) {\n                    if (pointOnLineLeft(u, Line(l.b, l.a))) {\n                        if (pointOnLineLeft(w, Line(l.b, l.a))\n                            && pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    } else {\n                        if (pointOnLineLeft(w, Line(l.b, l.a))\n                            || pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    }\n                } else {\n                    if (pointOnLineLeft(u, l)) {\n                        if (pointOnLineLeft(w, Line(l.b, l.a))\n                            || pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    } else {\n                        if (pointOnLineLeft(w, l)\n                            || pointOnLineLeft(w, Line(u, v))) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\ntemplate<class T>\nstd::vector<Point<T>> hp(std::vector<Line<T>> lines) {\n    std::sort(lines.begin(), lines.end(), [&](auto l1, auto l2) {\n        auto d1 = l1.b - l1.a;\n        auto d2 = l2.b - l2.a;\n        \n        if (sgn(d1) != sgn(d2)) {\n            return sgn(d1) == 1;\n        }\n        \n        return cross(d1, d2) > 0;\n    });\n    \n    std::deque<Line<T>> ls;\n    std::deque<Point<T>> ps;\n    for (auto l : lines) {\n        if (ls.empty()) {\n            ls.push_back(l);\n            continue;\n        }\n        \n        while (!ps.empty() && !pointOnLineLeft(ps.back(), l)) {\n            ps.pop_back();\n            ls.pop_back();\n        }\n        \n        while (!ps.empty() && !pointOnLineLeft(ps[0], l)) {\n            ps.pop_front();\n            ls.pop_front();\n        }\n        \n        if (cross(l.b - l.a, ls.back().b - ls.back().a) == 0) {\n            if (dot(l.b - l.a, ls.back().b - ls.back().a) > 0) {\n                \n                if (!pointOnLineLeft(ls.back().a, l)) {\n                    assert(ls.size() == 1);\n                    ls[0] = l;\n                }\n                continue;\n            }\n            return {};\n        }\n        \n        ps.push_back(lineIntersection(ls.back(), l));\n        ls.push_back(l);\n    }\n    \n    while (!ps.empty() && !pointOnLineLeft(ps.back(), ls[0])) {\n        ps.pop_back();\n        ls.pop_back();\n    }\n    if (ls.size() <= 2) {\n        return {};\n    }\n    ps.push_back(lineIntersection(ls[0], ls.back()));\n    \n    return std::vector(ps.begin(), ps.end());\n}\n\nusing P = Point<i64>;\n\nvoid solve() {\n    int n;\n    std::cin >> n;\n    n *= 2;\n    \n    std::vector<P> a;\n    std::vector<int> b;\n    a.reserve(n);\n    b.reserve(n);\n    std::map<std::array<int, 2>, int> ind;\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        std::cin >> x >> y;\n        char p;\n        std::cin >> p;\n        int val = p == '(' ? 1 : -1;\n        if (ind.count({x, y})) {\n            b[ind[{x, y}]] += val;\n        } else {\n            ind[{x, y}] = a.size();\n            a.push_back({x, y});\n            b.push_back(val);\n        }\n    }\n    n = a.size();\n    \n    std::vector<int> p(n), invp(n);\n    std::vector<int> s(n + 1);\n    std::iota(p.begin(), p.end(), 0);\n    std::sort(p.begin(), p.end(),\n        [&](int i, int j) {\n            return a[i].x < a[j].x || (a[i].x == a[j].x && a[i].y < a[j].y);\n        });\n    int bad = 0;\n    for (int i = 0; i < n; i++) {\n        invp[p[i]] = i;\n        s[i + 1] = s[i] + b[p[i]];\n        bad += (s[i + 1] < 0);\n    }\n    if (bad == 0) {\n        std::cout << \"YES\\n\";\n        return;\n    }\n    \n    std::vector<std::tuple<P, int, int>> e;\n    e.reserve(n * (n - 1) / 2);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i].x < a[j].x && a[i].y > a[j].y) {\n                P v = rotate(a[j] - a[i]);\n                e.push_back({v, i, j});\n            }\n        }\n    }\n    std::sort(e.begin(), e.end(),\n        [&](auto a, auto b) {\n            return cross(std::get<0>(a), std::get<0>(b)) > 0;\n        });\n    int E = e.size();\n    for (int l = 0, r = 0; l < E; l = r) {\n        while (r < E && cross(std::get<0>(e[l]), std::get<0>(e[r])) == 0) {\n            r++;\n        }\n        std::vector<std::array<int, 2>> seg;\n        seg.reserve(r - l);\n        for (int i = l; i < r; i++) {\n            auto [_, x, y] = e[i];\n            seg.push_back({invp[x], invp[y]});\n        }\n        std::sort(seg.begin(), seg.end());\n        auto tmp = std::move(seg);\n        for (auto [l, r] : tmp) {\n            if (!seg.empty() && l <= seg.back()[1]) {\n                seg.back()[1] = std::max(seg.back()[1], r);\n            } else {\n                seg.push_back({l, r});\n            }\n        }\n        for (auto [l, r] : seg) {\n            for (int i = l + 1; i <= r; i++) {\n                bad -= (s[i] < 0);\n            }\n        }\n        if (bad == 0) {\n            std::cout << \"YES\\n\";\n            return;\n        }\n        for (auto [l, r] : seg) {\n            std::reverse(p.begin() + l, p.begin() + r + 1);\n            for (int i = l; i <= r; i++) {\n                invp[p[i]] = i;\n                s[i + 1] = s[i] + b[p[i]];\n            }\n            for (int i = l + 1; i <= r; i++) {\n                bad += (s[i] < 0);\n            }\n        }\n    }\n    std::cout << \"NO\\n\";\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    \n    int t;\n    std::cin >> t;\n    \n    while (t--) {\n        solve();\n    }\n    \n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "geometry",
        "implementation",
        "math",
        "sortings"
    ],
    "dificulty": "2900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Evaluate RBS.json",
    "editorial_link": "https://codeforces.com//blog/entry/119504",
    "editorial": "Think of this as a geometry problem. If that\u00e2\u0080\u0099s a revelation for you,\r\ndon\u00e2\u0080\u0099t worry, you\u00e2\u0080\u0099ll start seeing it with more experience.We have some\r\npoints , are asked to choose a vector and sort the points by a dot\r\nproduct of and . What exactly is a dot product? Well, . Obviously, will\r\nalways be the same length no matter what we choose. At the same time,\r\nthe length of will also be the same for a fixed . So, a dot product only\r\ndepends on an angle between and . Thus, the vector can always be a unit\r\none.Imagine iterating over all vectors in the increasing order of their\r\nangle. Consider a pair of different points and . When does one go before\r\nthe other in the order? We can compare their angles to . So, if we keep\r\nrotating , the order of two points will be changing when their angles to\r\nare the same. That happens exactly twice, and both events correspond to\r\nthe opposite vectors. Both of them lie on the line perpendicular to the\r\none and are on.Now imagine that rotating idea as an actual algorithm.\r\nWe\u00e2\u0080\u0099d want to iterate over all while maintaining the order of points.\r\nWhen we encounter on a line where two points swap, we swap. For each we\r\ncheck if current order of points produces an RBS.For points with the\r\nsame dot product (so when is on a line where these swap), we arrange\r\nthem in such an order that the opening bracket goes first, then the\r\nclosing bracket. That must be pretty obvious from any RBS\r\nintuition.Obviously, we don\u00e2\u0080\u0099t care about all (also there are infinitely\r\nmany of them). We only care about ones where something happens. Now,\r\nthat algorithm is called a radial sweepline. Very commonly not the\r\nprettiest thing to code, but I\u00e2\u0080\u0099ll share some implementation details that\r\nhelp with this one. I\u00e2\u0080\u0099ll also call vectors events from now on\r\nsometimes.First, generate all interesting , arrange them by their angle\r\nand save what happens for each of them. Get rid of pairs with\r\nnon-positive or . Now, arranging by angle can be done with just a cross\r\nproduct. Also, with that, you don\u00e2\u0080\u0099t even have to normalize the vectors.\r\nYou can use a map from points to events with a comparator using cross\r\nproduct (and no additional tie-breaks).Second, instead of swapping pairs\r\none by one on each angle (which might turn very annoying very fast),\r\nlet\u00e2\u0080\u0099s process them all in bulk. When there are multiple pairs of points\r\nswapping on the same angle, extract all of them from the current order,\r\nsort them on their own and insert them back.Notice that it doesn\u00e2\u0080\u0099t\r\nproduce exactly the same outcome. It rearranges the points as if all\r\npoints with equal dot product are free among each other until the next\r\nevent. However, if we turn just a bit further, they will get in their\r\ntrue places. But our algorithm will just skip to the next event without\r\nfixing the order.It\u00e2\u0080\u0099s actually quite easy to fix the issue. Along with\r\nsorting points that swap on the current event, take also points that had\r\nto be swapped on the previous event. Sort them all together. That won\u00e2\u0080\u0099t\r\nincrease the complexity (however, will increase the constant factor),\r\nbut will fix the order of the previous event points.The sorting is best\r\ndone with an inverse permutation of the order. For each point, remember\r\nits current place in the order. Now, we can find where each point is,\r\nand we can easily update the inverse permutation after the\r\nrearrangement. Since every pair of point appears at most times, the\r\ntotal size of arrays to sort is .Finally, how to check for an RBS every\r\ntime? We can\u00e2\u0080\u0099t afford , so we must maintain something. For a sequence to\r\nbe an RBS, all prefix balances of brackets should be non-negative (since\r\nwe are already guaranteed by the input that the final balance is ). The\r\nidea is easy. Notice how the points that are swapped on each event\r\nactually represent some segments of the order. And all swaps are\r\nperformed within these segments. Thus, the prefix balances are only\r\nupdated for the positions of the swapping points. Basically, we can\r\nmaintain the entire array of the prefix balances and the number of\r\nnegative elements in it. On each event, recalculate its entire parts\r\ncorresponding to the positions of the sorted points. If the number of\r\nnegative elements becomes , then we found the answer.Overall complexity:\r\n.\r\n"
}