{
    "link": "https://codeforces.com//contest/1400/problem/A",
    "problemId": "709183",
    "problem_idx": "A",
    "shortId": "1400A",
    "contest_number": "1400",
    "problem_submissions": {
        "D": [
            91063958,
            91019003,
            90921157,
            90924583,
            91129094,
            90921742,
            90924518,
            90925405,
            90924228,
            90928527,
            90927053,
            90928008,
            90921390,
            90926754,
            90926098,
            90923479,
            90932560,
            90927207,
            90928111,
            90927601,
            90927240
        ],
        "E": [
            91063322,
            90999997,
            90927958,
            90932635,
            91129112,
            90933891,
            90932788,
            90935094,
            90929091,
            90933541,
            90984689,
            90938941,
            90934180,
            90924023,
            90933282,
            90933092,
            92294796,
            92121423,
            90928722,
            90927143,
            91007103,
            90937273,
            90935595,
            90936018,
            90937203,
            90931579
        ],
        "A": [
            90999219,
            90908018,
            90908383,
            91129044,
            90908056,
            90908072,
            90909135,
            90908276,
            90908322,
            90909230,
            90908179,
            90908024,
            90908751,
            90908160,
            90908096,
            90908554,
            90910364,
            90910969,
            90908122,
            90909588
        ],
        "G": [
            90977154,
            90944389,
            90958977,
            91129247,
            90953059,
            90965280,
            90969288,
            90980892,
            90974551,
            90962476,
            90980693,
            90948619,
            90945807,
            90946996,
            90945319,
            90958148,
            90949510,
            90964852,
            90966663
        ],
        "F": [
            90977148,
            90956838,
            90944290,
            91129137,
            90963414,
            90954565,
            90943343,
            90954552,
            90955511,
            90976453,
            90961680,
            90961250,
            91019872,
            91482375,
            91348176,
            90960811,
            91338009,
            90994292
        ],
        "B": [
            90918673,
            90916748,
            91129051,
            90911853,
            90914978,
            90917579,
            90917952,
            90918236,
            90916691,
            90916458,
            90913884,
            90919126,
            90919862,
            90914960,
            90914966,
            90919061,
            90921310,
            90914836,
            90917699
        ],
        "C": [
            90915688,
            90920946,
            91129078,
            90918859,
            90921028,
            90921919,
            90921370,
            90923530,
            90922399,
            90921710,
            90918731,
            90923624,
            90923408,
            90918967,
            90930451,
            90922773,
            90925808,
            90920451,
            90924212
        ]
    },
    "name": "A. String Similarity",
    "statement": "A binary string is a string where each character is either or . Two\r\nbinary strings a and b of equal length are , if they have the same\r\ncharacter in some position (there exists an integer i such that a_i =\r\nb_i). For example: and are (they have the same character in position 4);\r\nand are ; and are ; and are not . You are given an integer n and a\r\nbinary string s consisting of 2n-1 characters. Letâ€™s denote s[l..r] as\r\nthe contiguous substring of s starting with l-th character and ending\r\nwith r-th character (in other words, s[l..r] = s_l s_{l + 1} s_{l + 2}\r\ndots s_r).You have to construct a binary string w of length n which is\r\nto : s[1..n], s[2..n+1], s[3..n+2], ..., s[n..2n-1].\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <iostream>\n#include <random>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\nauto random_address = [] { char *p = new char; delete p; return uint64_t(p); };\n\nconst uint64_t SEED = chrono::steady_clock::now().time_since_epoch().count() * (random_address() | 1);\nmt19937_64 rng(SEED);\n\n\nvoid run_case() {\n    int N;\n    string S;\n    cin >> N >> S;\n    string ans(N, '?');\n\n    while (true) {\n        for (int i = 0; i < N; i++)\n            ans[i] = char('0' + rng() % 2);\n\n        bool valid = true;\n\n        for (int start = 0; start < N; start++) {\n            bool match = false;\n\n            for (int i = 0; i < N; i++)\n                match = match || ans[i] == S[start + i];\n\n            valid = valid && match;\n        }\n\n        if (valid)\n            break;\n    }\n\n    cout << ans << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "strings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. String Similarity.json",
    "editorial_link": "https://codeforces.com//blog/entry/81916",
    "editorial": "We just need to make sure our string of characters matches each of the\r\nsubstrings in at least one spot. The easiest way to do this is to take\r\nevery other character from . Code: 90908018 Another fun solution: we can\r\ngenerate random strings and check them until we find one that matches\r\neverything. This works because the probability of failing to match any\r\nparticular substring is , so as gets bigger the probability of failing\r\ngets extremely low. Code: 90999219\r\n",
    "hint": []
}