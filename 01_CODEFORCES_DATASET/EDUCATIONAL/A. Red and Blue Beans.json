{
    "link": "https://codeforces.com//contest/1519/problem/A",
    "problemId": "971586",
    "problem_idx": "A",
    "shortId": "1519A",
    "contest_number": "1519",
    "problem_submissions": {
        "C": [
            114616470,
            114551329,
            114551180,
            114564495,
            114550309,
            114552694,
            114547702,
            114548020,
            114553618,
            114563241,
            114559641,
            114555665,
            114557042,
            114556787,
            114554939,
            114556558,
            114555376,
            114549327,
            114552625,
            114552238,
            114554684,
            114559315
        ],
        "F": [
            114613463,
            114611288,
            114604337,
            114598897,
            114611467,
            114680142,
            114636104,
            114635840
        ],
        "E": [
            114607966,
            114580590,
            114575288,
            114583294,
            114570654,
            114566689,
            114580490,
            114581344,
            114581275,
            114584747,
            114587745,
            114586133,
            114587347,
            114590609,
            114592573,
            114589054,
            114601871,
            114596259,
            114594317,
            114625207,
            114625166,
            114600206,
            114595857
        ],
        "D": [
            114555495,
            114555902,
            114567847,
            114556972,
            114556567,
            114552424,
            114552771,
            114561234,
            114544188,
            114558776,
            114560835,
            114564971,
            114561515,
            114561300,
            114565333,
            114554107,
            114558569,
            114558286,
            114563876,
            114568526
        ],
        "B": [
            114542697,
            114545137,
            114558022,
            114545565,
            114550455,
            114542163,
            114542842,
            114545295,
            114550992,
            114551627,
            114546744,
            114549467,
            114548090,
            114544402,
            114547969,
            114543205,
            114546111,
            114545907,
            114546890,
            114546969
        ],
        "A": [
            114541604,
            114541862,
            114551019,
            114541996,
            114541593,
            114541608,
            114541607,
            114541640,
            114546683,
            114543589,
            114543013,
            114543817,
            114542361,
            114541678,
            114541836,
            114541598,
            114541959,
            114541646,
            114541768,
            114542287
        ]
    },
    "name": "A. Red and Blue Beans",
    "statement": "You have r red and b blue beans. You’d like to distribute them among\r\nseveral (maybe, one) packets in such a way that each packet: has at\r\nleast one red bean (or the number of red beans r_i\r\nge 1); has at least one blue bean (or the number of blue beans b_i\r\nge 1); the number of red and blue beans should differ in no more than d\r\n(or |r_i - b_i|\r\nle d) Can you distribute all beans?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nvoid run_case() {\n    int64_t R, B, D;\n    cin >> R >> B >> D;\n\n    if (R > B)\n        swap(R, B);\n\n    cout << (R * (D + 1) >= B ? \"YES\" : \"NO\") << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Red and Blue Beans.json",
    "editorial_link": "https://codeforces.com//blog/entry/90212",
    "editorial": "Without loss of generality, letâs say (otherwise, we can swap them).\r\nNote that you canât use more than packets (at least one red bean in each\r\npacket), so canât exceed (at most blue beans in each packet).So, if then\r\nasnwer is . Otherwise, we can form exactly packets.\r\n",
    "hint": []
}