{
    "link": "https://codeforces.com//contest/1295/problem/B",
    "problemId": "526701",
    "problem_idx": "B",
    "shortId": "1295B",
    "contest_number": "1295",
    "problem_submissions": {
        "F": [
            69765027,
            69766931,
            69774700,
            69768602,
            69856768,
            69855408,
            69855407,
            69855207,
            69795000,
            69794801,
            69794791,
            69780998,
            70134503,
            69764574,
            69774965,
            69768972,
            69767605,
            69764218,
            69774776,
            69773934,
            69777915,
            69775661,
            69780279,
            69776002,
            69772429,
            69771368,
            69777730,
            69779043
        ],
        "E": [
            69754267,
            69756231,
            69750419,
            69758264,
            75026655,
            75026651,
            75026616,
            75026614,
            75026605,
            75026602,
            69861069,
            69860763,
            69796506,
            69751804,
            70134450,
            69755652,
            69754935,
            69757172,
            69759455,
            69762033,
            69761392,
            69761807,
            69764886,
            69763394,
            69762971,
            69754925,
            69778394,
            69762618,
            69760940
        ],
        "D": [
            69749184,
            69749435,
            69737870,
            69746208,
            69740901,
            70134431,
            69750756,
            69745336,
            69774454,
            69751512,
            69748972,
            69748437,
            69750220,
            69755333,
            69757518,
            69754451,
            69753242,
            69748833,
            69755501,
            69757780,
            69749229
        ],
        "C": [
            69746419,
            69745530,
            69752829,
            69744855,
            69859631,
            69859619,
            69742998,
            70134418,
            69749557,
            69743909,
            69747578,
            69746709,
            69752867,
            69746601,
            69749344,
            69748626,
            69749455,
            69751397,
            69746966,
            69748635,
            69750189,
            69746738
        ],
        "B": [
            69741160,
            69740703,
            69739974,
            69739609,
            69792992,
            69737452,
            70134357,
            69742495,
            69740938,
            69745005,
            69743434,
            69743024,
            69740858,
            69742897,
            69742450,
            69742512,
            69742639,
            69740406,
            69745732,
            69757660,
            69746475,
            69745760,
            69745145,
            69742911,
            69741321,
            69742736,
            69741570
        ],
        "A": [
            69736925,
            69736449,
            69735963,
            69735937,
            69793731,
            69735857,
            70134345,
            69737467,
            69736037,
            69735902,
            69737776,
            69735865,
            69736131,
            69736841,
            69736251,
            69735843,
            69740300,
            69744873,
            69735945,
            69738318,
            69752292
        ]
    },
    "name": "B. Infinite Prefixes",
    "statement": "You are given string s of length n consisting of -s and -s. You build an\r\ninfinite string t as a concatenation of an infinite number of strings s,\r\nor t = ssss\r\ndots For example, if s = , then t = ...Calculate the number of prefixes\r\nof t with equal to x. The balance of some string q is equal to cnt_{0,\r\nq} - cnt_{1, q}, where cnt_{0, q} is the number of occurrences of in q,\r\nand cnt_{1, q} is the number of occurrences of in q. The number of such\r\nprefixes can be infinite; if it is so, you must say that.A prefix is a\r\nstring consisting of several first letters of a given string, without\r\nany reorders. An empty prefix is also a valid prefix. For example, the\r\nstring \"abcd\" has 5 prefixes: empty string, \"a\", \"ab\", \"abc\" and \"abcd\".\r\n",
    "solutions": [
        "// Words are flowing out like endless rain into a paper cup\n// They slither while they pass they slip away across the universe\n// Pools of sorrow, waves of joy are drifting through my open mind\n// Possessing and caressing me\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n    if (ib == ie) {\n        ib = ibuf;\n        ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n    }\n    return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n    using namespace _buff;\n    LL ret = 0;\n    bool pos = true;\n    char c = getc();\n    for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n        assert(~c);\n    }\n    if (c == '-') {\n        pos = false;\n        c = getc();\n    }\n    for (; c >= '0' && c <= '9'; c = getc()) {\n        ret = (ret << 3) + (ret << 1) + (c ^ 48);\n    }\n    return pos ? ret : -ret;\n}\n\nconst size_t N = 1e5 + 5;\n\nchar s[N];\n\nvoid solve() {\n    int n, x;\n    scanf(\"%d%d%s\", &n, &x, s);\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '0') {\n            ++sum;\n        } else {\n            --sum;\n        }\n    }\n    int ans = 0, cur = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!sum) {\n            if (x == cur) {\n                puts(\"-1\");\n                return;\n            }\n        } else if ((x - cur) % sum == 0) {\n            int l = (x - cur) / sum;\n            if (l >= 0) {\n                ++ans;\n            }\n        }\n        if (s[i] == '0') {\n            ++cur;\n        } else {\n            --cur;\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        solve();\n    }\n    return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "math",
        "strings"
    ],
    "dificulty": "1700",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Infinite Prefixes.json",
    "editorial_link": "https://codeforces.com//blog/entry/73467",
    "editorial": "Let\u00e2\u0080\u0099s denote a prefix of length as . We can note that each where and is\r\na concatenation. Then balance of prefix of length is equal to .Now there\r\ntwo cases: is equal to or not. If then if exist such () that then for\r\neach and answer is .Otherwise, for each such there will no more than one\r\npossible : since there are zero or one solution to the equation . The\r\nsolution exists if and only if and . So, just precalc and for each check\r\nthe equation.\r\n"
}