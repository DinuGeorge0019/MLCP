{
    "link": "https://codeforces.com//contest/2043/problem/D",
    "problemId": "3103849",
    "problem_idx": "D",
    "shortId": "2043D",
    "contest_number": "2043",
    "problem_submissions": {
        "G": [
            298276621,
            298458376,
            298455954,
            298459741,
            298498128,
            298494225,
            298493989,
            298368643,
            298368617
        ],
        "F": [
            298243973,
            298258053,
            298242817,
            298260253,
            298257085,
            298250612,
            298241233,
            298252743,
            298266622,
            298254223,
            298258269,
            298270540,
            298270292,
            298270970,
            298272964,
            298350526,
            298284182,
            298276985,
            298272819,
            298283274,
            298421391,
            298417038,
            298257904
        ],
        "E": [
            298230325,
            298236565,
            298229495,
            298226934,
            298227308,
            298237122,
            298220698,
            298238215,
            298226770,
            298234499,
            298239196,
            298230091,
            298228297,
            298244169,
            298310355,
            298234798,
            298238168,
            298247710,
            298242187,
            298286367
        ],
        "D": [
            298219869,
            298216982,
            298222571,
            298218218,
            298213410,
            298224781,
            298213619,
            298219577,
            298216318,
            298221470,
            298226089,
            298219311,
            298219518,
            298230143,
            298226137,
            298226579,
            298229601,
            298224236,
            298231826
        ],
        "C": [
            298215825,
            298213305,
            298214855,
            298212674,
            298210052,
            298218770,
            298246686,
            298216835,
            298211668,
            298217178,
            298218473,
            298215699,
            298214498,
            298219482,
            298220559,
            298222653,
            298215672,
            298216539,
            298220531
        ],
        "B": [
            298205974,
            298203999,
            298204560,
            298204165,
            298201534,
            298206623,
            298209665,
            298205595,
            298204637,
            298205310,
            298207112,
            298207961,
            298204179,
            298210111,
            298210081,
            298211372,
            298204136,
            298203902,
            298209938
        ],
        "A": [
            298200061,
            298199218,
            298199258,
            298199378,
            298199175,
            298200132,
            298199984,
            298200407,
            298199812,
            298205860,
            298199259,
            298199630,
            298199502,
            298199251,
            298211149,
            298199244,
            298199260,
            298199390,
            298200087
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/137801",
    "editorial": "First, letâs try to solve this problem with . We can check the pair . If\r\nits greatest common divisor is not , then we should check and , i. e.\r\nthe pairs on the distance . If these donât work, we can check , and ,\r\nand so on, and the answer will be located fast enough (more about that\r\nin the third paragraph of the editorial). So, we get a solution in per\r\ntest case, where is the bound on the integers on the input, and is the\r\ndecrease in distance we had to make to find this pair (i. e. if the\r\nanswer has distance , then ).What to do if ? Almost the same, but first,\r\nwe need to ensure that the first pair we try has both integers divisible\r\nby . So, if , letâs shift it to the next closest integer which is\r\ndivisible by ; and if , letâs subtract from to make it divisible. Then,\r\nwe make the same process, but instead of trying pairs like , , and so\r\non, we try , , , and so on.Okay, now letâs talk about why this works\r\nfast, i. e. why this in the complexity formula is not that big. All the\r\nfollowing paragraphs will assume , but we can use the same reasoning\r\nwith if we divide everything by .Intuitively, we can think about it in\r\nterms of prime gaps: as soon as becomes a prime number, we get our\r\nresult. Average gap between two primes is about , but there can be\r\npretty big gaps, more than . If youâre bold and brave, you can stop here\r\nand submit, but letâs find a better bound.Instead of thinking about the\r\ngap between two primes, letâs think about the gap between two numbers\r\nwhich are coprime with . Letâs assume that is the product of several\r\nfirst prime numbers (if it is not, integers which are coprime with will\r\nappear even more often). of all integers are not divisible by ; of them\r\nare not divisible by ; of them are not divisible by , and so on. If we\r\nrepeat this process until the product of primes we considered becomes\r\ntoo large, we can get that, on average, in or integers is coprime with .\r\nThis is a better bound, but it still uses \"average\" gaps. However, this\r\nshould be enough to try to submit the solution.Okay, now letâs show a\r\nrigorous proof (which you really shouldnât need during the contest) of\r\nsome reasonable bound. We can prove that if you consider all possible\r\npairs of integers from intervals and , you will find at least one\r\ncoprime pair.There are integers in each interval, so there are pairs to\r\nconsider. Suppose in some of them, both integers are divisible by .\r\nThere will be at most such pairs, so we are left with pairs.Suppose in\r\nsome of the remaining pairs, both integers are divisible by . There will\r\nbe at most integers divisible by in each segment, so at most pairs. We\r\nare left with pairs.Suppose in some of the remaining pairs, both\r\nintegers are divisible by . There will be at most integers divisible by\r\nin each segment, so at most pairs. We are left with pairs.If we repeat\r\nthis until some prime number like , we will still have to \"fix\" more\r\nthan pairs, so at least one number has or more pairs to \"fix\". This\r\nshould mean that it is divisible by at least primes which are greater\r\nthan , and it means itâs greater than . So, in every pair of intervals\r\nand such that the numbers are not greater than , there will be at least\r\none coprime pair, and this proves that . In practice, it is much lower\r\nsince, in our proof, we didnât consider the fact that a lot of pairs\r\nwill have more than prime which they are divisible by; if we take this\r\ninto account (or repeat the same process until primes become much\r\ngreater), we can prove tighter bounds, for example, .\r\n",
    "name": "D. Problem about GCD",
    "statement": "Given three integers l, r, and G, find two integers A and B (l\r\nle A\r\nle B\r\nle r) such that their greatest common divisor (GCD) equals G and the\r\ndistance |A - B| is maximized.If there are multiple such pairs, choose\r\nthe one where A is minimized. If no such pairs exist, output \"\".\r\n",
    "solutions": [
        "#include <bits/stdc++.h>#define ALL(x) begin(x), end(x)using namespace std;void file() {  freopen(\"1.in\", \"r\", stdin);  freopen(\"1.out\", \"w\", stdout);}using ll = long long; void Solve() {  ll l, r, g;  cin >> l >> r >> g;  l = (l + g - 1) / g, r /= g;  ll ans = -1, pl, pr;  for(ll i = l; i <= r; i++) {    if(r - i + 1 <= ans) break;    for(ll j = r; j >= i; j--) {      if(j - i + 1 <= ans) break;      if(__gcd(i, j) == 1) {        pl = i, pr = j, ans = j - i + 1;        break;      }    }  }  if(ans == -1) cout << \"-1 -1\\n\";  else cout << pl * g << \" \" << pr * g << \"\\n\";} int main() {  // file();  ios::sync_with_stdio(0), cin.tie(0);  int T;  cin >> T;  while(T--) Solve();  return 0;}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "flows",
        "math",
        "number theory"
    ],
    "dificulty": "1800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Problem about GCD.json",
    "hint": []
}