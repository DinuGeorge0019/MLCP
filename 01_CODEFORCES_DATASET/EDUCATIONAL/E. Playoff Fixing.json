{
    "link": "https://codeforces.com//contest/1837/problem/E",
    "problemId": "1937913",
    "problem_idx": "E",
    "shortId": "1837E",
    "contest_number": "1837",
    "problem_submissions": {
        "F": [
            207194085,
            207203613,
            207207682,
            207213171,
            207211865,
            207210824,
            207211176,
            207318425,
            207318356,
            207219269,
            207223400,
            207222112,
            207230081,
            209182293,
            207218386,
            207220953,
            207230258,
            207229992,
            207230774,
            207219053,
            207217652,
            207234599,
            207241428,
            207217300
        ],
        "E": [
            207188119,
            207194518,
            207187724,
            207193975,
            207201887,
            207200866,
            207200402,
            207204477,
            207201158,
            207203473,
            207202659,
            209182421,
            207206918,
            207295603,
            207295577,
            207295208,
            207212525,
            207205450,
            207220600,
            207221757,
            207209332,
            207208536,
            207213556,
            207215245,
            207197679
        ],
        "B": [
            207173438,
            207165428,
            207164196,
            207176139,
            207175678,
            207167732,
            207174974,
            207163573,
            207171463,
            207163877,
            207175371,
            207164199,
            207166728,
            209182537,
            207176961,
            207175758,
            207169369,
            207163934,
            207178400,
            207163937,
            207176249,
            207171837,
            207164338,
            207177413,
            207185470
        ],
        "D": [
            207172764,
            207180689,
            207175489,
            207169386,
            207180603,
            207183437,
            207177453,
            207182367,
            207184812,
            207187481,
            207183382,
            209182475,
            207187168,
            207187553,
            207189679,
            207186480,
            207191942,
            207180382,
            207189882,
            207187720,
            207180792
        ],
        "C": [
            207163791,
            207169258,
            207167268,
            207163200,
            207171135,
            207167990,
            207163968,
            207163247,
            207171084,
            207177546,
            207172770,
            209182511,
            207171094,
            207178509,
            207179374,
            207167154,
            207173221,
            207169406,
            207177662,
            207172590,
            207173505
        ],
        "A": [
            207156762,
            207156505,
            207156456,
            207156409,
            207157257,
            207156929,
            207156537,
            207156398,
            207156432,
            207157333,
            207156686,
            209182570,
            207157924,
            207157341,
            207156863,
            207156455,
            207156545,
            207156506,
            207157325,
            207156712,
            207156556
        ]
    },
    "name": "E. Playoff Fixing",
    "statement": "2^k teams participate in a playoff tournament. The teams are numbered\r\nfrom 1 to 2^k, in order of decreasing strength. So, team 1 is the\r\nstrongest one, team 2^k is the weakest one. A team with a smaller number\r\nalways defeats a team with a larger number.First of all, the teams are\r\narranged in some order during a procedure called seeding. Each team is\r\nassigned another unique value from 1 to 2^k, called a seed, that\r\nrepresents its starting position in the playoff.The tournament consists\r\nof 2^k - 1 games. They are held as follows: the teams are split into\r\npairs: team with seed 1 plays against team with seed 2, team with seed 3\r\nplays against team with seed 4 (exactly in this order), and so on (so,\r\n2^{k-1} games are played in that phase). When a team loses a game, it is\r\neliminated.After that, only 2^{k-1} teams remain. If only one team\r\nremains, it is declared the champion; otherwise, 2^{k-2} games are\r\nplayed: in the first one of them, the winner of the game \"seed 1 vs seed\r\n2\" plays against the winner of the game \"seed 3 vs seed 4\", then the\r\nwinner of the game \"seed 5 vs seed 6\" plays against the winner of the\r\ngame \"seed 7 vs seed 8\", and so on. This process repeats until only one\r\nteam remains.After the tournament ends, the teams are assigned places\r\naccording to the tournament phase when they were eliminated. In\r\nparticular: the winner of the tournament gets place 1; the team\r\neliminated in the finals gets place 2; both teams eliminated in the\r\nsemifinals get place 3; all teams eliminated in the quarterfinals get\r\nplace 5; all teams eliminated in the 1/8 finals get place 9, and so on.\r\nNow that we established the rules, we do a little rigging. In\r\nparticular, we want: team 1 (not team with seed 1) to take place 1; team\r\n2 to take place 2; teams 3 and 4 to take place 3; teams from 5 to 8 to\r\ntake place 5, and so on. For example, this picture describes one of the\r\npossible ways the tournament can go with k = 3, and the resulting places\r\nof the teams: Some seeds are already reserved for some teams (we are not\r\nthe only ones rigging the tournament, apparently). We have to fill the\r\nrest of the seeds with the remaining teams to achieve the desired\r\nplacements. How many ways are there to do that? Since that value might\r\nbe large, print it modulo 998\r\n,244\r\n,353.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nint main(){\n  int k;\n  cin >> k;\n  vector<int> a(1 << k);\n  for (int i = 0; i < (1 << k); i++){\n    cin >> a[i];\n    if (a[i] != -1){\n      a[i]--;\n      if (a[i] != 0){\n        a[i] = 32 - __builtin_clz(a[i]);\n      }\n    }\n  }\n  vector<int> r(k + 1, 0);\n  r[0] = 1;\n  for (int i = 0; i < k; i++){\n    r[i + 1] = 1 << i;\n  }\n  for (int i = 0; i < (1 << k); i++){\n    if (a[i] != -1){\n      r[a[i]]--;\n    }\n  }\n  vector<vector<long long>> dp(k + 1, vector<long long>(1 << (k + 1), 0));\n  for (int i = 0; i < (1 << k); i++){\n    if (a[i] != -1){\n      dp[a[i]][(1 << k) + i] = 1;\n    } else {\n      for (int j = 0; j <= k; j++){\n        dp[j][(1 << k) + i] = 1;\n      }\n    }\n  }\n  for (int i = k; i >= 1; i--){\n    for (int j = 1 << (i - 1); j < (1 << i); j++){\n      for (int l = 0; l < i; l++){\n        dp[l][j] += dp[l][j * 2] * dp[i][j * 2 + 1];\n        dp[l][j] += dp[i][j * 2] * dp[l][j * 2 + 1];\n        dp[l][j] %= MOD;\n      }\n    }\n  }\n  long long ans = dp[0][1];\n  for (int i = 0; i <= k; i++){\n    for (int j = 1; j <= r[i]; j++){\n      ans *= j;\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "trees"
    ],
    "dificulty": "2200",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Playoff Fixing.json",
    "editorial_link": "https://codeforces.com//blog/entry/116752",
    "editorial": "Letâs investigate the structure of the tournament, starting from the\r\nfirst round.We know that teams from to have to lose during this round.\r\nAt the same time, there are exactly losers in this round. So, every\r\npairing has to look like this: a team from to versus a team from to\r\n.Letâs try to solve for zero reserved seeds all . So, we only have to\r\ncount the number of valid tournaments.Letâs try to do that starting from\r\nthe top. The winner is team . The final is team against team , but we\r\nhave an option to choose their order in the finals. Next, the semifinal.\r\nOne of teams and have to play against team and another one against team\r\n. So we have the following options: choose a permutation of the losers\r\non this stage, then choose the order of teams in every game.If we\r\nextrapolate that argument further, we will see that the stage with teams\r\nmultiplies the answer by (arrange the losers, then fix the order in\r\npairs). The product over all stages is the answer.In order to add the\r\nreserved seeds, we have to go back to solving bottom-up. Consider the\r\nfirst stage. We want to calculate its contribution to the answer, then\r\npromote the winners of each pair to the next stage and continue solving\r\nfor .Some pairs have both teams reserved. If both or neither of the\r\nteams are from to , then the answer is immediately . Otherwise, the\r\nwinner is known, so we can promote it further.Some pairs have no teams\r\nreserved. Here, we can pick the order of the teams (multiply the answer\r\nby ). And we basically know the winner as well this is marked as . The\r\nloser is yet to be determined.Some pairs have one team reserved, and\r\nthat team is from to . That team has to win in this pair, so we know who\r\nto promote. We will determine the loser later as well.Finally, some\r\npairs have one team reserved, and the team is from to . We know the\r\nloser here, but the winner is marked . Still, we can promote this\r\nfurther and deal with it on the later stages.How do we arrange the\r\nlosers? Well, itâs almost the same as in the case with zero reserved\r\nteams. There are some pairs that are missing losers, and there are loser\r\nteams yet to be placed. We only have to choose which team goes where.\r\nSo, itâs (the number of pairs with no reserved loser)!.Why can we\r\npromote the \"winner\" âs furthers without dealing with them immediately?\r\nBasically, that factorial term is the only place where we assign the\r\nnumbers to teams. Obviously, we want to assign each team a number\r\nexactly once. And that happens only when the team loses. Once we assign\r\nsome number to it, we can uniquely trace back to where this team\r\nstarted, since we fixed the order of each pair beforehand.We decrease\r\nuntil itâs equal to . The answer is still the product of the\r\ncombinations for each stage.Overall complexity: .\r\n",
    "hint": []
}