{"link": "https://codeforces.com//contest/1837/problem/E", "problemId": "1937913", "problem_idx": "E", "shortId": "1837E", "contest_number": "1837", "problem_submissions": {"F": [207194085, 207203613, 207207682, 207213171, 207211865, 207210824, 207211176, 207318425, 207318356, 207219269, 207223400, 207222112, 207230081, 209182293, 207218386, 207220953, 207230258, 207229992, 207230774, 207219053, 207217652, 207234599, 207241428, 207217300], "E": [207188119, 207194518, 207187724, 207193975, 207201887, 207200866, 207200402, 207204477, 207201158, 207203473, 207202659, 209182421, 207206918, 207295603, 207295577, 207295208, 207212525, 207205450, 207220600, 207221757, 207209332, 207208536, 207213556, 207215245, 207197679], "B": [207173438, 207165428, 207164196, 207176139, 207175678, 207167732, 207174974, 207163573, 207171463, 207163877, 207175371, 207164199, 207166728, 209182537, 207176961, 207175758, 207169369, 207163934, 207178400, 207163937, 207176249, 207171837, 207164338, 207177413, 207185470], "D": [207172764, 207180689, 207175489, 207169386, 207180603, 207183437, 207177453, 207182367, 207184812, 207187481, 207183382, 209182475, 207187168, 207187553, 207189679, 207186480, 207191942, 207180382, 207189882, 207187720, 207180792], "C": [207163791, 207169258, 207167268, 207163200, 207171135, 207167990, 207163968, 207163247, 207171084, 207177546, 207172770, 209182511, 207171094, 207178509, 207179374, 207167154, 207173221, 207169406, 207177662, 207172590, 207173505], "A": [207156762, 207156505, 207156456, 207156409, 207157257, 207156929, 207156537, 207156398, 207156432, 207157333, 207156686, 209182570, 207157924, 207157341, 207156863, 207156455, 207156545, 207156506, 207157325, 207156712, 207156556]}, "name": "E. Playoff Fixing", "statement": "2^k teams participate in a playoff tournament. The teams are numbered\r\nfrom 1 to 2^k, in order of decreasing strength. So, team 1 is the\r\nstrongest one, team 2^k is the weakest one. A team with a smaller number\r\nalways defeats a team with a larger number.First of all, the teams are\r\narranged in some order during a procedure called seeding. Each team is\r\nassigned another unique value from 1 to 2^k, called a seed, that\r\nrepresents its starting position in the playoff.The tournament consists\r\nof 2^k - 1 games. They are held as follows: the teams are split into\r\npairs: team with seed 1 plays against team with seed 2, team with seed 3\r\nplays against team with seed 4 (exactly in this order), and so on (so,\r\n2^{k-1} games are played in that phase). When a team loses a game, it is\r\neliminated.After that, only 2^{k-1} teams remain. If only one team\r\nremains, it is declared the champion; otherwise, 2^{k-2} games are\r\nplayed: in the first one of them, the winner of the game \"seed 1 vs seed\r\n2\" plays against the winner of the game \"seed 3 vs seed 4\", then the\r\nwinner of the game \"seed 5 vs seed 6\" plays against the winner of the\r\ngame \"seed 7 vs seed 8\", and so on. This process repeats until only one\r\nteam remains.After the tournament ends, the teams are assigned places\r\naccording to the tournament phase when they were eliminated. In\r\nparticular: the winner of the tournament gets place 1; the team\r\neliminated in the finals gets place 2; both teams eliminated in the\r\nsemifinals get place 3; all teams eliminated in the quarterfinals get\r\nplace 5; all teams eliminated in the 1/8 finals get place 9, and so on.\r\nNow that we established the rules, we do a little rigging. In\r\nparticular, we want: team 1 (not team with seed 1) to take place 1; team\r\n2 to take place 2; teams 3 and 4 to take place 3; teams from 5 to 8 to\r\ntake place 5, and so on. For example, this picture describes one of the\r\npossible ways the tournament can go with k = 3, and the resulting places\r\nof the teams: Some seeds are already reserved for some teams (we are not\r\nthe only ones rigging the tournament, apparently). We have to fill the\r\nrest of the seeds with the remaining teams to achieve the desired\r\nplacements. How many ways are there to do that? Since that value might\r\nbe large, print it modulo 998\r\n,244\r\n,353.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD = 998244353;\nint main(){\n  int k;\n  cin >> k;\n  vector<int> a(1 << k);\n  for (int i = 0; i < (1 << k); i++){\n    cin >> a[i];\n    if (a[i] != -1){\n      a[i]--;\n      if (a[i] != 0){\n        a[i] = 32 - __builtin_clz(a[i]);\n      }\n    }\n  }\n  vector<int> r(k + 1, 0);\n  r[0] = 1;\n  for (int i = 0; i < k; i++){\n    r[i + 1] = 1 << i;\n  }\n  for (int i = 0; i < (1 << k); i++){\n    if (a[i] != -1){\n      r[a[i]]--;\n    }\n  }\n  vector<vector<long long>> dp(k + 1, vector<long long>(1 << (k + 1), 0));\n  for (int i = 0; i < (1 << k); i++){\n    if (a[i] != -1){\n      dp[a[i]][(1 << k) + i] = 1;\n    } else {\n      for (int j = 0; j <= k; j++){\n        dp[j][(1 << k) + i] = 1;\n      }\n    }\n  }\n  for (int i = k; i >= 1; i--){\n    for (int j = 1 << (i - 1); j < (1 << i); j++){\n      for (int l = 0; l < i; l++){\n        dp[l][j] += dp[l][j * 2] * dp[i][j * 2 + 1];\n        dp[l][j] += dp[i][j * 2] * dp[l][j * 2 + 1];\n        dp[l][j] %= MOD;\n      }\n    }\n  }\n  long long ans = dp[0][1];\n  for (int i = 0; i <= k; i++){\n    for (int j = 1; j <= r[i]; j++){\n      ans *= j;\n      ans %= MOD;\n    }\n  }\n  cout << ans << endl;\n}"], "input": "", "output": "", "tags": ["combinatorics", "trees"], "dificulty": "2200", "interactive": false}