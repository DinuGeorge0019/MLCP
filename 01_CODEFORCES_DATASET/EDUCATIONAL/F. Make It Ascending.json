{
    "link": "https://codeforces.com//contest/1342/problem/F",
    "problemId": "604761",
    "problem_idx": "F",
    "shortId": "1342F",
    "contest_number": "1342",
    "problem_submissions": {
        "F": [
            78207467,
            78205817,
            78205943,
            78204678,
            78303371,
            78242472,
            78242440,
            78242319,
            78242310,
            78242303,
            78242233,
            78206781,
            78205447,
            78186696,
            78527031,
            78214922,
            78227172,
            78226873,
            78225695,
            78223681,
            78223297,
            78309995
        ],
        "E": [
            78177071,
            78184631,
            78183322,
            78182599,
            78180358,
            78183013,
            78207444,
            78167441,
            78172844,
            78527023,
            78170429,
            78166909,
            78409946,
            78177636,
            78170212,
            78167446,
            78169823,
            78170875,
            78173864,
            78184907,
            78181489,
            78183649,
            78170771,
            78176771
        ],
        "D": [
            78151939,
            78159481,
            78160158,
            78169080,
            78162112,
            78191720,
            78157598,
            78162251,
            78527016,
            78158733,
            78159121,
            78158539,
            78153238,
            78158581,
            78162104,
            78158417,
            78161220,
            78159573,
            78156760,
            78155231,
            78161242
        ],
        "B": [
            78134011,
            78131222,
            78131215,
            78138260,
            78132277,
            78189261,
            78129032,
            78126918,
            78527008,
            78133543,
            78129305,
            78126816,
            78131103,
            78132696,
            78132210,
            78133794,
            78131695,
            78131819,
            78131288,
            78134923,
            78135996
        ],
        "A": [
            78131888,
            78126534,
            78126963,
            78132887,
            78127318,
            78126206,
            78126166,
            78126082,
            78527005,
            78128059,
            78126263,
            78126121,
            78126742,
            78126275,
            78127236,
            78128360,
            78126590,
            78126515,
            78127035,
            78131641,
            78127186
        ],
        "C": [
            78127633,
            78147176,
            78139297,
            78163411,
            78150308,
            78144130,
            78139528,
            78141789,
            78138222,
            78527011,
            78139530,
            78141232,
            78145910,
            78135141,
            78142133,
            78151945,
            78141231,
            78149349,
            78144977,
            78144111,
            78142843,
            78144643,
            78150859
        ]
    },
    "name": "F. Make It Ascending",
    "statement": "You are given an array a consisting of n elements. You may apply several\r\noperations (possibly zero) to it.During each operation, you choose two\r\nindices i and j (1\r\nle i, j\r\nle n; i\r\nne j), increase a_j by a_i, and remove the i-th element from the array\r\n(so the indices of all elements to the right to it decrease by 1, and n\r\nalso decreases by 1).Your goal is to make the array a strictly\r\nascending. That is, the condition a_1 < a_2 <\r\ndots < a_n should hold (where n is the resulting size of the\r\narray).Calculate the minimum number of actions required to make the\r\narray strictly ascending.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\nint a[16];\nint f[16][1 << 15 | 1], g[16][1 << 15 | 1], sum[1 << 15 | 1];\nvector<int> x, y;\nint main() {\n\tint t;\n\tscanf(\"%d\", &t);\n\twhile(t --) {\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 0; i < n; i ++)\n\t\t            scanf(\"%d\", &a[i]);\n\t\tint o = n;\n\t\tvector<int> ff[16];\n\t\tfor (int i = 0; i < (1 << n); i ++) {\n\t\t\t// printf(\"push %d\\n\", i);\n\t\t\tff[__builtin_popcount(i)].push_back(i);\n\t\t}\n\t\t// for(int ss = 0; ss < n; ss ++)\n\t\t//     printf(\"size %d\\n\", (int)ff[ss].size());\n\t\tfor (int ss = 0; ss < n; ss ++)\n\t\t            for (int ii = 0; ii < (int)ff[ss].size(); ii ++) {\n\t\t\tint s = ff[ss][ii];\n\t\t\tx.clear();\n\t\t\ty.clear();\n\t\t\ty.push_back(0);\n\t\t\tfor (int i = 0; i < n; i ++)\n\t\t\t                    if(s >> i & 1)\n\t\t\t                        x.push_back(i); else\n\t\t\t                        y.push_back(i);\n\t\t\tint n = y.size() - 1, m = x.size();\n\t\t\tfor (int i = 0; i < (1 << m); i ++)\n\t\t\t                    for (int j = sum[i] = 0; j < m; j ++)\n\t\t\t                        if(i >> j & 1)\n\t\t\t                            sum[i] += a[x[j]];\n\t\t\tfor (int i = 0; i < (1 << m); i ++)\n\t\t\t                    f[0][i] = INT_MAX;\n\t\t\tf[0][0] = 0;\n\t\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\t\tfor (int j = 0; j < (1 << m); j ++) {\n\t\t\t\t\tf[i][j] = INT_MAX;\n\t\t\t\t\tif(a[y[i]] > f[i - 1][j]) {\n\t\t\t\t\t\tf[i][j] = a[y[i]];\n\t\t\t\t\t\tg[i][j] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (int k = j; k; k = j & (k - 1))\n\t\t\t\t\t\t                                if(a[y[i]] + sum[k] > f[i - 1][j ^ k]) {\n\t\t\t\t\t\t\tif(a[y[i]] + sum[k] < f[i][j]) {\n\t\t\t\t\t\t\t\tf[i][j] = a[y[i]] + sum[k];\n\t\t\t\t\t\t\t\tg[i][j] = k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f[n][(1 << m) - 1] != INT_MAX) {\n\t\t\t\t// printf(\"fetch %d %d\\n\", ss, s);\n\t\t\t\to = ss;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tout:\n\t\t        printf(\"%d\\n\", o);\n\t\tint cc = (1 << x.size()) - 1;\n\t\tvector<int> out[16];\n\t\tfor (int i = y.size() - 1; i >= 1; i --) {\n\t\t\tfor (int j = 0; j < x.size(); j ++)\n\t\t\t                if(g[i][cc] >> j & 1) {\n\t\t\t\t// printf(\"pushed\");\n\t\t\t\tout[y[i]].push_back(x[j]);\n\t\t\t}\n\t\t\t// printf(\"used %d\\n\", g[i][cc]);\n\t\t\tcc ^= g[i][cc];\n\t\t}\n\t\tint p[16];\n\t\tfor (int i = 0; i < n; i ++)\n\t\t            p[i] = i;\n\t\tfor (int i = 1; i < y.size(); i ++) {\n\t\t\tfor (int j = 0; j < out[y[i]].size(); j ++) {\n\t\t\t\tprintf(\"%d %d\\n\", p[out[y[i]][j]] + 1, p[y[i]] + 1);\n\t\t\t\tfor (int k = out[y[i]][j]; k < n; k ++)\n\t\t\t\t                    p[k] --;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "bitmasks",
        "brute force",
        "dp"
    ],
    "dificulty": "3000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Make It Ascending.json",
    "editorial_link": "https://codeforces.com//blog/entry/76633",
    "editorial": "Suppose we donât have any constraints on the order of elements, the\r\nresulting array just should not contain any duplicates. Letâs build the\r\nresult one element after another in ascending order, so each element we\r\ncreate is strictly greater than the previous. To create an element, just\r\nuse some subset of elements and merge them into new element. This\r\nprocess can be efficiently modeled with the following dynamic\r\nprogramming: is the minimum value of the last element, if we merged all\r\nthe elements from into ascending numbers. To model transitions, we\r\nsimply iterate on the mask of elements that will be merged into a new\r\none, and check if its sum is greater than the last element we created.\r\nThis runs in , if we use an efficient way to iterate on all masks that\r\ndonât intersect with the given mask.Okay, how about maintaining the\r\norder? When we create an element by merging some elements of the\r\noriginal array, letâs choose some position of an element we use in\r\nmerging and state that all other elements are added to it. Then, to\r\nensure that the result is ascending, the position of this element should\r\nbe greater than the position of the element we chose while building the\r\nprevious number. We can add the position we have chosen for the last\r\nelement to the states of our dynamic programming, so it becomes the\r\nminimum value of the last element, if we merged the of elements into\r\nnumbers, and the last element originally had index in the array.Using\r\nsome greedy optimizations (for example, we should not iterate on the\r\nposition we are choosing to merge it can be chosen greedily as the\r\nleftmost position after the position of previous element we are taking\r\ninto consideration), we can make it , yet with a small constant factor.\r\nTo restore the answer, we can maintain the previous values of and in\r\neach state, since just increases by with each transition.\r\n",
    "hint": []
}