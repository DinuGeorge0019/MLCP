{
    "link": "https://codeforces.com//contest/1795/problem/A",
    "problemId": "1785697",
    "problem_idx": "A",
    "shortId": "1795A",
    "contest_number": "1795",
    "problem_submissions": {
        "G": [
            193868249,
            193922126,
            193880640,
            193880242,
            193879883,
            193877939,
            193892319,
            193909416,
            193909281,
            193909039,
            193908855,
            193907982,
            193907256,
            193907116,
            193905885,
            193905428,
            193895936,
            193894919,
            193900585,
            193900447,
            193900331,
            193900021,
            193895212,
            193901119,
            193897399,
            194065980,
            193895350,
            193897364,
            193910352,
            193909678,
            193877594,
            193901310,
            193900708,
            193909774,
            193909664,
            193908826,
            193902609,
            193895098,
            193898582,
            193887169,
            193989778,
            193903191,
            193906575,
            193901677
        ],
        "E": [
            193858484,
            193864061,
            193860485,
            193866472,
            193870118,
            193881494,
            193869535,
            193877440,
            194065966,
            193867450,
            193873381,
            193864290,
            193872060,
            193880762,
            193876051,
            193901176,
            193882421,
            193899122,
            193881276,
            193885055
        ],
        "F": [
            193849592,
            193871412,
            193870619,
            193880295,
            193883585,
            193866256,
            193887756,
            193901053,
            193899102,
            193887184,
            194065972,
            193879792,
            193887970,
            193889897,
            193889600,
            193879424,
            193886027,
            193888430,
            193890811,
            193880065,
            193894847,
            193891841
        ],
        "D": [
            193842483,
            193853701,
            193849666,
            193849500,
            193854093,
            193850355,
            193858853,
            193853243,
            194065953,
            193855818,
            193855956,
            193852941,
            193856134,
            193845600,
            193859844,
            193851729,
            193849114,
            193866588,
            193860778,
            193855517
        ],
        "C": [
            193840570,
            193847474,
            193846113,
            193844888,
            193847932,
            193844693,
            193851549,
            193846559,
            194065943,
            193849210,
            193849704,
            193847867,
            193849903,
            193858596,
            193851945,
            193847688,
            193845368,
            193860332,
            193855373,
            193849162
        ],
        "B": [
            193839119,
            193839637,
            193839480,
            193839407,
            193839832,
            193839202,
            193842405,
            193840503,
            194065925,
            193843321,
            193841514,
            193841857,
            193840539,
            193848293,
            193839850,
            193839356,
            193839529,
            193847088,
            193842717,
            193840388
        ],
        "A": [
            193838910,
            193838985,
            193838946,
            193838908,
            193839007,
            193838901,
            193840204,
            193839189,
            194065914,
            193839222,
            193839386,
            193882631,
            193839087,
            193843666,
            193841139,
            193839086,
            193838960,
            193838928,
            193845036,
            193840156,
            193838911
        ]
    },
    "name": "A. Two Towers",
    "statement": "There are two towers consisting of blocks of two colors: red and blue.\r\nBoth towers are represented by strings of characters and/or denoting the\r\norder of blocks in them , where corresponds to a blue block, and\r\ncorresponds to a red block. You can perform the following operation any\r\nnumber of times: choose a tower with , and move its block to the of the\r\nother tower. The pair of towers is if no pair of touching blocks has the\r\nsame color; i. e. no red block stands on top of another red block, and\r\nno blue block stands on top of another blue block.You have to check if\r\nit is possible to perform any number of operations (possibly zero) to\r\nmake the pair of towers beautiful.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 16.02.2023 18:34:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n, m;\n    cin >> n >> m;\n    string a;\n    string b;\n    cin >> a >> b;\n    reverse(b.begin(), b.end());\n    a += b;\n    int cnt = 0;\n    for (int i = 0; i < n + m - 1; i++) {\n      cnt += (a[i] == a[i + 1]);\n    }\n    cout << (cnt <= 1 ? \"YES\" : \"NO\") << '\\n';\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "implementation",
        "strings"
    ],
    "dificulty": "800",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\A. Two Towers.json",
    "editorial_link": "https://codeforces.com//blog/entry/112963",
    "editorial": "Note that it does not make sense to move several blocks first from the\r\nleft tower to the right, and then from the right to the left, since this\r\nis similar to canceling the last actions.Using the fact described above\r\nand small restrictions on the input data, one of the possible solutions\r\nis the following: choose which tower will be the one where we take\r\nblocks from (try both options), iterate over the number of operations,\r\nand then check that both towers are beautiful after that number of\r\noperations.There is a faster solution: move all the blocks to the left\r\ntower, and then check that there is no more than one pair of adjacent\r\nblocks of the same color. If there are no such pairs, then we can divide\r\nthe tower into two in an arbitrary way, and if there is exactly one\r\npair, then we need to make a \"cut\" exactly between two blocks of the\r\nsame color. Otherwise, there will always be a pair of adjacent blocks of\r\nthe same color in one of the towers.\r\n",
    "hint": []
}