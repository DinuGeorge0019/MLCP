{
    "link": "https://codeforces.com//contest/1701/problem/D",
    "problemId": "1455052",
    "problem_idx": "D",
    "shortId": "1701D",
    "contest_number": "1701",
    "problem_submissions": {
        "F": [
            163251511,
            163268194,
            163257685,
            163252572,
            163254045,
            163268305,
            163279907,
            163277017,
            163279770,
            163277875,
            163278549,
            163242709,
            163276457,
            163283113,
            163287382,
            163289836,
            163287332,
            163286601,
            163290833,
            163270658
        ],
        "E": [
            163244868,
            163259890,
            163266161,
            163272812,
            163264648,
            163275442,
            163258821,
            163268518,
            163268841,
            163260671,
            163264743,
            163281368,
            163267683,
            163251911,
            163266438,
            163264157,
            163269030,
            163266798,
            163269366,
            163285662
        ],
        "D": [
            163228805,
            163243794,
            163241985,
            163230350,
            163241043,
            163238273,
            163235471,
            163239458,
            163247152,
            163243702,
            163253899,
            163251145,
            163245848,
            163241441,
            163251457,
            163249655,
            163254700,
            163255033,
            163238314,
            163253263
        ],
        "C": [
            163221033,
            163229733,
            163226787,
            163222248,
            163228927,
            163224161,
            163224146,
            163230155,
            163230384,
            163234091,
            163239295,
            163237663,
            163233141,
            163239841,
            163244784,
            163239399,
            163238796,
            163229460,
            163228482,
            163229332
        ],
        "B": [
            163216526,
            163223020,
            163218771,
            163216500,
            163222790,
            163218690,
            163217320,
            163219287,
            163222344,
            163220198,
            163229802,
            163224763,
            163220303,
            163218845,
            163218374,
            163222260,
            163227662,
            163222420,
            163219736,
            163217995
        ],
        "A": [
            163216029,
            163216466,
            163216829,
            163216062,
            163216261,
            163216352,
            163216058,
            163216701,
            163216924,
            163216152,
            163225075,
            163216629,
            163216398,
            163216381,
            163216162,
            163216559,
            163221320,
            163216621,
            163217196,
            163216126
        ]
    },
    "name": "D. Permutation Restoration",
    "statement": "Monocarp had a permutation a of n integers 1, 2, ..., n (a permutation\r\nis an array where each element from 1 to n occurs exactly once).Then\r\nMonocarp calculated an array of integers b of size n, where b_i =\r\nleft\r\nlfloor\r\nfrac{i}{a_i}\r\nright\r\nrfloor. For example, if the permutation a is [2, 1, 4, 3], then the\r\narray b is equal to\r\nleft[\r\nleft\r\nlfloor\r\nfrac{1}{2}\r\nright\r\nrfloor,\r\nleft\r\nlfloor\r\nfrac{2}{1}\r\nright\r\nrfloor,\r\nleft\r\nlfloor\r\nfrac{3}{4}\r\nright\r\nrfloor,\r\nleft\r\nlfloor\r\nfrac{4}{3}\r\nright\r\nrfloor\r\nright] = [0, 2, 0, 1].Unfortunately, the Monocarp has lost his\r\npermutation, so he wants to restore it. Your task is to find a\r\npermutation a that corresponds to the given array b. If there are\r\nmultiple possible permutations, then print any of them. The tests are\r\nconstructed in such a way that least one suitable permutation exists.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 08.07.2022 18:40:07       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    int n;\n    cin >> n;\n    vector<int> b(n);\n    vector<int> L(n), R(n);\n    for (int i = 0; i < n; i++) {\n      cin >> b[i];\n      // floor((i + 1) / a[i]) = b[i]\n      // b[i] <= (i + 1) / a[i] < b[i] + 1\n      // a[i] <= (i + 1) / b[i]\n      // a[i] > (i + 1) / (b[i] + 1)\n      R[i] = (b[i] == 0 ? n : (i + 1) / b[i]);\n      L[i] = (i + 1) / (b[i] + 1) + 1;\n    }\n    vector<vector<int>> at(n + 1);\n    for (int i = 0; i < n; i++) {\n      at[L[i]].push_back(i);\n    }\n    set<pair<int, int>> s;\n    vector<int> p(n, -1);\n    for (int i = 1; i <= n; i++) {\n      for (int j : at[i]) {\n        s.emplace(R[j], j);\n      }\n      assert(!s.empty());\n      p[s.begin()->second] = i;\n      s.erase(s.begin());\n    }\n    for (int i = 0; i < n; i++) {\n      cout << p[i] << \" \\n\"[i == n - 1];\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "data structures",
        "greedy",
        "math",
        "sortings",
        "two pointers"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Permutation Restoration.json",
    "editorial_link": "https://codeforces.com//blog/entry/104671",
    "editorial": "We have for each , we can rewrite this as follows: , or . From here we\r\ncan see that for each there is a segment of values that can be assigned\r\nto . So we have to match each number from to with one of these\r\nsegments.To solve this problem, we can iterate from to . Let the current\r\nnumber be , then it can be paired with a segment without a pair such\r\nthat and the right bound is minimum among all such segments (because it\r\nwill be the first to end among these segments). To do this, it is enough\r\nto maintain a set with open segments that have not yet been assigned a\r\npair and choose from it a segment with the minimum right bound. Before\r\nrunning this method, you can sort the segments by their left border so\r\nthey can be easily added to this set when we go from to (we will need to\r\ninsert all segments that begin with , that\u00e2\u0080\u0099s why it\u00e2\u0080\u0099s convenient to have\r\nthem sorted by their left border beforehand).\r\n"
}