{
    "link": "https://codeforces.com//contest/1969/problem/D",
    "problemId": "2619520",
    "problem_idx": "D",
    "shortId": "1969D",
    "contest_number": "1969",
    "problem_submissions": {
        "F": [
            258740971,
            258740820,
            258746132,
            258746716,
            258755183,
            258754014,
            258764616,
            258761581,
            258761069,
            258757448,
            258733006,
            258743321,
            258792091,
            258769461
        ],
        "E": [
            258725328,
            258720683,
            258724478,
            258731693,
            258756331,
            258755767,
            258736057,
            258804715,
            258733183,
            258735874,
            258730875,
            258757457,
            258749091,
            258722655,
            258724259,
            258731836,
            258735531,
            258733424,
            258733392,
            258730397,
            258733010,
            258733415,
            258736757
        ],
        "D": [
            258715496,
            258711950,
            258717455,
            258715807,
            258715309,
            258717478,
            258718891,
            258722961,
            258744444,
            258753841,
            258715868,
            258714258,
            258718192,
            258717839,
            258720978,
            258721300,
            258722241,
            258769261,
            258723656,
            258722483,
            258717125
        ],
        "C": [
            258709519,
            258714184,
            258710089,
            258708902,
            258709129,
            258711287,
            258711586,
            258731391,
            258739788,
            258758308,
            258709210,
            258714988,
            258712692,
            258710594,
            258712746,
            258713533,
            258716060,
            258713283,
            258715693,
            258710630
        ],
        "B": [
            258705054,
            258704158,
            258705135,
            258705001,
            258705619,
            258707939,
            258707446,
            258706758,
            258736445,
            258759399,
            258704770,
            258705679,
            258707425,
            258706710,
            258706746,
            258707793,
            258708419,
            258705968,
            258708957,
            258706188
        ],
        "A": [
            258703665,
            258703553,
            258703758,
            258703560,
            258703556,
            258703637,
            258704655,
            258703660,
            258734943,
            258760234,
            258703586,
            258703687,
            258704850,
            258703730,
            258703995,
            258703579,
            258704091,
            258703811,
            258704619,
            258703722
        ]
    },
    "editorial_link": "https://codeforces.com//blog/entry/129022",
    "editorial": "Letâs sort the array in descending order based on the array . For a\r\nfixed set of Aliceâs items, Bob will take the first of them for free\r\n(because they are the most expensive) and pay for the rest. Now we can\r\niterate over the first item that Bob will pay (denote it as ). Alice has\r\nto buy the cheapest items among (denote the sum of these values as ),\r\nbecause Bob can take them for free. Bob has to pay for each of the items\r\namong that Alice will buy. So Alice will buy all the items with (denote\r\nthe sum of these values as ). Then the Aliceâs profit is .Thus, we got a\r\nsolution that works in . In order to speed up this solution, we have to\r\ncalculate the values and faster than . We can do it as follows: while\r\niterating over the value of , letâs store \"free\" items in the ordered\r\nset, and when the size of this set becomes larger than , remove the most\r\nexpensive element from it; and the value of can be calculated using\r\nprefix sums (over the values ) or maintaining a variable (and update it\r\nwhen moving to the next value of ).\r\n",
    "name": "D. Shop Game",
    "statement": "Alice and Bob are playing a game in the shop. There are n items in the\r\nshop; each item has two parameters: a_i (item price for Alice) and b_i\r\n(item price for Bob).Alice wants to choose a subset (possibly empty) of\r\nitems and buy them. After that, Bob does the following: if Alice bought\r\nless than k items, Bob can take all of them for free; otherwise, he will\r\ntake k items for free that Alice bought (Bob chooses which k items it\r\nwill be), and for the rest of the chosen items, Bob will buy them from\r\nAlice and pay b_i for the i-th item. Alice’s profit is equal to\r\nsum\r\nlimits_{i\r\nin S} b_i -\r\nsum\r\nlimits_{j\r\nin T} a_j, where S is the set of items Bob buys from Alice, and T is the\r\nset of items Alice buys from the shop. In other words, Alice’s profit is\r\nthe difference between the amount Bob pays her and the amount she spends\r\nbuying the items.Alice wants to maximize her profit, Bob wants to\r\nminimize Alice’s profit. Your task is to calculate Alice’s profit if\r\nboth Alice and Bob act optimally.\r\n",
    "solutions": [
        "#include \"bits/stdc++.h\"#pragma GCC optimize (\"O3\")#pragma GCC target (\"sse4\") using namespace std; typedef long long ll;typedef long double ld;typedef complex<ld> cd; typedef pair<int, int> pi;typedef pair<ll,ll> pl;typedef pair<ld,ld> pd; typedef vector<int> vi;typedef vector<ld> vd;typedef vector<ll> vl;typedef vector<pi> vpi;typedef vector<pl> vpl;typedef vector<cd> vcd; template<class T> using pq = priority_queue<T>;template<class T> using pqg = priority_queue<T, vector<T>, greater<T>>; #define FOR(i, a, b) for (int i=a; i<(b); i++)#define F0R(i, a) for (int i=0; i<(a); i++)#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)#define trav(a,x) for (auto& a : x)#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) #define sz(x) (int)(x).size()#define mp make_pair#define pb push_back#define f first#define s second#define lb lower_bound#define ub upper_bound#define all(x) x.begin(), x.end()#define ins insert template<class T> bool ckmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }template<class T> bool ckmax(T& a, const T& b) { return a < b ? a = b, 1 : 0; } mt19937 rng(chrono::steady_clock::now().time_since_epoch().count()); void __print(int x) {cerr << x;}void __print(long x) {cerr << x;}void __print(long long x) {cerr << x;}void __print(unsigned x) {cerr << x;}void __print(unsigned long x) {cerr << x;}void __print(unsigned long long x) {cerr << x;}void __print(float x) {cerr << x;}void __print(double x) {cerr << x;}void __print(long double x) {cerr << x;}void __print(char x) {cerr << '\\'' << x << '\\'';}void __print(const char *x) {cerr << '\\\"' << x << '\\\"';}void __print(const string &x) {cerr << '\\\"' << x << '\\\"';}void __print(bool x) {cerr << (x ? \"true\" : \"false\");} template<typename T, typename V>void __print(const pair<T, V> &x) {cerr << '{'; __print(x.first); cerr << \", \"; __print(x.second); cerr << '}';}template<typename T>void __print(const T &x) {int f = 0; cerr << '{'; for (auto &i: x) cerr << (f++ ? \", \" : \"\"), __print(i); cerr << \"}\";}void _print() {cerr << \"]\\n\";}template <typename T, typename... V>void _print(T t, V... v) {__print(t); if (sizeof...(v)) cerr << \", \"; _print(v...);}#ifdef DEBUG#define dbg(x...) cerr << \"\\e[91m\"<<__func__<<\":\"<<__LINE__<<\" [\" << #x << \"] = [\"; _print(x); cerr << \"\\e[39m\" << endl;#else#define dbg(x...)#endif  const int MOD = 1000000007;const char nl = '\\n';const int MX = 100001;  void solve() {    int N, K; cin >> N >> K;    vpl A(N); F0R(i, N) cin >> A[i].s;    F0R(i, N) cin >> A[i].f;    F0R(i, N) A[i].f *= -1;    sort(all(A));    F0R(i, N) A[i].f *= -1;    multiset<ll> cur;    ll ans = 0;    ll cans = 0;    F0R(i, K) {         cur.ins(A[i].s);        cans -= A[i].s;    }    FOR(i, K, N) {        cans += max(0ll, A[i].f - A[i].s);    }    ckmax(ans, cans);    FOR(i, K, N) {        cans -= max(0ll, A[i].f - A[i].s);        cur.ins(A[i].s);        cans -= A[i].s;        cans += *cur.rbegin();        cur.erase(cur.find(*cur.rbegin()));        ckmax(ans, cans);    }     cout << ans << nl; } int main() {    ios_base::sync_with_stdio(0); cin.tie(0);     int T = 1;    cin >> T;    while(T--) {        solve();    } \treturn 0;}  "
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "greedy",
        "math",
        "sortings"
    ],
    "dificulty": "1900",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Shop Game.json",
    "hint": []
}