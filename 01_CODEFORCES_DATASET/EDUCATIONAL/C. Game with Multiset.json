{
    "link": "https://codeforces.com//contest/1913/problem/C",
    "problemId": "2387089",
    "problem_idx": "C",
    "shortId": "1913C",
    "contest_number": "1913",
    "problem_submissions": {
        "F": [
            237765417,
            237786045,
            237798410,
            237793751,
            237794290,
            237782267,
            237795023,
            237800140,
            237807937,
            237810699,
            237812614,
            249487858,
            249487734,
            237811339,
            237810034,
            237786173,
            237918310,
            238095706,
            238317726,
            238317705,
            238317604,
            238062834,
            238062445,
            237828170
        ],
        "E": [
            237747038,
            237760786,
            237768219,
            237770076,
            237769118,
            237750176,
            237762212,
            237777254,
            237781408,
            237770526,
            237770804,
            237785103,
            237769588,
            237762037,
            237767968,
            237768315,
            237776019,
            237777315,
            237775619
        ],
        "D": [
            237741941,
            237751825,
            237754635,
            237754576,
            237759161,
            237795697,
            237798473,
            237753926,
            237756867,
            237764842,
            237762933,
            237761396,
            237809126,
            237799893,
            237754034,
            237759987,
            237761087,
            237760420,
            237755829,
            237761290
        ],
        "C": [
            237735693,
            237739173,
            237740092,
            237741221,
            237739010,
            237738520,
            237799594,
            237738193,
            237740375,
            237744478,
            237744080,
            237745844,
            237762290,
            237803855,
            237741083,
            237740358,
            237744813,
            237743742,
            237745330,
            237745113
        ],
        "B": [
            237734023,
            237735619,
            237736194,
            237737923,
            237736443,
            237735162,
            237800569,
            237735958,
            237737285,
            237740748,
            237737318,
            237739744,
            237743140,
            237806408,
            237735801,
            237736968,
            237740846,
            237738174,
            237741145,
            237740499
        ],
        "A": [
            237733399,
            237733472,
            237733545,
            237733680,
            237733544,
            237733357,
            237734167,
            237733513,
            237734405,
            237733701,
            237733822,
            237734094,
            237807435,
            237733584,
            237733737,
            237733530,
            237733681,
            237735085,
            237733871
        ]
    },
    "name": "C. Game with Multiset",
    "statement": "In this problem, you are initially given an empty multiset. You have to\r\nprocess two types of queries: x add an element equal to 2^{x} to the\r\nmultiset; w say whether it is possible to take the sum of some subset of\r\nthe current multiset and get a value equal to w.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 18.12.2023 09:38:49       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"algo/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  vector<int> cnt(30);\n  int tt;\n  cin >> tt;\n  while (tt--) {\n    string op;\n    cin >> op;\n    if (op == \"1\") {\n      int x;\n      cin >> x;\n      cnt[x] += 1;\n    } else {\n      int w;\n      cin >> w;\n      for (int i = 29; i >= 0; i--) {\n        int take = min(w >> i, cnt[i]);\n        w -= take << i;\n      }\n      cout << (w == 0 ? \"YES\" : \"NO\") << '\\n';\n    }\n  }\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "greedy"
    ],
    "dificulty": "1300",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\C. Game with Multiset.json",
    "editorial_link": "https://codeforces.com//blog/entry/123493",
    "editorial": "We are given a classic knapsack problem. There are items with certain\r\nweights and a total weight that we want to achieve. If the weights were\r\narbitrary, we would need dynamic programming to solve it. However, this\r\nvariation of the knapsack problem can be solved greedily. What makes it\r\nspecial? If we arrange the weights in non-decreasing order, each\r\nsubsequent weight is divisible by the previous one.Then the following\r\ngreedy approach works. Arrange the items by weight, from smallest to\r\nlargest. Letâs say we want to achieve sum , and the weights of the items\r\nare . Let the weights be distinct, and the number of items with weight\r\nbe .If is not divisible by , the answer is . Otherwise, we look at the\r\nremainder of divided by . If it is not equal to , our only hope to make\r\nit is to take items with weight . All other items are divisible by , so\r\nthey will not help. We take exactly items. If there are less than that,\r\nthe answer is .Subtract this from now the remainder is . Now the claim\r\nis: there is no point in taking additional items with weight in a\r\nquantity not divisible by . If we do that, we will break the remainder\r\nagain. Thus, we can pack items with weight into groups of weight and add\r\nthe number of these groups to . Then recursively solve the same problem,\r\nbut for the new value of and weights .When we run out of distinct\r\nweights, we have to check that there are enough items of the largest\r\nweight to collect the entire weight .This can be written by iterating\r\nthrough the weight values from smallest to largest. For each weight, we\r\ncan maintain the count in an array. Then the first type of query works\r\nin , and the second type of query works in iterations.\r\n",
    "hint": []
}