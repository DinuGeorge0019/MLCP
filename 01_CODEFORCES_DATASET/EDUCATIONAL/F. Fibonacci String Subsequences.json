{
    "link": "https://codeforces.com//contest/946/problem/F",
    "problemId": "162811",
    "problem_idx": "F",
    "shortId": "946F",
    "contest_number": "946",
    "problem_submissions": {
        "G": [
            36021661,
            36026384,
            36022849,
            36018588,
            36030003,
            36031880,
            36023496,
            36141030,
            36023713,
            36019743,
            36021921
        ],
        "F": [
            36016439,
            36010306,
            36011759,
            36017801,
            36015918,
            36015627,
            36017713,
            36012422,
            36018592,
            36017729,
            36020768,
            36016813,
            36019907,
            36021177,
            36017821,
            36021462
        ],
        "E": [
            36007161,
            36005953,
            36006973,
            36007671,
            36003744,
            36009603,
            36013999,
            36014555,
            36006191,
            36012983,
            36013994,
            36013308,
            36012827,
            36016281,
            36012410,
            36015253,
            36015878,
            36009347,
            36016909
        ],
        "D": [
            36001071,
            36002106,
            35999863,
            36001996,
            36001455,
            36003959,
            36005490,
            36004597,
            36014071,
            36007176,
            36006435,
            36007071,
            36005693,
            36006922,
            36007333,
            36006139,
            36006839,
            36019644,
            36007254
        ],
        "C": [
            35997922,
            35999476,
            35998023,
            35998548,
            35998939,
            35999238,
            36000359,
            35999969,
            35998896,
            36000616,
            36003485,
            36001243,
            36000192,
            36002608,
            35999675,
            36001749,
            36003789,
            35999684,
            36002661
        ],
        "B": [
            35996866,
            35998672,
            35996504,
            35997493,
            35996253,
            35997312,
            35998806,
            35998462,
            35998652,
            35999416,
            35998242,
            35998547,
            35997873,
            35998443,
            36000126,
            35998309,
            35998592,
            35998542
        ],
        "A": [
            35995800,
            35997505,
            35995802,
            35996074,
            35995799,
            35995844,
            35997767,
            35996078,
            35996606,
            35997456,
            35995903,
            35995883,
            35995904,
            35996096,
            35995831,
            35996261,
            35997282,
            35997134
        ]
    },
    "name": "F. Fibonacci String Subsequences",
    "statement": "You are given a binary string (each character of this string is either\r\nor ).Let\u2019s denote the cost of string as the number of occurences of in .\r\nFor example, if is and is , then the cost of is .Let\u2019s also denote the\r\nFibonacci strings sequence as follows: is ; is ; if , where means the\r\nconcatenation of two strings.Your task is to calculate the sum of costs\r\nof all subsequences of the string . Since answer may be large, calculate\r\nit modulo .\r\n",
    "solutions": [
        "// {{{ by shik\n#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wunused-result\"\n#pragma GCC diagnostic ignored \"-Wunused-function\"\n#define SZ(x) ((int)(x).size())\n#define ALL(x) begin(x), end(x)\n#define REP(i, n) for (int i = 0; i < int(n); i++)\n#define REP1(i, a, b) for (int i = (a); i <= int(b); i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\ntypedef int64_t LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n\nnamespace { namespace shik {\n\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%\" SCNd64, &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\n\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%\" PRId64, x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n\n#ifdef SHIK\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\ntemplate<class T, class F = less<T>> void sort_uniq(vector<T> &v, F f = F()) { sort(begin(v), end(v), f); v.resize(unique(begin(v), end(v)) - begin(v)); }\ntemplate<class T> inline T bit(T x, int i) { return (x >> i) & 1; }\ntemplate<class T> inline bool chkmax(T &a, const T &b) { return b > a ? a = b, true : false; }\ntemplate<class T> inline bool chkmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<class T> using MaxHeap = priority_queue<T>;\ntemplate<class T> using MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\n// }}}\n\n// {{{ ModInt\ntemplate<int _MOD>\nstruct ModInt {\n    static const auto MOD = _MOD;\n    template<class T> using integral_only = typename enable_if<is_integral<T>::value>::type;\n\n    int x;\n    constexpr ModInt() : x() {}\n    template<class T, integral_only<T>* = nullptr>\n    ModInt(T _x) {\n        x = _x % MOD;\n        if (x < 0) x += MOD;\n    }\n    ModInt operator-() const { return {x == 0 ? 0 : MOD-x}; }\n    ModInt& operator+=(ModInt rhs) {\n        x += rhs.x;\n        if (x >= MOD) x -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt rhs) {\n        x -= rhs.x;\n        if (x < 0) x += MOD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt rhs) {\n        x = (long long)x * rhs.x % MOD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt rhs) {\n        return *this *= rhs.inv();\n    }\n    ModInt operator+(ModInt rhs) const { return ModInt(*this) += rhs; }\n    ModInt operator-(ModInt rhs) const { return ModInt(*this) -= rhs; }\n    ModInt operator*(ModInt rhs) const { return ModInt(*this) *= rhs; }\n    ModInt operator/(ModInt rhs) const { return ModInt(*this) /= rhs; }\n    ModInt inv() const {\n        // should work for non-prime MOD if gcd(x, MOD) = 1\n        int a = x, b = MOD, u = 1, v = 0;\n        while (b != 0) {\n            int t = a / b;\n            a -= t * b;\n            u -= t * v;\n            swap(a, b);\n            swap(u, v);\n        }\n        return u;\n    }\n    template<class T, integral_only<T>* = nullptr>\n    ModInt pow(T e) {\n        ModInt r = 1, p = *this;\n        while (e) {\n            if (e & 1) r *= p;\n            p *= p;\n            e >>= 1;\n        }\n        return r;\n    }\n    bool operator==(ModInt rhs) const { return x == rhs.x; }\n    bool operator!=(ModInt rhs) const { return x != rhs.x; }\n    bool operator<(ModInt rhs) const { return x < rhs.x; }\n    bool operator<=(ModInt rhs) const { return x <= rhs.x; }\n    bool operator>(ModInt rhs) const { return x > rhs.x; }\n    bool operator>=(ModInt rhs) const { return x >= rhs.x; }\n    friend string to_string(ModInt i) { return to_string(i.x); }\n    friend ostream& operator<<(ostream &os, ModInt i) { return os << i.x; }\n};\n// }}}\n\nconst int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\n\nconst int N=110;\n\nstruct M {\n    mint x[N][N];\n    const mint* operator[]( int i ) const { return x[i]; }\n    mint* operator[]( int i ) { return x[i]; }\n};\n\nint n;\n\n#ifdef SHIK\nostream& operator<<( ostream &os, const M &a ) {\n    vector<vector<mint>> v(n+1,vector<mint>(n+1));\n    REP(i,n+1) REP(j,n+1) v[i][j]=a[i][j];\n    return os<<v;\n}\n#endif\n\nM operator*( const M &a, const M &b ) {\n    M c;\n    REP(i,n+1) REP(j,n+1) {\n        mint s;\n        REP(k,n+1) s+=a[i][k]*b[k][j];\n        c[i][j]=s;\n    }\n    return c;\n}\n\nint m;\nchar s[N];\nM dp[N];\nvoid main() {\n    R(n,m,s);\n    dp[0][0][0]=dp[0][n][n]=dp[1][0][0]=dp[1][n][n]=2;\n    REP1(i,1,n-1) dp[0][i][i]=dp[1][i][i]=1;\n    REP(i,n) if ( s[i]=='0' ) dp[0][i][i+1]=1;\n    REP(i,n) if ( s[i]=='1' ) dp[1][i][i+1]=1;\n    REP1(i,2,m) dp[i]=dp[i-1]*dp[i-2];\n    // REP1(i,0,m) dump(i,dp[i]);\n    mint ans=dp[m][0][n];\n    W(ans);\n}\n\n// {{{ main\n}}\nint main() { shik::main(); return 0; }\n// }}}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp",
        "matrices"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Fibonacci String Subsequences.json",
    "editorial_link": "https://codeforces.com//blog/entry/58210",
    "editorial": "If was not really large, then we could run the following dynamic\r\nprogramming solution:Let be the number of ways to process first\r\ncharacters of so that the suffix of the subsequence of length matches\r\nthe prefix of with length . This is not really different from a usual\r\napproach with dynamic programming on KMP (constraints in this problem\r\nallow us to build KMP automaton naively without the help of any fast\r\nprefix-function algorithm). However, the length of is really large.Let\u00e2\u0080\u0099s\r\nconsider the traversions we make in dynamic programming. Let be the KMP\r\nautomaton matrix (that is, let be the new value of prefix-function if\r\nthe previous value was and we added a character ). Then from the state ,\r\nif the following character is , we make traversions to and to . This\r\nactually leads to rewriting traversions as a matrix. Let be the vector\r\nsuch that its -th element is equal to . Then advancing from to , if -th\r\ncharacter is , can be represented as follows: , where can be filled with\r\nthe help of KMP automaton: for every we add to , and also add to . The\r\nsame approach can be used to form matrix that denotes adding character ,\r\nand if we want to add the string , we can actually represent its matrix\r\nas .This matrix multiplication approach will run in , but the problem is\r\nthat it doesn\u00e2\u0080\u0099t give us the answer. To obtain it, we may add an\r\nauxiliary state to the dynamic programming, add to it each time we\r\ntraverse to state , multiply it by each time we add a character, and\r\nrewrite it into matrix form.Model solution:\r\nhttps://pastebin.com/ctSVxmnD\r\n"
}