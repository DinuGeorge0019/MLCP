{
    "link": "https://codeforces.com//contest/813/problem/F",
    "problemId": "108593",
    "problem_idx": "F",
    "shortId": "813F",
    "contest_number": "813",
    "problem_submissions": {
        "F": [
            27592959,
            27592462,
            27595859,
            27593693,
            27589826,
            27597032,
            27592495,
            27594242,
            27592969,
            27592265,
            27592101,
            27593647,
            27593448,
            27607698,
            27607690,
            27597005
        ],
        "D": [
            27591413,
            27596376,
            27595878,
            27592392,
            27596101,
            27595104,
            27676236,
            27675210,
            27591510,
            27603640,
            27593900,
            27624567,
            27624550,
            27624539,
            27628580,
            27593089,
            27592322,
            28282372,
            28281379
        ],
        "E": [
            27590671,
            27593775,
            27594164,
            27598623,
            27590165,
            27587725,
            27590977,
            27593884,
            27590632,
            27590190,
            27593976,
            27593899,
            27591757,
            27595354,
            27602821,
            27589094,
            27596364,
            27590212,
            27590714,
            27590708
        ],
        "C": [
            27586798,
            27589288,
            27588038,
            27588205,
            27585642,
            27587654,
            27587622,
            27598220,
            27588200,
            27597496,
            27586750,
            27587670,
            27588183,
            27589351,
            27598034,
            27587880,
            27588758,
            27588420,
            27587303,
            27587398,
            27597722,
            27588272
        ],
        "B": [
            27587426,
            27586981,
            27586763,
            27590844,
            27586387,
            27587082,
            27586616,
            27585981,
            27586358,
            27586732,
            27588430,
            27586365,
            27587378,
            27586643,
            27586207,
            27586121
        ],
        "A": [
            27586386,
            27585541,
            27587254,
            27590210,
            27585562,
            27585639,
            27585557,
            27585471,
            27585490,
            27585606,
            27586831,
            27585625,
            27586127,
            27585762,
            27585515,
            27585489,
            27585475
        ]
    },
    "name": "F. Bipartite Checking",
    "statement": "You are given an undirected graph consisting of vertices. Initially\r\nthere are no edges in the graph. Also you are given queries, each query\r\neither adds one undirected edge to the graph or removes it. After each\r\nquery you have to check if the resulting graph is bipartite (that is,\r\nyou can paint all vertices of the graph into two colors so that there is\r\nno edge connecting two vertices of the same color).\r\n",
    "solutions": [
        "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 202020\nstruct edge {\n  int u, v, l, r;\n  bool operator<(const edge &a) const{\n    return l == a.l ? r < a.r : l < a.l;\n  }\n};\ntypedef vector<edge> ve;\nint n , top;\nnamespace ufs {\n  struct node {int fa, val, size;} t[N];\n  struct info {int x, y; node a, b;} st[N];\n  inline void pre() {for(int i=1; i<=n; i++) t[i] = (node){i, 0, 1};}\n  inline int find(int x) {while(t[x].fa != x) x = t[x].fa; return x;}\n  inline int dis(int x) {\n    int ans=0; \n    while(t[x].fa != x) ans ^= t[x].val, x = t[x].fa;\n    return ans;\n  }\n  inline void link(int x, int y) {\n    int val = dis(x) ^ dis(y) ^ 1;\n    x = find(x); y = find(y);\n    st[++top] = (info) {x, y, t[x], t[y]};\n    if(t[x].size > t[y].size) swap(x, y);\n    t[x].fa = y; t[x].val = val; t[y].size += t[x].size;\n  }\n  inline void recov(int bot) {\n    while(top != bot) {\n      info &now = st[top--];\n      t[now.x] = now.a; t[now.y] = now.b;\n    }\n  }\n} using namespace ufs;\n\nvoid cdq(int l, int r, ve &a) {\n  int mid = (l+r)>>1, bot = top;\n  ve b, c;\n  for(int i=0; i<(int)a.size(); i++) {\n    edge &now = a[i];\n    int x = now.u, y = now.v;\n    if(now.l == l && now.r == r) {\n      int p = find(x), q = find(y);\n      if(p == q) {\n        int val = dis(x) ^ dis(y);\n        if(val == 0) {\n          for(int j=l; j<=r; j++) puts(\"NO\");\n          recov(bot); return;\n        }\n      } else link(x, y);\n    } \n    else if(now.r <= mid) b.push_back(now);\n    else if(mid < now.l) c.push_back(now);\n    else b.push_back( (edge){now.u, now.v, now.l, mid} ), c.push_back( (edge){now.u, now.v, mid+1, now.r} );\n  }\n  if(l == r) puts(\"YES\");\n  else cdq(l, mid, b), cdq(mid+1, r, c);\n  recov(bot);\n}\nvoid build(){\n\n}\nmap< pair<int,int> , int > M;\nint q;\nve a;\nvoid init(){\n  n = getint();\n  q = getint();\n  for( int i = 1 ; i <= q ; i ++ ){\n    int ai = getint();\n    int bi = getint();\n    if( M.count( {ai, bi} ) ){\n      a.push_back((edge){ai, bi, M[ {ai, bi} ], i-1});\n      M.erase( {ai, bi} );\n    }else\n      M[ {ai, bi} ] = i;\n  }\n  for( auto i : M )\n    a.push_back((edge){i.first.first, i.first.second, i.second, q});\n}\nvoid solve(){\n  pre();\n  cdq( 1 , q , a );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures",
        "dsu",
        "graphs"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. Bipartite Checking.json",
    "editorial_link": "https://codeforces.com//blog/entry/52410",
    "editorial": "If the edges were only added and not deleted, it would be a common\r\nproblem that is solved with disjoint set union. All you need to do in\r\nthat problem is implement a DSU which maintains not only the leader in\r\nthe class of some vertex, but also the distance to this leader. Then, if\r\nwe try to connect two vertices that have the same leader in DSU and the\r\nsum of distances to this leader is even, then we get a cycle with odd\r\nlength, and graph is no longer bipartite.But in this problem we need to\r\nsomehow process removing edges from the graph.In the algorithm I will\r\ndescribe below we will need to somehow remove the last added edge from\r\nDSU (or even some number of last added edges). How can we process that?\r\nEach time we change some variable in DSU, we can store an address of\r\nthis variable and its previous value somewhere (for example, in a\r\nstack). Then to remove last added edge, we rollback these changes we\r\nrewrite the previous values of the variables we changed by adding the\r\nlast edge.Now we can add a new edge and remove last added edge. All\r\nthese operations cost because path compression doesn\u00e2\u0080\u0099t work in intended\r\ntime if we have to rollback. Let\u00e2\u0080\u0099s actually start solving the\r\nproblem.For convinience, we change all information to queries like \"edge\r\nexists from query number till query number \". It\u00e2\u0080\u0099s obvious that there\r\nare no more than such queries. Let\u00e2\u0080\u0099s use divide-and-conquer technique to\r\nmake a function that answers whether the graph is bipartite or not after\r\nevery query from some segment of queries . First of all, we add to DSU\r\nall the edges that are present in the whole segment (and not added yet);\r\nthen we solve it recursively for and ; then we remove edges from DSU\r\nusing the rollback technique described above. When we arrive to some\r\nsegment , then after adding the edges present in this segment we can\r\nanswer if the graph is bipartite after query . Remember to get rid of\r\nthe edges that are already added and the edges that are not present at\r\nall in the segment when you make a recursive call. Of course, to solve\r\nthe whole problem, we need to call our function from segment .Time\r\ncomplexity is , because every edge will be added only in calls of the\r\nfunction.\r\n"
}