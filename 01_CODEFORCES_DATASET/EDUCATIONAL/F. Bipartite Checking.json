{"link": "https://codeforces.com//contest/813/problem/F", "problemId": "108593", "problem_idx": "F", "shortId": "813F", "contest_number": "813", "problem_submissions": {"F": [27592959, 27592462, 27595859, 27593693, 27589826, 27597032, 27592495, 27594242, 27592969, 27592265, 27592101, 27593647, 27593448, 27607698, 27607690, 27597005], "D": [27591413, 27596376, 27595878, 27592392, 27596101, 27595104, 27676236, 27675210, 27591510, 27603640, 27593900, 27624567, 27624550, 27624539, 27628580, 27593089, 27592322, 28282372, 28281379], "E": [27590671, 27593775, 27594164, 27598623, 27590165, 27587725, 27590977, 27593884, 27590632, 27590190, 27593976, 27593899, 27591757, 27595354, 27602821, 27589094, 27596364, 27590212, 27590714, 27590708], "C": [27586798, 27589288, 27588038, 27588205, 27585642, 27587654, 27587622, 27598220, 27588200, 27597496, 27586750, 27587670, 27588183, 27589351, 27598034, 27587880, 27588758, 27588420, 27587303, 27587398, 27597722, 27588272], "B": [27587426, 27586981, 27586763, 27590844, 27586387, 27587082, 27586616, 27585981, 27586358, 27586732, 27588430, 27586365, 27587378, 27586643, 27586207, 27586121], "A": [27586386, 27585541, 27587254, 27590210, 27585562, 27585639, 27585557, 27585471, 27585490, 27585606, 27586831, 27585625, 27586127, 27585762, 27585515, 27585489, 27585475]}, "name": "F. Bipartite Checking", "statement": "You are given an undirected graph consisting of vertices. Initially\r\nthere are no edges in the graph. Also you are given queries, each query\r\neither adds one undirected edge to the graph or removes it. After each\r\nquery you have to check if the resulting graph is bipartite (that is,\r\nyou can paint all vertices of the graph into two colors so that there is\r\nno edge connecting two vertices of the same color).\r\n", "solutions": ["// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n#define N 202020\nstruct edge {\n  int u, v, l, r;\n  bool operator<(const edge &a) const{\n    return l == a.l ? r < a.r : l < a.l;\n  }\n};\ntypedef vector<edge> ve;\nint n , top;\nnamespace ufs {\n  struct node {int fa, val, size;} t[N];\n  struct info {int x, y; node a, b;} st[N];\n  inline void pre() {for(int i=1; i<=n; i++) t[i] = (node){i, 0, 1};}\n  inline int find(int x) {while(t[x].fa != x) x = t[x].fa; return x;}\n  inline int dis(int x) {\n    int ans=0; \n    while(t[x].fa != x) ans ^= t[x].val, x = t[x].fa;\n    return ans;\n  }\n  inline void link(int x, int y) {\n    int val = dis(x) ^ dis(y) ^ 1;\n    x = find(x); y = find(y);\n    st[++top] = (info) {x, y, t[x], t[y]};\n    if(t[x].size > t[y].size) swap(x, y);\n    t[x].fa = y; t[x].val = val; t[y].size += t[x].size;\n  }\n  inline void recov(int bot) {\n    while(top != bot) {\n      info &now = st[top--];\n      t[now.x] = now.a; t[now.y] = now.b;\n    }\n  }\n} using namespace ufs;\n\nvoid cdq(int l, int r, ve &a) {\n  int mid = (l+r)>>1, bot = top;\n  ve b, c;\n  for(int i=0; i<(int)a.size(); i++) {\n    edge &now = a[i];\n    int x = now.u, y = now.v;\n    if(now.l == l && now.r == r) {\n      int p = find(x), q = find(y);\n      if(p == q) {\n        int val = dis(x) ^ dis(y);\n        if(val == 0) {\n          for(int j=l; j<=r; j++) puts(\"NO\");\n          recov(bot); return;\n        }\n      } else link(x, y);\n    } \n    else if(now.r <= mid) b.push_back(now);\n    else if(mid < now.l) c.push_back(now);\n    else b.push_back( (edge){now.u, now.v, now.l, mid} ), c.push_back( (edge){now.u, now.v, mid+1, now.r} );\n  }\n  if(l == r) puts(\"YES\");\n  else cdq(l, mid, b), cdq(mid+1, r, c);\n  recov(bot);\n}\nvoid build(){\n\n}\nmap< pair<int,int> , int > M;\nint q;\nve a;\nvoid init(){\n  n = getint();\n  q = getint();\n  for( int i = 1 ; i <= q ; i ++ ){\n    int ai = getint();\n    int bi = getint();\n    if( M.count( {ai, bi} ) ){\n      a.push_back((edge){ai, bi, M[ {ai, bi} ], i-1});\n      M.erase( {ai, bi} );\n    }else\n      M[ {ai, bi} ] = i;\n  }\n  for( auto i : M )\n    a.push_back((edge){i.first.first, i.first.second, i.second, q});\n}\nvoid solve(){\n  pre();\n  cdq( 1 , q , a );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"], "input": "", "output": "", "tags": ["data structures", "dsu", "graphs"], "dificulty": "2500", "interactive": false}