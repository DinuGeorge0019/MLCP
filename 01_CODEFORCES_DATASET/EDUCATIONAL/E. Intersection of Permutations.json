{
    "link": "https://codeforces.com//contest/1093/problem/E",
    "problemId": "270226",
    "problem_idx": "E",
    "shortId": "1093E",
    "contest_number": "1093",
    "problem_submissions": {
        "F": [
            47064317,
            47066369,
            47072013,
            47063078,
            47070194,
            47066599,
            47069818,
            47071658,
            47069736,
            47073345,
            47066962,
            47067247,
            47069530,
            47073606,
            47073395,
            47061796,
            47063002,
            47067085,
            47069647
        ],
        "E": [
            47059940,
            47175053,
            47174990,
            47174965,
            47060977,
            47054377,
            47057431,
            47053669,
            47071310,
            47064501,
            47060021,
            47063571,
            47051018,
            47060722,
            47054485,
            47099037,
            47099010,
            47054662,
            47065797,
            47074158,
            47051089,
            47074689,
            47067318,
            47063903,
            47063526,
            47063507,
            47058046,
            47058483
        ],
        "G": [
            47051449,
            47054318,
            47060619,
            47069286,
            47064176,
            47054294,
            47058010,
            47064582,
            47059658,
            47045741,
            47069865,
            47071490,
            47044907,
            47068431,
            47054907,
            47076907,
            47070943,
            47045135,
            47052551,
            47065756,
            47061805,
            47064972
        ],
        "D": [
            47046394,
            47048590,
            47050157,
            47049421,
            47048833,
            47047771,
            47051232,
            47049608,
            47047579,
            47056236,
            47052390,
            47047717,
            47060889,
            47049097,
            47062998,
            47068801,
            47069194,
            47070905,
            47050207,
            47053679
        ],
        "C": [
            47043859,
            47045338,
            47046257,
            47046095,
            47044608,
            47045282,
            47047834,
            47047265,
            47045573,
            47053477,
            47049038,
            47043947,
            47058752,
            47044937,
            47064718,
            47070147,
            233878752,
            233878357,
            233877672,
            233874035,
            47071603,
            47073360,
            47045788,
            47044965
        ],
        "B": [
            47041242,
            47042516,
            47041777,
            47042122,
            47042500,
            47043090,
            47044535,
            47044930,
            47041021,
            47051714,
            47043546,
            47041074,
            47056563,
            47042532,
            47063756,
            47070397,
            47070118,
            47071889,
            47042554,
            47041254
        ],
        "A": [
            47040802,
            47041248,
            47040853,
            47040900,
            47040739,
            47042123,
            47040939,
            47043340,
            47040729,
            47052191,
            47041112,
            47040744,
            47075234,
            47055833,
            47041119,
            47063989,
            47070741,
            47069623,
            47071501,
            47041275,
            47040765
        ]
    },
    "name": "E. Intersection of Permutations",
    "statement": "You are given two permutations a and b, both consisting of n elements.\r\nPermutation of n elements is such a integer sequence that each value\r\nfrom 1 to n appears exactly once in it.You are asked to perform two\r\ntypes of queries with them: 1\u00a0l_a\u00a0r_a\u00a0l_b\u00a0r_b calculate the number of\r\nvalues which appear in both segment [l_a; r_a] of positions in\r\npermutation a and segment [l_b; r_b] of positions in permutation b;\r\n2\u00a0x\u00a0y swap values on positions x and y in permutation b. Print the\r\nanswer for each query of the first type.It is guaranteed that there will\r\nbe at least one query of the first type in the input.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2e5 + 5;\nint a[maxn], b[maxn], c[maxn], e[maxn], pos[maxn], d[maxn];\n\nnamespace segtree {\n    struct fenwick {\n        vector<int> ds, bit;\n        void add(int v) { ds.push_back(v); }\n        int query(int l, int r) { return query(r) - query(l - 1); }\n        void done() {\n            sort(ds.begin(), ds.end());\n            ds.resize(unique(ds.begin(), ds.end()) - ds.begin());\n            bit.resize(ds.size() + 1);\n        }\n        void modify(int p, int v) {\n            p = upper_bound(ds.begin(), ds.end(), p) - ds.begin();\n            for (int i = p; i < (int)bit.size(); i += i & -i)\n                bit[i] += v;\n        }\n        int query(int p) {\n            p = upper_bound(ds.begin(), ds.end(), p) - ds.begin();\n            int res = 0;\n            for (int i = p; i > 0; i -= i & -i)\n                res += bit[i];\n            return res;\n        }\n    } st[maxn * 4];\n    void make() {\n        for (int i = 0; i < maxn * 4; ++i)\n            st[i].done();\n    }\n    void add(int l, int r, int p, int v, int o = 0) {\n        st[o].add(v);\n        if (r - l == 1) return;\n        if (p < (l + r) >> 1) add(l, (l + r) >> 1, p, v, o * 2 + 1);\n        else add((l + r) >> 1, r, p, v, o * 2 + 2);\n    } \n    void modify(int l, int r, int p, int v, int z, int o = 0) {\n        st[o].modify(v, z);\n        if (r - l == 1) return;\n        if (p < (l + r) >> 1) modify(l, (l + r) >> 1, p, v, z, o * 2 + 1);\n        else modify((l + r) >> 1, r, p, v, z, o * 2 + 2);\n    } \n    int query(int l, int r, int ql, int qr, int x, int y, int o = 0) {\n        if (l >= qr || ql >= r) return 0;\n        if (l >= ql && r <= qr) return st[o].query(x, y);\n        return query(l, (l + r) >> 1, ql, qr, x, y, o * 2 + 1) + \n               query((l + r) >> 1, r, ql, qr, x, y, o * 2 + 2);\n    }\n}\n\nint t[maxn];\nvector<int> op[maxn];\n\nint main() {\n    int n, m; scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &b[i]);\n    for (int i = 0; i < n; ++i) pos[b[i]] = i;\n    for (int i = 0; i < n; ++i) c[i] = pos[a[i]];\n    for (int i = 0; i < n; ++i) d[a[i]] = i;\n    for (int i = 0; i < n; ++i) e[i] = b[i];\n    for (int i = 0; i < n; ++i) segtree::add(0, n, i, c[i]);\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%d\", &t[i]);\n        if (t[i] == 1) {\n            int l, r, x, y; scanf(\"%d%d%d%d\", &l, &r, &x, &y);\n            --l, --r, --x, --y;\n            op[i] = { l, r, x, y };\n        } else {\n            int x, y; scanf(\"%d%d\", &x, &y);\n            --x, --y;\n            segtree::add(0, n, d[b[x]], y);\n            segtree::add(0, n, d[b[y]], x);\n            swap(b[x], b[y]);\n            op[i] = { x, y };\n        }\n    }\n    segtree::make();\n    for (int i = 0; i < n; ++i) b[i] = e[i];\n    for (int i = 0; i < n; ++i) segtree::modify(0, n, i, c[i], 1);\n    for (int i = 0; i < m; ++i) {\n        if (t[i] == 1) {\n            int l = op[i][0], r = op[i][1], x = op[i][2], y = op[i][3];\n            printf(\"%d\\n\", segtree::query(0, n, l, r + 1, x, y));\n        } else {\n            int x = op[i][0], y = op[i][1];\n            segtree::modify(0, n, d[b[x]], x, -1);\n            segtree::modify(0, n, d[b[x]], y, +1);\n            segtree::modify(0, n, d[b[y]], y, -1);\n            segtree::modify(0, n, d[b[y]], x, +1);\n            swap(b[x], b[y]);\n        }\n    }\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "data structures"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Intersection of Permutations.json",
    "editorial_link": "https://codeforces.com/blog/entry/63877",
    "editorial": "At first, time limit was not that tight for the problem. We didn\u00e2\u0080\u0099t want\r\nany sqrt, bitset or straight up solution to pass (and it\u00e2\u0080\u0099s close to none\r\nto pass). Jury solution works faster than twice the time limit so we\r\ndecided 6 seconds is alright.The task is purely about implementation.\r\nYou renumerate numbers in permutations so that the queries are and then\r\nhave the structure to make update in point and sum on rectangle.\r\nRenumeration in my case was making the first permutation into identity\r\none and changing the numbers in second appropriately. You can choose the\r\nstructure you want, I\u00e2\u0080\u0099ll tell about the one I use when the queries are\r\noffline. For online the common technique is having BITs, each with treap\r\nin it (ordered_set template from pbds is usually enough). For offline\r\nyou can precalculate the values to fall into each BIT beforehand and do\r\nBIT on these values inside. Preprocess all the update and get queries ,\r\nadding into all the BITs will fall into. Then sort them and leave only\r\nunique occurrences.Overall complexity: .\r\n"
}