{
    "link": "https://codeforces.com//contest/1739/problem/B",
    "problemId": "1559864",
    "problem_idx": "B",
    "shortId": "1739B",
    "contest_number": "1739",
    "problem_submissions": {
        "F": [
            173982711,
            173969607,
            173981022,
            173986288,
            173992146,
            173980539,
            173991072,
            173980378,
            173978555,
            174245795,
            174000933,
            173993564,
            173995270,
            173994662,
            173995645,
            173994787,
            173991035,
            173995175,
            173975986,
            173996342,
            173995107,
            173986566
        ],
        "E": [
            173962909,
            173976378,
            173969496,
            173967080,
            173967227,
            173969366,
            173969799,
            173988104,
            173970277,
            173983172,
            173983299,
            173978308,
            173974083,
            173979712,
            173983159,
            173980060,
            173986740,
            173979502,
            173967920
        ],
        "D": [
            173953446,
            173954284,
            173959501,
            173953114,
            173950233,
            173963545,
            173960383,
            173950745,
            173966040,
            173950883,
            173962543,
            173951795,
            173957703,
            173966024,
            173951939,
            173967693,
            173958723,
            173974529,
            173956732
        ],
        "C": [
            173946487,
            173945498,
            173949713,
            174075655,
            174075624,
            173946209,
            173940986,
            173958498,
            173954556,
            173955135,
            173961377,
            173958964,
            173957077,
            173960274,
            173951680,
            173958743,
            173985617,
            173961155,
            173949432,
            173968872,
            173953205
        ],
        "B": [
            173936382,
            173937044,
            173937069,
            173935458,
            173935314,
            173943298,
            173937530,
            173935389,
            173954918,
            173937400,
            173937767,
            173940608,
            173940106,
            173945520,
            173936795,
            173941470,
            173938759,
            173964539,
            173936543
        ],
        "A": [
            173934470,
            173935151,
            173934498,
            173934222,
            173934344,
            173939803,
            173934700,
            173934286,
            173952986,
            173934928,
            173934527,
            173936084,
            173935340,
            173938305,
            173937802,
            173937555,
            173935130,
            173963081,
            173934367
        ]
    },
    "name": "B. Array Recovery",
    "statement": "For an array of integers a of size n, we construct another array d as\r\nfollows: d_1 = a_1, d_i = |a_i - a_{i - 1}| for 2\r\nle i\r\nle n.Your task is to restore the array a from a given array d, or to\r\nreport that there are multiple possible arrays.\r\n",
    "solutions": [
        "#include <bits/stdc++.h>\nusing namespace std;\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...)\n#endif\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int tt;\n    cin >> tt;\n    while (tt--) {\n        int n;\n        cin >> n;\n        vector<int> d(n);\n        for (int i = 0; i < n; i++) {\n            cin >> d[i];\n        }\n        bool ok = true;\n        for (int i = 1; i < n; i++) {\n            if (d[i] != 0 && d[i - 1] >= d[i]) {\n                ok = false;\n                break;\n            }\n            d[i] += d[i - 1];\n        }\n        if (ok) {\n            for (int i = 0; i < n; i++) {\n                cout << d[i] << \" \\n\"[i == n - 1];\n            }\n        } else {\n            cout << -1 << '\\n';\n        }\n    }\n    return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "greedy",
        "math"
    ],
    "dificulty": "1100",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\B. Array Recovery.json",
    "editorial_link": "https://codeforces.com//blog/entry/107461",
    "editorial": "Note that or . Since there is no upper bound for the values of , the\r\ncase where for all always exists. It remains to check if there are other\r\nways. To do this, it is enough to check whether there is such a position\r\nthat: ; ; the change to doesn\u00e2\u0080\u0099t result in a negative value of . The\r\nreason for is that for no matter the plus or minus we choose, the array\r\ndoesn\u00e2\u0080\u0099t change. If you could change at least one sign to minus, that\r\nwould be another answer.\r\n"
}