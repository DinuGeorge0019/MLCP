{"link": "https://codeforces.com//contest/1598/problem/F", "problemId": "1138075", "problem_idx": "F", "shortId": "1598F", "contest_number": "1598", "problem_submissions": {"G": [131442050, 131445550, 131474021, 131733851, 189236477, 131533150, 131521436, 131521173, 131520806, 131458159], "F": [131413919, 131426175, 131419948, 131424974, 131423465, 131425512, 131426044, 131429617, 131434101, 131424856, 131429061, 135925566, 131432789, 131436462, 131426160, 131433379, 131432739, 131442015, 131426352, 131438575], "E": [131409216, 131417508, 131411965, 131416590, 131414689, 131417539, 131419673, 131417908, 131417850, 131413609, 131419666, 131418620, 131426224, 131434401, 131422338, 131425095, 131423673, 131432059, 131428300], "D": [131405446, 131408232, 131403803, 131406730, 131406693, 131408831, 131409679, 131411498, 131409766, 131431099, 131412818, 131410917, 131408763, 131411240, 131414979, 131418536, 131414491, 131405913, 131414013, 131411546], "C": [131402318, 131402805, 131401746, 131403276, 131404307, 131403297, 131407011, 131405600, 131402882, 131404574, 131406244, 131405518, 131403235, 131406335, 131403809, 131404263, 131402426, 131410937, 131406878], "B": [131399659, 131401435, 131400062, 131400441, 131401570, 131401020, 131401164, 131404218, 131400433, 131402267, 131404703, 131402822, 131405775, 131403060, 131401809, 131401389, 131400640, 131406015, 131403932], "A": [131398034, 131398273, 131398102, 131398196, 131398135, 131398297, 131398147, 131400227, 131399230, 131398720, 131400611, 131612251, 131398353, 131399540, 131399744, 131398269, 131398178, 131398070, 131401090, 131399096]}, "name": "F. RBS", "statement": "A bracket sequence is a string containing only characters \"\" and \"\". A\r\nregular bracket sequence (or, shortly, an RBS) is a bracket sequence\r\nthat can be transformed into a correct arithmetic expression by\r\ninserting characters \"\" and \"\" between the original characters of the\r\nsequence. For example: bracket sequences \"\" and \"\" are regular (the\r\nresulting expressions are: \"\" and \"\"); bracket sequences \"\", \"\" and \"\"\r\nare not. Let\u2019s denote the concatenation of two strings x and y as x+y.\r\nFor example, \"\" + \"\" = \"\".You are given n bracket sequences s_1, s_2,\r\ndots, s_n. You can rearrange them in any order (you can rearrange only\r\nthe strings themselves, but not the characters in them).Your task is to\r\nrearrange the strings in such a way that the string s_1 + s_2 +\r\ndots + s_n has as many non-empty prefixes that are RBS as possible.\r\n", "solutions": ["/**\n *    author:  tourist\n *    created: 10.10.2021 12:24:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<string> s(n);\n  vector<int> len(n);\n  vector<vector<vector<int>>> at(n);\n  vector<int> min_delta(n);\n  vector<int> delta(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    len[i] = (int) s[i].size();\n    at[i].resize(2 * len[i] + 1);\n    int b = len[i];\n//    at[i][b].push_back(0);\n    for (int j = 0; j < len[i]; j++) {\n      b += (s[i][j] == '(' ? 1 : -1);\n      at[i][b].push_back(j + 1);\n      min_delta[i] = min(min_delta[i], b - len[i]);\n    }\n    delta[i] = b - len[i];\n  }\n  vector<int> dp(1 << n, -1);\n  dp[0] = 0;\n  int ans = 0;\n  for (int t = 0; t < (1 << n); t++) {\n    if (dp[t] == -1) {\n      continue;\n    }\n    int cur = 0;\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        cur += delta[i];\n      }\n    }\n    assert(cur >= 0);\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        continue;\n      }\n      int goal = len[i] - cur;\n      int ft = dp[t];\n      if (cur + min_delta[i] < 0) {\n        assert(goal > 0 && goal <= 2 * len[i]);\n        assert(!at[i][goal - 1].empty());\n        int bound = at[i][goal - 1][0];\n        ft += (int) (lower_bound(at[i][goal].begin(), at[i][goal].end(), bound) - at[i][goal].begin());\n        ans = max(ans, ft);\n        continue;\n      }\n      if (goal >= 0 && goal <= 2 * len[i]) {\n        ft += (int) at[i][goal].size();\n      }\n      dp[t | (1 << i)] = max(dp[t | (1 << i)], ft);\n    }\n  }\n  ans = max(ans, dp.back());\n  cout << ans << '\\n';\n  return 0;\n}\n"], "input": "", "output": "", "tags": ["binary search", "bitmasks", "brute force", "data structures", "dp"], "dificulty": "2400", "interactive": false}