{
    "link": "https://codeforces.com//contest/1598/problem/F",
    "problemId": "1138075",
    "problem_idx": "F",
    "shortId": "1598F",
    "contest_number": "1598",
    "problem_submissions": {
        "G": [
            131442050,
            131445550,
            131474021,
            131733851,
            189236477,
            131533150,
            131521436,
            131521173,
            131520806,
            131458159
        ],
        "F": [
            131413919,
            131426175,
            131419948,
            131424974,
            131423465,
            131425512,
            131426044,
            131429617,
            131434101,
            131424856,
            131429061,
            135925566,
            131432789,
            131436462,
            131426160,
            131433379,
            131432739,
            131442015,
            131426352,
            131438575
        ],
        "E": [
            131409216,
            131417508,
            131411965,
            131416590,
            131414689,
            131417539,
            131419673,
            131417908,
            131417850,
            131413609,
            131419666,
            131418620,
            131426224,
            131434401,
            131422338,
            131425095,
            131423673,
            131432059,
            131428300
        ],
        "D": [
            131405446,
            131408232,
            131403803,
            131406730,
            131406693,
            131408831,
            131409679,
            131411498,
            131409766,
            131431099,
            131412818,
            131410917,
            131408763,
            131411240,
            131414979,
            131418536,
            131414491,
            131405913,
            131414013,
            131411546
        ],
        "C": [
            131402318,
            131402805,
            131401746,
            131403276,
            131404307,
            131403297,
            131407011,
            131405600,
            131402882,
            131404574,
            131406244,
            131405518,
            131403235,
            131406335,
            131403809,
            131404263,
            131402426,
            131410937,
            131406878
        ],
        "B": [
            131399659,
            131401435,
            131400062,
            131400441,
            131401570,
            131401020,
            131401164,
            131404218,
            131400433,
            131402267,
            131404703,
            131402822,
            131405775,
            131403060,
            131401809,
            131401389,
            131400640,
            131406015,
            131403932
        ],
        "A": [
            131398034,
            131398273,
            131398102,
            131398196,
            131398135,
            131398297,
            131398147,
            131400227,
            131399230,
            131398720,
            131400611,
            131612251,
            131398353,
            131399540,
            131399744,
            131398269,
            131398178,
            131398070,
            131401090,
            131399096
        ]
    },
    "name": "F. RBS",
    "statement": "A bracket sequence is a string containing only characters \"\" and \"\". A\r\nregular bracket sequence (or, shortly, an RBS) is a bracket sequence\r\nthat can be transformed into a correct arithmetic expression by\r\ninserting characters \"\" and \"\" between the original characters of the\r\nsequence. For example: bracket sequences \"\" and \"\" are regular (the\r\nresulting expressions are: \"\" and \"\"); bracket sequences \"\", \"\" and \"\"\r\nare not. Let’s denote the concatenation of two strings x and y as x+y.\r\nFor example, \"\" + \"\" = \"\".You are given n bracket sequences s_1, s_2,\r\ndots, s_n. You can rearrange them in any order (you can rearrange only\r\nthe strings themselves, but not the characters in them).Your task is to\r\nrearrange the strings in such a way that the string s_1 + s_2 +\r\ndots + s_n has as many non-empty prefixes that are RBS as possible.\r\n",
    "solutions": [
        "/**\n *    author:  tourist\n *    created: 10.10.2021 12:24:30       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<string> s(n);\n  vector<int> len(n);\n  vector<vector<vector<int>>> at(n);\n  vector<int> min_delta(n);\n  vector<int> delta(n);\n  for (int i = 0; i < n; i++) {\n    cin >> s[i];\n    len[i] = (int) s[i].size();\n    at[i].resize(2 * len[i] + 1);\n    int b = len[i];\n//    at[i][b].push_back(0);\n    for (int j = 0; j < len[i]; j++) {\n      b += (s[i][j] == '(' ? 1 : -1);\n      at[i][b].push_back(j + 1);\n      min_delta[i] = min(min_delta[i], b - len[i]);\n    }\n    delta[i] = b - len[i];\n  }\n  vector<int> dp(1 << n, -1);\n  dp[0] = 0;\n  int ans = 0;\n  for (int t = 0; t < (1 << n); t++) {\n    if (dp[t] == -1) {\n      continue;\n    }\n    int cur = 0;\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        cur += delta[i];\n      }\n    }\n    assert(cur >= 0);\n    for (int i = 0; i < n; i++) {\n      if (t & (1 << i)) {\n        continue;\n      }\n      int goal = len[i] - cur;\n      int ft = dp[t];\n      if (cur + min_delta[i] < 0) {\n        assert(goal > 0 && goal <= 2 * len[i]);\n        assert(!at[i][goal - 1].empty());\n        int bound = at[i][goal - 1][0];\n        ft += (int) (lower_bound(at[i][goal].begin(), at[i][goal].end(), bound) - at[i][goal].begin());\n        ans = max(ans, ft);\n        continue;\n      }\n      if (goal >= 0 && goal <= 2 * len[i]) {\n        ft += (int) at[i][goal].size();\n      }\n      dp[t | (1 << i)] = max(dp[t | (1 << i)], ft);\n    }\n  }\n  ans = max(ans, dp.back());\n  cout << ans << '\\n';\n  return 0;\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "binary search",
        "bitmasks",
        "brute force",
        "data structures",
        "dp"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\F. RBS.json",
    "editorial_link": "https://codeforces.com//blog/entry/95890",
    "editorial": "The constraint is a clear hint that we need some exponential solution.\r\nOf course, we cannot try all permutations. Letâs instead try to design a\r\nsolution with bitmask dynamic programming.A string is an RBS if its\r\nbalance (the difference between the number of opening and closing\r\nbrackets) is , and the balance of its each prefix is non-negative. So,\r\nletâs introduce the following dynamic programming: is the greatest\r\nnumber of RBS-prefixes of a string if we considered a mask of strings ,\r\nthe current balance of the prefix is , and is a flag that denotes\r\nwhether there already has been a prefix with negative balance. We can\r\nalready get rid of one of the states: the current balance is uniquely\r\ndetermined by the mask . So, this dynamic programming will have\r\nstates.To perform transitions, we need to find a way to recalculate the\r\nvalue of and the answer if we append a new string at the end of the\r\ncurrent one. Unfortunately, itâs too slow to simply simulate the\r\nprocess. Instead, for every string , letâs precalculate the value how\r\ndoes the flag and the answer change, if the current flag is , and the\r\ncurrent balance is .The resulting flag will be in one of the following\r\ntwo cases: it is already ; the string we append creates a new prefix\r\nwith non-positive balance. The second case can be checked as follows:\r\nletâs precalculate the minimum balance of a prefix of ; let it be . If ,\r\nthe flag will be .Calculating how the answer changes is a bit trickier.\r\nIf the current flag is already , the answer doesnât change. But if it is\r\n, the answer will increase by the number of new RBS-prefixes. If the\r\nbalance before adding the string is , then we get a new RBS-prefix for\r\nevery prefix of such that: its balance is exactly (to compensate the\r\nbalance we already have); there is no prefix with balance in before this\r\nprefix. To quickly get the number of prefixes meeting these constraints,\r\nwe can create a data structure that stores the following information:\r\nfor every balance , store a sorted vector of positions in with balance\r\nequal to . Then, to calculate the number of prefixes meeting the\r\nconstraints, we can find the first position in with balance equal to by\r\nlooking at the beginning of the vector for , and then get the number of\r\nelements less than this one from the vector for balance by binary\r\nsearch.These optimizations yield a solution in , although itâs possible\r\nto improve to if you precalculate each value of for every string .\r\n",
    "hint": []
}