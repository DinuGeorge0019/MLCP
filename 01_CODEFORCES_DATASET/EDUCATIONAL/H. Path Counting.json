{
    "link": "https://codeforces.com//contest/954/problem/H",
    "problemId": "167345",
    "problem_idx": "H",
    "shortId": "954H",
    "contest_number": "954",
    "problem_submissions": {
        "I": [
            36483613,
            36489921,
            36491468,
            36492587,
            36489151,
            36505182,
            36498444,
            36489158,
            36493599,
            36495253,
            36493983,
            36523197,
            36517457,
            36494315,
            36517490
        ],
        "E": [
            36478770,
            36477321,
            36476296,
            36476332,
            36477191,
            36479277,
            36478407,
            36484072,
            36476637,
            36483722,
            36476830,
            36479359,
            36479273,
            36481624,
            36479515,
            36473956,
            36477339,
            36477449,
            36476422,
            36481260
        ],
        "D": [
            36478485,
            36475307,
            36474083,
            36478258,
            36474970,
            36476455,
            36476263,
            36472023,
            36474824,
            36478016,
            36474200,
            36476982,
            36476891,
            36474372,
            36477175,
            36479984,
            36487971,
            36474275,
            36474076,
            36475466
        ],
        "C": [
            36476002,
            36474037,
            36473020,
            36474296,
            36473832,
            36473968,
            36474218,
            36474540,
            36483525,
            36476724,
            36472809,
            36474171,
            36499291,
            36473004,
            36474442,
            36477242,
            36486700,
            36473123,
            36472782,
            36473808
        ],
        "G": [
            36475037,
            36479869,
            36479819,
            36482297,
            36479701,
            36481399,
            36480184,
            36480325,
            36481161,
            36480550,
            36485383,
            36482231,
            36482668,
            36492299,
            36483624,
            36487406,
            36490213,
            36485274,
            36478330,
            36479287
        ],
        "F": [
            36474930,
            36486416,
            36483404,
            36528491,
            36484207,
            36482822,
            36485630,
            36483061,
            36477477,
            36481839,
            36487500,
            36482960,
            36488051,
            36485000,
            36479677,
            36489393,
            36482816,
            36484976,
            36483377,
            36483862,
            36487177
        ],
        "H": [
            36473564,
            36483628,
            36486927,
            36487388,
            36497291,
            36492759,
            36492641,
            36496336,
            36493059,
            36491960,
            36490810,
            36488245,
            36487713,
            36489798,
            36483087
        ],
        "B": [
            36472231,
            36471541,
            36471094,
            36471718,
            36471325,
            36471918,
            36470816,
            36471290,
            36470543,
            36472680,
            36470969,
            36471052,
            36470688,
            36471049,
            36472812,
            36475352,
            36471581,
            36471121,
            36470814,
            36470886
        ],
        "A": [
            36470941,
            36470615,
            36469920,
            36470743,
            36470038,
            36470789,
            36469978,
            36470246,
            36469943,
            36471510,
            36470178,
            36469918,
            36469982,
            36470334,
            36471516,
            36475017,
            36470944,
            36470503,
            36470133,
            36470029
        ]
    },
    "name": "H. Path Counting",
    "statement": "You are given a rooted tree. Let’s denote as depth of node : depth of\r\nthe root is , depth of any other node is , where is a parent of .The\r\ntree has the following property: every node with has exactly children.\r\nMaximum possible depth of a node is , and .We define as the number of\r\nunordered pairs of vertices in the tree such that the number of edges on\r\nthe simple path between them is equal to .Calculate modulo for every .\r\n",
    "solutions": [
        "#include<bits/stdc++.h>\n#define MN 5000\n#define mod 1000000007\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,a[MN+5],num[MN+5],res[MN+5][MN*2+5],ans[MN*2+5];\ninline int pow(int x,int k)\n{\n\tint sum=1;\n\tfor(;k;k>>=1,x=1LL*x*x%mod)\n\t\tif(k&1) sum=1LL*sum*x%mod;\n\treturn sum;\t\n}\nint main()\n{\n\tn=read();num[1]=1;\n\tfor(int i=1;i<n;++i) a[i]=read(),num[i+1]=1LL*num[i]*a[i]%mod;\n\tfor(int i=1;i<=n;++i) \n\t{\n\t\tint x=1,inv=pow(a[i],mod-2);\n\t\tfor(int j=1;j<=2*n-2;++j)\n\t\t{\t\n\t\t\tx=i+j>n?0:1LL*x*a[i+j-1]%mod;\n\t\t\tint sum=(res[i][j]+x)%mod;\n\t\t\tans[j]=(ans[j]+1LL*num[i]*sum)%mod;\n\t\t\tif(i<n) res[i+1][j+1]=(1LL*res[i+1][j+1]+res[i][j]+1LL*x*inv%mod*(a[i]-1))%mod;\n\t\t}\n\t\tif(i<n) res[i+1][1]=(res[i+1][1]+1)%mod;\n\t}\n\tfor(int i=1;i<=n*2-2;++i) printf(\"%d \",1LL*ans[i]*(mod+1)/2%mod);\n\treturn 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "combinatorics",
        "dp"
    ],
    "dificulty": "2500",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\H. Path Counting.json",
    "editorial_link": "https://codeforces.com//blog/entry/58519",
    "editorial": "At first when we read the problem, a simple solution comes to our mind,\r\ntake a look at the LCA (Lowest Common Ancestor) of that starting and\r\nending vertices of the path and then use combinatorics to calculate the\r\nnumber of the paths, but after trying to implement this or solve this on\r\npaper it doesnât seem to be easy at all and it may even be impossible to\r\nimplement this. So lets try to solve this problem in a different way.For\r\ncalculating the answer, we count the number of times each path starts or\r\nends at every vertex, and then divide them by to get the answer for each\r\nvertex.For calculating the answer to the above, it is easy to see that\r\nall vertices with the same height have the same number of paths going\r\nthrough them, so if we calculate the number of paths going through one\r\nof them and then multiply it by the number of the vertices in that\r\nheight (let it be ) it gets equal to our answer.We can calculate the\r\nanswer for a certain height. So to do that, we divide the paths into two\r\ntypes, paths that go only into the subtree of a vertex (letâs call it ),\r\nand paths that go up (letâs call it ).For the ones that are in the\r\nsubtree, it is easy to see if there are at least other vertices that go\r\ndown, we can go all paths going down (let the number of them be ), and\r\nthe answer for this part, equals to:For the ones that go up, we use\r\ndynamic-programming, and we define the number of paths that start at a\r\nvertex with height and have length and do not use the leftmost edge\r\nexiting the vertex at height . To update this either we go down on one\r\nof the paths and then we go through a path of length , or we go up and\r\nget a path of length starting at a vertex from height , so the answer\r\nfor this one equals to:Now .And the final complexity of the solution\r\nwill be , but because of the large constant of the solution the time\r\nlimit is higher.\r\n",
    "hint": []
}