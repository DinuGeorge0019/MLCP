{"link": "https://codeforces.com//contest/845/problem/E", "problemId": "119175", "problem_idx": "E", "shortId": "845E", "contest_number": "845", "problem_submissions": {"F": [29662191, 29658691, 29662577, 29662557, 29659271, 29663949, 29653306, 29665823, 29656869, 29668298], "E": [29659390, 29664188, 29664063, 29663215, 29663046, 29661461, 29660552, 29653793, 29658574, 29655087, 29668158, 29670073, 29664054, 35903704, 29673169, 29656703], "G": [29653058, 29648925, 29654997, 29656636, 29656923, 29653301, 29656155, 29657485, 29658552, 29655006, 29655066, 29653896, 29654510, 29655977, 29654363, 29657005, 29659307], "D": [29651798, 29653616, 29652569, 29653638, 29650642, 29655985, 29652243, 29654023, 29657108, 29650588, 29651844, 29650739, 29653419, 29656251, 29652823, 29652595, 29655002, 29652809, 29650646], "C": [29648829, 29651383, 29648358, 29648061, 29648669, 29648794, 29648303, 29648671, 29648937, 29648455, 29648984, 29648127, 29648921, 29649045, 29649074, 29650613, 29649296, 29649747, 29649146], "B": [29648130, 29650436, 29648956, 29647280, 29647747, 29647255, 29647572, 29647971, 29647530, 29648013, 29647504, 29647868, 29647800, 29648160, 29648934, 29648366, 29648191, 29646728], "A": [29647342, 29649692, 29646643, 29646523, 29646782, 29646497, 29646493, 29646476, 29646501, 29647201, 29646463, 29646669, 29646500, 29646893, 29647910, 29647098, 29646857, 29647624]}, "name": "E. Fire in the City", "statement": "The capital of Berland looks like a rectangle of size of the square\r\nblocks of same size.Fire!It is known that blocks got caught on fire ().\r\nThose blocks are centers of ignition. Moreover positions of of these\r\ncenters are known and one of these stays unknown. All positions are\r\ndistinct.The fire goes the following way: during the zero minute of fire\r\nonly these centers of ignition are burning. Every next minute the fire\r\ngoes to all neighbouring blocks to the one which is burning. You can\r\nconsider blocks to burn for so long that this time exceeds the time\r\ntaken in the problem. The neighbouring blocks are those that touch the\r\ncurrent block by a side or by a corner.Berland Fire Deparment wants to\r\nestimate the minimal time it takes the fire to lighten up the whole\r\ncity. Remember that the positions of blocks (centers of ignition) are\r\nknown and ()-th can be positioned in any other block.Help Berland Fire\r\nDepartment to estimate the minimal time it takes the fire to lighten up\r\nthe whole city.\r\n", "solutions": ["#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=505;\nint x[MAXN],y[MAXN];\nstruct Event\n{\n    int l,r,y,t;\n    bool operator < (const Event &rhs)const\n    {\n        return (y==rhs.y ? t>rhs.t : y<rhs.y);\n    }\n}e[MAXN<<1];\nint xx[MAXN<<4],cov[MAXN<<4];\nbool check(int n,int m,int k,int r)\n{\n    int mx[2],mi[2];\n    for(int _=0;_<2;_++)\n    {\n        int cnt=0;\n        xx[cnt++]=1;\n        xx[cnt++]=n;\n        for(int i=0;i<k;i++)\n        {\n            e[i<<1]=Event{max(1,x[i]-r),min(n,x[i]+r),max(1,y[i]-r),1};\n            e[i<<1|1]=Event{max(1,x[i]-r),min(n,x[i]+r),min(m+1,y[i]+r+1),-1};\n            xx[cnt++]=e[i<<1].l;\n            if(e[i<<1].l-1>=1)xx[cnt++]=e[i<<1].l-1;\n            if(e[i<<1].l+1<=n)xx[cnt++]=e[i<<1].l+1;\n            xx[cnt++]=e[i<<1].r;\n            if(e[i<<1].r-1>=1)xx[cnt++]=e[i<<1].r-1;\n            if(e[i<<1].r+1<=n)xx[cnt++]=e[i<<1].r+1;\n            xx[cnt++]=e[i<<1|1].l;\n            if(e[i<<1|1].l-1>=1)xx[cnt++]=e[i<<1|1].l-1;\n            if(e[i<<1|1].l+1<=n)xx[cnt++]=e[i<<1|1].l+1;\n            xx[cnt++]=e[i<<1|1].r;\n            if(e[i<<1|1].r-1>=1)xx[cnt++]=e[i<<1|1].r-1;\n            if(e[i<<1|1].r+1<=n)xx[cnt++]=e[i<<1|1].r+1;\n        }\n        sort(xx,xx+cnt);\n        cnt=unique(xx,xx+cnt)-xx;\n        for(int i=0;i<2*k;i++)\n        {\n            e[i].l=lower_bound(xx,xx+cnt,e[i].l)-xx;\n            e[i].r=lower_bound(xx,xx+cnt,e[i].r)-xx;\n        }\n        for(int i=0;i<cnt;i++)cov[i]=0;\n        sort(e,e+2*k);\n        mx[_]=xx[0],mi[_]=xx[cnt-1];\n        if(e[0].y>1)mx[_]=xx[cnt-1],mi[_]=xx[0];\n        for(int l=0,r=0;l<2*k && e[l].y<=m;l=r)\n        {\n            while(r<2*k && e[l].y==e[r].y)r++;\n            for(int i=l;i<r;i++)\n                for(int j=e[i].l;j<=e[i].r;j++)\n                    cov[j]+=e[i].t;\n            for(int i=0;i<cnt;i++)if(!cov[i])\n                mx[_]=max(mx[_],xx[i]),mi[_]=min(mi[_],xx[i]);\n        }\n        for(int i=0;i<k;i++)\n            swap(x[i],y[i]);\n        swap(n,m);\n    }\n    return mx[0]-mi[0]+1<=2*r+1 && mx[1]-mi[1]+1<=2*r+1;\n}\nint main()\n{\n    int n,m,k;\n    scanf(\"%d%d%d\",&n,&m,&k);\n    for(int i=0;i<k;i++)\n        scanf(\"%d%d\",&x[i],&y[i]);\n    int tl=0,tr=1000000000;\n    while(tl<tr)\n    {\n        int tm=(tl+tr)/2;\n        if(check(n,m,k,tm))tr=tm;\n        else tl=tm+1;\n    }\n    return 0*printf(\"%d\\n\",tl);\n}\n"], "input": "", "output": "", "tags": ["binary search", "data structures"], "dificulty": "2400", "interactive": false}