{
    "link": "https://codeforces.com//contest/1620/problem/D",
    "problemId": "1233291",
    "problem_idx": "D",
    "shortId": "1620D",
    "contest_number": "1620",
    "problem_submissions": {
        "G": [
            139834723,
            139834630,
            139800025,
            139798720,
            139797780,
            139795833,
            139793177,
            139797195,
            139801753,
            139800125,
            139798252,
            139806590,
            139801965,
            139799470,
            139800885,
            139815133,
            139836989,
            139836961,
            139803234,
            139783937,
            139766371,
            139781791,
            198626640,
            139785516,
            139791910,
            139794593,
            139799506,
            139797098,
            139802371,
            139794714
        ],
        "E": [
            139834170,
            139768900,
            139778404,
            139777262,
            139781401,
            139780307,
            180264469,
            139772320,
            139783598,
            139787731,
            139788776,
            139795635,
            139801166,
            139803161,
            139771172,
            139772982,
            139775572,
            139777494,
            139781749,
            139783689,
            139782938,
            139773708
        ],
        "D": [
            139828795,
            139828599,
            139828445,
            139801175,
            139773916,
            139773661,
            139775200,
            139772309,
            139777532,
            139778435,
            139852816,
            139778132,
            139769927,
            139780286,
            139786796,
            139790402,
            139791529,
            139805624,
            139765400,
            139770581,
            139781836,
            139766109,
            139779076,
            139774566,
            139785166
        ],
        "F": [
            139826678,
            139786211,
            139791869,
            139787814,
            139791341,
            139788904,
            139814807,
            139811473,
            139818294,
            139801200,
            139837073,
            139811622,
            139810717,
            139801430,
            139908478,
            139834808,
            139830354
        ],
        "B": [
            139800559,
            139758636,
            139759221,
            139759228,
            139768929,
            139762743,
            139760389,
            139791856,
            139762557,
            139759423,
            139779986,
            139793644,
            139810932,
            139757813,
            139761675,
            139760955,
            139759416,
            139760977,
            139759368,
            139760377
        ],
        "C": [
            139765159,
            139765932,
            139765302,
            139774145,
            139773181,
            207683198,
            139765484,
            139764863,
            139771290,
            139772950,
            139784482,
            139796217,
            139807967,
            139762141,
            139766772,
            139767896,
            139775442,
            139767619,
            139767081,
            139780353
        ],
        "A": [
            139756564,
            139756597,
            139756503,
            139756739,
            139759409,
            139756692,
            139757881,
            139756729,
            139756611,
            139777143,
            139792512,
            139812388,
            139756396,
            139756654,
            139757129,
            139756551,
            139756903,
            139756439,
            139756571
        ]
    },
    "name": "D. Exact Change",
    "statement": "One day, early in the morning, you decided to buy yourself a bag of\r\nchips in the nearby store. The store has chips of n different flavors. A\r\nbag of the i-th flavor costs a_i burles.The store may run out of some\r\nflavors, so you’ll decide which one to buy after arriving there. But\r\nthere are two major flaws in this plan: you have only coins of 1, 2 and\r\n3 burles; since it’s morning, the store will ask you to pay in exact\r\nchange, i. e. if you choose the i-th flavor, you’ll have to pay a_i\r\nburles. Coins are heavy, so you’d like to take the least possible number\r\nof coins in total. That’s why you are wondering: what is the minimum\r\ntotal number of coins you should take with you, so you can buy a bag of\r\nchips of any flavor in exact change?\r\n",
    "solutions": [
        "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <vector>\nusing namespace std;\n\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html\ntemplate<class Fun> class y_combinator_result {\n    Fun fun_;\npublic:\n    template<class T> explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}\n    template<class ...Args> decltype(auto) operator()(Args &&...args) { return fun_(std::ref(*this), std::forward<Args>(args)...); }\n};\ntemplate<class Fun> decltype(auto) y_combinator(Fun &&fun) { return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun)); }\n\n\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\ntemplate<typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type> ostream& operator<<(ostream &os, const T_container &v) { os << '{'; string sep; for (const T &x : v) os << sep << x, sep = \", \"; return os << '}'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\n\nconst int INF = int(1e9) + 5;\n\nvoid run_case() {\n    int N;\n    cin >> N;\n    vector<int> A(N);\n\n    for (auto &a : A)\n        cin >> a;\n\n    int best = INF;\n\n    for (int ones = 0; ones <= 1; ones++)\n        for (int twos = 0; ones + twos <= 2; twos++) {\n            int threes = 0;\n\n            for (int a : A) {\n                int least = INF;\n\n                for (int x = 0; x <= ones; x++)\n                    for (int y = 0; y <= twos; y++) {\n                        int need = a - x - 2 * y;\n\n                        if (need >= 0 && need % 3 == 0)\n                            least = min(least, need / 3);\n                    }\n\n                threes = max(threes, least);\n            }\n\n            best = min(best, ones + twos + threes);\n        }\n\n    cout << best << '\\n';\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int tests;\n    cin >> tests;\n\n    while (tests-- > 0)\n        run_case();\n}\n"
    ],
    "input": "",
    "output": "",
    "tags": [
        "brute force",
        "constructive algorithms",
        "greedy"
    ],
    "dificulty": "2000",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\D. Exact Change.json",
    "editorial_link": "https://codeforces.com//blog/entry/98061",
    "editorial": "Letâs define , then it should be obvious that we need at least coins to\r\nbuy a bag of chips of cost . Now, itâs not hard to prove that coins is\r\nalways enough to buy a bag of chips of any cost . Proof: if , weâll take\r\ncoins of value , coin and coin ; if , weâll take coins and two coins ;\r\nif , weâll take coins , one coin and two coins . So the question is how\r\nto decide, is coins enough. The solution is to note that there is no\r\nneed to take more than coins and more than coins , so we can just brute\r\nforce the number of coins weâll take and the number of coins weâll take\r\n. Then, the number of coins , and we can check: is it possible to pay\r\nexactly using at most , and coins respectively. There exists casework\r\nsolution as well, but itâs quite tricky, so brute force is preferable.\r\nThe main problem for case work is the case , since there are two\r\ndifferent ways to take coins: either coins and coin or coins and two\r\ncoins . In the first way, you canât gather exactly and in the second\r\none, you can gather neither nor .\r\n",
    "hint": []
}