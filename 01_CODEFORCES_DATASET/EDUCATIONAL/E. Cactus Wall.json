{
    "link": "https://codeforces.com//contest/1749/problem/E",
    "problemId": "1596426",
    "problem_idx": "E",
    "shortId": "1749E",
    "contest_number": "1749",
    "problem_submissions": {
        "F": [
            177196926,
            177193969,
            177197845,
            177198119,
            177206430,
            177210873,
            177199785,
            177210774,
            177202230,
            177192913,
            177192213,
            177200070,
            177205944,
            177170394,
            177182862,
            177215270,
            177215844,
            177215523,
            177215051
        ],
        "E": [
            177175453,
            177181859,
            177173202,
            177167666,
            177181787,
            177187486,
            177182981,
            177191658,
            177182011,
            177191907,
            177180248,
            177184144,
            177194645,
            177180352,
            177179743,
            177190262,
            177179802,
            177185905,
            177189289,
            177181499
        ],
        "D": [
            177160734,
            177165684,
            177163670,
            177160708,
            177168035,
            177167597,
            177159805,
            177163272,
            177173571,
            177176783,
            177165402,
            177190745,
            177201885,
            177169012,
            177171922,
            177163620,
            177167442,
            177171641,
            177173186,
            177176099
        ],
        "C": [
            177153350,
            177154933,
            177150750,
            177151409,
            177156559,
            177158501,
            177150569,
            177150769,
            177164991,
            177159801,
            177155722,
            177194758,
            177205203,
            177156409,
            177150026,
            177153467,
            177161017,
            177156613,
            177158578,
            177157179
        ],
        "B": [
            177148010,
            177147226,
            177145824,
            177144459,
            177148401,
            177151190,
            177144790,
            177144751,
            177149472,
            177152803,
            177150420,
            177196545,
            177209340,
            177148820,
            177144521,
            177146740,
            177154433,
            177150579,
            177148916,
            177150562
        ],
        "A": [
            177143584,
            177143989,
            177143613,
            177143436,
            177144016,
            177147398,
            177143479,
            177143419,
            177143476,
            177149821,
            177206375,
            177197200,
            177210312,
            177145598,
            177143407,
            177143819,
            177150081,
            177145044,
            177144026,
            177143706
        ]
    },
    "name": "E. Cactus Wall",
    "statement": "Monocarp is playing Minecraft and wants to build a wall of cacti. He\r\nwants to build it on a field of sand of the size of n\r\ntimes m cells. Initially, there are cacti in some cells of the field. .\r\nMonocarp can plant new cacti (they must also fulfil the aforementioned\r\ncondition). He can\u2019t chop down any of the cacti that are already growing\r\non the field he doesn\u2019t have an axe, and the cacti are too prickly for\r\nhis hands.Monocarp believes that the wall is complete if there is no\r\npath from the top row of the field to the bottom row, such that: each\r\ntwo consecutive cells in the path are adjacent by side; no cell\r\nbelonging to the path contains a cactus. Your task is to plant the\r\nminimum number of cacti to build a wall (or to report that this is\r\nimpossible).\r\n",
    "solutions": [
        "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define UNIQUE(a) (a).erase(unique((a).begin(),(a).end()),(a).end())\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T> using PQ = priority_queue<T>;\ntemplate<typename T> using QP = priority_queue<T,vector<T>,greater<T>>;\ntemplate<typename T1, typename T2>bool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>bool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>void ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T1,typename T2,typename T3>void anss(T1 x,T2 y,T3 z){ans(x!=y,x,z);};  \ntemplate<typename T>void debug(const T &v,ll h,ll w,string sv=\" \"){for(ll i=0;i<h;i++){cout<<v[i][0];for(ll j=1;j<w;j++)cout<<sv<<v[i][j];cout<<endl;}};\ntemplate<typename T>void debug(const T &v,ll n,string sv=\" \"){if(n!=0)cout<<v[0];for(ll i=1;i<n;i++)cout<<sv<<v[i];cout<<endl;};\ntemplate<typename T>void debug(const vector<T>&v){debug(v,v.size());}\ntemplate<typename T>void debug(const vector<vector<T>>&v){for(auto &vv:v)debug(vv,vv.size());}\ntemplate<typename T>void debug(stack<T> st){while(!st.empty()){cout<<st.top()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(queue<T> st){while(!st.empty()){cout<<st.front()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(deque<T> st){while(!st.empty()){cout<<st.front()<<\" \";st.pop_front();}cout<<endl;}\ntemplate<typename T>void debug(PQ<T> st){while(!st.empty()){cout<<st.top()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(QP<T> st){while(!st.empty()){cout<<st.top()<<\" \";st.pop();}cout<<endl;}\ntemplate<typename T>void debug(const set<T>&v){for(auto z:v)cout<<z<<\" \";cout<<endl;}\ntemplate<typename T>void debug(const multiset<T>&v){for(auto z:v)cout<<z<<\" \";cout<<endl;}\ntemplate<typename T,size_t size>void debug(const array<T, size> &a){for(auto z:a)cout<<z<<\" \";cout<<endl;}\ntemplate<typename T,typename V>void debug(const map<T,V>&v){for(auto z:v)cout<<\"[\"<<z.first<<\"]=\"<<z.second<<\",\";cout<<endl;}\ntemplate<typename T>vector<vector<T>>vec(ll x, ll y, T w){vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};vector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>vector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>auto make_v(size_t a,Ts... ts){return vector<decltype(make_v(ts...))>(a,make_v(ts...));}\ntemplate<typename T1, typename T2>ostream &operator<<(ostream &os, const pair<T1, T2>&p){return os << p.first << \" \" << p.second;}\ntemplate<typename T>ostream &operator<<(ostream &os, const vector<T> &v){for(auto &z:v)os << z << \" \";cout<<\"|\"; return os;}\ntemplate<typename T>void rearrange(vector<int>&ord, vector<T>&v){\n  auto tmp = v;\n  for(int i=0;i<tmp.size();i++)v[i] = tmp[ord[i]];\n}\ntemplate<typename Head, typename... Tail>void rearrange(vector<int>&ord,Head&& head, Tail&&... tail){\n  rearrange(ord, head);\n  rearrange(ord, tail...);\n}\ntemplate<typename T> vector<int> ascend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],i)<make_pair(v[j],j);});\n  return ord;\n}\ntemplate<typename T> vector<int> descend(const vector<T>&v){\n  vector<int>ord(v.size());iota(ord.begin(),ord.end(),0);\n  sort(ord.begin(),ord.end(),[&](int i,int j){return make_pair(v[i],-i)>make_pair(v[j],-j);});\n  return ord;\n}\ntemplate<typename T> vector<T> inv_perm(const vector<T>&ord){\n  vector<T>inv(ord.size());\n  for(int i=0;i<ord.size();i++)inv[ord[i]] = i;\n  return inv;\n}\nll FLOOR(ll n,ll div){assert(div>0);return n>=0?n/div:(n-div+1)/div;}\nll CEIL(ll n,ll div){assert(div>0);return n>=0?(n+div-1)/div:n/div;}\nll digitsum(ll n){ll ret=0;while(n){ret+=n%10;n/=10;}return ret;}\nll modulo(ll n,ll d){return (n%d+d)%d;};\ntemplate<typename T>T min(const vector<T>&v){return *min_element(v.begin(),v.end());}\ntemplate<typename T>T max(const vector<T>&v){return *max_element(v.begin(),v.end());}\ntemplate<typename T>T acc(const vector<T>&v){return accumulate(v.begin(),v.end(),T(0));};\ntemplate<typename T>T reverse(const T &v){return T(v.rbegin(),v.rend());};\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\nint popcount(ll x){return __builtin_popcountll(x);};\nint poplow(ll x){return __builtin_ctzll(x);};\nint pophigh(ll x){return 63 - __builtin_clzll(x);};\ntemplate<typename T>T poll(queue<T> &q){auto ret=q.front();q.pop();return ret;};\ntemplate<typename T>T poll(priority_queue<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(QP<T> &q){auto ret=q.top();q.pop();return ret;};\ntemplate<typename T>T poll(stack<T> &s){auto ret=s.top();s.pop();return ret;};\nll MULT(ll x,ll y){if(LLONG_MAX/x<=y)return LLONG_MAX;return x*y;}\nll POW2(ll x, ll k){ll ret=1,mul=x;while(k){if(mul==LLONG_MAX)return LLONG_MAX;if(k&1)ret=MULT(ret,mul);mul=MULT(mul,mul);k>>=1;}return ret;}\nll POW(ll x, ll k){ll ret=1;for(int i=0;i<k;i++){if(LLONG_MAX/x<=ret)return LLONG_MAX;ret*=x;}return ret;}\ntemplate< typename T = int >\nstruct edge {\n  int to;\n  T cost;\n  int id;\n  edge():id(-1){};\n  edge(int to, T cost = 1, int id = -1):to(to), cost(cost), id(id){}\n  operator int() const { return to; }\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\ntemplate<typename T>\nGraph<T>revgraph(const Graph<T> &g){\n  Graph<T>ret(g.size());\n  for(int i=0;i<g.size();i++){\n    for(auto e:g[i]){\n      int to = e.to;\n      e.to = i;\n      ret[to].push_back(e);\n    }\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readGraph(int n,int m,int indexed=1,bool directed=false,bool weighted=false){\n  Graph<T> ret(n);\n  for(int es = 0; es < m; es++){\n    int u,v;\n    T w=1;\n    cin>>u>>v;u-=indexed,v-=indexed;\n    if(weighted)cin>>w;\n    ret[u].emplace_back(v,w,es);\n    if(!directed)ret[v].emplace_back(u,w,es);\n  }\n  return ret;\n}\ntemplate<typename T>\nGraph<T> readParent(int n,int indexed=1,bool directed=true){\n  Graph<T>ret(n);\n  for(int i=1;i<n;i++){\n    int p;cin>>p;\n    p-=indexed;\n    ret[p].emplace_back(i);\n    if(!directed)ret[i].emplace_back(p);\n  }\n  return ret;\n}\nvector<int>from;\ntemplate<typename G>\nvector<ll> bfs01(G &g,const vector<int>&s){\n  from=vector<int>(g.size(),-1);\n  vector<ll>dist(g.size(),INF);\n  vector<bool>used(g.size());\n  deque<int>deq;\n  int n=g.size();\n  for(auto v:s){\n    deq.push_back(v);\n    dist[v]=0;\n  }\n  while(!deq.empty()){\n    int x=deq.front();\n    deq.pop_front();\n    if(used[x])continue;\n    used[x]=true;\n    for(auto e:g[x]){\n      if(dist[e.to]>dist[x]+e.cost){\n        dist[e.to]=dist[x]+e.cost;\n        from[e.to]=x;\n        if(e.cost==0)deq.push_front(e.to);\n        else deq.push_back(e.to);\n      }\n    }\n  }\n  return dist;\n}\ntemplate<typename G>\nvector<ll>bfs01(G &g,int s=0){\n  return bfs01(g,vector<int>(1,s));\n}\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll t;cin>>t;\n  while(t--){\n    ll h,w;cin>>h>>w;\n    vector<string>s(h);\n    rep(i,0,h)cin>>s[i];\n    Graph<int>g(h*w+2);\n    ll S=h*w,T=h*w+1;\n    auto ng=vec(h,w,false);\n    rep(i,0,h)rep(j,0,w){\n      rep(o,0,4){\n        int di=i+dx[o],dj=j+dy[o];\n        if(di<0||dj<0||di>=h||dj>=w)continue;\n        if(s[di][dj]=='#')ng[i][j]=true;\n      }\n    }\n    rep(i,0,h)rep(j,0,w){\n      if(ng[i][j])continue;\n      rep(o,4,8){\n        int di=i+dx[o],dj=j+dy[o];\n        if(di<0||dj<0||di>=h||dj>=w||ng[di][dj])continue;\n        g[i*w+j].EB(di*w+dj,s[di][dj]!='#');\n      }\n      if(j==0)g[S].EB(i*w+j,s[i][j]!='#');\n      if(j==w-1)g[i*w+j].EB(T,0);\n    }\n    auto d=bfs01(g,S);\n    if(d[T]==INF){\n      cout<<\"NO\"<<endl;\n    }\n    else{\n      cout<<\"YES\"<<endl;\n      ll now=T;\n      while(now!=S){\n        now=from[now];\n        if(now!=S){\n          s[now/w][now%w]='#';\n        }\n      }\n      rep(i,0,h)cout<<s[i]<<endl;\n    }\n  }\n  return 0;\n}"
    ],
    "input": "",
    "output": "",
    "tags": [
        "constructive algorithms",
        "dfs and similar",
        "graphs",
        "shortest paths"
    ],
    "dificulty": "2400",
    "interactive": false,
    "file_name": "D:\\scoala\\RESEARCH\\MLCP\\01_CODEFORCES_DATASET\\EDUCATIONAL\\E. Cactus Wall.json",
    "editorial_link": "https://codeforces.com//blog/entry/108269",
    "editorial": "In order to block any path from the top row to the bottom row, you have\r\nto build a path from the left side to the right side consisting of .\r\nSince two consecutive cacti in a path cannot be placed side by side,\r\nthey should be placed diagonally (i.e should be followed by on the\r\npath). So we can rephrase the task as a shortest path problem. The edge\r\nweight is if cactus is already in the cell that corresponds to the end\r\nof the edge, and otherwise. Don\u00e2\u0080\u0099t forget that some cells can\u00e2\u0080\u0099t contain a\r\ncactus, thus be part of a path, because of the cacti initially placed.\r\nThe shortest path can be found using Dijkstra\u00e2\u0080\u0099s or 0-1 BFS algorithm.\r\n"
}