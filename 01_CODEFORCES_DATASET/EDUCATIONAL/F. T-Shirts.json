{"link": "https://codeforces.com//contest/702/problem/F", "problemId": "66883", "problem_idx": "F", "shortId": "702F", "contest_number": "702", "problem_submissions": {"E": [19486872, 19487666, 19486777, 19488022, 19488501, 19486952, 19489405, 19490682, 19489522, 19488617, 19490923, 19486709, 19522484, 19490874, 19489785, 19489723, 19491945, 19490147, 19488259], "D": [19485847, 19522818, 19484850, 19484926, 19486392, 19486665, 19485668, 19486132, 19485860, 19486710, 19487180, 19486570, 19489538, 19522515, 19522418, 19486300, 19487524, 19487454, 19488567, 19487473, 19486660], "C": [19483715, 19483569, 19483475, 19484435, 19484197, 19484188, 19484516, 19484086, 19484332, 19484785, 19484582, 19484825, 19522492, 19484774, 19485083, 19485937, 19486251, 19485322, 19485133], "B": [19482582, 19482877, 19482445, 19483458, 19483246, 19482500, 19483149, 19482917, 19482947, 19483579, 19483004, 19483922, 19522499, 19483767, 19483896, 19483055, 19484158, 19483561, 19484180], "A": [19482266, 19482419, 19482207, 19482228, 19482294, 19482199, 19482499, 19482303, 19482312, 19482233, 19482288, 19482949, 19522504, 19482543, 19482505, 19484313, 19482461, 19482547, 19482286], "F": [127799040, 19527903, 19529247, 19529141, 19523290, 19514117, 19501229]}, "name": "F. T-Shirts", "statement": "The big consignment of t-shirts goes on sale in the shop before the\r\nbeginning of the spring. In all types of t-shirts go on sale. The\r\nt-shirt of the -th type has two integer parameters and , where is the\r\nprice of the -th type t-shirt, is the quality of the -th type t-shirt.\r\nIt should be assumed that the unlimited number of t-shirts of each type\r\ngoes on sale in the shop, but in general the quality is not concerned\r\nwith the price. As predicted, customers will come to the shop within the\r\nnext month, the -th customer will get ready to spend up to on buying\r\nt-shirts. All customers have the same strategy. First of all, the\r\ncustomer wants to buy the maximum possible number of the highest quality\r\nt-shirts, then to buy the maximum possible number of the highest quality\r\nt-shirts from residuary t-shirts and so on. At the same time among\r\nseveral same quality t-shirts the customer will buy one that is cheaper.\r\nThe customers don\u2019t like the same t-shirts, so each customer will not\r\nbuy more than one t-shirt of one type. Determine the number of t-shirts\r\nwhich each customer will buy, if they use the described strategy. All\r\ncustomers act independently from each other, and the purchase of one\r\ndoes not affect the purchase of another.\r\n", "solutions": ["#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef pair <int, int> ii;\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntypedef struct item * pitem;\nstruct item {\n    int prior, lft, ind;\n    int cnt;\n    int flaglft, flagcnt;\n    pitem l, r;\n    item(int val, int ind): prior(uniform_int_distribution<int>(1, 1000000000)(rng)), lft(val), ind(ind), cnt(0), flaglft(0), flagcnt(0), l(nullptr), r(nullptr) {}\n};\n \nvoid push(pitem it) {\n    if (it && (it->flaglft || it->flagcnt)) {\n        it->lft -= it->flaglft;\n        it->cnt += it->flagcnt;\n        if (it->l) {\n            it->l->flaglft += it->flaglft;\n            it->l->flagcnt += it->flagcnt;\n        }\n        if (it->r) {\n            it->r->flaglft += it->flaglft;\n            it->r->flagcnt += it->flagcnt;\n        }\n        it->flaglft = it->flagcnt = 0;\n    }\n}\n \nvoid merge (pitem & t, pitem l, pitem r) {\n    push (l);\n    push (r);\n    if (!l || !r)\n        t = l ? l : r;\n    else if (l->prior > r->prior)\n        merge (l->r, l->r, r),  t = l;\n    else\n        merge (r->l, l, r->l),  t = r;\n}\n\nint min(pitem it)\n{\n    push(it);\n    if (it->l) return min(it->l);\n    return it->lft;\n}\n\nint max(pitem it)\n{\n    push(it);\n    if (it->r) return max(it->r);\n    return it->lft;\n}\n \nvoid split (pitem t, int key, pitem & l, pitem & r) {\n    push(t);\n    if (!t)\n        l = r = NULL;\n    else if (key < t->lft)\n        split (t->l, key, l, t->l),  r = t;\n    else\n        split (t->r, key, t->r, r),  l = t;\n}\n\nvoid splitMin(pitem t, pitem &l, pitem &r) {\n    push(t);\n    if (t->l) splitMin(t->l, l, t->l), r = t;\n    else split(t->r, -1, t->r, r), l = t;\n}\n \nconst int Maxn = 200005;\n \nint n;\nii qc[Maxn];\nint k;\nii b[Maxn];\npitem root;\nint res[Maxn];\n \nvoid Print(pitem t)\n{\n    push(t);\n    if (!t) return;\n    Print(t->l);\n    res[t->ind] = t->cnt;\n    Print(t->r);\n}\n \nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &qc[i].second, &qc[i].first);\n        qc[i].first = -qc[i].first;\n    }\n    scanf(\"%d\", &k);\n    for (int i = 0; i < k; i++) {\n        scanf(\"%d\", &b[i].first);\n        b[i].second = i;\n    }\n    sort(b, b + k);\n    for (int i = 0; i < k; i++)\n        merge(root, root, new item(b[i].first, b[i].second));\n    Print(root);\n    sort(qc, qc + n);\n    for (int i = 0; i < n; i++) {\n        pitem lef, rig; split(root, qc[i].second - 1, lef, rig);\n        if (rig) {\n            rig->flaglft += qc[i].second;\n            rig->flagcnt++;\n        }\n        while (lef && rig && max(lef) > min(rig)) {\n            pitem it;\n            splitMin(rig, it, rig);\n            pitem A, B;\n            split(lef, it->lft, A, B);\n            merge(A, A, it);\n            merge(lef, A, B);\n        }\n        merge(root, lef, rig);\n    }\n    Print(root);\n    for (int i = 0; i < k; i++)\n        printf(\"%d%c\", res[i], i + 1 < k? ' ': '\\n');\n    return 0;\n}\n"], "input": "", "output": "", "tags": ["data structures"], "dificulty": "2800", "interactive": false}